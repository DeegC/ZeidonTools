; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\a\oe\KZHGENKY.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG10767 DB	01H DUP (?)
$SG10769 DB	01H DUP (?)
$SG10771 DB	01H DUP (?)
$SG10781 DB	01H DUP (?)
$SG10802 DB	01H DUP (?)
$SG10803 DB	01H DUP (?)
$SG10804 DB	01H DUP (?)
$SG10806 DB	01H DUP (?)
$SG10807 DB	01H DUP (?)
$SG10821 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG10768 DB	'==================================================', 00H
	ORG $+1
$SG10770 DB	'==================  Genkey Creation   ==============', 00H
	ORG $+3
$SG10772 DB	'==================================================', 00H
	ORG $+1
$SG10773 DB	'KZHGENKY Version 1.', 00H
$SG10774 DB	'Zeidon GKH', 00H
	ORG $+1
$SG10775 DB	'GENKEYWO', 00H
	ORG $+3
$SG10776 DB	'_GENKEYWO', 00H
	ORG $+2
$SG10777 DB	'Genkey', 00H
	ORG $+1
$SG10778 DB	'Genkey', 00H
	ORG $+1
$SG10779 DB	'TableName', 00H
	ORG $+2
$SG10780 DB	'Genkey', 00H
	ORG $+1
$SG10782 DB	'TableName', 00H
	ORG $+2
$SG10783 DB	'ZeidonGenkeyTable', 00H
	ORG $+2
$SG10785 DB	'ZeidonGenkeyTable', 00H
	ORG $+2
$SG10786 DB	'TableName', 00H
	ORG $+2
$SG10787 DB	'ZeidonGenkeyTable', 00H
	ORG $+2
$SG10788 DB	'CurrentGenkey', 00H
	ORG $+2
$SG10789 DB	'ZeidonGenkeyTable', 00H
	ORG $+2
$SG10790 DB	'CurrentGenkey', 00H
	ORG $+2
$SG10791 DB	'ZeidonGenkeyTable', 00H
	ORG $+2
$SG10792 DB	'CurrentGenkey', 00H
	ORG $+2
$SG10793 DB	'Genkey', 00H
	ORG $+1
$SG10794 DB	'EntityCount', 00H
$SG10795 DB	'Genkey', 00H
	ORG $+1
$SG10796 DB	'CurrentGenkey', 00H
	ORG $+2
$SG10797 DB	'ZeidonGenkeyTable', 00H
	ORG $+2
$SG10800 DB	'Zeidon GKH', 00H
	ORG $+1
$SG10805 DB	'============= End of Genkey Creation =============', 00H
	ORG $+1
$SG10822 DB	'EntityID', 00H
	ORG $+3
$SG10823 DB	'Genkey', 00H
	ORG $+1
$SG10825 DB	'lpViewEntity not found in KZGKHWOB', 00H
	ORG $+1
$SG10826 DB	'CurrentGenkey', 00H
	ORG $+2
$SG10827 DB	'Genkey', 00H
	ORG $+1
$SG10828 DB	'CurrentGenkey', 00H
	ORG $+2
$SG10829 DB	'Genkey', 00H
_DATA	ENDS
PUBLIC	_InitializeGenkeyObject
PUBLIC	_GetNextGenkey
PUBLIC	_GKH_MsgProc@20
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_IssueError@16:PROC
EXTRN	_ActivateObjectInstance@20:PROC
EXTRN	_CommitMultipleOIs@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_SetCursorFirstEntityByInteger@20:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_GetIntegerFromAttribute@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_AddToAttributeFromInteger@16:PROC
EXTRN	_SetAttributeFromAttribute@24:PROC
EXTRN	_GetTaskDBHandlerTraceLevel@4:PROC
EXTRN	_SysMutexLock@16:PROC
EXTRN	_SysMutexUnlock@12:PROC
EXTRN	_SysGetPointerFromHandle@4:PROC
EXTRN	_GetAddrForAttribute@16:PROC
EXTRN	_StoreValueInRecord@20:PROC
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhgenky.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_Message$ = 8						; size = 2
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_lpViewEntity$ = 20					; size = 4
_lpKZGKHWOB$ = 24					; size = 4
_GKH_MsgProc@20 PROC

; 58   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 59   :    zSHORT nRC;
; 60   : 
; 61   :    // Execute a function according to the message passed.
; 62   :    if ( Message == (Message | DBH_Init) )

	movzx	eax, WORD PTR _Message$[ebp]
	movzx	ecx, WORD PTR _Message$[ebp]
	or	ecx, 4096				; 00001000H
	cmp	eax, ecx
	jne	SHORT $LN2@GKH_MsgPro

; 63   :    {
; 64   :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 65   :    }

	jmp	$LN3@GKH_MsgPro
$LN2@GKH_MsgPro:

; 66   :    else
; 67   :    if ( Message == (Message | DBH_StartGenkey) )

	movzx	eax, WORD PTR _Message$[ebp]
	movzx	ecx, WORD PTR _Message$[ebp]
	or	ecx, 64					; 00000040H
	cmp	eax, ecx
	jne	SHORT $LN4@GKH_MsgPro

; 68   :    {
; 69   :       nRC = InitializeGenkeyObject( lpView, lpViewOD, lpKZGKHWOB );

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_InitializeGenkeyObject
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 70   :       if ( nRC == -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jne	SHORT $LN6@GKH_MsgPro

; 71   :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN6@GKH_MsgPro:

; 72   :    }

	jmp	SHORT $LN3@GKH_MsgPro
$LN4@GKH_MsgPro:

; 73   :    else
; 74   :    if ( Message == (Message | DBH_Rollback) )

	movzx	ecx, WORD PTR _Message$[ebp]
	movzx	edx, WORD PTR _Message$[ebp]
	or	edx, 4
	cmp	ecx, edx
	jne	SHORT $LN7@GKH_MsgPro

; 75   :    {
; 76   :       // We don't need to do anything here--the object was committed in
; 77   :       // DBH_StartGenkey.
; 78   :       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 79   :    }

	jmp	SHORT $LN3@GKH_MsgPro
$LN7@GKH_MsgPro:

; 80   :    else
; 81   :    if ( Message == (Message | DBH_Commit) )

	movzx	ecx, WORD PTR _Message$[ebp]
	movzx	edx, WORD PTR _Message$[ebp]
	or	edx, 2
	cmp	ecx, edx
	jne	SHORT $LN9@GKH_MsgPro

; 82   :    {
; 83   :       // We don't need to do anything here--the object was committed in
; 84   :       // DBH_StartGenkey.
; 85   :       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 86   :    }

	jmp	SHORT $LN3@GKH_MsgPro
$LN9@GKH_MsgPro:

; 87   :    else
; 88   :    if ( Message == (Message | DBH_GetGenkey) )

	movzx	ecx, WORD PTR _Message$[ebp]
	movzx	edx, WORD PTR _Message$[ebp]
	or	edx, 128				; 00000080H
	cmp	ecx, edx
	jne	SHORT $LN11@GKH_MsgPro

; 89   :    {
; 90   :       nRC = GetNextGenkey( lpView, lpViewEntity, lpKZGKHWOB );

	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_GetNextGenkey
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 91   :    }

	jmp	SHORT $LN3@GKH_MsgPro
$LN11@GKH_MsgPro:

; 92   :    else
; 93   :    if ( Message == (Message | DBH_Term) )

	movzx	eax, WORD PTR _Message$[ebp]
	movzx	ecx, WORD PTR _Message$[ebp]
	or	ecx, 8192				; 00002000H
	cmp	eax, ecx
	jne	SHORT $LN3@GKH_MsgPro

; 94   :    {
; 95   :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN3@GKH_MsgPro:

; 96   :    }
; 97   : 
; 98   :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 99   : } // KZHGENKY_GKH_MsgProc

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GKH_MsgProc@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhgenky.c
_TEXT	SEGMENT
_lpViewAttrib$ = -12					; size = 4
_lGenkey$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpKZGKHWOB$ = 16					; size = 4
_GetNextGenkey PROC

; 344  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 345  :    zSHORT       nRC;
; 346  :    zLONG        lGenkey;
; 347  :    LPVIEWATTRIB lpViewAttrib;
; 348  : 
; 349  :    nRC = SetCursorFirstEntityByInteger( lpKZGKHWOB, "Genkey", "EntityID",

	push	OFFSET $SG10821
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+195]
	push	ecx
	push	OFFSET $SG10822
	push	OFFSET $SG10823
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 350  :                                         lpViewEntity->lEREntTok, "" );
; 351  :    if ( nRC != zCURSOR_SET )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN4@GetNextGen

; 352  :    {
; 353  :       IssueError( lpView, 16, 16, "lpViewEntity not found in KZGKHWOB" );

	push	OFFSET $SG10825
	push	16					; 00000010H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_IssueError@16

; 354  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetNextGen
$LN4@GetNextGen:

; 355  :    }
; 356  : 
; 357  :    GetIntegerFromAttribute( &lGenkey, lpKZGKHWOB, "Genkey", "CurrentGenkey" );

	push	OFFSET $SG10826
	push	OFFSET $SG10827
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	lea	eax, DWORD PTR _lGenkey$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 358  :    lGenkey++;

	mov	ecx, DWORD PTR _lGenkey$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lGenkey$[ebp], ecx

; 359  :    SetAttributeFromInteger( lpKZGKHWOB, "Genkey", "CurrentGenkey", lGenkey );

	mov	edx, DWORD PTR _lGenkey$[ebp]
	push	edx
	push	OFFSET $SG10828
	push	OFFSET $SG10829
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 360  : 
; 361  :    // Find the genkey view attrib.
; 362  :    lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN2@GetNextGen:

; 363  :    while ( lpViewAttrib->bGenkey == FALSE )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN3@GetNextGen

; 364  :       lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN2@GetNextGen
$LN3@GetNextGen:

; 365  : 
; 366  :    // Copy the genkey to the entity.
; 367  :    StoreValueInRecord( lpView, lpViewEntity, lpViewAttrib,

	push	4
	lea	ecx, DWORD PTR _lGenkey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_StoreValueInRecord@20

; 368  :                        (zPVOID) &lGenkey, sizeof( lGenkey ) );
; 369  : 
; 370  :    return( 0 );

	xor	eax, eax
$LN1@GetNextGen:

; 371  : }  /* GetNextGenkey */

	mov	esp, ebp
	pop	ebp
	ret	0
_GetNextGenkey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhgenky.c
_TEXT	SEGMENT
_Cluster$1 = -32					; size = 8
_lLong$ = -24						; size = 4
_szTableName$ = -20					; size = 4
_lpGENKEYWO$ = -16					; size = 4
_nTraceLevel$ = -12					; size = 2
_nReturnCode$ = -8					; size = 2
_nRC$ = -4						; size = 2
_vSubtask$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpKZGKHWOB$ = 16					; size = 4
_InitializeGenkeyObject PROC

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 117  :    zPCHAR   szTableName;
; 118  :    zVIEW    lpGENKEYWO;
; 119  :    zLONG    lLong;
; 120  :    zSHORT   nTraceLevel;
; 121  :    zSHORT   nReturnCode;
; 122  :    zSHORT   nRC;
; 123  : 
; 124  :    nReturnCode = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnCode$[ebp], ax

; 125  :    nTraceLevel = GetTaskDBHandlerTraceLevel( vSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_GetTaskDBHandlerTraceLevel@4
	mov	WORD PTR _nTraceLevel$[ebp], ax

; 126  :    if ( nTraceLevel > 0 )

	movsx	edx, WORD PTR _nTraceLevel$[ebp]
	test	edx, edx
	jle	SHORT $LN5@Initialize

; 127  :    {
; 128  :       TraceLineS( "==================================================", "" );

	push	OFFSET $SG10767
	push	OFFSET $SG10768
	call	_TraceLineS@8

; 129  :       TraceLineS( "==================  Genkey Creation   ==============", "" );

	push	OFFSET $SG10769
	push	OFFSET $SG10770
	call	_TraceLineS@8

; 130  :       TraceLineS( "==================================================", "" );

	push	OFFSET $SG10771
	push	OFFSET $SG10772
	call	_TraceLineS@8

; 131  :       TraceLineI( "KZHGENKY Version 1.", (zLONG) KZHGENKY_Version );

	push	26					; 0000001aH
	push	OFFSET $SG10773
	call	_TraceLineI@8
$LN5@Initialize:

; 132  :    }
; 133  : 
; 134  : #ifdef DATABASE_LOCK
; 135  : 
; 136  :    nRC = ActivateEmptyObjectInstance( &lpGENKEYWO, "GENKEYWO", vSubtask,
; 137  :                                       zMULTIPLE );
; 138  :    if ( nRC )
; 139  :    {
; 140  :       IssueError( vSubtask, 16, 16, "Error activating GENKEYWO object." );
; 141  :       if ( nTraceLevel > 0 )
; 142  :       {
; 143  :          TraceLineS( "", "" );
; 144  :          TraceLineS( "============= End of Genkey Creation =============", "" );
; 145  :          TraceLineS( "", "" );
; 146  :       }
; 147  : 
; 148  :       return( zCALL_ERROR );
; 149  :    }
; 150  : 
; 151  :    SetNameForView( lpGENKEYWO, "_GENKEYWO", 0, zLEVEL_TASK );
; 152  : 
; 153  :    // Create enqueue entity.
; 154  :    nRC = CreateEntity( lpGENKEYWO, "ZeidonGenkeyTable", zPOS_FIRST );
; 155  :    if ( nRC )
; 156  :    {
; 157  :       DropView( lpGENKEYWO );
; 158  :       return( zCALL_ERROR );
; 159  :    }
; 160  : 
; 161  :    nRC = SetAttributeFromString( lpGENKEYWO, "ZeidonGenkeyTable", "TableName",
; 162  :                                  "..ENQ KZHGENKY" );
; 163  :    if ( nRC )
; 164  :    {
; 165  :       DropView( lpGENKEYWO );
; 166  :       return( zCALL_ERROR );
; 167  :    }
; 168  : 
; 169  :    nRC = SetAttributeFromInteger( lpGENKEYWO, "ZeidonGenkeyTable",
; 170  :                                   "CurrentGenkey", 999 );
; 171  :    if ( nRC )
; 172  :    {
; 173  :       DropView( lpGENKEYWO );
; 174  :       return( zCALL_ERROR );
; 175  :    }
; 176  : 
; 177  :    // Try to commit the OI with the locking entity.  If it succeeds, then
; 178  :    // nobody else is currently using the GenKey database object.  The
; 179  :    // creation of the entity keeps other processes from using the GenKey
; 180  :    // object until we are done with it.  If the Commit fails, then someone
; 181  :    // else is currently using the GenKey datbase object.
; 182  : #if 0
; 183  :    nRC = CommitMultipleOIs( &lpGENKEYWO, 1, 0, zCOMMIT_FORCETRAN );
; 184  : #else
; 185  :    nRC = CommitObjectInstance( lpGENKEYWO );
; 186  : #endif
; 187  :    // Whether the commit succeeded or not, we don't need the OI anymore.
; 188  :    DropView( lpGENKEYWO );
; 189  :    if ( nRC )
; 190  :    {
; 191  :       IssueError( vSubtask, 16, 16,
; 192  :          "Error writing ENQ entity - Check ZeidonGenkeyTable" );
; 193  : 
; 194  :       if ( nTraceLevel > 0 )
; 195  :       {
; 196  :          TraceLineS( "", "" );
; 197  :          TraceLineS( "============= End of Genkey Creation =============", "" );
; 198  :          TraceLineS( "", "" );
; 199  :       }
; 200  : 
; 201  :       return( zCALL_ERROR );
; 202  :    }
; 203  : 
; 204  : #else  // DATABASE_LOCK
; 205  : 
; 206  :    // Lock a mutex.
; 207  :    SysMutexLock( vSubtask, "Zeidon GKH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG10774
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysMutexLock@16

; 208  : 
; 209  : #endif // DATABASE_LOCK else...
; 210  : 
; 211  :    // Now retrieve all GenKey objects from the database.
; 212  :    nRC = ActivateObjectInstance( &lpGENKEYWO, "GENKEYWO", vSubtask, 0,

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	OFFSET $SG10775
	lea	edx, DWORD PTR _lpGENKEYWO$[ebp]
	push	edx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _nRC$[ebp], ax

; 213  :                                  zMULTIPLE );
; 214  :    SetNameForView( lpGENKEYWO, "_GENKEYWO", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET $SG10776
	mov	eax, DWORD PTR _lpGENKEYWO$[ebp]
	push	eax
	call	_SetNameForView@16

; 215  : 
; 216  : #if 0
; 217  :    // A hack...Loop through all the entities and delete any trailing spaces
; 218  :    // from the entity names.  Note that because we get a pointer to the
; 219  :    // entity name and then use that to change the string the entity does not
; 220  :    // get flagged as updated.
; 221  :    for ( nRC = SetCursorFirstEntity( lpGENKEYWO, "ZeidonGenkeyTable", 0 );
; 222  :          nRC == zCURSOR_SET;
; 223  :          nRC = SetCursorNextEntity( lpGENKEYWO, "ZeidonGenkeyTable", 0 ) )
; 224  :    {
; 225  :       zSHORT k;
; 226  : 
; 227  :       GetAddrForAttribute( &szTableName, lpGENKEYWO, "ZeidonGenkeyTable",
; 228  :                            "TableName" );
; 229  :       k = zstrlen( szTableName ) - 1;
; 230  :       while ( szTableName[ k ] == ' ' )
; 231  :          szTableName[ k-- ] = 0;
; 232  :    }
; 233  : #endif
; 234  : 
; 235  :    // Now loop through the OI containing the names of entities that need
; 236  :    // genkeys.  For each one, find the entity in the GenKey list that has
; 237  :    // the same name and get the current GenKey value.
; 238  :    for ( nRC = SetCursorFirstEntity( lpKZGKHWOB, "Genkey", 0 );

	push	0
	push	OFFSET $SG10777
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@Initialize
$LN2@Initialize:

; 240  :          nRC = SetCursorNextEntity( lpKZGKHWOB, "Genkey", 0 ) )

	push	0
	push	OFFSET $SG10778
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@Initialize:

; 239  :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN3@Initialize

; 241  :    {
; 242  :       // Get name of user entity that needs a genkey.
; 243  :       GetAddrForAttribute( &szTableName, lpKZGKHWOB, "Genkey", "TableName" );

	push	OFFSET $SG10779
	push	OFFSET $SG10780
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 244  : 
; 245  :       // Find the entity in the genkey list that has the same name as the
; 246  :       // user's entity.
; 247  :       nRC = SetCursorFirstEntityByString( lpGENKEYWO, "ZeidonGenkeyTable",

	push	OFFSET $SG10781
	mov	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	OFFSET $SG10782
	push	OFFSET $SG10783
	mov	ecx, DWORD PTR _lpGENKEYWO$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax

; 248  :                                           "TableName", szTableName, "" );
; 249  : 
; 250  :       // If the entity wasn't found, then this is the first time a genkey has
; 251  :       // been requested for this entity.  Create the entity in the GenKey
; 252  :       // list and initialize any values.
; 253  :       if ( nRC != zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN6@Initialize

; 254  :       {
; 255  :          CreateEntity( lpGENKEYWO, "ZeidonGenkeyTable", zPOS_FIRST );

	push	1
	push	OFFSET $SG10785
	mov	eax, DWORD PTR _lpGENKEYWO$[ebp]
	push	eax
	call	_CreateEntity@12

; 256  :          SetAttributeFromString( lpGENKEYWO, "ZeidonGenkeyTable",

	mov	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	push	OFFSET $SG10786
	push	OFFSET $SG10787
	mov	edx, DWORD PTR _lpGENKEYWO$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 257  :                                  "TableName", szTableName );
; 258  :          SetAttributeFromInteger( lpGENKEYWO, "ZeidonGenkeyTable",

	push	0
	push	OFFSET $SG10788
	push	OFFSET $SG10789
	mov	eax, DWORD PTR _lpGENKEYWO$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16
$LN6@Initialize:

; 259  :                                  "CurrentGenkey", 0 );
; 260  :       }
; 261  : 
; 262  :       // Copy the GenKey value from the GenKey list to the GenKey handler
; 263  :       // work object.  This is how the value is passed back to CommitObj....
; 264  :       SetAttributeFromAttribute( lpKZGKHWOB, "Genkey", "CurrentGenkey",

	push	OFFSET $SG10790
	push	OFFSET $SG10791
	mov	ecx, DWORD PTR _lpGENKEYWO$[ebp]
	push	ecx
	push	OFFSET $SG10792
	push	OFFSET $SG10793
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 265  :                                  lpGENKEYWO, "ZeidonGenkeyTable",
; 266  :                                  "CurrentGenkey" );
; 267  : 
; 268  :       // Retrieve the count of entity instances that need genkeys and add it
; 269  :       // to the current value in the genkey list.
; 270  :       GetIntegerFromAttribute( &lLong, lpKZGKHWOB, "Genkey", "EntityCount" );

	push	OFFSET $SG10794
	push	OFFSET $SG10795
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lLong$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 271  :       nRC = AddToAttributeFromInteger( lpGENKEYWO, "ZeidonGenkeyTable",

	mov	edx, DWORD PTR _lLong$[ebp]
	push	edx
	push	OFFSET $SG10796
	push	OFFSET $SG10797
	mov	eax, DWORD PTR _lpGENKEYWO$[ebp]
	push	eax
	call	_AddToAttributeFromInteger@16
	mov	WORD PTR _nRC$[ebp], ax

; 272  :                                        "CurrentGenkey", lLong );
; 273  :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@Initialize

; 274  :       {
; 275  :          nReturnCode = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], dx

; 276  :          break;

	jmp	SHORT $LN3@Initialize
$LN7@Initialize:

; 277  :       }
; 278  :    }

	jmp	$LN2@Initialize
$LN3@Initialize:

; 279  : 
; 280  : #ifdef DATABASE_LOCK
; 281  : 
; 282  :    // Delete Enqueue entity from Genkey OI.
; 283  :    nRC = SetCursorFirstEntityByString( lpGENKEYWO, "ZeidonGenkeyTable",
; 284  :                                        "TableName", "..ENQ KZHGENKY", "" );
; 285  :    if ( nRC != zCURSOR_SET )
; 286  :    {
; 287  :       IssueError( vSubtask, 16, 16, "Error - can't find ..ENQ entity" );
; 288  :       nReturnCode = zCALL_ERROR;
; 289  :    }
; 290  :    else
; 291  :       DeleteEntity( lpGENKEYWO, "ZeidonGenkeyTable", zREPOS_AFTER );
; 292  : 
; 293  : #endif
; 294  : 
; 295  :    // Commit the GenKey list.  This will delete the enqueue entity from the
; 296  :    // database to allow other processes to create genkeys and will also
; 297  :    // create any entities that have had genkeys requested for the first time.
; 298  : #if 1 // DGC 99.07.02
; 299  :    {
; 300  :       ViewClusterRecord Cluster;
; 301  : 
; 302  :       Cluster.vOI      = lpGENKEYWO;

	mov	eax, DWORD PTR _lpGENKEYWO$[ebp]
	mov	DWORD PTR _Cluster$1[ebp], eax

; 303  :       Cluster.lControl = 0;

	mov	DWORD PTR _Cluster$1[ebp+4], 0

; 304  : 
; 305  :       nRC = CommitMultipleOIs( &Cluster, 1, 0, zCOMMIT_FORCETRAN );

	push	1024					; 00000400H
	push	0
	push	1
	lea	ecx, DWORD PTR _Cluster$1[ebp]
	push	ecx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 306  :    }
; 307  : #else
; 308  :    nRC = CommitObjectInstance( lpGENKEYWO );
; 309  : #endif
; 310  :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN8@Initialize

; 311  :       nReturnCode = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], ax
$LN8@Initialize:

; 312  : 
; 313  : #ifndef DATABASE_LOCK
; 314  : 
; 315  :    SysMutexUnlock( vSubtask, "Zeidon GKH", 0 );

	push	0
	push	OFFSET $SG10800
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysMutexUnlock@12

; 316  : 
; 317  : #endif
; 318  : 
; 319  :    if ( nTraceLevel > 0 )

	movsx	edx, WORD PTR _nTraceLevel$[ebp]
	test	edx, edx
	jle	SHORT $LN9@Initialize

; 320  :    {
; 321  :       TraceLineS( "", "" );

	push	OFFSET $SG10802
	push	OFFSET $SG10803
	call	_TraceLineS@8

; 322  :       TraceLineS( "============= End of Genkey Creation =============", "" );

	push	OFFSET $SG10804
	push	OFFSET $SG10805
	call	_TraceLineS@8

; 323  :       TraceLineS( "", "" );

	push	OFFSET $SG10806
	push	OFFSET $SG10807
	call	_TraceLineS@8
$LN9@Initialize:

; 324  :    }
; 325  : 
; 326  :    DropView( lpGENKEYWO );

	mov	eax, DWORD PTR _lpGENKEYWO$[ebp]
	push	eax
	call	_DropView@4

; 327  : 
; 328  :    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]

; 329  : }  /* InitializeGenkeyObject */

	mov	esp, ebp
	pop	ebp
	ret	0
_InitializeGenkeyObject ENDP
_TEXT	ENDS
END
