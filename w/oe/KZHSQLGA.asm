; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\a\oe\KZHSQLGA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG13347 DB	01H DUP (?)
$SG13569 DB	01H DUP (?)
$SG13570 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_BoundAttrListRecord:BYTE:01aH
_DATA	ENDS
_BSS	SEGMENT
$SG13260 DB	01H DUP (?)
$SG13261 DB	01H DUP (?)
$SG13284 DB	01H DUP (?)
$SG13286 DB	01H DUP (?)
$SG13288 DB	01H DUP (?)
$SG13289 DB	01H DUP (?)
$SG13290 DB	01H DUP (?)
$SG13295 DB	01H DUP (?)
$SG13297 DB	01H DUP (?)
$SG13301 DB	01H DUP (?)
$SG13303 DB	01H DUP (?)
$SG13306 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG13341 DB	'Warning', 00H
$SG12317 DB	'UPDATE ', 00H
$SG13342 DB	'Error', 00H
	ORG $+2
$SG13343 DB	'%s loading qualification object while activating LOD %s:'
	DB	' %s', 00H
$SG13344 DB	'Qualification Object Warning', 00H
	ORG $+3
$SG13345 DB	'Qualification Object Error', 00H
	ORG $+1
$SG13346 DB	'KZH0201', 00H
$SG12323 DB	' SET ', 00H
	ORG $+2
$SG12324 DB	' = ', 00H
$SG12325 DB	' WHERE ( ', 00H
	ORG $+2
$SG12326 DB	' = ', 00H
$SG12328 DB	' AND ', 00H
	ORG $+2
$SG12329 DB	' )', 00H
	ORG $+1
$SG12348 DB	'DELETE FROM ', 00H
	ORG $+3
$SG12349 DB	' ', 00H
	ORG $+2
_szlEntitySpec DB 'EntitySpec', 00H
	ORG $+1
_szlQualAttrib DB 'QualAttrib', 00H
	ORG $+1
_szlSubQualAttrib DB 'SubQualAttrib', 00H
	ORG $+2
$SG12368 DB	'DELETE FROM ', 00H
	ORG $+3
$SG12369 DB	' ', 00H
	ORG $+2
$SG13407 DB	'Cannot allocate memory.', 00H
$SG13410 DB	'Cannot allocate memory.', 00H
$SG12394 DB	'DELETE FROM ', 00H
	ORG $+3
$SG12397 DB	' AND ', 00H
	ORG $+2
$SG12398 DB	' = ', 00H
$SG13432 DB	')', 00H
	ORG $+2
$SG13433 DB	'AND', 00H
$SG13434 DB	'IS NOT NULL', 00H
$SG13435 DB	'(', 00H
	ORG $+2
$SG12482 DB	' ( ', 00H
$SG12488 DB	' AND ', 00H
	ORG $+2
$SG12489 DB	'.', 00H
	ORG $+2
$SG12490 DB	' = ', 00H
$SG12493 DB	'.', 00H
	ORG $+2
$SG12497 DB	'.', 00H
	ORG $+2
$SG12502 DB	' AND ', 00H
	ORG $+2
$SG12503 DB	'.', 00H
	ORG $+2
$SG12504 DB	' = ', 00H
$SG12507 DB	'.', 00H
	ORG $+2
$SG12512 DB	' AND ', 00H
	ORG $+2
$SG12513 DB	'.', 00H
	ORG $+2
$SG12514 DB	' = ', 00H
$SG12521 DB	'(#11) View OD Name = ', 00H
	ORG $+2
$SG12522 DB	'(#11) Building foreign keys for entity', 00H
	ORG $+1
$SG12523 DB	'(#11) RelViewAttrib = ', 00H
	ORG $+1
$SG12524 DB	'Internal error #11--can''t find RelRecord', 00H
	ORG $+3
$SG12525 DB	'Zeidon SQL Generator Error', 00H
	ORG $+1
$SG12529 DB	'.', 00H
	ORG $+2
$SG12530 DB	' )', 00H
	ORG $+1
$SG13572 DB	'Cannot allocate memory', 00H
	ORG $+1
$SG13573 DB	'Oper', 00H
	ORG $+3
$SG13580 DB	'OR', 00H
	ORG $+1
$SG13575 DB	'QualAttrib does not have an operation defined.  Oper is '
	DB	'a required attribute.', 00H
	ORG $+2
$SG13581 DB	'EntityName', 00H
	ORG $+1
$SG13585 DB	'*root*', 00H
	ORG $+1
$SG13586 DB	'*root*', 00H
	ORG $+1
$SG12562 DB	' AND ', 00H
	ORG $+2
$SG13587 DB	'*root*', 00H
	ORG $+1
$SG13605 DB	'Internal error #10--can''t find RelRecord', 00H
	ORG $+3
$SG13589 DB	'Entity ''%s'' was specified in the Qualification object '
	DB	'but does not exist in LOD ''%s''', 00H
	ORG $+3
$SG13592 DB	'Entity ''%s'' in Object ''%s'' is a work or derived enti'
	DB	'ty and is not allowed for entity qualification during an Acti'
	DB	'vate', 00H
	ORG $+2
$SG13594 DB	'You cannot qualify entity ''%s'' using entity ''%s'' in '
	DB	'Object Definition ''%s''.  Only child entities may be used fo'
	DB	'r qualification.', 00H
$SG13596 DB	'AttributeName', 00H
	ORG $+2
$SG13599 DB	'QualAttrib entity has AttributeName but doesn''t have En'
	DB	'tityName.', 00H
	ORG $+3
$SG11557 DB	' FROM ', 00H
	ORG $+1
$SG11561 DB	' WHERE ( ', 00H
	ORG $+2
$SG13602 DB	'AttributeName in QualAttrib not found in in target objec'
	DB	't definition.', 00H
	ORG $+2
$SG13608 DB	'Value', 00H
	ORG $+2
$SG11562 DB	' )', 00H
	ORG $+1
$SG13611 DB	'QualAttrib entity has Value but doesn''t have AttributeN'
	DB	'ame.', 00H
$SG11563 DB	' WHERE ', 00H
$SG12588 DB	' ( SELECT ', 00H
	ORG $+1
$SG13615 DB	'QualAttrib Value invalid for DateTime.', 00H
	ORG $+1
$SG12591 DB	' FROM ', 00H
	ORG $+1
$SG12592 DB	' WHERE ', 00H
$SG13617 DB	'Cannot allocate memory.', 00H
$SG12594 DB	' ( ', 00H
$SG13619 DB	'KeyList', 00H
$SG12596 DB	' ) ', 00H
$SG13621 DB	'Cannot specify ''Value'' and ''KeyList'' on the same Qua'
	DB	'lAttrib.', 00H
	ORG $+3
$SG12597 DB	' )', 00H
	ORG $+1
$SG13623 DB	'QualAttrib entity has KeyList but doesn''t have Attribut'
	DB	'eName.', 00H
	ORG $+2
$SG13625 DB	'The only datatypes supported with KeyList is Integer.', 00H
	ORG $+2
$SG13627 DB	'Only one QualAttrib is allowed to have a KeyList specifi'
	DB	'ed under each QualEntity.', 00H
	ORG $+2
$SG13628 DB	'KeyList', 00H
$SG13629 DB	'KeyList', 00H
$SG13630 DB	'KeyList', 00H
$SG13631 DB	'IntegerValue', 00H
	ORG $+3
$SG13632 DB	'KeyList', 00H
$SG13633 DB	'SourceViewName', 00H
	ORG $+1
$SG13638 DB	'SourceViewID', 00H
	ORG $+3
$SG13639 DB	'SourceViewName not found at TASK level.', 00H
$SG13640 DB	'SourceViewID', 00H
	ORG $+3
$SG13642 DB	'SourceEntityName', 00H
	ORG $+3
$SG13647 DB	'Attribute SourceEntityName not found in target object de'
	DB	'fintion.', 00H
	ORG $+3
$SG12623 DB	' AND ', 00H
	ORG $+2
$SG12624 DB	'.', 00H
	ORG $+2
$SG12625 DB	' = ', 00H
$SG13654 DB	'SourceAttributeName', 00H
$SG13651 DB	'Cursor is not set properly in the Source View specified '
	DB	'in QualAttrib.', 00H
	ORG $+1
$SG13653 DB	'SourceEntityName does not have hierarchical precidence o'
	DB	'ver EntityName in EntitySpec.', 00H
	ORG $+2
$SG13657 DB	'QualAttrib has SourceAttributeName but doesn''t have Sou'
	DB	'rceEntityName.', 00H
	ORG $+2
$SG13660 DB	'SourceAttributeName in QualAttrib not found in target ob'
	DB	'ject definition.', 00H
	ORG $+3
$SG11612 DB	' AS', 00H
$SG13664 DB	'EXISTS', 00H
	ORG $+1
$SG13665 DB	'NOT EXISTS', 00H
	ORG $+1
$SG13667 DB	'QualAttrib must specify EntityName for [NOT] EXISTS oper'
	DB	'ation.', 00H
	ORG $+1
$SG13679 DB	')', 00H
	ORG $+2
$SG13669 DB	'QualAttrib.EntityName must be a direct descendant of Ent'
	DB	'itySpec.EntityName for the [NOT] EXISTS operation.', 00H
	ORG $+1
$SG13683 DB	'AND', 00H
$SG13672 DB	'Extraneous attributes specified for [NOT] EXISTS operati'
	DB	'on.  Only Oper and EntityName are needed.  All others will be'
	DB	' ignored.', 00H
	ORG $+1
$SG13675 DB	'EXISTS', 00H
	ORG $+1
$SG13685 DB	'IS NOT NULL', 00H
$SG13686 DB	'IS NULL', 00H
$SG13688 DB	'(', 00H
	ORG $+2
$SG13692 DB	'IS', 00H
	ORG $+1
$SG13694 DB	'QualAttrib must have EntityName for IS operation.', 00H
	ORG $+2
$SG13696 DB	'QualAttrib must have SourceEntityName for IS operation.', 00H
$SG13698 DB	'QualAttrib must have SourceView for IS operation.', 00H
	ORG $+2
$SG12684 DB	' AND ( ', 00H
$SG12685 DB	'( ', 00H
	ORG $+1
$SG13701 DB	'Extraneous attributes specified for IS operation.  Only '
	DB	'Oper, EntityName, SourceEntityName, and SourceView are needed'
	DB	'.  All others will be ignored.', 00H
$SG13704 DB	'LIKE', 00H
	ORG $+3
$SG13706 DB	'QualAttrib must have Entity.AttributeName for LIKE opera'
	DB	'tion.', 00H
	ORG $+2
$SG12687 DB	' ', 00H
	ORG $+2
$SG13708 DB	'Entity.AttributeName for QualAttrib must be a string for'
	DB	' the LIKE operation.', 00H
	ORG $+3
$SG13712 DB	'=', 00H
	ORG $+2
$SG12688 DB	' ', 00H
	ORG $+2
$SG13713 DB	'=', 00H
	ORG $+2
$SG13714 DB	'=', 00H
	ORG $+2
$SG13715 DB	'IS NULL', 00H
$SG13718 DB	'<> !=', 00H
	ORG $+2
$SG13719 DB	'IS NOT NULL', 00H
$SG13721 DB	'<= =< >= =>', 00H
$SG13722 DB	'QualAttrib has AttributeName but does not have Value or '
	DB	'SourceAttributeName, which are needed for the following compa'
	DB	'rison opererators: ''<'', ''<='', ''>'', and''>=''.', 00H
	ORG $+3
$SG12698 DB	'.', 00H
	ORG $+2
$SG12699 DB	' IN ( SELECT INTVALUE FROM ZEIDONKEYLIST WHERE TASKID = '
	DB	'%ld ) ', 00H
	ORG $+1
$SG13725 DB	'IS NULL', 00H
$SG12702 DB	'UPPER', 00H
	ORG $+2
$SG12703 DB	'( ', 00H
	ORG $+1
$SG12704 DB	'.', 00H
	ORG $+2
$SG13728 DB	'QualAttrib has Value or SourceAttributeName but does not'
	DB	' have AttributeName.', 00H
	ORG $+3
$SG12706 DB	' )', 00H
	ORG $+1
$SG13731 DB	'=', 00H
	ORG $+2
$SG12707 DB	' ', 00H
	ORG $+2
$SG13732 DB	'=', 00H
	ORG $+2
$SG13733 DB	'=', 00H
	ORG $+2
$SG13736 DB	'Internal error setting view to Subobject.', 00H
	ORG $+2
$SG12717 DB	' IS NOT ', 00H
	ORG $+3
$SG12718 DB	'<>', 00H
	ORG $+1
$SG12721 DB	' IS ', 00H
	ORG $+3
$SG11700 DB	'Too many tables in SQL cmd', 00H
	ORG $+1
$SG11701 DB	'Internal Core Error', 00H
$SG12726 DB	' ', 00H
	ORG $+2
$SG13752 DB	'EXISTS', 00H
	ORG $+1
$SG12729 DB	' ', 00H
	ORG $+2
$SG12730 DB	' )', 00H
	ORG $+1
$SG11710 DB	' LEFT JOIN ', 00H
$SG13759 DB	'The QualAttrib used to qualify EntitySpec causes two tab'
	DB	'les from different databases to be joined.  This is invalid.', 00H
	ORG $+3
$SG11711 DB	', ', 00H
	ORG $+1
$SG13761 DB	'Parens for all QualAttrib.Oper under EntitySpec do not m'
	DB	'atch.', 00H
	ORG $+2
$SG11714 DB	' ON ', 00H
	ORG $+3
$SG11718 DB	' AND ', 00H
	ORG $+2
$SG11719 DB	'.', 00H
	ORG $+2
$SG11720 DB	' = ', 00H
$SG11721 DB	'.', 00H
	ORG $+2
$SG11722 DB	' ) ', 00H
$SG11726 DB	' LEFT JOIN ', 00H
$SG11727 DB	', ', 00H
	ORG $+1
$SG11731 DB	' ON ', 00H
	ORG $+3
$SG11736 DB	' AND ', 00H
	ORG $+2
$SG11737 DB	'.', 00H
	ORG $+2
$SG11738 DB	' = ', 00H
$SG11741 DB	'.', 00H
	ORG $+2
$SG11742 DB	'.', 00H
	ORG $+2
$SG11743 DB	' ) ', 00H
$SG11782 DB	'YYYYMMDD', 00H
	ORG $+3
$SG11785 DB	'YYYY-M-D H:MI:SSAM', 00H
	ORG $+1
$SG11788 DB	'D-Mmm-YYYY H:MI:SSAM', 00H
	ORG $+3
$SG13838 DB	'Cannot allocate memory', 00H
	ORG $+1
$SG13839 DB	'EntityName', 00H
	ORG $+1
$SG11791 DB	'D-Mmm-YYYY', 00H
	ORG $+1
$SG13842 DB	'*root*', 00H
	ORG $+1
$SG11794 DB	'YYYY-M-D H:MI:SS', 00H
	ORG $+3
$SG13843 DB	'*root*', 00H
	ORG $+1
$SG13844 DB	'*root*', 00H
	ORG $+1
$SG11797 DB	'YYYY-M-D H:MIAM', 00H
$SG13846 DB	'Entity ''%s'' does not exist in Object ''%s''', 00H
	ORG $+2
$SG12823 DB	', ', 00H
	ORG $+1
$SG11800 DB	'YYYY-M-D H:MI', 00H
	ORG $+2
$SG13850 DB	'OpenSQL', 00H
$SG11803 DB	'YYYY-M-D', 00H
	ORG $+3
$SG13849 DB	'Entity ''%s'' in Object ''%s'' is a work or derived enti'
	DB	'ty and is not allowed for entity qualification during an Acti'
	DB	'vate', 00H
	ORG $+2
$SG12825 DB	' AND ', 00H
	ORG $+2
$SG13853 DB	'OpenSQL_AttributeList', 00H
	ORG $+2
$SG11806 DB	'H:MI:SSAM', 00H
	ORG $+2
$SG13855 DB	'OpenSQL is specified but not OpenSQL_AttributeList.', 00H
$SG11809 DB	'H:MI:SS', 00H
$SG13858 DB	'OpenSQL is specified but entity does not have DB informa'
	DB	'tion for attributes.', 00H
	ORG $+3
$SG13860 DB	'Cannot allocate memory', 00H
	ORG $+1
$SG11812 DB	'H:MIAM', 00H
	ORG $+1
$SG11814 DB	'H:MI', 00H
	ORG $+3
$SG11816 DB	'19000101000000000', 00H
	ORG $+2
$SG13866 DB	'Options', 00H
$SG12888 DB	'Qualification Object Error', 00H
	ORG $+1
$SG13865 DB	'Attribute name ''%s'' specified in OpenSQL_AttributeList'
	DB	' does not exist for entity ''%s''', 00H
	ORG $+2
$SG13869 DB	'NOJOIN', 00H
	ORG $+1
$SG12887 DB	'Cursor is NULL for attribute ''@%s.%s''', 00H
	ORG $+2
$SG12889 DB	'KZH0202', 00H
$SG11865 DB	'null', 00H
	ORG $+3
$SG11875 DB	'UPPER', 00H
	ORG $+2
$SG13931 DB	'ERR>  ', 00H
	ORG $+1
$SG13932 DB	'^', 00H
	ORG $+2
$SG12929 DB	'SELECT ', 00H
$SG11908 DB	'Blobs not supported as string attributes', 00H
	ORG $+3
$SG11909 DB	'Zeidon Core', 00H
$SG12939 DB	'( ', 00H
	ORG $+1
$SG11917 DB	'HH.MI.SS.999', 00H
	ORG $+3
$SG12942 DB	' )', 00H
	ORG $+1
$SG11919 DB	'YYYY-mm-DD', 00H
	ORG $+1
$SG11921 DB	'YYYY-mm-DD-HH.MI.SS.999', 00H
$SG11922 DB	'''%s''', 00H
	ORG $+3
$SG14009 DB	'ON ', 00H
$SG14013 DB	'AND ', 00H
	ORG $+3
$SG12989 DB	'SELECT ', 00H
$SG14014 DB	'OR ', 00H
$SG14017 DB	'FROM ', 00H
	ORG $+2
$SG12993 DB	' AND ', 00H
	ORG $+2
$SG12994 DB	' = ', 00H
$SG14020 DB	'INTO ', 00H
	ORG $+2
$SG14022 DB	'IN ', 00H
$SG13000 DB	', ', 00H
	ORG $+1
$SG14026 DB	'SELECT ', 00H
$SG14029 DB	'SET ', 00H
	ORG $+3
$SG14032 DB	'VALUES ', 00H
$SG14035 DB	'WHERE ', 00H
	ORG $+1
$SG12002 DB	'AVG( ', 00H
	ORG $+2
$SG12004 DB	'COUNT( ', 00H
$SG12006 DB	'MIN( ', 00H
	ORG $+2
$SG12008 DB	'SUM( ', 00H
	ORG $+2
$SG12010 DB	'MAX( ', 00H
	ORG $+2
$SG14059 DB	'SQL>  ', 00H
	ORG $+1
$SG12014 DB	'.', 00H
	ORG $+2
$SG12018 DB	' )', 00H
	ORG $+1
$SG12021 DB	', ', 00H
	ORG $+1
$SG12024 DB	', ', 00H
	ORG $+1
$SG12046 DB	' INTO ', 00H
	ORG $+1
$SG12052 DB	', ', 00H
	ORG $+1
$SG12055 DB	':', 00H
	ORG $+2
$SG13094 DB	'SELECT ', 00H
$SG13097 DB	'(kzhsqlga) Internal error #2', 00H
	ORG $+3
$SG13100 DB	', ', 00H
	ORG $+1
$SG13102 DB	' ( ', 00H
$SG13106 DB	' AND ', 00H
	ORG $+2
$SG12082 DB	' , ', 00H
$SG13107 DB	' = ', 00H
$SG13110 DB	' ) AND ( ', 00H
	ORG $+2
$SG13113 DB	' AND ', 00H
	ORG $+2
$SG13115 DB	'(kzhsqlga) Internal error #3', 00H
	ORG $+3
$SG13116 DB	' ', 00H
	ORG $+2
$SG13119 DB	' ', 00H
	ORG $+2
$SG13121 DB	' ', 00H
	ORG $+2
$SG13122 DB	' )', 00H
	ORG $+1
$SG12128 DB	'fnSqlBuildWhere found ForeignKey: ', 00H
	ORG $+1
$SG12129 DB	'fnSqlBuildWhere found Attribute: ', 00H
	ORG $+2
$SG12130 DB	' ( ', 00H
$SG12133 DB	' IS ', 00H
	ORG $+3
$SG12134 DB	' = ', 00H
$SG12135 DB	' )', 00H
	ORG $+1
$SG13162 DB	' ORDER BY ', 00H
	ORG $+1
$SG12139 DB	' ( ', 00H
$SG12140 DB	' AND ', 00H
	ORG $+2
$SG12142 DB	'.', 00H
	ORG $+2
$SG13167 DB	', ', 00H
	ORG $+1
$SG13168 DB	'.', 00H
	ORG $+2
$SG12145 DB	' IS ', 00H
	ORG $+3
$SG13170 DB	' DESC', 00H
	ORG $+2
$SG12146 DB	' = ', 00H
$SG12150 DB	' )', 00H
	ORG $+1
$SG12148 DB	'SQL Error creating WHERE clause -- no key attribute foun'
	DB	'd in object definition.', 0aH, 'Object name = ', 00H
	ORG $+1
$SG12149 DB	0aH, 'Entity name = ', 00H
$SG12172 DB	'INSERT INTO ', 00H
	ORG $+3
$SG12173 DB	' ( ', 00H
$SG12177 DB	' ) VALUES ( ', 00H
	ORG $+3
$SG12179 DB	' )', 00H
	ORG $+1
$SG13224 DB	'Invalid Sequencing defined for Entity ', 00H
	ORG $+1
$SG13230 DB	' ORDER BY ', 00H
	ORG $+1
$SG13231 DB	', ', 00H
	ORG $+1
$SG13232 DB	'.', 00H
	ORG $+2
$SG13234 DB	' DESC', 00H
	ORG $+2
$SG12215 DB	'INSERT INTO ', 00H
	ORG $+3
$SG12216 DB	' ( ', 00H
$SG12218 DB	', ', 00H
	ORG $+1
$SG12222 DB	', ', 00H
	ORG $+1
$SG12223 DB	' ) VALUES ( ', 00H
	ORG $+3
$SG12225 DB	', ', 00H
	ORG $+1
$SG12227 DB	', ', 00H
	ORG $+1
$SG12228 DB	' )', 00H
	ORG $+1
$SG13262 DB	'--- QualAttrib ---', 00H
	ORG $+1
$SG13264 DB	'Entity name: ', 00H
	ORG $+2
$SG13266 DB	'Attrib name: ', 00H
	ORG $+2
$SG13267 DB	'Oper       : ', 00H
	ORG $+2
$SG13269 DB	'Value      : ', 00H
	ORG $+2
$SG13271 DB	'Source Entity name: ', 00H
	ORG $+3
$SG13273 DB	'Source Attrib name: ', 00H
	ORG $+3
$SG13275 DB	'SourceView is defined', 00H
	ORG $+2
$SG13285 DB	'************************************', 00H
	ORG $+3
$SG12261 DB	'UPDATE ', 00H
$SG13287 DB	'Display QualEntity structure', 00H
	ORG $+3
$SG13291 DB	'--- QualEntity ---', 00H
	ORG $+1
$SG13292 DB	'  Entity Name:', 00H
	ORG $+1
$SG13296 DB	'  bQualUsesChildEntity: TRUE', 00H
	ORG $+3
$SG12273 DB	' SET ', 00H
	ORG $+2
$SG13298 DB	'  bQualUsesChildEntity: FALSE', 00H
	ORG $+2
$SG12274 DB	' , ', 00H
$SG12275 DB	' = ', 00H
$SG12276 DB	' ', 00H
	ORG $+2
$SG13302 DB	'  bContainsSubselect: TRUE', 00H
	ORG $+1
$SG13304 DB	'  bContainsSubselect: FALSE', 00H
$SG13307 DB	'************************************', 00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_SqlFreeBoundAttrList@4
PUBLIC	_SqlAddBoundAttr@20
PUBLIC	_SqlInitBoundAttrList@20
PUBLIC	_SqlBuildInsert@20
PUBLIC	_SqlBuildInsertCorrTable@20
PUBLIC	_SqlBuildUpdate@24
PUBLIC	_SqlBuildUpdateCorrTable@20
PUBLIC	_SqlBuildDelete@20
PUBLIC	_SqlBuildDeleteAll@20
PUBLIC	_SqlBuildDeleteCorrTable@20
PUBLIC	_SqlBuildSelect@24
PUBLIC	_SqlBuildSelectForEntityInstance@24
PUBLIC	_SqlAutoLoadFromParent@24
PUBLIC	_SqlEntityIsQualified@8
PUBLIC	_SqlFreeQualEntity@4
PUBLIC	_SqlRetrieveQualObject@20
PUBLIC	_SqlDisplayCommandEx@16
PUBLIC	_SqlDisplayCommand@8
PUBLIC	_SqlDisplayQualEntity@8
PUBLIC	_SqlAttributeIsNull@12
PUBLIC	_SqlFindNextJoinableChild@20
PUBLIC	_SqlEntityValidForJoin@12
PUBLIC	_SqlCheckOpenSQL@8
PUBLIC	_zstrtrim
PUBLIC	_fnTableName@12
PUBLIC	_fnAddCheckForNullKey
PUBLIC	_fnTraceSql@8
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___strnicmp:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_DisplayEntityInstancePath@8:PROC
EXTRN	_DisplayObjectInstance@12:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_IssueError@16:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_SetViewToSubobject@8:PROC
EXTRN	_CheckExistenceOfEntity@8:PROC
EXTRN	_LoadEntity@16:PROC
EXTRN	_DropEntity@12:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorPrevEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorLastEntity@12:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_GetIntegerFromAttribute@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_CountEntitiesForView@8:PROC
EXTRN	_UfFormatDateTime@12:PROC
EXTRN	_UfEditFormatDateTime@8:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_SysCompareDecimalToDecimal@8:PROC
EXTRN	_SysConvertStringToDecimal@8:PROC
EXTRN	_MiGetViewEntityForView@8:PROC
EXTRN	_SysAllocMemory@20:PROC
EXTRN	_SysFree@4:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysGetPointerFromHandle@4:PROC
EXTRN	_SysGetTaskFromView@4:PROC
EXTRN	_SysMalloc@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_GetAddrForAttribute@16:PROC
EXTRN	_GetValueFromRecord@24:PROC
EXTRN	_StoreStringInRecord@16:PROC
EXTRN	_GetStringFromRecord@20:PROC
EXTRN	_GetAttributeFlags@16:PROC
EXTRN	_UfStringToDateTime@8:PROC
EXTRN	_UfCompareDateTimeToDateTime@8:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__isdigit:PROC
EXTRN	__imp__isspace:PROC
EXTRN	__imp__isalnum:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_pch$ = 8						; size = 4
_pDummy$ = 12						; size = 4
_fnTraceSql@8 PROC

; 7195 : {

	push	ebp
	mov	ebp, esp

; 7196 : #if 0
; 7197 :    if ( strstr( pch, "SELECT ATTENDAN" ) )  // dks debug 2005.12.13
; 7198 :    {
; 7199 :       int k = 0;
; 7200 : 
; 7201 :       k /= k;
; 7202 :       TraceLine( "fnTraceSql Cmd: 0x%08x", pch );
; 7203 :    }
; 7204 : #endif
; 7205 :    TraceLineS( "SQL>  ", pch );

	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET $SG14059
	call	_TraceLineS@8

; 7206 : }

	pop	ebp
	ret	8
_fnTraceSql@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
tv129 = -68						; size = 4
_hMemBuffer$ = -64					; size = 4
$T1 = -60						; size = 4
tv150 = -56						; size = 4
_nParenCount$ = -52					; size = 2
_bFirstOnStmt$ = -45					; size = 1
_nTokenLth$ = -44					; size = 2
_pchToken$ = -40					; size = 4
_pchSqlCmd$ = -36					; size = 4
_pchBuffer$ = -32					; size = 4
_pchLine$ = -28						; size = 4
_pnIndentIncrement$ = -24				; size = 2
_pnErrorIdx$ = -20					; size = 2
_szTemp$2 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_pchSqlCmdStr$ = 8					; size = 4
_pchErrorChar$ = 12					; size = 4
_pnIndentLth$ = 16					; size = 2
_pchInitString$ = 20					; size = 4
_bFirstCall$ = 24					; size = 1
_pfnWrite$ = 28						; size = 4
_pInfo$ = 32						; size = 4
_fnSqlDisplayCommand PROC

; 6864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6865 :    zPCHAR pchBuffer;
; 6866 :    zLONG  hMemBuffer;
; 6867 :    zSHORT pnIndentIncrement;
; 6868 :    zSHORT nParenCount;
; 6869 :    zSHORT nTokenLth;
; 6870 :    zSHORT pnErrorIdx;
; 6871 :    zPCHAR pchToken;
; 6872 :    zPCHAR pchLine;
; 6873 :    zPCHAR pchSqlCmd;
; 6874 :    zBOOL  bFirstOnStmt = TRUE;

	mov	BYTE PTR _bFirstOnStmt$[ebp], 1

; 6875 : 
; 6876 :    hMemBuffer = SysAllocMemory( (zCOREMEM) &pchBuffer, MAX_SQLCMD_LENGTH, 0,

	push	0
	push	32768					; 00008000H
	push	0
	push	105000					; 00019a28H
	lea	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMemBuffer$[ebp], eax

; 6877 :                                 zCOREMEM_ALLOC, 0 );
; 6878 :    if ( pchBuffer == 0 )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $LN14@fnSqlDispl

; 6879 :       return;

	jmp	$LN49@fnSqlDispl
$LN14@fnSqlDispl:

; 6880 : 
; 6881 :    pchLine = pchBuffer;

	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _pchLine$[ebp], ecx

; 6882 :    if ( pchInitString )

	cmp	DWORD PTR _pchInitString$[ebp], 0
	je	SHORT $LN15@fnSqlDispl

; 6883 :    {
; 6884 :       zstrcpy( pchBuffer, pchInitString );

	mov	edx, DWORD PTR _pchInitString$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN2@fnSqlDispl:

; 6885 :       mAdvanceToNull( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@fnSqlDispl
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax
	jmp	SHORT $LN2@fnSqlDispl
$LN3@fnSqlDispl:

; 6886 :       pnIndentIncrement = zstrlen( pchInitString ) + 1;

	mov	ecx, DWORD PTR _pchInitString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	WORD PTR _pnIndentIncrement$[ebp], ax

; 6887 :    }

	jmp	SHORT $LN16@fnSqlDispl
$LN15@fnSqlDispl:

; 6888 :    else
; 6889 :       pnIndentIncrement = 0;

	xor	edx, edx
	mov	WORD PTR _pnIndentIncrement$[ebp], dx
$LN16@fnSqlDispl:

; 6890 : 
; 6891 :    nParenCount = 0;

	xor	eax, eax
	mov	WORD PTR _nParenCount$[ebp], ax

; 6892 :    pnErrorIdx   = 0;

	xor	ecx, ecx
	mov	WORD PTR _pnErrorIdx$[ebp], cx

; 6893 : 
; 6894 :    // Loop through, copying each character from pchSqlCmd to pchBuffer for
; 6895 :    // printing.
; 6896 :    pchSqlCmd = *pchSqlCmdStr;

	mov	edx, DWORD PTR _pchSqlCmdStr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pchSqlCmd$[ebp], eax
$LN4@fnSqlDispl:

; 6897 :    while ( *pchSqlCmd )

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN5@fnSqlDispl
$LN6@fnSqlDispl:

; 6898 :    {
; 6899 :       // Skip spaces.
; 6900 :       while ( zisspace( *pchSqlCmd ) )

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@fnSqlDispl

; 6901 :          pchSqlCmd++;

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSqlCmd$[ebp], edx
	jmp	SHORT $LN6@fnSqlDispl
$LN7@fnSqlDispl:

; 6902 : 
; 6903 :       // Get next token.
; 6904 :       pchToken = pchSqlCmd;

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR _pchToken$[ebp], eax
$LN8@fnSqlDispl:

; 6905 :       while ( *pchSqlCmd )

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN9@fnSqlDispl

; 6906 :       {
; 6907 :          if ( zisspace( *pchSqlCmd ) )

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN17@fnSqlDispl

; 6908 :             break;

	jmp	SHORT $LN9@fnSqlDispl
$LN17@fnSqlDispl:

; 6909 : 
; 6910 :          // If the character is a single quote, skip everything until ending
; 6911 :          // single quote is found.
; 6912 :          if ( *pchSqlCmd++ == '\'' )

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv129[ebp], eax
	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchSqlCmd$[ebp], ecx
	cmp	DWORD PTR tv129[ebp], 39		; 00000027H
	jne	SHORT $LN18@fnSqlDispl
$LN10@fnSqlDispl:

; 6913 :          {
; 6914 :             while ( *pchSqlCmd )

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN11@fnSqlDispl

; 6915 :             {
; 6916 :                if ( *pchSqlCmd == '\'' && pchSqlCmd[ 1 ] != '\'' )

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	SHORT $LN19@fnSqlDispl
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 39					; 00000027H
	je	SHORT $LN19@fnSqlDispl

; 6917 :                   break;

	jmp	SHORT $LN11@fnSqlDispl
$LN19@fnSqlDispl:

; 6918 : 
; 6919 :                if ( *pchSqlCmd == '\'' )

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 39					; 00000027H
	jne	SHORT $LN20@fnSqlDispl

; 6920 :                   pchSqlCmd++;

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSqlCmd$[ebp], edx
$LN20@fnSqlDispl:

; 6921 : 
; 6922 :                pchSqlCmd++;

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSqlCmd$[ebp], eax

; 6923 :             }

	jmp	SHORT $LN10@fnSqlDispl
$LN11@fnSqlDispl:

; 6924 : 
; 6925 :             if ( *pchSqlCmd == '\'' )

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 39					; 00000027H
	jne	SHORT $LN18@fnSqlDispl

; 6926 :                pchSqlCmd++;

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSqlCmd$[ebp], eax
$LN18@fnSqlDispl:

; 6927 :          }
; 6928 :       }

	jmp	$LN8@fnSqlDispl
$LN9@fnSqlDispl:

; 6929 : 
; 6930 :       nTokenLth = (zSHORT) (pchSqlCmd - pchToken);

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	sub	ecx, DWORD PTR _pchToken$[ebp]
	mov	WORD PTR _nTokenLth$[ebp], cx

; 6931 : 
; 6932 :       if ( pchLine != pchBuffer )

	mov	edx, DWORD PTR _pchLine$[ebp]
	cmp	edx, DWORD PTR _pchBuffer$[ebp]
	je	SHORT $LN22@fnSqlDispl

; 6933 :          *pchLine++ = ' ';

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx
$LN22@fnSqlDispl:

; 6934 : 
; 6935 : #if DBG_DISPLAY
; 6936 :       {
; 6937 :          zCHAR s[ 100 ];
; 6938 : 
; 6939 :          zstrncpy( s, pchToken, nTokenLth );
; 6940 :          s[ nTokenLth ] = 0;
; 6941 :          TraceLineS( "DBG Token> ", s );
; 6942 :       }
; 6943 : #endif
; 6944 : 
; 6945 :       switch ( *pchToken )

	mov	edx, DWORD PTR _pchToken$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv150[ebp], eax
	mov	ecx, DWORD PTR tv150[ebp]
	sub	ecx, 40					; 00000028H
	mov	DWORD PTR tv150[ebp], ecx
	cmp	DWORD PTR tv150[ebp], 47		; 0000002fH
	ja	$LN47@fnSqlDispl
	mov	edx, DWORD PTR tv150[ebp]
	movzx	eax, BYTE PTR $LN52@fnSqlDispl[edx]
	jmp	DWORD PTR $LN53@fnSqlDispl[eax*4]
$LN23@fnSqlDispl:

; 6946 :       {
; 6947 :          case '(':
; 6948 :             nParenCount++;

	mov	cx, WORD PTR _nParenCount$[ebp]
	add	cx, 1
	mov	WORD PTR _nParenCount$[ebp], cx

; 6949 :             pnIndentIncrement += 2;

	movsx	edx, WORD PTR _pnIndentIncrement$[ebp]
	add	edx, 2
	mov	WORD PTR _pnIndentIncrement$[ebp], dx

; 6950 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchErrorChar$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nTokenLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 6951 :                             pchBuffer, &pnErrorIdx );
; 6952 :             break;

	jmp	$LN12@fnSqlDispl
$LN24@fnSqlDispl:

; 6953 : 
; 6954 :          case ')':
; 6955 :             nParenCount--;

	mov	ax, WORD PTR _nParenCount$[ebp]
	sub	ax, 1
	mov	WORD PTR _nParenCount$[ebp], ax

; 6956 :             pnIndentIncrement -= 2;

	movsx	ecx, WORD PTR _pnIndentIncrement$[ebp]
	sub	ecx, 2
	mov	WORD PTR _pnIndentIncrement$[ebp], cx

; 6957 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	edx, DWORD PTR _pnErrorIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchErrorChar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	movzx	eax, WORD PTR _nTokenLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchToken$[ebp]
	push	ecx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 6958 :                             pchBuffer, &pnErrorIdx );
; 6959 : 
; 6960 :             // If paren count is 0 and we are in a recursive call
; 6961 :             // then get out of recursive call.
; 6962 :             if ( nParenCount == 0 && bFirstCall == FALSE )

	movsx	edx, WORD PTR _nParenCount$[ebp]
	test	edx, edx
	jne	SHORT $LN25@fnSqlDispl
	movzx	eax, BYTE PTR _bFirstCall$[ebp]
	test	eax, eax
	jne	SHORT $LN25@fnSqlDispl

; 6963 :             {
; 6964 :               fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentIncrement$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH

; 6965 :                               &pnIndentIncrement, &pnErrorIdx,
; 6966 :                               pfnWrite, pInfo );
; 6967 :               *pchSqlCmdStr = pchSqlCmd;

	mov	edx, DWORD PTR _pchSqlCmdStr$[ebp]
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [edx], eax

; 6968 :               SysFreeMemory( hMemBuffer );

	mov	ecx, DWORD PTR _hMemBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 6969 :               return;

	jmp	$LN49@fnSqlDispl
$LN25@fnSqlDispl:

; 6970 :             }
; 6971 : 
; 6972 :             break;

	jmp	$LN12@fnSqlDispl
$LN26@fnSqlDispl:

; 6973 : 
; 6974 :          case ',':
; 6975 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	edx, DWORD PTR _pnErrorIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchErrorChar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	movzx	eax, WORD PTR _nTokenLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchToken$[ebp]
	push	ecx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 6976 :                             pchBuffer, &pnErrorIdx );
; 6977 :             fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	edx, DWORD PTR _pInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfnWrite$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnErrorIdx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentIncrement$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnIndentLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH

; 6978 :                             &pnIndentIncrement, &pnErrorIdx,
; 6979 :                             pfnWrite, pInfo );
; 6980 :             break;

	jmp	$LN12@fnSqlDispl
$LN27@fnSqlDispl:

; 6981 : 
; 6982 :          case 'A':
; 6983 :          case 'O':
; 6984 :             if ( zstrncmpi( pchToken, "ON ", 3 ) == 0 )

	push	3
	push	OFFSET $SG14009
	mov	eax, DWORD PTR _pchToken$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@fnSqlDispl

; 6985 :             {
; 6986 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentIncrement$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH

; 6987 :                                &pnIndentIncrement, &pnErrorIdx,
; 6988 :                                pfnWrite, pInfo );
; 6989 : 
; 6990 :                // pnIndentLth will be reset during the "WHERE" clause.
; 6991 :                if ( bFirstOnStmt )

	movzx	edx, BYTE PTR _bFirstOnStmt$[ebp]
	test	edx, edx
	je	SHORT $LN29@fnSqlDispl

; 6992 :                   pnIndentLth += 5;

	movsx	eax, WORD PTR _pnIndentLth$[ebp]
	add	eax, 5
	mov	WORD PTR _pnIndentLth$[ebp], ax
$LN29@fnSqlDispl:

; 6993 : 
; 6994 :                bFirstOnStmt = FALSE;

	mov	BYTE PTR _bFirstOnStmt$[ebp], 0
$LN28@fnSqlDispl:

; 6995 :             }
; 6996 : 
; 6997 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	ecx, DWORD PTR _pnErrorIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchErrorChar$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nTokenLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchToken$[ebp]
	push	eax
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 6998 :                             pchBuffer, &pnErrorIdx );
; 6999 : 
; 7000 :             if ( zstrncmpi( pchToken, "AND ", 4 ) == 0 ||

	push	4
	push	OFFSET $SG14013
	mov	ecx, DWORD PTR _pchToken$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN31@fnSqlDispl
	push	3
	push	OFFSET $SG14014
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@fnSqlDispl
$LN31@fnSqlDispl:

; 7001 :                  zstrncmpi( pchToken, "OR ", 3 ) == 0 )
; 7002 :             {
; 7003 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	eax, DWORD PTR _pInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfnWrite$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnErrorIdx$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnIndentIncrement$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH
$LN30@fnSqlDispl:

; 7004 :                                &pnIndentIncrement, &pnErrorIdx,
; 7005 :                                pfnWrite, pInfo );
; 7006 :             }
; 7007 : 
; 7008 :             break;

	jmp	$LN12@fnSqlDispl
$LN32@fnSqlDispl:

; 7009 : 
; 7010 :          case 'F':
; 7011 :             if ( zstrncmpi( pchToken, "FROM ", 5 ) == 0 )

	push	5
	push	OFFSET $SG14017
	mov	ecx, DWORD PTR _pchToken$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@fnSqlDispl

; 7012 :             {
; 7013 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	edx, DWORD PTR _pInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfnWrite$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnErrorIdx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentIncrement$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnIndentLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH
$LN33@fnSqlDispl:

; 7014 :                                &pnIndentIncrement, &pnErrorIdx,
; 7015 :                                pfnWrite, pInfo );
; 7016 :             }
; 7017 : 
; 7018 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchErrorChar$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nTokenLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 7019 :                             pchBuffer, &pnErrorIdx );
; 7020 :             break;

	jmp	$LN12@fnSqlDispl
$LN34@fnSqlDispl:

; 7021 : 
; 7022 :          case 'I':
; 7023 :             if ( zstrncmpi( pchToken, "INTO ", 5 ) == 0 )

	push	5
	push	OFFSET $SG14020
	mov	eax, DWORD PTR _pchToken$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN35@fnSqlDispl

; 7024 :             {
; 7025 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentIncrement$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH
$LN35@fnSqlDispl:

; 7026 :                                &pnIndentIncrement, &pnErrorIdx,
; 7027 :                                pfnWrite, pInfo );
; 7028 :             }
; 7029 : 
; 7030 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	edx, DWORD PTR _pnErrorIdx$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchErrorChar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	movzx	eax, WORD PTR _nTokenLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchToken$[ebp]
	push	ecx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 7031 :                             pchBuffer, &pnErrorIdx );
; 7032 : 
; 7033 :             if ( zstrncmpi( pchToken, "IN ", 3 ) == 0 )

	push	3
	push	OFFSET $SG14022
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN36@fnSqlDispl

; 7034 :             {
; 7035 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	eax, DWORD PTR _pInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfnWrite$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnErrorIdx$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnIndentIncrement$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH

; 7036 :                                &pnIndentIncrement, &pnErrorIdx,
; 7037 :                                pfnWrite, pInfo );
; 7038 :                fnSqlDisplayCommand( &pchSqlCmd, pchErrorChar,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	push	0
	push	0
	movzx	eax, WORD PTR _pnIndentLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchErrorChar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchSqlCmd$[ebp]
	push	edx
	call	_fnSqlDisplayCommand
	add	esp, 28					; 0000001cH
$LN36@fnSqlDispl:

; 7039 :                                     pnIndentLth, 0, FALSE,
; 7040 :                                     pfnWrite, pInfo );
; 7041 :             }
; 7042 : 
; 7043 :             break;

	jmp	$LN12@fnSqlDispl
$LN37@fnSqlDispl:

; 7044 : 
; 7045 :          case 'S':
; 7046 :             if ( zstrncmpi( pchToken, "SELECT ", 7 ) == 0 )

	push	7
	push	OFFSET $SG14026
	mov	eax, DWORD PTR _pchToken$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN38@fnSqlDispl

; 7047 :             {
; 7048 :                if ( bFirstCall == FALSE )

	movzx	ecx, BYTE PTR _bFirstCall$[ebp]
	test	ecx, ecx
	jne	SHORT $LN40@fnSqlDispl

; 7049 :                   fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	edx, DWORD PTR _pInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfnWrite$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnErrorIdx$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentIncrement$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnIndentLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH
$LN40@fnSqlDispl:

; 7050 :                                   &pnIndentIncrement, &pnErrorIdx,
; 7051 :                                   pfnWrite, pInfo );
; 7052 :             }

	jmp	SHORT $LN39@fnSqlDispl
$LN38@fnSqlDispl:

; 7053 :             else
; 7054 :             if ( zstrncmpi( pchToken, "SET ", 4 ) == 0 )

	push	4
	push	OFFSET $SG14029
	mov	eax, DWORD PTR _pchToken$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN39@fnSqlDispl

; 7055 :             {
; 7056 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentIncrement$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH

; 7057 :                                &pnIndentIncrement, &pnErrorIdx,
; 7058 :                                pfnWrite, pInfo );
; 7059 :                pnIndentIncrement += 4;

	movsx	edx, WORD PTR _pnIndentIncrement$[ebp]
	add	edx, 4
	mov	WORD PTR _pnIndentIncrement$[ebp], dx
$LN39@fnSqlDispl:

; 7060 :             }
; 7061 : 
; 7062 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchErrorChar$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nTokenLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 7063 :                             pchBuffer, &pnErrorIdx );
; 7064 :             break;

	jmp	$LN12@fnSqlDispl
$LN42@fnSqlDispl:

; 7065 : 
; 7066 :          case 'V':
; 7067 :             if ( zstrncmpi( pchToken, "VALUES ", 7 ) == 0 )

	push	7
	push	OFFSET $SG14032
	mov	eax, DWORD PTR _pchToken$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN43@fnSqlDispl

; 7068 :             {
; 7069 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentIncrement$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH

; 7070 :                                &pnIndentIncrement, &pnErrorIdx,
; 7071 :                                pfnWrite, pInfo );
; 7072 :                pnIndentIncrement += 7;

	movsx	edx, WORD PTR _pnIndentIncrement$[ebp]
	add	edx, 7
	mov	WORD PTR _pnIndentIncrement$[ebp], dx
$LN43@fnSqlDispl:

; 7073 :             }
; 7074 : 
; 7075 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchErrorChar$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nTokenLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 7076 :                             pchBuffer, &pnErrorIdx );
; 7077 :             break;

	jmp	$LN12@fnSqlDispl
$LN44@fnSqlDispl:

; 7078 : 
; 7079 :          case 'W':
; 7080 :             if ( zstrncmpi( pchToken, "WHERE ", 6 ) == 0 )

	push	6
	push	OFFSET $SG14035
	mov	eax, DWORD PTR _pchToken$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN45@fnSqlDispl

; 7081 :             {
; 7082 :                zCHAR szTemp[ 10 ];
; 7083 : 
; 7084 :                fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentIncrement$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH

; 7085 :                                &pnIndentIncrement, &pnErrorIdx,
; 7086 :                                pfnWrite, pInfo );
; 7087 : 
; 7088 :                if ( bFirstCall )

	movzx	edx, BYTE PTR _bFirstCall$[ebp]
	test	edx, edx
	je	SHORT $LN46@fnSqlDispl

; 7089 :                   pnIndentLth = 0;

	xor	eax, eax
	mov	WORD PTR _pnIndentLth$[ebp], ax
$LN46@fnSqlDispl:

; 7090 : 
; 7091 :                // Because of OpenSQL, we want to use the generated
; 7092 :                // WHERE because it might be lower-case.
; 7093 :                zstrncpy( szTemp, pchToken, 5 );

	push	5
	mov	ecx, DWORD PTR _pchToken$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTemp$2[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 7094 :                szTemp[ 5 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 5
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 10			; 0000000aH
	jae	SHORT $LN50@fnSqlDispl
	jmp	SHORT $LN51@fnSqlDispl
$LN50@fnSqlDispl:
	call	___report_rangecheckfailure
$LN51@fnSqlDispl:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szTemp$2[ebp+edx], 0

; 7095 : 
; 7096 :                fnSqlDisplayCommand( &pchSqlCmd, pchErrorChar,

	mov	eax, DWORD PTR _pInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pfnWrite$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _szTemp$2[ebp]
	push	edx
	movzx	eax, WORD PTR _pnIndentLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchErrorChar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchSqlCmd$[ebp]
	push	edx
	call	_fnSqlDisplayCommand
	add	esp, 28					; 0000001cH

; 7097 :                                     pnIndentLth, szTemp, FALSE,
; 7098 :                                     pfnWrite, pInfo );
; 7099 :                break;

	jmp	SHORT $LN12@fnSqlDispl
$LN45@fnSqlDispl:

; 7100 :             }
; 7101 : 
; 7102 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchErrorChar$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nTokenLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H

; 7103 :                             pchBuffer, &pnErrorIdx );
; 7104 :             break;

	jmp	SHORT $LN12@fnSqlDispl
$LN47@fnSqlDispl:

; 7105 : 
; 7106 :          default:
; 7107 :             fnSqlCopyToken( pchToken, nTokenLth, &pchLine, pchErrorChar,

	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchErrorChar$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nTokenLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchToken$[ebp]
	push	edx
	call	_fnSqlCopyToken
	add	esp, 24					; 00000018H
$LN12@fnSqlDispl:

; 7108 :                             pchBuffer, &pnErrorIdx );
; 7109 :             break;
; 7110 : 
; 7111 :       } // switch ( *pchToken )...
; 7112 : 
; 7113 :    } // while ( *pchSqlCmd )...

	jmp	$LN4@fnSqlDispl
$LN5@fnSqlDispl:

; 7114 : 
; 7115 :    if ( pchLine > pchBuffer )

	mov	eax, DWORD PTR _pchLine$[ebp]
	cmp	eax, DWORD PTR _pchBuffer$[ebp]
	jbe	SHORT $LN48@fnSqlDispl

; 7116 :       fnSqlPrintLine( pchBuffer, &pchLine, &pnIndentLth,

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pfnWrite$[ebp]
	push	edx
	lea	eax, DWORD PTR _pnErrorIdx$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pnIndentIncrement$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pnIndentLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnSqlPrintLine
	add	esp, 28					; 0000001cH
$LN48@fnSqlDispl:

; 7117 :                       &pnIndentIncrement, &pnErrorIdx, pfnWrite, pInfo );
; 7118 : 
; 7119 :    *pchSqlCmdStr = pchSqlCmd;

	mov	edx, DWORD PTR _pchSqlCmdStr$[ebp]
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [edx], eax

; 7120 :    SysFreeMemory( hMemBuffer );

	mov	ecx, DWORD PTR _hMemBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4
$LN49@fnSqlDispl:

; 7121 : 
; 7122 : }  /* fnSqlDisplayCommand */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN53@fnSqlDispl:
	DD	$LN23@fnSqlDispl
	DD	$LN24@fnSqlDispl
	DD	$LN26@fnSqlDispl
	DD	$LN27@fnSqlDispl
	DD	$LN32@fnSqlDispl
	DD	$LN34@fnSqlDispl
	DD	$LN37@fnSqlDispl
	DD	$LN42@fnSqlDispl
	DD	$LN44@fnSqlDispl
	DD	$LN47@fnSqlDispl
$LN52@fnSqlDispl:
	DB	0
	DB	1
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	9
	DB	7
	DB	8
_fnSqlDisplayCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_n$ = -4						; size = 2
_pchToken$ = 8						; size = 4
_nTokenLth$ = 12					; size = 2
_ppchLine$ = 16						; size = 4
_pchErrorChar$ = 20					; size = 4
_pchBuffer$ = 24					; size = 4
_ppnErrorIdx$ = 28					; size = 4
_fnSqlCopyToken PROC

; 6828 :  {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6829 :    zSHORT n;
; 6830 : 
; 6831 :    for ( n = 0; n < nTokenLth; n++ )

	xor	eax, eax
	mov	WORD PTR _n$[ebp], ax
	jmp	SHORT $LN4@fnSqlCopyT
$LN2@fnSqlCopyT:
	mov	cx, WORD PTR _n$[ebp]
	add	cx, 1
	mov	WORD PTR _n$[ebp], cx
$LN4@fnSqlCopyT:
	movsx	edx, WORD PTR _n$[ebp]
	movsx	eax, WORD PTR _nTokenLth$[ebp]
	cmp	edx, eax
	jge	SHORT $LN1@fnSqlCopyT

; 6832 :    {
; 6833 :       // Copy the n'th character from pchToken to **ppchLine.
; 6834 :       **ppchLine = pchToken[ n ];

	movsx	ecx, WORD PTR _n$[ebp]
	mov	edx, DWORD PTR _ppchLine$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	edx, DWORD PTR _pchToken$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR [eax], cl

; 6835 : 
; 6836 :       // If the current character in pchToken is the ErrorChar then set
; 6837 :       // pnErrorIdx to be the offset of the character in pchBuffer.
; 6838 :       if ( pchToken + n == pchErrorChar )

	movsx	edx, WORD PTR _n$[ebp]
	add	edx, DWORD PTR _pchToken$[ebp]
	cmp	edx, DWORD PTR _pchErrorChar$[ebp]
	jne	SHORT $LN5@fnSqlCopyT

; 6839 :          *ppnErrorIdx = *ppchLine - pchBuffer;

	mov	eax, DWORD PTR _ppchLine$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	edx, DWORD PTR _ppnErrorIdx$[ebp]
	mov	WORD PTR [edx], cx
$LN5@fnSqlCopyT:

; 6840 : 
; 6841 :       (*ppchLine)++;

	mov	eax, DWORD PTR _ppchLine$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _ppchLine$[ebp]
	mov	DWORD PTR [edx], ecx

; 6842 :    }

	jmp	SHORT $LN2@fnSqlCopyT
$LN1@fnSqlCopyT:

; 6843 : } /* fnSqlCopyToken */

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlCopyToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_pfnWrite$ = -20					; size = 4
_pchIndentStr$ = -16					; size = 4
_pchPtr$ = -12						; size = 4
_nParenIndent$ = -8					; size = 2
_n$ = -4						; size = 2
_pchBuffer$ = 8						; size = 4
_ppchLine$ = 12						; size = 4
_pnIndentLth$ = 16					; size = 4
_pnIndentIncrement$ = 20				; size = 4
_pnErrorIdx$ = 24					; size = 4
_pfn$ = 28						; size = 4
_pInfo$ = 32						; size = 4
_fnSqlPrintLine PROC

; 6748 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 6749 :    zSHORT n;
; 6750 :    zSHORT nParenIndent;
; 6751 :    zPCHAR pchPtr;
; 6752 :    zPCHAR pchIndentStr;
; 6753 :    void (POPERATION pfnWrite)( zPCHAR, zPVOID ) =

	mov	eax, DWORD PTR _pfn$[ebp]
	mov	DWORD PTR _pfnWrite$[ebp], eax

; 6754 :                                (void (POPERATION )( zPCHAR, zPVOID )) pfn;
; 6755 : 
; 6756 :    // Terminate ppchLine string.
; 6757 :    **ppchLine = 0;

	mov	ecx, DWORD PTR _ppchLine$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx], 0

; 6758 : 
; 6759 :    pchIndentStr = SysMalloc( zstrlen( pchBuffer ) + 1000 );

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1000				; 000003e8H
	push	eax
	call	_SysMalloc@4
	mov	DWORD PTR _pchIndentStr$[ebp], eax

; 6760 : 
; 6761 :    // If the first character is a right paren ( ')' ) then un-indent two
; 6762 :    // spaces for each right paren.
; 6763 :    pchPtr = pchBuffer;

	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _pchPtr$[ebp], ecx

; 6764 :    nParenIndent = 0;

	xor	edx, edx
	mov	WORD PTR _nParenIndent$[ebp], dx
$LN2@fnSqlPrint:

; 6765 :    while ( *pchPtr )

	mov	eax, DWORD PTR _pchPtr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@fnSqlPrint

; 6766 :    {
; 6767 :       if ( *pchPtr == ')' )

	mov	edx, DWORD PTR _pchPtr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	jne	SHORT $LN12@fnSqlPrint

; 6768 :          nParenIndent += 2;

	movsx	ecx, WORD PTR _nParenIndent$[ebp]
	add	ecx, 2
	mov	WORD PTR _nParenIndent$[ebp], cx
	jmp	SHORT $LN13@fnSqlPrint
$LN12@fnSqlPrint:

; 6769 :       else
; 6770 :       if ( *pchPtr != ' ' && nParenIndent == 0 )

	mov	edx, DWORD PTR _pchPtr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN13@fnSqlPrint
	movsx	ecx, WORD PTR _nParenIndent$[ebp]
	test	ecx, ecx
	jne	SHORT $LN13@fnSqlPrint

; 6771 :          break;

	jmp	SHORT $LN3@fnSqlPrint
$LN13@fnSqlPrint:

; 6772 : 
; 6773 :       pchPtr++;

	mov	edx, DWORD PTR _pchPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchPtr$[ebp], edx

; 6774 :    }

	jmp	SHORT $LN2@fnSqlPrint
$LN3@fnSqlPrint:

; 6775 : 
; 6776 :    // Set up indent string.
; 6777 :    pchPtr = pchIndentStr;

	mov	eax, DWORD PTR _pchIndentStr$[ebp]
	mov	DWORD PTR _pchPtr$[ebp], eax

; 6778 :    for ( n = 0; n < (*pnIndentLth - nParenIndent); n++ )

	xor	ecx, ecx
	mov	WORD PTR _n$[ebp], cx
	jmp	SHORT $LN6@fnSqlPrint
$LN4@fnSqlPrint:
	mov	dx, WORD PTR _n$[ebp]
	add	dx, 1
	mov	WORD PTR _n$[ebp], dx
$LN6@fnSqlPrint:
	movsx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _pnIndentLth$[ebp]
	movsx	edx, WORD PTR [ecx]
	movsx	ecx, WORD PTR _nParenIndent$[ebp]
	sub	edx, ecx
	cmp	eax, edx
	jge	SHORT $LN5@fnSqlPrint

; 6779 :       *pchPtr++ = ' ';

	mov	edx, DWORD PTR _pchPtr$[ebp]
	mov	BYTE PTR [edx], 32			; 00000020H
	mov	eax, DWORD PTR _pchPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchPtr$[ebp], eax
	jmp	SHORT $LN4@fnSqlPrint
$LN5@fnSqlPrint:

; 6780 : 
; 6781 :    *pchPtr = 0;

	mov	ecx, DWORD PTR _pchPtr$[ebp]
	mov	BYTE PTR [ecx], 0

; 6782 : 
; 6783 :    zstrcat( pchIndentStr, pchBuffer );

	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchIndentStr$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 6784 :    (*pfnWrite)( pchIndentStr, pInfo );

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchIndentStr$[ebp]
	push	edx
	call	DWORD PTR _pfnWrite$[ebp]

; 6785 : 
; 6786 :    if ( *pnErrorIdx )

	mov	eax, DWORD PTR _pnErrorIdx$[ebp]
	movsx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	$LN15@fnSqlPrint

; 6787 :    {
; 6788 :       zstrcpy( pchIndentStr, "ERR>  " );

	push	OFFSET $SG13931
	mov	edx, DWORD PTR _pchIndentStr$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 6789 :       pchPtr = pchIndentStr;

	mov	eax, DWORD PTR _pchIndentStr$[ebp]
	mov	DWORD PTR _pchPtr$[ebp], eax
$LN7@fnSqlPrint:

; 6790 :       mAdvanceToNull( pchPtr );

	mov	ecx, DWORD PTR _pchPtr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN8@fnSqlPrint
	mov	eax, DWORD PTR _pchPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchPtr$[ebp], eax
	jmp	SHORT $LN7@fnSqlPrint
$LN8@fnSqlPrint:

; 6791 :       for ( n = 0; n < (*pnIndentLth + *pnErrorIdx); n++ )

	xor	ecx, ecx
	mov	WORD PTR _n$[ebp], cx
	jmp	SHORT $LN11@fnSqlPrint
$LN9@fnSqlPrint:
	mov	dx, WORD PTR _n$[ebp]
	add	dx, 1
	mov	WORD PTR _n$[ebp], dx
$LN11@fnSqlPrint:
	movsx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _pnIndentLth$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	ecx, DWORD PTR _pnErrorIdx$[ebp]
	movsx	ecx, WORD PTR [ecx]
	add	edx, ecx
	cmp	eax, edx
	jge	SHORT $LN10@fnSqlPrint

; 6792 :          *pchPtr++ = ' ';

	mov	edx, DWORD PTR _pchPtr$[ebp]
	mov	BYTE PTR [edx], 32			; 00000020H
	mov	eax, DWORD PTR _pchPtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchPtr$[ebp], eax
	jmp	SHORT $LN9@fnSqlPrint
$LN10@fnSqlPrint:

; 6793 : 
; 6794 :       *pchPtr = 0;

	mov	ecx, DWORD PTR _pchPtr$[ebp]
	mov	BYTE PTR [ecx], 0

; 6795 :       TraceLineS( pchIndentStr, "^" );

	push	OFFSET $SG13932
	mov	edx, DWORD PTR _pchIndentStr$[ebp]
	push	edx
	call	_TraceLineS@8

; 6796 :       *pnErrorIdx = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _pnErrorIdx$[ebp]
	mov	WORD PTR [ecx], ax
$LN15@fnSqlPrint:

; 6797 :    }
; 6798 : 
; 6799 :    *ppchLine     = pchBuffer;

	mov	edx, DWORD PTR _ppchLine$[ebp]
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR [edx], eax

; 6800 :    *pnIndentLth = *pnIndentLth + *pnIndentIncrement;

	mov	ecx, DWORD PTR _pnIndentLth$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _pnIndentIncrement$[ebp]
	movsx	ecx, WORD PTR [eax]
	add	edx, ecx
	mov	eax, DWORD PTR _pnIndentLth$[ebp]
	mov	WORD PTR [eax], dx

; 6801 :    *pnIndentIncrement = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _pnIndentIncrement$[ebp]
	mov	WORD PTR [edx], cx

; 6802 : 
; 6803 :    SysFree( pchIndentStr );

	mov	eax, DWORD PTR _pchIndentStr$[ebp]
	push	eax
	call	_SysFree@4

; 6804 : 
; 6805 : } /* fnSqlPrintLine */

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlPrintLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpFirstDataField$1 = -1428				; size = 4
_lpViewOD$2 = -1424					; size = 4
_pchOptions$ = -1420					; size = 4
tv290 = -1416						; size = 4
tv289 = -1412						; size = 4
$T3 = -1408						; size = 4
_pchAttrList$4 = -1404					; size = 4
tv138 = -1400						; size = 4
tv137 = -1396						; size = 4
_lpViewAttrib$5 = -1392					; size = 4
_hMem$ = -1388						; size = 4
_lpDataRecord$ = -1384					; size = 4
_lpQualAttrib$6 = -1380					; size = 4
_lpViewAttrib$7 = -1376					; size = 4
_lpDataField$8 = -1372					; size = 4
_pchEntityName$ = -1368					; size = 4
_nAttrListCount$9 = -1364				; size = 2
_lpViewEntity$ = -1360					; size = 4
_nAttrLth$10 = -1356					; size = 2
_nRC$ = -1352						; size = 2
_pch$11 = -1348						; size = 4
_lpQualEntity$ = -1344					; size = 4
_szMsg$12 = -1340					; size = 500
_szMsg$13 = -840					; size = 500
_szMsg$14 = -340					; size = 300
_szAttrName$15 = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpQualView$ = 12					; size = 4
_lpViewOD$ = 16						; size = 4
_lpFirstQualEntity$ = 20				; size = 4
_lpBoundList$ = 24					; size = 4
_fnSqlRetrieveQualObject PROC

; 6439 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1428				; 00000594H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6440 :    LPQUALENTITY lpQualEntity;
; 6441 :    LPVIEWENTITY lpViewEntity;
; 6442 :    LPDATARECORD lpDataRecord;
; 6443 :    zPCHAR       pchOptions;
; 6444 :    zPCHAR       pchEntityName;
; 6445 :    zLONG        hMem;
; 6446 :    zSHORT       nRC;
; 6447 : 
; 6448 :    *lpFirstQualEntity = 0;

	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	DWORD PTR [eax], 0

; 6449 : 
; 6450 :    // Copy each of the EntitySpec entities to the qualification chain.
; 6451 :    for ( nRC = SetCursorFirstEntity( lpQualView, szlEntitySpec, 0 );

	push	0
	push	OFFSET _szlEntitySpec
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnSqlRetri
$LN2@fnSqlRetri:

; 6453 :          nRC = SetCursorNextEntity( lpQualView, szlEntitySpec, 0 ) )

	push	0
	push	OFFSET _szlEntitySpec
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnSqlRetri:

; 6452 :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN3@fnSqlRetri

; 6454 :    {
; 6455 :       hMem = SysAllocMemory( (zPVOID) &lpQualEntity,

	push	0
	push	32768					; 00008000H
	push	0
	push	32					; 00000020H
	lea	ecx, DWORD PTR _lpQualEntity$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 6456 :                              sizeof( QualEntityRecord ), 0, zCOREMEM_ALLOC, 0 );
; 6457 :       if ( lpQualEntity == 0 )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	jne	SHORT $LN21@fnSqlRetri

; 6458 :       {
; 6459 :          fnSqlDisplayQualMsg( lpView, lpQualView,

	push	0
	push	0
	push	OFFSET $SG13838
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6460 :                               "Cannot allocate memory", zERROR, 0 );
; 6461 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSqlRetri
$LN21@fnSqlRetri:

; 6462 :       }
; 6463 : 
; 6464 :       // Add lpQualEntity to beginning of chain.
; 6465 :       zmemset( (zPVOID) lpQualEntity, 0, sizeof( QualEntityRecord ) );

	push	32					; 00000020H
	push	0
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6466 :       lpQualEntity->hMem = hMem;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [edx], eax

; 6467 :       lpQualEntity->lpNextQualEntity = *lpFirstQualEntity;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+4], eax

; 6468 :       *lpFirstQualEntity = lpQualEntity;

	mov	ecx, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx], edx

; 6469 : 
; 6470 :       // Find the view entity that matches the qual entity.
; 6471 :       GetAddrForAttribute( &pchEntityName, lpQualView, szlEntitySpec,

	push	OFFSET $SG13839
	push	OFFSET _szlEntitySpec
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 6472 :                            "EntityName" );
; 6473 :       if ( zstrcmp( pchEntityName, "*root*" ) == 0 )

	mov	edx, DWORD PTR _pchEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13842
	cmp	eax, ecx
	jne	SHORT $LN49@fnSqlRetri
	push	OFFSET $SG13843
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN50@fnSqlRetri
$LN49@fnSqlRetri:
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13844
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN47@fnSqlRetri
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $LN48@fnSqlRetri
$LN47@fnSqlRetri:
	mov	DWORD PTR tv137[ebp], -1
$LN48@fnSqlRetri:
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv138[ebp], eax
$LN50@fnSqlRetri:
	cmp	DWORD PTR tv138[ebp], 0
	jne	SHORT $LN22@fnSqlRetri

; 6474 :       {
; 6475 :          LPVIEWOD lpViewOD;
; 6476 : 
; 6477 :          // User specified they want to use the root.  Just get the entity
; 6478 :          // name.
; 6479 :          lpViewOD = (LPVIEWOD) MiGetViewEntityForView( lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewOD$2[ebp], eax

; 6480 :          lpViewEntity = (LPVIEWENTITY) zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$2[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6481 :       }

	jmp	SHORT $LN23@fnSqlRetri
$LN22@fnSqlRetri:

; 6482 :       else
; 6483 :          lpViewEntity = MiGetViewEntityForView( lpView, pchEntityName );

	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN23@fnSqlRetri:

; 6484 : 
; 6485 :       // If no view entity was found to match entity name in qual entity
; 6486 :       // then issue an error and exit.
; 6487 :       if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN24@fnSqlRetri

; 6488 :       {
; 6489 :          zCHAR szMsg[ 500 ];
; 6490 : 
; 6491 :          zsprintf( szMsg, "Entity '%s' does not exist in Object '%s'",

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	push	OFFSET $SG13846
	lea	edx, DWORD PTR _szMsg$13[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 6492 :                    pchEntityName, lpViewOD->szName );
; 6493 :          fnSqlDisplayQualMsg( lpView, lpQualView, szMsg,

	push	OFFSET _szlEntitySpec
	push	0
	lea	eax, DWORD PTR _szMsg$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6494 :                               zERROR, szlEntitySpec );
; 6495 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSqlRetri
$LN24@fnSqlRetri:

; 6496 :       }
; 6497 : 
; 6498 :       if ( lpViewEntity->bDerived || lpViewEntity->bDerivedPath ||

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	SHORT $LN26@fnSqlRetri
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	jne	SHORT $LN26@fnSqlRetri
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+191], 0
	jne	SHORT $LN25@fnSqlRetri
$LN26@fnSqlRetri:

; 6499 :            lpViewEntity->hFirstDataRecord == 0 )
; 6500 :       {
; 6501 :          zCHAR szMsg[ 500 ];
; 6502 : 
; 6503 :          zsprintf( szMsg, "Entity '%s' in Object '%s' is a work or derived entity "

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	push	OFFSET $SG13849
	lea	ecx, DWORD PTR _szMsg$12[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 6504 :                    "and is not allowed for entity qualification during an "
; 6505 :                    "Activate", pchEntityName, lpViewOD->szName );
; 6506 :          fnSqlDisplayQualMsg( lpView, lpQualView, szMsg,

	push	OFFSET _szlEntitySpec
	push	0
	lea	edx, DWORD PTR _szMsg$12[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6507 :                               zERROR, szlEntitySpec );
; 6508 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSqlRetri
$LN25@fnSqlRetri:

; 6509 :       }
; 6510 : 
; 6511 :       GetAddrForAttribute( &lpQualEntity->pszOpenSQL,

	push	OFFSET $SG13850
	push	OFFSET _szlEntitySpec
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	_GetAddrForAttribute@16

; 6512 :                            lpQualView, szlEntitySpec, "OpenSQL" );
; 6513 :       if ( lpQualEntity->pszOpenSQL && *lpQualEntity->pszOpenSQL == 0 )

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [ecx+16], 0
	je	SHORT $LN27@fnSqlRetri
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+16]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN27@fnSqlRetri

; 6514 :          lpQualEntity->pszOpenSQL = 0;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+16], 0
$LN27@fnSqlRetri:

; 6515 : 
; 6516 :       // Check to see if there is OpenSQL statement.
; 6517 :       if ( lpQualEntity->pszOpenSQL )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	$LN28@fnSqlRetri

; 6518 :       {
; 6519 :          zPCHAR       pchAttrList;
; 6520 :          zPCHAR       pch;
; 6521 :          zSHORT       nAttrListCount;
; 6522 :          LPDATAFIELD  lpFirstDataField;
; 6523 : 
; 6524 :          lpQualEntity->bUniqueQualification = FALSE;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [eax+28], edx

; 6525 : 
; 6526 :          // We have an OpenSQL select statement.  Now make sure that the
; 6527 :          // attribute list is specified.
; 6528 :          GetAddrForAttribute( &pchAttrList, lpQualView,

	push	OFFSET $SG13853
	push	OFFSET _szlEntitySpec
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchAttrList$4[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 6529 :                               szlEntitySpec, "OpenSQL_AttributeList" );
; 6530 :          if ( pchAttrList == 0 )

	cmp	DWORD PTR _pchAttrList$4[ebp], 0
	jne	SHORT $LN29@fnSqlRetri

; 6531 :          {
; 6532 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlEntitySpec
	push	0
	push	OFFSET $SG13855
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6533 :                                  "OpenSQL is specified but not "
; 6534 :                                  "OpenSQL_AttributeList.",
; 6535 :                                  zERROR, szlEntitySpec );
; 6536 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSqlRetri
$LN29@fnSqlRetri:

; 6537 :          }
; 6538 : 
; 6539 :          // Make sure the entity has data records.
; 6540 :          lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 6541 :          if ( lpDataRecord == 0 ||

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	je	SHORT $LN31@fnSqlRetri
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	jne	SHORT $LN30@fnSqlRetri
$LN31@fnSqlRetri:

; 6542 :               lpDataRecord->hFirstDataField == 0 )
; 6543 :          {
; 6544 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlEntitySpec
	push	0
	push	OFFSET $SG13858
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6545 :                                  "OpenSQL is specified but entity does not "
; 6546 :                                  "have DB information for attributes.",
; 6547 :                                  zERROR, szlEntitySpec );
; 6548 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSqlRetri
$LN30@fnSqlRetri:

; 6549 :          }
; 6550 : 
; 6551 :          lpFirstDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpFirstDataField$1[ebp], eax

; 6552 : 
; 6553 :          // Retrieve the attribute list and convert the list to a table of
; 6554 :          // data records.
; 6555 :          hMem = SysAllocMemory( (zPVOID) &lpQualEntity->lpDataField,

	push	0
	push	32768					; 00008000H
	push	0
	push	2000					; 000007d0H
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 6556 :                                 sizeof( LPDATAFIELD ) * zMAX_OPENSQL_ATTRS,
; 6557 :                                 0, zCOREMEM_ALLOC, 0 );
; 6558 :          if ( lpQualEntity->lpDataField == 0 )

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN32@fnSqlRetri

; 6559 :          {
; 6560 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	0
	push	0
	push	OFFSET $SG13860
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6561 :                                  "Cannot allocate memory",
; 6562 :                                  zERROR, 0 );
; 6563 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSqlRetri
$LN32@fnSqlRetri:

; 6564 :          }
; 6565 : 
; 6566 :          lpQualEntity->hAttrListMem = hMem;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 6567 : 
; 6568 :          zmemset( (zPVOID) lpQualEntity->lpDataField, 0,

	push	2000					; 000007d0H
	push	0
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6569 :                   sizeof( LPDATAFIELD ) * zMAX_OPENSQL_ATTRS );
; 6570 : 
; 6571 :          // Parse through the attribute list.  For each attribute, find the
; 6572 :          // cooresponding DataRecord and add it to the data record list.
; 6573 :          nAttrListCount = 0;

	xor	edx, edx
	mov	WORD PTR _nAttrListCount$9[ebp], dx

; 6574 :          pch = pchAttrList;

	mov	eax, DWORD PTR _pchAttrList$4[ebp]
	mov	DWORD PTR _pch$11[ebp], eax
$LN5@fnSqlRetri:

; 6575 :          while ( *pch )

	mov	ecx, DWORD PTR _pch$11[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN28@fnSqlRetri
$LN7@fnSqlRetri:

; 6576 :          {
; 6577 :             zCHAR        szAttrName[ 33 ];
; 6578 :             zSHORT       nAttrLth;
; 6579 :             LPDATAFIELD  lpDataField;
; 6580 : 
; 6581 :             // Skip non-alphanumeric chars.
; 6582 :             while ( *pch && !IS_VALID_ID_CHAR( *pch ) )

	mov	eax, DWORD PTR _pch$11[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@fnSqlRetri
	mov	edx, DWORD PTR _pch$11[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@fnSqlRetri
	mov	ecx, DWORD PTR _pch$11[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 95					; 0000005fH
	je	SHORT $LN8@fnSqlRetri

; 6583 :                pch++;

	mov	eax, DWORD PTR _pch$11[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$11[ebp], eax
	jmp	SHORT $LN7@fnSqlRetri
$LN8@fnSqlRetri:

; 6584 : 
; 6585 :             if ( pch[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pch$11[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN33@fnSqlRetri

; 6586 :                break;

	jmp	$LN28@fnSqlRetri
$LN33@fnSqlRetri:

; 6587 : 
; 6588 :             // Copy current attr name in list to variable.
; 6589 :             for ( nAttrLth = 0; IS_VALID_ID_CHAR( *pch ); )

	xor	edx, edx
	mov	WORD PTR _nAttrLth$10[ebp], dx
$LN11@fnSqlRetri:
	mov	eax, DWORD PTR _pch$11[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN34@fnSqlRetri
	mov	edx, DWORD PTR _pch$11[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	jne	SHORT $LN10@fnSqlRetri
$LN34@fnSqlRetri:

; 6590 :                szAttrName[ nAttrLth++ ] = *pch++;

	movsx	ecx, WORD PTR _nAttrLth$10[ebp]
	mov	edx, DWORD PTR _pch$11[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szAttrName$15[ebp+ecx], al
	mov	cx, WORD PTR _nAttrLth$10[ebp]
	add	cx, 1
	mov	WORD PTR _nAttrLth$10[ebp], cx
	mov	edx, DWORD PTR _pch$11[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$11[ebp], edx
	jmp	SHORT $LN11@fnSqlRetri
$LN10@fnSqlRetri:

; 6591 : 
; 6592 :             szAttrName[ nAttrLth ] = 0;

	movsx	eax, WORD PTR _nAttrLth$10[ebp]
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 33			; 00000021H
	jae	SHORT $LN51@fnSqlRetri
	jmp	SHORT $LN52@fnSqlRetri
$LN51@fnSqlRetri:
	call	___report_rangecheckfailure
$LN52@fnSqlRetri:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szAttrName$15[ebp+ecx], 0

; 6593 : 
; 6594 :             // Now look for the attribute that matches szAttrName.
; 6595 :             for ( lpDataField = lpFirstDataField;

	mov	edx, DWORD PTR _lpFirstDataField$1[ebp]
	mov	DWORD PTR _lpDataField$8[ebp], edx
	jmp	SHORT $LN14@fnSqlRetri
$LN12@fnSqlRetri:

; 6597 :                   lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	eax, DWORD PTR _lpDataField$8[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$8[ebp], eax
$LN14@fnSqlRetri:

; 6596 :                   lpDataField;

	cmp	DWORD PTR _lpDataField$8[ebp], 0
	je	$LN13@fnSqlRetri

; 6598 :             {
; 6599 :                LPVIEWATTRIB lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$5[ebp], eax

; 6600 :                if ( zstrcmp( szAttrName, lpViewAttrib->szName ) == 0 )

	movsx	ecx, BYTE PTR _szAttrName$15[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$5[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	ecx, eax
	jne	SHORT $LN55@fnSqlRetri
	mov	ecx, DWORD PTR _lpViewAttrib$5[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szAttrName$15[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv290[ebp], eax
	jmp	SHORT $LN56@fnSqlRetri
$LN55@fnSqlRetri:
	movsx	eax, BYTE PTR _szAttrName$15[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$5[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN53@fnSqlRetri
	mov	DWORD PTR tv289[ebp], 1
	jmp	SHORT $LN54@fnSqlRetri
$LN53@fnSqlRetri:
	mov	DWORD PTR tv289[ebp], -1
$LN54@fnSqlRetri:
	mov	eax, DWORD PTR tv289[ebp]
	mov	DWORD PTR tv290[ebp], eax
$LN56@fnSqlRetri:
	cmp	DWORD PTR tv290[ebp], 0
	jne	SHORT $LN35@fnSqlRetri

; 6601 :                {
; 6602 :                   // We found the attribute we were looking for.  Copy the
; 6603 :                   // data field pointer to the attr list table and break.
; 6604 :                   lpQualEntity->lpDataField[ nAttrListCount++ ] = lpDataField;

	movsx	ecx, WORD PTR _nAttrListCount$9[ebp]
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	edx, DWORD PTR _lpDataField$8[ebp]
	mov	DWORD PTR [eax+ecx*4], edx
	mov	ax, WORD PTR _nAttrListCount$9[ebp]
	add	ax, 1
	mov	WORD PTR _nAttrListCount$9[ebp], ax

; 6605 :                   break;

	jmp	SHORT $LN13@fnSqlRetri
$LN35@fnSqlRetri:

; 6606 :                }
; 6607 :             }

	jmp	$LN12@fnSqlRetri
$LN13@fnSqlRetri:

; 6608 : 
; 6609 :             // If lpDataField is 0, then we didn't find szAttrName in the
; 6610 :             // attribute list.
; 6611 :             if ( lpDataField == 0 )

	cmp	DWORD PTR _lpDataField$8[ebp], 0
	jne	SHORT $LN36@fnSqlRetri

; 6612 :             {
; 6613 :                zCHAR szMsg[ 300 ];
; 6614 : 
; 6615 :                zsprintf( szMsg, "Attribute name '%s' specified in "

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _szAttrName$15[ebp]
	push	edx
	push	OFFSET $SG13865
	lea	eax, DWORD PTR _szMsg$14[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 6616 :                          "OpenSQL_AttributeList does not exist for entity '%s'",
; 6617 :                          szAttrName, lpViewEntity->szName );
; 6618 :                fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlEntitySpec
	push	0
	lea	ecx, DWORD PTR _szMsg$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6619 :                                     szMsg, zERROR, szlEntitySpec );
; 6620 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSqlRetri
$LN36@fnSqlRetri:

; 6621 :             }
; 6622 : 
; 6623 :          } // for ( nAttrListCount... )

	jmp	$LN5@fnSqlRetri
$LN28@fnSqlRetri:

; 6624 : 
; 6625 :       } // if ( lpQualEntity->pszOpenSQL )...
; 6626 : 
; 6627 :       // Check for the different options.
; 6628 :       GetAddrForAttribute( &pchOptions, lpQualView, szlEntitySpec, "Options" );

	push	OFFSET $SG13866
	push	OFFSET _szlEntitySpec
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchOptions$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 6629 :       if ( *pchOptions )

	mov	eax, DWORD PTR _pchOptions$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN37@fnSqlRetri

; 6630 :       {
; 6631 :          if ( zstrstr( pchOptions, "NOJOIN" ) != 0 )

	push	OFFSET $SG13869
	mov	edx, DWORD PTR _pchOptions$[ebp]
	push	edx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN37@fnSqlRetri

; 6632 :             lpQualEntity->bOptionsNoJoins = TRUE;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 8
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN37@fnSqlRetri:

; 6633 :       }
; 6634 : 
; 6635 :       lpQualEntity->lpViewEntity         = lpViewEntity;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 6636 :       lpQualEntity->bUniqueQualification = TRUE;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 6637 :       lpQualEntity->bContainsSubselect   = FALSE;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 6638 : 
; 6639 :       // Retrieve all QualAttribs under the current EntitySpec.
; 6640 :       nRC = fnSqlRetrieveQualAttrib( lpView, lpViewOD,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlRetrieveQualAttrib
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 6641 :                                      lpQualView, lpQualEntity,
; 6642 :                                      &lpQualEntity->lpFirstQualAttrib,
; 6643 :                                      lpBoundList );
; 6644 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN39@fnSqlRetri

; 6645 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN46@fnSqlRetri
$LN39@fnSqlRetri:

; 6646 : 
; 6647 :       // If we are qualifying using a child entity or a subselect then we are
; 6648 :       // not qualifying using only the keys of the qual entity.
; 6649 :       if ( lpQualEntity->bQualUsesChildEntity ||

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 1
	jne	SHORT $LN41@fnSqlRetri
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN40@fnSqlRetri
$LN41@fnSqlRetri:

; 6650 :            lpQualEntity->bContainsSubselect )
; 6651 :       {
; 6652 :          lpQualEntity->bUniqueQualification = FALSE;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN40@fnSqlRetri:

; 6653 :       }
; 6654 : 
; 6655 :       // If we still think we are qualifying using only keys then let's check
; 6656 :       // to see if we are selecting by all the keys.  If the qualfication
; 6657 :       // contains an 'IS' oper then we don't have to worry about checking
; 6658 :       // because it automatically uses all the keys.
; 6659 :       if ( lpQualEntity->bUniqueQualification &&

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	shr	edx, 4
	and	edx, 1
	je	$LN42@fnSqlRetri
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	shr	ecx, 2
	and	ecx, 1
	jne	$LN42@fnSqlRetri

; 6660 :            lpQualEntity->bContainsIS == FALSE )
; 6661 :       {
; 6662 :          LPVIEWATTRIB lpViewAttrib;
; 6663 :          LPQUALATTRIB lpQualAttrib;
; 6664 : 
; 6665 :          // We already know that we're qualifying using only keys with 'AND'.
; 6666 :          // Now make sure that we have all the keys.
; 6667 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$7[ebp], eax
	jmp	SHORT $LN17@fnSqlRetri
$LN15@fnSqlRetri:

; 6669 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$7[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$7[ebp], eax
$LN17@fnSqlRetri:

; 6668 :                lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$7[ebp], 0
	je	SHORT $LN42@fnSqlRetri

; 6670 :          {
; 6671 :             // We only care about keys.
; 6672 :             if ( lpViewAttrib->bKey == FALSE )

	mov	eax, DWORD PTR _lpViewAttrib$7[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN43@fnSqlRetri

; 6673 :                continue;

	jmp	SHORT $LN15@fnSqlRetri
$LN43@fnSqlRetri:

; 6674 : 
; 6675 :             // Now see if there is a qual attrib for the key.
; 6676 :             for ( lpQualAttrib = lpQualEntity->lpFirstQualAttrib;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpQualAttrib$6[ebp], eax
	jmp	SHORT $LN20@fnSqlRetri
$LN18@fnSqlRetri:

; 6678 :                   lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$6[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _lpQualAttrib$6[ebp], edx
$LN20@fnSqlRetri:

; 6677 :                   lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$6[ebp], 0
	je	SHORT $LN19@fnSqlRetri

; 6679 :             {
; 6680 :                if ( lpQualAttrib->lpViewAttrib == lpViewAttrib )

	mov	eax, DWORD PTR _lpQualAttrib$6[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _lpViewAttrib$7[ebp]
	jne	SHORT $LN44@fnSqlRetri

; 6681 :                   break;

	jmp	SHORT $LN19@fnSqlRetri
$LN44@fnSqlRetri:

; 6682 :             }

	jmp	SHORT $LN18@fnSqlRetri
$LN19@fnSqlRetri:

; 6683 : 
; 6684 :             // If we didn't find qualification for the key then break.
; 6685 :             if ( lpQualAttrib == 0 )

	cmp	DWORD PTR _lpQualAttrib$6[ebp], 0
	jne	SHORT $LN45@fnSqlRetri

; 6686 :             {
; 6687 :                lpQualEntity->bUniqueQualification = FALSE;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 6688 :                break;

	jmp	SHORT $LN42@fnSqlRetri
$LN45@fnSqlRetri:

; 6689 :             }
; 6690 : 
; 6691 :          } // for ( lpViewAttrib )...

	jmp	$LN15@fnSqlRetri
$LN42@fnSqlRetri:

; 6692 :       }
; 6693 : 
; 6694 :    } // while ( nRC == zCURSOR_SET )...

	jmp	$LN2@fnSqlRetri
$LN3@fnSqlRetri:

; 6695 : 
; 6696 : #if 0  // Change 0 to 1 for debugging...
; 6697 :    // Display the QualEntity structure to trace.
; 6698 :    SqlDisplayQualEntity( *lpFirstQualEntity );
; 6699 : #endif
; 6700 : 
; 6701 :    return( 0 );

	xor	eax, eax
$LN46@fnSqlRetri:

; 6702 : }  /* fnSqlRetrieveQualObject */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlRetrieveQualObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
tv509 = -1500						; size = 4
_pl$1 = -1496						; size = 4
_lpSrcDataField$2 = -1492				; size = 4
tv1122 = -1488						; size = 4
_lpParent$3 = -1484					; size = 4
tv1064 = -1480						; size = 4
tv1024 = -1476						; size = 4
tv1023 = -1472						; size = 4
tv946 = -1468						; size = 4
tv945 = -1464						; size = 4
tv796 = -1460						; size = 4
tv659 = -1456						; size = 4
tv658 = -1452						; size = 4
_pchSrcViewName$ = -1448				; size = 4
_lKeyCount$4 = -1444					; size = 4
tv283 = -1440						; size = 4
tv282 = -1436						; size = 4
tv178 = -1432						; size = 4
tv177 = -1428						; size = 4
_hMem$ = -1424						; size = 4
_pchOper$ = -1420					; size = 4
_uLth$ = -1416						; size = 2
_lpSubQualView$5 = -1412				; size = 4
_pchSrcEntityName$ = -1408				; size = 4
_pchAttributeName$ = -1404				; size = 4
_lpSearchEntity$6 = -1400				; size = 4
_lpNewQualAttrib$7 = -1396				; size = 4
_lpRelField$8 = -1392					; size = 4
_pchSrcAttributeName$ = -1388				; size = 4
_pchPtr$ = -1384					; size = 4
_lpSourceView$ = -1380					; size = 4
_pchValue$ = -1376					; size = 4
_lpRelField$9 = -1372					; size = 4
_lpPrevQualAttrib$10 = -1368				; size = 4
_lpRelRecord$ = -1364					; size = 4
_lpSourceViewEntity$ = -1360				; size = 4
_bExists$11 = -1353					; size = 1
_k$12 = -1352						; size = 2
_pchAttEntityName$ = -1348				; size = 4
_lpDataRecord$ = -1344					; size = 4
_nParenCount$ = -1340					; size = 2
_bConvertNeeded$13 = -1336				; size = 1
_bQualUsesOR_Oper$ = -1335				; size = 1
_bContainsSubselect$14 = -1334				; size = 1
_bFirst$15 = -1333					; size = 1
_lpViewAttrib$ = -1332					; size = 4
_bUseLeftJoin$ = -1325					; size = 1
_lpDataField$ = -1324					; size = 4
_lpViewEntity$ = -1320					; size = 4
_bQualUsesChildEntity$ = -1313				; size = 1
_nRC$ = -1312						; size = 2
_lpQualAttrib$ = -1308					; size = 4
_szMsg$16 = -1304					; size = 500
_szMsg$17 = -804					; size = 500
_szStr$ = -304						; size = 300
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpQualView$ = 16					; size = 4
_lpQualEntity$ = 20					; size = 4
_lpFirstQualAttrib$ = 24				; size = 4
_lpBoundList$ = 28					; size = 4
_fnSqlRetrieveQualAttrib PROC

; 5333 :  {

	push	ebp
	mov	ebp, esp
	sub	esp, 1500				; 000005dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5334 :    zSHORT       nParenCount;
; 5335 :    zUSHORT      uLth;
; 5336 :    zLONG        hMem;
; 5337 :    zBOOL        bQualUsesChildEntity;
; 5338 :    zBOOL        bQualUsesOR_Oper = FALSE;

	mov	BYTE PTR _bQualUsesOR_Oper$[ebp], 0

; 5339 :    zBOOL        bUseLeftJoin = FALSE;

	mov	BYTE PTR _bUseLeftJoin$[ebp], 0

; 5340 :    zPCHAR       pchAttributeName, pchAttEntityName;
; 5341 :    zPCHAR       pchOper, pchValue, pchSrcAttributeName;
; 5342 :    zPCHAR       pchSrcEntityName, pchPtr;
; 5343 :    zPCHAR       pchSrcViewName;
; 5344 :    zCHAR        szStr[ 300 ];
; 5345 :    zVIEW        lpSourceView;
; 5346 :    LPQUALATTRIB lpQualAttrib;
; 5347 :    LPVIEWENTITY lpViewEntity;
; 5348 :    LPVIEWATTRIB lpViewAttrib;
; 5349 :    LPVIEWENTITY lpSourceViewEntity;
; 5350 :    LPDATARECORD lpDataRecord;
; 5351 :    LPDATAFIELD  lpDataField;
; 5352 :    LPRELRECORD  lpRelRecord;
; 5353 :    zSHORT       nRC;
; 5354 : 
; 5355 :    // Go through each of the QualAttrib entities for EntitySpec and
; 5356 :    // copy attribute data to QualAttrib records.
; 5357 :    //
; 5358 :    // Note that we process the QualAttrib entities by going BACKWARDS,
; 5359 :    // starting with the last entity.  This is done so that adding the
; 5360 :    // lpQualAttribs to the chain is simple--we add each one to the beginning
; 5361 :    // of the chain.
; 5362 : 
; 5363 :    // =================================================================
; 5364 :    // ===
; 5365 :    // === Retrieve each of the attributes in QualAttrib and copy them to
; 5366 :    // === the record lpQualAttrib.
; 5367 :    // ===
; 5368 :    // =================================================================
; 5369 : 
; 5370 :    if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_USEJOIN ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN39@fnSqlRetri
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	and	ecx, 33554432				; 02000000H
	je	SHORT $LN39@fnSqlRetri

; 5371 :       bUseLeftJoin = TRUE;

	mov	BYTE PTR _bUseLeftJoin$[ebp], 1
$LN39@fnSqlRetri:

; 5372 : 
; 5373 :    nParenCount = 0;

	xor	edx, edx
	mov	WORD PTR _nParenCount$[ebp], dx

; 5374 :    for ( nRC = SetCursorLastEntity( lpQualView, szlQualAttrib, "" );

	push	OFFSET $SG13569
	push	OFFSET _szlQualAttrib
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetCursorLastEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnSqlRetri
$LN2@fnSqlRetri:

; 5376 :          nRC = SetCursorPrevEntity( lpQualView, szlQualAttrib, "" ) )

	push	OFFSET $SG13570
	push	OFFSET _szlQualAttrib
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnSqlRetri:

; 5375 :          nRC == zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN3@fnSqlRetri

; 5377 :    {
; 5378 :       bQualUsesChildEntity = FALSE;

	mov	BYTE PTR _bQualUsesChildEntity$[ebp], 0

; 5379 : 
; 5380 :       // Allocate space for new QualAttrib record.
; 5381 :       hMem = SysAllocMemory( (zPVOID) &lpQualAttrib,

	push	0
	push	32768					; 00008000H
	push	0
	push	68					; 00000044H
	lea	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 5382 :                              sizeof( QualAttribRecord ), 0,
; 5383 :                              zCOREMEM_ALLOC, 0 );
; 5384 :       if ( lpQualAttrib == 0 )

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	jne	SHORT $LN40@fnSqlRetri

; 5385 :       {
; 5386 :          fnSqlDisplayQualMsg( lpView, lpQualView,

	push	0
	push	0
	push	OFFSET $SG13572
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5387 :                               "Cannot allocate memory",
; 5388 :                               zERROR, 0 );
; 5389 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN40@fnSqlRetri:

; 5390 :       }
; 5391 : 
; 5392 :       // Fill new QualAttrib with zeros.
; 5393 :       zmemset( (zPVOID) lpQualAttrib, 0, sizeof( QualAttribRecord ) );

	push	68					; 00000044H
	push	0
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5394 :       lpQualAttrib->hMem = hMem;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [ecx], edx

; 5395 : 
; 5396 :       // Add lpQualAttrib as first qual attrib in chain.
; 5397 :       lpQualAttrib->lpNextQualAttrib = *lpFirstQualAttrib;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 5398 :       *lpFirstQualAttrib = lpQualAttrib;

	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [eax], ecx

; 5399 : 
; 5400 :       // ===
; 5401 :       // ===  QualAttrib.Oper
; 5402 :       // ===
; 5403 : 
; 5404 :       // All Qual attribs must have an Oper.
; 5405 :       GetAddrForAttribute( &pchOper, lpQualView, szlQualAttrib, "Oper" );

	push	OFFSET $SG13573
	push	OFFSET _szlQualAttrib
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchOper$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 5406 :       if ( pchOper[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchOper$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN41@fnSqlRetri

; 5407 :       {
; 5408 :          fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13575
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5409 :                               "QualAttrib does not have an operation defined. "
; 5410 :                               " Oper is a required attribute.",
; 5411 :                               zERROR, szlQualAttrib );
; 5412 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN41@fnSqlRetri:

; 5413 :       }
; 5414 : 
; 5415 :       // Oper was found--go through and count parens.
; 5416 :       pchPtr = pchOper;

	mov	ecx, DWORD PTR _pchOper$[ebp]
	mov	DWORD PTR _pchPtr$[ebp], ecx
$LN5@fnSqlRetri:

; 5417 :       while ( *pchPtr )

	mov	edx, DWORD PTR _pchPtr$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@fnSqlRetri

; 5418 :       {
; 5419 :          if ( *pchPtr == '(' )

	mov	ecx, DWORD PTR _pchPtr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 40					; 00000028H
	jne	SHORT $LN42@fnSqlRetri

; 5420 :             nParenCount++;

	mov	ax, WORD PTR _nParenCount$[ebp]
	add	ax, 1
	mov	WORD PTR _nParenCount$[ebp], ax
	jmp	SHORT $LN43@fnSqlRetri
$LN42@fnSqlRetri:

; 5421 :          else
; 5422 :          if ( *pchPtr == ')' )

	mov	ecx, DWORD PTR _pchPtr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $LN43@fnSqlRetri

; 5423 :             nParenCount--;

	mov	ax, WORD PTR _nParenCount$[ebp]
	sub	ax, 1
	mov	WORD PTR _nParenCount$[ebp], ax
$LN43@fnSqlRetri:

; 5424 : 
; 5425 :          pchPtr++;

	mov	ecx, DWORD PTR _pchPtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchPtr$[ebp], ecx

; 5426 :       }

	jmp	SHORT $LN5@fnSqlRetri
$LN6@fnSqlRetri:

; 5427 : 
; 5428 :       fnAllocOper( lpQualAttrib, pchOper );

	mov	edx, DWORD PTR _pchOper$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	call	_fnAllocOper
	add	esp, 8

; 5429 :       zstrtrim( lpQualAttrib->szOper );

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_zstrtrim
	add	esp, 4

; 5430 : 
; 5431 :       if ( zstrcmpi( lpQualAttrib->szOper, "OR" ) == 0 )

	push	OFFSET $SG13580
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN45@fnSqlRetri

; 5432 :       {
; 5433 :          bQualUsesOR_Oper = TRUE;

	mov	BYTE PTR _bQualUsesOR_Oper$[ebp], 1

; 5434 :          lpQualEntity->bUniqueQualification = FALSE;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax
$LN45@fnSqlRetri:

; 5435 :       }
; 5436 : 
; 5437 :       // ===
; 5438 :       // ===  QualAttrib.EntityName
; 5439 :       // ===
; 5440 : 
; 5441 :       GetAddrForAttribute( &pchAttEntityName, lpQualView, szlQualAttrib,

	push	OFFSET $SG13581
	push	OFFSET _szlQualAttrib
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttEntityName$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 5442 :                            "EntityName" );
; 5443 :       if ( *pchAttEntityName )

	mov	ecx, DWORD PTR _pchAttEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN46@fnSqlRetri

; 5444 :       {
; 5445 :          LPVIEWENTITY lpSearchEntity;
; 5446 : 
; 5447 :          if ( zstrcmp( pchAttEntityName, "*root*" ) == 0 )

	mov	eax, DWORD PTR _pchAttEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13585
	cmp	ecx, edx
	jne	SHORT $LN158@fnSqlRetri
	push	OFFSET $SG13586
	mov	eax, DWORD PTR _pchAttEntityName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv178[ebp], eax
	jmp	SHORT $LN159@fnSqlRetri
$LN158@fnSqlRetri:
	mov	ecx, DWORD PTR _pchAttEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG13587
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN156@fnSqlRetri
	mov	DWORD PTR tv177[ebp], 1
	jmp	SHORT $LN157@fnSqlRetri
$LN156@fnSqlRetri:
	mov	DWORD PTR tv177[ebp], -1
$LN157@fnSqlRetri:
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR tv178[ebp], ecx
$LN159@fnSqlRetri:
	cmp	DWORD PTR tv178[ebp], 0
	jne	SHORT $LN47@fnSqlRetri

; 5448 :          {
; 5449 :             // User specified they want to use the root.  Just get the entity
; 5450 :             // name.
; 5451 :             lpViewEntity = (LPVIEWENTITY) zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5452 :          }

	jmp	SHORT $LN48@fnSqlRetri
$LN47@fnSqlRetri:

; 5453 :          else
; 5454 :             // Find the view entity that matches entity name.
; 5455 :             lpViewEntity = MiGetViewEntityForView( lpView, pchAttEntityName );

	mov	ecx, DWORD PTR _pchAttEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN48@fnSqlRetri:

; 5456 : 
; 5457 :          // If no view entity was found to match entity name in qual entity
; 5458 :          // then issue an error and exit.
; 5459 :          if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN49@fnSqlRetri

; 5460 :          {
; 5461 :             zsprintf( szStr, "Entity '%s' was specified in the Qualification "

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchAttEntityName$[ebp]
	push	ecx
	push	OFFSET $SG13589
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 5462 :                       "object but does not exist in LOD '%s'",
; 5463 :                       pchAttEntityName, lpViewOD->szName );
; 5464 :             fnSqlDisplayQualMsg( lpView, lpQualView, szStr,

	push	OFFSET _szlQualAttrib
	push	0
	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5465 :                                  zERROR, szlQualAttrib );
; 5466 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN49@fnSqlRetri:

; 5467 :          }
; 5468 : 
; 5469 :          // Make sure the entity is a valid one.
; 5470 :          if ( lpViewEntity->bDerived || lpViewEntity->bDerivedPath ||

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	SHORT $LN51@fnSqlRetri
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	jne	SHORT $LN51@fnSqlRetri
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+191], 0
	jne	SHORT $LN50@fnSqlRetri
$LN51@fnSqlRetri:

; 5471 :               lpViewEntity->hFirstDataRecord == 0 )
; 5472 :          {
; 5473 :             zCHAR szMsg[ 500 ];
; 5474 : 
; 5475 :             zsprintf( szMsg, "Entity '%s' in Object '%s' is a work or derived entity "

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _pchAttEntityName$[ebp]
	push	eax
	push	OFFSET $SG13592
	lea	ecx, DWORD PTR _szMsg$16[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 5476 :                       "and is not allowed for entity qualification during an "
; 5477 :                       "Activate", pchAttEntityName, lpViewOD->szName );
; 5478 :             fnSqlDisplayQualMsg( lpView, lpQualView, szMsg,

	push	OFFSET _szlEntitySpec
	push	0
	lea	edx, DWORD PTR _szMsg$16[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5479 :                                  zERROR, szlEntitySpec );
; 5480 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN50@fnSqlRetri:

; 5481 :          }
; 5482 : 
; 5483 :          // This entity had better be a child of the entity we are
; 5484 :          // qualifying.
; 5485 :          for ( lpSearchEntity = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpSearchEntity$6[ebp], edx
	jmp	SHORT $LN9@fnSqlRetri
$LN7@fnSqlRetri:

; 5487 :                lpSearchEntity = zGETPTR( lpSearchEntity->hParent ) )

	mov	eax, DWORD PTR _lpSearchEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSearchEntity$6[ebp], eax
$LN9@fnSqlRetri:

; 5486 :                lpSearchEntity != lpQualEntity->lpViewEntity;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR _lpSearchEntity$6[ebp]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN8@fnSqlRetri

; 5488 :          {
; 5489 :             if ( lpSearchEntity->hParent == 0 )

	mov	ecx, DWORD PTR _lpSearchEntity$6[ebp]
	cmp	DWORD PTR [ecx+10], 0
	jne	SHORT $LN52@fnSqlRetri

; 5490 :             {
; 5491 :                // Oops.  lpSearchEntity is the root entity of the LOD but
; 5492 :                // we haven't found a match with lpQualEntity->lpViewEntity.
; 5493 :                // Illegal qual.
; 5494 :                zCHAR szMsg[ 500 ];
; 5495 : 
; 5496 :                zsprintf( szMsg, "You cannot qualify entity '%s' using entity "

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _pchAttEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13594
	lea	eax, DWORD PTR _szMsg$17[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 5497 :                          "'%s' in Object Definition '%s'.  Only child entities "
; 5498 :                          "may be used for qualification.",
; 5499 :                          lpQualEntity->lpViewEntity->szName,
; 5500 :                          pchAttEntityName, lpViewOD->szName );
; 5501 :                fnSqlDisplayQualMsg( lpView, lpQualView, szMsg,

	push	OFFSET _szlEntitySpec
	push	0
	lea	ecx, DWORD PTR _szMsg$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5502 :                                     zERROR, szlEntitySpec );
; 5503 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN52@fnSqlRetri:

; 5504 :             }
; 5505 :          }

	jmp	$LN7@fnSqlRetri
$LN8@fnSqlRetri:

; 5506 : 
; 5507 :          // If the entity name for the attribute is not the same as the
; 5508 :          // entity name of the qual entity then the qualification uses
; 5509 :          // child entities.
; 5510 :          if ( lpQualEntity->lpViewEntity &&

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN53@fnSqlRetri
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN53@fnSqlRetri

; 5511 :               lpQualEntity->lpViewEntity != lpViewEntity )
; 5512 :             bQualUsesChildEntity = TRUE;

	mov	BYTE PTR _bQualUsesChildEntity$[ebp], 1
$LN53@fnSqlRetri:

; 5513 : 
; 5514 :          lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 5515 :          lpQualAttrib->lpViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5516 :          lpQualAttrib->lpDataRecord = lpDataRecord;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN46@fnSqlRetri:

; 5517 : 
; 5518 :       } // if ( *pchAttEntityName )...
; 5519 : 
; 5520 :       // ===
; 5521 :       // ===  QualAttrib.AttributeName
; 5522 :       // ===
; 5523 : 
; 5524 :       GetAddrForAttribute( &pchAttributeName, lpQualView, szlQualAttrib,

	push	OFFSET $SG13596
	push	OFFSET _szlQualAttrib
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchAttributeName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 5525 :                            "AttributeName" );
; 5526 :       if ( *pchAttributeName )

	mov	eax, DWORD PTR _pchAttributeName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN54@fnSqlRetri

; 5527 :       {
; 5528 :          // If QualAttrib entity has an AttributeName then QualAttrib
; 5529 :          // must also have a valid EntityName.
; 5530 :          if ( lpQualAttrib->lpViewEntity == 0 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN55@fnSqlRetri

; 5531 :          {
; 5532 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13599
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5533 :                                  "QualAttrib entity has AttributeName but "
; 5534 :                                  "doesn't have EntityName.",
; 5535 :                                  zERROR, szlQualAttrib );
; 5536 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN55@fnSqlRetri:

; 5537 :          }
; 5538 : 
; 5539 :          // Find the lpViewAttrib and DataField that matches AttribName.
; 5540 :          for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN12@fnSqlRetri
$LN10@fnSqlRetri:

; 5542 :                lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN12@fnSqlRetri:

; 5541 :                lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN11@fnSqlRetri

; 5543 :          {
; 5544 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 5545 : 
; 5546 :             if ( zstrcmp( lpViewAttrib->szName, pchAttributeName ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _pchAttributeName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN162@fnSqlRetri
	mov	eax, DWORD PTR _pchAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv283[ebp], eax
	jmp	SHORT $LN163@fnSqlRetri
$LN162@fnSqlRetri:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _pchAttributeName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN160@fnSqlRetri
	mov	DWORD PTR tv282[ebp], 1
	jmp	SHORT $LN161@fnSqlRetri
$LN160@fnSqlRetri:
	mov	DWORD PTR tv282[ebp], -1
$LN161@fnSqlRetri:
	mov	eax, DWORD PTR tv282[ebp]
	mov	DWORD PTR tv283[ebp], eax
$LN163@fnSqlRetri:
	cmp	DWORD PTR tv283[ebp], 0
	jne	SHORT $LN56@fnSqlRetri

; 5547 :                break;

	jmp	SHORT $LN11@fnSqlRetri
$LN56@fnSqlRetri:

; 5548 :          }

	jmp	$LN10@fnSqlRetri
$LN11@fnSqlRetri:

; 5549 : 
; 5550 :          // If no view entity was found to match entity name in qual
; 5551 :          // entity then issue an error and exit.
; 5552 :          if ( lpDataField == 0 )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	jne	SHORT $LN57@fnSqlRetri

; 5553 :          {
; 5554 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13602
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5555 :                                  "AttributeName in QualAttrib not found in "
; 5556 :                                  "in target object definition.",
; 5557 :                                  zERROR, szlQualAttrib );
; 5558 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN57@fnSqlRetri:

; 5559 :          }
; 5560 : 
; 5561 :          // In some cases, we might be qualifying an entity using an attribute
; 5562 :          // from a child entity.  If the child attribute is a key AND that key
; 5563 :          // is the source attribute for a many-to-one relationship then the
; 5564 :          // attribute's value is also stored in the parent entity (the entity
; 5565 :          // we are qualifying) as a foreign key.  It will be much quicker to
; 5566 :          // perform qualification on just the foreign key, so change the
; 5567 :          // qualification to reference the foreign key.
; 5568 :          lpRelRecord = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax
$LN13@fnSqlRetri:

; 5569 :          while ( lpViewAttrib->bKey &&
; 5570 :                  lpQualAttrib->lpViewEntity != lpQualEntity->lpViewEntity &&
; 5571 :                  lpRelRecord &&

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	je	$LN14@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	je	$LN14@fnSqlRetri
	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	$LN14@fnSqlRetri
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	edx, 77					; 0000004dH
	jne	$LN14@fnSqlRetri

; 5572 :                  lpRelRecord->cOwnerMember == zDBH_CHILD_IS_SOURCE )
; 5573 :          {
; 5574 :             LPRELFIELD   lpRelField;
; 5575 : 
; 5576 :             // Find the rel field for the qualifying attribute.
; 5577 :             for ( lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
	jmp	SHORT $LN17@fnSqlRetri
$LN15@fnSqlRetri:

; 5579 :                   lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	edx, DWORD PTR _lpRelField$9[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
$LN17@fnSqlRetri:

; 5578 :                   lpRelField;

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	je	SHORT $LN16@fnSqlRetri

; 5580 :             {
; 5581 :                LPDATAFIELD lpSrcDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	ecx, DWORD PTR _lpRelField$9[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$2[ebp], eax

; 5582 : 
; 5583 :                if ( lpSrcDataField->hViewAttrib == lpDataField->hViewAttrib )

	mov	eax, DWORD PTR _lpSrcDataField$2[ebp]
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [eax+6]
	cmp	edx, DWORD PTR [ecx+6]
	jne	SHORT $LN58@fnSqlRetri

; 5584 :                   break;

	jmp	SHORT $LN16@fnSqlRetri
$LN58@fnSqlRetri:

; 5585 :             }

	jmp	SHORT $LN15@fnSqlRetri
$LN16@fnSqlRetri:

; 5586 : 
; 5587 :             if ( lpRelField == 0 )

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	jne	SHORT $LN59@fnSqlRetri

; 5588 :             {
; 5589 :                fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13605
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5590 :                                     "Internal error #10--can't find RelRecord",
; 5591 :                                     zERROR, szlQualAttrib );
; 5592 :                break;

	jmp	$LN14@fnSqlRetri
$LN59@fnSqlRetri:

; 5593 :             }
; 5594 : 
; 5595 :             // Change the column we are qualifying on.
; 5596 :             lpDataField  = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$9[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 5597 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 5598 :             lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5599 :             lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 5600 :             lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 5601 : 
; 5602 :             lpQualAttrib->lpViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 5603 :             lpQualAttrib->lpDataRecord = lpDataRecord;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	DWORD PTR [edx+16], eax

; 5604 : 
; 5605 :             // If the entity name for the attribute is not the same as the
; 5606 :             // entity name of the qual entity then the qualification uses
; 5607 :             // child entities.  If we're here then we know that the entity
; 5608 :             // for the QualAttrib is not the same as the entity for
; 5609 :             // QualEntity (which means that bQualUsesChildEntity = TRUE).
; 5610 :             // Check to see if we should turn it back off.
; 5611 :             if ( lpQualEntity->lpViewEntity == lpViewEntity )

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN60@fnSqlRetri

; 5612 :                bQualUsesChildEntity = FALSE;

	mov	BYTE PTR _bQualUsesChildEntity$[ebp], 0
$LN60@fnSqlRetri:

; 5613 : 
; 5614 :          } // while...

	jmp	$LN13@fnSqlRetri
$LN14@fnSqlRetri:

; 5615 : 
; 5616 :          lpQualAttrib->lpDataField  = lpDataField;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 5617 :          lpQualAttrib->lpViewAttrib = lpViewAttrib;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+20], eax

; 5618 :          if ( lpViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN54@fnSqlRetri

; 5619 :             lpQualEntity->bUniqueQualification = FALSE;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN54@fnSqlRetri:

; 5620 : 
; 5621 :       } // if ( *pchAttributeName )...
; 5622 : 
; 5623 :       // ===
; 5624 :       // ===  QualAttrib.Value
; 5625 :       // ===
; 5626 : 
; 5627 :       GetAddrForAttribute( &pchValue, lpQualView, szlQualAttrib, "Value" );

	push	OFFSET $SG13608
	push	OFFSET _szlQualAttrib
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchValue$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 5628 :       if ( *pchValue )

	mov	edx, DWORD PTR _pchValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN62@fnSqlRetri

; 5629 :       {
; 5630 :          // If Value is defined then QualAttrib must also have AttribName.
; 5631 :          if ( lpQualAttrib->lpDataField == 0 )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN63@fnSqlRetri

; 5632 :          {
; 5633 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13611
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5634 :                                  "QualAttrib entity has Value but doesn't "
; 5635 :                                  "have AttributeName.",
; 5636 :                                  zERROR, szlQualAttrib );
; 5637 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN63@fnSqlRetri:

; 5638 :          }
; 5639 : 
; 5640 :          // If Attribute is a date/time, convert pchValue to YYYYMMDDHHMMSSTTT.
; 5641 :          if ( lpQualAttrib->lpDataField->cFldType == zTYPE_DATETIME ||
; 5642 :               lpQualAttrib->lpDataField->cFldType == zTYPE_DATE     ||

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 84					; 00000054H
	je	SHORT $LN65@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 68					; 00000044H
	je	SHORT $LN65@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 73					; 00000049H
	jne	SHORT $LN64@fnSqlRetri
$LN65@fnSqlRetri:

; 5643 :               lpQualAttrib->lpDataField->cFldType == zTYPE_TIME )
; 5644 :          {
; 5645 :             if ( fnSqlUnformatDateTimeString( szStr, pchValue ) < 0 )

	mov	ecx, DWORD PTR _pchValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_fnSqlUnformatDateTimeString
	add	esp, 8
	cwde
	test	eax, eax
	jge	SHORT $LN66@fnSqlRetri

; 5646 :             {
; 5647 :                fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13615
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5648 :                                     "QualAttrib Value invalid for DateTime.",
; 5649 :                                     zERROR, szlQualAttrib );
; 5650 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN66@fnSqlRetri:

; 5651 :             }
; 5652 : 
; 5653 :             // Set pchValue to point to unformatted string.
; 5654 :             pchValue = szStr;

	lea	eax, DWORD PTR _szStr$[ebp]
	mov	DWORD PTR _pchValue$[ebp], eax
$LN64@fnSqlRetri:

; 5655 :          }
; 5656 : 
; 5657 :          uLth = zstrlen( pchValue ) + 1;

	mov	ecx, DWORD PTR _pchValue$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	WORD PTR _uLth$[ebp], ax

; 5658 :          hMem = SysAllocMemory( (zPVOID) &lpQualAttrib->szValue,

	push	0
	push	32768					; 00008000H
	push	0
	movzx	edx, WORD PTR _uLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 5659 :                                 uLth, 0, zCOREMEM_ALLOC, 0 );
; 5660 :          if ( lpQualAttrib->szValue == 0 )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN67@fnSqlRetri

; 5661 :          {
; 5662 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	0
	push	0
	push	OFFSET $SG13617
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5663 :                                  "Cannot allocate memory.", zERROR, 0 );
; 5664 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN67@fnSqlRetri:

; 5665 :          }
; 5666 : 
; 5667 :          lpQualAttrib->hValueMem = hMem;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [ecx+36], edx

; 5668 :          zstrcpy( lpQualAttrib->szValue, pchValue );

	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	_strcpy
	add	esp, 8
$LN62@fnSqlRetri:

; 5669 : 
; 5670 :       } // if ( *pchValue )...
; 5671 : 
; 5672 :       // ===
; 5673 :       // ===  Check for KeyList entities.
; 5674 :       // ===
; 5675 :       if ( CheckExistenceOfEntity( lpQualView, "KeyList" ) >= zCURSOR_SET )

	push	OFFSET $SG13619
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jl	$LN68@fnSqlRetri

; 5676 :       {
; 5677 :          zLONG  lKeyCount;
; 5678 :          zPLONG pl;
; 5679 :          zSHORT k;
; 5680 : 
; 5681 :          if ( *pchValue )

	mov	edx, DWORD PTR _pchValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN69@fnSqlRetri

; 5682 :          {
; 5683 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13621
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5684 :                                  "Cannot specify 'Value' and 'KeyList' on the same "
; 5685 :                                  "QualAttrib.",
; 5686 :                                  zERROR, szlQualAttrib );
; 5687 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN69@fnSqlRetri:

; 5688 :          }
; 5689 : 
; 5690 :          // If KeyList is defined then QualAttrib must also have AttribName.
; 5691 :          if ( lpQualAttrib->lpDataField == 0 )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN70@fnSqlRetri

; 5692 :          {
; 5693 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13623
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5694 :                                  "QualAttrib entity has KeyList but doesn't "
; 5695 :                                  "have AttributeName.",
; 5696 :                                  zERROR, szlQualAttrib );
; 5697 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN70@fnSqlRetri:

; 5698 :          }
; 5699 : 
; 5700 :          if ( lpQualAttrib->lpDataField->cFldType != zTYPE_INTEGER )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	movsx	edx, BYTE PTR [ecx+270]
	cmp	edx, 76					; 0000004cH
	je	SHORT $LN71@fnSqlRetri

; 5701 :          {
; 5702 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13625
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5703 :                                  "The only datatypes supported with KeyList is "
; 5704 :                                  "Integer.",
; 5705 :                                  zERROR, szlQualAttrib );
; 5706 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN71@fnSqlRetri:

; 5707 :          }
; 5708 : 
; 5709 :          // We only support one keylist at the moment.
; 5710 :          if ( lpQualEntity->bContainsKeyList )

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN72@fnSqlRetri

; 5711 :          {
; 5712 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13627
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5713 :                                  "Only one QualAttrib is allowed to have a KeyList "
; 5714 :                                  "specified under each QualEntity.",
; 5715 :                                  zERROR, szlQualAttrib );
; 5716 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN72@fnSqlRetri:

; 5717 :          }
; 5718 : 
; 5719 :          // Get the number of entities in the key list.
; 5720 :          lKeyCount = CountEntitiesForView( lpQualView, "KeyList" );

	push	OFFSET $SG13628
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CountEntitiesForView@8
	mov	DWORD PTR _lKeyCount$4[ebp], eax

; 5721 : 
; 5722 :          // Alloc space to hold the keys.
; 5723 :          lpQualAttrib->lpKeyList = malloc( lKeyCount * sizeof( zLONG ) );

	mov	ecx, DWORD PTR _lKeyCount$4[ebp]
	shl	ecx, 2
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [edx+44], eax

; 5724 :          lpQualAttrib->lKeyCount = lKeyCount;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lKeyCount$4[ebp]
	mov	DWORD PTR [eax+48], ecx

; 5725 :          pl = (zPLONG) lpQualAttrib->lpKeyList;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR _pl$1[ebp], eax

; 5726 : 
; 5727 :          // Copy the keys to the table.
; 5728 :          k = 0;

	xor	ecx, ecx
	mov	WORD PTR _k$12[ebp], cx

; 5729 :          for ( nRC = SetCursorFirstEntity( lpQualView, "KeyList", 0 );

	push	0
	push	OFFSET $SG13629
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN20@fnSqlRetri
$LN18@fnSqlRetri:

; 5731 :                nRC = SetCursorNextEntity( lpQualView, "KeyList", 0 ) )

	push	0
	push	OFFSET $SG13630
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN20@fnSqlRetri:

; 5730 :                nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $LN19@fnSqlRetri

; 5732 :          {
; 5733 :             GetIntegerFromAttribute( &pl[ k++ ], lpQualView, "KeyList",

	movsx	edx, WORD PTR _k$12[ebp]
	mov	eax, DWORD PTR _pl$1[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv509[ebp], ecx
	push	OFFSET $SG13631
	push	OFFSET $SG13632
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR tv509[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	mov	cx, WORD PTR _k$12[ebp]
	add	cx, 1
	mov	WORD PTR _k$12[ebp], cx

; 5734 :                                      "IntegerValue" );
; 5735 :          }

	jmp	SHORT $LN18@fnSqlRetri
$LN19@fnSqlRetri:

; 5736 : 
; 5737 :          lpQualEntity->bContainsKeyList = TRUE;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax
$LN68@fnSqlRetri:

; 5738 :       }
; 5739 : 
; 5740 :       // ===
; 5741 :       // ===  QualAttrib.SourceViewName/SourceViewID
; 5742 :       // ===
; 5743 : 
; 5744 :       GetAddrForAttribute( &pchSrcViewName, lpQualView, szlQualAttrib,

	push	OFFSET $SG13633
	push	OFFSET _szlQualAttrib
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSrcViewName$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 5745 :                            "SourceViewName" );
; 5746 :       if ( *pchSrcViewName )

	mov	ecx, DWORD PTR _pchSrcViewName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN73@fnSqlRetri

; 5747 :       {
; 5748 :          GetViewByName( &lpSourceView, pchSrcViewName, lpQualView,

	push	2
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchSrcViewName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSourceView$[ebp]
	push	edx
	call	_GetViewByName@16

; 5749 :                         zLEVEL_TASK );
; 5750 :          if ( lpSourceView )

	cmp	DWORD PTR _lpSourceView$[ebp], 0
	je	SHORT $LN75@fnSqlRetri

; 5751 :          {
; 5752 :             lpQualAttrib->lpSourceView = lpSourceView;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpSourceView$[ebp]
	mov	DWORD PTR [eax+60], ecx

; 5753 :             SetAttributeFromInteger( lpQualView, szlQualAttrib,

	mov	edx, DWORD PTR _lpSourceView$[ebp]
	push	edx
	push	OFFSET $SG13638
	push	OFFSET _szlQualAttrib
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 5754 :                                      "SourceViewID", (zLONG) lpSourceView );
; 5755 :          }

	jmp	SHORT $LN76@fnSqlRetri
$LN75@fnSqlRetri:

; 5756 :          else
; 5757 :          {
; 5758 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13639
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5759 :                                  "SourceViewName not found at TASK level.",
; 5760 :                                  zERROR, szlQualAttrib );
; 5761 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN76@fnSqlRetri:

; 5762 :          }
; 5763 :       }

	jmp	SHORT $LN74@fnSqlRetri
$LN73@fnSqlRetri:

; 5764 :       else
; 5765 :       {
; 5766 :          // SourceViewName was not specified--see if SourceViewID was.
; 5767 :          GetIntegerFromAttribute( (zPLONG) &lpSourceView, lpQualView,

	push	OFFSET $SG13640
	push	OFFSET _szlQualAttrib
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSourceView$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 5768 :                                   szlQualAttrib, "SourceViewID" );
; 5769 :          if ( lpSourceView )

	cmp	DWORD PTR _lpSourceView$[ebp], 0
	je	SHORT $LN74@fnSqlRetri

; 5770 :             lpQualAttrib->lpSourceView = lpSourceView;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpSourceView$[ebp]
	mov	DWORD PTR [edx+60], eax
$LN74@fnSqlRetri:

; 5771 :       }
; 5772 : 
; 5773 :       // ===
; 5774 :       // ===  QualAttrib.SourceEntityName
; 5775 :       // ===
; 5776 : 
; 5777 :       GetAddrForAttribute( &pchSrcEntityName, lpQualView,

	push	OFFSET $SG13642
	push	OFFSET _szlQualAttrib
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchSrcEntityName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 5778 :                            szlQualAttrib, "SourceEntityName" );
; 5779 :       lpSourceViewEntity = 0;

	mov	DWORD PTR _lpSourceViewEntity$[ebp], 0

; 5780 :       if ( *pchSrcEntityName )

	mov	eax, DWORD PTR _pchSrcEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN78@fnSqlRetri

; 5781 :       {
; 5782 :          // Find the lpViewEntity for source attrib entity.
; 5783 :          if ( lpQualAttrib->lpSourceView )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN79@fnSqlRetri

; 5784 :             lpSourceViewEntity =

	mov	eax, DWORD PTR _pchSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpSourceViewEntity$[ebp], eax
	jmp	SHORT $LN80@fnSqlRetri
$LN79@fnSqlRetri:

; 5785 :                         MiGetViewEntityForView( lpQualAttrib->lpSourceView,
; 5786 :                                                 pchSrcEntityName );
; 5787 :          else
; 5788 :             lpSourceViewEntity =

	mov	eax, DWORD PTR _pchSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpSourceViewEntity$[ebp], eax
$LN80@fnSqlRetri:

; 5789 :                         MiGetViewEntityForView( lpView, pchSrcEntityName );
; 5790 : 
; 5791 :          // If no view entity was found to match the entity name
; 5792 :          // then issue an error and exit.
; 5793 :          if ( lpSourceViewEntity == 0 )

	cmp	DWORD PTR _lpSourceViewEntity$[ebp], 0
	jne	SHORT $LN81@fnSqlRetri

; 5794 :          {
; 5795 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13647
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5796 :                                  "Attribute SourceEntityName not found in "
; 5797 :                                  "target object defintion.",
; 5798 :                                  zERROR, szlQualAttrib );
; 5799 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN81@fnSqlRetri:

; 5800 :          }
; 5801 : 
; 5802 :          // If lpSourceView is defined then make sure that the
; 5803 :          // SourceViewEntity entity is defined.
; 5804 :          if ( lpQualAttrib->lpSourceView )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN82@fnSqlRetri

; 5805 :          {
; 5806 :             nRC = CheckExistenceOfEntity( lpQualAttrib->lpSourceView,

	mov	edx, DWORD PTR _lpSourceViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	_CheckExistenceOfEntity@8
	mov	WORD PTR _nRC$[ebp], ax

; 5807 :                                           lpSourceViewEntity->szName );
; 5808 :             if ( nRC != zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN84@fnSqlRetri

; 5809 :             {
; 5810 :                fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13651
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5811 :                                     "Cursor is not set properly in the Source "
; 5812 :                                     "View specified in QualAttrib.",
; 5813 :                                     zERROR, szlQualAttrib );
; 5814 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN84@fnSqlRetri:

; 5815 :             }
; 5816 :          }

	jmp	SHORT $LN83@fnSqlRetri
$LN82@fnSqlRetri:

; 5817 :          // lpSourceView is not defined--the Source View Entity
; 5818 :          // is the view we will activate later.
; 5819 :          // Make sure that lpSourceViewEntity comes before entity spec in
; 5820 :          // hierarchical order.
; 5821 :          else
; 5822 :          if ( lpSourceViewEntity->nHierNbr >

	mov	edx, DWORD PTR _lpSourceViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	movsx	ecx, WORD PTR [edx+217]
	cmp	eax, ecx
	jle	SHORT $LN83@fnSqlRetri

; 5823 :                                        lpQualEntity->lpViewEntity->nHierNbr )
; 5824 :          {
; 5825 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13653
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5826 :                                  "SourceEntityName does not have hierarchical "
; 5827 :                                  "precidence over EntityName in EntitySpec.",
; 5828 :                                  zERROR, szlQualAttrib );
; 5829 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN83@fnSqlRetri:

; 5830 :          }
; 5831 : 
; 5832 :          lpQualAttrib->lpSourceViewEntity = lpSourceViewEntity;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _lpSourceViewEntity$[ebp]
	mov	DWORD PTR [ecx+52], edx
$LN78@fnSqlRetri:

; 5833 :       } // if ( *pchSrcEntityName )...
; 5834 : 
; 5835 :       // ===
; 5836 :       // ===  QualAttrib.SourceAttributeName
; 5837 :       // ===
; 5838 : 
; 5839 :       GetAddrForAttribute( &pchSrcAttributeName, lpQualView,

	push	OFFSET $SG13654
	push	OFFSET _szlQualAttrib
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchSrcAttributeName$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 5840 :                            szlQualAttrib, "SourceAttributeName" );
; 5841 :       if ( *pchSrcAttributeName )

	mov	edx, DWORD PTR _pchSrcAttributeName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN86@fnSqlRetri

; 5842 :       {
; 5843 :          if ( lpQualAttrib->lpSourceViewEntity == 0 )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	jne	SHORT $LN87@fnSqlRetri

; 5844 :          {
; 5845 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13657
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5846 :                                  "QualAttrib has SourceAttributeName but "
; 5847 :                                  "doesn't have SourceEntityName.",
; 5848 :                                  zERROR, szlQualAttrib );
; 5849 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN87@fnSqlRetri:

; 5850 :          }
; 5851 : 
; 5852 :          // Find the lpViewAttrib and DataField that matches
; 5853 :          // SourceAttributeName.
; 5854 :          lpDataRecord = zGETPTR( lpSourceViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpSourceViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 5855 :          for ( lpDataField  = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN23@fnSqlRetri
$LN21@fnSqlRetri:

; 5857 :                lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN23@fnSqlRetri:

; 5856 :                lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN22@fnSqlRetri

; 5858 :          {
; 5859 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 5860 : 
; 5861 :             if ( zstrcmp( lpViewAttrib->szName, pchSrcAttributeName ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchSrcAttributeName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN166@fnSqlRetri
	mov	ecx, DWORD PTR _pchSrcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv659[ebp], eax
	jmp	SHORT $LN167@fnSqlRetri
$LN166@fnSqlRetri:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchSrcAttributeName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN164@fnSqlRetri
	mov	DWORD PTR tv658[ebp], 1
	jmp	SHORT $LN165@fnSqlRetri
$LN164@fnSqlRetri:
	mov	DWORD PTR tv658[ebp], -1
$LN165@fnSqlRetri:
	mov	ecx, DWORD PTR tv658[ebp]
	mov	DWORD PTR tv659[ebp], ecx
$LN167@fnSqlRetri:
	cmp	DWORD PTR tv659[ebp], 0
	jne	SHORT $LN88@fnSqlRetri

; 5862 :                break;

	jmp	SHORT $LN22@fnSqlRetri
$LN88@fnSqlRetri:

; 5863 :          }

	jmp	$LN21@fnSqlRetri
$LN22@fnSqlRetri:

; 5864 : 
; 5865 :          // If no data field was found to match source attribute name in
; 5866 :          // target entity then issue an error and exit.
; 5867 :          if ( lpDataField == 0 )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	jne	SHORT $LN89@fnSqlRetri

; 5868 :          {
; 5869 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13660
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5870 :                                  "SourceAttributeName in QualAttrib not found "
; 5871 :                                  "in target object definition.",
; 5872 :                                  zERROR, szlQualAttrib );
; 5873 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN89@fnSqlRetri:

; 5874 :          }
; 5875 : 
; 5876 :          lpQualAttrib->lpSourceDataField = lpDataField;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR [ecx+56], edx
$LN86@fnSqlRetri:

; 5877 :       } // if ( *pchSrcAttribteName )...
; 5878 : 
; 5879 :       // =================================================================
; 5880 :       // ===
; 5881 :       // ===  Validate Qualification attributes.
; 5882 :       // ===
; 5883 :       // =================================================================
; 5884 : 
; 5885 :       // ===
; 5886 :       // === Make sure that all attributes have been set that are needed for
; 5887 :       // === each command.
; 5888 :       // ===
; 5889 :       if ( zstrcmpi( lpQualAttrib->szOper, "EXISTS" ) == 0 ||

	push	OFFSET $SG13664
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN92@fnSqlRetri
	push	OFFSET $SG13665
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN90@fnSqlRetri
$LN92@fnSqlRetri:

; 5890 :            zstrcmpi( lpQualAttrib->szOper, "NOT EXISTS" ) == 0 )
; 5891 :       {
; 5892 :          zBOOL bContainsSubselect;
; 5893 : 
; 5894 :          // Exists commands must have entity name specified.
; 5895 :          if ( lpQualAttrib->lpViewEntity == 0 )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN93@fnSqlRetri

; 5896 :          {
; 5897 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13667
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5898 :                                  "QualAttrib must specify EntityName for "
; 5899 :                                  "[NOT] EXISTS operation.",
; 5900 :                                  zERROR, szlQualAttrib );
; 5901 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN93@fnSqlRetri:

; 5902 :          }
; 5903 : 
; 5904 :          // Check to make sure that the entity in QualEntity is a parent of
; 5905 :          // lpQualAttrib->lpViewEntity.
; 5906 :          for ( lpViewEntity = zGETPTR( lpQualAttrib->lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN26@fnSqlRetri
$LN24@fnSqlRetri:

; 5908 :                lpViewEntity = zGETPTR( lpViewEntity->hParent ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN26@fnSqlRetri:

; 5907 :                lpViewEntity && lpViewEntity != lpQualEntity->lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN25@fnSqlRetri
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN25@fnSqlRetri

; 5909 :          {
; 5910 :             // Nothing needs to be done here.
; 5911 :          }

	jmp	SHORT $LN24@fnSqlRetri
$LN25@fnSqlRetri:

; 5912 : 
; 5913 :          if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN94@fnSqlRetri

; 5914 :          {
; 5915 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13669
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5916 :                                  "QualAttrib.EntityName must be a direct "
; 5917 :                                  "descendant of EntitySpec.EntityName for the "
; 5918 :                                  "[NOT] EXISTS operation.",
; 5919 :                                  zERROR, szlQualAttrib );
; 5920 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN94@fnSqlRetri:

; 5921 :          }
; 5922 : 
; 5923 :          // If any other attributes are specified, warn user but continue.
; 5924 :          if ( lpQualAttrib->lpDataField         ||
; 5925 :               lpQualAttrib->szValue             ||
; 5926 :               lpQualAttrib->lpSourceViewEntity  ||
; 5927 :               lpQualAttrib->lpSourceDataField   ||

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jne	SHORT $LN96@fnSqlRetri
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+40], 0
	jne	SHORT $LN96@fnSqlRetri
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+52], 0
	jne	SHORT $LN96@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	jne	SHORT $LN96@fnSqlRetri
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+60], 0
	je	SHORT $LN95@fnSqlRetri
$LN96@fnSqlRetri:

; 5928 :               lpQualAttrib->lpSourceView )
; 5929 :          {
; 5930 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	1
	push	OFFSET $SG13672
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H
$LN95@fnSqlRetri:

; 5931 :                                  "Extraneous attributes specified for [NOT] "
; 5932 :                                  "EXISTS operation.  Only Oper and EntityName "
; 5933 :                                  "are needed.  All others will be ignored.",
; 5934 :                                  zWARNING, szlQualAttrib );
; 5935 :          }
; 5936 : 
; 5937 :          // For now we think we will need a subselect.
; 5938 :          bContainsSubselect = TRUE;

	mov	BYTE PTR _bContainsSubselect$14[ebp], 1

; 5939 : 
; 5940 :          if ( zstrcmpi( lpQualAttrib->szOper, "EXISTS" ) == 0 )

	push	OFFSET $SG13675
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN97@fnSqlRetri

; 5941 :             lpQualAttrib->bExists = TRUE;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	or	edx, 1
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [eax+64], edx
	jmp	SHORT $LN98@fnSqlRetri
$LN97@fnSqlRetri:

; 5942 :          else
; 5943 :             lpQualAttrib->bDoesNotExist = TRUE;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	or	edx, 2
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [eax+64], edx
$LN98@fnSqlRetri:

; 5944 : 
; 5945 :          // Check to see if the relationship with the parent is x-to-1.  If
; 5946 :          // it is then we can replace the EXISTS clause with a qualification
; 5947 :          // that uses "parent.fk_key not NULL" instead.
; 5948 :          // Note that this doesn't work if there is sub-qualification.
; 5949 :          if ( lpQualAttrib->lpViewEntity->uCardMax == 1 &&

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	movzx	eax, WORD PTR [edx+221]
	cmp	eax, 1
	jne	$LN99@fnSqlRetri
	push	OFFSET _szlSubQualAttrib
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	je	$LN99@fnSqlRetri

; 5950 :               CheckExistenceOfEntity( lpQualView,
; 5951 :                                       szlSubQualAttrib ) != zCURSOR_SET )
; 5952 :          {
; 5953 :             // Even though the max cardinality is 1 we still need to make
; 5954 :             // sure the FKs are stored in the parent.  The only way to do
; 5955 :             // this is to check the rel record.
; 5956 :             lpDataRecord = zGETPTR( lpQualAttrib->lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 5957 :             lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 5958 :             if ( lpRelRecord->cOwnerMember == zDBH_CHILD_IS_SOURCE )

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	eax, 77					; 0000004dH
	jne	$LN99@fnSqlRetri

; 5959 :             {
; 5960 :                zBOOL        bFirst;
; 5961 :                zBOOL        bExists = lpQualAttrib->bExists;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	and	edx, 1
	mov	BYTE PTR _bExists$11[ebp], dl

; 5962 :                LPRELFIELD   lpRelField;
; 5963 :                LPVIEWENTITY lpParent = zGETPTR( lpQualAttrib->lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$3[ebp], eax

; 5964 : 
; 5965 :                // We can change the qualification from EXISTS to check FKs.
; 5966 : 
; 5967 :                // If the parent is the same as the entity we are qualifying
; 5968 :                // then we no longer use child qualification for this
; 5969 :                // QualAttrib.
; 5970 :                if ( lpQualEntity->lpViewEntity == lpParent )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _lpParent$3[ebp]
	jne	SHORT $LN101@fnSqlRetri

; 5971 :                   bQualUsesChildEntity = FALSE;

	mov	BYTE PTR _bQualUsesChildEntity$[ebp], 0
$LN101@fnSqlRetri:

; 5972 : 
; 5973 :                // Qualification no longer needs a subselect.
; 5974 :                bContainsSubselect = FALSE;

	mov	BYTE PTR _bContainsSubselect$14[ebp], 0

; 5975 : 
; 5976 :                // Keep track of the entity.
; 5977 :                lpViewEntity = lpQualAttrib->lpViewEntity;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5978 : 
; 5979 :                // Change current qual attrib to be an close paren.  We do this
; 5980 :                // because it's possible we have more than one key attribute
; 5981 :                // and we use a close paren because we are adding the
; 5982 :                // QualAttribs *backwards*.
; 5983 :                lpQualAttrib->lpViewEntity = 0;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 5984 :                lpQualAttrib->bExists = lpQualAttrib->bDoesNotExist = 0;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+64]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+64], eax
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+64]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 5985 :                zstrcpy( lpQualAttrib->szOper, ")" );

	push	OFFSET $SG13679
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcpy
	add	esp, 8

; 5986 : 
; 5987 :                // Now we have to create a new QualAttrib for each of the FKs.
; 5988 :                bFirst = TRUE;

	mov	BYTE PTR _bFirst$15[ebp], 1

; 5989 :                for ( lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$8[ebp], eax
	jmp	SHORT $LN29@fnSqlRetri
$LN27@fnSqlRetri:

; 5991 :                      lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	eax, DWORD PTR _lpRelField$8[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$8[ebp], eax
$LN29@fnSqlRetri:

; 5990 :                      lpRelField;

	cmp	DWORD PTR _lpRelField$8[ebp], 0
	je	$LN28@fnSqlRetri

; 5992 :                {
; 5993 :                   if ( bFirst )

	movzx	edx, BYTE PTR _bFirst$15[ebp]
	test	edx, edx
	je	SHORT $LN102@fnSqlRetri

; 5994 :                      bFirst = FALSE;

	mov	BYTE PTR _bFirst$15[ebp], 0
	jmp	SHORT $LN103@fnSqlRetri
$LN102@fnSqlRetri:

; 5995 :                   else
; 5996 :                   {
; 5997 :                      // Allocate an 'AND' qual.
; 5998 :                      if ( fnCreateQualAttrib( lpView, lpQualView,
; 5999 :                                               lpFirstQualAttrib,
; 6000 :                                               &lpQualAttrib, 0, 0, "AND",
; 6001 :                                               0 ) != 0 )

	push	0
	push	OFFSET $SG13683
	push	0
	push	0
	lea	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN103@fnSqlRetri

; 6002 :                      {
; 6003 :                         return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN103@fnSqlRetri:

; 6004 :                      }
; 6005 :                   }
; 6006 : 
; 6007 :                   lpDataField  = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$8[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 6008 :                   lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 6009 : 
; 6010 :                   if ( fnCreateQualAttrib( lpView, lpQualView,
; 6011 :                                            lpFirstQualAttrib,
; 6012 :                                            &lpQualAttrib, lpParent,
; 6013 :                                            lpDataField,
; 6014 :                                            bExists ? "IS NOT NULL" : "IS NULL",
; 6015 :                                            0 ) != 0 )

	movzx	eax, BYTE PTR _bExists$11[ebp]
	test	eax, eax
	je	SHORT $LN168@fnSqlRetri
	mov	DWORD PTR tv796[ebp], OFFSET $SG13685
	jmp	SHORT $LN169@fnSqlRetri
$LN168@fnSqlRetri:
	mov	DWORD PTR tv796[ebp], OFFSET $SG13686
$LN169@fnSqlRetri:
	push	0
	mov	ecx, DWORD PTR tv796[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParent$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpQualAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN105@fnSqlRetri

; 6016 :                   {
; 6017 :                      return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN105@fnSqlRetri:

; 6018 :                   }
; 6019 : 
; 6020 :                } // for each lpRelField...

	jmp	$LN27@fnSqlRetri
$LN28@fnSqlRetri:

; 6021 : 
; 6022 :                // Add the opening paren.
; 6023 :                if ( fnCreateQualAttrib( lpView, lpQualView, lpFirstQualAttrib,
; 6024 :                                         &lpQualAttrib, 0, 0, "(", 0 ) != 0 )

	push	0
	push	OFFSET $SG13688
	push	0
	push	0
	lea	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN99@fnSqlRetri

; 6025 :                {
; 6026 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN99@fnSqlRetri:

; 6027 :                }
; 6028 : 
; 6029 :             } // if ( lpRelRecord->cOwnerMember == zDBH_CHILD_IS_SOURCE )...
; 6030 : 
; 6031 :          } // if ( lpQualAttrib->lpViewEntity->uCardMax == 1 )...
; 6032 : 
; 6033 :          if ( bContainsSubselect )

	movzx	edx, BYTE PTR _bContainsSubselect$14[ebp]
	test	edx, edx
	je	SHORT $LN107@fnSqlRetri

; 6034 :             lpQualEntity->bContainsSubselect = TRUE;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 2
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN107@fnSqlRetri:

; 6035 : 
; 6036 :       } // if ( zstrcmpi( lpQualAttrib->szOper, "EXISTS" ) == 0 || ... )...

	jmp	$LN91@fnSqlRetri
$LN90@fnSqlRetri:

; 6037 :       else
; 6038 :       if ( zstrcmpi( lpQualAttrib->szOper, "IS" ) == 0 )

	push	OFFSET $SG13692
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN108@fnSqlRetri

; 6039 :       {
; 6040 :          // IS command must have entity name specified.
; 6041 :          if ( lpQualAttrib->lpViewEntity == 0 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN110@fnSqlRetri

; 6042 :          {
; 6043 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13694
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6044 :                                  "QualAttrib must have EntityName for IS "
; 6045 :                                  "operation.",
; 6046 :                                  zERROR, szlQualAttrib );
; 6047 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN110@fnSqlRetri:

; 6048 :          }
; 6049 : 
; 6050 :          // IS command must have source entity name specified.
; 6051 :          if ( lpQualAttrib->lpSourceViewEntity == 0 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+52], 0
	jne	SHORT $LN111@fnSqlRetri

; 6052 :          {
; 6053 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13696
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6054 :                                  "QualAttrib must have SourceEntityName for "
; 6055 :                                  "IS operation.",
; 6056 :                                  zERROR, szlQualAttrib );
; 6057 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN111@fnSqlRetri:

; 6058 :          }
; 6059 : 
; 6060 :          // IS command must have source view specified.
; 6061 :          if ( lpQualAttrib->lpSourceView == 0 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+60], 0
	jne	SHORT $LN112@fnSqlRetri

; 6062 :          {
; 6063 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13698
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6064 :                                  "QualAttrib must have SourceView for "
; 6065 :                                  "IS operation.",
; 6066 :                                  zERROR, szlQualAttrib );
; 6067 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN112@fnSqlRetri:

; 6068 :          }
; 6069 : 
; 6070 :          // If any other attributes are specified, warn user but continue.
; 6071 :          if ( lpQualAttrib->lpDataField         ||
; 6072 :               lpQualAttrib->szValue             ||

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN114@fnSqlRetri
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN114@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN113@fnSqlRetri
$LN114@fnSqlRetri:

; 6073 :               lpQualAttrib->lpSourceDataField )
; 6074 :          {
; 6075 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	1
	push	OFFSET $SG13701
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H
$LN113@fnSqlRetri:

; 6076 :                                  "Extraneous attributes specified for IS "
; 6077 :                                  "operation.  Only Oper, EntityName, "
; 6078 :                                  "SourceEntityName, and SourceView "
; 6079 :                                  "are needed.  All others will be ignored.",
; 6080 :                                  zWARNING, szlQualAttrib );
; 6081 :          }
; 6082 : 
; 6083 :          lpQualEntity->bContainsIS = TRUE;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	or	edx, 4
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [eax+28], edx

; 6084 :          lpQualAttrib->bIs         = TRUE;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	or	edx, 8
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [eax+64], edx

; 6085 : 
; 6086 :       } // if ( zstrcmpi( lpQualAttrib->szOper, "IS" ) == 0 )...

	jmp	$LN91@fnSqlRetri
$LN108@fnSqlRetri:

; 6087 :       else
; 6088 :       if ( zstrcmpi( lpQualAttrib->szOper, "LIKE" ) == 0 )

	push	OFFSET $SG13704
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN115@fnSqlRetri

; 6089 :       {
; 6090 :          lpQualEntity->bUniqueQualification = FALSE;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 6091 : 
; 6092 :          // IS command must have entity name specified.
; 6093 :          if ( lpQualAttrib->lpViewAttrib == 0 )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN117@fnSqlRetri

; 6094 :          {
; 6095 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13706
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6096 :                                  "QualAttrib must have Entity.AttributeName "
; 6097 :                                  "for LIKE operation.",
; 6098 :                                  zERROR, szlQualAttrib );
; 6099 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN117@fnSqlRetri:

; 6100 :          }
; 6101 : 
; 6102 :          // Make sure attribute is a string.
; 6103 :          if ( lpQualAttrib->lpViewAttrib->cType != zTYPE_STRING )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 83					; 00000053H
	je	SHORT $LN118@fnSqlRetri

; 6104 :          {
; 6105 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13708
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6106 :                                  "Entity.AttributeName for QualAttrib must be "
; 6107 :                                  "a string for the LIKE operation.",
; 6108 :                                  zERROR, szlQualAttrib );
; 6109 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN118@fnSqlRetri:

; 6110 :          }
; 6111 : 
; 6112 :          lpQualAttrib->bLike = TRUE;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+64]
	or	eax, 4
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 6113 : 
; 6114 :       } // if ( zstrcmpi( lpQualAttrib->szOper, "LIKE" ) == 0 )...

	jmp	$LN91@fnSqlRetri
$LN115@fnSqlRetri:

; 6115 :       else
; 6116 :       {
; 6117 :          // Check to see if pchValue should be changed to "NULL".
; 6118 :          if ( lpQualAttrib->lpDataField &&
; 6119 :               lpQualAttrib->szValue == 0 &&

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	$LN119@fnSqlRetri
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	$LN119@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	jne	$LN119@fnSqlRetri

; 6120 :               lpQualAttrib->lpSourceDataField == 0 )
; 6121 :          {
; 6122 :             if ( zstrcmp( lpQualAttrib->szOper, "=" ) == 0 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13712
	cmp	ecx, edx
	jne	SHORT $LN172@fnSqlRetri
	push	OFFSET $SG13713
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv946[ebp], eax
	jmp	SHORT $LN173@fnSqlRetri
$LN172@fnSqlRetri:
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13714
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN170@fnSqlRetri
	mov	DWORD PTR tv945[ebp], 1
	jmp	SHORT $LN171@fnSqlRetri
$LN170@fnSqlRetri:
	mov	DWORD PTR tv945[ebp], -1
$LN171@fnSqlRetri:
	mov	eax, DWORD PTR tv945[ebp]
	mov	DWORD PTR tv946[ebp], eax
$LN173@fnSqlRetri:
	cmp	DWORD PTR tv946[ebp], 0
	jne	SHORT $LN120@fnSqlRetri

; 6123 :                fnAllocOper( lpQualAttrib, "IS NULL" );

	push	OFFSET $SG13715
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	push	ecx
	call	_fnAllocOper
	add	esp, 8
	jmp	SHORT $LN121@fnSqlRetri
$LN120@fnSqlRetri:

; 6124 :             else
; 6125 :             if ( strstr( "<> !=", lpQualAttrib->szOper ) )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	OFFSET $SG13718
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN122@fnSqlRetri

; 6126 :                fnAllocOper( lpQualAttrib, "IS NOT NULL" );

	push	OFFSET $SG13719
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	push	ecx
	call	_fnAllocOper
	add	esp, 8
	jmp	SHORT $LN121@fnSqlRetri
$LN122@fnSqlRetri:

; 6127 :             else
; 6128 :             // QualAttrib has AttributeName specified but no Value or
; 6129 :             // SourceAttributeName.  If the operator is a comparison
; 6130 :             // operator, a Value is required.  Connection operators ( AND,
; 6131 :             // OR ) and precidence operators ( "(", ")" ) don't have values.
; 6132 :             if ( strstr( "<= =< >= =>", lpQualAttrib->szOper ) )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	OFFSET $SG13721
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN121@fnSqlRetri

; 6133 :             {
; 6134 :                fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13722
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6135 :                                     "QualAttrib has AttributeName but does "
; 6136 :                                     "not have Value or SourceAttributeName, "
; 6137 :                                     "which are needed for the following comparison "
; 6138 :                                     "opererators: '<', '<=', '>', and'>='.",
; 6139 :                                     zERROR, szlQualAttrib );
; 6140 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN121@fnSqlRetri:

; 6141 :             }
; 6142 : 
; 6143 :             // For databases that allow LEFT JOINs, qualification using a child
; 6144 :             // will be added via a join.  If the child qualification uses a
; 6145 :             // "IS NULL" on a non-key, the resulting join will create a match
; 6146 :             // for child entities that do not exist.  To fix this, we will also
; 6147 :             // make sure a key is non-null.
; 6148 :             if ( bUseLeftJoin &&
; 6149 :                  lpQualAttrib->lpViewEntity &&
; 6150 :                  lpQualAttrib->lpViewEntity != lpQualEntity->lpViewEntity &&
; 6151 :                  lpQualAttrib->lpViewEntity->uCardMin == 0 &&

	movzx	eax, BYTE PTR _bUseLeftJoin$[ebp]
	test	eax, eax
	je	$LN119@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN119@fnSqlRetri
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN119@fnSqlRetri
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	ecx, WORD PTR [eax+219]
	test	ecx, ecx
	jne	SHORT $LN119@fnSqlRetri
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN119@fnSqlRetri

; 6152 :                  lpQualAttrib->lpViewAttrib->bKey == FALSE )
; 6153 :             {
; 6154 :                if ( zstrstr( "IS NULL", lpQualAttrib->szOper ) )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	push	OFFSET $SG13725
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN119@fnSqlRetri

; 6155 :                {
; 6156 :                   fnAddCheckForNullKey( lpView, lpQualView, lpQualEntity,

	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnAddCheckForNullKey
	add	esp, 20					; 00000014H
$LN119@fnSqlRetri:

; 6157 :                                         lpQualAttrib, lpFirstQualAttrib );
; 6158 :                }
; 6159 :             }
; 6160 :          }
; 6161 : 
; 6162 :          if ( lpQualAttrib->lpDataField == 0 &&

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN127@fnSqlRetri
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN128@fnSqlRetri
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN127@fnSqlRetri
$LN128@fnSqlRetri:

; 6163 :               (lpQualAttrib->szValue || lpQualAttrib->lpSourceDataField) )
; 6164 :          {
; 6165 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13728
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6166 :                                  "QualAttrib has Value or SourceAttributeName"
; 6167 :                                  " but does not have AttributeName.",
; 6168 :                                  zERROR, szlQualAttrib );
; 6169 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN127@fnSqlRetri:

; 6170 :          }
; 6171 : 
; 6172 :          // If we're still think we have a unique qualification check to make
; 6173 :          // sure that the oper is '='.
; 6174 :          if ( lpQualEntity->bUniqueQualification )

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 4
	and	eax, 1
	je	$LN91@fnSqlRetri

; 6175 :          {
; 6176 :             if ( zstrcmp( lpQualAttrib->szOper, "=" ) != 0 )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13731
	cmp	eax, ecx
	jne	SHORT $LN176@fnSqlRetri
	push	OFFSET $SG13732
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv1024[ebp], eax
	jmp	SHORT $LN177@fnSqlRetri
$LN176@fnSqlRetri:
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13733
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN174@fnSqlRetri
	mov	DWORD PTR tv1023[ebp], 1
	jmp	SHORT $LN175@fnSqlRetri
$LN174@fnSqlRetri:
	mov	DWORD PTR tv1023[ebp], -1
$LN175@fnSqlRetri:
	mov	edx, DWORD PTR tv1023[ebp]
	mov	DWORD PTR tv1024[ebp], edx
$LN177@fnSqlRetri:
	cmp	DWORD PTR tv1024[ebp], 0
	je	SHORT $LN91@fnSqlRetri

; 6177 :                lpQualEntity->bUniqueQualification = FALSE;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+28], ecx
$LN91@fnSqlRetri:

; 6178 :          }
; 6179 :       }
; 6180 : 
; 6181 :       // =================================================================
; 6182 :       // ===
; 6183 :       // === Check to see if there are sub-qualifications for the current
; 6184 :       // === QualAttrib.  Retrieve the sub-qualifications if they are there.
; 6185 :       // ===
; 6186 :       // =================================================================
; 6187 :       if ( CheckExistenceOfEntity( lpQualView,
; 6188 :                                    szlSubQualAttrib ) == zCURSOR_SET )

	push	OFFSET _szlSubQualAttrib
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jne	$LN131@fnSqlRetri

; 6189 :       {
; 6190 :          zVIEW lpSubQualView;
; 6191 : 
; 6192 :          CreateViewFromViewForTask( &lpSubQualView, lpQualView, 0 );

	push	0
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSubQualView$5[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 6193 :          nRC = SetViewToSubobject( lpSubQualView, szlSubQualAttrib );

	push	OFFSET _szlSubQualAttrib
	mov	ecx, DWORD PTR _lpSubQualView$5[ebp]
	push	ecx
	call	_SetViewToSubobject@8
	mov	WORD PTR _nRC$[ebp], ax

; 6194 :          if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN132@fnSqlRetri

; 6195 :          {
; 6196 :             fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13736
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6197 :                                  "Internal error setting view to Subobject.",
; 6198 :                                  zERROR, szlQualAttrib );
; 6199 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN132@fnSqlRetri:

; 6200 :          }
; 6201 : 
; 6202 :          // Call fnSqlRetrieveQualAttrib recursivly to load sub-qual.
; 6203 :          nRC = fnSqlRetrieveQualAttrib( lpView, lpViewOD,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSubQualView$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlRetrieveQualAttrib
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 6204 :                                         lpSubQualView, lpQualEntity,
; 6205 :                                         &lpQualAttrib->lpFirstSubQualAttrib,
; 6206 :                                         lpBoundList );
; 6207 :          DropView( lpSubQualView ); // Don't need view anymore.

	mov	edx, DWORD PTR _lpSubQualView$5[ebp]
	push	edx
	call	_DropView@4

; 6208 :          if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN131@fnSqlRetri

; 6209 :             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnSqlRetri
$LN131@fnSqlRetri:

; 6210 :       }
; 6211 : 
; 6212 :       // Turn on bQualUsesChildEntity.
; 6213 :       lpQualEntity->bQualUsesChildEntity =

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 1
	jne	SHORT $LN178@fnSqlRetri
	movzx	eax, BYTE PTR _bQualUsesChildEntity$[ebp]
	test	eax, eax
	jne	SHORT $LN178@fnSqlRetri
	mov	DWORD PTR tv1064[ebp], 0
	jmp	SHORT $LN179@fnSqlRetri
$LN178@fnSqlRetri:
	mov	DWORD PTR tv1064[ebp], 1
$LN179@fnSqlRetri:
	mov	ecx, DWORD PTR tv1064[ebp]
	and	ecx, 1
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, -2					; fffffffeH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 6214 :                   lpQualEntity->bQualUsesChildEntity || bQualUsesChildEntity;
; 6215 : 
; 6216 :    } // for each lpQualView.QualAttrib

	jmp	$LN2@fnSqlRetri
$LN3@fnSqlRetri:

; 6217 : 
; 6218 :    // =================================================================
; 6219 :    // ===
; 6220 :    // === End of attribute loop.
; 6221 :    // ===
; 6222 :    // =================================================================
; 6223 : 
; 6224 :    // Go through all the qual attribs and check to see if any are seperated
; 6225 :    // by an "OR".  Say we have the following object:
; 6226 :    //
; 6227 :    //      A
; 6228 :    //      /\
; 6229 :    //     B  C
; 6230 :    //
; 6231 :    // (B and C have 0-to-many relationships with A).
; 6232 :    // and the user qualified A with "B.col = 1 OR C.col = 2".  This causes
; 6233 :    // the following to be generated:
; 6234 :    //
; 6235 :    //    SELECT A-columns
; 6236 :    //    FROM A, B, C
; 6237 :    //    WHERE ( (A.fk_b = B.key AND a.fk_c = C.key) AND
; 6238 :    //            (b.key = 1 OR C.key = 2) )
; 6239 :    //
; 6240 :    // This is a problem because if either B or C doesn't exist then the the
; 6241 :    // select doesn't find anything because the join fails to find any children
; 6242 :    // that match the foreign keys.
; 6243 :    //
; 6244 :    // NOTE: This is only a problem with databases that don't support LEFT
; 6245 :    // JOINs.
; 6246 :    //
; 6247 :    // To solve this we need to go through each of the qual attribs and see if:
; 6248 :    //    o  They involve qualification on multiple children.
; 6249 :    //    o  There is an "OR" operation.
; 6250 :    // Then convert each of the child quals to use an EXIST clause.
; 6251 :    if ( bUseLeftJoin == FALSE && bQualUsesChildEntity && bQualUsesOR_Oper )

	movzx	edx, BYTE PTR _bUseLeftJoin$[ebp]
	test	edx, edx
	jne	$LN134@fnSqlRetri
	movzx	eax, BYTE PTR _bQualUsesChildEntity$[ebp]
	test	eax, eax
	je	$LN134@fnSqlRetri
	movzx	ecx, BYTE PTR _bQualUsesOR_Oper$[ebp]
	test	ecx, ecx
	je	$LN134@fnSqlRetri

; 6252 :    {
; 6253 :       zBOOL        bConvertNeeded = FALSE;

	mov	BYTE PTR _bConvertNeeded$13[ebp], 0

; 6254 :       LPQUALATTRIB lpPrevQualAttrib = 0;

	mov	DWORD PTR _lpPrevQualAttrib$10[ebp], 0

; 6255 : 
; 6256 :       // We still don't know if there are multiple children.  Check for it.
; 6257 :       for ( lpQualAttrib = *lpFirstQualAttrib;

	mov	edx, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpQualAttrib$[ebp], eax
	jmp	SHORT $LN32@fnSqlRetri
$LN30@fnSqlRetri:

; 6259 :             lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
$LN32@fnSqlRetri:

; 6258 :             lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	SHORT $LN31@fnSqlRetri

; 6260 :       {
; 6261 :          // No entity for this qual attrib?  Skip it.
; 6262 :          if ( lpQualAttrib->lpViewEntity == 0 )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN135@fnSqlRetri

; 6263 :             continue;

	jmp	SHORT $LN30@fnSqlRetri
$LN135@fnSqlRetri:

; 6264 : 
; 6265 :          // Entity for qual attrib is entity we are loading (i.e. the root)
; 6266 :          // then skip it (we only care about child entities).
; 6267 :          if ( lpQualAttrib->lpViewEntity == lpQualEntity->lpViewEntity )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN136@fnSqlRetri

; 6268 :             continue;

	jmp	SHORT $LN30@fnSqlRetri
$LN136@fnSqlRetri:

; 6269 : 
; 6270 :          // If the operation already is an EXISTS operation don't bother.
; 6271 :          if ( lpQualAttrib->bExists || lpQualAttrib->bDoesNotExist )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	and	edx, 1
	jne	SHORT $LN138@fnSqlRetri
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN137@fnSqlRetri
$LN138@fnSqlRetri:

; 6272 :             continue;

	jmp	SHORT $LN30@fnSqlRetri
$LN137@fnSqlRetri:

; 6273 : 
; 6274 :          // If lpPrevQualEntity is 0 then this is the first child we have
; 6275 :          // found so set it and go on to the next qual attrib.
; 6276 :          if ( lpPrevQualAttrib == 0 )

	cmp	DWORD PTR _lpPrevQualAttrib$10[ebp], 0
	jne	SHORT $LN139@fnSqlRetri

; 6277 :          {
; 6278 :             lpPrevQualAttrib = lpQualAttrib;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR _lpPrevQualAttrib$10[ebp], edx

; 6279 :             continue;

	jmp	SHORT $LN30@fnSqlRetri
$LN139@fnSqlRetri:

; 6280 :          }
; 6281 : 
; 6282 :          // If we have multiple child entities involved in the qualification
; 6283 :          // then we need to convert the QualAttrib.
; 6284 :          if ( lpPrevQualAttrib->lpViewEntity != lpQualAttrib->lpViewEntity )

	mov	eax, DWORD PTR _lpPrevQualAttrib$10[ebp]
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN140@fnSqlRetri

; 6285 :          {
; 6286 :             bConvertNeeded = TRUE;

	mov	BYTE PTR _bConvertNeeded$13[ebp], 1

; 6287 :             break;

	jmp	SHORT $LN31@fnSqlRetri
$LN140@fnSqlRetri:

; 6288 :          }
; 6289 : 
; 6290 :       } // for each lpQualAttrib...

	jmp	$LN30@fnSqlRetri
$LN31@fnSqlRetri:

; 6291 : 
; 6292 :       // Now that we know if we need to convert child qualification to use
; 6293 :       // EXISTS do so now.
; 6294 :       if ( bConvertNeeded )

	movzx	eax, BYTE PTR _bConvertNeeded$13[ebp]
	test	eax, eax
	je	$LN134@fnSqlRetri

; 6295 :       {
; 6296 :          for ( lpPrevQualAttrib = 0, lpQualAttrib = *lpFirstQualAttrib;

	mov	DWORD PTR _lpPrevQualAttrib$10[ebp], 0
	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
	jmp	SHORT $LN35@fnSqlRetri
$LN33@fnSqlRetri:

; 6298 :                lpPrevQualAttrib = lpQualAttrib,

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR _lpPrevQualAttrib$10[ebp], eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
$LN35@fnSqlRetri:

; 6297 :                lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	$LN34@fnSqlRetri

; 6299 :                  lpQualAttrib = lpQualAttrib->lpNextQualAttrib )
; 6300 :          {
; 6301 :             LPQUALATTRIB lpNewQualAttrib = 0;

	mov	DWORD PTR _lpNewQualAttrib$7[ebp], 0

; 6302 : 
; 6303 :             // No entity for this qual attrib?  Skip it.
; 6304 :             if ( lpQualAttrib->lpViewEntity == 0 )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN142@fnSqlRetri

; 6305 :                continue;

	jmp	SHORT $LN33@fnSqlRetri
$LN142@fnSqlRetri:

; 6306 : 
; 6307 :             // Entity for qual attrib is entity we are loading (i.e. the root)
; 6308 :             // then skip it (we only care about child entities).
; 6309 :             if ( lpQualAttrib->lpViewEntity == lpQualEntity->lpViewEntity )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN143@fnSqlRetri

; 6310 :                continue;

	jmp	SHORT $LN33@fnSqlRetri
$LN143@fnSqlRetri:

; 6311 : 
; 6312 :             // If the operation already is and EXISTS operation don't bother.
; 6313 :             if ( lpQualAttrib->bExists || lpQualAttrib->bDoesNotExist )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	and	edx, 1
	jne	SHORT $LN145@fnSqlRetri
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN144@fnSqlRetri
$LN145@fnSqlRetri:

; 6314 :                continue;

	jmp	SHORT $LN33@fnSqlRetri
$LN144@fnSqlRetri:

; 6315 : 
; 6316 :             // We don't care about entities that have a min cardinality of 1
; 6317 :             // because there will always be an occurence of the child entity.
; 6318 :             if ( lpQualAttrib->lpViewEntity->uCardMin == 1 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+12]
	movzx	ecx, WORD PTR [eax+219]
	cmp	ecx, 1
	jne	SHORT $LN146@fnSqlRetri

; 6319 :                continue;

	jmp	$LN33@fnSqlRetri
$LN146@fnSqlRetri:

; 6320 : 
; 6321 :             // =========================================================
; 6322 :             // If we get here then lpQualAttrib fits all the criteria and
; 6323 :             // needs to be converted to use an EXISTS clause.
; 6324 :             // =========================================================
; 6325 : 
; 6326 :             // First create the new EXISTS qual attrib in front of the
; 6327 :             // current qual attrib.
; 6328 :             if ( fnCreateQualAttrib( lpView, lpQualView,
; 6329 :                                      lpPrevQualAttrib ?
; 6330 :                                        &lpPrevQualAttrib->lpNextQualAttrib :
; 6331 :                                        lpFirstQualAttrib,
; 6332 :                                      &lpNewQualAttrib,
; 6333 :                                      lpQualAttrib->lpViewEntity,
; 6334 :                                      0, "EXISTS", 0 ) != 0 )

	cmp	DWORD PTR _lpPrevQualAttrib$10[ebp], 0
	je	SHORT $LN180@fnSqlRetri
	mov	edx, DWORD PTR _lpPrevQualAttrib$10[ebp]
	add	edx, 4
	mov	DWORD PTR tv1122[ebp], edx
	jmp	SHORT $LN181@fnSqlRetri
$LN180@fnSqlRetri:
	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	DWORD PTR tv1122[ebp], eax
$LN181@fnSqlRetri:
	push	0
	push	OFFSET $SG13752
	push	0
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	lea	eax, DWORD PTR _lpNewQualAttrib$7[ebp]
	push	eax
	mov	ecx, DWORD PTR tv1122[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN147@fnSqlRetri

; 6335 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlRetri
$LN147@fnSqlRetri:

; 6336 : 
; 6337 :             // Now move qual attrib so that it is a sub-qual attrib of the
; 6338 :             // exists qual attrib.
; 6339 :             lpNewQualAttrib->lpFirstSubQualAttrib = lpQualAttrib;

	mov	edx, DWORD PTR _lpNewQualAttrib$7[ebp]
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [edx+8], eax

; 6340 :             lpNewQualAttrib->lpNextQualAttrib     = lpQualAttrib->lpNextQualAttrib;

	mov	ecx, DWORD PTR _lpNewQualAttrib$7[ebp]
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax

; 6341 :             lpQualAttrib->lpNextQualAttrib        = 0;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+4], 0

; 6342 : 
; 6343 :             // Qualification now uses a subselect so set flag accordingly.
; 6344 :             lpQualEntity->bContainsSubselect = TRUE;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	or	eax, 2
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 6345 : 
; 6346 :             // Last thing...reset lpQualAttrib to lpNewQualAttrib so that the
; 6347 :             // next iteration of the 'for' loop works correctly.
; 6348 :             lpQualAttrib = lpNewQualAttrib;

	mov	edx, DWORD PTR _lpNewQualAttrib$7[ebp]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx

; 6349 : 
; 6350 :          } // For each lpQualAttrib...

	jmp	$LN33@fnSqlRetri
$LN34@fnSqlRetri:

; 6351 : 
; 6352 :          // We have to go through the qual attribs again and reset the
; 6353 :          // bContainsChildQual flag.
; 6354 :          lpQualEntity->bQualUsesChildEntity = FALSE;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 6355 :          for ( lpQualAttrib = *lpFirstQualAttrib;

	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpQualAttrib$[ebp], ecx
	jmp	SHORT $LN38@fnSqlRetri
$LN36@fnSqlRetri:

; 6357 :                lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], eax
$LN38@fnSqlRetri:

; 6356 :                lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	SHORT $LN134@fnSqlRetri

; 6358 :          {
; 6359 :             // If there is no entity for the qual attrib skip it.
; 6360 :             if ( lpQualAttrib->lpViewEntity == 0 )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN148@fnSqlRetri

; 6361 :                continue;

	jmp	SHORT $LN36@fnSqlRetri
$LN148@fnSqlRetri:

; 6362 : 
; 6363 :             // If entity for qual attrib is same as entity for qual entity
; 6364 :             // then qual attrib is not a child so skip it.
; 6365 :             if ( lpQualAttrib->lpViewEntity == lpQualEntity->lpViewEntity )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN149@fnSqlRetri

; 6366 :                continue;

	jmp	SHORT $LN36@fnSqlRetri
$LN149@fnSqlRetri:

; 6367 : 
; 6368 :             // If there is no data field for the qual attrib then the OPER
; 6369 :             // must be EXISTS or similair so skip it.
; 6370 :             if ( lpQualAttrib->lpDataField == 0 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jne	SHORT $LN150@fnSqlRetri

; 6371 :                continue;

	jmp	SHORT $LN36@fnSqlRetri
$LN150@fnSqlRetri:

; 6372 : 
; 6373 :             lpQualEntity->bQualUsesChildEntity = TRUE;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 1
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 6374 :             break;

	jmp	SHORT $LN134@fnSqlRetri

; 6375 : 
; 6376 :          } // For each lpQualAttrib...

	jmp	SHORT $LN36@fnSqlRetri
$LN134@fnSqlRetri:

; 6377 : 
; 6378 :       } // if ( bConvertNeeded )...
; 6379 : 
; 6380 :    } // if ( bQualUsesChildEntity && bQualUsesOR_Oper )...
; 6381 : 
; 6382 :    // Now check to make sure that all the QualAttribs use the same database
; 6383 :    // as the EntitySpec.
; 6384 :    if ( *lpQualEntity->lpViewEntity->szDBName )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax+80]
	test	ecx, ecx
	je	SHORT $LN151@fnSqlRetri

; 6385 :    {
; 6386 :       // fnSqlVerifyDataBase with the DBName in lpViewEntity.
; 6387 :       nRC = fnSqlVerifyDataBase( lpQualEntity->lpFirstQualAttrib,

	push	0
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_fnSqlVerifyDataBase
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 6388 :                                  lpQualEntity->lpViewEntity->szDBName,
; 6389 :                                  FALSE );
; 6390 :    }

	jmp	SHORT $LN152@fnSqlRetri
$LN151@fnSqlRetri:

; 6391 :    else
; 6392 :       // fnSqlVerifyDataBase with the default DBName.
; 6393 :       nRC = fnSqlVerifyDataBase( lpQualEntity->lpFirstQualAttrib,

	push	1
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 43					; 0000002bH
	push	eax
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_fnSqlVerifyDataBase
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax
$LN152@fnSqlRetri:

; 6394 :                                  lpViewOD->szDfltDBName, TRUE );
; 6395 : 
; 6396 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN153@fnSqlRetri

; 6397 :    {
; 6398 :       fnSqlDisplayQualMsg( lpView, lpQualView,

	push	OFFSET _szlQualAttrib
	push	0
	push	OFFSET $SG13759
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6399 :                            "The QualAttrib used to qualify EntitySpec "
; 6400 :                            "causes two tables from different databases "
; 6401 :                            "to be joined.  This is invalid.",
; 6402 :                            zERROR, szlQualAttrib );
; 6403 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSqlRetri
$LN153@fnSqlRetri:

; 6404 :    }
; 6405 : 
; 6406 :    // After going through all QualAttribs, the ParenCount must be zero. If
; 6407 :    // it isn't then there are too many left parens (if nParenCount > 0 )
; 6408 :    // or too may right parens (if nParenCount < 0).
; 6409 :    if ( nParenCount != 0 )

	movsx	eax, WORD PTR _nParenCount$[ebp]
	test	eax, eax
	je	SHORT $LN154@fnSqlRetri

; 6410 :    {
; 6411 :       fnSqlDisplayQualMsg( lpView, lpQualView,

	push	0
	push	0
	push	OFFSET $SG13761
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 6412 :                            "Parens for all QualAttrib.Oper under "
; 6413 :                            "EntitySpec do not match.", zERROR, 0 );
; 6414 :       DisplayObjectInstance( lpQualView, szlEntitySpec, 0 );

	push	0
	push	OFFSET _szlEntitySpec
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_DisplayObjectInstance@12

; 6415 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSqlRetri
$LN154@fnSqlRetri:

; 6416 :    }
; 6417 : 
; 6418 :    return( 0 );

	xor	eax, eax
$LN1@fnSqlRetri:

; 6419 : 
; 6420 : }  /* fnSqlRetrieveQualAttrib */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlRetrieveQualAttrib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewAttrib$ = -12					; size = 4
_lpNewQualAttrib$ = -8					; size = 4
_lpDataField$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpQualView$ = 12					; size = 4
_lpQualEntity$ = 16					; size = 4
_lpQualAttrib$ = 20					; size = 4
_lpFirstQualAttrib$ = 24				; size = 4
_fnAddCheckForNullKey PROC

; 5268 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5269 :    LPQUALATTRIB lpNewQualAttrib;
; 5270 :    LPVIEWATTRIB lpViewAttrib;
; 5271 :    LPDATAFIELD  lpDataField;
; 5272 : 
; 5273 :    // Copy the lpQualAttrib.  In a minute we're going to change lpQualAttrib
; 5274 :    // to be a closing paren.
; 5275 :    fnCreateQualAttrib( lpView, lpQualView, lpFirstQualAttrib,

	push	0
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	lea	eax, DWORD PTR _lpNewQualAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H

; 5276 :                        &lpNewQualAttrib, lpQualAttrib->lpViewEntity,
; 5277 :                        lpQualAttrib->lpDataField, lpQualAttrib->szOper, 0 );
; 5278 : 
; 5279 :    // Find a key attrib for the entity. Note that any key attrib will
; 5280 :    // do (even if it's a multi-part key) because we only need to check if
; 5281 :    // the key is NULL.
; 5282 :    for ( lpDataField = zGETPTR( lpQualAttrib->lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN4@fnAddCheck
$LN2@fnAddCheck:

; 5284 :          lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@fnAddCheck:

; 5283 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	SHORT $LN3@fnAddCheck

; 5285 :    {
; 5286 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 5287 :       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN5@fnAddCheck

; 5288 :          break;

	jmp	SHORT $LN3@fnAddCheck
$LN5@fnAddCheck:

; 5289 :    }

	jmp	SHORT $LN2@fnAddCheck
$LN3@fnAddCheck:

; 5290 : 
; 5291 :    // Change lpQualAttrib to a close paren.
; 5292 :    lpQualAttrib->lpViewEntity = 0;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 5293 :    lpQualAttrib->lpDataRecord = 0;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [edx+16], 0

; 5294 :    lpQualAttrib->lpViewAttrib = 0;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [eax+20], 0

; 5295 :    lpQualAttrib->lpDataField  = 0;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 5296 :    fnAllocOper( lpQualAttrib, ")" );

	push	OFFSET $SG13432
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	push	edx
	call	_fnAllocOper
	add	esp, 8

; 5297 : 
; 5298 :    // Add the AND
; 5299 :    fnCreateQualAttrib( lpView, lpQualView, lpFirstQualAttrib,

	push	0
	push	OFFSET $SG13433
	push	0
	push	0
	lea	eax, DWORD PTR _lpNewQualAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H

; 5300 :                        &lpNewQualAttrib, 0, 0, "AND", 0 );
; 5301 : 
; 5302 :    // Add the check for a null key.
; 5303 :    fnCreateQualAttrib( lpView, lpQualView, lpFirstQualAttrib,

	push	0
	push	OFFSET $SG13434
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	push	eax
	lea	ecx, DWORD PTR _lpNewQualAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H

; 5304 :                        &lpNewQualAttrib, zGETPTR( lpViewAttrib->hViewEntity ),
; 5305 :                        lpDataField, "IS NOT NULL", 0 );
; 5306 : 
; 5307 :    // Add the opening paren.
; 5308 :    fnCreateQualAttrib( lpView, lpQualView, lpFirstQualAttrib,

	push	0
	push	OFFSET $SG13435
	push	0
	push	0
	lea	edx, DWORD PTR _lpNewQualAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCreateQualAttrib
	add	esp, 32					; 00000020H

; 5309 :                        &lpNewQualAttrib, 0, 0, "(", 0 );
; 5310 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnAddCheckForNullKey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_uLth$ = -12						; size = 4
_hMem$ = -8						; size = 4
_lpQualAttrib$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpQualView$ = 12					; size = 4
_lpFirstQualAttrib$ = 16				; size = 4
_plpQualAttrib$ = 20					; size = 4
_lpViewEntity$ = 24					; size = 4
_lpDataField$ = 28					; size = 4
_pchOper$ = 32						; size = 4
_pchValue$ = 36						; size = 4
_fnCreateQualAttrib PROC

; 5192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5193 :    zULONG       uLth;
; 5194 :    zLONG        hMem;
; 5195 :    LPQUALATTRIB lpQualAttrib;
; 5196 : 
; 5197 :    // Allocate space for new QualAttrib record.
; 5198 :    hMem = SysAllocMemory( (zPVOID) plpQualAttrib,

	push	0
	push	32768					; 00008000H
	push	0
	push	68					; 00000044H
	mov	eax, DWORD PTR _plpQualAttrib$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 5199 :                           sizeof( QualAttribRecord ), 0,
; 5200 :                           zCOREMEM_ALLOC, 0 );
; 5201 :    if ( *plpQualAttrib == 0 )

	mov	ecx, DWORD PTR _plpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN2@fnCreateQu

; 5202 :    {
; 5203 :       fnSqlDisplayQualMsg( lpView, lpQualView,

	push	0
	push	0
	push	OFFSET $SG13407
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5204 :                            "Cannot allocate memory.", zERROR, 0 );
; 5205 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN2@fnCreateQu:

; 5206 :    }
; 5207 : 
; 5208 :    lpQualAttrib = *plpQualAttrib;

	mov	ecx, DWORD PTR _plpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx

; 5209 : 
; 5210 :    // Fill new QualAttrib with zeros.
; 5211 :    zmemset( (zPVOID) lpQualAttrib, 0, sizeof( QualAttribRecord ) );

	push	68					; 00000044H
	push	0
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5212 :    lpQualAttrib->hMem = hMem;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [ecx], edx

; 5213 : 
; 5214 :    // Add lpQualAttrib as first qual attrib in chain.
; 5215 :    lpQualAttrib->lpNextQualAttrib = *lpFirstQualAttrib;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 5216 :    *lpFirstQualAttrib = lpQualAttrib;

	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [eax], ecx

; 5217 : 
; 5218 :    // Allocate space for the oper.
; 5219 :    fnAllocOper( lpQualAttrib, pchOper );

	mov	edx, DWORD PTR _pchOper$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	call	_fnAllocOper
	add	esp, 8

; 5220 : 
; 5221 :    // Allocate space for the value.
; 5222 :    if ( pchValue && *pchValue )

	cmp	DWORD PTR _pchValue$[ebp], 0
	je	SHORT $LN3@fnCreateQu
	mov	ecx, DWORD PTR _pchValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@fnCreateQu

; 5223 :    {
; 5224 :       uLth = zstrlen( pchValue ) + 1;

	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _uLth$[ebp], eax

; 5225 :       hMem = SysAllocMemory( (zPVOID) &lpQualAttrib->szValue,

	push	0
	push	32768					; 00008000H
	push	0
	mov	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 5226 :                              uLth, 0, zCOREMEM_ALLOC, 0 );
; 5227 :       if ( lpQualAttrib->szValue == 0 )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN4@fnCreateQu

; 5228 :       {
; 5229 :          fnSqlDisplayQualMsg( lpView, lpQualView,

	push	0
	push	0
	push	OFFSET $SG13410
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlDisplayQualMsg
	add	esp, 20					; 00000014H

; 5230 :                               "Cannot allocate memory.", zERROR, 0 );
; 5231 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnCreateQu
$LN4@fnCreateQu:

; 5232 :       }
; 5233 : 
; 5234 :       lpQualAttrib->hValueMem = hMem;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [eax+36], ecx

; 5235 :       zstrcpy( lpQualAttrib->szValue, pchValue );

	mov	edx, DWORD PTR _pchValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN3@fnCreateQu:

; 5236 :    }
; 5237 : 
; 5238 :    if ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN5@fnCreateQu

; 5239 :    {
; 5240 :       lpQualAttrib->lpViewEntity = lpViewEntity;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+12], eax

; 5241 :       lpQualAttrib->lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN5@fnCreateQu:

; 5242 :    }
; 5243 : 
; 5244 :    if ( lpDataField )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	SHORT $LN6@fnCreateQu

; 5245 :    {
; 5246 :       lpQualAttrib->lpDataField  = lpDataField;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR [edx+24], eax

; 5247 :       lpQualAttrib->lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN6@fnCreateQu:

; 5248 :    }
; 5249 : 
; 5250 :    return( 0 );

	xor	eax, eax
$LN1@fnCreateQu:

; 5251 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCreateQualAttrib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_uLth$ = -4						; size = 4
_lpQualAttrib$ = 8					; size = 4
_pchOper$ = 12						; size = 4
_fnAllocOper PROC

; 5163 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5164 : 
; 5165 :    zULONG uLth = zstrlen( pchOper ) + 1;

	mov	eax, DWORD PTR _pchOper$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _uLth$[ebp], eax

; 5166 : 
; 5167 :    if ( lpQualAttrib->hOperMem )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN2@fnAllocOpe

; 5168 :    {
; 5169 :       SysFreeMemory( lpQualAttrib->hOperMem );

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	_SysFreeMemory@4

; 5170 :       lpQualAttrib->hOperMem = 0;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 5171 :       lpQualAttrib->szOper = 0;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [edx+32], 0
$LN2@fnAllocOpe:

; 5172 :    }
; 5173 : 
; 5174 :    if ( pchOper == 0 || *pchOper == 0 )

	cmp	DWORD PTR _pchOper$[ebp], 0
	je	SHORT $LN4@fnAllocOpe
	mov	eax, DWORD PTR _pchOper$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@fnAllocOpe
$LN4@fnAllocOpe:

; 5175 :       return;

	jmp	SHORT $LN1@fnAllocOpe
$LN3@fnAllocOpe:

; 5176 : 
; 5177 :    lpQualAttrib->hOperMem = SysAllocMemory( (zPVOID) &lpQualAttrib->szOper,

	push	0
	push	32768					; 00008000H
	push	0
	mov	edx, DWORD PTR _uLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	call	_SysAllocMemory@20
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 5178 :                                             uLth, 0, zCOREMEM_ALLOC, 0 );
; 5179 :    if ( lpQualAttrib->szOper )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN1@fnAllocOpe

; 5180 :       zstrcpy( lpQualAttrib->szOper, pchOper );

	mov	eax, DWORD PTR _pchOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcpy
	add	esp, 8
$LN1@fnAllocOpe:

; 5181 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnAllocOper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewEntity$ = -8					; size = 4
_lpQualAttrib$ = -4					; size = 4
_lpFirstQualAttrib$ = 8					; size = 4
_pchDBName$ = 12					; size = 4
_bDBNameIsDefault$ = 16					; size = 1
_fnSqlVerifyDataBase PROC

; 5115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5116 :    LPVIEWENTITY lpViewEntity;
; 5117 :    LPQUALATTRIB lpQualAttrib;
; 5118 : 
; 5119 :    for ( lpQualAttrib = lpFirstQualAttrib;

	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	DWORD PTR _lpQualAttrib$[ebp], eax
	jmp	SHORT $LN4@fnSqlVerif
$LN2@fnSqlVerif:

; 5121 :          lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
$LN4@fnSqlVerif:

; 5120 :          lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	$LN3@fnSqlVerif

; 5122 :    {
; 5123 :       // If the current lpQualAttrib has a subQualAttrib then make sure
; 5124 :       // that all the sub-quals are OK.
; 5125 :       if ( lpQualAttrib->lpFirstSubQualAttrib &&

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN5@fnSqlVerif
	movzx	ecx, BYTE PTR _bDBNameIsDefault$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchDBName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_fnSqlVerifyDataBase
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN5@fnSqlVerif

; 5126 :            !fnSqlVerifyDataBase( lpQualAttrib->lpFirstSubQualAttrib,
; 5127 :                                  pchDBName, bDBNameIsDefault ) )
; 5128 :       {
; 5129 :          return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnSqlVerif
$LN5@fnSqlVerif:

; 5130 :       }
; 5131 : 
; 5132 :       lpViewEntity = lpQualAttrib->lpViewEntity;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpViewEntity$[ebp], ecx

; 5133 : 
; 5134 :       // If there is no lpViewEntity, don't bother doing check.
; 5135 :       if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN6@fnSqlVerif

; 5136 :          continue;

	jmp	SHORT $LN2@fnSqlVerif
$LN6@fnSqlVerif:

; 5137 : 
; 5138 :       // If there is no DBName for lpViewEntity then the database name for
; 5139 :       // the entity is the default.  In this case, check...
; 5140 :       if ( lpViewEntity->szDBName[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+80]
	test	edx, edx
	jne	SHORT $LN7@fnSqlVerif

; 5141 :       {
; 5142 :          // ...to make sure that we are using the default DBName.  If...
; 5143 :          if ( bDBNameIsDefault )

	movzx	eax, BYTE PTR _bDBNameIsDefault$[ebp]
	test	eax, eax
	je	SHORT $LN8@fnSqlVerif

; 5144 :             continue;           // ...we are then continue, otherwise...

	jmp	SHORT $LN2@fnSqlVerif
	jmp	SHORT $LN7@fnSqlVerif
$LN8@fnSqlVerif:

; 5145 :          else
; 5146 :             return( FALSE );    // ...return FALSE.

	xor	eax, eax
	jmp	SHORT $LN1@fnSqlVerif
$LN7@fnSqlVerif:

; 5147 :       }
; 5148 : 
; 5149 :       // If DBNames aren't the same then return FALSE.
; 5150 :       if ( zstrcmpi( pchDBName, lpViewEntity->szDBName ) != 0 )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	edx, DWORD PTR _pchDBName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN10@fnSqlVerif

; 5151 :          return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnSqlVerif
$LN10@fnSqlVerif:

; 5152 : 
; 5153 :    } // for ( lpQualAttrib... )...

	jmp	$LN2@fnSqlVerif
$LN3@fnSqlVerif:

; 5154 : 
; 5155 :    // If we got this far then all the DBNames match up OK.
; 5156 :    return( TRUE );

	mov	eax, 1
$LN1@fnSqlVerif:

; 5157 : 
; 5158 : } // fnSqlVerifyDataBase

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlVerifyDataBase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewOD$ = -1024					; size = 4
tv86 = -1020						; size = 4
tv77 = -1016						; size = 4
tv66 = -1012						; size = 4
_bWarning$ = -1005					; size = 1
_szText$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpQualView$ = 12					; size = 4
_pchMsg$ = 16						; size = 4
_nErrorOrWarning$ = 20					; size = 2
_szQualEntity$ = 24					; size = 4
_fnSqlDisplayQualMsg PROC

; 5080 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1024				; 00000400H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5081 :    LPVIEWOD lpViewOD;
; 5082 :    zBOOL    bWarning = (nErrorOrWarning == zWARNING);

	movsx	eax, WORD PTR _nErrorOrWarning$[ebp]
	cmp	eax, 1
	jne	SHORT $LN4@fnSqlDispl
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN5@fnSqlDispl
$LN4@fnSqlDispl:
	mov	DWORD PTR tv66[ebp], 0
$LN5@fnSqlDispl:
	mov	cl, BYTE PTR tv66[ebp]
	mov	BYTE PTR _bWarning$[ebp], cl

; 5083 :    zCHAR    szText[ 1000 ];
; 5084 : 
; 5085 :    lpViewOD = (LPVIEWOD) MiGetViewEntityForView( lpView, 0 );

	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5086 :    zsprintf( szText, "%s loading qualification object while activating LOD "

	movzx	eax, BYTE PTR _bWarning$[ebp]
	test	eax, eax
	je	SHORT $LN6@fnSqlDispl
	mov	DWORD PTR tv77[ebp], OFFSET $SG13341
	jmp	SHORT $LN7@fnSqlDispl
$LN6@fnSqlDispl:
	mov	DWORD PTR tv77[ebp], OFFSET $SG13342
$LN7@fnSqlDispl:
	mov	ecx, DWORD PTR _pchMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR tv77[ebp]
	push	eax
	push	OFFSET $SG13343
	lea	ecx, DWORD PTR _szText$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 5087 :              "%s: %s", bWarning ? "Warning" : "Error", lpViewOD->szName,
; 5088 :              pchMsg );
; 5089 : 
; 5090 :    MessageSend( lpView, "KZH0201", bWarning ? "Qualification Object Warning" :

	movzx	edx, BYTE PTR _bWarning$[ebp]
	test	edx, edx
	je	SHORT $LN8@fnSqlDispl
	mov	DWORD PTR tv86[ebp], OFFSET $SG13344
	jmp	SHORT $LN9@fnSqlDispl
$LN8@fnSqlDispl:
	mov	DWORD PTR tv86[ebp], OFFSET $SG13345
$LN9@fnSqlDispl:
	push	0
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _szText$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv86[ebp]
	push	ecx
	push	OFFSET $SG13346
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MessageSend@24

; 5091 :                                               "Qualification Object Error",
; 5092 :                 szText, zMSGQ_SYSTEM_ERROR, 0 );
; 5093 : 
; 5094 :    TraceLineS( szText, "" );

	push	OFFSET $SG13347
	lea	eax, DWORD PTR _szText$[ebp]
	push	eax
	call	_TraceLineS@8

; 5095 : 
; 5096 :    if ( szQualEntity && szQualEntity[ 0 ] )

	cmp	DWORD PTR _szQualEntity$[ebp], 0
	je	SHORT $LN1@fnSqlDispl
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _szQualEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN1@fnSqlDispl

; 5097 :       DisplayEntityInstancePath( lpQualView, szQualEntity );

	mov	edx, DWORD PTR _szQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_DisplayEntityInstancePath@8
$LN1@fnSqlDispl:

; 5098 : 
; 5099 : }  /* fnSqlDisplayQualMsg */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlDisplayQualMsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpQualAttrib$ = -4					; size = 4
_lpFirstQualAttrib$ = 8					; size = 4
_fnSqlFreeQualAttrib PROC

; 5023 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@fnSqlFreeQ:

; 5024 :    LPQUALATTRIB lpQualAttrib;
; 5025 : 
; 5026 :    while ( lpFirstQualAttrib )

	cmp	DWORD PTR _lpFirstQualAttrib$[ebp], 0
	je	SHORT $LN1@fnSqlFreeQ

; 5027 :    {
; 5028 :       fnSqlFreeQualAttrib( lpFirstQualAttrib->lpFirstSubQualAttrib );

	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_fnSqlFreeQualAttrib
	add	esp, 4

; 5029 : 
; 5030 :       lpQualAttrib = lpFirstQualAttrib;

	mov	edx, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx

; 5031 :       lpFirstQualAttrib = lpFirstQualAttrib->lpNextQualAttrib;

	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpFirstQualAttrib$[ebp], ecx

; 5032 : 
; 5033 :       if ( lpQualAttrib->hOperMem )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN4@fnSqlFreeQ

; 5034 :          SysFreeMemory( lpQualAttrib->hOperMem );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	_SysFreeMemory@4
$LN4@fnSqlFreeQ:

; 5035 : 
; 5036 :       if ( lpQualAttrib->hValueMem )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN5@fnSqlFreeQ

; 5037 :          SysFreeMemory( lpQualAttrib->hValueMem );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	_SysFreeMemory@4
$LN5@fnSqlFreeQ:

; 5038 : 
; 5039 :       if ( lpQualAttrib->lpKeyList )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN6@fnSqlFreeQ

; 5040 :          free( lpQualAttrib->lpKeyList );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN6@fnSqlFreeQ:

; 5041 : 
; 5042 :       SysFreeMemory( lpQualAttrib->hMem );

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SysFreeMemory@4

; 5043 :    }

	jmp	SHORT $LN2@fnSqlFreeQ
$LN1@fnSqlFreeQ:

; 5044 : }  /* fnSqlFreeQualAttrib */

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlFreeQualAttrib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewAttrib$1 = -244					; size = 4
$T2 = -240						; size = 4
$T3 = -236						; size = 4
$T4 = -232						; size = 4
$T5 = -228						; size = 4
$T6 = -224						; size = 4
$T7 = -220						; size = 4
$T8 = -216						; size = 4
$T9 = -212						; size = 4
_n$ = -208						; size = 2
_szStr$ = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_lpQualAttrib$ = 8					; size = 4
_nIndent$ = 12						; size = 2
_fnSqlDisplayQualAttrib PROC

; 4904 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4905 :    zCHAR  szStr[ 200 ];
; 4906 :    zSHORT n;
; 4907 : 
; 4908 :    if ( lpQualAttrib == 0 )

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	jne	SHORT $LN7@fnSqlDispl

; 4909 :       return;

	jmp	$LN14@fnSqlDispl
$LN7@fnSqlDispl:

; 4910 : 
; 4911 :    nIndent += 5;

	movsx	eax, WORD PTR _nIndent$[ebp]
	add	eax, 5
	mov	WORD PTR _nIndent$[ebp], ax

; 4912 :    for ( n = 0; n < nIndent; n++ )

	xor	ecx, ecx
	mov	WORD PTR _n$[ebp], cx
	jmp	SHORT $LN4@fnSqlDispl
$LN2@fnSqlDispl:
	mov	dx, WORD PTR _n$[ebp]
	add	dx, 1
	mov	WORD PTR _n$[ebp], dx
$LN4@fnSqlDispl:
	movsx	eax, WORD PTR _n$[ebp]
	movsx	ecx, WORD PTR _nIndent$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN3@fnSqlDispl

; 4913 :       szStr[ n ] = ' ';

	movsx	edx, WORD PTR _n$[ebp]
	mov	BYTE PTR _szStr$[ebp+edx], 32		; 00000020H
	jmp	SHORT $LN2@fnSqlDispl
$LN3@fnSqlDispl:

; 4914 :    szStr[ n ] = 0;

	movsx	eax, WORD PTR _n$[ebp]
	mov	DWORD PTR $T9[ebp], eax
	cmp	DWORD PTR $T9[ebp], 200			; 000000c8H
	jae	SHORT $LN15@fnSqlDispl
	jmp	SHORT $LN16@fnSqlDispl
$LN15@fnSqlDispl:
	call	___report_rangecheckfailure
$LN16@fnSqlDispl:
	mov	ecx, DWORD PTR $T9[ebp]
	mov	BYTE PTR _szStr$[ebp+ecx], 0
$LN5@fnSqlDispl:

; 4915 : 
; 4916 :    while ( lpQualAttrib )

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	$LN14@fnSqlDispl

; 4917 :    {
; 4918 :       TraceLineS( "", "" );

	push	OFFSET $SG13260
	push	OFFSET $SG13261
	call	_TraceLineS@8

; 4919 :       TraceLineS( szStr, "--- QualAttrib ---" );

	push	OFFSET $SG13262
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_TraceLineS@8

; 4920 : 
; 4921 :       if ( lpQualAttrib->lpViewEntity )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN8@fnSqlDispl

; 4922 :       {
; 4923 :          zstrcat( szStr, "Entity name: " );

	push	OFFSET $SG13264
	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4924 :          TraceLineS( szStr, lpQualAttrib->lpViewEntity->szName );

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	call	_TraceLineS@8

; 4925 :          szStr[ n ] = 0;

	movsx	edx, WORD PTR _n$[ebp]
	mov	DWORD PTR $T8[ebp], edx
	cmp	DWORD PTR $T8[ebp], 200			; 000000c8H
	jae	SHORT $LN17@fnSqlDispl
	jmp	SHORT $LN18@fnSqlDispl
$LN17@fnSqlDispl:
	call	___report_rangecheckfailure
$LN18@fnSqlDispl:
	mov	eax, DWORD PTR $T8[ebp]
	mov	BYTE PTR _szStr$[ebp+eax], 0
$LN8@fnSqlDispl:

; 4926 :       }
; 4927 : 
; 4928 :       if ( lpQualAttrib->lpViewAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN9@fnSqlDispl

; 4929 :       {
; 4930 :          zstrcat( szStr, "Attrib name: " );

	push	OFFSET $SG13266
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4931 :          TraceLineS( szStr, lpQualAttrib->lpViewAttrib->szName );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_TraceLineS@8

; 4932 :          szStr[ n ] = 0;

	movsx	eax, WORD PTR _n$[ebp]
	mov	DWORD PTR $T7[ebp], eax
	cmp	DWORD PTR $T7[ebp], 200			; 000000c8H
	jae	SHORT $LN19@fnSqlDispl
	jmp	SHORT $LN20@fnSqlDispl
$LN19@fnSqlDispl:
	call	___report_rangecheckfailure
$LN20@fnSqlDispl:
	mov	ecx, DWORD PTR $T7[ebp]
	mov	BYTE PTR _szStr$[ebp+ecx], 0
$LN9@fnSqlDispl:

; 4933 :       }
; 4934 : 
; 4935 :       zstrcat( szStr, "Oper       : " );

	push	OFFSET $SG13267
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4936 :       TraceLineS( szStr, lpQualAttrib->szOper );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_TraceLineS@8

; 4937 :       szStr[ n ] = 0;

	movsx	eax, WORD PTR _n$[ebp]
	mov	DWORD PTR $T6[ebp], eax
	cmp	DWORD PTR $T6[ebp], 200			; 000000c8H
	jae	SHORT $LN21@fnSqlDispl
	jmp	SHORT $LN22@fnSqlDispl
$LN21@fnSqlDispl:
	call	___report_rangecheckfailure
$LN22@fnSqlDispl:
	mov	ecx, DWORD PTR $T6[ebp]
	mov	BYTE PTR _szStr$[ebp+ecx], 0

; 4938 : 
; 4939 :       if ( lpQualAttrib->szValue )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN10@fnSqlDispl

; 4940 :       {
; 4941 :          zstrcat( szStr, "Value      : " );

	push	OFFSET $SG13269
	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 4942 :          TraceLineS( szStr, lpQualAttrib->szValue );

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	call	_TraceLineS@8

; 4943 :          szStr[ n ] = 0;

	movsx	ecx, WORD PTR _n$[ebp]
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 200			; 000000c8H
	jae	SHORT $LN23@fnSqlDispl
	jmp	SHORT $LN24@fnSqlDispl
$LN23@fnSqlDispl:
	call	___report_rangecheckfailure
$LN24@fnSqlDispl:
	mov	edx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _szStr$[ebp+edx], 0
$LN10@fnSqlDispl:

; 4944 :       }
; 4945 : 
; 4946 :       if ( lpQualAttrib->lpSourceViewEntity )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN11@fnSqlDispl

; 4947 :       {
; 4948 :          zstrcat( szStr, "Source Entity name: " );

	push	OFFSET $SG13271
	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4949 :          TraceLineS( szStr, lpQualAttrib->lpSourceViewEntity->szName );

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+52]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	call	_TraceLineS@8

; 4950 :          szStr[ n ] = 0;

	movsx	edx, WORD PTR _n$[ebp]
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 200			; 000000c8H
	jae	SHORT $LN25@fnSqlDispl
	jmp	SHORT $LN26@fnSqlDispl
$LN25@fnSqlDispl:
	call	___report_rangecheckfailure
$LN26@fnSqlDispl:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szStr$[ebp+eax], 0
$LN11@fnSqlDispl:

; 4951 :       }
; 4952 : 
; 4953 :       if ( lpQualAttrib->lpSourceDataField )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN12@fnSqlDispl

; 4954 :       {
; 4955 :          LPVIEWATTRIB lpViewAttrib =

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$1[ebp], eax

; 4956 :                      zGETPTR( lpQualAttrib->lpSourceDataField->hViewAttrib );
; 4957 : 
; 4958 :          zstrcat( szStr, "Source Attrib name: " );

	push	OFFSET $SG13273
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4959 :          TraceLineS( szStr, lpViewAttrib->szName );

	mov	eax, DWORD PTR _lpViewAttrib$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	call	_TraceLineS@8

; 4960 :          szStr[ n ] = 0;

	movsx	edx, WORD PTR _n$[ebp]
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 200			; 000000c8H
	jae	SHORT $LN27@fnSqlDispl
	jmp	SHORT $LN28@fnSqlDispl
$LN27@fnSqlDispl:
	call	___report_rangecheckfailure
$LN28@fnSqlDispl:
	mov	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szStr$[ebp+eax], 0
$LN12@fnSqlDispl:

; 4961 :       }
; 4962 : 
; 4963 :       if ( lpQualAttrib->lpSourceView )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+60], 0
	je	SHORT $LN13@fnSqlDispl

; 4964 :       {
; 4965 :          TraceLineS( szStr, "SourceView is defined" );

	push	OFFSET $SG13275
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_TraceLineS@8

; 4966 :          szStr[ n ] = 0;

	movsx	eax, WORD PTR _n$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 200			; 000000c8H
	jae	SHORT $LN29@fnSqlDispl
	jmp	SHORT $LN30@fnSqlDispl
$LN29@fnSqlDispl:
	call	___report_rangecheckfailure
$LN30@fnSqlDispl:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szStr$[ebp+ecx], 0
$LN13@fnSqlDispl:

; 4967 :       }
; 4968 : 
; 4969 :       fnSqlDisplayQualAttrib( lpQualAttrib->lpFirstSubQualAttrib, nIndent );

	movzx	edx, WORD PTR _nIndent$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_fnSqlDisplayQualAttrib
	add	esp, 8

; 4970 :       lpQualAttrib = lpQualAttrib->lpNextQualAttrib;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], eax

; 4971 :    }

	jmp	$LN5@fnSqlDispl
$LN14@fnSqlDispl:

; 4972 : 
; 4973 : }  /* fnSqlDisplayQualAttrib */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlDisplayQualAttrib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -632					; size = 4
tv214 = -628						; size = 4
tv213 = -624						; size = 4
tv185 = -620						; size = 4
tv184 = -616						; size = 4
$T1 = -612						; size = 4
$T2 = -608						; size = 4
_lpViewAttrib$3 = -604					; size = 4
_lpDataField$ = -600					; size = 4
_nRC$ = -596						; size = 2
_lpSrchEntity$ = -592					; size = 4
_pchTgt$ = -588						; size = 4
_k$ = -584						; size = 2
_pchSrc$ = -580						; size = 4
_szTempStr$ = -576					; size = 500
_szAttributeName$ = -76					; size = 33
_szEntityName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_lpQualEntity$ = 20					; size = 4
_pchSqlCmd$ = 24					; size = 4
_lpBoundList$ = 28					; size = 4
_fnSqlBuildOpenSQL PROC

; 3899 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 632				; 00000278H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3900 :    zPCHAR       pchSrc;    // Points to current char in OpenSQL statement.
; 3901 :    zPCHAR       pchTgt;    // Points to current char in pchSqlCmd.
; 3902 :    zCHAR        szTempStr[ 500 ];
; 3903 :    zCHAR        szEntityName[ 33 ];
; 3904 :    zCHAR        szAttributeName[ 33 ];
; 3905 :    LPDATAFIELD  lpDataField;
; 3906 :    LPVIEWENTITY lpSrchEntity;
; 3907 :    LPDATARECORD lpDataRecord;
; 3908 :    zSHORT       k;
; 3909 :    zSHORT       nRC;
; 3910 : 
; 3911 :    pchSrc = lpQualEntity->pszOpenSQL;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pchSrc$[ebp], ecx

; 3912 :    pchTgt = pchSqlCmd;

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR _pchTgt$[ebp], edx
$LN2@fnSqlBuild:

; 3913 : 
; 3914 :    while ( *pchSrc )

	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@fnSqlBuild

; 3915 :    {
; 3916 :       // If the current char isn't a '@', then just copy the char and continue.
; 3917 :       if ( *pchSrc != '@' )

	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 64					; 00000040H
	je	SHORT $LN16@fnSqlBuild

; 3918 :       {
; 3919 :          *pchTgt++ = *pchSrc++;

	mov	ecx, DWORD PTR _pchTgt$[ebp]
	mov	edx, DWORD PTR _pchSrc$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTgt$[ebp], ecx
	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx

; 3920 :          continue;

	jmp	SHORT $LN2@fnSqlBuild
$LN16@fnSqlBuild:

; 3921 :       }
; 3922 : 
; 3923 :       // If the next char is also a '@', then copy '@@' as '@' and continue.
; 3924 :       if ( pchSrc[ 1 ] == '@' )

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 64					; 00000040H
	jne	SHORT $LN17@fnSqlBuild

; 3925 :       {
; 3926 :          *pchTgt++ = *pchSrc++;     // Copy '@'.

	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchTgt$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTgt$[ebp], eax
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchSrc$[ebp], ecx

; 3927 :          pchSrc++;                  // Skip second '@'.

	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx

; 3928 :          continue;

	jmp	$LN2@fnSqlBuild
$LN17@fnSqlBuild:

; 3929 :       }
; 3930 : 
; 3931 :       // We should now be pointing to a string with the form @EntName.Attr.
; 3932 :       // Get the Entity name.
; 3933 : 
; 3934 :       pchSrc++;   // Skip the '@'.

	mov	eax, DWORD PTR _pchSrc$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSrc$[ebp], eax

; 3935 :       k = 0;

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
$LN4@fnSqlBuild:

; 3936 :       while ( *pchSrc && IS_VALID_ID_CHAR( *pchSrc ) )

	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN5@fnSqlBuild
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@fnSqlBuild
	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	jne	SHORT $LN5@fnSqlBuild
$LN18@fnSqlBuild:

; 3937 :          szEntityName[ k++ ] = *pchSrc++;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchSrc$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szEntityName$[ebp+edx], cl
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
	mov	eax, DWORD PTR _pchSrc$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSrc$[ebp], eax
	jmp	SHORT $LN4@fnSqlBuild
$LN5@fnSqlBuild:

; 3938 : 
; 3939 :       szEntityName[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 33			; 00000021H
	jae	SHORT $LN26@fnSqlBuild
	jmp	SHORT $LN27@fnSqlBuild
$LN26@fnSqlBuild:
	call	___report_rangecheckfailure
$LN27@fnSqlBuild:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szEntityName$[ebp+edx], 0

; 3940 : 
; 3941 :       if ( *pchSrc )

	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN19@fnSqlBuild

; 3942 :          pchSrc++;  // Skip the '.'.

	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx
$LN19@fnSqlBuild:

; 3943 : 
; 3944 :       k = 0;

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
$LN6@fnSqlBuild:

; 3945 :       while ( *pchSrc && IS_VALID_ID_CHAR( *pchSrc ) )

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN7@fnSqlBuild
	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@fnSqlBuild
	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	jne	SHORT $LN7@fnSqlBuild
$LN20@fnSqlBuild:

; 3946 :          szAttributeName[ k++ ] = *pchSrc++;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchSrc$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szAttributeName$[ebp+ecx], al
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx
	jmp	SHORT $LN6@fnSqlBuild
$LN7@fnSqlBuild:

; 3947 : 
; 3948 :       szAttributeName[ k ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 33			; 00000021H
	jae	SHORT $LN28@fnSqlBuild
	jmp	SHORT $LN29@fnSqlBuild
$LN28@fnSqlBuild:
	call	___report_rangecheckfailure
$LN29@fnSqlBuild:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szAttributeName$[ebp+ecx], 0

; 3949 : 
; 3950 :       // Try getting the attribute value as a string.  If it failed, then
; 3951 :       // return with an error.  This call also verifies that the entity name
; 3952 :       // and attribute name are valid.
; 3953 :       nRC = GetStringFromAttribute( szTempStr, lpView, szEntityName,

	lea	edx, DWORD PTR _szAttributeName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTempStr$[ebp]
	push	edx
	call	_GetStringFromAttribute@16
	mov	WORD PTR _nRC$[ebp], ax

; 3954 :                                     szAttributeName );
; 3955 :       if ( nRC < -2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	jge	SHORT $LN21@fnSqlBuild

; 3956 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN25@fnSqlBuild
	jmp	SHORT $LN22@fnSqlBuild
$LN21@fnSqlBuild:

; 3957 :       else
; 3958 :       if ( nRC == -2 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -2					; fffffffeH
	jne	SHORT $LN22@fnSqlBuild

; 3959 :       {
; 3960 :          zsprintf( szTempStr, "Cursor is NULL for attribute '@%s.%s'",

	lea	edx, DWORD PTR _szAttributeName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	push	OFFSET $SG12887
	lea	ecx, DWORD PTR _szTempStr$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3961 :                    szEntityName, szAttributeName );
; 3962 :          MessageSend( lpView, "KZH0202", "Qualification Object Error",

	push	0
	push	1000					; 000003e8H
	lea	edx, DWORD PTR _szTempStr$[ebp]
	push	edx
	push	OFFSET $SG12888
	push	OFFSET $SG12889
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MessageSend@24

; 3963 :                       szTempStr, zMSGQ_SYSTEM_ERROR, 0 );
; 3964 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN25@fnSqlBuild
$LN22@fnSqlBuild:

; 3965 :       }
; 3966 : 
; 3967 :       // Find the lpViewEntity that matches szEntityName.
; 3968 :       for ( lpSrchEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrchEntity$[ebp], eax
	jmp	SHORT $LN10@fnSqlBuild
$LN8@fnSqlBuild:

; 3970 :             lpSrchEntity = zGETPTR( lpSrchEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpSrchEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrchEntity$[ebp], eax
$LN10@fnSqlBuild:

; 3969 :             zstrcmp( lpSrchEntity->szName, szEntityName ) != 0;

	mov	edx, DWORD PTR _lpSrchEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	movsx	ecx, BYTE PTR _szEntityName$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN32@fnSqlBuild
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrchEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN33@fnSqlBuild
$LN32@fnSqlBuild:
	mov	ecx, DWORD PTR _lpSrchEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	movsx	eax, BYTE PTR _szEntityName$[ebp]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN30@fnSqlBuild
	mov	DWORD PTR tv184[ebp], 1
	jmp	SHORT $LN31@fnSqlBuild
$LN30@fnSqlBuild:
	mov	DWORD PTR tv184[ebp], -1
$LN31@fnSqlBuild:
	mov	ecx, DWORD PTR tv184[ebp]
	mov	DWORD PTR tv185[ebp], ecx
$LN33@fnSqlBuild:
	cmp	DWORD PTR tv185[ebp], 0
	je	SHORT $LN9@fnSqlBuild

; 3971 :       {
; 3972 :          ; // Nothing needs to be done here.
; 3973 :       }

	jmp	$LN8@fnSqlBuild
$LN9@fnSqlBuild:

; 3974 : 
; 3975 :       // Now find the data field for the attribute.
; 3976 :       lpDataRecord = zGETPTR( lpSrchEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpSrchEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3977 :       for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN13@fnSqlBuild
$LN11@fnSqlBuild:

; 3979 :             lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN13@fnSqlBuild:

; 3978 :             lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN12@fnSqlBuild

; 3980 :       {
; 3981 :          LPVIEWATTRIB lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$3[ebp], eax

; 3982 : 
; 3983 :          if ( zstrcmp( szAttributeName, lpViewAttrib->szName ) == 0 )

	movsx	ecx, BYTE PTR _szAttributeName$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$3[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	ecx, eax
	jne	SHORT $LN36@fnSqlBuild
	mov	ecx, DWORD PTR _lpViewAttrib$3[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szAttributeName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN37@fnSqlBuild
$LN36@fnSqlBuild:
	movsx	eax, BYTE PTR _szAttributeName$[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$3[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN34@fnSqlBuild
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN35@fnSqlBuild
$LN34@fnSqlBuild:
	mov	DWORD PTR tv213[ebp], -1
$LN35@fnSqlBuild:
	mov	eax, DWORD PTR tv213[ebp]
	mov	DWORD PTR tv214[ebp], eax
$LN37@fnSqlBuild:
	cmp	DWORD PTR tv214[ebp], 0
	jne	SHORT $LN24@fnSqlBuild

; 3984 :             break;

	jmp	SHORT $LN12@fnSqlBuild
$LN24@fnSqlBuild:

; 3985 :       }

	jmp	$LN11@fnSqlBuild
$LN12@fnSqlBuild:

; 3986 : 
; 3987 :       // Convert the string value to a string the DB understands.
; 3988 :       fnSqlConvertStringToSqlString ( lpDataField, szTempStr, pchTgt,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTgt$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTempStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	call	_fnSqlConvertStringToSqlString
	add	esp, 16					; 00000010H
$LN14@fnSqlBuild:

; 3989 :                                       lpBoundList );
; 3990 :       mAdvanceToNull( pchTgt );

	mov	edx, DWORD PTR _pchTgt$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN15@fnSqlBuild
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTgt$[ebp], ecx
	jmp	SHORT $LN14@fnSqlBuild
$LN15@fnSqlBuild:

; 3991 : 
; 3992 :    } // while ( *pchSrc )...

	jmp	$LN2@fnSqlBuild
$LN3@fnSqlBuild:

; 3993 : 
; 3994 :    *pchTgt = 0;

	mov	edx, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [edx], 0

; 3995 : 
; 3996 :    return( 0 );

	xor	eax, eax
$LN25@fnSqlBuild:

; 3997 : 
; 3998 : } // fnSqlBuildOpenSQL

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlBuildOpenSQL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -20					; size = 4
_pchEntityJoinTable$ = -16				; size = 4
_lpChildEntity$ = -12					; size = 4
_nRC$ = -8						; size = 2
_bFirst$ = -1						; size = 1
_lpSql$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_fnSqlAddChildEntities PROC

; 3841 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 3842 :    zBOOL        bFirst;
; 3843 :    LPVIEWENTITY lpChildEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpChildEntity$[ebp], eax

; 3844 :    LPDATARECORD lpDataRecord;
; 3845 :    zSHORT       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 3846 :    zPCHAR       pchEntityJoinTable = lpSql->lpBoundList->pchEntityJoinTable;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR _pchEntityJoinTable$[ebp], edx

; 3847 : 
; 3848 :    // Loop through all the children of lpViewEntity.
; 3849 :    lpChildEntity = 0;

	mov	DWORD PTR _lpChildEntity$[ebp], 0

; 3850 :    bFirst = TRUE;

	mov	BYTE PTR _bFirst$[ebp], 1
$LN2@fnSqlAddCh:

; 3851 :    while ( SqlFindNextJoinableChild( lpViewEntity, &lpChildEntity,

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	push	edx
	lea	eax, DWORD PTR _lpChildEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	_SqlFindNextJoinableChild@20
	movsx	edx, ax
	test	edx, edx
	je	$LN3@fnSqlAddCh

; 3852 :                                      lpSql->lpLoadViewEntity,
; 3853 :                                      lpSql->lpFirstQualEntity, lpSql->lpBoundList ) )
; 3854 :    {
; 3855 :       // Ok, we now have to add this entity to the select statement as a join.
; 3856 :       // First, add the table name.
; 3857 :       lpDataRecord = zGETPTR( lpChildEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3858 :       fnAddTableToFrom( lpSql, 0, lpChildEntity, 0 );

	push	0
	mov	edx, DWORD PTR _lpChildEntity$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H

; 3859 : 
; 3860 :       // Set a flag to tell the dbhandler that this entity will be loaded via
; 3861 :       // a join.
; 3862 :       if ( pchEntityJoinTable )

	cmp	DWORD PTR _pchEntityJoinTable$[ebp], 0
	je	SHORT $LN4@fnSqlAddCh

; 3863 :          pchEntityJoinTable[ lpChildEntity->nHierNbr ] |= zSELECT_JOINEDWITHPARENT;

	mov	ecx, DWORD PTR _lpChildEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _pchEntityJoinTable$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	or	ecx, 1
	mov	edx, DWORD PTR _lpChildEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	edx, DWORD PTR _pchEntityJoinTable$[ebp]
	mov	BYTE PTR [edx+eax], cl
$LN4@fnSqlAddCh:

; 3864 : 
; 3865 :       // Now add the column names.  Since we know that we've already added the
; 3866 :       // column names of the parent (lpViewEntity) then add a ',' to the table
; 3867 :       // name list.
; 3868 :       fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG12823
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 3869 :       fnSqlBuildColumnList( lpChildEntity, lpSql,

	push	5
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	push	eax
	call	_fnSqlBuildColumnList
	add	esp, 12					; 0000000cH

; 3870 :                             zFULLY_QUALIFIED | zNO_HIDDEN );
; 3871 : 
; 3872 :       nRC = 1; // indicate that Joins were generated

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 3873 :    }

	jmp	$LN2@fnSqlAddCh
$LN3@fnSqlAddCh:

; 3874 : 
; 3875 :    if ( bFirst == FALSE && lpViewEntity->hParent )

	movzx	edx, BYTE PTR _bFirst$[ebp]
	test	edx, edx
	jne	SHORT $LN5@fnSqlAddCh
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN5@fnSqlAddCh

; 3876 :       fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12825
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN5@fnSqlAddCh:

; 3877 : 
; 3878 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 3879 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlAddChildEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpBoundList$ = -28					; size = 4
_lpView$ = -24						; size = 4
_lpViewAttrib$ = -20					; size = 4
_lpDataRecord$ = -16					; size = 4
_lpViewEntity$ = -12					; size = 4
_lpDataField$ = -8					; size = 4
_nKeyCnt$ = -4						; size = 2
_lpQualEntity$ = 8					; size = 4
_lpQualAttrib$ = 12					; size = 4
_lpSql$ = 16						; size = 4
_fnSqlBuildIS_Clause PROC

; 3270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 3271 :    LPVIEWENTITY lpViewEntity;
; 3272 :    LPVIEWATTRIB lpViewAttrib;
; 3273 :    LPDATARECORD lpDataRecord;
; 3274 :    LPDATAFIELD  lpDataField;
; 3275 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 3276 :    zVIEW        lpView;
; 3277 :    zSHORT       nKeyCnt;
; 3278 : 
; 3279 :    nKeyCnt      = 0;

	xor	edx, edx
	mov	WORD PTR _nKeyCnt$[ebp], dx

; 3280 :    lpView       = lpQualAttrib->lpSourceView;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _lpView$[ebp], ecx

; 3281 :    lpViewEntity = lpQualAttrib->lpSourceViewEntity;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 3282 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3283 : 
; 3284 :    for ( lpDataField  = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN4@fnSqlBuild
$LN2@fnSqlBuild:

; 3286 :          lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@fnSqlBuild:

; 3285 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN3@fnSqlBuild

; 3287 :    {
; 3288 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 3289 :       if ( lpViewAttrib->bKey == FALSE )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN5@fnSqlBuild

; 3290 :          continue;

	jmp	SHORT $LN2@fnSqlBuild
$LN5@fnSqlBuild:

; 3291 : 
; 3292 :       if ( nKeyCnt > 0 )

	movsx	edx, WORD PTR _nKeyCnt$[ebp]
	test	edx, edx
	jle	SHORT $LN6@fnSqlBuild

; 3293 :          fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12623
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
$LN6@fnSqlBuild:

; 3294 : 
; 3295 :       fnSqlAddStringToWhere( lpSql,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3296 :                              fnTableName( lpSql,
; 3297 :                                           lpDataRecord->szRecordName,
; 3298 :                                           lpViewEntity ) );
; 3299 :       fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12624
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3300 :       fnSqlAddStringToWhere( lpSql, lpDataField->szFldName );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3301 :       fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12625
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 3302 :       fnSqlGetAttributeValue( lpView, lpDataField, lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH

; 3303 : 
; 3304 :       nKeyCnt++;

	mov	dx, WORD PTR _nKeyCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nKeyCnt$[ebp], dx

; 3305 :    }

	jmp	$LN2@fnSqlBuild
$LN3@fnSqlBuild:

; 3306 : 
; 3307 :    return( 0 );

	xor	eax, eax

; 3308 : 
; 3309 : }  /* fnSqlBuildIS_Clause */

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlBuildIS_Clause ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -1912					; size = 4
_lpBoundList$ = -1908					; size = 4
_lpViewEntity$ = -1904					; size = 4
_lpSql$ = -1900						; size = 4
_SubselectSql$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpQualEntity$ = 12					; size = 4
_lpQualAttrib$ = 16					; size = 4
_lpParentSql$ = 20					; size = 4
_fnSqlBuildSubselect PROC

; 3200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1912				; 00000778H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 3201 :    LPVIEWENTITY       lpViewEntity;
; 3202 :    LPDATARECORD       lpDataRecord;
; 3203 :    LPBOUNDLIST        lpBoundList = lpParentSql->lpBoundList;

	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 3204 :    SqlStatementRecord SubselectSql;
; 3205 :    LPSQLSTATEMENT     lpSql;
; 3206 : 
; 3207 :    lpViewEntity = lpQualAttrib->lpViewEntity;

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 3208 :    lpDataRecord = lpQualAttrib->lpDataRecord;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _lpDataRecord$[ebp], edx

; 3209 : 
; 3210 :    lpSql = &SubselectSql;

	lea	eax, DWORD PTR _SubselectSql$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 3211 :    fnSqlInitSqlStatement( lpSql, zSUBSELECT_CMD, 0, lpView, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	2
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 3212 : 
; 3213 :    // Since we're dealing with a sub-select, the set the sub level as 1 more
; 3214 :    // than the parent's sub level.
; 3215 :    lpSql->lpParentSql = lpParentSql;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [ecx+1882], edx

; 3216 :    lpSql->nSubLevel   = lpParentSql->nSubLevel + 1;

	mov	eax, DWORD PTR _lpParentSql$[ebp]
	movsx	ecx, WORD PTR [eax+62]
	add	ecx, 1
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [edx+62], cx

; 3217 : 
; 3218 :    fnSqlAddStringToSql( lpSql, lpQualAttrib->szOper );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 3219 :    fnSqlAddStringToSql( lpSql, " ( SELECT " );

	push	OFFSET $SG12588
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 3220 : 
; 3221 :    // Add the QualEntity table to pchFromTable so that fnSqlBuildColumnList
; 3222 :    // will use any generated alias names.  Last argument is TRUE which means
; 3223 :    // add the table no matter what.
; 3224 :    fnAddTableToFrom( lpSql, 0, lpViewEntity, AT_ALWAYS_ADD );

	push	1
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H

; 3225 : 
; 3226 :    fnSqlBuildColumnList( lpViewEntity, lpSql, zKEYS_ONLY | zFULLY_QUALIFIED );

	push	3
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_fnSqlBuildColumnList
	add	esp, 12					; 0000000cH

; 3227 : 
; 3228 :    // Add table representing lpViewEntity to select statement.
; 3229 :    fnSqlAddTableToSelect( lpView, lpViewEntity, TRUE, lpSql );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlAddTableToSelect
	add	esp, 16					; 00000010H

; 3230 : 
; 3231 :    // If Subselect is further qualified, add qualification to WHERE clause.
; 3232 :    if ( lpQualAttrib->lpFirstSubQualAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN2@fnSqlBuild

; 3233 :    {
; 3234 :       fnSqlAddQualToWhere ( lpView, lpQualEntity,

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlAddQualToWhere
	add	esp, 16					; 00000010H
$LN2@fnSqlBuild:

; 3235 :                             lpQualAttrib->lpFirstSubQualAttrib, lpSql );
; 3236 :    }
; 3237 : 
; 3238 :    if ( fnSqlWhereIsNotEmpty( lpSql ) )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@fnSqlBuild

; 3239 :    {
; 3240 :       fnSqlAddStringToWhere( lpParentSql, lpSql->pchSqlCmd );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 3241 :       fnSqlAddStringToWhere( lpParentSql, " FROM " );

	push	OFFSET $SG12591
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3242 :       fnSqlAddStringToWhere( lpParentSql, lpSql->pchFrom );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 3243 :       fnSqlAddStringToWhere( lpParentSql, " WHERE " );

	push	OFFSET $SG12592
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3244 :       if ( lpSql->nComponentCount > 1 )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	cmp	edx, 1
	jle	SHORT $LN4@fnSqlBuild

; 3245 :          fnSqlAddStringToWhere( lpParentSql, " ( " );

	push	OFFSET $SG12594
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
$LN4@fnSqlBuild:

; 3246 :       fnSqlAddStringToWhere( lpParentSql, lpSql->pchWhere );

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3247 :       if ( lpSql->nComponentCount > 1 )

	mov	eax, DWORD PTR _lpSql$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	cmp	ecx, 1
	jle	SHORT $LN5@fnSqlBuild

; 3248 :          fnSqlAddStringToWhere( lpParentSql, " ) " );

	push	OFFSET $SG12596
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [eax+44], esi
$LN5@fnSqlBuild:

; 3249 :       fnSqlAddStringToWhere( lpParentSql, " )" );

	push	OFFSET $SG12597
	mov	ecx, DWORD PTR _lpParentSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpParentSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpParentSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN3@fnSqlBuild:

; 3250 :    }
; 3251 : 
; 3252 :    fnSqlFreeSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 3253 :    return( 0 );

	xor	eax, eax

; 3254 : 
; 3255 : }  /* fnSqlBuildSubselect */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlBuildSubselect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpBoundList$ = -424					; size = 4
_lpRelRecord$ = -420					; size = 4
_lpDataRecord$ = -416					; size = 4
_lpParent$ = -412					; size = 4
_nViewCount$ = -408					; size = 2
_lpViewEntityList$ = -404				; size = 400
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_bParentsOnly$ = 16					; size = 1
_lpSql$ = 20						; size = 4
_fnSqlAddTableToSelect PROC

; 3106 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 424				; 000001a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 3107 :    LPDATARECORD lpDataRecord;
; 3108 :    LPVIEWENTITY lpParent;
; 3109 :    LPVIEWENTITY lpViewEntityList[ MAX_TABLES ];
; 3110 :    LPRELRECORD  lpRelRecord;
; 3111 :    zSHORT       nViewCount = 0;

	xor	eax, eax
	mov	WORD PTR _nViewCount$[ebp], ax

; 3112 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+1886]
	mov	DWORD PTR _lpBoundList$[ebp], edx

; 3113 : 
; 3114 :    lpViewEntityList[ nViewCount++ ] = lpViewEntity;

	movsx	eax, WORD PTR _nViewCount$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpViewEntityList$[ebp+eax*4], ecx
	mov	dx, WORD PTR _nViewCount$[ebp]
	add	dx, 1
	mov	WORD PTR _nViewCount$[ebp], dx

; 3115 : 
; 3116 :    // Make sure that all the parent tables have been added to the select.
; 3117 :    // If we are using LEFT joins, we'll call ourselves recursively.  If not,
; 3118 :    // we'll loop through the parents and add them.  We have to do this because
; 3119 :    // if we are not using left joins we need to keep track of the tables
; 3120 :    // that we add.
; 3121 :    if ( lpSql->bUseLeftJoin )

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	shr	ecx, 2
	and	ecx, 1
	je	$LN8@fnSqlAddTa

; 3122 :    {
; 3123 :       lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$[ebp], eax

; 3124 :       lpDataRecord = zGETPTR( lpParent->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpParent$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3125 :       lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 3126 : 
; 3127 :       if ( fnSqlFindTableName( lpDataRecord->szRecordName,
; 3128 :                                lpParent, lpSql, FALSE ) == -1 )

	push	0
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	push	ecx
	call	_fnSqlFindTableName
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN10@fnSqlAddTa

; 3129 :       {
; 3130 :          // Table not in select statement.  Add it.
; 3131 :          fnSqlAddTableToSelect ( lpView, lpParent, FALSE, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpParent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlAddTableToSelect
	add	esp, 16					; 00000010H
$LN10@fnSqlAddTa:

; 3132 :       }
; 3133 :    }

	jmp	$LN9@fnSqlAddTa
$LN8@fnSqlAddTa:

; 3134 :    else
; 3135 :    {
; 3136 :       // We'll keep track of all the tables that haven't been added to the select
; 3137 :       // so that we can add foreign keys later.
; 3138 :       for ( lpParent = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$[ebp], eax
	jmp	SHORT $LN4@fnSqlAddTa
$LN2@fnSqlAddTa:

; 3140 :             lpParent = zGETPTR( lpParent->hParent ) )

	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$[ebp], eax
$LN4@fnSqlAddTa:

; 3139 :             lpParent;

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	$LN9@fnSqlAddTa

; 3141 :       {
; 3142 :          lpDataRecord = zGETPTR( lpParent->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpParent$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3143 :          lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 3144 : 
; 3145 :          // If the table exists in the current select statement, then
; 3146 :          // stop searching.
; 3147 :          if ( fnSqlFindTableName( lpDataRecord->szRecordName,
; 3148 :                                   lpParent, lpSql, FALSE ) != -1 )

	push	0
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	push	ecx
	call	_fnSqlFindTableName
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $LN11@fnSqlAddTa

; 3149 :             break;

	jmp	SHORT $LN9@fnSqlAddTa
$LN11@fnSqlAddTa:

; 3150 : 
; 3151 :          fnAddTableToFrom( lpSql, 0, lpParent, 0 );

	push	0
	mov	eax, DWORD PTR _lpParent$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H

; 3152 : 
; 3153 :          // Save the entity for later.
; 3154 :          lpViewEntityList[ nViewCount++ ] = lpParent;

	movsx	edx, WORD PTR _nViewCount$[ebp]
	mov	eax, DWORD PTR _lpParent$[ebp]
	mov	DWORD PTR _lpViewEntityList$[ebp+edx*4], eax
	mov	cx, WORD PTR _nViewCount$[ebp]
	add	cx, 1
	mov	WORD PTR _nViewCount$[ebp], cx

; 3155 :       }

	jmp	$LN2@fnSqlAddTa
$LN9@fnSqlAddTa:

; 3156 :    }
; 3157 : 
; 3158 :    if ( bParentsOnly == FALSE )

	movzx	edx, BYTE PTR _bParentsOnly$[ebp]
	test	edx, edx
	jne	SHORT $LN12@fnSqlAddTa

; 3159 :       fnAddTableToFrom( lpSql, 0, lpViewEntity, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H
$LN12@fnSqlAddTa:

; 3160 : 
; 3161 :    // If we are using left joins, then the qualification for the new tables
; 3162 :    // as already been added in the FROM clause so we're done.
; 3163 :    if ( lpSql->bUseLeftJoin )

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+76]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN13@fnSqlAddTa

; 3164 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSqlAddTa
$LN13@fnSqlAddTa:

; 3165 : 
; 3166 :    // Now that we've added all the table names to the table list, add the
; 3167 :    // qualification for the foreign keys.
; 3168 :    for ( nViewCount--; nViewCount >= 0; nViewCount-- )

	mov	cx, WORD PTR _nViewCount$[ebp]
	sub	cx, 1
	mov	WORD PTR _nViewCount$[ebp], cx
	jmp	SHORT $LN7@fnSqlAddTa
$LN5@fnSqlAddTa:
	mov	dx, WORD PTR _nViewCount$[ebp]
	sub	dx, 1
	mov	WORD PTR _nViewCount$[ebp], dx
$LN7@fnSqlAddTa:
	movsx	eax, WORD PTR _nViewCount$[ebp]
	test	eax, eax
	jl	$LN6@fnSqlAddTa

; 3169 :    {
; 3170 :       lpDataRecord = zGETPTR( lpViewEntityList[ nViewCount ]->hFirstDataRecord );

	movsx	ecx, WORD PTR _nViewCount$[ebp]
	mov	edx, DWORD PTR _lpViewEntityList$[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3171 :       lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 3172 : 
; 3173 :       // If the ViewEntity doesn't have a rel record then don't try adding the
; 3174 :       // foreign keys (there aren't any!).  This is probably only valid if the
; 3175 :       // entity is the root.
; 3176 :       if ( lpRelRecord == 0 )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	jne	SHORT $LN14@fnSqlAddTa

; 3177 :          continue;

	jmp	SHORT $LN5@fnSqlAddTa
$LN14@fnSqlAddTa:

; 3178 : 
; 3179 :       if ( !fnSqlWhereIsEmpty( lpSql ) )

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN15@fnSqlAddTa

; 3180 :          fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12562
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
$LN15@fnSqlAddTa:

; 3181 : 
; 3182 :       fnSqlBuildForeignKeys( lpView, lpViewEntityList[ nViewCount ],

	push	1
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	movsx	eax, WORD PTR _nViewCount$[ebp]
	mov	ecx, DWORD PTR _lpViewEntityList$[ebp+eax*4]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlBuildForeignKeys
	add	esp, 16					; 00000010H

; 3183 :                              lpSql, zSUB_ENTITY );
; 3184 :    }

	jmp	$LN5@fnSqlAddTa
$LN6@fnSqlAddTa:

; 3185 : 
; 3186 :    return( 0 );

	xor	eax, eax
$LN1@fnSqlAddTa:

; 3187 : 
; 3188 : }  /* fnSqlAddTableToSelect */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlAddTableToSelect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpBoundList$ = -124					; size = 4
_lpViewOD$1 = -120					; size = 4
_lpTempDataField$2 = -116				; size = 4
_lpSrcDataRecord$3 = -112				; size = 4
_lpSrcViewAttrib$4 = -108				; size = 4
_lpForeignDataRecord$5 = -104				; size = 4
_lpTempViewAttrib$6 = -100				; size = 4
_lpRelDataRecord$7 = -96				; size = 4
_lpRelViewAttrib$8 = -92				; size = 4
_lpSrcDataRecord$9 = -88				; size = 4
_lpSrcViewAttrib$10 = -84				; size = 4
_lpSrcDataField$11 = -80				; size = 4
_lpSrcViewEntity$12 = -76				; size = 4
_lpForeignEntity$13 = -72				; size = 4
_lpRelDataField$14 = -68				; size = 4
_lpRelViewEntity$15 = -64				; size = 4
_lpDataRecord$ = -60					; size = 4
_lpSrcDataField$16 = -56				; size = 4
_lpSrcDataField$17 = -52				; size = 4
_lpRelDataRecord$18 = -48				; size = 4
_lpRelRecord$19 = -44					; size = 4
_lpSrcViewEntity$20 = -40				; size = 4
_lpRelViewEntity$21 = -36				; size = 4
_lpRelViewAttrib$22 = -32				; size = 4
_lpRelDataField$23 = -28				; size = 4
_lpTempRelField$24 = -24				; size = 4
_lpRelRecord$ = -20					; size = 4
_lpRelField$ = -16					; size = 4
_nNull$ = -12						; size = 2
_nRC$ = -8						; size = 2
_bUseLiteralValue$25 = -2				; size = 1
_bAddAnd$ = -1						; size = 1
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpSql$ = 16						; size = 4
_nControl$ = 20						; size = 2
_fnSqlBuildForeignKeys PROC

; 2759 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	push	esi

; 2760 :    LPDATARECORD lpDataRecord;
; 2761 :    LPRELRECORD  lpRelRecord;
; 2762 :    LPRELFIELD   lpRelField;
; 2763 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 2764 :    zBOOL        bAddAnd;
; 2765 :    zSHORT       nNull;
; 2766 :    zSHORT       nRC;
; 2767 : 
; 2768 :    // Check to see if the current entity was joined with the entity we are
; 2769 :    // loading.  If it was, then the FK qualification was already added.
; 2770 :    if ( lpSql->lpLoadViewEntity != lpViewEntity &&
; 2771 :         lpSql->bUseLeftJoin &&

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+68]
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN10@fnSqlBuild
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN10@fnSqlBuild
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+68]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	_SqlEntityValidForJoin@12
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@fnSqlBuild

; 2772 :         SqlEntityValidForJoin( lpViewEntity, lpSql->lpLoadViewEntity,
; 2773 :                                lpSql->lpFirstQualEntity ) )
; 2774 :    {
; 2775 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSqlBuild
$LN10@fnSqlBuild:

; 2776 :    }
; 2777 : 
; 2778 :    nRC          = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2779 :    nNull        = 0;

	xor	ecx, ecx
	mov	WORD PTR _nNull$[ebp], cx

; 2780 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2781 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 2782 : 
; 2783 :    fnSqlIncrementComponentCount( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	cx, WORD PTR [eax+56]
	add	cx, 1
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [edx+56], cx

; 2784 : 
; 2785 :    // If the table name for lpViewEntity is not already part of the SELECT
; 2786 :    // statement then add it to the FROM clause.
; 2787 :    fnAddTableToFrom( lpSql, 0, lpViewEntity, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H

; 2788 : 
; 2789 :    // If we are using an outer join in this statement and if we are
; 2790 :    // adding the FK's for an entity that is not the root of the join then
; 2791 :    // qualification has already been added as part of the "LEFT JOIN"
; 2792 :    // statment.
; 2793 :    if ( lpSql->bUseLeftJoin &&

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+76]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN11@fnSqlBuild
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN11@fnSqlBuild

; 2794 :         lpSql->lpLoadViewEntity != lpViewEntity )
; 2795 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSqlBuild
$LN11@fnSqlBuild:

; 2796 : 
; 2797 :    if ( lpRelRecord->hFirstRelField )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN12@fnSqlBuild

; 2798 :          fnSqlAddStringToWhere( lpSql, " ( " );

	push	OFFSET $SG12482
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN12@fnSqlBuild:

; 2799 : 
; 2800 :    // Add the rel fields (for the view entity) to the WHERE clause.
; 2801 :    bAddAnd = FALSE;

	mov	BYTE PTR _bAddAnd$[ebp], 0

; 2802 :    for ( lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax
	jmp	SHORT $LN4@fnSqlBuild
$LN2@fnSqlBuild:

; 2804 :          lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN4@fnSqlBuild:

; 2803 :          lpRelField;

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN3@fnSqlBuild

; 2805 :    {
; 2806 :       if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	edx, 50					; 00000032H
	jne	$LN13@fnSqlBuild

; 2807 :       {
; 2808 :          LPDATAFIELD  lpSrcDataField;
; 2809 :          LPVIEWATTRIB lpSrcViewAttrib;
; 2810 :          LPVIEWENTITY lpSrcViewEntity;
; 2811 : 
; 2812 :          lpSrcDataField  = zGETPTR( lpRelField->hSrcDataField );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$17[ebp], eax

; 2813 :          lpSrcViewAttrib = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpSrcDataField$17[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewAttrib$10[ebp], eax

; 2814 :          lpSrcViewEntity = zGETPTR( lpSrcViewAttrib->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcViewAttrib$10[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewEntity$20[ebp], eax

; 2815 : 
; 2816 :          // If we are using an outer join in this statement then some of
; 2817 :          // the qualification has already been added.
; 2818 :          if ( lpSql->bUseLeftJoin &&

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN15@fnSqlBuild
	mov	edx, DWORD PTR _lpSrcViewEntity$20[ebp]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN15@fnSqlBuild

; 2819 :               lpSrcViewEntity == lpViewEntity )
; 2820 :          {
; 2821 :             // Already added.  Continue with the next lpRelField.
; 2822 :             continue;

	jmp	SHORT $LN2@fnSqlBuild
$LN15@fnSqlBuild:

; 2823 :          }
; 2824 : 
; 2825 :          if ( bAddAnd )

	movzx	eax, BYTE PTR _bAddAnd$[ebp]
	test	eax, eax
	je	SHORT $LN16@fnSqlBuild

; 2826 :             fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12488
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
	jmp	SHORT $LN17@fnSqlBuild
$LN16@fnSqlBuild:

; 2827 :          else
; 2828 :             // We want to add an " AND " next time through the loop.
; 2829 :             bAddAnd = TRUE;

	mov	BYTE PTR _bAddAnd$[ebp], 1
$LN17@fnSqlBuild:

; 2830 : 
; 2831 :          fnSqlAddStringToWhere( lpSql, fnTableName( lpSql,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnTableName@12
	push	eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2832 :                                                     lpRelRecord->szRecordName,
; 2833 :                                                     lpViewEntity ) );
; 2834 :          fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12489
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2835 :          fnSqlAddStringToWhere( lpSql, lpRelField->szFldName );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2836 :          fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12490
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2837 : 
; 2838 :          // In m-m relationships, we need to qualify using the correspondence
; 2839 :          // table.  If the current rel field is stored in the correspondence
; 2840 :          // then we compare the column from above (from the c-table) with the
; 2841 :          // the column in the child (non-correspondence) table.
; 2842 :          if ( lpSrcViewEntity == lpViewEntity )

	mov	eax, DWORD PTR _lpSrcViewEntity$20[ebp]
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	jne	$LN18@fnSqlBuild

; 2843 :          {
; 2844 :             fnSqlAddStringToWhere( lpSql,

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnTableName@12
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2845 :                                    fnTableName( lpSql,
; 2846 :                                                 lpDataRecord->szRecordName,
; 2847 :                                                 lpViewEntity ) );
; 2848 :             fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12493
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2849 :             fnSqlAddStringToWhere( lpSql,

	mov	edx, DWORD PTR _lpSrcDataField$17[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2850 :                                    lpSrcDataField->szFldName );
; 2851 :          }

	jmp	$LN19@fnSqlBuild
$LN18@fnSqlBuild:

; 2852 :          else
; 2853 :          if ( nControl == zROOT_ENTITY )

	movsx	edx, WORD PTR _nControl$[ebp]
	cmp	edx, 2
	jne	SHORT $LN20@fnSqlBuild

; 2854 :          {
; 2855 :             // If we get here then we are building the foreign keys for the
; 2856 :             // entity that we are loading.  In this case the key values from
; 2857 :             // the parent entities have already been loaded so we only need
; 2858 :             // to copy the attribute values from the parent entities.
; 2859 : 
; 2860 :             nRC = fnSqlGetAttributeValue( lpView,

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2861 :                                           zGETPTR( lpRelField->hSrcDataField ),
; 2862 :                                           lpSql );
; 2863 : 
; 2864 :             // If nRC == 1 then the attribute value is null, so set nNull
; 2865 :             // to 1.
; 2866 :             if ( nRC == 1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN22@fnSqlBuild

; 2867 :                nNull = 1;

	mov	edx, 1
	mov	WORD PTR _nNull$[ebp], dx
$LN22@fnSqlBuild:

; 2868 :          }

	jmp	$LN19@fnSqlBuild
$LN20@fnSqlBuild:

; 2869 :          else
; 2870 :          {
; 2871 :             LPDATARECORD lpSrcDataRecord =

	mov	eax, DWORD PTR _lpSrcViewEntity$20[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataRecord$9[ebp], eax

; 2872 :                               zGETPTR( lpSrcViewEntity->hFirstDataRecord );
; 2873 : 
; 2874 :             // If we get here then we are building the foreign keys for an
; 2875 :             // entity/table that is being used to qualify the entity/table
; 2876 :             // that we are loading.  This means that the foreign key values
; 2877 :             // must come from a parent table that is part of the current
; 2878 :             // select.
; 2879 : 
; 2880 :             fnSqlAddStringToWhere( lpSql,

	mov	edx, DWORD PTR _lpSrcViewEntity$20[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcDataRecord$9[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2881 :                                    fnTableName( lpSql,
; 2882 :                                                 lpSrcDataRecord->szRecordName,
; 2883 :                                                 lpSrcViewEntity ) );
; 2884 :             fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12497
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2885 :             fnSqlAddStringToWhere( lpSql, lpSrcDataField->szFldName );

	mov	eax, DWORD PTR _lpSrcDataField$17[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN19@fnSqlBuild:

; 2886 :          }
; 2887 :       } // if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	jmp	$LN14@fnSqlBuild
$LN13@fnSqlBuild:

; 2888 :       else
; 2889 :       if ( lpRelRecord->cOwnerMember == zDBH_PARENT_IS_SOURCE )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 79					; 0000004fH
	jne	$LN23@fnSqlBuild

; 2890 :       {
; 2891 :          LPDATAFIELD  lpRelDataField;
; 2892 :          LPDATAFIELD  lpSrcDataField;
; 2893 :          LPVIEWATTRIB lpRelViewAttrib;
; 2894 :          LPVIEWENTITY lpRelViewEntity;
; 2895 :          LPDATARECORD lpRelDataRecord;
; 2896 : 
; 2897 :          if ( bAddAnd )

	movzx	edx, BYTE PTR _bAddAnd$[ebp]
	test	edx, edx
	je	SHORT $LN25@fnSqlBuild

; 2898 :             fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12502
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
	jmp	SHORT $LN26@fnSqlBuild
$LN25@fnSqlBuild:

; 2899 :          else
; 2900 :             // We want to add an " AND " next time through the loop.
; 2901 :             bAddAnd = TRUE;

	mov	BYTE PTR _bAddAnd$[ebp], 1
$LN26@fnSqlBuild:

; 2902 : 
; 2903 :          lpSrcDataField  = zGETPTR( lpRelField->hSrcDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$16[ebp], eax

; 2904 :          lpRelDataField  = zGETPTR( lpRelField->hRelDataField );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataField$14[ebp], eax

; 2905 :          lpRelViewAttrib = zGETPTR( lpRelDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpRelDataField$14[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelViewAttrib$8[ebp], eax

; 2906 :          lpRelViewEntity = zGETPTR( lpRelViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpRelViewAttrib$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelViewEntity$15[ebp], eax

; 2907 :          lpRelDataRecord = zGETPTR( lpRelViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpRelViewEntity$15[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataRecord$7[ebp], eax

; 2908 : 
; 2909 :          fnSqlAddStringToWhere( lpSql,

	mov	eax, DWORD PTR _lpRelViewEntity$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelDataRecord$7[ebp]
	add	ecx, 15					; 0000000fH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnTableName@12
	push	eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2910 :                                 fnTableName( lpSql,
; 2911 :                                              lpRelDataRecord->szRecordName,
; 2912 :                                              lpRelViewEntity ) );
; 2913 :          fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12503
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2914 :          fnSqlAddStringToWhere( lpSql, lpRelDataField->szFldName );

	mov	ecx, DWORD PTR _lpRelDataField$14[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2915 : 
; 2916 :          fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12504
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2917 : 
; 2918 :          if ( nControl == zSUB_ENTITY )

	movsx	eax, WORD PTR _nControl$[ebp]
	cmp	eax, 1
	jne	$LN27@fnSqlBuild

; 2919 :          {
; 2920 :             LPVIEWENTITY lpForeignEntity;
; 2921 :             LPVIEWATTRIB lpTempViewAttrib;
; 2922 :             LPDATARECORD lpForeignDataRecord;
; 2923 : 
; 2924 :             // If we get here then we are building the foreign keys for an
; 2925 :             // entity/table that is being used to qualify the entity/table
; 2926 :             // that we are loading.  This means that the foreign key values
; 2927 :             // must come from a parent table that is part of the current
; 2928 :             // select.
; 2929 : 
; 2930 :             lpTempViewAttrib    = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpSrcDataField$16[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTempViewAttrib$6[ebp], eax

; 2931 :             lpForeignEntity     = zGETPTR( lpTempViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpTempViewAttrib$6[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpForeignEntity$13[ebp], eax

; 2932 :             lpForeignDataRecord = zGETPTR( lpForeignEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpForeignEntity$13[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpForeignDataRecord$5[ebp], eax

; 2933 : 
; 2934 :             fnSqlAddStringToWhere( lpSql,

	mov	ecx, DWORD PTR _lpForeignEntity$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpForeignDataRecord$5[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnTableName@12
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2935 :                                    fnTableName( lpSql,
; 2936 :                                                 lpForeignDataRecord->szRecordName,
; 2937 :                                                 lpForeignEntity ) );
; 2938 :             fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12507
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2939 :             fnSqlAddStringToWhere( lpSql, lpSrcDataField->szFldName );

	mov	edx, DWORD PTR _lpSrcDataField$16[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2940 : 
; 2941 :          }

	jmp	SHORT $LN28@fnSqlBuild
$LN27@fnSqlBuild:

; 2942 :          else
; 2943 :          {
; 2944 :             // If we get here then we are building the foreign keys for the
; 2945 :             // entity that we are loading.  In this case the key values from
; 2946 :             // the parent entities have already been loaded so we only need
; 2947 :             // to copy the attribute values from the parent entities.
; 2948 : 
; 2949 :             nRC = fnSqlGetAttributeValue( lpView, lpSrcDataField, lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcDataField$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2950 : 
; 2951 :             // If nRC == 1 then the attribute value is null, so set nNull
; 2952 :             // to 1.
; 2953 :             if ( nRC == 1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	jne	SHORT $LN28@fnSqlBuild

; 2954 :                nNull = 1;

	mov	eax, 1
	mov	WORD PTR _nNull$[ebp], ax
$LN28@fnSqlBuild:

; 2955 :          }
; 2956 :       } // if ( lpRelRecord->cOwnerMember == zDBH_PARENT_IS_SOURCE )...

	jmp	$LN14@fnSqlBuild
$LN23@fnSqlBuild:

; 2957 :       else
; 2958 :       if ( lpRelRecord->cOwnerMember == zDBH_CHILD_IS_SOURCE )

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	edx, 77					; 0000004dH
	jne	$LN14@fnSqlBuild

; 2959 :       {
; 2960 :          zBOOL        bUseLiteralValue;
; 2961 :          LPVIEWENTITY lpSrcViewEntity;
; 2962 :          LPDATARECORD lpSrcDataRecord;
; 2963 :          LPDATAFIELD  lpRelDataField;
; 2964 :          LPDATAFIELD  lpSrcDataField;
; 2965 :          LPVIEWATTRIB lpSrcViewAttrib;
; 2966 :          LPVIEWATTRIB lpRelViewAttrib;
; 2967 :          LPVIEWENTITY lpRelViewEntity;
; 2968 :          LPDATARECORD lpRelDataRecord;
; 2969 : 
; 2970 :          if ( bAddAnd )

	movzx	eax, BYTE PTR _bAddAnd$[ebp]
	test	eax, eax
	je	SHORT $LN31@fnSqlBuild

; 2971 :             fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12512
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
	jmp	SHORT $LN32@fnSqlBuild
$LN31@fnSqlBuild:

; 2972 :          else
; 2973 :             // We want to add an " AND " next time through the loop.
; 2974 :             bAddAnd = TRUE;

	mov	BYTE PTR _bAddAnd$[ebp], 1
$LN32@fnSqlBuild:

; 2975 : 
; 2976 :          lpSrcDataField  = zGETPTR( lpRelField->hSrcDataField );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$11[ebp], eax

; 2977 :          lpRelDataField  = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataField$23[ebp], eax

; 2978 :          lpSrcViewAttrib = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpSrcDataField$11[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewAttrib$4[ebp], eax

; 2979 :          lpRelViewAttrib = zGETPTR( lpRelDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpRelDataField$23[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelViewAttrib$22[ebp], eax

; 2980 :          lpRelViewEntity = zGETPTR( lpRelViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpRelViewAttrib$22[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelViewEntity$21[ebp], eax

; 2981 :          lpRelDataRecord = zGETPTR( lpRelViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpRelViewEntity$21[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataRecord$18[ebp], eax

; 2982 :          lpSrcViewEntity = zGETPTR( lpSrcViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpSrcViewAttrib$4[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewEntity$12[ebp], eax

; 2983 :          lpSrcDataRecord = zGETPTR( lpSrcViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpSrcViewEntity$12[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataRecord$3[ebp], eax

; 2984 : 
; 2985 :          fnSqlAddStringToWhere( lpSql,

	mov	ecx, DWORD PTR _lpSrcViewEntity$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcDataRecord$3[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnTableName@12
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2986 :                                 fnTableName( lpSql,
; 2987 :                                              lpSrcDataRecord->szRecordName,
; 2988 :                                              lpSrcViewEntity ) );
; 2989 :          fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12513
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2990 :          fnSqlAddStringToWhere( lpSql, lpSrcDataField->szFldName );

	mov	edx, DWORD PTR _lpSrcDataField$11[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2991 : 
; 2992 :          fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12514
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2993 : 
; 2994 :          if ( nControl == zROOT_ENTITY )

	movsx	ecx, WORD PTR _nControl$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN33@fnSqlBuild

; 2995 :             bUseLiteralValue = TRUE;

	mov	BYTE PTR _bUseLiteralValue$25[ebp], 1
	jmp	$LN34@fnSqlBuild
$LN33@fnSqlBuild:

; 2996 :          else
; 2997 :          {
; 2998 :             LPRELRECORD lpRelRecord;
; 2999 : 
; 3000 :             // If we get here then we are building the foreign keys for an
; 3001 :             // entity/table that is being used to qualify the entity/table
; 3002 :             // that we are loading.  This means that the foreign key values
; 3003 :             // must come from a parent table that is part of the current
; 3004 :             // select.
; 3005 : 
; 3006 :             // Note that lpRelViewEntity points to a parent of lpViewEntity.
; 3007 :             bUseLiteralValue = FALSE;

	mov	BYTE PTR _bUseLiteralValue$25[ebp], 0

; 3008 : 
; 3009 :             lpRelRecord = zGETPTR( lpRelDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpRelDataRecord$18[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$19[ebp], eax
$LN5@fnSqlBuild:

; 3010 : 
; 3011 :             while ( lpRelViewAttrib->bKey && lpRelRecord &&

	mov	ecx, DWORD PTR _lpRelViewAttrib$22[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	je	$LN34@fnSqlBuild
	cmp	DWORD PTR _lpRelRecord$19[ebp], 0
	je	$LN34@fnSqlBuild
	mov	eax, DWORD PTR _lpRelRecord$19[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 77					; 0000004dH
	jne	$LN34@fnSqlBuild

; 3012 :                     lpRelRecord->cOwnerMember == zDBH_CHILD_IS_SOURCE )
; 3013 :             {
; 3014 :                LPRELFIELD   lpTempRelField;
; 3015 : 
; 3016 :                // Find the rel field for the qualifying attribute.
; 3017 :                for ( lpTempRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$19[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTempRelField$24[ebp], eax
	jmp	SHORT $LN9@fnSqlBuild
$LN7@fnSqlBuild:

; 3019 :                      lpTempRelField = zGETPTR( lpTempRelField->hNextRelField ) )

	mov	ecx, DWORD PTR _lpTempRelField$24[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTempRelField$24[ebp], eax
$LN9@fnSqlBuild:

; 3018 :                      lpTempRelField;

	cmp	DWORD PTR _lpTempRelField$24[ebp], 0
	je	SHORT $LN8@fnSqlBuild

; 3020 :                {
; 3021 :                   LPDATAFIELD lpTempDataField = zGETPTR( lpTempRelField->hSrcDataField );

	mov	eax, DWORD PTR _lpTempRelField$24[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTempDataField$2[ebp], eax

; 3022 : 
; 3023 :                   if ( lpTempDataField->hViewAttrib ==

	mov	edx, DWORD PTR _lpTempDataField$2[ebp]
	mov	eax, DWORD PTR _lpRelDataField$23[ebp]
	mov	ecx, DWORD PTR [edx+6]
	cmp	ecx, DWORD PTR [eax+6]
	jne	SHORT $LN35@fnSqlBuild

; 3024 :                                                 lpRelDataField->hViewAttrib )
; 3025 :                      break;

	jmp	SHORT $LN8@fnSqlBuild
$LN35@fnSqlBuild:

; 3026 :                }

	jmp	SHORT $LN7@fnSqlBuild
$LN8@fnSqlBuild:

; 3027 : 
; 3028 :                if ( lpTempRelField )

	cmp	DWORD PTR _lpTempRelField$24[ebp], 0
	je	SHORT $LN36@fnSqlBuild

; 3029 :                {
; 3030 :                   // Change the column we are qualifying on.
; 3031 :                   lpRelDataField  = zGETPTR( lpTempRelField->hRelDataField );

	mov	edx, DWORD PTR _lpTempRelField$24[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataField$23[ebp], eax

; 3032 :                   lpRelViewAttrib = zGETPTR( lpRelDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpRelDataField$23[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelViewAttrib$22[ebp], eax

; 3033 :                   lpRelViewEntity = zGETPTR( lpRelViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpRelViewAttrib$22[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelViewEntity$21[ebp], eax

; 3034 :                   lpRelDataRecord = zGETPTR( lpRelViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpRelViewEntity$21[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataRecord$18[ebp], eax

; 3035 :                   lpRelRecord     = zGETPTR( lpRelDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpRelDataRecord$18[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$19[ebp], eax

; 3036 : 
; 3037 :                   // If the new RelViewEntity is the parent of the entity we
; 3038 :                   // are loading then it has already been loaded so we can
; 3039 :                   // now use a literal value instead of a column value.
; 3040 :                   if ( lpRelViewEntity ==

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	cmp	DWORD PTR _lpRelViewEntity$21[ebp], eax
	jne	SHORT $LN38@fnSqlBuild

; 3041 :                                  zGETPTR( lpSql->lpLoadViewEntity->hParent ) )
; 3042 :                      bUseLiteralValue = TRUE;

	mov	BYTE PTR _bUseLiteralValue$25[ebp], 1
$LN38@fnSqlBuild:

; 3043 :                }

	jmp	SHORT $LN37@fnSqlBuild
$LN36@fnSqlBuild:

; 3044 :                else
; 3045 :                {
; 3046 :                   LPVIEWOD lpViewOD;
; 3047 : 
; 3048 :                   lpViewOD = (LPVIEWOD) MiGetViewEntityForView( lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 3049 :                   TraceLineS( "(#11) View OD Name = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG12521
	call	_TraceLineS@8

; 3050 :                   TraceLineS( "(#11) Building foreign keys for entity", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG12522
	call	_TraceLineS@8

; 3051 :                   TraceLineS( "(#11) RelViewAttrib = ", lpRelViewAttrib->szName );

	mov	eax, DWORD PTR _lpRelViewAttrib$22[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG12523
	call	_TraceLineS@8

; 3052 :                   SysMessageBox( lpView, "Zeidon SQL Generator Error",

	push	1
	push	OFFSET $SG12524
	push	OFFSET $SG12525
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 3053 :                                  "Internal error #11--can't find RelRecord", 1 );
; 3054 :                   break;

	jmp	SHORT $LN34@fnSqlBuild
$LN37@fnSqlBuild:

; 3055 :                }
; 3056 :             } // while...

	jmp	$LN5@fnSqlBuild
$LN34@fnSqlBuild:

; 3057 :          }
; 3058 : 
; 3059 :          if ( bUseLiteralValue )

	movzx	edx, BYTE PTR _bUseLiteralValue$25[ebp]
	test	edx, edx
	je	SHORT $LN39@fnSqlBuild

; 3060 :          {
; 3061 :             // If we get here then we are building the foreign keys for the
; 3062 :             // entity that we are loading.  In this case the key values from
; 3063 :             // the parent entities have already been loaded so we only need
; 3064 :             // to copy the attribute values from the parent entities.
; 3065 : 
; 3066 :             nRC = fnSqlGetAttributeValue( lpView, lpRelDataField, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelDataField$23[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 3067 : 
; 3068 :             // If nRC == 1 then the attribute value is null, so set nNull
; 3069 :             // to 1.
; 3070 :             if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $LN41@fnSqlBuild

; 3071 :                nNull = 1;

	mov	ecx, 1
	mov	WORD PTR _nNull$[ebp], cx
$LN41@fnSqlBuild:

; 3072 :          }

	jmp	$LN14@fnSqlBuild
$LN39@fnSqlBuild:

; 3073 :          else
; 3074 :          {
; 3075 :             fnSqlAddStringToWhere( lpSql,

	mov	edx, DWORD PTR _lpRelViewEntity$21[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelDataRecord$18[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3076 :                                    fnTableName( lpSql,
; 3077 :                                                 lpRelDataRecord->szRecordName,
; 3078 :                                                 lpRelViewEntity ) );
; 3079 :             fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12529
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3080 :             fnSqlAddStringToWhere( lpSql, lpRelDataField->szFldName );

	mov	eax, DWORD PTR _lpRelDataField$23[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN14@fnSqlBuild:

; 3081 :          }
; 3082 :       } // if ( lpRelRecord->cOwnerMember == zDBH_CHILD_IS_SOURCE )...
; 3083 : 
; 3084 :    } // for ( lpRelField )...

	jmp	$LN2@fnSqlBuild
$LN3@fnSqlBuild:

; 3085 : 
; 3086 :    fnSqlAddStringToWhere( lpSql, " )" );

	push	OFFSET $SG12530
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 3087 : 
; 3088 :    return( nNull );

	mov	ax, WORD PTR _nNull$[ebp]
$LN1@fnSqlBuild:

; 3089 : 
; 3090 : }  /* fnSqlBuildForeignKeys */

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlBuildForeignKeys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewAttrib$ = -496					; size = 4
_lpRelRecord$1 = -492					; size = 4
_lpRelDataField$2 = -488				; size = 4
_lpRelField$3 = -484					; size = 4
_lpDataRecord$ = -480					; size = 4
_lpBoundList$ = -476					; size = 4
_lpSrcDataField$4 = -472				; size = 4
_bKeyFound$ = -468					; size = 2
_lpDataField$ = -464					; size = 4
_szMsg$5 = -460						; size = 400
_pchValue$6 = -60					; size = 25
_pchValue$7 = -32					; size = 25
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_lpSql$ = 20						; size = 4
_nQual$ = 24						; size = 2
_fnSqlBuildWhere PROC

; 1985 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 496				; 000001f0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1986 :    LPDATARECORD lpDataRecord;
; 1987 :    LPDATAFIELD  lpDataField;
; 1988 :    LPVIEWATTRIB lpViewAttrib;
; 1989 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 1990 :    zSHORT       bKeyFound = FALSE;

	xor	edx, edx
	mov	WORD PTR _bKeyFound$[ebp], dx

; 1991 : 
; 1992 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 1993 : 
; 1994 :    // Start dks ... 2006.01.25
; 1995 :    if ( nQual & zFOREIGN_KEY )

	movsx	edx, WORD PTR _nQual$[ebp]
	and	edx, 16					; 00000010H
	je	$LN5@fnSqlBuild

; 1996 :    {
; 1997 :       LPRELRECORD  lpRelRecord = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$1[ebp], eax

; 1998 :       LPRELFIELD   lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$3[ebp], eax

; 1999 :       LPDATAFIELD  lpSrcDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	ecx, DWORD PTR _lpRelField$3[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$4[ebp], eax

; 2000 :       LPDATAFIELD  lpRelDataField = zGETPTR( lpRelField->hRelDataField );

	mov	eax, DWORD PTR _lpRelField$3[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataField$2[ebp], eax

; 2001 : 
; 2002 :       TraceLineS( "fnSqlBuildWhere found ForeignKey: ", lpRelDataField->szFldName );

	mov	edx, DWORD PTR _lpRelDataField$2[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG12128
	call	_TraceLineS@8

; 2003 :       TraceLineS( "fnSqlBuildWhere found Attribute: ", lpSrcDataField->szFldName );

	mov	eax, DWORD PTR _lpSrcDataField$4[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG12129
	call	_TraceLineS@8

; 2004 : 
; 2005 :       fnSqlAddStringToWhere( lpSql, " ( " );

	push	OFFSET $SG12130
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2006 :       fnSqlAddStringToWhere( lpSql, lpRelDataField->szFldName );

	mov	eax, DWORD PTR _lpRelDataField$2[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2007 :       if ( SqlAttributeIsNull( lpView, lpSrcDataField, lpBoundList ) )

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcDataField$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SqlAttributeIsNull@12
	cwde
	test	eax, eax
	je	SHORT $LN6@fnSqlBuild

; 2008 :       {
; 2009 :          // If the attribute is null, then write 'null'-value into the
; 2010 :          // statement 29.10.1997, RG
; 2011 :          zCHAR pchValue[ 25 ];
; 2012 : 
; 2013 :          fnSqlAddStringToWhere( lpSql, " IS " );

	push	OFFSET $SG12133
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2014 :          fnSqlGetNullString( pchValue, lpSrcDataField, lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcDataField$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchValue$7[ebp]
	push	edx
	call	_fnSqlGetNullString
	add	esp, 12					; 0000000cH

; 2015 :          fnSqlAddStringToWhere( lpSql, pchValue );

	lea	eax, DWORD PTR _pchValue$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2016 :       }

	jmp	SHORT $LN7@fnSqlBuild
$LN6@fnSqlBuild:

; 2017 :       else
; 2018 :       {
; 2019 :          fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12134
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2020 :          fnSqlGetAttributeValue( lpView, lpSrcDataField, lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcDataField$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
$LN7@fnSqlBuild:

; 2021 :       }
; 2022 : 
; 2023 :       fnSqlAddStringToWhere( lpSql, " )" );

	push	OFFSET $SG12135
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2024 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSqlBuild
$LN5@fnSqlBuild:

; 2025 :    }
; 2026 :    // End dks ... 2006.01.25
; 2027 : 
; 2028 :    for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN4@fnSqlBuild
$LN2@fnSqlBuild:

; 2030 :          lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@fnSqlBuild:

; 2029 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN3@fnSqlBuild

; 2031 :    {
; 2032 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2033 : 
; 2034 :       if ( lpViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN8@fnSqlBuild

; 2035 :          continue;

	jmp	SHORT $LN2@fnSqlBuild
$LN8@fnSqlBuild:

; 2036 : 
; 2037 :       bKeyFound = TRUE;

	mov	eax, 1
	mov	WORD PTR _bKeyFound$[ebp], ax

; 2038 :       if ( fnSqlWhereIsEmpty( lpSql ) )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@fnSqlBuild

; 2039 :          fnSqlAddStringToWhere( lpSql, " ( " );

	push	OFFSET $SG12139
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
	jmp	SHORT $LN10@fnSqlBuild
$LN9@fnSqlBuild:

; 2040 :       else
; 2041 :          fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12140
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
$LN10@fnSqlBuild:

; 2042 : 
; 2043 :       if ( nQual == zFULLY_QUALIFIED )

	movsx	edx, WORD PTR _nQual$[ebp]
	cmp	edx, 1
	jne	SHORT $LN11@fnSqlBuild

; 2044 :       {
; 2045 :          fnSqlAddStringToWhere( lpSql, fnTableName( lpSql,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnTableName@12
	push	eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2046 :                                                     lpDataRecord->szRecordName,
; 2047 :                                                     lpViewEntity ) );
; 2048 :          fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12142
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi
$LN11@fnSqlBuild:

; 2049 :       }
; 2050 : 
; 2051 :       fnSqlAddStringToWhere( lpSql, lpDataField->szFldName );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2052 :       if ( SqlAttributeIsNull( lpView, lpDataField, lpBoundList ) )

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SqlAttributeIsNull@12
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN12@fnSqlBuild

; 2053 :       {
; 2054 :          // If the attribute is null, then write 'null'-value into the
; 2055 :          // statement 29.10.1997, RG
; 2056 :          zCHAR pchValue[ 25 ];
; 2057 : 
; 2058 :          fnSqlAddStringToWhere( lpSql, " IS " );

	push	OFFSET $SG12145
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2059 :          fnSqlGetNullString( pchValue, lpDataField, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchValue$6[ebp]
	push	eax
	call	_fnSqlGetNullString
	add	esp, 12					; 0000000cH

; 2060 :          fnSqlAddStringToWhere( lpSql, pchValue );

	lea	ecx, DWORD PTR _pchValue$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2061 :       }

	jmp	SHORT $LN13@fnSqlBuild
$LN12@fnSqlBuild:

; 2062 :       else
; 2063 :       {
; 2064 :          fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12146
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2065 :          fnSqlGetAttributeValue( lpView, lpDataField, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
$LN13@fnSqlBuild:

; 2066 :       }
; 2067 :    } // for ( ... )...

	jmp	$LN2@fnSqlBuild
$LN3@fnSqlBuild:

; 2068 : 
; 2069 :    if ( bKeyFound == FALSE )

	movsx	eax, WORD PTR _bKeyFound$[ebp]
	test	eax, eax
	jne	SHORT $LN14@fnSqlBuild

; 2070 :    {
; 2071 :       zCHAR szMsg[ 400 ];
; 2072 : 
; 2073 :       zstrcpy( szMsg, "SQL Error creating WHERE clause -- no key attribute "

	push	OFFSET $SG12148
	lea	ecx, DWORD PTR _szMsg$5[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2074 :                "found in object definition.\nObject name = " );
; 2075 :       zstrcat( szMsg, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szMsg$5[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2076 :       zstrcat( szMsg, "\nEntity name = " );

	push	OFFSET $SG12149
	lea	ecx, DWORD PTR _szMsg$5[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2077 :       zstrcat( szMsg, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _szMsg$5[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2078 :       IssueError( lpView, 16, 16, szMsg );

	lea	ecx, DWORD PTR _szMsg$5[ebp]
	push	ecx
	push	16					; 00000010H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_IssueError@16

; 2079 : 
; 2080 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSqlBuild
$LN14@fnSqlBuild:

; 2081 :    }
; 2082 : 
; 2083 :    fnSqlAddStringToWhere( lpSql, " )" );

	push	OFFSET $SG12150
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 2084 :    return( 0 );

	xor	eax, eax
$LN1@fnSqlBuild:

; 2085 : 
; 2086 : }  /* fnSqlBuildWhere */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlBuildWhere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpBoundList$ = -32					; size = 4
_lpAttribFlags$1 = -28					; size = 4
_lpRelRecord$ = -24					; size = 4
_lpDataRecord$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpDataField$ = -12					; size = 4
_nLongCharCount$ = -8					; size = 2
_bFirstTime$ = -1					; size = 1
_lpViewEntity$ = 8					; size = 4
_lpSql$ = 12						; size = 4
_nControl$ = 16						; size = 2
_fnSqlBuildColumnValueList PROC

; 1904 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 1905 :    zBOOL        bFirstTime;
; 1906 :    zSHORT       nLongCharCount;
; 1907 :    LPVIEWATTRIB lpViewAttrib;
; 1908 :    LPDATARECORD lpDataRecord;
; 1909 :    LPDATAFIELD  lpDataField;
; 1910 :    LPRELRECORD  lpRelRecord;
; 1911 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 1912 : 
; 1913 :    lpDataRecord  = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 1914 :    lpRelRecord   = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 1915 : 
; 1916 :    nLongCharCount = 0;

	xor	eax, eax
	mov	WORD PTR _nLongCharCount$[ebp], ax

; 1917 :    bFirstTime     = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 1918 :    for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN4@fnSqlBuild
$LN2@fnSqlBuild:

; 1920 :          lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@fnSqlBuild:

; 1919 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN3@fnSqlBuild

; 1921 :    {
; 1922 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1923 : 
; 1924 :       // If the attribute is not persistent then try again with next field.
; 1925 :       if ( lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN5@fnSqlBuild

; 1926 :          continue;

	jmp	SHORT $LN2@fnSqlBuild
$LN5@fnSqlBuild:

; 1927 : 
; 1928 :       // If the attribute is an auto seq attribute and the parent relationship
; 1929 :       // is many-to-many then the attribute is stored in the corresponding
; 1930 :       // table and not include in the column value list.
; 1931 :       if ( lpViewAttrib->bAutoSeq &&
; 1932 :            lpRelRecord && lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN6@fnSqlBuild
	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	SHORT $LN6@fnSqlBuild
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN6@fnSqlBuild

; 1933 :       {
; 1934 :          continue;

	jmp	SHORT $LN2@fnSqlBuild
$LN6@fnSqlBuild:

; 1935 :       }
; 1936 : 
; 1937 :       // Check to see if we only want updated attributes (for INSERT).
; 1938 :       if ( nControl & zUPDATED_ONLY )

	movsx	ecx, WORD PTR _nControl$[ebp]
	and	ecx, 8
	je	SHORT $LN7@fnSqlBuild

; 1939 :       {
; 1940 :          LPATTRIBFLAGS lpAttribFlags;
; 1941 : 
; 1942 :          GetAttributeFlags( &lpAttribFlags, lpSql->lpView,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	lea	eax, DWORD PTR _lpAttribFlags$1[ebp]
	push	eax
	call	_GetAttributeFlags@16

; 1943 :                             lpViewEntity, lpViewAttrib );
; 1944 : 
; 1945 :          // If the attribute hasn't been updated then forget it.
; 1946 :          if ( lpAttribFlags->u.bFlags.bUpdated == FALSE )

	mov	ecx, DWORD PTR _lpAttribFlags$1[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN7@fnSqlBuild

; 1947 :             continue;

	jmp	$LN2@fnSqlBuild
$LN7@fnSqlBuild:

; 1948 :       }
; 1949 : 
; 1950 :       // If column is not the first then append comma.
; 1951 :       if ( bFirstTime )

	movzx	eax, BYTE PTR _bFirstTime$[ebp]
	test	eax, eax
	je	SHORT $LN9@fnSqlBuild

; 1952 :          bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0
	jmp	SHORT $LN10@fnSqlBuild
$LN9@fnSqlBuild:

; 1953 :       else
; 1954 :          fnSqlAddStringToSql( lpSql, " , " );

	push	OFFSET $SG12082
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi
$LN10@fnSqlBuild:

; 1955 : 
; 1956 :       // Insert the text value of the attribute.  It is possible that instead
; 1957 :       // of the value we will insert a place-holder for bound attributes.
; 1958 :       fnSqlGetAttributeValue( lpSql->lpView, lpDataField, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH

; 1959 : 
; 1960 :    } // for (; lpDataField )...

	jmp	$LN2@fnSqlBuild
$LN3@fnSqlBuild:

; 1961 : 
; 1962 :    if ( lpBoundList->nBoundCount > 0 )

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	test	edx, edx
	jle	SHORT $LN11@fnSqlBuild

; 1963 :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnSqlBuild
	jmp	SHORT $LN1@fnSqlBuild
$LN11@fnSqlBuild:

; 1964 :    else
; 1965 :       return( 0 );

	xor	eax, eax
$LN1@fnSqlBuild:

; 1966 : 
; 1967 : }  /* fnSqlBuildColumnValueList */

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlBuildColumnValueList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpRelRecord$ = -232					; size = 4
_lpDataRecord$ = -228					; size = 4
_nRC$ = -224						; size = 2
_lpBoundList$ = -220					; size = 4
_lpDataField$ = -216					; size = 4
_lpViewAttrib$ = -212					; size = 4
_bFirstTime$ = -205					; size = 1
_szColumnName$ = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_lpSql$ = 12						; size = 4
_fnSqlBuildIntoList PROC

; 1813 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1814 :    LPVIEWATTRIB lpViewAttrib;
; 1815 :    LPDATAFIELD  lpDataField;
; 1816 :    LPDATARECORD lpDataRecord;
; 1817 :    LPRELRECORD  lpRelRecord;
; 1818 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 1819 :    zCHAR        szColumnName[ 200 ];
; 1820 :    zBOOL        bFirstTime;
; 1821 :    zSHORT       nRC;
; 1822 : 
; 1823 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 1824 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 1825 : 
; 1826 :    fnSqlAddStringToSql( lpSql, " INTO " );

	push	OFFSET $SG12046
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 1827 : 
; 1828 :    bFirstTime = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 1829 :    for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN4@fnSqlBuild
$LN2@fnSqlBuild:

; 1831 :          lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@fnSqlBuild:

; 1830 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN3@fnSqlBuild

; 1832 :    {
; 1833 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1834 : 
; 1835 :       // We don't want hidden attributes UNLESS THEY ARE KEYS.  Keys, even if
; 1836 :       // they are hidden, should be included.  Same thing with auto sequencing
; 1837 :       // attributes.
; 1838 :       if ( lpViewAttrib->bHidden && lpViewAttrib->bKey == FALSE &&
; 1839 :                                     lpViewAttrib->bForeignKey == FALSE &&

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN5@fnSqlBuild
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN5@fnSqlBuild
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 2
	and	ecx, 1
	jne	SHORT $LN5@fnSqlBuild
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN5@fnSqlBuild

; 1840 :                                     lpViewAttrib->bAutoSeq == FALSE )
; 1841 :       {
; 1842 :          continue;

	jmp	$LN2@fnSqlBuild
$LN5@fnSqlBuild:

; 1843 :       }
; 1844 : 
; 1845 :       // If the attribute is an Auto Seq attribute and the relationship
; 1846 :       // is many-to-many then the attribute is stored in the corrsponding
; 1847 :       // table.  If the command type is also INSERT then the attribute is
; 1848 :       // not to be included in this list.
; 1849 :       if ( lpViewAttrib->bAutoSeq &&
; 1850 :            lpRelRecord && lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY &&

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN6@fnSqlBuild
	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	SHORT $LN6@fnSqlBuild
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	jne	SHORT $LN6@fnSqlBuild
	mov	edx, DWORD PTR _lpSql$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 4
	je	SHORT $LN6@fnSqlBuild

; 1851 :            lpSql->nCommandType & zINSERT_CMD )
; 1852 :       {
; 1853 :          continue;

	jmp	$LN2@fnSqlBuild
$LN6@fnSqlBuild:

; 1854 :       }
; 1855 : 
; 1856 :       // If we are creating a SELECT command and the entity has an attribute
; 1857 :       // that has a db operation, then check to see if the current attribute
; 1858 :       // has a db operation.  If not, then skip the attribute.
; 1859 :       if ( lpSql->nCommandType & zSELECT_CMD &&
; 1860 :            lpViewEntity->bHasDB_Oper && lpViewAttrib->cDB_Oper == 0 )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+10]
	and	edx, 1
	je	SHORT $LN7@fnSqlBuild
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	and	ecx, 1
	je	SHORT $LN7@fnSqlBuild
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+254]
	test	eax, eax
	jne	SHORT $LN7@fnSqlBuild

; 1861 :          continue;

	jmp	$LN2@fnSqlBuild
$LN7@fnSqlBuild:

; 1862 : 
; 1863 :       if ( bFirstTime )

	movzx	ecx, BYTE PTR _bFirstTime$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@fnSqlBuild

; 1864 :          bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0
	jmp	SHORT $LN9@fnSqlBuild
$LN8@fnSqlBuild:

; 1865 :       else
; 1866 :          fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG12052
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi
$LN9@fnSqlBuild:

; 1867 : 
; 1868 :       if ( EXEC_CALLBACK( zSQLCALLBACK_GETINTONAME, 0, lpDataField, 0,

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN10@fnSqlBuild
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN10@fnSqlBuild
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+14]
	and	eax, 128				; 00000080H
	je	SHORT $LN10@fnSqlBuild
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	push	0
	push	128					; 00000080H
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	call	edx
	mov	WORD PTR _nRC$[ebp], ax
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN10@fnSqlBuild

; 1869 :                           szColumnName ) )
; 1870 :       {
; 1871 :          // Callback handled it.
; 1872 :       }

	jmp	SHORT $LN11@fnSqlBuild
$LN10@fnSqlBuild:

; 1873 :       else
; 1874 :       {
; 1875 :          // Default processing is to just copy the attribute name.
; 1876 :          zstrcpy( szColumnName, ":" );

	push	OFFSET $SG12055
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1877 :          zstrcat( szColumnName, lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN11@fnSqlBuild:

; 1878 :       }
; 1879 : 
; 1880 :       fnSqlAddStringToSql( lpSql, szColumnName );

	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 1881 : 
; 1882 :    } // for (; lpDataField; ... )...

	jmp	$LN2@fnSqlBuild
$LN3@fnSqlBuild:

; 1883 : 
; 1884 :    return( 0 );

	xor	eax, eax

; 1885 : 
; 1886 : }  /* fnSqlBuildIntoList */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlBuildIntoList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpAttribFlags$1 = -300					; size = 4
$T2 = -296						; size = 4
_lpDataRecord$ = -292					; size = 4
tv182 = -288						; size = 4
_lpRelRecord$ = -284					; size = 4
_lpDataField$ = -280					; size = 4
_nRC$ = -276						; size = 2
_lpBoundList$ = -272					; size = 4
_bFirstTime$ = -265					; size = 1
_lpViewAttrib$ = -264					; size = 4
_szColumnName$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_lpSql$ = 12						; size = 4
_nControl$ = 16						; size = 2
_fnSqlBuildColumnList PROC

; 1632 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1633 :    LPVIEWATTRIB lpViewAttrib;
; 1634 :    LPDATAFIELD  lpDataField;
; 1635 :    LPDATARECORD lpDataRecord;
; 1636 :    LPRELRECORD  lpRelRecord;
; 1637 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 1638 :    zCHAR        szColumnName[ 256 ];
; 1639 :    zBOOL        bFirstTime;
; 1640 :    zSHORT       nRC;
; 1641 : 
; 1642 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 1643 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 1644 : 
; 1645 :    bFirstTime = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 1646 :    for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN4@fnSqlBuild
$LN2@fnSqlBuild:

; 1648 :          lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@fnSqlBuild:

; 1647 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN3@fnSqlBuild

; 1649 :    {
; 1650 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1651 : 
; 1652 :       // Hartmut thinks we shouldn't look for foreign keys.
; 1653 :       if ( (nControl & zKEYS_ONLY) &&

	movsx	eax, WORD PTR _nControl$[ebp]
	and	eax, 2
	je	SHORT $LN7@fnSqlBuild
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN7@fnSqlBuild

; 1654 :            (lpViewAttrib->bKey == FALSE) )
; 1655 :         // (!lpViewAttrib->bKey && !lpViewAttrib->bForeignKey) )
; 1656 :       {
; 1657 :          continue;

	jmp	SHORT $LN2@fnSqlBuild
$LN7@fnSqlBuild:

; 1658 :       }
; 1659 : 
; 1660 :       // If nControl indicates that we don't want hidden attributes, then
; 1661 :       // don't use hidden attributes UNLESS THEY ARE KEYS.  Keys, even if
; 1662 :       // they are hidden, should be included.  Same thing with auto sequencing
; 1663 :       // attributes.
; 1664 :       if ( (nControl & zNO_HIDDEN) &&

	movsx	eax, WORD PTR _nControl$[ebp]
	and	eax, 4
	je	SHORT $LN8@fnSqlBuild
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN8@fnSqlBuild
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN8@fnSqlBuild
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 2
	and	eax, 1
	jne	SHORT $LN8@fnSqlBuild
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN8@fnSqlBuild

; 1665 :            (lpViewAttrib->bHidden && lpViewAttrib->bKey == FALSE &&
; 1666 :                                      lpViewAttrib->bForeignKey == FALSE &&
; 1667 :                                      lpViewAttrib->bAutoSeq == FALSE) )
; 1668 :       {
; 1669 :          continue;

	jmp	$LN2@fnSqlBuild
$LN8@fnSqlBuild:

; 1670 :       }
; 1671 : 
; 1672 :       // If the attribute is an Auto Seq attribute and the relationship
; 1673 :       // is many-to-many then the attribute is stored in the corrsponding
; 1674 :       // table.  If the command type is also INSERT then the attribute is
; 1675 :       // not to be included in this list.
; 1676 :       if ( lpViewAttrib->bAutoSeq &&
; 1677 :            lpRelRecord && lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY &&

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN9@fnSqlBuild
	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	SHORT $LN9@fnSqlBuild
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN9@fnSqlBuild
	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+10]
	and	edx, 4
	je	SHORT $LN9@fnSqlBuild

; 1678 :            lpSql->nCommandType & zINSERT_CMD )
; 1679 :       {
; 1680 :          continue;

	jmp	$LN2@fnSqlBuild
$LN9@fnSqlBuild:

; 1681 :       }
; 1682 : 
; 1683 :       // Check to see if we only want updated attributes (for INSERT).
; 1684 :       if ( nControl & zUPDATED_ONLY )

	movsx	eax, WORD PTR _nControl$[ebp]
	and	eax, 8
	je	SHORT $LN10@fnSqlBuild

; 1685 :       {
; 1686 :          LPATTRIBFLAGS lpAttribFlags;
; 1687 : 
; 1688 :          GetAttributeFlags( &lpAttribFlags, lpSql->lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	lea	edx, DWORD PTR _lpAttribFlags$1[ebp]
	push	edx
	call	_GetAttributeFlags@16

; 1689 :                             lpViewEntity, lpViewAttrib );
; 1690 : 
; 1691 :          // If the attribute hasn't been updated then forget it.
; 1692 :          if ( lpAttribFlags->u.bFlags.bUpdated == FALSE )

	mov	eax, DWORD PTR _lpAttribFlags$1[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN10@fnSqlBuild

; 1693 :             continue;

	jmp	$LN2@fnSqlBuild
$LN10@fnSqlBuild:

; 1694 :       }
; 1695 : 
; 1696 :       // If we are creating a SELECT command and the entity has an attribute
; 1697 :       // that has a db operation, then check to see if the current attribute
; 1698 :       // has a db operation.  If not, then skip the attribute.
; 1699 :       if ( lpSql->nCommandType & zSELECT_CMD &&
; 1700 :            lpViewEntity->bHasDB_Oper && lpViewAttrib->cDB_Oper == 0 )

	mov	edx, DWORD PTR _lpSql$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 1
	je	SHORT $LN12@fnSqlBuild
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	and	edx, 1
	je	SHORT $LN12@fnSqlBuild
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+254]
	test	ecx, ecx
	jne	SHORT $LN12@fnSqlBuild

; 1701 :       {
; 1702 :          continue;

	jmp	$LN2@fnSqlBuild
$LN12@fnSqlBuild:

; 1703 :       }
; 1704 : 
; 1705 :       szColumnName[ 0 ] = 0; // init szColumnName to null string

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 256			; 00000100H
	jae	SHORT $LN30@fnSqlBuild
	jmp	SHORT $LN31@fnSqlBuild
$LN30@fnSqlBuild:
	call	___report_rangecheckfailure
$LN31@fnSqlBuild:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szColumnName$[ebp+ecx], 0

; 1706 : 
; 1707 :       if ( lpSql->nCommandType & zSELECT_CMD )

	mov	edx, DWORD PTR _lpSql$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 1
	je	$LN13@fnSqlBuild

; 1708 :       {
; 1709 :          switch ( lpViewAttrib->cDB_Oper )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+254]
	mov	DWORD PTR tv182[ebp], edx
	mov	eax, DWORD PTR tv182[ebp]
	sub	eax, 65					; 00000041H
	mov	DWORD PTR tv182[ebp], eax
	cmp	DWORD PTR tv182[ebp], 23		; 00000017H
	ja	$LN13@fnSqlBuild
	mov	ecx, DWORD PTR tv182[ebp]
	movzx	edx, BYTE PTR $LN32@fnSqlBuild[ecx]
	jmp	DWORD PTR $LN33@fnSqlBuild[edx*4]
$LN14@fnSqlBuild:

; 1710 :          {
; 1711 :             case 'A':
; 1712 :                zstrcat( szColumnName, "AVG( " );

	push	OFFSET $SG12002
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1713 :                break;

	jmp	SHORT $LN13@fnSqlBuild
$LN15@fnSqlBuild:

; 1714 : 
; 1715 :             case 'C':
; 1716 :                zstrcat( szColumnName, "COUNT( " );

	push	OFFSET $SG12004
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1717 :                break;

	jmp	SHORT $LN13@fnSqlBuild
$LN16@fnSqlBuild:

; 1718 : 
; 1719 :             case 'N':
; 1720 :                zstrcat( szColumnName, "MIN( " );

	push	OFFSET $SG12006
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1721 :                break;

	jmp	SHORT $LN13@fnSqlBuild
$LN17@fnSqlBuild:

; 1722 : 
; 1723 :             case 'S':
; 1724 :                zstrcat( szColumnName, "SUM( " );

	push	OFFSET $SG12008
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1725 :                break;

	jmp	SHORT $LN13@fnSqlBuild
$LN18@fnSqlBuild:

; 1726 : 
; 1727 :             case 'X':
; 1728 :                zstrcat( szColumnName, "MAX( " );

	push	OFFSET $SG12010
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN13@fnSqlBuild:

; 1729 :                break;
; 1730 :          }
; 1731 :       }
; 1732 : 
; 1733 :       // Add table names if columns need to be fully qualified.
; 1734 :       // We don't want the table name if a COUNT Sql Function is generated.
; 1735 :       if ( (nControl & zFULLY_QUALIFIED) && lpViewAttrib->cDB_Oper != 'C' )

	movsx	edx, WORD PTR _nControl$[ebp]
	and	edx, 1
	je	$LN19@fnSqlBuild
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+254]
	cmp	ecx, 67					; 00000043H
	je	$LN19@fnSqlBuild

; 1736 :       {
; 1737 :          if ( lpViewAttrib->bAutoSeq &&
; 1738 :               lpRelRecord &&

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN20@fnSqlBuild
	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	SHORT $LN20@fnSqlBuild
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	edx, 50					; 00000032H
	jne	SHORT $LN20@fnSqlBuild

; 1739 :               lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )
; 1740 :          {
; 1741 :             // Qualify column using corresponding table.
; 1742 :             zstrcat( szColumnName,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnTableName@12
	push	eax
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1743 :                      fnTableName( lpSql,
; 1744 :                                   lpRelRecord->szRecordName,
; 1745 :                                   lpViewEntity ) );
; 1746 :          }

	jmp	SHORT $LN21@fnSqlBuild
$LN20@fnSqlBuild:

; 1747 :          else
; 1748 :             zstrcat( szColumnName,

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnTableName@12
	push	eax
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN21@fnSqlBuild:

; 1749 :                      fnTableName( lpSql,
; 1750 :                                   lpDataRecord->szRecordName,
; 1751 :                                   lpViewEntity ) );
; 1752 : 
; 1753 :          zstrcat( szColumnName, "." );

	push	OFFSET $SG12014
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN19@fnSqlBuild:

; 1754 :       }
; 1755 : 
; 1756 :       if ( EXEC_CALLBACK( zSQLCALLBACK_GETCOLUMNNAME, 0, lpDataField,

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN22@fnSqlBuild
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN22@fnSqlBuild
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	and	edx, 32					; 00000020H
	je	SHORT $LN22@fnSqlBuild
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+10]
	and	edx, 4
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	push	0
	push	32					; 00000020H
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+10]
	call	eax
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN22@fnSqlBuild

; 1757 :                           (lpSql->nCommandType & zINSERT_CMD),
; 1758 :                           szColumnName ) )
; 1759 :       {
; 1760 :          // Callback handled it.
; 1761 :       }

	jmp	SHORT $LN23@fnSqlBuild
$LN22@fnSqlBuild:

; 1762 :       else
; 1763 :       {
; 1764 :          // Default processing is to just copy the column name.
; 1765 :          zstrcat( szColumnName, lpDataField->szFldName );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN23@fnSqlBuild:

; 1766 :       }
; 1767 : 
; 1768 :       if ( lpSql->nCommandType & zSELECT_CMD && lpViewAttrib->cDB_Oper )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+10]
	and	edx, 1
	je	SHORT $LN24@fnSqlBuild
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+254]
	test	ecx, ecx
	je	SHORT $LN24@fnSqlBuild

; 1769 :          zstrcat( szColumnName, " )" );

	push	OFFSET $SG12018
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN24@fnSqlBuild:

; 1770 : 
; 1771 :       // Some columns need to go at the end of the list.  Check with the DBH
; 1772 :       // if this column should do so but only if we are dealing with a
; 1773 :       // SELECT command.
; 1774 :       if ( lpSql->nCommandType & zSELECT_CMD &&
; 1775 :            EXEC_CALLBACK( zSQLCALLBACK_GETCOLLISTPOS, 0, lpDataField,

	mov	eax, DWORD PTR _lpSql$[ebp]
	movsx	ecx, WORD PTR [eax+10]
	and	ecx, 1
	je	$LN25@fnSqlBuild
	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	$LN25@fnSqlBuild
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	$LN25@fnSqlBuild
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	and	ecx, 256				; 00000100H
	je	$LN25@fnSqlBuild
	push	0
	mov	edx, DWORD PTR _lpSql$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 4
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	push	0
	push	256					; 00000100H
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	call	ecx
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN25@fnSqlBuild

; 1776 :                           (lpSql->nCommandType & zINSERT_CMD), 0 ) )
; 1777 :       {
; 1778 :          // Callback indicated that column goes in 2nd column list.
; 1779 :          lpSql->pchColList2End = zstrcatp( lpSql->pchColList2End, ", " );

	push	OFFSET $SG12021
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+24], esi

; 1780 :          lpSql->pchColList2End = zstrcatp( lpSql->pchColList2End, szColumnName );

	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+24], esi

; 1781 :       }

	jmp	SHORT $LN26@fnSqlBuild
$LN25@fnSqlBuild:

; 1782 :       else
; 1783 :       {
; 1784 :          // Default processing is to copy the column name to the first list.
; 1785 :          if ( bFirstTime )

	movzx	edx, BYTE PTR _bFirstTime$[ebp]
	test	edx, edx
	je	SHORT $LN27@fnSqlBuild

; 1786 :             bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0
	jmp	SHORT $LN28@fnSqlBuild
$LN27@fnSqlBuild:

; 1787 :          else
; 1788 :             fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG12024
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi
$LN28@fnSqlBuild:

; 1789 : 
; 1790 :          fnSqlAddStringToSql( lpSql, szColumnName );

	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi
$LN26@fnSqlBuild:

; 1791 :       }
; 1792 : 
; 1793 :    } // for (; lpDataField; ... )...

	jmp	$LN2@fnSqlBuild
$LN3@fnSqlBuild:

; 1794 : 
; 1795 :    return( 0 );

	xor	eax, eax
$LN29@fnSqlBuild:

; 1796 : 
; 1797 : }  /* fnSqlBuildColumnList */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN33@fnSqlBuild:
	DD	$LN14@fnSqlBuild
	DD	$LN15@fnSqlBuild
	DD	$LN16@fnSqlBuild
	DD	$LN17@fnSqlBuild
	DD	$LN18@fnSqlBuild
	DD	$LN13@fnSqlBuild
$LN32@fnSqlBuild:
	DB	0
	DB	5
	DB	1
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_fnSqlBuildColumnList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_uLth$ = -344						; size = 4
_szStr$ = -340						; size = 4
tv150 = -336						; size = 4
_chType$ = -330						; size = 1
_bBound$ = -329						; size = 1
_lpViewEntity$ = -328					; size = 4
_pchValue$ = -324					; size = 4
_lpViewAttrib$ = -320					; size = 4
_bSqlCmd$ = -313					; size = 1
_lpBoundList$ = -312					; size = 4
_nRC$ = -308						; size = 2
_sz$1 = -304						; size = 300
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpDataField$ = 12					; size = 4
_lpSql$ = 16						; size = 4
_fnSqlGetAttributeValue PROC

; 1524 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1525 :    zSHORT  nRC;
; 1526 :    zCHAR   chType;
; 1527 :    zPCHAR  szStr;
; 1528 :    zPCHAR  pchValue;
; 1529 :    zULONG  uLth;
; 1530 :    zBOOL   bSqlCmd;
; 1531 :    zBOOL   bBound;
; 1532 :    LPVIEWENTITY lpViewEntity;
; 1533 :    LPVIEWATTRIB lpViewAttrib;
; 1534 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 1535 : 
; 1536 :    nRC = 0;    // Assume that attribute is not null.

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 1537 :    lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1538 :    lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1539 :    bBound = FALSE;

	mov	BYTE PTR _bBound$[ebp], 0

; 1540 : 
; 1541 :    // If the command is an INSERT or UPDATing a non-key then add value to
; 1542 :    // main SQL command, otherwise add value to the WHERE part of command.
; 1543 :    if ( (lpSql->nCommandType & zINSERT_CMD) ||

	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+10]
	and	edx, 4
	jne	SHORT $LN10@fnSqlGetAt
	mov	eax, DWORD PTR _lpSql$[ebp]
	movsx	ecx, WORD PTR [eax+10]
	and	ecx, 16					; 00000010H
	je	SHORT $LN8@fnSqlGetAt
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN8@fnSqlGetAt
$LN10@fnSqlGetAt:

; 1544 :         (lpSql->nCommandType & zUPDATE_CMD && lpViewAttrib->bKey == FALSE) )
; 1545 :    {
; 1546 :       pchValue = lpSql->pchSqlCmdEnd;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _pchValue$[ebp], edx

; 1547 :       bSqlCmd = TRUE;

	mov	BYTE PTR _bSqlCmd$[ebp], 1

; 1548 :    }

	jmp	SHORT $LN9@fnSqlGetAt
$LN8@fnSqlGetAt:

; 1549 :    else
; 1550 :    {
; 1551 :       pchValue = lpSql->pchWhereEnd;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _pchValue$[ebp], ecx

; 1552 :       bSqlCmd = FALSE;

	mov	BYTE PTR _bSqlCmd$[ebp], 0
$LN9@fnSqlGetAt:

; 1553 :    }
; 1554 : 
; 1555 :    // If callback function is supplied see if it will get the value.
; 1556 :    if ( EXEC_CALLBACK( zSQLCALLBACK_GETATTRVALUE, lpView,

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	$LN11@fnSqlGetAt
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN11@fnSqlGetAt
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	and	ecx, 8
	je	SHORT $LN11@fnSqlGetAt
	mov	edx, DWORD PTR _pchValue$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	call	ecx
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN11@fnSqlGetAt

; 1557 :                        lpDataField, 0, pchValue ) )
; 1558 :    {
; 1559 :       // The DBHandler call back routine retrieved the attribute value.
; 1560 :       // Check for null value.
; 1561 :       if ( SqlAttributeIsNull( lpView, lpDataField, lpBoundList ) )

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SqlAttributeIsNull@12
	cwde
	test	eax, eax
	je	SHORT $LN13@fnSqlGetAt

; 1562 :          nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN14@fnSqlGetAt
$LN13@fnSqlGetAt:

; 1563 :       else
; 1564 :          nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN14@fnSqlGetAt:

; 1565 :    }

	jmp	$LN12@fnSqlGetAt
$LN11@fnSqlGetAt:

; 1566 :    else
; 1567 :    {
; 1568 :       // If attribute is null then insert language specific null.
; 1569 :       if ( SqlAttributeIsNull( lpView, lpDataField, lpBoundList ) )

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SqlAttributeIsNull@12
	cwde
	test	eax, eax
	je	SHORT $LN15@fnSqlGetAt

; 1570 :       {
; 1571 :          fnSqlGetNullString( pchValue, lpDataField, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	call	_fnSqlGetNullString
	add	esp, 12					; 0000000cH

; 1572 :          nRC = 1;    // Indicate that attribute is null.

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 1573 :       }

	jmp	$LN12@fnSqlGetAt
$LN15@fnSqlGetAt:

; 1574 :       else
; 1575 :       switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv150[ebp], al
	cmp	BYTE PTR tv150[ebp], 77			; 0000004dH
	je	$LN19@fnSqlGetAt
	cmp	BYTE PTR tv150[ebp], 83			; 00000053H
	je	SHORT $LN17@fnSqlGetAt
	cmp	BYTE PTR tv150[ebp], 84			; 00000054H
	je	SHORT $LN18@fnSqlGetAt
	jmp	$LN20@fnSqlGetAt
$LN17@fnSqlGetAt:

; 1576 :       {
; 1577 :          zCHAR sz[ 300 ];
; 1578 : 
; 1579 :          case zTYPE_STRING:
; 1580 :             GetValueFromRecord( lpView, lpViewEntity, lpViewAttrib, &szStr,

	lea	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$[ebp]
	push	edx
	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_GetValueFromRecord@24

; 1581 :                                 &chType, &uLth );
; 1582 :             fnSqlConvertStringToSqlString( lpDataField,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _szStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	call	_fnSqlConvertStringToSqlString
	add	esp, 16					; 00000010H

; 1583 :                                            szStr, pchValue, lpBoundList );
; 1584 :             break;

	jmp	$LN12@fnSqlGetAt
$LN18@fnSqlGetAt:

; 1585 : 
; 1586 :          case zTYPE_DATETIME:
; 1587 :             // Get date-time from record as an unformatted string --
; 1588 :             // yyyymmddhhmmsss.
; 1589 :             GetStringFromRecord( lpView, lpViewEntity, lpViewAttrib, sz, 20 );

	push	20					; 00000014H
	lea	edx, DWORD PTR _sz$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_GetStringFromRecord@20

; 1590 :             fnSqlConvertStringToSqlString( lpDataField, sz, pchValue,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sz$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	call	_fnSqlConvertStringToSqlString
	add	esp, 16					; 00000010H

; 1591 :                                            lpBoundList );
; 1592 :             break;

	jmp	$LN12@fnSqlGetAt
$LN19@fnSqlGetAt:

; 1593 : 
; 1594 :          case zTYPE_DECIMAL:
; 1595 :             GetStringFromRecord( lpView, lpViewEntity, lpViewAttrib, sz, 256 );

	push	256					; 00000100H
	lea	ecx, DWORD PTR _sz$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetStringFromRecord@20

; 1596 :             fnSqlConvertStringToSqlString( lpDataField, sz, pchValue,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	call	_fnSqlConvertStringToSqlString
	add	esp, 16					; 00000010H

; 1597 :                                            lpBoundList );
; 1598 :             break;

	jmp	SHORT $LN12@fnSqlGetAt
$LN20@fnSqlGetAt:

; 1599 : 
; 1600 :          default:
; 1601 :             // For all other datatypes, get the value of the attribute as a
; 1602 :             // string and put it in pchValue.
; 1603 : 
; 1604 :             // Get string from record with a max length of 256.
; 1605 :             GetStringFromRecord( lpView, lpViewEntity, lpViewAttrib, sz, 256 );

	push	256					; 00000100H
	lea	eax, DWORD PTR _sz$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_GetStringFromRecord@20

; 1606 :             fnSqlConvertStringToSqlString( lpDataField, sz, pchValue,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	call	_fnSqlConvertStringToSqlString
	add	esp, 16					; 00000010H
$LN12@fnSqlGetAt:

; 1607 :                                            lpBoundList );
; 1608 :             break;
; 1609 :       }
; 1610 :    }
; 1611 : 
; 1612 :    if ( bSqlCmd )

	movzx	edx, BYTE PTR _bSqlCmd$[ebp]
	test	edx, edx
	je	SHORT $LN6@fnSqlGetAt
$LN4@fnSqlGetAt:

; 1613 :       mAdvanceToNull( lpSql->pchSqlCmdEnd );

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@fnSqlGetAt
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], ecx
	jmp	SHORT $LN4@fnSqlGetAt
$LN5@fnSqlGetAt:
	jmp	SHORT $LN22@fnSqlGetAt
$LN6@fnSqlGetAt:

; 1614 :    else
; 1615 :       mAdvanceToNull( lpSql->pchWhereEnd );

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN22@fnSqlGetAt
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	add	ecx, 1
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], ecx
	jmp	SHORT $LN6@fnSqlGetAt
$LN22@fnSqlGetAt:

; 1616 : 
; 1617 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 1618 : }  /* fnSqlGetAttributeValue */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlGetAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewAttrib$ = -92					; size = 4
tv166 = -88						; size = 4
tv91 = -84						; size = 4
_nRC$ = -80						; size = 2
_sz$ = -76						; size = 4
_k$1 = -72						; size = 2
_szDateTime2$ = -68					; size = 30
_szDateTime1$ = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_lpDataField$ = 8					; size = 4
_pchSrc$ = 12						; size = 4
_pchTgt$ = 16						; size = 4
_lpBoundList$ = 20					; size = 4
_fnSqlConvertStringToSqlString PROC

; 1390 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1391 :    zSHORT       nRC;
; 1392 :    zPCHAR       sz;
; 1393 :    zCHAR        szDateTime1[ 30 ], szDateTime2[ 30 ];
; 1394 :    LPVIEWATTRIB lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1395 : 
; 1396 :    // If source is null, then return value for null string.
; 1397 :    if ( pchSrc == 0 || *pchSrc == 0 )

	cmp	DWORD PTR _pchSrc$[ebp], 0
	je	SHORT $LN14@fnSqlConve
	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN13@fnSqlConve
$LN14@fnSqlConve:

; 1398 :    {
; 1399 :       fnSqlGetNullString( pchTgt, lpDataField, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTgt$[ebp]
	push	eax
	call	_fnSqlGetNullString
	add	esp, 12					; 0000000cH

; 1400 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSqlConve
$LN13@fnSqlConve:

; 1401 :    }
; 1402 : 
; 1403 :    if ( EXEC_CALLBACK( zSQLCALLBACK_CONVERTSTRING, 0,

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN15@fnSqlConve
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN15@fnSqlConve
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+14]
	and	eax, 4
	je	SHORT $LN15@fnSqlConve
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSrc$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	push	0
	push	4
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+10]
	call	eax
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@fnSqlConve

; 1404 :                        lpDataField, pchSrc, pchTgt ) )
; 1405 :    {
; 1406 :       // Callback handled it.
; 1407 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSqlConve
$LN15@fnSqlConve:

; 1408 :    }
; 1409 : 
; 1410 :    switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv91[ebp], al
	cmp	BYTE PTR tv91[ebp], 66			; 00000042H
	je	SHORT $LN16@fnSqlConve
	cmp	BYTE PTR tv91[ebp], 83			; 00000053H
	je	SHORT $LN17@fnSqlConve
	cmp	BYTE PTR tv91[ebp], 84			; 00000054H
	je	$LN21@fnSqlConve
	jmp	$LN26@fnSqlConve
$LN16@fnSqlConve:

; 1411 :    {
; 1412 :       case zTYPE_BLOB:
; 1413 :          // At least for now we better never get a blob.
; 1414 :          SysMessageBox( 0, "Zeidon Core",

	push	1
	push	OFFSET $SG11908
	push	OFFSET $SG11909
	push	0
	call	_SysMessageBox@16

; 1415 :                         "Blobs not supported as string attributes", 1 );
; 1416 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlConve
$LN17@fnSqlConve:

; 1417 : 
; 1418 :       case zTYPE_STRING:
; 1419 :       {
; 1420 :          // Go through the string and check for single quotes and double them
; 1421 :          // up (ie "don't" becomes "don''t").
; 1422 :          *pchTgt++ = '\'';

	mov	ecx, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [ecx], 39			; 00000027H
	mov	edx, DWORD PTR _pchTgt$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTgt$[ebp], edx
$LN4@fnSqlConve:

; 1423 : 
; 1424 :          // If there are any imbedded single quotes then double them up.
; 1425 :          while ( *pchSrc )

	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@fnSqlConve

; 1426 :          {
; 1427 :             if ( *pchSrc == '\'' )

	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 39					; 00000027H
	jne	SHORT $LN18@fnSqlConve

; 1428 :             {
; 1429 :                *pchTgt++ = '\'';

	mov	ecx, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [ecx], 39			; 00000027H
	mov	edx, DWORD PTR _pchTgt$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTgt$[ebp], edx

; 1430 :                *pchTgt++ = '\'';

	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [eax], 39			; 00000027H
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTgt$[ebp], ecx

; 1431 :                *pchSrc++;

	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx

; 1432 :             }

	jmp	SHORT $LN19@fnSqlConve
$LN18@fnSqlConve:

; 1433 :             else
; 1434 :                *pchTgt++ = *pchSrc++;

	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchTgt$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTgt$[ebp], eax
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchSrc$[ebp], ecx
$LN19@fnSqlConve:

; 1435 :          }

	jmp	SHORT $LN4@fnSqlConve
$LN5@fnSqlConve:

; 1436 : 
; 1437 :          // In the special case where the string is stored as a fixed-length
; 1438 :          // string make sure the length is set correctly.
; 1439 :          if ( lpDataField->cFldType == zTYPE_FIXEDCHAR )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN20@fnSqlConve

; 1440 :          {
; 1441 :             zUSHORT k;
; 1442 : 
; 1443 :             for ( k = zstrlen( pchSrc );

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$1[ebp], ax
	jmp	SHORT $LN8@fnSqlConve
$LN6@fnSqlConve:

; 1445 :                   k++ )

	mov	dx, WORD PTR _k$1[ebp]
	add	dx, 1
	mov	WORD PTR _k$1[ebp], dx
$LN8@fnSqlConve:

; 1444 :                   k < lpDataField->uFldLth;

	movzx	eax, WORD PTR _k$1[ebp]
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	movzx	edx, WORD PTR [ecx+271]
	cmp	eax, edx
	jge	SHORT $LN20@fnSqlConve

; 1446 :             {
; 1447 :                *pchTgt++ = ' ';

	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTgt$[ebp], ecx

; 1448 :             }

	jmp	SHORT $LN6@fnSqlConve
$LN20@fnSqlConve:

; 1449 :          }
; 1450 : 
; 1451 :          *pchTgt++ = '\'';

	mov	edx, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [edx], 39			; 00000027H
	mov	eax, DWORD PTR _pchTgt$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTgt$[ebp], eax

; 1452 :          *pchTgt   = 0;

	mov	ecx, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [ecx], 0

; 1453 :          break;

	jmp	$LN2@fnSqlConve
$LN21@fnSqlConve:

; 1454 :       }
; 1455 : 
; 1456 :       case zTYPE_DATETIME:
; 1457 :          // Get date-time from pchSrc as an unformatted string --
; 1458 :          // yyyymmddhhmmsss.
; 1459 :          zstrcpy( szDateTime1, pchSrc );

	mov	edx, DWORD PTR _pchSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDateTime1$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1460 : 
; 1461 :          // Make sure that the DateTime doesn't contain any spaces.
; 1462 :          sz = szDateTime1;

	lea	ecx, DWORD PTR _szDateTime1$[ebp]
	mov	DWORD PTR _sz$[ebp], ecx
$LN9@fnSqlConve:

; 1463 :          while ( sz[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _sz$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN10@fnSqlConve

; 1464 :          {
; 1465 :             if ( sz[ 0 ] == ' ' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _sz$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN22@fnSqlConve

; 1466 :                sz[ 0 ] = '0';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _sz$[ebp]
	mov	BYTE PTR [eax+edx], 48			; 00000030H
$LN22@fnSqlConve:

; 1467 : 
; 1468 :             sz++;

	mov	ecx, DWORD PTR _sz$[ebp]
	add	ecx, 1
	mov	DWORD PTR _sz$[ebp], ecx

; 1469 :          }

	jmp	SHORT $LN9@fnSqlConve
$LN10@fnSqlConve:

; 1470 : 
; 1471 :          // Now format for date/time/datetime.
; 1472 :          switch ( lpDataField->cFldType )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	al, BYTE PTR [edx+270]
	mov	BYTE PTR tv166[ebp], al
	cmp	BYTE PTR tv166[ebp], 68			; 00000044H
	je	SHORT $LN24@fnSqlConve
	cmp	BYTE PTR tv166[ebp], 73			; 00000049H
	je	SHORT $LN23@fnSqlConve
	jmp	SHORT $LN25@fnSqlConve
$LN23@fnSqlConve:

; 1473 :          {
; 1474 :             case zTYPE_TIME:
; 1475 :                UfFormatDateTime( szDateTime2, szDateTime1,

	push	OFFSET $SG11917
	lea	ecx, DWORD PTR _szDateTime1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDateTime2$[ebp]
	push	edx
	call	_UfFormatDateTime@12

; 1476 :                                  "HH.MI.SS.999" );
; 1477 :                break;

	jmp	SHORT $LN11@fnSqlConve
$LN24@fnSqlConve:

; 1478 : 
; 1479 :             case zTYPE_DATE:
; 1480 :                UfFormatDateTime( szDateTime2, szDateTime1,

	push	OFFSET $SG11919
	lea	eax, DWORD PTR _szDateTime1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDateTime2$[ebp]
	push	ecx
	call	_UfFormatDateTime@12

; 1481 :                                  "YYYY-mm-DD" );
; 1482 :                break;

	jmp	SHORT $LN11@fnSqlConve
$LN25@fnSqlConve:

; 1483 : 
; 1484 :             default:
; 1485 :                UfFormatDateTime( szDateTime2, szDateTime1,

	push	OFFSET $SG11921
	lea	edx, DWORD PTR _szDateTime1$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDateTime2$[ebp]
	push	eax
	call	_UfFormatDateTime@12
$LN11@fnSqlConve:

; 1486 :                                  "YYYY-mm-DD-HH.MI.SS.999" );
; 1487 :          }
; 1488 : 
; 1489 :          // Date string must be inside a quote.
; 1490 :          zsprintf( pchTgt, "'%s'", szDateTime2 );

	lea	ecx, DWORD PTR _szDateTime2$[ebp]
	push	ecx
	push	OFFSET $SG11922
	mov	edx, DWORD PTR _pchTgt$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1491 :          break;

	jmp	SHORT $LN2@fnSqlConve
$LN26@fnSqlConve:

; 1492 : 
; 1493 :       default:
; 1494 :          // For all other datatypes, just copy it to pchTgt.
; 1495 :          zstrcpy( pchTgt, pchSrc );

	mov	eax, DWORD PTR _pchSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN2@fnSqlConve:

; 1496 :          break;
; 1497 : 
; 1498 :    } // switch ( lpDataField->cFldType )...
; 1499 : 
; 1500 :    return( 0 );

	xor	eax, eax
$LN1@fnSqlConve:

; 1501 : 
; 1502 : }  /* fnSqlConvertStringToSqlString */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlConvertStringToSqlString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_pchValue$ = 8						; size = 4
_lpBoundList$ = 12					; size = 4
_fnSqlGetUpperString PROC

; 1354 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1355 :    zSHORT nRC;
; 1356 : 
; 1357 :    // If pfnCallback is specified try to get the UPPER string from the dbhandler.
; 1358 :    if ( EXEC_CALLBACK( zSQLCALLBACK_GETUPPERSTRING, 0, 0, 0, pchValue ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN2@fnSqlGetUp
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN2@fnSqlGetUp
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	and	edx, 512				; 00000200H
	je	SHORT $LN2@fnSqlGetUp
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	push	0
	push	512					; 00000200H
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+10]
	call	eax
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@fnSqlGetUp

; 1359 :    {
; 1360 :       // Callback handled it.
; 1361 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSqlGetUp
$LN2@fnSqlGetUp:

; 1362 :    }
; 1363 : 
; 1364 :    zstrcpy( pchValue, "UPPER" );

	push	OFFSET $SG11875
	mov	edx, DWORD PTR _pchValue$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1365 : 
; 1366 :    return( 0 );

	xor	eax, eax
$LN1@fnSqlGetUp:

; 1367 : 
; 1368 : } // SqlGetNullString

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlGetUpperString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_pchValue$ = 8						; size = 4
_lpDataField$ = 12					; size = 4
_lpBoundList$ = 16					; size = 4
_fnSqlGetNullString PROC

; 1328 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1329 :    zSHORT nRC;
; 1330 : 
; 1331 :    // If pfnCallback is specified try to get the null string from the dbhandler.
; 1332 :    if ( EXEC_CALLBACK( zSQLCALLBACK_GETNULLSTRING, 0, lpDataField, 0, pchValue ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN2@fnSqlGetNu
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN2@fnSqlGetNu
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	and	edx, 2
	je	SHORT $LN2@fnSqlGetNu
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	push	0
	push	2
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	call	ecx
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@fnSqlGetNu

; 1333 :    {
; 1334 :       // Callback handled it.
; 1335 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSqlGetNu
$LN2@fnSqlGetNu:

; 1336 :    }
; 1337 : 
; 1338 :    zstrcpy( pchValue, "null" );

	push	OFFSET $SG11865
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1339 :    return( 0 );

	xor	eax, eax
$LN1@fnSqlGetNu:

; 1340 : 
; 1341 : } // SqlGetNullString

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlGetNullString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_pchDefault$ = -128					; size = 4
$T1 = -124						; size = 4
_nLth$ = -120						; size = 2
_nRC$ = -116						; size = 2
_j$ = -112						; size = 2
_k$ = -108						; size = 2
_szStr$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_pchTarget$ = 8						; size = 4
_pchSource$ = 12					; size = 4
_fnSqlUnformatDateTimeString PROC

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1097 :    zPCHAR pchDefault;
; 1098 :    zCHAR  szStr[ 100 ];
; 1099 :    zSHORT k, j;
; 1100 :    zSHORT nLth;
; 1101 :    zSHORT nRC;
; 1102 : 
; 1103 :    // Copy source to temp string, elimating some spaces.  We can't eliminate
; 1104 :    // spaces that are between 2 digits.
; 1105 :    for ( k = j = 0; pchSource[ k ]; k++ )

	xor	eax, eax
	mov	WORD PTR _j$[ebp], ax
	mov	cx, WORD PTR _j$[ebp]
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@fnSqlUnfor
$LN2@fnSqlUnfor:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN4@fnSqlUnfor:
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchSource$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN3@fnSqlUnfor

; 1106 :    {
; 1107 :       if ( pchSource[ k ] == ' ' )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchSource$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN14@fnSqlUnfor

; 1108 :       {
; 1109 :          // Current char is a space--make sure we can eliminate it.
; 1110 : 
; 1111 :          // If j = 0, then no chars have been copied yet to the target string,
; 1112 :          // so pchSource has leading spaces--its OK to get rid of them.
; 1113 :          if ( j == 0 )

	movsx	eax, WORD PTR _j$[ebp]
	test	eax, eax
	jne	SHORT $LN15@fnSqlUnfor

; 1114 :             continue;   // Continue loop without copying the space.

	jmp	SHORT $LN2@fnSqlUnfor
$LN15@fnSqlUnfor:

; 1115 : 
; 1116 :          // The only time we can't eliminate a space is if it's the only char
; 1117 :          // between two digits.  Make sure that the previous char in the
; 1118 :          // target string and the next char in the source string aren't #'s.
; 1119 :          if ( isdigit( szStr[ j - 1 ] ) && isdigit( pchSource[ k + 1 ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	movsx	edx, BYTE PTR _szStr$[ebp+ecx-1]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@fnSqlUnfor
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchSource$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+1]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN16@fnSqlUnfor

; 1120 :          {
; 1121 :             ; // Can't skip space.
; 1122 :          }

	jmp	SHORT $LN14@fnSqlUnfor
$LN16@fnSqlUnfor:

; 1123 :          else
; 1124 :             continue;   // Continue loop without copying the space.

	jmp	SHORT $LN2@fnSqlUnfor
$LN14@fnSqlUnfor:

; 1125 :       }
; 1126 : 
; 1127 :       // Copy the char from source to target.
; 1128 :       szStr[ j++ ] = pchSource[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchSource$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _szStr$[ebp+ecx], al
	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx

; 1129 :    }

	jmp	$LN2@fnSqlUnfor
$LN3@fnSqlUnfor:

; 1130 : 
; 1131 :    szStr[ j ] = 0;

	movsx	edx, WORD PTR _j$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 100			; 00000064H
	jae	SHORT $LN48@fnSqlUnfor
	jmp	SHORT $LN49@fnSqlUnfor
$LN48@fnSqlUnfor:
	call	___report_rangecheckfailure
$LN49@fnSqlUnfor:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szStr$[ebp+eax], 0

; 1132 : 
; 1133 :    nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 1134 : 
; 1135 :    // If the date string is 8 chars or more and of valid length
; 1136 :    //  and consists only of digits, then we assume that it is already
; 1137 :    //  in the right format.
; 1138 :    //  A valid length is
; 1139 :    //    8  - YYYYMMDD
; 1140 :    //    10 - YYYYMMDDHH
; 1141 :    //    12 - YYYYMMDDHHMM
; 1142 :    //    14 - YYYYMMDDHHMMSS
; 1143 :    //    17 - YYYYMMDDHHMMSSTTT
; 1144 :    //  Then, we just fill it up with '0' chars.
; 1145 :    j = zstrlen( szStr );

	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _j$[ebp], ax

; 1146 :    if ( j == 8 || j == 10 || j == 12 || j == 14 || j == 17 )

	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 8
	je	SHORT $LN19@fnSqlUnfor
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN19@fnSqlUnfor
	movsx	edx, WORD PTR _j$[ebp]
	cmp	edx, 12					; 0000000cH
	je	SHORT $LN19@fnSqlUnfor
	movsx	eax, WORD PTR _j$[ebp]
	cmp	eax, 14					; 0000000eH
	je	SHORT $LN19@fnSqlUnfor
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 17					; 00000011H
	jne	$LN18@fnSqlUnfor
$LN19@fnSqlUnfor:

; 1147 :    {
; 1148 :       for ( k = 0; k < j; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN7@fnSqlUnfor
$LN5@fnSqlUnfor:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN7@fnSqlUnfor:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN6@fnSqlUnfor

; 1149 :       {
; 1150 :          if ( !isdigit( szStr[ k ] ) )

	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR _szStr$[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@fnSqlUnfor

; 1151 :             break;

	jmp	SHORT $LN6@fnSqlUnfor
$LN20@fnSqlUnfor:

; 1152 :       }

	jmp	SHORT $LN5@fnSqlUnfor
$LN6@fnSqlUnfor:

; 1153 : 
; 1154 :       if ( k == j )

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	cmp	edx, eax
	jne	SHORT $LN18@fnSqlUnfor

; 1155 :       {
; 1156 :         // nothing but digits
; 1157 :         zstrcpy( pchTarget, szStr );

	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTarget$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1158 :         for ( k = j; k < 17; k++ )

	mov	ax, WORD PTR _j$[ebp]
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN10@fnSqlUnfor
$LN8@fnSqlUnfor:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN10@fnSqlUnfor:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 17					; 00000011H
	jge	SHORT $LN9@fnSqlUnfor

; 1159 :           pchTarget[ k ] = '0';

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx+eax], 48			; 00000030H
	jmp	SHORT $LN8@fnSqlUnfor
$LN9@fnSqlUnfor:

; 1160 : 
; 1161 :         pchTarget[ 17 ] = 0;

	mov	edx, 1
	imul	eax, edx, 17
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 1162 :         return( 1 );

	mov	eax, 1
	jmp	$LN47@fnSqlUnfor
$LN18@fnSqlUnfor:

; 1163 :       }
; 1164 :    }
; 1165 : 
; 1166 :    // Now find a valid format that matches szStr and unformat it.  Note that
; 1167 :    // the order of the UfEditFormatDateTime calls is important--the more
; 1168 :    // complex ones MUST be done FIRST.  UfEditFormatDateTime returns 0 only
; 1169 :    // if the data in szStr matches the format given.
; 1170 :    if ( UfEditFormatDateTime( szStr, "YYYYMMDD" ) == 0 )

	push	OFFSET $SG11782
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN22@fnSqlUnfor

; 1171 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	$LN23@fnSqlUnfor
$LN22@fnSqlUnfor:

; 1172 :    else
; 1173 :    if ( UfEditFormatDateTime( szStr, "YYYY-M-D H:MI:SSAM" ) == 0 )

	push	OFFSET $SG11785
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN24@fnSqlUnfor

; 1174 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	$LN23@fnSqlUnfor
$LN24@fnSqlUnfor:

; 1175 :    else
; 1176 :    if ( UfEditFormatDateTime( szStr, "D-Mmm-YYYY H:MI:SSAM" ) == 0 )

	push	OFFSET $SG11788
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN26@fnSqlUnfor

; 1177 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	$LN23@fnSqlUnfor
$LN26@fnSqlUnfor:

; 1178 :    else
; 1179 :    if ( UfEditFormatDateTime( szStr, "D-Mmm-YYYY" ) == 0 )

	push	OFFSET $SG11791
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN28@fnSqlUnfor

; 1180 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	$LN23@fnSqlUnfor
$LN28@fnSqlUnfor:

; 1181 :    else
; 1182 :    if ( UfEditFormatDateTime( szStr, "YYYY-M-D H:MI:SS" ) == 0 )

	push	OFFSET $SG11794
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN30@fnSqlUnfor

; 1183 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	$LN23@fnSqlUnfor
$LN30@fnSqlUnfor:

; 1184 :    else
; 1185 :    if ( UfEditFormatDateTime( szStr, "YYYY-M-D H:MIAM" ) == 0 )

	push	OFFSET $SG11797
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN32@fnSqlUnfor

; 1186 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	$LN23@fnSqlUnfor
$LN32@fnSqlUnfor:

; 1187 :    else
; 1188 :    if ( UfEditFormatDateTime( szStr, "YYYY-M-D H:MI" ) == 0 )

	push	OFFSET $SG11800
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN34@fnSqlUnfor

; 1189 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	$LN23@fnSqlUnfor
$LN34@fnSqlUnfor:

; 1190 :    else
; 1191 :    if ( UfEditFormatDateTime( szStr, "YYYY-M-D" ) == 0 )

	push	OFFSET $SG11803
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN36@fnSqlUnfor

; 1192 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN23@fnSqlUnfor
$LN36@fnSqlUnfor:

; 1193 :    else
; 1194 :    if ( UfEditFormatDateTime( szStr, "H:MI:SSAM" ) == 0 )

	push	OFFSET $SG11806
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN38@fnSqlUnfor

; 1195 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN23@fnSqlUnfor
$LN38@fnSqlUnfor:

; 1196 :    else
; 1197 :    if ( UfEditFormatDateTime( szStr, "H:MI:SS" ) == 0 )

	push	OFFSET $SG11809
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN40@fnSqlUnfor

; 1198 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN23@fnSqlUnfor
$LN40@fnSqlUnfor:

; 1199 :    else
; 1200 :    if ( UfEditFormatDateTime( szStr, "H:MIAM" ) == 0 )

	push	OFFSET $SG11812
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN42@fnSqlUnfor

; 1201 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN23@fnSqlUnfor
$LN42@fnSqlUnfor:

; 1202 :    else
; 1203 :    if ( UfEditFormatDateTime( szStr, "H:MI" ) == 0 )

	push	OFFSET $SG11814
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN23@fnSqlUnfor

; 1204 :       nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN23@fnSqlUnfor:

; 1205 : 
; 1206 :    if ( nRC == 1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	jne	SHORT $LN45@fnSqlUnfor

; 1207 :    {
; 1208 :       // We formatted the date-time string.  If the date-time string is
; 1209 :       // incomplete, then we need to fill in default data.  For example if
; 1210 :       // the date-time string is "1996-04-02" (doesn't have time data), then
; 1211 :       // the string szStr will look like "19960402XXXXXXXXX" -- X's for the
; 1212 :       // unspecified data.  We need to set the X's to default values.
; 1213 : 
; 1214 :       // Changes any capitol X's to reflect the default.
; 1215 :       pchDefault = "19000101000000000";       // i.e. Jan 1, 1900, 00:00:00.000

	mov	DWORD PTR _pchDefault$[ebp], OFFSET $SG11816

; 1216 :       nLth = zstrlen( szStr );

	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 1217 :       for ( k = 0; k < nLth; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN13@fnSqlUnfor
$LN11@fnSqlUnfor:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN13@fnSqlUnfor:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nLth$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN12@fnSqlUnfor

; 1218 :       {
; 1219 :          if ( szStr[ k ] == 'X' )

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, BYTE PTR _szStr$[ebp+edx]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN46@fnSqlUnfor

; 1220 :             szStr[ k ] = pchDefault[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchDefault$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR _szStr$[ebp+edx], cl
$LN46@fnSqlUnfor:

; 1221 :       }

	jmp	SHORT $LN11@fnSqlUnfor
$LN12@fnSqlUnfor:

; 1222 : 
; 1223 :       zstrcpy( pchTarget, szStr );

	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTarget$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN45@fnSqlUnfor:

; 1224 :    }
; 1225 : 
; 1226 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN47@fnSqlUnfor:

; 1227 : 
; 1228 : }  /* fnSqlUnformatDateTimeString */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlUnformatDateTimeString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpSrcDataRecord$1 = -88				; size = 4
_lpSrcViewAttrib$2 = -84				; size = 4
_lpSrcDataField$3 = -80					; size = 4
tv190 = -76						; size = 4
tv189 = -72						; size = 4
_lpBoundList$ = -68					; size = 4
tv156 = -64						; size = 4
tv155 = -60						; size = 4
_lpViewAttrib$4 = -56					; size = 4
_lpSrcViewEntity$5 = -52				; size = 4
_pchEntityJoinTable$6 = -48				; size = 4
_lpDataField$7 = -44					; size = 4
_lpRelField$8 = -40					; size = 4
_lpDataRecord$ = -36					; size = 4
_lpRelField$9 = -32					; size = 4
_lpTempEntity$10 = -28					; size = 4
_lpParent$11 = -24					; size = 4
_lpRelRecord$ = -20					; size = 4
_nTableNbr$ = -16					; size = 2
_nRelTableNbr$ = -12					; size = 2
_k$ = -8						; size = 2
_bAlwaysAdd$ = -4					; size = 1
_bFirst$12 = -3						; size = 1
_bFirstTime$13 = -2					; size = 1
_bCreateAlias$ = -1					; size = 1
_lpSql$ = 8						; size = 4
_pchTableName$ = 12					; size = 4
_lpViewEntity$ = 16					; size = 4
_lControl$ = 20						; size = 4
_fnAddTableToFrom PROC

; 788  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	push	esi

; 789  :    LPBOUNDLIST  lpBoundList    = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 790  :    LPDATARECORD lpDataRecord   = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 791  :    LPRELRECORD  lpRelRecord    = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 792  :    zBOOL        bAlwaysAdd     = (lControl & AT_ALWAYS_ADD);

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1
	mov	BYTE PTR _bAlwaysAdd$[ebp], al

; 793  :    zBOOL        bCreateAlias   = FALSE;

	mov	BYTE PTR _bCreateAlias$[ebp], 0

; 794  :    zSHORT       nTableNbr;
; 795  :    zSHORT       nRelTableNbr;
; 796  :    zSHORT       k;
; 797  : 
; 798  :    // Default the table name to match the table name for the entity.
; 799  :    if ( pchTableName == 0 )

	cmp	DWORD PTR _pchTableName$[ebp], 0
	jne	SHORT $LN14@fnAddTable

; 800  :       pchTableName = lpDataRecord->szRecordName;

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	mov	DWORD PTR _pchTableName$[ebp], ecx
$LN14@fnAddTable:

; 801  : 
; 802  :    // If the table name has already been added then return.
; 803  :    if ( bAlwaysAdd == FALSE &&

	movzx	edx, BYTE PTR _bAlwaysAdd$[ebp]
	test	edx, edx
	jne	SHORT $LN15@fnAddTable
	push	1
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	call	_fnSqlFindTableName
	add	esp, 16					; 00000010H
	cwde
	test	eax, eax
	jl	SHORT $LN15@fnAddTable

; 804  :         fnSqlFindTableName( pchTableName, lpViewEntity,
; 805  :                             lpSql, TRUE ) >= 0 )
; 806  :    {
; 807  :       return;

	jmp	$LN1@fnAddTable
$LN15@fnAddTable:

; 808  :    }
; 809  : 
; 810  :    if ( lpSql->nFromTableCount >= MAX_TABLES )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	cmp	edx, 100				; 00000064H
	jl	SHORT $LN16@fnAddTable

; 811  :    {
; 812  :       SysMessageBox( 0, "Internal Core Error", "Too many tables in SQL cmd", 1 );

	push	1
	push	OFFSET $SG11700
	push	OFFSET $SG11701
	push	0
	call	_SysMessageBox@16

; 813  :       return;

	jmp	$LN1@fnAddTable
$LN16@fnAddTable:

; 814  :    }
; 815  : 
; 816  :    // Check to see if we need to create an alias name for the table.
; 817  :    // There are five conditions that cause alias names to be used:
; 818  :    //    o  User wants us to always use an alias.
; 819  :    //    o  If we are building sub-selects (see below).
; 820  :    //    o  If we are referencing a table name that is already being used for
; 821  :    //       another entity.
; 822  :    //    o  If the current select statement contains a sub-select.
; 823  :    //    o  If the there is a Qualification on a child.
; 824  : 
; 825  :    // Check to see if we pchTableName already exists in the table list.
; 826  :    for ( k = 0; k < lpSql->nFromTableCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@fnAddTable
$LN2@fnAddTable:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@fnAddTable:
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpSql$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	cmp	edx, ecx
	jge	SHORT $LN3@fnAddTable

; 827  :    {
; 828  :       if ( zstrcmp( pchTableName,
; 829  :                     lpSql->TableNameInfo[ k ].pchTableName ) == 0 )

	mov	edx, DWORD PTR _pchTableName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 18
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+edx+82]
	movsx	ecx, BYTE PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN48@fnAddTable
	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+eax+82]
	push	edx
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv156[ebp], eax
	jmp	SHORT $LN49@fnAddTable
$LN48@fnAddTable:
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 18
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+82]
	movsx	eax, BYTE PTR [ecx]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN46@fnAddTable
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN47@fnAddTable
$LN46@fnAddTable:
	mov	DWORD PTR tv155[ebp], -1
$LN47@fnAddTable:
	mov	ecx, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv156[ebp], ecx
$LN49@fnAddTable:
	cmp	DWORD PTR tv156[ebp], 0
	jne	SHORT $LN17@fnAddTable

; 830  :       {
; 831  :          break;

	jmp	SHORT $LN3@fnAddTable
$LN17@fnAddTable:

; 832  :       }
; 833  :    }

	jmp	$LN2@fnAddTable
$LN3@fnAddTable:

; 834  : 
; 835  :    // If the sub level of the current Sql statement is greater than 0 then
; 836  :    // we are building a sub-select--which means that we need to use aliases
; 837  :    // for the table names.
; 838  :    if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_ALWAYSALIAS ) ||
; 839  :         k < lpSql->nFromTableCount                      ||
; 840  :         lpSql->nSubLevel > 0                            ||

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN20@fnAddTable
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+14]
	and	eax, 268435456				; 10000000H
	jne	SHORT $LN19@fnAddTable
$LN20@fnAddTable:
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpSql$[ebp]
	movsx	eax, WORD PTR [edx+80]
	cmp	ecx, eax
	jl	SHORT $LN19@fnAddTable
	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+62]
	test	edx, edx
	jg	SHORT $LN19@fnAddTable
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	and	ecx, 1
	je	SHORT $LN18@fnAddTable
$LN19@fnAddTable:

; 841  :         lpSql->bContainsSubselect )
; 842  :    {
; 843  :       bCreateAlias = TRUE;

	mov	BYTE PTR _bCreateAlias$[ebp], 1
$LN18@fnAddTable:

; 844  :    }
; 845  : 
; 846  :    // See if this table has a many-to-many relationship with it's parent.
; 847  :    // If it does, we want to add the relationship table.  If the name of
; 848  :    // the table matches the table name in the lpRelRecord, then we don't
; 849  :    // need to add this because it will be added shortly.
; 850  :    if ( lpRelRecord && lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY &&

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	$LN21@fnAddTable
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	eax, 50					; 00000032H
	jne	$LN21@fnAddTable
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+11]
	mov	eax, DWORD PTR _pchTableName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN52@fnAddTable
	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv190[ebp], eax
	jmp	SHORT $LN53@fnAddTable
$LN52@fnAddTable:
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+11]
	mov	eax, DWORD PTR _pchTableName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN50@fnAddTable
	mov	DWORD PTR tv189[ebp], 1
	jmp	SHORT $LN51@fnAddTable
$LN50@fnAddTable:
	mov	DWORD PTR tv189[ebp], -1
$LN51@fnAddTable:
	mov	edx, DWORD PTR tv189[ebp]
	mov	DWORD PTR tv190[ebp], edx
$LN53@fnAddTable:
	cmp	DWORD PTR tv190[ebp], 0
	je	$LN21@fnAddTable

; 851  :         zstrcmp( lpRelRecord->szRecordName, pchTableName ) != 0 )
; 852  :    {
; 853  :       // Do we already have tables in the FROM clause?  If we do then we need
; 854  :       // to add a "," or a "LEFT JOIN".
; 855  :       if ( lpSql->nFromTableCount > 0 )

	mov	eax, DWORD PTR _lpSql$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	test	ecx, ecx
	jle	SHORT $LN22@fnAddTable

; 856  :       {
; 857  :          if ( lpSql->bUseLeftJoin )

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+76]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN23@fnAddTable

; 858  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " LEFT JOIN " );

	push	OFFSET $SG11710
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi
	jmp	SHORT $LN22@fnAddTable
$LN23@fnAddTable:

; 859  :          else
; 860  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, ", " );

	push	OFFSET $SG11711
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], esi
$LN22@fnAddTable:

; 861  :       }
; 862  : 
; 863  :       // Add the rel table to the table list.
; 864  :       nRelTableNbr = lpSql->nFromTableCount++;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	ax, WORD PTR [edx+80]
	mov	WORD PTR _nRelTableNbr$[ebp], ax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	dx, WORD PTR [ecx+80]
	add	dx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [eax+80], dx

; 865  : 
; 866  :       lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 867  :                                     lpRelRecord->szRecordName );
; 868  :       lpSql->TableNameInfo[ nRelTableNbr ].pchTableName =

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	add	ecx, 11					; 0000000bH
	movsx	edx, WORD PTR _nRelTableNbr$[ebp]
	imul	eax, edx, 18
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+eax+82], ecx

; 869  :                                              lpRelRecord->szRecordName;
; 870  :       //lpSql->TableNameInfo[ nRelTableNbr ].pchTableName = pchTableName;
; 871  :       lpSql->TableNameInfo[ nRelTableNbr ].lpViewEntity = lpViewEntity;

	movsx	eax, WORD PTR _nRelTableNbr$[ebp]
	imul	ecx, eax, 18
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 872  : 
; 873  :       if ( bCreateAlias )

	movzx	ecx, BYTE PTR _bCreateAlias$[ebp]
	test	ecx, ecx
	je	SHORT $LN25@fnAddTable

; 874  :          fnAddAliasName( lpSql, nRelTableNbr );

	movsx	edx, WORD PTR _nRelTableNbr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnAddAliasName
	add	esp, 8
$LN25@fnAddTable:

; 875  : 
; 876  :       // If the entity that contains the M-M table is not the root entity
; 877  :       // of the sub-object we are loading, we need to add qualification.
; 878  :       if ( lpSql->bUseLeftJoin &&

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	shr	edx, 2
	and	edx, 1
	je	$LN21@fnAddTable
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	ecx, DWORD PTR [eax+68]
	je	$LN21@fnAddTable

; 879  :            lpViewEntity != lpSql->lpLoadViewEntity )
; 880  :       {
; 881  :          LPRELFIELD lpRelField;
; 882  :          zBOOL      bFirstTime = TRUE;

	mov	BYTE PTR _bFirstTime$13[ebp], 1

; 883  : 
; 884  :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " ON " );

	push	OFFSET $SG11714
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 885  : 
; 886  :          for ( lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$8[ebp], eax
	jmp	SHORT $LN7@fnAddTable
$LN5@fnAddTable:

; 888  :                lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	eax, DWORD PTR _lpRelField$8[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$8[ebp], eax
$LN7@fnAddTable:

; 887  :                lpRelField;

	cmp	DWORD PTR _lpRelField$8[ebp], 0
	je	$LN6@fnAddTable

; 889  :          {
; 890  :             LPDATAFIELD  lpSrcDataField;
; 891  :             LPDATARECORD lpSrcDataRecord;
; 892  :             LPVIEWATTRIB lpSrcViewAttrib;
; 893  :             LPVIEWENTITY lpSrcViewEntity;
; 894  : 
; 895  :             lpSrcDataField  = zGETPTR( lpRelField->hSrcDataField );

	mov	edx, DWORD PTR _lpRelField$8[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$3[ebp], eax

; 896  :             lpSrcViewAttrib = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpSrcDataField$3[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewAttrib$2[ebp], eax

; 897  :             lpSrcViewEntity = zGETPTR( lpSrcViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpSrcViewAttrib$2[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewEntity$5[ebp], eax

; 898  :             lpSrcDataRecord = zGETPTR( lpSrcViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpSrcViewEntity$5[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataRecord$1[ebp], eax

; 899  : 
; 900  :             // We only want to add the rel fields that are linked with the
; 901  :             // parent.
; 902  :             if ( lpSrcViewEntity == lpViewEntity )

	mov	ecx, DWORD PTR _lpSrcViewEntity$5[ebp]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN27@fnAddTable

; 903  :                continue;

	jmp	SHORT $LN5@fnAddTable
$LN27@fnAddTable:

; 904  : 
; 905  :             if ( bFirstTime )

	movzx	edx, BYTE PTR _bFirstTime$13[ebp]
	test	edx, edx
	je	SHORT $LN28@fnAddTable

; 906  :                bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$13[ebp], 0
	jmp	SHORT $LN29@fnAddTable
$LN28@fnAddTable:

; 907  :             else
; 908  :                lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " AND " );

	push	OFFSET $SG11718
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], esi
$LN29@fnAddTable:

; 909  : 
; 910  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 911  :                                           fnTableName( lpSql,
; 912  :                                                        lpRelRecord->szRecordName,
; 913  :                                                        lpViewEntity ) );
; 914  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, "." );

	push	OFFSET $SG11719
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 915  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	eax, DWORD PTR _lpRelField$8[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 916  :                                           lpRelField->szFldName );
; 917  : 
; 918  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " = " );

	push	OFFSET $SG11720
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], esi

; 919  : 
; 920  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	edx, DWORD PTR _lpSrcViewEntity$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcDataRecord$1[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 921  :                                           fnTableName( lpSql,
; 922  :                                                        lpSrcDataRecord->szRecordName,
; 923  :                                                        lpSrcViewEntity ) );
; 924  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, "." );

	push	OFFSET $SG11721
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 925  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	eax, DWORD PTR _lpSrcDataField$3[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 926  :                                           lpSrcDataField->szFldName );
; 927  : 
; 928  :          } // for ( lpRelField... )

	jmp	$LN5@fnAddTable
$LN6@fnAddTable:

; 929  : 
; 930  :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " ) " );

	push	OFFSET $SG11722
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], esi

; 931  : 
; 932  :          // We've added a paren to the end of the FROM clause, so we need to
; 933  :          // add one to the beginning.
; 934  :          *lpSql->pchNextJoinParen++ = '(';

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	BYTE PTR [eax], 40			; 00000028H
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+36], edx

; 935  :          lpSql->pchNextJoinParen++;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN21@fnAddTable:

; 936  : 
; 937  :       } // if ( lpSql->bUseLeftJoin ... )
; 938  : 
; 939  :    } // if ( lpRelRecord && lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )...
; 940  : 
; 941  :    // Do we already have tables in the FROM clause?  If we do then we need
; 942  :    // to add a "," or a "LEFT JOIN".
; 943  :    if ( lpSql->nFromTableCount > 0 )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+80]
	test	edx, edx
	jle	SHORT $LN30@fnAddTable

; 944  :    {
; 945  :       if ( lpSql->bUseLeftJoin )

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN31@fnAddTable

; 946  :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " LEFT JOIN " );

	push	OFFSET $SG11726
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi
	jmp	SHORT $LN30@fnAddTable
$LN31@fnAddTable:

; 947  :       else
; 948  :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, ", " );

	push	OFFSET $SG11727
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi
$LN30@fnAddTable:

; 949  :    }
; 950  : 
; 951  :    nTableNbr = lpSql->nFromTableCount++;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	cx, WORD PTR [eax+80]
	mov	WORD PTR _nTableNbr$[ebp], cx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	ax, WORD PTR [edx+80]
	add	ax, 1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [ecx+80], ax

; 952  :    lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, pchTableName );

	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], esi

; 953  :    lpSql->TableNameInfo[ nTableNbr ].pchTableName = pchTableName;

	movsx	edx, WORD PTR _nTableNbr$[ebp]
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _pchTableName$[ebp]
	mov	DWORD PTR [ecx+eax+82], edx

; 954  :    lpSql->TableNameInfo[ nTableNbr ].lpViewEntity = lpViewEntity;

	movsx	eax, WORD PTR _nTableNbr$[ebp]
	imul	ecx, eax, 18
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+ecx+96], eax

; 955  : 
; 956  :    if ( bCreateAlias )

	movzx	ecx, BYTE PTR _bCreateAlias$[ebp]
	test	ecx, ecx
	je	SHORT $LN33@fnAddTable

; 957  :       fnAddAliasName( lpSql, nTableNbr );

	movsx	edx, WORD PTR _nTableNbr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnAddAliasName
	add	esp, 8
$LN33@fnAddTable:

; 958  : 
; 959  :    // If we are using joins then add the foreign keys.
; 960  :    if ( lpSql->bUseLeftJoin &&

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	shr	edx, 2
	and	edx, 1
	je	$LN34@fnAddTable
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	ecx, DWORD PTR [eax+68]
	jne	SHORT $LN35@fnAddTable
	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	$LN34@fnAddTable
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	eax, 50					; 00000032H
	jne	$LN34@fnAddTable
$LN35@fnAddTable:

; 961  :         (lpViewEntity != lpSql->lpLoadViewEntity ||
; 962  :          (lpRelRecord && lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY)) )
; 963  :    {
; 964  :       LPRELFIELD   lpRelField;
; 965  :       zBOOL        bFirst = TRUE;

	mov	BYTE PTR _bFirst$12[ebp], 1

; 966  : 
; 967  :       lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " ON " );

	push	OFFSET $SG11731
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 968  : 
; 969  :       // Go through all the RelFields and add the qualification.
; 970  :       for ( lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
	jmp	SHORT $LN10@fnAddTable
$LN8@fnAddTable:

; 972  :             lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	edx, DWORD PTR _lpRelField$9[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
$LN10@fnAddTable:

; 971  :             lpRelField;

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	je	$LN9@fnAddTable

; 973  :       {
; 974  :          LPDATAFIELD  lpDataField;
; 975  :          LPVIEWATTRIB lpViewAttrib;
; 976  :          LPVIEWENTITY lpTempEntity;
; 977  : 
; 978  :          // Get Source relfield table name.
; 979  :          lpDataField  = zGETPTR( lpRelField->hSrcDataField );

	mov	ecx, DWORD PTR _lpRelField$9[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$7[ebp], eax

; 980  :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$7[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$4[ebp], eax

; 981  :          lpTempEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTempEntity$10[ebp], eax

; 982  :          lpDataRecord = zGETPTR( lpTempEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpTempEntity$10[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 983  : 
; 984  :          // If we are adding the qualification for a m-m relationship we only
; 985  :          // need to worry about some of the rel fields because the others
; 986  :          // were added when we added the relationship table above.
; 987  :          // parent.
; 988  :          if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	jne	SHORT $LN36@fnAddTable

; 989  :          {
; 990  :             if ( lpTempEntity != lpViewEntity )

	mov	edx, DWORD PTR _lpTempEntity$10[ebp]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN36@fnAddTable

; 991  :                continue;

	jmp	SHORT $LN8@fnAddTable
$LN36@fnAddTable:

; 992  :          }
; 993  : 
; 994  :          if ( bFirst )

	movzx	eax, BYTE PTR _bFirst$12[ebp]
	test	eax, eax
	je	SHORT $LN38@fnAddTable

; 995  :             bFirst = FALSE;

	mov	BYTE PTR _bFirst$12[ebp], 0
	jmp	SHORT $LN39@fnAddTable
$LN38@fnAddTable:

; 996  :          else
; 997  :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " AND " );

	push	OFFSET $SG11736
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi
$LN39@fnAddTable:

; 998  : 
; 999  :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	eax, DWORD PTR _lpTempEntity$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnTableName@12
	push	eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], esi

; 1000 :                                        fnTableName( lpSql,
; 1001 :                                                     lpDataRecord->szRecordName,
; 1002 :                                                     lpTempEntity ) );
; 1003 :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, "." );

	push	OFFSET $SG11737
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 1004 :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	ecx, DWORD PTR _lpDataField$7[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 1005 :                                        lpDataField->szFldName );
; 1006 : 
; 1007 :          lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " = " );

	push	OFFSET $SG11738
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 1008 : 
; 1009 :          // Get Target relfield table name.
; 1010 :          if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	jne	$LN40@fnAddTable

; 1011 :          {
; 1012 :             // Target for this relationship is in the relationship table.
; 1013 :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	edx, DWORD PTR _lpTempEntity$10[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 1014 :                                           fnTableName( lpSql,
; 1015 :                                                        lpRelRecord->szRecordName,
; 1016 :                                                        lpTempEntity ) );
; 1017 :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, "." );

	push	OFFSET $SG11741
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 1018 :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	eax, DWORD PTR _lpRelField$9[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 1019 :                                           lpRelField->szFldName );
; 1020 :          }

	jmp	$LN41@fnAddTable
$LN40@fnAddTable:

; 1021 :          else
; 1022 :          {
; 1023 :             lpDataField  = zGETPTR( lpRelField->hRelDataField );

	mov	eax, DWORD PTR _lpRelField$9[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$7[ebp], eax

; 1024 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$7[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$4[ebp], eax

; 1025 :             lpTempEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTempEntity$10[ebp], eax

; 1026 :             lpDataRecord = zGETPTR( lpTempEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpTempEntity$10[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 1027 : 
; 1028 :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	edx, DWORD PTR _lpTempEntity$10[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi

; 1029 :                                           fnTableName( lpSql,
; 1030 :                                                        lpDataRecord->szRecordName,
; 1031 :                                                        lpTempEntity ) );
; 1032 :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, "." );

	push	OFFSET $SG11742
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 1033 :             lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd,

	mov	eax, DWORD PTR _lpDataField$7[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi
$LN41@fnAddTable:

; 1034 :                                           lpDataField->szFldName );
; 1035 :          }
; 1036 :       }

	jmp	$LN8@fnAddTable
$LN9@fnAddTable:

; 1037 : 
; 1038 :       // Close the qualification and the join statement.
; 1039 :       lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " ) " );

	push	OFFSET $SG11743
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], esi

; 1040 : 
; 1041 :       // We've added a paren to the end of the FROM clause, so we need to
; 1042 :       // add one to the beginning.
; 1043 :       *lpSql->pchNextJoinParen++ = '(';

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	BYTE PTR [eax], 40			; 00000028H
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1044 :       lpSql->pchNextJoinParen++;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	add	edx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN34@fnAddTable:

; 1045 : 
; 1046 :    } // if ( lpSql->bUseLeftJoin ... )
; 1047 : 
; 1048 :    if ( lpSql->lpBoundList->pchEntityJoinTable )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+1886]
	cmp	DWORD PTR [edx+18], 0
	je	$LN1@fnAddTable

; 1049 :    {
; 1050 :       LPVIEWENTITY lpParent;
; 1051 :       zPCHAR       pchEntityJoinTable = lpSql->lpBoundList->pchEntityJoinTable;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR _pchEntityJoinTable$6[ebp], edx

; 1052 : 
; 1053 :       // Now set the JOINEDWITHCHILD flag for the parent.  In addition, if
; 1054 :       // the child entity has a x-to-m relationship with its parent,
; 1055 :       // everything joined with the parent must have JOINEDWITHMULTCHILD
; 1056 :       // flag set.
; 1057 :       for ( lpParent = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$11[ebp], eax
	jmp	SHORT $LN13@fnAddTable
$LN11@fnAddTable:

; 1059 :             lpParent = zGETPTR( lpParent->hParent ) )

	mov	edx, DWORD PTR _lpParent$11[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$11[ebp], eax
$LN13@fnAddTable:

; 1058 :             lpParent;

	cmp	DWORD PTR _lpParent$11[ebp], 0
	je	SHORT $LN1@fnAddTable

; 1060 :       {
; 1061 :          pchEntityJoinTable[ lpParent->nHierNbr ] |= zSELECT_JOINEDWITHCHILD;

	mov	ecx, DWORD PTR _lpParent$11[ebp]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _pchEntityJoinTable$6[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	or	ecx, 2
	mov	edx, DWORD PTR _lpParent$11[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	edx, DWORD PTR _pchEntityJoinTable$6[ebp]
	mov	BYTE PTR [edx+eax], cl

; 1062 : 
; 1063 :          // If child entity has card max of 1, we're done.
; 1064 :          if ( lpViewEntity->uCardMax <= 1 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movzx	ecx, WORD PTR [eax+221]
	cmp	ecx, 1
	jg	SHORT $LN43@fnAddTable

; 1065 :             break;

	jmp	SHORT $LN1@fnAddTable
$LN43@fnAddTable:

; 1066 : 
; 1067 :          // Set multichild flag.
; 1068 :          pchEntityJoinTable[ lpParent->nHierNbr ] |= zSELECT_JOINEDWITHMULTCHILD;

	mov	edx, DWORD PTR _lpParent$11[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	ecx, DWORD PTR _pchEntityJoinTable$6[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	or	edx, 4
	mov	eax, DWORD PTR _lpParent$11[ebp]
	movsx	ecx, WORD PTR [eax+217]
	mov	eax, DWORD PTR _pchEntityJoinTable$6[ebp]
	mov	BYTE PTR [eax+ecx], dl

; 1069 : 
; 1070 :          // If the parent is the entity we are loading, then we don't need to
; 1071 :          // go any higher.
; 1072 :          if ( lpParent == lpSql->lpLoadViewEntity )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _lpParent$11[ebp]
	cmp	edx, DWORD PTR [ecx+68]
	jne	SHORT $LN44@fnAddTable

; 1073 :             break;

	jmp	SHORT $LN1@fnAddTable
$LN44@fnAddTable:

; 1074 :       }

	jmp	SHORT $LN11@fnAddTable
$LN1@fnAddTable:

; 1075 :    }
; 1076 : 
; 1077 :    return;
; 1078 : 
; 1079 : }  /* fnAddTableToFrom */

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnAddTableToFrom ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_szAlias$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpSql$ = 8						; size = 4
_nTableNbr$ = 12					; size = 4
_fnAddAliasName PROC

; 745  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 746  :    zCHAR  szAlias[ 10 ];
; 747  : 
; 748  :    // If we are using outer joins then we need to add "AS" to the join
; 749  :    // statement.
; 750  :    if ( lpSql->bUseLeftJoin )

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN2@fnAddAlias

; 751  :       lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, " AS" );

	push	OFFSET $SG11612
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], esi
$LN2@fnAddAlias:

; 752  : 
; 753  :    // Generate aliases for the table names.  The alias name is generated
; 754  :    // as An where:
; 755  :    //
; 756  :    //     A = A letter representation of nSubLevel (i.e.  0='A', 1='B', etc.)
; 757  :    //     n = Number representing the sequence number of the table.
; 758  :    //
; 759  :    //  For example, the following FROM statement would be generated for a
; 760  :    //  subselect 1 level deep (e.g. nSubLevel = 1) with 2 tables:
; 761  :    //
; 762  :    //  FROM Table1 B1, Table2 B2...
; 763  : 
; 764  :    szAlias[ 0 ] = ' ';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szAlias$[ebp+edx], 32		; 00000020H

; 765  :    szAlias[ 1 ] = 'A' + (zCHAR) lpSql->nSubLevel;

	mov	eax, DWORD PTR _lpSql$[ebp]
	movsx	ecx, BYTE PTR [eax+62]
	add	ecx, 65					; 00000041H
	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _szAlias$[ebp+edx], cl

; 766  :    zltoa( (zLONG) nTableNbr, &szAlias[ 2 ] );

	push	10					; 0000000aH
	mov	eax, 1
	shl	eax, 1
	lea	ecx, DWORD PTR _szAlias$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _nTableNbr$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 767  : 
; 768  :    lpSql->pchFromEnd = zstrcatp( lpSql->pchFromEnd, szAlias );

	lea	eax, DWORD PTR _szAlias$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], esi

; 769  : 
; 770  :    // Copy alias name to table info (skipping the leading space ).
; 771  :    zstrcpy( lpSql->TableNameInfo[ nTableNbr ].szAliasName, &szAlias[ 1 ] );

	mov	eax, 1
	shl	eax, 0
	lea	ecx, DWORD PTR _szAlias$[ebp+eax]
	push	ecx
	imul	edx, DWORD PTR _nTableNbr$[ebp], 18
	mov	eax, DWORD PTR _lpSql$[ebp]
	lea	ecx, DWORD PTR [eax+edx+86]
	push	ecx
	call	_strcpy
	add	esp, 8

; 772  : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnAddAliasName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_nTableNum$ = -4					; size = 2
_lpSql$ = 8						; size = 4
_pchTableName$ = 12					; size = 4
_lpViewEntity$ = 16					; size = 4
_fnTableName@12 PROC

; 714  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 715  :    zSHORT nTableNum = fnSqlFindTableName( pchTableName, lpViewEntity,

	push	0
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	call	_fnSqlFindTableName
	add	esp, 16					; 00000010H
	mov	WORD PTR _nTableNum$[ebp], ax

; 716  :                                           lpSql, FALSE );
; 717  : 
; 718  :    // If nTableNum >= 0 then a matching table/entity has been found.  If the
; 719  :    // table has an alias name then return the alias name as the name of the
; 720  :    // table.  If not just return the table name.
; 721  :    if ( nTableNum >= 0 )

	movsx	eax, WORD PTR _nTableNum$[ebp]
	test	eax, eax
	jl	SHORT $LN2@fnTableNam

; 722  :    {
; 723  :       if (  lpSql->TableNameInfo[ nTableNum ].szAliasName[ 0 ] != 0 )

	movsx	ecx, WORD PTR _nTableNum$[ebp]
	imul	edx, ecx, 18
	mov	eax, DWORD PTR _lpSql$[ebp]
	lea	ecx, DWORD PTR [eax+edx+82]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax+4]
	test	ecx, ecx
	je	SHORT $LN3@fnTableNam

; 724  :          return( lpSql->TableNameInfo[ nTableNum ].szAliasName );

	movsx	edx, WORD PTR _nTableNum$[ebp]
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _lpSql$[ebp]
	lea	eax, DWORD PTR [ecx+eax+86]
	jmp	SHORT $LN1@fnTableNam
	jmp	SHORT $LN2@fnTableNam
$LN3@fnTableNam:

; 725  :       else
; 726  :          return( pchTableName );

	mov	eax, DWORD PTR _pchTableName$[ebp]
	jmp	SHORT $LN1@fnTableNam
$LN2@fnTableNam:

; 727  :    }
; 728  : 
; 729  :    // No matching table/entity was found.  If lpSql has a parent sql (this
; 730  :    // means that lpSql is part of a sub-select) then check for the table
; 731  :    // name in the parent sql statement.
; 732  :    if ( lpSql->lpParentSql )

	mov	edx, DWORD PTR _lpSql$[ebp]
	cmp	DWORD PTR [edx+1882], 0
	je	SHORT $LN5@fnTableNam

; 733  :       return( fnTableName( lpSql->lpParentSql, pchTableName, lpViewEntity ) );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+1882]
	push	eax
	call	_fnTableName@12
	jmp	SHORT $LN1@fnTableNam
$LN5@fnTableNam:

; 734  : 
; 735  :    // No matching table/entity and no parent sql statement.  This happens for
; 736  :    // simple stuff like INSERT, etc. where there are no alias names.  Just
; 737  :    // return the table name.
; 738  :    return( pchTableName );

	mov	eax, DWORD PTR _pchTableName$[ebp]
$LN1@fnTableNam:

; 739  : 
; 740  : } // fnTableName

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnTableName@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
tv135 = -12						; size = 4
tv134 = -8						; size = 4
_nTableCount$ = -4					; size = 2
_pchTableName$ = 8					; size = 4
_lpViewEntity$ = 12					; size = 4
_lpSql$ = 16						; size = 4
_bCheckParent$ = 20					; size = 1
_fnSqlFindTableName PROC

; 675  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 676  :    zSHORT nTableCount;
; 677  : 
; 678  :    for ( nTableCount = 0;

	xor	eax, eax
	mov	WORD PTR _nTableCount$[ebp], ax
	jmp	SHORT $LN4@fnSqlFindT
$LN2@fnSqlFindT:

; 680  :          nTableCount++ )

	mov	cx, WORD PTR _nTableCount$[ebp]
	add	cx, 1
	mov	WORD PTR _nTableCount$[ebp], cx
$LN4@fnSqlFindT:

; 679  :          nTableCount < lpSql->nFromTableCount;

	movsx	edx, WORD PTR _nTableCount$[ebp]
	mov	eax, DWORD PTR _lpSql$[ebp]
	movsx	ecx, WORD PTR [eax+80]
	cmp	edx, ecx
	jge	$LN3@fnSqlFindT

; 681  :    {
; 682  :       if ( lpSql->TableNameInfo[ nTableCount ].lpViewEntity == lpViewEntity &&

	movsx	edx, WORD PTR _nTableCount$[ebp]
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+eax+96]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN5@fnSqlFindT
	movsx	eax, WORD PTR _nTableCount$[ebp]
	imul	ecx, eax, 18
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+ecx+82]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pchTableName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN10@fnSqlFindT
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nTableCount$[ebp]
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+eax+82]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv135[ebp], eax
	jmp	SHORT $LN11@fnSqlFindT
$LN10@fnSqlFindT:
	movsx	eax, WORD PTR _nTableCount$[ebp]
	imul	ecx, eax, 18
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+ecx+82]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pchTableName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN8@fnSqlFindT
	mov	DWORD PTR tv134[ebp], 1
	jmp	SHORT $LN9@fnSqlFindT
$LN8@fnSqlFindT:
	mov	DWORD PTR tv134[ebp], -1
$LN9@fnSqlFindT:
	mov	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR tv135[ebp], ecx
$LN11@fnSqlFindT:
	cmp	DWORD PTR tv135[ebp], 0
	jne	SHORT $LN5@fnSqlFindT

; 683  :            zstrcmp( lpSql->TableNameInfo[ nTableCount ].pchTableName,
; 684  :                     pchTableName ) == 0 )
; 685  :       {
; 686  :          return( nTableCount );

	mov	ax, WORD PTR _nTableCount$[ebp]
	jmp	SHORT $LN1@fnSqlFindT
$LN5@fnSqlFindT:

; 687  :       }
; 688  :    }

	jmp	$LN2@fnSqlFindT
$LN3@fnSqlFindT:

; 689  : 
; 690  :    // We didn't find the table name so if the caller wants us to check the
; 691  :    // parent (and if there is a parent) then make recursive call using the
; 692  :    // parent.
; 693  :    if ( bCheckParent && lpSql->lpParentSql )

	movzx	edx, BYTE PTR _bCheckParent$[ebp]
	test	edx, edx
	je	SHORT $LN6@fnSqlFindT
	mov	eax, DWORD PTR _lpSql$[ebp]
	cmp	DWORD PTR [eax+1882], 0
	je	SHORT $LN6@fnSqlFindT

; 694  :       return( fnSqlFindTableName( pchTableName, lpViewEntity,

	movzx	ecx, BYTE PTR _bCheckParent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+1882]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	call	_fnSqlFindTableName
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@fnSqlFindT
$LN6@fnSqlFindT:

; 695  :                                   lpSql->lpParentSql, bCheckParent ) );
; 696  : 
; 697  :    // We got here?  Then there is no table name.
; 698  :    return( -1 );

	or	eax, -1
$LN1@fnSqlFindT:

; 699  : 
; 700  : }  /* fnSqlFindTableName */

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlFindTableName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpSql$ = 8						; size = 4
_fnSqlAssembleSqlStatement PROC

; 620  : {

	push	ebp
	mov	ebp, esp
	push	esi

; 621  :    if ( lpSql->pchColList2[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movsx	ecx, BYTE PTR [eax+ecx]
	test	ecx, ecx
	je	SHORT $LN2@fnSqlAssem

; 622  :       fnSqlAddStringToSql( lpSql, lpSql->pchColList2 );

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi
$LN2@fnSqlAssem:

; 623  : 
; 624  :    if ( lpSql->pchFrom[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+28]
	movsx	ecx, BYTE PTR [eax+ecx]
	test	ecx, ecx
	je	SHORT $LN3@fnSqlAssem

; 625  :    {
; 626  :       fnSqlAddStringToSql( lpSql, " FROM " );

	push	OFFSET $SG11557
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 627  :       fnSqlAddStringToSql( lpSql, lpSql->pchFrom );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi
$LN3@fnSqlAssem:

; 628  :    }
; 629  : 
; 630  :    if ( lpSql->pchWhere[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	movsx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	$LN4@fnSqlAssem

; 631  :    {
; 632  :       if ( lpSql->nComponentCount > 1 )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	movsx	edx, WORD PTR [ecx+56]
	cmp	edx, 1
	jle	$LN5@fnSqlAssem

; 633  :       {
; 634  :          fnSqlAddStringToSql( lpSql, " WHERE ( " );

	push	OFFSET $SG11561
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 635  :          fnSqlAddStringToSql( lpSql, lpSql->pchWhere );

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 636  :          fnSqlAddStringToSql( lpSql, " )" );

	push	OFFSET $SG11562
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 637  :       }

	jmp	SHORT $LN4@fnSqlAssem
$LN5@fnSqlAssem:

; 638  :       else
; 639  :       {
; 640  :          fnSqlAddStringToSql( lpSql, " WHERE " );

	push	OFFSET $SG11563
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 641  :          fnSqlAddStringToSql( lpSql, lpSql->pchWhere );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi
$LN4@fnSqlAssem:

; 642  :       }
; 643  :    }
; 644  : 
; 645  :    if ( lpSql->pchSuffix[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	movsx	eax, BYTE PTR [edx+eax]
	test	eax, eax
	je	SHORT $LN7@fnSqlAssem

; 646  :       fnSqlAddStringToSql( lpSql, lpSql->pchSuffix );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi
$LN7@fnSqlAssem:

; 647  : 
; 648  :    fnSqlFreeSqlStatement( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 649  : 
; 650  :    return( 0 );

	xor	eax, eax

; 651  : }  /* fnSqlAssembleSqlStatement */

	pop	esi
	pop	ebp
	ret	0
_fnSqlAssembleSqlStatement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpSql$ = 8						; size = 4
_fnSqlFreeSqlStatement PROC

; 606  : {

	push	ebp
	mov	ebp, esp

; 607  :    if ( lpSql->hSqlCmd )

	mov	eax, DWORD PTR _lpSql$[ebp]
	cmp	DWORD PTR [eax+58], 0
	je	SHORT $LN2@fnSqlFreeS

; 608  :       SysFreeMemory( lpSql->hSqlCmd );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+58]
	push	edx
	call	_SysFreeMemory@4
$LN2@fnSqlFreeS:

; 609  : 
; 610  :    return( 0 );

	xor	eax, eax

; 611  : }  /* fnSqlFreeSqlStatement */

	pop	ebp
	ret	0
_fnSqlFreeSqlStatement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpSql$ = 8						; size = 4
_nCommandType$ = 12					; size = 2
_pchSqlCmd$ = 16					; size = 4
_lpView$ = 20						; size = 4
_lpBoundList$ = 24					; size = 4
_fnSqlInitSqlStatement PROC

; 542  : {

	push	ebp
	mov	ebp, esp

; 543  :    zmemset( (zPVOID) lpSql, 0, sizeof( SqlStatementRecord ) );

	push	1890					; 00000762H
	push	0
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 544  :    if ( pchSqlCmd == 0 )

	cmp	DWORD PTR _pchSqlCmd$[ebp], 0
	jne	SHORT $LN2@fnSqlInitS

; 545  :    {
; 546  :       lpSql->hSqlCmd = SysAllocMemory( &pchSqlCmd, MAX_SQLCMD_LENGTH,

	push	0
	push	32768					; 00008000H
	push	0
	push	105000					; 00019a28H
	lea	ecx, DWORD PTR _pchSqlCmd$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+58], eax

; 547  :                                        0, zCOREMEM_ALLOC, 0 );
; 548  :       if ( lpSql->hSqlCmd == 0 )

	mov	eax, DWORD PTR _lpSql$[ebp]
	cmp	DWORD PTR [eax+58], 0
	jne	SHORT $LN2@fnSqlInitS

; 549  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSqlInitS
$LN2@fnSqlInitS:

; 550  :    }
; 551  : 
; 552  : #ifdef DEBUG
; 553  :    zmemset( pchSqlCmd, 0, MAX_SQLCMD_LENGTH - 1 );

	push	104999					; 00019a27H
	push	0
	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 554  : #endif
; 555  : 
; 556  :    *pchSqlCmd = 0;   // Make sure SQL initialized with null.

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	mov	BYTE PTR [edx], 0

; 557  :    lpSql->pchSqlCmd    = pchSqlCmd;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 558  :    lpSql->pchSqlCmdEnd = pchSqlCmd;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [edx+16], eax

; 559  : 
; 560  :    // Set aside room for the column list.
; 561  :    pchSqlCmd += MAX_COLUMN_LENGTH;

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	add	ecx, 50000				; 0000c350H
	mov	DWORD PTR _pchSqlCmd$[ebp], ecx

; 562  : 
; 563  :    // Set up space for 2nd column list.  This is used when some columns must
; 564  :    // appear at the end of the SELECT list (e.g. ODBC long columns).
; 565  :    *pchSqlCmd            = 0;            // Init to empty string.

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	mov	BYTE PTR [edx], 0

; 566  :    lpSql->pchColList2    = pchSqlCmd;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 567  :    lpSql->pchColList2[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	BYTE PTR [eax+edx], 0

; 568  :    lpSql->pchColList2End = lpSql->pchColList2;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+24], edx

; 569  : 
; 570  :    // Set aside room for the 2nd column list.
; 571  :    pchSqlCmd += MAX_COLUMN2_LENGTH;

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	add	eax, 10000				; 00002710H
	mov	DWORD PTR _pchSqlCmd$[ebp], eax

; 572  : 
; 573  :    *pchSqlCmd         = 0;            // Init to empty string.

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	mov	BYTE PTR [ecx], 0

; 574  :    lpSql->pchWhere    = pchSqlCmd;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [edx+40], eax

; 575  :    lpSql->pchWhereEnd = pchSqlCmd;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [ecx+44], edx

; 576  : 
; 577  :    // Set aside room for the WHERE clause.
; 578  :    pchSqlCmd += MAX_WHERE_LENGTH;

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	add	eax, 20000				; 00004e20H
	mov	DWORD PTR _pchSqlCmd$[ebp], eax

; 579  : 
; 580  :    *pchSqlCmd        = 0;            // Init to empty string.

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	mov	BYTE PTR [ecx], 0

; 581  :    lpSql->pchFrom    = pchSqlCmd;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [edx+28], eax

; 582  :    lpSql->pchFromEnd = pchSqlCmd;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 583  : 
; 584  :    // Set aside room for the FROM clause.
; 585  :    pchSqlCmd += MAX_FROM_LENGTH;

	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	add	eax, 20000				; 00004e20H
	mov	DWORD PTR _pchSqlCmd$[ebp], eax

; 586  : 
; 587  :    *pchSqlCmd          = 0;            // Init to empty string.

	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	mov	BYTE PTR [ecx], 0

; 588  :    lpSql->pchSuffix    = pchSqlCmd;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [edx+48], eax

; 589  :    lpSql->pchSuffixEnd = pchSqlCmd;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	mov	DWORD PTR [ecx+52], edx

; 590  : 
; 591  :    lpSql->nCommandType = nCommandType;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	cx, WORD PTR _nCommandType$[ebp]
	mov	WORD PTR [eax+10], cx

; 592  :    lpSql->lpView       = lpView;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+64], eax

; 593  :    lpSql->lpBoundList  = lpBoundList;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	DWORD PTR [ecx+1886], edx

; 594  : 
; 595  :    return( 0 );

	xor	eax, eax
$LN1@fnSqlInitS:

; 596  : 
; 597  : }  /* fnSqlInitSqlStatement */

	pop	ebp
	ret	0
_fnSqlInitSqlStatement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lTemp$ = -172						; size = 4
tv165 = -168						; size = 4
tv158 = -164						; size = 4
tv244 = -160						; size = 4
tv237 = -156						; size = 4
tv229 = -152						; size = 4
tv223 = -148						; size = 4
tv216 = -144						; size = 4
tv214 = -140						; size = 4
tv213 = -136						; size = 4
tv201 = -132						; size = 4
tv194 = -128						; size = 4
tv187 = -124						; size = 4
tv180 = -120						; size = 4
tv178 = -116						; size = 4
tv177 = -112						; size = 4
tv151 = -108						; size = 4
tv144 = -104						; size = 4
tv142 = -100						; size = 4
tv141 = -96						; size = 4
tv129 = -92						; size = 4
tv90 = -88						; size = 4
tv192 = -84						; size = 4
tv156 = -80						; size = 4
tv88 = -76						; size = 4
tv86 = -72						; size = 4
tv65 = -68						; size = 4
_szOper$ = -64						; size = 4
_lpB$ = -60						; size = 4
_bNot$ = -55						; size = 1
_bReturn$ = -54						; size = 1
_b$ = -53						; size = 1
_dTemp$ = -52						; size = 40
_dtTemp$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpA$ = 12						; size = 4
_pchOperStr$ = 16					; size = 4
_pchBStr$ = 20						; size = 4
_chType$ = 24						; size = 1
_fnCompare PROC

; 384  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 172				; 000000acH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 385  :    zPCHAR   szOper;
; 386  :    zBOOL    b;
; 387  :    zBOOL    bNot;
; 388  :    zBOOL    bReturn;
; 389  :    zPVOID   lpB;
; 390  :    zLONG    lTemp;
; 391  :    zDECIMAL dTemp;
; 392  :    DateTimeRecord dtTemp;
; 393  : 
; 394  :    switch ( chType )

	movsx	eax, BYTE PTR _chType$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	sub	ecx, 68					; 00000044H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 16			; 00000010H
	ja	SHORT $LN2@fnCompare
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN80@fnCompare[edx]
	jmp	DWORD PTR $LN85@fnCompare[eax*4]
$LN16@fnCompare:

; 395  :    {
; 396  :       case zTYPE_INTEGER:
; 397  :          lTemp = zatol( pchBStr );

	mov	ecx, DWORD PTR _pchBStr$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lTemp$[ebp], eax

; 398  :          lpB = (zPVOID) &lTemp;

	lea	edx, DWORD PTR _lTemp$[ebp]
	mov	DWORD PTR _lpB$[ebp], edx

; 399  :          break;

	jmp	SHORT $LN2@fnCompare
$LN17@fnCompare:

; 400  : 
; 401  :       case zTYPE_DECIMAL:
; 402  :          SysConvertStringToDecimal( pchBStr, &dTemp );

	lea	eax, DWORD PTR _dTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBStr$[ebp]
	push	ecx
	call	_SysConvertStringToDecimal@8

; 403  :          lpB = (zPVOID) &dTemp;

	lea	edx, DWORD PTR _dTemp$[ebp]
	mov	DWORD PTR _lpB$[ebp], edx

; 404  :          break;

	jmp	SHORT $LN2@fnCompare
$LN18@fnCompare:

; 405  : 
; 406  :       case zTYPE_DATETIME:
; 407  :       case zTYPE_TIME:
; 408  :       case zTYPE_DATE:
; 409  :          UfStringToDateTime( pchBStr, &dtTemp );

	lea	eax, DWORD PTR _dtTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBStr$[ebp]
	push	ecx
	call	_UfStringToDateTime@8

; 410  :          lpB = (zPVOID) &dtTemp;

	lea	edx, DWORD PTR _dtTemp$[ebp]
	mov	DWORD PTR _lpB$[ebp], edx
$LN2@fnCompare:

; 411  :          break;
; 412  :    }
; 413  : 
; 414  :    bReturn = FALSE;

	mov	BYTE PTR _bReturn$[ebp], 0

; 415  :    bNot    = FALSE;

	mov	BYTE PTR _bNot$[ebp], 0

; 416  :    szOper  = pchOperStr;

	mov	eax, DWORD PTR _pchOperStr$[ebp]
	mov	DWORD PTR _szOper$[ebp], eax
$LN4@fnCompare:

; 417  :    while ( szOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _szOper$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	$LN5@fnCompare
$LN6@fnCompare:

; 418  :    {
; 419  :       // Skip whitespaces.
; 420  :       while ( szOper[ 0 ] == ' ' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _szOper$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN7@fnCompare

; 421  :          szOper++;

	mov	eax, DWORD PTR _szOper$[ebp]
	add	eax, 1
	mov	DWORD PTR _szOper$[ebp], eax
	jmp	SHORT $LN6@fnCompare
$LN7@fnCompare:

; 422  : 
; 423  :       // Using szOper, compare the two values.  The variable b is the result
; 424  :       // of the compareson.
; 425  :       switch ( szOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _szOper$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	sub	edx, 33					; 00000021H
	mov	DWORD PTR tv86[ebp], edx
	cmp	DWORD PTR tv86[ebp], 29			; 0000001dH
	ja	$LN8@fnCompare
	mov	eax, DWORD PTR tv86[ebp]
	movzx	ecx, BYTE PTR $LN81@fnCompare[eax]
	jmp	DWORD PTR $LN86@fnCompare[ecx*4]
$LN19@fnCompare:

; 426  :       {
; 427  :          case '>':
; 428  :             switch ( chType )

	movsx	edx, BYTE PTR _chType$[ebp]
	mov	DWORD PTR tv88[ebp], edx
	mov	eax, DWORD PTR tv88[ebp]
	sub	eax, 68					; 00000044H
	mov	DWORD PTR tv88[ebp], eax
	cmp	DWORD PTR tv88[ebp], 16			; 00000010H
	ja	$LN10@fnCompare
	mov	ecx, DWORD PTR tv88[ebp]
	movzx	edx, BYTE PTR $LN82@fnCompare[ecx]
	jmp	DWORD PTR $LN87@fnCompare[edx*4]
$LN20@fnCompare:

; 429  :             {
; 430  :                case zTYPE_INTEGER:
; 431  :                   b = *((zPLONG) lpA) > *((zPLONG) lpB);

	mov	eax, DWORD PTR _lpA$[ebp]
	mov	ecx, DWORD PTR _lpB$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jle	SHORT $LN38@fnCompare
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN39@fnCompare
$LN38@fnCompare:
	mov	DWORD PTR tv90[ebp], 0
$LN39@fnCompare:
	mov	al, BYTE PTR tv90[ebp]
	mov	BYTE PTR _b$[ebp], al

; 432  :                   break;

	jmp	$LN10@fnCompare
$LN21@fnCompare:

; 433  : 
; 434  :                case zTYPE_DECIMAL:
; 435  :                   b = SysCompareDecimalToDecimal( (zPDECIMAL) lpA,

	mov	ecx, DWORD PTR _lpB$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpA$[ebp]
	push	edx
	call	_SysCompareDecimalToDecimal@8
	cwde
	test	eax, eax
	jle	SHORT $LN40@fnCompare
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN41@fnCompare
$LN40@fnCompare:
	mov	DWORD PTR tv129[ebp], 0
$LN41@fnCompare:
	mov	cl, BYTE PTR tv129[ebp]
	mov	BYTE PTR _b$[ebp], cl

; 436  :                                                   (zPDECIMAL) lpB ) > 0;
; 437  :                   break;

	jmp	$LN10@fnCompare
$LN22@fnCompare:

; 438  : 
; 439  :                case zTYPE_STRING:
; 440  :                   b = zstrcmp( (zPCHAR) lpA, (zPCHAR) pchBStr ) > 0;

	mov	edx, DWORD PTR _lpA$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchBStr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN44@fnCompare
	mov	eax, DWORD PTR _pchBStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpA$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN45@fnCompare
$LN44@fnCompare:
	mov	edx, DWORD PTR _lpA$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchBStr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN42@fnCompare
	mov	DWORD PTR tv141[ebp], 1
	jmp	SHORT $LN43@fnCompare
$LN42@fnCompare:
	mov	DWORD PTR tv141[ebp], -1
$LN43@fnCompare:
	mov	eax, DWORD PTR tv141[ebp]
	mov	DWORD PTR tv142[ebp], eax
$LN45@fnCompare:
	cmp	DWORD PTR tv142[ebp], 0
	jle	SHORT $LN46@fnCompare
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN47@fnCompare
$LN46@fnCompare:
	mov	DWORD PTR tv144[ebp], 0
$LN47@fnCompare:
	mov	cl, BYTE PTR tv144[ebp]
	mov	BYTE PTR _b$[ebp], cl

; 441  :                   break;

	jmp	SHORT $LN10@fnCompare
$LN23@fnCompare:

; 442  : 
; 443  :                case zTYPE_DATETIME:
; 444  :                case zTYPE_TIME:
; 445  :                case zTYPE_DATE:
; 446  :                   b = UfCompareDateTimeToDateTime( (LPDATETIME) lpA,

	mov	edx, DWORD PTR _lpB$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpA$[ebp]
	push	eax
	call	_UfCompareDateTimeToDateTime@8
	movsx	ecx, ax
	test	ecx, ecx
	jle	SHORT $LN48@fnCompare
	mov	DWORD PTR tv151[ebp], 1
	jmp	SHORT $LN49@fnCompare
$LN48@fnCompare:
	mov	DWORD PTR tv151[ebp], 0
$LN49@fnCompare:
	mov	dl, BYTE PTR tv151[ebp]
	mov	BYTE PTR _b$[ebp], dl
$LN10@fnCompare:

; 447  :                                                    (LPDATETIME) lpB ) > 0;
; 448  :                   break;
; 449  :             }
; 450  : 
; 451  :             break;

	jmp	$LN8@fnCompare
$LN24@fnCompare:

; 452  : 
; 453  :          case '<':
; 454  :             switch ( chType )

	movsx	eax, BYTE PTR _chType$[ebp]
	mov	DWORD PTR tv156[ebp], eax
	mov	ecx, DWORD PTR tv156[ebp]
	sub	ecx, 68					; 00000044H
	mov	DWORD PTR tv156[ebp], ecx
	cmp	DWORD PTR tv156[ebp], 16		; 00000010H
	ja	$LN12@fnCompare
	mov	edx, DWORD PTR tv156[ebp]
	movzx	eax, BYTE PTR $LN83@fnCompare[edx]
	jmp	DWORD PTR $LN88@fnCompare[eax*4]
$LN25@fnCompare:

; 455  :             {
; 456  :                case zTYPE_INTEGER:
; 457  :                   b = *((zPLONG) lpA) < *((zPLONG) lpB);

	mov	ecx, DWORD PTR _lpA$[ebp]
	mov	edx, DWORD PTR _lpB$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN50@fnCompare
	mov	DWORD PTR tv158[ebp], 1
	jmp	SHORT $LN51@fnCompare
$LN50@fnCompare:
	mov	DWORD PTR tv158[ebp], 0
$LN51@fnCompare:
	mov	cl, BYTE PTR tv158[ebp]
	mov	BYTE PTR _b$[ebp], cl

; 458  :                   break;

	jmp	$LN12@fnCompare
$LN26@fnCompare:

; 459  : 
; 460  :                case zTYPE_DECIMAL:
; 461  :                   b = SysCompareDecimalToDecimal( (zPDECIMAL) lpA,

	mov	edx, DWORD PTR _lpB$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpA$[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN52@fnCompare
	mov	DWORD PTR tv165[ebp], 1
	jmp	SHORT $LN53@fnCompare
$LN52@fnCompare:
	mov	DWORD PTR tv165[ebp], 0
$LN53@fnCompare:
	mov	dl, BYTE PTR tv165[ebp]
	mov	BYTE PTR _b$[ebp], dl

; 462  :                                                   (zPDECIMAL) lpB ) < 0;
; 463  :                   break;

	jmp	$LN12@fnCompare
$LN27@fnCompare:

; 464  : 
; 465  :                case zTYPE_STRING:
; 466  :                   b = zstrcmp( (zPCHAR) lpA, pchBStr ) < 0;

	mov	eax, DWORD PTR _lpA$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pchBStr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN56@fnCompare
	mov	ecx, DWORD PTR _pchBStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpA$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv178[ebp], eax
	jmp	SHORT $LN57@fnCompare
$LN56@fnCompare:
	mov	eax, DWORD PTR _lpA$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pchBStr$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN54@fnCompare
	mov	DWORD PTR tv177[ebp], 1
	jmp	SHORT $LN55@fnCompare
$LN54@fnCompare:
	mov	DWORD PTR tv177[ebp], -1
$LN55@fnCompare:
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR tv178[ebp], ecx
$LN57@fnCompare:
	cmp	DWORD PTR tv178[ebp], 0
	jge	SHORT $LN58@fnCompare
	mov	DWORD PTR tv180[ebp], 1
	jmp	SHORT $LN59@fnCompare
$LN58@fnCompare:
	mov	DWORD PTR tv180[ebp], 0
$LN59@fnCompare:
	mov	dl, BYTE PTR tv180[ebp]
	mov	BYTE PTR _b$[ebp], dl

; 467  :                   break;

	jmp	SHORT $LN12@fnCompare
$LN28@fnCompare:

; 468  : 
; 469  :                case zTYPE_DATETIME:
; 470  :                case zTYPE_TIME:
; 471  :                case zTYPE_DATE:
; 472  :                   b = UfCompareDateTimeToDateTime( (LPDATETIME) lpA,

	mov	eax, DWORD PTR _lpB$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpA$[ebp]
	push	ecx
	call	_UfCompareDateTimeToDateTime@8
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN60@fnCompare
	mov	DWORD PTR tv187[ebp], 1
	jmp	SHORT $LN61@fnCompare
$LN60@fnCompare:
	mov	DWORD PTR tv187[ebp], 0
$LN61@fnCompare:
	mov	al, BYTE PTR tv187[ebp]
	mov	BYTE PTR _b$[ebp], al
$LN12@fnCompare:

; 473  :                                                    (LPDATETIME) lpB ) < 0;
; 474  :                   break;
; 475  :             }
; 476  : 
; 477  :             break;

	jmp	$LN8@fnCompare
$LN29@fnCompare:

; 478  : 
; 479  :          case '=':
; 480  :             switch ( chType )

	movsx	ecx, BYTE PTR _chType$[ebp]
	mov	DWORD PTR tv192[ebp], ecx
	mov	edx, DWORD PTR tv192[ebp]
	sub	edx, 68					; 00000044H
	mov	DWORD PTR tv192[ebp], edx
	cmp	DWORD PTR tv192[ebp], 16		; 00000010H
	ja	$LN14@fnCompare
	mov	eax, DWORD PTR tv192[ebp]
	movzx	ecx, BYTE PTR $LN84@fnCompare[eax]
	jmp	DWORD PTR $LN89@fnCompare[ecx*4]
$LN30@fnCompare:

; 481  :             {
; 482  :                case zTYPE_INTEGER:
; 483  :                   b = *((zPLONG) lpA) == *((zPLONG) lpB);

	mov	edx, DWORD PTR _lpA$[ebp]
	mov	eax, DWORD PTR _lpB$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN62@fnCompare
	mov	DWORD PTR tv194[ebp], 1
	jmp	SHORT $LN63@fnCompare
$LN62@fnCompare:
	mov	DWORD PTR tv194[ebp], 0
$LN63@fnCompare:
	mov	dl, BYTE PTR tv194[ebp]
	mov	BYTE PTR _b$[ebp], dl

; 484  :                   break;

	jmp	$LN14@fnCompare
$LN31@fnCompare:

; 485  : 
; 486  :                case zTYPE_DECIMAL:
; 487  :                   b = SysCompareDecimalToDecimal( (zPDECIMAL) lpA,

	mov	eax, DWORD PTR _lpB$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpA$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN64@fnCompare
	mov	DWORD PTR tv201[ebp], 1
	jmp	SHORT $LN65@fnCompare
$LN64@fnCompare:
	mov	DWORD PTR tv201[ebp], 0
$LN65@fnCompare:
	mov	al, BYTE PTR tv201[ebp]
	mov	BYTE PTR _b$[ebp], al

; 488  :                                                   (zPDECIMAL) lpB ) == 0;
; 489  :                   break;

	jmp	$LN14@fnCompare
$LN32@fnCompare:

; 490  : 
; 491  :                case zTYPE_STRING:
; 492  :                   b = zstrcmp( (zPCHAR) lpA, pchBStr ) == 0;

	mov	ecx, DWORD PTR _lpA$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchBStr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN68@fnCompare
	mov	edx, DWORD PTR _pchBStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpA$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN69@fnCompare
$LN68@fnCompare:
	mov	ecx, DWORD PTR _lpA$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchBStr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN66@fnCompare
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN67@fnCompare
$LN66@fnCompare:
	mov	DWORD PTR tv213[ebp], -1
$LN67@fnCompare:
	mov	edx, DWORD PTR tv213[ebp]
	mov	DWORD PTR tv214[ebp], edx
$LN69@fnCompare:
	cmp	DWORD PTR tv214[ebp], 0
	jne	SHORT $LN70@fnCompare
	mov	DWORD PTR tv216[ebp], 1
	jmp	SHORT $LN71@fnCompare
$LN70@fnCompare:
	mov	DWORD PTR tv216[ebp], 0
$LN71@fnCompare:
	mov	al, BYTE PTR tv216[ebp]
	mov	BYTE PTR _b$[ebp], al

; 493  :                   break;

	jmp	SHORT $LN14@fnCompare
$LN33@fnCompare:

; 494  : 
; 495  :                case zTYPE_DATETIME:
; 496  :                case zTYPE_TIME:
; 497  :                case zTYPE_DATE:
; 498  :                   b = UfCompareDateTimeToDateTime( (LPDATETIME) lpA,

	mov	ecx, DWORD PTR _lpB$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpA$[ebp]
	push	edx
	call	_UfCompareDateTimeToDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN72@fnCompare
	mov	DWORD PTR tv223[ebp], 1
	jmp	SHORT $LN73@fnCompare
$LN72@fnCompare:
	mov	DWORD PTR tv223[ebp], 0
$LN73@fnCompare:
	mov	cl, BYTE PTR tv223[ebp]
	mov	BYTE PTR _b$[ebp], cl
$LN14@fnCompare:

; 499  :                                                    (LPDATETIME) lpB ) == 0;
; 500  :                   break;
; 501  :             }
; 502  : 
; 503  :             break;

	jmp	SHORT $LN8@fnCompare
$LN34@fnCompare:

; 504  : 
; 505  :          case '!':
; 506  :             bNot = !bNot;

	movzx	edx, BYTE PTR _bNot$[ebp]
	test	edx, edx
	jne	SHORT $LN74@fnCompare
	mov	DWORD PTR tv229[ebp], 1
	jmp	SHORT $LN75@fnCompare
$LN74@fnCompare:
	mov	DWORD PTR tv229[ebp], 0
$LN75@fnCompare:
	mov	al, BYTE PTR tv229[ebp]
	mov	BYTE PTR _bNot$[ebp], al

; 507  :             b    = FALSE;

	mov	BYTE PTR _b$[ebp], 0
$LN8@fnCompare:

; 508  :             break;
; 509  :       }
; 510  : 
; 511  :       bReturn = bReturn || b;

	movzx	ecx, BYTE PTR _bReturn$[ebp]
	test	ecx, ecx
	jne	SHORT $LN76@fnCompare
	movzx	edx, BYTE PTR _b$[ebp]
	test	edx, edx
	jne	SHORT $LN76@fnCompare
	mov	DWORD PTR tv237[ebp], 0
	jmp	SHORT $LN77@fnCompare
$LN76@fnCompare:
	mov	DWORD PTR tv237[ebp], 1
$LN77@fnCompare:
	mov	al, BYTE PTR tv237[ebp]
	mov	BYTE PTR _bReturn$[ebp], al

; 512  : 
; 513  :       szOper++;

	mov	ecx, DWORD PTR _szOper$[ebp]
	add	ecx, 1
	mov	DWORD PTR _szOper$[ebp], ecx

; 514  :    } // while ( szOper[ 0 ] )...

	jmp	$LN4@fnCompare
$LN5@fnCompare:

; 515  : 
; 516  :    if ( bNot )

	movzx	edx, BYTE PTR _bNot$[ebp]
	test	edx, edx
	je	SHORT $LN35@fnCompare

; 517  :       return( !bReturn );

	movzx	eax, BYTE PTR _bReturn$[ebp]
	test	eax, eax
	jne	SHORT $LN78@fnCompare
	mov	DWORD PTR tv244[ebp], 1
	jmp	SHORT $LN79@fnCompare
$LN78@fnCompare:
	mov	DWORD PTR tv244[ebp], 0
$LN79@fnCompare:
	mov	ax, WORD PTR tv244[ebp]
	jmp	SHORT $LN1@fnCompare
	jmp	SHORT $LN1@fnCompare
$LN35@fnCompare:

; 518  :    else
; 519  :       return( bReturn );

	movzx	ax, BYTE PTR _bReturn$[ebp]
$LN1@fnCompare:

; 520  : 
; 521  : }  /* fnCompare */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN85@fnCompare:
	DD	$LN18@fnCompare
	DD	$LN16@fnCompare
	DD	$LN17@fnCompare
	DD	$LN2@fnCompare
$LN80@fnCompare:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	0
	DB	3
	DB	3
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	0
	npad	3
$LN86@fnCompare:
	DD	$LN34@fnCompare
	DD	$LN24@fnCompare
	DD	$LN29@fnCompare
	DD	$LN19@fnCompare
	DD	$LN8@fnCompare
$LN81@fnCompare:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
	npad	2
$LN87@fnCompare:
	DD	$LN23@fnCompare
	DD	$LN20@fnCompare
	DD	$LN21@fnCompare
	DD	$LN22@fnCompare
	DD	$LN10@fnCompare
$LN82@fnCompare:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
	npad	3
$LN88@fnCompare:
	DD	$LN28@fnCompare
	DD	$LN25@fnCompare
	DD	$LN26@fnCompare
	DD	$LN27@fnCompare
	DD	$LN12@fnCompare
$LN83@fnCompare:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
	npad	3
$LN89@fnCompare:
	DD	$LN33@fnCompare
	DD	$LN30@fnCompare
	DD	$LN31@fnCompare
	DD	$LN32@fnCompare
	DD	$LN14@fnCompare
$LN84@fnCompare:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
_fnCompare ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_pch$ = -4						; size = 4
_pchSource$ = 8						; size = 4
_zstrtrim PROC

; 330  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 331  :    zPCHAR pch;
; 332  : 
; 333  :    // Find first non-space.
; 334  :    for ( pch = pchSource; zisspace( *pch ); pch++ )

	mov	eax, DWORD PTR _pchSource$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN4@zstrtrim
$LN2@zstrtrim:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN4@zstrtrim:
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@zstrtrim

; 335  :       ; // Nothing needs to be done here.

	jmp	SHORT $LN2@zstrtrim
$LN3@zstrtrim:

; 336  : 
; 337  :    if ( pch != pchSource )

	mov	ecx, DWORD PTR _pch$[ebp]
	cmp	ecx, DWORD PTR _pchSource$[ebp]
	je	SHORT $LN8@zstrtrim

; 338  :       zstrcpy( pchSource, pch );

	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSource$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN8@zstrtrim:

; 339  : 
; 340  :    for ( pch = pchSource + zstrlen( pchSource ); zisspace( *pch ); pch-- )

	mov	ecx, DWORD PTR _pchSource$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchSource$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN7@zstrtrim
$LN5@zstrtrim:
	mov	edx, DWORD PTR _pch$[ebp]
	sub	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$LN7@zstrtrim:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@zstrtrim

; 341  :       ; // nothing needs to be done here

	jmp	SHORT $LN5@zstrtrim
$LN6@zstrtrim:

; 342  : 
; 343  :    *pch = 0;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 0

; 344  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_zstrtrim ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_pTemp$1 = -1072					; size = 4
_lpOrderDataRecord$2 = -1068				; size = 4
_lpOrderViewEntity$ = -1064				; size = 4
_lpDataField$ = -1060					; size = 4
_bContinue$ = -1056					; size = 2
_lpViewAttrib$ = -1052					; size = 4
_j$ = -1048						; size = 4
_nKey$ = -1044						; size = 4
_nSequencing$ = -1040					; size = 4
_nOrderBy$ = -1036					; size = 2
_k$ = -1032						; size = 4
_apDataField$3 = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_lpSql$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpFirstQualEntity$ = 16				; size = 4
_lpBoundList$ = 20					; size = 4
_fnCanonicalOrder PROC

; 4762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1072				; 00000430H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 4763 :    LPVIEWENTITY lpOrderViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpOrderViewEntity$[ebp], eax

; 4764 :    LPDATAFIELD  lpDataField;
; 4765 :    LPVIEWATTRIB lpViewAttrib;
; 4766 :    zSHORT       nOrderBy = -1;

	or	ecx, -1
	mov	WORD PTR _nOrderBy$[ebp], cx

; 4767 :    zSHORT       bContinue = 0;

	xor	edx, edx
	mov	WORD PTR _bContinue$[ebp], dx
$LN4@fnCanonica:

; 4768 :    zLONG        nKey;
; 4769 :    zLONG        nSequencing;
; 4770 :    zLONG        k, j;
; 4771 : 
; 4772 :    do
; 4773 :    {
; 4774 :       LPDATARECORD lpOrderDataRecord;
; 4775 :       LPDATAFIELD apDataField[ MAXLEN_KEY_ARRAY ];
; 4776 : 
; 4777 :       memset( apDataField, 0, sizeof( apDataField ) );

	push	1024					; 00000400H
	push	0
	lea	eax, DWORD PTR _apDataField$3[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4778 :       nKey = 0;

	mov	DWORD PTR _nKey$[ebp], 0

; 4779 :       nSequencing = 0;

	mov	DWORD PTR _nSequencing$[ebp], 0

; 4780 : 
; 4781 :       lpOrderDataRecord = zGETPTR( lpOrderViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpOrderViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpOrderDataRecord$2[ebp], eax

; 4782 : 
; 4783 :       // find the key attributes, honoring the sequencing fild
; 4784 :       for ( lpDataField = zGETPTR( lpOrderDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpOrderDataRecord$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN7@fnCanonica
$LN5@fnCanonica:

; 4786 :             lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN7@fnCanonica:

; 4785 :             lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN6@fnCanonica

; 4787 :       {
; 4788 :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 4789 :          if ( lpViewAttrib->cSequencing ) {

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movzx	ecx, BYTE PTR [eax+197]
	test	ecx, ecx
	je	SHORT $LN17@fnCanonica

; 4790 :             nSequencing++;

	mov	edx, DWORD PTR _nSequencing$[ebp]
	add	edx, 1
	mov	DWORD PTR _nSequencing$[ebp], edx

; 4791 :             // if a sequencing attr is NOT a key, then the ORDER BY to
; 4792 :             //  be generated won't be the right one
; 4793 :             if ( lpViewAttrib->bKey == FALSE )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN17@fnCanonica

; 4794 :                nOrderBy = 0;

	xor	edx, edx
	mov	WORD PTR _nOrderBy$[ebp], dx
$LN17@fnCanonica:

; 4795 :          }
; 4796 : 
; 4797 :          if ( lpViewAttrib->bKey ) {

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN19@fnCanonica

; 4798 :             if ( nKey >= MAXLEN_KEY_ARRAY )

	cmp	DWORD PTR _nKey$[ebp], 256		; 00000100H
	jl	SHORT $LN20@fnCanonica

; 4799 :                 break; // should not occur

	jmp	SHORT $LN6@fnCanonica
$LN20@fnCanonica:

; 4800 :             apDataField[ nKey ] = lpDataField;

	mov	edx, DWORD PTR _nKey$[ebp]
	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR _apDataField$3[ebp+edx*4], eax

; 4801 :             nKey++;

	mov	ecx, DWORD PTR _nKey$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nKey$[ebp], ecx
$LN19@fnCanonica:

; 4802 :          }
; 4803 :       }

	jmp	$LN5@fnCanonica
$LN6@fnCanonica:

; 4804 : 
; 4805 :       if ( nOrderBy != 0 && nSequencing > 0 && nKey >= nSequencing )

	movsx	edx, WORD PTR _nOrderBy$[ebp]
	test	edx, edx
	je	$LN21@fnCanonica
	cmp	DWORD PTR _nSequencing$[ebp], 0
	jle	$LN21@fnCanonica
	mov	eax, DWORD PTR _nKey$[ebp]
	cmp	eax, DWORD PTR _nSequencing$[ebp]
	jl	$LN21@fnCanonica

; 4806 :       {
; 4807 :          // Since sequencing fields are key fields,
; 4808 :          // we put them to the right order using bubble sort.
; 4809 :          for ( k = 0; k < nSequencing; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN10@fnCanonica
$LN8@fnCanonica:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN10@fnCanonica:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _nSequencing$[ebp]
	jge	$LN9@fnCanonica

; 4810 :          {
; 4811 :             for ( j = k; j < nKey; j++ )

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR _j$[ebp], eax
	jmp	SHORT $LN13@fnCanonica
$LN11@fnCanonica:
	mov	ecx, DWORD PTR _j$[ebp]
	add	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx
$LN13@fnCanonica:
	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nKey$[ebp]
	jge	$LN12@fnCanonica

; 4812 :             {
; 4813 :                lpViewAttrib = zGETPTR( apDataField[ j ]->hViewAttrib );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _apDataField$3[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 4814 : 
; 4815 :                // lpViewAttrib->cSequencing is a 1-based index
; 4816 :                if ( lpViewAttrib->cSequencing == k + 1 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movzx	ecx, BYTE PTR [eax+197]
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jne	SHORT $LN22@fnCanonica

; 4817 :                {
; 4818 :                   if ( j > k )

	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jle	SHORT $LN23@fnCanonica

; 4819 :                   {
; 4820 :                      LPDATAFIELD pTemp = apDataField[ j ];

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _apDataField$3[ebp+ecx*4]
	mov	DWORD PTR _pTemp$1[ebp], edx

; 4821 :                      apDataField[ j ] = apDataField[ k ];

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _apDataField$3[ebp+ecx*4]
	mov	DWORD PTR _apDataField$3[ebp+eax*4], edx

; 4822 :                      apDataField[ k ] = pTemp;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pTemp$1[ebp]
	mov	DWORD PTR _apDataField$3[ebp+eax*4], ecx
$LN23@fnCanonica:

; 4823 :                   }
; 4824 : 
; 4825 :                   break;

	jmp	SHORT $LN12@fnCanonica
$LN22@fnCanonica:

; 4826 :                }
; 4827 :             }

	jmp	$LN11@fnCanonica
$LN12@fnCanonica:

; 4828 : 
; 4829 :             if ( j >= nKey )

	mov	edx, DWORD PTR _j$[ebp]
	cmp	edx, DWORD PTR _nKey$[ebp]
	jl	SHORT $LN24@fnCanonica

; 4830 :             {
; 4831 :                // this is a problem, because we did' not find cSequencing=k
; 4832 :                // should not occur
; 4833 :                TraceLineS( "Invalid Sequencing defined for Entity ",

	mov	eax, DWORD PTR _lpOrderViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG13224
	call	_TraceLineS@8

; 4834 :                            lpOrderViewEntity->szName );
; 4835 :                nSequencing = -1;

	mov	DWORD PTR _nSequencing$[ebp], -1

; 4836 :                break;

	jmp	SHORT $LN9@fnCanonica
$LN24@fnCanonica:

; 4837 :             }
; 4838 :          }

	jmp	$LN8@fnCanonica
$LN9@fnCanonica:

; 4839 : 
; 4840 :          if ( nOrderBy == -1 && nSequencing > 0 )

	movsx	ecx, WORD PTR _nOrderBy$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN21@fnCanonica
	cmp	DWORD PTR _nSequencing$[ebp], 0
	jle	SHORT $LN21@fnCanonica

; 4841 :             nOrderBy = 1; // valid Order By according to LOD sequencing

	mov	edx, 1
	mov	WORD PTR _nOrderBy$[ebp], dx
$LN21@fnCanonica:

; 4842 :       }
; 4843 : 
; 4844 :       if ( nSequencing < 0 || nKey < nSequencing )

	cmp	DWORD PTR _nSequencing$[ebp], 0
	jl	SHORT $LN27@fnCanonica
	mov	eax, DWORD PTR _nKey$[ebp]
	cmp	eax, DWORD PTR _nSequencing$[ebp]
	jge	SHORT $LN26@fnCanonica
$LN27@fnCanonica:

; 4845 :       {
; 4846 :          // the ORDER BY is not the right one according to LOD ordering
; 4847 :          nOrderBy = 0;

	xor	ecx, ecx
	mov	WORD PTR _nOrderBy$[ebp], cx
$LN26@fnCanonica:

; 4848 :       }
; 4849 : 
; 4850 :       for ( k = 0; k < nKey; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN16@fnCanonica
$LN14@fnCanonica:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN16@fnCanonica:
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _nKey$[ebp]
	jge	$LN15@fnCanonica

; 4851 :       {
; 4852 :          if ( bContinue == FALSE )

	movsx	ecx, WORD PTR _bContinue$[ebp]
	test	ecx, ecx
	jne	SHORT $LN28@fnCanonica

; 4853 :          {
; 4854 :             // start ORDER BY clause
; 4855 :             fnSqlAddStringToSuffix( lpSql, " ORDER BY " );

	push	OFFSET $SG13230
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+52], esi

; 4856 :             bContinue = TRUE;

	mov	ecx, 1
	mov	WORD PTR _bContinue$[ebp], cx

; 4857 :          }

	jmp	SHORT $LN29@fnCanonica
$LN28@fnCanonica:

; 4858 :          else
; 4859 :          {
; 4860 :             // add a separator comma
; 4861 :             fnSqlAddStringToSuffix( lpSql, ", " );

	push	OFFSET $SG13231
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+52], esi
$LN29@fnCanonica:

; 4862 :          }
; 4863 : 
; 4864 :          fnSqlAddStringToSuffix( lpSql,

	mov	ecx, DWORD PTR _lpOrderViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOrderDataRecord$2[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnTableName@12
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+52], esi

; 4865 :                                  fnTableName( lpSql,
; 4866 :                                     lpOrderDataRecord->szRecordName,
; 4867 :                                     lpOrderViewEntity ) );
; 4868 :          fnSqlAddStringToSuffix( lpSql, "." );

	push	OFFSET $SG13232
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+52], esi

; 4869 :          fnSqlAddStringToSuffix( lpSql, apDataField[ k ]->szFldName );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _apDataField$3[ebp+edx*4]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+52], esi

; 4870 : 
; 4871 :          lpViewAttrib = zGETPTR( apDataField[ k ]->hViewAttrib );

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _apDataField$3[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 4872 :          if ( lpViewAttrib->bSequencingD )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN30@fnCanonica

; 4873 :             fnSqlAddStringToSuffix( lpSql, " DESC" );

	push	OFFSET $SG13234
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+52], esi
$LN30@fnCanonica:

; 4874 : 
; 4875 :       }

	jmp	$LN14@fnCanonica
$LN15@fnCanonica:

; 4876 : 
; 4877 :       // add the key fields for the joined child entities.
; 4878 :       if ( lpSql->bUseLeftJoin == FALSE )

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	shr	edx, 2
	and	edx, 1
	jne	SHORT $LN31@fnCanonica

; 4879 :          break;

	jmp	SHORT $LN3@fnCanonica
$LN31@fnCanonica:

; 4880 : 
; 4881 :       if ( !SqlFindNextJoinableChild( lpViewEntity, &lpOrderViewEntity,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFirstQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpOrderViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	_SqlFindNextJoinableChild@20
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN2@fnCanonica

; 4882 :                                       lpViewEntity,
; 4883 :                                       lpFirstQualEntity, lpBoundList ) )
; 4884 :       {
; 4885 :          // No more joined entities.  Stop adding attributes.
; 4886 :          break;

	jmp	SHORT $LN3@fnCanonica
$LN2@fnCanonica:

; 4887 :       }
; 4888 : 
; 4889 :    } while ( TRUE ); // We'll break inside the loop.

	mov	eax, 1
	test	eax, eax
	jne	$LN4@fnCanonica
$LN3@fnCanonica:

; 4890 : 
; 4891 :    return( nOrderBy );

	mov	ax, WORD PTR _nOrderBy$[ebp]

; 4892 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnCanonicalOrder ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpChildEntity$ = -28					; size = 4
_lpOrderDataRecord$1 = -24				; size = 4
_lpOrderViewEntity$ = -20				; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpDataField$ = -12					; size = 4
_nOrderBy$ = -8						; size = 2
_chCurrentAttrNbr$ = -2					; size = 1
_chMaxAttrNbr$ = -1					; size = 1
_lpSql$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpFirstQualEntity$ = 16				; size = 4
_lpBoundList$ = 20					; size = 4
_fnGenerateOrderBy PROC

; 4634 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi

; 4635 :    zCHAR        chCurrentAttrNbr;
; 4636 :    zCHAR        chMaxAttrNbr = 0;

	mov	BYTE PTR _chMaxAttrNbr$[ebp], 0

; 4637 :    LPVIEWENTITY lpOrderViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpOrderViewEntity$[ebp], eax

; 4638 :    LPVIEWENTITY lpChildEntity = 0;

	mov	DWORD PTR _lpChildEntity$[ebp], 0

; 4639 :    LPDATAFIELD  lpDataField;
; 4640 :    LPVIEWATTRIB lpViewAttrib;
; 4641 :    zSHORT       nOrderBy = 0;

	xor	ecx, ecx
	mov	WORD PTR _nOrderBy$[ebp], cx
$LN4@fnGenerate:

; 4642 : 
; 4643 :    // We want to list the fields in the "ORDER BY" in 'most-significant'
; 4644 :    // order.  We therefore need to list the fields in the order defined by
; 4645 :    // lpViewAttrib->cSequencing.  In other words, the first field in the
; 4646 :    // "ORDER BY" is the field associated with the attribute with cSequencing
; 4647 :    // 1, the second field has cSequencing 2, etc. chCurrentAttrNbr indicates
; 4648 :    // the cSequencing number we are currently looking for to add to the list.
; 4649 :    //
; 4650 :    // It is possible that an attribute with cSequencing is a work attribute
; 4651 :    // which means it has no DataField.  This is valid and we must be able
; 4652 :    // to handle it.
; 4653 :    do
; 4654 :    {
; 4655 :       // If the entity has attribute ordering create the ORDER BY.
; 4656 :       if ( lpOrderViewEntity->bAttrOrder )

	mov	edx, DWORD PTR _lpOrderViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 18					; 00000012H
	and	eax, 1
	je	$LN14@fnGenerate

; 4657 :       {
; 4658 :          LPDATARECORD lpOrderDataRecord;
; 4659 : 
; 4660 :          chMaxAttrNbr = 0;

	mov	BYTE PTR _chMaxAttrNbr$[ebp], 0

; 4661 : 
; 4662 :          lpOrderDataRecord = zGETPTR( lpOrderViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpOrderViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpOrderDataRecord$1[ebp], eax

; 4663 : 
; 4664 :          // First find the max cSequencing numbers for persistent attributes.
; 4665 :          for ( lpDataField = zGETPTR( lpOrderDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpOrderDataRecord$1[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN7@fnGenerate
$LN5@fnGenerate:

; 4667 :                lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN7@fnGenerate:

; 4666 :                lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	SHORT $LN6@fnGenerate

; 4668 :          {
; 4669 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 4670 :             if ( lpViewAttrib->cSequencing > chMaxAttrNbr )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movzx	ecx, BYTE PTR [eax+197]
	movsx	edx, BYTE PTR _chMaxAttrNbr$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN15@fnGenerate

; 4671 :                chMaxAttrNbr = lpViewAttrib->cSequencing;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+197]
	mov	BYTE PTR _chMaxAttrNbr$[ebp], cl
$LN15@fnGenerate:

; 4672 :          }

	jmp	SHORT $LN5@fnGenerate
$LN6@fnGenerate:

; 4673 : 
; 4674 :          if ( chMaxAttrNbr > 0 )

	movsx	edx, BYTE PTR _chMaxAttrNbr$[ebp]
	test	edx, edx
	jle	$LN14@fnGenerate

; 4675 :          {
; 4676 :             // If we haven't added the ORDER BY, do it now.  We'll
; 4677 :             // set the flag to TRUE a little later.
; 4678 :             if ( nOrderBy == 0 )

	movsx	eax, WORD PTR _nOrderBy$[ebp]
	test	eax, eax
	jne	SHORT $LN17@fnGenerate

; 4679 :                fnSqlAddStringToSuffix( lpSql, " ORDER BY " );

	push	OFFSET $SG13162
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+52], esi
$LN17@fnGenerate:

; 4680 : 
; 4681 :             for ( chCurrentAttrNbr = 1;

	mov	BYTE PTR _chCurrentAttrNbr$[ebp], 1
	jmp	SHORT $LN10@fnGenerate
$LN8@fnGenerate:

; 4683 :                   chCurrentAttrNbr++ )

	mov	al, BYTE PTR _chCurrentAttrNbr$[ebp]
	add	al, 1
	mov	BYTE PTR _chCurrentAttrNbr$[ebp], al
$LN10@fnGenerate:

; 4682 :                   chCurrentAttrNbr <= chMaxAttrNbr;

	movsx	ecx, BYTE PTR _chCurrentAttrNbr$[ebp]
	movsx	edx, BYTE PTR _chMaxAttrNbr$[ebp]
	cmp	ecx, edx
	jg	$LN14@fnGenerate

; 4684 :             {
; 4685 :                // Search through the data fields looking for the current
; 4686 :                // sequencing attribute.
; 4687 :                for ( lpDataField = zGETPTR( lpOrderDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpOrderDataRecord$1[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN13@fnGenerate
$LN11@fnGenerate:

; 4689 :                      lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN13@fnGenerate:

; 4688 :                      lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	SHORT $LN12@fnGenerate

; 4690 :                {
; 4691 :                   lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 4692 :                   if ( lpViewAttrib->cSequencing == chCurrentAttrNbr )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movzx	ecx, BYTE PTR [eax+197]
	movsx	edx, BYTE PTR _chCurrentAttrNbr$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN18@fnGenerate

; 4693 :                      break;

	jmp	SHORT $LN12@fnGenerate
$LN18@fnGenerate:

; 4694 :                }

	jmp	SHORT $LN11@fnGenerate
$LN12@fnGenerate:

; 4695 : 
; 4696 :                if ( lpDataField == 0 )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	jne	SHORT $LN19@fnGenerate

; 4697 :                   continue;

	jmp	SHORT $LN8@fnGenerate
$LN19@fnGenerate:

; 4698 : 
; 4699 :                // If the ORDER BY was just added, then we don't want to
; 4700 :                // add a comma.
; 4701 :                if ( nOrderBy == 0 )

	movsx	eax, WORD PTR _nOrderBy$[ebp]
	test	eax, eax
	jne	SHORT $LN20@fnGenerate

; 4702 :                   nOrderBy = 1;

	mov	ecx, 1
	mov	WORD PTR _nOrderBy$[ebp], cx
	jmp	SHORT $LN21@fnGenerate
$LN20@fnGenerate:

; 4703 :                else
; 4704 :                   fnSqlAddStringToSuffix( lpSql, ", " );

	push	OFFSET $SG13167
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+52], esi
$LN21@fnGenerate:

; 4705 : 
; 4706 :                fnSqlAddStringToSuffix( lpSql,

	mov	ecx, DWORD PTR _lpOrderViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOrderDataRecord$1[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnTableName@12
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+52], esi

; 4707 :                                        fnTableName( lpSql,
; 4708 :                                                     lpOrderDataRecord->szRecordName,
; 4709 :                                                     lpOrderViewEntity ) );
; 4710 :                fnSqlAddStringToSuffix( lpSql, "." );

	push	OFFSET $SG13168
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+52], esi

; 4711 :                fnSqlAddStringToSuffix( lpSql, lpDataField->szFldName );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+52], esi

; 4712 : 
; 4713 :                // If the sequencing is descending, add DESC chars to statement
; 4714 :                if ( lpViewAttrib->bSequencingD )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN22@fnGenerate

; 4715 :                   fnSqlAddStringToSuffix( lpSql, " DESC" );

	push	OFFSET $SG13170
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+52], esi
$LN22@fnGenerate:

; 4716 : 
; 4717 :             } // for chCurrentAttrNbr...

	jmp	$LN8@fnGenerate
$LN14@fnGenerate:

; 4718 : 
; 4719 :          } // if ( chMaxAttrNbr > 0 )...
; 4720 : 
; 4721 :       } // if ( lpOrderViewEntity->bAttrOrder )...
; 4722 : 
; 4723 :       // If we aren't using joins, then we're done (only one entity per
; 4724 :       // SELECT statement), other wise we need to add the order by
; 4725 :       // fields for joine entities.
; 4726 :       if ( lpSql->bUseLeftJoin == FALSE ) // bugfix HH 2002.02.14

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	shr	ecx, 2
	and	ecx, 1
	jne	SHORT $LN23@fnGenerate

; 4727 :          break;

	jmp	SHORT $LN3@fnGenerate
	jmp	SHORT $LN2@fnGenerate
$LN23@fnGenerate:

; 4728 :       else
; 4729 :       {
; 4730 :          if ( !SqlFindNextJoinableChild( lpViewEntity, &lpChildEntity,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpChildEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_SqlFindNextJoinableChild@20
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN25@fnGenerate

; 4731 :                                          lpViewEntity,
; 4732 :                                          lpFirstQualEntity, lpBoundList ) )
; 4733 :          {
; 4734 :             // No more joined entities.  Stop adding attributes.
; 4735 :             break;

	jmp	SHORT $LN3@fnGenerate
$LN25@fnGenerate:

; 4736 :          }
; 4737 : 
; 4738 :          // lpChildEntity is only used to find the next joined child
; 4739 :          // entity.  Copy it's value to lpOrderViewEntity.
; 4740 :          lpOrderViewEntity = lpChildEntity;

	mov	edx, DWORD PTR _lpChildEntity$[ebp]
	mov	DWORD PTR _lpOrderViewEntity$[ebp], edx
$LN2@fnGenerate:

; 4741 :       }
; 4742 : 
; 4743 :    } while ( TRUE ); // We'll break inside the loop.

	mov	eax, 1
	test	eax, eax
	jne	$LN4@fnGenerate
$LN3@fnGenerate:

; 4744 : 
; 4745 :    return( nOrderBy );

	mov	ax, WORD PTR _nOrderBy$[ebp]

; 4746 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnGenerateOrderBy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
$T1 = -864						; size = 4
_lpBoundList$ = -860					; size = 4
_nRC$ = -856						; size = 2
_pchQualOper$2 = -852					; size = 4
_nLth$3 = -848						; size = 2
_bUpper$4 = -842					; size = 1
_bNull$5 = -841						; size = 1
_lpQualAttrib$ = -840					; size = 4
_szCmd$6 = -836						; size = 300
_szStr$ = -536						; size = 500
_szUpper$7 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpQualEntity$ = 12					; size = 4
_lpFirstQualAttrib$ = 16				; size = 4
_lpSql$ = 20						; size = 4
_fnSqlAddQualToWhere PROC

; 3325 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 864				; 00000360H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 3326 :    LPQUALATTRIB lpQualAttrib;
; 3327 :    LPBOUNDLIST  lpBoundList = lpSql->lpBoundList;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+1886]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 3328 :    zCHAR        szStr[ 500 ];
; 3329 :    zSHORT       nRC;
; 3330 : 
; 3331 :    // Qualification stuff are components, so increment count.
; 3332 :    fnSqlIncrementComponentCount( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	ax, WORD PTR [edx+56]
	add	ax, 1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [ecx+56], ax

; 3333 : 
; 3334 :    // Go through each of the QualAttrib's looking for tables that are not
; 3335 :    // already part of the select.
; 3336 :    for ( lpQualAttrib = lpFirstQualAttrib;

	mov	edx, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
	jmp	SHORT $LN4@fnSqlAddQu
$LN2@fnSqlAddQu:

; 3338 :          lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], ecx
$LN4@fnSqlAddQu:

; 3337 :          lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	SHORT $LN3@fnSqlAddQu

; 3339 :    {
; 3340 :       // Add the table to the SELECT statement only if the QualAttrib has
; 3341 :       // a lpViewEntity and a lpViewAttrib.
; 3342 :       if ( lpQualAttrib->lpViewEntity == 0 || lpQualAttrib->lpViewAttrib == 0 )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN11@fnSqlAddQu
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN10@fnSqlAddQu
$LN11@fnSqlAddQu:

; 3343 :          continue;

	jmp	SHORT $LN2@fnSqlAddQu
$LN10@fnSqlAddQu:

; 3344 : 
; 3345 :       // If lpSearchRecord->lpRecordName can't be found in the FromTable
; 3346 :       // then it needs to be added to the SELECT statement.
; 3347 :       if ( fnSqlFindTableName( lpQualAttrib->lpDataRecord->szRecordName,
; 3348 :                                lpQualAttrib->lpViewEntity,
; 3349 :                                lpSql, TRUE ) == -1 )

	push	1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 15					; 0000000fH
	push	edx
	call	_fnSqlFindTableName
	add	esp, 16					; 00000010H
	cwde
	cmp	eax, -1
	jne	SHORT $LN12@fnSqlAddQu

; 3350 :       {
; 3351 :          // Foreign keys are a component, so increment count.
; 3352 :          fnSqlIncrementComponentCount( lpSql );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	dx, WORD PTR [ecx+56]
	add	dx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [eax+56], dx

; 3353 : 
; 3354 :          fnSqlAddTableToSelect( lpView, lpQualAttrib->lpViewEntity,

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlAddTableToSelect
	add	esp, 16					; 00000010H
$LN12@fnSqlAddQu:

; 3355 :                                 FALSE, lpSql );
; 3356 :       }
; 3357 :    } // for ( lpQualAttrib... )...

	jmp	$LN2@fnSqlAddQu
$LN3@fnSqlAddQu:

; 3358 : 
; 3359 :    if ( fnSqlWhereIsNotEmpty( lpSql ) )

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+40]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN13@fnSqlAddQu

; 3360 :       fnSqlAddStringToWhere( lpSql, " AND ( " );

	push	OFFSET $SG12684
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi
	jmp	SHORT $LN14@fnSqlAddQu
$LN13@fnSqlAddQu:

; 3361 :     else
; 3362 :       fnSqlAddStringToWhere( lpSql, "( " );

	push	OFFSET $SG12685
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN14@fnSqlAddQu:

; 3363 : 
; 3364 :    //===
; 3365 :    //===  At this point, all tables that are needed in the select have
; 3366 :    //===  been included in the SELECT.  All that remains to do is to
; 3367 :    //===  add the QualAttrib expressions to the SELECT statement.
; 3368 :    //===
; 3369 : 
; 3370 :    for ( lpQualAttrib = lpFirstQualAttrib;

	mov	eax, DWORD PTR _lpFirstQualAttrib$[ebp]
	mov	DWORD PTR _lpQualAttrib$[ebp], eax
	jmp	SHORT $LN7@fnSqlAddQu
$LN5@fnSqlAddQu:

; 3372 :          lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
$LN7@fnSqlAddQu:

; 3371 :          lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	$LN6@fnSqlAddQu

; 3373 :    {
; 3374 :       if ( lpQualAttrib->lpViewEntity == 0 )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	$LN15@fnSqlAddQu

; 3375 :       {
; 3376 :          // If there is no entity name for QualAttrib then the QualAttrib
; 3377 :          // has just an Oper.  Tack it on to the end of the WHERE clause.
; 3378 : 
; 3379 :          fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG12687
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3380 :          fnSqlAddStringToWhere( lpSql, lpQualAttrib->szOper );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3381 :          fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG12688
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3382 : 
; 3383 :          continue;

	jmp	$LN5@fnSqlAddQu
$LN15@fnSqlAddQu:

; 3384 :       }
; 3385 : 
; 3386 :       // QualAttrib has an entity name, so this is an expression.  Add
; 3387 :       // the expression to the WHERE clause.
; 3388 : 
; 3389 :       // Check to see if szOper matches certain commands.  If it does
; 3390 :       // then the oper preceeds a subselect.
; 3391 :       if ( lpQualAttrib->bExists || lpQualAttrib->bDoesNotExist )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	and	ecx, 1
	jne	SHORT $LN18@fnSqlAddQu
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+64]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN16@fnSqlAddQu
$LN18@fnSqlAddQu:

; 3392 :       {
; 3393 :          nRC = fnSqlBuildSubselect( lpView, lpQualEntity,

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlBuildSubselect
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 3394 :                                     lpQualAttrib, lpSql );
; 3395 :          if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN19@fnSqlAddQu

; 3396 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN45@fnSqlAddQu
$LN19@fnSqlAddQu:

; 3397 :       }

	jmp	$LN17@fnSqlAddQu
$LN16@fnSqlAddQu:

; 3398 :       else
; 3399 :       if ( lpQualAttrib->bIs )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN20@fnSqlAddQu

; 3400 :       {
; 3401 :          nRC = fnSqlBuildIS_Clause( lpQualEntity, lpQualAttrib, lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	push	ecx
	call	_fnSqlBuildIS_Clause
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 3402 :          if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN22@fnSqlAddQu

; 3403 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN45@fnSqlAddQu
$LN22@fnSqlAddQu:

; 3404 :       }

	jmp	$LN17@fnSqlAddQu
$LN20@fnSqlAddQu:

; 3405 :       else
; 3406 :       if ( lpQualAttrib->lpKeyList )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	$LN23@fnSqlAddQu

; 3407 :       {
; 3408 :          zCHAR szCmd[ 300 ];
; 3409 :          fnSqlAddStringToWhere( lpSql,

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 15					; 0000000fH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnTableName@12
	push	eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 3410 :                                 fnTableName( lpSql,
; 3411 :                                     lpQualAttrib->lpDataRecord->szRecordName,
; 3412 :                                     lpQualAttrib->lpViewEntity ) );
; 3413 :          fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12698
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3414 :          fnSqlAddStringToWhere( lpSql, lpQualAttrib->lpDataField->szFldName );

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 3415 : 
; 3416 : 
; 3417 :          zsprintf( szCmd, " IN ( SELECT INTVALUE FROM ZEIDONKEYLIST"

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysGetTaskFromView@4
	push	eax
	push	OFFSET $SG12699
	lea	eax, DWORD PTR _szCmd$6[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3418 :                           " WHERE TASKID = %ld ) ", SysGetTaskFromView( lpView ) );
; 3419 :          fnSqlAddStringToWhere( lpSql, szCmd );

	lea	ecx, DWORD PTR _szCmd$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3420 :       }

	jmp	$LN17@fnSqlAddQu
$LN23@fnSqlAddQu:

; 3421 :       else
; 3422 :       {
; 3423 :       // zSHORT bNotEqual;
; 3424 :       // zSHORT nLoop;
; 3425 :          zBOOL  bNull;
; 3426 :          zBOOL  bUpper;
; 3427 :          zPCHAR pchQualOper = lpQualAttrib->szOper;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _pchQualOper$2[ebp], edx

; 3428 : 
; 3429 :          // Oper is a simple compare.  Add statement to WHERE clause.
; 3430 :          // Check for Qual Operator UPPER
; 3431 :          if ( zstrncmpi( lpQualAttrib->szOper, "UPPER", 5 ) == 0 )

	push	5
	push	OFFSET $SG12702
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN25@fnSqlAddQu

; 3432 :          {
; 3433 :             zCHAR szUpper[ 32 ];
; 3434 : 
; 3435 :             bUpper = TRUE;

	mov	BYTE PTR _bUpper$4[ebp], 1

; 3436 :             fnSqlGetUpperString( szUpper, lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	lea	eax, DWORD PTR _szUpper$7[ebp]
	push	eax
	call	_fnSqlGetUpperString
	add	esp, 8

; 3437 :             fnSqlAddStringToWhere( lpSql, szUpper );

	lea	ecx, DWORD PTR _szUpper$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3438 :             fnSqlAddStringToWhere( lpSql, "( " );

	push	OFFSET $SG12703
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3439 :          }

	jmp	SHORT $LN26@fnSqlAddQu
$LN25@fnSqlAddQu:

; 3440 :          else
; 3441 :          {
; 3442 :             bUpper = FALSE;

	mov	BYTE PTR _bUpper$4[ebp], 0
$LN26@fnSqlAddQu:

; 3443 :          }
; 3444 : 
; 3445 : #if 0
; 3446 :          if ( bUpper )
; 3447 :             pchQualOper += 5; // after "UPPER"
; 3448 : 
; 3449 :          if ( pchQualOper[ 2 ] == 0 &&
; 3450 :               ((pchQualOper[ 0 ] == '<' && pchQualOper[ 1 ] == '>') ||
; 3451 :                (pchQualOper[ 0 ] == '!' && pchQualOper[ 1 ] == '=')) )
; 3452 :          {
; 3453 :             nLoop = 2;
; 3454 :             bNotEqual = TRUE;
; 3455 :             fnSqlAddStringToWhere( lpSql, "( " );
; 3456 :          }
; 3457 :          else
; 3458 :          {
; 3459 :             nLoop = 1;
; 3460 :             bNotEqual = FALSE;
; 3461 :          }
; 3462 : 
; 3463 :          while ( nLoop > 0 )  // loop added to put out IS NULL when oper is <>
; 3464 : #endif
; 3465 :          {
; 3466 :             fnSqlAddStringToWhere( lpSql,

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnTableName@12
	push	eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3467 :                                    fnTableName( lpSql,
; 3468 :                                        lpQualAttrib->lpDataRecord->szRecordName,
; 3469 :                                        lpQualAttrib->lpViewEntity ) );
; 3470 :             fnSqlAddStringToWhere( lpSql, "." );

	push	OFFSET $SG12704
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3471 :             fnSqlAddStringToWhere( lpSql, lpQualAttrib->lpDataField->szFldName );

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3472 :             if ( bUpper )

	movzx	ecx, BYTE PTR _bUpper$4[ebp]
	test	ecx, ecx
	je	SHORT $LN27@fnSqlAddQu

; 3473 :                fnSqlAddStringToWhere( lpSql, " )" );

	push	OFFSET $SG12706
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi
$LN27@fnSqlAddQu:

; 3474 : 
; 3475 :             fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG12707
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 3476 : 
; 3477 :             // Check first to see if the compare value is null.
; 3478 :             bNull = FALSE;

	mov	BYTE PTR _bNull$5[ebp], 0

; 3479 :             if ( lpQualAttrib->szValue )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN28@fnSqlAddQu

; 3480 :             {
; 3481 :                if ( lpQualAttrib->szValue == 0 ) // this could never happen??? dks 2005.11.03

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	jne	SHORT $LN30@fnSqlAddQu

; 3482 :                   bNull = TRUE;

	mov	BYTE PTR _bNull$5[ebp], 1
$LN30@fnSqlAddQu:

; 3483 :             }

	jmp	SHORT $LN29@fnSqlAddQu
$LN28@fnSqlAddQu:

; 3484 :             else
; 3485 :             if ( lpQualAttrib->lpSourceDataField &&

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+56], 0
	je	SHORT $LN29@fnSqlAddQu
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	_SqlAttributeIsNull@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN29@fnSqlAddQu

; 3486 :                  SqlAttributeIsNull( lpQualAttrib->lpSourceView,
; 3487 :                                      lpQualAttrib->lpSourceDataField,
; 3488 :                                      lpBoundList ) )
; 3489 :             {
; 3490 :                bNull = TRUE;

	mov	BYTE PTR _bNull$5[ebp], 1
$LN29@fnSqlAddQu:

; 3491 :             }
; 3492 : #if 0
; 3493 :             if ( bNotEqual && nLoop == 2 )
; 3494 :             {
; 3495 :                fnSqlAddStringToWhere( lpSql, " IS NULL OR " );
; 3496 : 
; 3497 :                nLoop--;
; 3498 :                continue;
; 3499 :             }
; 3500 : #else
; 3501 : 
; 3502 :             if ( bUpper )

	movzx	eax, BYTE PTR _bUpper$4[ebp]
	test	eax, eax
	je	SHORT $LN32@fnSqlAddQu

; 3503 :                pchQualOper += 5; // after "UPPER"

	mov	ecx, DWORD PTR _pchQualOper$2[ebp]
	add	ecx, 5
	mov	DWORD PTR _pchQualOper$2[ebp], ecx
$LN32@fnSqlAddQu:

; 3504 : 
; 3505 : #endif
; 3506 :             // Add operation.  Note that some SQL implementations use different
; 3507 :             // forms of the "Not Equal" operator.
; 3508 :             // In German language + EBCDIC environment there is a problem:
; 3509 :             //  sometimes the '!' is a german Umlaut 'UE', and so the '!'
; 3510 :             //  may be converted to another character.
; 3511 :             //  I consider every character preceding '=', which is not a ' ',
; 3512 :             //  '<' , '>' and not a '=', logically to be a to be a '!'
; 3513 :             // better use <> instead of !=
; 3514 :             if ( pchQualOper[ 1 ] == '=' &&
; 3515 :                  pchQualOper[ 0 ] != ' ' &&
; 3516 :                  pchQualOper[ 0 ] != '=' &&
; 3517 :                  pchQualOper[ 0 ] != '<' &&

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchQualOper$2[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 61					; 0000003dH
	jne	$LN33@fnSqlAddQu
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchQualOper$2[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	$LN33@fnSqlAddQu
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchQualOper$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 61					; 0000003dH
	je	$LN33@fnSqlAddQu
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchQualOper$2[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 60					; 0000003cH
	je	$LN33@fnSqlAddQu
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchQualOper$2[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 62					; 0000003eH
	je	SHORT $LN33@fnSqlAddQu

; 3518 :                  pchQualOper[ 0 ] != '>' )
; 3519 :             {
; 3520 :                // This is SQL standard, which is understood by every DB.
; 3521 :                if ( bNull )

	movzx	eax, BYTE PTR _bNull$5[ebp]
	test	eax, eax
	je	SHORT $LN35@fnSqlAddQu

; 3522 :                   fnSqlAddStringToWhere( lpSql, " IS NOT " );

	push	OFFSET $SG12717
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
	jmp	SHORT $LN36@fnSqlAddQu
$LN35@fnSqlAddQu:

; 3523 :                else
; 3524 :                   fnSqlAddStringToWhere( lpSql, "<>" );

	push	OFFSET $SG12718
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
$LN36@fnSqlAddQu:

; 3525 :             }

	jmp	SHORT $LN34@fnSqlAddQu
$LN33@fnSqlAddQu:

; 3526 :             else
; 3527 :             {
; 3528 :                if ( bNull )

	movzx	edx, BYTE PTR _bNull$5[ebp]
	test	edx, edx
	je	SHORT $LN37@fnSqlAddQu

; 3529 :                   fnSqlAddStringToWhere( lpSql, " IS " );

	push	OFFSET $SG12721
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
	jmp	SHORT $LN34@fnSqlAddQu
$LN37@fnSqlAddQu:

; 3530 :                else
; 3531 :                   fnSqlAddStringToWhere( lpSql, pchQualOper );

	mov	edx, DWORD PTR _pchQualOper$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
$LN34@fnSqlAddQu:

; 3532 :             }
; 3533 : 
; 3534 :             if ( bNull )

	movzx	edx, BYTE PTR _bNull$5[ebp]
	test	edx, edx
	je	SHORT $LN39@fnSqlAddQu

; 3535 :             {
; 3536 :                fnSqlGetNullString( szStr, lpQualAttrib->lpDataField, lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	call	_fnSqlGetNullString
	add	esp, 12					; 0000000cH

; 3537 :                fnSqlAddStringToWhere( lpSql, szStr );

	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3538 :             }

	jmp	$LN17@fnSqlAddQu
$LN39@fnSqlAddQu:

; 3539 :             else
; 3540 :             if ( lpQualAttrib->szValue )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	$LN41@fnSqlAddQu

; 3541 :             {
; 3542 :                fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG12726
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3543 :                fnSqlConvertStringToSqlString( lpQualAttrib->lpDataField,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_fnSqlConvertStringToSqlString
	add	esp, 16					; 00000010H

; 3544 :                                               lpQualAttrib->szValue, szStr,
; 3545 :                                               lpBoundList );
; 3546 : 
; 3547 :                // If the oper is LIKE then we don't want to pad with spaces for
; 3548 :                // fixed char types.
; 3549 :                if ( lpQualAttrib->lpDataField->cFldType == zTYPE_FIXEDCHAR &&

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 70					; 00000046H
	jne	$LN43@fnSqlAddQu
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN43@fnSqlAddQu

; 3550 :                     lpQualAttrib->bLike )
; 3551 :                {
; 3552 :                   zSHORT nLth = zstrlen( szStr ) - 1;

	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	sub	eax, 1
	mov	WORD PTR _nLth$3[ebp], ax
$LN8@fnSqlAddQu:

; 3553 : 
; 3554 :                   while ( nLth >= 0 && szStr[ nLth ] == ' ' )

	movsx	ecx, WORD PTR _nLth$3[ebp]
	test	ecx, ecx
	jl	SHORT $LN43@fnSqlAddQu
	movsx	edx, WORD PTR _nLth$3[ebp]
	movsx	eax, BYTE PTR _szStr$[ebp+edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN43@fnSqlAddQu

; 3555 :                      szStr[ nLth-- ] = 0;

	movsx	ecx, WORD PTR _nLth$3[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	mov	dx, WORD PTR _nLth$3[ebp]
	sub	dx, 1
	mov	WORD PTR _nLth$3[ebp], dx
	cmp	DWORD PTR $T1[ebp], 500			; 000001f4H
	jae	SHORT $LN46@fnSqlAddQu
	jmp	SHORT $LN47@fnSqlAddQu
$LN46@fnSqlAddQu:
	call	___report_rangecheckfailure
$LN47@fnSqlAddQu:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szStr$[ebp+eax], 0
	jmp	SHORT $LN8@fnSqlAddQu
$LN43@fnSqlAddQu:

; 3556 :                }
; 3557 : 
; 3558 :                fnSqlAddStringToWhere( lpSql, szStr );

	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3559 :             }

	jmp	SHORT $LN17@fnSqlAddQu
$LN41@fnSqlAddQu:

; 3560 :             else
; 3561 :             if ( lpQualAttrib->lpSourceDataField )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+56], 0
	je	SHORT $LN17@fnSqlAddQu

; 3562 :             {
; 3563 :                fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG12729
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 3564 :                fnSqlGetAttributeValue( lpQualAttrib->lpSourceView,

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
$LN17@fnSqlAddQu:

; 3565 :                                        lpQualAttrib->lpSourceDataField, lpSql );
; 3566 :             }
; 3567 : #if 0
; 3568 :             if ( bNotEqual && nLoop == 1 )
; 3569 :             {
; 3570 :                fnSqlAddStringToWhere( lpSql, " ) " );
; 3571 :             }
; 3572 : 
; 3573 :             nLoop--;
; 3574 : #endif
; 3575 :          }
; 3576 :       }
; 3577 : 
; 3578 :    } // for ( lpQualAttrib... )...

	jmp	$LN5@fnSqlAddQu
$LN6@fnSqlAddQu:

; 3579 : 
; 3580 :    fnSqlAddStringToWhere( lpSql, " )" );

	push	OFFSET $SG12730
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 3581 : 
; 3582 :    return( 0 );

	xor	eax, eax
$LN45@fnSqlAddQu:

; 3583 : 
; 3584 : }  /* fnSqlAddQualToWhere */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlAddQualToWhere ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpQualEntity$ = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_lpFirstQualEntity$ = 12				; size = 4
_SqlCheckOpenSQL@8 PROC

; 3594 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3595 :    LPQUALENTITY lpQualEntity;
; 3596 : 
; 3597 :    // check, whether we find a qual entity with open SQL
; 3598 :    lpQualEntity = lpFirstQualEntity;

	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	DWORD PTR _lpQualEntity$[ebp], eax
$LN2@SqlCheckOp:

; 3599 :    while ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN3@SqlCheckOp

; 3600 :    {
; 3601 :       if ( lpQualEntity->lpViewEntity == lpViewEntity &&
; 3602 :            lpQualEntity->pszOpenSQL && lpQualEntity->pszOpenSQL[ 0 ] )

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN4@SqlCheckOp
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN4@SqlCheckOp
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	movsx	edx, BYTE PTR [ecx+edx]
	test	edx, edx
	je	SHORT $LN4@SqlCheckOp

; 3603 :       {
; 3604 :          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@SqlCheckOp
$LN4@SqlCheckOp:

; 3605 :       }
; 3606 : 
; 3607 :       lpQualEntity = lpQualEntity->lpNextQualEntity;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpQualEntity$[ebp], ecx

; 3608 :    }

	jmp	SHORT $LN2@SqlCheckOp
$LN3@SqlCheckOp:

; 3609 : 
; 3610 :    return( 0 );

	xor	eax, eax
$LN1@SqlCheckOp:

; 3611 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SqlCheckOpenSQL@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -24					; size = 4
_lpParent$ = -20					; size = 4
_lpQualAttrib$1 = -16					; size = 4
_lpQualEntity$ = -12					; size = 4
_lpTemp$ = -8						; size = 4
_bQualOnChild$ = -1					; size = 1
_lpViewEntity$ = 8					; size = 4
_lpLoadEntity$ = 12					; size = 4
_lpFirstQualEntity$ = 16				; size = 4
_SqlEntityValidForJoin@12 PROC

; 3619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3620 :    LPDATARECORD lpDataRecord;
; 3621 :    LPQUALENTITY lpQualEntity;
; 3622 :    LPVIEWENTITY lpParent;
; 3623 :    LPVIEWENTITY lpTemp;
; 3624 :    zBOOL        bQualOnChild = FALSE;

	mov	BYTE PTR _bQualOnChild$[ebp], 0

; 3625 : 
; 3626 :    // Root entities aren't joinable--it has no parent.
; 3627 :    if ( lpViewEntity->hParent == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN14@SqlEntityV

; 3628 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN14@SqlEntityV:

; 3629 : 
; 3630 :    // Only entities with physical information can be joined.
; 3631 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3632 :    if ( lpDataRecord == 0 )

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	jne	SHORT $LN15@SqlEntityV

; 3633 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN15@SqlEntityV:

; 3634 : 
; 3635 :    // Only entities flagged with 'Y' can be joined.
; 3636 :    if ( lpDataRecord->cJoin != 'Y' )

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+275]
	cmp	ecx, 89					; 00000059H
	je	SHORT $LN16@SqlEntityV

; 3637 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN16@SqlEntityV:

; 3638 : 
; 3639 :    // If we can load the entities attrs from the parent then it's faster than
; 3640 :    // doing a join so...
; 3641 :    if ( lpViewEntity->bAutoLoadFromParent )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 30					; 0000001eH
	and	eax, 1
	je	SHORT $LN17@SqlEntityV

; 3642 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN17@SqlEntityV:

; 3643 : 
; 3644 :    // If entity is part of a duplicate relationship then we'll copy the EI
; 3645 :    // from a different part of the OI so don't load it.
; 3646 :    if ( lpViewEntity->bDupRelPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN18@SqlEntityV

; 3647 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN18@SqlEntityV:

; 3648 : 
; 3649 :    // Don't try joining recursive entities.
; 3650 :    if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN19@SqlEntityV

; 3651 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN19@SqlEntityV:

; 3652 : 
; 3653 :    // This probably isn't necessary but we'll check for it anyway ...
; 3654 :    // Don't join derived entities.
; 3655 :    if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	je	SHORT $LN20@SqlEntityV

; 3656 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN20@SqlEntityV:

; 3657 : 
; 3658 :    // we cannot JOIN, if the parent has Open SQL
; 3659 :    lpParent = (LPVIEWENTITY) zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$[ebp], eax

; 3660 :    if ( lpParent && SqlCheckOpenSQL( lpParent, lpFirstQualEntity ) )

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	SHORT $LN21@SqlEntityV
	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpParent$[ebp]
	push	ecx
	call	_SqlCheckOpenSQL@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN21@SqlEntityV

; 3661 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN21@SqlEntityV:

; 3662 : 
; 3663 :    // we cannot JOIN, if the parent has a DB Oper (MAX, SUM  ... )
; 3664 :    if ( lpParent && lpParent->bHasDB_Oper )

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	SHORT $LN22@SqlEntityV
	mov	eax, DWORD PTR _lpParent$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	and	ecx, 1
	je	SHORT $LN22@SqlEntityV

; 3665 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN22@SqlEntityV:

; 3666 : 
; 3667 :    // Go through the qual entity list.  The entity is not valid for a join if:
; 3668 :    // o  Any of the QualEntities have the bOptionsNoJoins set.
; 3669 :    // o  The current entity has qualification.
; 3670 :    // o  The current is x:many related to the entity beeing loaded AND
; 3671 :    //    there is a qualification on the current entity or on one of
; 3672 :    //    its childs.
; 3673 :    for ( lpQualEntity = lpFirstQualEntity;

	mov	edx, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	DWORD PTR _lpQualEntity$[ebp], edx
	jmp	SHORT $LN4@SqlEntityV
$LN2@SqlEntityV:

; 3675 :          lpQualEntity = lpQualEntity->lpNextQualEntity )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpQualEntity$[ebp], ecx
$LN4@SqlEntityV:

; 3674 :          lpQualEntity;

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	$LN3@SqlEntityV

; 3676 :    {
; 3677 :       if ( lpQualEntity->bOptionsNoJoins )

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN23@SqlEntityV

; 3678 :          return( FALSE ); // User specified NOJOINS in the qual object.

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN23@SqlEntityV:

; 3679 : 
; 3680 :       if ( lpQualEntity->lpViewEntity == lpViewEntity )

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN24@SqlEntityV

; 3681 :          return( FALSE ); // This entity has a RESTRICTING clause...can't join it.

	xor	al, al
	jmp	$LN1@SqlEntityV
$LN24@SqlEntityV:

; 3682 : 
; 3683 : 
; 3684 :       if ( lpQualEntity->lpViewEntity == lpLoadEntity )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _lpLoadEntity$[ebp]
	jne	SHORT $LN25@SqlEntityV

; 3685 :       {
; 3686 :          LPQUALATTRIB lpQualAttrib;
; 3687 : 
; 3688 :          // We found the qualification for the entity we are loading.  Check
; 3689 :          // to see if any of the QualAttribs reference lpViewEntity or
; 3690 :          // a child of lpViewEntity.
; 3691 :          // If it does, then we can't join lpViewEntity if it is x:many
; 3692 :          // connected to lpLoadEntity. That is checked later.
; 3693 :          for ( lpQualAttrib = lpQualEntity->lpFirstQualAttrib;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpQualAttrib$1[ebp], eax
	jmp	SHORT $LN7@SqlEntityV
$LN5@SqlEntityV:

; 3695 :                lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _lpQualAttrib$1[ebp], edx
$LN7@SqlEntityV:

; 3694 :                lpQualAttrib && bQualOnChild == FALSE;

	cmp	DWORD PTR _lpQualAttrib$1[ebp], 0
	je	SHORT $LN25@SqlEntityV
	movzx	eax, BYTE PTR _bQualOnChild$[ebp]
	test	eax, eax
	jne	SHORT $LN25@SqlEntityV

; 3696 :          {
; 3697 :             // If the lpQualAttrib doesn't have a lpViewEntity then it's just
; 3698 :             // an oper (e.g. AND, OR) so we can ignore it.
; 3699 :             if ( lpQualAttrib->lpViewEntity == 0 )

	mov	ecx, DWORD PTR _lpQualAttrib$1[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	SHORT $LN26@SqlEntityV

; 3700 :                continue;

	jmp	SHORT $LN5@SqlEntityV
$LN26@SqlEntityV:

; 3701 : 
; 3702 :             for ( lpTemp = lpQualAttrib->lpViewEntity;

	mov	edx, DWORD PTR _lpQualAttrib$1[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpTemp$[ebp], eax
	jmp	SHORT $LN10@SqlEntityV
$LN8@SqlEntityV:

; 3704 :                   lpTemp = zGETPTR( lpTemp->hParent ) )

	mov	ecx, DWORD PTR _lpTemp$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTemp$[ebp], eax
$LN10@SqlEntityV:

; 3703 :                   lpTemp;

	cmp	DWORD PTR _lpTemp$[ebp], 0
	je	SHORT $LN9@SqlEntityV

; 3705 :             {
; 3706 :                // If lpTemp = lpLoadEntity, then lpQualAttrib has nothing
; 3707 :                //   to do with lpViewEntity.
; 3708 :                if ( lpTemp == lpLoadEntity )

	mov	eax, DWORD PTR _lpTemp$[ebp]
	cmp	eax, DWORD PTR _lpLoadEntity$[ebp]
	jne	SHORT $LN27@SqlEntityV

; 3709 :                   break;

	jmp	SHORT $LN9@SqlEntityV
$LN27@SqlEntityV:

; 3710 : 
; 3711 :                // If lpTemp = lpViewEntity, then lpQualAttrib references
; 3712 :                //  lpViewEntity or a child of lpViewEntity.
; 3713 :                if ( lpTemp == lpViewEntity )

	mov	ecx, DWORD PTR _lpTemp$[ebp]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN28@SqlEntityV

; 3714 :                {
; 3715 :                   bQualOnChild = TRUE;

	mov	BYTE PTR _bQualOnChild$[ebp], 1

; 3716 :                   break;

	jmp	SHORT $LN9@SqlEntityV
$LN28@SqlEntityV:

; 3717 :                }
; 3718 :             } // for lpTemp

	jmp	SHORT $LN8@SqlEntityV
$LN9@SqlEntityV:

; 3719 :          } // for lpQualAttrib

	jmp	SHORT $LN5@SqlEntityV
$LN25@SqlEntityV:

; 3720 :       } // if ( lpQualEntity->lpViewEntity == lpLoadEntity )
; 3721 :    }  // for lpQualEntity

	jmp	$LN2@SqlEntityV
$LN3@SqlEntityV:

; 3722 : 
; 3723 :    // If there is no qualification on child, we can join.
; 3724 :    // Otherwise:
; 3725 :    // If the entity to be checked (lpViewEntity) is connected to the
; 3726 :    //  entity beeing loaded (lpLoadEntity) via x:many relationships,
; 3727 :    //  then it is NOT VALID to do the join (1.Example).
; 3728 : 
; 3729 :    //  1.Example:
; 3730 :    //  A -0:m- B -1:1- C
; 3731 :    //  ACTIVATE ABC WHERE C.attr = 123
; 3732 :    //  lpLoadEntity=A, lpViewEntity=B
; 3733 :    //  We cannot join B, otherwise:
; 3734 :    //  SELECT A.attrs, B.attrs FROM
; 3735 :    //     ( A LEFT JOIN B ON ... ) LEFT JOIN C ON ... WHERE C.qual = ...
; 3736 :    //  If the result set for a particular A might be:
; 3737 :    //  A1 B1 C1
; 3738 :    //  Now, if there is a B2 below A1, this is NOT read, ERROR
; 3739 : 
; 3740 :    //  2.Example:
; 3741 :    //  A -1:1- B -0:m- C
; 3742 :    //  ACTIVATE ABC WHERE C.attr = 123
; 3743 :    //  We CAN join B ( not C ).
; 3744 :    //  SELECT A.attrs, B.attrs FROM
; 3745 :    //     ( A LEFT JOIN B ON ... ) LEFT JOIN C ON ... WHERE C.qual = ...
; 3746 :    //  If the result set for a particular A has multiple C's:
; 3747 :    //  A1 B1 C1
; 3748 :    //  A1 B1 Cm
; 3749 :    //  No problem, there is only one B, and it is read.
; 3750 : 
; 3751 :    if ( bQualOnChild == FALSE )

	movzx	edx, BYTE PTR _bQualOnChild$[ebp]
	test	edx, edx
	jne	SHORT $LN29@SqlEntityV

; 3752 :       return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@SqlEntityV
$LN29@SqlEntityV:

; 3753 : 
; 3754 :    for ( lpTemp = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpTemp$[ebp], eax
	jmp	SHORT $LN13@SqlEntityV
$LN11@SqlEntityV:

; 3756 :          lpTemp = zGETPTR( lpTemp->hParent ) )

	mov	ecx, DWORD PTR _lpTemp$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTemp$[ebp], eax
$LN13@SqlEntityV:

; 3755 :          lpTemp;

	cmp	DWORD PTR _lpTemp$[ebp], 0
	je	SHORT $LN12@SqlEntityV

; 3757 :    {
; 3758 :       // If reach lpLoadEntity, we're done
; 3759 :       if ( lpTemp == lpLoadEntity )

	mov	eax, DWORD PTR _lpTemp$[ebp]
	cmp	eax, DWORD PTR _lpLoadEntity$[ebp]
	jne	SHORT $LN30@SqlEntityV

; 3760 :          break;

	jmp	SHORT $LN12@SqlEntityV
$LN30@SqlEntityV:

; 3761 : 
; 3762 :       // If lpTemp = lpViewEntity, then lpQualAttrib references
; 3763 :       //  lpViewEntity or a child of lpViewEntity.
; 3764 :       if ( lpTemp->uCardMax > 1 )

	mov	ecx, DWORD PTR _lpTemp$[ebp]
	movzx	edx, WORD PTR [ecx+221]
	cmp	edx, 1
	jle	SHORT $LN31@SqlEntityV

; 3765 :       {
; 3766 :          // Qual on Child AND x:many
; 3767 :          //  this is the JOIN KILLER.
; 3768 :          return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@SqlEntityV
$LN31@SqlEntityV:

; 3769 :       }
; 3770 :    } // for lpTemp

	jmp	SHORT $LN11@SqlEntityV
$LN12@SqlEntityV:

; 3771 : 
; 3772 :    // If we get here then everything must check out so return TRUE.
; 3773 :    return( TRUE );

	mov	al, 1
$LN1@SqlEntityV:

; 3774 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SqlEntityValidForJoin@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_nLevel$1 = -4						; size = 2
_lpParent$ = 8						; size = 4
_plpChildEntity$ = 12					; size = 4
_lpLoadEntity$ = 16					; size = 4
_lpFirstQualEntity$ = 20				; size = 4
_lpBoundList$ = 24					; size = 4
_SqlFindNextJoinableChild@20 PROC

; 3786 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3787 :    if ( *plpChildEntity == 0 )

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@SqlFindNex

; 3788 :       *plpChildEntity = lpParent;

	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	DWORD PTR [ecx], edx
$LN8@SqlFindNex:

; 3789 : 
; 3790 :    // DBHandler has said there might be more children so look for them.
; 3791 :    *plpChildEntity = zGETPTR( (*plpChildEntity)->hNextHier );

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@SqlFindNex:

; 3792 :    while ( *plpChildEntity )

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN3@SqlFindNex

; 3793 :    {
; 3794 :       if ( *plpChildEntity == 0 ||

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@SqlFindNex
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpParent$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $LN9@SqlFindNex
$LN10@SqlFindNex:

; 3795 :            (*plpChildEntity)->nLevel <= lpParent->nLevel )
; 3796 :       {
; 3797 :          return( FALSE );

	xor	eax, eax
	jmp	$LN1@SqlFindNex
$LN9@SqlFindNex:

; 3798 :       }
; 3799 : 
; 3800 :       // If the relationship between the child and parent is not joinable
; 3801 :       // skip it.
; 3802 :       if ( !SqlEntityValidForJoin( *plpChildEntity, lpLoadEntity,

	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SqlEntityValidForJoin@12
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN11@SqlFindNex

; 3803 :                                    lpFirstQualEntity ) )
; 3804 :       {
; 3805 :          zSHORT nLevel;
; 3806 : 
; 3807 :          // This entity is not joinable so skip it.  We also want to skip all
; 3808 :          // it's children.
; 3809 :          if ( (*plpChildEntity)->hNextSibling )

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+247], 0
	je	SHORT $LN12@SqlFindNex

; 3810 :          {
; 3811 :             (*plpChildEntity) = zGETPTR( (*plpChildEntity)->hNextSibling );

	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+247]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [ecx], eax

; 3812 :             continue;

	jmp	SHORT $LN2@SqlFindNex
$LN12@SqlFindNex:

; 3813 :          }
; 3814 : 
; 3815 :          // (*plpChildEntity) has no siblings.  Find the next entity by trolling
; 3816 :          // through the children hierachically.
; 3817 :          nLevel = (*plpChildEntity)->nLevel;

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cx, WORD PTR [eax+215]
	mov	WORD PTR _nLevel$1[ebp], cx
$LN4@SqlFindNex:

; 3818 :          while ( (*plpChildEntity) && (*plpChildEntity)->nLevel >= nLevel )

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN5@SqlFindNex
	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, WORD PTR [ecx+215]
	movsx	eax, WORD PTR _nLevel$1[ebp]
	cmp	edx, eax
	jl	SHORT $LN5@SqlFindNex
$LN6@SqlFindNex:

; 3819 :          {
; 3820 :             while ( (*plpChildEntity)->hNextSibling )

	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+247], 0
	je	SHORT $LN7@SqlFindNex

; 3821 :                (*plpChildEntity) = zGETPTR( (*plpChildEntity)->hNextSibling );

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+247]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN6@SqlFindNex
$LN7@SqlFindNex:

; 3822 : 
; 3823 :             (*plpChildEntity) = zGETPTR( (*plpChildEntity)->hNextHier );

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [edx], eax

; 3824 :          }

	jmp	SHORT $LN4@SqlFindNex
$LN5@SqlFindNex:

; 3825 : 
; 3826 :          continue;

	jmp	$LN2@SqlFindNex
$LN11@SqlFindNex:

; 3827 :       }
; 3828 : 
; 3829 :       // If we get here then we've found what we're looking for.
; 3830 :       return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@SqlFindNex

; 3831 :    }

	jmp	$LN2@SqlFindNex
$LN3@SqlFindNex:

; 3832 : 
; 3833 :    // If we get here then *plpChildEntity must be 0 so return FALSE.
; 3834 :    return( FALSE );

	xor	eax, eax
$LN1@SqlFindNex:

; 3835 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlFindNextJoinableChild@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_uLth$1 = -68						; size = 4
_uLth$2 = -64						; size = 4
_szStr$3 = -60						; size = 4
_szStr$4 = -56						; size = 4
tv92 = -52						; size = 4
_lpViewEntity$ = -48					; size = 4
_chType$5 = -42						; size = 1
_chType$6 = -41						; size = 1
_lpViewAttrib$ = -40					; size = 4
_nRC$ = -36						; size = 2
_sz$7 = -32						; size = 25
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpDataField$ = 12					; size = 4
_lpBoundList$ = 16					; size = 4
_SqlAttributeIsNull@12 PROC

; 1242 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1243 :    zSHORT       nRC;
; 1244 :    LPVIEWENTITY lpViewEntity;
; 1245 :    LPVIEWATTRIB lpViewAttrib;
; 1246 : 
; 1247 :    if ( EXEC_CALLBACK( zSQLCALLBACK_CHECKNULL, lpView, lpDataField, 0, 0 ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN4@SqlAttribu
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN4@SqlAttribu
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	and	edx, 1
	je	SHORT $LN4@SqlAttribu
	push	0
	push	0
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	call	ecx
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN4@SqlAttribu

; 1248 :    {
; 1249 :       // Callback routine returns following:
; 1250 :       //    1 - Attribute is null.
; 1251 :       //    0 - Callback didn't determine -- use default processing.
; 1252 :       //   -1 - Attribute is not null.
; 1253 :       if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $LN5@SqlAttribu

; 1254 :          return( TRUE );

	mov	eax, 1
	jmp	$LN1@SqlAttribu
	jmp	SHORT $LN4@SqlAttribu
$LN5@SqlAttribu:

; 1255 :       else
; 1256 :       if ( nRC == -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN4@SqlAttribu

; 1257 :          return( FALSE );

	xor	eax, eax
	jmp	$LN1@SqlAttribu
$LN4@SqlAttribu:

; 1258 :    }
; 1259 : 
; 1260 :    lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1261 :    lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1262 : 
; 1263 :    switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv92[ebp], cl
	cmp	BYTE PTR tv92[ebp], 66			; 00000042H
	je	SHORT $LN13@SqlAttribu
	cmp	BYTE PTR tv92[ebp], 83			; 00000053H
	je	SHORT $LN8@SqlAttribu
	jmp	$LN17@SqlAttribu
$LN8@SqlAttribu:

; 1264 :    {
; 1265 :       case zTYPE_STRING:
; 1266 :       {
; 1267 :          zULONG  uLth;
; 1268 :          zPCHAR  szStr;
; 1269 :          zCHAR   chType;
; 1270 : 
; 1271 :          // In the special case where the string is stored as a fixed-length
; 1272 :          // string the attribute is never considered null.
; 1273 :          if ( lpDataField->cFldType == zTYPE_FIXEDCHAR )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN9@SqlAttribu

; 1274 :             return( FALSE );

	xor	eax, eax
	jmp	$LN1@SqlAttribu
$LN9@SqlAttribu:

; 1275 : 
; 1276 :          GetValueFromRecord( lpView, lpViewEntity, lpViewAttrib, &szStr,

	lea	ecx, DWORD PTR _uLth$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$6[ebp]
	push	edx
	lea	eax, DWORD PTR _szStr$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_GetValueFromRecord@24

; 1277 :                              &chType, &uLth );
; 1278 :          if ( szStr == 0 || szStr[ 0 ] == 0 )

	cmp	DWORD PTR _szStr$4[ebp], 0
	je	SHORT $LN12@SqlAttribu
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _szStr$4[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN10@SqlAttribu
$LN12@SqlAttribu:

; 1279 :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@SqlAttribu
	jmp	SHORT $LN13@SqlAttribu
$LN10@SqlAttribu:

; 1280 :          else
; 1281 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@SqlAttribu
$LN13@SqlAttribu:

; 1282 :       }
; 1283 : 
; 1284 :       case zTYPE_BLOB:
; 1285 :       {
; 1286 :          zULONG  uLth;
; 1287 :          zPCHAR  szStr;
; 1288 :          zCHAR   chType;
; 1289 :          GetValueFromRecord( lpView, lpViewEntity, lpViewAttrib, &szStr,

	lea	edx, DWORD PTR _uLth$2[ebp]
	push	edx
	lea	eax, DWORD PTR _chType$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _szStr$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetValueFromRecord@24

; 1290 :                              &chType, &uLth );
; 1291 :          if ( szStr == 0 || uLth == 0 )

	cmp	DWORD PTR _szStr$3[ebp], 0
	je	SHORT $LN16@SqlAttribu
	cmp	DWORD PTR _uLth$2[ebp], 0
	jne	SHORT $LN14@SqlAttribu
$LN16@SqlAttribu:

; 1292 :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@SqlAttribu
	jmp	SHORT $LN17@SqlAttribu
$LN14@SqlAttribu:

; 1293 :          else
; 1294 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@SqlAttribu
$LN17@SqlAttribu:

; 1295 :       }
; 1296 : 
; 1297 :       default:
; 1298 :       {
; 1299 :          zCHAR sz[ 25 ];
; 1300 : 
; 1301 :          // Get string from record with a max length of 25. We're just
; 1302 :          // checking to see if the attribute is null, so we don't care
; 1303 :          // about the return string.
; 1304 :          if ( GetStringFromRecord( lpView, lpViewEntity, lpViewAttrib,
; 1305 :                                    sz, 20 ) == -1 )

	push	20					; 00000014H
	lea	edx, DWORD PTR _sz$7[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_GetStringFromRecord@20
	cwde
	cmp	eax, -1
	jne	SHORT $LN18@SqlAttribu

; 1306 :          {
; 1307 :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@SqlAttribu

; 1308 :          }

	jmp	SHORT $LN1@SqlAttribu
$LN18@SqlAttribu:

; 1309 :          else
; 1310 :             return( FALSE );

	xor	eax, eax
$LN1@SqlAttribu:

; 1311 :       }
; 1312 :    }
; 1313 : 
; 1314 : } // SqlAttributeIsNull

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SqlAttributeIsNull@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpQualEntity$ = 8					; size = 4
_bDisplayAll$ = 12					; size = 1
_SqlDisplayQualEntity@8 PROC

; 4985 : {

	push	ebp
	mov	ebp, esp

; 4986 :    TraceLineS( "************************************", "" );

	push	OFFSET $SG13284
	push	OFFSET $SG13285
	call	_TraceLineS@8

; 4987 :    TraceLineS( "Display QualEntity structure", "" );

	push	OFFSET $SG13286
	push	OFFSET $SG13287
	call	_TraceLineS@8

; 4988 :    for ( ;

	jmp	SHORT $LN4@SqlDisplay
$LN2@SqlDisplay:

; 4990 :          lpQualEntity = lpQualEntity->lpNextQualEntity )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpQualEntity$[ebp], ecx
$LN4@SqlDisplay:

; 4989 :          lpQualEntity;

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	$LN3@SqlDisplay

; 4991 :    {
; 4992 :       TraceLineS( "", "" );

	push	OFFSET $SG13288
	push	OFFSET $SG13289
	call	_TraceLineS@8

; 4993 :       TraceLineS( "--- QualEntity ---", "" );

	push	OFFSET $SG13290
	push	OFFSET $SG13291
	call	_TraceLineS@8

; 4994 :       TraceLineS( "  Entity Name:", lpQualEntity->lpViewEntity->szName );

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG13292
	call	_TraceLineS@8

; 4995 : 
; 4996 :       if ( lpQualEntity->bQualUsesChildEntity )

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 1
	je	SHORT $LN5@SqlDisplay

; 4997 :          TraceLineS( "  bQualUsesChildEntity: TRUE", "" );

	push	OFFSET $SG13295
	push	OFFSET $SG13296
	call	_TraceLineS@8
	jmp	SHORT $LN6@SqlDisplay
$LN5@SqlDisplay:

; 4998 :       else
; 4999 :          TraceLineS( "  bQualUsesChildEntity: FALSE", "" );

	push	OFFSET $SG13297
	push	OFFSET $SG13298
	call	_TraceLineS@8
$LN6@SqlDisplay:

; 5000 : 
; 5001 :       if ( lpQualEntity->bContainsSubselect )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN7@SqlDisplay

; 5002 :          TraceLineS( "  bContainsSubselect: TRUE", "" );

	push	OFFSET $SG13301
	push	OFFSET $SG13302
	call	_TraceLineS@8
	jmp	SHORT $LN8@SqlDisplay
$LN7@SqlDisplay:

; 5003 :       else
; 5004 :          TraceLineS( "  bContainsSubselect: FALSE", "" );

	push	OFFSET $SG13303
	push	OFFSET $SG13304
	call	_TraceLineS@8
$LN8@SqlDisplay:

; 5005 : 
; 5006 :       fnSqlDisplayQualAttrib( lpQualEntity->lpFirstQualAttrib, 0 );

	push	0
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_fnSqlDisplayQualAttrib
	add	esp, 8

; 5007 : 
; 5008 :       if ( bDisplayAll == FALSE )

	movzx	ecx, BYTE PTR _bDisplayAll$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@SqlDisplay

; 5009 :          break;

	jmp	SHORT $LN3@SqlDisplay
$LN9@SqlDisplay:

; 5010 :    }

	jmp	$LN2@SqlDisplay
$LN3@SqlDisplay:

; 5011 : 
; 5012 :    TraceLineS( "************************************", "" );

	push	OFFSET $SG13306
	push	OFFSET $SG13307
	call	_TraceLineS@8

; 5013 : 
; 5014 : }  /* SqlDisplayQualEntity */

	pop	ebp
	ret	8
_SqlDisplayQualEntity@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_pchSqlCmd$ = 8						; size = 4
_pchErrorChar$ = 12					; size = 4
_SqlDisplayCommand@8 PROC

; 7215 : {

	push	ebp
	mov	ebp, esp

; 7216 :    SqlDisplayCommandEx( pchSqlCmd, pchErrorChar, (zPVOID) fnTraceSql, 0 );

	push	0
	push	OFFSET _fnTraceSql@8
	mov	eax, DWORD PTR _pchErrorChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	push	ecx
	call	_SqlDisplayCommandEx@16

; 7217 : }

	pop	ebp
	ret	8
_SqlDisplayCommand@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_hMemBuffer$ = -8					; size = 4
_pchBuffer$ = -4					; size = 4
_pchSqlCmd$ = 8						; size = 4
_pchErrorChar$ = 12					; size = 4
_pfnWrite$ = 16						; size = 4
_pInfo$ = 20						; size = 4
_SqlDisplayCommandEx@16 PROC

; 7134 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7135 :    zLONG  hMemBuffer;
; 7136 :    zPCHAR pchBuffer;
; 7137 : 
; 7138 : #if DBG_DISPLAY
; 7139 :    zSHORT n, m;
; 7140 :    zCHAR  c;
; 7141 :    zCHAR  s[ 201 ];
; 7142 :    zPCHAR p;
; 7143 : 
; 7144 :    // Print out the unformatted SQL command for debugging purposes.
; 7145 :    n = zstrlen( pchSqlCmd );
; 7146 :    p = pchSqlCmd;
; 7147 :    while ( n > 200 )
; 7148 :    {
; 7149 :       c = p[ 200 ];
; 7150 :       p[ 200 ] = 0;
; 7151 :       TraceLineS( "DBG> ", p );
; 7152 : 
; 7153 :       if ( pchErrorChar && pchErrorChar >= p && pchErrorChar < &p[ 200 ] )
; 7154 :       {
; 7155 :          m = (zSHORT) (pchErrorChar - p);
; 7156 :          zmemset( s, ' ', m );
; 7157 :          s[ m ] = '^';
; 7158 :          s[ m + 1 ] = 0;
; 7159 :          TraceLineS( "ERR> ", s );
; 7160 :       }
; 7161 : 
; 7162 :       p = &p[ 200 ];
; 7163 :       *p = c;
; 7164 :       n = n - 200;
; 7165 :    }
; 7166 : 
; 7167 :    TraceLineS( "DBG> ", p );
; 7168 :    TraceLineS( "---- ", "" );
; 7169 : #endif
; 7170 : 
; 7171 :    // Copy the command to a temporary buffer because we will change the SQL
; 7172 :    // string while we are printing it.
; 7173 :    hMemBuffer = SysAllocMemory( (zCOREMEM) &pchBuffer,

	push	0
	push	32768					; 00008000H
	push	0
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMemBuffer$[ebp], eax

; 7174 :                                 zstrlen( pchSqlCmd ) + 1,
; 7175 :                                 0, zCOREMEM_ALLOC, 0 );
; 7176 :    if ( pchBuffer == 0 )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $LN2@SqlDisplay

; 7177 :       return;

	jmp	SHORT $LN1@SqlDisplay
$LN2@SqlDisplay:

; 7178 : 
; 7179 :    zstrcpy( pchBuffer, pchSqlCmd );

	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7180 : 
; 7181 :    if ( pchErrorChar )

	cmp	DWORD PTR _pchErrorChar$[ebp], 0
	je	SHORT $LN3@SqlDisplay

; 7182 :       pchErrorChar = pchBuffer + (pchErrorChar - pchSqlCmd);

	mov	ecx, DWORD PTR _pchErrorChar$[ebp]
	sub	ecx, DWORD PTR _pchSqlCmd$[ebp]
	add	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _pchErrorChar$[ebp], ecx
$LN3@SqlDisplay:

; 7183 : 
; 7184 :    // Call fnSqlDisplayCommand with an initial indent value of 0.
; 7185 :    fnSqlDisplayCommand( &pchBuffer, pchErrorChar, 0, 0, TRUE, pfnWrite, pInfo );

	mov	edx, DWORD PTR _pInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pfnWrite$[ebp]
	push	eax
	push	1
	push	0
	push	0
	mov	ecx, DWORD PTR _pchErrorChar$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	call	_fnSqlDisplayCommand
	add	esp, 28					; 0000001cH

; 7186 : 
; 7187 :    SysFreeMemory( hMemBuffer );

	mov	eax, DWORD PTR _hMemBuffer$[ebp]
	push	eax
	call	_SysFreeMemory@4
$LN1@SqlDisplay:

; 7188 : 
; 7189 : }  // SqlDisplayCommand

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SqlDisplayCommandEx@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpQualView$ = 12					; size = 4
_lpViewOD$ = 16						; size = 4
_lpFirstQualEntity$ = 20				; size = 4
_lpBoundList$ = 24					; size = 4
_SqlRetrieveQualObject@20 PROC

; 6718 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6719 :    zSHORT nRC;
; 6720 : 
; 6721 :    nRC = fnSqlRetrieveQualObject( lpView, lpQualView, lpViewOD,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFirstQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlRetrieveQualObject
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 6722 :                                   lpFirstQualEntity, lpBoundList );
; 6723 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN2@SqlRetriev

; 6724 :    {
; 6725 :       if ( *lpFirstQualEntity )

	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@SqlRetriev

; 6726 :          SqlFreeQualEntity( lpFirstQualEntity );

	mov	ecx, DWORD PTR _lpFirstQualEntity$[ebp]
	push	ecx
	call	_SqlFreeQualEntity@4
$LN2@SqlRetriev:

; 6727 :    }
; 6728 : 
; 6729 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 6730 : }  /* SqlRetrieveQualObject */

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlRetrieveQualObject@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpQualEntity$ = -4					; size = 4
_lpFirstQualEntity$ = 8					; size = 4
_SqlFreeQualEntity@4 PROC

; 5053 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@SqlFreeQua:

; 5054 :    LPQUALENTITY lpQualEntity;
; 5055 : 
; 5056 :    while ( *lpFirstQualEntity )

	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@SqlFreeQua

; 5057 :    {
; 5058 :       lpQualEntity = *lpFirstQualEntity;

	mov	ecx, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpQualEntity$[ebp], edx

; 5059 :       *lpFirstQualEntity = (*lpFirstQualEntity)->lpNextQualEntity;

	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax

; 5060 : 
; 5061 :       fnSqlFreeQualAttrib( lpQualEntity->lpFirstQualAttrib );

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_fnSqlFreeQualAttrib
	add	esp, 4

; 5062 :       if ( lpQualEntity->lpDataField )

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN4@SqlFreeQua

; 5063 :          SysFreeMemory( lpQualEntity->hAttrListMem );

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_SysFreeMemory@4
$LN4@SqlFreeQua:

; 5064 : 
; 5065 :       SysFreeMemory( lpQualEntity->hMem );

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SysFreeMemory@4

; 5066 :    }

	jmp	SHORT $LN2@SqlFreeQua
$LN1@SqlFreeQua:

; 5067 : }  /* SqlFreeQualEntity */

	mov	esp, ebp
	pop	ebp
	ret	4
_SqlFreeQualEntity@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpQualEntity$ = -4					; size = 4
_lpFirstQualEntity$ = 8					; size = 4
_lpViewEntity$ = 12					; size = 4
_SqlEntityIsQualified@8 PROC

; 354  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 355  :    LPQUALENTITY lpQualEntity;
; 356  : 
; 357  :    // Check to see if table is qualified by looking in the qualification
; 358  :    // table for a matching View entity.
; 359  :    lpQualEntity = lpFirstQualEntity;

	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	DWORD PTR _lpQualEntity$[ebp], eax
$LN2@SqlEntityI:

; 360  :    while ( lpQualEntity && lpQualEntity->lpViewEntity != lpViewEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN3@SqlEntityI
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN3@SqlEntityI

; 361  :       lpQualEntity = lpQualEntity->lpNextQualEntity;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpQualEntity$[ebp], ecx
	jmp	SHORT $LN2@SqlEntityI
$LN3@SqlEntityI:

; 362  : 
; 363  :    return( lpQualEntity );

	mov	eax, DWORD PTR _lpQualEntity$[ebp]

; 364  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SqlEntityIsQualified@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_uLth$ = -2484						; size = 4
_lpParent$ = -2480					; size = 4
_lpViewAttrib$1 = -2476					; size = 4
_lpTempEntity$2 = -2472					; size = 4
_lpValue$ = -2468					; size = 4
_lpRelDataField$3 = -2464				; size = 4
_lpSrcDataField$4 = -2460				; size = 4
_lpSrcDataField$5 = -2456				; size = 4
_lpDataRecord$ = -2452					; size = 4
_nRC$ = -2448						; size = 2
_nNull$6 = -2444					; size = 2
_lpRelViewAttrib$ = -2440				; size = 4
_lpDataField$7 = -2436					; size = 4
_lpRelField$8 = -2432					; size = 4
_lpSrcViewAttrib$ = -2428				; size = 4
_lpRelRecord$ = -2424					; size = 4
_lpQualEntity$ = -2420					; size = 4
_chType$ = -2414					; size = 1
_bEntityCreated$ = -2413				; size = 1
_lpRelField$9 = -2412					; size = 4
_lpQualAttrib$ = -2408					; size = 4
_bFirstTime$ = -2401					; size = 1
_lpSql$ = -2400						; size = 4
_SqlStatement$ = -2396					; size = 1890
_szStr$ = -504						; size = 500
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_lpFirstQualEntity$ = 20				; size = 4
_pchSqlCmd$ = 24					; size = 4
_lpBoundList$ = 28					; size = 4
_SqlAutoLoadFromParent@24 PROC

; 4335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2484				; 000009b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 4336 :    zBOOL        bFirstTime;
; 4337 :    LPVIEWENTITY lpParent;
; 4338 :    LPDATARECORD lpDataRecord;
; 4339 :    LPRELRECORD  lpRelRecord;
; 4340 :    zULONG       uLth;
; 4341 :    zPVOID       lpValue;
; 4342 :    zCHAR        chType;
; 4343 :    zCHAR        szStr[ 500 ];
; 4344 :    LPVIEWATTRIB lpSrcViewAttrib;
; 4345 :    LPVIEWATTRIB lpRelViewAttrib;
; 4346 :    zBOOL        bEntityCreated;
; 4347 :    LPQUALENTITY lpQualEntity;
; 4348 :    LPQUALATTRIB lpQualAttrib;
; 4349 :    SqlStatementRecord SqlStatement;
; 4350 :    LPSQLSTATEMENT lpSql;
; 4351 :    zSHORT       nRC;
; 4352 : 
; 4353 :    // Check to see if the entity we are about to load is qualified.
; 4354 :    lpQualEntity = SqlEntityIsQualified (lpFirstQualEntity, lpViewEntity);

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFirstQualEntity$[ebp]
	push	ecx
	call	_SqlEntityIsQualified@8
	mov	DWORD PTR _lpQualEntity$[ebp], eax

; 4355 :    if ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN24@SqlAutoLoa

; 4356 :    {
; 4357 :       // If there is a lpQualEntity then the entity we are loading is
; 4358 :       // qualified.  Loop through the attributes we are qualifing on; if any
; 4359 :       // are NOT keys or the attribute belongs to a different entity
; 4360 :       // then we can't perform the load here--return 0 to
; 4361 :       // indicate that regular SELECT processing must be performed.
; 4362 :       for ( lpQualAttrib = lpQualEntity->lpFirstQualAttrib;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpQualAttrib$[ebp], eax
	jmp	SHORT $LN4@SqlAutoLoa
$LN2@SqlAutoLoa:

; 4364 :             lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
$LN4@SqlAutoLoa:

; 4363 :             lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	SHORT $LN24@SqlAutoLoa

; 4365 :       {
; 4366 :          if ( lpQualAttrib->lpViewEntity != lpViewEntity ||

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN26@SqlAutoLoa
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [edx+20], 0
	je	SHORT $LN25@SqlAutoLoa
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN25@SqlAutoLoa
$LN26@SqlAutoLoa:

; 4367 :               (lpQualAttrib->lpViewAttrib &&
; 4368 :                lpQualAttrib->lpViewAttrib->bKey == FALSE) )
; 4369 :          {
; 4370 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@SqlAutoLoa
$LN25@SqlAutoLoa:

; 4371 :          }
; 4372 :       }

	jmp	SHORT $LN2@SqlAutoLoa
$LN24@SqlAutoLoa:

; 4373 :    }
; 4374 : 
; 4375 :    lpParent       = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$[ebp], eax

; 4376 :    lpDataRecord   = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4377 :    lpRelRecord    = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 4378 :    bEntityCreated = FALSE;

	mov	BYTE PTR _bEntityCreated$[ebp], 0

; 4379 :    bFirstTime     = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 4380 : 
; 4381 :    if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_ONE )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 77					; 0000004dH
	jne	$LN27@SqlAutoLoa

; 4382 :    {
; 4383 :       LPRELFIELD   lpRelField;
; 4384 : 
; 4385 :       // For many-to-one relationships, the keys for the child entity can be
; 4386 :       // retrieved from the parent entity.
; 4387 :       for ( lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$8[ebp], eax
	jmp	SHORT $LN7@SqlAutoLoa
$LN5@SqlAutoLoa:

; 4389 :             lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	ecx, DWORD PTR _lpRelField$8[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$8[ebp], eax
$LN7@SqlAutoLoa:

; 4388 :             lpRelField;

	cmp	DWORD PTR _lpRelField$8[ebp], 0
	je	$LN6@SqlAutoLoa

; 4390 :       {
; 4391 :          LPDATAFIELD lpSrcDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	eax, DWORD PTR _lpRelField$8[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$4[ebp], eax

; 4392 :          LPDATAFIELD lpRelDataField = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$8[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelDataField$3[ebp], eax

; 4393 :          zSHORT      nNull;
; 4394 : 
; 4395 :          lpSrcViewAttrib = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpSrcDataField$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax

; 4396 :          lpRelViewAttrib = zGETPTR( lpRelDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpRelDataField$3[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelViewAttrib$[ebp], eax

; 4397 : 
; 4398 :          // Get attribute value from the parent entity.  We use GetString...
; 4399 :          // because it will tell us if the attribute is null.
; 4400 :          nNull = GetStringFromRecord( lpView,

	push	500					; 000001f4H
	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_GetStringFromRecord@20
	mov	WORD PTR _nNull$6[ebp], ax

; 4401 :                                       zGETPTR( lpRelViewAttrib->hViewEntity ),
; 4402 :                                       lpRelViewAttrib, szStr, 500 );
; 4403 : 
; 4404 :          // If entity is qualified, check to make sure that the attribute
; 4405 :          // value just retrieved matches the qualification.
; 4406 :          if ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	$LN29@SqlAutoLoa

; 4407 :          {
; 4408 :             for ( lpQualAttrib = lpQualEntity->lpFirstQualAttrib;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
	jmp	SHORT $LN10@SqlAutoLoa
$LN8@SqlAutoLoa:

; 4410 :                   lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], ecx
$LN10@SqlAutoLoa:

; 4409 :                   lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	$LN29@SqlAutoLoa

; 4411 :             {
; 4412 :                if ( lpQualAttrib->lpViewAttrib == lpSrcViewAttrib )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	jne	$LN30@SqlAutoLoa

; 4413 :                {
; 4414 :                   GetValueFromRecord( lpView, zGETPTR( lpRelViewAttrib->hViewEntity ),

	lea	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetValueFromRecord@24

; 4415 :                                     lpRelViewAttrib, (zPVOID) &lpValue,
; 4416 :                                     &chType, &uLth );
; 4417 : 
; 4418 :                   // If attribute value does not compare with qualification
; 4419 :                   // value then return without creating entity.
; 4420 :                   if ( !fnCompare( lpView,

	movzx	edx, BYTE PTR _chType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _lpValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCompare
	add	esp, 20					; 00000014H
	cwde
	test	eax, eax
	jne	SHORT $LN30@SqlAutoLoa

; 4421 :                                    (zPVOID) lpValue, lpQualAttrib->szOper,
; 4422 :                                    (zPVOID) lpQualAttrib->szValue, chType ) )
; 4423 :                   {
; 4424 :                      if ( bEntityCreated )

	movzx	ecx, BYTE PTR _bEntityCreated$[ebp]
	test	ecx, ecx
	je	SHORT $LN32@SqlAutoLoa

; 4425 :                      {
; 4426 :                         LPVIEWENTITY lpTempEntity =

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTempEntity$2[ebp], eax

; 4427 :                                     zGETPTR( lpSrcViewAttrib->hViewEntity );
; 4428 : 
; 4429 :                         DropEntity( lpView, lpTempEntity->szName, zREPOS_NONE );

	push	0
	mov	ecx, DWORD PTR _lpTempEntity$2[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DropEntity@12
$LN32@SqlAutoLoa:

; 4430 :                      }
; 4431 :                      return( 1 );

	mov	eax, 1
	jmp	$LN1@SqlAutoLoa
$LN30@SqlAutoLoa:

; 4432 :                   }
; 4433 :                }
; 4434 : 
; 4435 :             } // for ( lpQualAttrib... )...

	jmp	$LN8@SqlAutoLoa
$LN29@SqlAutoLoa:

; 4436 : 
; 4437 :          } // if ( lpQuallEntity )...
; 4438 : 
; 4439 :          // If a value was retrieved then store it in the entity.
; 4440 :          if ( nNull != -1 )

	movsx	eax, WORD PTR _nNull$6[ebp]
	cmp	eax, -1
	je	SHORT $LN33@SqlAutoLoa

; 4441 :          {
; 4442 :             if ( bEntityCreated == FALSE )

	movzx	ecx, BYTE PTR _bEntityCreated$[ebp]
	test	ecx, ecx
	jne	SHORT $LN34@SqlAutoLoa

; 4443 :             {
; 4444 :                bEntityCreated = TRUE;

	mov	BYTE PTR _bEntityCreated$[ebp], 1

; 4445 :                LoadEntity( lpView, lpViewEntity->szName, zPOS_AFTER, 0 );

	push	0
	push	3
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_LoadEntity@16
$LN34@SqlAutoLoa:

; 4446 :             }
; 4447 : 
; 4448 :             StoreStringInRecord( lpView, zGETPTR( lpSrcViewAttrib->hViewEntity ),

	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreStringInRecord@16
$LN33@SqlAutoLoa:

; 4449 :                                  lpSrcViewAttrib, szStr );
; 4450 :          }
; 4451 :       } // for ( lpRelField;...)...

	jmp	$LN5@SqlAutoLoa
$LN6@SqlAutoLoa:

; 4452 : 
; 4453 :       return( 1 ); // Information for entity loaded.

	mov	eax, 1
	jmp	$LN1@SqlAutoLoa

; 4454 :    }

	jmp	$LN1@SqlAutoLoa
$LN27@SqlAutoLoa:

; 4455 :    else
; 4456 :    if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	jne	$LN35@SqlAutoLoa

; 4457 :    {
; 4458 :       LPRELFIELD   lpRelField;
; 4459 :       LPDATAFIELD  lpDataField;
; 4460 : 
; 4461 :       // For many-to-many relationships, the keys for the child entity can
; 4462 :       // be retrieved using only the correspondence table--the main table
; 4463 :       // for the child entity does not need to be used.
; 4464 :       lpSql = &SqlStatement;

	lea	edx, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], edx

; 4465 :       fnSqlInitSqlStatement( lpSql, zSELECT_CMD, pchSqlCmd,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 4466 :                              lpView, lpBoundList );
; 4467 : 
; 4468 :       fnSqlAddStringToSql( lpSql, "SELECT " );

	push	OFFSET $SG13094
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 4469 : 
; 4470 :       // Build column list for key attributes.  We loop thru the datafields
; 4471 :       // looking for keys.  When we find one, we must then find the
; 4472 :       // lpRelField that matches the data field.  When it is found then
; 4473 :       // we add the rel fields FieldName to the select statement.  We must
; 4474 :       // do this round-about code because the rel fields must be listed in the
; 4475 :       // same order as the datafields.
; 4476 :       for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$7[ebp], eax
	jmp	SHORT $LN13@SqlAutoLoa
$LN11@SqlAutoLoa:

; 4478 :             lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	edx, DWORD PTR _lpDataField$7[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$7[ebp], eax
$LN13@SqlAutoLoa:

; 4477 :             lpDataField;

	cmp	DWORD PTR _lpDataField$7[ebp], 0
	je	$LN12@SqlAutoLoa

; 4479 :       {
; 4480 :          LPVIEWATTRIB lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$7[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$1[ebp], eax

; 4481 : 
; 4482 :          // We only want keys.
; 4483 :          if ( lpViewAttrib->bKey == FALSE )

	mov	eax, DWORD PTR _lpViewAttrib$1[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN37@SqlAutoLoa

; 4484 :             continue;

	jmp	SHORT $LN11@SqlAutoLoa
$LN37@SqlAutoLoa:

; 4485 : 
; 4486 :          // Find the rel field that matches lpDataField.
; 4487 :          lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
$LN14@SqlAutoLoa:

; 4488 :          while( lpRelField &&

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	je	SHORT $LN15@SqlAutoLoa
	mov	ecx, DWORD PTR _lpRelField$9[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	cmp	eax, DWORD PTR _lpDataField$7[ebp]
	je	SHORT $LN15@SqlAutoLoa

; 4489 :                 zGETPTR( lpRelField->hSrcDataField ) != lpDataField )
; 4490 :             lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	eax, DWORD PTR _lpRelField$9[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
	jmp	SHORT $LN14@SqlAutoLoa
$LN15@SqlAutoLoa:

; 4491 : 
; 4492 :          if ( lpRelField == 0 )

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	jne	SHORT $LN38@SqlAutoLoa

; 4493 :          {
; 4494 :             IssueError( lpView, 16, 16, "(kzhsqlga) Internal error #2" );

	push	OFFSET $SG13097
	push	16					; 00000010H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_IssueError@16

; 4495 :             fnSqlFreeSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 4496 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SqlAutoLoa
$LN38@SqlAutoLoa:

; 4497 :          }
; 4498 : 
; 4499 :          if ( bFirstTime )

	movzx	ecx, BYTE PTR _bFirstTime$[ebp]
	test	ecx, ecx
	je	SHORT $LN39@SqlAutoLoa

; 4500 :             bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0
	jmp	SHORT $LN40@SqlAutoLoa
$LN39@SqlAutoLoa:

; 4501 :          else
; 4502 :             fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG13100
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi
$LN40@SqlAutoLoa:

; 4503 : 
; 4504 :          fnSqlAddStringToSql( lpSql, lpRelField->szFldName );

	mov	ecx, DWORD PTR _lpRelField$9[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 4505 :       } // for ( ; lpDataField; ... )...

	jmp	$LN11@SqlAutoLoa
$LN12@SqlAutoLoa:

; 4506 : 
; 4507 :       fnAddTableToFrom( lpSql, lpRelRecord->szRecordName, lpViewEntity, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	add	edx, 11					; 0000000bH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H

; 4508 : 
; 4509 :       if ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN41@SqlAutoLoa

; 4510 :          fnSqlAddStringToWhere( lpSql, " ( " );

	push	OFFSET $SG13102
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN41@SqlAutoLoa:

; 4511 : 
; 4512 :       // Add the foreign keys.
; 4513 :       bFirstTime = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 4514 :       for ( lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
	jmp	SHORT $LN18@SqlAutoLoa
$LN16@SqlAutoLoa:

; 4516 :             lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	edx, DWORD PTR _lpRelField$9[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
$LN18@SqlAutoLoa:

; 4515 :             lpRelField;

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	je	$LN17@SqlAutoLoa

; 4517 :       {
; 4518 :          LPDATAFIELD lpSrcDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	ecx, DWORD PTR _lpRelField$9[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcDataField$5[ebp], eax

; 4519 : 
; 4520 :          lpSrcViewAttrib = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpSrcDataField$5[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax

; 4521 : 
; 4522 :          // We only want the key values of the attributes that are part of
; 4523 :          // the parent entity.
; 4524 :          if ( zGETPTR( lpSrcViewAttrib->hViewEntity ) != lpParent )

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	cmp	eax, DWORD PTR _lpParent$[ebp]
	je	SHORT $LN42@SqlAutoLoa

; 4525 :             continue;

	jmp	SHORT $LN16@SqlAutoLoa
$LN42@SqlAutoLoa:

; 4526 : 
; 4527 :          if ( bFirstTime )

	movzx	ecx, BYTE PTR _bFirstTime$[ebp]
	test	ecx, ecx
	je	SHORT $LN43@SqlAutoLoa

; 4528 :          {
; 4529 :             bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0

; 4530 :             fnSqlIncrementComponentCount( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	ax, WORD PTR [edx+56]
	add	ax, 1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [ecx+56], ax

; 4531 :          }

	jmp	SHORT $LN44@SqlAutoLoa
$LN43@SqlAutoLoa:

; 4532 :          else
; 4533 :             fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG13106
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi
$LN44@SqlAutoLoa:

; 4534 : 
; 4535 :          fnSqlAddStringToWhere( lpSql, lpRelField->szFldName );

	mov	ecx, DWORD PTR _lpRelField$9[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 4536 :          fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG13107
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 4537 :          nRC = fnSqlGetAttributeValue( lpView, lpSrcDataField, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcDataField$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 4538 : 
; 4539 :          // If nRC == 1 then the attribute value is null, therefore there
; 4540 :          // can be no child entities.  Return with value that indicates that
; 4541 :          // nothing needs to be done.
; 4542 :          if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $LN45@SqlAutoLoa

; 4543 :          {
; 4544 :             fnSqlFreeSqlStatement( lpSql );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 4545 :             return( 1 );

	mov	eax, 1
	jmp	$LN1@SqlAutoLoa
$LN45@SqlAutoLoa:

; 4546 :          }
; 4547 :       } // for ( ; lpRelField; ... )...

	jmp	$LN16@SqlAutoLoa
$LN17@SqlAutoLoa:

; 4548 : 
; 4549 :       // Add Qualification to SELECT command.
; 4550 :       if ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	$LN46@SqlAutoLoa

; 4551 :       {
; 4552 :          fnSqlAddStringToWhere( lpSql, " ) AND ( " );

	push	OFFSET $SG13110
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 4553 :          bFirstTime = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 4554 :          for ( lpQualAttrib = lpQualEntity->lpFirstQualAttrib;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _lpQualAttrib$[ebp], edx
	jmp	SHORT $LN21@SqlAutoLoa
$LN19@SqlAutoLoa:

; 4556 :                lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], ecx
$LN21@SqlAutoLoa:

; 4555 :                lpQualAttrib;

	cmp	DWORD PTR _lpQualAttrib$[ebp], 0
	je	$LN20@SqlAutoLoa

; 4557 :          {
; 4558 :             if ( bFirstTime )

	movzx	edx, BYTE PTR _bFirstTime$[ebp]
	test	edx, edx
	je	SHORT $LN47@SqlAutoLoa

; 4559 :             {
; 4560 :                bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0

; 4561 :                fnSqlIncrementComponentCount( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	cx, WORD PTR [eax+56]
	add	cx, 1
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [edx+56], cx

; 4562 :             }

	jmp	SHORT $LN48@SqlAutoLoa
$LN47@SqlAutoLoa:

; 4563 :             else
; 4564 :                fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG13113
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi
$LN48@SqlAutoLoa:

; 4565 : 
; 4566 :             // Find the rel field that matches lpQualAttrib->lpDataField.
; 4567 :             // We need it to find the column name in the correspondence table
; 4568 :             // that matches the qualification attribute.
; 4569 :             lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
$LN22@SqlAutoLoa:

; 4570 :             while( lpRelField &&

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	je	SHORT $LN23@SqlAutoLoa
	mov	ecx, DWORD PTR _lpRelField$9[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	eax, DWORD PTR [ecx+24]
	je	SHORT $LN23@SqlAutoLoa

; 4571 :                    zGETPTR( lpRelField->hSrcDataField ) !=
; 4572 :                                                  lpQualAttrib->lpDataField )
; 4573 :                lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	edx, DWORD PTR _lpRelField$9[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$9[ebp], eax
	jmp	SHORT $LN22@SqlAutoLoa
$LN23@SqlAutoLoa:

; 4574 : 
; 4575 :             if ( lpRelField == 0 )

	cmp	DWORD PTR _lpRelField$9[ebp], 0
	jne	SHORT $LN49@SqlAutoLoa

; 4576 :             {
; 4577 :                IssueError( lpView, 16, 16, "(kzhsqlga) Internal error #3" );

	push	OFFSET $SG13115
	push	16					; 00000010H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_IssueError@16

; 4578 :                fnSqlFreeSqlStatement( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 4579 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SqlAutoLoa
$LN49@SqlAutoLoa:

; 4580 :             }
; 4581 : 
; 4582 :             fnSqlAddStringToWhere( lpSql, lpRelField->szFldName );

	mov	eax, DWORD PTR _lpRelField$9[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 4583 :             fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG13116
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+44], esi

; 4584 :             fnSqlAddStringToWhere( lpSql, lpQualAttrib->szOper );

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 4585 : 
; 4586 :             if ( lpQualAttrib->szValue )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN50@SqlAutoLoa

; 4587 :             {
; 4588 :                fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG13119
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 4589 :                fnSqlConvertStringToSqlString( lpQualAttrib->lpDataField,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_fnSqlConvertStringToSqlString
	add	esp, 16					; 00000010H

; 4590 :                                               lpQualAttrib->szValue, szStr,
; 4591 :                                               lpBoundList );
; 4592 :                fnSqlAddStringToWhere( lpSql, szStr );

	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 4593 :             }

	jmp	SHORT $LN51@SqlAutoLoa
$LN50@SqlAutoLoa:

; 4594 :             else
; 4595 :             if ( lpQualAttrib->lpSourceDataField )

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [eax+56], 0
	je	SHORT $LN51@SqlAutoLoa

; 4596 :             {
; 4597 :                fnSqlAddStringToWhere( lpSql, " " );

	push	OFFSET $SG13121
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 4598 :                fnSqlGetAttributeValue( lpView,

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
$LN51@SqlAutoLoa:

; 4599 :                                        lpQualAttrib->lpSourceDataField, lpSql );
; 4600 :             }
; 4601 :          }

	jmp	$LN19@SqlAutoLoa
$LN20@SqlAutoLoa:

; 4602 : 
; 4603 :          fnSqlAddStringToWhere( lpSql, " )" );

	push	OFFSET $SG13122
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN46@SqlAutoLoa:

; 4604 :       } // if ( lpQualEntity )...
; 4605 : 
; 4606 :       fnSqlAssembleSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 4607 : 
; 4608 :       return( 2 );         // SELECT command created and must be executed.

	mov	eax, 2
	jmp	SHORT $LN1@SqlAutoLoa

; 4609 :    }

	jmp	SHORT $LN1@SqlAutoLoa
$LN35@SqlAutoLoa:

; 4610 :    else
; 4611 :    {
; 4612 :       // Nothing special can be done for one-to-many relationships, so
; 4613 :       // return 0.
; 4614 :       return( 0 );

	xor	eax, eax
$LN1@SqlAutoLoa:

; 4615 :    }
; 4616 : 
; 4617 : }  /* SqlAutoLoadFromParent */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SqlAutoLoadFromParent@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewAttrib$ = -1932					; size = 4
_lpDataRecord$ = -1928					; size = 4
tv78 = -1924						; size = 4
_uLth$ = -1920						; size = 2
_bPartialColumnList$ = -1913				; size = 1
_lpDataField$ = -1912					; size = 4
_bFirstColumn$ = -1906					; size = 1
_bFirstKey$ = -1905					; size = 1
_szToken$ = -1904					; size = 4
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_pchColumnList$ = 20					; size = 4
_pchSqlCmd$ = 24					; size = 4
_lpBoundList$ = 28					; size = 4
_SqlBuildSelectForEntityInstance@24 PROC

; 4230 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1932				; 0000078cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 4231 :    zBOOL        bFirstKey;
; 4232 :    zBOOL        bFirstColumn;
; 4233 :    zBOOL        bPartialColumnList;
; 4234 :    zPCHAR       szToken;
; 4235 :    zUSHORT      uLth;
; 4236 :    LPVIEWATTRIB lpViewAttrib;
; 4237 :    LPDATARECORD lpDataRecord;
; 4238 :    LPDATAFIELD  lpDataField;
; 4239 :    LPSQLSTATEMENT lpSql;
; 4240 :    SqlStatementRecord SqlStatement;
; 4241 : 
; 4242 :    lpSql = &SqlStatement;

	lea	eax, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 4243 :    fnSqlInitSqlStatement( lpSql, zSELECT_CMD, pchSqlCmd, lpView, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 4244 : 
; 4245 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4246 :    lpDataField  = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 4247 :    bPartialColumnList = (pchColumnList && *pchColumnList);

	cmp	DWORD PTR _pchColumnList$[ebp], 0
	je	SHORT $LN20@SqlBuildSe
	mov	eax, DWORD PTR _pchColumnList$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN20@SqlBuildSe
	mov	DWORD PTR tv78[ebp], 1
	jmp	SHORT $LN21@SqlBuildSe
$LN20@SqlBuildSe:
	mov	DWORD PTR tv78[ebp], 0
$LN21@SqlBuildSe:
	mov	dl, BYTE PTR tv78[ebp]
	mov	BYTE PTR _bPartialColumnList$[ebp], dl

; 4248 : 
; 4249 :    fnSqlAddStringToSql( lpSql, "SELECT " );

	push	OFFSET $SG12989
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 4250 :    fnAddTableToFrom( lpSql, 0, lpViewEntity, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H

; 4251 : 
; 4252 :    // Go through all the datafields.  If a key is found, add it to the WHERE
; 4253 :    // clause.  Also conditionally add the column name to the SELECT clause.
; 4254 :    bFirstColumn = TRUE;

	mov	BYTE PTR _bFirstColumn$[ebp], 1

; 4255 :    bFirstKey    = TRUE;

	mov	BYTE PTR _bFirstKey$[ebp], 1

; 4256 :    for (; lpDataField; lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	jmp	SHORT $LN4@SqlBuildSe
$LN2@SqlBuildSe:
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@SqlBuildSe:
	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN3@SqlBuildSe

; 4257 :    {
; 4258 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 4259 : 
; 4260 :       // If attribute is a key then add it to the WHERE clause.
; 4261 :       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	je	$LN11@SqlBuildSe

; 4262 :       {
; 4263 :          if ( bFirstKey == FALSE )

	movzx	ecx, BYTE PTR _bFirstKey$[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@SqlBuildSe

; 4264 :             fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12993
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi
	jmp	SHORT $LN13@SqlBuildSe
$LN12@SqlBuildSe:

; 4265 :          else
; 4266 :             bFirstKey = FALSE;

	mov	BYTE PTR _bFirstKey$[ebp], 0
$LN13@SqlBuildSe:

; 4267 : 
; 4268 :          fnSqlAddStringToWhere( lpSql, lpDataField->szFldName );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 4269 :          fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12994
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 4270 :          fnSqlGetAttributeValue( lpView, lpDataField, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
$LN11@SqlBuildSe:

; 4271 :       }
; 4272 : 
; 4273 :       // If only a partial list is wanted then check to make sure that the
; 4274 :       // current data field should belong to the SELECT statement.
; 4275 :       if ( bPartialColumnList )

	movzx	eax, BYTE PTR _bPartialColumnList$[ebp]
	test	eax, eax
	je	$LN14@SqlBuildSe

; 4276 :       {
; 4277 :          uLth    = zstrlen( lpDataField->szFldName );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _uLth$[ebp], ax

; 4278 :          szToken = pchColumnList;

	mov	edx, DWORD PTR _pchColumnList$[ebp]
	mov	DWORD PTR _szToken$[ebp], edx
$LN5@SqlBuildSe:

; 4279 :          while ( szToken[ 0 ] &&

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _szToken$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN6@SqlBuildSe
	movzx	ecx, WORD PTR _uLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _szToken$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN6@SqlBuildSe
$LN7@SqlBuildSe:

; 4280 :                  zstrncmpi( szToken,
; 4281 :                             lpDataField->szFldName, uLth ) != 0 )
; 4282 :          {
; 4283 :             // Set szToken to point to end of current token.
; 4284 :             while ( szToken[ 0 ] && szToken[ 0 ] != ',' && szToken[ 0 ] != ' ' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _szToken$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN9@SqlBuildSe
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _szToken$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN9@SqlBuildSe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _szToken$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN9@SqlBuildSe

; 4285 :                szToken++;

	mov	ecx, DWORD PTR _szToken$[ebp]
	add	ecx, 1
	mov	DWORD PTR _szToken$[ebp], ecx
	jmp	SHORT $LN7@SqlBuildSe
$LN9@SqlBuildSe:

; 4286 : 
; 4287 :             // Edit out delimiters.
; 4288 :             while ( szToken[ 0 ] && (szToken[ 0 ] == ',' || szToken[ 0 ] == ' ') )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _szToken$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN10@SqlBuildSe
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _szToken$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN15@SqlBuildSe
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _szToken$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN10@SqlBuildSe
$LN15@SqlBuildSe:

; 4289 :                szToken++;

	mov	edx, DWORD PTR _szToken$[ebp]
	add	edx, 1
	mov	DWORD PTR _szToken$[ebp], edx
	jmp	SHORT $LN9@SqlBuildSe
$LN10@SqlBuildSe:

; 4290 :          }

	jmp	$LN5@SqlBuildSe
$LN6@SqlBuildSe:

; 4291 : 
; 4292 :          // If szToken[ 0 ] is 0 then the column was not found and shouldn't be
; 4293 :          // included in the SELECT clause, so continue "for" loop.
; 4294 :          if ( szToken[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _szToken$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN14@SqlBuildSe

; 4295 :             continue;

	jmp	$LN2@SqlBuildSe
$LN14@SqlBuildSe:

; 4296 :       }
; 4297 : 
; 4298 :       if ( bFirstColumn == FALSE )

	movzx	ecx, BYTE PTR _bFirstColumn$[ebp]
	test	ecx, ecx
	jne	SHORT $LN17@SqlBuildSe

; 4299 :          fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG13000
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi
	jmp	SHORT $LN18@SqlBuildSe
$LN17@SqlBuildSe:

; 4300 :       else
; 4301 :          bFirstColumn = FALSE;

	mov	BYTE PTR _bFirstColumn$[ebp], 0
$LN18@SqlBuildSe:

; 4302 : 
; 4303 :       // Add DataField to column list.
; 4304 :       fnSqlAddStringToSql( lpSql, lpDataField->szFldName );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 4305 :    } // for (; lpDataField; ... )...

	jmp	$LN2@SqlBuildSe
$LN3@SqlBuildSe:

; 4306 : 
; 4307 :    fnSqlAssembleSqlStatement( lpSql );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 4308 : 
; 4309 :    return( 0 );

	xor	eax, eax

; 4310 : 
; 4311 : }  /* SqlBuildSelectForEntityInstance */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SqlBuildSelectForEntityInstance@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpRelRecord$ = -2040					; size = 4
_lpChildDataRecord$1 = -2036				; size = 4
_lpDataField$ = -2032					; size = 4
_lpChildRelRecord$2 = -2028				; size = 4
_lpDataRecord$ = -2024					; size = 4
_lpChildEntity$3 = -2020				; size = 4
_nOrderBy$ = -2016					; size = 2
_nRC$ = -2012						; size = 2
_lpQualEntity$ = -2008					; size = 4
_nNull$ = -2004						; size = 2
_lpSql$ = -2000						; size = 4
_SqlStatement$ = -1996					; size = 1890
_sz$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_lpFirstQualEntity$ = 20				; size = 4
_pchSqlCmd$ = 24					; size = 4
_lpBoundList$ = 28					; size = 4
_SqlBuildSelect@24 PROC

; 4023 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2040				; 000007f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 4024 :    LPDATARECORD       lpDataRecord;
; 4025 :    LPDATAFIELD        lpDataField;
; 4026 :    LPRELRECORD        lpRelRecord;
; 4027 :    LPQUALENTITY       lpQualEntity;
; 4028 :    LPSQLSTATEMENT     lpSql;
; 4029 :    SqlStatementRecord SqlStatement;
; 4030 :    zCHAR              sz[ 100 ];
; 4031 :    zSHORT             nOrderBy = 0;

	xor	eax, eax
	mov	WORD PTR _nOrderBy$[ebp], ax

; 4032 :    zSHORT             nNull;
; 4033 :    zSHORT             nRC;
; 4034 : 
; 4035 :    // Check to see if table is qualified by looking in the qualification
; 4036 :    // table for a matching View entity.
; 4037 :    lpQualEntity = SqlEntityIsQualified( lpFirstQualEntity, lpViewEntity );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpFirstQualEntity$[ebp]
	push	edx
	call	_SqlEntityIsQualified@8
	mov	DWORD PTR _lpQualEntity$[ebp], eax

; 4038 : 
; 4039 :    if ( lpQualEntity && lpQualEntity->pszOpenSQL )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN5@SqlBuildSe
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@SqlBuildSe

; 4040 :    {
; 4041 :       // User has specified their own SQL, so copy SQL and return.
; 4042 :       return( fnSqlBuildOpenSQL( lpView, lpViewOD, lpViewEntity,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlBuildOpenSQL
	add	esp, 24					; 00000018H
	jmp	$LN1@SqlBuildSe
$LN5@SqlBuildSe:

; 4043 :                                  lpQualEntity, pchSqlCmd, lpBoundList ) );
; 4044 :    }
; 4045 : 
; 4046 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4047 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 4048 :    lpDataField  = zGETPTR( lpDataRecord->hFirstDataField );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 4049 : 
; 4050 :    // Exec callback to intialize SELECT string.
; 4051 :    if ( EXEC_CALLBACK( zSQLCALLBACK_INITSELECT, lpView,

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN6@SqlBuildSe
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN6@SqlBuildSe
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+14]
	and	eax, 16					; 00000010H
	je	SHORT $LN6@SqlBuildSe
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	call	ecx
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN6@SqlBuildSe

; 4052 :                        lpDataField, (zPCHAR) lpQualEntity, sz ) )
; 4053 :    {
; 4054 :       // Init handled by call back.
; 4055 :    }

	jmp	SHORT $LN7@SqlBuildSe
$LN6@SqlBuildSe:

; 4056 :    else
; 4057 :       zstrcpy( sz, "SELECT " );

	push	OFFSET $SG12929
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN7@SqlBuildSe:

; 4058 : 
; 4059 :    lpSql = &SqlStatement;

	lea	ecx, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], ecx

; 4060 :    fnSqlInitSqlStatement( lpSql, zSELECT_CMD, pchSqlCmd, lpView, lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchSqlCmd$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 4061 :    lpSql->lpLoadViewEntity  = lpViewEntity;

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+68], ecx

; 4062 :    lpSql->lpFirstQualEntity = lpFirstQualEntity;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	mov	DWORD PTR [edx+72], eax

; 4063 :    nNull = 0;

	xor	ecx, ecx
	mov	WORD PTR _nNull$[ebp], cx

; 4064 : 
; 4065 :    fnSqlAddStringToSql( lpSql, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 4066 : 
; 4067 :    if ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN8@SqlBuildSe

; 4068 :    {
; 4069 :       lpSql->bContainsSubselect   = lpQualEntity->bContainsSubselect;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 1
	and	eax, 1
	and	eax, 1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	and	edx, -2					; fffffffeH
	or	edx, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+76], edx

; 4070 :       lpSql->bQualUsesChildEntity = lpQualEntity->bQualUsesChildEntity;

	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 1
	and	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+76]
	and	ecx, -3					; fffffffdH
	or	ecx, edx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+76], ecx
$LN8@SqlBuildSe:

; 4071 :    }
; 4072 : 
; 4073 :    // We have to add an extra paren for each child that will be joined with
; 4074 :    // the root.
; 4075 :    if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_USEJOIN ) &&

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	$LN9@SqlBuildSe
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	and	ecx, 33554432				; 02000000H
	je	$LN9@SqlBuildSe
	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN10@SqlBuildSe
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 3
	and	eax, 1
	jne	$LN9@SqlBuildSe
$LN10@SqlBuildSe:

; 4076 :         (lpQualEntity == 0 || lpQualEntity->bOptionsNoJoins == FALSE) )
; 4077 :    {
; 4078 :       LPVIEWENTITY lpChildEntity;
; 4079 : 
; 4080 :       lpSql->bUseLeftJoin = TRUE;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	or	edx, 4
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+76], edx

; 4081 : 
; 4082 :       // Set aside some spaces for opening parens.  We'll be safe and set aside
; 4083 :       // two spaces for each child entity (and an extra one for good measure).
; 4084 :       lpSql->pchNextJoinParen = lpSql->pchFromEnd;

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+36], eax

; 4085 :       for ( lpChildEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpChildEntity$3[ebp], eax
	jmp	SHORT $LN4@SqlBuildSe
$LN2@SqlBuildSe:

; 4087 :             lpChildEntity = zGETPTR( lpChildEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpChildEntity$3[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpChildEntity$3[ebp], eax
$LN4@SqlBuildSe:

; 4086 :             lpChildEntity && lpChildEntity->nLevel > lpViewEntity->nLevel;

	cmp	DWORD PTR _lpChildEntity$3[ebp], 0
	je	$LN3@SqlBuildSe
	mov	edx, DWORD PTR _lpChildEntity$3[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jle	$LN3@SqlBuildSe

; 4088 :       {
; 4089 :          LPDATARECORD lpChildDataRecord;
; 4090 :          LPRELRECORD  lpChildRelRecord;
; 4091 : 
; 4092 :          // If the child entity doesn't have a data record then it can't
; 4093 :          // be part of a SELECT so skip it.
; 4094 :          if ( lpChildEntity->hFirstDataRecord == 0 )

	mov	eax, DWORD PTR _lpChildEntity$3[ebp]
	cmp	DWORD PTR [eax+191], 0
	jne	SHORT $LN11@SqlBuildSe

; 4095 :             continue;

	jmp	SHORT $LN2@SqlBuildSe
$LN11@SqlBuildSe:

; 4096 : 
; 4097 :          *lpSql->pchFromEnd++ = ' ';

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	BYTE PTR [edx], 32			; 00000020H
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], ecx

; 4098 :          *lpSql->pchFromEnd++ = ' ';

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	BYTE PTR [ecx], 32			; 00000020H
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 4099 : 
; 4100 :          lpChildDataRecord = zGETPTR( lpChildEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpChildEntity$3[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpChildDataRecord$1[ebp], eax

; 4101 :          lpChildRelRecord  = zGETPTR( lpChildDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpChildDataRecord$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpChildRelRecord$2[ebp], eax

; 4102 : 
; 4103 :          // Take into account M-M tables.
; 4104 :          if ( lpChildRelRecord &&

	cmp	DWORD PTR _lpChildRelRecord$2[ebp], 0
	je	SHORT $LN12@SqlBuildSe
	mov	eax, DWORD PTR _lpChildRelRecord$2[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	jne	SHORT $LN12@SqlBuildSe

; 4105 :               lpChildRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )
; 4106 :          {
; 4107 :             *lpSql->pchFromEnd++ = ' ';

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	add	edx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+32], edx

; 4108 :             *lpSql->pchFromEnd++ = ' ';

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	BYTE PTR [edx], 32			; 00000020H
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	add	ecx, 1
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+32], ecx
$LN12@SqlBuildSe:

; 4109 :          }
; 4110 :       }

	jmp	$LN2@SqlBuildSe
$LN3@SqlBuildSe:

; 4111 : 
; 4112 :       *lpSql->pchFromEnd++ = ' ';

	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	BYTE PTR [ecx], 32			; 00000020H
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	eax, 1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 4113 :       *lpSql->pchFromEnd = 0;

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	BYTE PTR [eax], 0
$LN9@SqlBuildSe:

; 4114 : 
; 4115 :    } // if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_USEJOIN ) )...
; 4116 : 
; 4117 :    // Add the main table name to the FROM list so that if any alias names are
; 4118 :    // generated they can be used in fnSqlBuildColumnList.
; 4119 :    fnAddTableToFrom( lpSql, 0, lpViewEntity, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnAddTableToFrom
	add	esp, 16					; 00000010H

; 4120 : 
; 4121 :    nRC = fnSqlBuildColumnList( lpViewEntity, lpSql,

	push	5
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	_fnSqlBuildColumnList
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 4122 :                                zFULLY_QUALIFIED | zNO_HIDDEN );
; 4123 : 
; 4124 :    // Check to see if we should use a join to select all child tables that
; 4125 :    // are flagged as joinable.
; 4126 :    if ( lpSql->bUseLeftJoin )

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+76]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN13@SqlBuildSe

; 4127 :       fnSqlAddChildEntities( lpSql, lpViewEntity );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnSqlAddChildEntities
	add	esp, 8
$LN13@SqlBuildSe:

; 4128 : 
; 4129 :    // Some generated SQL needs an 'INTO' clause.  This is used for static SQL.
; 4130 :    if ( EXEC_CALLBACK( zSQLCALLBACK_USEINTO, lpView, 0, 0, 0 ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN14@SqlBuildSe
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN14@SqlBuildSe
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	and	edx, 64					; 00000040H
	je	SHORT $LN14@SqlBuildSe
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	64					; 00000040H
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+10]
	call	eax
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@SqlBuildSe

; 4131 :    {
; 4132 :       // DBHandler wants us to generate 'INTO' clause.
; 4133 :       fnSqlBuildIntoList( lpViewEntity, lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_fnSqlBuildIntoList
	add	esp, 8
$LN14@SqlBuildSe:

; 4134 :    }
; 4135 : 
; 4136 :    //===
; 4137 :    //=== Add parent foreign keys to WHERE clause.
; 4138 :    //===
; 4139 : 
; 4140 :    // If the table we are about to select has a parent table then we need to
; 4141 :    // add to the WHERE clause any foreign keys that logically connect the
; 4142 :    // table with it's parent.
; 4143 :    if ( lpViewEntity->hParent )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN15@SqlBuildSe

; 4144 :    {
; 4145 :       // If the table is qualified then we're going to add more stuff later
; 4146 :       // so let's add an opening paren.
; 4147 :       if ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN16@SqlBuildSe

; 4148 :          fnSqlAddStringToWhere( lpSql, "( " );

	push	OFFSET $SG12939
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi
$LN16@SqlBuildSe:

; 4149 : 
; 4150 :       // Add foreign keys to WHERE.  We use zROOT_ENTITY to indicate that the
; 4151 :       // entity specified by lpViewEntity is the entity that we are loading
; 4152 :       // (i.e. it is the 'root' of the current load).
; 4153 :       nNull = fnSqlBuildForeignKeys( lpView, lpViewEntity, lpSql, zROOT_ENTITY );

	push	2
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlBuildForeignKeys
	add	esp, 16					; 00000010H
	mov	WORD PTR _nNull$[ebp], ax
$LN15@SqlBuildSe:

; 4154 :    }
; 4155 : 
; 4156 :    // If entity is qualified, then add qualification.
; 4157 :    if ( lpQualEntity )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN17@SqlBuildSe

; 4158 :    {
; 4159 :       //===
; 4160 :       //===  Table is qualified.  Add qualification to WHERE clause.
; 4161 :       //===
; 4162 :       fnSqlAddQualToWhere( lpView, lpQualEntity,

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlAddQualToWhere
	add	esp, 16					; 00000010H

; 4163 :                            lpQualEntity->lpFirstQualAttrib, lpSql );
; 4164 : 
; 4165 :       // If the parent is non-null then we added foreign keys above.  Add
; 4166 :       // the closing paren.
; 4167 :       if ( lpViewEntity->hParent )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN17@SqlBuildSe

; 4168 :          fnSqlAddStringToWhere( lpSql, " )" );

	push	OFFSET $SG12942
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi
$LN17@SqlBuildSe:

; 4169 : 
; 4170 :    } // if ( lpQualEntity )...
; 4171 : 
; 4172 :    // If the entity has default ordering attributes, set up a 'ORDER BY'
; 4173 :    // clause.  We only do this if there is an activate limit.  If there is no
; 4174 :    // limit then we will load all the entities and sort them in memory.  If
; 4175 :    // there is an activate limit we need the 'ORDER BY' to ensure that we
; 4176 :    // load the *first* 'n' entities.
; 4177 :    // Special handling is  needed (TonBeller DBHandler), if left Joins
; 4178 :    //  with a x:m cardinality are used.
; 4179 :    // This is indicated by zSQLCALLBACK_CANONICALORDER
; 4180 : 
; 4181 :    if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_CANONICALORDER ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN19@SqlBuildSe
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	and	ecx, 67108864				; 04000000H
	je	SHORT $LN19@SqlBuildSe

; 4182 :    {
; 4183 :       nOrderBy = fnCanonicalOrder( lpSql, lpViewEntity,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnCanonicalOrder
	add	esp, 16					; 00000010H
	mov	WORD PTR _nOrderBy$[ebp], ax

; 4184 :                                    lpFirstQualEntity, lpBoundList );
; 4185 :    }

	jmp	SHORT $LN20@SqlBuildSe
$LN19@SqlBuildSe:

; 4186 :    else
; 4187 :    if ( lpViewOD->bUseOrderBy ||
; 4188 :         CHECK_CALLBACK_FLAG( zSQLCALLBACK_FORCEORDERBY ) ||

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	SHORT $LN22@SqlBuildSe
	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN23@SqlBuildSe
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+14]
	and	eax, 134217728				; 08000000H
	jne	SHORT $LN22@SqlBuildSe
$LN23@SqlBuildSe:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+226], 0
	je	SHORT $LN20@SqlBuildSe
$LN22@SqlBuildSe:

; 4189 :         lpViewEntity->lActivateLimit )
; 4190 :    {
; 4191 :       // Changed the *OrderBy check* to old logic.
; 4192 :       nOrderBy = fnGenerateOrderBy( lpSql, lpViewEntity,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFirstQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnGenerateOrderBy
	add	esp, 16					; 00000010H
	mov	WORD PTR _nOrderBy$[ebp], ax
$LN20@SqlBuildSe:

; 4193 :                                     lpFirstQualEntity, lpBoundList );
; 4194 :    }
; 4195 : 
; 4196 :    // Assemble the SQL statement from all the parts.
; 4197 :    fnSqlAssembleSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 4198 : 
; 4199 :    if ( nNull >= 0 )

	movsx	ecx, WORD PTR _nNull$[ebp]
	test	ecx, ecx
	jl	SHORT $LN24@SqlBuildSe

; 4200 :    {
; 4201 :       if ( lpSql->nFromTableCount > 1 )

	mov	edx, DWORD PTR _lpSql$[ebp]
	movsx	eax, WORD PTR [edx+80]
	cmp	eax, 1
	jle	SHORT $LN25@SqlBuildSe

; 4202 :         nNull += 2;  // indicate that joins were generated

	movsx	ecx, WORD PTR _nNull$[ebp]
	add	ecx, 2
	mov	WORD PTR _nNull$[ebp], cx
$LN25@SqlBuildSe:

; 4203 : 
; 4204 :       if ( nOrderBy > 0 )

	movsx	edx, WORD PTR _nOrderBy$[ebp]
	test	edx, edx
	jle	SHORT $LN24@SqlBuildSe

; 4205 :         nNull += 4;  // indicate that Order By was generated

	movsx	eax, WORD PTR _nNull$[ebp]
	add	eax, 4
	mov	WORD PTR _nNull$[ebp], ax
$LN24@SqlBuildSe:

; 4206 :    }
; 4207 : 
; 4208 :    return( nNull );

	mov	ax, WORD PTR _nNull$[ebp]
$LN1@SqlBuildSe:

; 4209 : }  /* SqlBuildSelect */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SqlBuildSelect@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -1916					; size = 4
_lpRelRecord$ = -1912					; size = 4
_lpRelField$ = -1908					; size = 4
_bFirstTime$ = -1901					; size = 1
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_pchSqlCmd$ = 20					; size = 4
_lpBoundList$ = 24					; size = 4
_SqlBuildDeleteCorrTable@20 PROC

; 2697 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1916				; 0000077cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2698 :    LPDATARECORD lpDataRecord;
; 2699 :    LPRELRECORD  lpRelRecord;
; 2700 :    LPRELFIELD   lpRelField;
; 2701 :    LPSQLSTATEMENT lpSql;
; 2702 :    SqlStatementRecord SqlStatement;
; 2703 :    zBOOL        bFirstTime;
; 2704 : 
; 2705 :    lpSql = &SqlStatement;

	lea	eax, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 2706 :    fnSqlInitSqlStatement( lpSql, zDELETE_CMD | zCORR_CMD, pchSqlCmd,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	push	4104					; 00001008H
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 2707 :                           lpView, lpBoundList );
; 2708 : 
; 2709 :    bFirstTime = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 2710 : 
; 2711 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2712 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 2713 : 
; 2714 :    fnSqlAddStringToSql( lpSql, "DELETE FROM " );

	push	OFFSET $SG12394
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2715 :    fnSqlAddStringToSql( lpSql, lpRelRecord->szRecordName );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	add	edx, 11					; 0000000bH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2716 :    fnSqlIncrementComponentCount( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	ax, WORD PTR [edx+56]
	add	ax, 1
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [ecx+56], ax

; 2717 : 
; 2718 :    lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN2@SqlBuildDe:

; 2719 :    while ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN3@SqlBuildDe

; 2720 :    {
; 2721 :       if ( bFirstTime == FALSE )

	movzx	ecx, BYTE PTR _bFirstTime$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@SqlBuildDe

; 2722 :       {
; 2723 :          fnSqlAddStringToWhere( lpSql, " AND " );

	push	OFFSET $SG12397
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2724 :          fnSqlIncrementComponentCount( lpSql );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	dx, WORD PTR [ecx+56]
	add	dx, 1
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	WORD PTR [eax+56], dx

; 2725 :       }

	jmp	SHORT $LN5@SqlBuildDe
$LN4@SqlBuildDe:

; 2726 :       else
; 2727 :          bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0
$LN5@SqlBuildDe:

; 2728 : 
; 2729 :       fnSqlAddStringToWhere( lpSql, lpRelField->szFldName );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+44], esi

; 2730 :       fnSqlAddStringToWhere( lpSql, " = " );

	push	OFFSET $SG12398
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+44], esi

; 2731 : 
; 2732 :       fnSqlGetAttributeValue( lpView, zGETPTR( lpRelField->hSrcDataField ),

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH

; 2733 :                               lpSql );
; 2734 : 
; 2735 :       lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax

; 2736 :    }

	jmp	$LN2@SqlBuildDe
$LN3@SqlBuildDe:

; 2737 : 
; 2738 :    fnSqlAssembleSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 2739 : 
; 2740 :    return( 0 );

	xor	eax, eax

; 2741 : }  /* SqlBuildDeleteCorrTable */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlBuildDeleteCorrTable@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -1908					; size = 4
_nRC$ = -1904						; size = 2
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_pchSqlCmd$ = 20					; size = 4
_lpBoundList$ = 24					; size = 4
_SqlBuildDeleteAll@20 PROC

; 2513 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1908				; 00000774H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2514 : #if 1
; 2515 : 
; 2516 :    LPDATARECORD lpDataRecord;
; 2517 :    LPSQLSTATEMENT lpSql;
; 2518 :    SqlStatementRecord SqlStatement;
; 2519 :    zSHORT       nRC;
; 2520 : 
; 2521 :    lpSql = &SqlStatement;

	lea	eax, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 2522 :    fnSqlInitSqlStatement( lpSql, zDELETE_CMD, pchSqlCmd, lpView, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 2523 : 
; 2524 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2525 : 
; 2526 :    fnSqlAddStringToSql( lpSql, "DELETE FROM " );

	push	OFFSET $SG12368
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2527 :    fnSqlAddStringToSql( lpSql, lpDataRecord->szRecordName );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2528 :    fnSqlAddStringToSql( lpSql, " " );

	push	OFFSET $SG12369
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2529 : 
; 2530 :    nRC = fnSqlBuildWhere( lpView, lpViewOD, lpViewEntity, lpSql, zFOREIGN_KEY );

	push	16					; 00000010H
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlBuildWhere
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2531 : 
; 2532 :    fnSqlAssembleSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 2533 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2534 : 
; 2535 : #else
; 2536 : 
; 2537 :    LPENTITYINSTANCE  lpEntityInstance;
; 2538 :    LPVIEWCSR         lpViewCsr;
; 2539 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2540 :    LPVIEWENTITY      lpVE_Parent;
; 2541 :    LPENTITYINSTANCE  lpEI_Parent;
; 2542 : 
; 2543 :    lpViewCsr = zGETPTR( lpView->hViewCsr );
; 2544 : 
; 2545 :    // Validate that the entity exists.
; 2546 :    if ( fnValidViewEntity( &lpViewEntityCsr, lpView,
; 2547 :                            lpViewEntity->szName, 0 ) == 0 )
; 2548 :    {
; 2549 :       return( zCALL_ERROR );
; 2550 :    }
; 2551 : 
; 2552 :    if ( lpViewEntityCsr )
; 2553 :    {
; 2554 :       SqlStatementRecord SqlStatement;
; 2555 :       LPSQLSTATEMENT lpSql;
; 2556 :       LPDATARECORD lpDataRecord;
; 2557 :       LPDATAFIELD  lpDataField;
; 2558 :       LPVIEWATTRIB lpViewAttrib;
; 2559 :       zSHORT       bKeyFound;
; 2560 :    // zSHORT       nRC;
; 2561 : 
; 2562 :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );
; 2563 :       lpEI_Parent = zGETPTR( lpEntityInstance->hParent );
; 2564 :       lpVE_Parent = zGETPTR( lpViewEntity->hParent );
; 2565 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );
; 2566 :       TraceLineS( "DeleteAll Found lpEntityInstance: ", lpViewEntity->szName );
; 2567 :    // bDeleteRequired = FALSE;
; 2568 : 
; 2569 :       lpSql = &SqlStatement;
; 2570 :       fnSqlInitSqlStatement( lpSql, zDELETE_CMD, pchSqlCmd,
; 2571 :                              lpView, lpBoundList );
; 2572 : 
; 2573 :       lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );
; 2574 : 
; 2575 :       fnSqlAddStringToSql( lpSql, "DELETE FROM " );
; 2576 :       fnSqlAddStringToSql( lpSql, lpDataRecord->szRecordName );
; 2577 :       fnSqlAddStringToSql( lpSql, " " );
; 2578 : 
; 2579 :   // nRC = fnSqlBuildWhere( lpView, lpViewOD, lpViewEntity, lpSql, 0 );
; 2580 : 
; 2581 :       bKeyFound = FALSE;
; 2582 :       lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );
; 2583 :       for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );
; 2584 :             lpDataField;
; 2585 :             lpDataField = zGETPTR( lpDataField->hNextDataField ) )
; 2586 :       {
; 2587 :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );
; 2588 : 
; 2589 :          if ( lpViewAttrib->bKey == TRUE )
; 2590 :          {
; 2591 :             bKeyFound = TRUE;
; 2592 :             TraceLine( "SqlBuildDeleteAll Key: %s  ERTok: 0x%08x  XVTok: %d",
; 2593 :                        lpViewAttrib->szName, lpViewAttrib->lERAttTok, lpViewAttrib->lXVAAttTok );
; 2594 :          }
; 2595 : 
; 2596 :          if ( lpViewAttrib->bForeignKey == TRUE )
; 2597 :             TraceLine( "SqlBuildDeleteAll ForeignKey: %s  ERTok: 0x%08x  XVTok: %d",
; 2598 :                        lpViewAttrib->szName, lpViewAttrib->lERAttTok, lpViewAttrib->lXVAAttTok );
; 2599 :       }
; 2600 : 
; 2601 :       bKeyFound = FALSE;
; 2602 :       lpDataRecord = zGETPTR( lpVE_Parent->hFirstDataRecord );
; 2603 :       for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );
; 2604 :             lpDataField;
; 2605 :             lpDataField = zGETPTR( lpDataField->hNextDataField ) )
; 2606 :       {
; 2607 :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );
; 2608 : 
; 2609 :          if ( lpViewAttrib->bKey == TRUE )
; 2610 :          {
; 2611 :             bKeyFound = TRUE;
; 2612 :             TraceLine( "SqlBuildDeleteAll Parent Key: %s  ERTok: 0x%08x  XVTok: %d",
; 2613 :                        lpViewAttrib->szName, lpViewAttrib->lERAttTok, lpViewAttrib->lXVAAttTok );
; 2614 :          }
; 2615 : 
; 2616 :          if ( lpViewAttrib->bForeignKey == TRUE )
; 2617 :          {
; 2618 :             TraceLine( "SqlBuildDeleteAll Parent ForeignKey: %s  ERTok: 0x%08x  XVTok: %d",
; 2619 :                        lpViewAttrib->szName, lpViewAttrib->lERAttTok, lpViewAttrib->lXVAAttTok );
; 2620 :          }
; 2621 :       }
; 2622 : 
; 2623 :       return( 1 );
; 2624 : 
; 2625 : #if 0
; 2626 :       if ( fnSqlWhereIsEmpty( lpSql ) )
; 2627 :          fnSqlAddStringToWhere( lpSql, " ( " );
; 2628 :       else
; 2629 :          fnSqlAddStringToWhere( lpSql, " AND " );
; 2630 : 
; 2631 :       if ( nQual == zFULLY_QUALIFIED )
; 2632 :       {
; 2633 :          fnSqlAddStringToWhere( lpSql, fnTableName( lpSql,
; 2634 :                                                     lpDataRecord->szRecordName,
; 2635 :                                                     lpViewEntity ) );
; 2636 :          fnSqlAddStringToWhere( lpSql, "." );
; 2637 :       }
; 2638 : 
; 2639 :       fnSqlAddStringToWhere( lpSql, lpDataField->szFldName );
; 2640 :       if ( SqlAttributeIsNull( lpView, lpDataField, lpBoundList ) )
; 2641 :       {
; 2642 :          // if the attribute is null, then write 'null'-value into the
; 2643 :          // statement 29.10.1997, RG
; 2644 :          zCHAR pchValue[ 25 ];
; 2645 : 
; 2646 :          fnSqlAddStringToWhere( lpSql, " IS " );
; 2647 :          fnSqlGetNullString( pchValue, lpDataField, lpBoundList );
; 2648 :          fnSqlAddStringToWhere( lpSql, pchValue );
; 2649 :       }
; 2650 :       else
; 2651 :       {
; 2652 :          fnSqlAddStringToWhere( lpSql, " = " );
; 2653 :          fnSqlGetAttributeValue( lpView, lpDataField, lpSql );
; 2654 :       }
; 2655 : 
; 2656 :       if ( bKeyFound == FALSE )
; 2657 :       {
; 2658 :          zCHAR szMsg[ 400 ];
; 2659 : 
; 2660 :          zstrcpy( szMsg, "SQL Error creating WHERE clause -- no key attribute "
; 2661 :                   "found in object definition.\nObject name = " );
; 2662 :          zstrcat( szMsg, lpViewOD->szName );
; 2663 :          zstrcat( szMsg, "\nEntity name = " );
; 2664 :          zstrcat( szMsg, lpViewEntity->szName );
; 2665 :          IssueError( lpView, 16, 16, szMsg );
; 2666 : 
; 2667 :          return( zCALL_ERROR );
; 2668 :       }
; 2669 : 
; 2670 :       fnSqlAddStringToWhere( lpSql, " )" );
; 2671 :       return( 0 );
; 2672 : 
; 2673 :       fnSqlAssembleSqlStatement( lpSql );
; 2674 : 
; 2675 :    return( nRC );
; 2676 : 
; 2677 : #endif
; 2678 : 
; 2679 :    }
; 2680 : 
; 2681 :    return( FALSE );
; 2682 : 
; 2683 : #endif
; 2684 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlBuildDeleteAll@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -1908					; size = 4
_nRC$ = -1904						; size = 2
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_pchSqlCmd$ = 20					; size = 4
_lpBoundList$ = 24					; size = 4
_SqlBuildDelete@20 PROC

; 2481 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1908				; 00000774H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2482 :    LPDATARECORD lpDataRecord;
; 2483 :    LPSQLSTATEMENT lpSql;
; 2484 :    SqlStatementRecord SqlStatement;
; 2485 :    zSHORT       nRC;
; 2486 : 
; 2487 :    lpSql = &SqlStatement;

	lea	eax, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 2488 :    fnSqlInitSqlStatement( lpSql, zDELETE_CMD, pchSqlCmd, lpView, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 2489 : 
; 2490 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2491 : 
; 2492 :    fnSqlAddStringToSql( lpSql, "DELETE FROM " );

	push	OFFSET $SG12348
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2493 :    fnSqlAddStringToSql( lpSql, lpDataRecord->szRecordName );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2494 :    fnSqlAddStringToSql( lpSql, " " );

	push	OFFSET $SG12349
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2495 : 
; 2496 :    nRC = fnSqlBuildWhere( lpView, lpViewOD, lpViewEntity, lpSql, 0 );

	push	0
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlBuildWhere
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2497 : 
; 2498 :    fnSqlAssembleSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 2499 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2500 : }  /* SqlBuildDelete */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlBuildDelete@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpAttribFlags$1 = -1928				; size = 4
_lpDataRecord$ = -1924					; size = 4
_lpViewAttrib$ = -1920					; size = 4
_lpRelRecord$ = -1916					; size = 4
_lpRelField$ = -1912					; size = 4
_lpDataField$ = -1908					; size = 4
_bUpdatedOnly$ = -1901					; size = 1
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_pchSqlCmd$ = 20					; size = 4
_lpBoundList$ = 24					; size = 4
_SqlBuildUpdateCorrTable@20 PROC

; 2378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1928				; 00000788H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2379 :    LPDATARECORD lpDataRecord;
; 2380 :    LPDATAFIELD  lpDataField;
; 2381 :    LPRELRECORD  lpRelRecord;
; 2382 :    LPRELFIELD   lpRelField;
; 2383 :    LPVIEWATTRIB lpViewAttrib;
; 2384 :    LPSQLSTATEMENT lpSql;
; 2385 :    SqlStatementRecord SqlStatement;
; 2386 :    zBOOL        bUpdatedOnly;
; 2387 : 
; 2388 :    // Since we can only update a corr table if it has auto seq attributes,
; 2389 :    // exit if there are no seq attributes for the entity.
; 2390 :    if ( lpViewEntity->bAutoSeq == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 20					; 00000014H
	and	ecx, 1
	jne	SHORT $LN6@SqlBuildUp

; 2391 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SqlBuildUp
$LN6@SqlBuildUp:

; 2392 : 
; 2393 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2394 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 2395 :    if ( lpRelRecord == 0 )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	jne	SHORT $LN7@SqlBuildUp

; 2396 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SqlBuildUp
$LN7@SqlBuildUp:

; 2397 : 
; 2398 :    if ( lpRelRecord->cOwnerMember != zDBH_MANY_TO_MANY )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	je	SHORT $LN8@SqlBuildUp

; 2399 :       return( -1 );

	or	eax, -1
	jmp	$LN1@SqlBuildUp
$LN8@SqlBuildUp:

; 2400 : 
; 2401 :    lpSql = &SqlStatement;

	lea	edx, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], edx

; 2402 :    fnSqlInitSqlStatement( lpSql, zUPDATE_CMD | zCORR_CMD, pchSqlCmd,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSqlCmd$[ebp]
	push	edx
	push	4112					; 00001010H
	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 2403 :                           lpView, lpBoundList );
; 2404 : 
; 2405 :    fnSqlAddStringToSql( lpSql, "UPDATE " );

	push	OFFSET $SG12317
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2406 :    fnSqlAddStringToSql( lpSql, lpRelRecord->szRecordName );

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2407 : 
; 2408 :    // Check to see if we should only updating changed attributes.
; 2409 :    if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_UPDATEDONLY ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN9@SqlBuildUp
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	and	ecx, 16777216				; 01000000H
	je	SHORT $LN9@SqlBuildUp

; 2410 :       bUpdatedOnly = TRUE;

	mov	BYTE PTR _bUpdatedOnly$[ebp], 1
	jmp	SHORT $LN10@SqlBuildUp
$LN9@SqlBuildUp:

; 2411 :    else
; 2412 :       bUpdatedOnly = FALSE;

	mov	BYTE PTR _bUpdatedOnly$[ebp], 0
$LN10@SqlBuildUp:

; 2413 : 
; 2414 :    // First create "SET col = val" clause for AutoSeq attribute.
; 2415 :    // I know we already check for bAutoSeq, but I'm leaving the IF statment
; 2416 :    // here in case we need it in the future.
; 2417 :    if ( lpViewEntity->bAutoSeq )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	je	$LN11@SqlBuildUp

; 2418 :    {
; 2419 :       // Find the Autoseq attribute.
; 2420 :       lpDataField  = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 2421 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN2@SqlBuildUp:

; 2422 :       while ( lpViewAttrib->bAutoSeq == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN3@SqlBuildUp

; 2423 :       {
; 2424 :          lpDataField  = zGETPTR( lpDataField->hNextDataField );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 2425 :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2426 :       }

	jmp	SHORT $LN2@SqlBuildUp
$LN3@SqlBuildUp:

; 2427 : 
; 2428 :       // Check to see if we only want updated attributes (for INSERT).
; 2429 :       if ( bUpdatedOnly )

	movzx	edx, BYTE PTR _bUpdatedOnly$[ebp]
	test	edx, edx
	je	SHORT $LN12@SqlBuildUp

; 2430 :       {
; 2431 :          LPATTRIBFLAGS lpAttribFlags;
; 2432 : 
; 2433 :          GetAttributeFlags( &lpAttribFlags, lpSql->lpView,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	lea	ecx, DWORD PTR _lpAttribFlags$1[ebp]
	push	ecx
	call	_GetAttributeFlags@16

; 2434 :                             lpViewEntity, lpViewAttrib );
; 2435 : 
; 2436 :          // If the attribute hasn't been updated then forget it.
; 2437 :          if ( lpAttribFlags->u.bFlags.bUpdated == FALSE )

	mov	edx, DWORD PTR _lpAttribFlags$1[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN12@SqlBuildUp

; 2438 :             return( -1 );

	or	eax, -1
	jmp	$LN1@SqlBuildUp
$LN12@SqlBuildUp:

; 2439 :       }
; 2440 : 
; 2441 :       fnSqlAddStringToSql( lpSql, " SET " );

	push	OFFSET $SG12323
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2442 :       fnSqlAddStringToSql( lpSql, lpDataField->szFldName );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2443 :       fnSqlAddStringToSql( lpSql, " = " );

	push	OFFSET $SG12324
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2444 :       fnSqlGetAttributeValue( lpView, lpDataField, lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
$LN11@SqlBuildUp:

; 2445 : 
; 2446 :    } // if ( lpViewEntity->bAutoSeq )...
; 2447 : 
; 2448 :    // Build WHERE clause.
; 2449 :    fnSqlAddStringToSql( lpSql, " WHERE ( " );

	push	OFFSET $SG12325
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 2450 :    lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN4@SqlBuildUp:

; 2451 :    while ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN5@SqlBuildUp

; 2452 :    {
; 2453 :       fnSqlAddStringToSql( lpSql, lpRelField->szFldName );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2454 :       fnSqlAddStringToSql( lpSql, " = " );

	push	OFFSET $SG12326
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2455 : 
; 2456 :       fnSqlGetAttributeValue( lpView, zGETPTR( lpRelField->hSrcDataField ),

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH

; 2457 :                               lpSql );
; 2458 : 
; 2459 :       lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax

; 2460 :       if ( lpRelRecord )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	SHORT $LN14@SqlBuildUp

; 2461 :          fnSqlAddStringToSql( lpSql, " AND " );

	push	OFFSET $SG12328
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi
$LN14@SqlBuildUp:

; 2462 :    }

	jmp	$LN4@SqlBuildUp
$LN5@SqlBuildUp:

; 2463 : 
; 2464 :    fnSqlAddStringToSql( lpSql, " )" );

	push	OFFSET $SG12329
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2465 : 
; 2466 :    fnSqlAssembleSqlStatement( lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 2467 :    return( 0 );

	xor	eax, eax
$LN1@SqlBuildUp:

; 2468 : }  /* SqlBuildUpdateCorrTable */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlBuildUpdateCorrTable@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpAttribFlags$1 = -1920				; size = 4
_lpDataRecord$ = -1916					; size = 4
_lpDataField$ = -1912					; size = 4
_lpViewAttrib$ = -1908					; size = 4
_bAttribUpdated$ = -1903				; size = 1
_bFirstTime$ = -1902					; size = 1
_bUpdatedOnly$ = -1901					; size = 1
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_bAutoSeqOnly$ = 20					; size = 2
_pchSqlCmd$ = 24					; size = 4
_lpBoundList$ = 28					; size = 4
_SqlBuildUpdate@24 PROC

; 2255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1920				; 00000780H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2256 :    zBOOL          bFirstTime;
; 2257 :    zBOOL          bAttribUpdated;
; 2258 :    zBOOL          bUpdatedOnly;
; 2259 :    LPDATARECORD   lpDataRecord;
; 2260 :    LPDATAFIELD    lpDataField;
; 2261 :    LPVIEWATTRIB   lpViewAttrib;
; 2262 :    LPSQLSTATEMENT lpSql;
; 2263 :    SqlStatementRecord SqlStatement;
; 2264 : 
; 2265 :    lpSql = &SqlStatement;

	lea	eax, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 2266 :    fnSqlInitSqlStatement( lpSql, zUPDATE_CMD, pchSqlCmd, lpView, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 2267 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2268 : 
; 2269 :    fnSqlAddStringToSql( lpSql, "UPDATE " );

	push	OFFSET $SG12261
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2270 :    fnSqlAddStringToSql( lpSql, lpDataRecord->szRecordName );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2271 : 
; 2272 :    // Check to see if we should only updating changed attributes.
; 2273 :    if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_UPDATEDONLY ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN5@SqlBuildUp
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	and	ecx, 16777216				; 01000000H
	je	SHORT $LN5@SqlBuildUp

; 2274 :       bUpdatedOnly = TRUE;

	mov	BYTE PTR _bUpdatedOnly$[ebp], 1
	jmp	SHORT $LN6@SqlBuildUp
$LN5@SqlBuildUp:

; 2275 :    else
; 2276 :       bUpdatedOnly = FALSE;

	mov	BYTE PTR _bUpdatedOnly$[ebp], 0
$LN6@SqlBuildUp:

; 2277 : 
; 2278 :    // First create "Set col = val [, ...]" clause.
; 2279 :    bFirstTime     = TRUE;

	mov	BYTE PTR _bFirstTime$[ebp], 1

; 2280 :    bAttribUpdated = FALSE;

	mov	BYTE PTR _bAttribUpdated$[ebp], 0

; 2281 :    for ( lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN4@SqlBuildUp
$LN2@SqlBuildUp:

; 2283 :          lpDataField = zGETPTR( lpDataField->hNextDataField ) )

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@SqlBuildUp:

; 2282 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN3@SqlBuildUp

; 2284 :    {
; 2285 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2286 : 
; 2287 :       // If this update is for autosequence fields only and the attribute is
; 2288 :       // not an autoseq attribute then do nothing for this attribute.
; 2289 :       if ( bAutoSeqOnly && lpViewAttrib->bAutoSeq == FALSE )

	movsx	edx, WORD PTR _bAutoSeqOnly$[ebp]
	test	edx, edx
	je	SHORT $LN7@SqlBuildUp
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN7@SqlBuildUp

; 2290 :          continue;

	jmp	SHORT $LN2@SqlBuildUp
$LN7@SqlBuildUp:

; 2291 : 
; 2292 :       // Update only persistent attributes.
; 2293 :       if ( lpViewAttrib->bPersist == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	jne	SHORT $LN8@SqlBuildUp

; 2294 :          continue;

	jmp	SHORT $LN2@SqlBuildUp
$LN8@SqlBuildUp:

; 2295 : 
; 2296 :       // No updating keys!
; 2297 :       if ( lpViewAttrib->bKey )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN9@SqlBuildUp

; 2298 :          continue;

	jmp	SHORT $LN2@SqlBuildUp
$LN9@SqlBuildUp:

; 2299 : 
; 2300 :       // Check to see if we only want updated attributes (for INSERT).
; 2301 :       if ( bUpdatedOnly )

	movzx	eax, BYTE PTR _bUpdatedOnly$[ebp]
	test	eax, eax
	je	SHORT $LN10@SqlBuildUp

; 2302 :       {
; 2303 :          LPATTRIBFLAGS lpAttribFlags;
; 2304 : 
; 2305 :          GetAttributeFlags( &lpAttribFlags, lpSql->lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	lea	edx, DWORD PTR _lpAttribFlags$1[ebp]
	push	edx
	call	_GetAttributeFlags@16

; 2306 :                             lpViewEntity, lpViewAttrib );
; 2307 : 
; 2308 :          // If the attribute hasn't been updated then forget it.
; 2309 :          if ( lpAttribFlags->u.bFlags.bUpdated == FALSE )

	mov	eax, DWORD PTR _lpAttribFlags$1[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN12@SqlBuildUp

; 2310 :             continue;

	jmp	$LN2@SqlBuildUp
$LN12@SqlBuildUp:

; 2311 : 
; 2312 :          // If we get here then an attribute will be updated.
; 2313 :          bAttribUpdated = TRUE;

	mov	BYTE PTR _bAttribUpdated$[ebp], 1

; 2314 :       }

	jmp	SHORT $LN11@SqlBuildUp
$LN10@SqlBuildUp:

; 2315 :       else
; 2316 :       {
; 2317 :          // If the attribute is hidden then skip it UNLESS the attribute is a:
; 2318 :          //    o Foreign key.
; 2319 :          //    o Sequence attribute.
; 2320 :          if ( lpViewAttrib->bHidden &&

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN11@SqlBuildUp
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 2
	and	edx, 1
	jne	SHORT $LN11@SqlBuildUp
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN11@SqlBuildUp

; 2321 :               !( lpViewAttrib->bForeignKey || lpViewAttrib->bAutoSeq ) )
; 2322 :             continue;

	jmp	$LN2@SqlBuildUp
$LN11@SqlBuildUp:

; 2323 :       }
; 2324 : 
; 2325 :       if ( bFirstTime )

	movzx	edx, BYTE PTR _bFirstTime$[ebp]
	test	edx, edx
	je	SHORT $LN14@SqlBuildUp

; 2326 :       {
; 2327 :          fnSqlAddStringToSql( lpSql, " SET " );

	push	OFFSET $SG12273
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2328 :          bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$[ebp], 0

; 2329 :       }

	jmp	SHORT $LN15@SqlBuildUp
$LN14@SqlBuildUp:

; 2330 :       else
; 2331 :          fnSqlAddStringToSql( lpSql, " , " );

	push	OFFSET $SG12274
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi
$LN15@SqlBuildUp:

; 2332 : 
; 2333 :       fnSqlAddStringToSql( lpSql, lpDataField->szFldName );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 2334 :       fnSqlAddStringToSql( lpSql, " = " );

	push	OFFSET $SG12275
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2335 : 
; 2336 :       // Insert the text value of the attribute.  It is possible that instead
; 2337 :       // of the value we will insert a place-holder for bound attributes.
; 2338 :       fnSqlGetAttributeValue( lpView, lpDataField, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH

; 2339 : 
; 2340 :    } // for ( lpDataField )...

	jmp	$LN2@SqlBuildUp
$LN3@SqlBuildUp:

; 2341 : 
; 2342 :    fnSqlAddStringToSql( lpSql, " " );

	push	OFFSET $SG12276
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2343 :    if ( fnSqlBuildWhere( lpView, lpViewOD, lpViewEntity,
; 2344 :                          lpSql, 0 ) == zCALL_ERROR )

	push	0
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlBuildWhere
	add	esp, 20					; 00000014H
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN16@SqlBuildUp

; 2345 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SqlBuildUp
$LN16@SqlBuildUp:

; 2346 : 
; 2347 :    fnSqlAssembleSqlStatement( lpSql );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 2348 : 
; 2349 :    // If no attributes were updated then return -1.
; 2350 :    if ( bUpdatedOnly && bAttribUpdated == FALSE )

	movzx	edx, BYTE PTR _bUpdatedOnly$[ebp]
	test	edx, edx
	je	SHORT $LN17@SqlBuildUp
	movzx	eax, BYTE PTR _bAttribUpdated$[ebp]
	test	eax, eax
	jne	SHORT $LN17@SqlBuildUp

; 2351 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@SqlBuildUp
$LN17@SqlBuildUp:

; 2352 : 
; 2353 :    // Return 1 if columns need to be bound, 0 if not.
; 2354 :    if ( lpBoundList->nBoundCount > 0 )

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	movsx	edx, WORD PTR [ecx+4]
	test	edx, edx
	jle	SHORT $LN18@SqlBuildUp

; 2355 :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@SqlBuildUp
$LN18@SqlBuildUp:

; 2356 : 
; 2357 :    return( 0 );

	xor	eax, eax
$LN1@SqlBuildUp:

; 2358 : 
; 2359 : }  /* SqlBuildUpdate */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SqlBuildUpdate@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpViewAttrib$ = -1920					; size = 4
_lpDataRecord$ = -1916					; size = 4
_lpRelRecord$ = -1912					; size = 4
_lpDataField$ = -1908					; size = 4
_lpRelField$ = -1904					; size = 4
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_pchSqlCmd$ = 20					; size = 4
_lpBoundList$ = 24					; size = 4
_SqlBuildInsertCorrTable@20 PROC

; 2161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1920				; 00000780H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2162 :    LPVIEWATTRIB   lpViewAttrib;
; 2163 :    LPDATARECORD   lpDataRecord;
; 2164 :    LPDATAFIELD    lpDataField;
; 2165 :    LPRELRECORD    lpRelRecord;
; 2166 :    LPRELFIELD     lpRelField;
; 2167 :    LPSQLSTATEMENT lpSql;
; 2168 :    SqlStatementRecord SqlStatement;
; 2169 : 
; 2170 :    lpSql = &SqlStatement;

	lea	eax, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 2171 :    fnSqlInitSqlStatement( lpSql, zINSERT_CMD | zCORR_CMD, pchSqlCmd,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	push	4100					; 00001004H
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 2172 :                           lpView, lpBoundList );
; 2173 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2174 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 2175 : 
; 2176 :    fnSqlAddStringToSql( lpSql, "INSERT INTO " );

	push	OFFSET $SG12215
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2177 :    fnSqlAddStringToSql( lpSql, lpRelRecord->szRecordName );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	add	edx, 11					; 0000000bH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2178 :    fnSqlAddStringToSql( lpSql, " ( " );

	push	OFFSET $SG12216
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 2179 : 
; 2180 :    // Add list of corr table column names to sql cmd.
; 2181 :    lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN2@SqlBuildIn:

; 2182 :    while ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN3@SqlBuildIn

; 2183 :    {
; 2184 :       fnSqlAddStringToSql( lpSql, lpRelField->szFldName );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2185 : 
; 2186 :       lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax

; 2187 :       if ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	SHORT $LN8@SqlBuildIn

; 2188 :          fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG12218
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi
$LN8@SqlBuildIn:

; 2189 :    }

	jmp	$LN2@SqlBuildIn
$LN3@SqlBuildIn:

; 2190 : 
; 2191 :    // If the entity has a seq attribute, that also must be inserted.
; 2192 :    if ( lpViewEntity->bAutoSeq )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 20					; 00000014H
	and	edx, 1
	je	$LN9@SqlBuildIn

; 2193 :    {
; 2194 :       lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN4@SqlBuildIn:

; 2195 :       while ( lpDataField )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN5@SqlBuildIn

; 2196 :       {
; 2197 :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2198 :          if ( lpViewAttrib->bAutoSeq )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN11@SqlBuildIn

; 2199 :          {
; 2200 :             fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG12222
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2201 :             fnSqlAddStringToSql( lpSql, lpDataField->szFldName );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2202 :             break;  // Only 1 seq per entity, so break out.

	jmp	SHORT $LN5@SqlBuildIn
$LN11@SqlBuildIn:

; 2203 :          }
; 2204 : 
; 2205 :          lpDataField = zGETPTR( lpDataField->hNextDataField );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 2206 :       } // while ( lpDataField )...

	jmp	$LN4@SqlBuildIn
$LN5@SqlBuildIn:

; 2207 :    } // if ( lpViewEntity->bAutoSeq )...

	jmp	SHORT $LN10@SqlBuildIn
$LN9@SqlBuildIn:

; 2208 :    else
; 2209 :       lpDataField = 0;

	mov	DWORD PTR _lpDataField$[ebp], 0
$LN10@SqlBuildIn:

; 2210 : 
; 2211 :    fnSqlAddStringToSql( lpSql, " ) VALUES ( " );

	push	OFFSET $SG12223
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2212 : 
; 2213 :    // Add list of corr table column values to sql cmd.
; 2214 :    lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN6@SqlBuildIn:

; 2215 :    while ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	SHORT $LN7@SqlBuildIn

; 2216 :    {
; 2217 :       fnSqlGetAttributeValue( lpView, zGETPTR( lpRelField->hSrcDataField ),

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH

; 2218 :                               lpSql );
; 2219 : 
; 2220 :       lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelField$[ebp], eax

; 2221 :       if ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	SHORT $LN12@SqlBuildIn

; 2222 :          fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG12225
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi
$LN12@SqlBuildIn:

; 2223 :    }

	jmp	$LN6@SqlBuildIn
$LN7@SqlBuildIn:

; 2224 : 
; 2225 :    // If a seq attribute was found earlier then add it to insert.
; 2226 :    if ( lpDataField )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	SHORT $LN13@SqlBuildIn

; 2227 :    {
; 2228 :       fnSqlAddStringToSql( lpSql, ", " );

	push	OFFSET $SG12227
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2229 :       fnSqlGetAttributeValue( lpView, lpDataField, lpSql );

	mov	eax, DWORD PTR _lpSql$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSqlGetAttributeValue
	add	esp, 12					; 0000000cH
$LN13@SqlBuildIn:

; 2230 :    }
; 2231 : 
; 2232 :    fnSqlAddStringToSql( lpSql, " )" );

	push	OFFSET $SG12228
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2233 : 
; 2234 :    fnSqlAssembleSqlStatement( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnSqlAssembleSqlStatement
	add	esp, 4

; 2235 :    return( 0 );

	xor	eax, eax

; 2236 : }  /* SqlBuildInsertCorrTable */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlBuildInsertCorrTable@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lpDataRecord$ = -1912					; size = 4
_nFlag$ = -1908						; size = 2
_nRC$ = -1904						; size = 2
_lpSql$ = -1900						; size = 4
_SqlStatement$ = -1896					; size = 1890
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_pchSqlCmd$ = 20					; size = 4
_lpBoundList$ = 24					; size = 4
_SqlBuildInsert@20 PROC

; 2108 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1912				; 00000778H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 2109 :    LPDATARECORD   lpDataRecord;
; 2110 :    LPSQLSTATEMENT lpSql;
; 2111 :    SqlStatementRecord SqlStatement;
; 2112 :    zSHORT         nFlag;
; 2113 :    zSHORT         nRC;
; 2114 : 
; 2115 :    lpSql = &SqlStatement;

	lea	eax, DWORD PTR _SqlStatement$[ebp]
	mov	DWORD PTR _lpSql$[ebp], eax

; 2116 :    fnSqlInitSqlStatement( lpSql, zINSERT_CMD, pchSqlCmd, lpView, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchSqlCmd$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlInitSqlStatement
	add	esp, 20					; 00000014H

; 2117 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2118 : 
; 2119 :    fnSqlAddStringToSql( lpSql, "INSERT INTO " );

	push	OFFSET $SG12172
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2120 :    fnSqlAddStringToSql( lpSql, lpDataRecord->szRecordName );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [edx+16], esi

; 2121 :    fnSqlAddStringToSql( lpSql, " ( " );

	push	OFFSET $SG12173
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2122 : 
; 2123 :    // Check to see if we should only inserted updated attributes.
; 2124 :    if ( CHECK_CALLBACK_FLAG( zSQLCALLBACK_UPDATEDONLY ) )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	SHORT $LN2@SqlBuildIn
	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+14]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN2@SqlBuildIn

; 2125 :       nFlag = zUPDATED_ONLY;

	mov	ecx, 8
	mov	WORD PTR _nFlag$[ebp], cx
	jmp	SHORT $LN3@SqlBuildIn
$LN2@SqlBuildIn:

; 2126 :    else
; 2127 :       nFlag = 0;

	xor	edx, edx
	mov	WORD PTR _nFlag$[ebp], dx
$LN3@SqlBuildIn:

; 2128 : 
; 2129 :    nRC = fnSqlBuildColumnList( lpViewEntity, lpSql, nFlag );

	movzx	eax, WORD PTR _nFlag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	_fnSqlBuildColumnList
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2130 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN4@SqlBuildIn

; 2131 :    {
; 2132 :       fnSqlFreeSqlStatement ( lpSql );

	mov	ecx, DWORD PTR _lpSql$[ebp]
	push	ecx
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 2133 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SqlBuildIn
$LN4@SqlBuildIn:

; 2134 :    }
; 2135 : 
; 2136 :    fnSqlAddStringToSql( lpSql, " ) VALUES ( " );

	push	OFFSET $SG12177
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [eax+16], esi

; 2137 :    nRC = fnSqlBuildColumnValueList( lpViewEntity, lpSql, nFlag );

	movzx	ecx, WORD PTR _nFlag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_fnSqlBuildColumnValueList
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2138 :    if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN5@SqlBuildIn

; 2139 :    {
; 2140 :       fnSqlFreeSqlStatement ( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 2141 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SqlBuildIn
$LN5@SqlBuildIn:

; 2142 :    }
; 2143 : 
; 2144 :    fnSqlAddStringToSql( lpSql, " )" );

	push	OFFSET $SG12179
	mov	eax, DWORD PTR _lpSql$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_strcat
	add	esp, 8
	mov	esi, eax
	mov	edx, DWORD PTR _lpSql$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	ecx, DWORD PTR _lpSql$[ebp]
	mov	DWORD PTR [ecx+16], esi

; 2145 : 
; 2146 :    fnSqlFreeSqlStatement( lpSql );

	mov	edx, DWORD PTR _lpSql$[ebp]
	push	edx
	call	_fnSqlFreeSqlStatement
	add	esp, 4

; 2147 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SqlBuildIn:

; 2148 : }  /* SqlBuildInsert */

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlBuildInsert@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lHandle$ = -8						; size = 4
_lpBoundList$ = -4					; size = 4
_plpBoundList$ = 8					; size = 4
_pchEntityJoinTable$ = 12				; size = 4
_pfnCallback$ = 16					; size = 4
_lFuncs$ = 20						; size = 4
_pvPtr$ = 24						; size = 4
_SqlInitBoundAttrList@20 PROC

; 7235 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7236 :    zLONG       lHandle;
; 7237 :    LPBOUNDLIST lpBoundList;
; 7238 : 
; 7239 :    lHandle = SysAllocMemory( (zCOREMEM) plpBoundList,

	push	0
	push	32768					; 00008000H
	push	0
	push	26					; 0000001aH
	mov	eax, DWORD PTR _plpBoundList$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _lHandle$[ebp], eax

; 7240 :                              sizeof( BoundAttrListRecord ), 0,
; 7241 :                              zCOREMEM_ALLOC, 0 );
; 7242 : // TraceLine( "SqlInitBoundAttrList allocating memory: 0x%08x  for %d bytes",
; 7243 : //            lHandle, sizeof( BoundAttrListRecord ) );
; 7244 : 
; 7245 :    lpBoundList = *plpBoundList;

	mov	ecx, DWORD PTR _plpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpBoundList$[ebp], edx

; 7246 :    zmemset( lpBoundList, 0, sizeof( BoundAttrListRecord ) );

	push	26					; 0000001aH
	push	0
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 7247 : 
; 7248 :    lpBoundList->hMemory            = lHandle;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR _lHandle$[ebp]
	mov	DWORD PTR [ecx], edx

; 7249 :    lpBoundList->nBoundCount        = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	WORD PTR [ecx+4], ax

; 7250 :    lpBoundList->lpFirstBoundAttr   = 0;

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	DWORD PTR [edx+6], 0

; 7251 :    lpBoundList->pfnCallback        = pfnCallback;

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR _pfnCallback$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 7252 :    lpBoundList->lFuncs             = lFuncs;

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR _lFuncs$[ebp]
	mov	DWORD PTR [edx+14], eax

; 7253 :    lpBoundList->pchEntityJoinTable = pchEntityJoinTable;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR _pchEntityJoinTable$[ebp]
	mov	DWORD PTR [ecx+18], edx

; 7254 :    lpBoundList->pvPtr              = pvPtr;

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR _pvPtr$[ebp]
	mov	DWORD PTR [eax+22], ecx

; 7255 : 
; 7256 :    return( TRUE );

	mov	al, 1

; 7257 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlInitBoundAttrList@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lHMemHandle$ = -12					; size = 4
_lpPrevBound$1 = -8					; size = 4
_lpBoundAttr$ = -4					; size = 4
_lpBoundList$ = 8					; size = 4
_lpDataField$ = 12					; size = 4
_lpView$ = 16						; size = 4
_pchValue$ = 20						; size = 4
_lHMemValue$ = 24					; size = 4
_SqlAddBoundAttr@20 PROC

; 7271 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 7272 :    LPBOUNDATTR lpBoundAttr = 0;

	mov	DWORD PTR _lpBoundAttr$[ebp], 0

; 7273 :    zLONG       lHMemHandle;
; 7274 : 
; 7275 :    lHMemHandle = SysAllocMemory( (zPVOID) &lpBoundAttr, sizeof( BoundAttr ),

	push	0
	push	32768					; 00008000H
	push	0
	push	24					; 00000018H
	lea	eax, DWORD PTR _lpBoundAttr$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _lHMemHandle$[ebp], eax

; 7276 :                                  0, zCOREMEM_ALLOC, 0 );
; 7277 : 
; 7278 :    if ( lpBoundAttr == 0 )

	cmp	DWORD PTR _lpBoundAttr$[ebp], 0
	jne	SHORT $LN5@SqlAddBoun

; 7279 :       return( FALSE );

	xor	al, al
	jmp	$LN1@SqlAddBoun
$LN5@SqlAddBoun:

; 7280 : 
; 7281 :    lpBoundAttr->lpDataField     = lpDataField;

	mov	ecx, DWORD PTR _lpBoundAttr$[ebp]
	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR [ecx], edx

; 7282 :    lpBoundAttr->lpView          = lpView;

	mov	eax, DWORD PTR _lpBoundAttr$[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 7283 :    lpBoundAttr->lHMemHandle     = lHMemHandle;

	mov	edx, DWORD PTR _lpBoundAttr$[ebp]
	mov	eax, DWORD PTR _lHMemHandle$[ebp]
	mov	DWORD PTR [edx+12], eax

; 7284 :    lpBoundAttr->lHMemValue      = lHMemValue;

	mov	ecx, DWORD PTR _lpBoundAttr$[ebp]
	mov	edx, DWORD PTR _lHMemValue$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 7285 :    lpBoundAttr->pszValue        = pchValue;

	mov	eax, DWORD PTR _lpBoundAttr$[ebp]
	mov	ecx, DWORD PTR _pchValue$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 7286 :    lpBoundAttr->lpNextBoundAttr = 0;

	mov	edx, DWORD PTR _lpBoundAttr$[ebp]
	mov	DWORD PTR [edx+8], 0

; 7287 : 
; 7288 :    // If the list currently has no entries then just add the current one.
; 7289 :    if ( lpBoundList->lpFirstBoundAttr == 0 )

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+6], 0
	jne	SHORT $LN6@SqlAddBoun

; 7290 :       lpBoundList->lpFirstBoundAttr = lpBoundAttr;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR _lpBoundAttr$[ebp]
	mov	DWORD PTR [ecx+6], edx
	jmp	SHORT $LN7@SqlAddBoun
$LN6@SqlAddBoun:

; 7291 :    else
; 7292 :    {
; 7293 :       LPBOUNDATTR lpPrevBound;
; 7294 : 
; 7295 :       // Find the end of the list and add the current lpBoundAttr to the end.
; 7296 : 
; 7297 :       for ( lpPrevBound = lpBoundList->lpFirstBoundAttr;

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR _lpPrevBound$1[ebp], ecx
	jmp	SHORT $LN4@SqlAddBoun
$LN2@SqlAddBoun:

; 7299 :             lpPrevBound = lpPrevBound->lpNextBoundAttr )

	mov	edx, DWORD PTR _lpPrevBound$1[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _lpPrevBound$1[ebp], eax
$LN4@SqlAddBoun:

; 7298 :             lpPrevBound->lpNextBoundAttr;

	mov	ecx, DWORD PTR _lpPrevBound$1[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN3@SqlAddBoun

; 7300 :       {
; 7301 :          ; // Nothing needs to be done here.
; 7302 :       }

	jmp	SHORT $LN2@SqlAddBoun
$LN3@SqlAddBoun:

; 7303 : 
; 7304 :       lpPrevBound->lpNextBoundAttr = lpBoundAttr;

	mov	edx, DWORD PTR _lpPrevBound$1[ebp]
	mov	eax, DWORD PTR _lpBoundAttr$[ebp]
	mov	DWORD PTR [edx+8], eax
$LN7@SqlAddBoun:

; 7305 :    }
; 7306 : 
; 7307 :    lpBoundList->nBoundCount++;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	dx, WORD PTR [ecx+4]
	add	dx, 1
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	WORD PTR [eax+4], dx

; 7308 : 
; 7309 :    return( TRUE );

	mov	al, 1
$LN1@SqlAddBoun:

; 7310 : 
; 7311 : } // SqlAddBoundAttr

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SqlAddBoundAttr@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlga.c
_TEXT	SEGMENT
_lHMemHandle$ = -8					; size = 4
_lpNextBound$ = -4					; size = 4
_lpBoundList$ = 8					; size = 4
_SqlFreeBoundAttrList@4 PROC

; 7317 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7318 :    LPBOUNDATTR lpNextBound;
; 7319 :    zLONG       lHMemHandle;
; 7320 : 
; 7321 :    if ( lpBoundList == 0 )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	jne	SHORT $LN5@SqlFreeBou

; 7322 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SqlFreeBou
$LN5@SqlFreeBou:

; 7323 : 
; 7324 :    if ( lpBoundList->lpFirstBoundAttr )

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN6@SqlFreeBou

; 7325 :    {
; 7326 :       lpNextBound = lpBoundList->lpFirstBoundAttr;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _lpNextBound$[ebp], edx
$LN4@SqlFreeBou:

; 7327 : 
; 7328 :       do
; 7329 :       {
; 7330 :          if ( lpNextBound->lHMemValue )

	mov	eax, DWORD PTR _lpNextBound$[ebp]
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN7@SqlFreeBou

; 7331 :          {
; 7332 :             SysFreeMemory( lpNextBound->lHMemValue );

	mov	ecx, DWORD PTR _lpNextBound$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_SysFreeMemory@4
$LN7@SqlFreeBou:

; 7333 :          // TraceLine( "SqlFreeBoundAttrList freeing lHMemValue: 0x%08x",
; 7334 :          //            lpNextBound->lHMemValue );
; 7335 :          }
; 7336 : 
; 7337 :          lHMemHandle = lpNextBound->lHMemHandle;

	mov	eax, DWORD PTR _lpNextBound$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lHMemHandle$[ebp], ecx

; 7338 :          lpNextBound = lpNextBound->lpNextBoundAttr;

	mov	edx, DWORD PTR _lpNextBound$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _lpNextBound$[ebp], eax

; 7339 : 
; 7340 :       // TraceLine( "SqlFreeBoundAttrList freeing lHMemHandle: 0x%08x",
; 7341 :       //            lHMemHandle );
; 7342 :          SysFreeMemory( lHMemHandle );

	mov	ecx, DWORD PTR _lHMemHandle$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 7343 : 
; 7344 :       } while ( lpNextBound );

	cmp	DWORD PTR _lpNextBound$[ebp], 0
	jne	SHORT $LN4@SqlFreeBou
$LN6@SqlFreeBou:

; 7345 :    }
; 7346 : 
; 7347 : // TraceLine( "SqlFreeBoundAttrList freeing lpBoundList hMemory: 0x%08x",
; 7348 : //            lpBoundList->hMemory );
; 7349 :    SysFreeMemory( lpBoundList->hMemory );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SysFreeMemory@4

; 7350 : 
; 7351 :    return( 0 );

	xor	eax, eax
$LN1@SqlFreeBou:

; 7352 : 
; 7353 : } // SqlFreeBoundAttrList

	mov	esp, ebp
	pop	ebp
	ret	4
_SqlFreeBoundAttrList@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
