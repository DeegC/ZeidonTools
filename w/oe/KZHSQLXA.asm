; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\a\oe\KZHSQLXA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_bHoldStmtHandles
PUBLIC	_g_DefaultODBC_Data
PUBLIC	_g_lpOdbcSystemInfo
_BSS	SEGMENT
$SG95232 DB	01H DUP (?)
	ALIGN	4

$SG95259 DB	01H DUP (?)
	ALIGN	4

$SG95261 DB	01H DUP (?)
	ALIGN	4

$SG95280 DB	01H DUP (?)
	ALIGN	4

$SG95281 DB	01H DUP (?)
	ALIGN	4

$SG95468 DB	01H DUP (?)
	ALIGN	4

$SG95469 DB	01H DUP (?)
	ALIGN	4

$SG95470 DB	01H DUP (?)
	ALIGN	4

_g_lpOdbcSystemInfo DD 01H DUP (?)
$SG95506 DB	01H DUP (?)
	ALIGN	4

$SG95507 DB	01H DUP (?)
	ALIGN	4

$SG95508 DB	01H DUP (?)
	ALIGN	4

$SG95513 DB	01H DUP (?)
	ALIGN	4

$SG95515 DB	01H DUP (?)
	ALIGN	4

$SG95539 DB	01H DUP (?)
	ALIGN	4

$SG95540 DB	01H DUP (?)
	ALIGN	4

$SG95541 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_lCurrentProcessID:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG95570 DB	01H DUP (?)
	ALIGN	4

$SG95571 DB	01H DUP (?)
	ALIGN	4

$SG95572 DB	01H DUP (?)
	ALIGN	4

$SG95601 DB	01H DUP (?)
	ALIGN	4

$SG95602 DB	01H DUP (?)
	ALIGN	4

$SG95603 DB	01H DUP (?)
	ALIGN	4

$SG95630 DB	01H DUP (?)
	ALIGN	4

$SG95636 DB	01H DUP (?)
	ALIGN	4

$SG94658 DB	01H DUP (?)
	ALIGN	4

$SG95684 DB	01H DUP (?)
	ALIGN	4

$SG95685 DB	01H DUP (?)
	ALIGN	4

$SG95687 DB	01H DUP (?)
	ALIGN	4

$SG95688 DB	01H DUP (?)
	ALIGN	4

$SG94665 DB	01H DUP (?)
	ALIGN	4

$SG94671 DB	01H DUP (?)
	ALIGN	4

$SG94719 DB	01H DUP (?)
	ALIGN	4

$SG94726 DB	01H DUP (?)
	ALIGN	4

$SG94739 DB	01H DUP (?)
	ALIGN	4

$SG94740 DB	01H DUP (?)
	ALIGN	4

$SG94776 DB	01H DUP (?)
	ALIGN	4

$SG94778 DB	01H DUP (?)
	ALIGN	4

$SG94780 DB	01H DUP (?)
	ALIGN	4

$SG95805 DB	01H DUP (?)
	ALIGN	4

$SG94784 DB	01H DUP (?)
	ALIGN	4

$SG94809 DB	01H DUP (?)
	ALIGN	4

$SG94812 DB	01H DUP (?)
	ALIGN	4

$SG94814 DB	01H DUP (?)
	ALIGN	4

$SG94816 DB	01H DUP (?)
	ALIGN	4

$SG94836 DB	01H DUP (?)
	ALIGN	4

$SG94839 DB	01H DUP (?)
	ALIGN	4

$SG94841 DB	01H DUP (?)
	ALIGN	4

$SG94843 DB	01H DUP (?)
	ALIGN	4

$SG95877 DB	01H DUP (?)
	ALIGN	4

$SG95878 DB	01H DUP (?)
	ALIGN	4

$SG95880 DB	01H DUP (?)
	ALIGN	4

$SG95887 DB	01H DUP (?)
	ALIGN	4

$SG96084 DB	01H DUP (?)
	ALIGN	4

$SG96085 DB	01H DUP (?)
	ALIGN	4

$SG96104 DB	01H DUP (?)
	ALIGN	4

$SG96106 DB	01H DUP (?)
	ALIGN	4

$SG96107 DB	01H DUP (?)
	ALIGN	4

$SG96108 DB	01H DUP (?)
	ALIGN	4

$SG96111 DB	01H DUP (?)
	ALIGN	4

$SG96124 DB	01H DUP (?)
	ALIGN	4

$SG96127 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_BoundAttrListRecord:BYTE:01aH
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG95230 DB	01H DUP (?)
	ALIGN	4

$SG95231 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG95233 DB	'================= Performing load ===================', 00H
_g_bHoldStmtHandles DB 058H
?bShowDateTime@?1??InitDatabase@@9@9 DB 01H		; `InitDatabase'::`2'::bShowDateTime
$SG95234 DB	'  Entity name: ', 00H
$SG95235 DB	'  Table name: ', 00H
	ORG $+1
$SG96264 DB	'TZTENVRO', 00H
	ORG $+3
$SG96265 DB	'TE_DB_Environ', 00H
	ORG $+2
$SG95241 DB	'  Table loaded earlier as part of a join. Entity = ', 00H
$SG96266 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG96267 DB	'Name', 00H
	ORG $+3
$SG96268 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG96269 DB	'SQLAllocEnv', 00H
$SG95246 DB	'DBHandler Warning', 00H
	ORG $+2
$SG95245 DB	'XOD ''%s'' needs to be saved with new JOIN code. Keys mu'
	DB	'st be first for entity: %s.', 00H
	ORG $+2
$SG96271 DB	'SQLAllocConnect', 00H
$SG96273 DB	'Database = ', 00H
$SG96274 DB	'SQLConnect', 00H
	ORG $+1
$SG96276 DB	'Error connecting to DB %s', 00H
	ORG $+2
$SG96277 DB	'ODBC DBH Error', 00H
	ORG $+1
$SG96278 DB	'KZH0102', 00H
$SG96279 DB	'Turning AutoCommit off', 00H
	ORG $+1
$SG96280 DB	'SQLSetConnectAttr', 00H
	ORG $+2
$SG96281 DB	'Allocate HSTMT', 00H
	ORG $+1
$SG96282 DB	'SQLAllocHandle', 00H
	ORG $+1
$SG96284 DB	'TABLE', 00H
	ORG $+2
$SG95260 DB	'  Table IS qualified.', 00H
	ORG $+2
$SG96285 DB	'Get table list', 00H
	ORG $+1
$SG96286 DB	'SQLTables', 00H
	ORG $+2
$SG95262 DB	'  Table is not qualified.', 00H
	ORG $+2
$SG96287 DB	'Fetch table name', 00H
	ORG $+3
$SG96288 DB	'SQLFetch', 00H
	ORG $+3
$SG96291 DB	'dtproperties', 00H
	ORG $+3
$SG96292 DB	'TE_TablRec', 00H
	ORG $+1
$SG96293 DB	'Name', 00H
	ORG $+3
$SG96294 DB	'TE_TablRec', 00H
	ORG $+1
$SG96295 DB	'SQLCloseCursor', 00H
	ORG $+1
$SG96296 DB	'TE_TablRec', 00H
	ORG $+1
$SG96297 DB	'TE_TablRec', 00H
	ORG $+1
$SG96298 DB	'Name', 00H
	ORG $+3
$SG95274 DB	'Allocate HSTMT', 00H
	ORG $+1
$SG96299 DB	'TE_TablRec', 00H
	ORG $+1
$SG95275 DB	'SQLAllocHandle', 00H
	ORG $+1
$SG96300 DB	'Get column list', 00H
$SG96301 DB	'SQLColumns', 00H
	ORG $+1
$SG96302 DB	'Fetch column name', 00H
	ORG $+2
$SG96303 DB	'SQLFetch', 00H
	ORG $+3
$SG95282 DB	'SQL might not be needed.', 00H
	ORG $+3
$SG95283 DB	'Loading entity from parent using AutoLoadFromParent; ', 00H
	ORG $+2
$SG95284 DB	'Entity name = ', 00H
	ORG $+1
$SG96317 DB	'Unknown datatype = ', 00H
$SG96318 DB	'Datatype number = ', 00H
	ORG $+1
$SG96319 DB	'Table Name = ', 00H
	ORG $+2
$SG96320 DB	'ColumnName = ', 00H
	ORG $+2
$SG96321 DB	'Unhandled data type', 00H
$SG96322 DB	'DGC', 00H
$SG95298 DB	'executed.', 00H
	ORG $+2
$SG96323 DB	'TE_FieldDataRel', 00H
$SG95299 DB	'Foreign key is null, so following command was not ', 00H
	ORG $+1
$SG96324 DB	'Name', 00H
	ORG $+3
$SG95300 DB	'Number of rows selected = ', 00H
	ORG $+1
$SG96325 DB	'TE_FieldDataRel', 00H
$SG96326 DB	'Length', 00H
	ORG $+1
$SG96327 DB	'TE_FieldDataRel', 00H
$SG96328 DB	'DataType', 00H
	ORG $+3
$SG96329 DB	'TE_FieldDataRel', 00H
$SG96330 DB	'SQLCloseCursor', 00H
	ORG $+1
$SG96331 DB	'TE_TablRec', 00H
	ORG $+1
$SG96332 DB	'TE_TablRec', 00H
	ORG $+1
$SG96333 DB	'Name', 00H
	ORG $+3
$SG96334 DB	'TE_TablRec', 00H
	ORG $+1
$SG96335 DB	'Get index list', 00H
	ORG $+1
$SG95311 DB	'Unknown Data Type', 00H
	ORG $+2
$SG96336 DB	'SQLStatistics', 00H
	ORG $+2
$SG96337 DB	'Fetch column name', 00H
	ORG $+2
$SG95313 DB	'SQLPrepare', 00H
	ORG $+1
$SG96338 DB	'SQLFetch', 00H
	ORG $+3
$SG96342 DB	'IndexName', 00H
	ORG $+2
$SG96343 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG96344 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG96345 DB	'IndexName', 00H
	ORG $+2
$SG96346 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG96347 DB	'Retrieved From DB', 00H
	ORG $+2
$SG96348 DB	'Name', 00H
	ORG $+3
$SG95324 DB	'Unknown Data Type', 00H
	ORG $+2
$SG96349 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG95325 DB	'Attr = ', 00H
$SG95326 DB	'SQLBindCol', 00H
	ORG $+1
$SG96351 DB	'Name', 00H
	ORG $+3
$SG96352 DB	'TE_FieldDataRel', 00H
$SG95328 DB	' ', 00H
	ORG $+2
$SG96353 DB	'TE_FieldDataRel', 00H
$SG95329 DB	'Column Count         = ', 00H
$SG96354 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG95330 DB	'Column Name          = ', 00H
$SG96355 DB	'SQLCloseCursor', 00H
	ORG $+1
$SG95331 DB	'ViewAttrib data type = ', 00H
$SG95332 DB	'DataField data type  = ', 00H
$SG95337 DB	'(KZHSQLBA) Binding attributename = ', 00H
$SG95338 DB	'nParmCount = ', 00H
	ORG $+2
$SG95341 DB	'Column = ', 00H
	ORG $+2
$SG95342 DB	'SQLBindParameter', 00H
	ORG $+3
$SG95344 DB	'nC_DataType = ', 00H
	ORG $+1
$SG95345 DB	'nSQL_Type   = ', 00H
	ORG $+1
$SG95346 DB	'nColumnSize = ', 00H
	ORG $+1
$SG95347 DB	'nDecDigits  = ', 00H
	ORG $+1
$SG95355 DB	'SQLExecute', 00H
	ORG $+1
$SG95362 DB	'SQLFetch', 00H
	ORG $+3
$SG95369 DB	'(xa) Number of rows currently read = ', 00H
	ORG $+2
$SG95382 DB	'Duplicate row found, entity = ', 00H
	ORG $+1
$SG95389 DB	'Getting length for ', 00H
$SG95390 DB	'SQLGetData', 00H
	ORG $+1
$SG95392 DB	'Column number = ', 00H
	ORG $+3
$SG95393 DB	'Returned lth for column = ', 00H
	ORG $+1
$SG95400 DB	'Getting data ', 00H
	ORG $+2
$SG95401 DB	'SQLGetData', 00H
	ORG $+1
$SG95403 DB	'Returned lth for column = ', 00H
	ORG $+1
$SG95411 DB	'YYYY-MM-DD HH:MI:SS', 00H
$SG95413 DB	'M/D/YYYY H:MI:SS AM', 00H
$SG95415 DB	'000000000', 00H
	ORG $+2
$SG95417 DB	'19000101', 00H
	ORG $+3
$SG95423 DB	'SQLFetch', 00H
	ORG $+3
$SG95429 DB	'Number of roots retrieved = ', 00H
	ORG $+3
$SG95430 DB	'Number of rows  retrieved = ', 00H
	ORG $+3
$SG95435 DB	'SQLCloseCursor', 00H
	ORG $+1
$SG95437 DB	'DELETE FROM ZEIDONKEYLIST WHERE TASKID = %ld', 00H
	ORG $+3
$SG95438 DB	'Deleting KeyList', 00H
	ORG $+3
$SG95439 DB	'Prepare', 00H
$SG95440 DB	'Delete keys', 00H
$SG95441 DB	'SQLExecute', 00H
	ORG $+1
$SG95444 DB	'Unbinding stmt handle', 00H
	ORG $+2
$SG95445 DB	'SQLFreeStmt', 00H
_g_DefaultODBC_Data DD 03H
	DB	04eH
	DB	03H
	ORG $+98
$SG95471 DB	'========== Insert ==========', 00H
	ORG $+3
$SG95472 DB	'Inserting entity ', 00H
	ORG $+2
$SG95473 DB	'Inserting record ', 00H
	ORG $+2
$SG95476 DB	'SQLPrepare', 00H
	ORG $+1
$SG95483 DB	'Duplicate root', 00H
	ORG $+1
$SG95484 DB	'SQLExecute', 00H
	ORG $+1
$SG95485 DB	'SQLExecute', 00H
	ORG $+1
$SG95509 DB	'========== Insert Rel ==========', 00H
	ORG $+3
$SG95510 DB	'Inserting rel for entity ', 00H
	ORG $+2
$SG95511 DB	'Inserting rel for record ', 00H
	ORG $+2
$SG95514 DB	'PARENT:', 00H
$SG95516 DB	'CHILD:', 00H
	ORG $+1
$SG95519 DB	'SQLExecDirect', 00H
	ORG $+2
$SG95542 DB	'========== Delete ==========', 00H
	ORG $+3
$SG95543 DB	'Deleting entity ', 00H
	ORG $+3
$SG95544 DB	'Deleting record ', 00H
	ORG $+3
$SG95548 DB	'SqlBuildDeleteAll SQL: ', 00H
$SG95551 DB	'SQLExecDirect', 00H
	ORG $+2
$SG95573 DB	'========== Delete Rel ==========', 00H
	ORG $+3
$SG95574 DB	'Deleting entity ', 00H
	ORG $+3
$SG95575 DB	'Deleting record ', 00H
	ORG $+3
$SG95579 DB	'SQLExecDirect', 00H
	ORG $+2
$SG95604 DB	'========== Update ==========', 00H
	ORG $+3
$SG95605 DB	'Updating entity ', 00H
	ORG $+3
$SG95606 DB	'Updating record ', 00H
	ORG $+3
$SG95610 DB	'SQLPrepare', 00H
	ORG $+1
$SG95613 DB	'SQLExecute', 00H
	ORG $+1
$SG95619 DB	'SQLExecDirect', 00H
	ORG $+2
$SG95631 DB	'===== DBH_Entry Error =====', 00H
$SG95632 DB	'Msg=> ', 00H
	ORG $+1
$SG95634 DB	'nRC=> ', 00H
	ORG $+1
$SG95637 DB	'KZHSQLOA DBH Error', 00H
	ORG $+1
$SG95638 DB	'KZH0101', 00H
$SG95648 DB	'%d (SQL_SUCCESS)', 00H
	ORG $+3
$SG94625 DB	'Closing stmt handle', 00H
$SG95650 DB	'%d (SQL_SUCCESS_WITH_INFO)', 00H
	ORG $+1
$SG94626 DB	'SQLFreeHandle', 00H
	ORG $+2
$SG95652 DB	'%d (SQL_ERROR)', 00H
	ORG $+1
$SG94629 DB	'Closing stmt handle', 00H
$SG95654 DB	'%d (SQL_INVALID_HANDLE)', 00H
$SG94630 DB	'SQLFreeHandle', 00H
	ORG $+2
$SG95656 DB	'%d (SQL_NEED_DATA)', 00H
	ORG $+1
$SG95658 DB	'%d (SQL_NO_DATA)', 00H
	ORG $+3
$SG95660 DB	'%d (SQL_STILL_EXECUTING)', 00H
	ORG $+3
$SG95662 DB	'%d (unknown)', 00H
	ORG $+3
$SG94654 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG94656 DB	'Can''t find DB-Handler work view.', 00H
	ORG $+3
$SG94657 DB	'Zeidon DBH', 00H
	ORG $+1
$SG94659 DB	'Type', 00H
	ORG $+3
$SG94660 DB	'Type', 00H
	ORG $+3
$SG95686 DB	'Database name = ', 00H
	ORG $+3
$SG94662 DB	'Type', 00H
	ORG $+3
$SG94663 DB	'Type', 00H
	ORG $+3
$SG94664 DB	'Type', 00H
	ORG $+3
$SG94666 DB	'CommitLatency', 00H
	ORG $+2
$SG95691 DB	'ODBC Call : ', 00H
	ORG $+3
$SG94667 DB	'[kzhsqloa]', 00H
	ORG $+1
$SG95692 DB	'Return Code :', 00H
	ORG $+2
$SG94668 DB	'TypeEnvBlob', 00H
$SG94669 DB	'Type', 00H
	ORG $+3
$SG94672 DB	'HoldStmtHandles', 00H
$SG94673 DB	'[kzhsqloa]', 00H
	ORG $+1
$SG95700 DB	'===== SQL ODBC Error ===== rc = ', 00H
	ORG $+3
$SG95701 DB	'===== SQL ODBC Info ===== rc = ', 00H
$SG94677 DB	'TypeEnvBlob', 00H
$SG95702 DB	'[ODBC] SQLState = %s, Err=', 00H
	ORG $+1
$SG94678 DB	'Type', 00H
	ORG $+3
$SG95703 DB	'ODBC DBH Error', 00H
	ORG $+1
$SG94679 DB	'Zeidon DBH', 00H
	ORG $+1
$SG95704 DB	'KZH0102', 00H
$SG94681 DB	'May 25 2017 16:38:39', 00H
	ORG $+3
$SG94682 DB	'Compile date/time for KZHSQLOA is ', 00H
	ORG $+1
$SG95726 DB	'SQLAllocEnv', 00H
$SG95735 DB	'Too many open databases for 1 session.', 00H
	ORG $+1
$SG95737 DB	'SQLAllocConnect', 00H
$SG94714 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG95739 DB	'Database = ', 00H
$SG95740 DB	'SQLConnect', 00H
	ORG $+1
$SG94716 DB	'Can''t find DB-Handler work view.', 00H
	ORG $+3
$SG95742 DB	'Error connecting to DB %s', 00H
	ORG $+2
$SG94718 DB	'Zeidon DBH', 00H
	ORG $+1
$SG95743 DB	'ODBC DBH Error', 00H
	ORG $+1
$SG95744 DB	'KZH0102', 00H
$SG94720 DB	'Type', 00H
	ORG $+3
$SG95745 DB	'Turning AutoCommit off', 00H
	ORG $+1
$SG94721 DB	'Type', 00H
	ORG $+3
$SG95746 DB	'SQLSetConnectAttr', 00H
	ORG $+2
$SG94723 DB	'Zeidon DBH', 00H
	ORG $+1
$SG95748 DB	'Allocate HSTMT', 00H
	ORG $+1
$SG94725 DB	'0x%08x:%08x', 00H
$SG94724 DB	'Internal error -- cannot find DB Base type (%s) in db-ha'
	DB	'ndler work object.', 00H
	ORG $+1
$SG95749 DB	'SQLAllocHandle', 00H
	ORG $+1
$SG94727 DB	'LogicalUserName', 00H
$SG94728 DB	'Connection', 00H
	ORG $+1
$SG94730 DB	'Connection', 00H
	ORG $+1
$SG94731 DB	'LogicalUserName', 00H
$SG94732 DB	'Connection', 00H
	ORG $+1
$SG94734 DB	'Connection', 00H
	ORG $+1
$SG94736 DB	'Zeidon DBH', 00H
	ORG $+1
$SG94737 DB	'TaskID not found for Task:TaskID %s', 00H
$SG94738 DB	'ERROR ********** CloseDatabase ', 00H
$SG94741 DB	'ConnectionBlob', 00H
	ORG $+1
$SG94742 DB	'Connection', 00H
	ORG $+1
$SG94745 DB	'Disconnecting handle for database ', 00H
	ORG $+1
$SG94746 DB	'SQLDisconnect', 00H
	ORG $+2
$SG94747 DB	'Closing handle for database ', 00H
	ORG $+3
$SG94748 DB	'SQLFreeHandle', 00H
	ORG $+2
$SG94750 DB	'Closing henv', 00H
	ORG $+3
$SG94751 DB	'SQLFreeHandle', 00H
	ORG $+2
$SG94752 DB	'ConnectionBlob', 00H
	ORG $+1
$SG94753 DB	'Connection', 00H
	ORG $+1
$SG94754 DB	'Connection', 00H
	ORG $+1
$SG94755 DB	'Zeidon DBH', 00H
	ORG $+1
$SG95792 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG95794 DB	'Can''t find DB-Handler work view.', 00H
	ORG $+3
$SG95795 DB	'Zeidon DBH', 00H
	ORG $+1
$SG95796 DB	'Type', 00H
	ORG $+3
$SG95797 DB	'Type', 00H
	ORG $+3
$SG95799 DB	'Type', 00H
	ORG $+3
$SG95800 DB	'Type', 00H
	ORG $+3
$SG95801 DB	'Type', 00H
	ORG $+3
$SG94777 DB	'####################################################', 00H
	ORG $+3
$SG95803 DB	'GetWorkObjectView RESETTING task from: 0x%08x  to: 0x%08'
	DB	'x', 00H
	ORG $+2
$SG94779 DB	'##################  BEGIN TRANSACTION ##############', 00H
	ORG $+3
$SG95804 DB	'0x%08x:%08x', 00H
$SG94781 DB	'####################################################', 00H
	ORG $+3
$SG95806 DB	'LogicalUserName', 00H
$SG95807 DB	'Connection', 00H
	ORG $+1
$SG94785 DB	'Storing Objects', 00H
$SG95810 DB	'Connection', 00H
	ORG $+1
$SG94786 DB	'Activating Object Def ', 00H
	ORG $+1
$SG95811 DB	'LogicalUserName', 00H
$SG94787 DB	'Database name = ', 00H
	ORG $+3
$SG95812 DB	'Connection', 00H
	ORG $+1
$SG95813 DB	'TaskID', 00H
	ORG $+1
$SG95814 DB	'Connection', 00H
	ORG $+1
$SG95815 DB	'Conn BEGIN', 00H
	ORG $+1
$SG94791 DB	'ODBC Latency...waiting... milliseconds = ', 00H
	ORG $+2
$SG95816 DB	'Conn END', 00H
	ORG $+3
$SG95817 DB	'ConnectionBlob', 00H
	ORG $+1
$SG95818 DB	'Connection', 00H
	ORG $+1
$SG95819 DB	'ConnectionBlob', 00H
	ORG $+1
$SG95820 DB	'Connection', 00H
	ORG $+1
$SG95822 DB	'Zeidon DBH', 00H
	ORG $+1
$SG95824 DB	'Zeidon DBH', 00H
	ORG $+1
$SG95825 DB	'ConnectionBlob', 00H
	ORG $+1
$SG95826 DB	'Connection', 00H
	ORG $+1
$SG95829 DB	'TraceLevel', 00H
	ORG $+1
$SG95830 DB	'[KZHSQLOA]', 00H
	ORG $+1
$SG95833 DB	'Zeidon DBH', 00H
	ORG $+1
$SG94810 DB	'lpConnection is null!!!!!!', 00H
	ORG $+1
$SG94813 DB	'####################################################', 00H
	ORG $+3
$SG94815 DB	'#################  COMMIT TRANSACTION ##############', 00H
	ORG $+3
$SG94817 DB	'####################################################', 00H
	ORG $+3
$SG94819 DB	'Commit DB ', 00H
	ORG $+1
$SG94820 DB	'SQLEndTran', 00H
	ORG $+1
$SG94837 DB	'lpConnection is null!!!!!!', 00H
	ORG $+1
$SG94840 DB	'####################################################', 00H
	ORG $+3
$SG94842 DB	'################ ROLLBACK TRANSACTION ##############', 00H
	ORG $+3
$SG94844 DB	'####################################################', 00H
	ORG $+3
$SG94845 DB	'Rollback DB ', 00H
	ORG $+3
$SG94846 DB	'SQLEndTran', 00H
	ORG $+1
$SG95871 DB	'SQLFetch', 00H
	ORG $+3
$SG95872 DB	'SQLFetch', 00H
	ORG $+3
$SG95873 DB	'SQLFetch', 00H
	ORG $+3
$SG95881 DB	'===== ODBC Error =====', 00H
	ORG $+1
$SG95882 DB	'ODBC Call : ', 00H
	ORG $+3
$SG95883 DB	'RC        : ', 00H
	ORG $+3
$SG95893 DB	'[ODBC] SQLState = %s, Err=', 00H
	ORG $+1
$SG95895 DB	'ODBC DBH Error', 00H
	ORG $+1
$SG95896 DB	'KZH0102', 00H
$SG95927 DB	'(KZHSQLBA) WriteLongChar attributename = ', 00H
	ORG $+2
$SG95928 DB	'nParmCount = ', 00H
	ORG $+2
$SG95935 DB	'Column = ', 00H
	ORG $+2
$SG95936 DB	'SQLBindParameter', 00H
	ORG $+3
$SG95938 DB	'nValueType  = ', 00H
	ORG $+1
$SG95939 DB	'nParmType   = ', 00H
	ORG $+1
$SG95940 DB	'nColumnSize = ', 00H
	ORG $+1
$SG95941 DB	'nDecDigits  = ', 00H
	ORG $+1
$SG95942 DB	'nLth        = ', 00H
	ORG $+1
$SG94937 DB	'Allocate HSTMT', 00H
	ORG $+1
$SG94938 DB	'SQLAllocHandle', 00H
	ORG $+1
$SG94940 DB	'INSERT INTO ZEIDONKEYLIST ( TASKID, INTVALUE ) VALUES ( '
	DB	'%ld, ? )', 00H
	ORG $+3
$SG94941 DB	'SQLPrepare insert', 00H
	ORG $+2
$SG95966 DB	'__MSGQ', 00H
	ORG $+1
$SG94942 DB	'IntValue', 00H
	ORG $+3
$SG94943 DB	'Column = ', 00H
	ORG $+2
$SG94944 DB	'SQLBindParameter', 00H
	ORG $+3
$SG95969 DB	'DBH_Error', 00H
	ORG $+2
$SG95970 DB	'DBH_Error', 00H
	ORG $+2
$SG94946 DB	'nC_DataType = ', 00H
	ORG $+1
$SG95971 DB	'DBH_Error', 00H
	ORG $+2
$SG94947 DB	'nSQL_Type   = ', 00H
	ORG $+1
$SG94948 DB	'nColumnSize = ', 00H
	ORG $+1
$SG95973 DB	'Id', 00H
	ORG $+1
$SG94949 DB	'Allocate HSTMT', 00H
	ORG $+1
$SG95974 DB	'Task', 00H
	ORG $+3
$SG94950 DB	'SQLExecute', 00H
	ORG $+1
$SG95976 DB	'DBH_Error', 00H
	ORG $+2
$SG95977 DB	'DBH_Error', 00H
	ORG $+2
$SG96007 DB	'__MSGQ', 00H
	ORG $+1
$SG96011 DB	'KZMSGQOO', 00H
	ORG $+3
$SG96012 DB	'Task', 00H
	ORG $+3
$SG96013 DB	'__MSGQ', 00H
	ORG $+1
$SG96015 DB	'DBH_Error', 00H
	ORG $+2
$SG96016 DB	'DBH_Error', 00H
	ORG $+2
$SG96017 DB	'DBH_Error', 00H
	ORG $+2
$SG96020 DB	'Id', 00H
	ORG $+1
$SG96021 DB	'Task', 00H
	ORG $+3
$SG96022 DB	'Task', 00H
	ORG $+3
$SG96023 DB	'Id', 00H
	ORG $+1
$SG96024 DB	'Task', 00H
	ORG $+3
$SG96025 DB	'Zeidon', 00H
	ORG $+1
$SG96026 DB	'Client', 00H
	ORG $+1
$SG96027 DB	'Task', 00H
	ORG $+3
$SG96029 DB	'Id', 00H
	ORG $+1
$SG96030 DB	'Task', 00H
	ORG $+3
$SG96032 DB	'DBH_Error', 00H
	ORG $+2
$SG96033 DB	'DBH_Error', 00H
	ORG $+2
$SG96034 DB	'DBH_Error', 00H
	ORG $+2
$SG96036 DB	'DBH_Error', 00H
	ORG $+2
$SG96037 DB	'Code', 00H
	ORG $+3
$SG96038 DB	'DBH_Error', 00H
	ORG $+2
$SG96039 DB	'State', 00H
	ORG $+2
$SG96040 DB	'DBH_Error', 00H
	ORG $+2
$SG96041 DB	'Msg', 00H
$SG96042 DB	'DBH_Error', 00H
	ORG $+2
$SG95031 DB	'Key type not supported', 00H
	ORG $+1
$SG95032 DB	'DBHandler Error', 00H
$SG95040 DB	'Key type not supported', 00H
	ORG $+1
$SG95041 DB	'DBHandler Error', 00H
$SG96088 DB	'Error performing Load for OD: ', 00H
	ORG $+1
$SG96091 DB	'Error performing Insert for OD: ', 00H
	ORG $+3
$SG96094 DB	'Error performing InsertRel for OD: ', 00H
$SG96097 DB	'Error performing Delete for OD: ', 00H
	ORG $+3
$SG96100 DB	'Error performing DeleteRel for OD: ', 00H
$SG96102 DB	'Error performing Update for OD: ', 00H
	ORG $+3
$SG96105 DB	'PARENT:', 00H
$SG96109 DB	'CHILD:', 00H
	ORG $+1
$SG96112 DB	'Qualification View:', 00H
$SG96125 DB	'---------------------------------', 00H
	ORG $+2
$SG96126 DB	'Committing object ', 00H
	ORG $+1
$SG96128 DB	'---------------------------------', 00H
	ORG $+2
$SG96175 DB	'HHMISS', 00H
	ORG $+1
$SG96176 DB	't', 00H
	ORG $+2
$SG96177 DB	'HH:MI:SS', 00H
	ORG $+3
$SG96179 DB	'd', 00H
	ORG $+2
$SG96180 DB	'YYYY-mm-DD', 00H
	ORG $+1
$SG96183 DB	'ts', 00H
	ORG $+1
$SG96188 DB	'YYYYmmDDHHMISS', 00H
	ORG $+1
$SG96189 DB	'YYYY-mm-DD HH:MI:SS', 00H
$SG96192 DB	'YYYYmmDDHHMISS999999999999999', 00H
	ORG $+2
$SG96193 DB	'YYYY-mm-DD HH:MI:SS.999999999999999', 00H
$SG96195 DB	'''', 00H
	ORG $+2
$SG96201 DB	'?', 00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnSqlRC
PUBLIC	_DisplayCommand
PUBLIC	_DBH_Error
PUBLIC	_WriteLongChar
PUBLIC	_fnDBH_Callback@24
PUBLIC	_fnClearDBHandlerError@4
PUBLIC	_fnSetDBHandlerError@16
PUBLIC	_fnOpenDatabaseConnection@16
PUBLIC	_fnAllocateConnectionMemory@16
PUBLIC	_fnFreeStmtHandles
PUBLIC	_InitDatabase
PUBLIC	_CloseDatabase
PUBLIC	_BeginTransaction
PUBLIC	_CommitTransaction
PUBLIC	_RollbackTransaction
PUBLIC	_fnCancelQuery
PUBLIC	_fnFindNextJoinedChild@12
PUBLIC	_fnGetNextDataField@4
PUBLIC	_fnCreateKeyList@16
PUBLIC	_fnSetEntityByKeys@28
PUBLIC	_Load
PUBLIC	_Insert
PUBLIC	_InsertRel
PUBLIC	_Delete
PUBLIC	_DeleteRel
PUBLIC	_Update
PUBLIC	_fnRC_Text
PUBLIC	_GetWorkObjectView
PUBLIC	_DBH_MsgProc@32
PUBLIC	_RetrieveSchema@8
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__toupper:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atol:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_DisplayEntityInstance@8:PROC
EXTRN	_DisplayObjectInstance@12:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_ActivateEmptyObjectInstance@16:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_GetDefaultViewForActiveTask@0:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CheckExistenceOfEntity@8:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_LoadEntity@16:PROC
EXTRN	_DeleteEntity@12:PROC
EXTRN	_DropEntity@12:PROC
EXTRN	_IncludeSubobjectFromSubobject@20:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_SetCursorFirstEntityByInteger@20:PROC
EXTRN	_SetEntityCursor@40:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_SetAttributeFromBlob@20:PROC
EXTRN	_CompareAttributeToString@16:PROC
EXTRN	_SetAttributeFromVariable@32:PROC
EXTRN	_CountEntitiesForView@8:PROC
EXTRN	_UfFormatDateTime@12:PROC
EXTRN	_UfEditFormatDateTime@8:PROC
EXTRN	_GetTaskDBHandlerTraceLevel@4:PROC
EXTRN	_OrderOI_ByDefaultAttribs@4:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_SysMutexLock@16:PROC
EXTRN	_SysMutexUnlock@12:PROC
EXTRN	_MiGetViewEntityForView@8:PROC
EXTRN	_SysAllocMemory@20:PROC
EXTRN	_SysFree@4:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysGetDB_UserID@12:PROC
EXTRN	_SysGetPointerFromHandle@4:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysGetTaskFromView@4:PROC
EXTRN	_SysGetTickCount@0:PROC
EXTRN	_SysMalloc@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysWait@4:PROC
EXTRN	_GetAddrForAttribute@16:PROC
EXTRN	_StoreValueInRecord@20:PROC
EXTRN	_GetValueFromRecord@24:PROC
EXTRN	_StoreStringInRecord@16:PROC
EXTRN	_GetStringFromRecord@20:PROC
EXTRN	_GetAttributeFlags@16:PROC
EXTRN	_SfCreateSubtask@12:PROC
EXTRN	_SfDropSubtask@8:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_SqlFreeBoundAttrList@4:PROC
EXTRN	_SqlAddBoundAttr@20:PROC
EXTRN	_SqlInitBoundAttrList@20:PROC
EXTRN	_SqlBuildInsert@20:PROC
EXTRN	_SqlBuildInsertCorrTable@20:PROC
EXTRN	_SqlBuildUpdate@24:PROC
EXTRN	_SqlBuildUpdateCorrTable@20:PROC
EXTRN	_SqlBuildDelete@20:PROC
EXTRN	_SqlBuildDeleteAll@20:PROC
EXTRN	_SqlBuildDeleteCorrTable@20:PROC
EXTRN	_SqlBuildSelect@24:PROC
EXTRN	_SqlAutoLoadFromParent@24:PROC
EXTRN	_SqlEntityIsQualified@8:PROC
EXTRN	_SqlFreeQualEntity@4:PROC
EXTRN	_SqlRetrieveQualObject@20:PROC
EXTRN	_SqlDisplayCommand@8:PROC
EXTRN	_SqlDisplayQualEntity@8:PROC
EXTRN	_SQLAllocConnect@8:PROC
EXTRN	_SQLAllocEnv@4:PROC
EXTRN	_SQLAllocHandle@12:PROC
EXTRN	_SQLBindCol@24:PROC
EXTRN	_SQLCloseCursor@4:PROC
EXTRN	_SQLColumns@36:PROC
EXTRN	_SQLConnect@28:PROC
EXTRN	_SQLDisconnect@4:PROC
EXTRN	_SQLEndTran@12:PROC
EXTRN	_SQLExecDirect@12:PROC
EXTRN	_SQLExecute@4:PROC
EXTRN	_SQLFetch@4:PROC
EXTRN	_SQLFreeHandle@8:PROC
EXTRN	_SQLFreeStmt@8:PROC
EXTRN	_SQLGetData@24:PROC
EXTRN	_SQLGetDiagField@28:PROC
EXTRN	_SQLGetDiagRec@32:PROC
EXTRN	_SQLPrepare@12:PROC
EXTRN	_SQLSetConnectAttr@16:PROC
EXTRN	_SQLStatistics@36:PROC
EXTRN	_SQLTables@36:PROC
EXTRN	_SQLBindParameter@40:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

?szReturn@?1??fnRC_Text@@9@9 DB 064H DUP (?)		; `fnRC_Text'::`2'::szReturn
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_iCardinality$ = -4596					; size = 4
_cbCardinality$ = -4592					; size = 4
_pchPtr$ = -4588					; size = 4
_cbIndexNameLth$ = -4584				; size = 4
_cbTableNameLth$ = -4580				; size = 4
_sNullable$ = -4576					; size = 2
_cbColumnNameLth$ = -4572				; size = 4
$T1 = -4568						; size = 4
_pchDBName$ = -4564					; size = 4
tv340 = -4560						; size = 4
_sDataType$ = -4556					; size = 2
_iColLth$ = -4552					; size = 4
_vDB$ = -4548						; size = 4
_lpConnection$ = -4544					; size = 4
_nRC$ = -4540						; size = 2
_cr$ = -4536						; size = 2928
_szIndexQual$ = -1608					; size = 256
_szDataTypeName$ = -1352				; size = 256
_szText$2 = -1096					; size = 200
_szIndexName$ = -896					; size = 256
_szColumnName$ = -640					; size = 256
_szTableName$ = -384					; size = 256
_szUserID$ = -128					; size = 50
_szPassword$ = -76					; size = 50
_szDataType$3 = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_pvDB$ = 12						; size = 4
_RetrieveSchema@8 PROC

; 5883 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4596				; 000011f4H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5884 :    ConnectionRecord cr = { 0 };

	mov	BYTE PTR _cr$[ebp], 0
	push	2927					; 00000b6fH
	push	0
	lea	eax, DWORD PTR _cr$[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5885 :    LPCONNECTION lpConnection = &cr;

	lea	ecx, DWORD PTR _cr$[ebp]
	mov	DWORD PTR _lpConnection$[ebp], ecx

; 5886 : 
; 5887 :    zVIEW  vDB;
; 5888 :    zCHAR  szUserID[ 50 ];
; 5889 :    zCHAR  szPassword[ 50 ];
; 5890 :    zPCHAR pchPtr = 0;

	mov	DWORD PTR _pchPtr$[ebp], 0

; 5891 :    zPCHAR pchDBName;
; 5892 : 
; 5893 :    zCHAR  szTableName[ STR_LEN + 1 ];
; 5894 :    zCHAR  szColumnName[ STR_LEN + 1 ];
; 5895 :    zCHAR  szIndexName[ STR_LEN + 1 ];
; 5896 : 
; 5897 : #if defined( DB2 ) || defined( ODBC )
; 5898 :    zCHAR       szDataTypeName[ STR_LEN + 1 ];
; 5899 :    zCHAR       szIndexQual[ STR_LEN + 1 ];
; 5900 :    SQLINTEGER  cbTableNameLth, cbColumnNameLth, cbIndexNameLth, cbCardinality;
; 5901 :    SQLINTEGER  iColLth;
; 5902 :    SQLINTEGER  iCardinality;
; 5903 :    SQLSMALLINT sDataType;
; 5904 :    SQLSMALLINT sNullable;
; 5905 : #else
; 5906 :    zLONG       iColLth = 0;
; 5907 : #endif
; 5908 :    zSHORT nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 5909 : 
; 5910 : // lpConnection->nTraceLevel = 1;
; 5911 :    lpConnection->lpAppView = vDTE;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR _vDTE$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 5912 : 
; 5913 :    if ( *pvDB == 0 )

	mov	edx, DWORD PTR _pvDB$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN16@RetrieveSc

; 5914 :    {
; 5915 :       ActivateEmptyObjectInstance( pvDB, "TZTENVRO", vDTE, zSINGLE );

	push	0
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG96264
	mov	ecx, DWORD PTR _pvDB$[ebp]
	push	ecx
	call	_ActivateEmptyObjectInstance@16

; 5916 :       CreateEntity( *pvDB, "TE_DB_Environ", zPOS_LAST );

	push	2
	push	OFFSET $SG96265
	mov	edx, DWORD PTR _pvDB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CreateEntity@12

; 5917 :       CreateEntity( *pvDB, "TE_DBMS_Source", zPOS_LAST );

	push	2
	push	OFFSET $SG96266
	mov	ecx, DWORD PTR _pvDB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CreateEntity@12
$LN16@RetrieveSc:

; 5918 :    }
; 5919 : 
; 5920 :    vDB = *pvDB;  // Just to make things easier.

	mov	eax, DWORD PTR _pvDB$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vDB$[ebp], ecx

; 5921 : 
; 5922 :    // Get the database name.
; 5923 :    GetAddrForAttribute( &pchDBName, vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET $SG96267
	push	OFFSET $SG96268
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDBName$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 5924 : 
; 5925 :    SysGetDB_UserID( vDTE, szUserID, szPassword );

	lea	ecx, DWORD PTR _szPassword$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szUserID$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysGetDB_UserID@12

; 5926 : 
; 5927 :    //==============================================================
; 5928 :    // Open database.
; 5929 :    //==============================================================
; 5930 : 
; 5931 : #if defined( DB2 ) || defined( ODBC )
; 5932 : 
; 5933 :    nRC = SQLAllocEnv( &lpConnection->henv );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	add	ecx, 2804				; 00000af4H
	push	ecx
	call	_SQLAllocEnv@4
	mov	WORD PTR _nRC$[ebp], ax

; 5934 :    SQL_RC( "SQLAllocEnv", nRC, 0, 0, 2 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	push	0
	push	0
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG96269
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5935 :    if ( nRC != SQL_SUCCESS )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN17@RetrieveSc

; 5936 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN40@RetrieveSc
$LN17@RetrieveSc:

; 5937 : 
; 5938 :    nRC = SQLAllocConnect( lpConnection->henv, &lpConnection->hdbc );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	add	edx, 2808				; 00000af8H
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2804]
	push	ecx
	call	_SQLAllocConnect@8
	mov	WORD PTR _nRC$[ebp], ax

; 5939 :    SQL_RC( "SQLAllocConnect", nRC, 0, 0, 2 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	push	0
	push	0
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG96271
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5940 :    if ( nRC != SQL_SUCCESS )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@RetrieveSc

; 5941 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN40@RetrieveSc
$LN18@RetrieveSc:

; 5942 : 
; 5943 :    nRC = SQLConnect( lpConnection->hdbc, pchDBName, SQL_NTS,

	push	-3					; fffffffdH
	lea	edx, DWORD PTR _szPassword$[ebp]
	push	edx
	push	-3					; fffffffdH
	lea	eax, DWORD PTR _szUserID$[ebp]
	push	eax
	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _pchDBName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2808]
	push	eax
	call	_SQLConnect@28
	mov	WORD PTR _nRC$[ebp], ax

; 5944 :                      szUserID, SQL_NTS, szPassword, SQL_NTS );
; 5945 :    SQL_RC( "SQLConnect", nRC, "Database = ", pchDBName, 1 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _pchDBName$[ebp]
	push	edx
	push	OFFSET $SG96273
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG96274
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5946 :    if ( !RC_SUCCESSFUL( nRC ) )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@RetrieveSc
	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	je	SHORT $LN19@RetrieveSc

; 5947 :    {
; 5948 :       zCHAR szText[ 200 ];
; 5949 : 
; 5950 :       zsprintf( szText, "Error connecting to DB %s", pchDBName );

	mov	eax, DWORD PTR _pchDBName$[ebp]
	push	eax
	push	OFFSET $SG96276
	lea	ecx, DWORD PTR _szText$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 5951 :       MessageSend( lpConnection->lpAppView, "KZH0102", "ODBC DBH Error",

	push	0
	push	1000					; 000003e8H
	lea	edx, DWORD PTR _szText$2[ebp]
	push	edx
	push	OFFSET $SG96277
	push	OFFSET $SG96278
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_MessageSend@24

; 5952 :                    szText, zMSGQ_SYSTEM_ERROR, 0 );
; 5953 : 
; 5954 :       SQLFreeHandle( SQL_HANDLE_DBC, (SQLHANDLE) lpConnection->hdbc );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2808]
	push	eax
	push	2
	call	_SQLFreeHandle@8

; 5955 :       lpConnection->hdbc = 0;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+2808], 0

; 5956 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN40@RetrieveSc
$LN19@RetrieveSc:

; 5957 :    }
; 5958 : 
; 5959 : #if defined( DB2 )
; 5960 : 
; 5961 :    nRC = SQLAllocStmt( lpConnection->hdbc, &lpConnection->hstmt );
; 5962 :    SQL_RC( "SQLAllocStmt", nRC, "Allocate HSTMT", 0, 2 );
; 5963 :    if ( nRC != SQL_SUCCESS )
; 5964 :       return( zCALL_ERROR );
; 5965 : 
; 5966 : #else
; 5967 : 
; 5968 :    nRC = SQLSetConnectAttr( lpConnection->hdbc, SQL_ATTR_AUTOCOMMIT,

	push	0
	push	0
	push	102					; 00000066H
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2808]
	push	eax
	call	_SQLSetConnectAttr@16
	mov	WORD PTR _nRC$[ebp], ax

; 5969 :                             SQL_AUTOCOMMIT_OFF, 0 );
; 5970 :    SQL_RC( "SQLSetConnectAttr", nRC, "Turning AutoCommit off", 0, 2 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	2
	push	0
	push	OFFSET $SG96279
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG96280
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5971 : 
; 5972 :    nRC = SQLAllocHandle( SQL_HANDLE_STMT, lpConnection->hdbc,

	mov	eax, DWORD PTR _lpConnection$[ebp]
	add	eax, 2812				; 00000afcH
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2808]
	push	edx
	push	3
	call	_SQLAllocHandle@12
	mov	WORD PTR _nRC$[ebp], ax

; 5973 :                          &lpConnection->hstmt );
; 5974 :    SQL_RC( "SQLAllocHandle", nRC, "Allocate HSTMT", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG96281
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG96282
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5975 :    if ( nRC != SQL_SUCCESS )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN20@RetrieveSc

; 5976 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN40@RetrieveSc
$LN20@RetrieveSc:

; 5977 : 
; 5978 : #endif
; 5979 : 
; 5980 :    nRC = SQLTables( lpConnection->hstmt, 0, 0, 0, 0, 0, 0,

	push	-3					; fffffffdH
	push	OFFSET $SG96284
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLTables@36
	mov	WORD PTR _nRC$[ebp], ax

; 5981 :                     "TABLE", SQL_NTS );
; 5982 :    SQL_RC( "SQLTables", nRC, "Get table list", 0, 1 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	1
	push	0
	push	OFFSET $SG96285
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG96286
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5983 : 
; 5984 :    SQLBindCol( lpConnection->hstmt, 3, SQL_C_CHAR, szTableName,

	lea	ecx, DWORD PTR _cbTableNameLth$[ebp]
	push	ecx
	push	255					; 000000ffH
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	1
	push	3
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLBindCol@24
$LN2@RetrieveSc:

; 5985 :                STR_LEN, &cbTableNameLth );
; 5986 : 
; 5987 : #endif
; 5988 : 
; 5989 :    // Load tables.
; 5990 :    while ( TRUE )

	mov	edx, 1
	test	edx, edx
	je	$LN3@RetrieveSc

; 5991 :    {
; 5992 : #if defined( DB2 ) || defined( ODBC )
; 5993 : 
; 5994 :       nRC = SQLFetch( lpConnection->hstmt );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLFetch@4
	mov	WORD PTR _nRC$[ebp], ax

; 5995 :       SQL_RC( "SQLFetch", nRC, "Fetch table name", 0, 1 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	1
	push	0
	push	OFFSET $SG96287
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG96288
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5996 :       if ( !RC_SUCCESSFUL( nRC ) )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN21@RetrieveSc
	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	je	SHORT $LN21@RetrieveSc

; 5997 :          break;

	jmp	SHORT $LN3@RetrieveSc
$LN21@RetrieveSc:

; 5998 : 
; 5999 :       // We have to ignore some system tables.
; 6000 :       if ( zstrcmpi( szTableName, "dtproperties" ) == 0 )

	push	OFFSET $SG96291
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@RetrieveSc

; 6001 :          continue;

	jmp	SHORT $LN2@RetrieveSc
$LN22@RetrieveSc:

; 6002 : 
; 6003 : #endif
; 6004 : 
; 6005 :       CreateEntity( vDB, "TE_TablRec", zPOS_LAST );

	push	2
	push	OFFSET $SG96292
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CreateEntity@12

; 6006 :       SetAttributeFromString( vDB, "TE_TablRec", "Name", szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET $SG96293
	push	OFFSET $SG96294
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 6007 : 
; 6008 :    } // Load tables...

	jmp	$LN2@RetrieveSc
$LN3@RetrieveSc:

; 6009 : 
; 6010 :    // Clean up after getting tables.
; 6011 : #if defined( DB2 ) || defined( ODBC )
; 6012 : 
; 6013 :    nRC = SQLCloseCursor( lpConnection->hstmt );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLCloseCursor@4
	mov	WORD PTR _nRC$[ebp], ax

; 6014 :    SQL_RC( "SQLCloseCursor", nRC, 0, 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	0
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG96295
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 6015 : 
; 6016 : #endif
; 6017 : 
; 6018 :    // Load columns.
; 6019 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG96296
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN6@RetrieveSc
$LN4@RetrieveSc:

; 6021 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG96297
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN6@RetrieveSc:

; 6020 :          nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN5@RetrieveSc

; 6022 :    {
; 6023 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET $SG96298
	push	OFFSET $SG96299
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 6024 : 
; 6025 : #if defined( DB2 ) || defined( ODBC )
; 6026 :       nRC = SQLColumns( lpConnection->hstmt, 0, 0, 0, 0, szTableName,

	push	0
	push	0
	push	-3					; fffffffdH
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLColumns@36
	mov	WORD PTR _nRC$[ebp], ax

; 6027 :                         SQL_NTS, 0, 0 );
; 6028 :       SQL_RC( "SQLColumns", nRC, "Get column list", 0, 1 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	1
	push	0
	push	OFFSET $SG96300
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG96301
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 6029 : 
; 6030 :       SQLBindCol( lpConnection->hstmt, 4, SQL_C_CHAR,

	lea	eax, DWORD PTR _cbColumnNameLth$[ebp]
	push	eax
	push	255					; 000000ffH
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	push	1
	push	4
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLBindCol@24

; 6031 :                   szColumnName, STR_LEN, &cbColumnNameLth );
; 6032 :       SQLBindCol( lpConnection->hstmt, 5, SQL_C_SSHORT, &sDataType, 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR _sDataType$[ebp]
	push	ecx
	push	-15					; fffffff1H
	push	5
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLBindCol@24

; 6033 :       SQLBindCol( lpConnection->hstmt, 6, SQL_C_CHAR,

	lea	ecx, DWORD PTR _cbColumnNameLth$[ebp]
	push	ecx
	push	255					; 000000ffH
	lea	edx, DWORD PTR _szDataTypeName$[ebp]
	push	edx
	push	1
	push	6
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLBindCol@24

; 6034 :                   szDataTypeName, STR_LEN, &cbColumnNameLth );
; 6035 :       SQLBindCol( lpConnection->hstmt, 7, SQL_C_SLONG, &iColLth, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _iColLth$[ebp]
	push	edx
	push	-16					; fffffff0H
	push	7
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLBindCol@24

; 6036 :       SQLBindCol( lpConnection->hstmt, 11, SQL_C_SSHORT, &sNullable, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _sNullable$[ebp]
	push	edx
	push	-15					; fffffff1H
	push	11					; 0000000bH
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLBindCol@24
$LN7@RetrieveSc:

; 6037 : #endif
; 6038 : 
; 6039 :       while ( TRUE )

	mov	edx, 1
	test	edx, edx
	je	$LN8@RetrieveSc

; 6040 :       {
; 6041 :          zCHAR szDataType[ 20 ];
; 6042 : 
; 6043 : #if defined( DB2 ) || defined( ODBC )
; 6044 : 
; 6045 :          nRC = SQLFetch( lpConnection->hstmt );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLFetch@4
	mov	WORD PTR _nRC$[ebp], ax

; 6046 :          SQL_RC( "SQLFetch", nRC, "Fetch column name", 0, 1 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	1
	push	0
	push	OFFSET $SG96302
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG96303
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 6047 :          if ( !RC_SUCCESSFUL( nRC ) )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@RetrieveSc
	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	je	SHORT $LN23@RetrieveSc

; 6048 :             break;

	jmp	$LN8@RetrieveSc
$LN23@RetrieveSc:

; 6049 : 
; 6050 :          switch ( sDataType )

	movsx	eax, WORD PTR _sDataType$[ebp]
	mov	DWORD PTR tv340[ebp], eax
	mov	ecx, DWORD PTR tv340[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR tv340[ebp], ecx
	cmp	DWORD PTR tv340[ebp], 103		; 00000067H
	ja	$LN35@RetrieveSc
	mov	edx, DWORD PTR tv340[ebp]
	movzx	eax, BYTE PTR $LN45@RetrieveSc[edx]
	jmp	DWORD PTR $LN46@RetrieveSc[eax*4]
$LN24@RetrieveSc:

; 6051 :          {
; 6052 :             case SQL_CHAR:
; 6053 :                szDataType[ 0 ] = zTYPE_FIXEDCHAR;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szDataType$3[ebp+edx], 70	; 00000046H

; 6054 :                break;

	jmp	$LN9@RetrieveSc
$LN25@RetrieveSc:

; 6055 : 
; 6056 :             case SQL_VARCHAR:
; 6057 :                szDataType[ 0 ] = zTYPE_STRING;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szDataType$3[ebp+ecx], 83	; 00000053H

; 6058 :                break;

	jmp	$LN9@RetrieveSc
$LN26@RetrieveSc:

; 6059 : 
; 6060 :             case SQL_LONGVARCHAR:
; 6061 :             case -9:   // No idea what it is, but it's returned by SqlServer.
; 6062 :             case -10:  // Returned by SqlServer, says its an ntext.
; 6063 :                szDataType[ 0 ] = 'V';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szDataType$3[ebp+eax], 86	; 00000056H

; 6064 :                break;

	jmp	$LN9@RetrieveSc
$LN27@RetrieveSc:

; 6065 : 
; 6066 :             case SQL_INTEGER:
; 6067 :             case SQL_SMALLINT:
; 6068 :                szDataType[ 0 ] = zTYPE_INTEGER;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szDataType$3[ebp+edx], 76	; 0000004cH

; 6069 :                iColLth = 4;

	mov	DWORD PTR _iColLth$[ebp], 4

; 6070 :                break;

	jmp	$LN9@RetrieveSc
$LN28@RetrieveSc:

; 6071 : 
; 6072 :             case -6:  // SQL_TINYINT
; 6073 :                szDataType[ 0 ] = zTYPE_INTEGER;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szDataType$3[ebp+ecx], 76	; 0000004cH

; 6074 :                iColLth = 1;

	mov	DWORD PTR _iColLth$[ebp], 1

; 6075 :                break;

	jmp	$LN9@RetrieveSc
$LN29@RetrieveSc:

; 6076 : 
; 6077 :             case -5:  // SQL_BIGINT
; 6078 :                szDataType[ 0 ] = zTYPE_INTEGER;

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szDataType$3[ebp+eax], 76	; 0000004cH

; 6079 :                iColLth = 8;

	mov	DWORD PTR _iColLth$[ebp], 8

; 6080 :                break;

	jmp	$LN9@RetrieveSc
$LN30@RetrieveSc:

; 6081 : 
; 6082 :             case SQL_REAL:
; 6083 :             case SQL_FLOAT:
; 6084 :             case SQL_DOUBLE:
; 6085 :                szDataType[ 0 ] = zTYPE_DECIMAL;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szDataType$3[ebp+edx], 77	; 0000004dH

; 6086 :                iColLth = 40;

	mov	DWORD PTR _iColLth$[ebp], 40		; 00000028H

; 6087 :                break;

	jmp	$LN9@RetrieveSc
$LN31@RetrieveSc:

; 6088 : 
; 6089 :             case SQL_TYPE_DATE:
; 6090 :             case SQL_DATE:
; 6091 :                szDataType[ 0 ] = zTYPE_DATE;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szDataType$3[ebp+ecx], 68	; 00000044H

; 6092 :                iColLth = 4;

	mov	DWORD PTR _iColLth$[ebp], 4

; 6093 :                break;

	jmp	$LN9@RetrieveSc
$LN32@RetrieveSc:

; 6094 : 
; 6095 :             case SQL_TYPE_TIME:
; 6096 :             case SQL_TIME:
; 6097 :                szDataType[ 0 ] = zTYPE_TIME;

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szDataType$3[ebp+eax], 73	; 00000049H

; 6098 :                iColLth = 4;

	mov	DWORD PTR _iColLth$[ebp], 4

; 6099 :                break;

	jmp	$LN9@RetrieveSc
$LN33@RetrieveSc:

; 6100 : 
; 6101 :             case SQL_TYPE_TIMESTAMP:
; 6102 :             case SQL_TIMESTAMP:
; 6103 :                szDataType[ 0 ] = zTYPE_DATETIME;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szDataType$3[ebp+edx], 84	; 00000054H

; 6104 :                iColLth = 4;

	mov	DWORD PTR _iColLth$[ebp], 4

; 6105 :                break;

	jmp	SHORT $LN9@RetrieveSc
$LN34@RetrieveSc:

; 6106 : 
; 6107 :             case SQL_BINARY:
; 6108 :             case SQL_VARBINARY:
; 6109 :             case SQL_LONGVARBINARY:
; 6110 :                szDataType[ 0 ] = zTYPE_BLOB;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szDataType$3[ebp+ecx], 66	; 00000042H

; 6111 :                break;

	jmp	SHORT $LN9@RetrieveSc
$LN35@RetrieveSc:

; 6112 : 
; 6113 :             default:
; 6114 :                TraceLineS( "Unknown datatype = ", szDataTypeName );

	lea	edx, DWORD PTR _szDataTypeName$[ebp]
	push	edx
	push	OFFSET $SG96317
	call	_TraceLineS@8

; 6115 :                TraceLineI( "Datatype number = ", sDataType );

	movsx	eax, WORD PTR _sDataType$[ebp]
	push	eax
	push	OFFSET $SG96318
	call	_TraceLineI@8

; 6116 :                TraceLineS( "Table Name = ", szTableName );

	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	push	OFFSET $SG96319
	call	_TraceLineS@8

; 6117 :                TraceLineS( "ColumnName = ", szColumnName );

	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	push	OFFSET $SG96320
	call	_TraceLineS@8

; 6118 :                SysMessageBox( vDTE, "DGC", "Unhandled data type", 1 );

	push	1
	push	OFFSET $SG96321
	push	OFFSET $SG96322
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16
$LN9@RetrieveSc:

; 6119 :                break;
; 6120 :          }
; 6121 : 
; 6122 :          // Add null terminator.
; 6123 :          szDataType[ 1 ] = 0;

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 20			; 00000014H
	jae	SHORT $LN41@RetrieveSc
	jmp	SHORT $LN42@RetrieveSc
$LN41@RetrieveSc:
	call	___report_rangecheckfailure
$LN42@RetrieveSc:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szDataType$3[ebp+ecx], 0

; 6124 : 
; 6125 : #endif
; 6126 : 
; 6127 :       CreateEntity( vDB, "TE_FieldDataRel", zPOS_LAST );

	push	2
	push	OFFSET $SG96323
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_CreateEntity@12

; 6128 :       SetAttributeFromString( vDB, "TE_FieldDataRel", "Name",

	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	push	OFFSET $SG96324
	push	OFFSET $SG96325
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 6129 :                               szColumnName );
; 6130 :       SetAttributeFromInteger( vDB, "TE_FieldDataRel", "Length",

	mov	edx, DWORD PTR _iColLth$[ebp]
	push	edx
	push	OFFSET $SG96326
	push	OFFSET $SG96327
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 6131 :                                iColLth );
; 6132 :       SetAttributeFromString( vDB, "TE_FieldDataRel", "DataType",

	lea	ecx, DWORD PTR _szDataType$3[ebp]
	push	ecx
	push	OFFSET $SG96328
	push	OFFSET $SG96329
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 6133 :                               szDataType );
; 6134 :    }

	jmp	$LN7@RetrieveSc
$LN8@RetrieveSc:

; 6135 : 
; 6136 : #if defined( DB2 ) || defined( ODBC )
; 6137 : 
; 6138 :       nRC = SQLCloseCursor( lpConnection->hstmt );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLCloseCursor@4
	mov	WORD PTR _nRC$[ebp], ax

; 6139 :       SQL_RC( "SQLCloseCursor", nRC, 0, 0, 2 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	push	0
	push	0
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG96330
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 6140 : 
; 6141 : #endif
; 6142 : 
; 6143 :    } // For each Table

	jmp	$LN4@RetrieveSc
$LN5@RetrieveSc:

; 6144 : 
; 6145 :    // Load Indexes.
; 6146 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG96331
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN13@RetrieveSc
$LN11@RetrieveSc:

; 6148 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG96332
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN13@RetrieveSc:

; 6147 :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN12@RetrieveSc

; 6149 :    {
; 6150 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET $SG96333
	push	OFFSET $SG96334
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 6151 : 
; 6152 : #if defined( DB2 ) || defined( ODBC )
; 6153 :       nRC = SQLStatistics( lpConnection->hstmt, 0, 0, 0, 0, szTableName,

	push	0
	push	1
	push	-3					; fffffffdH
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLStatistics@36
	mov	WORD PTR _nRC$[ebp], ax

; 6154 :                         SQL_NTS, SQL_INDEX_ALL, 0 );
; 6155 :       SQL_RC( "SQLStatistics", nRC, "Get index list", 0, 1 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	1
	push	0
	push	OFFSET $SG96335
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG96336
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 6156 : 
; 6157 :       SQLBindCol( lpConnection->hstmt, 5, SQL_C_CHAR, szIndexQual,

	lea	edx, DWORD PTR _cbTableNameLth$[ebp]
	push	edx
	push	255					; 000000ffH
	lea	eax, DWORD PTR _szIndexQual$[ebp]
	push	eax
	push	1
	push	5
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLBindCol@24

; 6158 :                   STR_LEN, &cbTableNameLth );
; 6159 :       SQLBindCol( lpConnection->hstmt, 6, SQL_C_CHAR, szIndexName,

	lea	eax, DWORD PTR _cbIndexNameLth$[ebp]
	push	eax
	push	255					; 000000ffH
	lea	ecx, DWORD PTR _szIndexName$[ebp]
	push	ecx
	push	1
	push	6
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLBindCol@24

; 6160 :                   STR_LEN, &cbIndexNameLth );
; 6161 :       SQLBindCol( lpConnection->hstmt, 9, SQL_C_CHAR, szColumnName,

	lea	ecx, DWORD PTR _cbColumnNameLth$[ebp]
	push	ecx
	push	255					; 000000ffH
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	push	1
	push	9
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLBindCol@24

; 6162 :                   STR_LEN, &cbColumnNameLth );
; 6163 :       SQLBindCol( lpConnection->hstmt, 11, SQL_C_SLONG, &iCardinality,

	lea	edx, DWORD PTR _cbCardinality$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _iCardinality$[ebp]
	push	eax
	push	-16					; fffffff0H
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLBindCol@24
$LN14@RetrieveSc:

; 6164 :                   0, &cbCardinality );
; 6165 : 
; 6166 : #endif
; 6167 : 
; 6168 :       while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$LN15@RetrieveSc

; 6169 :       {
; 6170 : #if defined( DB2 ) || defined( ODBC )
; 6171 : 
; 6172 :          nRC = SQLFetch( lpConnection->hstmt );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLFetch@4
	mov	WORD PTR _nRC$[ebp], ax

; 6173 :          SQL_RC( "SQLFetch", nRC, "Fetch column name", 0, 1 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	1
	push	0
	push	OFFSET $SG96337
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG96338
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 6174 :          if ( !RC_SUCCESSFUL( nRC ) )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN36@RetrieveSc
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN36@RetrieveSc

; 6175 :             break;

	jmp	$LN15@RetrieveSc
$LN36@RetrieveSc:

; 6176 : 
; 6177 :          // If index name is null, then the current row is a "stat" table
; 6178 :          // so we'll ignore it.
; 6179 :          if ( cbIndexNameLth == SQL_NULL_DATA )

	cmp	DWORD PTR _cbIndexNameLth$[ebp], -1
	jne	SHORT $LN37@RetrieveSc

; 6180 :             continue;

	jmp	SHORT $LN14@RetrieveSc
$LN37@RetrieveSc:

; 6181 : #endif
; 6182 : 
; 6183 :          // Does the index already exist?
; 6184 :          if ( SetCursorFirstEntityByString( vDB, "TE_TablRecKey", "IndexName",
; 6185 :                                             szIndexName, 0 ) < zCURSOR_SET )

	push	0
	lea	ecx, DWORD PTR _szIndexName$[ebp]
	push	ecx
	push	OFFSET $SG96342
	push	OFFSET $SG96343
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorFirstEntityByString@20
	cwde
	test	eax, eax
	jge	SHORT $LN38@RetrieveSc

; 6186 :          {
; 6187 :             CreateEntity( vDB, "TE_TablRecKey", zPOS_LAST );

	push	2
	push	OFFSET $SG96344
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CreateEntity@12

; 6188 :             SetAttributeFromString( vDB, "TE_TablRecKey", "IndexName", szIndexName );

	lea	edx, DWORD PTR _szIndexName$[ebp]
	push	edx
	push	OFFSET $SG96345
	push	OFFSET $SG96346
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 6189 :             SetAttributeFromString( vDB, "TE_TablRecKey", "Name",

	push	OFFSET $SG96347
	push	OFFSET $SG96348
	push	OFFSET $SG96349
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN38@RetrieveSc:

; 6190 :                                     "Retrieved From DB" );
; 6191 :          }
; 6192 : 
; 6193 :          // Find the column in the column list.
; 6194 :          if ( SetCursorFirstEntityByString( vDB, "TE_FieldDataRel", "Name",
; 6195 :                                             szColumnName, 0 ) >= zCURSOR_SET )

	push	0
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	push	OFFSET $SG96351
	push	OFFSET $SG96352
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jl	SHORT $LN39@RetrieveSc

; 6196 :          {
; 6197 :             IncludeSubobjectFromSubobject( vDB, "TE_FieldDataRelKey",

	push	2
	push	OFFSET $SG96353
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	push	OFFSET $SG96354
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_IncludeSubobjectFromSubobject@20
$LN39@RetrieveSc:

; 6198 :                                            vDB, "TE_FieldDataRel", zPOS_LAST );
; 6199 :          }
; 6200 :       }

	jmp	$LN14@RetrieveSc
$LN15@RetrieveSc:

; 6201 : 
; 6202 : #if defined( DB2 ) || defined( ODBC )
; 6203 : 
; 6204 :       nRC = SQLCloseCursor( lpConnection->hstmt );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLCloseCursor@4
	mov	WORD PTR _nRC$[ebp], ax

; 6205 :       SQL_RC( "SQLCloseCursor", nRC, 0, 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	0
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG96355
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 6206 : 
; 6207 : #endif
; 6208 : 
; 6209 :    } // For each Table

	jmp	$LN11@RetrieveSc
$LN12@RetrieveSc:

; 6210 : 
; 6211 : #if defined( DB2 ) || defined( ODBC )
; 6212 : 
; 6213 :    SQLFreeHandle( SQL_HANDLE_STMT, (SQLHANDLE) lpConnection->hstmt );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	push	3
	call	_SQLFreeHandle@8

; 6214 :    SQLFreeHandle( SQL_HANDLE_DBC,  (SQLHANDLE) lpConnection->hdbc );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2808]
	push	edx
	push	2
	call	_SQLFreeHandle@8

; 6215 :    SQLFreeHandle( SQL_HANDLE_ENV,  (SQLHANDLE) lpConnection->henv);

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2804]
	push	ecx
	push	1
	call	_SQLFreeHandle@8

; 6216 : 
; 6217 : #endif
; 6218 : 
; 6219 :    return( 0 );

	xor	eax, eax
$LN40@RetrieveSc:

; 6220 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN46@RetrieveSc:
	DD	$LN26@RetrieveSc
	DD	$LN28@RetrieveSc
	DD	$LN29@RetrieveSc
	DD	$LN34@RetrieveSc
	DD	$LN24@RetrieveSc
	DD	$LN27@RetrieveSc
	DD	$LN30@RetrieveSc
	DD	$LN31@RetrieveSc
	DD	$LN32@RetrieveSc
	DD	$LN33@RetrieveSc
	DD	$LN25@RetrieveSc
	DD	$LN35@RetrieveSc
$LN45@RetrieveSc:
	DB	0
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	0
	DB	11					; 0000000bH
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	5
	DB	5
	DB	6
	DB	6
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	7
	DB	8
	DB	9
_RetrieveSchema@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpParent$1 = -16					; size = 4
tv296 = -12						; size = 4
_lpConnection$ = -8					; size = 4
_nRC$ = -4						; size = 2
_hTask$ = 8						; size = 4
_Message$ = 12						; size = 2
_Indicators$ = 16					; size = 4
_lpViewOD$ = 20						; size = 4
_lpViewEntity$ = 24					; size = 4
_lpView$ = 28						; size = 4
_lpQualView$ = 32					; size = 4
_ppvWorkPtr$ = 36					; size = 4
_DBH_MsgProc@32 PROC

; 5420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5421 :    LPCONNECTION lpConnection;
; 5422 :    zSHORT       nRC;
; 5423 : 
; 5424 :    // Execute a function according to the message passed.
; 5425 : // TraceLineX( "DBH_MsgProc Message: ", Message );
; 5426 :    if ( Message & DBH_Entity )

	movzx	eax, WORD PTR _Message$[ebp]
	and	eax, 32768				; 00008000H
	je	$LN2@DBH_MsgPro

; 5427 :    {
; 5428 : 
; 5429 : #if Timer
; 5430 :       lEntityMessageCount++;
; 5431 : #endif
; 5432 : 
; 5433 :       nRC = GetWorkObjectView( hTask, lpView, lpViewOD, lpViewEntity,

	lea	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvWorkPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	call	_GetWorkObjectView
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 5434 :                                ppvWorkPtr, &lpConnection );
; 5435 :       if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN4@DBH_MsgPro

; 5436 :          goto EndOfFunction;

	jmp	$EndOfFunction$50
$LN4@DBH_MsgPro:

; 5437 : 
; 5438 :       if ( Message & DBH_Load )

	movzx	edx, WORD PTR _Message$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN5@DBH_MsgPro

; 5439 :          nRC = Load( lpViewEntity, lpView, lpViewOD, lpQualView, lpConnection,

	mov	eax, DWORD PTR _Indicators$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	_Load
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	$LN6@DBH_MsgPro
$LN5@DBH_MsgPro:

; 5440 :                      Indicators );
; 5441 :       else
; 5442 :       if ( Message & DBH_Insert )

	movzx	eax, WORD PTR _Message$[ebp]
	and	eax, 1
	je	SHORT $LN7@DBH_MsgPro

; 5443 :          nRC = Insert( lpViewEntity, lpView, lpViewOD, FALSE, lpConnection );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	_Insert
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	$LN6@DBH_MsgPro
$LN7@DBH_MsgPro:

; 5444 :       else
; 5445 :       if ( Message & DBH_InsertRel )

	movzx	edx, WORD PTR _Message$[ebp]
	and	edx, 2
	je	SHORT $LN9@DBH_MsgPro

; 5446 :          nRC = InsertRel( lpViewEntity, lpView, lpViewOD, lpConnection );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_InsertRel
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	$LN6@DBH_MsgPro
$LN9@DBH_MsgPro:

; 5447 :       else
; 5448 :       if ( Message & DBH_Delete )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 4
	je	SHORT $LN11@DBH_MsgPro

; 5449 :       {
; 5450 :          if ( Message & DBH_DeleteAll )

	movzx	edx, WORD PTR _Message$[ebp]
	and	edx, 1024				; 00000400H
	je	SHORT $LN13@DBH_MsgPro

; 5451 :             lpConnection->bDeleteAll = TRUE;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	or	ecx, 4
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+800], ecx
$LN13@DBH_MsgPro:

; 5452 : 
; 5453 :          nRC = Delete( lpViewEntity, lpView, lpViewOD, lpConnection );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_Delete
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 5454 :       // lpConnection->bDeleteAll = FALSE;  turned off in Delete call
; 5455 :       }

	jmp	SHORT $LN6@DBH_MsgPro
$LN11@DBH_MsgPro:

; 5456 :       else
; 5457 :       if ( Message & DBH_DeleteRel )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 8
	je	SHORT $LN14@DBH_MsgPro

; 5458 :          nRC = DeleteRel( lpViewEntity, lpView, lpViewOD, lpConnection );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	_DeleteRel
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN6@DBH_MsgPro
$LN14@DBH_MsgPro:

; 5459 :       else
; 5460 :       if ( Message & DBH_Update )

	movzx	eax, WORD PTR _Message$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN16@DBH_MsgPro

; 5461 :          nRC = Update( lpViewEntity, lpView, lpViewOD, FALSE, lpConnection );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	_Update
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN6@DBH_MsgPro
$LN16@DBH_MsgPro:

; 5462 :       else
; 5463 :       if ( Message & DBH_UpdateSeq )

	movzx	edx, WORD PTR _Message$[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN6@DBH_MsgPro

; 5464 :          nRC = Update( lpViewEntity, lpView, lpViewOD, TRUE, lpConnection );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_Update
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN6@DBH_MsgPro:

; 5465 : 
; 5466 :       if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	$LN19@DBH_MsgPro

; 5467 :       {
; 5468 :          TraceLineS( "", "" );

	push	OFFSET $SG96084
	push	OFFSET $SG96085
	call	_TraceLineS@8

; 5469 :          if ( Message & DBH_Load )

	movzx	edx, WORD PTR _Message$[ebp]
	and	edx, 32					; 00000020H
	je	SHORT $LN20@DBH_MsgPro

; 5470 :             TraceLineS( "Error performing Load for OD: ", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG96088
	call	_TraceLineS@8
	jmp	$LN21@DBH_MsgPro
$LN20@DBH_MsgPro:

; 5471 :          else
; 5472 :          if ( Message & DBH_Insert )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 1
	je	SHORT $LN22@DBH_MsgPro

; 5473 :             TraceLineS( "Error performing Insert for OD: ", lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG96091
	call	_TraceLineS@8
	jmp	SHORT $LN21@DBH_MsgPro
$LN22@DBH_MsgPro:

; 5474 :          else
; 5475 :          if ( Message & DBH_InsertRel )

	movzx	eax, WORD PTR _Message$[ebp]
	and	eax, 2
	je	SHORT $LN24@DBH_MsgPro

; 5476 :             TraceLineS( "Error performing InsertRel for OD: ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG96094
	call	_TraceLineS@8
	jmp	SHORT $LN21@DBH_MsgPro
$LN24@DBH_MsgPro:

; 5477 :          else
; 5478 :          if ( Message & DBH_Delete )

	movzx	edx, WORD PTR _Message$[ebp]
	and	edx, 4
	je	SHORT $LN26@DBH_MsgPro

; 5479 :             TraceLineS( "Error performing Delete for OD: ", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG96097
	call	_TraceLineS@8
	jmp	SHORT $LN21@DBH_MsgPro
$LN26@DBH_MsgPro:

; 5480 :          else
; 5481 :          if ( Message & DBH_DeleteRel )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 8
	je	SHORT $LN28@DBH_MsgPro

; 5482 :             TraceLineS( "Error performing DeleteRel for OD: ", lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG96100
	call	_TraceLineS@8
	jmp	SHORT $LN21@DBH_MsgPro
$LN28@DBH_MsgPro:

; 5483 :          else
; 5484 :          if ( Message & DBH_Update )

	movzx	eax, WORD PTR _Message$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN21@DBH_MsgPro

; 5485 :             TraceLineS( "Error performing Update for OD: ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG96102
	call	_TraceLineS@8
$LN21@DBH_MsgPro:

; 5486 : 
; 5487 :          if ( lpViewEntity->hParent )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN31@DBH_MsgPro

; 5488 :          {
; 5489 :             LPVIEWENTITY lpParent = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$1[ebp], eax

; 5490 : 
; 5491 :             TraceLineS( "PARENT:", "" );

	push	OFFSET $SG96104
	push	OFFSET $SG96105
	call	_TraceLineS@8

; 5492 :             DisplayEntityInstance( lpView, lpParent->szName );

	mov	edx, DWORD PTR _lpParent$1[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_DisplayEntityInstance@8

; 5493 :             TraceLineS( "", "" );

	push	OFFSET $SG96106
	push	OFFSET $SG96107
	call	_TraceLineS@8

; 5494 :             TraceLineS( "CHILD:", "" );

	push	OFFSET $SG96108
	push	OFFSET $SG96109
	call	_TraceLineS@8
$LN31@DBH_MsgPro:

; 5495 :          }
; 5496 : 
; 5497 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DisplayEntityInstance@8

; 5498 : 
; 5499 :          if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $LN19@DBH_MsgPro

; 5500 :          {
; 5501 :             TraceLineS( "Qualification View:", "" );

	push	OFFSET $SG96111
	push	OFFSET $SG96112
	call	_TraceLineS@8

; 5502 :             DisplayObjectInstance( lpQualView, 0, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_DisplayObjectInstance@12
$LN19@DBH_MsgPro:

; 5503 :          }
; 5504 :       }
; 5505 :    }

	jmp	$EndOfFunction$50
$LN2@DBH_MsgPro:

; 5506 :    else
; 5507 :    if ( Message & DBH_Object )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 16384				; 00004000H
	je	$LN33@DBH_MsgPro

; 5508 :    {
; 5509 :       nRC = GetWorkObjectView( hTask, lpView, lpViewOD, lpViewEntity,

	lea	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvWorkPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hTask$[ebp]
	push	ecx
	call	_GetWorkObjectView
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 5510 :                                ppvWorkPtr, &lpConnection );
; 5511 :       if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN35@DBH_MsgPro

; 5512 :          goto EndOfFunction;

	jmp	$EndOfFunction$50
$LN35@DBH_MsgPro:

; 5513 : 
; 5514 :       if ( Message & DBH_TranBegin )

	movzx	eax, WORD PTR _Message$[ebp]
	and	eax, 1
	je	SHORT $LN36@DBH_MsgPro

; 5515 :          nRC = BeginTransaction( Indicators, lpViewOD, lpView, lpQualView,

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Indicators$[ebp]
	push	edx
	call	_BeginTransaction
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	$LN37@DBH_MsgPro
$LN36@DBH_MsgPro:

; 5516 :                                  lpConnection );
; 5517 :       else
; 5518 :       if ( Message & DBH_Commit )

	movzx	eax, WORD PTR _Message$[ebp]
	and	eax, 2
	je	SHORT $LN38@DBH_MsgPro

; 5519 :          nRC = CommitTransaction( lpView, Indicators, lpConnection );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Indicators$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_CommitTransaction
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN37@DBH_MsgPro
$LN38@DBH_MsgPro:

; 5520 :       else
; 5521 :       if ( Message & DBH_Rollback )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 4
	je	SHORT $LN40@DBH_MsgPro

; 5522 :          nRC = RollbackTransaction( Indicators, lpConnection );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	mov	eax, DWORD PTR _Indicators$[ebp]
	push	eax
	call	_RollbackTransaction
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN37@DBH_MsgPro
$LN40@DBH_MsgPro:

; 5523 :       else
; 5524 :       if ( Message & DBH_NewObject )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 8
	je	SHORT $LN37@DBH_MsgPro

; 5525 :       {
; 5526 :          if ( lpConnection->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	test	eax, eax
	jle	SHORT $LN37@DBH_MsgPro

; 5527 :          {
; 5528 :             TraceLineS( "---------------------------------", "" );

	push	OFFSET $SG96124
	push	OFFSET $SG96125
	call	_TraceLineS@8

; 5529 :             TraceLineS( "Committing object ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG96126
	call	_TraceLineS@8

; 5530 :             TraceLineS( "---------------------------------", "" );

	push	OFFSET $SG96127
	push	OFFSET $SG96128
	call	_TraceLineS@8
$LN37@DBH_MsgPro:

; 5531 :          }
; 5532 :       }
; 5533 :    }

	jmp	SHORT $EndOfFunction$50
$LN33@DBH_MsgPro:

; 5534 :    else
; 5535 :    if ( Message & DBH_Init )

	movzx	edx, WORD PTR _Message$[ebp]
	and	edx, 4096				; 00001000H
	je	SHORT $LN44@DBH_MsgPro

; 5536 :       nRC = InitDatabase( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_InitDatabase
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $EndOfFunction$50
$LN44@DBH_MsgPro:

; 5537 :    else
; 5538 :    if ( Message & (DBH_Term | DBH_TaskCloseAll) )

	movzx	ecx, WORD PTR _Message$[ebp]
	and	ecx, 8448				; 00002100H
	je	SHORT $EndOfFunction$50

; 5539 :       nRC = CloseDatabase( lpQualView ? lpQualView : lpView, Indicators );

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $LN48@DBH_MsgPro
	mov	edx, DWORD PTR _lpQualView$[ebp]
	mov	DWORD PTR tv296[ebp], edx
	jmp	SHORT $LN49@DBH_MsgPro
$LN48@DBH_MsgPro:
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR tv296[ebp], eax
$LN49@DBH_MsgPro:
	mov	ecx, DWORD PTR _Indicators$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv296[ebp]
	push	edx
	call	_CloseDatabase
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$50:

; 5540 : 
; 5541 : EndOfFunction:
; 5542 : 
; 5543 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 5544 : 
; 5545 : } // fnDBH_MsgProc

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_DBH_MsgProc@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lProcessID$ = -3204					; size = 4
_v$1 = -3200						; size = 4
$T2 = -3196						; size = 4
_lTask$3 = -3192					; size = 4
_nTraceLevel$4 = -3188					; size = 2
_lpConnection$ = -3184					; size = 4
_nRC$ = -3180						; size = 2
_vDbhWork$ = -3176					; size = 4
_ConnRec$5 = -3172					; size = 2928
_szLogicalName$ = -244					; size = 200
_szStr$6 = -44						; size = 20
_szStr$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_hTask$ = 8						; size = 4
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_lpViewEntity$ = 20					; size = 4
_ppvWorkPtr$ = 24					; size = 4
_lppConnection$ = 28					; size = 4
_GetWorkObjectView PROC

; 4727 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3204				; 00000c84H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4728 :    LPCONNECTION     lpConnection;
; 4729 :    zVIEW            vDbhWork;
; 4730 :    zCHAR            szLogicalName[ 200 ];
; 4731 :    zCHAR            szStr[ 20 ];
; 4732 :    zLONG            lProcessID;
; 4733 :    zSHORT           nRC;
; 4734 : 
; 4735 :    // If vDbhWorkPTr points to a null pointer then we haven't yet initialized
; 4736 :    // the work pointer--so do it.
; 4737 :    if ( *ppvWorkPtr == 0 )

	mov	eax, DWORD PTR _ppvWorkPtr$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN2@GetWorkObj

; 4738 :    {
; 4739 :       ConnectionRecord ConnRec;
; 4740 :       zSHORT           nTraceLevel = 0;

	xor	ecx, ecx
	mov	WORD PTR _nTraceLevel$4[ebp], cx

; 4741 : 
; 4742 :       GetViewByName( &vDbhWork, zDBHANDLER_WORK_VIEW_NAME, lpView, zLEVEL_SYSTEM );

	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	OFFSET $SG95792
	lea	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	call	_GetViewByName@16

; 4743 :       if ( vDbhWork == 0 )

	cmp	DWORD PTR _vDbhWork$[ebp], 0
	jne	SHORT $LN4@GetWorkObj

; 4744 :       {
; 4745 :          DBH_Error( lpView, "Can't find DB-Handler work view.", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG95794
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DBH_Error
	add	esp, 16					; 00000010H

; 4746 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN15@GetWorkObj
$LN4@GetWorkObj:

; 4747 :       }
; 4748 : 
; 4749 :       SysMutexLock( lpView, "Zeidon DBH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG95795
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMutexLock@16

; 4750 : 
; 4751 :       CreateViewFromViewForTask( &vDbhWork, vDbhWork, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 4752 : 
; 4753 :       szStr[ 0 ] = zSQL_type;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szStr$[ebp+ecx], 79		; 0000004fH

; 4754 :       szStr[ 1 ] = 0;

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 20			; 00000014H
	jae	SHORT $LN16@GetWorkObj
	jmp	SHORT $LN17@GetWorkObj
$LN16@GetWorkObj:
	call	___report_rangecheckfailure
$LN17@GetWorkObj:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szStr$[ebp+edx], 0

; 4755 : 
; 4756 :       nRC = SetCursorFirstEntityByString( vDbhWork, "Type", "Type", szStr, 0 );

	push	0
	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	push	OFFSET $SG95796
	push	OFFSET $SG95797
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax

; 4757 :       if ( nRC != zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN5@GetWorkObj

; 4758 :       {
; 4759 :          CreateEntity( vDbhWork, "Type", zPOS_LAST );

	push	2
	push	OFFSET $SG95799
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	call	_CreateEntity@12

; 4760 :          SetAttributeFromString( vDbhWork, "Type", "Type", szStr );

	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	push	OFFSET $SG95800
	push	OFFSET $SG95801
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$LN5@GetWorkObj:

; 4761 :       }
; 4762 : 
; 4763 : #if 1
; 4764 :       {
; 4765 :          zVIEW v = GetDefaultViewForActiveTask( );

	call	_GetDefaultViewForActiveTask@0
	mov	DWORD PTR _v$1[ebp], eax

; 4766 :          zLONG lTask;
; 4767 : 
; 4768 :          if ( v && (LPTASK) (lTask = SysGetTaskFromView( v )) != hTask )

	cmp	DWORD PTR _v$1[ebp], 0
	je	SHORT $LN6@GetWorkObj
	mov	eax, DWORD PTR _v$1[ebp]
	push	eax
	call	_SysGetTaskFromView@4
	mov	DWORD PTR _lTask$3[ebp], eax
	mov	ecx, DWORD PTR _lTask$3[ebp]
	cmp	ecx, DWORD PTR _hTask$[ebp]
	je	SHORT $LN6@GetWorkObj

; 4769 :          {
; 4770 :             TraceLine( "GetWorkObjectView RESETTING task from: 0x%08x  to: 0x%08x",

	mov	edx, DWORD PTR _lTask$3[ebp]
	push	edx
	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	push	OFFSET $SG95803
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 4771 :                        hTask, lTask );
; 4772 :             hTask = (LPTASK) lTask;

	mov	ecx, DWORD PTR _lTask$3[ebp]
	mov	DWORD PTR _hTask$[ebp], ecx
$LN6@GetWorkObj:

; 4773 :          }
; 4774 :       }
; 4775 : #endif
; 4776 : 
; 4777 :       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 4778 :    // zltoa( (zLONG) hTask, szLogicalName );
; 4779 :       zsprintf( szLogicalName, "0x%08x:%08x", hTask, lProcessID );

	mov	edx, DWORD PTR _lProcessID$[ebp]
	push	edx
	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	push	OFFSET $SG95804
	lea	ecx, DWORD PTR _szLogicalName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4780 : 
; 4781 :    // sprintf( szLogicalName, "0x%08x", SysGetTaskFromView( lpView ) );
; 4782 : 
; 4783 :       nRC = SetCursorFirstEntityByString( vDbhWork, "Connection",

	push	OFFSET $SG95805
	lea	edx, DWORD PTR _szLogicalName$[ebp]
	push	edx
	push	OFFSET $SG95806
	push	OFFSET $SG95807
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax

; 4784 :                                           "LogicalUserName", szLogicalName, "" );
; 4785 :       if ( nRC != zCURSOR_SET )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	$LN7@GetWorkObj

; 4786 :       {
; 4787 :          CreateEntity( vDbhWork, "Connection", zPOS_AFTER );

	push	3
	push	OFFSET $SG95810
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_CreateEntity@12

; 4788 :          SetAttributeFromString( vDbhWork, "Connection",

	lea	eax, DWORD PTR _szLogicalName$[ebp]
	push	eax
	push	OFFSET $SG95811
	push	OFFSET $SG95812
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4789 :                                  "LogicalUserName", szLogicalName );
; 4790 :       // TraceLineS( "GetWorkObjectView adding Connection =======================>",
; 4791 :       //             szLogicalName );   // dks debug
; 4792 :          SetAttributeFromInteger( vDbhWork, "Connection",

	mov	edx, DWORD PTR _hTask$[ebp]
	push	edx
	push	OFFSET $SG95813
	push	OFFSET $SG95814
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4793 :                                   "TaskID", (zLONG) hTask );
; 4794 : 
; 4795 :          zmemset( (zPVOID) &ConnRec, 0, sizeof( ConnRec ) );

	push	2928					; 00000b70H
	push	0
	lea	ecx, DWORD PTR _ConnRec$5[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 4796 : #ifdef DEBUG
; 4797 :          zstrcpy( ConnRec.szDebug1, "Conn BEGIN" );

	push	OFFSET $SG95815
	lea	edx, DWORD PTR _ConnRec$5[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4798 :          zstrcpy( ConnRec.szDebug2, "Conn END" );

	push	OFFSET $SG95816
	lea	eax, DWORD PTR _ConnRec$5[ebp+2908]
	push	eax
	call	_strcpy
	add	esp, 8

; 4799 : #endif
; 4800 : 
; 4801 :          SetAttributeFromBlob( vDbhWork, "Connection", "ConnectionBlob",

	push	2928					; 00000b70H
	lea	ecx, DWORD PTR _ConnRec$5[ebp]
	push	ecx
	push	OFFSET $SG95817
	push	OFFSET $SG95818
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_SetAttributeFromBlob@20

; 4802 :                                (zPVOID) &ConnRec, sizeof( ConnectionRecord ) );
; 4803 : 
; 4804 :          GetAddrForAttribute( (zPVOID) lppConnection, vDbhWork,

	push	OFFSET $SG95819
	push	OFFSET $SG95820
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lppConnection$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4805 :                               "Connection", "ConnectionBlob" );
; 4806 : 
; 4807 :          lpConnection = *lppConnection;

	mov	edx, DWORD PTR _lppConnection$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConnection$[ebp], eax

; 4808 :          lpConnection->vDbhWork = vDbhWork;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 4809 : 
; 4810 :          // Allocate space for SQL commands and the column buffer.
; 4811 :          fnAllocateConnectionMemory( lpView, *lppConnection, TRUE, MAX_SQLCMD_LENGTH );

	push	105000					; 00019a28H
	push	1
	mov	eax, DWORD PTR _lppConnection$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnAllocateConnectionMemory@16

; 4812 :          if ( lpConnection->hCmdMem == 0 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [eax+198], 0
	jne	SHORT $LN9@GetWorkObj

; 4813 :          {
; 4814 :             SysMutexUnlock( lpView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG95822
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMutexUnlock@12

; 4815 :             DropView( vDbhWork );

	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_DropView@4

; 4816 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN15@GetWorkObj
$LN9@GetWorkObj:

; 4817 :          }
; 4818 : 
; 4819 :          fnAllocateConnectionMemory( lpView, *lppConnection, FALSE, TABLE_BUFFER_LTH );

	push	32000					; 00007d00H
	push	0
	mov	eax, DWORD PTR _lppConnection$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnAllocateConnectionMemory@16

; 4820 :          if ( lpConnection->hTblMem == 0 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [eax+210], 0
	jne	SHORT $LN10@GetWorkObj

; 4821 :          {
; 4822 :             SysMutexUnlock( lpView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG95824
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMutexUnlock@12

; 4823 : 
; 4824 :             // Free connection memory (last parm zero).
; 4825 :             fnAllocateConnectionMemory( lpView, *lppConnection, TRUE, 0 );

	push	0
	push	1
	mov	edx, DWORD PTR _lppConnection$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnAllocateConnectionMemory@16

; 4826 :             DropView( vDbhWork );

	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_DropView@4

; 4827 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN15@GetWorkObj
$LN10@GetWorkObj:

; 4828 :          }
; 4829 : 
; 4830 :       }  // if ( nRC != zCURSOR_SET )...

	jmp	SHORT $LN8@GetWorkObj
$LN7@GetWorkObj:

; 4831 :       else
; 4832 :       {
; 4833 :          GetAddrForAttribute( (zPVOID) lppConnection, vDbhWork,

	push	OFFSET $SG95825
	push	OFFSET $SG95826
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lppConnection$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4834 :                               "Connection", "ConnectionBlob" );
; 4835 :          lpConnection = *lppConnection;

	mov	edx, DWORD PTR _lppConnection$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConnection$[ebp], eax

; 4836 :          lpConnection->vDbhWork = vDbhWork;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	mov	DWORD PTR [ecx+24], edx
$LN8@GetWorkObj:

; 4837 :       }
; 4838 : 
; 4839 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN11@GetWorkObj

; 4840 :          nTraceLevel = GetTaskDBHandlerTraceLevel( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_GetTaskDBHandlerTraceLevel@4
	mov	WORD PTR _nTraceLevel$4[ebp], ax
$LN11@GetWorkObj:

; 4841 : 
; 4842 :       if ( nTraceLevel == 0 )

	movsx	ecx, WORD PTR _nTraceLevel$4[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@GetWorkObj

; 4843 :       {
; 4844 :          zCHAR  szStr[ 20 ];
; 4845 : 
; 4846 :          // Get the default trace level from the INI file.
; 4847 :          SysReadZeidonIni( -1, "[" DBHANDLER_NAME "]", "TraceLevel", szStr );

	lea	edx, DWORD PTR _szStr$6[ebp]
	push	edx
	push	OFFSET $SG95829
	push	OFFSET $SG95830
	push	-1
	call	_SysReadZeidonIni@16

; 4848 :          if ( szStr[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szStr$6[ebp+ecx]
	test	edx, edx
	je	SHORT $LN12@GetWorkObj

; 4849 :             nTraceLevel = (zSHORT) zatol( szStr );

	lea	eax, DWORD PTR _szStr$6[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nTraceLevel$4[ebp], ax
$LN12@GetWorkObj:

; 4850 :       }
; 4851 : 
; 4852 :       lpConnection->nTraceLevel = nTraceLevel;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	dx, WORD PTR _nTraceLevel$4[ebp]
	mov	WORD PTR [ecx+214], dx

; 4853 : 
; 4854 :       *ppvWorkPtr = (zPVOID) *lppConnection;

	mov	eax, DWORD PTR _ppvWorkPtr$[ebp]
	mov	ecx, DWORD PTR _lppConnection$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 4855 : 
; 4856 :       // Create a subtask view so we can reference the application.
; 4857 :       if ( lpConnection->lpAppView == 0 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN14@GetWorkObj

; 4858 :          SfCreateSubtask( &lpConnection->lpAppView, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	_SfCreateSubtask@12
$LN14@GetWorkObj:

; 4859 : 
; 4860 :       SysMutexUnlock( lpView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG95833
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMutexUnlock@12

; 4861 : 
; 4862 :    } // if ( *ppvWorkPtr == 0 )...

	jmp	SHORT $LN3@GetWorkObj
$LN2@GetWorkObj:

; 4863 :    else
; 4864 :    {
; 4865 :       *lppConnection = (LPCONNECTION) *ppvWorkPtr;

	mov	ecx, DWORD PTR _lppConnection$[ebp]
	mov	edx, DWORD PTR _ppvWorkPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 4866 :       lpConnection = *lppConnection;

	mov	ecx, DWORD PTR _lppConnection$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpConnection$[ebp], edx
$LN3@GetWorkObj:

; 4867 :    }
; 4868 : 
; 4869 : #if defined ( DB2 )
; 4870 : {
; 4871 :    LPOD_LIST lpOD = fnFindOD( lpViewOD, lpConnection );
; 4872 : 
; 4873 :    if ( lpOD == 0 )
; 4874 :       lpOD = fnAddOD( lpViewOD, lpConnection );
; 4875 : }
; 4876 : #endif
; 4877 : 
; 4878 :    nRC = fnOpenDatabaseConnection( lpView, lpViewOD,

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnOpenDatabaseConnection@16
	mov	WORD PTR _nRC$[ebp], ax

; 4879 :                                    lpViewEntity, lpConnection );
; 4880 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN15@GetWorkObj:

; 4881 : 
; 4882 : }  /* GetWorkObjectView */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_GetWorkObjectView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_nRC$ = 8						; size = 2
_fnRC_Text PROC

; 4327 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4328 :    static zCHAR szReturn[ 100 ];
; 4329 : 
; 4330 :    switch ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	add	ecx, 2
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 102		; 00000066H
	ja	$LN11@fnRC_Text
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN13@fnRC_Text[edx]
	jmp	DWORD PTR $LN14@fnRC_Text[eax*4]
$LN4@fnRC_Text:

; 4331 :    {
; 4332 :       case SQL_SUCCESS:
; 4333 :          zsprintf( szReturn, "%d (SQL_SUCCESS)", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95648
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4334 :          break;

	jmp	$LN2@fnRC_Text
$LN5@fnRC_Text:

; 4335 : 
; 4336 :       case SQL_SUCCESS_WITH_INFO:
; 4337 :          zsprintf( szReturn, "%d (SQL_SUCCESS_WITH_INFO)", nRC );

	movsx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95650
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4338 :          break;

	jmp	$LN2@fnRC_Text
$LN6@fnRC_Text:

; 4339 : 
; 4340 :       case SQL_ERROR:
; 4341 :          zsprintf( szReturn, "%d (SQL_ERROR)", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG95652
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4342 :          break;

	jmp	SHORT $LN2@fnRC_Text
$LN7@fnRC_Text:

; 4343 : 
; 4344 :       case SQL_INVALID_HANDLE:
; 4345 :          zsprintf( szReturn, "%d (SQL_INVALID_HANDLE)", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95654
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4346 :          break;

	jmp	SHORT $LN2@fnRC_Text
$LN8@fnRC_Text:

; 4347 : 
; 4348 :       case SQL_NEED_DATA:
; 4349 :          zsprintf( szReturn, "%d (SQL_NEED_DATA)", nRC );

	movsx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95656
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4350 :          break;

	jmp	SHORT $LN2@fnRC_Text
$LN9@fnRC_Text:

; 4351 : 
; 4352 : #ifdef DB2
; 4353 :       case SQL_NO_DATA_FOUND:
; 4354 :          zsprintf( szReturn, "%d (SQL_NO_DATA_FOUND)", nRC );
; 4355 :          break;
; 4356 : #else
; 4357 :       #if (ODBCVER >= 0x0300)
; 4358 :          case SQL_NO_DATA:
; 4359 :             zsprintf( szReturn, "%d (SQL_NO_DATA)", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG95658
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4360 :             break;

	jmp	SHORT $LN2@fnRC_Text
$LN10@fnRC_Text:

; 4361 : #endif
; 4362 : 
; 4363 :       case SQL_STILL_EXECUTING:
; 4364 :          zsprintf( szReturn, "%d (SQL_STILL_EXECUTING)", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95660
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4365 :          break;

	jmp	SHORT $LN2@fnRC_Text
$LN11@fnRC_Text:

; 4366 : #endif
; 4367 : 
; 4368 :       default:
; 4369 :          zsprintf( szReturn, "%d (unknown)", nRC );

	movsx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95662
	push	OFFSET ?szReturn@?1??fnRC_Text@@9@9
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN2@fnRC_Text:

; 4370 :          break;
; 4371 :    }
; 4372 : 
; 4373 :    return( szReturn );

	mov	eax, OFFSET ?szReturn@?1??fnRC_Text@@9@9

; 4374 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@fnRC_Text:
	DD	$LN7@fnRC_Text
	DD	$LN6@fnRC_Text
	DD	$LN4@fnRC_Text
	DD	$LN5@fnRC_Text
	DD	$LN10@fnRC_Text
	DD	$LN8@fnRC_Text
	DD	$LN9@fnRC_Text
	DD	$LN11@fnRC_Text
$LN13@fnRC_Text:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	6
_fnRC_Text ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_CallbackInfo$ = -32					; size = 5
_lpRelRecord$ = -24					; size = 4
_lpDataRecord$ = -20					; size = 4
_pvDBH_Data$ = -16					; size = 4
_lpBoundList$ = -12					; size = 4
_nBuildRC$ = -8						; size = 2
_nRC$ = -4						; size = 2
_lpViewEntity$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_bAutoSeqOnly$ = 20					; size = 2
_lpConnection$ = 24					; size = 4
_Update	PROC

; 4140 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 4141 :    LPDATARECORD    lpDataRecord;
; 4142 :    LPRELRECORD     lpRelRecord;
; 4143 :    LPBOUNDLIST     lpBoundList;
; 4144 :    zPVOID          pvDBH_Data = 0;

	mov	DWORD PTR _pvDBH_Data$[ebp], 0

; 4145 :    zSHORT          nRC, nBuildRC;
; 4146 : 
; 4147 : #if defined( DB2 ) || defined( ODBC )
; 4148 :    CallbackInfoRecord CallbackInfo = { 0 };

	mov	BYTE PTR _CallbackInfo$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 4149 : 
; 4150 :    pvDBH_Data = &CallbackInfo;

	lea	ecx, DWORD PTR _CallbackInfo$[ebp]
	mov	DWORD PTR _pvDBH_Data$[ebp], ecx

; 4151 :    CallbackInfo.cBuildFunction = BUILD_UPDATE;

	mov	BYTE PTR _CallbackInfo$[ebp], 85	; 00000055H

; 4152 : 
; 4153 :    #if defined( ODBC )
; 4154 :       // Get a pointer to the dbh-specific data for ODBC.  We'll pass this
; 4155 :       // info around via the lpBoundList structure.
; 4156 :       CallbackInfo.lpObjectData = zGETPTR( lpViewOD->hDBH_Data );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 4157 :    #endif
; 4158 : 
; 4159 : #endif
; 4160 : 
; 4161 :    SqlInitBoundAttrList( &lpBoundList, 0,

	mov	ecx, DWORD PTR _pvDBH_Data$[ebp]
	push	ecx
	push	50331916				; 0300010cH
	push	OFFSET _fnDBH_Callback@24
	push	0
	lea	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlInitBoundAttrList@20

; 4162 :                          fnDBH_Callback, zCB_FUNCS, pvDBH_Data );
; 4163 : 
; 4164 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4165 : 
; 4166 :    if ( lpConnection->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jle	SHORT $LN2@Update

; 4167 :    {
; 4168 :       TraceLineS( "", "" );

	push	OFFSET $SG95601
	push	OFFSET $SG95602
	call	_TraceLineS@8

; 4169 :       TraceLineS( "========== Update ==========", "" );

	push	OFFSET $SG95603
	push	OFFSET $SG95604
	call	_TraceLineS@8

; 4170 :       TraceLineS( "Updating entity ", lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG95605
	call	_TraceLineS@8

; 4171 :       TraceLineS( "Updating record ", lpDataRecord->szRecordName );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	push	OFFSET $SG95606
	call	_TraceLineS@8

; 4172 :       if ( lpConnection->nTraceLevel > 2 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	cmp	ecx, 2
	jle	SHORT $LN2@Update

; 4173 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_DisplayEntityInstance@8
$LN2@Update:

; 4174 :    }
; 4175 : 
; 4176 :    nBuildRC = SqlBuildUpdate( lpView, lpViewOD, lpViewEntity, bAutoSeqOnly,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	movzx	ecx, WORD PTR _bAutoSeqOnly$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SqlBuildUpdate@24
	mov	WORD PTR _nBuildRC$[ebp], ax

; 4177 :                               lpConnection->pchConnSqlCmd, lpBoundList );
; 4178 :    if ( nBuildRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nBuildRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN4@Update

; 4179 :    {
; 4180 :       SqlFreeBoundAttrList( lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlFreeBoundAttrList@4

; 4181 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Update
$LN4@Update:

; 4182 :    }
; 4183 : 
; 4184 :    // ================================================================
; 4185 :    // Prepare/compile Update statement.
; 4186 :    // ================================================================
; 4187 : 
; 4188 :    // If nBuildRC is -1 then none of the attributes where updated so don't
; 4189 :    // update the table.
; 4190 :    if ( nBuildRC != -1 )

	movsx	ecx, WORD PTR _nBuildRC$[ebp]
	cmp	ecx, -1
	je	$LN5@Update

; 4191 :    {
; 4192 : 
; 4193 : #if defined( DB2 ) || defined( ODBC )
; 4194 : 
; 4195 :       lpConnection->hstmt = lpConnection->hGeneralStmt;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2816]
	mov	DWORD PTR [edx+2812], ecx

; 4196 : 
; 4197 :       nRC = SQLPrepare( lpConnection->hstmt, lpConnection->pchConnSqlCmd, SQL_NTS );

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLPrepare@12
	mov	WORD PTR _nRC$[ebp], ax

; 4198 :       DisplayCommand( "SQLPrepare", nRC, lpConnection );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95610
	call	_DisplayCommand
	add	esp, 12					; 0000000cH

; 4199 :       if ( nRC != SQL_SUCCESS )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN6@Update

; 4200 :       {
; 4201 :          SqlFreeBoundAttrList( lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlFreeBoundAttrList@4

; 4202 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Update
$LN6@Update:

; 4203 :       }
; 4204 : 
; 4205 : #elif defined( DUMMY )
; 4206 : 
; 4207 :       if ( lpConnection->nTraceLevel > 0 )
; 4208 :       {
; 4209 :          TraceLineS( "", "" );
; 4210 :          SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );
; 4211 :       }
; 4212 : 
; 4213 : #endif
; 4214 : 
; 4215 :       nRC = WriteLongChar( lpConnection, lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	call	_WriteLongChar
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 4216 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN7@Update

; 4217 :       {
; 4218 :          SqlFreeBoundAttrList( lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	call	_SqlFreeBoundAttrList@4

; 4219 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Update
$LN7@Update:

; 4220 :       }
; 4221 : 
; 4222 :       // ================================================================
; 4223 :       // Execute Update statement.
; 4224 :       // ================================================================
; 4225 : #if defined( DB2 ) || defined( ODBC )
; 4226 : 
; 4227 :       nRC = SQLExecute( lpConnection->hstmt );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLExecute@4
	mov	WORD PTR _nRC$[ebp], ax

; 4228 :       SQL_RC( "SQLExecute", nRC, 0, 0, 2 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	2
	push	0
	push	0
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95613
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 4229 :       if ( nRC != SQL_SUCCESS )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN5@Update

; 4230 :       {
; 4231 :          // If the trace level is 0 then let's trace the SQL to help debugging.
; 4232 :          if ( lpConnection->nTraceLevel == 0 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	test	edx, edx
	jne	SHORT $LN9@Update

; 4233 :             SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );

	push	0
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	call	_SqlDisplayCommand@8
$LN9@Update:

; 4234 : 
; 4235 :          SqlFreeBoundAttrList( lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlFreeBoundAttrList@4

; 4236 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Update
$LN5@Update:

; 4237 :       }
; 4238 : 
; 4239 : #endif
; 4240 : 
; 4241 :    } // if ( nBuildRC != -1 )...
; 4242 : 
; 4243 :    // We don't need it any more...
; 4244 :    SqlFreeBoundAttrList( lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlFreeBoundAttrList@4

; 4245 : // lpBoundList = 0;
; 4246 : 
; 4247 :    // If the entity has auto seq attributes, then the corr table might have
; 4248 :    // to be updated.  This will only happen if the current entity has a parent
; 4249 :    // and if the relationship is many-to-many.
; 4250 :    lpRelRecord = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 4251 :    if ( lpViewEntity->bAutoSeq && lpViewEntity->hParent &&

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 20					; 00000014H
	and	ecx, 1
	je	$LN10@Update
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	$LN10@Update
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	jne	$LN10@Update

; 4252 :         lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )
; 4253 :    {
; 4254 :       nRC = SqlBuildUpdateCorrTable( lpView, lpViewOD, lpViewEntity,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SqlBuildUpdateCorrTable@20
	mov	WORD PTR _nRC$[ebp], ax

; 4255 :                                      lpConnection->pchConnSqlCmd, lpBoundList );
; 4256 :       SqlFreeBoundAttrList( lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlFreeBoundAttrList@4

; 4257 :    // lpBoundList = 0;
; 4258 :       if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN11@Update

; 4259 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@Update
$LN11@Update:

; 4260 : 
; 4261 :       // ================================================================
; 4262 :       // Update correspondence table.
; 4263 :       // ================================================================
; 4264 : 
; 4265 :       // If nBuildRC is -1 then none of the attributes where updated so don't
; 4266 :       // update the table.
; 4267 :       if ( nRC != -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	je	SHORT $LN10@Update

; 4268 :       {
; 4269 : #if defined( DB2 ) || defined( ODBC )
; 4270 : 
; 4271 :          lpConnection->hstmt = lpConnection->hGeneralStmt;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2816]
	mov	DWORD PTR [edx+2812], ecx

; 4272 : 
; 4273 :          nRC = SQLExecDirect( lpConnection->hstmt, lpConnection->pchConnSqlCmd,

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLExecDirect@12
	mov	WORD PTR _nRC$[ebp], ax

; 4274 :                               SQL_NTS );
; 4275 :          DisplayCommand( "SQLExecDirect", nRC, lpConnection );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95619
	call	_DisplayCommand
	add	esp, 12					; 0000000cH

; 4276 :          if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN10@Update

; 4277 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@Update
$LN10@Update:

; 4278 : 
; 4279 : #elif defined( DUMMY )
; 4280 : 
; 4281 :          if ( lpConnection->nTraceLevel > 0 )
; 4282 :          {
; 4283 :             TraceLineS( "", "" );
; 4284 :             SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );
; 4285 :          }
; 4286 : 
; 4287 : #endif
; 4288 :       } // if ( nBuildRC != -1 )...
; 4289 :    }
; 4290 : 
; 4291 :    lpConnection->bDatabaseChanged = TRUE;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	or	ecx, 2
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+800], ecx

; 4292 : 
; 4293 :    return( 0 );

	xor	eax, eax
$LN1@Update:

; 4294 : }  /* Update */

	mov	esp, ebp
	pop	ebp
	ret	0
_Update	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_CallbackInfo$ = -28					; size = 5
_lpRelRecord$ = -20					; size = 4
_lpBoundList$ = -16					; size = 4
_lpDataRecord$ = -12					; size = 4
_pvDBH_Data$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpViewEntity$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_lpConnection$ = 20					; size = 4
_DeleteRel PROC

; 4053 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 4054 :    LPDATARECORD    lpDataRecord;
; 4055 :    LPRELRECORD     lpRelRecord;
; 4056 :    LPBOUNDLIST     lpBoundList;
; 4057 :    zPVOID          pvDBH_Data = 0;

	mov	DWORD PTR _pvDBH_Data$[ebp], 0

; 4058 :    zSHORT          nRC;
; 4059 : 
; 4060 : #if defined( DB2 ) || defined( ODBC )
; 4061 :    CallbackInfoRecord CallbackInfo = { 0 };

	mov	BYTE PTR _CallbackInfo$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 4062 : 
; 4063 :    pvDBH_Data = &CallbackInfo;

	lea	ecx, DWORD PTR _CallbackInfo$[ebp]
	mov	DWORD PTR _pvDBH_Data$[ebp], ecx

; 4064 :    CallbackInfo.cBuildFunction = BUILD_EXCLUDE;

	mov	BYTE PTR _CallbackInfo$[ebp], 88	; 00000058H

; 4065 : 
; 4066 :    #if defined( ODBC )
; 4067 :       // Get a pointer to the dbh-specific data for ODBC.  We'll pass this
; 4068 :       // info around via the lpBoundList structure.
; 4069 :       CallbackInfo.lpObjectData = zGETPTR( lpViewOD->hDBH_Data );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 4070 :    #endif
; 4071 : 
; 4072 : #endif
; 4073 : 
; 4074 :    SqlInitBoundAttrList( &lpBoundList, 0,

	mov	ecx, DWORD PTR _pvDBH_Data$[ebp]
	push	ecx
	push	50331916				; 0300010cH
	push	OFFSET _fnDBH_Callback@24
	push	0
	lea	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlInitBoundAttrList@20

; 4075 :                          fnDBH_Callback, zCB_FUNCS, pvDBH_Data );
; 4076 : 
; 4077 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4078 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 4079 : 
; 4080 :    if ( lpConnection->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 1
	jle	SHORT $LN2@DeleteRel

; 4081 :    {
; 4082 :       TraceLineS( "", "" );

	push	OFFSET $SG95570
	push	OFFSET $SG95571
	call	_TraceLineS@8

; 4083 :       TraceLineS( "========== Delete Rel ==========", "" );

	push	OFFSET $SG95572
	push	OFFSET $SG95573
	call	_TraceLineS@8

; 4084 :       TraceLineS( "Deleting entity ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG95574
	call	_TraceLineS@8

; 4085 :       TraceLineS( "Deleting record ", lpDataRecord->szRecordName );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET $SG95575
	call	_TraceLineS@8

; 4086 :       if ( lpConnection->nTraceLevel > 2 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 2
	jle	SHORT $LN2@DeleteRel

; 4087 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DisplayEntityInstance@8
$LN2@DeleteRel:

; 4088 :    }
; 4089 : 
; 4090 :    // The only thing that needs to be done is to delete the correspondence
; 4091 :    // table if the relationship is many-to-many.
; 4092 :    if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	cmp	ecx, 50					; 00000032H
	jne	$LN4@DeleteRel

; 4093 :    {
; 4094 :       nRC = SqlBuildDeleteCorrTable( lpView, lpViewOD, lpViewEntity,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SqlBuildDeleteCorrTable@20
	mov	WORD PTR _nRC$[ebp], ax

; 4095 :                                      lpConnection->pchConnSqlCmd, lpBoundList );
; 4096 :       SqlFreeBoundAttrList( lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlFreeBoundAttrList@4

; 4097 :    // lpBoundList = 0;
; 4098 :       if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN5@DeleteRel

; 4099 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@DeleteRel
$LN5@DeleteRel:

; 4100 : 
; 4101 :       // ================================================================
; 4102 :       // Delete correspondence table.
; 4103 :       // ================================================================
; 4104 : 
; 4105 : #if defined( DB2 ) || defined( ODBC )
; 4106 : 
; 4107 :       lpConnection->hstmt = lpConnection->hGeneralStmt;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2816]
	mov	DWORD PTR [ecx+2812], eax

; 4108 : 
; 4109 :       nRC = SQLExecDirect( lpConnection->hstmt, lpConnection->pchConnSqlCmd,

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+194]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLExecDirect@12
	mov	WORD PTR _nRC$[ebp], ax

; 4110 :                            SQL_NTS);
; 4111 :       DisplayCommand( "SQLExecDirect", nRC, lpConnection );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG95579
	call	_DisplayCommand
	add	esp, 12					; 0000000cH

; 4112 :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@DeleteRel

; 4113 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@DeleteRel
$LN6@DeleteRel:

; 4114 : 
; 4115 : #elif defined( DUMMY )
; 4116 : 
; 4117 :       if ( lpConnection->nTraceLevel > 0 )
; 4118 :       {
; 4119 :          TraceLineS( "", "" );
; 4120 :          SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );
; 4121 :       }
; 4122 : 
; 4123 : #endif
; 4124 : 
; 4125 :       lpConnection->bDatabaseChanged = TRUE;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+800]
	or	eax, 2
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+800], eax
$LN4@DeleteRel:

; 4126 :    }
; 4127 : 
; 4128 :    return( 0 );

	xor	eax, eax
$LN1@DeleteRel:

; 4129 : }  /* DeleteRel */

	mov	esp, ebp
	pop	ebp
	ret	0
_DeleteRel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_CallbackInfo$ = -32					; size = 5
_lpRelRecord$ = -24					; size = 4
_lpDataRecord$ = -20					; size = 4
_pvDBH_Data$ = -16					; size = 4
_lpBoundList$ = -12					; size = 4
_nRC$ = -8						; size = 2
_bDeleteRequired$ = -1					; size = 1
_lpViewEntity$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_lpConnection$ = 20					; size = 4
_Delete	PROC

; 3954 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 3955 :    LPDATARECORD    lpDataRecord;
; 3956 :    LPRELRECORD     lpRelRecord;
; 3957 :    LPBOUNDLIST     lpBoundList;
; 3958 :    zPVOID          pvDBH_Data = 0;

	mov	DWORD PTR _pvDBH_Data$[ebp], 0

; 3959 :    zBOOL           bDeleteRequired = TRUE;  // dks ... 2006.01.25

	mov	BYTE PTR _bDeleteRequired$[ebp], 1

; 3960 :    zSHORT          nRC;
; 3961 : 
; 3962 : #if defined( DB2 ) || defined( ODBC )
; 3963 :    CallbackInfoRecord CallbackInfo = { 0 };

	mov	BYTE PTR _CallbackInfo$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 3964 : 
; 3965 :    pvDBH_Data = &CallbackInfo;

	lea	ecx, DWORD PTR _CallbackInfo$[ebp]
	mov	DWORD PTR _pvDBH_Data$[ebp], ecx

; 3966 :    CallbackInfo.cBuildFunction = BUILD_DELETE;

	mov	BYTE PTR _CallbackInfo$[ebp], 68	; 00000044H

; 3967 : 
; 3968 :    #if defined( ODBC )
; 3969 :       // Get a pointer to the dbh-specific data for ODBC.  We'll pass this
; 3970 :       // info around via the lpBoundList structure.
; 3971 :       CallbackInfo.lpObjectData = zGETPTR( lpViewOD->hDBH_Data );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 3972 :    #endif
; 3973 : 
; 3974 : #endif
; 3975 : 
; 3976 :    SqlInitBoundAttrList( &lpBoundList, 0,

	mov	ecx, DWORD PTR _pvDBH_Data$[ebp]
	push	ecx
	push	50331916				; 0300010cH
	push	OFFSET _fnDBH_Callback@24
	push	0
	lea	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlInitBoundAttrList@20

; 3977 :                          fnDBH_Callback, zCB_FUNCS, pvDBH_Data );
; 3978 : 
; 3979 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3980 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 3981 : 
; 3982 :    if ( lpConnection->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 1
	jle	SHORT $LN2@Delete

; 3983 :    {
; 3984 :       TraceLineS( "", "" );

	push	OFFSET $SG95539
	push	OFFSET $SG95540
	call	_TraceLineS@8

; 3985 :       TraceLineS( "========== Delete ==========", "" );

	push	OFFSET $SG95541
	push	OFFSET $SG95542
	call	_TraceLineS@8

; 3986 :       TraceLineS( "Deleting entity ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG95543
	call	_TraceLineS@8

; 3987 :       TraceLineS( "Deleting record ", lpDataRecord->szRecordName );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	push	ecx
	push	OFFSET $SG95544
	call	_TraceLineS@8

; 3988 :       if ( lpConnection->nTraceLevel > 2 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 2
	jle	SHORT $LN2@Delete

; 3989 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DisplayEntityInstance@8
$LN2@Delete:

; 3990 :    }
; 3991 : 
; 3992 :    // ================================================================
; 3993 :    // Delete table.
; 3994 :    // ================================================================
; 3995 : 
; 3996 :    // Start dks ... 2006.01.25
; 3997 :    if ( lpConnection->bDeleteAll )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN4@Delete

; 3998 :    {
; 3999 :       if ( SqlBuildDeleteAll( lpView, lpViewOD, lpViewEntity,
; 4000 :                               lpConnection->pchConnSqlCmd, lpBoundList ) == 0 )

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SqlBuildDeleteAll@20
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN5@Delete

; 4001 :       {
; 4002 :          TraceLineS( "SqlBuildDeleteAll SQL: ", lpConnection->pchConnSqlCmd );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	push	OFFSET $SG95548
	call	_TraceLineS@8

; 4003 :          bDeleteRequired = FALSE;

	mov	BYTE PTR _bDeleteRequired$[ebp], 0
$LN5@Delete:

; 4004 :       }
; 4005 : 
; 4006 :       lpConnection->bDeleteAll = FALSE;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+800]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+800], eax
$LN4@Delete:

; 4007 :    }
; 4008 :    // End dks ... 2006.01.25
; 4009 : 
; 4010 :    if ( bDeleteRequired )

	movzx	edx, BYTE PTR _bDeleteRequired$[ebp]
	test	edx, edx
	je	SHORT $LN6@Delete

; 4011 :    {
; 4012 :       nRC = SqlBuildDelete( lpView, lpViewOD, lpViewEntity,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+194]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SqlBuildDelete@20
	mov	WORD PTR _nRC$[ebp], ax
$LN6@Delete:

; 4013 :                             lpConnection->pchConnSqlCmd, lpBoundList );
; 4014 :    }
; 4015 : 
; 4016 :    SqlFreeBoundAttrList( lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlFreeBoundAttrList@4

; 4017 : // lpBoundList = 0;
; 4018 :    if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN7@Delete

; 4019 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@Delete
$LN7@Delete:

; 4020 : 
; 4021 : #if defined( DB2 ) || defined( ODBC )
; 4022 : 
; 4023 :    lpConnection->hstmt = lpConnection->hGeneralStmt;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2816]
	mov	DWORD PTR [edx+2812], ecx

; 4024 : 
; 4025 :    nRC = SQLExecDirect( lpConnection->hstmt, lpConnection->pchConnSqlCmd, SQL_NTS );

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLExecDirect@12
	mov	WORD PTR _nRC$[ebp], ax

; 4026 :    DisplayCommand( "SQLExecDirect", nRC, lpConnection );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95551
	call	_DisplayCommand
	add	esp, 12					; 0000000cH

; 4027 :    if ( nRC != SQL_SUCCESS )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN8@Delete

; 4028 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@Delete
$LN8@Delete:

; 4029 : 
; 4030 : #elif defined( DUMMY )
; 4031 : 
; 4032 :    if ( lpConnection->nTraceLevel > 0 )
; 4033 :    {
; 4034 :       TraceLineS( "", "" );
; 4035 :       SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );
; 4036 :    }
; 4037 : 
; 4038 : #endif
; 4039 : 
; 4040 :    lpConnection->bDatabaseChanged = TRUE;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	or	ecx, 2
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+800], ecx

; 4041 : 
; 4042 :    return( 0 );

	xor	eax, eax
$LN1@Delete:

; 4043 : }  /* Delete */

	mov	esp, ebp
	pop	ebp
	ret	0
_Delete	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_CallbackInfo$ = -36					; size = 5
_pchRecordName$ = -28					; size = 4
_lpRelRecord$ = -24					; size = 4
_lpParent$1 = -20					; size = 4
_lpBoundList$ = -16					; size = 4
_pvDBH_Data$ = -12					; size = 4
_lpDataRecord$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpViewEntity$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_lpConnection$ = 20					; size = 4
_InsertRel PROC

; 3856 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3857 :    LPDATARECORD    lpDataRecord;
; 3858 :    LPRELRECORD     lpRelRecord;
; 3859 :    LPBOUNDLIST     lpBoundList;
; 3860 :    zPVOID          pvDBH_Data = 0;

	mov	DWORD PTR _pvDBH_Data$[ebp], 0

; 3861 :    zPCHAR          pchRecordName;
; 3862 :    zSHORT          nRC;
; 3863 : 
; 3864 : #if defined( DB2 ) || defined( ODBC )
; 3865 :    CallbackInfoRecord CallbackInfo = { 0 };

	mov	BYTE PTR _CallbackInfo$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 3866 : 
; 3867 :    pvDBH_Data = &CallbackInfo;

	lea	ecx, DWORD PTR _CallbackInfo$[ebp]
	mov	DWORD PTR _pvDBH_Data$[ebp], ecx

; 3868 :    CallbackInfo.cBuildFunction = BUILD_INCLUDE;

	mov	BYTE PTR _CallbackInfo$[ebp], 73	; 00000049H

; 3869 : 
; 3870 :    #if defined( ODBC )
; 3871 :       // Get a pointer to the dbh-specific data for ODBC.  We'll pass this
; 3872 :       // info around via the lpBoundList structure.
; 3873 :       CallbackInfo.lpObjectData = zGETPTR( lpViewOD->hDBH_Data );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 3874 :    #endif
; 3875 : 
; 3876 : #endif
; 3877 : 
; 3878 :    SqlInitBoundAttrList( &lpBoundList, 0,

	mov	ecx, DWORD PTR _pvDBH_Data$[ebp]
	push	ecx
	push	50331916				; 0300010cH
	push	OFFSET _fnDBH_Callback@24
	push	0
	lea	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlInitBoundAttrList@20

; 3879 :                          fnDBH_Callback, zCB_FUNCS, pvDBH_Data );
; 3880 : 
; 3881 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3882 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 3883 :    pchRecordName = lpDataRecord->szRecordName;

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	add	ecx, 15					; 0000000fH
	mov	DWORD PTR _pchRecordName$[ebp], ecx

; 3884 : 
; 3885 :    if ( lpConnection->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jle	$LN2@InsertRel

; 3886 :    {
; 3887 :       TraceLineS( "", "" );

	push	OFFSET $SG95506
	push	OFFSET $SG95507
	call	_TraceLineS@8

; 3888 :       TraceLineS( "========== Insert Rel ==========", "" );

	push	OFFSET $SG95508
	push	OFFSET $SG95509
	call	_TraceLineS@8

; 3889 :       TraceLineS( "Inserting rel for entity ", lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG95510
	call	_TraceLineS@8

; 3890 :       TraceLineS( "Inserting rel for record ", lpDataRecord->szRecordName );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	push	OFFSET $SG95511
	call	_TraceLineS@8

; 3891 : 
; 3892 :       if ( lpConnection->nTraceLevel > 2 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	cmp	ecx, 2
	jle	SHORT $LN2@InsertRel

; 3893 :       {
; 3894 :          LPVIEWENTITY lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$1[ebp], eax

; 3895 : 
; 3896 :          TraceLineS( "PARENT:", "" );

	push	OFFSET $SG95513
	push	OFFSET $SG95514
	call	_TraceLineS@8

; 3897 :          DisplayEntityInstance( lpView, lpParent->szName );

	mov	ecx, DWORD PTR _lpParent$1[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DisplayEntityInstance@8

; 3898 : 
; 3899 :          TraceLineS( "CHILD:", "" );

	push	OFFSET $SG95515
	push	OFFSET $SG95516
	call	_TraceLineS@8

; 3900 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DisplayEntityInstance@8
$LN2@InsertRel:

; 3901 :       }
; 3902 :    }
; 3903 : 
; 3904 :    // The only thing that needs to be done is to insert the correspondence
; 3905 :    // table if the relationship is many-to-many.
; 3906 :    if ( lpRelRecord->cOwnerMember == zDBH_MANY_TO_MANY )

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	eax, 50					; 00000032H
	jne	$LN4@InsertRel

; 3907 :    {
; 3908 :       nRC = SqlBuildInsertCorrTable( lpView, lpViewOD, lpViewEntity,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SqlBuildInsertCorrTable@20
	mov	WORD PTR _nRC$[ebp], ax

; 3909 :                                      lpConnection->pchConnSqlCmd, lpBoundList );
; 3910 :       SqlFreeBoundAttrList( lpBoundList );

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	call	_SqlFreeBoundAttrList@4

; 3911 :    // lpBoundList = 0;
; 3912 :       if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN5@InsertRel

; 3913 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@InsertRel
$LN5@InsertRel:

; 3914 : 
; 3915 :       // ================================================================
; 3916 :       // Insert correspondence table.
; 3917 :       // ================================================================
; 3918 : 
; 3919 : #if defined( DB2 ) || defined( ODBC )
; 3920 : 
; 3921 :       lpConnection->hstmt = lpConnection->hGeneralStmt;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2816]
	mov	DWORD PTR [eax+2812], edx

; 3922 : 
; 3923 :       nRC = SQLExecDirect( lpConnection->hstmt, lpConnection->pchConnSqlCmd,

	push	-3					; fffffffdH
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLExecDirect@12
	mov	WORD PTR _nRC$[ebp], ax

; 3924 :                            SQL_NTS );
; 3925 :       DisplayCommand( "SQLExecDirect", nRC, lpConnection );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95519
	call	_DisplayCommand
	add	esp, 12					; 0000000cH

; 3926 :       if ( nRC != SQL_SUCCESS )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN6@InsertRel

; 3927 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@InsertRel
$LN6@InsertRel:

; 3928 : 
; 3929 : #elif defined( DUMMY )
; 3930 : 
; 3931 :       if ( lpConnection->nTraceLevel > 0 )
; 3932 :       {
; 3933 :          TraceLineS( "", "" );
; 3934 :          SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );
; 3935 :       }
; 3936 : 
; 3937 : #endif
; 3938 : 
; 3939 :       lpConnection->bDatabaseChanged = TRUE;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+800]
	or	edx, 2
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+800], edx
$LN4@InsertRel:

; 3940 :    }
; 3941 : 
; 3942 :    return( 0 );

	xor	eax, eax
$LN1@InsertRel:

; 3943 : 
; 3944 : }  /* InsertRel */

	mov	esp, ebp
	pop	ebp
	ret	0
_InsertRel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_CallbackInfo$ = -36					; size = 5
_pchRecordName$ = -28					; size = 4
_lpRelRecord$ = -24					; size = 4
_pvDBH_Data$ = -20					; size = 4
_lpDataRecord$ = -16					; size = 4
_lpBoundList$ = -12					; size = 4
_nBuildRC$ = -8						; size = 2
_nRC$ = -4						; size = 2
_lpViewEntity$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_bAutoSeqOnly$ = 20					; size = 2
_lpConnection$ = 24					; size = 4
_Insert	PROC

; 3724 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3725 :    LPDATARECORD    lpDataRecord;
; 3726 :    LPRELRECORD     lpRelRecord;
; 3727 :    LPBOUNDLIST     lpBoundList;
; 3728 :    zPVOID          pvDBH_Data = 0;

	mov	DWORD PTR _pvDBH_Data$[ebp], 0

; 3729 :    zPCHAR          pchRecordName;
; 3730 :    zSHORT          nBuildRC;
; 3731 :    zSHORT          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 3732 : 
; 3733 : #if defined( DB2 ) || defined( ODBC )
; 3734 :    CallbackInfoRecord CallbackInfo = { 0 };

	mov	BYTE PTR _CallbackInfo$[ebp], 0
	xor	ecx, ecx
	mov	DWORD PTR _CallbackInfo$[ebp+1], ecx

; 3735 : 
; 3736 :    pvDBH_Data = &CallbackInfo;

	lea	edx, DWORD PTR _CallbackInfo$[ebp]
	mov	DWORD PTR _pvDBH_Data$[ebp], edx

; 3737 :    CallbackInfo.cBuildFunction = BUILD_CREATE;

	mov	BYTE PTR _CallbackInfo$[ebp], 67	; 00000043H

; 3738 : 
; 3739 : #if defined( ODBC )
; 3740 :       // Get a pointer to the dbh-specific data for ODBC.  We'll pass this
; 3741 :       // info around via the lpBoundList structure.
; 3742 :       CallbackInfo.lpObjectData = zGETPTR( lpViewOD->hDBH_Data );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 3743 : #endif
; 3744 : 
; 3745 : #endif
; 3746 : 
; 3747 :    SqlInitBoundAttrList( &lpBoundList, 0,

	mov	edx, DWORD PTR _pvDBH_Data$[ebp]
	push	edx
	push	50331916				; 0300010cH
	push	OFFSET _fnDBH_Callback@24
	push	0
	lea	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlInitBoundAttrList@20

; 3748 :                          fnDBH_Callback, zCB_FUNCS, pvDBH_Data );
; 3749 : 
; 3750 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 3751 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 3752 :    pchRecordName = lpDataRecord->szRecordName;

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	add	edx, 15					; 0000000fH
	mov	DWORD PTR _pchRecordName$[ebp], edx

; 3753 : 
; 3754 :    if ( lpConnection->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	cmp	ecx, 1
	jle	SHORT $LN2@Insert

; 3755 :    {
; 3756 :       TraceLineS( "", "" );

	push	OFFSET $SG95468
	push	OFFSET $SG95469
	call	_TraceLineS@8

; 3757 :       TraceLineS( "========== Insert ==========", "" );

	push	OFFSET $SG95470
	push	OFFSET $SG95471
	call	_TraceLineS@8

; 3758 :       TraceLineS( "Inserting entity ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG95472
	call	_TraceLineS@8

; 3759 :       TraceLineS( "Inserting record ", lpDataRecord->szRecordName );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET $SG95473
	call	_TraceLineS@8

; 3760 :       if ( lpConnection->nTraceLevel > 2 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 2
	jle	SHORT $LN2@Insert

; 3761 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DisplayEntityInstance@8
$LN2@Insert:

; 3762 :    }
; 3763 : 
; 3764 :    // Build SQL for insert.  If nBuildRC == 1 after build, then there are some
; 3765 :    // long var chars that need to be bound.
; 3766 :    nBuildRC = SqlBuildInsert( lpView, lpViewOD, lpViewEntity,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SqlBuildInsert@20
	mov	WORD PTR _nBuildRC$[ebp], ax

; 3767 :                               lpConnection->pchConnSqlCmd, lpBoundList );
; 3768 :    if ( nBuildRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nBuildRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN4@Insert

; 3769 :    {
; 3770 :       SqlFreeBoundAttrList( lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlFreeBoundAttrList@4

; 3771 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Insert
$LN4@Insert:

; 3772 :    }
; 3773 : 
; 3774 :    // ================================================================
; 3775 :    // Prepare/compile insert statement
; 3776 :    // ================================================================
; 3777 : 
; 3778 : #if defined( DB2 ) || defined( ODBC )
; 3779 : 
; 3780 :    lpConnection->hstmt = lpConnection->hGeneralStmt;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2816]
	mov	DWORD PTR [ecx+2812], eax

; 3781 : 
; 3782 :    nRC = SQLPrepare( lpConnection->hstmt, lpConnection->pchConnSqlCmd, SQL_NTS );

	push	-3					; fffffffdH
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+194]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLPrepare@12
	mov	WORD PTR _nRC$[ebp], ax

; 3783 :    DisplayCommand( "SQLPrepare", nRC, lpConnection );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG95476
	call	_DisplayCommand
	add	esp, 12					; 0000000cH

; 3784 : 
; 3785 : #endif
; 3786 : 
; 3787 :    if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@Insert

; 3788 :    {
; 3789 :       SqlFreeBoundAttrList( lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlFreeBoundAttrList@4

; 3790 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Insert
$LN5@Insert:

; 3791 :    }
; 3792 : 
; 3793 :    // If needed, bind any long varchars.
; 3794 :    nRC = WriteLongChar( lpConnection, lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	call	_WriteLongChar
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 3795 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN6@Insert

; 3796 :    {
; 3797 :       SqlFreeBoundAttrList( lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlFreeBoundAttrList@4

; 3798 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Insert
$LN6@Insert:

; 3799 :    }
; 3800 : 
; 3801 :    // ================================================================
; 3802 :    // Insert table.
; 3803 :    // ================================================================
; 3804 : 
; 3805 : #if defined( DB2 ) || defined( ODBC )
; 3806 : 
; 3807 :    nRC = SQLExecute( lpConnection->hstmt );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLExecute@4
	mov	WORD PTR _nRC$[ebp], ax

; 3808 :    SqlFreeBoundAttrList( lpBoundList );

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlFreeBoundAttrList@4

; 3809 : // lpBoundList = 0;
; 3810 : 
; 3811 :    if ( nRC != SQL_SUCCESS && nRC != SQL_SUCCESS_WITH_INFO )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@Insert
	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	je	SHORT $LN7@Insert

; 3812 :    {
; 3813 :       // If the trace level is 0 then let's trace the SQL to help debugging.
; 3814 :       if ( lpConnection->nTraceLevel == 0 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	test	ecx, ecx
	jne	SHORT $LN7@Insert

; 3815 :          SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );

	push	0
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	call	_SqlDisplayCommand@8
$LN7@Insert:

; 3816 :    }
; 3817 : 
; 3818 :    if ( nRC == 805 && lpViewEntity->hParent == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 805				; 00000325H
	jne	SHORT $LN9@Insert
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	SHORT $LN9@Insert

; 3819 :    {
; 3820 :       SQL_RC( "SQLExecute", nRC, "Duplicate root", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG95483
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95484
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 3821 :       nRC = zDUPLICATE_ROOT;

	mov	edx, -4					; fffffffcH
	mov	WORD PTR _nRC$[ebp], dx

; 3822 :       return( zDUPLICATE_ROOT );

	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN1@Insert

; 3823 :    }

	jmp	SHORT $LN10@Insert
$LN9@Insert:

; 3824 :    else
; 3825 :    {
; 3826 :       SQL_RC( "SQLExecute", nRC, 0, 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	0
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95485
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 3827 :       if ( nRC != SQL_SUCCESS && nRC != SQL_SUCCESS_WITH_INFO )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN10@Insert
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN10@Insert

; 3828 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@Insert
$LN10@Insert:

; 3829 :    }
; 3830 : 
; 3831 : #elif defined( DUMMY )
; 3832 : 
; 3833 :    if ( lpConnection->nTraceLevel > 0 )
; 3834 :    {
; 3835 :       TraceLineS( "", "" );
; 3836 :       SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );
; 3837 :    }
; 3838 : 
; 3839 : #endif
; 3840 : 
; 3841 :    lpConnection->bDatabaseChanged = TRUE;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+800]
	or	edx, 2
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+800], edx

; 3842 : 
; 3843 :    return( 0 );

	xor	eax, eax
$LN1@Insert:

; 3844 : }  /* Insert */

	mov	esp, ebp
	pop	ebp
	ret	0
_Insert	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpRelRecord$ = -3808					; size = 4
_lpnLth$1 = -3804					; size = 4
_ulLth$2 = -3800					; size = 4
_lpParent$3 = -3796					; size = 4
_lpBoundEntity$4 = -3792				; size = 4
_lpDataField$5 = -3788					; size = 4
_hTask$6 = -3784					; size = 4
_lpDataPtr$7 = -3780					; size = 4
tv596 = -3776						; size = 4
tv524 = -3772						; size = 4
$T8 = -3768						; size = 4
tv1084 = -3764						; size = 4
tv870 = -3760						; size = 4
_lpDataField$9 = -3756					; size = 4
tv784 = -3752						; size = 4
_lpHandles$ = -3748					; size = 4
_pvDBH_Data$ = -3744					; size = 4
tv69 = -3740						; size = 4
_lpValue$10 = -3736					; size = 4
tv1166 = -3732						; size = 4
_chType$11 = -3725					; size = 1
_nLth$12 = -3724					; size = 2
_nRC2$13 = -3720					; size = 2
_LoopInfo$ = -3716					; size = 33
_CallbackInfo$ = -3680					; size = 5
_nRC2$14 = -3672					; size = 2
tv1260 = -3668						; size = 4
_lpLastCreatedEntity$15 = -3664				; size = 4
tv921 = -3660						; size = 4
_iBufferLth$16 = -3656					; size = 4
_nColumnSize$17 = -3652					; size = 4
_lpnParmLth$18 = -3648					; size = 4
_lFuncs$ = -3644					; size = 4
_lpDataRecord$ = -3640					; size = 4
_lMemLth$ = -3636					; size = 4
tv593 = -3632						; size = 4
tv521 = -3628						; size = 4
tv1203 = -3624						; size = 4
_lpMem$ = -3620						; size = 4
_ulTotalLth$ = -3616					; size = 4
_rc$19 = -3612						; size = 2
_nLth$20 = -3608					; size = 2
_lRowCount$ = -3604					; size = 4
_ppchBufferPtr$ = -3600					; size = 4
_lpBoundAttr$21 = -3596					; size = 4
_ulLth$22 = -3592					; size = 4
_lRootLimit$ = -3588					; size = 4
_pchBufferPos$23 = -3584				; size = 4
_lpPtr$ = -3580						; size = 4
_lRootCnt$ = -3576					; size = 4
_nC_DataType$24 = -3572					; size = 2
_nSQL_Type$25 = -3568					; size = 2
_hMem$ = -3564						; size = 4
_ulLth$26 = -3560					; size = 4
_nDecDigits$27 = -3556					; size = 2
_bCreateMultipleRoots$ = -3549				; size = 1
_fSqlType$28 = -3548					; size = 2
_nParmCount$29 = -3544					; size = 2
_pchBufferPos$30 = -3540				; size = 4
_lpAttribFlags$ = -3536					; size = 4
_lpPtr$31 = -3532					; size = 4
_sz$32 = -3528						; size = 2
_lpBoundAttr$33 = -3524					; size = 4
_nLth$34 = -3520					; size = 4
_lpQualEntity$ = -3516					; size = 4
_fSqlType$35 = -3512					; size = 2
_bKeyListCreated$ = -3508				; size = 1
_bCursorOpened$ = -3507					; size = 1
_bRootLimitReached$ = -3506				; size = 1
_bNewEntity$36 = -3505					; size = 1
_lpLoadEntity$37 = -3504				; size = 4
_k$38 = -3500						; size = 2
_k$39 = -3496						; size = 2
_bOpenSQL$ = -3490					; size = 1
_bKeysOnly$ = -3489					; size = 1
_lpBoundList$ = -3488					; size = 4
_lpDataField$ = -3484					; size = 4
_lpStmtHandle$ = -3480					; size = 4
_nEntityKeyCnt$ = -3476					; size = 2
_nReturnCode$ = -3472					; size = 2
_lpViewAttrib$ = -3468					; size = 4
_nColumnCnt$ = -3464					; size = 2
_nRC$ = -3460						; size = 2
_ppchBufferPtrArea$ = -3456				; size = 1200
_lpKeyData$ = -2256					; size = 800
_szMsg$40 = -1456					; size = 500
_szDeleteCmd$41 = -956					; size = 300
_bEntityCreatedList$42 = -656				; size = 500
_sz$43 = -156						; size = 50
_szDatetime$44 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewOD$ = 16						; size = 4
_lpQualView$ = 20					; size = 4
_lpConnection$ = 24					; size = 4
_Indicators$ = 28					; size = 4
_Load	PROC

; 1983 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3808				; 00000ee0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1984 :    LPQUALENTITY      lpQualEntity;
; 1985 :    LPVIEWATTRIB      lpViewAttrib;
; 1986 :    LPDATARECORD      lpDataRecord;
; 1987 :    LPDATAFIELD       lpDataField;
; 1988 :    LPRELRECORD       lpRelRecord;
; 1989 :    LPATTRIBFLAGS     lpAttribFlags;
; 1990 :    LPBOUNDLIST       lpBoundList = 0;

	mov	DWORD PTR _lpBoundList$[ebp], 0

; 1991 :    DataFieldLoopInfo LoopInfo;
; 1992 :    KeyData           lpKeyData[ 50 ];
; 1993 :    zPVOID            pvDBH_Data = 0;

	mov	DWORD PTR _pvDBH_Data$[ebp], 0

; 1994 :    zPVOID            lpMem;
; 1995 :    zPCHAR            ppchBufferPtrArea[ MAX_COLUMNS ] = { 0 };

	mov	DWORD PTR _ppchBufferPtrArea$[ebp], 0
	push	1196					; 000004acH
	push	0
	lea	eax, DWORD PTR _ppchBufferPtrArea$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1996 :    zPPCHAR           ppchBufferPtr = ppchBufferPtrArea;

	lea	ecx, DWORD PTR _ppchBufferPtrArea$[ebp]
	mov	DWORD PTR _ppchBufferPtr$[ebp], ecx

; 1997 :    zPCHAR            lpPtr;
; 1998 :    zULONG            ulTotalLth;
; 1999 :    zLONG             lRowCount;
; 2000 :    zLONG             lRootCnt;
; 2001 :    zLONG             lRootLimit;
; 2002 :    zLONG             hMem = 0;

	mov	DWORD PTR _hMem$[ebp], 0

; 2003 :    zLONG             lMemLth;
; 2004 :    zLONG             lFuncs;
; 2005 :    zBOOL             bKeyListCreated = FALSE;

	mov	BYTE PTR _bKeyListCreated$[ebp], 0

; 2006 :    zBOOL             bCursorOpened = FALSE;

	mov	BYTE PTR _bCursorOpened$[ebp], 0

; 2007 :    zBOOL             bKeysOnly;
; 2008 :    zBOOL             bOpenSQL = FALSE;

	mov	BYTE PTR _bOpenSQL$[ebp], 0

; 2009 :    zBOOL             bCreateMultipleRoots = ((Indicators & zMULTIPLE) != 0);

	mov	edx, DWORD PTR _Indicators$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN201@Load
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN202@Load
$LN201@Load:
	mov	DWORD PTR tv69[ebp], 0
$LN202@Load:
	mov	al, BYTE PTR tv69[ebp]
	mov	BYTE PTR _bCreateMultipleRoots$[ebp], al

; 2010 :    zBOOL             bRootLimitReached = FALSE;

	mov	BYTE PTR _bRootLimitReached$[ebp], 0

; 2011 :    zSHORT            nEntityKeyCnt = 0;

	xor	ecx, ecx
	mov	WORD PTR _nEntityKeyCnt$[ebp], cx

; 2012 :    zSHORT            nColumnCnt;
; 2013 :    zSHORT            nReturnCode = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], dx

; 2014 :    zSHORT            nRC;
; 2015 : 
; 2016 : #if defined( DB2 )
; 2017 : 
; 2018 :    LPHANDLES      lpHandles = 0;
; 2019 :    LPSTMTHANDLES  lpStmtHandle = 0;
; 2020 : 
; 2021 :    // Define statements needed to load BLOB/CLOB columns.
; 2022 :    SQLHSTMT     hBlobStmt    = 0;
; 2023 :    SQLHSTMT     hLocatorStmt = 0;
; 2024 : 
; 2025 :    // Get a pointer to the dbh-specific data for DB2.
; 2026 :    CallbackInfoRecord CallbackInfo = { 0 };
; 2027 : 
; 2028 :    LPDB2_OBJECTDATA lpDB2_Data =
; 2029 :                            (LPDB2_OBJECTDATA) zGETPTR( lpViewOD->hDBH_Data );
; 2030 : 
; 2031 :    pvDBH_Data = &CallbackInfo;
; 2032 :    CallbackInfo.cBuildFunction = BUILD_SELECT;
; 2033 : 
; 2034 : #elif defined( ODBC )
; 2035 : 
; 2036 :    LPHANDLES          lpHandles = 0;

	mov	DWORD PTR _lpHandles$[ebp], 0

; 2037 :    LPSTMTHANDLES      lpStmtHandle = 0;

	mov	DWORD PTR _lpStmtHandle$[ebp], 0

; 2038 :    CallbackInfoRecord CallbackInfo = { 0 };

	mov	BYTE PTR _CallbackInfo$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 2039 : 
; 2040 :    pvDBH_Data = &CallbackInfo;

	lea	ecx, DWORD PTR _CallbackInfo$[ebp]
	mov	DWORD PTR _pvDBH_Data$[ebp], ecx

; 2041 : 
; 2042 :    // Get a pointer to the dbh-specific data for ODBC.  We'll pass this info
; 2043 :    // around via the lpBoundList structure.
; 2044 :    CallbackInfo.lpObjectData = zGETPTR( lpViewOD->hDBH_Data );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _CallbackInfo$[ebp+1], eax

; 2045 :    CallbackInfo.cBuildFunction = BUILD_SELECT;

	mov	BYTE PTR _CallbackInfo$[ebp], 83	; 00000053H

; 2046 : 
; 2047 : #endif
; 2048 : 
; 2049 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2050 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 2051 : 
; 2052 :    if ( lpConnection->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jle	SHORT $LN49@Load

; 2053 :    {
; 2054 :       TraceLineS( "", "" );

	push	OFFSET $SG95230
	push	OFFSET $SG95231
	call	_TraceLineS@8

; 2055 :       TraceLineS( "================= Performing load ===================", "" );

	push	OFFSET $SG95232
	push	OFFSET $SG95233
	call	_TraceLineS@8

; 2056 :       TraceLineS( "  Entity name: ", lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG95234
	call	_TraceLineS@8

; 2057 :       TraceLineS( "  Table name: ", lpDataRecord->szRecordName );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	add	edx, 15					; 0000000fH
	push	edx
	push	OFFSET $SG95235
	call	_TraceLineS@8
$LN49@Load:

; 2058 :    }
; 2059 : 
; 2060 : #ifdef USE_JOINS
; 2061 :    // If we are loading only the root entities then we don't want to use a
; 2062 :    // join to load any children.
; 2063 :    lFuncs = zCB_FUNCS;

	mov	DWORD PTR _lFuncs$[ebp], 50331916	; 0300010cH

; 2064 :    if ( Indicators & zACTIVATE_ROOTONLY )

	mov	eax, DWORD PTR _Indicators$[ebp]
	and	eax, 268435456				; 10000000H
	je	SHORT $LN50@Load

; 2065 :       lFuncs &= ~zSQLCALLBACK_USEJOIN;

	mov	ecx, DWORD PTR _lFuncs$[ebp]
	and	ecx, -33554433				; fdffffffH
	mov	DWORD PTR _lFuncs$[ebp], ecx
$LN50@Load:

; 2066 : 
; 2067 :    // Check to see if the entity was already loaded via a join.
; 2068 :    if ( lpConnection->pchEntityJoinTable == 0 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+2900], 0
	jne	SHORT $LN51@Load

; 2069 :    {
; 2070 :       // We haven't yet allocated the table to indicate what has been joined
; 2071 :       // so do it now.
; 2072 :       lpConnection->pchEntityJoinTable = SysMalloc( lpViewOD->uEntities + 1 );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movzx	ecx, WORD PTR [eax+234]
	add	ecx, 1
	push	ecx
	call	_SysMalloc@4
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+2900], eax

; 2073 :    }

	jmp	SHORT $LN52@Load
$LN51@Load:

; 2074 :    else
; 2075 :    {
; 2076 :       // pchEntityJoinTable is an array of chars, one char for each entity in
; 2077 :       // the XOD.  If the bit for the current entity is non-zero, then the
; 2078 :       // entity has already been loaded via a join.
; 2079 :       if ( (lpConnection->pchEntityJoinTable[ lpViewEntity->nHierNbr ] &
; 2080 :                                             zSELECT_JOINEDWITHPARENT) != 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2900]
	movsx	ecx, BYTE PTR [eax+ecx]
	and	ecx, 1
	je	SHORT $LN52@Load

; 2081 :       {
; 2082 :          if ( lpConnection->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jle	SHORT $LN54@Load

; 2083 :             TraceLineS( "  Table loaded earlier as part of a join. Entity = ",

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG95241
	call	_TraceLineS@8
$LN54@Load:

; 2084 :                         lpViewEntity->szName );
; 2085 : 
; 2086 :          nReturnCode = 0;

	xor	edx, edx
	mov	WORD PTR _nReturnCode$[ebp], dx

; 2087 : 
; 2088 :          // If the entity has hanging FKeys then we need to check to see if the
; 2089 :          // entity was loaded.  If not we want to return a -1 so that core knows
; 2090 :          // it should check to see if the entity has a hanging FK.
; 2091 :          if ( lpViewEntity->bHangingFKey )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN55@Load

; 2092 :          {
; 2093 :             if ( CheckExistenceOfEntity( lpView,
; 2094 :                                          lpViewEntity->szName ) != zCURSOR_SET )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN55@Load

; 2095 :                nReturnCode = -1;  // Indicates that entity doesn't exist.

	or	edx, -1
	mov	WORD PTR _nReturnCode$[ebp], dx
$LN55@Load:

; 2096 :          }
; 2097 : 
; 2098 :          goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN52@Load:

; 2099 :       }
; 2100 :    }
; 2101 : 
; 2102 : #ifdef DEBUG
; 2103 :    // DGC 6/22/2001
; 2104 :    // Put in a check to make sure that keys are sorted first.  This shouldn't
; 2105 :    // be necessary after everybody moves to new join code.
; 2106 :    lpDataField  = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataField$[ebp], eax

; 2107 :    lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2108 :    if ( lpViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN57@Load

; 2109 :    {
; 2110 :       zCHAR szMsg[ 500 ];
; 2111 : 
; 2112 :       zsprintf( szMsg, "XOD '%s' needs to be saved with new JOIN code. "

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG95245
	lea	edx, DWORD PTR _szMsg$40[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2113 :                 "Keys must be first for entity: %s.",
; 2114 :                 lpViewOD->szName, lpViewEntity->szName );
; 2115 :       SysMessageBox( lpView, "DBHandler Warning", szMsg, 0 );

	push	0
	lea	eax, DWORD PTR _szMsg$40[ebp]
	push	eax
	push	OFFSET $SG95246
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16
$LN57@Load:

; 2116 :    }
; 2117 : #endif
; 2118 : 
; 2119 : #endif
; 2120 : 
; 2121 :    SqlInitBoundAttrList( &lpBoundList, lpConnection->pchEntityJoinTable,

	mov	edx, DWORD PTR _pvDBH_Data$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFuncs$[ebp]
	push	eax
	push	OFFSET _fnDBH_Callback@24
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2900]
	push	edx
	lea	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlInitBoundAttrList@20

; 2122 :                          fnDBH_Callback, lFuncs, pvDBH_Data );
; 2123 : 
; 2124 :    // Until further notice we will return zCALL_ERROR if we exit early.
; 2125 : 
; 2126 :    if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	$LN58@Load

; 2127 :    {
; 2128 :       zSHORT k;
; 2129 : 
; 2130 :       // Check to see if we've already stored the qual OI.  Start by looking
; 2131 :       // for lpQualView in the qualification list.
; 2132 :       for ( k = 0; k < lpConnection->nQualCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$39[ebp], cx
	jmp	SHORT $LN4@Load
$LN2@Load:
	mov	dx, WORD PTR _k$39[ebp]
	add	dx, 1
	mov	WORD PTR _k$39[ebp], dx
$LN4@Load:
	movsx	eax, WORD PTR _k$39[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+188]
	cmp	eax, edx
	jge	SHORT $LN3@Load

; 2133 :       {
; 2134 :          if ( lpConnection->vQualList[ k ] == lpQualView )

	movsx	eax, WORD PTR _k$39[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+28]
	cmp	edx, DWORD PTR _lpQualView$[ebp]
	jne	SHORT $LN60@Load

; 2135 :             break;

	jmp	SHORT $LN3@Load
$LN60@Load:

; 2136 :       }

	jmp	SHORT $LN2@Load
$LN3@Load:

; 2137 : 
; 2138 :       // If k = nQualCount then we didn't find lpQualView so we must extract
; 2139 :       // the OI to a QualEntity list.  If lpViewEntity is the root entity
; 2140 :       // then we'll reload the qualfication OI if lpQualView was found.
; 2141 :       if ( k == lpConnection->nQualCount || lpViewEntity->hParent == 0 )

	movsx	eax, WORD PTR _k$39[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+188]
	cmp	eax, edx
	je	SHORT $LN62@Load
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	$LN61@Load
$LN62@Load:

; 2142 :       {
; 2143 :          // If there already is a lpQualEntity then we need to free up the
; 2144 :          // old one so we can create a new one.
; 2145 :          if ( lpConnection->lpQualEntityList[ k ] )

	movsx	ecx, WORD PTR _k$39[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+ecx*4+108], 0
	je	SHORT $LN63@Load

; 2146 :             SqlFreeQualEntity( &lpConnection->lpQualEntityList[ k ] );

	movsx	eax, WORD PTR _k$39[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+108]
	push	edx
	call	_SqlFreeQualEntity@4
$LN63@Load:

; 2147 : 
; 2148 :          // Copy the contents of lpQualView to memory.
; 2149 :          nRC = SqlRetrieveQualObject( lpView, lpQualView, lpViewOD,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$39[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+108]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SqlRetrieveQualObject@20
	mov	WORD PTR _nRC$[ebp], ax

; 2150 :                                       &lpConnection->lpQualEntityList[ k ],
; 2151 :                                       lpBoundList );
; 2152 :          if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN64@Load

; 2153 :             goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN64@Load:

; 2154 : 
; 2155 :          // If this is a new view we must bump up our count.
; 2156 :          if ( k == lpConnection->nQualCount )

	movsx	edx, WORD PTR _k$39[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+188]
	cmp	edx, ecx
	jne	SHORT $LN61@Load

; 2157 :          {
; 2158 :             // Make sure that nQualCount doesn't get bigger than our max
; 2159 :             // count.  We have to subtract one from MAX_QUALIFICATIONS for
; 2160 :             // comparison because nQualCount can never be equal to
; 2161 :             // MAX_QUALIFICATIONS.
; 2162 :             if ( lpConnection->nQualCount < MAX_QUALIFICATIONS - 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+188]
	cmp	eax, 19					; 00000013H
	jge	SHORT $LN66@Load

; 2163 :                lpConnection->nQualCount++;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	dx, WORD PTR [ecx+188]
	add	dx, 1
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	WORD PTR [eax+188], dx
$LN66@Load:

; 2164 : 
; 2165 :             lpConnection->vQualList[ k ] = lpQualView;

	movsx	ecx, WORD PTR _k$39[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR _lpQualView$[ebp]
	mov	DWORD PTR [edx+ecx*4+28], eax
$LN61@Load:

; 2166 :          }
; 2167 :       }
; 2168 : 
; 2169 :       lpConnection->lpFirstQualEntity = lpConnection->lpQualEntityList[ k ];

	movsx	ecx, WORD PTR _k$39[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+108]
	mov	DWORD PTR [edx+190], ecx

; 2170 :    }

	jmp	SHORT $LN59@Load
$LN58@Load:

; 2171 :    else
; 2172 :    {
; 2173 :       // No qual entity so blank it out.
; 2174 :       lpConnection->lpFirstQualEntity = 0;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+190], 0
$LN59@Load:

; 2175 :    }
; 2176 : 
; 2177 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2178 :    bKeysOnly = FALSE;

	mov	BYTE PTR _bKeysOnly$[ebp], 0

; 2179 : 
; 2180 :    lpQualEntity = SqlEntityIsQualified( lpConnection->lpFirstQualEntity,

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+190]
	push	eax
	call	_SqlEntityIsQualified@8
	mov	DWORD PTR _lpQualEntity$[ebp], eax

; 2181 :                                         lpViewEntity );
; 2182 : 
; 2183 :    if ( lpConnection->nTraceLevel > 2 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 2
	jle	SHORT $LN67@Load

; 2184 :    {
; 2185 :       if ( lpConnection->lpFirstQualEntity )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [eax+190], 0
	je	SHORT $LN68@Load

; 2186 :          TraceLineS( "  Table IS qualified.", "" );

	push	OFFSET $SG95259
	push	OFFSET $SG95260
	call	_TraceLineS@8
	jmp	SHORT $LN69@Load
$LN68@Load:

; 2187 :       else
; 2188 :          TraceLineS( "  Table is not qualified.", "" );

	push	OFFSET $SG95261
	push	OFFSET $SG95262
	call	_TraceLineS@8
$LN69@Load:

; 2189 : 
; 2190 :       if ( lpViewEntity->hParent )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN67@Load

; 2191 :       {
; 2192 :          LPVIEWENTITY lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpParent$3[ebp], eax

; 2193 : 
; 2194 :          DisplayEntityInstance( lpView, lpParent->szName );

	mov	ecx, DWORD PTR _lpParent$3[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DisplayEntityInstance@8
$LN67@Load:

; 2195 :       }
; 2196 :    }
; 2197 : 
; 2198 :    if ( lpQualEntity && lpConnection->nTraceLevel > 2 )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN71@Load
	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	cmp	ecx, 2
	jle	SHORT $LN71@Load

; 2199 :       SqlDisplayQualEntity( lpQualEntity, FALSE );

	push	0
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	push	edx
	call	_SqlDisplayQualEntity@8
$LN71@Load:

; 2200 : 
; 2201 : #if defined( DB2 )
; 2202 : {
; 2203 :    LPOD_LIST lpOD = fnFindOD( lpViewOD, lpConnection );
; 2204 : 
; 2205 :    // Check for static bind.
; 2206 :    if ( lpDB2_Data && lpDB2_Data->bUseStaticSQL )
; 2207 :    {
; 2208 :       // Load static library if not already loaded.
; 2209 :       if ( lpOD->hStaticLibrary == 0 )
; 2210 :       {
; 2211 :          lpOD->hStaticLibrary = SysLoadLibrary( lpView,
; 2212 :                                                 lpDB2_Data->szStaticSQL_DLL );
; 2213 :          if ( lpOD->hStaticLibrary == 0 )
; 2214 :             goto EndOfFunction;
; 2215 :       }
; 2216 : 
; 2217 :       if ( lpQualEntity == 0 )
; 2218 :       {
; 2219 :          zSHORT (POPERATION pfnFunc)( zVIEW, LPVIEWOD, LPVIEWENTITY,
; 2220 :                                       int, zSHORT );
; 2221 :          zCHAR  szFuncName[ 200 ];
; 2222 : 
; 2223 :          lpOD->bNeedsCommit = TRUE;
; 2224 : 
; 2225 :          // We have static binding so call the static function.
; 2226 :          zsprintf( szFuncName, "SQL_%s_%s_Select", lpOD->lpViewOD->szName,
; 2227 :                    lpViewEntity->szName );
; 2228 :          pfnFunc = SysGetProc( lpOD->hStaticLibrary, szFuncName );
; 2229 : 
; 2230 :          nRC = (*pfnFunc)( lpView, lpViewOD, lpViewEntity, Indicators,
; 2231 :                            lpConnection->nTraceLevel );
; 2232 : 
; 2233 :          nReturnCode = nRC;
; 2234 :          goto EndOfFunction;
; 2235 :       }
; 2236 :       else
; 2237 :       if ( lpQualEntity->bUniqueQualification )
; 2238 :       {
; 2239 :          zSHORT (POPERATION pfnFunc)( zVIEW, LPVIEWOD, LPVIEWENTITY,
; 2240 :                                       LPQUALENTITY, int, zSHORT );
; 2241 :          zCHAR  szFuncName[ 200 ];
; 2242 : 
; 2243 :          lpOD->bNeedsCommit = TRUE;
; 2244 : 
; 2245 :          // We have static binding so call the static function.
; 2246 :          zsprintf( szFuncName, "SQL_%s_%s_SelectUnique", lpOD->lpViewOD->szName,
; 2247 :                    lpViewEntity->szName );
; 2248 :          pfnFunc = SysGetProc( lpOD->hStaticLibrary, szFuncName );
; 2249 : 
; 2250 :          nRC = (*pfnFunc)( lpView, lpViewOD, lpViewEntity, lpQualEntity,
; 2251 :                            Indicators, lpConnection->nTraceLevel );
; 2252 : 
; 2253 :          nReturnCode = nRC;
; 2254 :          goto EndOfFunction;
; 2255 :       }
; 2256 : 
; 2257 :       // We have to use dynamic SQL so open a connection using it.
; 2258 :       fnOpenDatabaseConnection( lpView, lpViewOD, lpViewEntity, lpConnection );
; 2259 :    }
; 2260 : }
; 2261 : #endif
; 2262 : 
; 2263 : #if defined( DB2 ) || defined( ODBC )
; 2264 : 
; 2265 :    // Check to see if we've already generated/prepared the SQL for this
; 2266 :    // entity.
; 2267 :    if ( g_bHoldStmtHandles )

	movzx	eax, BYTE PTR _g_bHoldStmtHandles
	test	eax, eax
	je	$LN72@Load

; 2268 :    {
; 2269 :       zSHORT rc;
; 2270 :       zSHORT k;
; 2271 : 
; 2272 :       // Find the handle info for this LOD.
; 2273 :       for ( k = 0; lpConnection->lpHandles[ k ]; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$38[ebp], cx
	jmp	SHORT $LN7@Load
$LN5@Load:
	mov	dx, WORD PTR _k$38[ebp]
	add	dx, 1
	mov	WORD PTR _k$38[ebp], dx
$LN7@Load:
	movsx	eax, WORD PTR _k$38[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [ecx+eax*4+2820], 0
	je	SHORT $LN6@Load

; 2274 :       {
; 2275 :          if ( lpConnection->lpHandles[ k ]->lpViewOD == lpViewOD )

	movsx	edx, WORD PTR _k$38[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2820]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lpViewOD$[ebp]
	jne	SHORT $LN74@Load

; 2276 :             break;

	jmp	SHORT $LN6@Load
$LN74@Load:

; 2277 :       }

	jmp	SHORT $LN5@Load
$LN6@Load:

; 2278 : 
; 2279 :       // We need to allocate handles (and other info) for each of the entities
; 2280 :       // in the LOD.  If lpHandles is 0 we need to allocate it now.
; 2281 :       if ( lpConnection->lpHandles[ k ] == 0 )

	movsx	eax, WORD PTR _k$38[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [ecx+eax*4+2820], 0
	jne	$LN75@Load

; 2282 :       {
; 2283 :          zUSHORT nLth;
; 2284 : 
; 2285 :          lpConnection->lpHandles[ k ] = malloc( sizeof( SelectHandlesRecord ) );

	push	8
	call	DWORD PTR __imp__malloc
	add	esp, 4
	movsx	edx, WORD PTR _k$38[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+edx*4+2820], eax

; 2286 :          zmemset( lpConnection->lpHandles[ k ], 0, sizeof( SelectHandlesRecord ) );

	push	8
	push	0
	movsx	edx, WORD PTR _k$38[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+2820]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2287 : 
; 2288 :          // It's just easier to allocate one extra record instead of worrying
; 2289 :          // about converting hier # to an offset.
; 2290 :          nLth = sizeof( EntityHandlesRecord ) * (lpViewOD->uEntities + 1);

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, WORD PTR [edx+234]
	add	eax, 1
	shl	eax, 5
	mov	WORD PTR _nLth$20[ebp], ax

; 2291 : 
; 2292 :          // We didn't find one so create space to store the handles.
; 2293 :          lpConnection->lpHandles[ k ]->lpViewOD = lpViewOD;

	movsx	ecx, WORD PTR _k$38[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+2820]
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [eax], ecx

; 2294 :          lpConnection->lpHandles[ k ]->lpStmtHandles = malloc( nLth );

	movzx	edx, WORD PTR _nLth$20[ebp]
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	movsx	ecx, WORD PTR _k$38[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4+2820]
	mov	DWORD PTR [ecx+4], eax

; 2295 :          zmemset( lpConnection->lpHandles[ k ]->lpStmtHandles, 0, nLth );

	movzx	edx, WORD PTR _nLth$20[ebp]
	push	edx
	push	0
	movsx	eax, WORD PTR _k$38[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2820]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN75@Load:

; 2296 :       }
; 2297 : 
; 2298 :       lpHandles    = lpConnection->lpHandles[ k ];

	movsx	ecx, WORD PTR _k$38[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+2820]
	mov	DWORD PTR _lpHandles$[ebp], eax

; 2299 :       lpStmtHandle = &lpHandles->lpStmtHandles[ lpViewEntity->nHierNbr ];

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	shl	edx, 5
	mov	eax, DWORD PTR _lpHandles$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpStmtHandle$[ebp], edx

; 2300 : 
; 2301 :       // Check to see if a handle has been created for this entity.
; 2302 :       if ( lpStmtHandle->hstmt )

	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	$LN76@Load

; 2303 :       {
; 2304 :          // Use the old bound list.  Free up the current one since we don't
; 2305 :          // need it anymore.
; 2306 :          SqlFreeBoundAttrList( lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlFreeBoundAttrList@4

; 2307 :          lpBoundList = lpStmtHandle->lpBoundList;

	mov	eax, DWORD PTR _lpStmtHandle$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _lpBoundList$[ebp], ecx

; 2308 : 
; 2309 :          // If we are using autoload, then we are only activating the keys,
; 2310 :          // so set the flag.
; 2311 :          if ( lpViewEntity->bAutoLoadFromParent )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 30					; 0000001eH
	and	eax, 1
	je	SHORT $LN77@Load

; 2312 :             bKeysOnly = TRUE;

	mov	BYTE PTR _bKeysOnly$[ebp], 1
$LN77@Load:

; 2313 : 
; 2314 :          if ( lpStmtHandle->bLoadFromParent )

	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, 1
	je	SHORT $LN78@Load

; 2315 :          {
; 2316 :             // We can load this guy from the parent so do it now.
; 2317 :             nRC = SqlAutoLoadFromParent( lpView, lpViewOD, lpViewEntity,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+194]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+190]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SqlAutoLoadFromParent@24
	mov	WORD PTR _nRC$[ebp], ax

; 2318 :                                          lpConnection->lpFirstQualEntity,
; 2319 :                                          lpConnection->pchConnSqlCmd, lpBoundList );
; 2320 :             if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN79@Load

; 2321 :                goto EndOfFunction;

	jmp	$EndOfFunction$213
	jmp	SHORT $LN78@Load
$LN79@Load:

; 2322 :             else
; 2323 :             {
; 2324 :                nReturnCode = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnCode$[ebp], ax

; 2325 :                goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN78@Load:

; 2326 :             }
; 2327 :          }
; 2328 : 
; 2329 :          lpConnection->hstmt = lpStmtHandle->hstmt;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+2812], eax

; 2330 :          lpConnection->pchGlobalTableBuffer = lpStmtHandle->pchOutputBuffer;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+202], eax

; 2331 :          ppchBufferPtr = lpStmtHandle->ppchBufferPtr;

	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ppchBufferPtr$[ebp], edx

; 2332 : 
; 2333 :          // Skip the prepare/bind step.
; 2334 :          goto ExecuteCommand;

	jmp	$ExecuteCommand$214
$LN76@Load:

; 2335 :       }
; 2336 : 
; 2337 :       // No statement handle so we must create one and prepare the SQL.
; 2338 : #if defined( DB2 )
; 2339 : 
; 2340 :       rc = SQLAllocStmt( lpConnection->hdbc, &lpStmtHandle->hstmt );
; 2341 :       SQL_RC( "SQLAllocStmt", rc, "Allocate HSTMT", 0, 2 );
; 2342 :       if ( rc != SQL_SUCCESS )
; 2343 :          goto EndOfFunction;
; 2344 : 
; 2345 : #elif defined( ODBC )
; 2346 : 
; 2347 :       rc = SQLAllocHandle( SQL_HANDLE_STMT, lpConnection->hdbc,

	mov	eax, DWORD PTR _lpStmtHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2808]
	push	edx
	push	3
	call	_SQLAllocHandle@12
	mov	WORD PTR _rc$19[ebp], ax

; 2348 :                            &lpStmtHandle->hstmt );
; 2349 :       SQL_RC( "SQLAllocHandle", rc, "Allocate HSTMT", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG95274
	movzx	ecx, WORD PTR _rc$19[ebp]
	push	ecx
	push	OFFSET $SG95275
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 2350 :       if ( rc != SQL_SUCCESS )

	movsx	edx, WORD PTR _rc$19[ebp]
	test	edx, edx
	je	SHORT $LN81@Load

; 2351 :          goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN81@Load:

; 2352 : 
; 2353 : #endif
; 2354 : 
; 2355 :       lpConnection->hstmt = lpStmtHandle->hstmt;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+2812], edx

; 2356 :    }

	jmp	SHORT $LN73@Load
$LN72@Load:

; 2357 :    else
; 2358 :       lpConnection->hstmt = lpConnection->hGeneralStmt;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2816]
	mov	DWORD PTR [eax+2812], edx
$LN73@Load:

; 2359 : 
; 2360 : #endif
; 2361 : 
; 2362 :    // AutoLoad:
; 2363 :    // When the parent has the imbedded keys for the child and the
; 2364 :    // only attributes in the child are those imbedded keys.
; 2365 :    // Autoload is defined (for Phil) from the object for performance reasons.
; 2366 :    if ( lpViewEntity->bAutoLoadFromParent )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 30					; 0000001eH
	and	ecx, 1
	je	$LN82@Load

; 2367 :    {
; 2368 :       if ( lpConnection->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jle	SHORT $LN84@Load

; 2369 :       {
; 2370 :          TraceLineS( "", "" );

	push	OFFSET $SG95280
	push	OFFSET $SG95281
	call	_TraceLineS@8

; 2371 :          TraceLineS( "Loading entity from parent using AutoLoadFromParent; ",

	push	OFFSET $SG95282
	push	OFFSET $SG95283
	call	_TraceLineS@8

; 2372 :                      "SQL might not be needed." );
; 2373 :          TraceLineS( "Entity name = ", lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG95284
	call	_TraceLineS@8
$LN84@Load:

; 2374 :       }
; 2375 : 
; 2376 :       // Return codes from SqlAutoLoadFromParent are:
; 2377 :       //    0 - Nothing done. Perform normal SQL code.
; 2378 :       //    1 - Entity created using info from parent.
; 2379 :       //    2 - A SQL command was created and needs to be executed.  In this
; 2380 :       //        case only the keys need to be loaded for the entity.
; 2381 :       nRC = SqlAutoLoadFromParent( lpView, lpViewOD, lpViewEntity,

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+190]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SqlAutoLoadFromParent@24
	mov	WORD PTR _nRC$[ebp], ax

; 2382 :                                    lpConnection->lpFirstQualEntity,
; 2383 :                                    lpConnection->pchConnSqlCmd, lpBoundList );
; 2384 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN85@Load

; 2385 :          goto EndOfFunction;

	jmp	$EndOfFunction$213
	jmp	$LN86@Load
$LN85@Load:

; 2386 :       else
; 2387 :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN87@Load

; 2388 :       {
; 2389 :          nRC = SqlBuildSelect( lpView, lpViewOD, lpViewEntity,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+194]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+190]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SqlBuildSelect@24
	mov	WORD PTR _nRC$[ebp], ax

; 2390 :                                lpConnection->lpFirstQualEntity,
; 2391 :                                lpConnection->pchConnSqlCmd, lpBoundList );
; 2392 :          if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN89@Load

; 2393 :             goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN89@Load:

; 2394 :       }

	jmp	SHORT $LN86@Load
$LN87@Load:

; 2395 :       else
; 2396 :       if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $LN90@Load

; 2397 :       {
; 2398 :          nReturnCode = 0;

	xor	ecx, ecx
	mov	WORD PTR _nReturnCode$[ebp], cx

; 2399 : 
; 2400 : #if defined( DB2 ) || defined( ODBC )
; 2401 :          // We have to indicate that this entity is loaded from the parent
; 2402 :          // instead of the database.
; 2403 :          if ( g_bHoldStmtHandles )

	movzx	edx, BYTE PTR _g_bHoldStmtHandles
	test	edx, edx
	je	SHORT $LN92@Load

; 2404 :          {
; 2405 :             lpStmtHandle->bLoadFromParent = TRUE;

	mov	eax, DWORD PTR _lpStmtHandle$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 1
	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 2406 :             lpStmtHandle->lpBoundList = lpBoundList;

	mov	eax, DWORD PTR _lpStmtHandle$[ebp]
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN92@Load:

; 2407 :          }
; 2408 : #endif
; 2409 : 
; 2410 :          goto EndOfFunction;

	jmp	$EndOfFunction$213

; 2411 :       }

	jmp	SHORT $LN86@Load
$LN90@Load:

; 2412 :       else
; 2413 :       if ( nRC == 2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $LN86@Load

; 2414 :       {
; 2415 :          bKeysOnly = TRUE;

	mov	BYTE PTR _bKeysOnly$[ebp], 1

; 2416 :          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN86@Load:

; 2417 :       }
; 2418 :    }

	jmp	SHORT $LN83@Load
$LN82@Load:

; 2419 :    else
; 2420 :    {
; 2421 :       nRC = SqlBuildSelect( lpView, lpViewOD, lpViewEntity,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+190]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SqlBuildSelect@24
	mov	WORD PTR _nRC$[ebp], ax

; 2422 :                             lpConnection->lpFirstQualEntity,
; 2423 :                             lpConnection->pchConnSqlCmd, lpBoundList );
; 2424 :       if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN83@Load

; 2425 :          goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN83@Load:

; 2426 :    }
; 2427 : 
; 2428 :    // If the '2' bit is set then multiple tables where joined together.
; 2429 :    nRC &= ~((zSHORT) 0x0002); // turn off the join flag

	movsx	ecx, WORD PTR _nRC$[ebp]
	and	ecx, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], cx

; 2430 : 
; 2431 :    // If nRC == 1, then some of the foreign keys are null, which means that
; 2432 :    // there are no children.
; 2433 : 
; 2434 : #if defined( DB2 ) || defined( ODBC )
; 2435 : 
; 2436 :    // If we're holding on to stmt handles we will ignore the nRC == 1 return
; 2437 :    // code because we still want to prepare the stmt for later use.
; 2438 :    if ( nRC == 1 && g_bHoldStmtHandles )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	jne	SHORT $LN95@Load
	movzx	eax, BYTE PTR _g_bHoldStmtHandles
	test	eax, eax
	je	SHORT $LN95@Load

; 2439 :       nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN95@Load:

; 2440 : 
; 2441 : #endif
; 2442 : 
; 2443 :    if ( nRC == 1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	jne	SHORT $LN96@Load

; 2444 :    {
; 2445 :       if ( lpConnection->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	cmp	ecx, 1
	jle	SHORT $LN97@Load

; 2446 :       {
; 2447 :          TraceLineS( "Foreign key is null, so following command was not ",

	push	OFFSET $SG95298
	push	OFFSET $SG95299
	call	_TraceLineS@8

; 2448 :                      "executed." );
; 2449 :          SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );

	push	0
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	call	_SqlDisplayCommand@8

; 2450 :          TraceLineI( "Number of rows selected = ", (zLONG) 0 );

	push	0
	push	OFFSET $SG95300
	call	_TraceLineI@8
$LN97@Load:

; 2451 :       }
; 2452 : 
; 2453 :       nReturnCode = 0;

	xor	ecx, ecx
	mov	WORD PTR _nReturnCode$[ebp], cx

; 2454 :       goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN96@Load:

; 2455 :    }
; 2456 : 
; 2457 :    // Check to see if the current select was built using OpenSQL.
; 2458 :    if ( lpQualEntity && lpQualEntity->pszOpenSQL )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN98@Load
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN98@Load

; 2459 :       bOpenSQL = TRUE;

	mov	BYTE PTR _bOpenSQL$[ebp], 1
$LN98@Load:

; 2460 : 
; 2461 :    // ================================================================
; 2462 :    // Set up incoming buffer area.
; 2463 :    // ================================================================
; 2464 : 
; 2465 :    // First get the attribute lengths.
; 2466 :    LoopInfo.bOpenSQL          = bOpenSQL;

	mov	al, BYTE PTR _bOpenSQL$[ebp]
	mov	BYTE PTR _LoopInfo$[ebp], al

; 2467 :    LoopInfo.bKeysOnly         = bKeysOnly;

	mov	cl, BYTE PTR _bKeysOnly$[ebp]
	mov	BYTE PTR _LoopInfo$[ebp+1], cl

; 2468 :    LoopInfo.bFirstPass        = TRUE;

	mov	BYTE PTR _LoopInfo$[ebp+32], 1

; 2469 :    LoopInfo.lpQualEntity      = lpQualEntity;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+4], edx

; 2470 :    LoopInfo.lpFirstQualEntity = lpConnection->lpFirstQualEntity;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+190]
	mov	DWORD PTR _LoopInfo$[ebp+8], ecx

; 2471 :    LoopInfo.lpViewEntity      = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+12], edx

; 2472 :    LoopInfo.lpDataField       = 0;

	mov	DWORD PTR _LoopInfo$[ebp+20], 0

; 2473 :    LoopInfo.lControl          = Indicators;

	mov	eax, DWORD PTR _Indicators$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+24], eax

; 2474 :    LoopInfo.lpBoundList       = lpBoundList;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+28], ecx

; 2475 :    nColumnCnt                 = 0;

	xor	edx, edx
	mov	WORD PTR _nColumnCnt$[ebp], dx

; 2476 :    ulTotalLth                 = 0;

	mov	DWORD PTR _ulTotalLth$[ebp], 0

; 2477 : 
; 2478 :    for ( lpDataField = fnGetNextDataField( &LoopInfo );

	lea	eax, DWORD PTR _LoopInfo$[ebp]
	push	eax
	call	_fnGetNextDataField@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN10@Load
$LN8@Load:

; 2480 :          lpDataField = fnGetNextDataField( &LoopInfo ) )

	lea	ecx, DWORD PTR _LoopInfo$[ebp]
	push	ecx
	call	_fnGetNextDataField@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN10@Load:

; 2479 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN9@Load

; 2481 :    {
; 2482 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2483 :       nColumnCnt++;

	mov	cx, WORD PTR _nColumnCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nColumnCnt$[ebp], cx

; 2484 : 
; 2485 :       // ================================================================
; 2486 :       // Get column length.
; 2487 :       // ================================================================
; 2488 : 
; 2489 : #if defined( DB2 ) || defined( ODBC )
; 2490 :       {
; 2491 :       SWORD        fSqlType;
; 2492 :       UDWORD       ulLth;
; 2493 : 
; 2494 :       // We need space for the incoming length.
; 2495 :       ulTotalLth += sizeof( SQLINTEGER );

	mov	edx, DWORD PTR _ulTotalLth$[ebp]
	add	edx, 4
	mov	DWORD PTR _ulTotalLth$[ebp], edx

; 2496 : 
; 2497 :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv521[ebp], ecx
	mov	edx, DWORD PTR tv521[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv521[ebp], edx
	cmp	DWORD PTR tv521[ebp], 22		; 00000016H
	ja	$LN107@Load
	mov	eax, DWORD PTR tv521[ebp]
	movzx	ecx, BYTE PTR $LN207@Load[eax]
	jmp	DWORD PTR $LN210@Load[ecx*4]
$LN99@Load:

; 2498 :       {
; 2499 :          case zTYPE_BLOB:
; 2500 : #if defined( ODBC )
; 2501 :             // We don't want to bind blobs because we are going to use
; 2502 :             // SQLGetData( ) to retrieve the data.
; 2503 :             continue;

	jmp	$LN8@Load

; 2504 : #else
; 2505 :             fSqlType = SQL_C_BLOB_LOCATOR;
; 2506 : #endif
; 2507 :             ulLth = sizeof( SQLINTEGER );

	mov	DWORD PTR _ulLth$22[ebp], 4

; 2508 :             break;

	jmp	$LN11@Load
$LN100@Load:

; 2509 : 
; 2510 :          case zTYPE_DATETIME:
; 2511 :          case zTYPE_TIME:
; 2512 :          case zTYPE_DATE:
; 2513 :             fSqlType = SQL_C_CHAR;

	mov	edx, 1
	mov	WORD PTR _fSqlType$28[ebp], dx

; 2514 :             ulLth = CONVERSION_AREA_LTH; // We'll retrieve the date as a string

	mov	DWORD PTR _ulLth$22[ebp], 100		; 00000064H

; 2515 :                                          // and then convert it.
; 2516 :             break;

	jmp	$LN11@Load
$LN101@Load:

; 2517 : 
; 2518 :          case 'X':
; 2519 :             // TimeStampEx.
; 2520 :             fSqlType = SQL_C_CHAR;

	mov	eax, 1
	mov	WORD PTR _fSqlType$28[ebp], ax

; 2521 :             ulLth = CONVERSION_AREA_LTH;

	mov	DWORD PTR _ulLth$22[ebp], 100		; 00000064H

; 2522 :             break;

	jmp	$LN11@Load
$LN102@Load:

; 2523 : 
; 2524 :          case zTYPE_INTEGER:
; 2525 :             fSqlType = SQL_C_SLONG;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _fSqlType$28[ebp], cx

; 2526 :             ulLth = sizeof( zLONG );

	mov	DWORD PTR _ulLth$22[ebp], 4

; 2527 :             break;

	jmp	$LN11@Load
$LN103@Load:

; 2528 : 
; 2529 :          case zTYPE_DECIMAL:
; 2530 :             fSqlType = SQL_C_CHAR;

	mov	edx, 1
	mov	WORD PTR _fSqlType$28[ebp], dx

; 2531 :             ulLth = CONVERSION_AREA_LTH; // We'll retrieve the date as a string

	mov	DWORD PTR _ulLth$22[ebp], 100		; 00000064H

; 2532 :                                          // and then convert it.
; 2533 :             break;

	jmp	SHORT $LN11@Load
$LN104@Load:

; 2534 : 
; 2535 :          case zTYPE_STRING:
; 2536 :             switch ( lpDataField->cFldType )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	cl, BYTE PTR [eax+270]
	mov	BYTE PTR tv524[ebp], cl
	cmp	BYTE PTR tv524[ebp], 86			; 00000056H
	je	SHORT $LN105@Load
	jmp	SHORT $LN106@Load
$LN105@Load:

; 2537 :             {
; 2538 :                case 'V':
; 2539 : #if defined( DB2 )
; 2540 :                   fSqlType = SQL_C_CLOB_LOCATOR;
; 2541 :                   ulLth = sizeof( SQLINTEGER );
; 2542 : #else
; 2543 :                   // We don't want to bind varchar because we are going to use
; 2544 :                   // SQLGetData( ) to retrieve the data.
; 2545 :                   continue;

	jmp	$LN8@Load

; 2546 : #endif
; 2547 :                   break;

	jmp	SHORT $LN13@Load
$LN106@Load:

; 2548 : 
; 2549 :                default:
; 2550 :                   fSqlType = SQL_C_CHAR;

	mov	edx, 1
	mov	WORD PTR _fSqlType$28[ebp], dx

; 2551 :                   ulLth = lpDataField->uFldLth + 1;

	mov	eax, DWORD PTR _lpDataField$[ebp]
	movzx	ecx, WORD PTR [eax+271]
	add	ecx, 1
	mov	DWORD PTR _ulLth$22[ebp], ecx
$LN13@Load:

; 2552 :                   break;
; 2553 :             }
; 2554 : 
; 2555 :             break;

	jmp	SHORT $LN11@Load
$LN107@Load:

; 2556 : 
; 2557 :          default:
; 2558 :             DBH_Error(lpView, "Unknown Data Type", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG95311
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DBH_Error
	add	esp, 16					; 00000010H

; 2559 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN11@Load:

; 2560 :             break;
; 2561 :       }
; 2562 : 
; 2563 :       ulTotalLth += ulLth;

	mov	ecx, DWORD PTR _ulTotalLth$[ebp]
	add	ecx, DWORD PTR _ulLth$22[ebp]
	mov	DWORD PTR _ulTotalLth$[ebp], ecx

; 2564 : 
; 2565 :       }
; 2566 : 
; 2567 : #endif
; 2568 : 
; 2569 :    } // for ( lpDataField )...

	jmp	$LN8@Load
$LN9@Load:

; 2570 : 
; 2571 :    // Allocate the buffer.
; 2572 : #if defined( DB2 ) || defined( ODBC )
; 2573 : 
; 2574 :    if ( g_bHoldStmtHandles )

	movzx	edx, BYTE PTR _g_bHoldStmtHandles
	test	edx, edx
	je	$LN108@Load

; 2575 :    {
; 2576 :       // We need to add one more to column count to account for the difference
; 2577 :       // between the count and offsets.
; 2578 :       nColumnCnt++;

	mov	ax, WORD PTR _nColumnCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nColumnCnt$[ebp], ax

; 2579 : 
; 2580 :       lpStmtHandle->pchOutputBuffer = malloc( ulTotalLth + 1 );

	mov	ecx, DWORD PTR _ulTotalLth$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2581 :       lpConnection->pchGlobalTableBuffer = lpStmtHandle->pchOutputBuffer;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+202], edx

; 2582 :       lpStmtHandle->ppchBufferPtr = malloc( sizeof( zPCHAR ) * nColumnCnt );

	movsx	eax, WORD PTR _nColumnCnt$[ebp]
	shl	eax, 2
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 2583 :       ppchBufferPtr = lpStmtHandle->ppchBufferPtr;

	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _ppchBufferPtr$[ebp], eax

; 2584 :       zmemset( ppchBufferPtr, 0, sizeof( zPCHAR ) * nColumnCnt );

	movsx	ecx, WORD PTR _nColumnCnt$[ebp]
	shl	ecx, 2
	push	ecx
	push	0
	mov	edx, DWORD PTR _ppchBufferPtr$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 2585 :       lpStmtHandle->lpBoundList = lpBoundList;

	mov	eax, DWORD PTR _lpStmtHandle$[ebp]
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	DWORD PTR [eax+24], ecx
$LN108@Load:

; 2586 :    }
; 2587 : #endif
; 2588 : 
; 2589 :    // ================================================================
; 2590 :    // Compile/prepare SQL.
; 2591 :    // ================================================================
; 2592 : 
; 2593 : #if defined( DB2 ) || defined( ODBC )
; 2594 : 
; 2595 :    nRC = SQLPrepare( lpConnection->hstmt, lpConnection->pchConnSqlCmd, SQL_NTS );

	push	-3					; fffffffdH
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLPrepare@12
	mov	WORD PTR _nRC$[ebp], ax

; 2596 :    DisplayCommand( "SQLPrepare", nRC, lpConnection );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95313
	call	_DisplayCommand
	add	esp, 12					; 0000000cH

; 2597 :    if ( nRC != SQL_SUCCESS )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN109@Load

; 2598 :       goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN109@Load:

; 2599 : 
; 2600 : #elif defined( DUMMY )
; 2601 : 
; 2602 :    DisplayCommand( "Compile SQL", nRC, lpConnection );
; 2603 :    if ( nRC )
; 2604 :       goto EndOfFunction;
; 2605 : 
; 2606 : #endif
; 2607 : 
; 2608 :    // Set the select buffer for each data field.
; 2609 :    LoopInfo.bOpenSQL          = bOpenSQL;

	mov	al, BYTE PTR _bOpenSQL$[ebp]
	mov	BYTE PTR _LoopInfo$[ebp], al

; 2610 :    LoopInfo.bKeysOnly         = bKeysOnly;

	mov	cl, BYTE PTR _bKeysOnly$[ebp]
	mov	BYTE PTR _LoopInfo$[ebp+1], cl

; 2611 :    LoopInfo.bFirstPass        = TRUE;

	mov	BYTE PTR _LoopInfo$[ebp+32], 1

; 2612 :    LoopInfo.lpQualEntity      = lpQualEntity;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+4], edx

; 2613 :    LoopInfo.lpFirstQualEntity = lpConnection->lpFirstQualEntity;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+190]
	mov	DWORD PTR _LoopInfo$[ebp+8], ecx

; 2614 :    LoopInfo.lpViewEntity      = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+12], edx

; 2615 :    LoopInfo.lpDataField       = 0;

	mov	DWORD PTR _LoopInfo$[ebp+20], 0

; 2616 :    LoopInfo.lControl          = Indicators;

	mov	eax, DWORD PTR _Indicators$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+24], eax

; 2617 :    LoopInfo.lpBoundList       = lpBoundList;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+28], ecx

; 2618 :    nColumnCnt = 0;

	xor	edx, edx
	mov	WORD PTR _nColumnCnt$[ebp], dx

; 2619 :    lpPtr        = lpConnection->pchGlobalTableBuffer;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+202]
	mov	DWORD PTR _lpPtr$[ebp], ecx

; 2620 : 
; 2621 :    for ( lpDataField = fnGetNextDataField( &LoopInfo );

	lea	edx, DWORD PTR _LoopInfo$[ebp]
	push	edx
	call	_fnGetNextDataField@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN17@Load
$LN15@Load:

; 2623 :          lpDataField = fnGetNextDataField( &LoopInfo ) )

	lea	eax, DWORD PTR _LoopInfo$[ebp]
	push	eax
	call	_fnGetNextDataField@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN17@Load:

; 2622 :          lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN16@Load

; 2624 :    {
; 2625 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2626 :       nColumnCnt++;

	mov	ax, WORD PTR _nColumnCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nColumnCnt$[ebp], ax

; 2627 : 
; 2628 :       // ================================================================
; 2629 :       // Bind columns.
; 2630 :       // ================================================================
; 2631 : 
; 2632 : #if defined( DB2 ) || defined( ODBC )
; 2633 :       {
; 2634 :       SWORD        fSqlType;
; 2635 :       UDWORD       ulLth;
; 2636 :       zPCHAR       lpDataPtr;
; 2637 : 
; 2638 :       ppchBufferPtr[ nColumnCnt ] = lpPtr;

	movsx	ecx, WORD PTR _nColumnCnt$[ebp]
	mov	edx, DWORD PTR _ppchBufferPtr$[ebp]
	mov	eax, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 2639 : 
; 2640 :       // lpDataPtr points to the area that is to hold the data returned from
; 2641 :       // the database.
; 2642 :       lpDataPtr = lpPtr + sizeof( SQLINTEGER );

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _lpDataPtr$7[ebp], ecx

; 2643 :       *(SQLINTEGER *) lpPtr = 0;

	mov	edx, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [edx], 0

; 2644 : 
; 2645 :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv593[ebp], ecx
	mov	edx, DWORD PTR tv593[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv593[ebp], edx
	cmp	DWORD PTR tv593[ebp], 22		; 00000016H
	ja	$LN118@Load
	mov	eax, DWORD PTR tv593[ebp]
	movzx	ecx, BYTE PTR $LN208@Load[eax]
	jmp	DWORD PTR $LN211@Load[ecx*4]
$LN110@Load:

; 2646 :       {
; 2647 :          case zTYPE_BLOB:
; 2648 : #if defined( ODBC )
; 2649 :             // We don't want to bind blobs because we are going to use
; 2650 :             // SQLGetData( ) to retrieve the data.
; 2651 :             continue;

	jmp	$LN15@Load

; 2652 : #else
; 2653 :             fSqlType = SQL_C_BLOB_LOCATOR;
; 2654 : #endif
; 2655 :             ulLth = sizeof( SQLINTEGER );

	mov	DWORD PTR _ulLth$26[ebp], 4

; 2656 :             break;

	jmp	$LN18@Load
$LN111@Load:

; 2657 : 
; 2658 :          case zTYPE_DATETIME:
; 2659 :          case zTYPE_TIME:
; 2660 :          case zTYPE_DATE:
; 2661 :             fSqlType = SQL_C_CHAR;

	mov	edx, 1
	mov	WORD PTR _fSqlType$35[ebp], dx

; 2662 :             ulLth = CONVERSION_AREA_LTH; // We'll store the date as a string

	mov	DWORD PTR _ulLth$26[ebp], 100		; 00000064H

; 2663 :                                          // and then convert it.
; 2664 :             break;

	jmp	$LN18@Load
$LN112@Load:

; 2665 : 
; 2666 :          case 'X':
; 2667 :             // TimeStampEx.
; 2668 :             fSqlType = SQL_C_CHAR;

	mov	eax, 1
	mov	WORD PTR _fSqlType$35[ebp], ax

; 2669 :             ulLth = CONVERSION_AREA_LTH;

	mov	DWORD PTR _ulLth$26[ebp], 100		; 00000064H

; 2670 :             break;

	jmp	$LN18@Load
$LN113@Load:

; 2671 : 
; 2672 :          case zTYPE_INTEGER:
; 2673 :             fSqlType = SQL_C_SLONG;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _fSqlType$35[ebp], cx

; 2674 :             ulLth = sizeof( zLONG );

	mov	DWORD PTR _ulLth$26[ebp], 4

; 2675 :             break;

	jmp	$LN18@Load
$LN114@Load:

; 2676 : 
; 2677 :          case zTYPE_DECIMAL:
; 2678 :             fSqlType = SQL_C_CHAR;

	mov	edx, 1
	mov	WORD PTR _fSqlType$35[ebp], dx

; 2679 :             ulLth = CONVERSION_AREA_LTH; // We'll retrieve the decimal as a

	mov	DWORD PTR _ulLth$26[ebp], 100		; 00000064H

; 2680 :                                          // string and then convert it.
; 2681 :             break;

	jmp	SHORT $LN18@Load
$LN115@Load:

; 2682 : 
; 2683 :          case zTYPE_STRING:
; 2684 :             switch ( lpDataField->cFldType )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	cl, BYTE PTR [eax+270]
	mov	BYTE PTR tv596[ebp], cl
	cmp	BYTE PTR tv596[ebp], 86			; 00000056H
	je	SHORT $LN116@Load
	jmp	SHORT $LN117@Load
$LN116@Load:

; 2685 :             {
; 2686 :                case 'V':
; 2687 : #if defined( DB2 )
; 2688 :                   fSqlType = SQL_C_CLOB_LOCATOR;
; 2689 :                   ulLth = sizeof( SQLINTEGER );
; 2690 : #else
; 2691 :                   // We don't want to bind varchar because we are going to use
; 2692 :                   // SQLGetData( ) to retrieve the data.
; 2693 :                   continue;

	jmp	$LN15@Load

; 2694 : #endif
; 2695 :                   break;

	jmp	SHORT $LN20@Load
$LN117@Load:

; 2696 : 
; 2697 :                default:
; 2698 :                   fSqlType = SQL_C_CHAR;

	mov	edx, 1
	mov	WORD PTR _fSqlType$35[ebp], dx

; 2699 :                   ulLth = lpDataField->uFldLth + 1;

	mov	eax, DWORD PTR _lpDataField$[ebp]
	movzx	ecx, WORD PTR [eax+271]
	add	ecx, 1
	mov	DWORD PTR _ulLth$26[ebp], ecx
$LN20@Load:

; 2700 :                   break;
; 2701 :             }
; 2702 : 
; 2703 :             break;

	jmp	SHORT $LN18@Load
$LN118@Load:

; 2704 : 
; 2705 :          default:
; 2706 :             DBH_Error(lpView, "Unknown Data Type", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG95324
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DBH_Error
	add	esp, 16					; 00000010H

; 2707 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN18@Load:

; 2708 :             break;
; 2709 :       }
; 2710 : 
; 2711 : 
; 2712 :       nRC = SQLBindCol( lpConnection->hstmt, nColumnCnt, fSqlType,

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulLth$26[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataPtr$7[ebp]
	push	eax
	movzx	ecx, WORD PTR _fSqlType$35[ebp]
	push	ecx
	movzx	edx, WORD PTR _nColumnCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLBindCol@24
	mov	WORD PTR _nRC$[ebp], ax

; 2713 :                         (SQLPOINTER) lpDataPtr,
; 2714 :                         ulLth, (SQLINTEGER *) lpPtr );
; 2715 :       SQL_RC( "SQLBindCol", nRC, "Attr = ", lpViewAttrib->szName, 2 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG95325
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95326
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 2716 : 
; 2717 :       if ( lpConnection->nTraceLevel >= 2 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 2
	jl	$LN119@Load

; 2718 :       {
; 2719 :          zCHAR sz[ 2 ] = " ";

	mov	cx, WORD PTR $SG95328
	mov	WORD PTR _sz$32[ebp], cx

; 2720 : 
; 2721 :          TraceLineI( "Column Count         = ", nColumnCnt );

	movsx	edx, WORD PTR _nColumnCnt$[ebp]
	push	edx
	push	OFFSET $SG95329
	call	_TraceLineI@8

; 2722 :          TraceLineS( "Column Name          = ", lpDataField->szFldName );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG95330
	call	_TraceLineS@8

; 2723 :          sz[ 0 ] = lpViewAttrib->cType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR _sz$32[ebp+edx], cl

; 2724 :          TraceLineS( "ViewAttrib data type = ", sz );

	lea	edx, DWORD PTR _sz$32[ebp]
	push	edx
	push	OFFSET $SG95331
	call	_TraceLineS@8

; 2725 :          sz[ 0 ] = lpDataField->cFldType;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	al, BYTE PTR [edx+270]
	mov	BYTE PTR _sz$32[ebp+ecx], al

; 2726 :          TraceLineS( "DataField data type  = ", sz );

	lea	ecx, DWORD PTR _sz$32[ebp]
	push	ecx
	push	OFFSET $SG95332
	call	_TraceLineS@8
$LN119@Load:

; 2727 :       }
; 2728 : 
; 2729 :       if ( !RC_SUCCESSFUL( nRC ) )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN120@Load
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN120@Load

; 2730 :          goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN120@Load:

; 2731 : 
; 2732 :       lpPtr += ulLth + sizeof( SQLINTEGER );

	mov	ecx, DWORD PTR _ulLth$26[ebp]
	mov	edx, DWORD PTR _lpPtr$[ebp]
	lea	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 2733 : 
; 2734 :       }
; 2735 : 
; 2736 : #endif
; 2737 : 
; 2738 :    } // for ( lpDataField )...

	jmp	$LN15@Load
$LN16@Load:

; 2739 : 
; 2740 : #if defined( DB2 ) || defined( ODBC )
; 2741 : 
; 2742 :    // Save the SQL command and statement handle.
; 2743 :    if ( g_bHoldStmtHandles )

	movzx	ecx, BYTE PTR _g_bHoldStmtHandles
	test	ecx, ecx
	je	$ExecuteCommand$214

; 2744 :    {
; 2745 :       zSHORT nLth = zstrlen( lpConnection->pchConnSqlCmd );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+194]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$12[ebp], ax

; 2746 : 
; 2747 :       lpStmtHandle->pchSqlCmd = malloc( nLth + 1 );

	movsx	ecx, WORD PTR _nLth$12[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2748 :       zstrcpy( lpStmtHandle->pchSqlCmd, lpConnection->pchConnSqlCmd );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_strcpy
	add	esp, 8

; 2749 : 
; 2750 :       lpStmtHandle->hstmt = lpConnection->hstmt;

	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	mov	DWORD PTR [ecx], eax

; 2751 : 
; 2752 :       // Check to make sure that there is a buffer to hold the input variables.
; 2753 :       if ( lpBoundList->lpFirstBoundAttr )

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	$ExecuteCommand$214

; 2754 :       {
; 2755 :          LPBOUNDATTR  lpBoundAttr;
; 2756 :          zPCHAR       pchBufferPos;
; 2757 :          SQLUSMALLINT nParmCount;
; 2758 : 
; 2759 :          // Go through the bind variable list and determine how big the buffer
; 2760 :          // needs to be.
; 2761 :          lpStmtHandle->ulInputLth = 0;

	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [edx+16], 0

; 2762 :          for ( lpBoundAttr = lpBoundList->lpFirstBoundAttr;

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR _lpBoundAttr$33[ebp], ecx
	jmp	SHORT $LN24@Load
$LN22@Load:

; 2764 :                lpBoundAttr = lpBoundAttr->lpNextBoundAttr )

	mov	edx, DWORD PTR _lpBoundAttr$33[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _lpBoundAttr$33[ebp], eax
$LN24@Load:

; 2763 :                lpBoundAttr;

	cmp	DWORD PTR _lpBoundAttr$33[ebp], 0
	je	SHORT $LN23@Load

; 2765 :          {
; 2766 :             // We need to keep an area to specify the attribute length.
; 2767 :             lpStmtHandle->ulInputLth += sizeof( SQLINTEGER );

	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	add	edx, 4
	mov	eax, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [eax+16], edx

; 2768 : 
; 2769 :             // Now set aside the buffer area.
; 2770 :             lpViewAttrib = zGETPTR( lpBoundAttr->lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpBoundAttr$33[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2771 :             lpStmtHandle->ulInputLth += lpViewAttrib->ulLth;

	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, DWORD PTR [eax+203]
	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 2772 :          }

	jmp	SHORT $LN22@Load
$LN23@Load:

; 2773 : 
; 2774 :          lpStmtHandle->pchInputBuffer = malloc( lpStmtHandle->ulInputLth + 1 );

	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _lpStmtHandle$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2775 : 
; 2776 :          // Now call BindParamter to set up the input buffer.
; 2777 :          nParmCount   = 0;

	xor	edx, edx
	mov	WORD PTR _nParmCount$29[ebp], dx

; 2778 :          pchBufferPos = lpStmtHandle->pchInputBuffer;

	mov	eax, DWORD PTR _lpStmtHandle$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pchBufferPos$23[ebp], ecx

; 2779 :          for ( lpBoundAttr = lpBoundList->lpFirstBoundAttr;

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _lpBoundAttr$33[ebp], eax
	jmp	SHORT $LN27@Load
$LN25@Load:

; 2781 :                lpBoundAttr = lpBoundAttr->lpNextBoundAttr )

	mov	ecx, DWORD PTR _lpBoundAttr$33[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _lpBoundAttr$33[ebp], edx
$LN27@Load:

; 2780 :                lpBoundAttr;

	cmp	DWORD PTR _lpBoundAttr$33[ebp], 0
	je	$ExecuteCommand$214

; 2782 :          {
; 2783 :             LPDATAFIELD    lpDataField  = lpBoundAttr->lpDataField;

	mov	eax, DWORD PTR _lpBoundAttr$33[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpDataField$9[ebp], ecx

; 2784 :             SQLSMALLINT    nC_DataType;
; 2785 :             SQLSMALLINT    nSQL_Type;
; 2786 :             SQLSMALLINT    nDecDigits;
; 2787 :             SQLUINTEGER    nColumnSize;
; 2788 :             SQLINTEGER *   lpnParmLth;
; 2789 :             SQLINTEGER     iBufferLth;
; 2790 : 
; 2791 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$9[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2792 : 
; 2793 :             nParmCount++;

	mov	cx, WORD PTR _nParmCount$29[ebp]
	add	cx, 1
	mov	WORD PTR _nParmCount$29[ebp], cx

; 2794 : 
; 2795 :             if ( lpConnection->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jle	SHORT $LN123@Load

; 2796 :             {
; 2797 :                TraceLineS( "(KZHSQLBA) Binding attributename = ",

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG95337
	call	_TraceLineS@8

; 2798 :                            lpViewAttrib->szName );
; 2799 :                TraceLineI( "nParmCount = ", nParmCount );

	movzx	edx, WORD PTR _nParmCount$29[ebp]
	push	edx
	push	OFFSET $SG95338
	call	_TraceLineI@8
$LN123@Load:

; 2800 :             }
; 2801 : 
; 2802 :             lpnParmLth = (SQLINTEGER *) pchBufferPos;

	mov	eax, DWORD PTR _pchBufferPos$23[ebp]
	mov	DWORD PTR _lpnParmLth$18[ebp], eax

; 2803 :             pchBufferPos += sizeof( SQLINTEGER );

	mov	ecx, DWORD PTR _pchBufferPos$23[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchBufferPos$23[ebp], ecx

; 2804 : 
; 2805 :             switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv784[ebp], al
	cmp	BYTE PTR tv784[ebp], 76			; 0000004cH
	je	SHORT $LN125@Load
	cmp	BYTE PTR tv784[ebp], 83			; 00000053H
	je	SHORT $LN124@Load
	jmp	$LN28@Load
$LN124@Load:

; 2806 :             {
; 2807 :                case zTYPE_STRING:
; 2808 :                   nC_DataType = SQL_C_CHAR;

	mov	ecx, 1
	mov	WORD PTR _nC_DataType$24[ebp], cx

; 2809 :                   nSQL_Type   = SQL_VARCHAR;

	mov	edx, 12					; 0000000cH
	mov	WORD PTR _nSQL_Type$25[ebp], dx

; 2810 :                   iBufferLth  = lpViewAttrib->ulLth;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+203]
	mov	DWORD PTR _iBufferLth$16[ebp], ecx

; 2811 :                   nColumnSize = lpViewAttrib->ulLth;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+203]
	mov	DWORD PTR _nColumnSize$17[ebp], eax

; 2812 :                   *lpnParmLth = SQL_NTS;

	mov	ecx, DWORD PTR _lpnParmLth$18[ebp]
	mov	DWORD PTR [ecx], -3			; fffffffdH

; 2813 :                   nDecDigits = 0;

	xor	edx, edx
	mov	WORD PTR _nDecDigits$27[ebp], dx

; 2814 :                   break;

	jmp	SHORT $LN28@Load
$LN125@Load:

; 2815 : 
; 2816 :                case zTYPE_INTEGER:
; 2817 :                   nC_DataType = SQL_C_SLONG;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nC_DataType$24[ebp], ax

; 2818 :                   nSQL_Type   = SQL_INTEGER;

	mov	ecx, 4
	mov	WORD PTR _nSQL_Type$25[ebp], cx

; 2819 :                   iBufferLth  = sizeof( zLONG );

	mov	DWORD PTR _iBufferLth$16[ebp], 4

; 2820 :                   nColumnSize = sizeof( zLONG );

	mov	DWORD PTR _nColumnSize$17[ebp], 4

; 2821 :                   *lpnParmLth = sizeof( zLONG );

	mov	edx, DWORD PTR _lpnParmLth$18[ebp]
	mov	DWORD PTR [edx], 4

; 2822 :                   nDecDigits = 0;

	xor	eax, eax
	mov	WORD PTR _nDecDigits$27[ebp], ax
$LN28@Load:

; 2823 :                   break;
; 2824 :             }
; 2825 : 
; 2826 :             nRC = SQLBindParameter( lpConnection->hstmt, nParmCount, SQL_PARAM_INPUT,

	mov	ecx, DWORD PTR _lpnParmLth$18[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBufferLth$16[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBufferPos$23[ebp]
	push	eax
	movzx	ecx, WORD PTR _nDecDigits$27[ebp]
	push	ecx
	mov	edx, DWORD PTR _nColumnSize$17[ebp]
	push	edx
	movzx	eax, WORD PTR _nSQL_Type$25[ebp]
	push	eax
	movzx	ecx, WORD PTR _nC_DataType$24[ebp]
	push	ecx
	push	1
	movzx	edx, WORD PTR _nParmCount$29[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLBindParameter@40
	mov	WORD PTR _nRC$[ebp], ax

; 2827 :                                     nC_DataType, nSQL_Type, nColumnSize, nDecDigits,
; 2828 :                                     (SQLPOINTER) pchBufferPos, iBufferLth,
; 2829 :                                     lpnParmLth );
; 2830 :             SQL_RC( "SQLBindParameter", nRC, "Column = ", lpDataField->szFldName, 3 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	3
	mov	eax, DWORD PTR _lpDataField$9[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG95341
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95342
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 2831 : 
; 2832 :             if ( lpConnection->nTraceLevel > 2 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 2
	jle	SHORT $LN126@Load

; 2833 :             {
; 2834 :                TraceLineI( "nC_DataType = ", nC_DataType );

	movsx	ecx, WORD PTR _nC_DataType$24[ebp]
	push	ecx
	push	OFFSET $SG95344
	call	_TraceLineI@8

; 2835 :                TraceLineI( "nSQL_Type   = ", nSQL_Type );

	movsx	edx, WORD PTR _nSQL_Type$25[ebp]
	push	edx
	push	OFFSET $SG95345
	call	_TraceLineI@8

; 2836 :                TraceLineI( "nColumnSize = ", nColumnSize );

	mov	eax, DWORD PTR _nColumnSize$17[ebp]
	push	eax
	push	OFFSET $SG95346
	call	_TraceLineI@8

; 2837 :                TraceLineI( "nDecDigits  = ", nDecDigits );

	movsx	ecx, WORD PTR _nDecDigits$27[ebp]
	push	ecx
	push	OFFSET $SG95347
	call	_TraceLineI@8
$LN126@Load:

; 2838 :             }
; 2839 : 
; 2840 :             if ( !RC_SUCCESSFUL( nRC ) )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN127@Load
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN127@Load

; 2841 :                goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN127@Load:

; 2842 : 
; 2843 :             pchBufferPos += iBufferLth;

	mov	ecx, DWORD PTR _pchBufferPos$23[ebp]
	add	ecx, DWORD PTR _iBufferLth$16[ebp]
	mov	DWORD PTR _pchBufferPos$23[ebp], ecx

; 2844 : 
; 2845 :          } // for...

	jmp	$LN25@Load
$ExecuteCommand$214:

; 2846 : 
; 2847 :       } // if ( lpStmtHandle->pchInputBuffer == 0 )...
; 2848 : 
; 2849 :    } // if ( g_bHoldStmtHandles )...
; 2850 : 
; 2851 : #endif
; 2852 : 
; 2853 :    // ================================================================
; 2854 :    // Execute generated SQL
; 2855 :    // ================================================================
; 2856 : 
; 2857 :    // Following is kind of a hack to keep from getting warning messages that
; 2858 :    // the label ExecuteCommand is unused.
; 2859 :    goto ExecuteCommand;
; 2860 : 
; 2861 : // I know goto statements are lousy but it is much easier to code when
; 2862 : // dealing with all the conditional compiling.
; 2863 : ExecuteCommand:
; 2864 : 
; 2865 :    // If the qualification uses a key list then we need to add the keys to
; 2866 :    // the key list table.
; 2867 :    if ( lpQualEntity && lpQualEntity->bContainsKeyList )

	cmp	DWORD PTR _lpQualEntity$[ebp], 0
	je	SHORT $LN128@Load
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+28]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN128@Load

; 2868 :    {
; 2869 :       zLONG hTask = SysGetTaskFromView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysGetTaskFromView@4
	mov	DWORD PTR _hTask$6[ebp], eax

; 2870 :       if ( fnCreateKeyList( hTask, lpConnection, lpBoundList, lpQualEntity ) < 0 )

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hTask$6[ebp]
	push	edx
	call	_fnCreateKeyList@16
	cwde
	test	eax, eax
	jge	SHORT $LN129@Load

; 2871 :          goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN129@Load:

; 2872 : 
; 2873 :       bKeyListCreated = TRUE;

	mov	BYTE PTR _bKeyListCreated$[ebp], 1
$LN128@Load:

; 2874 :    }
; 2875 : 
; 2876 : #if defined( DB2 ) || defined( ODBC )
; 2877 : 
; 2878 :    // OK, if there are any bound attributes we need to copy the attribute
; 2879 :    // values into the input buffer.
; 2880 :    if ( lpBoundList && lpBoundList->lpFirstBoundAttr )

	cmp	DWORD PTR _lpBoundList$[ebp], 0
	je	$LN130@Load
	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	$LN130@Load

; 2881 :    {
; 2882 :       LPBOUNDATTR  lpBoundAttr;
; 2883 :       zPCHAR       pchBufferPos;
; 2884 : 
; 2885 :       // Go through the bind variable list and determine how big the buffer
; 2886 :       // needs to be.
; 2887 :       pchBufferPos = lpStmtHandle->pchInputBuffer;

	mov	edx, DWORD PTR _lpStmtHandle$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _pchBufferPos$30[ebp], eax

; 2888 :       for ( lpBoundAttr = lpBoundList->lpFirstBoundAttr;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _lpBoundAttr$21[ebp], edx
	jmp	SHORT $LN32@Load
$LN30@Load:

; 2890 :             lpBoundAttr = lpBoundAttr->lpNextBoundAttr )

	mov	eax, DWORD PTR _lpBoundAttr$21[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lpBoundAttr$21[ebp], ecx
$LN32@Load:

; 2889 :             lpBoundAttr;

	cmp	DWORD PTR _lpBoundAttr$21[ebp], 0
	je	$LN130@Load

; 2891 :       {
; 2892 :          LPDATAFIELD    lpDataField  = lpBoundAttr->lpDataField;

	mov	edx, DWORD PTR _lpBoundAttr$21[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpDataField$5[ebp], eax

; 2893 :          LPVIEWENTITY   lpBoundEntity;
; 2894 :          SQLINTEGER     *lpnLth;
; 2895 :          zPCHAR         lpValue;
; 2896 :          zCHAR          chType;
; 2897 :          zULONG         ulLth;
; 2898 : 
; 2899 :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2900 :          lpBoundEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpBoundEntity$4[ebp], eax

; 2901 : 
; 2902 :          lpnLth = (SQLINTEGER *) pchBufferPos;

	mov	edx, DWORD PTR _pchBufferPos$30[ebp]
	mov	DWORD PTR _lpnLth$1[ebp], edx

; 2903 :          pchBufferPos += sizeof( SQLINTEGER );

	mov	eax, DWORD PTR _pchBufferPos$30[ebp]
	add	eax, 4
	mov	DWORD PTR _pchBufferPos$30[ebp], eax

; 2904 : 
; 2905 :          if ( GetValueFromRecord( lpBoundAttr->lpView,
; 2906 :                                   lpBoundEntity, lpViewAttrib, (zPVOID) &lpValue,
; 2907 :                                   &chType, &ulLth ) == zCALL_ERROR )

	lea	ecx, DWORD PTR _ulLth$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$11[ebp]
	push	edx
	lea	eax, DWORD PTR _lpValue$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpBoundEntity$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBoundAttr$21[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_GetValueFromRecord@24
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN131@Load

; 2908 :          {
; 2909 :             // Oops, error.  Get out of function.
; 2910 :             goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN131@Load:

; 2911 :          }
; 2912 : 
; 2913 :          switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv870[ebp], cl
	cmp	BYTE PTR tv870[ebp], 76			; 0000004cH
	je	SHORT $LN133@Load
	cmp	BYTE PTR tv870[ebp], 83			; 00000053H
	je	SHORT $LN132@Load
	jmp	SHORT $LN33@Load
$LN132@Load:

; 2914 :          {
; 2915 :             case zTYPE_STRING:
; 2916 :             // Length is always SQL_NTS.
; 2917 :                //*lpnLth = (SQLINTEGER) ulLth;
; 2918 :                zstrcpy( pchBufferPos, lpValue );

	mov	edx, DWORD PTR _lpValue$10[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBufferPos$30[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2919 :                pchBufferPos += lpViewAttrib->ulLth;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchBufferPos$30[ebp]
	add	edx, DWORD PTR [ecx+203]
	mov	DWORD PTR _pchBufferPos$30[ebp], edx

; 2920 :                break;

	jmp	SHORT $LN33@Load
$LN133@Load:

; 2921 : 
; 2922 :             case zTYPE_INTEGER:
; 2923 :                *((zPLONG) pchBufferPos) = *((zPLONG) lpValue);

	mov	eax, DWORD PTR _pchBufferPos$30[ebp]
	mov	ecx, DWORD PTR _lpValue$10[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 2924 :                pchBufferPos += sizeof( zLONG );

	mov	eax, DWORD PTR _pchBufferPos$30[ebp]
	add	eax, 4
	mov	DWORD PTR _pchBufferPos$30[ebp], eax
$LN33@Load:

; 2925 :                break;
; 2926 :          }
; 2927 :       }

	jmp	$LN30@Load
$LN130@Load:

; 2928 :    }
; 2929 : 
; 2930 :    // Execute the sql command.
; 2931 :    nRC = SQLExecute( lpConnection->hstmt );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLExecute@4
	mov	WORD PTR _nRC$[ebp], ax

; 2932 :    SQL_RC( "SQLExecute", nRC, 0, 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	0
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95355
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 2933 :    if ( nRC != SQL_SUCCESS && nRC != SQL_SUCCESS_WITH_INFO )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $StartOfFetches$215
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $StartOfFetches$215

; 2934 :    {
; 2935 :       // If the trace level is 0 then let's trace the SQL to help debugging.
; 2936 :       if ( lpConnection->nTraceLevel == 0 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	test	edx, edx
	jne	SHORT $LN135@Load

; 2937 :          SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );

	push	0
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+194]
	push	ecx
	call	_SqlDisplayCommand@8
$LN135@Load:

; 2938 : 
; 2939 :       goto EndOfFunction;

	jmp	$EndOfFunction$213
$StartOfFetches$215:

; 2940 :    }
; 2941 : 
; 2942 : #endif
; 2943 : 
; 2944 :    // Following is kind of a hack to keep from getting warning messages that
; 2945 :    // the label StartOfFetches is unused.
; 2946 :    goto StartOfFetches;
; 2947 : 
; 2948 : StartOfFetches:
; 2949 : 
; 2950 : #ifdef DELETEHACK
; 2951 :    // If OpenSQL has been specified but there are no data fields then we'll
; 2952 :    // assume that OpenSQL has been used for DELETE processing.  For delete
; 2953 :    // processing we obviously don't need to do a fetch so return now.
; 2954 :    if ( bOpenSQL && lpQualEntity->lpDataField[ 0 ] == 0 )

	movzx	edx, BYTE PTR _bOpenSQL$[ebp]
	test	edx, edx
	je	SHORT $LN136@Load
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	eax, DWORD PTR [edx+20]
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $LN136@Load

; 2955 :    {
; 2956 :       nReturnCode = -1;  // Indicates nothing was loaded.

	or	ecx, -1
	mov	WORD PTR _nReturnCode$[ebp], cx

; 2957 :       goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN136@Load:

; 2958 :    }
; 2959 : #endif
; 2960 : 
; 2961 :    // ================================================================
; 2962 :    // Fetch first row from the table.
; 2963 :    // ================================================================
; 2964 : 
; 2965 :    lRowCount  = 0;

	mov	DWORD PTR _lRowCount$[ebp], 0

; 2966 :    lRootCnt = 0;

	mov	DWORD PTR _lRootCnt$[ebp], 0

; 2967 : 
; 2968 :    if ( bCreateMultipleRoots == FALSE && lpViewEntity->hParent == 0 )

	movzx	edx, BYTE PTR _bCreateMultipleRoots$[ebp]
	test	edx, edx
	jne	SHORT $LN137@Load
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN137@Load

; 2969 :       lRootLimit = 1;

	mov	DWORD PTR _lRootLimit$[ebp], 1
	jmp	SHORT $LN138@Load
$LN137@Load:

; 2970 :    else
; 2971 :    {
; 2972 :       lRootLimit = lpViewEntity->lActivateLimit;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+226]
	mov	DWORD PTR _lRootLimit$[ebp], edx

; 2973 :       if ( lRootLimit == 0 )

	cmp	DWORD PTR _lRootLimit$[ebp], 0
	jne	SHORT $LN138@Load

; 2974 :          lRootLimit = 0x7FFFFFFF;

	mov	DWORD PTR _lRootLimit$[ebp], 2147483647	; 7fffffffH
$LN138@Load:

; 2975 :    }
; 2976 : 
; 2977 : #if defined( DB2 ) || defined( ODBC )
; 2978 : 
; 2979 :    bCursorOpened = TRUE;

	mov	BYTE PTR _bCursorOpened$[ebp], 1

; 2980 : 
; 2981 :    nRC = SQLFetch( lpConnection->hstmt );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2812]
	push	ecx
	call	_SQLFetch@4
	mov	WORD PTR _nRC$[ebp], ax

; 2982 :    SQL_RC( "SQLFetch", nRC, 0, 0, 2 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	push	0
	push	0
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG95362
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 2983 :    switch ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv921[ebp], ecx
	cmp	DWORD PTR tv921[ebp], 0
	jl	SHORT $LN142@Load
	cmp	DWORD PTR tv921[ebp], 1
	jle	SHORT $LN140@Load
	cmp	DWORD PTR tv921[ebp], 100		; 00000064H
	je	SHORT $LN141@Load
	jmp	SHORT $LN142@Load
$LN140@Load:

; 2984 :    {
; 2985 :       case SQL_SUCCESS:
; 2986 :       case SQL_SUCCESS_WITH_INFO:
; 2987 :          nRC = zFETCH_OK;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 2988 :          break;

	jmp	SHORT $LN35@Load
$LN141@Load:

; 2989 : 
; 2990 :       case SQL_NO_DATA:
; 2991 :          nRC = zFETCH_NO_DATA;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 2992 :          break;

	jmp	SHORT $LN35@Load
$LN142@Load:

; 2993 : 
; 2994 :       default:
; 2995 :          // Oops, error.
; 2996 :          goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN35@Load:

; 2997 :    }
; 2998 : 
; 2999 : #elif defined( DUMMY )
; 3000 : 
; 3001 :    // If the entity supports hanging keys then let's pretend we didn't find
; 3002 :    // any.
; 3003 :    if ( lpViewEntity->bHangingFKey )
; 3004 :       nRC = zFETCH_NO_DATA;
; 3005 :    else
; 3006 :       nRC = zFETCH_OK;
; 3007 : 
; 3008 : #endif
; 3009 : 
; 3010 :    hMem    = 0;

	mov	DWORD PTR _hMem$[ebp], 0

; 3011 :    lMemLth = 0;

	mov	DWORD PTR _lMemLth$[ebp], 0

; 3012 :    lpMem   = 0;

	mov	DWORD PTR _lpMem$[ebp], 0

; 3013 : 
; 3014 :    // If a row was fetched, copy the table data into a newly created entity.
; 3015 :    if ( nRC == zFETCH_OK )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN143@Load

; 3016 :    {
; 3017 :       // The following is a list of booleans, one for each entity in the
; 3018 :       // lpViewOD.  It keeps track of whether the entity was created
; 3019 :       // (added to the OI) since the last fetch.
; 3020 :       zBOOL bEntityCreatedList[ 500 ];
; 3021 : 
; 3022 :       // Reset all the flags to not-created.
; 3023 :       zmemset( bEntityCreatedList, 0, sizeof( bEntityCreatedList ) );

	push	500					; 000001f4H
	push	0
	lea	edx, DWORD PTR _bEntityCreatedList$42[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3024 : 
; 3025 :       nReturnCode = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnCode$[ebp], ax
$LN39@Load:

; 3026 : 
; 3027 :       // For each row, create an entity instance and copy the attribute
; 3028 :       // values from the table to the entity.
; 3029 :       do
; 3030 :       {
; 3031 :          LPVIEWENTITY lpLastCreatedEntity;
; 3032 :          zBOOL        bNewEntity;
; 3033 : #if defined( DUMMY )
; 3034 : 
; 3035 :          LPVIEWENTITY lpCreatedEntity = 0;
; 3036 : 
; 3037 :          // Dummy DBH doesn't load children via a join.
; 3038 :          lRootCnt++;
; 3039 : 
; 3040 : #endif
; 3041 :          lRowCount++;

	mov	ecx, DWORD PTR _lRowCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lRowCount$[ebp], ecx

; 3042 : 
; 3043 :          if ( lpConnection->nTraceLevel >= 1 && (lRowCount % 1000) == 0 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jl	SHORT $LN145@Load
	mov	eax, DWORD PTR _lRowCount$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN145@Load

; 3044 :             TraceLineI( "(xa) Number of rows currently read = ", lRowCount );

	mov	edx, DWORD PTR _lRowCount$[ebp]
	push	edx
	push	OFFSET $SG95369
	call	_TraceLineI@8
$LN145@Load:

; 3045 : 
; 3046 :          // Loop through each of the attributes and get the column values
; 3047 :          // from the currently fetched row.
; 3048 : 
; 3049 :          LoopInfo.bOpenSQL          = bOpenSQL;

	mov	al, BYTE PTR _bOpenSQL$[ebp]
	mov	BYTE PTR _LoopInfo$[ebp], al

; 3050 :          LoopInfo.bKeysOnly         = bKeysOnly;

	mov	cl, BYTE PTR _bKeysOnly$[ebp]
	mov	BYTE PTR _LoopInfo$[ebp+1], cl

; 3051 :          LoopInfo.bFirstPass        = TRUE;

	mov	BYTE PTR _LoopInfo$[ebp+32], 1

; 3052 :          LoopInfo.lpQualEntity      = lpQualEntity;

	mov	edx, DWORD PTR _lpQualEntity$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+4], edx

; 3053 :          LoopInfo.lpFirstQualEntity = lpConnection->lpFirstQualEntity;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+190]
	mov	DWORD PTR _LoopInfo$[ebp+8], ecx

; 3054 :          LoopInfo.lpViewEntity      = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+12], edx

; 3055 :          LoopInfo.lpDataField       = 0;

	mov	DWORD PTR _LoopInfo$[ebp+20], 0

; 3056 :          LoopInfo.lControl          = Indicators;

	mov	eax, DWORD PTR _Indicators$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+24], eax

; 3057 :          LoopInfo.lpBoundList       = lpBoundList;

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	mov	DWORD PTR _LoopInfo$[ebp+28], ecx

; 3058 :          lpLastCreatedEntity        = 0;

	mov	DWORD PTR _lpLastCreatedEntity$15[ebp], 0

; 3059 :          bNewEntity                 = FALSE;

	mov	BYTE PTR _bNewEntity$36[ebp], 0

; 3060 :          nColumnCnt = 0;

	xor	edx, edx
	mov	WORD PTR _nColumnCnt$[ebp], dx

; 3061 :          for ( lpDataField = fnGetNextDataField( &LoopInfo );

	lea	eax, DWORD PTR _LoopInfo$[ebp]
	push	eax
	call	_fnGetNextDataField@4
	mov	DWORD PTR _lpDataField$[ebp], eax
	jmp	SHORT $LN42@Load
$LN40@Load:

; 3063 :                lpDataField = fnGetNextDataField( &LoopInfo ) )

	lea	ecx, DWORD PTR _LoopInfo$[ebp]
	push	ecx
	call	_fnGetNextDataField@4
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN42@Load:

; 3062 :                lpDataField;

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN41@Load

; 3064 :          {
; 3065 :             LPVIEWENTITY lpLoadEntity;
; 3066 : 
; 3067 : #if defined( DB2 )
; 3068 : 
; 3069 :             zPCHAR       lpPtr;
; 3070 :             SQLINTEGER   nLth;
; 3071 :             SQLINTEGER   nInd;
; 3072 : 
; 3073 : #elif defined( ODBC )
; 3074 : 
; 3075 :             zCHAR        sz[ 50 ];
; 3076 :             zPCHAR       lpPtr;
; 3077 :             SQLINTEGER   nLth;
; 3078 : 
; 3079 : #endif
; 3080 : 
; 3081 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 3082 :             lpLoadEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpLoadEntity$37[ebp], eax

; 3083 : 
; 3084 :             if ( lpLoadEntity != lpLastCreatedEntity )

	mov	eax, DWORD PTR _lpLoadEntity$37[ebp]
	cmp	eax, DWORD PTR _lpLastCreatedEntity$15[ebp]
	je	SHORT $LN146@Load

; 3085 :                bNewEntity = TRUE;

	mov	BYTE PTR _bNewEntity$36[ebp], 1
	jmp	SHORT $LN147@Load
$LN146@Load:

; 3086 :             else
; 3087 :                bNewEntity = FALSE;

	mov	BYTE PTR _bNewEntity$36[ebp], 0
$LN147@Load:

; 3088 : 
; 3089 :             nColumnCnt++;

	mov	cx, WORD PTR _nColumnCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nColumnCnt$[ebp], cx

; 3090 : 
; 3091 :             // When dealing with joins, we need to make sure we don't create
; 3092 :             // duplicate entities.  The only way to do this is to compare the
; 3093 :             // key for the current row and see if it already exists in the
; 3094 :             // entity list.  So first we need to store the keys for the current
; 3095 :             // row.  If we find an attribute that is NOT a key, then we've
; 3096 :             // retrieved and stored the keys for the current entity in the
; 3097 :             // current row.  Call fnSetEntityByKeys to see if the entity
; 3098 :             // already exists.
; 3099 :             // The second part of the 'if' is to handle the situation where
; 3100 :             // an entity has only keys.  If nEntityKeyCnt is > 0, then we
; 3101 :             // know we've stored some key values.  If the 'lpLoadEntity' for
; 3102 :             // the key is different from the current lpLoadEntity, then we're
; 3103 :             // onto a new entity and we must create the previous entity.
; 3104 :             if ( lpViewAttrib->bKey == FALSE ||

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN149@Load
	movsx	ecx, WORD PTR _nEntityKeyCnt$[ebp]
	test	ecx, ecx
	jle	$LN148@Load
	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpKeyData$[ebp+eax]
	cmp	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	je	$LN148@Load
$LN149@Load:

; 3105 :                  (nEntityKeyCnt > 0 &&
; 3106 :                   lpKeyData[ 0 ].lpLoadEntity != lpLoadEntity) )
; 3107 :             {
; 3108 :                // If nEntityKeyCnt is > 0, then the current lpDataField is
; 3109 :                // not a key and the previous lpDataField was a key.  Use the
; 3110 :                // keys stored in lpKeyData to see if we need to create an
; 3111 :                // entity.
; 3112 :                if ( nEntityKeyCnt > 0 )

	movsx	edx, WORD PTR _nEntityKeyCnt$[ebp]
	test	edx, edx
	jle	$LN150@Load

; 3113 :                {
; 3114 :                   nRC = fnSetEntityByKeys( lpView, lpKeyData, nEntityKeyCnt,

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lRootCnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lRootLimit$[ebp]
	push	edx
	lea	eax, DWORD PTR _bEntityCreatedList$42[ebp]
	push	eax
	movzx	ecx, WORD PTR _nEntityKeyCnt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpKeyData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetEntityByKeys@28
	mov	WORD PTR _nRC$[ebp], ax

; 3115 :                                            bEntityCreatedList, lRootLimit,
; 3116 :                                            lRootCnt, lpBoundList );
; 3117 :                   if ( nRC == -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN152@Load

; 3118 :                   {
; 3119 :                      // We found a new root entity but we have reached our
; 3120 :                      // root limit.  Set flag and break to fetch the next row.
; 3121 :                      nEntityKeyCnt = 0;

	xor	edx, edx
	mov	WORD PTR _nEntityKeyCnt$[ebp], dx

; 3122 :                      bRootLimitReached = TRUE;

	mov	BYTE PTR _bRootLimitReached$[ebp], 1

; 3123 :                      break;

	jmp	$LN41@Load

; 3124 :                   }

	jmp	SHORT $LN153@Load
$LN152@Load:

; 3125 :                   else
; 3126 :                   if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $LN154@Load

; 3127 :                   {
; 3128 :                      // Keep track of the number of root entities created.
; 3129 :                      if ( lpLoadEntity == lpViewEntity )

	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN156@Load

; 3130 :                         lRootCnt++;

	mov	edx, DWORD PTR _lRootCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lRootCnt$[ebp], edx
$LN156@Load:

; 3131 :                   }

	jmp	SHORT $LN153@Load
$LN154@Load:

; 3132 :                   else
; 3133 :                   {
; 3134 :                      if ( lpConnection->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	cmp	ecx, 1
	jle	SHORT $LN153@Load

; 3135 :                      {
; 3136 :                         TraceLineS( "Duplicate row found, entity = ",

	mov	edx, DWORD PTR _lpLoadEntity$37[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG95382
	call	_TraceLineS@8
$LN153@Load:

; 3137 :                                     lpLoadEntity->szName );
; 3138 :                      }
; 3139 :                   }
; 3140 : 
; 3141 :                   // We just created an entity (or at least positioned on the
; 3142 :                   // right one) so set lpLastCreatedEntity.
; 3143 :                   lpLastCreatedEntity = lpLoadEntity;

	mov	eax, DWORD PTR _lpLoadEntity$37[ebp]
	mov	DWORD PTR _lpLastCreatedEntity$15[ebp], eax

; 3144 : 
; 3145 :                   // Reset nEntityKeyCnt so we don't try this on the following
; 3146 :                   // non-key attributes.
; 3147 :                   nEntityKeyCnt = 0;

	xor	ecx, ecx
	mov	WORD PTR _nEntityKeyCnt$[ebp], cx

; 3148 : 
; 3149 :                } // if ( nEntityKeyCnt > 0 )...

	jmp	SHORT $LN151@Load
$LN150@Load:

; 3150 :                else
; 3151 :                if ( lpLoadEntity->bHasDB_Oper )

	mov	edx, DWORD PTR _lpLoadEntity$37[ebp]
	mov	eax, DWORD PTR [edx+239]
	and	eax, 1
	je	SHORT $LN151@Load

; 3152 :                {
; 3153 :                   if ( bNewEntity )

	movzx	ecx, BYTE PTR _bNewEntity$36[ebp]
	test	ecx, ecx
	je	SHORT $LN151@Load

; 3154 :                   {
; 3155 :                      LoadEntity( lpView, lpLoadEntity->szName, zPOS_LAST, 0 );

	push	0
	push	2
	mov	edx, DWORD PTR _lpLoadEntity$37[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_LoadEntity@16

; 3156 :                      lpLastCreatedEntity = lpLoadEntity;

	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	mov	DWORD PTR _lpLastCreatedEntity$15[ebp], ecx

; 3157 :                      bEntityCreatedList[ lpLoadEntity->nHierNbr ] = TRUE;

	mov	edx, DWORD PTR _lpLoadEntity$37[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	BYTE PTR _bEntityCreatedList$42[ebp+eax], 1
$LN151@Load:

; 3158 :                   }
; 3159 :                }
; 3160 : 
; 3161 :                // If the DataField is not a key and the entity was not created
; 3162 :                // during the current FETCH, it was loaded on a previous fetch
; 3163 :                // and we don't need to copy the attributes.
; 3164 :                if ( lpViewAttrib->bKey == FALSE &&

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN148@Load
	mov	eax, DWORD PTR _lpLoadEntity$37[ebp]
	movsx	ecx, WORD PTR [eax+217]
	movzx	edx, BYTE PTR _bEntityCreatedList$42[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN148@Load

; 3165 :                     bEntityCreatedList[ lpLoadEntity->nHierNbr ] == FALSE )
; 3166 :                {
; 3167 :                   continue; // Continue on with the next lpDataField.

	jmp	$LN40@Load
$LN148@Load:

; 3168 :                }
; 3169 : 
; 3170 :             } // if ( !lpViewAttrib->bKey || ...
; 3171 : 
; 3172 :             // ================================================================
; 3173 :             // Retrieve column value and store it as an attribute in the entity.
; 3174 :             // ================================================================
; 3175 : 
; 3176 : #if defined( DB2 ) || defined( ODBC )
; 3177 : 
; 3178 :             lpPtr = ppchBufferPtr[ nColumnCnt ];

	movsx	eax, WORD PTR _nColumnCnt$[ebp]
	mov	ecx, DWORD PTR _ppchBufferPtr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _lpPtr$31[ebp], edx

; 3179 :             nLth = *((SQLINTEGER *) lpPtr);

	mov	eax, DWORD PTR _lpPtr$31[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _nLth$34[ebp], ecx

; 3180 :             lpPtr += sizeof( SQLINTEGER );

	mov	edx, DWORD PTR _lpPtr$31[ebp]
	add	edx, 4
	mov	DWORD PTR _lpPtr$31[ebp], edx

; 3181 : 
; 3182 :             // If attribute is a blob or long string, then the value must be
; 3183 :             // retrieved from a long varchar.
; 3184 :             if ( lpDataField->cFldType == zTYPE_BLOB ||

	mov	eax, DWORD PTR _lpDataField$[ebp]
	movsx	ecx, BYTE PTR [eax+270]
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN163@Load
	mov	edx, DWORD PTR _lpDataField$[ebp]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 86					; 00000056H
	jne	$LN161@Load
$LN163@Load:

; 3185 :                  lpDataField->cFldType == 'V' )
; 3186 :             {
; 3187 : #ifdef DB2
; 3188 :                SQLINTEGER  cLocator = *((SQLINTEGER *) lpPtr);
; 3189 :                SQLSMALLINT iSqlType;
; 3190 :                SQLSMALLINT iCType;
; 3191 : 
; 3192 :                if ( lpDataField->cFldType == zTYPE_BLOB )
; 3193 :                {
; 3194 :                   iSqlType = SQL_C_BLOB_LOCATOR;
; 3195 :                   iCType   = SQL_C_BINARY;
; 3196 :                }
; 3197 :                else
; 3198 :                {
; 3199 :                   iSqlType = SQL_C_CLOB_LOCATOR;
; 3200 :                   iCType   = SQL_C_CHAR;
; 3201 :                }
; 3202 : 
; 3203 :                if ( hBlobStmt == 0 )
; 3204 :                {
; 3205 :                   nRC = SQLAllocStmt( lpConnection->hdbc, &hBlobStmt );
; 3206 :                   SQL_RC( "SQLAllocStmt", nRC, "Allocate Temp HSTMT", 0, 2 );
; 3207 :                   if ( nRC != SQL_SUCCESS )
; 3208 :                      goto EndOfFunction;
; 3209 : 
; 3210 :                   nRC = SQLAllocStmt( lpConnection->hdbc, &hLocatorStmt );
; 3211 :                   SQL_RC( "SQLAllocStmt", nRC, "Allocate Temp HSTMT", 0, 2 );
; 3212 :                   if ( nRC != SQL_SUCCESS )
; 3213 :                      goto EndOfFunction;
; 3214 :                }
; 3215 : 
; 3216 :                // NOTE: There doesn't seem to be a way to find out if the
; 3217 :                // BLOB/CLOB is null (checking for SQL_NULL doesn't work)
; 3218 :                // so SQLGetLength( ) will return an error if the attribute
; 3219 :                // is null.
; 3220 :                nRC = SQLGetLength( hBlobStmt, iSqlType, cLocator, &nLth, &nInd );
; 3221 :                SQL_RC( "SQLGetLength", nRC, "Getting length of column ",
; 3222 :                        lpDataField->szFldName, 2 );
; 3223 : 
; 3224 :                // If the length is 0, then there is nothing to be read.
; 3225 :                if ( nLth > 0 )
; 3226 :                {
; 3227 :                   // If memory needs to be allocated, then allocate it.
; 3228 :                   if ( hMem == 0 || lMemLth <= nLth )
; 3229 :                   {
; 3230 :                      if ( hMem != 0 )
; 3231 :                         SysFreeMemory( hMem );
; 3232 : 
; 3233 :                      // Make sure that the length of the buffer is a least
; 3234 :                      // 1000 and always at least 1 greater then the length of
; 3235 :                      // the column value.
; 3236 :                      lMemLth = ( nLth < 1000 ) ? 1001 : nLth + 1;
; 3237 :                      hMem = SysAllocMemory( (zPVOID) &lpMem, lMemLth, 0,
; 3238 :                                             zCOREMEM_ALLOC, 0 );
; 3239 :                      if ( lpMem == 0 )
; 3240 :                         goto EndOfFunction;
; 3241 :                   }
; 3242 : 
; 3243 :                   nRC = SQLGetSubString( hBlobStmt, iSqlType, cLocator, 1, nLth,
; 3244 :                                          iCType, (SQLPOINTER) lpMem,
; 3245 :                                          lMemLth,  &nInd, &nInd );
; 3246 :                   SQL_RC( "SQLGetSubString", nRC, 0, 0, 3 );
; 3247 :                   if ( nRC != SQL_SUCCESS )
; 3248 :                      goto EndOfFunction;
; 3249 : 
; 3250 :                   StoreValueInRecord( lpView, lpLoadEntity, lpViewAttrib,
; 3251 :                                       lpMem, (zULONG) nLth );
; 3252 : 
; 3253 :                   // Now set the attribute flags.
; 3254 :                   GetAttributeFlags( &lpAttribFlags, lpView,
; 3255 :                                      lpLoadEntity, lpViewAttrib );
; 3256 :                   lpAttribFlags->u.bFlags.bActivated = TRUE;
; 3257 :                   lpAttribFlags->u.bFlags.bUpdated  = FALSE;
; 3258 : 
; 3259 :                   nRC = SQLFreeStmt( hBlobStmt, SQL_CLOSE );
; 3260 :                   SQL_RC( "SQLFreeStmt", nRC, "Freeing temp handle?", 0, 3 );
; 3261 : 
; 3262 : 
; 3263 :                   nRC = SQLSetParam( hLocatorStmt, 1, SQL_C_CLOB_LOCATOR,
; 3264 :                                      SQL_CLOB_LOCATOR, 0, 0, &cLocator, 0 );
; 3265 :                   SQL_RC( "SQLSetParam", nRC, "About to free locator.", 0, 3 );
; 3266 : 
; 3267 :                   nRC = SQLExecDirect( hLocatorStmt, "FREE LOCATOR ?", SQL_NTS );
; 3268 :                   SQL_RC( "SQLExecDirect", nRC, "Freeing locator.", 0, 3 );
; 3269 : 
; 3270 :                } // if ( nLth > 0 )...
; 3271 :                else
; 3272 :                   nRC = 0;
; 3273 : 
; 3274 : #else   // i.e. #ifdef ODBC
; 3275 : 
; 3276 :                // Get the length of the column.
; 3277 :                nRC = SQLGetData( lpConnection->hstmt, nColumnCnt,

	lea	ecx, DWORD PTR _nLth$34[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _sz$43[ebp]
	push	edx
	push	99					; 00000063H
	movzx	eax, WORD PTR _nColumnCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLGetData@24
	mov	WORD PTR _nRC$[ebp], ax

; 3278 :                                  SQL_C_DEFAULT, (SQLPOINTER) sz, 0, &nLth );
; 3279 :                SQL_RC( "SQLGetData", nRC, "Getting length for ",

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG95389
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95390
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 3280 :                        lpDataField->szFldName, 2 );
; 3281 : 
; 3282 :                if ( lpConnection->nTraceLevel >= 2 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	cmp	ecx, 2
	jl	SHORT $LN164@Load

; 3283 :                {
; 3284 :                   TraceLineI( "Column number = ", nColumnCnt );

	movsx	edx, WORD PTR _nColumnCnt$[ebp]
	push	edx
	push	OFFSET $SG95392
	call	_TraceLineI@8

; 3285 :                   TraceLineI( "Returned lth for column = ", nLth );

	mov	eax, DWORD PTR _nLth$34[ebp]
	push	eax
	push	OFFSET $SG95393
	call	_TraceLineI@8
$LN164@Load:

; 3286 :                }
; 3287 : 
; 3288 :                if ( !RC_SUCCESSFUL( nRC ) )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN165@Load
	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 1
	je	SHORT $LN165@Load

; 3289 :                   goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN165@Load:

; 3290 : 
; 3291 :                if ( nLth > 0 )

	cmp	DWORD PTR _nLth$34[ebp], 0
	jle	$LN166@Load

; 3292 :                {
; 3293 :                   // If memory needs to be allocated, then allocate it.
; 3294 :                   if ( hMem == 0 || lMemLth <= nLth )

	cmp	DWORD PTR _hMem$[ebp], 0
	je	SHORT $LN168@Load
	mov	eax, DWORD PTR _lMemLth$[ebp]
	cmp	eax, DWORD PTR _nLth$34[ebp]
	jg	SHORT $LN167@Load
$LN168@Load:

; 3295 :                   {
; 3296 :                      if ( hMem != 0 )

	cmp	DWORD PTR _hMem$[ebp], 0
	je	SHORT $LN169@Load

; 3297 :                         SysFreeMemory( hMem );

	mov	ecx, DWORD PTR _hMem$[ebp]
	push	ecx
	call	_SysFreeMemory@4
$LN169@Load:

; 3298 : 
; 3299 :                      // Make sure that the length of the buffer is a least
; 3300 :                      // 1000 and always at least 1 greater then the length of
; 3301 :                      // the column value.
; 3302 :                      lMemLth = ( nLth < 1000 ) ? 1001 : nLth + 1;

	cmp	DWORD PTR _nLth$34[ebp], 1000		; 000003e8H
	jge	SHORT $LN203@Load
	mov	DWORD PTR tv1084[ebp], 1001		; 000003e9H
	jmp	SHORT $LN204@Load
$LN203@Load:
	mov	edx, DWORD PTR _nLth$34[ebp]
	add	edx, 1
	mov	DWORD PTR tv1084[ebp], edx
$LN204@Load:
	mov	eax, DWORD PTR tv1084[ebp]
	mov	DWORD PTR _lMemLth$[ebp], eax

; 3303 :                      hMem = SysAllocMemory( (zPVOID) &lpMem, lMemLth, 0,

	push	0
	push	32768					; 00008000H
	push	0
	mov	ecx, DWORD PTR _lMemLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpMem$[ebp]
	push	edx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 3304 :                                             zCOREMEM_ALLOC, 0 );
; 3305 :                      if ( lpMem == 0 )

	cmp	DWORD PTR _lpMem$[ebp], 0
	jne	SHORT $LN167@Load

; 3306 :                         goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN167@Load:

; 3307 :                   }
; 3308 : 
; 3309 :                   // Now retrieve the data.
; 3310 :                   nRC = SQLGetData( lpConnection->hstmt, nColumnCnt,

	lea	eax, DWORD PTR _nLth$34[ebp]
	push	eax
	mov	ecx, DWORD PTR _lMemLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMem$[ebp]
	push	edx
	push	99					; 00000063H
	movzx	eax, WORD PTR _nColumnCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLGetData@24
	mov	WORD PTR _nRC$[ebp], ax

; 3311 :                                     SQL_C_DEFAULT, (SQLPOINTER) lpMem,
; 3312 :                                     lMemLth, &nLth );
; 3313 :                   SQL_RC( "SQLGetData", nRC, "Getting data ", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG95400
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95401
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 3314 : 
; 3315 :                   if ( lpConnection->nTraceLevel >= 2 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 2
	jl	SHORT $LN171@Load

; 3316 :                      TraceLineI( "Returned lth for column = ", nLth );

	mov	ecx, DWORD PTR _nLth$34[ebp]
	push	ecx
	push	OFFSET $SG95403
	call	_TraceLineI@8
$LN171@Load:

; 3317 : 
; 3318 :                   if ( !RC_SUCCESSFUL( nRC ) )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN172@Load
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN172@Load

; 3319 :                      goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN172@Load:

; 3320 : 
; 3321 :                   StoreValueInRecord( lpView, lpLoadEntity, lpViewAttrib,

	mov	ecx, DWORD PTR _nLth$34[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMem$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreValueInRecord@20

; 3322 :                                       lpMem, (zULONG) nLth );
; 3323 : 
; 3324 :                   // Now set the attribute flags.
; 3325 :                   GetAttributeFlags( &lpAttribFlags, lpView,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpAttribFlags$[ebp]
	push	eax
	call	_GetAttributeFlags@16

; 3326 :                                      lpLoadEntity, lpViewAttrib );
; 3327 :                   lpAttribFlags->u.bFlags.bActivated = TRUE;

	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR _lpAttribFlags$[ebp]
	mov	DWORD PTR [eax], edx

; 3328 :                   lpAttribFlags->u.bFlags.bUpdated  = FALSE;

	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpAttribFlags$[ebp]
	mov	DWORD PTR [eax], edx
$LN166@Load:

; 3329 :                }
; 3330 : #endif
; 3331 : 
; 3332 :             } // if ( lpDataField->cFldType == zTYPE_BLOB || ... )...

	jmp	$LN162@Load
$LN161@Load:

; 3333 :             else
; 3334 :             {
; 3335 :                zCHAR szDatetime[ 100 ];
; 3336 : 
; 3337 :                // Check to see if the column is null.  If it is skip it.
; 3338 :                if ( nLth == SQL_NULL_DATA )

	cmp	DWORD PTR _nLth$34[ebp], -1
	jne	SHORT $LN173@Load

; 3339 :                {
; 3340 :                   // Check to see if this attribute is a DB_Oper.  If it is,
; 3341 :                   // then the table must not exist because the oper would have
; 3342 :                   // a value.  If this is the first attribute we have found for
; 3343 :                   // this entity, we must drop the just-created entity.
; 3344 :                   if ( lpViewAttrib->cDB_Oper != 0 && bNewEntity )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+254]
	test	edx, edx
	je	SHORT $LN174@Load
	movzx	eax, BYTE PTR _bNewEntity$36[ebp]
	test	eax, eax
	je	SHORT $LN174@Load

; 3345 :                      DropEntity( lpView, lpLoadEntity->szName, zREPOS_LAST );

	push	2
	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DropEntity@12
$LN174@Load:

; 3346 : 
; 3347 :                   continue;

	jmp	$LN40@Load
$LN173@Load:

; 3348 :                }
; 3349 : 
; 3350 :                // If the attribute is a DateTime field, then the string must be
; 3351 :                // "unformatted".
; 3352 :                if ( lpDataField->cFldType == zTYPE_DATETIME ||
; 3353 :                     lpDataField->cFldType == zTYPE_DATE     ||

	mov	eax, DWORD PTR _lpDataField$[ebp]
	movsx	ecx, BYTE PTR [eax+270]
	cmp	ecx, 84					; 00000054H
	je	SHORT $LN176@Load
	mov	edx, DWORD PTR _lpDataField$[ebp]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 68					; 00000044H
	je	SHORT $LN176@Load
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	movsx	edx, BYTE PTR [ecx+270]
	cmp	edx, 73					; 00000049H
	jne	$LN175@Load
$LN176@Load:

; 3354 :                     lpDataField->cFldType == zTYPE_TIME )
; 3355 :                {
; 3356 :                   szDatetime[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T8[ebp], ecx
	cmp	DWORD PTR $T8[ebp], 100			; 00000064H
	jae	SHORT $LN205@Load
	jmp	SHORT $LN206@Load
$LN205@Load:
	call	___report_rangecheckfailure
$LN206@Load:
	mov	edx, DWORD PTR $T8[ebp]
	mov	BYTE PTR _szDatetime$44[ebp+edx], 0

; 3357 : #ifdef DB2
; 3358 :                   if ( lpDataField->cFldType == zTYPE_TIME )
; 3359 :                      // lpPtr points to "HH:MM:SS".  Prefix dummy date.
; 3360 :                      zstrcpy( szDatetime, "1900-01-01 " );
; 3361 : #endif
; 3362 : 
; 3363 :                   zstrcat( szDatetime, lpPtr );

	mov	eax, DWORD PTR _lpPtr$31[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDatetime$44[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3364 : 
; 3365 : #ifdef DB2
; 3366 :                   if ( lpDataField->cFldType == zTYPE_DATE )
; 3367 :                      // lpPtr points to "YYYY-MM-DD".  Postfix dummy time
; 3368 :                      zstrcat( szDatetime, " 00:00:00" );
; 3369 : #endif
; 3370 : 
; 3371 :                   // Convert datetime to YYYYMMDDHHmmSS.
; 3372 :                   if ( UfEditFormatDateTime( szDatetime,
; 3373 :                                              "YYYY-MM-DD HH:MI:SS" ) == 0 )

	push	OFFSET $SG95411
	lea	edx, DWORD PTR _szDatetime$44[ebp]
	push	edx
	call	_UfEditFormatDateTime@8
	cwde
	test	eax, eax
	jne	SHORT $LN177@Load

; 3374 :                      ; // Do nothing...szDatetime converted OK.

	jmp	SHORT $LN178@Load
$LN177@Load:

; 3375 :                   else
; 3376 :                   if ( UfEditFormatDateTime( szDatetime,
; 3377 :                                              "M/D/YYYY H:MI:SS AM" ) == 0 )

	push	OFFSET $SG95413
	lea	ecx, DWORD PTR _szDatetime$44[ebp]
	push	ecx
	call	_UfEditFormatDateTime@8
$LN178@Load:

; 3378 :                      ; // Do nothing...szDatetime converted OK.
; 3379 : 
; 3380 :                   // For date and time formats we need to change unused part
; 3381 :                   // to 0's.
; 3382 :                   switch ( lpDataField->cFldType )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	cl, BYTE PTR [eax+270]
	mov	BYTE PTR tv1166[ebp], cl
	cmp	BYTE PTR tv1166[ebp], 68		; 00000044H
	je	SHORT $LN180@Load
	cmp	BYTE PTR tv1166[ebp], 73		; 00000049H
	je	SHORT $LN181@Load
	jmp	SHORT $LN43@Load
$LN180@Load:

; 3383 :                   {
; 3384 :                      case zTYPE_DATE:
; 3385 :                         zstrcpy( &szDatetime[ 8 ], "000000000" );

	push	OFFSET $SG95415
	mov	edx, 1
	shl	edx, 3
	lea	eax, DWORD PTR _szDatetime$44[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8

; 3386 :                         break;

	jmp	SHORT $LN43@Load
$LN181@Load:

; 3387 : 
; 3388 :                      case zTYPE_TIME:
; 3389 :                         zmemcpy( szDatetime, "19000101", 8 );

	push	8
	push	OFFSET $SG95417
	lea	ecx, DWORD PTR _szDatetime$44[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN43@Load:

; 3390 :                         break;
; 3391 :                   }
; 3392 : 
; 3393 :                   // Copy szDatetime back into the buffer.
; 3394 :                   zstrcpy( (zPCHAR) lpPtr, szDatetime );

	lea	edx, DWORD PTR _szDatetime$44[ebp]
	push	edx
	mov	eax, DWORD PTR _lpPtr$31[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN175@Load:

; 3395 :                }
; 3396 : #ifdef DB2
; 3397 :                else
; 3398 :                if ( lpDataField->cFldType == zTYPE_DECIMAL )
; 3399 :                {
; 3400 :                   if ( g_ucDB2_Comma == 2)
; 3401 :                   {
; 3402 :                      /* If the Database uses decimal comma
; 3403 :                       *  instead of point ..., but the functions
; 3404 :                       * in decari use only '.', therefore we have
; 3405 :                       * to change the ',' into '.'
; 3406 :                       */
; 3407 :                      zPCHAR pch = strchr( lpPtr, ',') ;
; 3408 : 
; 3409 :                      if ( pch )
; 3410 :                         *pch = '.';
; 3411 :                   }
; 3412 :                }
; 3413 : #endif
; 3414 : 
; 3415 :                if ( lpViewAttrib->bKey )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN182@Load

; 3416 :                {
; 3417 :                   // Store the key value for now.  When we reach the end
; 3418 :                   // of the keys we will use them to determine if the entity
; 3419 :                   // has been created yet.
; 3420 :                   lpKeyData[ nEntityKeyCnt ].lpDataField  = lpDataField;

	movsx	eax, WORD PTR _nEntityKeyCnt$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR _lpKeyData$[ebp+eax+8], ecx

; 3421 :                   lpKeyData[ nEntityKeyCnt ].lpPtr        = lpPtr;

	movsx	edx, WORD PTR _nEntityKeyCnt$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _lpPtr$31[ebp]
	mov	DWORD PTR _lpKeyData$[ebp+edx+12], eax

; 3422 :                   lpKeyData[ nEntityKeyCnt ].lpViewAttrib = lpViewAttrib;

	movsx	ecx, WORD PTR _nEntityKeyCnt$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyData$[ebp+ecx+4], edx

; 3423 :                   lpKeyData[ nEntityKeyCnt ].lpLoadEntity = lpLoadEntity;

	movsx	eax, WORD PTR _nEntityKeyCnt$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	mov	DWORD PTR _lpKeyData$[ebp+eax], ecx

; 3424 :                   nEntityKeyCnt++;

	mov	dx, WORD PTR _nEntityKeyCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nEntityKeyCnt$[ebp], dx

; 3425 : 
; 3426 :                   // Try next lpDataField.
; 3427 :                   continue;

	jmp	$LN40@Load
$LN182@Load:

; 3428 : 
; 3429 :                } // if ( lpViewAttrib->bKey )...
; 3430 : 
; 3431 :                // At this point lpPtr points to the datbase value. Copy the value
; 3432 :                // into the attribute.
; 3433 :                switch ( lpDataField->cFldType )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	movsx	ecx, BYTE PTR [eax+270]
	mov	DWORD PTR tv1203[ebp], ecx
	mov	edx, DWORD PTR tv1203[ebp]
	sub	edx, 68					; 00000044H
	mov	DWORD PTR tv1203[ebp], edx
	cmp	DWORD PTR tv1203[ebp], 16		; 00000010H
	ja	$LN185@Load
	mov	eax, DWORD PTR tv1203[ebp]
	movzx	ecx, BYTE PTR $LN209@Load[eax]
	jmp	DWORD PTR $LN212@Load[ecx*4]
$LN183@Load:

; 3434 :                {
; 3435 :                   case zTYPE_DATETIME:
; 3436 :                   case zTYPE_DATE:
; 3437 :                   case zTYPE_TIME:
; 3438 :                      StoreStringInRecord( lpView, lpLoadEntity, lpViewAttrib, lpPtr );

	mov	edx, DWORD PTR _lpPtr$31[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreStringInRecord@16

; 3439 :                      break;

	jmp	SHORT $LN45@Load
$LN184@Load:

; 3440 : 
; 3441 :                   case zTYPE_DECIMAL:
; 3442 :                      StoreStringInRecord( lpView, lpLoadEntity, lpViewAttrib, lpPtr );

	mov	eax, DWORD PTR _lpPtr$31[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLoadEntity$37[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_StoreStringInRecord@16

; 3443 : 
; 3444 :                      // Retrieve decimal value and copy it back into the attribute.
; 3445 :                      // This will cause the Format routines to be called so that
; 3446 :                      // the decimal gets rounded/truncated correctly.
; 3447 :                      // Use szDatetime as a dummy buffer.
; 3448 :                      GetStringFromRecord( lpView, lpLoadEntity, lpViewAttrib,

	push	100					; 00000064H
	lea	ecx, DWORD PTR _szDatetime$44[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLoadEntity$37[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetStringFromRecord@20

; 3449 :                                           szDatetime, sizeof( szDatetime ) );
; 3450 :                      StoreStringInRecord( lpView, lpLoadEntity, lpViewAttrib,

	lea	edx, DWORD PTR _szDatetime$44[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$37[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreStringInRecord@16

; 3451 :                                           szDatetime );
; 3452 :                      break;

	jmp	SHORT $LN45@Load
$LN185@Load:

; 3453 : 
; 3454 :                   default:
; 3455 :                      // Note that length is only used for blob attributes, so we
; 3456 :                      // will always pass 0.
; 3457 :                      StoreValueInRecord( lpView, lpLoadEntity, lpViewAttrib,

	push	0
	mov	eax, DWORD PTR _lpPtr$31[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLoadEntity$37[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_StoreValueInRecord@20
$LN45@Load:

; 3458 :                                          lpPtr, 0 );
; 3459 :                      break;
; 3460 :                }
; 3461 : 
; 3462 :                // Now set the attribute flags.
; 3463 :                GetAttributeFlags( &lpAttribFlags, lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLoadEntity$37[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpAttribFlags$[ebp]
	push	ecx
	call	_GetAttributeFlags@16

; 3464 :                                   lpLoadEntity, lpViewAttrib );
; 3465 :                lpAttribFlags->u.bFlags.bActivated = TRUE;

	mov	edx, DWORD PTR _lpAttribFlags$[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 1
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	DWORD PTR [ecx], eax

; 3466 :                lpAttribFlags->u.bFlags.bUpdated  = FALSE;

	mov	edx, DWORD PTR _lpAttribFlags$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	DWORD PTR [ecx], eax
$LN162@Load:

; 3467 : 
; 3468 :             } // if ( lpDataField->cFldType == zTYPE_BLOB || ... )...else...
; 3469 : 
; 3470 : #elif defined( DUMMY )
; 3471 : 
; 3472 : #ifdef USE_JOINS
; 3473 :             // Check to see if the entity corresponding to the lpDataField
; 3474 :             // is the same as the entity we are activating.  If it is NOT, then
; 3475 :             // we must be loading attributes from a child entity that has
; 3476 :             // been selected as part of a join.  This happens for children
; 3477 :             // that have a x-to-1 relationship.  In any case, we need to
; 3478 :             // create a new entity.
; 3479 :             if ( lpCreatedEntity ==  0  ||
; 3480 :                  (lpLoadEntity != lpCreatedEntity &&
; 3481 :                   lpLoadEntity->nHierNbr > lpCreatedEntity->nHierNbr) )
; 3482 :             {
; 3483 :                LoadEntity( lpView, lpLoadEntity->szName, zPOS_AFTER, 0 );
; 3484 :                lpCreatedEntity = lpLoadEntity;
; 3485 :             }
; 3486 : #endif
; 3487 : 
; 3488 :             // We'll just create dummy values.
; 3489 :             switch ( lpViewAttrib->cType )
; 3490 :             {
; 3491 :                case zTYPE_INTEGER:
; 3492 :                {
; 3493 :                   zLONG lTemp = lpConnection->lIntegerCount++;
; 3494 : 
; 3495 :                   StoreValueInRecord( lpView, lpLoadEntity, lpViewAttrib,
; 3496 :                                       &lTemp, 0 );
; 3497 :                   break;
; 3498 :                }
; 3499 : 
; 3500 :                case zTYPE_STRING:
; 3501 :                {
; 3502 :                   zCHAR szTemp[ 30 ];
; 3503 : 
; 3504 :                   zsprintf( szTemp, "TempString%ld",
; 3505 :                             lpConnection->lStringCount++ );
; 3506 :                   StoreValueInRecord( lpView, lpLoadEntity, lpViewAttrib,
; 3507 :                                       (zPVOID) szTemp, 0 );
; 3508 :                   break;
; 3509 :                }
; 3510 : 
; 3511 :                case zTYPE_DECIMAL:
; 3512 :                {
; 3513 :                   zDECIMAL dTemp;
; 3514 : 
; 3515 :                   SysConvertDoubleToDecimal(
; 3516 :                            (double) (lpConnection->lDecimalCount++ * 1.1),
; 3517 :                            &dTemp );
; 3518 :                   StoreValueInRecord( lpView, lpLoadEntity, lpViewAttrib,
; 3519 :                                       (zPVOID) &dTemp, 0 );
; 3520 :                   break;
; 3521 :                }
; 3522 : 
; 3523 :                case zTYPE_DATETIME:
; 3524 :                {
; 3525 :                   zCHAR szDateTime[ 20 ];
; 3526 : 
; 3527 :                   SysGetDateTime( szDateTime );
; 3528 :                   StoreStringInRecord( lpView, lpLoadEntity, lpViewAttrib,
; 3529 :                                        szDateTime );
; 3530 :                   break;
; 3531 :                }
; 3532 : 
; 3533 :                // Now set the attribute flags.
; 3534 :                GetAttributeFlags( &lpAttribFlags, lpView,
; 3535 :                                   lpLoadEntity, lpViewAttrib );
; 3536 :                lpAttribFlags->u.bFlags.bActivated = TRUE;
; 3537 :                lpAttribFlags->u.bFlags.bUpdated  = FALSE;
; 3538 :             }
; 3539 : #endif
; 3540 : 
; 3541 :          } // for ( lpDataField... )

	jmp	$LN40@Load
$LN41@Load:

; 3542 : 
; 3543 :          // ================================================================
; 3544 :          // Fetch the next row.
; 3545 :          // ================================================================
; 3546 : 
; 3547 :          // Since we're about to fetch a new row, reset all the flags to
; 3548 :          // not-created.
; 3549 :          zmemset( bEntityCreatedList, 0, sizeof( bEntityCreatedList ) );

	push	500					; 000001f4H
	push	0
	lea	edx, DWORD PTR _bEntityCreatedList$42[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3550 : 
; 3551 : #if defined( DB2 ) || defined( ODBC )
; 3552 : 
; 3553 :          // We're about to fetch a new row, but we need to check if all the
; 3554 :          // entities were created from the previous fetch.  If nEntityKeyCnt
; 3555 :          // is not 0, then the last entity that is part of the fetch is made
; 3556 :          // up of only keys.  It may need to be created.
; 3557 :          if ( nEntityKeyCnt > 0 )

	movsx	eax, WORD PTR _nEntityKeyCnt$[ebp]
	test	eax, eax
	jle	SHORT $LN186@Load

; 3558 :          {
; 3559 :             fnSetEntityByKeys( lpView, lpKeyData, nEntityKeyCnt, 0,

	mov	ecx, DWORD PTR _lpBoundList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lRootCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lRootLimit$[ebp]
	push	eax
	push	0
	movzx	ecx, WORD PTR _nEntityKeyCnt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpKeyData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetEntityByKeys@28

; 3560 :                                lRootLimit, lRootCnt, lpBoundList );
; 3561 :             nEntityKeyCnt = 0;

	xor	ecx, ecx
	mov	WORD PTR _nEntityKeyCnt$[ebp], cx
$LN186@Load:

; 3562 :          }
; 3563 : 
; 3564 :          nRC = SQLFetch( lpConnection->hstmt );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLFetch@4
	mov	WORD PTR _nRC$[ebp], ax

; 3565 :          SQL_RC( "SQLFetch", nRC, 0, 0, 2 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	2
	push	0
	push	0
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95423
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 3566 :          switch ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv1260[ebp], eax
	cmp	DWORD PTR tv1260[ebp], 0
	jl	SHORT $LN189@Load
	cmp	DWORD PTR tv1260[ebp], 1
	jle	SHORT $LN187@Load
	cmp	DWORD PTR tv1260[ebp], 100		; 00000064H
	je	SHORT $LN188@Load
	jmp	SHORT $LN189@Load
$LN187@Load:

; 3567 :          {
; 3568 :             case SQL_SUCCESS:
; 3569 :             case SQL_SUCCESS_WITH_INFO:
; 3570 :                nRC = zFETCH_OK;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 3571 :                break;

	jmp	SHORT $LN47@Load
$LN188@Load:

; 3572 : 
; 3573 :             case SQL_NO_DATA:
; 3574 :                nRC = zFETCH_NO_DATA;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 3575 :                break;

	jmp	SHORT $LN47@Load
$LN189@Load:

; 3576 : 
; 3577 :             default:
; 3578 :                // Oops, error.
; 3579 :                nReturnCode = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], ax

; 3580 :                goto EndOfFunction;

	jmp	$EndOfFunction$213
$LN47@Load:

; 3581 :          }
; 3582 : 
; 3583 : #elif defined( DUMMY )
; 3584 : 
; 3585 :          // If CardMax of the entity is 1 then we'll pretend we didn't find
; 3586 :          // any more entities.
; 3587 :          if ( lpViewEntity->uCardMax == 1 )
; 3588 :             nRC = zFETCH_NO_DATA;
; 3589 :          else
; 3590 :          if ( lRootCnt == 2 )
; 3591 :             nRC = zFETCH_NO_DATA;
; 3592 :          else
; 3593 :             nRC = zFETCH_OK;
; 3594 : 
; 3595 : #endif
; 3596 :          // If we didn't fetch a row this time and if we only fetched 1 row
; 3597 :          // then set the return code to 0 and break loop.
; 3598 :          if ( nRC == zFETCH_NO_DATA && lRootCnt == 1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN37@Load
	cmp	DWORD PTR _lRootCnt$[ebp], 1
	jne	SHORT $LN37@Load

; 3599 :          {
; 3600 :             nReturnCode = 0;

	xor	edx, edx
	mov	WORD PTR _nReturnCode$[ebp], dx

; 3601 :             break;

	jmp	SHORT $LN38@Load
$LN37@Load:

; 3602 :          }
; 3603 : 
; 3604 :       } while ( nRC == zFETCH_OK );

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	$LN39@Load
$LN38@Load:

; 3605 : 
; 3606 :    } // if ( nRC == zFETCH_OK )...

	jmp	SHORT $LN144@Load
$LN143@Load:

; 3607 :    else
; 3608 :       nReturnCode = -1;   // Indicate that no rows were fetched.

	or	ecx, -1
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN144@Load:

; 3609 : 
; 3610 :    if ( lpConnection->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	cmp	eax, 1
	jle	SHORT $LN191@Load

; 3611 :    {
; 3612 :       TraceLineI( "Number of roots retrieved = ", lRootCnt );

	mov	ecx, DWORD PTR _lRootCnt$[ebp]
	push	ecx
	push	OFFSET $SG95429
	call	_TraceLineI@8

; 3613 :       TraceLineI( "Number of rows  retrieved = ", lRowCount );

	mov	edx, DWORD PTR _lRowCount$[ebp]
	push	edx
	push	OFFSET $SG95430
	call	_TraceLineI@8
$LN191@Load:

; 3614 :    }
; 3615 : 
; 3616 :    if ( nReturnCode == 0 && bRootLimitReached )

	movsx	eax, WORD PTR _nReturnCode$[ebp]
	test	eax, eax
	jne	SHORT $EndOfFunction$213
	movzx	ecx, BYTE PTR _bRootLimitReached$[ebp]
	test	ecx, ecx
	je	SHORT $EndOfFunction$213

; 3617 :    {
; 3618 :       if ( lRootLimit > 1 )

	cmp	DWORD PTR _lRootLimit$[ebp], 1
	jle	SHORT $LN193@Load

; 3619 :          nReturnCode = 2; // We must have reached the activate limit.

	mov	edx, 2
	mov	WORD PTR _nReturnCode$[ebp], dx
	jmp	SHORT $EndOfFunction$213
$LN193@Load:

; 3620 :       else
; 3621 :          nReturnCode = 1; // Set RC to indicate we only got one root but that

	mov	eax, 1
	mov	WORD PTR _nReturnCode$[ebp], ax
$EndOfFunction$213:

; 3622 :                           // more than one was found.
; 3623 :    }
; 3624 : 
; 3625 : EndOfFunction:
; 3626 : 
; 3627 : #if defined( DB2 )
; 3628 :    if ( hBlobStmt )
; 3629 :    {
; 3630 :       // Free statements needed to load BLOB columns.
; 3631 :       nRC = SQLFreeStmt( hBlobStmt, SQL_DROP );
; 3632 :       SQL_RC( "SQLFreeStmt", nRC, "Freeing BLOB hstmt", 0, 2 );
; 3633 : 
; 3634 :       nRC = SQLFreeStmt( hLocatorStmt, SQL_DROP );
; 3635 :       SQL_RC( "SQLFreeStmt", nRC, "Freeing locator hstmt2", 0, 2 );
; 3636 :    }
; 3637 : 
; 3638 :    nRC = SQLFreeStmt(lpConnection->hstmt, SQL_UNBIND);
; 3639 :    SQL_RC( "SQLFreeStmt", nRC, "Unbinding stmt handle", 0, 2 );
; 3640 : 
; 3641 :    nRC = SQLFreeStmt(lpConnection->hstmt, SQL_RESET_PARAMS);
; 3642 :    SQL_RC( "SQLFreeStmt", nRC, "Resetting params", 0, 2 );
; 3643 : 
; 3644 :    if ( bKeyListCreated )
; 3645 :    {
; 3646 :       zCHAR szDeleteCmd[ 300 ];
; 3647 : 
; 3648 :       zsprintf( szDeleteCmd,
; 3649 :                 "DELETE FROM ZEIDONKEYLIST WHERE TASKID = %ld",
; 3650 :                 SysGetTaskFromView( lpView ) );
; 3651 : 
; 3652 :       nRC = SQLPrepare( lpConnection->hGeneralStmt, szDeleteCmd, SQL_NTS );
; 3653 :       SQL_RC( "Prepare", nRC, "Deleting KeyList", 0, 2 );
; 3654 : 
; 3655 :       nRC = SQLExecute( lpConnection->hGeneralStmt );
; 3656 :       SQL_RC( "SQLExecute", nRC, "Delete keys", 0, 2 );
; 3657 :    }
; 3658 : 
; 3659 :    nRC = SQLFreeStmt(lpConnection->hstmt, SQL_CLOSE);
; 3660 :    SQL_RC( "SQLFreeStmt", nRC, "Closing stmt handle", 0, 2 );
; 3661 : 
; 3662 : #elif defined( ODBC )
; 3663 :    if ( bCursorOpened )

	movzx	ecx, BYTE PTR _bCursorOpened$[ebp]
	test	ecx, ecx
	je	SHORT $LN195@Load

; 3664 :    {
; 3665 :       zSHORT nRC2;
; 3666 : 
; 3667 :       nRC2 = SQLCloseCursor( lpConnection->hstmt );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLCloseCursor@4
	mov	WORD PTR _nRC2$13[ebp], ax

; 3668 :       SQL_RC( "SQLCloseCursor", nRC2, 0, 0, 2 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	2
	push	0
	push	0
	movzx	edx, WORD PTR _nRC2$13[ebp]
	push	edx
	push	OFFSET $SG95435
	call	_fnSqlRC
	add	esp, 24					; 00000018H
$LN195@Load:

; 3669 :    }
; 3670 : 
; 3671 :    if ( bKeyListCreated )

	movzx	eax, BYTE PTR _bKeyListCreated$[ebp]
	test	eax, eax
	je	$LN196@Load

; 3672 :    {
; 3673 :       zCHAR szDeleteCmd[ 300 ];
; 3674 : 
; 3675 :       zsprintf( szDeleteCmd,

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysGetTaskFromView@4
	push	eax
	push	OFFSET $SG95437
	lea	edx, DWORD PTR _szDeleteCmd$41[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3676 :                 "DELETE FROM ZEIDONKEYLIST WHERE TASKID = %ld",
; 3677 :                 SysGetTaskFromView( lpView ) );
; 3678 : 
; 3679 :       nRC = SQLPrepare( lpConnection->hGeneralStmt, szDeleteCmd, SQL_NTS );

	push	-3					; fffffffdH
	lea	eax, DWORD PTR _szDeleteCmd$41[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2816]
	push	edx
	call	_SQLPrepare@12
	mov	WORD PTR _nRC$[ebp], ax

; 3680 :       SQL_RC( "Prepare", nRC, "Deleting KeyList", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG95438
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95439
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 3681 : 
; 3682 :       nRC = SQLExecute( lpConnection->hGeneralStmt );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2816]
	push	eax
	call	_SQLExecute@4
	mov	WORD PTR _nRC$[ebp], ax

; 3683 :       SQL_RC( "SQLExecute", nRC, "Delete keys", 0, 2 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	2
	push	0
	push	OFFSET $SG95440
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95441
	call	_fnSqlRC
	add	esp, 24					; 00000018H
$LN196@Load:

; 3684 :    }
; 3685 : 
; 3686 :    if ( g_bHoldStmtHandles == FALSE )

	movzx	eax, BYTE PTR _g_bHoldStmtHandles
	test	eax, eax
	jne	SHORT $LN197@Load

; 3687 :    {
; 3688 :       zSHORT nRC2;
; 3689 : 
; 3690 :       nRC2 = SQLFreeStmt( lpConnection->hstmt, SQL_UNBIND );

	push	2
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2812]
	push	edx
	call	_SQLFreeStmt@8
	mov	WORD PTR _nRC2$14[ebp], ax

; 3691 :       SQL_RC( "SQLFreeStmt", nRC2, "Unbinding stmt handle", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG95444
	movzx	ecx, WORD PTR _nRC2$14[ebp]
	push	ecx
	push	OFFSET $SG95445
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 3692 :    }

	jmp	SHORT $LN198@Load
$LN197@Load:

; 3693 :    else
; 3694 :    {
; 3695 :       // We're holding on to the handles so we don't want to free the
; 3696 :       // current lpBoundList so hold on to it.  Setting it to null means
; 3697 :       // it won't be freed (we saved the value earlier).
; 3698 :       lpBoundList = 0;

	mov	DWORD PTR _lpBoundList$[ebp], 0
$LN198@Load:

; 3699 :    }
; 3700 : 
; 3701 : #endif
; 3702 : 
; 3703 :    SqlFreeBoundAttrList( lpBoundList );

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	push	edx
	call	_SqlFreeBoundAttrList@4

; 3704 : 
; 3705 :    // If hMem is not zero, then free the memory allocated.
; 3706 :    if ( hMem )

	cmp	DWORD PTR _hMem$[ebp], 0
	je	SHORT $LN199@Load

; 3707 :       SysFreeMemory( hMem );

	mov	eax, DWORD PTR _hMem$[ebp]
	push	eax
	call	_SysFreeMemory@4
$LN199@Load:

; 3708 : 
; 3709 :    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
$LN200@Load:

; 3710 : 
; 3711 : }  /* Load */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN210@Load:
	DD	$LN99@Load
	DD	$LN100@Load
	DD	$LN102@Load
	DD	$LN103@Load
	DD	$LN104@Load
	DD	$LN101@Load
	DD	$LN107@Load
$LN207@Load:
	DB	0
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	1
	DB	6
	DB	6
	DB	6
	DB	5
	npad	1
$LN211@Load:
	DD	$LN110@Load
	DD	$LN111@Load
	DD	$LN113@Load
	DD	$LN114@Load
	DD	$LN115@Load
	DD	$LN112@Load
	DD	$LN118@Load
$LN208@Load:
	DB	0
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	1
	DB	6
	DB	6
	DB	6
	DB	5
	npad	1
$LN212@Load:
	DD	$LN183@Load
	DD	$LN184@Load
	DD	$LN185@Load
$LN209@Load:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
_Load	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_ulLth$1 = -192						; size = 4
_plKeyValue$2 = -188					; size = 4
tv221 = -184						; size = 4
tv220 = -180						; size = 4
_lpLoopViewAttrib$3 = -176				; size = 4
_pQualValue$4 = -172					; size = 4
_pchEntityJoinTable$5 = -168				; size = 4
_lpDataField$ = -164					; size = 4
_pchKeyValue$6 = -160					; size = 4
tv196 = -156						; size = 4
tv135 = -152						; size = 4
tv271 = -148						; size = 4
_lpSearchEntity$ = -144					; size = 4
_nRC$ = -140						; size = 2
_chType$7 = -133					; size = 1
_lControl$8 = -132					; size = 4
_lpViewAttrib$ = -128					; size = 4
_lpPtr$ = -124						; size = 4
_lpLoadEntity$ = -120					; size = 4
_bSearchNeeded$ = -113					; size = 1
_nKeyCnt$ = -112					; size = 2
_bKeysMatch$ = -105					; size = 1
_szDecimal$9 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpKeyData$ = 12					; size = 4
_nEntityKeyCnt$ = 16					; size = 2
_bEntityCreatedList$ = 20				; size = 4
_lRootLimit$ = 24					; size = 4
_lRootCnt$ = 28						; size = 4
_lpBoundList$ = 32					; size = 4
_fnSetEntityByKeys@28 PROC

; 1726 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1727 :    LPDATAFIELD  lpDataField;
; 1728 :    LPVIEWATTRIB lpViewAttrib;
; 1729 :    LPVIEWENTITY lpLoadEntity;
; 1730 :    LPVIEWENTITY lpSearchEntity;
; 1731 :    zPVOID       lpPtr;
; 1732 :    zBOOL        bKeysMatch;
; 1733 :    zBOOL        bSearchNeeded;
; 1734 :    zSHORT       nKeyCnt;
; 1735 :    zSHORT       nRC;
; 1736 : 
; 1737 :    if ( nEntityKeyCnt == 0 )

	movsx	eax, WORD PTR _nEntityKeyCnt$[ebp]
	test	eax, eax
	jne	SHORT $LN20@fnSetEntit

; 1738 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSetEntit
$LN20@fnSetEntit:

; 1739 : 
; 1740 :    lpLoadEntity = lpKeyData[ 0 ].lpLoadEntity;

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpKeyData$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	DWORD PTR _lpLoadEntity$[ebp], ecx

; 1741 : 
; 1742 :    // If a table has been joined with other tables, then it's possible for
; 1743 :    // the data for an entity to show up more than once.  To check for this,
; 1744 :    // we will search the entities to see if the entity already exists.
; 1745 :    // However, we don't need to do this if:
; 1746 :    //    o  The table wasn't joined
; 1747 :    //    o  The table was only joined with entities that have a x-to-1
; 1748 :    //       relationship.
; 1749 :    if ( lpBoundList->pchEntityJoinTable )

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN21@fnSetEntit

; 1750 :    {
; 1751 :       zPCHAR pchEntityJoinTable = lpBoundList->pchEntityJoinTable;

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	mov	DWORD PTR _pchEntityJoinTable$5[ebp], ecx

; 1752 : 
; 1753 :       bSearchNeeded = FALSE;

	mov	BYTE PTR _bSearchNeeded$[ebp], 0

; 1754 : 
; 1755 :       for ( lpSearchEntity = lpLoadEntity;

	mov	edx, DWORD PTR _lpLoadEntity$[ebp]
	mov	DWORD PTR _lpSearchEntity$[ebp], edx
	jmp	SHORT $LN4@fnSetEntit
$LN2@fnSetEntit:

; 1757 :             lpSearchEntity = zGETPTR( lpSearchEntity->hParent ) )

	mov	eax, DWORD PTR _lpSearchEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpSearchEntity$[ebp], eax
$LN4@fnSetEntit:

; 1756 :             lpSearchEntity;

	cmp	DWORD PTR _lpSearchEntity$[ebp], 0
	je	SHORT $LN3@fnSetEntit

; 1758 :       {
; 1759 :          // If entity has been flagged with MULTICHILD, then search is needed
; 1760 :          // and we can stop our loop.
; 1761 :          if ( (pchEntityJoinTable[ lpSearchEntity->nHierNbr ] &
; 1762 :                                            zSELECT_JOINEDWITHMULTCHILD) != 0 )

	mov	edx, DWORD PTR _lpSearchEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	ecx, DWORD PTR _pchEntityJoinTable$5[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	and	edx, 4
	je	SHORT $LN23@fnSetEntit

; 1763 :          {
; 1764 :             bSearchNeeded = TRUE;

	mov	BYTE PTR _bSearchNeeded$[ebp], 1

; 1765 :             break;

	jmp	SHORT $LN3@fnSetEntit
$LN23@fnSetEntit:

; 1766 :          }
; 1767 : 
; 1768 :          // If entity hasn't been joined with a parent, we can stop checking.
; 1769 :          if ( (pchEntityJoinTable[ lpSearchEntity->nHierNbr ] &
; 1770 :                                            zSELECT_JOINEDWITHPARENT) == 0 )

	mov	eax, DWORD PTR _lpSearchEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	mov	edx, DWORD PTR _pchEntityJoinTable$5[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	and	eax, 1
	jne	SHORT $LN24@fnSetEntit

; 1771 :          {
; 1772 :             break;

	jmp	SHORT $LN3@fnSetEntit
$LN24@fnSetEntit:

; 1773 :          }
; 1774 :       }

	jmp	SHORT $LN2@fnSetEntit
$LN3@fnSetEntit:

; 1775 :    }

	jmp	SHORT $LN22@fnSetEntit
$LN21@fnSetEntit:

; 1776 :    else
; 1777 :       bSearchNeeded = TRUE;

	mov	BYTE PTR _bSearchNeeded$[ebp], 1
$LN22@fnSetEntit:

; 1778 : 
; 1779 :    if ( bSearchNeeded )

	movzx	ecx, BYTE PTR _bSearchNeeded$[ebp]
	test	ecx, ecx
	je	$LN25@fnSetEntit

; 1780 :    {
; 1781 :       zLONG        lControl   = zQUAL_ATTR_HIDDEN | zQUAL_EQUAL;

	mov	DWORD PTR _lControl$8[ebp], 16777232	; 01000010H

; 1782 :       zCPVOID      pQualValue = (zCPVOID) lpKeyData[ 0 ].lpPtr;

	mov	edx, 16					; 00000010H
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpKeyData$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _pQualValue$4[ebp], edx

; 1783 :       LPVIEWATTRIB lpLoopViewAttrib;
; 1784 : 
; 1785 :    // TraceLineS( "DGC", " Doing Search" );
; 1786 : 
; 1787 :       lpLoopViewAttrib = lpKeyData[ 0 ].lpViewAttrib;

	mov	eax, 16					; 00000010H
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpKeyData$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _lpLoopViewAttrib$3[ebp], eax

; 1788 : 
; 1789 :       switch ( lpKeyData[ 0 ].lpDataField->cFldType )

	mov	ecx, 16					; 00000010H
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpKeyData$[ebp]
	mov	ecx, DWORD PTR [eax+edx+8]
	mov	dl, BYTE PTR [ecx+270]
	mov	BYTE PTR tv135[ebp], dl
	cmp	BYTE PTR tv135[ebp], 76			; 0000004cH
	je	SHORT $LN26@fnSetEntit
	cmp	BYTE PTR tv135[ebp], 77			; 0000004dH
	je	SHORT $LN28@fnSetEntit
	cmp	BYTE PTR tv135[ebp], 83			; 00000053H
	je	SHORT $LN27@fnSetEntit
	jmp	SHORT $LN29@fnSetEntit
$LN26@fnSetEntit:

; 1790 :       {
; 1791 :          case zTYPE_INTEGER:
; 1792 :             lControl |= zQUAL_INTEGER;

	mov	eax, DWORD PTR _lControl$8[ebp]
	or	eax, 256				; 00000100H
	mov	DWORD PTR _lControl$8[ebp], eax

; 1793 :             break;

	jmp	SHORT $LN5@fnSetEntit
$LN27@fnSetEntit:

; 1794 : 
; 1795 :          case zTYPE_STRING:
; 1796 :             lControl |= zQUAL_STRING;

	mov	ecx, DWORD PTR _lControl$8[ebp]
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR _lControl$8[ebp], ecx

; 1797 :             break;

	jmp	SHORT $LN5@fnSetEntit
$LN28@fnSetEntit:

; 1798 : 
; 1799 :          case zTYPE_DECIMAL:
; 1800 :             lControl |= zQUAL_DECIMAL;

	mov	edx, DWORD PTR _lControl$8[ebp]
	or	edx, 512				; 00000200H
	mov	DWORD PTR _lControl$8[ebp], edx

; 1801 :             break;

	jmp	SHORT $LN5@fnSetEntit
$LN29@fnSetEntit:

; 1802 : 
; 1803 :          default:
; 1804 :             SysMessageBox( lpView, "DBHandler Error",

	push	0
	push	OFFSET $SG95031
	push	OFFSET $SG95032
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 1805 :                            "Key type not supported", 0 );
; 1806 :             bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$[ebp], 0
$LN5@fnSetEntit:

; 1807 :             break;
; 1808 :       }
; 1809 : 
; 1810 :       // See if there is an entity that matches all the key values.
; 1811 :       for ( nRC = SetEntityCursor( lpView, lpLoadEntity->szName,

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pQualValue$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lControl$8[ebp]
	or	edx, 1
	push	edx
	mov	eax, DWORD PTR _lpLoopViewAttrib$3[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetEntityCursor@40
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN9@fnSetEntit
$LN7@fnSetEntit:

; 1816 :             nRC = SetEntityCursor( lpView, lpLoadEntity->szName,

	push	0
	push	0
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _pQualValue$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$8[ebp]
	or	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _lpLoopViewAttrib$3[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpLoadEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetEntityCursor@40
	mov	WORD PTR _nRC$[ebp], ax
$LN9@fnSetEntit:

; 1812 :                                    lpLoopViewAttrib->szName,
; 1813 :                                    lControl | zPOS_FIRST, pQualValue, 0, 0,
; 1814 :                                    0, 0, 0 );
; 1815 :             nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN25@fnSetEntit

; 1817 :                                    lpLoopViewAttrib->szName,
; 1818 :                                    lControl | zPOS_NEXT, pQualValue, 0, 0,
; 1819 :                                    0, 0, 0 ) )
; 1820 :       {
; 1821 :          // Go through each of the keys and see if the current entity
; 1822 :          // matches the keys.  If not, try with the next entity.
; 1823 :          // Assume that the keys will match.
; 1824 :          bKeysMatch = TRUE;

	mov	BYTE PTR _bKeysMatch$[ebp], 1

; 1825 :          for ( nKeyCnt = 1; nKeyCnt < nEntityKeyCnt; nKeyCnt++ )

	mov	eax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
	jmp	SHORT $LN12@fnSetEntit
$LN10@fnSetEntit:
	mov	cx, WORD PTR _nKeyCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nKeyCnt$[ebp], cx
$LN12@fnSetEntit:
	movsx	edx, WORD PTR _nKeyCnt$[ebp]
	movsx	eax, WORD PTR _nEntityKeyCnt$[ebp]
	cmp	edx, eax
	jge	$LN11@fnSetEntit

; 1826 :          {
; 1827 :             zCHAR        chType;
; 1828 :             zULONG       ulLth;
; 1829 : 
; 1830 :             lpDataField  = lpKeyData[ nKeyCnt ].lpDataField;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _lpKeyData$[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	mov	DWORD PTR _lpDataField$[ebp], eax

; 1831 :             lpViewAttrib = lpKeyData[ nKeyCnt ].lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _lpKeyData$[ebp]
	mov	eax, DWORD PTR [edx+ecx+4]
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1832 :             lpPtr        = lpKeyData[ nKeyCnt ].lpPtr;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _lpKeyData$[ebp]
	mov	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 1833 : 
; 1834 :             switch ( lpDataField->cFldType )

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	dl, BYTE PTR [ecx+270]
	mov	BYTE PTR tv196[ebp], dl
	cmp	BYTE PTR tv196[ebp], 76			; 0000004cH
	je	SHORT $LN30@fnSetEntit
	cmp	BYTE PTR tv196[ebp], 77			; 0000004dH
	je	$LN34@fnSetEntit
	cmp	BYTE PTR tv196[ebp], 83			; 00000053H
	je	SHORT $LN32@fnSetEntit
	jmp	$LN36@fnSetEntit
$LN30@fnSetEntit:

; 1835 :             {
; 1836 :                case zTYPE_INTEGER:
; 1837 :                {
; 1838 :                   zPLONG plKeyValue;
; 1839 : 
; 1840 :                   GetValueFromRecord( lpView, lpLoadEntity, lpViewAttrib,

	lea	eax, DWORD PTR _ulLth$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _chType$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _plKeyValue$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_GetValueFromRecord@24

; 1841 :                                       (zCOREMEM) &plKeyValue, &chType, &ulLth );
; 1842 : 
; 1843 :                   // Compare the attribute value with the one we got from
; 1844 :                   // the database.
; 1845 :                   if ( *plKeyValue != *((zPLONG) lpPtr) )

	mov	eax, DWORD PTR _plKeyValue$2[ebp]
	mov	ecx, DWORD PTR _lpPtr$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN31@fnSetEntit

; 1846 :                      bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$[ebp], 0
$LN31@fnSetEntit:

; 1847 : 
; 1848 :                   break;

	jmp	$LN13@fnSetEntit
$LN32@fnSetEntit:

; 1849 :                }
; 1850 : 
; 1851 :                case zTYPE_STRING:
; 1852 :                {
; 1853 :                   zPCHAR pchKeyValue;
; 1854 : 
; 1855 :                   GetValueFromRecord( lpView, lpLoadEntity, lpViewAttrib,

	lea	eax, DWORD PTR _ulLth$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _chType$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchKeyValue$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_GetValueFromRecord@24

; 1856 :                                       (zCOREMEM) &pchKeyValue, &chType, &ulLth );
; 1857 : 
; 1858 :                   // Compare the attribute value with the one we
; 1859 :                   // got from the database.
; 1860 :                   if ( zstrcmp( pchKeyValue, (zPCHAR) lpPtr ) != 0 )

	mov	eax, DWORD PTR _pchKeyValue$6[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpPtr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN47@fnSetEntit
	mov	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchKeyValue$6[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv221[ebp], eax
	jmp	SHORT $LN48@fnSetEntit
$LN47@fnSetEntit:
	mov	eax, DWORD PTR _pchKeyValue$6[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpPtr$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN45@fnSetEntit
	mov	DWORD PTR tv220[ebp], 1
	jmp	SHORT $LN46@fnSetEntit
$LN45@fnSetEntit:
	mov	DWORD PTR tv220[ebp], -1
$LN46@fnSetEntit:
	mov	ecx, DWORD PTR tv220[ebp]
	mov	DWORD PTR tv221[ebp], ecx
$LN48@fnSetEntit:
	cmp	DWORD PTR tv221[ebp], 0
	je	SHORT $LN33@fnSetEntit

; 1861 :                      bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$[ebp], 0
$LN33@fnSetEntit:

; 1862 : 
; 1863 :                   break;

	jmp	SHORT $LN13@fnSetEntit
$LN34@fnSetEntit:

; 1864 :                }
; 1865 : 
; 1866 :                case zTYPE_DECIMAL:
; 1867 :                {
; 1868 :                   // We retrieve the value from the database as a string.  Call
; 1869 :                   // CompareAttributeToString( ) so that we use domain processing.
; 1870 :                   if ( CompareAttributeToString( lpView, lpLoadEntity->szName,
; 1871 :                                                  lpViewAttrib->szName,
; 1872 :                                                  (zPCHAR) lpPtr ) != 0 )

	mov	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	je	SHORT $LN35@fnSetEntit

; 1873 :                      bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$[ebp], 0
$LN35@fnSetEntit:

; 1874 : 
; 1875 :                   break;

	jmp	SHORT $LN13@fnSetEntit
$LN36@fnSetEntit:

; 1876 :                }
; 1877 : 
; 1878 :                default:
; 1879 :                   SysMessageBox( lpView, "DBHandler Error", "Key type not supported", 0 );

	push	0
	push	OFFSET $SG95040
	push	OFFSET $SG95041
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 1880 :                   bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$[ebp], 0
$LN13@fnSetEntit:

; 1881 :                   break;
; 1882 : 
; 1883 :             } // switch ( lpDataField->cFldType )...
; 1884 : 
; 1885 :             // If we found a key that doesn't match, break loop and try
; 1886 :             // with the next entity.
; 1887 :             if ( bKeysMatch == FALSE )

	movzx	edx, BYTE PTR _bKeysMatch$[ebp]
	test	edx, edx
	jne	SHORT $LN37@fnSetEntit

; 1888 :                break;

	jmp	SHORT $LN11@fnSetEntit
$LN37@fnSetEntit:

; 1889 : 
; 1890 :          } // for ( nKeyCnt... )

	jmp	$LN10@fnSetEntit
$LN11@fnSetEntit:

; 1891 : 
; 1892 :          // If we get here and bKeysMatch is TRUE, then all the
; 1893 :          // keys for this entity matched, so we found the one we
; 1894 :          // want.  Stop looping through the entities.
; 1895 :          if ( bKeysMatch )

	movzx	eax, BYTE PTR _bKeysMatch$[ebp]
	test	eax, eax
	je	SHORT $LN38@fnSetEntit

; 1896 :             return( 0 );       // Entity not created.

	xor	eax, eax
	jmp	$LN1@fnSetEntit
$LN38@fnSetEntit:

; 1897 : 
; 1898 :       } // for each lpLoadEntity...

	jmp	$LN7@fnSetEntit
$LN25@fnSetEntit:

; 1899 : 
; 1900 :    } // if ( lpBoundList->pchEntityJoinTable[ lpLoadEntity->nHierNbr ] != 0 )
; 1901 : 
; 1902 :    // If we get here, then we didn't find an entity whose keys matched those
; 1903 :    // in lpKeyData[], so we need to create one.
; 1904 : 
; 1905 :    // If hParent is null, then we are about to create a root.  Make sure we
; 1906 :    // haven't reached the limit yet.
; 1907 :    if ( lpLoadEntity->hParent == 0 && lRootCnt >= lRootLimit )

	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	jne	SHORT $LN39@fnSetEntit
	mov	edx, DWORD PTR _lRootCnt$[ebp]
	cmp	edx, DWORD PTR _lRootLimit$[ebp]
	jl	SHORT $LN39@fnSetEntit

; 1908 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnSetEntit
$LN39@fnSetEntit:

; 1909 : 
; 1910 :    LoadEntity( lpView, lpLoadEntity->szName, zPOS_LAST, 0 );

	push	0
	push	2
	mov	eax, DWORD PTR _lpLoadEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_LoadEntity@16

; 1911 : 
; 1912 :    // Loop through the keys and set the attribute values.
; 1913 :    for ( nKeyCnt = 0; nKeyCnt < nEntityKeyCnt; nKeyCnt++ )

	xor	edx, edx
	mov	WORD PTR _nKeyCnt$[ebp], dx
	jmp	SHORT $LN17@fnSetEntit
$LN15@fnSetEntit:
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
$LN17@fnSetEntit:
	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	movsx	edx, WORD PTR _nEntityKeyCnt$[ebp]
	cmp	ecx, edx
	jge	$LN16@fnSetEntit

; 1914 :    {
; 1915 :       lpDataField  = lpKeyData[ nKeyCnt ].lpDataField;

	movsx	eax, WORD PTR _nKeyCnt$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _lpKeyData$[ebp]
	mov	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _lpDataField$[ebp], edx

; 1916 :       lpViewAttrib = lpKeyData[ nKeyCnt ].lpViewAttrib;

	movsx	eax, WORD PTR _nKeyCnt$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _lpKeyData$[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	mov	DWORD PTR _lpViewAttrib$[ebp], edx

; 1917 :       lpPtr   = lpKeyData[ nKeyCnt ].lpPtr;

	movsx	eax, WORD PTR _nKeyCnt$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _lpKeyData$[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _lpPtr$[ebp], edx

; 1918 : 
; 1919 :       switch ( lpDataField->cFldType )

	mov	eax, DWORD PTR _lpDataField$[ebp]
	movsx	ecx, BYTE PTR [eax+270]
	mov	DWORD PTR tv271[ebp], ecx
	mov	edx, DWORD PTR tv271[ebp]
	sub	edx, 68					; 00000044H
	mov	DWORD PTR tv271[ebp], edx
	cmp	DWORD PTR tv271[ebp], 16		; 00000010H
	ja	SHORT $LN42@fnSetEntit
	mov	eax, DWORD PTR tv271[ebp]
	movzx	ecx, BYTE PTR $LN49@fnSetEntit[eax]
	jmp	DWORD PTR $LN50@fnSetEntit[ecx*4]
$LN40@fnSetEntit:

; 1920 :       {
; 1921 :          case zTYPE_DATETIME:
; 1922 :          case zTYPE_DATE:
; 1923 :          case zTYPE_TIME:
; 1924 :             StoreStringInRecord( lpView, lpLoadEntity, lpViewAttrib, lpPtr );

	mov	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreStringInRecord@16

; 1925 :             break;

	jmp	SHORT $LN18@fnSetEntit
$LN41@fnSetEntit:

; 1926 : 
; 1927 :          case zTYPE_DECIMAL:
; 1928 :          {
; 1929 :             zCHAR szDecimal[ 100 ];
; 1930 : 
; 1931 :             StoreStringInRecord( lpView, lpLoadEntity, lpViewAttrib, lpPtr );

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLoadEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_StoreStringInRecord@16

; 1932 : 
; 1933 :             // Retrieve decimal value and copy it back into the attribute.
; 1934 :             // This will cause the Format routines to be called so that
; 1935 :             // the decimal gets rounded/truncated correctly.
; 1936 :             GetStringFromRecord( lpView, lpLoadEntity, lpViewAttrib,

	push	100					; 00000064H
	lea	ecx, DWORD PTR _szDecimal$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLoadEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetStringFromRecord@20

; 1937 :                                  szDecimal, sizeof( szDecimal ) );
; 1938 :             StoreStringInRecord( lpView, lpLoadEntity, lpViewAttrib,

	lea	edx, DWORD PTR _szDecimal$9[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreStringInRecord@16

; 1939 :                                  szDecimal );
; 1940 : 
; 1941 :             break;

	jmp	SHORT $LN18@fnSetEntit
$LN42@fnSetEntit:

; 1942 :          }
; 1943 : 
; 1944 :          default:
; 1945 :             // Note that length is only used for blob attributes, so we
; 1946 :             // will always pass 0.
; 1947 :             StoreValueInRecord( lpView, lpLoadEntity, lpViewAttrib,

	push	0
	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLoadEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_StoreValueInRecord@20
$LN18@fnSetEntit:

; 1948 :                                 lpPtr, 0 );
; 1949 :             break;
; 1950 : 
; 1951 :       } // switch ( lpDataField->cFldType )...
; 1952 : 
; 1953 :    } // for ( nKeyCnt... )

	jmp	$LN15@fnSetEntit
$LN16@fnSetEntit:

; 1954 : 
; 1955 :    if ( bEntityCreatedList )

	cmp	DWORD PTR _bEntityCreatedList$[ebp], 0
	je	SHORT $LN43@fnSetEntit

; 1956 :       bEntityCreatedList[ lpLoadEntity->nHierNbr ] = TRUE;

	mov	ecx, DWORD PTR _lpLoadEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _bEntityCreatedList$[ebp]
	mov	BYTE PTR [eax+edx], 1
$LN43@fnSetEntit:

; 1957 : 
; 1958 :    // We created an entity so return 1.
; 1959 :    return( 1 );

	mov	eax, 1
$LN1@fnSetEntit:

; 1960 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	1
$LN50@fnSetEntit:
	DD	$LN40@fnSetEntit
	DD	$LN41@fnSetEntit
	DD	$LN42@fnSetEntit
$LN49@fnSetEntit:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
_fnSetEntityByKeys@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lKey$1 = -348						; size = 4
_lKeyList$2 = -344					; size = 4
_iBufferLth$3 = -340					; size = 4
_nParmLth$4 = -336					; size = 4
_nColumnSize$5 = -332					; size = 4
_hstmt$6 = -328						; size = 4
_lpQualAttrib$ = -324					; size = 4
_nSQL_Type$7 = -320					; size = 2
_nC_DataType$8 = -316					; size = 2
_k$9 = -312						; size = 2
_nRC$10 = -308						; size = 2
_szCmd$11 = -304					; size = 300
__$ArrayPad$ = -4					; size = 4
_hTask$ = 8						; size = 4
_lpConnection$ = 12					; size = 4
_lpBoundList$ = 16					; size = 4
_lpQualEntity$ = 20					; size = 4
_fnCreateKeyList@16 PROC

; 1627 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1628 :    LPQUALATTRIB lpQualAttrib;
; 1629 : 
; 1630 :    // Find the qual attrib with the key list.
; 1631 :    for ( lpQualAttrib = lpQualEntity->lpFirstQualAttrib;

	mov	eax, DWORD PTR _lpQualEntity$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _lpQualAttrib$[ebp], ecx
	jmp	SHORT $LN4@fnCreateKe
$LN2@fnCreateKe:

; 1633 :          lpQualAttrib = lpQualAttrib->lpNextQualAttrib )

	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _lpQualAttrib$[ebp], eax
$LN4@fnCreateKe:

; 1632 :          lpQualAttrib->lpKeyList == 0;

	mov	ecx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	jne	SHORT $LN3@fnCreateKe

; 1634 :    {
; 1635 :       // Nothing needs to be done here.
; 1636 :    }

	jmp	SHORT $LN2@fnCreateKe
$LN3@fnCreateKe:

; 1637 : 
; 1638 : #if defined( DB2 ) || defined( ODBC )
; 1639 :    {
; 1640 :       HSTMT          hstmt;
; 1641 :       zSHORT         nRC;
; 1642 :       zSHORT         k;
; 1643 :       SQLSMALLINT    nC_DataType;
; 1644 :       SQLSMALLINT    nSQL_Type;
; 1645 :       SQLUINTEGER    nColumnSize;
; 1646 :       SQLINTEGER     nParmLth;
; 1647 :       SQLINTEGER     iBufferLth;
; 1648 :       SQLINTEGER     lKey;
; 1649 :       zPLONG         lKeyList;
; 1650 :       zCHAR          szCmd[ 300 ];
; 1651 : 
; 1652 :       // If we are holding stmt handles then we can use the "general" stmt
; 1653 :       // handle because each SELECT gets its own handle.  If we are not
; 1654 :       // holding handles then we have to create a temp one because the
; 1655 :       // general hstmt is being used by the current SELECT command.
; 1656 :       if ( g_bHoldStmtHandles )

	movzx	edx, BYTE PTR _g_bHoldStmtHandles
	test	edx, edx
	je	SHORT $LN8@fnCreateKe

; 1657 :          hstmt = lpConnection->hGeneralStmt;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2816]
	mov	DWORD PTR _hstmt$6[ebp], ecx
	jmp	SHORT $LN9@fnCreateKe
$LN8@fnCreateKe:

; 1658 :       else
; 1659 :       {
; 1660 :          nRC = SQLAllocHandle( SQL_HANDLE_STMT, lpConnection->hdbc, &hstmt );

	lea	edx, DWORD PTR _hstmt$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2808]
	push	ecx
	push	3
	call	_SQLAllocHandle@12
	mov	WORD PTR _nRC$10[ebp], ax

; 1661 :          SQL_RC( "SQLAllocHandle", nRC, "Allocate HSTMT", 0, 2 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	push	0
	push	OFFSET $SG94937
	movzx	eax, WORD PTR _nRC$10[ebp]
	push	eax
	push	OFFSET $SG94938
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1662 :          if ( nRC != SQL_SUCCESS )

	movsx	ecx, WORD PTR _nRC$10[ebp]
	test	ecx, ecx
	je	SHORT $LN9@fnCreateKe

; 1663 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateKe
$LN9@fnCreateKe:

; 1664 :       }
; 1665 : 
; 1666 :       zsprintf( szCmd,

	mov	edx, DWORD PTR _hTask$[ebp]
	push	edx
	push	OFFSET $SG94940
	lea	eax, DWORD PTR _szCmd$11[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1667 :                 "INSERT INTO ZEIDONKEYLIST ( TASKID, INTVALUE ) VALUES ( %ld, ? )",
; 1668 :                 hTask );
; 1669 :       nRC = SQLPrepare( hstmt, szCmd, SQL_NTS );

	push	-3					; fffffffdH
	lea	ecx, DWORD PTR _szCmd$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _hstmt$6[ebp]
	push	edx
	call	_SQLPrepare@12
	mov	WORD PTR _nRC$10[ebp], ax

; 1670 :       SQL_RC( "SQLPrepare insert", nRC, 0, 0, 3 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	3
	push	0
	push	0
	movzx	ecx, WORD PTR _nRC$10[ebp]
	push	ecx
	push	OFFSET $SG94941
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1671 : 
; 1672 :       nC_DataType = SQL_C_SLONG;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nC_DataType$8[ebp], dx

; 1673 :       nSQL_Type   = SQL_INTEGER;

	mov	eax, 4
	mov	WORD PTR _nSQL_Type$7[ebp], ax

; 1674 :       iBufferLth  = sizeof( zLONG );

	mov	DWORD PTR _iBufferLth$3[ebp], 4

; 1675 :       nColumnSize = sizeof( zLONG );

	mov	DWORD PTR _nColumnSize$5[ebp], 4

; 1676 :       nParmLth    = sizeof( zLONG );

	mov	DWORD PTR _nParmLth$4[ebp], 4

; 1677 : 
; 1678 :       nRC = SQLBindParameter( hstmt, 1, SQL_PARAM_INPUT,

	lea	ecx, DWORD PTR _nParmLth$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _iBufferLth$3[ebp]
	push	edx
	lea	eax, DWORD PTR _lKey$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _nColumnSize$5[ebp]
	push	ecx
	movzx	edx, WORD PTR _nSQL_Type$7[ebp]
	push	edx
	movzx	eax, WORD PTR _nC_DataType$8[ebp]
	push	eax
	push	1
	push	1
	mov	ecx, DWORD PTR _hstmt$6[ebp]
	push	ecx
	call	_SQLBindParameter@40
	mov	WORD PTR _nRC$10[ebp], ax

; 1679 :                               nC_DataType, nSQL_Type, nColumnSize, 0,
; 1680 :                               (SQLPOINTER) &lKey, iBufferLth,
; 1681 :                               &nParmLth );
; 1682 :       SQL_RC( "SQLBindParameter", nRC, "Column = ", "IntValue", 3 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	3
	push	OFFSET $SG94942
	push	OFFSET $SG94943
	movzx	eax, WORD PTR _nRC$10[ebp]
	push	eax
	push	OFFSET $SG94944
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1683 :       if ( lpConnection->nTraceLevel > 2 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 2
	jle	SHORT $LN11@fnCreateKe

; 1684 :       {
; 1685 :          TraceLineI( "nC_DataType = ", nC_DataType );

	movsx	eax, WORD PTR _nC_DataType$8[ebp]
	push	eax
	push	OFFSET $SG94946
	call	_TraceLineI@8

; 1686 :          TraceLineI( "nSQL_Type   = ", nSQL_Type );

	movsx	ecx, WORD PTR _nSQL_Type$7[ebp]
	push	ecx
	push	OFFSET $SG94947
	call	_TraceLineI@8

; 1687 :          TraceLineI( "nColumnSize = ", nColumnSize );

	mov	edx, DWORD PTR _nColumnSize$5[ebp]
	push	edx
	push	OFFSET $SG94948
	call	_TraceLineI@8
$LN11@fnCreateKe:

; 1688 :       }
; 1689 : 
; 1690 :       lKeyList = (zPLONG) lpQualAttrib->lpKeyList;

	mov	eax, DWORD PTR _lpQualAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR _lKeyList$2[ebp], ecx

; 1691 :       for ( k = 0; k < lpQualAttrib->lKeyCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$9[ebp], dx
	jmp	SHORT $LN7@fnCreateKe
$LN5@fnCreateKe:
	mov	ax, WORD PTR _k$9[ebp]
	add	ax, 1
	mov	WORD PTR _k$9[ebp], ax
$LN7@fnCreateKe:
	movsx	ecx, WORD PTR _k$9[ebp]
	mov	edx, DWORD PTR _lpQualAttrib$[ebp]
	cmp	ecx, DWORD PTR [edx+48]
	jge	SHORT $LN6@fnCreateKe

; 1692 :       {
; 1693 :          lKey = lKeyList[ k ];

	movsx	eax, WORD PTR _k$9[ebp]
	mov	ecx, DWORD PTR _lKeyList$2[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _lKey$1[ebp], edx

; 1694 : 
; 1695 :          nRC = SQLExecute( hstmt );

	mov	eax, DWORD PTR _hstmt$6[ebp]
	push	eax
	call	_SQLExecute@4
	mov	WORD PTR _nRC$10[ebp], ax

; 1696 :          SQL_RC( "SQLExecute", nRC, "Allocate HSTMT", 0, 2 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	2
	push	0
	push	OFFSET $SG94949
	movzx	edx, WORD PTR _nRC$10[ebp]
	push	edx
	push	OFFSET $SG94950
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1697 :       }

	jmp	SHORT $LN5@fnCreateKe
$LN6@fnCreateKe:

; 1698 : 
; 1699 :       // If we created a temp statement handle we need to free it.
; 1700 :       if ( g_bHoldStmtHandles == FALSE )

	movzx	eax, BYTE PTR _g_bHoldStmtHandles
	test	eax, eax
	jne	SHORT $LN12@fnCreateKe

; 1701 :          SQLFreeHandle( SQL_HANDLE_STMT, (SQLHANDLE) hstmt );

	mov	ecx, DWORD PTR _hstmt$6[ebp]
	push	ecx
	push	3
	call	_SQLFreeHandle@8
$LN12@fnCreateKe:

; 1702 :    }
; 1703 : #endif
; 1704 : 
; 1705 :    return( 0 );

	xor	eax, eax
$LN1@fnCreateKe:

; 1706 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnCreateKeyList@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpLoadViewEntity$1 = -16				; size = 4
_lpDataRecord$2 = -12					; size = 4
_lpDataRecord$3 = -8					; size = 4
_lpViewAttrib$4 = -4					; size = 4
_lpLoopInfo$ = 8					; size = 4
_fnGetNextDataField@4 PROC

; 1478 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
$LN2@fnGetNextD:

; 1479 :    // Loop until we find the next valid datafield.
; 1480 :    while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$LN3@fnGetNextD

; 1481 :    {
; 1482 :       LPVIEWATTRIB lpViewAttrib;
; 1483 : 
; 1484 :       if ( lpLoopInfo->lpDataField == 0 )

	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN4@fnGetNextD

; 1485 :       {
; 1486 :          // First time this is called...initialize some stuff.
; 1487 :          lpLoopInfo->nDataFieldIdx = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	mov	WORD PTR [eax+2], dx

; 1488 :          lpLoopInfo->lpChildEntity = 0;

	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	DWORD PTR [ecx+16], 0

; 1489 : 
; 1490 :          if ( lpLoopInfo->bOpenSQL )

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN6@fnGetNextD

; 1491 :             lpLoopInfo->lpDataField =

	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+20], ecx
	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	ax, WORD PTR [edx+2]
	add	ax, 1
	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	WORD PTR [ecx+2], ax
	jmp	SHORT $LN7@fnGetNextD
$LN6@fnGetNextD:

; 1492 :               lpLoopInfo->lpQualEntity->lpDataField[ lpLoopInfo->nDataFieldIdx++ ];
; 1493 :          else
; 1494 :          {
; 1495 :             LPDATARECORD lpDataRecord =

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$3[ebp], eax

; 1496 :                            zGETPTR( lpLoopInfo->lpViewEntity->hFirstDataRecord );
; 1497 : 
; 1498 :             lpLoopInfo->lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	edx, DWORD PTR _lpDataRecord$3[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN7@fnGetNextD:

; 1499 :          }
; 1500 :       }

	jmp	$LN5@fnGetNextD
$LN4@fnGetNextD:

; 1501 :       else
; 1502 :       {
; 1503 :          // Get the 'next' data field.
; 1504 :          if ( lpLoopInfo->bOpenSQL )

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN8@fnGetNextD

; 1505 :          {
; 1506 :             lpLoopInfo->lpDataField =

	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	movsx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR [edx+20]
	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax+20], ecx
	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	ax, WORD PTR [edx+2]
	add	ax, 1
	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	WORD PTR [ecx+2], ax

; 1507 :               lpLoopInfo->lpQualEntity->lpDataField[ lpLoopInfo->nDataFieldIdx++ ];
; 1508 :          }

	jmp	$LN5@fnGetNextD
$LN8@fnGetNextD:

; 1509 :          else
; 1510 :          {
; 1511 :             lpLoopInfo->lpDataField =

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	DWORD PTR [edx+20], eax

; 1512 :                         zGETPTR( lpLoopInfo->lpDataField->hNextDataField );
; 1513 : 
; 1514 : #ifdef USE_JOINS
; 1515 :             if ( (lpLoopInfo->lpBoundList->lFuncs & zSQLCALLBACK_USEJOIN) &&
; 1516 :                  lpLoopInfo->lpDataField == 0 &&

	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+14]
	and	edx, 33554432				; 02000000H
	je	SHORT $LN5@fnGetNextD
	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN5@fnGetNextD
	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, 268435456				; 10000000H
	jne	SHORT $LN5@fnGetNextD

; 1517 :                  (lpLoopInfo->lControl & zACTIVATE_ROOTONLY) == 0 )
; 1518 :             {
; 1519 :                // See if there are any child entities that have been included
; 1520 :                // as part of a join.
; 1521 :                if ( fnFindNextJoinedChild( lpLoopInfo->lpViewEntity,

	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_fnFindNextJoinedChild@12
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@fnGetNextD

; 1522 :                                            &lpLoopInfo->lpChildEntity,
; 1523 :                                            lpLoopInfo->
; 1524 :                                               lpBoundList->pchEntityJoinTable ) )
; 1525 :                {
; 1526 :                   LPDATARECORD lpDataRecord;
; 1527 : 
; 1528 :                   // We have one.  Let's loop through it's data fields.
; 1529 :                   lpDataRecord =

	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpDataRecord$2[ebp], eax

; 1530 :                         zGETPTR( lpLoopInfo->lpChildEntity->hFirstDataRecord );
; 1531 :                   lpLoopInfo->lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$2[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN5@fnGetNextD:

; 1532 :                }
; 1533 :             }
; 1534 : #endif // USE_JOINS
; 1535 : 
; 1536 :          }
; 1537 :       }
; 1538 : 
; 1539 :       // If the data field is 0 then we're done.
; 1540 :       if ( lpLoopInfo->lpDataField == 0 )

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	cmp	DWORD PTR [edx+20], 0
	jne	SHORT $LN12@fnGetNextD

; 1541 :       {
; 1542 : #ifdef ODBC
; 1543 :          if ( lpLoopInfo->bFirstPass )

	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN13@fnGetNextD

; 1544 :          {
; 1545 :             lpLoopInfo->bFirstPass  = FALSE;

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	BYTE PTR [edx+32], 0

; 1546 :             lpLoopInfo->lpDataField = 0;

	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1547 :             continue;

	jmp	$LN2@fnGetNextD
$LN13@fnGetNextD:

; 1548 :          }
; 1549 : #endif
; 1550 : 
; 1551 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetNextD
$LN12@fnGetNextD:

; 1552 :       }
; 1553 : 
; 1554 :       lpViewAttrib = zGETPTR( lpLoopInfo->lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$4[ebp], eax

; 1555 : 
; 1556 :       // If we aren't using OpenSQL, then we might want to ignore certain
; 1557 :       // attributes.
; 1558 :       if ( lpLoopInfo->bOpenSQL == FALSE )

	mov	ecx, DWORD PTR _lpLoopInfo$[ebp]
	movzx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	$LN14@fnGetNextD

; 1559 :       {
; 1560 :          LPVIEWENTITY lpLoadViewEntity;
; 1561 : 
; 1562 :          // If we only want the keys and the attrib/datafield is not a key,
; 1563 :          // continue.
; 1564 :          if ( lpLoopInfo->bKeysOnly && lpViewAttrib->bKey == FALSE )

	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN15@fnGetNextD
	mov	edx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN15@fnGetNextD

; 1565 :             continue;

	jmp	$LN2@fnGetNextD
$LN15@fnGetNextD:

; 1566 : 
; 1567 :          // Ignore hidden attributes that aren't keys.
; 1568 :          if ( lpViewAttrib->bHidden &&
; 1569 :               lpViewAttrib->bKey == FALSE &&
; 1570 :               lpViewAttrib->bForeignKey == FALSE &&

	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN16@fnGetNextD
	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN16@fnGetNextD
	mov	edx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 2
	and	eax, 1
	jne	SHORT $LN16@fnGetNextD
	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN16@fnGetNextD

; 1571 :               lpViewAttrib->bAutoSeq == FALSE )
; 1572 :          {
; 1573 :             continue;

	jmp	$LN2@fnGetNextD
$LN16@fnGetNextD:

; 1574 :          }
; 1575 : 
; 1576 :          lpLoadViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpLoadViewEntity$1[ebp], eax

; 1577 : 
; 1578 :          // If the entity has a db operation, then skip attributes that don't
; 1579 :          // have a db operation.
; 1580 :          if ( lpLoadViewEntity->bHasDB_Oper && lpViewAttrib->cDB_Oper == 0 )

	mov	edx, DWORD PTR _lpLoadViewEntity$1[ebp]
	mov	eax, DWORD PTR [edx+239]
	and	eax, 1
	je	SHORT $LN14@fnGetNextD
	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	movsx	edx, BYTE PTR [ecx+254]
	test	edx, edx
	jne	SHORT $LN14@fnGetNextD

; 1581 :             continue;

	jmp	$LN2@fnGetNextD
$LN14@fnGetNextD:

; 1582 :       }
; 1583 : 
; 1584 : #ifdef ODBC
; 1585 :       if ( lpLoopInfo->bFirstPass )

	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+32]
	test	ecx, ecx
	je	SHORT $LN18@fnGetNextD

; 1586 :       {
; 1587 :          if ( lpLoopInfo->lpDataField->cFldType == zTYPE_BLOB ||

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movsx	ecx, BYTE PTR [eax+270]
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN21@fnGetNextD
	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movsx	ecx, BYTE PTR [eax+270]
	cmp	ecx, 86					; 00000056H
	jne	SHORT $LN20@fnGetNextD
$LN21@fnGetNextD:

; 1588 :               lpLoopInfo->lpDataField->cFldType == 'V' )
; 1589 :          {
; 1590 :             // Skip long fields on the first pass.
; 1591 :             continue;

	jmp	$LN2@fnGetNextD
$LN20@fnGetNextD:

; 1592 :          }
; 1593 :       }

	jmp	SHORT $LN19@fnGetNextD
$LN18@fnGetNextD:

; 1594 :       else
; 1595 :       {
; 1596 :          if ( lpLoopInfo->lpDataField->cFldType != zTYPE_BLOB &&

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movsx	ecx, BYTE PTR [eax+270]
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN19@fnGetNextD
	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	movsx	ecx, BYTE PTR [eax+270]
	cmp	ecx, 86					; 00000056H
	je	SHORT $LN19@fnGetNextD

; 1597 :               lpLoopInfo->lpDataField->cFldType != 'V' )
; 1598 :          {
; 1599 :             // Skip NON-long fields on the second pass.
; 1600 :             continue;

	jmp	$LN2@fnGetNextD
$LN19@fnGetNextD:

; 1601 :          }
; 1602 :       }
; 1603 : #endif
; 1604 : 
; 1605 :       // If we get here then we've found our man.
; 1606 :       return( lpLoopInfo->lpDataField );

	mov	edx, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [edx+20]
	jmp	SHORT $LN1@fnGetNextD

; 1607 : 
; 1608 :    } // while ( TRUE )...

	jmp	$LN2@fnGetNextD
$LN3@fnGetNextD:

; 1609 : 
; 1610 :    // We will never get here but this line in here so we don't get any
; 1611 :    // compiler warnings.
; 1612 :    return( lpLoopInfo->lpDataField );

	mov	eax, DWORD PTR _lpLoopInfo$[ebp]
	mov	eax, DWORD PTR [eax+20]
$LN1@fnGetNextD:

; 1613 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnGetNextDataField@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_nLevel$1 = -4						; size = 2
_lpParent$ = 8						; size = 4
_plpChildEntity$ = 12					; size = 4
_pchEntityJoinTable$ = 16				; size = 4
_fnFindNextJoinedChild@12 PROC

; 1421 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1422 :    if ( *plpChildEntity == 0 )

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@fnFindNext

; 1423 :       *plpChildEntity = lpParent;

	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	DWORD PTR [ecx], edx
$LN8@fnFindNext:

; 1424 : 
; 1425 :    // DBHandler has said there might be more children so look for them.
; 1426 :    *plpChildEntity = zGETPTR( (*plpChildEntity)->hNextHier );

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@fnFindNext:

; 1427 :    while ( *plpChildEntity )

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN3@fnFindNext

; 1428 :    {
; 1429 :       if ( *plpChildEntity == 0 ||

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN10@fnFindNext
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpParent$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $LN9@fnFindNext
$LN10@fnFindNext:

; 1430 :            (*plpChildEntity)->nLevel <= lpParent->nLevel )
; 1431 :       {
; 1432 :          return( FALSE );

	xor	al, al
	jmp	$LN1@fnFindNext
$LN9@fnFindNext:

; 1433 :       }
; 1434 : 
; 1435 :       // If the child was not joined, skip it.
; 1436 :       if ( (pchEntityJoinTable[ (*plpChildEntity)->nHierNbr ] &
; 1437 :                                        zSELECT_JOINEDWITHPARENT) == 0 )

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _pchEntityJoinTable$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	and	ecx, 1
	jne	$LN11@fnFindNext

; 1438 :       {
; 1439 :          zSHORT nLevel;
; 1440 : 
; 1441 :          // This entity was not joined so skip it.  We also want to skip all
; 1442 :          // its children.
; 1443 :          if ( (*plpChildEntity)->hNextSibling )

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+247], 0
	je	SHORT $LN12@fnFindNext

; 1444 :          {
; 1445 :             (*plpChildEntity) = zGETPTR( (*plpChildEntity)->hNextSibling );

	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+247]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [ecx], eax

; 1446 :             continue;

	jmp	SHORT $LN2@fnFindNext
$LN12@fnFindNext:

; 1447 :          }
; 1448 : 
; 1449 :          // (*plpChildEntity) has no siblings.  Find the next entity by trolling
; 1450 :          // through the children hierachically.
; 1451 :          nLevel = (*plpChildEntity)->nLevel;

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cx, WORD PTR [eax+215]
	mov	WORD PTR _nLevel$1[ebp], cx
$LN4@fnFindNext:

; 1452 :          while ( (*plpChildEntity) && (*plpChildEntity)->nLevel >= nLevel )

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN5@fnFindNext
	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	movsx	edx, WORD PTR [ecx+215]
	movsx	eax, WORD PTR _nLevel$1[ebp]
	cmp	edx, eax
	jl	SHORT $LN5@fnFindNext
$LN6@fnFindNext:

; 1453 :          {
; 1454 :             while ( (*plpChildEntity)->hNextSibling )

	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+247], 0
	je	SHORT $LN7@fnFindNext

; 1455 :                (*plpChildEntity) = zGETPTR( (*plpChildEntity)->hNextSibling );

	mov	eax, DWORD PTR _plpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+247]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	ecx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN6@fnFindNext
$LN7@fnFindNext:

; 1456 : 
; 1457 :             (*plpChildEntity) = zGETPTR( (*plpChildEntity)->hNextHier );

	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	edx, DWORD PTR _plpChildEntity$[ebp]
	mov	DWORD PTR [edx], eax

; 1458 :          }

	jmp	SHORT $LN4@fnFindNext
$LN5@fnFindNext:

; 1459 : 
; 1460 :          continue;

	jmp	$LN2@fnFindNext
$LN11@fnFindNext:

; 1461 :       }
; 1462 : 
; 1463 :       // If we get here then we've found what we're looking for.
; 1464 :       return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@fnFindNext

; 1465 :    }

	jmp	$LN2@fnFindNext
$LN3@fnFindNext:

; 1466 : 
; 1467 :    // If we get here then *plpChildEntity must be 0 so return FALSE.
; 1468 :    return( FALSE );

	xor	al, al
$LN1@fnFindNext:

; 1469 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnFindNextJoinedChild@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpConnection$ = 8					; size = 4
_fnCancelQuery PROC

; 1413 : {

	push	ebp
	mov	ebp, esp

; 1414 :    return;
; 1415 : }

	pop	ebp
	ret	0
_fnCancelQuery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_nReturnCode$ = -12					; size = 2
_nRC$ = -8						; size = 2
_k$ = -4						; size = 2
_Indicators$ = 8					; size = 4
_lpConnection$ = 12					; size = 4
_RollbackTransaction PROC

; 1322 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1323 :    zSHORT k;
; 1324 :    zSHORT nReturnCode = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnCode$[ebp], ax

; 1325 :    zSHORT nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 1326 : 
; 1327 :    if ( lpConnection == 0 )

	cmp	DWORD PTR _lpConnection$[ebp], 0
	jne	SHORT $LN5@RollbackTr

; 1328 :    {
; 1329 :       TraceLineS( "lpConnection is null!!!!!!", "" );

	push	OFFSET $SG94836
	push	OFFSET $SG94837
	call	_TraceLineS@8

; 1330 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@RollbackTr
$LN5@RollbackTr:

; 1331 :    }
; 1332 : 
; 1333 :    if ( lpConnection->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	test	eax, eax
	jle	SHORT $LN6@RollbackTr

; 1334 :    {
; 1335 :       TraceLineS( "####################################################", "" );

	push	OFFSET $SG94839
	push	OFFSET $SG94840
	call	_TraceLineS@8

; 1336 :       TraceLineS( "################ ROLLBACK TRANSACTION ##############", "" );

	push	OFFSET $SG94841
	push	OFFSET $SG94842
	call	_TraceLineS@8

; 1337 :       TraceLineS( "####################################################", "" );

	push	OFFSET $SG94843
	push	OFFSET $SG94844
	call	_TraceLineS@8
$LN6@RollbackTr:

; 1338 :    }
; 1339 : 
; 1340 :    // Free up qual data.
; 1341 :    for ( k = 0; k < lpConnection->nQualCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@RollbackTr
$LN2@RollbackTr:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN4@RollbackTr:
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+188]
	cmp	eax, edx
	jge	SHORT $LN3@RollbackTr

; 1342 :       SqlFreeQualEntity( &lpConnection->lpQualEntityList[ k ] );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4+108]
	push	edx
	call	_SqlFreeQualEntity@4
	jmp	SHORT $LN2@RollbackTr
$LN3@RollbackTr:

; 1343 :    lpConnection->nQualCount = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	WORD PTR [ecx+188], ax

; 1344 : 
; 1345 :    //==============================================================
; 1346 :    //
; 1347 :    // Transaction Rollback code.
; 1348 :    //
; 1349 :    //==============================================================
; 1350 : 
; 1351 : #if defined( DB2 )
; 1352 : 
; 1353 : {
; 1354 :    LPOD_LIST lpOD;
; 1355 : 
; 1356 :    for ( lpOD = lpConnection->lpFirstOD_List;
; 1357 :          lpOD;
; 1358 :          lpOD = lpOD->lpNextOD )
; 1359 :    {
; 1360 :       if ( lpOD->bNeedsCommit == FALSE )
; 1361 :          continue;
; 1362 : 
; 1363 :       if ( lpOD->pfnRollback == 0 )
; 1364 :       {
; 1365 :          zCHAR szProcName[ 100 ];
; 1366 : 
; 1367 :          zsprintf( szProcName, "%s_Rollback", lpOD->lpViewOD->szName );
; 1368 :          lpOD->pfnRollback = SysGetProc( lpOD->hStaticLibrary, szProcName );
; 1369 :       }
; 1370 : 
; 1371 :       nRC = (*lpOD->pfnRollback)( lpConnection->nTraceLevel );
; 1372 :       lpOD->bNeedsCommit = FALSE;
; 1373 :    }
; 1374 : 
; 1375 :    if ( lpConnection->hstmt )
; 1376 :    {
; 1377 :       fnFreeStmtHandles( lpConnection );
; 1378 : 
; 1379 :       nRC = SQLTransact( lpConnection->henv, lpConnection->hdbc, SQL_ROLLBACK );
; 1380 :       SQL_RC( "SQLEndTran", nRC, "Rollback DB ", 0, 1 );
; 1381 : 
; 1382 :       if ( nRC != SQL_SUCCESS )
; 1383 :          nReturnCode = zCALL_ERROR;
; 1384 :    }
; 1385 : }
; 1386 : 
; 1387 : #elif defined( ODBC )
; 1388 : 
; 1389 :    nRC = SQLEndTran( SQL_HANDLE_DBC, lpConnection->hdbc, SQL_ROLLBACK );

	push	1
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2808]
	push	eax
	push	2
	call	_SQLEndTran@12
	mov	WORD PTR _nRC$[ebp], ax

; 1390 :    SQL_RC( "SQLEndTran", nRC, "Rollback DB ", 0, 1 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	1
	push	0
	push	OFFSET $SG94845
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG94846
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1391 : 
; 1392 :    if ( nRC != SQL_SUCCESS )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN7@RollbackTr

; 1393 :       nReturnCode = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN7@RollbackTr:

; 1394 : 
; 1395 :    fnFreeStmtHandles( lpConnection );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	call	_fnFreeStmtHandles
	add	esp, 4

; 1396 : 
; 1397 : #endif
; 1398 : 
; 1399 :    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
$LN1@RollbackTr:

; 1400 : 
; 1401 : }  /* RollbackTransaction */

	mov	esp, ebp
	pop	ebp
	ret	0
_RollbackTransaction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_nReturnCode$ = -12					; size = 2
_nRC$ = -8						; size = 2
_k$ = -4						; size = 2
_lpView$ = 8						; size = 4
_Indicators$ = 12					; size = 4
_lpConnection$ = 16					; size = 4
_CommitTransaction PROC

; 1205 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1206 :    zSHORT k;
; 1207 :    zSHORT nReturnCode = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnCode$[ebp], ax

; 1208 :    zSHORT nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 1209 : 
; 1210 :    // Do any object ordering as necessary.
; 1211 :    if ( Indicators & DBH_LoadOI )

	mov	edx, DWORD PTR _Indicators$[ebp]
	and	edx, 1
	je	SHORT $LN5@CommitTran

; 1212 :       OrderOI_ByDefaultAttribs( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_OrderOI_ByDefaultAttribs@4
$LN5@CommitTran:

; 1213 : 
; 1214 :    if ( lpConnection == 0 )

	cmp	DWORD PTR _lpConnection$[ebp], 0
	jne	SHORT $LN6@CommitTran

; 1215 :    {
; 1216 :       TraceLineS( "lpConnection is null!!!!!!", "" );

	push	OFFSET $SG94809
	push	OFFSET $SG94810
	call	_TraceLineS@8

; 1217 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CommitTran
$LN6@CommitTran:

; 1218 :    }
; 1219 : 
; 1220 :    if ( lpConnection->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	test	edx, edx
	jle	SHORT $LN7@CommitTran

; 1221 :    {
; 1222 :       TraceLineS( "####################################################", "" );

	push	OFFSET $SG94812
	push	OFFSET $SG94813
	call	_TraceLineS@8

; 1223 :       TraceLineS( "#################  COMMIT TRANSACTION ##############", "" );

	push	OFFSET $SG94814
	push	OFFSET $SG94815
	call	_TraceLineS@8

; 1224 :       TraceLineS( "####################################################", "" );

	push	OFFSET $SG94816
	push	OFFSET $SG94817
	call	_TraceLineS@8
$LN7@CommitTran:

; 1225 :    }
; 1226 : 
; 1227 :    // Free up qual data.
; 1228 :    for ( k = 0; k < lpConnection->nQualCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@CommitTran
$LN2@CommitTran:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@CommitTran:
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+188]
	cmp	edx, ecx
	jge	SHORT $LN3@CommitTran

; 1229 :       SqlFreeQualEntity( &lpConnection->lpQualEntityList[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+108]
	push	ecx
	call	_SqlFreeQualEntity@4
	jmp	SHORT $LN2@CommitTran
$LN3@CommitTran:

; 1230 : 
; 1231 :    lpConnection->nQualCount = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	WORD PTR [eax+188], dx

; 1232 : 
; 1233 : #if 0 // Following not needed...yet.
; 1234 :    for ( k = 0; k < lpConnection->nOpenDatabaseCount; k++ )
; 1235 :    {
; 1236 :       if ( lpConnection->DBConnection[ k ].bDBUpdated )
; 1237 :       {
; 1238 :       }
; 1239 :    }
; 1240 : #endif
; 1241 : 
; 1242 :    //==============================================================
; 1243 :    //
; 1244 :    // Transaction Commit code.
; 1245 :    //
; 1246 :    //==============================================================
; 1247 : 
; 1248 : #if defined( DB2 )
; 1249 : 
; 1250 : {
; 1251 :    LPOD_LIST lpOD;
; 1252 : 
; 1253 :    for ( lpOD = lpConnection->lpFirstOD_List;
; 1254 :          lpOD;
; 1255 :          lpOD = lpOD->lpNextOD )
; 1256 :    {
; 1257 :       if ( lpOD->bNeedsCommit == FALSE )
; 1258 :          continue;
; 1259 : 
; 1260 :       if ( lpOD->pfnCommit == 0 )
; 1261 :       {
; 1262 :          zCHAR szProcName[ 100 ];
; 1263 : 
; 1264 :          zsprintf( szProcName, "%s_Commit", lpOD->lpViewOD->szName );
; 1265 :          lpOD->pfnCommit = SysGetProc( lpOD->hStaticLibrary, szProcName );
; 1266 :       }
; 1267 : 
; 1268 :       nRC = (*lpOD->pfnCommit)( lpConnection->nTraceLevel );
; 1269 :       lpOD->bNeedsCommit = FALSE;
; 1270 :    }
; 1271 : 
; 1272 :    if ( lpConnection->hstmt )
; 1273 :    {
; 1274 :       fnFreeStmtHandles( lpConnection );
; 1275 : 
; 1276 :       nRC = SQLTransact( lpConnection->henv, lpConnection->hdbc, SQL_ROLLBACK );
; 1277 :       SQL_RC( "SQLEndTran", nRC, "Rollback DB ", 0, 1 );
; 1278 : 
; 1279 :       if ( nRC != SQL_SUCCESS )
; 1280 :          nReturnCode = zCALL_ERROR;
; 1281 :    }
; 1282 : }
; 1283 : 
; 1284 : #elif defined( ODBC )
; 1285 : 
; 1286 :    // If the current transaction has changed the database, we may need to set
; 1287 :    // some flags so subsequent activates have a chance to reflect the changes.
; 1288 :    if ( lpConnection->bDatabaseChanged &&

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+800]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN8@CommitTran
	mov	eax, DWORD PTR _g_lpOdbcSystemInfo
	cmp	DWORD PTR [eax+8], 0
	jbe	SHORT $LN8@CommitTran

; 1289 :         g_lpOdbcSystemInfo->lCommitLatency > 0 )
; 1290 :    {
; 1291 :       g_lpOdbcSystemInfo->lLastCommitTask = SysGetTaskFromView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysGetTaskFromView@4
	mov	edx, DWORD PTR _g_lpOdbcSystemInfo
	mov	DWORD PTR [edx], eax

; 1292 :       g_lpOdbcSystemInfo->lLastCommitTime = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	ecx, DWORD PTR _g_lpOdbcSystemInfo
	mov	DWORD PTR [ecx+4], eax
$LN8@CommitTran:

; 1293 :    }
; 1294 : 
; 1295 :    nRC = SQLEndTran( SQL_HANDLE_DBC, lpConnection->hdbc, SQL_COMMIT );

	push	0
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2808]
	push	eax
	push	2
	call	_SQLEndTran@12
	mov	WORD PTR _nRC$[ebp], ax

; 1296 :    SQL_RC( "SQLEndTran", nRC, "Commit DB ", 0, 1 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	1
	push	0
	push	OFFSET $SG94819
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG94820
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1297 : 
; 1298 :    if ( nRC != SQL_SUCCESS )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN9@CommitTran

; 1299 :       nReturnCode = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN9@CommitTran:

; 1300 : 
; 1301 :    fnFreeStmtHandles( lpConnection );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	call	_fnFreeStmtHandles
	add	esp, 4

; 1302 : 
; 1303 : #endif
; 1304 : 
; 1305 :    if ( lpConnection->vDbhWork )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN10@CommitTran

; 1306 :    {
; 1307 :       DropView( lpConnection->vDbhWork );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	_DropView@4

; 1308 :       lpConnection->vDbhWork = 0;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN10@CommitTran:

; 1309 :    }
; 1310 : 
; 1311 :    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
$LN1@CommitTran:

; 1312 : 
; 1313 : }  /* CommitTransaction */

	mov	esp, ebp
	pop	ebp
	ret	0
_CommitTransaction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
tv152 = -16						; size = 4
_lWait$1 = -12						; size = 4
_ulTimeSinceLastCommit$2 = -8				; size = 4
_k$3 = -4						; size = 2
_Indicators$ = 8					; size = 4
_lpViewOD$ = 12						; size = 4
_lpView$ = 16						; size = 4
_lpQualView$ = 20					; size = 4
_lpConnection$ = 24					; size = 4
_BeginTransaction PROC

; 1090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1091 :    if ( lpConnection->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	test	ecx, ecx
	jle	$LN5@BeginTrans

; 1092 :    {
; 1093 :       zSHORT  k;
; 1094 : 
; 1095 :       TraceLineS( "####################################################", "" );

	push	OFFSET $SG94776
	push	OFFSET $SG94777
	call	_TraceLineS@8

; 1096 :       TraceLineS( "##################  BEGIN TRANSACTION ##############", "" );

	push	OFFSET $SG94778
	push	OFFSET $SG94779
	call	_TraceLineS@8

; 1097 :       TraceLineS( "####################################################", "" );

	push	OFFSET $SG94780
	push	OFFSET $SG94781
	call	_TraceLineS@8

; 1098 :       if ( Indicators == ( Indicators & DBH_StoreOI ) )

	mov	edx, DWORD PTR _Indicators$[ebp]
	and	edx, 2
	cmp	DWORD PTR _Indicators$[ebp], edx
	jne	SHORT $LN6@BeginTrans

; 1099 :          TraceLineS( "Storing Objects", "" );

	push	OFFSET $SG94784
	push	OFFSET $SG94785
	call	_TraceLineS@8
	jmp	SHORT $LN7@BeginTrans
$LN6@BeginTrans:

; 1100 :       else
; 1101 :          TraceLineS( "Activating Object Def ", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG94786
	call	_TraceLineS@8
$LN7@BeginTrans:

; 1102 : 
; 1103 :       for ( k = 0; k < lpConnection->nOpenDatabaseCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$3[ebp], cx
	jmp	SHORT $LN4@BeginTrans
$LN2@BeginTrans:
	mov	dx, WORD PTR _k$3[ebp]
	add	dx, 1
	mov	WORD PTR _k$3[ebp], dx
$LN4@BeginTrans:
	movsx	eax, WORD PTR _k$3[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+216]
	cmp	eax, edx
	jge	SHORT $LN5@BeginTrans

; 1104 :          TraceLineS( "Database name = ",

	movsx	eax, WORD PTR _k$3[ebp]
	imul	ecx, eax, 58
	mov	edx, DWORD PTR _lpConnection$[ebp]
	lea	eax, DWORD PTR [edx+ecx+220]
	push	eax
	push	OFFSET $SG94787
	call	_TraceLineS@8
	jmp	SHORT $LN2@BeginTrans
$LN5@BeginTrans:

; 1105 :                      lpConnection->DBConnection[ k ].szDatabaseName );
; 1106 : 
; 1107 :    }
; 1108 : 
; 1109 : #if 0  // Following not needed yet but could be someday.
; 1110 :    // Check to see if multiple databases are used.
; 1111 :    lpConnection->bMultipleDatabases = FALSE;
; 1112 :    lpViewEntity = lpViewOD->hFirstOD_Entity;
; 1113 :    while ( lpViewEntity )
; 1114 :    {
; 1115 :       if ( lpViewEntity->szDBName[ 0 ] )
; 1116 :          lpConnection->bMultipleDatabases = TRUE;
; 1117 : 
; 1118 :       lpViewEntity = lpViewEntity->hNextHier;
; 1119 :    }
; 1120 : #endif
; 1121 : 
; 1122 :    //==============================================================
; 1123 :    //
; 1124 :    // Transaction Begin code.
; 1125 :    //
; 1126 :    //==============================================================
; 1127 : 
; 1128 :    // Indicate that the database has not yet been changed by this transaction.
; 1129 :    lpConnection->bDatabaseChanged = FALSE;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+800]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+800], edx

; 1130 : 
; 1131 : #if defined ( DB2 )
; 1132 :    /* if we have DB2, determine the decimal "comma or point"
; 1133 :     *  switch in zeidon.ini .
; 1134 :     *  Comma is indicated by "DB2COMMA=Y"
; 1135 :     */
; 1136 :    if ( g_ucDB2_Comma == 0 )
; 1137 :    {
; 1138 :       zCHAR szValue[ 256 ] ;
; 1139 : 
; 1140 :       szValue[ 0 ] = 0;
; 1141 :       SysReadZeidonIni( -1, "[Zeidon]", "DB2COMMA", szValue );
; 1142 :       if( szValue[ 0 ] == 'Y' || szValue[ 0 ] == 'y' ||
; 1143 :           szValue[ 0 ] == 'J' || szValue[ 0 ] == 'j' )
; 1144 :          g_ucDB2_Comma = 2;
; 1145 :       else
; 1146 :          g_ucDB2_Comma = 1;
; 1147 :    }
; 1148 : 
; 1149 : #elif defined( DUMMY )
; 1150 : 
; 1151 :    lpConnection->lIntegerCount = 1;
; 1152 :    lpConnection->lDecimalCount = 1;
; 1153 :    lpConnection->lStringCount  = 1;
; 1154 : 
; 1155 : #elif defined( ODBC )
; 1156 : 
; 1157 :    // For MS Access we need to wait a short bit of time if another task has
; 1158 :    // done a commit.  This gives a chance for the database changes to be
; 1159 :    // seen by other tasks.
; 1160 :    if ( g_lpOdbcSystemInfo->lCommitLatency > 0   &&  // If 0 we don't need to wait
; 1161 :         g_lpOdbcSystemInfo->lLastCommitTask != 0 &&  // 0 means nothing committed yet
; 1162 :         (Indicators & DBH_LoadOI ) != 0          &&  // Only wait before Activate

	mov	ecx, DWORD PTR _g_lpOdbcSystemInfo
	cmp	DWORD PTR [ecx+8], 0
	jbe	SHORT $LN8@BeginTrans
	mov	edx, DWORD PTR _g_lpOdbcSystemInfo
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN8@BeginTrans
	mov	eax, DWORD PTR _Indicators$[ebp]
	and	eax, 1
	je	SHORT $LN8@BeginTrans
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysGetTaskFromView@4
	mov	edx, DWORD PTR _g_lpOdbcSystemInfo
	cmp	DWORD PTR [edx], eax
	je	SHORT $LN8@BeginTrans

; 1163 :         g_lpOdbcSystemInfo->lLastCommitTask !=
; 1164 :               SysGetTaskFromView( lpView ) ) // Don't need to wait for current task.
; 1165 :    {
; 1166 :       zULONG ulTimeSinceLastCommit = SysGetTickCount( ) -

	call	_SysGetTickCount@0
	mov	ecx, DWORD PTR _g_lpOdbcSystemInfo
	sub	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR _ulTimeSinceLastCommit$2[ebp], eax

; 1167 :                                           g_lpOdbcSystemInfo->lLastCommitTime;
; 1168 : 
; 1169 :       if ( ulTimeSinceLastCommit < g_lpOdbcSystemInfo->lCommitLatency )

	mov	edx, DWORD PTR _g_lpOdbcSystemInfo
	mov	eax, DWORD PTR _ulTimeSinceLastCommit$2[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	SHORT $LN8@BeginTrans

; 1170 :       {
; 1171 :          zULONG lWait;
; 1172 : 
; 1173 : 
; 1174 :          lWait = g_lpOdbcSystemInfo->lCommitLatency - ulTimeSinceLastCommit;

	mov	ecx, DWORD PTR _g_lpOdbcSystemInfo
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, DWORD PTR _ulTimeSinceLastCommit$2[ebp]
	mov	DWORD PTR _lWait$1[ebp], edx

; 1175 :          if ( lpConnection->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	test	ecx, ecx
	jle	SHORT $LN10@BeginTrans

; 1176 :             TraceLineI( "ODBC Latency...waiting... milliseconds = ", lWait );

	mov	edx, DWORD PTR _lWait$1[ebp]
	push	edx
	push	OFFSET $SG94791
	call	_TraceLineI@8
$LN10@BeginTrans:

; 1177 : 
; 1178 :          SysWait( (zUSHORT) lWait );

	movzx	eax, WORD PTR _lWait$1[ebp]
	push	eax
	call	_SysWait@4
$LN8@BeginTrans:

; 1179 :       }
; 1180 :    }
; 1181 : 
; 1182 : #endif
; 1183 : 
; 1184 :    fnClearDBHandlerError( lpQualView ? lpQualView : lpView );

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $LN13@BeginTrans
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	mov	DWORD PTR tv152[ebp], ecx
	jmp	SHORT $LN14@BeginTrans
$LN13@BeginTrans:
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR tv152[ebp], edx
$LN14@BeginTrans:
	mov	eax, DWORD PTR tv152[ebp]
	push	eax
	call	_fnClearDBHandlerError@4

; 1185 : 
; 1186 :    if ( lpConnection->vDbhWork )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	je	SHORT $LN11@BeginTrans

; 1187 :    {
; 1188 :       DropView( lpConnection->vDbhWork );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	_DropView@4

; 1189 :       lpConnection->vDbhWork = 0;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+24], 0
$LN11@BeginTrans:

; 1190 :    }
; 1191 : 
; 1192 :    return( 0 );

	xor	eax, eax

; 1193 : 
; 1194 : }  /* BeginTransaction */

	mov	esp, ebp
	pop	ebp
	ret	0
_BeginTransaction ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_pch$1 = -620						; size = 4
_hTask$ = -616						; size = 4
$T2 = -612						; size = 4
_nLth$3 = -608						; size = 2
_nRC2$ = -604						; size = 2
_szStr$ = -600						; size = 2
_vDbhWork$ = -596					; size = 4
_lpConnection$ = -592					; size = 4
_nRC$ = -588						; size = 2
_k$4 = -584						; size = 2
_szMsg$5 = -580						; size = 256
_szMsg$6 = -324						; size = 256
_szLogicalName$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_Indicators$ = 12					; size = 4
_CloseDatabase PROC

; 881  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 620				; 0000026cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 882  :    LPCONNECTION lpConnection;
; 883  :    zCHAR        szLogicalName[ 64 ];
; 884  :    zCHAR        szStr[ 2 ];
; 885  :    zVIEW        vDbhWork;
; 886  :    LPTASK       hTask;
; 887  : // zLONG        lProcessID;
; 888  :    zSHORT       nRC2 = 0;

	xor	eax, eax
	mov	WORD PTR _nRC2$[ebp], ax

; 889  :    zSHORT       nRC;
; 890  : 
; 891  :    GetViewByName( &vDbhWork, zDBHANDLER_WORK_VIEW_NAME, lpView, zLEVEL_SYSTEM );

	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG94714
	lea	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_GetViewByName@16

; 892  :    if ( vDbhWork == 0 )

	cmp	DWORD PTR _vDbhWork$[ebp], 0
	jne	SHORT $LN10@CloseDatab

; 893  :    {
; 894  :       DBH_Error( lpView, "Can't find DB-Handler work view.", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG94716
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_DBH_Error
	add	esp, 16					; 00000010H

; 895  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN19@CloseDatab
$LN10@CloseDatab:

; 896  :    }
; 897  : 
; 898  :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN11@CloseDatab

; 899  :       lpView = vDbhWork;

	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	mov	DWORD PTR _lpView$[ebp], ecx
$LN11@CloseDatab:

; 900  : 
; 901  :    SysMutexLock( lpView, "Zeidon DBH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG94718
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMutexLock@16

; 902  : 
; 903  :    szStr[ 0 ] = zSQL_type;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szStr$[ebp+ecx], 79		; 0000004fH

; 904  :    szStr[ 1 ] = 0;

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 2
	jae	SHORT $LN20@CloseDatab
	jmp	SHORT $LN21@CloseDatab
$LN20@CloseDatab:
	call	___report_rangecheckfailure
$LN21@CloseDatab:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szStr$[ebp+edx], 0

; 905  : 
; 906  :    nRC = SetCursorFirstEntityByString( vDbhWork, "Type", "Type", szStr, "" );

	push	OFFSET $SG94719
	lea	eax, DWORD PTR _szStr$[ebp]
	push	eax
	push	OFFSET $SG94720
	push	OFFSET $SG94721
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax

; 907  :    if ( nRC != zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN12@CloseDatab

; 908  :    {
; 909  :       zCHAR szMsg[ 256 ];
; 910  : 
; 911  :       SysMutexUnlock( lpView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG94723
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMutexUnlock@12

; 912  :       zsprintf( szMsg,

	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	push	OFFSET $SG94724
	lea	edx, DWORD PTR _szMsg$6[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 913  :                 "Internal error -- cannot find DB Base type (%s) in db-handler work object.",
; 914  :                 szStr );
; 915  :       DBH_Error( vDbhWork, szMsg, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _szMsg$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_DBH_Error
	add	esp, 16					; 00000010H

; 916  :       DropView( vDbhWork );

	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_DropView@4

; 917  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN19@CloseDatab
$LN12@CloseDatab:

; 918  :    }
; 919  : 
; 920  :    hTask = (LPTASK) SysGetTaskFromView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysGetTaskFromView@4
	mov	DWORD PTR _hTask$[ebp], eax

; 921  :    zsprintf( szLogicalName, "0x%08x:%08x", hTask, SysGetProcessID( 0 ) );

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	ecx, DWORD PTR _hTask$[ebp]
	push	ecx
	push	OFFSET $SG94725
	lea	edx, DWORD PTR _szLogicalName$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 922  :    nRC = SetCursorFirstEntityByString( vDbhWork, "Connection",

	push	OFFSET $SG94726
	lea	eax, DWORD PTR _szLogicalName$[ebp]
	push	eax
	push	OFFSET $SG94727
	push	OFFSET $SG94728
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax

; 923  :                                        "LogicalUserName", szLogicalName, "" );
; 924  :    if ( nRC != zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	$LN13@CloseDatab

; 925  :    {
; 926  :       zPCHAR pch;
; 927  :       zSHORT nLth = zstrlen( szLogicalName );

	lea	eax, DWORD PTR _szLogicalName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$3[ebp], ax

; 928  : 
; 929  :       nRC = SetCursorFirstEntity( vDbhWork, "Connection", 0 );

	push	0
	push	OFFSET $SG94730
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN2@CloseDatab:

; 930  :       while ( nRC >= zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN13@CloseDatab

; 931  :       {
; 932  :          GetAddrForAttribute( &pch, vDbhWork, "Connection", "LogicalUserName" );

	push	OFFSET $SG94731
	push	OFFSET $SG94732
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pch$1[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 933  :          if ( zstrncmp( szLogicalName, pch, nLth ) == 0 )

	movsx	edx, WORD PTR _nLth$3[ebp]
	push	edx
	mov	eax, DWORD PTR _pch$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _szLogicalName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@CloseDatab

; 934  :             break;

	jmp	SHORT $LN13@CloseDatab
$LN14@CloseDatab:

; 935  : 
; 936  :          nRC = SetCursorNextEntity( vDbhWork, "Connection", 0 );

	push	0
	push	OFFSET $SG94734
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 937  :       }

	jmp	SHORT $LN2@CloseDatab
$LN13@CloseDatab:

; 938  :    }
; 939  : 
; 940  :    if ( nRC != zCURSOR_SET )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN15@CloseDatab

; 941  :    {
; 942  :       zCHAR szMsg[ 256 ];
; 943  : 
; 944  :       SysMutexUnlock( lpView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG94736
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMutexUnlock@12

; 945  :       zsprintf( szMsg,

	lea	edx, DWORD PTR _szLogicalName$[ebp]
	push	edx
	push	OFFSET $SG94737
	lea	eax, DWORD PTR _szMsg$5[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 946  :                 "TaskID not found for Task:TaskID %s",
; 947  :                 szLogicalName );
; 948  : 
; 949  :       TraceLineS( "ERROR ********** CloseDatabase ", szMsg );

	lea	ecx, DWORD PTR _szMsg$5[ebp]
	push	ecx
	push	OFFSET $SG94738
	call	_TraceLineS@8

; 950  :       DisplayObjectInstance( vDbhWork, 0, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_DisplayObjectInstance@12

; 951  :       TraceLineS( "", "" );

	push	OFFSET $SG94739
	push	OFFSET $SG94740
	call	_TraceLineS@8

; 952  :       // Removing this message since we were getting it when all tasks have
; 953  :       // been deleted.  dks/don 2007.01.05
; 954  :    // MessageBox( 0, szMsg, "CloseDatabase Error", MB_OK );
; 955  :       return( 0 );

	xor	eax, eax
	jmp	$LN19@CloseDatab
$LN15@CloseDatab:

; 956  :    }
; 957  : 
; 958  :    GetAddrForAttribute( (zPVOID) &lpConnection, vDbhWork,

	push	OFFSET $SG94741
	push	OFFSET $SG94742
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 959  :                         "Connection", "ConnectionBlob" );
; 960  :    if ( lpConnection )

	cmp	DWORD PTR _lpConnection$[ebp], 0
	je	$LN16@CloseDatab

; 961  :    {
; 962  :       zSHORT k;
; 963  : 
; 964  :       // Free connection memory (last parm zero).
; 965  :       fnAllocateConnectionMemory( lpView, lpConnection, TRUE, 0 );

	push	0
	push	1
	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAllocateConnectionMemory@16

; 966  :       fnAllocateConnectionMemory( lpView, lpConnection, FALSE, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnAllocateConnectionMemory@16

; 967  : 
; 968  :       // Free up qual data.
; 969  :       for ( k = 0; k < lpConnection->nQualCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$4[ebp], ax
	jmp	SHORT $LN6@CloseDatab
$LN4@CloseDatab:
	mov	cx, WORD PTR _k$4[ebp]
	add	cx, 1
	mov	WORD PTR _k$4[ebp], cx
$LN6@CloseDatab:
	movsx	edx, WORD PTR _k$4[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+188]
	cmp	edx, ecx
	jge	SHORT $LN5@CloseDatab

; 970  :          SqlFreeQualEntity( &lpConnection->lpQualEntityList[ k ] );

	movsx	edx, WORD PTR _k$4[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4+108]
	push	ecx
	call	_SqlFreeQualEntity@4
	jmp	SHORT $LN4@CloseDatab
$LN5@CloseDatab:

; 971  : 
; 972  :       lpConnection->nQualCount = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	WORD PTR [eax+188], dx

; 973  : 
; 974  :       // Only perform the disconnect if there was a valid connection.
; 975  :       for ( k = 0; k < lpConnection->nOpenDatabaseCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$4[ebp], cx
	jmp	SHORT $LN9@CloseDatab
$LN7@CloseDatab:
	mov	dx, WORD PTR _k$4[ebp]
	add	dx, 1
	mov	WORD PTR _k$4[ebp], dx
$LN9@CloseDatab:
	movsx	eax, WORD PTR _k$4[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+216]
	cmp	eax, edx
	jge	$LN8@CloseDatab

; 976  :       {
; 977  :          if ( lpConnection->DBConnection[ k ].bValidConnection == FALSE )

	movsx	eax, WORD PTR _k$4[ebp]
	imul	ecx, eax, 58
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+ecx+270]
	and	eax, 1
	jne	SHORT $LN17@CloseDatab

; 978  :             continue;

	jmp	SHORT $LN7@CloseDatab
$LN17@CloseDatab:

; 979  : 
; 980  :          // DB disconnect routines.
; 981  : 
; 982  : #if defined( DB2 )
; 983  : 
; 984  :          nRC = SQLDisconnect( lpConnection->DBConnection[ k ].hdbc );
; 985  :          SQL_RC( "SQLDisconnect", nRC, "Disconnecting handle for database ",
; 986  :                  lpConnection->DBConnection[ k ].szDatabaseName, 2 );
; 987  : 
; 988  :          nRC = SQLFreeHandle( SQL_HANDLE_DBC,
; 989  :                           (SQLHANDLE) lpConnection->DBConnection[ k ].hdbc );
; 990  : 
; 991  :          SQL_RC( "SQLFreeHandle", nRC, "Closing handle for database ",
; 992  :                  lpConnection->DBConnection[ k ].szDatabaseName, 2 );
; 993  :          if ( nRC != SQL_SUCCESS )
; 994  :             nRC = zCALL_ERROR;
; 995  : 
; 996  : #elif defined( ODBC )
; 997  : 
; 998  :          nRC = SQLDisconnect( lpConnection->DBConnection[ k ].hdbc );

	movsx	ecx, WORD PTR _k$4[ebp]
	imul	edx, ecx, 58
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+edx+274]
	push	ecx
	call	_SQLDisconnect@4
	mov	WORD PTR _nRC$[ebp], ax

; 999  :          SQL_RC( "SQLDisconnect", nRC, "Disconnecting handle for database ",

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	movsx	eax, WORD PTR _k$4[ebp]
	imul	ecx, eax, 58
	mov	edx, DWORD PTR _lpConnection$[ebp]
	lea	eax, DWORD PTR [edx+ecx+220]
	push	eax
	push	OFFSET $SG94745
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG94746
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1000 :                  lpConnection->DBConnection[ k ].szDatabaseName, 2 );
; 1001 : 
; 1002 :          nRC = SQLFreeHandle( SQL_HANDLE_DBC,

	movsx	edx, WORD PTR _k$4[ebp]
	imul	eax, edx, 58
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+eax+274]
	push	edx
	push	2
	call	_SQLFreeHandle@8
	mov	WORD PTR _nRC$[ebp], ax

; 1003 :                           (SQLHANDLE) lpConnection->DBConnection[ k ].hdbc );
; 1004 :          SQL_RC( "SQLFreeHandle", nRC, "Closing handle for database ",

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	movsx	ecx, WORD PTR _k$4[ebp]
	imul	edx, ecx, 58
	mov	eax, DWORD PTR _lpConnection$[ebp]
	lea	ecx, DWORD PTR [eax+edx+220]
	push	ecx
	push	OFFSET $SG94747
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG94748
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1005 :                  lpConnection->DBConnection[ k ].szDatabaseName, 2 );
; 1006 :          if ( nRC != SQL_SUCCESS )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN18@CloseDatab

; 1007 :             nRC2 = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC2$[ebp], cx
$LN18@CloseDatab:

; 1008 : 
; 1009 : #endif
; 1010 : 
; 1011 :          lpConnection->DBConnection[ k ].bValidConnection = FALSE;

	movsx	edx, WORD PTR _k$4[ebp]
	imul	eax, edx, 58
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+eax+270]
	and	edx, -2					; fffffffeH
	movsx	eax, WORD PTR _k$4[ebp]
	imul	ecx, eax, 58
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+ecx+270], edx

; 1012 : 
; 1013 :       } // for ( k = 0; ... )

	jmp	$LN7@CloseDatab
$LN8@CloseDatab:

; 1014 : 
; 1015 :       //
; 1016 :       // Session disconnect routines.
; 1017 :       //
; 1018 : 
; 1019 : #if defined( DB2 )
; 1020 :    {
; 1021 :       LPOD_LIST lpOD;
; 1022 : 
; 1023 :       for ( lpOD = lpConnection->lpFirstOD_List;
; 1024 :             lpOD;
; 1025 :             lpOD = lpOD->lpNextOD )
; 1026 :       {
; 1027 :          if ( lpOD->bOpenConn )
; 1028 :          {
; 1029 : #if 0
; 1030 :             zSHORT (POPERATION pfnClose)( zSHORT );
; 1031 :             zCHAR  szFuncName[ 200 ];
; 1032 : 
; 1033 :             zsprintf( szFuncName, "%s_CloseConnection", lpOD->szOD_Name );
; 1034 :             pfnClose = SysGetProc( lpOD->hStaticLibrary, szFuncName );
; 1035 :             nRC = (*pfnClose) ( lpConnection->nTraceLevel );
; 1036 : #endif
; 1037 :             SysFreeLibrary( lpView, lpOD->hStaticLibrary );
; 1038 :          }
; 1039 :       }
; 1040 : 
; 1041 :       fnFreeOD_List( lpConnection );
; 1042 : 
; 1043 :       if ( lpConnection->henv )
; 1044 :       {
; 1045 :          nRC = SQLFreeHandle( SQL_HANDLE_ENV,
; 1046 :                               (SQLHANDLE) lpConnection->henv );
; 1047 :          SQL_RC( "SQLFreeHandle", nRC, "Closing henv", 0, 2 );
; 1048 :       }
; 1049 :    }
; 1050 : 
; 1051 : #elif defined( ODBC )
; 1052 : 
; 1053 :       nRC = SQLFreeHandle( SQL_HANDLE_ENV,

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2804]
	push	edx
	push	1
	call	_SQLFreeHandle@8
	mov	WORD PTR _nRC$[ebp], ax

; 1054 :                            (SQLHANDLE) lpConnection->henv );
; 1055 :       SQL_RC( "SQLFreeHandle", nRC, "Closing henv", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG94750
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG94751
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 1056 : 
; 1057 : #endif
; 1058 : 
; 1059 :       SfDropSubtask( lpConnection->lpAppView, 0 );

	push	0
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_SfDropSubtask@8
$LN16@CloseDatab:

; 1060 : 
; 1061 :    } // if ( lpConnection )...
; 1062 : 
; 1063 :    SetAttributeFromBlob( vDbhWork, "Connection", "ConnectionBlob", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG94752
	push	OFFSET $SG94753
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetAttributeFromBlob@20

; 1064 :    DeleteEntity( vDbhWork, "Connection", zREPOS_AFTER );  // blew on this line 2006.06.30 dks

	push	3
	push	OFFSET $SG94754
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_DeleteEntity@12

; 1065 : 
; 1066 : // TraceLineS( "After CloseDatabase for Task:TaskID ", szLogicalName );
; 1067 : // DisplayObjectInstance( vDbhWork, 0, 0 );
; 1068 : // TraceLineS( "", "" );
; 1069 : 
; 1070 :    SysMutexUnlock( lpView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG94755
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMutexUnlock@12

; 1071 : 
; 1072 :    return( nRC2 );

	mov	ax, WORD PTR _nRC2$[ebp]
$LN19@CloseDatab:

; 1073 : 
; 1074 : }  // CloseDatabase

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CloseDatabase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
$T1 = -548						; size = 4
_nRC$ = -544						; size = 2
tv171 = -540						; size = 4
_vDbhWork$ = -536					; size = 4
_szStr$ = -532						; size = 2
_OdbcSystemInfo$2 = -528				; size = 12
_szValue$3 = -516					; size = 256
_szValue$4 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_InitDatabase PROC

; 773  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 548				; 00000224H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 774  :    zCHAR        szStr[ 2 ];
; 775  :    zVIEW        vDbhWork;
; 776  :    zSHORT       nRC;
; 777  : 
; 778  :    static zBOOL bShowDateTime = TRUE;
; 779  : 
; 780  :    g_lCurrentProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _g_lCurrentProcessID, eax

; 781  : 
; 782  :    GetViewByName( &vDbhWork, zDBHANDLER_WORK_VIEW_NAME, lpView, zLEVEL_SYSTEM );

	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET $SG94654
	lea	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_GetViewByName@16

; 783  :    if ( vDbhWork == 0 )

	cmp	DWORD PTR _vDbhWork$[ebp], 0
	jne	SHORT $LN4@InitDataba

; 784  :    {
; 785  :       DBH_Error( lpView, "Can't find DB-Handler work view.", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG94656
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DBH_Error
	add	esp, 16					; 00000010H

; 786  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN11@InitDataba
$LN4@InitDataba:

; 787  :    }
; 788  : 
; 789  :    SysMutexLock( lpView, "Zeidon DBH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG94657
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMutexLock@16

; 790  : 
; 791  :    szStr[ 0 ] = zSQL_type;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szStr$[ebp+edx], 79		; 0000004fH

; 792  :    szStr[ 1 ] = 0;

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 2
	jae	SHORT $LN12@InitDataba
	jmp	SHORT $LN13@InitDataba
$LN12@InitDataba:
	call	___report_rangecheckfailure
$LN13@InitDataba:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szStr$[ebp+eax], 0

; 793  : 
; 794  :    nRC = SetCursorFirstEntityByString( vDbhWork, "Type", "Type", szStr, "" );

	push	OFFSET $SG94658
	lea	ecx, DWORD PTR _szStr$[ebp]
	push	ecx
	push	OFFSET $SG94659
	push	OFFSET $SG94660
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax

; 795  :    if ( nRC != zCURSOR_SET )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	$LN5@InitDataba

; 796  :    {
; 797  :       CreateEntity( vDbhWork, "Type", zPOS_AFTER );

	push	3
	push	OFFSET $SG94662
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_CreateEntity@12

; 798  :       SetAttributeFromString( vDbhWork, "Type", "Type", szStr );

	lea	edx, DWORD PTR _szStr$[ebp]
	push	edx
	push	OFFSET $SG94663
	push	OFFSET $SG94664
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 799  : 
; 800  :       // One-time-only DB initialization routines.
; 801  : #if defined( ODBC )
; 802  :       // Set up information shared by all ODBC tasks.
; 803  :       {
; 804  :          zCHAR            szValue[ 256 ] = "";

	mov	cl, BYTE PTR $SG94665
	mov	BYTE PTR _szValue$4[ebp], cl
	push	255					; 000000ffH
	push	0
	lea	edx, DWORD PTR _szValue$4[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 805  :          ODBC_SYSTEM_INFO OdbcSystemInfo = { 0 };

	mov	DWORD PTR _OdbcSystemInfo$2[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _OdbcSystemInfo$2[ebp+4], eax
	mov	DWORD PTR _OdbcSystemInfo$2[ebp+8], eax

; 806  : 
; 807  :          SysReadZeidonIni( -1, "[kzhsqloa]", "CommitLatency", szValue );

	lea	ecx, DWORD PTR _szValue$4[ebp]
	push	ecx
	push	OFFSET $SG94666
	push	OFFSET $SG94667
	push	-1
	call	_SysReadZeidonIni@16

; 808  :          OdbcSystemInfo.lCommitLatency = (zULONG) zatol( szValue );

	lea	edx, DWORD PTR _szValue$4[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _OdbcSystemInfo$2[ebp+8], eax

; 809  : 
; 810  :          SetAttributeFromBlob( vDbhWork, "Type", "TypeEnvBlob",

	push	12					; 0000000cH
	lea	eax, DWORD PTR _OdbcSystemInfo$2[ebp]
	push	eax
	push	OFFSET $SG94668
	push	OFFSET $SG94669
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetAttributeFromBlob@20
$LN5@InitDataba:

; 811  :                                &OdbcSystemInfo, sizeof( OdbcSystemInfo ) );
; 812  : 
; 813  :       }
; 814  : 
; 815  : #endif
; 816  :    }
; 817  : 
; 818  :    // Once-per-task initialization.
; 819  : #if defined( DB2 ) || defined( ODBC )
; 820  : 
; 821  :    if ( g_bHoldStmtHandles == 'X' )

	movzx	edx, BYTE PTR _g_bHoldStmtHandles
	cmp	edx, 88					; 00000058H
	jne	$LN6@InitDataba

; 822  :    {
; 823  :       zCHAR szValue[ 256 ] = "";

	mov	al, BYTE PTR $SG94671
	mov	BYTE PTR _szValue$3[ebp], al
	push	255					; 000000ffH
	push	0
	lea	ecx, DWORD PTR _szValue$3[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 824  : 
; 825  :       SysReadZeidonIni( -1, "[kzhsqloa]", "HoldStmtHandles", szValue );

	lea	edx, DWORD PTR _szValue$3[ebp]
	push	edx
	push	OFFSET $SG94672
	push	OFFSET $SG94673
	push	-1
	call	_SysReadZeidonIni@16

; 826  :       switch ( ztoupper( szValue[ 0 ] ) )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szValue$3[ebp+ecx]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	DWORD PTR tv171[ebp], eax
	mov	eax, DWORD PTR tv171[ebp]
	sub	eax, 48					; 00000030H
	mov	DWORD PTR tv171[ebp], eax
	cmp	DWORD PTR tv171[ebp], 41		; 00000029H
	ja	SHORT $LN9@InitDataba
	mov	ecx, DWORD PTR tv171[ebp]
	movzx	edx, BYTE PTR $LN14@InitDataba[ecx]
	jmp	DWORD PTR $LN15@InitDataba[edx*4]
$LN7@InitDataba:

; 827  :       {
; 828  :          case 'F':
; 829  :          case 'N':
; 830  :          case '0':
; 831  :             g_bHoldStmtHandles = FALSE;

	mov	BYTE PTR _g_bHoldStmtHandles, 0

; 832  :             break;

	jmp	SHORT $LN2@InitDataba
$LN8@InitDataba:

; 833  : 
; 834  :          case 'T':
; 835  :          case 'Y':
; 836  :          case '1':
; 837  :             g_bHoldStmtHandles = TRUE;

	mov	BYTE PTR _g_bHoldStmtHandles, 1

; 838  :             break;

	jmp	SHORT $LN2@InitDataba
$LN9@InitDataba:

; 839  : 
; 840  :          default:
; 841  :             // We'll default DB2 to off until we can fix the problems.
; 842  :             #if defined( DB2 )
; 843  :                g_bHoldStmtHandles = FALSE;
; 844  :             #else
; 845  :                g_bHoldStmtHandles = TRUE;

	mov	BYTE PTR _g_bHoldStmtHandles, 1
$LN2@InitDataba:

; 846  :             #endif
; 847  : 
; 848  :             break;
; 849  :       }
; 850  : 
; 851  :       #if defined( ODBC )
; 852  :          GetAddrForAttribute( (zCOREMEM) &g_lpOdbcSystemInfo,

	push	OFFSET $SG94677
	push	OFFSET $SG94678
	mov	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	push	OFFSET _g_lpOdbcSystemInfo
	call	_GetAddrForAttribute@16
$LN6@InitDataba:

; 853  :                               vDbhWork, "Type", "TypeEnvBlob" );
; 854  :       #endif
; 855  :    }
; 856  : 
; 857  : #endif
; 858  : 
; 859  :    SysMutexUnlock( lpView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG94679
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMutexUnlock@12

; 860  : 
; 861  :    if ( bShowDateTime )

	movzx	edx, BYTE PTR ?bShowDateTime@?1??InitDatabase@@9@9
	test	edx, edx
	je	SHORT $LN10@InitDataba

; 862  :    {
; 863  :       TraceLineS( "Compile date/time for " DBHANDLER_NAME " is ",

	push	OFFSET $SG94681
	push	OFFSET $SG94682
	call	_TraceLineS@8

; 864  :                   __DATE__ " " __TIME__ );
; 865  :       bShowDateTime = FALSE;

	mov	BYTE PTR ?bShowDateTime@?1??InitDatabase@@9@9, 0
$LN10@InitDataba:

; 866  :    }
; 867  : 
; 868  :    return( 0 );

	xor	eax, eax
$LN11@InitDataba:

; 869  : 
; 870  : }  /* InitDatabase */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN15@InitDataba:
	DD	$LN7@InitDataba
	DD	$LN8@InitDataba
	DD	$LN9@InitDataba
$LN14@InitDataba:
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_InitDatabase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpHandles$1 = -20					; size = 4
_lpStmtHandle$2 = -16					; size = 4
_nRC$ = -12						; size = 2
_k$ = -8						; size = 2
_j$ = -4						; size = 2
_lpConnection$ = 8					; size = 4
_fnFreeStmtHandles PROC

; 672  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 673  :    zSHORT k, j;
; 674  :    zSHORT nRC;
; 675  : 
; 676  :    if ( lpConnection->hGeneralStmt )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [eax+2816], 0
	je	SHORT $LN8@fnFreeStmt

; 677  :    {
; 678  : #if defined( DB2 )
; 679  :       nRC = SQLFreeHandle( SQL_HANDLE_STMT,
; 680  :                            (SQLHANDLE) lpConnection->hGeneralStmt );
; 681  :       SQL_RC( "SQLFreeHandle", nRC, "Closing stmt handle", 0, 2 );
; 682  : #else
; 683  :       nRC = SQLFreeHandle( SQL_HANDLE_STMT, lpConnection->hGeneralStmt );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2816]
	push	edx
	push	3
	call	_SQLFreeHandle@8
	mov	WORD PTR _nRC$[ebp], ax

; 684  :       SQL_RC( "SQLFreeHandle", nRC, "Closing stmt handle", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG94625
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG94626
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 685  : #endif
; 686  : 
; 687  :       lpConnection->hGeneralStmt = 0;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+2816], 0

; 688  :       lpConnection->hstmt = 0;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+2812], 0
$LN8@fnFreeStmt:

; 689  :    }
; 690  : 
; 691  :    // If we're not using multiple handles then there's nothing else to free.
; 692  :    if ( g_bHoldStmtHandles == FALSE )

	movzx	ecx, BYTE PTR _g_bHoldStmtHandles
	test	ecx, ecx
	jne	SHORT $LN9@fnFreeStmt

; 693  :       return;

	jmp	$LN1@fnFreeStmt
$LN9@fnFreeStmt:

; 694  : 
; 695  :    for ( k = 0; lpConnection->lpHandles[ k ]; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@fnFreeStmt
$LN2@fnFreeStmt:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@fnFreeStmt:
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+ecx*4+2820], 0
	je	$LN3@fnFreeStmt

; 696  :    {
; 697  :       LPHANDLES     lpHandles = lpConnection->lpHandles[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+2820]
	mov	DWORD PTR _lpHandles$1[ebp], edx

; 698  :       LPSTMTHANDLES lpStmtHandle = lpHandles->lpStmtHandles;

	mov	eax, DWORD PTR _lpHandles$1[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpStmtHandle$2[ebp], ecx

; 699  : 
; 700  :       for ( j = 1; j <= lpHandles->lpViewOD->uEntities; j++ )

	mov	edx, 1
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN7@fnFreeStmt
$LN5@fnFreeStmt:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN7@fnFreeStmt:
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpHandles$1[ebp]
	mov	eax, DWORD PTR [edx]
	movzx	edx, WORD PTR [eax+234]
	cmp	ecx, edx
	jg	$LN6@fnFreeStmt

; 701  :       {
; 702  :          if ( lpStmtHandle[ j ].hstmt == 0 )

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _lpStmtHandle$2[ebp]
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $LN10@fnFreeStmt

; 703  :             continue;

	jmp	SHORT $LN5@fnFreeStmt
$LN10@fnFreeStmt:

; 704  : 
; 705  :          // Close the handle.
; 706  : #if defined( DB2 )
; 707  :          nRC = SQLFreeHandle( SQL_HANDLE_STMT,
; 708  :                               (SQLHANDLE) lpStmtHandle[ j ].hstmt );
; 709  :          SQL_RC( "SQLFreeHandle", nRC, "Closing stmt handle", 0, 2 );
; 710  : #else
; 711  :          nRC = SQLFreeHandle( SQL_HANDLE_STMT, lpStmtHandle[ j ].hstmt );

	movsx	edx, WORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _lpStmtHandle$2[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	push	3
	call	_SQLFreeHandle@8
	mov	WORD PTR _nRC$[ebp], ax

; 712  :          SQL_RC( "SQLFreeHandle", nRC, "Closing stmt handle", 0, 2 );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	push	edx
	push	2
	push	0
	push	OFFSET $SG94629
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG94630
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 713  : #endif
; 714  : 
; 715  :          // Free up memory.
; 716  :          if ( lpStmtHandle[ j ].pchSqlCmd )

	movsx	ecx, WORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _lpStmtHandle$2[ebp]
	cmp	DWORD PTR [edx+ecx+4], 0
	je	SHORT $LN11@fnFreeStmt

; 717  :          {
; 718  :             free( lpStmtHandle[ j ].pchSqlCmd );

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _lpStmtHandle$2[ebp]
	mov	edx, DWORD PTR [ecx+eax+4]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 719  :             lpStmtHandle[ j ].pchSqlCmd = 0;

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _lpStmtHandle$2[ebp]
	mov	DWORD PTR [ecx+eax+4], 0
$LN11@fnFreeStmt:

; 720  :          }
; 721  : 
; 722  :          if ( lpStmtHandle[ j ].pchInputBuffer )

	movsx	edx, WORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _lpStmtHandle$2[ebp]
	cmp	DWORD PTR [eax+edx+8], 0
	je	SHORT $LN12@fnFreeStmt

; 723  :          {
; 724  :             free( lpStmtHandle[ j ].pchInputBuffer );

	movsx	ecx, WORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _lpStmtHandle$2[ebp]
	mov	eax, DWORD PTR [edx+ecx+8]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 725  :             lpStmtHandle[ j ].pchInputBuffer = 0;

	movsx	ecx, WORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _lpStmtHandle$2[ebp]
	mov	DWORD PTR [edx+ecx+8], 0
$LN12@fnFreeStmt:

; 726  :          }
; 727  : 
; 728  :          if ( lpStmtHandle[ j ].pchOutputBuffer )

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _lpStmtHandle$2[ebp]
	cmp	DWORD PTR [ecx+eax+20], 0
	je	SHORT $LN13@fnFreeStmt

; 729  :          {
; 730  :             free( lpStmtHandle[ j ].pchOutputBuffer );

	movsx	edx, WORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _lpStmtHandle$2[ebp]
	mov	ecx, DWORD PTR [eax+edx+20]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 731  :             lpStmtHandle[ j ].pchOutputBuffer = 0;

	movsx	edx, WORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _lpStmtHandle$2[ebp]
	mov	DWORD PTR [eax+edx+20], 0
$LN13@fnFreeStmt:

; 732  :          }
; 733  : 
; 734  :          if ( lpStmtHandle[ j ].ppchBufferPtr )

	movsx	ecx, WORD PTR _j$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _lpStmtHandle$2[ebp]
	cmp	DWORD PTR [edx+ecx+12], 0
	je	SHORT $LN14@fnFreeStmt

; 735  :          {
; 736  :             free( lpStmtHandle[ j ].ppchBufferPtr );

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _lpStmtHandle$2[ebp]
	mov	edx, DWORD PTR [ecx+eax+12]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 737  :             lpStmtHandle[ j ].ppchBufferPtr = 0;

	movsx	eax, WORD PTR _j$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _lpStmtHandle$2[ebp]
	mov	DWORD PTR [ecx+eax+12], 0
$LN14@fnFreeStmt:

; 738  :          }
; 739  : 
; 740  :          SqlFreeBoundAttrList( lpStmtHandle[ j ].lpBoundList );

	movsx	edx, WORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _lpStmtHandle$2[ebp]
	mov	ecx, DWORD PTR [eax+edx+24]
	push	ecx
	call	_SqlFreeBoundAttrList@4

; 741  :          lpStmtHandle[ j ].lpBoundList = 0;

	movsx	edx, WORD PTR _j$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _lpStmtHandle$2[ebp]
	mov	DWORD PTR [eax+edx+24], 0

; 742  : 
; 743  :       } // for j...

	jmp	$LN5@fnFreeStmt
$LN6@fnFreeStmt:

; 744  : 
; 745  :       free( lpHandles->lpStmtHandles );

	mov	ecx, DWORD PTR _lpHandles$1[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 746  :       lpHandles->lpStmtHandles = 0;

	mov	eax, DWORD PTR _lpHandles$1[ebp]
	mov	DWORD PTR [eax+4], 0

; 747  : 
; 748  :       free( lpConnection->lpHandles[ k ] );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+2820]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 749  :       lpConnection->lpHandles[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+ecx*4+2820], 0

; 750  :       lpConnection->hstmt = 0;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+2812], 0

; 751  :       lpConnection->pchGlobalTableBuffer = 0;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+202], 0

; 752  : 
; 753  :    } // for k...

	jmp	$LN2@fnFreeStmt
$LN3@fnFreeStmt:

; 754  : 
; 755  :    if ( lpConnection->pchEntityJoinTable )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+2900], 0
	je	SHORT $LN1@fnFreeStmt

; 756  :    {
; 757  :       SysFree( lpConnection->pchEntityJoinTable );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2900]
	push	ecx
	call	_SysFree@4

; 758  :       lpConnection->pchEntityJoinTable = 0;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+2900], 0
$LN1@fnFreeStmt:

; 759  :    }
; 760  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnFreeStmtHandles ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_lpConnection$ = 12					; size = 4
_bSqlCmd$ = 16						; size = 1
_ulLth$ = 20						; size = 4
_fnAllocateConnectionMemory@16 PROC

; 557  : {

	push	ebp
	mov	ebp, esp

; 558  :    if ( bSqlCmd )

	movzx	eax, BYTE PTR _bSqlCmd$[ebp]
	test	eax, eax
	je	SHORT $LN2@fnAllocate

; 559  :    {
; 560  :    // TraceLine( "fnAllocateConnectionMemory (PRE ) for Task: 0x%08x   Connection.CmdMem.SqlCmd: 0x%08x.0x%08x.0x%08x  SQL Lth: %d",
; 561  :    //            SysGetTaskFromView( lpView ), lpConnection, lpConnection->hCmdMem, lpConnection->pchConnSqlCmd, ulLth ); // dks debug
; 562  : 
; 563  :       if ( lpConnection->hCmdMem )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [ecx+198], 0
	je	SHORT $LN4@fnAllocate

; 564  :       {
; 565  :          SysFreeMemory( lpConnection->hCmdMem );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	_SysFreeMemory@4

; 566  :          lpConnection->hCmdMem = 0;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+198], 0

; 567  :          lpConnection->pchConnSqlCmd = 0;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+194], 0
$LN4@fnAllocate:

; 568  :       }
; 569  : 
; 570  :       if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN5@fnAllocate

; 571  :       {
; 572  :          lpConnection->hCmdMem = SysAllocMemory( &lpConnection->pchConnSqlCmd,

	push	0
	push	32768					; 00008000H
	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	call	_SysAllocMemory@20
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+198], eax

; 573  :                                                  ulLth, 0, zCOREMEM_ALLOC, 0 );
; 574  :          lpConnection->lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+2904], eax
$LN5@fnAllocate:

; 575  :       }
; 576  : 
; 577  :    // TraceLine( "fnAllocateConnectionMemory (POST) for Task: 0x%08x   Connection.CmdMem.SqlCmd: 0x%08x.0x%08x.0x%08x  SQL Lth: %d",
; 578  :    //            SysGetTaskFromView( lpView ), lpConnection, lpConnection->hCmdMem, lpConnection->pchConnSqlCmd, ulLth ); // dks debug
; 579  :    }

	jmp	$LN3@fnAllocate
$LN2@fnAllocate:

; 580  :    else
; 581  :    {
; 582  :    // TraceLine( "fnAllocateConnectionMemory (PRE ) for Task: 0x%08x   Connection.TblMem.Buffer: 0x%08x.0x%08x.0x%08x  TBL Lth: %d",
; 583  :    //            SysGetTaskFromView( lpView ), lpConnection, lpConnection->hTblMem, lpConnection->pchGlobalTableBuffer, ulLth ); // dks debug
; 584  :       if ( lpConnection->hTblMem )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+210], 0
	je	SHORT $LN6@fnAllocate

; 585  :       {
; 586  :          SysFreeMemory( lpConnection->hTblMem );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+210]
	push	ecx
	call	_SysFreeMemory@4

; 587  :          lpConnection->hTblMem = 0;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [edx+210], 0

; 588  :          lpConnection->pchGlobalTableBuffer = 0;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+202], 0

; 589  :          lpConnection->lTblSize = 0;

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+206], 0
$LN6@fnAllocate:

; 590  :       }
; 591  : 
; 592  :       if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN3@fnAllocate

; 593  :       {
; 594  :          lpConnection->hTblMem =

	push	0
	push	32768					; 00008000H
	push	0
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	add	eax, 202				; 000000caH
	push	eax
	call	_SysAllocMemory@20
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+210], eax

; 595  :                      SysAllocMemory( &lpConnection->pchGlobalTableBuffer,
; 596  :                                      ulLth, 0, zCOREMEM_ALLOC, 0 );
; 597  :          lpConnection->lTblSize = ulLth;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR [edx+206], eax

; 598  :          lpConnection->lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+2904], eax
$LN3@fnAllocate:

; 599  :       }
; 600  : 
; 601  :    // TraceLine( "fnAllocateConnectionMemory (POST) for Task: 0x%08x   Connection.TblMem.Buffer: 0x%08x.0x%08x.0x%08x  TBL Lth: %d",
; 602  :    //            SysGetTaskFromView( lpView ), lpConnection, lpConnection->hTblMem, lpConnection->pchGlobalTableBuffer, ulLth ); // dks debug
; 603  :    }
; 604  : 
; 605  :    return( 0 );

	xor	eax, eax

; 606  : }

	pop	ebp
	ret	16					; 00000010H
_fnAllocateConnectionMemory@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_pchPtr$ = -324						; size = 4
_lpDBName$ = -320					; size = 4
_k$ = -316						; size = 2
_nRC$ = -312						; size = 2
_szText$1 = -308					; size = 200
_szUserID$ = -108					; size = 50
_szPassword$ = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_lpConnection$ = 20					; size = 4
_fnOpenDatabaseConnection@16 PROC

; 4564 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 324				; 00000144H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4565 :    zCHAR  szUserID[ 50 ];
; 4566 :    zCHAR  szPassword[ 50 ];
; 4567 :    zPCHAR lpDBName;
; 4568 :    zPCHAR pchPtr = 0;

	mov	DWORD PTR _pchPtr$[ebp], 0

; 4569 :    zSHORT k;
; 4570 :    zSHORT nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 4571 : 
; 4572 : #if defined( DB2 ) || defined( ODBC )
; 4573 : 
; 4574 :    if ( lpConnection->henv == 0 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [ecx+2804], 0
	jne	SHORT $LN5@fnOpenData

; 4575 :    {
; 4576 :       nRC = SQLAllocEnv( &lpConnection->henv );

	mov	edx, DWORD PTR _lpConnection$[ebp]
	add	edx, 2804				; 00000af4H
	push	edx
	call	_SQLAllocEnv@4
	mov	WORD PTR _nRC$[ebp], ax

; 4577 :       SQL_RC( "SQLAllocEnv", nRC, 0, 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	0
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95726
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 4578 :       if ( nRC != SQL_SUCCESS )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN5@fnOpenData

; 4579 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOpenData
$LN5@fnOpenData:

; 4580 :    }
; 4581 : 
; 4582 : #elif defined( ODBC )
; 4583 : 
; 4584 :    if ( lpConnection->henv == 0 )
; 4585 :    {
; 4586 :       nRC = SQLAllocHandle( SQL_HANDLE_ENV, SQL_NULL_HANDLE,
; 4587 :                             &lpConnection->henv );
; 4588 :       SQL_RC( "SQLAllocHandle", nRC, 0, 0, 2 );
; 4589 :       if ( nRC != SQL_SUCCESS )
; 4590 :          return( zCALL_ERROR );
; 4591 :    }
; 4592 : 
; 4593 : #endif
; 4594 : 
; 4595 :    if ( lpViewOD == 0 && lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN7@fnOpenData
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN7@fnOpenData

; 4596 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOpenData
$LN7@fnOpenData:

; 4597 : 
; 4598 :    // Get the database name.
; 4599 :    if ( lpViewEntity && lpViewEntity->szDBName[ 0 ] )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN8@fnOpenData
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+80]
	test	eax, eax
	je	SHORT $LN8@fnOpenData

; 4600 :       lpDBName = lpViewEntity->szDBName;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 80					; 00000050H
	mov	DWORD PTR _lpDBName$[ebp], ecx
	jmp	SHORT $LN9@fnOpenData
$LN8@fnOpenData:

; 4601 :    else
; 4602 :       lpDBName = lpViewOD->szDfltDBName;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 43					; 0000002bH
	mov	DWORD PTR _lpDBName$[ebp], edx
$LN9@fnOpenData:

; 4603 : 
; 4604 :    // Loop through all the open database names, looking for one that
; 4605 :    // matches the database we're supposed to use.  If we find one, set
; 4606 :    // the current hSqlCsr to the cursor of the database.
; 4607 :    for ( k = 0; k < lpConnection->nOpenDatabaseCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@fnOpenData
$LN2@fnOpenData:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@fnOpenData:
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+216]
	cmp	edx, ecx
	jge	SHORT $LN3@fnOpenData

; 4608 :    {
; 4609 :       if ( zstrcmpi( lpConnection->DBConnection[ k ].szDatabaseName,
; 4610 :                      lpDBName ) == 0 )

	mov	edx, DWORD PTR _lpDBName$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 58
	mov	edx, DWORD PTR _lpConnection$[ebp]
	lea	eax, DWORD PTR [edx+ecx+220]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@fnOpenData

; 4611 :       {
; 4612 :          //==============================================================
; 4613 :          // Copy opened DB information to 'common' information.
; 4614 :          //==============================================================
; 4615 : 
; 4616 : #if defined( DB2 ) || defined( ODBC )
; 4617 : 
; 4618 :          lpConnection->hdbc = lpConnection->DBConnection[ k ].hdbc;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 58
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+edx+274]
	mov	DWORD PTR [eax+2808], edx

; 4619 : 
; 4620 : #endif
; 4621 :          break;

	jmp	SHORT $LN3@fnOpenData
$LN10@fnOpenData:

; 4622 :       }
; 4623 :    }

	jmp	SHORT $LN2@fnOpenData
$LN3@fnOpenData:

; 4624 : 
; 4625 :    lpConnection->nCurrentDB = k;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax+218], cx

; 4626 :    if ( k >= lpConnection->nOpenDatabaseCount ||

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+216]
	cmp	edx, ecx
	jge	SHORT $LN12@fnOpenData
	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 58
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+eax+270]
	and	edx, 1
	jne	$LN11@fnOpenData
$LN12@fnOpenData:

; 4627 :         lpConnection->DBConnection[ k ].bValidConnection == FALSE )
; 4628 :    {
; 4629 :       if ( k >= MAX_OPEN_DATABASES )

	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 10					; 0000000aH
	jl	SHORT $LN13@fnOpenData

; 4630 :       {
; 4631 :          DBH_Error( lpView, "Too many open databases for 1 session.", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG95735
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DBH_Error
	add	esp, 16					; 00000010H

; 4632 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOpenData
$LN13@fnOpenData:

; 4633 :       }
; 4634 : 
; 4635 :       // If k >= DBCount, then we need to open a new database.
; 4636 :       // Otherwise we will try to re-open a database that failed earlier.
; 4637 :       if ( k >= lpConnection->nOpenDatabaseCount )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+216]
	cmp	edx, ecx
	jl	SHORT $LN14@fnOpenData

; 4638 :       {
; 4639 :          lpConnection->nOpenDatabaseCount++;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	ax, WORD PTR [edx+216]
	add	ax, 1
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	WORD PTR [ecx+216], ax

; 4640 :          zstrcpy( lpConnection->DBConnection[ k ].szDatabaseName,

	mov	edx, DWORD PTR _lpDBName$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 58
	mov	edx, DWORD PTR _lpConnection$[ebp]
	lea	eax, DWORD PTR [edx+ecx+220]
	push	eax
	call	_strcpy
	add	esp, 8
$LN14@fnOpenData:

; 4641 :                   lpDBName );
; 4642 :       }
; 4643 : 
; 4644 :       SysGetDB_UserID( lpView, szUserID, szPassword );

	lea	ecx, DWORD PTR _szPassword$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szUserID$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysGetDB_UserID@12

; 4645 : 
; 4646 :       //==============================================================
; 4647 :       // Open database.
; 4648 :       //==============================================================
; 4649 : 
; 4650 : #if defined( DB2 ) || defined( ODBC )
; 4651 : 
; 4652 :       nRC = SQLAllocConnect( lpConnection->henv, &lpConnection->hdbc );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	add	ecx, 2808				; 00000af8H
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2804]
	push	eax
	call	_SQLAllocConnect@8
	mov	WORD PTR _nRC$[ebp], ax

; 4653 :       SQL_RC( "SQLAllocConnect", nRC, 0, 0, 2 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	2
	push	0
	push	0
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95737
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 4654 :       if ( nRC != SQL_SUCCESS )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN15@fnOpenData

; 4655 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOpenData
$LN15@fnOpenData:

; 4656 : 
; 4657 :       nRC = SQLConnect( lpConnection->hdbc, lpDBName, SQL_NTS,

	push	-3					; fffffffdH
	lea	ecx, DWORD PTR _szPassword$[ebp]
	push	ecx
	push	-3					; fffffffdH
	lea	edx, DWORD PTR _szUserID$[ebp]
	push	edx
	push	-3					; fffffffdH
	mov	eax, DWORD PTR _lpDBName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2808]
	push	edx
	call	_SQLConnect@28
	mov	WORD PTR _nRC$[ebp], ax

; 4658 :                         szUserID, SQL_NTS, szPassword, SQL_NTS );
; 4659 :       SQL_RC( "SQLConnect", nRC, "Database = ", lpDBName, 1 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpDBName$[ebp]
	push	ecx
	push	OFFSET $SG95739
	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG95740
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 4660 :       if ( !RC_SUCCESSFUL( nRC ) )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN16@fnOpenData
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 1
	je	SHORT $LN16@fnOpenData

; 4661 :       {
; 4662 :          zCHAR szText[ 200 ];
; 4663 : 
; 4664 :          zsprintf( szText, "Error connecting to DB %s", lpDBName );

	mov	edx, DWORD PTR _lpDBName$[ebp]
	push	edx
	push	OFFSET $SG95742
	lea	eax, DWORD PTR _szText$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4665 :          MessageSend( lpConnection->lpAppView, "KZH0102", "ODBC DBH Error",

	push	0
	push	1000					; 000003e8H
	lea	ecx, DWORD PTR _szText$1[ebp]
	push	ecx
	push	OFFSET $SG95743
	push	OFFSET $SG95744
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_MessageSend@24

; 4666 :                       szText, zMSGQ_SYSTEM_ERROR, 0 );
; 4667 : 
; 4668 :          SQLFreeHandle( SQL_HANDLE_DBC, (SQLHANDLE) lpConnection->hdbc );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2808]
	push	edx
	push	2
	call	_SQLFreeHandle@8

; 4669 :          lpConnection->hdbc = 0;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+2808], 0

; 4670 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOpenData
$LN16@fnOpenData:

; 4671 :       }
; 4672 : 
; 4673 : #if defined( ODBC )
; 4674 :       nRC = SQLSetConnectAttr( lpConnection->hdbc, SQL_ATTR_AUTOCOMMIT,

	push	0
	push	0
	push	102					; 00000066H
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2808]
	push	edx
	call	_SQLSetConnectAttr@16
	mov	WORD PTR _nRC$[ebp], ax

; 4675 :                                SQL_AUTOCOMMIT_OFF, 0 );
; 4676 :       SQL_RC( "SQLSetConnectAttr", nRC, "Turning AutoCommit off", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG95745
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95746
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 4677 : #endif
; 4678 : 
; 4679 :       lpConnection->DBConnection[ k ].hdbc = lpConnection->hdbc;

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 58
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [edx+2808]
	mov	DWORD PTR [ecx+eax+274], edx

; 4680 : 
; 4681 : #endif
; 4682 : 
; 4683 :       lpConnection->DBConnection[ k ].bValidConnection = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 58
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+ecx+270]
	or	eax, 1
	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 58
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+edx+270], eax
$LN11@fnOpenData:

; 4684 : 
; 4685 :    } // if ( k >= lpConnection->nOpenDatabaseCount ||...
; 4686 : 
; 4687 : #if defined( DB2 )
; 4688 : 
; 4689 :    if ( lpConnection->hGeneralStmt == 0 )
; 4690 :    {
; 4691 :       nRC = SQLAllocStmt( lpConnection->hdbc, &lpConnection->hGeneralStmt );
; 4692 :       SQL_RC( "SQLAllocStmt", nRC, "Allocate HSTMT", 0, 2 );
; 4693 :       if ( nRC != SQL_SUCCESS )
; 4694 :          return( zCALL_ERROR );
; 4695 :    }
; 4696 : 
; 4697 : #elif defined( ODBC )
; 4698 : 
; 4699 :    if ( lpConnection->hGeneralStmt == 0 )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+2816], 0
	jne	SHORT $LN17@fnOpenData

; 4700 :    {
; 4701 :       nRC = SQLAllocHandle( SQL_HANDLE_STMT, lpConnection->hdbc,

	mov	eax, DWORD PTR _lpConnection$[ebp]
	add	eax, 2816				; 00000b00H
	push	eax
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+2808]
	push	edx
	push	3
	call	_SQLAllocHandle@12
	mov	WORD PTR _nRC$[ebp], ax

; 4702 :                             &lpConnection->hGeneralStmt );
; 4703 :       SQL_RC( "SQLAllocHandle", nRC, "Allocate HSTMT", 0, 2 );

	mov	eax, DWORD PTR _lpConnection$[ebp]
	push	eax
	push	2
	push	0
	push	OFFSET $SG95748
	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95749
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 4704 :       if ( nRC != SQL_SUCCESS )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN17@fnOpenData

; 4705 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnOpenData
$LN17@fnOpenData:

; 4706 :    }
; 4707 : 
; 4708 : #endif
; 4709 : 
; 4710 :    return( 0 );

	xor	eax, eax
$LN1@fnOpenData:

; 4711 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnOpenDatabaseConnection@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpViewOD$ = -32					; size = 4
tv141 = -28						; size = 4
tv140 = -24						; size = 4
_lTask$ = -20						; size = 4
_vMsgQNamed$ = -16					; size = 4
_lpViewEntity$ = -12					; size = 4
_vMsgQ$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lCode$ = 12						; size = 4
_szState$ = 16						; size = 4
_szMsg$ = 20						; size = 4
_fnSetDBHandlerError@16 PROC

; 5313 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5314 :    LPVIEWOD     lpViewOD;
; 5315 :    LPVIEWENTITY lpViewEntity;
; 5316 :    zVIEW        vMsgQNamed;
; 5317 :    zVIEW        vMsgQ;
; 5318 :    zLONG        lTask;
; 5319 :    zSHORT       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 5320 : 
; 5321 :    lTask = SysGetTaskFromView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysGetTaskFromView@4
	mov	DWORD PTR _lTask$[ebp], eax

; 5322 : 
; 5323 :    // Does Named View exist?
; 5324 :    GetViewByName( &vMsgQNamed, "__MSGQ", lpView, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	OFFSET $SG96007
	lea	eax, DWORD PTR _vMsgQNamed$[ebp]
	push	eax
	call	_GetViewByName@16

; 5325 :    if ( vMsgQNamed == 0 )

	cmp	DWORD PTR _vMsgQNamed$[ebp], 0
	jne	SHORT $LN5@fnSetDBHan

; 5326 :    {
; 5327 :       // if not, create it
; 5328 :       if ( ActivateEmptyObjectInstance( &vMsgQNamed, "KZMSGQOO", lpView,
; 5329 :                                         zMULTIPLE ) >= 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG96011
	lea	edx, DWORD PTR _vMsgQNamed$[ebp]
	push	edx
	call	_ActivateEmptyObjectInstance@16
	cwde
	test	eax, eax
	jl	SHORT $LN6@fnSetDBHan

; 5330 :       {
; 5331 :          CreateEntity( vMsgQNamed, "Task", zPOS_FIRST );

	push	1
	push	OFFSET $SG96012
	mov	ecx, DWORD PTR _vMsgQNamed$[ebp]
	push	ecx
	call	_CreateEntity@12

; 5332 :       }

	jmp	SHORT $LN7@fnSetDBHan
$LN6@fnSetDBHan:

; 5333 :       else
; 5334 :       {
; 5335 :          // ERROR out of here ... we will not go far without this object!!!
; 5336 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetDBHan
$LN7@fnSetDBHan:

; 5337 :       }
; 5338 : 
; 5339 :       // Give it a global name
; 5340 :       SetNameForView( vMsgQNamed, "__MSGQ", lpView, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	OFFSET $SG96013
	mov	eax, DWORD PTR _vMsgQNamed$[ebp]
	push	eax
	call	_SetNameForView@16
$LN5@fnSetDBHan:

; 5341 :    }
; 5342 : 
; 5343 :    // Has Named View the entity DBH_Error in its definition?
; 5344 :    lpViewOD = (LPVIEWOD) MiGetViewEntityForView( vMsgQNamed, 0 );

	push	0
	mov	ecx, DWORD PTR _vMsgQNamed$[ebp]
	push	ecx
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5345 :    for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN4@fnSetDBHan
$LN2@fnSetDBHan:

; 5347 :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN4@fnSetDBHan:

; 5346 :          lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN3@fnSetDBHan

; 5348 :    {
; 5349 :       // is the entity the DBH_Error?
; 5350 :       if ( zstrcmp( lpViewEntity->szName, "DBH_Error" ) == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	movsx	edx, BYTE PTR $SG96015
	cmp	ecx, edx
	jne	SHORT $LN18@fnSetDBHan
	push	OFFSET $SG96016
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv141[ebp], eax
	jmp	SHORT $LN19@fnSetDBHan
$LN18@fnSetDBHan:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	movsx	eax, BYTE PTR $SG96017
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN16@fnSetDBHan
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN17@fnSetDBHan
$LN16@fnSetDBHan:
	mov	DWORD PTR tv140[ebp], -1
$LN17@fnSetDBHan:
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR tv141[ebp], ecx
$LN19@fnSetDBHan:
	cmp	DWORD PTR tv141[ebp], 0
	jne	SHORT $LN8@fnSetDBHan

; 5351 :          break;

	jmp	SHORT $LN3@fnSetDBHan
$LN8@fnSetDBHan:

; 5352 :    }

	jmp	SHORT $LN2@fnSetDBHan
$LN3@fnSetDBHan:

; 5353 : 
; 5354 :    // if DBH_Error not exist, we have an old KZMSGQOO
; 5355 :    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN9@fnSetDBHan

; 5356 :      return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetDBHan
$LN9@fnSetDBHan:

; 5357 : 
; 5358 :    // Create private copy, cause we change our cursors
; 5359 :    CreateViewFromViewForTask( &vMsgQ, vMsgQNamed, 0 );

	push	0
	mov	edx, DWORD PTR _vMsgQNamed$[ebp]
	push	edx
	lea	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 5360 : 
; 5361 :    // check, if task entity instance exists for our task
; 5362 :    if ( SetCursorFirstEntityByInteger( vMsgQ, "Task", "Id", lTask, 0 ) < 0 )

	push	0
	mov	ecx, DWORD PTR _lTask$[ebp]
	push	ecx
	push	OFFSET $SG96020
	push	OFFSET $SG96021
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetCursorFirstEntityByInteger@20
	cwde
	test	eax, eax
	jge	SHORT $LN10@fnSetDBHan

; 5363 :    {
; 5364 :       // if not, create it
; 5365 :       CreateEntity( vMsgQ, "Task", zPOS_LAST );

	push	2
	push	OFFSET $SG96022
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_CreateEntity@12

; 5366 :       SetAttributeFromVariable( vMsgQ, "Task", "Id",

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	lea	edx, DWORD PTR _lTask$[ebp]
	push	edx
	push	OFFSET $SG96023
	push	OFFSET $SG96024
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromVariable@32

; 5367 :                                 &lTask, zTYPE_INTEGER, 0, 0, 0 );
; 5368 :       SetAttributeFromVariable( vMsgQ, "Task", "Client",

	push	0
	push	0
	push	0
	push	83					; 00000053H
	push	OFFSET $SG96025
	push	OFFSET $SG96026
	push	OFFSET $SG96027
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetAttributeFromVariable@32
$LN10@fnSetDBHan:

; 5369 :                                 "Zeidon", zTYPE_STRING, 0, 0, 0 );
; 5370 :    }
; 5371 : 
; 5372 :    // set cursor on our task entity
; 5373 :    if ( SetCursorFirstEntityByInteger( vMsgQ, "Task", "Id", lTask, 0 ) < 0 )

	push	0
	mov	edx, DWORD PTR _lTask$[ebp]
	push	edx
	push	OFFSET $SG96029
	push	OFFSET $SG96030
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetCursorFirstEntityByInteger@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN11@fnSetDBHan

; 5374 :       goto EndOfFunction;

	jmp	$EndOfFunction$20
$LN11@fnSetDBHan:

; 5375 : 
; 5376 :    // if max. entries reached, delete the oldest one
; 5377 :    if ( CountEntitiesForView( vMsgQ, "DBH_Error" ) >= 100L )

	push	OFFSET $SG96032
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_CountEntitiesForView@8
	cmp	eax, 100				; 00000064H
	jl	SHORT $LN12@fnSetDBHan

; 5378 :    {
; 5379 :       SetCursorFirstEntity( vMsgQ, "DBH_Error", 0 );

	push	0
	push	OFFSET $SG96033
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12

; 5380 :       DeleteEntity( vMsgQ, "DBH_Error", zREPOS_FIRST );

	push	1
	push	OFFSET $SG96034
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_DeleteEntity@12
$LN12@fnSetDBHan:

; 5381 :    }
; 5382 : 
; 5383 :    // create new entry
; 5384 :    if ( CreateEntity( vMsgQ, "DBH_Error", zPOS_LAST ) < 0 )

	push	2
	push	OFFSET $SG96036
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_CreateEntity@12
	cwde
	test	eax, eax
	jge	SHORT $LN13@fnSetDBHan

; 5385 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$20
$LN13@fnSetDBHan:

; 5386 : 
; 5387 :    SetAttributeFromInteger( vMsgQ, "DBH_Error", "Code", lCode );

	mov	ecx, DWORD PTR _lCode$[ebp]
	push	ecx
	push	OFFSET $SG96037
	push	OFFSET $SG96038
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16

; 5388 :    SetAttributeFromVariable( vMsgQ, "DBH_Error", "State",

	push	0
	push	0
	push	5
	push	83					; 00000053H
	mov	eax, DWORD PTR _szState$[ebp]
	push	eax
	push	OFFSET $SG96039
	push	OFFSET $SG96040
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetAttributeFromVariable@32

; 5389 :                              szState, zTYPE_STRING, 5, 0, 0 );
; 5390 :    SetAttributeFromVariable( vMsgQ, "DBH_Error", "Msg",

	push	0
	push	0
	push	512					; 00000200H
	push	83					; 00000053H
	mov	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	push	OFFSET $SG96041
	push	OFFSET $SG96042
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromVariable@32

; 5391 :                              szMsg, zTYPE_STRING, 512, 0, 0 );
; 5392 : 
; 5393 :    // If we get here then everything's ok.
; 5394 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$EndOfFunction$20:

; 5395 : 
; 5396 : EndOfFunction:
; 5397 :    if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	SHORT $LN14@fnSetDBHan

; 5398 :       DropView( vMsgQ );

	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_DropView@4
$LN14@fnSetDBHan:

; 5399 : 
; 5400 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSetDBHan:

; 5401 : 
; 5402 : } /* fnSetDBHandlerError */

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSetDBHandlerError@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lTask$ = -32						; size = 4
_lpViewOD$ = -28					; size = 4
tv95 = -24						; size = 4
tv94 = -20						; size = 4
_vMsgQNamed$ = -16					; size = 4
_vMsgQ$ = -12						; size = 4
_lpViewEntity$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_fnClearDBHandlerError@4 PROC

; 5238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5239 :    LPVIEWOD     lpViewOD;
; 5240 :    LPVIEWENTITY lpViewEntity;
; 5241 :    zVIEW        vMsgQNamed;
; 5242 :    zVIEW        vMsgQ;
; 5243 :    zLONG        lTask;
; 5244 :    zSHORT       nRC;
; 5245 : 
; 5246 :    lTask = SysGetTaskFromView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysGetTaskFromView@4
	mov	DWORD PTR _lTask$[ebp], eax

; 5247 : 
; 5248 :    // Does Named View exist?
; 5249 :    GetViewByName( &vMsgQNamed, "__MSGQ", lpView, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG95966
	lea	edx, DWORD PTR _vMsgQNamed$[ebp]
	push	edx
	call	_GetViewByName@16

; 5250 :    if ( vMsgQNamed == 0 )

	cmp	DWORD PTR _vMsgQNamed$[ebp], 0
	jne	SHORT $LN8@fnClearDBH

; 5251 :       return( 0 );    // nothing need to be done

	xor	eax, eax
	jmp	$LN1@fnClearDBH
$LN8@fnClearDBH:

; 5252 : 
; 5253 :    // Has Named View the entity DBH_Error in its definition?
; 5254 :    lpViewOD = (LPVIEWOD) MiGetViewEntityForView( vMsgQNamed, 0 );

	push	0
	mov	eax, DWORD PTR _vMsgQNamed$[ebp]
	push	eax
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5255 :    for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN4@fnClearDBH
$LN2@fnClearDBH:

; 5257 :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN4@fnClearDBH:

; 5256 :          lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN3@fnClearDBH

; 5258 :    {
; 5259 :       // Is the entity the DBH_Error?
; 5260 :       if ( zstrcmp( lpViewEntity->szName, "DBH_Error" ) == 0 )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	movsx	ecx, BYTE PTR $SG95969
	cmp	eax, ecx
	jne	SHORT $LN15@fnClearDBH
	push	OFFSET $SG95970
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN16@fnClearDBH
$LN15@fnClearDBH:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	movsx	edx, BYTE PTR $SG95971
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN13@fnClearDBH
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN14@fnClearDBH
$LN13@fnClearDBH:
	mov	DWORD PTR tv94[ebp], -1
$LN14@fnClearDBH:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], eax
$LN16@fnClearDBH:
	cmp	DWORD PTR tv95[ebp], 0
	jne	SHORT $LN9@fnClearDBH

; 5261 :         break;

	jmp	SHORT $LN3@fnClearDBH
$LN9@fnClearDBH:

; 5262 :    }

	jmp	SHORT $LN2@fnClearDBH
$LN3@fnClearDBH:

; 5263 : 
; 5264 :    // If DBH_Error not exist, we have an old KZMSGQOO.
; 5265 :    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN10@fnClearDBH

; 5266 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnClearDBH
$LN10@fnClearDBH:

; 5267 : 
; 5268 :    CreateViewFromViewForTask( &vMsgQ, vMsgQNamed, 0 );

	push	0
	mov	ecx, DWORD PTR _vMsgQNamed$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 5269 : 
; 5270 :    // Determine if task entity instance exists for our task.
; 5271 :    nRC = SetCursorFirstEntityByInteger( vMsgQ, "Task", "Id", lTask, 0 );

	push	0
	mov	eax, DWORD PTR _lTask$[ebp]
	push	eax
	push	OFFSET $SG95973
	push	OFFSET $SG95974
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 5272 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN11@fnClearDBH

; 5273 :    {
; 5274 :       // Clean up view ... nothing needs to be done.
; 5275 :       DropView( vMsgQ );

	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_DropView@4

; 5276 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnClearDBH
$LN11@fnClearDBH:

; 5277 :    }
; 5278 : 
; 5279 :    // Delete all former error codes from earlier call.
; 5280 :    for ( nRC = SetCursorFirstEntity( vMsgQ, "DBH_Error", 0 );

	push	0
	push	OFFSET $SG95976
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN7@fnClearDBH
$LN5@fnClearDBH:

; 5282 :          nRC = DeleteEntity( vMsgQ, "DBH_Error", zREPOS_NEXT ) )

	push	3
	push	OFFSET $SG95977
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_DeleteEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN7@fnClearDBH:

; 5281 :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $LN6@fnClearDBH

; 5283 :    {
; 5284 :       // Nothing needs to be done here.
; 5285 :    }

	jmp	SHORT $LN5@fnClearDBH
$LN6@fnClearDBH:

; 5286 : 
; 5287 :    DropView( vMsgQ );

	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_DropView@4

; 5288 : 
; 5289 :    return( 0 );

	xor	eax, eax
$LN1@fnClearDBH:

; 5290 : 
; 5291 : } /* fnClearDBHandlerError */

	mov	esp, ebp
	pop	ebp
	ret	4
_fnClearDBHandlerError@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpViewEntity$ = -112					; size = 4
_lpCallbackInfo$ = -108					; size = 4
_lpViewAttrib$ = -104					; size = 4
tv87 = -100						; size = 4
_pchFormat$1 = -96					; size = 4
_pch$2 = -92						; size = 4
_szEscapeCode$3 = -88					; size = 3
_idx$4 = -84						; size = 2
_lpObjectData$ = -80					; size = 4
tv74 = -76						; size = 4
_bAddEscapeSequence$5 = -69				; size = 1
_szDateTime2$6 = -68					; size = 30
_szDateTime1$7 = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_nCommand$ = 8						; size = 4
_lpView$ = 12						; size = 4
_lpBoundList$ = 16					; size = 4
_lpDataField$ = 20					; size = 4
_pInfo$ = 24						; size = 4
_pchTarget$ = 28					; size = 4
_fnDBH_Callback@24 PROC

; 5557 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5558 :    LPVIEWENTITY lpViewEntity;
; 5559 :    LPVIEWATTRIB lpViewAttrib;
; 5560 : 
; 5561 : #if defined( DB2 )
; 5562 : 
; 5563 :    LPCALLBACKINFO    lpCallbackInfo = (LPCALLBACKINFO) lpBoundList->pvPtr;
; 5564 : 
; 5565 : #elif defined( ODBC )
; 5566 : 
; 5567 :    LPCALLBACKINFO    lpCallbackInfo = (LPCALLBACKINFO) lpBoundList->pvPtr;

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR _lpCallbackInfo$[ebp], ecx

; 5568 :    LPODBC_OBJECTDATA lpObjectData   = lpCallbackInfo->lpObjectData;

	mov	edx, DWORD PTR _lpCallbackInfo$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	DWORD PTR _lpObjectData$[ebp], eax

; 5569 : 
; 5570 :    if ( lpObjectData == 0 )

	cmp	DWORD PTR _lpObjectData$[ebp], 0
	jne	SHORT $LN8@fnDBH_Call

; 5571 :       lpObjectData = &g_DefaultODBC_Data;

	mov	DWORD PTR _lpObjectData$[ebp], OFFSET _g_DefaultODBC_Data
$LN8@fnDBH_Call:

; 5572 : 
; 5573 : #endif
; 5574 : 
; 5575 :    if ( lpDataField )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	SHORT $LN9@fnDBH_Call

; 5576 :    {
; 5577 :       lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 5578 :       lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN9@fnDBH_Call:

; 5579 :    }
; 5580 : 
; 5581 :    switch ( nCommand )

	mov	edx, DWORD PTR _nCommand$[ebp]
	mov	DWORD PTR tv74[ebp], edx
	cmp	DWORD PTR tv74[ebp], 16			; 00000010H
	ja	SHORT $LN42@fnDBH_Call
	cmp	DWORD PTR tv74[ebp], 16			; 00000010H
	je	SHORT $LN10@fnDBH_Call
	mov	eax, DWORD PTR tv74[ebp]
	sub	eax, 1
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 7
	ja	$LN2@fnDBH_Call
	mov	ecx, DWORD PTR tv74[ebp]
	jmp	DWORD PTR $LN44@fnDBH_Call[ecx*4]
$LN42@fnDBH_Call:
	mov	edx, DWORD PTR tv74[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR tv74[ebp], edx
	cmp	DWORD PTR tv74[ebp], 224		; 000000e0H
	ja	$LN2@fnDBH_Call
	mov	eax, DWORD PTR tv74[ebp]
	movzx	ecx, BYTE PTR $LN43@fnDBH_Call[eax]
	jmp	DWORD PTR $LN45@fnDBH_Call[ecx*4]
$LN10@fnDBH_Call:

; 5582 :    {
; 5583 :       // ==========================================================
; 5584 :       case zSQLCALLBACK_INITSELECT:
; 5585 :          return( FALSE );

	xor	eax, eax
	jmp	$LN1@fnDBH_Call
$LN11@fnDBH_Call:

; 5586 : 
; 5587 :       // ==========================================================
; 5588 :       case zSQLCALLBACK_GETNULLSTRING:
; 5589 : 
; 5590 :          // If we get here then nobody handled the message so return FALSE.
; 5591 :          return( FALSE );

	xor	eax, eax
	jmp	$LN1@fnDBH_Call
$LN12@fnDBH_Call:

; 5592 : 
; 5593 :       // ==========================================================
; 5594 :       case zSQLCALLBACK_CHECKNULL:
; 5595 : 
; 5596 :          // If we get here then nobody handled the message so return FALSE.
; 5597 :          return( FALSE );

	xor	eax, eax
	jmp	$LN1@fnDBH_Call
$LN13@fnDBH_Call:

; 5598 : 
; 5599 :       // ==========================================================
; 5600 :       case zSQLCALLBACK_CONVERTSTRING:
; 5601 :       {
; 5602 : 
; 5603 : #if defined( DB2 )
; 5604 : 
; 5605 :          // We only need to worry about date/times.
; 5606 :          if ( lpViewAttrib->cType == zTYPE_DATETIME )
; 5607 :          {
; 5608 :             zPCHAR pch;
; 5609 :             zCHAR  szDateTime1[ 30 ], szDateTime2[ 30 ];
; 5610 : 
; 5611 :             // Get date-time from szSource as an unformatted string --
; 5612 :             // yyyymmddhhmmsss.
; 5613 :             zstrcpy( szDateTime1, (zPCHAR) pInfo );
; 5614 : 
; 5615 :             // Make sure that the DateTime doesn't contain any spaces.
; 5616 :             pch = szDateTime1;
; 5617 :             while ( *pch )
; 5618 :             {
; 5619 :                if ( *pch == ' ' )
; 5620 :                   *pch = '0';
; 5621 : 
; 5622 :                pch++;
; 5623 :             }
; 5624 : 
; 5625 :             // Convert DateTime string to a formatted string that ODBC/DB2
; 5626 :             // understands.
; 5627 :             switch ( lpDataField->cFldType )
; 5628 :             {
; 5629 :                case zTYPE_TIME:
; 5630 :                   UfFormatDateTime( szDateTime2, szDateTime1, "HH.MI.SS" );
; 5631 :                   break;
; 5632 : 
; 5633 :                case zTYPE_DATE:
; 5634 :                   UfFormatDateTime( szDateTime2, szDateTime1, "YYYY-mm-DD" );
; 5635 : 
; 5636 :                   break;
; 5637 : 
; 5638 :                default:
; 5639 :                   UfFormatDateTime( szDateTime2, szDateTime1,
; 5640 :                                     "YYYY-mm-DD-HH.MI.SS.999" );
; 5641 :             }
; 5642 : 
; 5643 :             // Date string must start with a quote.
; 5644 :             *pchTarget++ = '\'';
; 5645 : 
; 5646 :             // Copy formatted date-time string to szTarget and terminate
; 5647 :             // with a quote.
; 5648 :             zstrcpy( pchTarget, szDateTime2 );
; 5649 :             zstrcat( pchTarget, "'" );
; 5650 : 
; 5651 :             return( TRUE ); // Return code indicating we handled it ok.
; 5652 : 
; 5653 :          } // if...
; 5654 : 
; 5655 : #elif defined( ODBC )
; 5656 : 
; 5657 :          zBOOL bAddEscapeSequence;
; 5658 :          zCHAR szEscapeCode[ 3 ];
; 5659 : 
; 5660 :          // We only need to worry about date/times.
; 5661 :          if ( lpViewAttrib->cType == zTYPE_DATETIME )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 84					; 00000054H
	jne	$LN14@fnDBH_Call

; 5662 :          {
; 5663 :             zPCHAR pch;
; 5664 :             zCHAR  szDateTime1[ 30 ], szDateTime2[ 30 ];
; 5665 : 
; 5666 :             // Get date-time from szSource as an unformatted string --
; 5667 :             // yyyymmddhhmmsss.
; 5668 :             zstrcpy( szDateTime1, (zPCHAR) pInfo );

	mov	ecx, DWORD PTR _pInfo$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDateTime1$7[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 5669 : 
; 5670 :             // Make sure that the DateTime doesn't contain any spaces.
; 5671 :             pch = szDateTime1;

	lea	eax, DWORD PTR _szDateTime1$7[ebp]
	mov	DWORD PTR _pch$2[ebp], eax
$LN4@fnDBH_Call:

; 5672 :             while ( *pch )

	mov	ecx, DWORD PTR _pch$2[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN5@fnDBH_Call

; 5673 :             {
; 5674 :                if ( *pch == ' ' )

	mov	eax, DWORD PTR _pch$2[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN15@fnDBH_Call

; 5675 :                   *pch = '0';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 48			; 00000030H
$LN15@fnDBH_Call:

; 5676 : 
; 5677 :                pch++;

	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 5678 :             }

	jmp	SHORT $LN4@fnDBH_Call
$LN5@fnDBH_Call:

; 5679 : 
; 5680 :             bAddEscapeSequence = FALSE;

	mov	BYTE PTR _bAddEscapeSequence$5[ebp], 0

; 5681 : 
; 5682 :             // Convert DateTime string to a formatted string that ODBC/DB2
; 5683 :             // understands.
; 5684 :             switch ( lpDataField->cFldType )

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	dl, BYTE PTR [ecx+270]
	mov	BYTE PTR tv87[ebp], dl
	cmp	BYTE PTR tv87[ebp], 68			; 00000044H
	je	SHORT $LN19@fnDBH_Call
	cmp	BYTE PTR tv87[ebp], 73			; 00000049H
	je	SHORT $LN16@fnDBH_Call
	cmp	BYTE PTR tv87[ebp], 84			; 00000054H
	je	SHORT $LN20@fnDBH_Call
	jmp	$LN6@fnDBH_Call
$LN16@fnDBH_Call:

; 5685 :             {
; 5686 :                case zTYPE_TIME:
; 5687 :                   if ( lpObjectData->bStoreTimestampAsString )

	mov	eax, DWORD PTR _lpObjectData$[ebp]
	movzx	ecx, BYTE PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN17@fnDBH_Call

; 5688 :                      UfFormatDateTime( szDateTime2, szDateTime1, "HHMISS" );

	push	OFFSET $SG96175
	lea	edx, DWORD PTR _szDateTime1$7[ebp]
	push	edx
	lea	eax, DWORD PTR _szDateTime2$6[ebp]
	push	eax
	call	_UfFormatDateTime@12
	jmp	SHORT $LN18@fnDBH_Call
$LN17@fnDBH_Call:

; 5689 :                   else
; 5690 :                   {
; 5691 :                      bAddEscapeSequence = TRUE;

	mov	BYTE PTR _bAddEscapeSequence$5[ebp], 1

; 5692 :                      zstrcpy( szEscapeCode, "t" );

	push	OFFSET $SG96176
	lea	ecx, DWORD PTR _szEscapeCode$3[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5693 :                      UfFormatDateTime( szDateTime2, szDateTime1, "HH:MI:SS" );

	push	OFFSET $SG96177
	lea	edx, DWORD PTR _szDateTime1$7[ebp]
	push	edx
	lea	eax, DWORD PTR _szDateTime2$6[ebp]
	push	eax
	call	_UfFormatDateTime@12
$LN18@fnDBH_Call:

; 5694 :                   }
; 5695 : 
; 5696 :                   break;

	jmp	$LN6@fnDBH_Call
$LN19@fnDBH_Call:

; 5697 : 
; 5698 :                case zTYPE_DATE:
; 5699 : #if 0  // Dates are always stored as date/time columns.
; 5700 :                   if ( lpObjectData->bStoreTimestampAsString )
; 5701 :                      UfFormatDateTime( szDateTime2, szDateTime1, "YYYYmmDD" );
; 5702 :                   else
; 5703 : #endif
; 5704 :                   {
; 5705 :                      bAddEscapeSequence = TRUE;

	mov	BYTE PTR _bAddEscapeSequence$5[ebp], 1

; 5706 :                      zstrcpy( szEscapeCode, "d" );

	push	OFFSET $SG96179
	lea	ecx, DWORD PTR _szEscapeCode$3[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5707 :                      UfFormatDateTime( szDateTime2, szDateTime1, "YYYY-mm-DD" );

	push	OFFSET $SG96180
	lea	edx, DWORD PTR _szDateTime1$7[ebp]
	push	edx
	lea	eax, DWORD PTR _szDateTime2$6[ebp]
	push	eax
	call	_UfFormatDateTime@12

; 5708 :                   }
; 5709 : 
; 5710 :                   break;

	jmp	$LN6@fnDBH_Call
$LN20@fnDBH_Call:

; 5711 : 
; 5712 :                case zTYPE_DATETIME:
; 5713 :                   if ( lpObjectData->bStoreTimestampAsString == FALSE )

	mov	ecx, DWORD PTR _lpObjectData$[ebp]
	movzx	edx, BYTE PTR [ecx+4]
	test	edx, edx
	jne	SHORT $LN21@fnDBH_Call

; 5714 :                   {
; 5715 :                      bAddEscapeSequence = TRUE;

	mov	BYTE PTR _bAddEscapeSequence$5[ebp], 1

; 5716 :                      zstrcpy( szEscapeCode, "ts" );

	push	OFFSET $SG96183
	lea	eax, DWORD PTR _szEscapeCode$3[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN21@fnDBH_Call:

; 5717 :                   }
; 5718 : 
; 5719 :                   // The precision of timestamps has been given to us.  Format
; 5720 :                   // the timestamp according to the precision.
; 5721 : 
; 5722 :                   if ( lpObjectData->nTimestampPrecision == 0 )

	mov	ecx, DWORD PTR _lpObjectData$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN22@fnDBH_Call

; 5723 :                   {
; 5724 :                      if ( lpObjectData->bStoreTimestampAsString )

	mov	edx, DWORD PTR _lpObjectData$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	test	eax, eax
	je	SHORT $LN24@fnDBH_Call

; 5725 :                         UfFormatDateTime( szDateTime2, szDateTime1,

	push	OFFSET $SG96188
	lea	ecx, DWORD PTR _szDateTime1$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDateTime2$6[ebp]
	push	edx
	call	_UfFormatDateTime@12
	jmp	SHORT $LN25@fnDBH_Call
$LN24@fnDBH_Call:

; 5726 :                                           "YYYYmmDDHHMISS" );
; 5727 :                      else
; 5728 :                         UfFormatDateTime( szDateTime2, szDateTime1,

	push	OFFSET $SG96189
	lea	eax, DWORD PTR _szDateTime1$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDateTime2$6[ebp]
	push	ecx
	call	_UfFormatDateTime@12
$LN25@fnDBH_Call:

; 5729 :                                           "YYYY-mm-DD HH:MI:SS" );
; 5730 :                   }

	jmp	SHORT $LN6@fnDBH_Call
$LN22@fnDBH_Call:

; 5731 :                   else
; 5732 :                   {
; 5733 :                      zPCHAR pchFormat;
; 5734 :                      zSHORT idx;
; 5735 : 
; 5736 :                      if ( lpObjectData->bStoreTimestampAsString )

	mov	edx, DWORD PTR _lpObjectData$[ebp]
	movzx	eax, BYTE PTR [edx+4]
	test	eax, eax
	je	SHORT $LN26@fnDBH_Call

; 5737 :                      {
; 5738 :                         idx = 14; // Index of first '9' in szFormat.

	mov	ecx, 14					; 0000000eH
	mov	WORD PTR _idx$4[ebp], cx

; 5739 :                         pchFormat = "YYYYmmDDHHMISS999999999999999";

	mov	DWORD PTR _pchFormat$1[ebp], OFFSET $SG96192

; 5740 :                      }

	jmp	SHORT $LN27@fnDBH_Call
$LN26@fnDBH_Call:

; 5741 :                      else
; 5742 :                      {
; 5743 :                         idx = 20; // Index of first '9' in szFormat.

	mov	edx, 20					; 00000014H
	mov	WORD PTR _idx$4[ebp], dx

; 5744 :                         pchFormat = "YYYY-mm-DD HH:MI:SS.999999999999999";

	mov	DWORD PTR _pchFormat$1[ebp], OFFSET $SG96193
$LN27@fnDBH_Call:

; 5745 :                      }
; 5746 : 
; 5747 :                      // We're being a little tricky here but all we're doing is
; 5748 :                      // making sure that the precision in szFormat matches
; 5749 :                      // nTimestampPrecision.
; 5750 : 
; 5751 :                      // First turn one of the 9's into a null-terminator.
; 5752 :                      pchFormat[ idx + lpObjectData->nTimestampPrecision ] = 0;

	movsx	eax, WORD PTR _idx$4[ebp]
	mov	ecx, DWORD PTR _lpObjectData$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _pchFormat$1[ebp]
	mov	BYTE PTR [edx+eax], 0

; 5753 : 
; 5754 :                      UfFormatDateTime( szDateTime2, szDateTime1, pchFormat );

	mov	eax, DWORD PTR _pchFormat$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDateTime1$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDateTime2$6[ebp]
	push	edx
	call	_UfFormatDateTime@12

; 5755 : 
; 5756 :                      // Now change the null-terminator back to a 9.
; 5757 :                      pchFormat[ idx + lpObjectData->nTimestampPrecision ] = '9';

	movsx	eax, WORD PTR _idx$4[ebp]
	mov	ecx, DWORD PTR _lpObjectData$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _pchFormat$1[ebp]
	mov	BYTE PTR [edx+eax], 57			; 00000039H
$LN6@fnDBH_Call:

; 5758 :                   }
; 5759 : 
; 5760 :                   break;
; 5761 : 
; 5762 :             } // switch ( lpDataField->cFldType )...
; 5763 : 
; 5764 :             if ( bAddEscapeSequence )

	movzx	eax, BYTE PTR _bAddEscapeSequence$5[ebp]
	test	eax, eax
	je	SHORT $LN28@fnDBH_Call

; 5765 :             {
; 5766 :                // Add escape sequence.
; 5767 :                *pchTarget++ = '{';

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx], 123			; 0000007bH
	mov	edx, DWORD PTR _pchTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTarget$[ebp], edx

; 5768 : 
; 5769 :                zstrcpy( pchTarget, szEscapeCode );

	lea	eax, DWORD PTR _szEscapeCode$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5770 :                pchTarget += zstrlen( szEscapeCode );

	lea	edx, DWORD PTR _szEscapeCode$3[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchTarget$[ebp]
	mov	DWORD PTR _pchTarget$[ebp], eax

; 5771 : 
; 5772 :                *pchTarget++ = ' ';

	mov	eax, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTarget$[ebp], ecx
$LN28@fnDBH_Call:

; 5773 :             }
; 5774 : 
; 5775 :             // Date string must start with a quote.
; 5776 :             *pchTarget++ = '\'';

	mov	edx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [edx], 39			; 00000027H
	mov	eax, DWORD PTR _pchTarget$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTarget$[ebp], eax

; 5777 : 
; 5778 :             // Copy formatted date-time string to szTarget and terminate
; 5779 :             // with a quote.
; 5780 :             zstrcpy( pchTarget, szDateTime2 );

	lea	ecx, DWORD PTR _szDateTime2$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTarget$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 5781 :             zstrcat( pchTarget, "'" );

	push	OFFSET $SG96195
	mov	eax, DWORD PTR _pchTarget$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 5782 : 
; 5783 :             if ( bAddEscapeSequence )

	movzx	ecx, BYTE PTR _bAddEscapeSequence$5[ebp]
	test	ecx, ecx
	je	SHORT $LN29@fnDBH_Call

; 5784 :             {
; 5785 :                // Terminate escape sequence.
; 5786 :                pchTarget = pchTarget + zstrlen( pchTarget );

	mov	edx, DWORD PTR _pchTarget$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchTarget$[ebp]
	mov	DWORD PTR _pchTarget$[ebp], eax

; 5787 :                *pchTarget++ = ' ';

	mov	eax, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [eax], 32			; 00000020H
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTarget$[ebp], ecx

; 5788 :                *pchTarget++ = '}';

	mov	edx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [edx], 125			; 0000007dH
	mov	eax, DWORD PTR _pchTarget$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTarget$[ebp], eax

; 5789 :                *pchTarget++ = 0;

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _pchTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTarget$[ebp], edx
$LN29@fnDBH_Call:

; 5790 :             }
; 5791 : 
; 5792 :             return( TRUE ); // Return code indicating we handled it ok.

	mov	eax, 1
	jmp	$LN1@fnDBH_Call
$LN14@fnDBH_Call:

; 5793 : 
; 5794 :          } // if...
; 5795 : 
; 5796 : #endif
; 5797 :          // If we get here then nobody handled the message so return FALSE.
; 5798 :          return( FALSE );

	xor	eax, eax
	jmp	$LN1@fnDBH_Call
$LN30@fnDBH_Call:

; 5799 :       }
; 5800 : 
; 5801 :       // ==========================================================
; 5802 :       case zSQLCALLBACK_GETATTRVALUE:
; 5803 : 
; 5804 : #if defined( DB2 ) || defined( ODBC )
; 5805 : 
; 5806 :          // We only need to worry about blobs/varchars.
; 5807 :          if ( (g_bHoldStmtHandles &&
; 5808 :                lpCallbackInfo->cBuildFunction == BUILD_SELECT) ||
; 5809 :               lpDataField->cFldType == zTYPE_BLOB ||

	movzx	eax, BYTE PTR _g_bHoldStmtHandles
	test	eax, eax
	je	SHORT $LN33@fnDBH_Call
	mov	ecx, DWORD PTR _lpCallbackInfo$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 83					; 00000053H
	je	SHORT $LN32@fnDBH_Call
$LN33@fnDBH_Call:
	mov	eax, DWORD PTR _lpDataField$[ebp]
	movsx	ecx, BYTE PTR [eax+270]
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN32@fnDBH_Call
	mov	edx, DWORD PTR _lpDataField$[ebp]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 86					; 00000056H
	jne	SHORT $LN31@fnDBH_Call
$LN32@fnDBH_Call:

; 5810 :               lpDataField->cFldType == 'V' )
; 5811 :          {
; 5812 :             // For LONG VARCHAR variables, create a bind variable.
; 5813 :             SqlAddBoundAttr( lpBoundList, lpDataField, lpView, 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataField$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBoundList$[ebp]
	push	eax
	call	_SqlAddBoundAttr@20

; 5814 :             zstrcat( pchTarget, "?" );

	push	OFFSET $SG96201
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 5815 : 
; 5816 :             return( TRUE ); // Return code indicating we handled it ok.

	mov	eax, 1
	jmp	SHORT $LN1@fnDBH_Call
$LN31@fnDBH_Call:

; 5817 :          }
; 5818 : 
; 5819 : #endif
; 5820 :          // If we get here then nobody handled the message so return FALSE.
; 5821 :          return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnDBH_Call
$LN34@fnDBH_Call:

; 5822 : 
; 5823 :       // ==========================================================
; 5824 :       case zSQLCALLBACK_GETCOLUMNNAME:
; 5825 : 
; 5826 : #if defined ( DB2 )
; 5827 : 
; 5828 :       {
; 5829 :          LPVIEWATTRIB lpViewAttrib;
; 5830 : 
; 5831 :          // If pInfo is 0 then we are getting the column name for a
; 5832 :          // SELECT statement.  We can use the default processing for non
; 5833 :          // SELECT statements.
; 5834 :          if ( pInfo )
; 5835 :             return( FALSE );
; 5836 : 
; 5837 :          lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );
; 5838 : 
; 5839 :          // For the 'COUNT' command we have to insert 'DISTINCT'.
; 5840 :          if ( lpViewAttrib->cDB_Oper == 'C' )
; 5841 :             zstrcat( pchTarget, " DISTINCT " );
; 5842 : 
; 5843 :          // We'll return FALSE even if we've done something here because we
; 5844 :          // want the dbhandler to tack on the column name.
; 5845 :          return( FALSE );
; 5846 :       }
; 5847 : 
; 5848 : #endif
; 5849 : 
; 5850 :          return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnDBH_Call
$LN35@fnDBH_Call:

; 5851 : 
; 5852 :       // ==========================================================
; 5853 :       case zSQLCALLBACK_USEINTO:
; 5854 :          return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnDBH_Call
$LN36@fnDBH_Call:

; 5855 : 
; 5856 :       // ==========================================================
; 5857 :       case zSQLCALLBACK_GETINTONAME:
; 5858 :          return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnDBH_Call
$LN37@fnDBH_Call:

; 5859 : 
; 5860 :       case zSQLCALLBACK_GETCOLLISTPOS:
; 5861 : #ifdef ODBC
; 5862 :          if ( lpDataField->cFldType == zTYPE_BLOB ||

	mov	edx, DWORD PTR _lpDataField$[ebp]
	movsx	eax, BYTE PTR [edx+270]
	cmp	eax, 66					; 00000042H
	je	SHORT $LN40@fnDBH_Call
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	movsx	edx, BYTE PTR [ecx+270]
	cmp	edx, 86					; 00000056H
	jne	SHORT $LN38@fnDBH_Call
$LN40@fnDBH_Call:

; 5863 :               lpDataField->cFldType == 'V' )
; 5864 :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@fnDBH_Call
	jmp	SHORT $LN2@fnDBH_Call
$LN38@fnDBH_Call:

; 5865 :          else
; 5866 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnDBH_Call
$LN2@fnDBH_Call:

; 5867 : #else
; 5868 :          return( FALSE );
; 5869 : #endif
; 5870 : 
; 5871 :    } // switch ( nCommand )...
; 5872 : 
; 5873 :    // If we get here then we didn't handle the request so return FALSE.
; 5874 :    return( FALSE );

	xor	eax, eax
$LN1@fnDBH_Call:

; 5875 : 
; 5876 : } // fnDBH_Callback

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	2
$LN44@fnDBH_Call:
	DD	$LN12@fnDBH_Call
	DD	$LN11@fnDBH_Call
	DD	$LN2@fnDBH_Call
	DD	$LN13@fnDBH_Call
	DD	$LN2@fnDBH_Call
	DD	$LN2@fnDBH_Call
	DD	$LN2@fnDBH_Call
	DD	$LN30@fnDBH_Call
$LN45@fnDBH_Call:
	DD	$LN34@fnDBH_Call
	DD	$LN35@fnDBH_Call
	DD	$LN36@fnDBH_Call
	DD	$LN37@fnDBH_Call
	DD	$LN2@fnDBH_Call
$LN43@fnDBH_Call:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnDBH_Callback@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpValue$ = -60						; size = 4
_lpViewEntity$1 = -56					; size = 4
_nColumnSize$2 = -52					; size = 4
_lpDataField$3 = -48					; size = 4
tv95 = -44						; size = 4
_ulLth$ = -40						; size = 4
_lpViewAttrib$4 = -36					; size = 4
_lpBoundAttr$ = -32					; size = 4
_nLth$5 = -28						; size = 4
_nDecDigits$6 = -24					; size = 2
_nRC$ = -20						; size = 2
_nParmType$7 = -16					; size = 2
_nValueType$8 = -12					; size = 2
_nParmCount$ = -8					; size = 2
_chType$ = -1						; size = 1
_lpConnection$ = 8					; size = 4
_lpBoundList$ = 12					; size = 4
_WriteLongChar PROC

; 5099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 5100 :    LPBOUNDATTR  lpBoundAttr;
; 5101 :    zCHAR        chType;
; 5102 :    zPVOID       lpValue;
; 5103 :    zULONG       ulLth;
; 5104 :    zUSHORT      nParmCount;
; 5105 :    zSHORT       nRC;
; 5106 : 
; 5107 :    // If there are no attributes to be bound, then return.
; 5108 :    if ( lpBoundList->lpFirstBoundAttr == 0 )

	mov	eax, DWORD PTR _lpBoundList$[ebp]
	cmp	DWORD PTR [eax+6], 0
	jne	SHORT $LN7@WriteLongC

; 5109 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@WriteLongC
$LN7@WriteLongC:

; 5110 : 
; 5111 :    // Loop through each bound attribute and write it to the database.
; 5112 :    nParmCount = 0;

	xor	ecx, ecx
	mov	WORD PTR _nParmCount$[ebp], cx

; 5113 :    for ( lpBoundAttr = lpBoundList->lpFirstBoundAttr;

	mov	edx, DWORD PTR _lpBoundList$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _lpBoundAttr$[ebp], eax
	jmp	SHORT $LN4@WriteLongC
$LN2@WriteLongC:

; 5115 :          lpBoundAttr = lpBoundAttr->lpNextBoundAttr )

	mov	ecx, DWORD PTR _lpBoundAttr$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _lpBoundAttr$[ebp], edx
$LN4@WriteLongC:

; 5114 :          lpBoundAttr;

	cmp	DWORD PTR _lpBoundAttr$[ebp], 0
	je	$LN3@WriteLongC

; 5116 :    {
; 5117 :       LPDATAFIELD    lpDataField  = lpBoundAttr->lpDataField;

	mov	eax, DWORD PTR _lpBoundAttr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpDataField$3[ebp], ecx

; 5118 :       LPVIEWATTRIB   lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$3[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewAttrib$4[ebp], eax

; 5119 :       LPVIEWENTITY   lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 5120 :       SQLSMALLINT    nValueType;
; 5121 :       SQLSMALLINT    nParmType;
; 5122 :       SQLSMALLINT    nDecDigits;
; 5123 :       SQLUINTEGER    nColumnSize;
; 5124 :       SQLINTEGER     nLth;
; 5125 : 
; 5126 :       nParmCount++;

	mov	ax, WORD PTR _nParmCount$[ebp]
	add	ax, 1
	mov	WORD PTR _nParmCount$[ebp], ax

; 5127 : 
; 5128 :       if ( lpConnection->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 1
	jle	SHORT $LN8@WriteLongC

; 5129 :       {
; 5130 :          TraceLineS( "(KZHSQLBA) WriteLongChar attributename = ",

	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG95927
	call	_TraceLineS@8

; 5131 :                      lpViewAttrib->szName );
; 5132 :          TraceLineI( "nParmCount = ", nParmCount );

	movzx	ecx, WORD PTR _nParmCount$[ebp]
	push	ecx
	push	OFFSET $SG95928
	call	_TraceLineI@8
$LN8@WriteLongC:

; 5133 :       }
; 5134 : 
; 5135 :       // Get pointer to var and get length.
; 5136 :       GetValueFromRecord( lpBoundAttr->lpView,

	lea	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _chType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBoundAttr$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_GetValueFromRecord@24

; 5137 :                           lpViewEntity, lpViewAttrib, (zPVOID) &lpValue,
; 5138 :                           &chType, &ulLth );
; 5139 : 
; 5140 :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv95[ebp], cl
	cmp	BYTE PTR tv95[ebp], 66			; 00000042H
	je	SHORT $LN9@WriteLongC
	cmp	BYTE PTR tv95[ebp], 83			; 00000053H
	je	SHORT $LN12@WriteLongC
	jmp	$LN5@WriteLongC
$LN9@WriteLongC:

; 5141 :       {
; 5142 :          case zTYPE_BLOB:
; 5143 :             nValueType = SQL_C_BINARY;

	mov	edx, -2					; fffffffeH
	mov	WORD PTR _nValueType$8[ebp], dx

; 5144 : #ifdef DB2
; 5145 :             nParmType  = SQL_BLOB;
; 5146 : #else
; 5147 :             nParmType  = SQL_LONGVARBINARY;

	mov	eax, -4					; fffffffcH
	mov	WORD PTR _nParmType$7[ebp], ax

; 5148 : #endif
; 5149 :             nLth = (SQLINTEGER) ulLth;

	mov	ecx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR _nLth$5[ebp], ecx

; 5150 : 
; 5151 :             if ( nLth == 0 )

	cmp	DWORD PTR _nLth$5[ebp], 0
	jne	SHORT $LN10@WriteLongC

; 5152 :                lpConnection->nStrLth[ nParmCount - 1 ] = SQL_NULL_DATA;

	movzx	edx, WORD PTR _nParmCount$[ebp]
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [eax+edx*4+800], -1
	jmp	SHORT $LN11@WriteLongC
$LN10@WriteLongC:

; 5153 :             else
; 5154 :                lpConnection->nStrLth[ nParmCount - 1 ] = nLth;

	movzx	ecx, WORD PTR _nParmCount$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR _nLth$5[ebp]
	mov	DWORD PTR [edx+ecx*4+800], eax
$LN11@WriteLongC:

; 5155 : 
; 5156 :             break;

	jmp	SHORT $LN5@WriteLongC
$LN12@WriteLongC:

; 5157 : 
; 5158 :          case zTYPE_STRING:
; 5159 :             nValueType = SQL_C_CHAR;

	mov	ecx, 1
	mov	WORD PTR _nValueType$8[ebp], cx

; 5160 :             nParmType  = SQL_LONGVARCHAR;

	or	edx, -1
	mov	WORD PTR _nParmType$7[ebp], dx

; 5161 : 
; 5162 :             // ulLth includes the null-terminator.  If ulLth == 1 then string
; 5163 :             // is empty.
; 5164 :             if ( ulLth <= 1 )

	cmp	DWORD PTR _ulLth$[ebp], 1
	ja	SHORT $LN13@WriteLongC

; 5165 :             {
; 5166 :                lpConnection->nStrLth[ nParmCount - 1 ] = SQL_NULL_DATA;

	movzx	eax, WORD PTR _nParmCount$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+eax*4+800], -1

; 5167 :                nLth = 0;

	mov	DWORD PTR _nLth$5[ebp], 0

; 5168 :             }

	jmp	SHORT $LN5@WriteLongC
$LN13@WriteLongC:

; 5169 :             else
; 5170 :             {
; 5171 :                nLth = (SQLINTEGER) ulLth;

	mov	edx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR _nLth$5[ebp], edx

; 5172 :                lpConnection->nStrLth[ nParmCount - 1 ] = SQL_NTS;

	movzx	eax, WORD PTR _nParmCount$[ebp]
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	DWORD PTR [ecx+eax*4+800], -3		; fffffffdH
$LN5@WriteLongC:

; 5173 :             }
; 5174 :             break;
; 5175 :       }
; 5176 : 
; 5177 :       nColumnSize = nLth;

	mov	edx, DWORD PTR _nLth$5[ebp]
	mov	DWORD PTR _nColumnSize$2[ebp], edx

; 5178 :       nDecDigits = 0;

	xor	eax, eax
	mov	WORD PTR _nDecDigits$6[ebp], ax

; 5179 : 
; 5180 : #if 0
; 5181 :       nRC = SQLDescribeParam( lpConnection->hstmt, nParmCount, &nParmType,
; 5182 :                               &nColumnSize, &nDecDigits, &nNullable );
; 5183 :       SQL_RC( "SQLDescribeParam", nRC, "Column = ", lpDataField->szFldName, 3 );
; 5184 : #endif
; 5185 : 
; 5186 :       nRC = SQLBindParameter( lpConnection->hstmt, nParmCount, SQL_PARAM_INPUT,

	movzx	ecx, WORD PTR _nParmCount$[ebp]
	mov	edx, DWORD PTR _lpConnection$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4+800]
	push	eax
	mov	ecx, DWORD PTR _nLth$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValue$[ebp]
	push	edx
	movzx	eax, WORD PTR _nDecDigits$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _nColumnSize$2[ebp]
	push	ecx
	movzx	edx, WORD PTR _nParmType$7[ebp]
	push	edx
	movzx	eax, WORD PTR _nValueType$8[ebp]
	push	eax
	push	1
	movzx	ecx, WORD PTR _nParmCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	push	eax
	call	_SQLBindParameter@40
	mov	WORD PTR _nRC$[ebp], ax

; 5187 :                               nValueType, nParmType, nColumnSize, nDecDigits,
; 5188 :                               (SQLPOINTER) lpValue, nLth,
; 5189 :                               &lpConnection->nStrLth[ nParmCount - 1 ] );
; 5190 :       SQL_RC( "SQLBindParameter", nRC, "Column = ", lpDataField->szFldName, 3 );

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _lpDataField$3[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG95935
	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG95936
	call	_fnSqlRC
	add	esp, 24					; 00000018H

; 5191 : 
; 5192 :       if ( lpConnection->nTraceLevel > 2 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 2
	jle	SHORT $LN15@WriteLongC

; 5193 :       {
; 5194 :          TraceLineI( "nValueType  = ", nValueType );

	movsx	eax, WORD PTR _nValueType$8[ebp]
	push	eax
	push	OFFSET $SG95938
	call	_TraceLineI@8

; 5195 :          TraceLineI( "nParmType   = ", nParmType );

	movsx	ecx, WORD PTR _nParmType$7[ebp]
	push	ecx
	push	OFFSET $SG95939
	call	_TraceLineI@8

; 5196 :          TraceLineI( "nColumnSize = ", nColumnSize );

	mov	edx, DWORD PTR _nColumnSize$2[ebp]
	push	edx
	push	OFFSET $SG95940
	call	_TraceLineI@8

; 5197 :          TraceLineI( "nDecDigits  = ", nDecDigits );

	movsx	eax, WORD PTR _nDecDigits$6[ebp]
	push	eax
	push	OFFSET $SG95941
	call	_TraceLineI@8

; 5198 :          TraceLineI( "nLth        = ", nLth );

	mov	ecx, DWORD PTR _nLth$5[ebp]
	push	ecx
	push	OFFSET $SG95942
	call	_TraceLineI@8
$LN15@WriteLongC:

; 5199 :       }
; 5200 : 
; 5201 :       if ( !RC_SUCCESSFUL( nRC ) )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN16@WriteLongC
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN16@WriteLongC

; 5202 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@WriteLongC
$LN16@WriteLongC:

; 5203 : 
; 5204 :    } // for...

	jmp	$LN2@WriteLongC
$LN3@WriteLongC:

; 5205 : 
; 5206 :    return( 0 );

	xor	eax, eax
$LN1@WriteLongC:

; 5207 : 
; 5208 : }  /* WriteLongChar */

	mov	esp, ebp
	pop	ebp
	ret	0
_WriteLongChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_pchErrorMsg$ = 12					; size = 4
_nRC$ = 16						; size = 4
_pchInfo$ = 20						; size = 4
_DBH_Error PROC

; 4307 : {

	push	ebp
	mov	ebp, esp

; 4308 :    TraceLineS( "===== DBH_Entry Error =====", "" );

	push	OFFSET $SG95630
	push	OFFSET $SG95631
	call	_TraceLineS@8

; 4309 :    TraceLineS( "Msg=> ", pchErrorMsg );

	mov	eax, DWORD PTR _pchErrorMsg$[ebp]
	push	eax
	push	OFFSET $SG95632
	call	_TraceLineS@8

; 4310 : 
; 4311 :    if ( nRC )

	cmp	DWORD PTR _nRC$[ebp], 0
	je	SHORT $LN2@DBH_Error

; 4312 :       TraceLineI( "nRC=> ", nRC );

	mov	ecx, DWORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG95634
	call	_TraceLineI@8
$LN2@DBH_Error:

; 4313 : 
; 4314 :    if ( pchInfo )

	cmp	DWORD PTR _pchInfo$[ebp], 0
	je	SHORT $LN3@DBH_Error

; 4315 :       TraceLineS( pchInfo, "" );

	push	OFFSET $SG95636
	mov	edx, DWORD PTR _pchInfo$[ebp]
	push	edx
	call	_TraceLineS@8
$LN3@DBH_Error:

; 4316 : 
; 4317 :    MessageSend( lpView, "KZH0101", DBHANDLER_NAME " DBH Error",

	push	0
	push	1000					; 000003e8H
	mov	eax, DWORD PTR _pchErrorMsg$[ebp]
	push	eax
	push	OFFSET $SG95637
	push	OFFSET $SG95638
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MessageSend@24

; 4318 :                 pchErrorMsg,
; 4319 :                 zMSGQ_SYSTEM_ERROR, 0 );
; 4320 : 
; 4321 : }  /* DBH_Error */

	pop	ebp
	ret	0
_DBH_Error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_sdNativeError$1 = -2088				; size = 4
_sdNumRecs$2 = -2084					; size = 4
_nTextLength$3 = -2080					; size = 2
_hSql$4 = -2076						; size = 4
_iHandleType$5 = -2072					; size = 2
_k$6 = -2068						; size = 2
_szText$ = -2064					; size = 2000
_szText2$ = -64						; size = 50
_szSQLState$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_pchRoutine$ = 8					; size = 4
_nRC$ = 12						; size = 2
_lpConnection$ = 16					; size = 4
_DisplayCommand PROC

; 4483 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2088				; 00000828H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4484 :    zCHAR   szText[ 2000 ];
; 4485 :    zCHAR   szText2[ 50 ];
; 4486 :    zCHAR   szSQLState[ 6 ];
; 4487 : 
; 4488 :    if ( lpConnection->nTraceLevel == 0 && nRC == SQL_SUCCESS )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	movsx	ecx, WORD PTR [eax+214]
	test	ecx, ecx
	jne	SHORT $LN5@DisplayCom
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN5@DisplayCom

; 4489 :       return;

	jmp	$LN1@DisplayCom
$LN5@DisplayCom:

; 4490 : 
; 4491 :    if ( lpConnection->bMultipleDatabases )

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+800]
	and	ecx, 1
	je	SHORT $LN6@DisplayCom

; 4492 :    {
; 4493 :       TraceLineS( "", "" );

	push	OFFSET $SG95684
	push	OFFSET $SG95685
	call	_TraceLineS@8

; 4494 :       TraceLineS( "Database name = ",

	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+218]
	imul	ecx, eax, 58
	mov	edx, DWORD PTR _lpConnection$[ebp]
	lea	eax, DWORD PTR [edx+ecx+220]
	push	eax
	push	OFFSET $SG95686
	call	_TraceLineS@8
$LN6@DisplayCom:

; 4495 :        lpConnection->DBConnection[ lpConnection->nCurrentDB ].szDatabaseName );
; 4496 :    }
; 4497 : 
; 4498 :    TraceLineS( "", "" );

	push	OFFSET $SG95687
	push	OFFSET $SG95688
	call	_TraceLineS@8

; 4499 : 
; 4500 :    if ( lpConnection->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	cmp	edx, 1
	jle	SHORT $LN7@DisplayCom

; 4501 :    {
; 4502 :       TraceLineS( "ODBC Call : ", pchRoutine );

	mov	eax, DWORD PTR _pchRoutine$[ebp]
	push	eax
	push	OFFSET $SG95691
	call	_TraceLineS@8

; 4503 :       SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );

	push	0
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+194]
	push	edx
	call	_SqlDisplayCommand@8

; 4504 :       TraceLineS( "Return Code :", fnRC_Text( nRC ) );

	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	call	_fnRC_Text
	add	esp, 4
	push	eax
	push	OFFSET $SG95692
	call	_TraceLineS@8

; 4505 :    }

	jmp	SHORT $LN8@DisplayCom
$LN7@DisplayCom:

; 4506 :    else
; 4507 :       SqlDisplayCommand( lpConnection->pchConnSqlCmd, 0 );

	push	0
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+194]
	push	edx
	call	_SqlDisplayCommand@8
$LN8@DisplayCom:

; 4508 : 
; 4509 :    if ( nRC != SQL_SUCCESS )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	$LN1@DisplayCom

; 4510 :    {
; 4511 :       SQLHANDLE   hSql;
; 4512 :       SQLSMALLINT iHandleType;
; 4513 :       SDWORD      sdNumRecs;
; 4514 :       SQLSMALLINT k;
; 4515 :       SDWORD      sdNativeError;
; 4516 :       SQLSMALLINT nTextLength;
; 4517 : 
; 4518 :       if ( lpConnection->hstmt )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [ecx+2812], 0
	je	SHORT $LN10@DisplayCom

; 4519 :       {
; 4520 :          hSql = lpConnection->hstmt;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	mov	DWORD PTR _hSql$4[ebp], eax

; 4521 :          iHandleType = SQL_HANDLE_STMT;

	mov	ecx, 3
	mov	WORD PTR _iHandleType$5[ebp], cx

; 4522 :       }

	jmp	SHORT $LN11@DisplayCom
$LN10@DisplayCom:

; 4523 :       else
; 4524 :       if ( lpConnection->hdbc )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+2808], 0
	je	SHORT $LN12@DisplayCom

; 4525 :       {
; 4526 :          hSql = lpConnection->hdbc;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2808]
	mov	DWORD PTR _hSql$4[ebp], ecx

; 4527 :          iHandleType = SQL_HANDLE_DBC;

	mov	edx, 2
	mov	WORD PTR _iHandleType$5[ebp], dx

; 4528 :       }

	jmp	SHORT $LN11@DisplayCom
$LN12@DisplayCom:

; 4529 :       else
; 4530 :       {
; 4531 :          hSql = lpConnection->henv;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2804]
	mov	DWORD PTR _hSql$4[ebp], ecx

; 4532 :          iHandleType = SQL_HANDLE_ENV;

	mov	edx, 1
	mov	WORD PTR _iHandleType$5[ebp], dx
$LN11@DisplayCom:

; 4533 :       }
; 4534 : 
; 4535 :       SQLGetDiagField( iHandleType, hSql, 0, SQL_DIAG_NUMBER, &sdNumRecs,

	push	0
	push	4
	lea	eax, DWORD PTR _sdNumRecs$2[ebp]
	push	eax
	push	2
	push	0
	mov	ecx, DWORD PTR _hSql$4[ebp]
	push	ecx
	movzx	edx, WORD PTR _iHandleType$5[ebp]
	push	edx
	call	_SQLGetDiagField@28

; 4536 :                        sizeof( sdNumRecs ), 0 );
; 4537 : 
; 4538 :       if ( nRC != SQL_SUCCESS_WITH_INFO )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN14@DisplayCom

; 4539 :          TraceLineS( "===== SQL ODBC Error ===== rc = ", fnRC_Text( nRC ) );

	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	call	_fnRC_Text
	add	esp, 4
	push	eax
	push	OFFSET $SG95700
	call	_TraceLineS@8
	jmp	SHORT $LN15@DisplayCom
$LN14@DisplayCom:

; 4540 :       else
; 4541 :          TraceLineS( "===== SQL ODBC Info ===== rc = ", fnRC_Text( nRC ) );

	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	call	_fnRC_Text
	add	esp, 4
	push	eax
	push	OFFSET $SG95701
	call	_TraceLineS@8
$LN15@DisplayCom:

; 4542 : 
; 4543 :       for ( k = 1; k <= sdNumRecs && k < 5; k++ )

	mov	eax, 1
	mov	WORD PTR _k$6[ebp], ax
	jmp	SHORT $LN4@DisplayCom
$LN2@DisplayCom:
	mov	cx, WORD PTR _k$6[ebp]
	add	cx, 1
	mov	WORD PTR _k$6[ebp], cx
$LN4@DisplayCom:
	movsx	edx, WORD PTR _k$6[ebp]
	cmp	edx, DWORD PTR _sdNumRecs$2[ebp]
	jg	$LN1@DisplayCom
	movsx	eax, WORD PTR _k$6[ebp]
	cmp	eax, 5
	jge	$LN1@DisplayCom

; 4544 :       {
; 4545 :          SQLGetDiagRec( iHandleType, hSql, k, szSQLState, &sdNativeError,

	lea	ecx, DWORD PTR _nTextLength$3[ebp]
	push	ecx
	push	2000					; 000007d0H
	lea	edx, DWORD PTR _szText$[ebp]
	push	edx
	lea	eax, DWORD PTR _sdNativeError$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _szSQLState$[ebp]
	push	ecx
	movzx	edx, WORD PTR _k$6[ebp]
	push	edx
	mov	eax, DWORD PTR _hSql$4[ebp]
	push	eax
	movzx	ecx, WORD PTR _iHandleType$5[ebp]
	push	ecx
	call	_SQLGetDiagRec@32

; 4546 :                         szText, sizeof( szText ), &nTextLength );
; 4547 :          zsprintf( szText2, "[ODBC] SQLState = %s, Err=", szSQLState );

	lea	edx, DWORD PTR _szSQLState$[ebp]
	push	edx
	push	OFFSET $SG95702
	lea	eax, DWORD PTR _szText2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4548 :          TraceLineS( szText2, szText );

	lea	ecx, DWORD PTR _szText$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szText2$[ebp]
	push	edx
	call	_TraceLineS@8

; 4549 : 
; 4550 :          MessageSend( lpConnection->lpAppView, "KZH0102", "ODBC DBH Error",

	push	0
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _szText$[ebp]
	push	eax
	push	OFFSET $SG95703
	push	OFFSET $SG95704
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	_MessageSend@24

; 4551 :                       szText, zMSGQ_SYSTEM_ERROR, 0 );
; 4552 :       }

	jmp	$LN2@DisplayCom
$LN1@DisplayCom:

; 4553 :    }
; 4554 : 
; 4555 : }  /* DisplayCommand */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DisplayCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxa.c
_TEXT	SEGMENT
_sdNativeError$1 = -2100				; size = 4
_sdNumRecs$2 = -2096					; size = 4
_nTextLength$3 = -2092					; size = 2
tv86 = -2088						; size = 4
tv85 = -2084						; size = 4
_hSql$4 = -2080						; size = 4
_iHandleType$5 = -2076					; size = 2
_k$6 = -2072						; size = 2
_bCmdOK$ = -2065					; size = 1
_szText$ = -2064					; size = 2000
_szText2$ = -64						; size = 50
_szSQLState$7 = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_pchRoutine$ = 8					; size = 4
_nRC$ = 12						; size = 2
_pchInfo1$ = 16						; size = 4
_pchInfo2$ = 20						; size = 4
_nTrcLvl$ = 24						; size = 2
_lpConnection$ = 28					; size = 4
_fnSqlRC PROC

; 4968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2100				; 00000834H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4969 :    zCHAR  szText[ 2000 ];
; 4970 :    zCHAR  szText2[ 50 ];
; 4971 :    zBOOL bCmdOK = FALSE;

	mov	BYTE PTR _bCmdOK$[ebp], 0

; 4972 : 
; 4973 :    if ( RC_SUCCESSFUL( nRC ) &&

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN6@fnSqlRC
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN5@fnSqlRC
$LN6@fnSqlRC:
	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	movsx	ecx, WORD PTR _nTrcLvl$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN7@fnSqlRC
	mov	edx, DWORD PTR _lpConnection$[ebp]
	movsx	eax, WORD PTR [edx+214]
	test	eax, eax
	jne	SHORT $LN5@fnSqlRC
$LN7@fnSqlRC:

; 4974 :         (lpConnection->nTraceLevel < nTrcLvl ||
; 4975 :          lpConnection->nTraceLevel == 0) )
; 4976 :    {
; 4977 :       return;

	jmp	$LN1@fnSqlRC
$LN5@fnSqlRC:

; 4978 :    }
; 4979 : 
; 4980 :    // In certain cases a return code is OK.
; 4981 :    if ( zstrcmp( pchRoutine, "SQLFetch" ) == 0 )

	mov	ecx, DWORD PTR _pchRoutine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG95871
	cmp	edx, eax
	jne	SHORT $LN25@fnSqlRC
	push	OFFSET $SG95872
	mov	ecx, DWORD PTR _pchRoutine$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN26@fnSqlRC
$LN25@fnSqlRC:
	mov	edx, DWORD PTR _pchRoutine$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG95873
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN23@fnSqlRC
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN24@fnSqlRC
$LN23@fnSqlRC:
	mov	DWORD PTR tv85[ebp], -1
$LN24@fnSqlRC:
	mov	edx, DWORD PTR tv85[ebp]
	mov	DWORD PTR tv86[ebp], edx
$LN26@fnSqlRC:
	cmp	DWORD PTR tv86[ebp], 0
	jne	SHORT $LN8@fnSqlRC

; 4982 :    {
; 4983 :       if ( nRC == SQL_NO_DATA )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 100				; 00000064H
	jne	SHORT $LN8@fnSqlRC

; 4984 :       {
; 4985 :          // The return code is OK so get out if we're not tracing out RCs
; 4986 :          // that worked OK.
; 4987 :          if ( lpConnection->nTraceLevel < nTrcLvl ||

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	movsx	eax, WORD PTR _nTrcLvl$[ebp]
	cmp	edx, eax
	jl	SHORT $LN11@fnSqlRC
	mov	ecx, DWORD PTR _lpConnection$[ebp]
	movsx	edx, WORD PTR [ecx+214]
	test	edx, edx
	jne	SHORT $LN10@fnSqlRC
$LN11@fnSqlRC:

; 4988 :               lpConnection->nTraceLevel == 0 )
; 4989 :          {
; 4990 :             return;

	jmp	$LN1@fnSqlRC
$LN10@fnSqlRC:

; 4991 :          }
; 4992 : 
; 4993 :          bCmdOK = TRUE;

	mov	BYTE PTR _bCmdOK$[ebp], 1
$LN8@fnSqlRC:

; 4994 :       }
; 4995 :    }
; 4996 : 
; 4997 :    TraceLineS( "", "" );

	push	OFFSET $SG95877
	push	OFFSET $SG95878
	call	_TraceLineS@8

; 4998 :    if ( !RC_SUCCESSFUL( nRC ) && bCmdOK == FALSE )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN12@fnSqlRC
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 1
	je	SHORT $LN12@fnSqlRC
	movzx	edx, BYTE PTR _bCmdOK$[ebp]
	test	edx, edx
	jne	SHORT $LN12@fnSqlRC

; 4999 :       TraceLineS( "===== ODBC Error =====", "" );

	push	OFFSET $SG95880
	push	OFFSET $SG95881
	call	_TraceLineS@8
$LN12@fnSqlRC:

; 5000 : 
; 5001 :    TraceLineS( "ODBC Call : ", pchRoutine );

	mov	eax, DWORD PTR _pchRoutine$[ebp]
	push	eax
	push	OFFSET $SG95882
	call	_TraceLineS@8

; 5002 :    TraceLineS( "RC        : ", fnRC_Text( nRC ) );

	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	call	_fnRC_Text
	add	esp, 4
	push	eax
	push	OFFSET $SG95883
	call	_TraceLineS@8

; 5003 : 
; 5004 :    if ( pchInfo1 )

	cmp	DWORD PTR _pchInfo1$[ebp], 0
	je	SHORT $LN13@fnSqlRC

; 5005 :    {
; 5006 :       if ( pchInfo2 )

	cmp	DWORD PTR _pchInfo2$[ebp], 0
	je	SHORT $LN14@fnSqlRC

; 5007 :          TraceLineS( pchInfo1, pchInfo2 );

	mov	edx, DWORD PTR _pchInfo2$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchInfo1$[ebp]
	push	eax
	call	_TraceLineS@8
	jmp	SHORT $LN13@fnSqlRC
$LN14@fnSqlRC:

; 5008 :       else
; 5009 :          TraceLineS( pchInfo1, "" );

	push	OFFSET $SG95887
	mov	ecx, DWORD PTR _pchInfo1$[ebp]
	push	ecx
	call	_TraceLineS@8
$LN13@fnSqlRC:

; 5010 :    }
; 5011 : 
; 5012 :    if ( nRC != SQL_SUCCESS && bCmdOK == FALSE )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	$LN1@fnSqlRC
	movzx	eax, BYTE PTR _bCmdOK$[ebp]
	test	eax, eax
	jne	$LN1@fnSqlRC

; 5013 :    {
; 5014 :       SQLHANDLE   hSql;
; 5015 :       SQLSMALLINT iHandleType;
; 5016 :       SDWORD      sdNumRecs;
; 5017 :       SQLSMALLINT k;
; 5018 :       SDWORD      sdNativeError;
; 5019 :       SQLSMALLINT nTextLength;
; 5020 :       zCHAR       szSQLState[ 6 ];
; 5021 : 
; 5022 :       if ( lpConnection->hstmt )

	mov	ecx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [ecx+2812], 0
	je	SHORT $LN17@fnSqlRC

; 5023 :       {
; 5024 :          hSql = lpConnection->hstmt;

	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+2812]
	mov	DWORD PTR _hSql$4[ebp], eax

; 5025 :          iHandleType = SQL_HANDLE_STMT;

	mov	ecx, 3
	mov	WORD PTR _iHandleType$5[ebp], cx

; 5026 :       }

	jmp	SHORT $LN18@fnSqlRC
$LN17@fnSqlRC:

; 5027 :       else
; 5028 :       if ( lpConnection->hdbc )

	mov	edx, DWORD PTR _lpConnection$[ebp]
	cmp	DWORD PTR [edx+2808], 0
	je	SHORT $LN19@fnSqlRC

; 5029 :       {
; 5030 :          hSql = lpConnection->hdbc;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2808]
	mov	DWORD PTR _hSql$4[ebp], ecx

; 5031 :          iHandleType = SQL_HANDLE_DBC;

	mov	edx, 2
	mov	WORD PTR _iHandleType$5[ebp], dx

; 5032 :       }

	jmp	SHORT $LN18@fnSqlRC
$LN19@fnSqlRC:

; 5033 :       else
; 5034 :       {
; 5035 :          hSql = lpConnection->henv;

	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+2804]
	mov	DWORD PTR _hSql$4[ebp], ecx

; 5036 :          iHandleType = SQL_HANDLE_ENV;

	mov	edx, 1
	mov	WORD PTR _iHandleType$5[ebp], dx
$LN18@fnSqlRC:

; 5037 :       }
; 5038 : 
; 5039 :       SQLGetDiagField( iHandleType, hSql, 0, SQL_DIAG_NUMBER, &sdNumRecs,

	push	0
	push	4
	lea	eax, DWORD PTR _sdNumRecs$2[ebp]
	push	eax
	push	2
	push	0
	mov	ecx, DWORD PTR _hSql$4[ebp]
	push	ecx
	movzx	edx, WORD PTR _iHandleType$5[ebp]
	push	edx
	call	_SQLGetDiagField@28

; 5040 :                        sizeof( sdNumRecs ), 0 );
; 5041 : 
; 5042 :       for ( k = 1; k <= sdNumRecs && k < 5; k++ )

	mov	eax, 1
	mov	WORD PTR _k$6[ebp], ax
	jmp	SHORT $LN4@fnSqlRC
$LN2@fnSqlRC:
	mov	cx, WORD PTR _k$6[ebp]
	add	cx, 1
	mov	WORD PTR _k$6[ebp], cx
$LN4@fnSqlRC:
	movsx	edx, WORD PTR _k$6[ebp]
	cmp	edx, DWORD PTR _sdNumRecs$2[ebp]
	jg	$LN1@fnSqlRC
	movsx	eax, WORD PTR _k$6[ebp]
	cmp	eax, 5
	jge	$LN1@fnSqlRC

; 5043 :       {
; 5044 :          SQLGetDiagRec( iHandleType, hSql, k, szSQLState, &sdNativeError,

	lea	ecx, DWORD PTR _nTextLength$3[ebp]
	push	ecx
	push	2000					; 000007d0H
	lea	edx, DWORD PTR _szText$[ebp]
	push	edx
	lea	eax, DWORD PTR _sdNativeError$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _szSQLState$7[ebp]
	push	ecx
	movzx	edx, WORD PTR _k$6[ebp]
	push	edx
	mov	eax, DWORD PTR _hSql$4[ebp]
	push	eax
	movzx	ecx, WORD PTR _iHandleType$5[ebp]
	push	ecx
	call	_SQLGetDiagRec@32

; 5045 :                         szText, sizeof( szText ), &nTextLength );
; 5046 :          zsprintf( szText2, "[ODBC] SQLState = %s, Err=", szSQLState );

	lea	edx, DWORD PTR _szSQLState$7[ebp]
	push	edx
	push	OFFSET $SG95893
	lea	eax, DWORD PTR _szText2$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 5047 :          TraceLineS( szText2, szText );

	lea	ecx, DWORD PTR _szText$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szText2$[ebp]
	push	edx
	call	_TraceLineS@8

; 5048 : 
; 5049 :          fnSetDBHandlerError( lpConnection->lpAppView, (zLONG) sdNativeError,

	lea	eax, DWORD PTR _szText$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szSQLState$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _sdNativeError$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConnection$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	_fnSetDBHandlerError@16

; 5050 :                               szSQLState, szText );
; 5051 : 
; 5052 :          if ( k == 1 && nRC != SQL_SUCCESS_WITH_INFO )

	movsx	edx, WORD PTR _k$6[ebp]
	cmp	edx, 1
	jne	SHORT $LN21@fnSqlRC
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	je	SHORT $LN21@fnSqlRC

; 5053 :          {
; 5054 :             MessageSend( lpConnection->lpAppView, "KZH0102", "ODBC DBH Error",

	push	0
	push	1000					; 000003e8H
	lea	ecx, DWORD PTR _szText$[ebp]
	push	ecx
	push	OFFSET $SG95895
	push	OFFSET $SG95896
	mov	edx, DWORD PTR _lpConnection$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_MessageSend@24
$LN21@fnSqlRC:

; 5055 :                          szText, zMSGQ_SYSTEM_ERROR, 0 );
; 5056 :          }
; 5057 :       }

	jmp	$LN2@fnSqlRC
$LN1@fnSqlRC:

; 5058 :    }
; 5059 : }  /* fnSqlRC */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSqlRC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
