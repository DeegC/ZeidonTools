	TITLE	C:\10C\a\oe\KZHSQLXB.C
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_08DFNL@ABSOLUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LHNJ@ACTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CICP@ADD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03MJMD@ALL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HG@ALLOCATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NNIC@ALPHANUMERIC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05BBIN@ALTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03ENCN@ANY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JPOO@ARE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02EPAG@AS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HGDG@ASC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HNNJ@ASSERTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02BKOD@AT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MMGM@AUTHORIZATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@DFOG@AUTOINCREMENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JAGK@AVG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JBBL@BEGIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FEKN@BETWEEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06ICJB@BINARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IODA@BIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HLBB@BOOLEAN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NOIB@BOTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05CPDG@BREAK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MIPA@BROWSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OLDH@BULK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02HFGP@BY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HJNK@CASCADE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GIOF@CASCADED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LCDH@CASE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LBNA@CAST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CPI@CATALOG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MLPN@CHAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09MNBH@CHARACTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@OBEF@CHAR_LENGTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JHFD@CHECK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CINA@CHECKPOINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05PHOA@CLOSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GMHN@CLUSTERED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DMIM@COALESCE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HABJ@COLLATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JEOK@COLLATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LGEH@COLUMN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NAIG@COMMIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BMPB@COMMITTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FDPF@COMPUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ODJF@CONFIRM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DKLG@CONNECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@ICLB@CONNECTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@LNCA@CONSTRAINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GMLE@CONSTRAINTS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HDIP@CONTINUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@BOLK@CONTROLROW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DJAE@CONVERT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@MOMH@CORRESPONDING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05BNPO@COUNT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CCFH@COUNTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JBCM@CREATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05BLP@CROSS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CHBF@CURRENCY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HGLC@CURRENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NEAE@CURRENT_DATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIMH@CURRENT_TIME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@KBKG@CURRENT_USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MDJJ@CURSOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PKHN@DATABASE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CJNM@DATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MIJC@DATETIME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IDGA@DAY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OPFP@DBAREA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CLGJ@DBCC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JGIO@DEALLOCATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DAPA@DEBUG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CJJP@DECLARE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FBHA@DEFAULT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@POBB@DEFERRABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IEEN@DEFERRED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FMHL@DELETE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PPKB@DESC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FBJG@DESCRIBE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKAF@DESCRIPTOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@OKKK@DIAGNOSTICS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GADM@DISALLOW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBA@DISCONNECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HDPG@DISK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EGKJ@DISTINCT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EMHJ@DISTINCTROW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@ONJI@DISTRIBUTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EIOP@DOMAIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CGGE@DOUBLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LDDE@DROP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JGEC@DUMMY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CAAA@DUMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OHCC@ELSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PIHE@END?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08GNOH@END_EXEC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LKIC@EQV?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BKPA@ERRLVL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EIBF@ERROREXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MJIP@ESCAPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06GDHH@EXCEPT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EEOO@EXCEPTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GMDG@EXEC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DNBH@EXECUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MBBB@EXISTS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HPFN@EXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@ILPO@EXPIREDATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EDIC@EXTERNAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IODP@EXTRACT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LLOB@FALSE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KBKM@FETCH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CMDA@FILE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPIO@FILLFACTOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MPDO@FIRST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JDEL@FLOAT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FFP@FLOAT4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PLLL@FLOAT8?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IPNK@FLOPPY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03EOOH@FOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ECFK@FOREIGN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EJD@FROM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CLJK@FULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HLIC@GET?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PODI@GETDEFAULT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EKIF@GLOBAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DLHO@GOTO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DLPA@GRANT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JGM@GROUP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BGHA@GUID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06GNBD@HAVING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JHAN@HOLDLOCK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PJ@HOUR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MFJF@IDENTITY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EOA@IDENTITYCOL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JADB@IDENTITY_INSERT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CMNP@IEEEDOUBLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@FEGJ@IEEESINGLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02FDOJ@IF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HLND@IGNORE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LEPP@IMMEDIATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BIEI@IMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02HFB@IN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05HKPP@INDEX?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09BAOC@INITIALLY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05EPPB@INNER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05IHIC@INPUT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PDHJ@INSENSITIVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CCAI@INSERT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IJOL@INT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KMGD@INTEGER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PEKL@INTEGER1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08LBC@INTEGER2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GIDA@INTERSECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08JNLE@INTERVAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JMBE@INTO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JCKC@ISOLATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JIJO@JOIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03PHBO@KEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EIJF@KILL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GBPO@LAST?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HHCE@LEADING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PAN@LEFT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JJEC@LEVEL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CNFB@LIKE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MJFP@LINENO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PDLA@LOAD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JIPK@LOCAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OAKI@LOGICAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08KCOH@LOGICAL1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NIAI@LONG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKBM@LONGBINARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08HLJO@LONGTEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NFKB@MATCH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OLFE@MAX?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KGIF@MEMO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03IAC@MIN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IOKL@MINUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@GNDP@MIRROREXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03HOGL@MOD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05EBDH@MONEY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DOND@MONTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KDIJ@NAMES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CHPD@NATIONAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BGPN@NATURAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DFM@NCHAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04ONKL@NEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NAJC@NEXTLOG?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02MMJD@NO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07IMID@NOCHECK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NJNJ@NONCLUSTERED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CBCA@NOT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DFCK@NOTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06HGII@NULLIF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MDMK@NUMBER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FIAN@NUMERIC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@PBNP@OCTET_LENGTH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CEBG@OF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07FMHE@OFFSETS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GMOF@OLEOBJECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02HAKO@ON?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EJJC@ONCE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MKAH@ONLY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04MIME@OPEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IFCC@OPTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FBEP@ORDER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05IKJL@OUTER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BMBF@OUTPUT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HDCH@OVER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08PGNB@OVERLAPS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GPH@OWNERACCESS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BHFD@PAD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PEIP@PARAMETERS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MOBO@PARTIAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MGCH@PERCENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04ICKI@PERM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JLAF@PERMANENT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CDKK@PIPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MALJ@PIVOT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OOOE@PLAN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BGJK@POSITION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LJHE@PRECISION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07OCNH@PREPARE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07JPNB@PRESEVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07PLFH@PRIMARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MJOK@PRINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05CADC@PRIOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@IFKE@PRIVILEGES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFJE@PROC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HPKL@PROCEDURE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CNCJ@PROCESSEXIT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JPM@PUBLIC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EHBK@RAISERROR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GHHF@READ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IEGM@READTEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DDMN@REAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CLEO@RECONFIGURE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DHND@REFERENCES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NDFO@RELATIVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DEIL@REPEATABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@GBCL@REPLICATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08BEHK@RESTRICT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09NACH@RETAINDAY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PJJM@RETURN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MEJM@REVOKE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JCNK@RIGHT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EMFJ@ROLLBACK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MGKJ@ROWCOUNT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LCCO@ROWS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BFNM@RULE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04KLBG@SAVE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NIIF@SCHEMA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JLNB@SCROLL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FCJA@SECOND?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OGAC@SELECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCJF@SERIALIZABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CGDO@SESSION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@JGA@SESSION_USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BCLC@SET?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07EDEP@SETUSER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05HFLA@SHORT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DPKF@SHUTDOWN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06FONC@SINGLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NEFN@SIZE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DMN@SMALLINT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DDNG@SOME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JCH@SPACE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DHID@SQLSTATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@JMMG@STATISTICS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05KHBF@STDEV?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06OCBH@STDEVP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06JDFN@STRING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03CPEE@SUM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBHB@SYSTEM_USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05DLJE@TABLE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DAKP@TABLEID?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CGFH@TAPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09EAGL@TEMPORARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NILO@TEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FIJO@TEXTSIZE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GJFM@THEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CFBP@TIME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KEAG@TIMESTAMP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02DODL@TO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03JOIO@TOP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08NJGC@TRAILING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CGAE@TRAN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JACB@TRANSACTION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09ECBO@TRANSFORM?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09HNKP@TRANSLATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LOEK@TRANSLATION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07GNLP@TRIGGER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LNAG@TRUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FCAH@TRUNCATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CODK@TSEQUAL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PJEA@UNCOMMITTED?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LNOP@UNION?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06LNBM@UNIQUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CNPM@UNKNOWN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NDPG@UPDATE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DPMH@UPDATETEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05PMKE@USAGE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03OAHE@USE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04FMHO@USER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05JKMB@USING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MOEL@VALUE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06KGMH@VALUES?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03KNCG@VAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09OLDK@VARBINARY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NGFA@VARCHAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OIBN@VARP?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MMOJ@VARYING?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04CGLB@VIEW?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06IEGE@VOLUME?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07KCD@WAITFOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GKK@WHEN?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05MCFK@WHERE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05LCLH@WHILE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NHMN@WITH?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LDPM@WORK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FIFP@WRITE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IKOB@WRITETEXT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03BDEP@XOR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HEBB@YEAR?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NAPJ@YESNO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04HOL@ZONE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01A@?$AA?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FAJB@?$DL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IAKB@TZTEDBLO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EALC@DBMS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@BCDD@TE_DBMS_Source?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DKGC@DBH_Data?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KJKI@TimestampAsString?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04JENC@ODBC?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@GNCH@MaxColumnNameLength?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04EFNI@Name?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PJGE@TE_FieldDataRel?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FNON@DataType?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DOMO@?$CF?9?$CKs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CAAP@Length?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CPOG@?5longblob?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09IJHK@?5datetime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OGMO@?5int?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CLFL@?5double?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DKHG@?5longtext?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@NJGJ@?5INTEGER?5PRIMARY?5KEY?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08KJLB@?5INTEGER?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NCMM@TE_TablRec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LPMC@SQL_NULLS?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08IDDA@NOT?5NULL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08FGIB@NULL?5?5?5?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@HJOL@DefaultOwner?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@CNMG@SQL_TableOwner?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KOPE@MaxTableNameLength?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04DKMG@Desc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02BOOO@?$CK?1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02FCCF@?1?$CK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BBDM@ZKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PAOO@B?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FCOA@?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CNO@ER_Entity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CEBI@IndexName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@LKEB@TE_TablRecKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04BAFE@?$CF?$CKs?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04GPPE@?0?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01OAK@N?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04PMIC@?4ddl?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05FCKF@?$CFs_?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07PHBB@B_AEIOU?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LGDF@?$CF02d?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BN@DHGH@DROP?5TABLE?5IF?5EXISTS?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05EGAJ@File?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@PLHO@Generate?5DDL?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@NKCB@Executable?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@JHOI@RetrieveSchema?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07LDCE@TE00422?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06NGI@_alter?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@FFM@MatchFound?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PJM@D?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@INLJ@DB_DataTypes?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PDAJ@S?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCA@InternalName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PINC@String?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NAC@ExternalName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FLCE@L?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07HDOI@Integer?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PBLD@M?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07DBJI@Decimal?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KGOM@T?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FIAI@X?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@BADB@TimeStampEx?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OMLL@Date?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FLOP@I?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04OAHI@Time?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FKLC@F?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09GOGB@FixedChar?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PDMC@V?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PFH@A?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NNJD@SERIAL?5?$CIautoincrement?$CJ?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06CDGA@Domain?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@CMME@GeneratedKey?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LBCJ@Lth?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@IKDH@ER_Attribute?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@FPPC@MaxStringLth?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PLDP@Zeidon?5TE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02IALC@z_?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0CA@CEEE@TranslateNamesToLowerUnderscore?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02IKBN@B_?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02IPGJ@Bc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@PPLE@DATARECORD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@PNOD@CHILDENTITY?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09JEIA@DATAFIELD?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MPNE@FLDTYPE?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@CDIB@XVAATT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06BLIJ@ATTRIB?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BB@NHDL@LOD_EntityParent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@KKLH@POD_Entity?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@FFFI@ER_RelLinkRec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07NHPD@CardMax?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PPA@ERENT_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09DPNM@ERREL_TOK?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DPMI@LOD_EntityChild?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@NFHJ@ER_EntityRec?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08DKCM@TZDBHODO?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KPGG@TimestampPrecision?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PIJH@OBJECT?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	??_C@_06FMHL@DELETE?$AA@			; `string'
PUBLIC	??_C@_04PPKB@DESC?$AA@				; `string'
PUBLIC	??_C@_08FBJG@DESCRIBE?$AA@			; `string'
PUBLIC	??_C@_0L@GKAF@DESCRIPTOR?$AA@			; `string'
PUBLIC	??_C@_0M@OKKK@DIAGNOSTICS?$AA@			; `string'
PUBLIC	??_C@_08GADM@DISALLOW?$AA@			; `string'
PUBLIC	??_C@_0L@OGBA@DISCONNECT?$AA@			; `string'
PUBLIC	??_C@_04HDPG@DISK?$AA@				; `string'
PUBLIC	??_C@_08EGKJ@DISTINCT?$AA@			; `string'
PUBLIC	??_C@_0M@EMHJ@DISTINCTROW?$AA@			; `string'
PUBLIC	??_C@_0M@ONJI@DISTRIBUTED?$AA@			; `string'
PUBLIC	??_C@_06EIOP@DOMAIN?$AA@			; `string'
PUBLIC	??_C@_06CGGE@DOUBLE?$AA@			; `string'
PUBLIC	??_C@_04LDDE@DROP?$AA@				; `string'
PUBLIC	??_C@_05JGEC@DUMMY?$AA@				; `string'
PUBLIC	??_C@_04CAAA@DUMP?$AA@				; `string'
PUBLIC	??_C@_04OHCC@ELSE?$AA@				; `string'
PUBLIC	??_C@_03PIHE@END?$AA@				; `string'
PUBLIC	??_C@_08GNOH@END_EXEC?$AA@			; `string'
PUBLIC	??_C@_03LKIC@EQV?$AA@				; `string'
PUBLIC	??_C@_06BKPA@ERRLVL?$AA@			; `string'
PUBLIC	??_C@_09EIBF@ERROREXIT?$AA@			; `string'
PUBLIC	??_C@_06MJIP@ESCAPE?$AA@			; `string'
PUBLIC	??_C@_06GDHH@EXCEPT?$AA@			; `string'
PUBLIC	??_C@_09EEOO@EXCEPTION?$AA@			; `string'
PUBLIC	??_C@_04GMDG@EXEC?$AA@				; `string'
PUBLIC	??_C@_07DNBH@EXECUTE?$AA@			; `string'
PUBLIC	??_C@_06MBBB@EXISTS?$AA@			; `string'
PUBLIC	??_C@_04HPFN@EXIT?$AA@				; `string'
PUBLIC	??_C@_0L@ILPO@EXPIREDATE?$AA@			; `string'
PUBLIC	??_C@_08EDIC@EXTERNAL?$AA@			; `string'
PUBLIC	??_C@_07IODP@EXTRACT?$AA@			; `string'
PUBLIC	??_C@_05LLOB@FALSE?$AA@				; `string'
PUBLIC	??_C@_05KBKM@FETCH?$AA@				; `string'
PUBLIC	??_C@_04CMDA@FILE?$AA@				; `string'
PUBLIC	??_C@_0L@NPIO@FILLFACTOR?$AA@			; `string'
PUBLIC	??_C@_05MPDO@FIRST?$AA@				; `string'
PUBLIC	??_C@_05JDEL@FLOAT?$AA@				; `string'
PUBLIC	??_C@_06FFP@FLOAT4?$AA@				; `string'
PUBLIC	??_C@_06PLLL@FLOAT8?$AA@			; `string'
PUBLIC	??_C@_06IPNK@FLOPPY?$AA@			; `string'
PUBLIC	??_C@_03EOOH@FOR?$AA@				; `string'
PUBLIC	??_C@_07ECFK@FOREIGN?$AA@			; `string'
PUBLIC	??_C@_04EJD@FROM?$AA@				; `string'
PUBLIC	??_C@_04CLJK@FULL?$AA@				; `string'
PUBLIC	??_C@_03HLIC@GET?$AA@				; `string'
PUBLIC	??_C@_0L@PODI@GETDEFAULT?$AA@			; `string'
PUBLIC	??_C@_06EKIF@GLOBAL?$AA@			; `string'
PUBLIC	??_C@_04DLHO@GOTO?$AA@				; `string'
PUBLIC	??_C@_05DLPA@GRANT?$AA@				; `string'
PUBLIC	??_C@_05JGM@GROUP?$AA@				; `string'
PUBLIC	??_C@_04BGHA@GUID?$AA@				; `string'
PUBLIC	??_C@_06GNBD@HAVING?$AA@			; `string'
PUBLIC	??_C@_08JHAN@HOLDLOCK?$AA@			; `string'
PUBLIC	??_C@_04PJ@HOUR?$AA@				; `string'
PUBLIC	??_C@_08MFJF@IDENTITY?$AA@			; `string'
PUBLIC	??_C@_0M@EOA@IDENTITYCOL?$AA@			; `string'
PUBLIC	??_C@_0BA@JADB@IDENTITY_INSERT?$AA@		; `string'
PUBLIC	??_C@_0L@CMNP@IEEEDOUBLE?$AA@			; `string'
PUBLIC	??_C@_0L@FEGJ@IEEESINGLE?$AA@			; `string'
PUBLIC	??_C@_02FDOJ@IF?$AA@				; `string'
PUBLIC	??_C@_06HLND@IGNORE?$AA@			; `string'
PUBLIC	??_C@_09LEPP@IMMEDIATE?$AA@			; `string'
PUBLIC	??_C@_03BIEI@IMP?$AA@				; `string'
PUBLIC	??_C@_02HFB@IN?$AA@				; `string'
PUBLIC	??_C@_05HKPP@INDEX?$AA@				; `string'
PUBLIC	??_C@_09BAOC@INITIALLY?$AA@			; `string'
PUBLIC	??_C@_05EPPB@INNER?$AA@				; `string'
PUBLIC	??_C@_05IHIC@INPUT?$AA@				; `string'
PUBLIC	??_C@_0M@PDHJ@INSENSITIVE?$AA@			; `string'
PUBLIC	??_C@_06CCAI@INSERT?$AA@			; `string'
PUBLIC	??_C@_03IJOL@INT?$AA@				; `string'
PUBLIC	??_C@_07KMGD@INTEGER?$AA@			; `string'
PUBLIC	??_C@_08PEKL@INTEGER1?$AA@			; `string'
PUBLIC	??_C@_08LBC@INTEGER2?$AA@			; `string'
PUBLIC	??_C@_09GIDA@INTERSECT?$AA@			; `string'
PUBLIC	??_C@_08JNLE@INTERVAL?$AA@			; `string'
PUBLIC	??_C@_04JMBE@INTO?$AA@				; `string'
PUBLIC	??_C@_02PKFC@IS?$AA@				; `string'
PUBLIC	??_C@_09JCKC@ISOLATION?$AA@			; `string'
PUBLIC	??_C@_04JIJO@JOIN?$AA@				; `string'
PUBLIC	??_C@_03PHBO@KEY?$AA@				; `string'
PUBLIC	??_C@_04EIJF@KILL?$AA@				; `string'
PUBLIC	??_C@_04GBPO@LAST?$AA@				; `string'
PUBLIC	??_C@_07HHCE@LEADING?$AA@			; `string'
PUBLIC	??_C@_04PAN@LEFT?$AA@				; `string'
PUBLIC	??_C@_05JJEC@LEVEL?$AA@				; `string'
PUBLIC	??_C@_04CNFB@LIKE?$AA@				; `string'
PUBLIC	??_C@_06MJFP@LINENO?$AA@			; `string'
PUBLIC	??_C@_04PDLA@LOAD?$AA@				; `string'
PUBLIC	??_C@_05JIPK@LOCAL?$AA@				; `string'
PUBLIC	??_C@_07OAKI@LOGICAL?$AA@			; `string'
PUBLIC	??_C@_08KCOH@LOGICAL1?$AA@			; `string'
PUBLIC	??_C@_04NIAI@LONG?$AA@				; `string'
PUBLIC	??_C@_0L@GKBM@LONGBINARY?$AA@			; `string'
PUBLIC	??_C@_08HLJO@LONGTEXT?$AA@			; `string'
PUBLIC	??_C@_05NFKB@MATCH?$AA@				; `string'
PUBLIC	??_C@_03OLFE@MAX?$AA@				; `string'
PUBLIC	??_C@_04KGIF@MEMO?$AA@				; `string'
PUBLIC	??_C@_03IAC@MIN?$AA@				; `string'
PUBLIC	??_C@_06IOKL@MINUTE?$AA@			; `string'
PUBLIC	??_C@_0L@GNDP@MIRROREXIT?$AA@			; `string'
PUBLIC	??_C@_03HOGL@MOD?$AA@				; `string'
PUBLIC	??_C@_05EBDH@MONEY?$AA@				; `string'
PUBLIC	??_C@_05DOND@MONTH?$AA@				; `string'
PUBLIC	??_C@_05KDIJ@NAMES?$AA@				; `string'
PUBLIC	??_C@_08CHPD@NATIONAL?$AA@			; `string'
PUBLIC	??_C@_07BGPN@NATURAL?$AA@			; `string'
PUBLIC	??_C@_05DFM@NCHAR?$AA@				; `string'
PUBLIC	??_C@_04ONKL@NEXT?$AA@				; `string'
PUBLIC	??_C@_07NAJC@NEXTLOG?$AA@			; `string'
PUBLIC	??_C@_02MMJD@NO?$AA@				; `string'
PUBLIC	??_C@_07IMID@NOCHECK?$AA@			; `string'
PUBLIC	??_C@_0N@NJNJ@NONCLUSTERED?$AA@			; `string'
PUBLIC	??_C@_03CBCA@NOT?$AA@				; `string'
PUBLIC	??_C@_04DFCK@NOTE?$AA@				; `string'
PUBLIC	??_C@_04BAK@NULL?$AA@				; `string'
PUBLIC	??_C@_06HGII@NULLIF?$AA@			; `string'
PUBLIC	??_C@_06MDMK@NUMBER?$AA@			; `string'
PUBLIC	??_C@_07FIAN@NUMERIC?$AA@			; `string'
PUBLIC	??_C@_0N@PBNP@OCTET_LENGTH?$AA@			; `string'
PUBLIC	??_C@_02CEBG@OF?$AA@				; `string'
PUBLIC	??_C@_03CMJG@OFF?$AA@				; `string'
PUBLIC	??_C@_07FMHE@OFFSETS?$AA@			; `string'
PUBLIC	??_C@_09GMOF@OLEOBJECT?$AA@			; `string'
PUBLIC	??_C@_02HAKO@ON?$AA@				; `string'
PUBLIC	??_C@_04EJJC@ONCE?$AA@				; `string'
PUBLIC	??_C@_04MKAH@ONLY?$AA@				; `string'
PUBLIC	??_C@_04MIME@OPEN?$AA@				; `string'
PUBLIC	??_C@_06IFCC@OPTION?$AA@			; `string'
PUBLIC	??_C@_02CHDK@OR?$AA@				; `string'
PUBLIC	??_C@_05FBEP@ORDER?$AA@				; `string'
PUBLIC	??_C@_05IKJL@OUTER?$AA@				; `string'
PUBLIC	??_C@_06BMBF@OUTPUT?$AA@			; `string'
PUBLIC	??_C@_04HDCH@OVER?$AA@				; `string'
PUBLIC	??_C@_08PGNB@OVERLAPS?$AA@			; `string'
PUBLIC	??_C@_0M@GPH@OWNERACCESS?$AA@			; `string'
PUBLIC	??_C@_03BHFD@PAD?$AA@				; `string'
PUBLIC	??_C@_0L@PEIP@PARAMETERS?$AA@			; `string'
PUBLIC	??_C@_07MOBO@PARTIAL?$AA@			; `string'
PUBLIC	??_C@_07MGCH@PERCENT?$AA@			; `string'
PUBLIC	??_C@_04ICKI@PERM?$AA@				; `string'
PUBLIC	??_C@_09JLAF@PERMANENT?$AA@			; `string'
PUBLIC	??_C@_04CDKK@PIPE?$AA@				; `string'
PUBLIC	??_C@_05MALJ@PIVOT?$AA@				; `string'
PUBLIC	??_C@_04OOOE@PLAN?$AA@				; `string'
PUBLIC	??_C@_08BGJK@POSITION?$AA@			; `string'
PUBLIC	??_C@_09LJHE@PRECISION?$AA@			; `string'
PUBLIC	??_C@_07OCNH@PREPARE?$AA@			; `string'
PUBLIC	??_C@_07JPNB@PRESEVE?$AA@			; `string'
PUBLIC	??_C@_07PLFH@PRIMARY?$AA@			; `string'
PUBLIC	??_C@_05MJOK@PRINT?$AA@				; `string'
PUBLIC	??_C@_05CADC@PRIOR?$AA@				; `string'
PUBLIC	??_C@_0L@IFKE@PRIVILEGES?$AA@			; `string'
PUBLIC	??_C@_04CFJE@PROC?$AA@				; `string'
PUBLIC	??_C@_09HPKL@PROCEDURE?$AA@			; `string'
PUBLIC	??_C@_0M@CNCJ@PROCESSEXIT?$AA@			; `string'
PUBLIC	??_C@_06JPM@PUBLIC?$AA@				; `string'
PUBLIC	??_C@_09EHBK@RAISERROR?$AA@			; `string'
PUBLIC	??_C@_04GHHF@READ?$AA@				; `string'
PUBLIC	??_C@_08IEGM@READTEXT?$AA@			; `string'
PUBLIC	??_C@_04DDMN@REAL?$AA@				; `string'
PUBLIC	??_C@_0M@CLEO@RECONFIGURE?$AA@			; `string'
PUBLIC	??_C@_0L@DHND@REFERENCES?$AA@			; `string'
PUBLIC	??_C@_08NDFO@RELATIVE?$AA@			; `string'
PUBLIC	??_C@_0L@DEIL@REPEATABLE?$AA@			; `string'
PUBLIC	??_C@_0M@GBCL@REPLICATION?$AA@			; `string'
PUBLIC	??_C@_08BEHK@RESTRICT?$AA@			; `string'
PUBLIC	??_C@_09NACH@RETAINDAY?$AA@			; `string'
PUBLIC	??_C@_06PJJM@RETURN?$AA@			; `string'
PUBLIC	??_C@_06MEJM@REVOKE?$AA@			; `string'
PUBLIC	??_C@_05JCNK@RIGHT?$AA@				; `string'
PUBLIC	??_C@_08EMFJ@ROLLBACK?$AA@			; `string'
PUBLIC	??_C@_08MGKJ@ROWCOUNT?$AA@			; `string'
PUBLIC	??_C@_04LCCO@ROWS?$AA@				; `string'
PUBLIC	??_C@_04BFNM@RULE?$AA@				; `string'
PUBLIC	??_C@_04KLBG@SAVE?$AA@				; `string'
PUBLIC	??_C@_06NIIF@SCHEMA?$AA@			; `string'
PUBLIC	??_C@_06JLNB@SCROLL?$AA@			; `string'
PUBLIC	??_C@_06FCJA@SECOND?$AA@			; `string'
PUBLIC	??_C@_06OGAC@SELECT?$AA@			; `string'
PUBLIC	??_C@_0N@CCJF@SERIALIZABLE?$AA@			; `string'
PUBLIC	??_C@_07CGDO@SESSION?$AA@			; `string'
PUBLIC	??_C@_0N@JGA@SESSION_USER?$AA@			; `string'
PUBLIC	??_C@_03BCLC@SET?$AA@				; `string'
PUBLIC	??_C@_07EDEP@SETUSER?$AA@			; `string'
PUBLIC	??_C@_05HFLA@SHORT?$AA@				; `string'
PUBLIC	??_C@_08DPKF@SHUTDOWN?$AA@			; `string'
PUBLIC	??_C@_06FONC@SINGLE?$AA@			; `string'
PUBLIC	??_C@_04NEFN@SIZE?$AA@				; `string'
PUBLIC	??_C@_08DMN@SMALLINT?$AA@			; `string'
PUBLIC	??_C@_04DDNG@SOME?$AA@				; `string'
PUBLIC	??_C@_05JCH@SPACE?$AA@				; `string'
PUBLIC	??_C@_08DHID@SQLSTATE?$AA@			; `string'
PUBLIC	??_C@_0L@JMMG@STATISTICS?$AA@			; `string'
PUBLIC	??_C@_05KHBF@STDEV?$AA@				; `string'
PUBLIC	??_C@_06OCBH@STDEVP?$AA@			; `string'
PUBLIC	??_C@_06JDFN@STRING?$AA@			; `string'
PUBLIC	??_C@_03CPEE@SUM?$AA@				; `string'
PUBLIC	??_C@_0M@JBHB@SYSTEM_USER?$AA@			; `string'
PUBLIC	??_C@_05DLJE@TABLE?$AA@				; `string'
PUBLIC	??_C@_07DAKP@TABLEID?$AA@			; `string'
PUBLIC	??_C@_04CGFH@TAPE?$AA@				; `string'
PUBLIC	??_C@_04FEEL@TEMP?$AA@				; `string'
PUBLIC	??_C@_09EAGL@TEMPORARY?$AA@			; `string'
PUBLIC	??_C@_04NILO@TEXT?$AA@				; `string'
PUBLIC	??_C@_08FIJO@TEXTSIZE?$AA@			; `string'
PUBLIC	??_C@_04GJFM@THEN?$AA@				; `string'
PUBLIC	??_C@_04CFBP@TIME?$AA@				; `string'
PUBLIC	??_C@_09KEAG@TIMESTAMP?$AA@			; `string'
PUBLIC	??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@		; `string'
PUBLIC	??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@		; `string'
PUBLIC	??_C@_02DODL@TO?$AA@				; `string'
PUBLIC	??_C@_03JOIO@TOP?$AA@				; `string'
PUBLIC	??_C@_08NJGC@TRAILING?$AA@			; `string'
PUBLIC	??_C@_04CGAE@TRAN?$AA@				; `string'
PUBLIC	??_C@_0M@JACB@TRANSACTION?$AA@			; `string'
PUBLIC	??_C@_09ECBO@TRANSFORM?$AA@			; `string'
PUBLIC	??_C@_09HNKP@TRANSLATE?$AA@			; `string'
PUBLIC	??_C@_0M@LOEK@TRANSLATION?$AA@			; `string'
PUBLIC	??_C@_07GNLP@TRIGGER?$AA@			; `string'
PUBLIC	??_C@_04LNAG@TRUE?$AA@				; `string'
PUBLIC	??_C@_08FCAH@TRUNCATE?$AA@			; `string'
PUBLIC	??_C@_07CODK@TSEQUAL?$AA@			; `string'
PUBLIC	??_C@_0M@PJEA@UNCOMMITTED?$AA@			; `string'
PUBLIC	??_C@_05LNOP@UNION?$AA@				; `string'
PUBLIC	??_C@_06LNBM@UNIQUE?$AA@			; `string'
PUBLIC	??_C@_07CNPM@UNKNOWN?$AA@			; `string'
PUBLIC	??_C@_06NDPG@UPDATE?$AA@			; `string'
PUBLIC	??_C@_0L@DPMH@UPDATETEXT?$AA@			; `string'
PUBLIC	??_C@_05PMKE@USAGE?$AA@				; `string'
PUBLIC	??_C@_03OAHE@USE?$AA@				; `string'
PUBLIC	??_C@_04FMHO@USER?$AA@				; `string'
PUBLIC	??_C@_05JKMB@USING?$AA@				; `string'
PUBLIC	??_C@_05MOEL@VALUE?$AA@				; `string'
PUBLIC	??_C@_06KGMH@VALUES?$AA@			; `string'
PUBLIC	??_C@_03KNCG@VAR?$AA@				; `string'
PUBLIC	??_C@_09OLDK@VARBINARY?$AA@			; `string'
PUBLIC	??_C@_07NGFA@VARCHAR?$AA@			; `string'
PUBLIC	??_C@_04OIBN@VARP?$AA@				; `string'
PUBLIC	??_C@_07MMOJ@VARYING?$AA@			; `string'
PUBLIC	??_C@_04CGLB@VIEW?$AA@				; `string'
PUBLIC	??_C@_06IEGE@VOLUME?$AA@			; `string'
PUBLIC	??_C@_07KCD@WAITFOR?$AA@			; `string'
PUBLIC	??_C@_04GKK@WHEN?$AA@				; `string'
PUBLIC	??_C@_05MCFK@WHERE?$AA@				; `string'
PUBLIC	??_C@_05LCLH@WHILE?$AA@				; `string'
PUBLIC	??_C@_04NHMN@WITH?$AA@				; `string'
PUBLIC	??_C@_04LDPM@WORK?$AA@				; `string'
PUBLIC	??_C@_05FIFP@WRITE?$AA@				; `string'
PUBLIC	??_C@_09IKOB@WRITETEXT?$AA@			; `string'
PUBLIC	??_C@_03BDEP@XOR?$AA@				; `string'
PUBLIC	??_C@_04HEBB@YEAR?$AA@				; `string'
PUBLIC	??_C@_05NAPJ@YESNO?$AA@				; `string'
PUBLIC	??_C@_04HOL@ZONE?$AA@				; `string'
PUBLIC	??_C@_01A@?$AA?$AA@				; `string'
PUBLIC	_szReservedName
PUBLIC	??_C@_08DFNL@ABSOLUTE?$AA@			; `string'
PUBLIC	??_C@_06LHNJ@ACTION?$AA@			; `string'
PUBLIC	??_C@_03CICP@ADD?$AA@				; `string'
PUBLIC	??_C@_03MJMD@ALL?$AA@				; `string'
PUBLIC	??_C@_08HG@ALLOCATE?$AA@			; `string'
PUBLIC	??_C@_0N@NNIC@ALPHANUMERIC?$AA@			; `string'
PUBLIC	??_C@_05BBIN@ALTER?$AA@				; `string'
PUBLIC	??_C@_03LACO@AND?$AA@				; `string'
PUBLIC	??_C@_03ENCN@ANY?$AA@				; `string'
PUBLIC	??_C@_03JPOO@ARE?$AA@				; `string'
PUBLIC	??_C@_02EPAG@AS?$AA@				; `string'
PUBLIC	??_C@_03HGDG@ASC?$AA@				; `string'
PUBLIC	??_C@_09HNNJ@ASSERTION?$AA@			; `string'
PUBLIC	??_C@_02BKOD@AT?$AA@				; `string'
PUBLIC	??_C@_0O@MMGM@AUTHORIZATION?$AA@		; `string'
PUBLIC	??_C@_0O@DFOG@AUTOINCREMENT?$AA@		; `string'
PUBLIC	??_C@_03JAGK@AVG?$AA@				; `string'
PUBLIC	??_C@_05JBBL@BEGIN?$AA@				; `string'
PUBLIC	??_C@_07FEKN@BETWEEN?$AA@			; `string'
PUBLIC	??_C@_06ICJB@BINARY?$AA@			; `string'
PUBLIC	??_C@_03IODA@BIT?$AA@				; `string'
PUBLIC	??_C@_07HLBB@BOOLEAN?$AA@			; `string'
PUBLIC	??_C@_04NOIB@BOTH?$AA@				; `string'
PUBLIC	??_C@_05CPDG@BREAK?$AA@				; `string'
PUBLIC	??_C@_06MIPA@BROWSE?$AA@			; `string'
PUBLIC	??_C@_04OLDH@BULK?$AA@				; `string'
PUBLIC	??_C@_02HFGP@BY?$AA@				; `string'
PUBLIC	??_C@_04EHOP@BYTE?$AA@				; `string'
PUBLIC	??_C@_07HJNK@CASCADE?$AA@			; `string'
PUBLIC	??_C@_08GIOF@CASCADED?$AA@			; `string'
PUBLIC	??_C@_04LCDH@CASE?$AA@				; `string'
PUBLIC	??_C@_04LBNA@CAST?$AA@				; `string'
PUBLIC	??_C@_07CPI@CATALOG?$AA@			; `string'
PUBLIC	??_C@_04MLPN@CHAR?$AA@				; `string'
PUBLIC	??_C@_09MNBH@CHARACTER?$AA@			; `string'
PUBLIC	??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@		; `string'
PUBLIC	??_C@_0M@OBEF@CHAR_LENGTH?$AA@			; `string'
PUBLIC	??_C@_05JHFD@CHECK?$AA@				; `string'
PUBLIC	??_C@_0L@CINA@CHECKPOINT?$AA@			; `string'
PUBLIC	??_C@_05PHOA@CLOSE?$AA@				; `string'
PUBLIC	??_C@_09GMHN@CLUSTERED?$AA@			; `string'
PUBLIC	??_C@_08DMIM@COALESCE?$AA@			; `string'
PUBLIC	??_C@_07HABJ@COLLATE?$AA@			; `string'
PUBLIC	??_C@_09JEOK@COLLATION?$AA@			; `string'
PUBLIC	??_C@_06LGEH@COLUMN?$AA@			; `string'
PUBLIC	??_C@_06NAIG@COMMIT?$AA@			; `string'
PUBLIC	??_C@_09BMPB@COMMITTED?$AA@			; `string'
PUBLIC	??_C@_07FDPF@COMPUTE?$AA@			; `string'
PUBLIC	??_C@_07ODJF@CONFIRM?$AA@			; `string'
PUBLIC	??_C@_07DKLG@CONNECT?$AA@			; `string'
PUBLIC	??_C@_0L@ICLB@CONNECTION?$AA@			; `string'
PUBLIC	??_C@_0L@LNCA@CONSTRAINT?$AA@			; `string'
PUBLIC	??_C@_0M@GMLE@CONSTRAINTS?$AA@			; `string'
PUBLIC	??_C@_08HDIP@CONTINUE?$AA@			; `string'
PUBLIC	??_C@_0L@BOLK@CONTROLROW?$AA@			; `string'
PUBLIC	??_C@_07DJAE@CONVERT?$AA@			; `string'
PUBLIC	??_C@_0O@MOMH@CORRESPONDING?$AA@		; `string'
PUBLIC	??_C@_05BNPO@COUNT?$AA@				; `string'
PUBLIC	??_C@_07CCFH@COUNTER?$AA@			; `string'
PUBLIC	??_C@_06JBCM@CREATE?$AA@			; `string'
PUBLIC	??_C@_05BLP@CROSS?$AA@				; `string'
PUBLIC	??_C@_08CHBF@CURRENCY?$AA@			; `string'
PUBLIC	??_C@_07HGLC@CURRENT?$AA@			; `string'
PUBLIC	??_C@_0N@NEAE@CURRENT_DATE?$AA@			; `string'
PUBLIC	??_C@_0N@NIMH@CURRENT_TIME?$AA@			; `string'
PUBLIC	??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@		; `string'
PUBLIC	??_C@_0N@KBKG@CURRENT_USER?$AA@			; `string'
PUBLIC	??_C@_06MDJJ@CURSOR?$AA@			; `string'
PUBLIC	??_C@_08PKHN@DATABASE?$AA@			; `string'
PUBLIC	??_C@_04CJNM@DATE?$AA@				; `string'
PUBLIC	??_C@_08MIJC@DATETIME?$AA@			; `string'
PUBLIC	??_C@_03IDGA@DAY?$AA@				; `string'
PUBLIC	??_C@_06OPFP@DBAREA?$AA@			; `string'
PUBLIC	??_C@_04CLGJ@DBCC?$AA@				; `string'
PUBLIC	??_C@_0L@JGIO@DEALLOCATE?$AA@			; `string'
PUBLIC	??_C@_05DAPA@DEBUG?$AA@				; `string'
PUBLIC	??_C@_07CJJP@DECLARE?$AA@			; `string'
PUBLIC	??_C@_07FBHA@DEFAULT?$AA@			; `string'
PUBLIC	??_C@_0L@POBB@DEFERRABLE?$AA@			; `string'
PUBLIC	??_C@_08IEEN@DEFERRED?$AA@			; `string'
;	COMDAT ??_C@_01A@?$AA?$AA@
_BSS	SEGMENT
??_C@_01A@?$AA?$AA@ DB 02H DUP (?)			; `string'
_BSS	ENDS
_DATA	SEGMENT
_szReservedName DD FLAT:??_C@_08DFNL@ABSOLUTE?$AA@
	DD	FLAT:??_C@_06LHNJ@ACTION?$AA@
	DD	FLAT:??_C@_03CICP@ADD?$AA@
	DD	FLAT:??_C@_03MJMD@ALL?$AA@
	DD	FLAT:??_C@_08HG@ALLOCATE?$AA@
	DD	FLAT:??_C@_0N@NNIC@ALPHANUMERIC?$AA@
	DD	FLAT:??_C@_05BBIN@ALTER?$AA@
	DD	FLAT:??_C@_03LACO@AND?$AA@
	DD	FLAT:??_C@_03ENCN@ANY?$AA@
	DD	FLAT:??_C@_03JPOO@ARE?$AA@
	DD	FLAT:??_C@_02EPAG@AS?$AA@
	DD	FLAT:??_C@_03HGDG@ASC?$AA@
	DD	FLAT:??_C@_09HNNJ@ASSERTION?$AA@
	DD	FLAT:??_C@_02BKOD@AT?$AA@
	DD	FLAT:??_C@_0O@MMGM@AUTHORIZATION?$AA@
	DD	FLAT:??_C@_0O@DFOG@AUTOINCREMENT?$AA@
	DD	FLAT:??_C@_03JAGK@AVG?$AA@
	DD	FLAT:??_C@_05JBBL@BEGIN?$AA@
	DD	FLAT:??_C@_07FEKN@BETWEEN?$AA@
	DD	FLAT:??_C@_06ICJB@BINARY?$AA@
	DD	FLAT:??_C@_03IODA@BIT?$AA@
	DD	FLAT:??_C@_07HLBB@BOOLEAN?$AA@
	DD	FLAT:??_C@_04NOIB@BOTH?$AA@
	DD	FLAT:??_C@_05CPDG@BREAK?$AA@
	DD	FLAT:??_C@_06MIPA@BROWSE?$AA@
	DD	FLAT:??_C@_04OLDH@BULK?$AA@
	DD	FLAT:??_C@_02HFGP@BY?$AA@
	DD	FLAT:??_C@_04EHOP@BYTE?$AA@
	DD	FLAT:??_C@_07HJNK@CASCADE?$AA@
	DD	FLAT:??_C@_08GIOF@CASCADED?$AA@
	DD	FLAT:??_C@_04LCDH@CASE?$AA@
	DD	FLAT:??_C@_04LBNA@CAST?$AA@
	DD	FLAT:??_C@_07CPI@CATALOG?$AA@
	DD	FLAT:??_C@_04MLPN@CHAR?$AA@
	DD	FLAT:??_C@_09MNBH@CHARACTER?$AA@
	DD	FLAT:??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@
	DD	FLAT:??_C@_0M@OBEF@CHAR_LENGTH?$AA@
	DD	FLAT:??_C@_05JHFD@CHECK?$AA@
	DD	FLAT:??_C@_0L@CINA@CHECKPOINT?$AA@
	DD	FLAT:??_C@_05PHOA@CLOSE?$AA@
	DD	FLAT:??_C@_09GMHN@CLUSTERED?$AA@
	DD	FLAT:??_C@_08DMIM@COALESCE?$AA@
	DD	FLAT:??_C@_07HABJ@COLLATE?$AA@
	DD	FLAT:??_C@_09JEOK@COLLATION?$AA@
	DD	FLAT:??_C@_06LGEH@COLUMN?$AA@
	DD	FLAT:??_C@_06NAIG@COMMIT?$AA@
	DD	FLAT:??_C@_09BMPB@COMMITTED?$AA@
	DD	FLAT:??_C@_07FDPF@COMPUTE?$AA@
	DD	FLAT:??_C@_07ODJF@CONFIRM?$AA@
	DD	FLAT:??_C@_07DKLG@CONNECT?$AA@
	DD	FLAT:??_C@_0L@ICLB@CONNECTION?$AA@
	DD	FLAT:??_C@_0L@LNCA@CONSTRAINT?$AA@
	DD	FLAT:??_C@_0M@GMLE@CONSTRAINTS?$AA@
	DD	FLAT:??_C@_08HDIP@CONTINUE?$AA@
	DD	FLAT:??_C@_0L@BOLK@CONTROLROW?$AA@
	DD	FLAT:??_C@_07DJAE@CONVERT?$AA@
	DD	FLAT:??_C@_0O@MOMH@CORRESPONDING?$AA@
	DD	FLAT:??_C@_05BNPO@COUNT?$AA@
	DD	FLAT:??_C@_07CCFH@COUNTER?$AA@
	DD	FLAT:??_C@_06JBCM@CREATE?$AA@
	DD	FLAT:??_C@_05BLP@CROSS?$AA@
	DD	FLAT:??_C@_08CHBF@CURRENCY?$AA@
	DD	FLAT:??_C@_07HGLC@CURRENT?$AA@
	DD	FLAT:??_C@_0N@NEAE@CURRENT_DATE?$AA@
	DD	FLAT:??_C@_0N@NIMH@CURRENT_TIME?$AA@
	DD	FLAT:??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@
	DD	FLAT:??_C@_0N@KBKG@CURRENT_USER?$AA@
	DD	FLAT:??_C@_06MDJJ@CURSOR?$AA@
	DD	FLAT:??_C@_08PKHN@DATABASE?$AA@
	DD	FLAT:??_C@_04CJNM@DATE?$AA@
	DD	FLAT:??_C@_08MIJC@DATETIME?$AA@
	DD	FLAT:??_C@_03IDGA@DAY?$AA@
	DD	FLAT:??_C@_06OPFP@DBAREA?$AA@
	DD	FLAT:??_C@_04CLGJ@DBCC?$AA@
	DD	FLAT:??_C@_0L@JGIO@DEALLOCATE?$AA@
	DD	FLAT:??_C@_05DAPA@DEBUG?$AA@
	DD	FLAT:??_C@_07CJJP@DECLARE?$AA@
	DD	FLAT:??_C@_07FBHA@DEFAULT?$AA@
	DD	FLAT:??_C@_0L@POBB@DEFERRABLE?$AA@
	DD	FLAT:??_C@_08IEEN@DEFERRED?$AA@
	DD	FLAT:??_C@_06FMHL@DELETE?$AA@
	DD	FLAT:??_C@_04PPKB@DESC?$AA@
	DD	FLAT:??_C@_08FBJG@DESCRIBE?$AA@
	DD	FLAT:??_C@_0L@GKAF@DESCRIPTOR?$AA@
	DD	FLAT:??_C@_0M@OKKK@DIAGNOSTICS?$AA@
	DD	FLAT:??_C@_08GADM@DISALLOW?$AA@
	DD	FLAT:??_C@_0L@OGBA@DISCONNECT?$AA@
	DD	FLAT:??_C@_04HDPG@DISK?$AA@
	DD	FLAT:??_C@_08EGKJ@DISTINCT?$AA@
	DD	FLAT:??_C@_0M@EMHJ@DISTINCTROW?$AA@
	DD	FLAT:??_C@_0M@ONJI@DISTRIBUTED?$AA@
	DD	FLAT:??_C@_06EIOP@DOMAIN?$AA@
	DD	FLAT:??_C@_06CGGE@DOUBLE?$AA@
	DD	FLAT:??_C@_04LDDE@DROP?$AA@
	DD	FLAT:??_C@_05JGEC@DUMMY?$AA@
	DD	FLAT:??_C@_04CAAA@DUMP?$AA@
	DD	FLAT:??_C@_04OHCC@ELSE?$AA@
	DD	FLAT:??_C@_03PIHE@END?$AA@
	DD	FLAT:??_C@_08GNOH@END_EXEC?$AA@
	DD	FLAT:??_C@_03LKIC@EQV?$AA@
	DD	FLAT:??_C@_06BKPA@ERRLVL?$AA@
	DD	FLAT:??_C@_09EIBF@ERROREXIT?$AA@
	DD	FLAT:??_C@_06MJIP@ESCAPE?$AA@
	DD	FLAT:??_C@_06GDHH@EXCEPT?$AA@
	DD	FLAT:??_C@_09EEOO@EXCEPTION?$AA@
	DD	FLAT:??_C@_04GMDG@EXEC?$AA@
	DD	FLAT:??_C@_07DNBH@EXECUTE?$AA@
	DD	FLAT:??_C@_06MBBB@EXISTS?$AA@
	DD	FLAT:??_C@_04HPFN@EXIT?$AA@
	DD	FLAT:??_C@_0L@ILPO@EXPIREDATE?$AA@
	DD	FLAT:??_C@_08EDIC@EXTERNAL?$AA@
	DD	FLAT:??_C@_07IODP@EXTRACT?$AA@
	DD	FLAT:??_C@_05LLOB@FALSE?$AA@
	DD	FLAT:??_C@_05KBKM@FETCH?$AA@
	DD	FLAT:??_C@_04CMDA@FILE?$AA@
	DD	FLAT:??_C@_0L@NPIO@FILLFACTOR?$AA@
	DD	FLAT:??_C@_05MPDO@FIRST?$AA@
	DD	FLAT:??_C@_05JDEL@FLOAT?$AA@
	DD	FLAT:??_C@_06FFP@FLOAT4?$AA@
	DD	FLAT:??_C@_06PLLL@FLOAT8?$AA@
	DD	FLAT:??_C@_06IPNK@FLOPPY?$AA@
	DD	FLAT:??_C@_03EOOH@FOR?$AA@
	DD	FLAT:??_C@_07ECFK@FOREIGN?$AA@
	DD	FLAT:??_C@_04EJD@FROM?$AA@
	DD	FLAT:??_C@_04CLJK@FULL?$AA@
	DD	FLAT:??_C@_03HLIC@GET?$AA@
	DD	FLAT:??_C@_0L@PODI@GETDEFAULT?$AA@
	DD	FLAT:??_C@_06EKIF@GLOBAL?$AA@
	DD	FLAT:??_C@_04DLHO@GOTO?$AA@
	DD	FLAT:??_C@_05DLPA@GRANT?$AA@
	DD	FLAT:??_C@_05JGM@GROUP?$AA@
	DD	FLAT:??_C@_04BGHA@GUID?$AA@
	DD	FLAT:??_C@_06GNBD@HAVING?$AA@
	DD	FLAT:??_C@_08JHAN@HOLDLOCK?$AA@
	DD	FLAT:??_C@_04PJ@HOUR?$AA@
	DD	FLAT:??_C@_08MFJF@IDENTITY?$AA@
	DD	FLAT:??_C@_0M@EOA@IDENTITYCOL?$AA@
	DD	FLAT:??_C@_0BA@JADB@IDENTITY_INSERT?$AA@
	DD	FLAT:??_C@_0L@CMNP@IEEEDOUBLE?$AA@
	DD	FLAT:??_C@_0L@FEGJ@IEEESINGLE?$AA@
	DD	FLAT:??_C@_02FDOJ@IF?$AA@
	DD	FLAT:??_C@_06HLND@IGNORE?$AA@
	DD	FLAT:??_C@_09LEPP@IMMEDIATE?$AA@
	DD	FLAT:??_C@_03BIEI@IMP?$AA@
	DD	FLAT:??_C@_02HFB@IN?$AA@
	DD	FLAT:??_C@_05HKPP@INDEX?$AA@
	DD	FLAT:??_C@_09BAOC@INITIALLY?$AA@
	DD	FLAT:??_C@_05EPPB@INNER?$AA@
	DD	FLAT:??_C@_05IHIC@INPUT?$AA@
	DD	FLAT:??_C@_0M@PDHJ@INSENSITIVE?$AA@
	DD	FLAT:??_C@_06CCAI@INSERT?$AA@
	DD	FLAT:??_C@_03IJOL@INT?$AA@
	DD	FLAT:??_C@_07KMGD@INTEGER?$AA@
	DD	FLAT:??_C@_08PEKL@INTEGER1?$AA@
	DD	FLAT:??_C@_08LBC@INTEGER2?$AA@
	DD	FLAT:??_C@_09GIDA@INTERSECT?$AA@
	DD	FLAT:??_C@_08JNLE@INTERVAL?$AA@
	DD	FLAT:??_C@_04JMBE@INTO?$AA@
	DD	FLAT:??_C@_02PKFC@IS?$AA@
	DD	FLAT:??_C@_09JCKC@ISOLATION?$AA@
	DD	FLAT:??_C@_04JIJO@JOIN?$AA@
	DD	FLAT:??_C@_03PHBO@KEY?$AA@
	DD	FLAT:??_C@_04EIJF@KILL?$AA@
	DD	FLAT:??_C@_04GBPO@LAST?$AA@
	DD	FLAT:??_C@_07HHCE@LEADING?$AA@
	DD	FLAT:??_C@_04PAN@LEFT?$AA@
	DD	FLAT:??_C@_05JJEC@LEVEL?$AA@
	DD	FLAT:??_C@_04CNFB@LIKE?$AA@
	DD	FLAT:??_C@_06MJFP@LINENO?$AA@
	DD	FLAT:??_C@_04PDLA@LOAD?$AA@
	DD	FLAT:??_C@_05JIPK@LOCAL?$AA@
	DD	FLAT:??_C@_07OAKI@LOGICAL?$AA@
	DD	FLAT:??_C@_08KCOH@LOGICAL1?$AA@
	DD	FLAT:??_C@_04NIAI@LONG?$AA@
	DD	FLAT:??_C@_0L@GKBM@LONGBINARY?$AA@
	DD	FLAT:??_C@_08HLJO@LONGTEXT?$AA@
	DD	FLAT:??_C@_05NFKB@MATCH?$AA@
	DD	FLAT:??_C@_03OLFE@MAX?$AA@
	DD	FLAT:??_C@_04KGIF@MEMO?$AA@
	DD	FLAT:??_C@_03IAC@MIN?$AA@
	DD	FLAT:??_C@_06IOKL@MINUTE?$AA@
	DD	FLAT:??_C@_0L@GNDP@MIRROREXIT?$AA@
	DD	FLAT:??_C@_03HOGL@MOD?$AA@
	DD	FLAT:??_C@_05EBDH@MONEY?$AA@
	DD	FLAT:??_C@_05DOND@MONTH?$AA@
	DD	FLAT:??_C@_05KDIJ@NAMES?$AA@
	DD	FLAT:??_C@_08CHPD@NATIONAL?$AA@
	DD	FLAT:??_C@_07BGPN@NATURAL?$AA@
	DD	FLAT:??_C@_05DFM@NCHAR?$AA@
	DD	FLAT:??_C@_04ONKL@NEXT?$AA@
	DD	FLAT:??_C@_07NAJC@NEXTLOG?$AA@
	DD	FLAT:??_C@_02MMJD@NO?$AA@
	DD	FLAT:??_C@_07IMID@NOCHECK?$AA@
	DD	FLAT:??_C@_0N@NJNJ@NONCLUSTERED?$AA@
	DD	FLAT:??_C@_03CBCA@NOT?$AA@
	DD	FLAT:??_C@_04DFCK@NOTE?$AA@
	DD	FLAT:??_C@_04BAK@NULL?$AA@
	DD	FLAT:??_C@_06HGII@NULLIF?$AA@
	DD	FLAT:??_C@_06MDMK@NUMBER?$AA@
	DD	FLAT:??_C@_07FIAN@NUMERIC?$AA@
	DD	FLAT:??_C@_0N@PBNP@OCTET_LENGTH?$AA@
	DD	FLAT:??_C@_02CEBG@OF?$AA@
	DD	FLAT:??_C@_03CMJG@OFF?$AA@
	DD	FLAT:??_C@_07FMHE@OFFSETS?$AA@
	DD	FLAT:??_C@_09GMOF@OLEOBJECT?$AA@
	DD	FLAT:??_C@_02HAKO@ON?$AA@
	DD	FLAT:??_C@_04EJJC@ONCE?$AA@
	DD	FLAT:??_C@_04MKAH@ONLY?$AA@
	DD	FLAT:??_C@_04MIME@OPEN?$AA@
	DD	FLAT:??_C@_06IFCC@OPTION?$AA@
	DD	FLAT:??_C@_02CHDK@OR?$AA@
	DD	FLAT:??_C@_05FBEP@ORDER?$AA@
	DD	FLAT:??_C@_05IKJL@OUTER?$AA@
	DD	FLAT:??_C@_06BMBF@OUTPUT?$AA@
	DD	FLAT:??_C@_04HDCH@OVER?$AA@
	DD	FLAT:??_C@_08PGNB@OVERLAPS?$AA@
	DD	FLAT:??_C@_0M@GPH@OWNERACCESS?$AA@
	DD	FLAT:??_C@_03BHFD@PAD?$AA@
	DD	FLAT:??_C@_0L@PEIP@PARAMETERS?$AA@
	DD	FLAT:??_C@_07MOBO@PARTIAL?$AA@
	DD	FLAT:??_C@_07MGCH@PERCENT?$AA@
	DD	FLAT:??_C@_04ICKI@PERM?$AA@
	DD	FLAT:??_C@_09JLAF@PERMANENT?$AA@
	DD	FLAT:??_C@_04CDKK@PIPE?$AA@
	DD	FLAT:??_C@_05MALJ@PIVOT?$AA@
	DD	FLAT:??_C@_04OOOE@PLAN?$AA@
	DD	FLAT:??_C@_08BGJK@POSITION?$AA@
	DD	FLAT:??_C@_09LJHE@PRECISION?$AA@
	DD	FLAT:??_C@_07OCNH@PREPARE?$AA@
	DD	FLAT:??_C@_07JPNB@PRESEVE?$AA@
	DD	FLAT:??_C@_07PLFH@PRIMARY?$AA@
	DD	FLAT:??_C@_05MJOK@PRINT?$AA@
	DD	FLAT:??_C@_05CADC@PRIOR?$AA@
	DD	FLAT:??_C@_0L@IFKE@PRIVILEGES?$AA@
	DD	FLAT:??_C@_04CFJE@PROC?$AA@
	DD	FLAT:??_C@_09HPKL@PROCEDURE?$AA@
	DD	FLAT:??_C@_0M@CNCJ@PROCESSEXIT?$AA@
	DD	FLAT:??_C@_06JPM@PUBLIC?$AA@
	DD	FLAT:??_C@_09EHBK@RAISERROR?$AA@
	DD	FLAT:??_C@_04GHHF@READ?$AA@
	DD	FLAT:??_C@_08IEGM@READTEXT?$AA@
	DD	FLAT:??_C@_04DDMN@REAL?$AA@
	DD	FLAT:??_C@_0M@CLEO@RECONFIGURE?$AA@
	DD	FLAT:??_C@_0L@DHND@REFERENCES?$AA@
	DD	FLAT:??_C@_08NDFO@RELATIVE?$AA@
	DD	FLAT:??_C@_0L@DEIL@REPEATABLE?$AA@
	DD	FLAT:??_C@_0M@GBCL@REPLICATION?$AA@
	DD	FLAT:??_C@_08BEHK@RESTRICT?$AA@
	DD	FLAT:??_C@_09NACH@RETAINDAY?$AA@
	DD	FLAT:??_C@_06PJJM@RETURN?$AA@
	DD	FLAT:??_C@_06MEJM@REVOKE?$AA@
	DD	FLAT:??_C@_05JCNK@RIGHT?$AA@
	DD	FLAT:??_C@_08EMFJ@ROLLBACK?$AA@
	DD	FLAT:??_C@_08MGKJ@ROWCOUNT?$AA@
	DD	FLAT:??_C@_04LCCO@ROWS?$AA@
	DD	FLAT:??_C@_04BFNM@RULE?$AA@
	DD	FLAT:??_C@_04KLBG@SAVE?$AA@
	DD	FLAT:??_C@_06NIIF@SCHEMA?$AA@
	DD	FLAT:??_C@_06JLNB@SCROLL?$AA@
	DD	FLAT:??_C@_06FCJA@SECOND?$AA@
	DD	FLAT:??_C@_06OGAC@SELECT?$AA@
	DD	FLAT:??_C@_0N@CCJF@SERIALIZABLE?$AA@
	DD	FLAT:??_C@_07CGDO@SESSION?$AA@
	DD	FLAT:??_C@_0N@JGA@SESSION_USER?$AA@
	DD	FLAT:??_C@_03BCLC@SET?$AA@
	DD	FLAT:??_C@_07EDEP@SETUSER?$AA@
	DD	FLAT:??_C@_05HFLA@SHORT?$AA@
	DD	FLAT:??_C@_08DPKF@SHUTDOWN?$AA@
	DD	FLAT:??_C@_06FONC@SINGLE?$AA@
	DD	FLAT:??_C@_04NEFN@SIZE?$AA@
	DD	FLAT:??_C@_08DMN@SMALLINT?$AA@
	DD	FLAT:??_C@_04DDNG@SOME?$AA@
	DD	FLAT:??_C@_05JCH@SPACE?$AA@
	DD	FLAT:??_C@_08DHID@SQLSTATE?$AA@
	DD	FLAT:??_C@_0L@JMMG@STATISTICS?$AA@
	DD	FLAT:??_C@_05KHBF@STDEV?$AA@
	DD	FLAT:??_C@_06OCBH@STDEVP?$AA@
	DD	FLAT:??_C@_06JDFN@STRING?$AA@
	DD	FLAT:??_C@_03CPEE@SUM?$AA@
	DD	FLAT:??_C@_0M@JBHB@SYSTEM_USER?$AA@
	DD	FLAT:??_C@_05DLJE@TABLE?$AA@
	DD	FLAT:??_C@_07DAKP@TABLEID?$AA@
	DD	FLAT:??_C@_04CGFH@TAPE?$AA@
	DD	FLAT:??_C@_04FEEL@TEMP?$AA@
	DD	FLAT:??_C@_09EAGL@TEMPORARY?$AA@
	DD	FLAT:??_C@_04NILO@TEXT?$AA@
	DD	FLAT:??_C@_08FIJO@TEXTSIZE?$AA@
	DD	FLAT:??_C@_04GJFM@THEN?$AA@
	DD	FLAT:??_C@_04CFBP@TIME?$AA@
	DD	FLAT:??_C@_09KEAG@TIMESTAMP?$AA@
	DD	FLAT:??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@
	DD	FLAT:??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@
	DD	FLAT:??_C@_02DODL@TO?$AA@
	DD	FLAT:??_C@_03JOIO@TOP?$AA@
	DD	FLAT:??_C@_08NJGC@TRAILING?$AA@
	DD	FLAT:??_C@_04CGAE@TRAN?$AA@
	DD	FLAT:??_C@_0M@JACB@TRANSACTION?$AA@
	DD	FLAT:??_C@_09ECBO@TRANSFORM?$AA@
	DD	FLAT:??_C@_09HNKP@TRANSLATE?$AA@
	DD	FLAT:??_C@_0M@LOEK@TRANSLATION?$AA@
	DD	FLAT:??_C@_07GNLP@TRIGGER?$AA@
	DD	FLAT:??_C@_04LNAG@TRUE?$AA@
	DD	FLAT:??_C@_08FCAH@TRUNCATE?$AA@
	DD	FLAT:??_C@_07CODK@TSEQUAL?$AA@
	DD	FLAT:??_C@_0M@PJEA@UNCOMMITTED?$AA@
	DD	FLAT:??_C@_05LNOP@UNION?$AA@
	DD	FLAT:??_C@_06LNBM@UNIQUE?$AA@
	DD	FLAT:??_C@_07CNPM@UNKNOWN?$AA@
	DD	FLAT:??_C@_06NDPG@UPDATE?$AA@
	DD	FLAT:??_C@_0L@DPMH@UPDATETEXT?$AA@
	DD	FLAT:??_C@_05PMKE@USAGE?$AA@
	DD	FLAT:??_C@_03OAHE@USE?$AA@
	DD	FLAT:??_C@_04FMHO@USER?$AA@
	DD	FLAT:??_C@_05JKMB@USING?$AA@
	DD	FLAT:??_C@_05MOEL@VALUE?$AA@
	DD	FLAT:??_C@_06KGMH@VALUES?$AA@
	DD	FLAT:??_C@_03KNCG@VAR?$AA@
	DD	FLAT:??_C@_09OLDK@VARBINARY?$AA@
	DD	FLAT:??_C@_07NGFA@VARCHAR?$AA@
	DD	FLAT:??_C@_04OIBN@VARP?$AA@
	DD	FLAT:??_C@_07MMOJ@VARYING?$AA@
	DD	FLAT:??_C@_04CGLB@VIEW?$AA@
	DD	FLAT:??_C@_06IEGE@VOLUME?$AA@
	DD	FLAT:??_C@_07KCD@WAITFOR?$AA@
	DD	FLAT:??_C@_04GKK@WHEN?$AA@
	DD	FLAT:??_C@_05MCFK@WHERE?$AA@
	DD	FLAT:??_C@_05LCLH@WHILE?$AA@
	DD	FLAT:??_C@_04NHMN@WITH?$AA@
	DD	FLAT:??_C@_04LDPM@WORK?$AA@
	DD	FLAT:??_C@_05FIFP@WRITE?$AA@
	DD	FLAT:??_C@_09IKOB@WRITETEXT?$AA@
	DD	FLAT:??_C@_03BDEP@XOR?$AA@
	DD	FLAT:??_C@_04HEBB@YEAR?$AA@
	DD	FLAT:??_C@_05NAPJ@YESNO?$AA@
	DD	FLAT:??_C@_04HOL@ZONE?$AA@
	DD	FLAT:??_C@_01A@?$AA?$AA@
_DATA	ENDS
;	COMDAT ??_C@_08DFNL@ABSOLUTE?$AA@
_DATA	SEGMENT
??_C@_08DFNL@ABSOLUTE?$AA@ DB 'ABSOLUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LHNJ@ACTION?$AA@
_DATA	SEGMENT
??_C@_06LHNJ@ACTION?$AA@ DB 'ACTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CICP@ADD?$AA@
_DATA	SEGMENT
??_C@_03CICP@ADD?$AA@ DB 'ADD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03MJMD@ALL?$AA@
_DATA	SEGMENT
??_C@_03MJMD@ALL?$AA@ DB 'ALL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HG@ALLOCATE?$AA@
_DATA	SEGMENT
??_C@_08HG@ALLOCATE?$AA@ DB 'ALLOCATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NNIC@ALPHANUMERIC?$AA@
_DATA	SEGMENT
??_C@_0N@NNIC@ALPHANUMERIC?$AA@ DB 'ALPHANUMERIC', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05BBIN@ALTER?$AA@
_DATA	SEGMENT
??_C@_05BBIN@ALTER?$AA@ DB 'ALTER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LACO@AND?$AA@
_DATA	SEGMENT
??_C@_03LACO@AND?$AA@ DB 'AND', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03ENCN@ANY?$AA@
_DATA	SEGMENT
??_C@_03ENCN@ANY?$AA@ DB 'ANY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03JPOO@ARE?$AA@
_DATA	SEGMENT
??_C@_03JPOO@ARE?$AA@ DB 'ARE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02EPAG@AS?$AA@
_DATA	SEGMENT
??_C@_02EPAG@AS?$AA@ DB 'AS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HGDG@ASC?$AA@
_DATA	SEGMENT
??_C@_03HGDG@ASC?$AA@ DB 'ASC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HNNJ@ASSERTION?$AA@
_DATA	SEGMENT
??_C@_09HNNJ@ASSERTION?$AA@ DB 'ASSERTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02BKOD@AT?$AA@
_DATA	SEGMENT
??_C@_02BKOD@AT?$AA@ DB 'AT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MMGM@AUTHORIZATION?$AA@
_DATA	SEGMENT
??_C@_0O@MMGM@AUTHORIZATION?$AA@ DB 'AUTHORIZATION', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@DFOG@AUTOINCREMENT?$AA@
_DATA	SEGMENT
??_C@_0O@DFOG@AUTOINCREMENT?$AA@ DB 'AUTOINCREMENT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_03JAGK@AVG?$AA@
_DATA	SEGMENT
??_C@_03JAGK@AVG?$AA@ DB 'AVG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JBBL@BEGIN?$AA@
_DATA	SEGMENT
??_C@_05JBBL@BEGIN?$AA@ DB 'BEGIN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FEKN@BETWEEN?$AA@
_DATA	SEGMENT
??_C@_07FEKN@BETWEEN?$AA@ DB 'BETWEEN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06ICJB@BINARY?$AA@
_DATA	SEGMENT
??_C@_06ICJB@BINARY?$AA@ DB 'BINARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IODA@BIT?$AA@
_DATA	SEGMENT
??_C@_03IODA@BIT?$AA@ DB 'BIT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HLBB@BOOLEAN?$AA@
_DATA	SEGMENT
??_C@_07HLBB@BOOLEAN?$AA@ DB 'BOOLEAN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NOIB@BOTH?$AA@
_DATA	SEGMENT
??_C@_04NOIB@BOTH?$AA@ DB 'BOTH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05CPDG@BREAK?$AA@
_DATA	SEGMENT
??_C@_05CPDG@BREAK?$AA@ DB 'BREAK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MIPA@BROWSE?$AA@
_DATA	SEGMENT
??_C@_06MIPA@BROWSE?$AA@ DB 'BROWSE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OLDH@BULK?$AA@
_DATA	SEGMENT
??_C@_04OLDH@BULK?$AA@ DB 'BULK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02HFGP@BY?$AA@
_DATA	SEGMENT
??_C@_02HFGP@BY?$AA@ DB 'BY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EHOP@BYTE?$AA@
_DATA	SEGMENT
??_C@_04EHOP@BYTE?$AA@ DB 'BYTE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HJNK@CASCADE?$AA@
_DATA	SEGMENT
??_C@_07HJNK@CASCADE?$AA@ DB 'CASCADE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GIOF@CASCADED?$AA@
_DATA	SEGMENT
??_C@_08GIOF@CASCADED?$AA@ DB 'CASCADED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LCDH@CASE?$AA@
_DATA	SEGMENT
??_C@_04LCDH@CASE?$AA@ DB 'CASE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LBNA@CAST?$AA@
_DATA	SEGMENT
??_C@_04LBNA@CAST?$AA@ DB 'CAST', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CPI@CATALOG?$AA@
_DATA	SEGMENT
??_C@_07CPI@CATALOG?$AA@ DB 'CATALOG', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MLPN@CHAR?$AA@
_DATA	SEGMENT
??_C@_04MLPN@CHAR?$AA@ DB 'CHAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09MNBH@CHARACTER?$AA@
_DATA	SEGMENT
??_C@_09MNBH@CHARACTER?$AA@ DB 'CHARACTER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@
_DATA	SEGMENT
??_C@_0BB@LGJP@CHARACTER_LENGTH?$AA@ DB 'CHARACTER_LENGTH', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@OBEF@CHAR_LENGTH?$AA@
_DATA	SEGMENT
??_C@_0M@OBEF@CHAR_LENGTH?$AA@ DB 'CHAR_LENGTH', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JHFD@CHECK?$AA@
_DATA	SEGMENT
??_C@_05JHFD@CHECK?$AA@ DB 'CHECK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CINA@CHECKPOINT?$AA@
_DATA	SEGMENT
??_C@_0L@CINA@CHECKPOINT?$AA@ DB 'CHECKPOINT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05PHOA@CLOSE?$AA@
_DATA	SEGMENT
??_C@_05PHOA@CLOSE?$AA@ DB 'CLOSE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GMHN@CLUSTERED?$AA@
_DATA	SEGMENT
??_C@_09GMHN@CLUSTERED?$AA@ DB 'CLUSTERED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DMIM@COALESCE?$AA@
_DATA	SEGMENT
??_C@_08DMIM@COALESCE?$AA@ DB 'COALESCE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HABJ@COLLATE?$AA@
_DATA	SEGMENT
??_C@_07HABJ@COLLATE?$AA@ DB 'COLLATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JEOK@COLLATION?$AA@
_DATA	SEGMENT
??_C@_09JEOK@COLLATION?$AA@ DB 'COLLATION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LGEH@COLUMN?$AA@
_DATA	SEGMENT
??_C@_06LGEH@COLUMN?$AA@ DB 'COLUMN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NAIG@COMMIT?$AA@
_DATA	SEGMENT
??_C@_06NAIG@COMMIT?$AA@ DB 'COMMIT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BMPB@COMMITTED?$AA@
_DATA	SEGMENT
??_C@_09BMPB@COMMITTED?$AA@ DB 'COMMITTED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FDPF@COMPUTE?$AA@
_DATA	SEGMENT
??_C@_07FDPF@COMPUTE?$AA@ DB 'COMPUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07ODJF@CONFIRM?$AA@
_DATA	SEGMENT
??_C@_07ODJF@CONFIRM?$AA@ DB 'CONFIRM', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DKLG@CONNECT?$AA@
_DATA	SEGMENT
??_C@_07DKLG@CONNECT?$AA@ DB 'CONNECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@ICLB@CONNECTION?$AA@
_DATA	SEGMENT
??_C@_0L@ICLB@CONNECTION?$AA@ DB 'CONNECTION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@LNCA@CONSTRAINT?$AA@
_DATA	SEGMENT
??_C@_0L@LNCA@CONSTRAINT?$AA@ DB 'CONSTRAINT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GMLE@CONSTRAINTS?$AA@
_DATA	SEGMENT
??_C@_0M@GMLE@CONSTRAINTS?$AA@ DB 'CONSTRAINTS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HDIP@CONTINUE?$AA@
_DATA	SEGMENT
??_C@_08HDIP@CONTINUE?$AA@ DB 'CONTINUE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@BOLK@CONTROLROW?$AA@
_DATA	SEGMENT
??_C@_0L@BOLK@CONTROLROW?$AA@ DB 'CONTROLROW', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DJAE@CONVERT?$AA@
_DATA	SEGMENT
??_C@_07DJAE@CONVERT?$AA@ DB 'CONVERT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@MOMH@CORRESPONDING?$AA@
_DATA	SEGMENT
??_C@_0O@MOMH@CORRESPONDING?$AA@ DB 'CORRESPONDING', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_05BNPO@COUNT?$AA@
_DATA	SEGMENT
??_C@_05BNPO@COUNT?$AA@ DB 'COUNT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CCFH@COUNTER?$AA@
_DATA	SEGMENT
??_C@_07CCFH@COUNTER?$AA@ DB 'COUNTER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JBCM@CREATE?$AA@
_DATA	SEGMENT
??_C@_06JBCM@CREATE?$AA@ DB 'CREATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05BLP@CROSS?$AA@
_DATA	SEGMENT
??_C@_05BLP@CROSS?$AA@ DB 'CROSS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08CHBF@CURRENCY?$AA@
_DATA	SEGMENT
??_C@_08CHBF@CURRENCY?$AA@ DB 'CURRENCY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HGLC@CURRENT?$AA@
_DATA	SEGMENT
??_C@_07HGLC@CURRENT?$AA@ DB 'CURRENT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NEAE@CURRENT_DATE?$AA@
_DATA	SEGMENT
??_C@_0N@NEAE@CURRENT_DATE?$AA@ DB 'CURRENT_DATE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NIMH@CURRENT_TIME?$AA@
_DATA	SEGMENT
??_C@_0N@NIMH@CURRENT_TIME?$AA@ DB 'CURRENT_TIME', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@
_DATA	SEGMENT
??_C@_0BC@GGBA@CURRENT_TIMESTAMP?$AA@ DB 'CURRENT_TIMESTAMP', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@KBKG@CURRENT_USER?$AA@
_DATA	SEGMENT
??_C@_0N@KBKG@CURRENT_USER?$AA@ DB 'CURRENT_USER', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MDJJ@CURSOR?$AA@
_DATA	SEGMENT
??_C@_06MDJJ@CURSOR?$AA@ DB 'CURSOR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PKHN@DATABASE?$AA@
_DATA	SEGMENT
??_C@_08PKHN@DATABASE?$AA@ DB 'DATABASE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CJNM@DATE?$AA@
_DATA	SEGMENT
??_C@_04CJNM@DATE?$AA@ DB 'DATE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MIJC@DATETIME?$AA@
_DATA	SEGMENT
??_C@_08MIJC@DATETIME?$AA@ DB 'DATETIME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IDGA@DAY?$AA@
_DATA	SEGMENT
??_C@_03IDGA@DAY?$AA@ DB 'DAY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OPFP@DBAREA?$AA@
_DATA	SEGMENT
??_C@_06OPFP@DBAREA?$AA@ DB 'DBAREA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CLGJ@DBCC?$AA@
_DATA	SEGMENT
??_C@_04CLGJ@DBCC?$AA@ DB 'DBCC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JGIO@DEALLOCATE?$AA@
_DATA	SEGMENT
??_C@_0L@JGIO@DEALLOCATE?$AA@ DB 'DEALLOCATE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DAPA@DEBUG?$AA@
_DATA	SEGMENT
??_C@_05DAPA@DEBUG?$AA@ DB 'DEBUG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CJJP@DECLARE?$AA@
_DATA	SEGMENT
??_C@_07CJJP@DECLARE?$AA@ DB 'DECLARE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FBHA@DEFAULT?$AA@
_DATA	SEGMENT
??_C@_07FBHA@DEFAULT?$AA@ DB 'DEFAULT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@POBB@DEFERRABLE?$AA@
_DATA	SEGMENT
??_C@_0L@POBB@DEFERRABLE?$AA@ DB 'DEFERRABLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IEEN@DEFERRED?$AA@
_DATA	SEGMENT
??_C@_08IEEN@DEFERRED?$AA@ DB 'DEFERRED', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FMHL@DELETE?$AA@
_DATA	SEGMENT
??_C@_06FMHL@DELETE?$AA@ DB 'DELETE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PPKB@DESC?$AA@
_DATA	SEGMENT
??_C@_04PPKB@DESC?$AA@ DB 'DESC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FBJG@DESCRIBE?$AA@
_DATA	SEGMENT
??_C@_08FBJG@DESCRIBE?$AA@ DB 'DESCRIBE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKAF@DESCRIPTOR?$AA@
_DATA	SEGMENT
??_C@_0L@GKAF@DESCRIPTOR?$AA@ DB 'DESCRIPTOR', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@OKKK@DIAGNOSTICS?$AA@
_DATA	SEGMENT
??_C@_0M@OKKK@DIAGNOSTICS?$AA@ DB 'DIAGNOSTICS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GADM@DISALLOW?$AA@
_DATA	SEGMENT
??_C@_08GADM@DISALLOW?$AA@ DB 'DISALLOW', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBA@DISCONNECT?$AA@
_DATA	SEGMENT
??_C@_0L@OGBA@DISCONNECT?$AA@ DB 'DISCONNECT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HDPG@DISK?$AA@
_DATA	SEGMENT
??_C@_04HDPG@DISK?$AA@ DB 'DISK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EGKJ@DISTINCT?$AA@
_DATA	SEGMENT
??_C@_08EGKJ@DISTINCT?$AA@ DB 'DISTINCT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@EMHJ@DISTINCTROW?$AA@
_DATA	SEGMENT
??_C@_0M@EMHJ@DISTINCTROW?$AA@ DB 'DISTINCTROW', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@ONJI@DISTRIBUTED?$AA@
_DATA	SEGMENT
??_C@_0M@ONJI@DISTRIBUTED?$AA@ DB 'DISTRIBUTED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EIOP@DOMAIN?$AA@
_DATA	SEGMENT
??_C@_06EIOP@DOMAIN?$AA@ DB 'DOMAIN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CGGE@DOUBLE?$AA@
_DATA	SEGMENT
??_C@_06CGGE@DOUBLE?$AA@ DB 'DOUBLE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LDDE@DROP?$AA@
_DATA	SEGMENT
??_C@_04LDDE@DROP?$AA@ DB 'DROP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JGEC@DUMMY?$AA@
_DATA	SEGMENT
??_C@_05JGEC@DUMMY?$AA@ DB 'DUMMY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CAAA@DUMP?$AA@
_DATA	SEGMENT
??_C@_04CAAA@DUMP?$AA@ DB 'DUMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OHCC@ELSE?$AA@
_DATA	SEGMENT
??_C@_04OHCC@ELSE?$AA@ DB 'ELSE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PIHE@END?$AA@
_DATA	SEGMENT
??_C@_03PIHE@END?$AA@ DB 'END', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08GNOH@END_EXEC?$AA@
_DATA	SEGMENT
??_C@_08GNOH@END_EXEC?$AA@ DB 'END_EXEC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LKIC@EQV?$AA@
_DATA	SEGMENT
??_C@_03LKIC@EQV?$AA@ DB 'EQV', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BKPA@ERRLVL?$AA@
_DATA	SEGMENT
??_C@_06BKPA@ERRLVL?$AA@ DB 'ERRLVL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EIBF@ERROREXIT?$AA@
_DATA	SEGMENT
??_C@_09EIBF@ERROREXIT?$AA@ DB 'ERROREXIT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MJIP@ESCAPE?$AA@
_DATA	SEGMENT
??_C@_06MJIP@ESCAPE?$AA@ DB 'ESCAPE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06GDHH@EXCEPT?$AA@
_DATA	SEGMENT
??_C@_06GDHH@EXCEPT?$AA@ DB 'EXCEPT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EEOO@EXCEPTION?$AA@
_DATA	SEGMENT
??_C@_09EEOO@EXCEPTION?$AA@ DB 'EXCEPTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GMDG@EXEC?$AA@
_DATA	SEGMENT
??_C@_04GMDG@EXEC?$AA@ DB 'EXEC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DNBH@EXECUTE?$AA@
_DATA	SEGMENT
??_C@_07DNBH@EXECUTE?$AA@ DB 'EXECUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MBBB@EXISTS?$AA@
_DATA	SEGMENT
??_C@_06MBBB@EXISTS?$AA@ DB 'EXISTS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HPFN@EXIT?$AA@
_DATA	SEGMENT
??_C@_04HPFN@EXIT?$AA@ DB 'EXIT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@ILPO@EXPIREDATE?$AA@
_DATA	SEGMENT
??_C@_0L@ILPO@EXPIREDATE?$AA@ DB 'EXPIREDATE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EDIC@EXTERNAL?$AA@
_DATA	SEGMENT
??_C@_08EDIC@EXTERNAL?$AA@ DB 'EXTERNAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IODP@EXTRACT?$AA@
_DATA	SEGMENT
??_C@_07IODP@EXTRACT?$AA@ DB 'EXTRACT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05LLOB@FALSE?$AA@
_DATA	SEGMENT
??_C@_05LLOB@FALSE?$AA@ DB 'FALSE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KBKM@FETCH?$AA@
_DATA	SEGMENT
??_C@_05KBKM@FETCH?$AA@ DB 'FETCH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CMDA@FILE?$AA@
_DATA	SEGMENT
??_C@_04CMDA@FILE?$AA@ DB 'FILE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NPIO@FILLFACTOR?$AA@
_DATA	SEGMENT
??_C@_0L@NPIO@FILLFACTOR?$AA@ DB 'FILLFACTOR', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MPDO@FIRST?$AA@
_DATA	SEGMENT
??_C@_05MPDO@FIRST?$AA@ DB 'FIRST', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JDEL@FLOAT?$AA@
_DATA	SEGMENT
??_C@_05JDEL@FLOAT?$AA@ DB 'FLOAT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FFP@FLOAT4?$AA@
_DATA	SEGMENT
??_C@_06FFP@FLOAT4?$AA@ DB 'FLOAT4', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PLLL@FLOAT8?$AA@
_DATA	SEGMENT
??_C@_06PLLL@FLOAT8?$AA@ DB 'FLOAT8', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IPNK@FLOPPY?$AA@
_DATA	SEGMENT
??_C@_06IPNK@FLOPPY?$AA@ DB 'FLOPPY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03EOOH@FOR?$AA@
_DATA	SEGMENT
??_C@_03EOOH@FOR?$AA@ DB 'FOR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07ECFK@FOREIGN?$AA@
_DATA	SEGMENT
??_C@_07ECFK@FOREIGN?$AA@ DB 'FOREIGN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EJD@FROM?$AA@
_DATA	SEGMENT
??_C@_04EJD@FROM?$AA@ DB 'FROM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CLJK@FULL?$AA@
_DATA	SEGMENT
??_C@_04CLJK@FULL?$AA@ DB 'FULL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HLIC@GET?$AA@
_DATA	SEGMENT
??_C@_03HLIC@GET?$AA@ DB 'GET', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PODI@GETDEFAULT?$AA@
_DATA	SEGMENT
??_C@_0L@PODI@GETDEFAULT?$AA@ DB 'GETDEFAULT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EKIF@GLOBAL?$AA@
_DATA	SEGMENT
??_C@_06EKIF@GLOBAL?$AA@ DB 'GLOBAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DLHO@GOTO?$AA@
_DATA	SEGMENT
??_C@_04DLHO@GOTO?$AA@ DB 'GOTO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DLPA@GRANT?$AA@
_DATA	SEGMENT
??_C@_05DLPA@GRANT?$AA@ DB 'GRANT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JGM@GROUP?$AA@
_DATA	SEGMENT
??_C@_05JGM@GROUP?$AA@ DB 'GROUP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BGHA@GUID?$AA@
_DATA	SEGMENT
??_C@_04BGHA@GUID?$AA@ DB 'GUID', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06GNBD@HAVING?$AA@
_DATA	SEGMENT
??_C@_06GNBD@HAVING?$AA@ DB 'HAVING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JHAN@HOLDLOCK?$AA@
_DATA	SEGMENT
??_C@_08JHAN@HOLDLOCK?$AA@ DB 'HOLDLOCK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PJ@HOUR?$AA@
_DATA	SEGMENT
??_C@_04PJ@HOUR?$AA@ DB 'HOUR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MFJF@IDENTITY?$AA@
_DATA	SEGMENT
??_C@_08MFJF@IDENTITY?$AA@ DB 'IDENTITY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@EOA@IDENTITYCOL?$AA@
_DATA	SEGMENT
??_C@_0M@EOA@IDENTITYCOL?$AA@ DB 'IDENTITYCOL', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@JADB@IDENTITY_INSERT?$AA@
_DATA	SEGMENT
??_C@_0BA@JADB@IDENTITY_INSERT?$AA@ DB 'IDENTITY_INSERT', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CMNP@IEEEDOUBLE?$AA@
_DATA	SEGMENT
??_C@_0L@CMNP@IEEEDOUBLE?$AA@ DB 'IEEEDOUBLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@FEGJ@IEEESINGLE?$AA@
_DATA	SEGMENT
??_C@_0L@FEGJ@IEEESINGLE?$AA@ DB 'IEEESINGLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_02FDOJ@IF?$AA@
_DATA	SEGMENT
??_C@_02FDOJ@IF?$AA@ DB 'IF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06HLND@IGNORE?$AA@
_DATA	SEGMENT
??_C@_06HLND@IGNORE?$AA@ DB 'IGNORE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LEPP@IMMEDIATE?$AA@
_DATA	SEGMENT
??_C@_09LEPP@IMMEDIATE?$AA@ DB 'IMMEDIATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BIEI@IMP?$AA@
_DATA	SEGMENT
??_C@_03BIEI@IMP?$AA@ DB 'IMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02HFB@IN?$AA@
_DATA	SEGMENT
??_C@_02HFB@IN?$AA@ DB 'IN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05HKPP@INDEX?$AA@
_DATA	SEGMENT
??_C@_05HKPP@INDEX?$AA@ DB 'INDEX', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09BAOC@INITIALLY?$AA@
_DATA	SEGMENT
??_C@_09BAOC@INITIALLY?$AA@ DB 'INITIALLY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05EPPB@INNER?$AA@
_DATA	SEGMENT
??_C@_05EPPB@INNER?$AA@ DB 'INNER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05IHIC@INPUT?$AA@
_DATA	SEGMENT
??_C@_05IHIC@INPUT?$AA@ DB 'INPUT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PDHJ@INSENSITIVE?$AA@
_DATA	SEGMENT
??_C@_0M@PDHJ@INSENSITIVE?$AA@ DB 'INSENSITIVE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CCAI@INSERT?$AA@
_DATA	SEGMENT
??_C@_06CCAI@INSERT?$AA@ DB 'INSERT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IJOL@INT?$AA@
_DATA	SEGMENT
??_C@_03IJOL@INT?$AA@ DB 'INT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KMGD@INTEGER?$AA@
_DATA	SEGMENT
??_C@_07KMGD@INTEGER?$AA@ DB 'INTEGER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PEKL@INTEGER1?$AA@
_DATA	SEGMENT
??_C@_08PEKL@INTEGER1?$AA@ DB 'INTEGER1', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08LBC@INTEGER2?$AA@
_DATA	SEGMENT
??_C@_08LBC@INTEGER2?$AA@ DB 'INTEGER2', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GIDA@INTERSECT?$AA@
_DATA	SEGMENT
??_C@_09GIDA@INTERSECT?$AA@ DB 'INTERSECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08JNLE@INTERVAL?$AA@
_DATA	SEGMENT
??_C@_08JNLE@INTERVAL?$AA@ DB 'INTERVAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JMBE@INTO?$AA@
_DATA	SEGMENT
??_C@_04JMBE@INTO?$AA@ DB 'INTO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02PKFC@IS?$AA@
_DATA	SEGMENT
??_C@_02PKFC@IS?$AA@ DB 'IS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JCKC@ISOLATION?$AA@
_DATA	SEGMENT
??_C@_09JCKC@ISOLATION?$AA@ DB 'ISOLATION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JIJO@JOIN?$AA@
_DATA	SEGMENT
??_C@_04JIJO@JOIN?$AA@ DB 'JOIN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03PHBO@KEY?$AA@
_DATA	SEGMENT
??_C@_03PHBO@KEY?$AA@ DB 'KEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EIJF@KILL?$AA@
_DATA	SEGMENT
??_C@_04EIJF@KILL?$AA@ DB 'KILL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GBPO@LAST?$AA@
_DATA	SEGMENT
??_C@_04GBPO@LAST?$AA@ DB 'LAST', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HHCE@LEADING?$AA@
_DATA	SEGMENT
??_C@_07HHCE@LEADING?$AA@ DB 'LEADING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PAN@LEFT?$AA@
_DATA	SEGMENT
??_C@_04PAN@LEFT?$AA@ DB 'LEFT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JJEC@LEVEL?$AA@
_DATA	SEGMENT
??_C@_05JJEC@LEVEL?$AA@ DB 'LEVEL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CNFB@LIKE?$AA@
_DATA	SEGMENT
??_C@_04CNFB@LIKE?$AA@ DB 'LIKE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MJFP@LINENO?$AA@
_DATA	SEGMENT
??_C@_06MJFP@LINENO?$AA@ DB 'LINENO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PDLA@LOAD?$AA@
_DATA	SEGMENT
??_C@_04PDLA@LOAD?$AA@ DB 'LOAD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JIPK@LOCAL?$AA@
_DATA	SEGMENT
??_C@_05JIPK@LOCAL?$AA@ DB 'LOCAL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07OAKI@LOGICAL?$AA@
_DATA	SEGMENT
??_C@_07OAKI@LOGICAL?$AA@ DB 'LOGICAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08KCOH@LOGICAL1?$AA@
_DATA	SEGMENT
??_C@_08KCOH@LOGICAL1?$AA@ DB 'LOGICAL1', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NIAI@LONG?$AA@
_DATA	SEGMENT
??_C@_04NIAI@LONG?$AA@ DB 'LONG', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GKBM@LONGBINARY?$AA@
_DATA	SEGMENT
??_C@_0L@GKBM@LONGBINARY?$AA@ DB 'LONGBINARY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08HLJO@LONGTEXT?$AA@
_DATA	SEGMENT
??_C@_08HLJO@LONGTEXT?$AA@ DB 'LONGTEXT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NFKB@MATCH?$AA@
_DATA	SEGMENT
??_C@_05NFKB@MATCH?$AA@ DB 'MATCH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03OLFE@MAX?$AA@
_DATA	SEGMENT
??_C@_03OLFE@MAX?$AA@ DB 'MAX', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KGIF@MEMO?$AA@
_DATA	SEGMENT
??_C@_04KGIF@MEMO?$AA@ DB 'MEMO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03IAC@MIN?$AA@
_DATA	SEGMENT
??_C@_03IAC@MIN?$AA@ DB 'MIN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IOKL@MINUTE?$AA@
_DATA	SEGMENT
??_C@_06IOKL@MINUTE?$AA@ DB 'MINUTE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@GNDP@MIRROREXIT?$AA@
_DATA	SEGMENT
??_C@_0L@GNDP@MIRROREXIT?$AA@ DB 'MIRROREXIT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03HOGL@MOD?$AA@
_DATA	SEGMENT
??_C@_03HOGL@MOD?$AA@ DB 'MOD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05EBDH@MONEY?$AA@
_DATA	SEGMENT
??_C@_05EBDH@MONEY?$AA@ DB 'MONEY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DOND@MONTH?$AA@
_DATA	SEGMENT
??_C@_05DOND@MONTH?$AA@ DB 'MONTH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KDIJ@NAMES?$AA@
_DATA	SEGMENT
??_C@_05KDIJ@NAMES?$AA@ DB 'NAMES', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08CHPD@NATIONAL?$AA@
_DATA	SEGMENT
??_C@_08CHPD@NATIONAL?$AA@ DB 'NATIONAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BGPN@NATURAL?$AA@
_DATA	SEGMENT
??_C@_07BGPN@NATURAL?$AA@ DB 'NATURAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DFM@NCHAR?$AA@
_DATA	SEGMENT
??_C@_05DFM@NCHAR?$AA@ DB 'NCHAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04ONKL@NEXT?$AA@
_DATA	SEGMENT
??_C@_04ONKL@NEXT?$AA@ DB 'NEXT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NAJC@NEXTLOG?$AA@
_DATA	SEGMENT
??_C@_07NAJC@NEXTLOG?$AA@ DB 'NEXTLOG', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02MMJD@NO?$AA@
_DATA	SEGMENT
??_C@_02MMJD@NO?$AA@ DB 'NO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07IMID@NOCHECK?$AA@
_DATA	SEGMENT
??_C@_07IMID@NOCHECK?$AA@ DB 'NOCHECK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NJNJ@NONCLUSTERED?$AA@
_DATA	SEGMENT
??_C@_0N@NJNJ@NONCLUSTERED?$AA@ DB 'NONCLUSTERED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CBCA@NOT?$AA@
_DATA	SEGMENT
??_C@_03CBCA@NOT?$AA@ DB 'NOT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DFCK@NOTE?$AA@
_DATA	SEGMENT
??_C@_04DFCK@NOTE?$AA@ DB 'NOTE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BAK@NULL?$AA@
_DATA	SEGMENT
??_C@_04BAK@NULL?$AA@ DB 'NULL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06HGII@NULLIF?$AA@
_DATA	SEGMENT
??_C@_06HGII@NULLIF?$AA@ DB 'NULLIF', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MDMK@NUMBER?$AA@
_DATA	SEGMENT
??_C@_06MDMK@NUMBER?$AA@ DB 'NUMBER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FIAN@NUMERIC?$AA@
_DATA	SEGMENT
??_C@_07FIAN@NUMERIC?$AA@ DB 'NUMERIC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@PBNP@OCTET_LENGTH?$AA@
_DATA	SEGMENT
??_C@_0N@PBNP@OCTET_LENGTH?$AA@ DB 'OCTET_LENGTH', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_02CEBG@OF?$AA@
_DATA	SEGMENT
??_C@_02CEBG@OF?$AA@ DB 'OF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CMJG@OFF?$AA@
_DATA	SEGMENT
??_C@_03CMJG@OFF?$AA@ DB 'OFF', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07FMHE@OFFSETS?$AA@
_DATA	SEGMENT
??_C@_07FMHE@OFFSETS?$AA@ DB 'OFFSETS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GMOF@OLEOBJECT?$AA@
_DATA	SEGMENT
??_C@_09GMOF@OLEOBJECT?$AA@ DB 'OLEOBJECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02HAKO@ON?$AA@
_DATA	SEGMENT
??_C@_02HAKO@ON?$AA@ DB 'ON', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EJJC@ONCE?$AA@
_DATA	SEGMENT
??_C@_04EJJC@ONCE?$AA@ DB 'ONCE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MKAH@ONLY?$AA@
_DATA	SEGMENT
??_C@_04MKAH@ONLY?$AA@ DB 'ONLY', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04MIME@OPEN?$AA@
_DATA	SEGMENT
??_C@_04MIME@OPEN?$AA@ DB 'OPEN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IFCC@OPTION?$AA@
_DATA	SEGMENT
??_C@_06IFCC@OPTION?$AA@ DB 'OPTION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_02CHDK@OR?$AA@
_DATA	SEGMENT
??_C@_02CHDK@OR?$AA@ DB 'OR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FBEP@ORDER?$AA@
_DATA	SEGMENT
??_C@_05FBEP@ORDER?$AA@ DB 'ORDER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05IKJL@OUTER?$AA@
_DATA	SEGMENT
??_C@_05IKJL@OUTER?$AA@ DB 'OUTER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BMBF@OUTPUT?$AA@
_DATA	SEGMENT
??_C@_06BMBF@OUTPUT?$AA@ DB 'OUTPUT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HDCH@OVER?$AA@
_DATA	SEGMENT
??_C@_04HDCH@OVER?$AA@ DB 'OVER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08PGNB@OVERLAPS?$AA@
_DATA	SEGMENT
??_C@_08PGNB@OVERLAPS?$AA@ DB 'OVERLAPS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GPH@OWNERACCESS?$AA@
_DATA	SEGMENT
??_C@_0M@GPH@OWNERACCESS?$AA@ DB 'OWNERACCESS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BHFD@PAD?$AA@
_DATA	SEGMENT
??_C@_03BHFD@PAD?$AA@ DB 'PAD', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@PEIP@PARAMETERS?$AA@
_DATA	SEGMENT
??_C@_0L@PEIP@PARAMETERS?$AA@ DB 'PARAMETERS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MOBO@PARTIAL?$AA@
_DATA	SEGMENT
??_C@_07MOBO@PARTIAL?$AA@ DB 'PARTIAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MGCH@PERCENT?$AA@
_DATA	SEGMENT
??_C@_07MGCH@PERCENT?$AA@ DB 'PERCENT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04ICKI@PERM?$AA@
_DATA	SEGMENT
??_C@_04ICKI@PERM?$AA@ DB 'PERM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JLAF@PERMANENT?$AA@
_DATA	SEGMENT
??_C@_09JLAF@PERMANENT?$AA@ DB 'PERMANENT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CDKK@PIPE?$AA@
_DATA	SEGMENT
??_C@_04CDKK@PIPE?$AA@ DB 'PIPE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MALJ@PIVOT?$AA@
_DATA	SEGMENT
??_C@_05MALJ@PIVOT?$AA@ DB 'PIVOT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OOOE@PLAN?$AA@
_DATA	SEGMENT
??_C@_04OOOE@PLAN?$AA@ DB 'PLAN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BGJK@POSITION?$AA@
_DATA	SEGMENT
??_C@_08BGJK@POSITION?$AA@ DB 'POSITION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LJHE@PRECISION?$AA@
_DATA	SEGMENT
??_C@_09LJHE@PRECISION?$AA@ DB 'PRECISION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07OCNH@PREPARE?$AA@
_DATA	SEGMENT
??_C@_07OCNH@PREPARE?$AA@ DB 'PREPARE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07JPNB@PRESEVE?$AA@
_DATA	SEGMENT
??_C@_07JPNB@PRESEVE?$AA@ DB 'PRESEVE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07PLFH@PRIMARY?$AA@
_DATA	SEGMENT
??_C@_07PLFH@PRIMARY?$AA@ DB 'PRIMARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MJOK@PRINT?$AA@
_DATA	SEGMENT
??_C@_05MJOK@PRINT?$AA@ DB 'PRINT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05CADC@PRIOR?$AA@
_DATA	SEGMENT
??_C@_05CADC@PRIOR?$AA@ DB 'PRIOR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@IFKE@PRIVILEGES?$AA@
_DATA	SEGMENT
??_C@_0L@IFKE@PRIVILEGES?$AA@ DB 'PRIVILEGES', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CFJE@PROC?$AA@
_DATA	SEGMENT
??_C@_04CFJE@PROC?$AA@ DB 'PROC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HPKL@PROCEDURE?$AA@
_DATA	SEGMENT
??_C@_09HPKL@PROCEDURE?$AA@ DB 'PROCEDURE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CNCJ@PROCESSEXIT?$AA@
_DATA	SEGMENT
??_C@_0M@CNCJ@PROCESSEXIT?$AA@ DB 'PROCESSEXIT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JPM@PUBLIC?$AA@
_DATA	SEGMENT
??_C@_06JPM@PUBLIC?$AA@ DB 'PUBLIC', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EHBK@RAISERROR?$AA@
_DATA	SEGMENT
??_C@_09EHBK@RAISERROR?$AA@ DB 'RAISERROR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GHHF@READ?$AA@
_DATA	SEGMENT
??_C@_04GHHF@READ?$AA@ DB 'READ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IEGM@READTEXT?$AA@
_DATA	SEGMENT
??_C@_08IEGM@READTEXT?$AA@ DB 'READTEXT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DDMN@REAL?$AA@
_DATA	SEGMENT
??_C@_04DDMN@REAL?$AA@ DB 'REAL', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CLEO@RECONFIGURE?$AA@
_DATA	SEGMENT
??_C@_0M@CLEO@RECONFIGURE?$AA@ DB 'RECONFIGURE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DHND@REFERENCES?$AA@
_DATA	SEGMENT
??_C@_0L@DHND@REFERENCES?$AA@ DB 'REFERENCES', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NDFO@RELATIVE?$AA@
_DATA	SEGMENT
??_C@_08NDFO@RELATIVE?$AA@ DB 'RELATIVE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DEIL@REPEATABLE?$AA@
_DATA	SEGMENT
??_C@_0L@DEIL@REPEATABLE?$AA@ DB 'REPEATABLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@GBCL@REPLICATION?$AA@
_DATA	SEGMENT
??_C@_0M@GBCL@REPLICATION?$AA@ DB 'REPLICATION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08BEHK@RESTRICT?$AA@
_DATA	SEGMENT
??_C@_08BEHK@RESTRICT?$AA@ DB 'RESTRICT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09NACH@RETAINDAY?$AA@
_DATA	SEGMENT
??_C@_09NACH@RETAINDAY?$AA@ DB 'RETAINDAY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PJJM@RETURN?$AA@
_DATA	SEGMENT
??_C@_06PJJM@RETURN?$AA@ DB 'RETURN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MEJM@REVOKE?$AA@
_DATA	SEGMENT
??_C@_06MEJM@REVOKE?$AA@ DB 'REVOKE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JCNK@RIGHT?$AA@
_DATA	SEGMENT
??_C@_05JCNK@RIGHT?$AA@ DB 'RIGHT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EMFJ@ROLLBACK?$AA@
_DATA	SEGMENT
??_C@_08EMFJ@ROLLBACK?$AA@ DB 'ROLLBACK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MGKJ@ROWCOUNT?$AA@
_DATA	SEGMENT
??_C@_08MGKJ@ROWCOUNT?$AA@ DB 'ROWCOUNT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LCCO@ROWS?$AA@
_DATA	SEGMENT
??_C@_04LCCO@ROWS?$AA@ DB 'ROWS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BFNM@RULE?$AA@
_DATA	SEGMENT
??_C@_04BFNM@RULE?$AA@ DB 'RULE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04KLBG@SAVE?$AA@
_DATA	SEGMENT
??_C@_04KLBG@SAVE?$AA@ DB 'SAVE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NIIF@SCHEMA?$AA@
_DATA	SEGMENT
??_C@_06NIIF@SCHEMA?$AA@ DB 'SCHEMA', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JLNB@SCROLL?$AA@
_DATA	SEGMENT
??_C@_06JLNB@SCROLL?$AA@ DB 'SCROLL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FCJA@SECOND?$AA@
_DATA	SEGMENT
??_C@_06FCJA@SECOND?$AA@ DB 'SECOND', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OGAC@SELECT?$AA@
_DATA	SEGMENT
??_C@_06OGAC@SELECT?$AA@ DB 'SELECT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCJF@SERIALIZABLE?$AA@
_DATA	SEGMENT
??_C@_0N@CCJF@SERIALIZABLE?$AA@ DB 'SERIALIZABLE', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CGDO@SESSION?$AA@
_DATA	SEGMENT
??_C@_07CGDO@SESSION?$AA@ DB 'SESSION', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@JGA@SESSION_USER?$AA@
_DATA	SEGMENT
??_C@_0N@JGA@SESSION_USER?$AA@ DB 'SESSION_USER', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BCLC@SET?$AA@
_DATA	SEGMENT
??_C@_03BCLC@SET?$AA@ DB 'SET', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07EDEP@SETUSER?$AA@
_DATA	SEGMENT
??_C@_07EDEP@SETUSER?$AA@ DB 'SETUSER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05HFLA@SHORT?$AA@
_DATA	SEGMENT
??_C@_05HFLA@SHORT?$AA@ DB 'SHORT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DPKF@SHUTDOWN?$AA@
_DATA	SEGMENT
??_C@_08DPKF@SHUTDOWN?$AA@ DB 'SHUTDOWN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06FONC@SINGLE?$AA@
_DATA	SEGMENT
??_C@_06FONC@SINGLE?$AA@ DB 'SINGLE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NEFN@SIZE?$AA@
_DATA	SEGMENT
??_C@_04NEFN@SIZE?$AA@ DB 'SIZE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DMN@SMALLINT?$AA@
_DATA	SEGMENT
??_C@_08DMN@SMALLINT?$AA@ DB 'SMALLINT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DDNG@SOME?$AA@
_DATA	SEGMENT
??_C@_04DDNG@SOME?$AA@ DB 'SOME', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JCH@SPACE?$AA@
_DATA	SEGMENT
??_C@_05JCH@SPACE?$AA@ DB 'SPACE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DHID@SQLSTATE?$AA@
_DATA	SEGMENT
??_C@_08DHID@SQLSTATE?$AA@ DB 'SQLSTATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@JMMG@STATISTICS?$AA@
_DATA	SEGMENT
??_C@_0L@JMMG@STATISTICS?$AA@ DB 'STATISTICS', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05KHBF@STDEV?$AA@
_DATA	SEGMENT
??_C@_05KHBF@STDEV?$AA@ DB 'STDEV', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06OCBH@STDEVP?$AA@
_DATA	SEGMENT
??_C@_06OCBH@STDEVP?$AA@ DB 'STDEVP', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06JDFN@STRING?$AA@
_DATA	SEGMENT
??_C@_06JDFN@STRING?$AA@ DB 'STRING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03CPEE@SUM?$AA@
_DATA	SEGMENT
??_C@_03CPEE@SUM?$AA@ DB 'SUM', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBHB@SYSTEM_USER?$AA@
_DATA	SEGMENT
??_C@_0M@JBHB@SYSTEM_USER?$AA@ DB 'SYSTEM_USER', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05DLJE@TABLE?$AA@
_DATA	SEGMENT
??_C@_05DLJE@TABLE?$AA@ DB 'TABLE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DAKP@TABLEID?$AA@
_DATA	SEGMENT
??_C@_07DAKP@TABLEID?$AA@ DB 'TABLEID', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CGFH@TAPE?$AA@
_DATA	SEGMENT
??_C@_04CGFH@TAPE?$AA@ DB 'TAPE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FEEL@TEMP?$AA@
_DATA	SEGMENT
??_C@_04FEEL@TEMP?$AA@ DB 'TEMP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09EAGL@TEMPORARY?$AA@
_DATA	SEGMENT
??_C@_09EAGL@TEMPORARY?$AA@ DB 'TEMPORARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NILO@TEXT?$AA@
_DATA	SEGMENT
??_C@_04NILO@TEXT?$AA@ DB 'TEXT', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FIJO@TEXTSIZE?$AA@
_DATA	SEGMENT
??_C@_08FIJO@TEXTSIZE?$AA@ DB 'TEXTSIZE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GJFM@THEN?$AA@
_DATA	SEGMENT
??_C@_04GJFM@THEN?$AA@ DB 'THEN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CFBP@TIME?$AA@
_DATA	SEGMENT
??_C@_04CFBP@TIME?$AA@ DB 'TIME', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KEAG@TIMESTAMP?$AA@
_DATA	SEGMENT
??_C@_09KEAG@TIMESTAMP?$AA@ DB 'TIMESTAMP', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@
_DATA	SEGMENT
??_C@_0O@OCJA@TIMEZONE_HOUR?$AA@ DB 'TIMEZONE_HOUR', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@
_DATA	SEGMENT
??_C@_0BA@OAII@TIMEZONE_MINUTE?$AA@ DB 'TIMEZONE_MINUTE', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_02DODL@TO?$AA@
_DATA	SEGMENT
??_C@_02DODL@TO?$AA@ DB 'TO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03JOIO@TOP?$AA@
_DATA	SEGMENT
??_C@_03JOIO@TOP?$AA@ DB 'TOP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08NJGC@TRAILING?$AA@
_DATA	SEGMENT
??_C@_08NJGC@TRAILING?$AA@ DB 'TRAILING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CGAE@TRAN?$AA@
_DATA	SEGMENT
??_C@_04CGAE@TRAN?$AA@ DB 'TRAN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JACB@TRANSACTION?$AA@
_DATA	SEGMENT
??_C@_0M@JACB@TRANSACTION?$AA@ DB 'TRANSACTION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09ECBO@TRANSFORM?$AA@
_DATA	SEGMENT
??_C@_09ECBO@TRANSFORM?$AA@ DB 'TRANSFORM', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09HNKP@TRANSLATE?$AA@
_DATA	SEGMENT
??_C@_09HNKP@TRANSLATE?$AA@ DB 'TRANSLATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LOEK@TRANSLATION?$AA@
_DATA	SEGMENT
??_C@_0M@LOEK@TRANSLATION?$AA@ DB 'TRANSLATION', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07GNLP@TRIGGER?$AA@
_DATA	SEGMENT
??_C@_07GNLP@TRIGGER?$AA@ DB 'TRIGGER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LNAG@TRUE?$AA@
_DATA	SEGMENT
??_C@_04LNAG@TRUE?$AA@ DB 'TRUE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FCAH@TRUNCATE?$AA@
_DATA	SEGMENT
??_C@_08FCAH@TRUNCATE?$AA@ DB 'TRUNCATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CODK@TSEQUAL?$AA@
_DATA	SEGMENT
??_C@_07CODK@TSEQUAL?$AA@ DB 'TSEQUAL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PJEA@UNCOMMITTED?$AA@
_DATA	SEGMENT
??_C@_0M@PJEA@UNCOMMITTED?$AA@ DB 'UNCOMMITTED', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05LNOP@UNION?$AA@
_DATA	SEGMENT
??_C@_05LNOP@UNION?$AA@ DB 'UNION', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06LNBM@UNIQUE?$AA@
_DATA	SEGMENT
??_C@_06LNBM@UNIQUE?$AA@ DB 'UNIQUE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CNPM@UNKNOWN?$AA@
_DATA	SEGMENT
??_C@_07CNPM@UNKNOWN?$AA@ DB 'UNKNOWN', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NDPG@UPDATE?$AA@
_DATA	SEGMENT
??_C@_06NDPG@UPDATE?$AA@ DB 'UPDATE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DPMH@UPDATETEXT?$AA@
_DATA	SEGMENT
??_C@_0L@DPMH@UPDATETEXT?$AA@ DB 'UPDATETEXT', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_05PMKE@USAGE?$AA@
_DATA	SEGMENT
??_C@_05PMKE@USAGE?$AA@ DB 'USAGE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_03OAHE@USE?$AA@
_DATA	SEGMENT
??_C@_03OAHE@USE?$AA@ DB 'USE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04FMHO@USER?$AA@
_DATA	SEGMENT
??_C@_04FMHO@USER?$AA@ DB 'USER', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05JKMB@USING?$AA@
_DATA	SEGMENT
??_C@_05JKMB@USING?$AA@ DB 'USING', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MOEL@VALUE?$AA@
_DATA	SEGMENT
??_C@_05MOEL@VALUE?$AA@ DB 'VALUE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06KGMH@VALUES?$AA@
_DATA	SEGMENT
??_C@_06KGMH@VALUES?$AA@ DB 'VALUES', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03KNCG@VAR?$AA@
_DATA	SEGMENT
??_C@_03KNCG@VAR?$AA@ DB 'VAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09OLDK@VARBINARY?$AA@
_DATA	SEGMENT
??_C@_09OLDK@VARBINARY?$AA@ DB 'VARBINARY', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NGFA@VARCHAR?$AA@
_DATA	SEGMENT
??_C@_07NGFA@VARCHAR?$AA@ DB 'VARCHAR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OIBN@VARP?$AA@
_DATA	SEGMENT
??_C@_04OIBN@VARP?$AA@ DB 'VARP', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MMOJ@VARYING?$AA@
_DATA	SEGMENT
??_C@_07MMOJ@VARYING?$AA@ DB 'VARYING', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04CGLB@VIEW?$AA@
_DATA	SEGMENT
??_C@_04CGLB@VIEW?$AA@ DB 'VIEW', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06IEGE@VOLUME?$AA@
_DATA	SEGMENT
??_C@_06IEGE@VOLUME?$AA@ DB 'VOLUME', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07KCD@WAITFOR?$AA@
_DATA	SEGMENT
??_C@_07KCD@WAITFOR?$AA@ DB 'WAITFOR', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GKK@WHEN?$AA@
_DATA	SEGMENT
??_C@_04GKK@WHEN?$AA@ DB 'WHEN', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05MCFK@WHERE?$AA@
_DATA	SEGMENT
??_C@_05MCFK@WHERE?$AA@ DB 'WHERE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05LCLH@WHILE?$AA@
_DATA	SEGMENT
??_C@_05LCLH@WHILE?$AA@ DB 'WHILE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04NHMN@WITH?$AA@
_DATA	SEGMENT
??_C@_04NHMN@WITH?$AA@ DB 'WITH', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LDPM@WORK?$AA@
_DATA	SEGMENT
??_C@_04LDPM@WORK?$AA@ DB 'WORK', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FIFP@WRITE?$AA@
_DATA	SEGMENT
??_C@_05FIFP@WRITE?$AA@ DB 'WRITE', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IKOB@WRITETEXT?$AA@
_DATA	SEGMENT
??_C@_09IKOB@WRITETEXT?$AA@ DB 'WRITETEXT', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_03BDEP@XOR?$AA@
_DATA	SEGMENT
??_C@_03BDEP@XOR?$AA@ DB 'XOR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HEBB@YEAR?$AA@
_DATA	SEGMENT
??_C@_04HEBB@YEAR?$AA@ DB 'YEAR', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NAPJ@YESNO?$AA@
_DATA	SEGMENT
??_C@_05NAPJ@YESNO?$AA@ DB 'YESNO', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_04HOL@ZONE?$AA@
_DATA	SEGMENT
??_C@_04HOL@ZONE?$AA@ DB 'ZONE', 00H			; `string'
_DATA	ENDS
PUBLIC	_fnBuildDropIndex@20
PUBLIC	??_C@_01FAJB@?$DL?$AA@				; `string'
PUBLIC	??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
EXTRN	_SysWriteLine@12:NEAR
EXTRN	__imp__sprintf:NEAR
;	COMDAT ??_C@_01FAJB@?$DL?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_01FAJB@?$DL?$AA@ DB ';', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@ DB 'DROP IN'
	DB	'DEX %s ON %s%s %s', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_lpTaskView$ = 8
_pchIndexName$ = 12
_pchOwner$ = 16
_pchTableName$ = 20
_f$ = 24
_szLine$ = -500
_fnBuildDropIndex@20 PROC NEAR

; 2330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 500				; 000001f4H

; 2331 :    zCHAR szLine[ 500 ];
; 2332 : 
; 2333 :    #if defined( SQLSERVER )
; 2334 :       zsprintf( szLine, "DROP INDEX %s%s.%s %s",
; 2335 :                 pchOwner, pchTableName, pchIndexName, LINE_TERMINATOR );
; 2336 :    #else
; 2337 :       zsprintf( szLine, "DROP INDEX %s ON %s%s %s",
; 2338 :                 pchIndexName, pchOwner, pchTableName, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchOwner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchIndexName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BJ@FNLO@DROP?5INDEX?5?$CFs?5ON?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 2339 :    #endif
; 2340 : 
; 2341 :    if ( fnWriteLine( lpTaskView, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L30994

; 2342 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L30990
$L30994:

; 2343 : 
; 2344 :    return( 0 );

	xor	ax, ax
$L30990:

; 2345 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnBuildDropIndex@20 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildColumn@12
PUBLIC	??_C@_08IAKB@TZTEDBLO?$AA@			; `string'
PUBLIC	??_C@_04EALC@DBMS?$AA@				; `string'
PUBLIC	??_C@_0P@BCDD@TE_DBMS_Source?$AA@		; `string'
PUBLIC	??_C@_08DKGC@DBH_Data?$AA@			; `string'
PUBLIC	??_C@_01PCJP@Y?$AA@				; `string'
PUBLIC	??_C@_0BC@KJKI@TimestampAsString?$AA@		; `string'
PUBLIC	??_C@_04JENC@ODBC?$AA@				; `string'
PUBLIC	??_C@_0BE@GNCH@MaxColumnNameLength?$AA@		; `string'
PUBLIC	??_C@_04EFNI@Name?$AA@				; `string'
PUBLIC	??_C@_0BA@PJGE@TE_FieldDataRel?$AA@		; `string'
PUBLIC	??_C@_08FNON@DataType?$AA@			; `string'
PUBLIC	??_C@_04DOMO@?$CF?9?$CKs?$AA@			; `string'
PUBLIC	??_C@_06CAAP@Length?$AA@			; `string'
PUBLIC	??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@	; `string'
PUBLIC	??_C@_09CPOG@?5longblob?$AA@			; `string'
PUBLIC	??_C@_09IJHK@?5datetime?$AA@			; `string'
PUBLIC	??_C@_04OGMO@?5int?$AA@				; `string'
PUBLIC	??_C@_07CLFL@?5double?$AA@			; `string'
PUBLIC	??_C@_09DKHG@?5longtext?$AA@			; `string'
PUBLIC	??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@		; `string'
PUBLIC	??_C@_0BG@NJGJ@?5INTEGER?5PRIMARY?5KEY?5?$AA@	; `string'
PUBLIC	??_C@_08KJLB@?5INTEGER?$AA@			; `string'
PUBLIC	??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@	; `string'
PUBLIC	??_C@_0L@NCMM@TE_TablRec?$AA@			; `string'
PUBLIC	??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@ ; `string'
PUBLIC	??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@		; `string'
PUBLIC	??_C@_09LPMC@SQL_NULLS?$AA@			; `string'
PUBLIC	??_C@_08IDDA@NOT?5NULL?$AA@			; `string'
PUBLIC	??_C@_08FGIB@NULL?5?5?5?5?$AA@			; `string'
EXTRN	_GetIntegerFromAttribute@16:NEAR
EXTRN	_SysMessageBox@16:NEAR
EXTRN	_SetOI_FromBlob@28:NEAR
EXTRN	_CompareAttributeToString@16:NEAR
EXTRN	_GetAddrForAttribute@16:NEAR
EXTRN	_GetViewByName@16:NEAR
EXTRN	_DropView@4:NEAR
EXTRN	_strcat:NEAR
EXTRN	_strlen:NEAR
EXTRN	_SetCursorFirstEntityByAttr@28:NEAR
EXTRN	_GetStringFromAttribute@16:NEAR
;	COMDAT ??_C@_08IAKB@TZTEDBLO?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_08IAKB@TZTEDBLO?$AA@ DB 'TZTEDBLO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EALC@DBMS?$AA@
_DATA	SEGMENT
??_C@_04EALC@DBMS?$AA@ DB 'DBMS', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@BCDD@TE_DBMS_Source?$AA@
_DATA	SEGMENT
??_C@_0P@BCDD@TE_DBMS_Source?$AA@ DB 'TE_DBMS_Source', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08DKGC@DBH_Data?$AA@
_DATA	SEGMENT
??_C@_08DKGC@DBH_Data?$AA@ DB 'DBH_Data', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PCJP@Y?$AA@
_DATA	SEGMENT
??_C@_01PCJP@Y?$AA@ DB 'Y', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KJKI@TimestampAsString?$AA@
_DATA	SEGMENT
??_C@_0BC@KJKI@TimestampAsString?$AA@ DB 'TimestampAsString', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04JENC@ODBC?$AA@
_DATA	SEGMENT
??_C@_04JENC@ODBC?$AA@ DB 'ODBC', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@GNCH@MaxColumnNameLength?$AA@
_DATA	SEGMENT
??_C@_0BE@GNCH@MaxColumnNameLength?$AA@ DB 'MaxColumnNameLength', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04EFNI@Name?$AA@
_DATA	SEGMENT
??_C@_04EFNI@Name?$AA@ DB 'Name', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PJGE@TE_FieldDataRel?$AA@
_DATA	SEGMENT
??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ DB 'TE_FieldDataRel', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FNON@DataType?$AA@
_DATA	SEGMENT
??_C@_08FNON@DataType?$AA@ DB 'DataType', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DOMO@?$CF?9?$CKs?$AA@
_DATA	SEGMENT
??_C@_04DOMO@?$CF?9?$CKs?$AA@ DB '%-*s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06CAAP@Length?$AA@
_DATA	SEGMENT
??_C@_06CAAP@Length?$AA@ DB 'Length', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@ DB ' varchar( %ld )', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CPOG@?5longblob?$AA@
_DATA	SEGMENT
??_C@_09CPOG@?5longblob?$AA@ DB ' longblob', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09IJHK@?5datetime?$AA@
_DATA	SEGMENT
??_C@_09IJHK@?5datetime?$AA@ DB ' datetime', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OGMO@?5int?$AA@
_DATA	SEGMENT
??_C@_04OGMO@?5int?$AA@ DB ' int', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CLFL@?5double?$AA@
_DATA	SEGMENT
??_C@_07CLFL@?5double?$AA@ DB ' double', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DKHG@?5longtext?$AA@
_DATA	SEGMENT
??_C@_09DKHG@?5longtext?$AA@ DB ' longtext', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@
_DATA	SEGMENT
??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ DB 'DataOrRelfieldOrSet', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@NJGJ@?5INTEGER?5PRIMARY?5KEY?5?$AA@
_DATA	SEGMENT
??_C@_0BG@NJGJ@?5INTEGER?5PRIMARY?5KEY?5?$AA@ DB ' INTEGER PRIMARY KEY ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08KJLB@?5INTEGER?$AA@
_DATA	SEGMENT
??_C@_08KJLB@?5INTEGER?$AA@ DB ' INTEGER', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@
_DATA	SEGMENT
??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@ DB ' varchar( 30 )', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@NCMM@TE_TablRec?$AA@
_DATA	SEGMENT
??_C@_0L@NCMM@TE_TablRec?$AA@ DB 'TE_TablRec', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@
_DATA	SEGMENT
??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@ DB 'Invalid Dat'
	DB	'aType ''%s'' for attribute %s.%s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@
_DATA	SEGMENT
??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@ DB 'SQL DDL Generator', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LPMC@SQL_NULLS?$AA@
_DATA	SEGMENT
??_C@_09LPMC@SQL_NULLS?$AA@ DB 'SQL_NULLS', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08IDDA@NOT?5NULL?$AA@
_DATA	SEGMENT
??_C@_08IDDA@NOT?5NULL?$AA@ DB 'NOT NULL', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08FGIB@NULL?5?5?5?5?$AA@
_DATA	SEGMENT
??_C@_08FGIB@NULL?5?5?5?5?$AA@ DB 'NULL    ', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_pchLine$ = 16
_szColName$ = -268
_pchDataType$ = -328
_pchKeyType$ = -4
_pchEnd$ = -324
_pch$ = -8
_nLth$ = -12
_nMaxColumnNameLth$ = -272
_szDBH_DataObjectName$ = -320
_vDBH_Data$ = -284
_vTZTEDBLO$ = -276
_vTZDBHODO$ = -280
_bTimestampAsString$ = -332
_l$31021 = -336
_szTableName$31065 = -704
_szMsg$31066 = -636
_fnBuildColumn@12 PROC NEAR

; 2349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 708				; 000002c4H

; 2350 :    zCHAR    szColName[ MAX_NAME_LTH + 1 ];
; 2351 :    zPCHAR   pchDataType;
; 2352 :    zPCHAR   pchKeyType;
; 2353 :    zPCHAR   pchEnd, pch;
; 2354 :    zLONG    nLth;
; 2355 :    zUSHORT  nMaxColumnNameLth = MAX_COLUMNNAME_LTH;

	mov	WORD PTR _nMaxColumnNameLth$[ebp], 64	; 00000040H

; 2356 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2357 :    zVIEW    vDBH_Data;
; 2358 :    zVIEW    vTZTEDBLO = 0;

	mov	DWORD PTR _vTZTEDBLO$[ebp], 0

; 2359 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 2360 :    zBOOL    bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0

; 2361 : 
; 2362 :    // If it exists get the object that defines the dbhandler type.
; 2363 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 2364 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31016

; 2365 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 2366 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
$L31016:

; 2367 : 
; 2368 :    // Try to get the OI that contains DBH-specific data.
; 2369 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 2370 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 2371 : 
; 2372 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2373 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2374 : 
; 2375 :    // Try to get the ODBC definition.
; 2376 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 2377 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 2378 : 
; 2379 :    // Check to see if there is DBH data set in the TE.
; 2380 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31020

; 2382 :       zLONG l;
; 2383 : 
; 2384 :       bTimestampAsString = ( CompareAttributeToString( vDBH_Data, "ODBC",
; 2385 :                                                        "TimestampAsString",
; 2386 :                                                        "Y" ) == 0 );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BC@KJKI@TimestampAsString?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _bTimestampAsString$[ebp], al

; 2387 : 
; 2388 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 2389 :                                     "MaxColumnNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BE@GNCH@MaxColumnNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$31021[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31025

; 2391 :          nMaxColumnNameLth = (zSHORT) l;

	mov	cx, WORD PTR _l$31021[ebp]
	mov	WORD PTR _nMaxColumnNameLth$[ebp], cx
$L31025:

; 2394 :    else

	jmp	SHORT $L31030
$L31020:

; 2395 :    // Check to see if there is DBH data set in the DB List object.
; 2396 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31029

; 2398 :       bTimestampAsString = ( CompareAttributeToString( vTZDBHODO, "ODBC",
; 2399 :                                                        "TimestampAsString",
; 2400 :                                                        "Y" ) == 0 );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BC@KJKI@TimestampAsString?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	neg	eax
	sbb	eax, eax
	inc	eax
	mov	BYTE PTR _bTimestampAsString$[ebp], al

; 2402 :    else

	jmp	SHORT $L31030
$L31029:

; 2404 :       // If we get here then no info was set for this DBH so use defaults.
; 2405 :       bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0
$L31030:

; 2407 : 
; 2408 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31031

; 2409 :       DropView( vTZDBHODO );

	mov	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_DropView@4
$L31031:

; 2410 : 
; 2411 : #endif
; 2412 : 
; 2413 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31032

; 2414 :       DropView( vDBH_Data );

	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_DropView@4
$L31032:

; 2415 : 
; 2416 :    GetStringFromAttribute( szColName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szColName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 2417 :    GetAddrForAttribute( &pchDataType, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDataType$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 2418 :    RemoveBrackets( szColName );

	lea	ecx, DWORD PTR _szColName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 2419 : 
; 2420 :    pchEnd = pchLine + zstrlen( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 2421 :    zsprintf( pchEnd, "%-*s", nMaxColumnNameLth, szColName );

	lea	edx, DWORD PTR _szColName$[ebp]
	push	edx
	mov	eax, DWORD PTR _nMaxColumnNameLth$[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	push	OFFSET FLAT:??_C@_04DOMO@?$CF?9?$CKs?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 2422 :    pchEnd = pchEnd + zstrlen( pchEnd );

	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 2423 : 
; 2424 : #if defined( ACCESS )
; 2425 : 
; 2426 :    switch ( pchDataType[ 0 ] )
; 2427 :    {
; 2428 :       case zTYPE_STRING:
; 2429 :       case zTYPE_FIXEDCHAR:
; 2430 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2431 :                                   "Length" );
; 2432 :          zsprintf( pchEnd, " TEXT( %ld )", nLth );
; 2433 : 
; 2434 :          break;
; 2435 : 
; 2436 :       case zTYPE_BLOB:
; 2437 :          zsprintf( pchEnd, " LONGBINARY" );
; 2438 :          break;
; 2439 : 
; 2440 :       case zTYPE_INTEGER:
; 2441 :          zsprintf( pchEnd, " INTEGER" );
; 2442 :          break;
; 2443 : 
; 2444 :       case zTYPE_DECIMAL:
; 2445 :          zsprintf( pchEnd, " DOUBLE" );
; 2446 :          break;
; 2447 : 
; 2448 :       case zTYPE_DATETIME:
; 2449 :       case zTYPE_TIME:
; 2450 :          if ( bTimestampAsString )
; 2451 :             zsprintf( pchEnd, " TEXT( 25 )" );
; 2452 :          else
; 2453 :          {
; 2454 :             switch ( pchDataType[ 0 ] )
; 2455 :             {
; 2456 :                case zTYPE_DATETIME:
; 2457 :                   zsprintf( pchEnd, " DATETIME" );
; 2458 :                   break;
; 2459 : 
; 2460 :                case zTYPE_TIME:
; 2461 :                   zsprintf( pchEnd, " TIME" );
; 2462 :                   break;
; 2463 :             }
; 2464 :          }
; 2465 : 
; 2466 :          break;
; 2467 : 
; 2468 :       case zTYPE_DATE:
; 2469 :          zsprintf( pchEnd, " DATE" );
; 2470 :          break;
; 2471 : 
; 2472 :       // ===
; 2473 :       // === Non-standard types follow here.
; 2474 :       // ===
; 2475 : 
; 2476 :       // Long text fields.
; 2477 :       case 'V':
; 2478 :          zsprintf( pchEnd, " MEMO" );
; 2479 :          break;
; 2480 : 
; 2481 :       // TimeStampEx
; 2482 :       case 'X':
; 2483 :          zsprintf( pchEnd, " TEXT( 30 )" );
; 2484 :          break;
; 2485 : 
; 2486 :       default:
; 2487 :       {
; 2488 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2489 :          zCHAR szMsg[ 300 ];
; 2490 : 
; 2491 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2492 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2493 :                    pchDataType, szTableName, szColName );
; 2494 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2495 :          return( -1 );
; 2496 :       }
; 2497 : 
; 2498 :    } // switch ( pchDataType[ 0 ] )...
; 2499 : 
; 2500 : #elif defined( DB2 )
; 2501 : 
; 2502 :    switch ( pchDataType[ 0 ] )
; 2503 :    {
; 2504 :       case zTYPE_STRING:
; 2505 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2506 :                                   "Length" );
; 2507 :          zsprintf( pchEnd, " VARCHAR( %ld )", nLth );
; 2508 : 
; 2509 :          break;
; 2510 : 
; 2511 :       case zTYPE_FIXEDCHAR:
; 2512 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2513 :                                   "Length" );
; 2514 :          zsprintf( pchEnd, " CHAR( %ld )", nLth );
; 2515 : 
; 2516 :          break;
; 2517 : 
; 2518 :       case zTYPE_BLOB:
; 2519 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2520 :                                   "Length" );
; 2521 :          zsprintf( pchEnd, " BLOB( %ld )", nLth );
; 2522 :          break;
; 2523 : 
; 2524 :       case zTYPE_DATETIME:
; 2525 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2526 :          break;
; 2527 : 
; 2528 :       case zTYPE_INTEGER:
; 2529 :          zsprintf( pchEnd, " INTEGER" );
; 2530 :          break;
; 2531 : 
; 2532 :       case zTYPE_DECIMAL:
; 2533 :       {
; 2534 :          zLONG nScale;
; 2535 : 
; 2536 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2537 :                                   "Length" );
; 2538 :          if ( nLth > 31 )
; 2539 :             nLth = 31;
; 2540 : 
; 2541 :          GetIntegerFromAttribute( &nScale, vDTE, "TE_FieldDataRel",
; 2542 :                                   "SQL_SCALE" );
; 2543 : 
; 2544 :          zsprintf( pchEnd, " DECIMAL( %ld,%ld )", nLth, nScale );
; 2545 :          break;
; 2546 :       }
; 2547 : 
; 2548 :       case zTYPE_DATE:
; 2549 :          zsprintf( pchEnd, " DATE" );
; 2550 :          break;
; 2551 : 
; 2552 :       case zTYPE_TIME:
; 2553 :          zsprintf( pchEnd, " TIME" );
; 2554 :          break;
; 2555 : 
; 2556 :       // ===
; 2557 :       // === Non-standard types follow here.
; 2558 :       // ===
; 2559 : 
; 2560 :       case 'V':
; 2561 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2562 :                                   "Length" );
; 2563 :          zsprintf( pchEnd, " CLOB( %ld )", nLth );
; 2564 :          break;
; 2565 : 
; 2566 :       // TimeStampEx
; 2567 :       case 'X':
; 2568 :          zsprintf( pchEnd, " VARCHAR( 30 )" );
; 2569 :          break;
; 2570 : 
; 2571 :       default:
; 2572 :       {
; 2573 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2574 :          zCHAR szMsg[ 300 ];
; 2575 : 
; 2576 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2577 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2578 :                    pchDataType, szTableName, szColName );
; 2579 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2580 :          return( -1 );
; 2581 :       }
; 2582 : 
; 2583 :    } // switch ( pchDataType[ 0 ] )...
; 2584 : 
; 2585 : #elif defined( MYSQL )
; 2586 : 
; 2587 :    switch ( pchDataType[ 0 ] )
; 2588 :    {

	mov	edx, DWORD PTR _pchDataType$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR -708+[ebp], eax
	mov	ecx, DWORD PTR -708+[ebp]
	sub	ecx, 65					; 00000041H
	mov	DWORD PTR -708+[ebp], ecx
	cmp	DWORD PTR -708+[ebp], 23		; 00000017H
	ja	$L31064
	mov	eax, DWORD PTR -708+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L32344[eax]
	jmp	DWORD PTR $L32345[edx*4]
$L31041:

; 2589 :       case zTYPE_STRING:
; 2590 :       case zTYPE_FIXEDCHAR:
; 2591 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2592 :                                   "Length" );

	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 2593 :          zsprintf( pchEnd, " varchar( %ld )", nLth );

	mov	eax, DWORD PTR _nLth$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0BA@FENM@?5varchar?$CI?5?$CFld?5?$CJ?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 2594 : 
; 2595 :          break;

	jmp	$L31038
$L31044:

; 2596 : 
; 2597 :       case zTYPE_BLOB:
; 2598 :          zsprintf( pchEnd, " longblob" );

	push	OFFSET FLAT:??_C@_09CPOG@?5longblob?$AA@ ; `string'
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2599 :          break;

	jmp	$L31038
$L31046:

; 2600 : 
; 2601 :       case zTYPE_DATETIME:
; 2602 :          zsprintf( pchEnd, " datetime" );

	push	OFFSET FLAT:??_C@_09IJHK@?5datetime?$AA@ ; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2603 :          break;

	jmp	$L31038
$L31048:

; 2604 : 
; 2605 :       case zTYPE_INTEGER:
; 2606 :          zsprintf( pchEnd, " int" );

	push	OFFSET FLAT:??_C@_04OGMO@?5int?$AA@	; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2607 :          break;

	jmp	$L31038
$L31050:

; 2608 : 
; 2609 :       case zTYPE_DECIMAL:
; 2610 :          zsprintf( pchEnd, " double" );

	push	OFFSET FLAT:??_C@_07CLFL@?5double?$AA@	; `string'
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2611 :          break;

	jmp	$L31038
$L31052:

; 2612 : 
; 2613 :       case zTYPE_DATE:
; 2614 :          zsprintf( pchEnd, " datetime" );

	push	OFFSET FLAT:??_C@_09IJHK@?5datetime?$AA@ ; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2615 :          break;

	jmp	$L31038
$L31053:

; 2616 : 
; 2617 :       case zTYPE_TIME:
; 2618 :          zsprintf( pchEnd, " datetime" );

	push	OFFSET FLAT:??_C@_09IJHK@?5datetime?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2619 :          break;

	jmp	$L31038
$L31054:

; 2620 : 
; 2621 :       // ===
; 2622 :       // === Non-standard types follow here.
; 2623 :       // ===
; 2624 : 
; 2625 :       case 'V':
; 2626 :          zsprintf( pchEnd, " longtext" );

	push	OFFSET FLAT:??_C@_09DKHG@?5longtext?$AA@ ; `string'
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2627 :          break;

	jmp	$L31038
$L31056:

; 2628 : 
; 2629 :       case 'A':
; 2630 :          GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel", "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 2631 :          if ( pchKeyType[ 0 ] == 'D' )

	mov	edx, DWORD PTR _pchKeyType$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 68					; 00000044H
	jne	SHORT $L31058

; 2633 :             // The key type is 'D' for data which means it's the main key.
; 2634 :             #if defined( SQLITE )
; 2635 : 	       zsprintf( pchEnd, " INTEGER PRIMARY KEY " );

	push	OFFSET FLAT:??_C@_0BG@NJGJ@?5INTEGER?5PRIMARY?5KEY?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2640 : 	 else

	jmp	SHORT $L31060
$L31058:

; 2642 :             // This must be a FK so don't declare it as SERIAL/KEY.
; 2643 :             zsprintf( pchEnd, " INTEGER" );

	push	OFFSET FLAT:??_C@_08KJLB@?5INTEGER?$AA@	; `string'
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 8
$L31060:

; 2645 : 
; 2646 :          break;

	jmp	SHORT $L31038
$L31062:

; 2647 : 
; 2648 :       // TimeStampEx
; 2649 :       case 'X':
; 2650 :          zsprintf( pchEnd, " varchar( 30 )" );

	push	OFFSET FLAT:??_C@_0P@OLJF@?5varchar?$CI?530?5?$CJ?$AA@ ; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 8

; 2651 :          break;

	jmp	SHORT $L31038
$L31064:

; 2655 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2656 :          zCHAR szMsg[ 300 ];
; 2657 : 
; 2658 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$31065[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2659 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2660 :                    pchDataType, szTableName, szColName );

	lea	eax, DWORD PTR _szColName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$31065[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchDataType$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CK@EKKO@Invalid?5DataType?5?8?$CFs?8?5for?5attrib@ ; `string'
	lea	eax, DWORD PTR _szMsg$31066[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 2661 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$31066[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BC@KEK@SQL?5DDL?5Generator?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysMessageBox@16

; 2662 :          return( -1 );

	or	ax, -1
	jmp	$L31002
$L31038:

; 2666 : 
; 2667 : #elif defined( SQLBASE ) || defined( ODBC )
; 2668 : 
; 2669 :    switch ( pchDataType[ 0 ] )
; 2670 :    {
; 2671 :       case zTYPE_STRING:
; 2672 :       case zTYPE_FIXEDCHAR:
; 2673 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2674 :                                   "Length" );
; 2675 :          zsprintf( pchEnd, " CHAR( %ld )", nLth );
; 2676 : 
; 2677 :          break;
; 2678 : 
; 2679 :       case zTYPE_BLOB:
; 2680 :          zsprintf( pchEnd, " LONG VARCHAR" );
; 2681 :          break;
; 2682 : 
; 2683 :       case zTYPE_INTEGER:
; 2684 :          zsprintf( pchEnd, " INTEGER" );
; 2685 :          break;
; 2686 : 
; 2687 :       case zTYPE_DECIMAL:
; 2688 :       {
; 2689 :          zLONG nScale;
; 2690 : 
; 2691 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2692 :                                   "Length" );
; 2693 :          GetIntegerFromAttribute( &nScale, vDTE, "TE_FieldDataRel",
; 2694 :                                   "SQL_SCALE" );
; 2695 : 
; 2696 :          zsprintf( pchEnd, " DECIMAL( %ld,%ld )", nLth, nScale );
; 2697 :          break;
; 2698 :       }
; 2699 : 
; 2700 :    #ifdef ODBC
; 2701 : 
; 2702 :       case zTYPE_DATETIME:
; 2703 :       case zTYPE_TIME:
; 2704 :          if ( bTimestampAsString )
; 2705 :             zsprintf( pchEnd, " TEXT( 25 )" );
; 2706 :          else
; 2707 :          {
; 2708 :             switch ( pchDataType[ 0 ] )
; 2709 :             {
; 2710 :                case zTYPE_DATETIME:
; 2711 :                   zsprintf( pchEnd, " DATETIME" );
; 2712 :                   break;
; 2713 : 
; 2714 :                case zTYPE_TIME:
; 2715 :                   zsprintf( pchEnd, " TIME" );
; 2716 :                   break;
; 2717 :             }
; 2718 :          }
; 2719 : 
; 2720 :          break;
; 2721 : 
; 2722 :       case zTYPE_DATE:
; 2723 :          zsprintf( pchEnd, " DATE" );
; 2724 :          break;
; 2725 : 
; 2726 :    #else
; 2727 :       case zTYPE_DATETIME:
; 2728 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2729 :          break;
; 2730 : 
; 2731 :       case zTYPE_DATE:
; 2732 :          zsprintf( pchEnd, " DATE" );
; 2733 :          break;
; 2734 : 
; 2735 :       case zTYPE_TIME:
; 2736 :          zsprintf( pchEnd, " TIME" );
; 2737 :          break;
; 2738 :    #endif
; 2739 : 
; 2740 :       // ===
; 2741 :       // === Non-standard types follow here.
; 2742 :       // ===
; 2743 : 
; 2744 :       case 'V':
; 2745 :          zsprintf( pchEnd, " LONG VARCHAR" );
; 2746 :          break;
; 2747 : 
; 2748 :       // TimeStampEx
; 2749 :       case 'X':
; 2750 :          zsprintf( pchEnd, " CHAR( 30 )" );
; 2751 :          break;
; 2752 : 
; 2753 :       default:
; 2754 :       {
; 2755 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2756 :          zCHAR szMsg[ 300 ];
; 2757 : 
; 2758 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2759 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2760 :                    pchDataType, szTableName, szColName );
; 2761 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2762 :          return( -1 );
; 2763 :       }
; 2764 : 
; 2765 :    } // switch ( pchDataType[ 0 ] )...
; 2766 : 
; 2767 : #elif defined( POSTGRESQL )
; 2768 : 
; 2769 :    switch ( pchDataType[ 0 ] )
; 2770 :    {
; 2771 :       case zTYPE_STRING:
; 2772 :       case zTYPE_FIXEDCHAR:
; 2773 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2774 :                                   "Length" );
; 2775 :          zsprintf( pchEnd, " VARCHAR( %ld )", nLth );
; 2776 : 
; 2777 :          break;
; 2778 : 
; 2779 :       case zTYPE_BLOB:
; 2780 :          zsprintf( pchEnd, " bytea" );
; 2781 :          //zsprintf( pchEnd, " text" );
; 2782 :          break;
; 2783 : 
; 2784 :       case zTYPE_DATETIME:
; 2785 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2786 :          break;
; 2787 : 
; 2788 :       case zTYPE_INTEGER:
; 2789 :          zsprintf( pchEnd, " INTEGER" );
; 2790 :          break;
; 2791 : 
; 2792 :       case zTYPE_DECIMAL:
; 2793 :          zsprintf( pchEnd, " FLOAT4" );
; 2794 :          break;
; 2795 : 
; 2796 :       case zTYPE_DATE:
; 2797 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2798 :          break;
; 2799 : 
; 2800 :       case zTYPE_TIME:
; 2801 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2802 :          break;
; 2803 : 
; 2804 :       // ===
; 2805 :       // === Non-standard types follow here.
; 2806 :       // ===
; 2807 : 
; 2808 :       case 'V':
; 2809 :          zsprintf( pchEnd, " TEXT" );
; 2810 :          break;
; 2811 : 
; 2812 :       // TimeStampEx
; 2813 :       case 'X':
; 2814 :          zsprintf( pchEnd, " VARCHAR( 30 )" );
; 2815 :          break;
; 2816 : 
; 2817 :       default:
; 2818 :       {
; 2819 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2820 :          zCHAR szMsg[ 300 ];
; 2821 : 
; 2822 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2823 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2824 :                    pchDataType, szTableName, szColName );
; 2825 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );
; 2826 :          return( -1 );
; 2827 :       }
; 2828 : 
; 2829 :    } // switch ( pchDataType[ 0 ] )...
; 2830 : 
; 2831 : #elif defined( SQLSERVER )
; 2832 : 
; 2833 :    switch ( pchDataType[ 0 ] )
; 2834 :    {
; 2835 :       case zTYPE_STRING:
; 2836 :       case zTYPE_FIXEDCHAR:
; 2837 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2838 :                                   "Length" );
; 2839 :          zsprintf( pchEnd, " varchar( %ld )", nLth );
; 2840 : 
; 2841 :          break;
; 2842 : 
; 2843 :       case zTYPE_BLOB:
; 2844 :          zsprintf( pchEnd, " varbinary(max)" );
; 2845 :          break;
; 2846 : 
; 2847 :       case zTYPE_DATETIME:
; 2848 :          zsprintf( pchEnd, " datetime" );
; 2849 :          break;
; 2850 : 
; 2851 :       case zTYPE_INTEGER:
; 2852 :          zsprintf( pchEnd, " int" );
; 2853 :          break;
; 2854 : 
; 2855 :       case zTYPE_DECIMAL:
; 2856 :          zsprintf( pchEnd, " float" );
; 2857 :          break;
; 2858 : 
; 2859 :       case zTYPE_DATE:
; 2860 :          zsprintf( pchEnd, " datetime" );
; 2861 :          break;
; 2862 : 
; 2863 :       case zTYPE_TIME:
; 2864 :          zsprintf( pchEnd, " datetime" );
; 2865 :          break;
; 2866 : 
; 2867 :       // ===
; 2868 :       // === Non-standard types follow here.
; 2869 :       // ===
; 2870 : 
; 2871 :       case 'V':
; 2872 :          zsprintf( pchEnd, " nvarchar(max)" );
; 2873 :          break;
; 2874 : 
; 2875 :       // TimeStampEx
; 2876 :       case 'X':
; 2877 :          zsprintf( pchEnd, " varchar( 30 )" );
; 2878 :          break;
; 2879 : 
; 2880 :       default:
; 2881 :       {
; 2882 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2883 :          zCHAR szMsg[ 300 ];
; 2884 : 
; 2885 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2886 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2887 :                    pchDataType, szTableName, szColName );
; 2888 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );
; 2889 :          return( -1 );
; 2890 :       }
; 2891 : 
; 2892 :    } // switch ( pchDataType[ 0 ] )...
; 2893 : #endif
; 2894 : 
; 2895 :    // Space out the data type string.
; 2896 :    for ( pch = pchEnd + zstrlen( pchEnd );
; 2897 :          pch < pchEnd + MAX_DATATYPE_LTH;
; 2898 :          pch++ )

	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $L31070
$L31071:
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$L31070:
	mov	eax, DWORD PTR _pchEnd$[ebp]
	add	eax, 20					; 00000014H
	cmp	DWORD PTR _pch$[ebp], eax
	jae	SHORT $L31072

; 2900 :       *pch = ' ';

	mov	ecx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [ecx], 32			; 00000020H

; 2901 :    }

	jmp	SHORT $L31071
$L31072:

; 2902 : 
; 2903 :    *pch = 0;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 0

; 2904 :    pchEnd = pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 2905 : 
; 2906 :    // Check to see if column can be NULL.
; 2907 :    if ( CompareAttributeToString( vDTE, "TE_FieldDataRel",
; 2908 :                                   "SQL_NULLS", "Y" ) == 0  )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_09LPMC@SQL_NULLS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31073

; 2910 :       // KJS 02/16/17 - Do I want to check if this is POSTGRES and the system generated key and if so set to 'PRIMARY KEY'??????
; 2911 : 	  #if defined( POSTGRESQL )
; 2912 :       if ( SetCursorFirstEntityByAttr( vDTE, "TE_FieldDataRelKey", "ZKey",
; 2913 :                                        vDTE, "TE_FieldDataRel", "ZKey", "TE_TablRec" ) >= 0 )
; 2914 : 	  {
; 2915 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )
; 2916 : 
; 2917 : 	  if ( CheckExistenceOfEntity( vDTE, "ER_EntIdentifier" ) >= zCURSOR_SET &&
; 2918 : 	       CompareAttributeToString( vDTE, "ER_EntIdentifier",
; 2919 : 										  "SystemMaintained", "Y" ) == 0  )
; 2920 : 			{
; 2921 : 			      zstrcat( pchEnd, "PRIMARY KEY" );
; 2922 : 
; 2923 : 			}
; 2924 : 			else
; 2925 : 			      zstrcat( pchEnd, NOT_NULL_FIELD );
; 2926 : 	  }
; 2927 : 	  else
; 2928 : 	        zstrcat( pchEnd, NOT_NULL_FIELD );
; 2929 : 
; 2930 : 	  
; 2931 : 	  #else
; 2932 :       zstrcat( pchEnd, NOT_NULL_FIELD );

	push	OFFSET FLAT:??_C@_08IDDA@NOT?5NULL?$AA@	; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2935 :    else

	jmp	SHORT $L31076
$L31073:

; 2936 :       zstrcat( pchEnd, NULL_FIELD );

	push	OFFSET FLAT:??_C@_08FGIB@NULL?5?5?5?5?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31076:

; 2937 : 
; 2938 :    pchEnd = pchLine + zstrlen( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, eax
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 2939 : 
; 2940 :    return( 0 );

	xor	ax, ax
$L31002:

; 2941 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L32345:
	DD	$L31056
	DD	$L31044
	DD	$L31052
	DD	$L31041
	DD	$L31053
	DD	$L31048
	DD	$L31050
	DD	$L31046
	DD	$L31054
	DD	$L31062
	DD	$L31064
$L32344:
	DB	0
	DB	1
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	5
	DB	6
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	3
	DB	7
	DB	10					; 0000000aH
	DB	8
	DB	10					; 0000000aH
	DB	9
_fnBuildColumn@12 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildFK_Index@8
PUBLIC	??_C@_0N@HJOL@DefaultOwner?$AA@			; `string'
PUBLIC	??_C@_0P@CNMG@SQL_TableOwner?$AA@		; `string'
PUBLIC	??_C@_01PJCK@?4?$AA@				; `string'
PUBLIC	??_C@_0BD@KOPE@MaxTableNameLength?$AA@		; `string'
PUBLIC	??_C@_04DKMG@Desc?$AA@				; `string'
PUBLIC	??_C@_02BOOO@?$CK?1?$AA@			; `string'
PUBLIC	??_C@_02FCCF@?1?$CK?$AA@			; `string'
PUBLIC	??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ ; `string'
PUBLIC	??_C@_04BBDM@ZKey?$AA@				; `string'
PUBLIC	??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@		; `string'
PUBLIC	??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ ; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
PUBLIC	??_C@_01PAOO@B?$AA@				; `string'
PUBLIC	??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_01FCOA@?5?$AA@				; `string'
PUBLIC	??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ ; `string'
EXTRN	_strcpy:NEAR
EXTRN	_UfCompressName@32:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0N@HJOL@DefaultOwner?$AA@
_DATA	SEGMENT
??_C@_0N@HJOL@DefaultOwner?$AA@ DB 'DefaultOwner', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@CNMG@SQL_TableOwner?$AA@
_DATA	SEGMENT
??_C@_0P@CNMG@SQL_TableOwner?$AA@ DB 'SQL_TableOwner', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PJCK@?4?$AA@
_DATA	SEGMENT
??_C@_01PJCK@?4?$AA@ DB '.', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KOPE@MaxTableNameLength?$AA@
_DATA	SEGMENT
??_C@_0BD@KOPE@MaxTableNameLength?$AA@ DB 'MaxTableNameLength', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_04DKMG@Desc?$AA@
_DATA	SEGMENT
??_C@_04DKMG@Desc?$AA@ DB 'Desc', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02BOOO@?$CK?1?$AA@
_DATA	SEGMENT
??_C@_02BOOO@?$CK?1?$AA@ DB '*/', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02FCCF@?1?$CK?$AA@
_DATA	SEGMENT
??_C@_02FCCF@?1?$CK?$AA@ DB '/*', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@
_DATA	SEGMENT
??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ DB '%s Ind'
	DB	'ex for Relationship - ''%s'' %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BBDM@ZKey?$AA@
_DATA	SEGMENT
??_C@_04BBDM@ZKey?$AA@ DB 'ZKey', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT
??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@ DB '%s_%s_%ld0', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@
_DATA	SEGMENT
??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ DB 'B_AEIOUYBCDFGHJKLMNP'
	DB	'QRSTVWXZ', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PAOO@B?$AA@
_DATA	SEGMENT
??_C@_01PAOO@B?$AA@ DB 'B', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ DB 'CREATE INDEX %s%'
	DB	's %s', 00H					; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ DB '       '
	DB	'ON %s%s ( %s', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FCOA@?5?$AA@
_DATA	SEGMENT
??_C@_01FCOA@?5?$AA@ DB ' ', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ DB '%*s %s ) %s', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_f$ = 12
_szLine$ = -836
_pch$ = -72
_szKeyName$ = -332
_szOwner$ = -68
_szTableName$ = -952
_pchDefaultOwner$ = -884
_szWorkIdxName$ = -1472
_szDBH_DataObjectName$ = -880
_nMaxTableNameLth$ = -76
_lZKey$ = -956
_vDBH_Data$ = -844
_vTZTEDBLO$ = -336
_vTZDBHODO$ = -840
_l$31106 = -1476
_fnBuildFK_Index@8 PROC NEAR

; 2945 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1476				; 000005c4H

; 2946 :    zCHAR    szLine[ 500 ];
; 2947 :    zPCHAR   pch;
; 2948 :    zCHAR    szKeyName[ MAX_NAME_LTH + 1 ];
; 2949 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 2950 :    zCHAR    szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2951 :    zPCHAR   pchDefaultOwner;
; 2952 :    zCHAR    szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 2953 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2954 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 64	; 00000040H

; 2955 :    zLONG    lZKey;
; 2956 :    zVIEW    vDBH_Data;
; 2957 :    zVIEW    vTZTEDBLO;
; 2958 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 2959 : 
; 2960 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 2961 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 2962 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31099
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L31098
$L31099:

; 2963 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31098:

; 2964 : 
; 2965 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2966 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	jne	SHORT $L31101
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31101

; 2967 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L31101:

; 2968 : 
; 2969 :    if ( szOwner[ 0 ] )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	je	SHORT $L31102

; 2970 :       zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31102:

; 2971 : 
; 2972 :    // If it exists get the object that defines the dbhandler type.
; 2973 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_GetViewByName@16

; 2974 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31104

; 2975 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 2976 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
$L31104:

; 2977 : 
; 2978 :    // Try to get the OI that contains DBH-specific data.
; 2979 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 2980 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2981 : 
; 2982 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2983 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2984 : 
; 2985 :    // Try to get the ODBC definition.
; 2986 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 2987 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 2988 : 
; 2989 :    // Check to see if there is DBH data set in the TE.
; 2990 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31107

; 2992 :       zLONG l;
; 2993 : 
; 2994 :       // Check to see if there is an max length override.
; 2995 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 2996 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$31106[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31107

; 2998 :          nMaxTableNameLth = (zSHORT) l;

	mov	cx, WORD PTR _l$31106[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], cx
$L31107:

; 3001 : 
; 3002 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31110

; 3003 :       DropView( vTZDBHODO );

	mov	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_DropView@4
$L31110:

; 3004 : #endif
; 3005 : 
; 3006 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31111

; 3007 :       DropView( vDBH_Data );

	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_DropView@4
$L31111:

; 3008 : 
; 3009 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3010 :    RemoveBrackets( szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3011 : 
; 3012 :    // Generate a comment identifying the relationship.
; 3013 :    GetAddrForAttribute( &pch, vDTE, "TE_FieldDataRel", "Desc" );

	push	OFFSET FLAT:??_C@_04DKMG@Desc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3014 :    if ( pch && pch[ 0 ] )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $L31117
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $L31117

; 3016 :       zsprintf( szLine, "%s Index for Relationship - '%s' %s",
; 3017 :                 COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3018 : 
; 3019 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31117

; 3020 :          return( -1 );

	or	ax, -1
	jmp	$L31083
$L31117:

; 3022 : 
; 3023 :    GetIntegerFromAttribute( &lZKey, vDTE, "TE_FieldDataRel", "ZKey" );

	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lZKey$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 3024 :    GetStringFromAttribute( szKeyName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3025 :    RemoveBrackets( szKeyName );

	lea	edx, DWORD PTR _szKeyName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3026 : 
; 3027 :    // The base name for the index is a concatenation of the table and
; 3028 :    // key name.  To ensure that the index name is unique, we also use the
; 3029 :    // zkey value.
; 3030 :    // NOTE: Becaues of a bug in UfCompressName, we tack on a extra '0' to the
; 3031 :    // name so that the zkey does not get truncated.
; 3032 :    zsprintf( szWorkIdxName, "%s_%s_%ld0", szTableName, szKeyName, lZKey );

	mov	eax, DWORD PTR _lZKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkIdxName$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3033 : 
; 3034 :    // Make sure that the index name is a valid length.
; 3035 :    UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 3036 :                    "", "B", "", "B_AEIOUYBCDFGHJKLMNPQRSTVWXZ", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	cx, WORD PTR _nMaxTableNameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$[ebp]
	push	eax
	call	_UfCompressName@32

; 3037 : 
; 3038 :    zsprintf( szLine, "CREATE INDEX %s%s %s",
; 3039 :              szOwner, szWorkIdxName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3040 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31124

; 3041 :       return( -1 );

	or	ax, -1
	jmp	$L31083
$L31124:

; 3042 : 
; 3043 :    zsprintf( szLine, "       ON %s%s ( %s",
; 3044 :              szOwner, szTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3045 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31126

; 3046 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31083
$L31126:

; 3047 : 
; 3048 :    // Write Key-Name.
; 3049 :    zsprintf( szLine, "%*s %s ) %s",
; 3050 :              (zSHORT) COLUMN_INDENT, " ",
; 3051 :              szKeyName,
; 3052 :              LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 3053 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31130

; 3054 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31083
$L31130:

; 3055 : 
; 3056 :    // Write a blank line.
; 3057 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31131

; 3058 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31083
$L31131:

; 3059 : 
; 3060 :    return( 0 );

	xor	ax, ax
$L31083:

; 3061 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildFK_Index@8 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildIndexFromTablRecKey@12
PUBLIC	??_C@_09CNO@ER_Entity?$AA@			; `string'
PUBLIC	??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_09CEBI@IndexName?$AA@			; `string'
PUBLIC	??_C@_0O@LKEB@TE_TablRecKey?$AA@		; `string'
PUBLIC	??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@		; `string'
PUBLIC	??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@		; `string'
PUBLIC	??_C@_02DILL@?$CFs?$AA@				; `string'
PUBLIC	??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@	; `string'
EXTRN	_CheckExistenceOfEntity@8:NEAR
EXTRN	_SetCursorNextEntity@12:NEAR
EXTRN	_SetCursorFirstEntity@12:NEAR
;	COMDAT ??_C@_09CNO@ER_Entity?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_09CNO@ER_Entity?$AA@ DB 'ER_Entity', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ DB '%'
	DB	's Main key for Entity - %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CEBI@IndexName?$AA@
_DATA	SEGMENT
??_C@_09CEBI@IndexName?$AA@ DB 'IndexName', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@LKEB@TE_TablRecKey?$AA@
_DATA	SEGMENT
??_C@_0O@LKEB@TE_TablRecKey?$AA@ DB 'TE_TablRecKey', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@
_DATA	SEGMENT
??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ DB 'TE_FieldDataRelKey', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@
_DATA	SEGMENT
??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@ DB 'U%s_%s_%ld0', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_02DILL@?$CFs?$AA@
_DATA	SEGMENT
??_C@_02DILL@?$CFs?$AA@ DB '%s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ DB 'CREATE U'
	DB	'NIQUE INDEX %s%s %s', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@ DB '%*s %s, %s', 00H ; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_bUnique$ = 12
_f$ = 16
_nLoop$ = -332
_szLine$ = -836
_szOwner$ = -324
_pchDefaultOwner$ = -1140
_szDBH_DataObjectName$ = -880
_nMaxTableNameLth$ = -328
_vDBH_Data$ = -844
_vTZTEDBLO$ = -336
_vTZDBHODO$ = -840
_szTableName$ = -1136
_szName$ = -256
_szWorkIdxName$ = -1656
_l$31158 = -1660
_pch$31165 = -1664
_szEntityName$31171 = -1920
_lZKey$31172 = -1924
_fnBuildIndexFromTablRecKey@12 PROC NEAR

; 3065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1924				; 00000784H

; 3066 :    zSHORT   nLoop;
; 3067 :    zCHAR    szLine[ 500 ];
; 3068 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3069 :    zPCHAR   pchDefaultOwner;
; 3070 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 3071 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 64	; 00000040H

; 3072 :    zVIEW    vDBH_Data;
; 3073 :    zVIEW    vTZTEDBLO;
; 3074 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 3075 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 3076 :    zCHAR    szName[ MAX_NAME_LTH + 1 ];
; 3077 :    zCHAR    szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3078 : 
; 3079 : 
; 3080 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 3081 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3082 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31153
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L31152
$L31153:

; 3083 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31152:

; 3084 : 
; 3085 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3086 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	jne	SHORT $L31154
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31154

; 3087 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$L31154:

; 3088 : 
; 3089 :    if ( szOwner[ 0 ] )

	movsx	eax, BYTE PTR _szOwner$[ebp]
	test	eax, eax
	je	SHORT $L31155

; 3090 :       zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$L31155:

; 3091 : 
; 3092 :    // If it exists get the object that defines the dbhandler type.
; 3093 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_GetViewByName@16

; 3094 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31156

; 3095 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 3096 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
$L31156:

; 3097 : 
; 3098 :    // Try to get the OI that contains DBH-specific data.
; 3099 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 3100 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 3101 : 
; 3102 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3103 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 3104 : 
; 3105 :    // Try to get the ODBC definition.
; 3106 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 3107 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 3108 : 
; 3109 :    // Check to see if there is DBH data set in the TE.
; 3110 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31159

; 3112 :       zLONG l;
; 3113 : 
; 3114 :       // Check to see if there is an max length override.
; 3115 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 3116 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$31158[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31159

; 3118 :          nMaxTableNameLth = (zSHORT) l;

	mov	cx, WORD PTR _l$31158[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], cx
$L31159:

; 3121 : 
; 3122 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31161

; 3123 :       DropView( vTZDBHODO );

	mov	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_DropView@4
$L31161:

; 3124 : #endif
; 3125 : 
; 3126 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31162

; 3127 :       DropView( vDBH_Data );

	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_DropView@4
$L31162:

; 3128 : 
; 3129 :    // Write comment.
; 3130 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	jl	SHORT $L31167

; 3132 :       zPCHAR pch;
; 3133 : 
; 3134 :       GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pch$31165[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3135 :       zsprintf( szLine, "%s Main key for Entity - %s %s",
; 3136 :                 COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	edx, DWORD PTR _pch$31165[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BP@GKMP@?$CFs?5Main?5key?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3137 : 
; 3138 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31167

; 3139 :          return( -1 );

	or	ax, -1
	jmp	$L31139
$L31167:

; 3141 : 
; 3142 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3143 :    RemoveBrackets( szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3144 : 
; 3145 :    // If an IndexName value exists in TE_TablRecKey, use it.  Otherwise
; 3146 :    // us the Name value.
; 3147 :    GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "IndexName" );

	push	OFFSET FLAT:??_C@_09CEBI@IndexName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3148 :    if ( szName[ 0 ] == 0 )

	movsx	eax, BYTE PTR _szName$[ebp]
	test	eax, eax
	jne	$L31170

; 3150 :       zCHAR  szEntityName[ MAX_NAME_LTH + 1 ];
; 3151 :       zLONG  lZKey;
; 3152 : 
; 3153 :       GetStringFromAttribute( szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$31171[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3154 :       RemoveBrackets( szEntityName );

	lea	eax, DWORD PTR _szEntityName$31171[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3155 : 
; 3156 :       GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3157 :       RemoveBrackets( szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3158 : 
; 3159 :       GetIntegerFromAttribute( &lZKey, vDTE, "TE_FieldDataRelKey", "ZKey" );

	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lZKey$31172[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 3160 : 
; 3161 :       // The base name for the index is a concatenation of the table and
; 3162 :       // key name.  To ensure that the index name is unique, we also use the
; 3163 :       // zkey value.
; 3164 :       // NOTE: Becaues of a bug in UfCompressName, we tack on a extra '0' to
; 3165 :       // the name so that the zkey does not get truncated.
; 3166 :       if ( bUnique )

	mov	eax, DWORD PTR _bUnique$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L31174

; 3167 :          zsprintf( szWorkIdxName, "U%s_%s_%ld0", szEntityName, szName, lZKey );

	mov	ecx, DWORD PTR _lZKey$31172[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$31171[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0M@EFNH@U?$CFs_?$CFs_?$CFld0?$AA@ ; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3168 :       else

	jmp	SHORT $L31176
$L31174:

; 3169 :          zsprintf( szWorkIdxName, "%s_%s_%ld0", szEntityName, szName, lZKey );

	mov	edx, DWORD PTR _lZKey$31172[ebp]
	push	edx
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$31171[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0L@OGL@?$CFs_?$CFs_?$CFld0?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
$L31176:

; 3171 :    else

	jmp	SHORT $L31177
$L31170:

; 3173 :       RemoveBrackets( szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3174 :       zsprintf( szWorkIdxName, "%s", szName );

	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L31177:

; 3176 : 
; 3177 :    // Make sure that the index name is a valid length.
; 3178 :    UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 3179 :                    "", "B", "", "B_AEIOUYBCDFGHJKLMNPQRSTVWXZ", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BN@IFEM@B_AEIOUYBCDFGHJKLMNPQRSTVWXZ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ax, WORD PTR _nMaxTableNameLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	_UfCompressName@32

; 3180 : 
; 3181 :    if ( bUnique )

	mov	eax, DWORD PTR _bUnique$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	SHORT $L31179

; 3183 :       zsprintf( szLine, "CREATE UNIQUE INDEX %s%s %s",
; 3184 :                 szOwner, szWorkIdxName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BM@HCMD@CREATE?5UNIQUE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3186 :    else

	jmp	SHORT $L31181
$L31179:

; 3187 :       zsprintf( szLine, "CREATE INDEX %s%s %s",
; 3188 :                 szOwner, szWorkIdxName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BF@BFOD@CREATE?5INDEX?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H
$L31181:

; 3189 : 
; 3190 : 
; 3191 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31182

; 3192 :       return( -1 );

	or	ax, -1
	jmp	$L31139
$L31182:

; 3193 : 
; 3194 :    zsprintf( szLine, "       ON %s%s ( %s",
; 3195 :              szOwner, szTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@IBEH@?5?5?5?5?5?5?5ON?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3196 : 
; 3197 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31183

; 3198 :       return( -1 );

	or	ax, -1
	jmp	$L31139
$L31183:

; 3199 : 
; 3200 :    //=================================================================
; 3201 :    //
; 3202 :    // Generate column names for index.
; 3203 :    //
; 3204 :    //=================================================================
; 3205 :    nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRelKey", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31185:

; 3206 :    while( nLoop >= zCURSOR_SET )

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	$L31186

; 3208 :       GetStringFromAttribute (szName, vDTE, "TE_FieldDataRelKey", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3209 :       RemoveBrackets( szName );

	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3210 : 
; 3211 :       nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRelKey", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3212 :       if ( nLoop >= zCURSOR_SET  )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jl	SHORT $L31187

; 3214 :          // More keys coming, so print line with continuation stuff.
; 3215 :          zsprintf( szLine, "%*s %s, %s",
; 3216 :                    (zSHORT) COLUMN_INDENT, " ",
; 3217 :                    szName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0L@OGBL@?$CF?$CKs?5?$CFs?0?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 3219 :       else

	jmp	SHORT $L31190
$L31187:

; 3221 :          // No more keys, so end current command.
; 3222 :          zsprintf( szLine, "%*s %s ) %s",
; 3223 :                    (zSHORT) COLUMN_INDENT, " ",
; 3224 :                    szName, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_0M@JBMN@?$CF?$CKs?5?$CFs?5?$CJ?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H
$L31190:

; 3226 : 
; 3227 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31192

; 3228 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31139
$L31192:

; 3229 : 
; 3230 :    } // while ( nLoop >= zCURSOR_SET )...

	jmp	$L31185
$L31186:

; 3231 : 
; 3232 :    return( 0 );

	xor	ax, ax
$L31139:

; 3233 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnBuildIndexFromTablRecKey@12 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildCreateMainIndex@8
_TEXT	SEGMENT
_vDTE$ = 8
_f$ = 12
_bFirstIndex$ = -4
_nLoop$ = -8
_fnBuildCreateMainIndex@8 PROC NEAR

; 3237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3238 :    zBOOL    bFirstIndex;
; 3239 :    zSHORT   nLoop;
; 3240 : 
; 3241 :    // Loop through each of the keys for the current table.
; 3242 :    bFirstIndex = TRUE;

	mov	BYTE PTR _bFirstIndex$[ebp], 1

; 3243 :    for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRecKey", 0 );
; 3244 :          nLoop >= zCURSOR_SET;
; 3245 :          nLoop = SetCursorNextEntity( vDTE, "TE_TablRecKey", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31201
$L31202:
	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31201:
	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	SHORT $L31203

; 3248 :       if ( fnBuildIndexFromTablRecKey( vDTE, bFirstIndex, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	cl, BYTE PTR _bFirstIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildIndexFromTablRecKey@12
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31204

; 3249 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31198
$L31204:

; 3250 : 
; 3251 :       bFirstIndex = FALSE;

	mov	BYTE PTR _bFirstIndex$[ebp], 0

; 3252 : 
; 3253 :    } // for ( "TE_TablRecKey"... )...

	jmp	SHORT $L31202
$L31203:

; 3254 : 
; 3255 :    // Write a blank line.
; 3256 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31205

; 3257 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31198
$L31205:

; 3258 : 
; 3259 :    return( 0 );

	xor	ax, ax
$L31198:

; 3260 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildCreateMainIndex@8 ENDP
_TEXT	ENDS
PUBLIC	_fnBuildCreateTable@8
PUBLIC	??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_04BAFE@?$CF?$CKs?5?$AA@			; `string'
PUBLIC	??_C@_04GPPE@?0?5?$CFs?$AA@			; `string'
PUBLIC	??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@			; `string'
;	COMDAT ??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@ DB '%s Entity - %s %s'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ DB 'CREATE TAB'
	DB	'LE %s%s ( %s', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_04BAFE@?$CF?$CKs?5?$AA@
_DATA	SEGMENT
??_C@_04BAFE@?$CF?$CKs?5?$AA@ DB '%*s ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04GPPE@?0?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_04GPPE@?0?5?$CFs?$AA@ DB ', %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@ DB ' ) %s', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_f$ = 12
_szTableName$ = -648
_pch$ = -72
_pchEnd$ = -388
_pchDefaultOwner$ = -392
_szLine$ = -340
_szOwner$ = -68
_szDBH_DataObjectName$ = -384
_nLoop$ = -80
_vDBH_Data$ = -348
_vTZTEDBLO$ = -84
_vTZDBHODO$ = -344
_nMaxTableNameLth$ = -76
_l$31226 = -652
_fnBuildCreateTable@8 PROC NEAR

; 3264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 652				; 0000028cH

; 3265 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 3266 :    zPCHAR   pch;
; 3267 :    zPCHAR   pchEnd;
; 3268 :    zPCHAR   pchDefaultOwner;
; 3269 :    zCHAR    szLine[ 256 ];
; 3270 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3271 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 3272 :    zSHORT   nLoop;
; 3273 :    zVIEW    vDBH_Data;
; 3274 :    zVIEW    vTZTEDBLO = 0;

	mov	DWORD PTR _vTZTEDBLO$[ebp], 0

; 3275 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 3276 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 64	; 00000040H

; 3277 : 
; 3278 :    // If it exists get the object that defines the dbhandler type.
; 3279 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 3280 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31224

; 3281 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 3282 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
$L31224:

; 3283 : 
; 3284 :    // Try to get the OI that contains DBH-specific data.
; 3285 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 3286 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 3287 : 
; 3288 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3289 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 3290 : 
; 3291 :    // Try to get the ODBC definition.
; 3292 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 3293 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 3294 : 
; 3295 :    // Check to see if there is DBH data set in the TE.
; 3296 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31227

; 3298 :       zLONG l;
; 3299 : 
; 3300 :       // Check to see if there is an max length override.
; 3301 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 3302 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$31226[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $L31227

; 3304 :          nMaxTableNameLth = (zSHORT) l;

	mov	dx, WORD PTR _l$31226[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], dx
$L31227:

; 3307 : 
; 3308 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $L31229

; 3309 :       DropView( vTZDBHODO );

	mov	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_DropView@4
$L31229:

; 3310 : 
; 3311 : #endif
; 3312 : 
; 3313 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31230

; 3314 :       DropView( vDBH_Data );

	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_DropView@4
$L31230:

; 3315 : 
; 3316 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 3317 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3318 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31232
	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L31231
$L31232:

; 3319 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31231:

; 3320 : 
; 3321 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3322 :    RemoveBrackets( szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3323 : 
; 3324 :    /* Position on the first column of the table */
; 3325 :    nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3326 :    if ( nLoop < zCURSOR_SET )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jge	SHORT $L31233

; 3327 :       return( 0 );

	xor	ax, ax
	jmp	$L31211
$L31233:

; 3328 : 
; 3329 :    // Write the CREATE TABLE Statement and the comment only if
; 3330 :    // there are columns in a table.
; 3331 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	movsx	eax, ax
	test	eax, eax
	jl	SHORT $L31236

; 3333 :       GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3334 :       zsprintf( szLine, "%s Entity - %s %s",
; 3335 :                 COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BC@PCJM@?$CFs?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3336 : 
; 3337 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31236

; 3338 :          return( -1 );

	or	ax, -1
	jmp	$L31211
$L31236:

; 3340 : 
; 3341 :    // Determine owner.
; 3342 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3343 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $L31237
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31237

; 3344 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L31237:

; 3345 : 
; 3346 :    if ( szOwner[ 0 ] )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	je	SHORT $L31238

; 3347 :       zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L31238:

; 3348 : 
; 3349 :    zsprintf( szLine, "CREATE TABLE %s%s ( %s",
; 3350 :              szOwner, szTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BH@HMHF@CREATE?5TABLE?5?$CFs?$CFs?5?$CI?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3351 : 
; 3352 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31240

; 3353 :       return( -1 );

	or	ax, -1
	jmp	$L31211
$L31240:

; 3354 : 
; 3355 :    //=================================================================
; 3356 :    //
; 3357 :    // Generate column definitions.
; 3358 :    //
; 3359 :    //=================================================================
; 3360 : 
; 3361 :    // Loop for each column in the table.
; 3362 :    while ( nLoop >= zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jl	$L31243

; 3364 :       zsprintf( szLine, "%*s ", (zSHORT) COLUMN_INDENT, " " );

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	push	10					; 0000000aH
	push	OFFSET FLAT:??_C@_04BAFE@?$CF?$CKs?5?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3365 :       fnBuildColumn( vDTE, f, szLine );

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildColumn@12

; 3366 : 
; 3367 :       pchEnd = &szLine[ zstrlen( szLine ) ];

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szLine$[ebp+eax]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 3368 : 
; 3369 :       nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3370 :       if ( nLoop >= zCURSOR_SET )

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	SHORT $L31246

; 3371 :          // More columns comming, so add continuation stuff.
; 3372 :          zsprintf( pchEnd, ", %s", CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_04GPPE@?0?5?$CFs?$AA@	; `string'
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 3373 :       else

	jmp	SHORT $L31248
$L31246:

; 3374 :          // No more columns, so terminate line.
; 3375 :          zsprintf( pchEnd, " ) %s", LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	push	OFFSET FLAT:??_C@_05NLEE@?5?$CJ?5?$CFs?$AA@ ; `string'
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L31248:

; 3376 : 
; 3377 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31250

; 3378 :          return( -1 );

	or	ax, -1
	jmp	SHORT $L31211
$L31250:

; 3379 : 
; 3380 :    } // while ( nLoop >= zCURSOR_SET )...

	jmp	$L31240
$L31243:

; 3381 : 
; 3382 :    // Write a blank line.
; 3383 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31251

; 3384 :       return( -1 );

	or	ax, -1
	jmp	SHORT $L31211
$L31251:

; 3385 : 
; 3386 :    #if COMMIT_EVERY_TABLE
; 3387 :       if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3388 :          return( -1 );
; 3389 : 
; 3390 :       if ( fnWriteLine( vDTE, f, " " ) < 0 )
; 3391 :          return( -1 );
; 3392 :    #endif
; 3393 : 
; 3394 :    return( 0 );

	xor	ax, ax
$L31211:

; 3395 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildCreateTable@8 ENDP
_TEXT	ENDS
PUBLIC	_BuildDDL@16
PUBLIC	??_C@_01OAK@N?$AA@				; `string'
PUBLIC	??_C@_04PMIC@?4ddl?$AA@				; `string'
PUBLIC	??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05FCKF@?$CFs_?$CFs?$AA@			; `string'
PUBLIC	??_C@_07PHBB@B_AEIOU?$AA@			; `string'
PUBLIC	??_C@_04LGDF@?$CF02d?$AA@			; `string'
PUBLIC	??_C@_0BN@DHGH@DROP?5TABLE?5IF?5EXISTS?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_05EGAJ@File?5?$AA@			; `string'
PUBLIC	??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@ ; `string'
PUBLIC	??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@	; `string'
PUBLIC	??_C@_0N@PLHO@Generate?5DDL?$AA@		; `string'
EXTRN	_SysOpenFile@12:NEAR
EXTRN	_MB_SetMessage@12:NEAR
EXTRN	_CreateViewFromViewForTask@12:NEAR
EXTRN	_SysCloseFile@12:NEAR
;	COMDAT ??_C@_01OAK@N?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_01OAK@N?$AA@ DB 'N', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_04PMIC@?4ddl?$AA@
_DATA	SEGMENT
??_C@_04PMIC@?4ddl?$AA@ DB '.ddl', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@ DB '%s C'
	DB	'REATE DATABASE %s %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ DB '%s '
	DB	'Indexes for Entity - %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05FCKF@?$CFs_?$CFs?$AA@
_DATA	SEGMENT
??_C@_05FCKF@?$CFs_?$CFs?$AA@ DB '%s_%s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07PHBB@B_AEIOU?$AA@
_DATA	SEGMENT
??_C@_07PHBB@B_AEIOU?$AA@ DB 'B_AEIOU', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LGDF@?$CF02d?$AA@
_DATA	SEGMENT
??_C@_04LGDF@?$CF02d?$AA@ DB '%02d', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BN@DHGH@DROP?5TABLE?5IF?5EXISTS?5?$CFs?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BN@DHGH@DROP?5TABLE?5IF?5EXISTS?5?$CFs?$CFs?5?$CFs?$AA@ DB 'DROP T'
	DB	'ABLE IF EXISTS %s%s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@ DB 'GRA'
	DB	'NT ALL ON %s%s TO PUBLIC %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05EGAJ@File?5?$AA@
_DATA	SEGMENT
??_C@_05EGAJ@File?5?$AA@ DB 'File ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@
_DATA	SEGMENT
??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@ DB ' is created succe'
	DB	'ssfully!', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@
_DATA	SEGMENT
??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@ DB 'Couldn''t create file ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@PLHO@Generate?5DDL?$AA@
_DATA	SEGMENT
??_C@_0N@PLHO@Generate?5DDL?$AA@ DB 'Generate DDL', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_vEMD$ = 12
_pchFileName$ = 16
_vSubtask$ = 20
_pchTableName$ = -4
_pchDatabaseName$ = -1452
_pch$ = -84
_f$ = -1136
_szLine$ = -1132
_nLth$ = -348
_nRC$ = -352
_nRCTable$ = -344
_nLoop$ = -872
_vTZTEDBLO$ = -876
_vDBH_Data$ = -1144
_szDBH_DataObjectName$ = -1184
_nMaxTableNameLth$ = -868
_szTableName$ = -1448
_szEntityName$ = -340
_pchDefaultOwner$ = -1192
_szOwner$ = -80
_pchGenCreateIdxs$ = -1188
_pchGenDropIdxs$ = -12
_pchGenCreateTables$ = -1148
_pchGenDropTables$ = -8
_szMsg$ = -864
_usForeignKeyCntForTable$31300 = -1456
_szName$31310 = -1712
_szWorkIdxName$31311 = -2228
_szKeyName$31319 = -2488
_pchKeyType$31320 = -2232
_szWorkIdxName$31321 = -3004
_pchKeyType$31351 = -3008
_BuildDDL@16 PROC NEAR

; 3420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3008				; 00000bc0H

; 3421 :    zPCHAR   pchTableName;
; 3422 :    zPCHAR   pchDatabaseName;
; 3423 :    zPCHAR   pch;
; 3424 :    zLONG    f = -1;

	mov	DWORD PTR _f$[ebp], -1

; 3425 :    zCHAR    szLine[ 256 ];
; 3426 :    zLONG    nLth;
; 3427 :    zSHORT   nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H

; 3428 :    zSHORT   nRCTable;
; 3429 :    zSHORT   nLoop;
; 3430 :    zVIEW    vTZTEDBLO;
; 3431 :    zVIEW    vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 3432 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 3433 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxTableNameLth$[ebp], 64	; 00000040H

; 3434 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 3435 :    zCHAR    szEntityName[ MAX_NAME_LTH + 1 ];
; 3436 :    zPCHAR   pchDefaultOwner;
; 3437 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3438 :    zPCHAR   pchGenCreateIdxs   = "Y";

	mov	DWORD PTR _pchGenCreateIdxs$[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'

; 3439 :    zPCHAR   pchGenDropIdxs     = "N";

	mov	DWORD PTR _pchGenDropIdxs$[ebp], OFFSET FLAT:??_C@_01OAK@N?$AA@ ; `string'

; 3440 :    zPCHAR   pchGenCreateTables = "Y";

	mov	DWORD PTR _pchGenCreateTables$[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'

; 3441 :    zPCHAR   pchGenDropTables   = "Y";

	mov	DWORD PTR _pchGenDropTables$[ebp], OFFSET FLAT:??_C@_01PCJP@Y?$AA@ ; `string'

; 3442 : 
; 3443 :    zCHAR    szMsg[ 512 ];
; 3444 : 
; 3445 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3446 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 3447 :    zVIEW    vTZDBHODO;
; 3448 : #endif
; 3449 : 
; 3450 :    // If TE_DBMS_Source entity doesn't exist, then nothing to generate.
; 3451 :    if ( CheckExistenceOfEntity( vDTE, "TE_DBMS_Source" ) != zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L31286

; 3452 :       return( zCALL_ERROR );

	mov	ax, -16					; fffffff0H
	jmp	$L31261
$L31286:

; 3453 : 
; 3454 :    // If it exists get the object that defines the dbhandler type.
; 3455 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vSubtask, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_GetViewByName@16

; 3456 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $L31287

; 3457 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 3458 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
$L31287:

; 3459 : 
; 3460 :    // Try to get the OI that contains DBH-specific data.
; 3461 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 3462 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 3463 : 
; 3464 : #if defined( SQLITE )
; 3465 : 
; 3466 :    pchGenCreateIdxs   = "N";   // Don't generate indexes for Sqlite.

	mov	DWORD PTR _pchGenCreateIdxs$[ebp], OFFSET FLAT:??_C@_01OAK@N?$AA@ ; `string'

; 3467 : 
; 3468 : #elif defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3469 :       defined( POSTGRESQL ) || defined( SQLSERVER )
; 3470 : 
; 3471 :    // Try to get the ODBC definition.
; 3472 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 3473 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 3474 : 
; 3475 :    // Check to see if there is DBH data set in the TE.
; 3476 :    if ( vDBH_Data )
; 3477 :    {
; 3478 :       zLONG l;
; 3479 : 
; 3480 :       // Check to see if there is an max length override.
; 3481 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 3482 :                                     "MaxTableNameLength" ) != -1 )
; 3483 :       {
; 3484 :          nMaxTableNameLth = (zSHORT) l;
; 3485 :       }
; 3486 : 
; 3487 :       // Get the conditional generate values.
; 3488 :       GetAddrForAttribute( &pchGenCreateTables, vDBH_Data, "ODBC", "GenCreateTables" );
; 3489 :       GetAddrForAttribute( &pchGenDropTables,   vDBH_Data, "ODBC", "DropTables" );
; 3490 :       GetAddrForAttribute( &pchGenCreateIdxs,   vDBH_Data, "ODBC", "GenCreateIdxs" );
; 3491 :       GetAddrForAttribute( &pchGenDropIdxs,     vDBH_Data, "ODBC", "GenDropIdxs" );
; 3492 :    }
; 3493 : 
; 3494 : #endif
; 3495 : 
; 3496 :    // Create copies of views so we can safely change the cursors.
; 3497 :    CreateViewFromViewForTask( &vDTE, vDTE, 0 );

	push	0
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 3498 :    CreateViewFromViewForTask( &vEMD, vEMD, 0 );

	push	0
	mov	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vEMD$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 3499 : 
; 3500 :    //
; 3501 :    // Generate the DDL file name and open it.
; 3502 :    //
; 3503 :    nLth = zstrlen( pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 3504 :    GetStringFromAttribute( pchFileName + nLth,
; 3505 :                            vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	add	ecx, DWORD PTR _nLth$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3506 : 
; 3507 :    // Make sure the filename isn't too long.
; 3508 :    if ( zstrlen( pchFileName + nLth ) > zBASE_FILENAME_LTH )

	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, DWORD PTR _nLth$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jbe	SHORT $L31288

; 3509 :       pchFileName[ nLth + zBASE_FILENAME_LTH ] = 0;

	mov	eax, DWORD PTR _pchFileName$[ebp]
	add	eax, DWORD PTR _nLth$[ebp]
	mov	BYTE PTR [eax+128], 0
$L31288:

; 3510 : 
; 3511 :    zstrcat( pchFileName, ".ddl" );

	push	OFFSET FLAT:??_C@_04PMIC@?4ddl?$AA@	; `string'
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3512 :    if ( (f = SysOpenFile( vDTE, pchFileName, COREFILE_WRITE )) < 0 )

	push	64					; 00000040H
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysOpenFile@12
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jge	SHORT $L31290

; 3513 :       goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31290:

; 3514 : 
; 3515 :    GetAddrForAttribute( &pchDatabaseName, vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDatabaseName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3516 : 
; 3517 : #ifdef CREATE_DB
; 3518 :    zsprintf( szLine, "%s CREATE DATABASE %s %s %s", COMMENT_START,
; 3519 :              pchDatabaseName, COMMENT_END, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	eax, DWORD PTR _pchDatabaseName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BM@MOMC@?$CFs?5CREATE?5DATABASE?5?$CFs?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 3520 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31293

; 3521 :       goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31293:

; 3522 : #endif
; 3523 : 
; 3524 :    //
; 3525 :    // Tell SQL processor what database to use.
; 3526 :    //
; 3527 : 
; 3528 : #if defined( DB2 )
; 3529 : 
; 3530 :    zsprintf( szLine, "CONNECT TO %s %s", pchDatabaseName, LINE_TERMINATOR );
; 3531 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3532 :       goto EndOfFunction;
; 3533 : 
; 3534 : #elif defined( MYSQL) || defined( SQLSERVER )
; 3535 : 
; 3536 :    #ifdef SQLITE
; 3537 :        // Skip the "USE" statement for SQLITE.
; 3538 :    #else
; 3539 :        zsprintf( szLine, "USE %s %s", pchDatabaseName, LINE_TERMINATOR );
; 3540 :        if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3541 :          goto EndOfFunction;
; 3542 :    #endif
; 3543 : 
; 3544 : #elif defined( POSTGRESQL ) 
; 3545 : 
; 3546 :        zsprintf( szLine, "SET SCHEMA '%s' %s", pchDatabaseName, LINE_TERMINATOR );
; 3547 :        if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3548 :          goto EndOfFunction;
; 3549 : 
; 3550 : #endif
; 3551 : 
; 3552 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",
; 3553 :                         "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3554 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31295
	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $L31294
$L31295:

; 3555 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31294:

; 3556 : 
; 3557 :    //=================================================================
; 3558 :    //
; 3559 :    // Generate Drop Index statements.
; 3560 :    //
; 3561 :    //=================================================================
; 3562 :    if ( pchGenDropIdxs[ 0 ] != 'N' )

	mov	eax, DWORD PTR _pchGenDropIdxs$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 78					; 0000004eH
	je	$L31299

; 3564 :       // Loop for each of the tables.
; 3565 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3566 :             nRCTable >= zCURSOR_SET;
; 3567 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31297
$L31298:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31297:
	movsx	ecx, WORD PTR _nRCTable$[ebp]
	test	ecx, ecx
	jl	$L31299

; 3569 :          zUSHORT usForeignKeyCntForTable = 0;

	mov	WORD PTR _usForeignKeyCntForTable$31300[ebp], 0

; 3570 : 
; 3571 :          GetStringFromAttribute (szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3572 :          pchTableName = szTableName;

	lea	ecx, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], ecx

; 3573 :          RemoveBrackets( pchTableName );

	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3574 : 
; 3575 :          /* Position on the first column of the table */
; 3576 :          nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3577 :          if ( nLoop < zCURSOR_SET )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jge	SHORT $L31301

; 3578 :             continue;

	jmp	$L31298
$L31301:

; 3579 : 
; 3580 :          // Write comment.
; 3581 :          if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	movsx	eax, ax
	test	eax, eax
	jl	SHORT $L31304

; 3583 :             GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3584 :             zsprintf( szLine, "%s Indexes for Entity - %s %s",
; 3585 :                       COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BO@IABD@?$CFs?5Indexes?5for?5Entity?5?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3586 : 
; 3587 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31304

; 3588 :                goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31304:

; 3590 : 
; 3591 :          // Determine owner.
; 3592 :          GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3593 :          if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $L31305
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31305

; 3594 :             zstrcpy( szOwner, pchDefaultOwner );

	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L31305:

; 3595 : 
; 3596 :          if ( szOwner[ 0 ] )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	je	SHORT $L31306

; 3597 :             zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L31306:

; 3598 : 
; 3599 :          //=================================================================
; 3600 :          //
; 3601 :          // Drop Unique Index.
; 3602 :          //
; 3603 :          //=================================================================
; 3604 : 
; 3605 :          // Loop through each of the keys for the current table.
; 3606 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRecKey", 0 );
; 3607 :                nLoop >= zCURSOR_SET;
; 3608 :                nLoop = SetCursorNextEntity( vDTE, "TE_TablRecKey", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31307
$L31308:
	push	0
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31307:
	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	$L31309

; 3610 :             zCHAR  szName[ MAX_NAME_LTH + 1 ];
; 3611 :             zCHAR  szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3612 : 
; 3613 :             // If an IndexName value exists in TE_TablRecKey, use it.  Otherwise
; 3614 :             // us the Name value.
; 3615 :             GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "IndexName");

	push	OFFSET FLAT:??_C@_09CEBI@IndexName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$31310[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3616 :             if ( szName[ 0 ] == 0 )

	movsx	edx, BYTE PTR _szName$31310[ebp]
	test	edx, edx
	jne	SHORT $L31312

; 3618 :                GetStringFromAttribute (szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3619 :                RemoveBrackets( szEntityName );

	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3620 : 
; 3621 :                GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$31310[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3622 :                RemoveBrackets( szName );

	lea	edx, DWORD PTR _szName$31310[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3623 : 
; 3624 :                zsprintf( szWorkIdxName, "%s_%s", szEntityName, szName );

	lea	eax, DWORD PTR _szName$31310[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_05FCKF@?$CFs_?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szWorkIdxName$31311[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3626 :             else

	jmp	SHORT $L31314
$L31312:

; 3628 :                RemoveBrackets( szName );

	lea	eax, DWORD PTR _szName$31310[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3629 : 
; 3630 :                zsprintf( szWorkIdxName, "%s", szName );

	lea	ecx, DWORD PTR _szName$31310[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02DILL@?$CFs?$AA@	; `string'
	lea	edx, DWORD PTR _szWorkIdxName$31311[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH
$L31314:

; 3632 : 
; 3633 :             // Make sure that the index name is a valid length.
; 3634 :             UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 3635 :                             "", "B", "", "B_AEIOU", 1 );

	push	1
	push	OFFSET FLAT:??_C@_07PHBB@B_AEIOU?$AA@	; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ax, WORD PTR _nMaxTableNameLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$31311[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$31311[ebp]
	push	edx
	call	_UfCompressName@32

; 3636 : 
; 3637 :             fnBuildDropIndex( vDTE, szWorkIdxName, szOwner, pchTableName, f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$31311[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildDropIndex@20

; 3638 : 
; 3639 :          } // for ( "TE_TablRecKey"... )...

	jmp	$L31308
$L31309:

; 3640 : 
; 3641 :          //===============================================================
; 3642 :          //
; 3643 :          // Drop Index for ForeignKeys
; 3644 :          //
; 3645 :          //===============================================================
; 3646 : 
; 3647 :          // Loop through each of the keys for the current table.
; 3648 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3649 :                nLoop >= zCURSOR_SET;
; 3650 :                nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31316
$L31317:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31316:
	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jl	$L31318

; 3653 :             zCHAR  szKeyName[ MAX_NAME_LTH + 1 ];
; 3654 :             zPCHAR pchKeyType;
; 3655 :             zCHAR  szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3656 : 
; 3657 :             // If the attribute is not a rel field try the next one.
; 3658 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 3659 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchKeyType$31320[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3660 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	ecx, DWORD PTR _pchKeyType$31320[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 82					; 00000052H
	je	SHORT $L31322

; 3661 :                continue;

	jmp	SHORT $L31317
$L31322:

; 3662 : 
; 3663 :             // generate a comment identifying the relationship
; 3664 :             GetAddrForAttribute( &pch, vDTE, "TE_FieldDataRel", "Desc" );

	push	OFFSET FLAT:??_C@_04DKMG@Desc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3665 :             zsprintf( szLine, "%s Index for Relationship - '%s' %s",
; 3666 :                       COMMENT_START, pch, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0CE@EPOC@?$CFs?5Index?5for?5Relationship?5?9?5?8?$CFs?8@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3667 : 
; 3668 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31323

; 3669 :                goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31323:

; 3670 : 
; 3671 :             GetStringFromAttribute( szKeyName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKeyName$31319[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3672 :             RemoveBrackets( szKeyName );

	lea	eax, DWORD PTR _szKeyName$31319[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3673 :             zsprintf( szWorkIdxName, "%s_%s", pchTableName, szKeyName );

	lea	ecx, DWORD PTR _szKeyName$31319[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_05FCKF@?$CFs_?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szWorkIdxName$31321[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 3674 : 
; 3675 :             // Make sure that the index name is a valid length.
; 3676 :             // MAX_TABLENAME_LTH - 2 because of numbering the indexname
; 3677 :             // in the last two chars.
; 3678 :             UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,
; 3679 :                             "", "B", "", "B_AEIOU", 1 );

	push	1
	push	OFFSET FLAT:??_C@_07PHBB@B_AEIOU?$AA@	; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	cx, WORD PTR _nMaxTableNameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$31321[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$31321[ebp]
	push	eax
	call	_UfCompressName@32

; 3680 :             usForeignKeyCntForTable++;

	mov	cx, WORD PTR _usForeignKeyCntForTable$31300[ebp]
	add	cx, 1
	mov	WORD PTR _usForeignKeyCntForTable$31300[ebp], cx

; 3681 :             nLth = zstrlen( szWorkIdxName );

	lea	edx, DWORD PTR _szWorkIdxName$31321[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 3682 :             zsprintf( &szWorkIdxName[ nLth ], "%02d", usForeignKeyCntForTable );

	mov	eax, DWORD PTR _usForeignKeyCntForTable$31300[ebp]
	and	eax, 65535				; 0000ffffH
	push	eax
	push	OFFSET FLAT:??_C@_04LGDF@?$CF02d?$AA@	; `string'
	mov	ecx, DWORD PTR _nLth$[ebp]
	lea	edx, DWORD PTR _szWorkIdxName$31321[ebp+ecx]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 3683 : 
; 3684 :             fnBuildDropIndex( vDTE, szWorkIdxName, szOwner, pchTableName, f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$31321[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildDropIndex@20

; 3685 : 
; 3686 :          } // for ( "TE_FieldDataRel" )...

	jmp	$L31317
$L31318:

; 3687 : 
; 3688 :          if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31325

; 3689 :             goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31325:

; 3690 : 
; 3691 :       } // for ( "TE_TableRec" )...

	jmp	$L31298
$L31299:

; 3694 : 
; 3695 :    //=================================================================
; 3696 :    //
; 3697 :    // Generate Drop Table statements.
; 3698 :    //
; 3699 :    //=================================================================
; 3700 : 
; 3701 :    if ( pchGenDropTables[ 0 ] != 'N' )

	mov	ecx, DWORD PTR _pchGenDropTables$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 78					; 0000004eH
	je	$L31335

; 3703 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3704 :             nRCTable >= zCURSOR_SET;
; 3705 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31327
$L31328:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31327:
	movsx	edx, WORD PTR _nRCTable$[ebp]
	test	edx, edx
	jl	$L31329

; 3707 :          /* Position on the first column of the table */
; 3708 :          /* If the table has no columns no DROP statement */
; 3709 :          nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3710 :          if (nRC < zCURSOR_SET)

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L31330

; 3711 :             continue;

	jmp	SHORT $L31328
$L31330:

; 3712 : 
; 3713 :          // Determine owner.
; 3714 :          GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3715 :          if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $L31331
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31331

; 3716 :             zstrcpy( szOwner, pchDefaultOwner );

	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L31331:

; 3717 : 
; 3718 :          if ( szOwner[ 0 ] )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	je	SHORT $L31332

; 3719 :             zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L31332:

; 3720 : 
; 3721 :          GetStringFromAttribute (szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3722 :          pch = szEntityName;

	lea	edx, DWORD PTR _szEntityName$[ebp]
	mov	DWORD PTR _pch$[ebp], edx

; 3723 :          RemoveBrackets( pch );

	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3724 : 
; 3725 :          #if defined( SQLITE )
; 3726 :             zsprintf( szLine, "DROP TABLE IF EXISTS %s%s %s", szOwner, pch, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BN@DHGH@DROP?5TABLE?5IF?5EXISTS?5?$CFs?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3727 :          #elif defined( MYSQL )
; 3728 :             zsprintf( szLine, "DROP TABLE IF EXISTS %s%s %s", szOwner, pch, LINE_TERMINATOR );
; 3729 :          #elif defined( POSTGRESQL )
; 3730 :             zsprintf( szLine, "DROP TABLE IF EXISTS %s%s CASCADE%s", szOwner, pch, LINE_TERMINATOR );
; 3731 :          #else
; 3732 :             zsprintf( szLine, "DROP TABLE %s%s %s", szOwner, pch, LINE_TERMINATOR );
; 3733 : 	 #endif
; 3734 : 
; 3735 :          if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31334

; 3736 :             nRC = zCALL_ERROR;

	mov	WORD PTR _nRC$[ebp], -16		; fffffff0H
$L31334:

; 3737 :       }

	jmp	$L31328
$L31329:

; 3738 : 
; 3739 :    #if defined( COMMIT_EVERY_TABLE )
; 3740 : 
; 3741 :       if ( fnWriteLine( vDTE, f, "" ) < 0 )
; 3742 :          goto EndOfFunction;
; 3743 : 
; 3744 :       if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3745 :          goto EndOfFunction;
; 3746 : 
; 3747 :    #endif
; 3748 : 
; 3749 :       if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31335

; 3750 :          goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31335:

; 3753 : 
; 3754 :    //=================================================================
; 3755 :    //
; 3756 :    // Generate Create Table statements.
; 3757 :    //
; 3758 :    //=================================================================
; 3759 : 
; 3760 :    if ( pchGenCreateTables[ 0 ] != 'N' )

	mov	eax, DWORD PTR _pchGenCreateTables$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 78					; 0000004eH
	je	SHORT $L31339

; 3762 :       // Loop for each of the tables.
; 3763 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3764 :             nRCTable >= zCURSOR_SET;
; 3765 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31337
$L31338:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31337:
	movsx	ecx, WORD PTR _nRCTable$[ebp]
	test	ecx, ecx
	jl	SHORT $L31339

; 3767 :          if ( fnBuildCreateTable( vDTE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildCreateTable@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L31340

; 3768 :             goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31340:

; 3769 :       } // for ( "TE_TableRec" )...

	jmp	SHORT $L31338
$L31339:

; 3772 : 
; 3773 :    //=================================================================
; 3774 :    //
; 3775 :    // Generate Create Index statements.
; 3776 :    //
; 3777 :    //=================================================================
; 3778 : 
; 3779 :    if ( pchGenCreateIdxs[ 0 ] != 'N' )

	mov	edx, DWORD PTR _pchGenCreateIdxs$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 78					; 0000004eH
	je	$L31344

; 3781 :       // Loop for each of the tables.
; 3782 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3783 :             nRCTable >= zCURSOR_SET;
; 3784 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $L31342
$L31343:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$L31342:
	movsx	eax, WORD PTR _nRCTable$[ebp]
	test	eax, eax
	jl	$L31344

; 3786 :          GetStringFromAttribute (szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3787 :          pchTableName = szTableName;

	lea	eax, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], eax

; 3788 :          RemoveBrackets( pchTableName );

	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3789 : 
; 3790 :          /* Position on the first column of the table */
; 3791 :          nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3792 :          if ( nLoop < zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jge	SHORT $L31345

; 3793 :             continue;

	jmp	SHORT $L31343
$L31345:

; 3794 : 
; 3795 :          if ( fnBuildCreateMainIndex( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildCreateMainIndex@8
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31346

; 3796 :             goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31346:

; 3797 : 
; 3798 :          if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31347

; 3799 :             goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31347:

; 3800 : 
; 3801 :          #if COMMIT_EVERY_TABLE
; 3802 :                if ( fnWriteLine( vDTE, f, " " ) < 0 )
; 3803 :                   goto EndOfFunction;
; 3804 : 
; 3805 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3806 :                   goto EndOfFunction;
; 3807 :          #endif
; 3808 : 
; 3809 :          //===============================================================
; 3810 :          //
; 3811 :          // Generate Index for ForeignKeys
; 3812 :          //
; 3813 :          //===============================================================
; 3814 : 
; 3815 :          // Loop through each of the keys for the current table.
; 3816 : 
; 3817 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3818 :                nLoop >= zCURSOR_SET;
; 3819 :                nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31348
$L31349:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31348:
	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	SHORT $L31350

; 3822 :             zPCHAR pchKeyType;
; 3823 : 
; 3824 :             // If the attribute is not a rel field try the next one.
; 3825 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 3826 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$31351[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3827 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	edx, DWORD PTR _pchKeyType$31351[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 82					; 00000052H
	je	SHORT $L31352

; 3828 :                continue;

	jmp	SHORT $L31349
$L31352:

; 3829 : 
; 3830 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildFK_Index@8
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31353

; 3831 :                goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31353:

; 3832 : 
; 3833 :             #if defined( COMMIT_EVERY_TABLE )
; 3834 : 
; 3835 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )
; 3836 :                   goto EndOfFunction;
; 3837 : 
; 3838 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3839 :                   goto EndOfFunction;
; 3840 : 
; 3841 :             #endif
; 3842 : 
; 3843 :             if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET FLAT:??_C@_01FCOA@?5?$AA@	; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31354

; 3844 :                goto EndOfFunction;

	jmp	$EndOfFunction$31291
$L31354:

; 3845 : 
; 3846 :          } // for ( "TE_FieldDataRel" )...

	jmp	$L31349
$L31350:

; 3847 : 
; 3848 :    #if COMMIT_EVERY_TABLE
; 3849 :          if ( fnWriteLine( vDTE, f, " " ) < 0 )
; 3850 :             goto EndOfFunction;
; 3851 : 
; 3852 :           if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3853 :             goto EndOfFunction;
; 3854 :    #endif
; 3855 : 
; 3856 :       } // for ( "TE_TableRec" )...

	jmp	$L31343
$L31344:

; 3859 : 
; 3860 :    //=================================================================
; 3861 :    //
; 3862 :    // Loop through the table names again to create the "GRANT ALL" statements.
; 3863 :    //
; 3864 :    //=================================================================
; 3865 : 
; 3866 : #ifdef GRANT_ALL
; 3867 :    for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3868 :          nLoop >= zCURSOR_SET;
; 3869 :          nLoop = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $L31355
$L31356:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$L31355:
	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	$L31357

; 3871 :       /* Position on the first column of the table */
; 3872 :       /* No GRANT if the are no columns in the table */
; 3873 :       nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3874 :       if (nRC < zCURSOR_SET)

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $L31358

; 3875 :          continue;

	jmp	SHORT $L31356
$L31358:

; 3876 : 
; 3877 :       // Determine owner.
; 3878 :       GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3879 :       if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $L31359
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31359

; 3880 :          zstrcpy( szOwner, pchDefaultOwner );

	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L31359:

; 3881 : 
; 3882 :       if ( szOwner[ 0 ] )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	je	SHORT $L31360

; 3883 :          zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L31360:

; 3884 : 
; 3885 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3886 :       pchTableName = szTableName;

	lea	edx, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], edx

; 3887 :       RemoveBrackets( pchTableName );

	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3888 :       zsprintf( szLine, "GRANT ALL ON %s%s TO PUBLIC %s",
; 3889 :                 szOwner, pchTableName, CONTINUATION_STR );

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BP@OLHP@GRANT?5ALL?5ON?5?$CFs?$CFs?5TO?5PUBLIC?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 3890 : 
; 3891 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31362

; 3892 :          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31291
$L31362:

; 3893 : 
; 3894 :    } // for ( "TE_TableRec" )...

	jmp	$L31356
$L31357:

; 3895 : #endif
; 3896 : 
; 3897 :    if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31363

; 3898 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31291
$L31363:

; 3899 : 
; 3900 :    // If we get here, then everything is OK.
; 3901 :    nRC = 0;

	mov	WORD PTR _nRC$[ebp], 0
$EndOfFunction$31291:

; 3902 : 
; 3903 : EndOfFunction:
; 3904 :    if ( f != -1 )

	cmp	DWORD PTR _f$[ebp], -1
	je	SHORT $L31364

; 3905 :       SysCloseFile( vSubtask, f, 0 );

	push	0
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysCloseFile@12
$L31364:

; 3906 : 
; 3907 :    DropView( vDTE );

	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_DropView@4

; 3908 :    DropView( vEMD );

	mov	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	call	_DropView@4

; 3909 : 
; 3910 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $L31365

; 3912 :       zstrcpy( szMsg, "File " );

	push	OFFSET FLAT:??_C@_05EGAJ@File?5?$AA@	; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3913 :       zstrcat( szMsg, pchFileName );

	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3914 :       zstrcat( szMsg, " is created successfully!" );

	push	OFFSET FLAT:??_C@_0BK@MMCL@?5is?5created?5successfully?$CB?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3915 :      MB_SetMessage( vSubtask, 0, szMsg );

	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_MB_SetMessage@12

; 3917 :    else

	jmp	SHORT $L31368
$L31365:

; 3919 :        zstrcpy( szMsg, "Couldn't create file " );

	push	OFFSET FLAT:??_C@_0BG@PJOD@Couldn?8t?5create?5file?5?$AA@ ; `string'
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3920 :        zstrcat( szMsg, pchFileName );

	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3921 :       SysMessageBox( vDTE, "Generate DDL", szMsg, 0 );

	push	0
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0N@PLHO@Generate?5DDL?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16
$L31368:

; 3923 : 
; 3924 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$L31261:

; 3925 : 
; 3926 : } // BuildDDL

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_BuildDDL@16 ENDP
_TEXT	ENDS
PUBLIC	_BuildSyncDDL@20
PUBLIC	??_C@_0L@NKCB@Executable?$AA@			; `string'
PUBLIC	??_C@_0P@JHOI@RetrieveSchema?$AA@		; `string'
PUBLIC	??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@ ; `string'
PUBLIC	??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@	; `string'
PUBLIC	??_C@_07LDCE@TE00422?$AA@			; `string'
PUBLIC	??_C@_06NGI@_alter?$AA@				; `string'
PUBLIC	??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0L@FFM@MatchFound?$AA@			; `string'
PUBLIC	??_C@_01PJM@D?$AA@				; `string'
PUBLIC	??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@	; `string'
PUBLIC	??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@	; `string'
PUBLIC	??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@ ; `string'
PUBLIC	??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@ ; `string'
PUBLIC	??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@ ; `string'
PUBLIC	??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@	; `string'
PUBLIC	??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@ ; `string'
EXTRN	_SysLoadLibrary@8:NEAR
EXTRN	_strcmp:NEAR
EXTRN	_MessageSend@24:NEAR
EXTRN	_SetCursorFirstEntityByString@20:NEAR
EXTRN	_SetCursorNextEntityByString@20:NEAR
EXTRN	_SysFreeLibrary@8:NEAR
EXTRN	_SysGetProc@8:NEAR
EXTRN	_SetAttributeFromString@16:NEAR
;	COMDAT ??_C@_0L@NKCB@Executable?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0L@NKCB@Executable?$AA@ DB 'Executable', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@JHOI@RetrieveSchema?$AA@
_DATA	SEGMENT
??_C@_0P@JHOI@RetrieveSchema?$AA@ DB 'RetrieveSchema', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@
_DATA	SEGMENT
??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@ DB 'Couldn''t fin'
	DB	'd ''BuildSyncDDL'' in Generater Executable', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@
_DATA	SEGMENT
??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@ DB 'Physical Data Model', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_07LDCE@TE00422?$AA@
_DATA	SEGMENT
??_C@_07LDCE@TE00422?$AA@ DB 'TE00422', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06NGI@_alter?$AA@
_DATA	SEGMENT
??_C@_06NGI@_alter?$AA@ DB '_alter', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@ DB '%'
	DB	's Alter script for %s -- %s %s', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@FFM@MatchFound?$AA@
_DATA	SEGMENT
??_C@_0L@FFM@MatchFound?$AA@ DB 'MatchFound', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PJM@D?$AA@
_DATA	SEGMENT
??_C@_01PJM@D?$AA@ DB 'D', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@ DB '%s Entity %s %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@
_DATA	SEGMENT
??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@ DB 'ALTER TABLE %s ADD ', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@
_DATA	SEGMENT
??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@ DB 'DROP TABLE %s %s', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@
_DATA	SEGMENT
??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@ DB 'ALTER'
	DB	' TABLE %s%s DROP COLUMN %s %s', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@
_DATA	SEGMENT
??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@ DB 'ALTER'
	DB	' TABLE %s%-*s ALTER COLUMN ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@
_DATA	SEGMENT
??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@ DB 'WARNING: The'
	DB	' data type for the column %s.%s has been changed and therefor'
	DB	'e had an index deleted.  The column is NOT a key and therefor'
	DB	'e the index was added by the DBA.  An attempt has been made t'
	DB	'o recreate the index in the DDL.  Look for ''WARNING'' in the'
	DB	' DDL file', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@
_DATA	SEGMENT
??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@ DB 'DDL Generationg Warning'
	DB	00H						; `string'
_DATA	ENDS
;	COMDAT ??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@
_DATA	SEGMENT
??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@ DB '%s WARNING-'
	DB	'-Following index may not have the  same the columns as the or'
	DB	'iginal index: %s', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_vEMD$ = 12
_pchFileName$ = 20
_vSubtask$ = 24
_hLibrary$ = -88
_f$ = -932
_pfn$ = -100
_vDB$ = -8
_vBoth$ = -16
_szDLL$ = -428
_szTableName$ = -1020
_szColumnName$ = -168
_szOwner$ = -84
_szLine$ = -928
_pchDefaultOwner$ = -952
_pchDBName$ = -940
_pchDBDesc$ = -948
_k$ = -944
_nRC$ = -96
_nLth$ = -92
_nReturn$ = -4
_bTableDropped$ = -936
_pchTableName$31433 = -1024
_lDB_Lth$31438 = -1044
_lDTE_Lth$31439 = -1040
_szDB_Type$31440 = -1036
_szDTE_Type$31441 = -1056
_pchColName$31442 = -1060
_pchKeyType$31470 = -1064
_bFirstAlterOfTable$31476 = -1068
_pchMatchFound$31481 = -1072
_pchKeyType$31483 = -1076
_szEntityName$31485 = -1112
_bFirstAlterForTable$31503 = -1116
_nIndexDroppedCount$31510 = -1120
_szEntityName$31513 = -1156
_szIndex$31519 = -1224
_pchKeyType$31525 = -1228
_szMsg$31537 = -2228
_BuildSyncDDL@20 PROC NEAR

; 3952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2236				; 000008bcH

; 3953 :    LPLIBRARY hLibrary;
; 3954 :    zLONG     f = -1;

	mov	DWORD PTR _f$[ebp], -1

; 3955 :    zSHORT    (POPERATION pfn)( zVIEW, zPVIEW );
; 3956 :    zVIEW     vDB = 0;

	mov	DWORD PTR _vDB$[ebp], 0

; 3957 :    zVIEW     vBoth[ 2 ];
; 3958 :    zCHAR     szDLL[ zMAX_FILENAME_LTH + 1 ];
; 3959 :    zCHAR     szTableName[ MAX_TABLENAME_LTH + 1 ];
; 3960 :    zCHAR     szColumnName[ MAX_TABLENAME_LTH + 1 ];
; 3961 :    zCHAR     szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3962 :    zCHAR     szLine[ 500 ];
; 3963 :    zPCHAR    pchDefaultOwner;
; 3964 :    zPCHAR    pchDBName;
; 3965 :    zPCHAR    pchDBDesc;
; 3966 :    zSHORT    k, nRC;
; 3967 :    zSHORT    nLth;
; 3968 :    zSHORT    nReturn = zCALL_ERROR;

	mov	WORD PTR _nReturn$[ebp], -16		; fffffff0H

; 3969 :    zBOOL     bTableDropped;
; 3970 : 
; 3971 :    // Make copies of the views so we can safely change the cursors.
; 3972 :    CreateViewFromViewForTask( &vDTE, vDTE, 0 );

	push	0
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 3973 :    CreateViewFromViewForTask( &vEMD, vEMD, 0 );

	push	0
	mov	edx, DWORD PTR _vEMD$[ebp]
	push	edx
	lea	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 3974 : 
; 3975 :    // First thing we have to do is call the SQL DBH to load the current
; 3976 :    // DB schema.
; 3977 :    GetStringFromAttribute( szDLL,
; 3978 :                            vDTE, "TE_DBMS_Source", "Executable" );

	push	OFFSET FLAT:??_C@_0L@NKCB@Executable?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDLL$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3979 :    hLibrary = SysLoadLibrary( vSubtask, szDLL );

	lea	eax, DWORD PTR _szDLL$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3980 :    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $L31404

; 3982 :       pfn = SysGetProc( hLibrary, "RetrieveSchema" );

	push	OFFSET FLAT:??_C@_0P@JHOI@RetrieveSchema?$AA@ ; `string'
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pfn$[ebp], eax

; 3983 :       if ( pfn )

	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $L31406

; 3985 :          (*pfn)( vDTE, &vDB );

	lea	eax, DWORD PTR _vDB$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	DWORD PTR _pfn$[ebp]

; 3987 :       else

	jmp	SHORT $L31407
$L31406:

; 3989 :          MessageSend( vSubtask, "TE00422", "Physical Data Model",
; 3990 :                       "Couldn't find 'BuildSyncDDL' in Generater Executable",
; 3991 :                       zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 );

	push	0
	push	300					; 0000012cH
	push	OFFSET FLAT:??_C@_0DF@MNGA@Couldn?8t?5find?5?8BuildSyncDDL?8?5in?5@ ; `string'
	push	OFFSET FLAT:??_C@_0BE@DNAH@Physical?5Data?5Model?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_07LDCE@TE00422?$AA@	; `string'
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_MessageSend@24
$L31407:

; 3993 : 
; 3994 :       SysFreeLibrary( vSubtask, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysFreeLibrary@8
$L31404:

; 3996 : 
; 3997 :    if ( vDB == 0 )

	cmp	DWORD PTR _vDB$[ebp], 0
	jne	SHORT $L31411

; 3998 :       return( -1 );

	or	ax, -1
	jmp	$L31382
$L31411:

; 3999 : 
; 4000 :    //
; 4001 :    // Generate the DDL file name and open it.
; 4002 :    //
; 4003 :    nLth = zstrlen( pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 4004 :    GetStringFromAttribute( pchFileName + nLth,
; 4005 :                            vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, ecx
	push	edx
	call	_GetStringFromAttribute@16

; 4006 :    zstrcat( pchFileName, "_alter" );

	push	OFFSET FLAT:??_C@_06NGI@_alter?$AA@	; `string'
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 4007 : 
; 4008 :    // Make sure the filename isn't too long.
; 4009 :    if ( zstrlen( pchFileName + nLth ) > zBASE_FILENAME_LTH )

	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, ecx
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jbe	SHORT $L31413

; 4010 :       pchFileName[ nLth + zBASE_FILENAME_LTH ] = 0;

	movsx	eax, WORD PTR _nLth$[ebp]
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	mov	BYTE PTR [ecx+eax+128], 0
$L31413:

; 4011 : 
; 4012 :    zstrcat( pchFileName, ".ddl" );

	push	OFFSET FLAT:??_C@_04PMIC@?4ddl?$AA@	; `string'
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4013 :    if ( (f = SysOpenFile( vDTE, pchFileName, COREFILE_WRITE )) < 0 )

	push	64					; 00000040H
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jge	SHORT $L31414

; 4014 :       goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31414:

; 4015 : 
; 4016 :    GetAddrForAttribute( &pchDBName, vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDBName$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 4017 :    GetAddrForAttribute( &pchDBDesc, vDTE, "TE_DBMS_Source", "Desc" );

	push	OFFSET FLAT:??_C@_04DKMG@Desc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDBDesc$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4018 :    zsprintf( szLine, "%s Alter script for %s -- %s %s",
; 4019 :              COMMENT_START, pchDBName, pchDBDesc, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	mov	eax, DWORD PTR _pchDBDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchDBName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0CA@EBOB@?$CFs?5Alter?5script?5for?5?$CFs?5?9?9?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 4020 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31417

; 4021 :       goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31417:

; 4022 : 
; 4023 :    GetAddrForAttribute( &pchDefaultOwner, vDTE,
; 4024 :                         "TE_DBMS_Source", "DefaultOwner" );

	push	OFFSET FLAT:??_C@_0N@HJOL@DefaultOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4025 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31419
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $L31418
$L31419:

; 4026 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$L31418:

; 4027 : 
; 4028 :    // Turn off the "MatchFound" flag for all the tables/columns.
; 4029 :    vBoth[ 0 ] = vDTE;

	mov	ecx, DWORD PTR _vDTE$[ebp]
	mov	DWORD PTR _vBoth$[ebp], ecx

; 4030 :    vBoth[ 1 ] = vDB;

	mov	edx, DWORD PTR _vDB$[ebp]
	mov	DWORD PTR _vBoth$[ebp+4], edx

; 4031 :    for ( k = 0; k < 2; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L31420
$L31421:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L31420:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 2
	jge	$L31422

; 4033 :       for ( nRC = SetCursorFirstEntity( vBoth[ k ], "TE_TablRec", 0 );
; 4034 :             nRC >= zCURSOR_SET;
; 4035 :             nRC = SetCursorNextEntity( vBoth[ k ], "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vBoth$[ebp+edx*4]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31423
$L31424:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vBoth$[ebp+ecx*4]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31423:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31425

; 4037 :          SetAttributeFromString( vBoth[ k ], "TE_TablRec", "MatchFound", "N" );

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vBoth$[ebp+ecx*4]
	push	edx
	call	_SetAttributeFromString@16

; 4038 : 
; 4039 :          for ( nRC = SetCursorFirstEntity( vBoth[ k ], "TE_FieldDataRel", 0 );
; 4040 :                nRC >= zCURSOR_SET;
; 4041 :                nRC = SetCursorNextEntity( vBoth[ k ], "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vBoth$[ebp+eax*4]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31427
$L31428:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vBoth$[ebp+edx*4]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31427:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L31429

; 4043 :             SetAttributeFromString( vBoth[ k ], "TE_FieldDataRel",
; 4044 :                                     "MatchFound", "N" );

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vBoth$[ebp+edx*4]
	push	eax
	call	_SetAttributeFromString@16

; 4045 :          }

	jmp	SHORT $L31428
$L31429:

; 4046 :       }

	jmp	$L31424
$L31425:

; 4047 :    }

	jmp	$L31421
$L31422:

; 4048 : 
; 4049 :    // Now look for matches.
; 4050 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 4051 :          nRC >= zCURSOR_SET;
; 4052 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31430
$L31431:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31430:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31432

; 4054 :       zPCHAR pchTableName;
; 4055 : 
; 4056 :       if ( SetCursorFirstEntityByAttr( vDB, "TE_TablRec", "Name",
; 4057 :                                        vDTE, "TE_TablRec",
; 4058 :                                        "Name", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
	movsx	eax, ax
	test	eax, eax
	jge	SHORT $L31434

; 4060 :          continue;

	jmp	SHORT $L31431
$L31434:

; 4062 : 
; 4063 :       GetAddrForAttribute( &pchTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchTableName$31433[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4064 :       SetAttributeFromString( vDTE, "TE_TablRec", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4065 :       SetAttributeFromString( vDB,  "TE_TablRec", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4066 : 
; 4067 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 4068 :             nRC >= zCURSOR_SET;
; 4069 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31435
$L31436:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31435:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31437

; 4071 :          zLONG  lDB_Lth;
; 4072 :          zLONG  lDTE_Lth;
; 4073 :          zCHAR  szDB_Type[ 10 ];
; 4074 :          zCHAR  szDTE_Type[ 10 ];
; 4075 :          zPCHAR pchColName;
; 4076 : 
; 4077 :          // Check to see if there is a field in the DB with the same
; 4078 :          // name.
; 4079 :          if ( SetCursorFirstEntityByAttr( vDB, "TE_FieldDataRel", "Name",
; 4080 :                                           vDTE, "TE_FieldDataRel",
; 4081 :                                           "Name", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L31443

; 4083 :             // Nope.  No match found, continue with the next one.
; 4084 :             continue;

	jmp	SHORT $L31436
$L31443:

; 4086 : 
; 4087 :          GetAddrForAttribute( &pchColName, vDB, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchColName$31442[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 4088 :          GetIntegerFromAttribute( &lDB_Lth,  vDB, "TE_FieldDataRel", "Length" );

	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lDB_Lth$31438[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 4089 :          GetIntegerFromAttribute( &lDTE_Lth, vDTE, "TE_FieldDataRel", "Length" );

	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lDTE_Lth$31439[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 4090 :          GetStringFromAttribute( szDB_Type,  vDB, "TE_FieldDataRel", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDB_Type$31440[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 4091 :          GetStringFromAttribute( szDTE_Type, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDTE_Type$31441[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4092 : 
; 4093 :          // Some datatypes need to be massaged before we compare them.
; 4094 :          #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 4095 :              defined( POSTGRESQL ) || defined( SQLSERVER )
; 4096 : 
; 4097 :             switch ( szDB_Type[ 0 ] )
; 4098 :             {

	mov	al, BYTE PTR _szDB_Type$31440[ebp]
	mov	BYTE PTR -2232+[ebp], al
	cmp	BYTE PTR -2232+[ebp], 68		; 00000044H
	je	SHORT $L31448
	cmp	BYTE PTR -2232+[ebp], 73		; 00000049H
	je	SHORT $L31448
	cmp	BYTE PTR -2232+[ebp], 84		; 00000054H
	je	SHORT $L31448
	jmp	SHORT $L31445
$L31448:

; 4099 :                case zTYPE_DATE:
; 4100 :                case zTYPE_TIME:
; 4101 :                case zTYPE_DATETIME:
; 4102 :                   // In access, all date/time/timestamps are stored as the same
; 4103 :                   // datatype, so we need to set things up so they compare the same.
; 4104 :                   szDB_Type[ 0 ] = szDTE_Type[ 0 ];

	mov	cl, BYTE PTR _szDTE_Type$31441[ebp]
	mov	BYTE PTR _szDB_Type$31440[ebp], cl
$L31445:

; 4107 : 
; 4108 :             // We only care about the length for string types.
; 4109 :             if ( szDB_Type[ 0 ] != zTYPE_STRING || szDB_Type[ 0 ] != zTYPE_FIXEDCHAR )

	movsx	edx, BYTE PTR _szDB_Type$31440[ebp]
	cmp	edx, 83					; 00000053H
	jne	SHORT $L31450
	movsx	eax, BYTE PTR _szDB_Type$31440[ebp]
	cmp	eax, 70					; 00000046H
	je	SHORT $L31449
$L31450:

; 4110 :                lDB_Lth = lDTE_Lth;

	mov	ecx, DWORD PTR _lDTE_Lth$31439[ebp]
	mov	DWORD PTR _lDB_Lth$31438[ebp], ecx
$L31449:

; 4111 : 
; 4112 :          #endif
; 4113 : 
; 4114 :          if ( lDB_Lth != lDTE_Lth || zstrcmp( szDB_Type, szDTE_Type ) != 0 )

	mov	edx, DWORD PTR _lDB_Lth$31438[ebp]
	cmp	edx, DWORD PTR _lDTE_Lth$31439[ebp]
	jne	SHORT $L31458
	movsx	eax, BYTE PTR _szDB_Type$31440[ebp]
	movsx	ecx, BYTE PTR _szDTE_Type$31441[ebp]
	cmp	eax, ecx
	jne	SHORT $L32353
	lea	edx, DWORD PTR _szDTE_Type$31441[ebp]
	push	edx
	lea	eax, DWORD PTR _szDB_Type$31440[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -2236+[ebp], eax
	jmp	SHORT $L32354
$L32353:
	movsx	ecx, BYTE PTR _szDB_Type$31440[ebp]
	movsx	edx, BYTE PTR _szDTE_Type$31441[ebp]
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -2236+[ebp], eax
$L32354:
	cmp	DWORD PTR -2236+[ebp], 0
	je	SHORT $L31457
$L31458:

; 4116 :             #if 0
; 4117 :                zCHAR sz[ 500 ];
; 4118 : 
; 4119 :                zsprintf( sz, "%s.%s  TE Datatype = %s, Length = %d",
; 4120 :                          pchTableName, pchColName, szDTE_Type, lDTE_Lth );
; 4121 :                TraceLineS( sz, "" );
; 4122 :                zsprintf( sz, "%s.%s  DB Datatype = %s, Length = %d",
; 4123 :                          pchTableName, pchColName, szDB_Type, lDB_Lth );
; 4124 :                TraceLineS( sz, "" );
; 4125 :             #endif
; 4126 : 
; 4127 :             // Column is different somehow.
; 4128 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "MatchFound", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4129 :             SetAttributeFromString( vDB,  "TE_FieldDataRel", "MatchFound", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4131 :          else

	jmp	SHORT $L31460
$L31457:

; 4133 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4134 :             SetAttributeFromString( vDB,  "TE_FieldDataRel", "MatchFound", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$L31460:

; 4136 : 
; 4137 :       }  // For each TE_FieldDataRel

	jmp	$L31436
$L31437:

; 4138 : 
; 4139 :    }  // For each TE_TablRec

	jmp	$L31431
$L31432:

; 4140 : 
; 4141 :    //
; 4142 :    // Print results.
; 4143 :    //
; 4144 : 
; 4145 :    // Create tables.
; 4146 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 4147 :          nRC >= zCURSOR_SET;
; 4148 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31461
$L31462:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31461:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31463

; 4150 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 4151 : 
; 4152 :       // If table is in the DB, we don't need to create it.
; 4153 :       if ( CompareAttributeToString( vDTE, "TE_TablRec", "MatchFound", "N" ) != 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L31464

; 4154 :          continue;

	jmp	SHORT $L31462
$L31464:

; 4155 : 
; 4156 :       if ( fnBuildCreateTable( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildCreateTable@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L31465

; 4157 :          goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31465:

; 4158 : 
; 4159 :       if ( fnBuildCreateMainIndex( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildCreateMainIndex@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L31466

; 4160 :          goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31466:

; 4161 : 
; 4162 :       #if COMMIT_EVERY_TABLE
; 4163 :          if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4164 :             return( -1 );
; 4165 :       #endif
; 4166 : 
; 4167 :       // Create the indexes for the FKs.
; 4168 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 4169 :             nRC >= zCURSOR_SET;
; 4170 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31467
$L31468:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31467:
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L31469

; 4172 :          zPCHAR pchKeyType;
; 4173 : 
; 4174 :          GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 4175 :                               "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$31470[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4176 :          if ( pchKeyType[ 0 ] == 'R' )

	mov	edx, DWORD PTR _pchKeyType$31470[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 82					; 00000052H
	jne	SHORT $L31472

; 4178 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildFK_Index@8
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31472

; 4179 :                goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31472:

; 4190 : 
; 4191 :       }  // For each TE_FieldDataRel

	jmp	SHORT $L31468
$L31469:

; 4192 : 
; 4193 :    }  // For each TE_TablRec

	jmp	$L31462
$L31463:

; 4194 : 
; 4195 :    // Add columns to tables.
; 4196 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 4197 :          nRC >= zCURSOR_SET;
; 4198 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31473
$L31474:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31473:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31475

; 4200 :       zBOOL bFirstAlterOfTable;
; 4201 : 
; 4202 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4203 : 
; 4204 :       if ( CompareAttributeToString( vDTE, "TE_TablRec", "MatchFound", "N" ) == 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31477

; 4206 :          // We alread created the table, so continue with the next one.
; 4207 :          continue;

	jmp	SHORT $L31474
$L31477:

; 4209 : 
; 4210 :       bFirstAlterOfTable = TRUE;

	mov	BYTE PTR _bFirstAlterOfTable$31476[ebp], 1

; 4211 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 4212 :             nRC >= zCURSOR_SET;
; 4213 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31478
$L31479:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31478:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31480

; 4215 :          zPCHAR pchMatchFound;
; 4216 : 
; 4217 :          GetAddrForAttribute( &pchMatchFound,
; 4218 :                               vDTE, "TE_FieldDataRel", "MatchFound" );

	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchMatchFound$31481[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 4219 : 
; 4220 :          if ( pchMatchFound[ 0 ] == 'N' )

	mov	ecx, DWORD PTR _pchMatchFound$31481[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 78					; 0000004eH
	jne	$L31493

; 4222 :             zPCHAR pchKeyType;
; 4223 : 
; 4224 :             // Add a blank line to seperate columns from different tables.
; 4225 :             if ( bFirstAlterOfTable )

	mov	eax, DWORD PTR _bFirstAlterOfTable$31476[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L31489

; 4227 :                zCHAR szEntityName[ zZEIDON_NAME_LTH + 1 ];
; 4228 : 
; 4229 :                bFirstAlterOfTable = FALSE;

	mov	BYTE PTR _bFirstAlterOfTable$31476[ebp], 0

; 4230 : 
; 4231 : 			   // KJS 10/16/14 - When I have selected "Keep Physical Characteristics..." for the datasource, and the
; 4232 : 			   // rebuild tables/rels and then "Build Sync DDL", I get to this point and have TE_TablRecs where there
; 4233 : 			   // is no ER_ENTITY. I am not sure why I don't seem to get that when "Keep ..." is not set.
; 4234 : 			   if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) == zCURSOR_SET )

	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31489

; 4236 :                GetStringFromAttribute( szEntityName, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$31485[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4237 : 
; 4238 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31487

; 4239 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31487:

; 4240 : 
; 4241 :                zsprintf( szLine, "%s Entity %s %s",
; 4242 :                          COMMENT_START, szEntityName, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	lea	ecx, DWORD PTR _szEntityName$31485[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 4243 :                if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31489

; 4244 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31489:

; 4247 : 
; 4248 :             GetStringFromAttribute( szColumnName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4249 : 
; 4250 :             zsprintf( szLine, "ALTER TABLE %s " ADD_COLUMN_STMT " ", szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BE@FPJB@ALTER?5TABLE?5?$CFs?5ADD?5?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 4251 :             fnBuildColumn( vDTE, f, szLine );

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildColumn@12

; 4252 :             zstrcat( szLine, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4253 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31491

; 4254 :                goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31491:

; 4255 : 
; 4256 :             // If the attribute is not a rel field try the next one.
; 4257 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 4258 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchKeyType$31483[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 4259 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	ecx, DWORD PTR _pchKeyType$31483[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 82					; 00000052H
	je	SHORT $L31492

; 4260 :                continue;

	jmp	$L31479
$L31492:

; 4261 : 
; 4262 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildFK_Index@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $L31493

; 4263 :                goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31493:

; 4265 : 
; 4266 :       }  // For each TE_FieldDataRel

	jmp	$L31479
$L31480:

; 4267 : 
; 4268 :       #if COMMIT_EVERY_TABLE
; 4269 :          // Commit the table if we altered it.
; 4270 :          if ( bFirstAlterOfTable == FALSE && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4271 :             return( -1 );
; 4272 :       #endif
; 4273 : 
; 4274 :    }  // For each TE_TablRec

	jmp	$L31474
$L31475:

; 4275 : 
; 4276 :    // Drop tables.
; 4277 :    bTableDropped = FALSE;

	mov	BYTE PTR _bTableDropped$[ebp], 0

; 4278 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );
; 4279 :          nRC >= zCURSOR_SET;
; 4280 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31494
$L31495:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31494:
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$L31496

; 4282 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4283 :       RemoveBrackets( szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 4284 : 
; 4285 :       if ( CompareAttributeToString( vDB, "TE_TablRec", "MatchFound", "Y" ) != 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L31497

; 4287 :          zsprintf( szLine, "DROP TABLE %s %s", szTableName,
; 4288 :                    LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BB@MKDI@DROP?5TABLE?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4289 : 
; 4290 :          if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31499

; 4291 :             goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31499:

; 4292 : 
; 4293 :          bTableDropped = TRUE;

	mov	BYTE PTR _bTableDropped$[ebp], 1
$L31497:

; 4295 : 
; 4296 :    }  // For each TE_TablRec

	jmp	$L31495
$L31496:

; 4297 : 
; 4298 :    #if COMMIT_EVERY_TABLE
; 4299 :       if ( bTableDropped && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4300 :          return( -1 );
; 4301 :    #endif
; 4302 : 
; 4303 :    // Drop/alter columns from tables.
; 4304 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );
; 4305 :          nRC >= zCURSOR_SET;
; 4306 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31500
$L31501:
	push	0
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31500:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31502

; 4308 :       zBOOL bFirstAlterForTable;
; 4309 : 
; 4310 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4311 :       RemoveBrackets( szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 4312 : 
; 4313 :       if ( CompareAttributeToString( vDB, "TE_TablRec", "MatchFound", "Y" ) != 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $L31504

; 4315 :          // Table deleted, go on to next one.
; 4316 :          continue;

	jmp	SHORT $L31501
$L31504:

; 4318 : 
; 4319 :       // Set the cursor in the TE to match the one in the DB.
; 4320 :       SetCursorFirstEntityByAttr( vDTE, "TE_TablRec", "Name",
; 4321 :                                   vDB,  "TE_TablRec", "Name", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28

; 4322 : 
; 4323 :       GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET FLAT:??_C@_0P@CNMG@SQL_TableOwner?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 4324 :       if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	jne	SHORT $L31505
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $L31505

; 4325 :          zstrcpy( szOwner, pchDefaultOwner );

	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$L31505:

; 4326 : 
; 4327 :       if ( szOwner[ 0 ] )

	movsx	ecx, BYTE PTR _szOwner$[ebp]
	test	ecx, ecx
	je	SHORT $L31506

; 4328 :          zstrcat( szOwner, "." );

	push	OFFSET FLAT:??_C@_01PJCK@?4?$AA@	; `string'
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$L31506:

; 4329 : 
; 4330 :       bFirstAlterForTable = TRUE;

	mov	BYTE PTR _bFirstAlterForTable$31503[ebp], 1

; 4331 :       for ( nRC = SetCursorFirstEntity( vDB, "TE_FieldDataRel", 0 );
; 4332 :             nRC >= zCURSOR_SET;
; 4333 :             nRC = SetCursorNextEntity( vDB, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31507
$L31508:
	push	0
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31507:
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$L31509

; 4335 :          zSHORT nIndexDroppedCount;
; 4336 : 
; 4337 :          // If a match was found for the column, we don't need to do anything.
; 4338 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 4339 :                                         "MatchFound", "Y" ) == 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31511

; 4341 :             continue;

	jmp	SHORT $L31508
$L31511:

; 4343 : 
; 4344 :          // Print out a comment if this is the first ALTER for the current
; 4345 :          // table.
; 4346 :          if ( bFirstAlterForTable )

	mov	edx, DWORD PTR _bFirstAlterForTable$31503[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	$L31515

; 4348 :             zCHAR szEntityName[ zZEIDON_NAME_LTH + 1 ];
; 4349 : 
; 4350 :             bFirstAlterForTable = FALSE;

	mov	BYTE PTR _bFirstAlterForTable$31503[ebp], 0

; 4351 :             GetStringFromAttribute( szEntityName, vDTE, "ER_Entity", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09CNO@ER_Entity?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$31513[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4352 : 
; 4353 :             if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31514

; 4354 :                goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31514:

; 4355 : 
; 4356 :             zsprintf( szLine, "%s Entity %s %s",
; 4357 :                       COMMENT_START, szEntityName, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	lea	ecx, DWORD PTR _szEntityName$31513[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@LFLL@?$CFs?5Entity?5?$CFs?5?$CFs?$AA@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 4358 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31515

; 4359 :                goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31515:

; 4361 : 
; 4362 :          GetStringFromAttribute( szColumnName, vDB, "TE_FieldDataRel", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4363 : 
; 4364 :          // Check to see if there is an index on the column.  If there is,
; 4365 :          // then we need to drop it.
; 4366 :          nIndexDroppedCount = 0;

	mov	WORD PTR _nIndexDroppedCount$31510[ebp], 0

; 4367 :          for ( nRC = SetCursorFirstEntityByString( vDB, "TE_FieldDataRelKey",
; 4368 :                                                    "Name", szColumnName,
; 4369 :                                                    "TE_TablRec" );
; 4370 :                nRC >= zCURSOR_SET;
; 4371 :                nRC = SetCursorNextEntityByString( vDB, "TE_FieldDataRelKey",
; 4372 :                                                   "Name", szColumnName,
; 4373 :                                                   "TE_TablRec" ) )

	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31516
$L31517:
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorNextEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
$L31516:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $L31518

; 4375 :             zCHAR szIndex[ MAX_TABLENAME_LTH + 1 ];
; 4376 : 
; 4377 :             GetStringFromAttribute( szIndex, vDB, "TE_TablRecKey", "IndexName" );

	push	OFFSET FLAT:??_C@_09CEBI@IndexName?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@LKEB@TE_TablRecKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szIndex$31519[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4378 :             fnBuildDropIndex( vDB, szIndex, szOwner, szTableName, f );

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	lea	eax, DWORD PTR _szIndex$31519[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_fnBuildDropIndex@20

; 4379 :             nIndexDroppedCount++;

	mov	dx, WORD PTR _nIndexDroppedCount$31510[ebp]
	add	dx, 1
	mov	WORD PTR _nIndexDroppedCount$31510[ebp], dx

; 4380 :          }

	jmp	SHORT $L31517
$L31518:

; 4381 : 
; 4382 :          // Check to see if the column needs to be altered or dropped.
; 4383 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 4384 :                                         "MatchFound", "N" ) == 0 )

	push	OFFSET FLAT:??_C@_01OAK@N?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31520

; 4386 :             // Drop the column.
; 4387 :             zsprintf( szLine, "ALTER TABLE %s%s " DROP_COLUMN_STMT " %s %s",
; 4388 :                       szOwner, szTableName, szColumnName, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0CD@OHJM@ALTER?5TABLE?5?$CFs?$CFs?5DROP?5COLUMN?5?$CFs?5@ ; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf
	add	esp, 24					; 00000018H

; 4389 : 
; 4390 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31522

; 4391 :                goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31522:

; 4393 :          else

	jmp	$L31542
$L31520:

; 4394 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 4395 :                                         "MatchFound", "D" ) == 0 )

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@FFM@MatchFound?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	$L31542

; 4397 :             zPCHAR pchKeyType;
; 4398 : 
; 4399 :             // Alter the column to match the datatype in the TE.
; 4400 :             zsprintf( szLine, "ALTER TABLE %s%-*s ALTER COLUMN ",
; 4401 :                       szOwner, (int) MAX_TABLENAME_LTH, szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	64					; 00000040H
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_0CB@MGNG@ALTER?5TABLE?5?$CFs?$CF?9?$CKs?5ALTER?5COLUMN?5@ ; `string'
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__sprintf
	add	esp, 20					; 00000014H

; 4402 : 
; 4403 :             fnBuildColumn( vDB, f, szLine );

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_fnBuildColumn@12

; 4404 :             zstrcat( szLine, LINE_TERMINATOR );

	push	OFFSET FLAT:??_C@_01FAJB@?$DL?$AA@	; `string'
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4405 : 
; 4406 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31528

; 4407 :                goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31528:

; 4408 : 
; 4409 :             // Check to see if we need to re-create any indexes.
; 4410 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",
; 4411 :                                  "DataOrRelfieldOrSet" );

	push	OFFSET FLAT:??_C@_0BE@ODFA@DataOrRelfieldOrSet?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$31525[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4412 :             if ( pchKeyType[ 0 ] == 'R' )

	mov	edx, DWORD PTR _pchKeyType$31525[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 82					; 00000052H
	jne	SHORT $L31529

; 4414 :                if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildFK_Index@8
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31530

; 4415 :                  goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31530:

; 4416 : 
; 4417 :                // We re-created one of the indexes dropped earlier so decrement
; 4418 :                // count so we'll know if we recreated all the indexes.
; 4419 :                nIndexDroppedCount--;

	mov	cx, WORD PTR _nIndexDroppedCount$31510[ebp]
	sub	cx, 1
	mov	WORD PTR _nIndexDroppedCount$31510[ebp], cx
$L31529:

; 4421 : 
; 4422 :             // If no more indexes need to be recreated, go on to the next col.
; 4423 :             if ( nIndexDroppedCount == 0 )

	movsx	edx, WORD PTR _nIndexDroppedCount$31510[ebp]
	test	edx, edx
	jne	SHORT $L31531

; 4424 :                continue;

	jmp	$L31508
$L31531:

; 4425 : 
; 4426 :             // Check to see if the column we altered is contained in the list of
; 4427 :             // identifiers for the table.  If it is we need to recreate
; 4428 :             // the indexes that were dropped above.
; 4429 :             for ( nRC = SetCursorFirstEntityByString( vDTE, "TE_FieldDataRelKey",
; 4430 :                                                       "Name", szColumnName,
; 4431 :                                                       "TE_TablRec" );
; 4432 : 
; 4433 :                   nRC >= zCURSOR_SET;
; 4434 :                   nRC = SetCursorNextEntityByString( vDTE, "TE_FieldDataRelKey",
; 4435 :                                                      "Name", szColumnName,
; 4436 :                                                       "TE_TablRec" ) )

	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31532
$L31533:
	push	OFFSET FLAT:??_C@_0L@NCMM@TE_TablRec?$AA@ ; `string'
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BD@EGMP@TE_FieldDataRelKey?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
$L31532:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $L31534

; 4438 :                if ( fnBuildIndexFromTablRecKey( vDTE, FALSE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildIndexFromTablRecKey@12
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $L31535

; 4439 :                   goto EndOfFunction;

	jmp	$EndOfFunction$31415
$L31535:

; 4440 : 
; 4441 :                // We re-created one of the indexes dropped earlier so decrement
; 4442 :                // count so we'll know if we recreated all the indexes.
; 4443 :                nIndexDroppedCount--;

	mov	dx, WORD PTR _nIndexDroppedCount$31510[ebp]
	sub	dx, 1
	mov	WORD PTR _nIndexDroppedCount$31510[ebp], dx

; 4444 :             }

	jmp	SHORT $L31533
$L31534:

; 4445 : 
; 4446 :             if ( nIndexDroppedCount )

	movsx	eax, WORD PTR _nIndexDroppedCount$31510[ebp]
	test	eax, eax
	je	$L31542

; 4448 :                zCHAR szMsg[ 1000 ];
; 4449 : 
; 4450 :                // An index has been dropped for this column because it has been
; 4451 :                // modified but it is not a FK so we don't normally create an
; 4452 :                // index on it.  We'll display a warning and try to create an
; 4453 :                // index for the column.
; 4454 :                zsprintf( szMsg, "WARNING: The data type for the column %s.%s "
; 4455 :                          "has been changed and therefore had an index deleted.  "
; 4456 :                          "The column is NOT a key and therefore the index was "
; 4457 :                          "added by the DBA.  An attempt has been made to "
; 4458 :                          "recreate the index in the DDL.  Look for 'WARNING' "
; 4459 :                          "in the DDL file",
; 4460 :                          szTableName, szColumnName );

	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0BAI@KIFF@WARNING?3?5The?5data?5type?5for?5the?5c@ ; `string'
	lea	eax, DWORD PTR _szMsg$31537[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4461 :                SysMessageBox( vDTE, "DDL Generationg Warning", szMsg, 0 );

	push	0
	lea	ecx, DWORD PTR _szMsg$31537[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_0BI@HFPH@DDL?5Generationg?5Warning?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysMessageBox@16

; 4462 : 
; 4463 :                zsprintf( szMsg, "%s WARNING--Following index may not have the "
; 4464 :                          " same the columns as the original index: %s",
; 4465 :                          COMMENT_START, COMMENT_END );

	push	OFFSET FLAT:??_C@_02BOOO@?$CK?1?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02FCCF@?1?$CK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0FJ@KCOE@?$CFs?5WARNING?9?9Following?5index?5may?5@ ; `string'
	lea	eax, DWORD PTR _szMsg$31537[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 16					; 00000010H

; 4466 :                if ( fnWriteLine( vDTE, f, szMsg ) < 0 )

	lea	ecx, DWORD PTR _szMsg$31537[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $L31541

; 4467 :                   goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31415
$L31541:

; 4468 : 
; 4469 :                if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildFK_Index@8
	movsx	eax, ax
	cmp	eax, -1
	jne	SHORT $L31542

; 4470 :                  goto EndOfFunction;

	jmp	SHORT $EndOfFunction$31415
$L31542:

; 4473 : 
; 4474 :       }  // For each TE_FieldDataRel

	jmp	$L31508
$L31509:

; 4475 : 
; 4476 :       #if COMMIT_EVERY_TABLE
; 4477 :          // Commit the table if we altered it.
; 4478 :          if ( bFirstAlterForTable == FALSE && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4479 :             return( -1 );
; 4480 :       #endif
; 4481 : 
; 4482 :    }  // For each TE_TablRec

	jmp	$L31501
$L31502:

; 4483 : 
; 4484 :    // If we get here, then everything's ok.
; 4485 :    nReturn = 0;

	mov	WORD PTR _nReturn$[ebp], 0
$EndOfFunction$31415:

; 4486 : 
; 4487 : EndOfFunction:
; 4488 :    if ( f >= 0 )

	cmp	DWORD PTR _f$[ebp], 0
	jl	SHORT $L31543

; 4489 :       SysCloseFile( vSubtask, f, 0 );

	push	0
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysCloseFile@12
$L31543:

; 4490 : 
; 4491 :    // Drop the view copies.
; 4492 :    DropView( vDTE );

	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_DropView@4

; 4493 :    DropView( vEMD );

	mov	ecx, DWORD PTR _vEMD$[ebp]
	push	ecx
	call	_DropView@4

; 4494 : 
; 4495 :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$L31382:

; 4496 : 
; 4497 : } // BuildSyncDDL

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_BuildSyncDDL@20 ENDP
_TEXT	ENDS
PUBLIC	_LoadDataTypes@4
PUBLIC	??_C@_0N@INLJ@DB_DataTypes?$AA@			; `string'
PUBLIC	??_C@_01PDAJ@S?$AA@				; `string'
PUBLIC	??_C@_0N@CCA@InternalName?$AA@			; `string'
PUBLIC	??_C@_06PINC@String?$AA@			; `string'
PUBLIC	??_C@_0N@NAC@ExternalName?$AA@			; `string'
PUBLIC	??_C@_01FLCE@L?$AA@				; `string'
PUBLIC	??_C@_07HDOI@Integer?$AA@			; `string'
PUBLIC	??_C@_01PBLD@M?$AA@				; `string'
PUBLIC	??_C@_07DBJI@Decimal?$AA@			; `string'
PUBLIC	??_C@_01KGOM@T?$AA@				; `string'
PUBLIC	??_C@_09KMOL@Timestamp?$AA@			; `string'
PUBLIC	??_C@_01FIAI@X?$AA@				; `string'
PUBLIC	??_C@_0M@BADB@TimeStampEx?$AA@			; `string'
PUBLIC	??_C@_04OMLL@Date?$AA@				; `string'
PUBLIC	??_C@_01FLOP@I?$AA@				; `string'
PUBLIC	??_C@_04OAHI@Time?$AA@				; `string'
PUBLIC	??_C@_01FKLC@F?$AA@				; `string'
PUBLIC	??_C@_09GOGB@FixedChar?$AA@			; `string'
PUBLIC	??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@	; `string'
PUBLIC	??_C@_01PDMC@V?$AA@				; `string'
PUBLIC	??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@	; `string'
PUBLIC	??_C@_01PFH@A?$AA@				; `string'
PUBLIC	??_C@_0BH@NNJD@SERIAL?5?$CIautoincrement?$CJ?$AA@ ; `string'
EXTRN	_CreateEntity@12:NEAR
;	COMDAT ??_C@_0N@INLJ@DB_DataTypes?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0N@INLJ@DB_DataTypes?$AA@ DB 'DB_DataTypes', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PDAJ@S?$AA@
_DATA	SEGMENT
??_C@_01PDAJ@S?$AA@ DB 'S', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CCA@InternalName?$AA@
_DATA	SEGMENT
??_C@_0N@CCA@InternalName?$AA@ DB 'InternalName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PINC@String?$AA@
_DATA	SEGMENT
??_C@_06PINC@String?$AA@ DB 'String', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NAC@ExternalName?$AA@
_DATA	SEGMENT
??_C@_0N@NAC@ExternalName?$AA@ DB 'ExternalName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FLCE@L?$AA@
_DATA	SEGMENT
??_C@_01FLCE@L?$AA@ DB 'L', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_07HDOI@Integer?$AA@
_DATA	SEGMENT
??_C@_07HDOI@Integer?$AA@ DB 'Integer', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PBLD@M?$AA@
_DATA	SEGMENT
??_C@_01PBLD@M?$AA@ DB 'M', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_07DBJI@Decimal?$AA@
_DATA	SEGMENT
??_C@_07DBJI@Decimal?$AA@ DB 'Decimal', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01KGOM@T?$AA@
_DATA	SEGMENT
??_C@_01KGOM@T?$AA@ DB 'T', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09KMOL@Timestamp?$AA@
_DATA	SEGMENT
??_C@_09KMOL@Timestamp?$AA@ DB 'Timestamp', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FIAI@X?$AA@
_DATA	SEGMENT
??_C@_01FIAI@X?$AA@ DB 'X', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@BADB@TimeStampEx?$AA@
_DATA	SEGMENT
??_C@_0M@BADB@TimeStampEx?$AA@ DB 'TimeStampEx', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OMLL@Date?$AA@
_DATA	SEGMENT
??_C@_04OMLL@Date?$AA@ DB 'Date', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FLOP@I?$AA@
_DATA	SEGMENT
??_C@_01FLOP@I?$AA@ DB 'I', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_04OAHI@Time?$AA@
_DATA	SEGMENT
??_C@_04OAHI@Time?$AA@ DB 'Time', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_01FKLC@F?$AA@
_DATA	SEGMENT
??_C@_01FKLC@F?$AA@ DB 'F', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09GOGB@FixedChar?$AA@
_DATA	SEGMENT
??_C@_09GOGB@FixedChar?$AA@ DB 'FixedChar', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@ DB 'Blob (longblob)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PDMC@V?$AA@
_DATA	SEGMENT
??_C@_01PDMC@V?$AA@ DB 'V', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@ DB 'Text (longtext)', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_01PFH@A?$AA@
_DATA	SEGMENT
??_C@_01PFH@A?$AA@ DB 'A', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BH@NNJD@SERIAL?5?$CIautoincrement?$CJ?$AA@
_DATA	SEGMENT
??_C@_0BH@NNJD@SERIAL?5?$CIautoincrement?$CJ?$AA@ DB 'SERIAL (autoincreme'
	DB	'nt)', 00H					; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vType$ = 8
_LoadDataTypes@4 PROC NEAR

; 4501 : {

	push	ebp
	mov	ebp, esp

; 4502 :    //
; 4503 :    // Following are standard types.
; 4504 :    //
; 4505 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4506 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "S" );

	push	OFFSET FLAT:??_C@_01PDAJ@S?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4507 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4508 :                            "String" );

	push	OFFSET FLAT:??_C@_06PINC@String?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4509 : 
; 4510 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4511 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "L" );

	push	OFFSET FLAT:??_C@_01FLCE@L?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4512 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4513 :                            "Integer" );

	push	OFFSET FLAT:??_C@_07HDOI@Integer?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4514 : 
; 4515 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4516 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "M" );

	push	OFFSET FLAT:??_C@_01PBLD@M?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4517 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4518 :                            "Decimal" );

	push	OFFSET FLAT:??_C@_07DBJI@Decimal?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4519 : 
; 4520 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4521 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );

	push	OFFSET FLAT:??_C@_01KGOM@T?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4522 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4523 :                            "Timestamp" );

	push	OFFSET FLAT:??_C@_09KMOL@Timestamp?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4524 : 
; 4525 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4526 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "X" );

	push	OFFSET FLAT:??_C@_01FIAI@X?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4527 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4528 :                            "TimeStampEx" );

	push	OFFSET FLAT:??_C@_0M@BADB@TimeStampEx?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4529 : 
; 4530 : #if defined( SQLSERVER ) && !defined( QUINSOFT )
; 4531 :    /*
; 4532 :    ** The ODBC-driver for SqlServer doesn't support SQL_DATE and SQL_TIME
; 4533 :    */
; 4534 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4535 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );
; 4536 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Date" );
; 4537 : 
; 4538 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4539 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );
; 4540 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Time" );
; 4541 : #else
; 4542 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4543 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4544 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Date" );

	push	OFFSET FLAT:??_C@_04OMLL@Date?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4545 : 
; 4546 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4547 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "I" );

	push	OFFSET FLAT:??_C@_01FLOP@I?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4548 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Time" );

	push	OFFSET FLAT:??_C@_04OAHI@Time?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4549 : #endif
; 4550 : 
; 4551 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4552 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "F" );

	push	OFFSET FLAT:??_C@_01FKLC@F?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4553 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "FixedChar" );

	push	OFFSET FLAT:??_C@_09GOGB@FixedChar?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4554 : 
; 4555 : #if defined( ACCESS )
; 4556 : 
; 4557 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4558 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4559 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4560 :                            "Blob (Memo)" );     // Blob name.
; 4561 : 
; 4562 :    //
; 4563 :    // Following are DB-specific types.
; 4564 :    //
; 4565 : 
; 4566 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4567 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4568 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Memo" );
; 4569 : 
; 4570 : #elif defined( DB2 )
; 4571 : 
; 4572 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4573 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4574 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Blob" );
; 4575 : 
; 4576 :    //
; 4577 :    // Following are DB-specific types.
; 4578 :    //
; 4579 : 
; 4580 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4581 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4582 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "CLOB" );
; 4583 : 
; 4584 : #elif defined( SQLBASE ) || defined( ODBC )
; 4585 : 
; 4586 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4587 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4588 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4589 :                            "Blob (VarChar)" );     // Blob name.
; 4590 : 
; 4591 :    //
; 4592 :    // Following are DB-specific types.
; 4593 :    //
; 4594 : 
; 4595 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4596 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4597 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "VarChar" );
; 4598 : 
; 4599 : #elif defined( MYSQL )
; 4600 : 
; 4601 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4602 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );

	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4603 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4604 :                            "Blob (longblob)" );       // Blob name.

	push	OFFSET FLAT:??_C@_0BA@IMGI@Blob?5?$CIlongblob?$CJ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4605 : 
; 4606 :    //
; 4607 :    // Following are DB-specific types.
; 4608 :    //
; 4609 : 
; 4610 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4611 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );

	push	OFFSET FLAT:??_C@_01PDMC@V?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4612 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Text (longtext)" );

	push	OFFSET FLAT:??_C@_0BA@NGGL@Text?5?$CIlongtext?$CJ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4613 : 
; 4614 :    // Create a data type that will be autoincrement in MySql
; 4615 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4616 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "A" );

	push	OFFSET FLAT:??_C@_01PFH@A?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0N@CCA@InternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4617 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4618 :                            "SERIAL (autoincrement)" );

	push	OFFSET FLAT:??_C@_0BH@NNJD@SERIAL?5?$CIautoincrement?$CJ?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@NAC@ExternalName?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0N@INLJ@DB_DataTypes?$AA@ ; `string'
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4619 : 
; 4620 : #elif defined( POSTGRESQL ) || defined( SQLSERVER )
; 4621 : 
; 4622 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4623 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4624 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4625 :                            "Blob (bytea)" );       // Blob name.
; 4626 : 
; 4627 :    //
; 4628 :    // Following are DB-specific types.
; 4629 :    //
; 4630 : 
; 4631 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4632 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4633 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Text" );
; 4634 : 
; 4635 : #endif
; 4636 : 
; 4637 :    return( 0 );

	xor	ax, ax

; 4638 : 
; 4639 : } // LoadDataTypes

	pop	ebp
	ret	4
_LoadDataTypes@4 ENDP
_TEXT	ENDS
PUBLIC	_SetDataType@8
PUBLIC	??_C@_06CDGA@Domain?$AA@			; `string'
PUBLIC	??_C@_0N@CMME@GeneratedKey?$AA@			; `string'
PUBLIC	??_C@_03LBCJ@Lth?$AA@				; `string'
PUBLIC	??_C@_0N@IKDH@ER_Attribute?$AA@			; `string'
PUBLIC	??_C@_0N@FPPC@MaxStringLth?$AA@			; `string'
PUBLIC	??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@ ; `string'
PUBLIC	??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@ ; `string'
PUBLIC	??_C@_09PLDP@Zeidon?5TE?$AA@			; `string'
EXTRN	_SetAttributeFromInteger@16:NEAR
EXTRN	_SetAttributeFromAttribute@24:NEAR
EXTRN	_TraceLineS@8:NEAR
EXTRN	__imp___stricmp:NEAR
;	COMDAT ??_C@_06CDGA@Domain?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_06CDGA@Domain?$AA@ DB 'Domain', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@CMME@GeneratedKey?$AA@
_DATA	SEGMENT
??_C@_0N@CMME@GeneratedKey?$AA@ DB 'GeneratedKey', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_03LBCJ@Lth?$AA@
_DATA	SEGMENT
??_C@_03LBCJ@Lth?$AA@ DB 'Lth', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@IKDH@ER_Attribute?$AA@
_DATA	SEGMENT
??_C@_0N@IKDH@ER_Attribute?$AA@ DB 'ER_Attribute', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@FPPC@MaxStringLth?$AA@
_DATA	SEGMENT
??_C@_0N@FPPC@MaxStringLth?$AA@ DB 'MaxStringLth', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@
_DATA	SEGMENT
??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@ DB '(TE) Inva'
	DB	'lid Physical Data type = ', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@
_DATA	SEGMENT
??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@ DB 'Invalid Physical '
	DB	'Data type.', 00H				; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PLDP@Zeidon?5TE?$AA@
_DATA	SEGMENT
??_C@_09PLDP@Zeidon?5TE?$AA@ DB 'Zeidon TE', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_bSetDefault$ = 12
_pchDataType$ = -8
_lLth$ = -4
_bTimestampAsString$ = -12
_pchDomainName$31592 = -16
_vTZTEDBLO$31593 = -20
_vTZDBHODO$31594 = -28
_vDBH_Data$31595 = -24
_szDBH_DataObjectName$31596 = -64
_SetDataType@8 PROC NEAR

; 4661 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 4662 :    zPCHAR pchDataType;
; 4663 :    zLONG  lLth;
; 4664 :    zBOOL  bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0

; 4665 : 
; 4666 :    if ( bSetDefault )

	mov	eax, DWORD PTR _bSetDefault$[ebp]
	and	eax, 255				; 000000ffH
	test	eax, eax
	je	$L31613

; 4668 :       zPCHAR pchDomainName;
; 4669 :       zVIEW  vTZTEDBLO;
; 4670 :       zVIEW  vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$31594[ebp], 0

; 4671 :       zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$31595[ebp], 0

; 4672 :       zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 4673 : 
; 4674 :       // If it exists get the object that defines the dbhandler type.
; 4675 :       GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );  // vDTE added dks 2009.11.11

	push	2
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08IAKB@TZTEDBLO?$AA@	; `string'
	lea	edx, DWORD PTR _vTZTEDBLO$31593[ebp]
	push	edx
	call	_GetViewByName@16

; 4676 :       if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$31593[ebp], 0
	je	SHORT $L31597

; 4677 :          SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",
; 4678 :                                      vDTE,      "TE_DBMS_Source", "DBMS", 0 );

	push	0
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_04EALC@DBMS?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$31593[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
$L31597:

; 4679 : 
; 4680 :       // Try to get the OI that contains DBH-specific data.
; 4681 :       SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 4682 :                       "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDBH_DataObjectName$31596[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDBH_Data$31595[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 4683 : 
; 4684 :       #if defined( ACCESS ) || defined( ODBC )
; 4685 : 
; 4686 :          // Try to get the ODBC definition.
; 4687 :          SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,
; 4688 :                          "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 4689 : 
; 4690 :          // Check to see if there is DBH data set in the TE.
; 4691 :          if ( vDBH_Data )
; 4692 :          {
; 4693 :             bTimestampAsString =
; 4694 :                          ( CompareAttributeToString( vDBH_Data, "ODBC",
; 4695 :                                                      "TimestampAsString",
; 4696 :                                                      "Y" ) == 0 );
; 4697 :          }
; 4698 :          else
; 4699 :          // Check to see if there is DBH data set in the DB List object.
; 4700 :          if ( vTZDBHODO )
; 4701 :          {
; 4702 :                bTimestampAsString =
; 4703 :                          ( CompareAttributeToString( vTZDBHODO, "ODBC",
; 4704 :                                                      "TimestampAsString",
; 4705 :                                                      "Y" ) == 0 );
; 4706 :          }
; 4707 : 
; 4708 :       #endif
; 4709 : 
; 4710 :       // Set the default data type from the ER attribute domain.  If the
; 4711 :       // domain name is "Date" or "Time" then use SqlBase date/time types.
; 4712 :       GetAddrForAttribute( &pchDomainName, vDTE, "Domain", "Name" );

	push	OFFSET FLAT:??_C@_04EFNI@Name?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDomainName$31592[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4713 : 
; 4714 : #if defined( SQLSERVER ) && !defined( QUINSOFT )
; 4715 :       if ( zstrcmpi( pchDomainName, "Date" ) == 0 ||
; 4716 :            zstrcmpi( pchDomainName, "Time" ) == 0 )
; 4717 :       {
; 4718 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "T" );
; 4719 :       }
; 4720 :       else
; 4721 :       if ( zstrcmpi( pchDomainName, "TimeStampEx" ) == 0 )
; 4722 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "X" );
; 4723 :       else
; 4724 :          // Domain is not Date or Time, so just set the default data type the
; 4725 :          // same as the domain's data type.
; 4726 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "DataType",
; 4727 :                                     vDTE, "Domain", "DataType" );
; 4728 : #else
; 4729 :       if ( zstrcmpi( pchDomainName, "Date" ) == 0 )

	push	OFFSET FLAT:??_C@_04OMLL@Date?$AA@	; `string'
	mov	edx, DWORD PTR _pchDomainName$31592[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L31599

; 4730 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "D" );

	push	OFFSET FLAT:??_C@_01PJM@D?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4731 :       else

	jmp	$L31607
$L31599:

; 4732 :       if ( zstrcmpi( pchDomainName, "Time" ) == 0 )

	push	OFFSET FLAT:??_C@_04OAHI@Time?$AA@	; `string'
	mov	ecx, DWORD PTR _pchDomainName$31592[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L31601

; 4733 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "I" );

	push	OFFSET FLAT:??_C@_01FLOP@I?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4734 :       else

	jmp	$L31607
$L31601:

; 4735 :       if ( zstrcmpi( pchDomainName, "TimeStampEx" ) == 0 )

	push	OFFSET FLAT:??_C@_0M@BADB@TimeStampEx?$AA@ ; `string'
	mov	eax, DWORD PTR _pchDomainName$31592[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L31603

; 4736 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "X" );

	push	OFFSET FLAT:??_C@_01FIAI@X?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4737 : #if defined( MYSQL )
; 4738 :       else

	jmp	SHORT $L31607
$L31603:

; 4739 :       // If domain is GeneratedKey then use "SERIAL" for default datatype.
; 4740 :       if ( zstrcmpi( pchDomainName, "GeneratedKey" ) == 0 )

	push	OFFSET FLAT:??_C@_0N@CMME@GeneratedKey?$AA@ ; `string'
	mov	edx, DWORD PTR _pchDomainName$31592[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $L31605

; 4742 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "A" );

	push	OFFSET FLAT:??_C@_01PFH@A?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4744 : #endif
; 4745 :       else

	jmp	SHORT $L31607
$L31605:

; 4746 :          // Domain is not Date or Time, so just set the default data type the
; 4747 :          // same as the domain's data type.
; 4748 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "DataType",
; 4749 :                                     vDTE, "Domain", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24
$L31607:

; 4750 : #endif
; 4751 : 
; 4752 :       // Strings with a length > 254 must have a data type of VarChar.
; 4753 :       GetAddrForAttribute( &pchDataType, vDTE, "Domain", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDataType$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4754 :       if ( pchDataType[ 0 ] == zTYPE_STRING )

	mov	edx, DWORD PTR _pchDataType$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 83					; 00000053H
	jne	SHORT $L31613

; 4756 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 4757 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31611

; 4758 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET FLAT:??_C@_0N@FPPC@MaxStringLth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lLth$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
$L31611:

; 4759 : 
; 4760 :          if ( lLth > MAX_LTH_FOR_STRING )

	cmp	DWORD PTR _lLth$[ebp], 254		; 000000feH
	jle	SHORT $L31613

; 4761 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "V" );

	push	OFFSET FLAT:??_C@_01PDMC@V?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$L31613:

; 4770 : 
; 4771 :    // Get the data type.
; 4772 :    GetAddrForAttribute( &pchDataType, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDataType$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4773 : 
; 4774 :    // Now set the length according to the physical data type.
; 4775 :    switch ( pchDataType[ 0 ] )
; 4776 :    {

	mov	edx, DWORD PTR _pchDataType$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR -68+[ebp], eax
	mov	ecx, DWORD PTR -68+[ebp]
	sub	ecx, 65					; 00000041H
	mov	DWORD PTR -68+[ebp], ecx
	cmp	DWORD PTR -68+[ebp], 23			; 00000017H
	ja	$L31638
	mov	eax, DWORD PTR -68+[ebp]
	xor	edx, edx
	mov	dl, BYTE PTR $L32357[eax]
	jmp	DWORD PTR $L32358[edx*4]
$L31618:

; 4777 : 
; 4778 :       case zTYPE_STRING:
; 4779 :       case 'V':
; 4780 :       case zTYPE_FIXEDCHAR:
; 4781 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 4782 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31619

; 4783 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET FLAT:??_C@_0N@FPPC@MaxStringLth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lLth$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
$L31619:

; 4784 : 
; 4785 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );

	mov	edx, DWORD PTR _lLth$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4786 :          break;

	jmp	$L31615
$L31620:

; 4787 : 
; 4788 :       case zTYPE_BLOB:
; 4789 : 
; 4790 : #if defined( DB2 )
; 4791 :          // DB2 needs a blob length.
; 4792 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );
; 4793 :          if ( lLth == 0  )
; 4794 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );
; 4795 : 
; 4796 :          if ( lLth == 0  )
; 4797 :             lLth = 65536;   // Default length for blobs.
; 4798 : 
; 4799 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );
; 4800 : #else
; 4801 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "Length",
; 4802 :                                     vDTE, "ER_Attribute",    "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 4803 : #endif
; 4804 : 
; 4805 :          break;

	jmp	$L31615
$L31621:

; 4806 : 
; 4807 :       case zTYPE_INTEGER:
; 4808 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4809 :          break;

	jmp	$L31615
$L31622:

; 4810 : 
; 4811 :       case 'A':                // For SERIAL/AUTOINCREMENT
; 4812 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 64 );

	push	64					; 00000040H
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4813 :          break;

	jmp	$L31615
$L31623:

; 4814 : 
; 4815 :       case zTYPE_DECIMAL:
; 4816 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET FLAT:??_C@_03LBCJ@Lth?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@IKDH@ER_Attribute?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _lLth$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 4817 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31625

; 4819 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET FLAT:??_C@_0N@FPPC@MaxStringLth?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06CDGA@Domain?$AA@	; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 4820 :             if ( lLth == 0 )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $L31625

; 4821 :                lLth = sizeof( zDECIMAL );

	mov	DWORD PTR _lLth$[ebp], 40		; 00000028H
$L31625:

; 4823 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );

	mov	eax, DWORD PTR _lLth$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4824 :          break;

	jmp	$L31615
$L31627:

; 4825 : 
; 4826 :       case zTYPE_DATETIME:
; 4827 :       case zTYPE_TIME:
; 4828 :          if ( bTimestampAsString )

	mov	edx, DWORD PTR _bTimestampAsString$[ebp]
	and	edx, 255				; 000000ffH
	test	edx, edx
	je	SHORT $L31628

; 4830 :             // This is only true when we are setting the default value of the
; 4831 :             // data type.  Change the datatype to be a string.
; 4832 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "S" );

	push	OFFSET FLAT:??_C@_01PDAJ@S?$AA@		; `string'
	push	OFFSET FLAT:??_C@_08FNON@DataType?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4833 :             SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 25 );

	push	25					; 00000019H
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4835 :          else

	jmp	SHORT $L31631
$L31628:

; 4837 :             switch ( pchDataType[ 0 ] )
; 4838 :             {

	mov	edx, DWORD PTR _pchDataType$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR -72+[ebp], al
	cmp	BYTE PTR -72+[ebp], 73			; 00000049H
	je	SHORT $L31635
	cmp	BYTE PTR -72+[ebp], 84			; 00000054H
	je	SHORT $L31634
	jmp	SHORT $L31631
$L31634:

; 4839 :                case zTYPE_DATETIME:
; 4840 :                   SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4841 :                   break;

	jmp	SHORT $L31631
$L31635:

; 4842 : 
; 4843 :                case zTYPE_TIME:
; 4844 :                   SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 8 );

	push	8
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16
$L31631:

; 4848 : 
; 4849 :          break;

	jmp	SHORT $L31615
$L31636:

; 4850 : 
; 4851 :       case zTYPE_DATE:
; 4852 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4853 :          break;

	jmp	SHORT $L31615
$L31637:

; 4854 : 
; 4855 :       case 'X':
; 4856 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 30 );

	push	30					; 0000001eH
	push	OFFSET FLAT:??_C@_06CAAP@Length?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BA@PJGE@TE_FieldDataRel?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4857 :          break;

	jmp	SHORT $L31615
$L31638:

; 4858 : 
; 4859 :       default:
; 4860 :          TraceLineS( "(TE) Invalid Physical Data type = ", pchDataType );

	mov	edx, DWORD PTR _pchDataType$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0CD@CCFO@?$CITE?$CJ?5Invalid?5Physical?5Data?5type?5@ ; `string'
	call	_TraceLineS@8

; 4861 :          SysMessageBox( vDTE, "Zeidon TE", "Invalid Physical Data type.", 1 );

	push	1
	push	OFFSET FLAT:??_C@_0BM@EEGE@Invalid?5Physical?5Data?5type?4?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09PLDP@Zeidon?5TE?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16

; 4862 :          return( 0 );

	xor	ax, ax
	jmp	SHORT $L31587
$L31615:

; 4864 : 
; 4865 :    return( 0 );

	xor	ax, ax
$L31587:

; 4866 : 
; 4867 : } // SetDataType

	mov	esp, ebp
	pop	ebp
	ret	8
$L32358:
	DD	$L31622
	DD	$L31620
	DD	$L31636
	DD	$L31618
	DD	$L31627
	DD	$L31621
	DD	$L31623
	DD	$L31637
	DD	$L31638
$L32357:
	DB	0
	DB	1
	DB	8
	DB	2
	DB	8
	DB	3
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	5
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	4
	DB	8
	DB	3
	DB	8
	DB	7
_SetDataType@8 ENDP
_TEXT	ENDS
PUBLIC	_fnChangeReservedName@4
PUBLIC	??_C@_02IALC@z_?$AA@				; `string'
;	COMDAT ??_C@_02IALC@z_?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_02IALC@z_?$AA@ DB 'z_', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_pchName$ = 8
_k$ = -8
_j$ = -4
_szTemp$31652 = -108
_fnChangeReservedName@4 PROC NEAR

; 4872 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	push	edi

; 4873 :    zSHORT   k, j;
; 4874 : 
; 4875 :    // List of reserved names is terminated by a empty string.
; 4876 :    for ( k = 0; szReservedName[ k ][ 0 ]; k++ )

	mov	WORD PTR _k$[ebp], 0
	jmp	SHORT $L31648
$L31649:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$L31648:
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _szReservedName[ecx*4]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $L31650

; 4878 :       j = zstrcmpi( szReservedName[ k ], pchName );

	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _szReservedName[edx*4]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _j$[ebp], ax

; 4879 :       if ( j == 0 )

	movsx	ecx, WORD PTR _j$[ebp]
	test	ecx, ecx
	jne	SHORT $L31651

; 4881 :          zCHAR szTemp[ 100 ] = "z_";

	mov	dx, WORD PTR ??_C@_02IALC@z_?$AA@
	mov	WORD PTR _szTemp$31652[ebp], dx
	mov	al, BYTE PTR ??_C@_02IALC@z_?$AA@+2
	mov	BYTE PTR _szTemp$31652[ebp+2], al
	mov	ecx, 24					; 00000018H
	xor	eax, eax
	lea	edi, DWORD PTR _szTemp$31652[ebp+3]
	rep stosd
	stosb

; 4882 : 
; 4883 :          // Since we know that all the reserved words are at least 2 chars
; 4884 :          // shorter then the max column/table length, then don't worry about
; 4885 :          // compressing the name.
; 4886 :          zstrcat( szTemp, pchName );

	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTemp$31652[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4887 :          zstrcpy( pchName, szTemp );

	lea	eax, DWORD PTR _szTemp$31652[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4888 :          return;

	jmp	SHORT $L31650
$L31651:

; 4890 : 
; 4891 :       // Reserved words are listed in alphabetical order.  If the compare
; 4892 :       // returned a value greater than 0, then pchName comes before the current
; 4893 :       // szReservedName, which means there cannot be a match.
; 4894 :       if ( j > 0 )

	movsx	edx, WORD PTR _j$[ebp]
	test	edx, edx
	jle	SHORT $L31654

; 4895 :          return;

	jmp	SHORT $L31650
$L31654:

; 4896 :    }

	jmp	$L31649
$L31650:

; 4897 : }

	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	4
_fnChangeReservedName@4 ENDP
_TEXT	ENDS
PUBLIC	_TranslateToUnderscoreCase@12
EXTRN	_SysTranslateString@8:NEAR
_TEXT	SEGMENT
_pchSrc$ = 8
_pchTarget$ = 12
_cMetaType$ = 16
_vDBH_Data$ = -16
_l$ = -20
_targetEnd$ = -280
_original$ = -8
_p$ = -4
_sz$ = -276
_nMaxLth$ = -12
_TranslateToUnderscoreCase@12 PROC NEAR

; 4929 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH

; 4930 :    zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 4931 :    //zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 4932 :    //zCHAR  szCreateUnderscore[ 2 ];
; 4933 :    zLONG  l;
; 4934 :    zPCHAR targetEnd; // = pchTarget + targetLth - 1; // Point to last char in target buffer.
; 4935 :    zPCHAR original = pchSrc;

	mov	eax, DWORD PTR _pchSrc$[ebp]
	mov	DWORD PTR _original$[ebp], eax

; 4936 :    zPCHAR p;
; 4937 :    zCHAR  sz[ 256 ];
; 4938 :    zSHORT nMaxLth;      // Used to keep track of duplicate names.
; 4939 : 
; 4940 :    switch ( cMetaType )
; 4941 :    {

	mov	cl, BYTE PTR _cMetaType$[ebp]
	mov	BYTE PTR -284+[ebp], cl
	cmp	BYTE PTR -284+[ebp], 65			; 00000041H
	je	SHORT $L31678
	cmp	BYTE PTR -284+[ebp], 69			; 00000045H
	je	SHORT $L31674
	jmp	SHORT $L31682
$L31674:

; 4942 :       case 'E':      // Meta type is Entity
; 4943 : 
; 4944 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 4945 :          // not specified use the default length.
; 4946 :          if ( vDBH_Data &&
; 4947 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 4948 :                                        "MaxTableNameLength" ) != -1 )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31675
	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $L31675

; 4950 :             nMaxLth = (zSHORT) l;

	mov	dx, WORD PTR _l$[ebp]
	mov	WORD PTR _nMaxLth$[ebp], dx

; 4952 :          else

	jmp	SHORT $L31677
$L31675:

; 4953 :             nMaxLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _nMaxLth$[ebp], 64		; 00000040H
$L31677:

; 4954 : 
; 4955 :          break;

	jmp	SHORT $L31671
$L31678:

; 4956 : 
; 4957 :       case 'A':      // Meta type is Attribute
; 4958 : 
; 4959 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 4960 :          // not specified use the default length.
; 4961 :          if ( vDBH_Data &&
; 4962 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 4963 :                                        "MaxColumnNameLength" ) != -1 )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31679
	push	OFFSET FLAT:??_C@_0BE@GNCH@MaxColumnNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $L31679

; 4965 :             nMaxLth = (zSHORT) l;

	mov	ax, WORD PTR _l$[ebp]
	mov	WORD PTR _nMaxLth$[ebp], ax

; 4967 :          else

	jmp	SHORT $L31681
$L31679:

; 4968 :             nMaxLth = MAX_COLUMNNAME_LTH;

	mov	WORD PTR _nMaxLth$[ebp], 64		; 00000040H
$L31681:

; 4969 : 
; 4970 :          break;

	jmp	SHORT $L31671
$L31682:

; 4971 : 
; 4972 : 	  default:
; 4973 : 	     zstrcpy( pchTarget, pchSrc );

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTarget$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4974 : 		 return 0;

	xor	ax, ax
	jmp	$L31662
$L31671:

; 4976 : 
; 4977 :    if ( nMaxLth >= BUFF_SIZE )

	movsx	eax, WORD PTR _nMaxLth$[ebp]
	cmp	eax, 256				; 00000100H
	jl	SHORT $L31683

; 4978 :       nMaxLth = BUFF_SIZE - 1;

	mov	WORD PTR _nMaxLth$[ebp], 255		; 000000ffH
$L31683:

; 4979 : 
; 4980 :   targetEnd = pchTarget + nMaxLth - 1;

	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	mov	edx, DWORD PTR _pchTarget$[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR _targetEnd$[ebp], eax

; 4981 : 
; 4982 :   // Defensive programming...
; 4983 :   *targetEnd = 0;

	mov	ecx, DWORD PTR _targetEnd$[ebp]
	mov	BYTE PTR [ecx], 0

; 4984 : 
; 4985 :   if ( (zSHORT) zstrlen( pchSrc ) >= nMaxLth )

	mov	edx, DWORD PTR _pchSrc$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	movsx	eax, ax
	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	cmp	eax, ecx
	jl	SHORT $L31685

; 4986 :      return zCALL_ERROR;

	mov	ax, -16					; fffffff0H
	jmp	$L31662
$L31685:

; 4987 : 
; 4988 :   zstrcpy( sz, pchSrc );

	mov	edx, DWORD PTR _pchSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4989 : 
; 4990 :   //p = pchTarget;
; 4991 :   p = sz;

	lea	ecx, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 4992 : 
; 4993 :   // Copy first char to target.
; 4994 :   *p++ = *pchSrc++;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _pchSrc$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
	mov	eax, DWORD PTR _pchSrc$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSrc$[ebp], eax
$L31687:

; 4995 :   while ( *pchSrc != 0 )

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$L31688

; 4997 :       // Do we have enough space to add two more chars?
; 4998 :     if ( p + 2 > targetEnd )

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	cmp	eax, DWORD PTR _targetEnd$[ebp]
	jbe	SHORT $L31689

; 4999 :   	  return -16;

	mov	ax, -16					; fffffff0H
	jmp	$L31662
$L31689:

; 5000 : 
; 5001 :     if ( *pchSrc >= 'A' && *pchSrc <= 'Z' )

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $L31694
	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jg	SHORT $L31694

; 5003 : 	  // We have a capital letter.  Is previous letter upper?
; 5004 : 	  if ( *(p-1) < 'A' || *(p-1) > 'Z' )

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx-1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $L31692
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $L31691
$L31692:

; 5005 : 	    // No, so copy _.
; 5006 : 	    *p++ = '_';

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 95			; 0000005fH
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 5007 : 	  else

	jmp	SHORT $L31694
$L31691:

; 5008 : 	    // Previous letter is also upper.  Insert _ if next char is lower.
; 5009 : 	    if ( ( *(pchSrc+1) < 'A' || *(pchSrc+1) > 'Z' ) && *(pchSrc+1) != 0 )

	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $L31695
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $L31694
$L31695:
	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $L31694

; 5010 : 			*p++ = '_';

	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], 95			; 0000005fH
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$L31694:

; 5012 :       *p++ = *pchSrc++;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _pchSrc$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx

; 5013 :     }

	jmp	$L31687
$L31688:

; 5014 : //
; 5015 :   *p++ = 0;

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 5016 :   
; 5017 :   // Now convert to all lower.
; 5018 :   SysTranslateString( p, 'L' );

	push	76					; 0000004cH
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_SysTranslateString@8

; 5019 :   zstrcpy( pchTarget, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5020 : 
; 5021 :   return 0;

	xor	ax, ax
$L31662:

; 5022 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TranslateToUnderscoreCase@12 ENDP
_TEXT	ENDS
PUBLIC	_GenerateName@12
PUBLIC	??_C@_0CA@CEEE@TranslateNamesToLowerUnderscore?$AA@ ; `string'
PUBLIC	??_C@_02IKBN@B_?$AA@				; `string'
PUBLIC	??_C@_02IPGJ@Bc?$AA@				; `string'
EXTRN	__imp____mb_cur_max:DWORD
EXTRN	__imp___pctype:DWORD
EXTRN	__imp___isctype:NEAR
_BSS	SEGMENT
_?nNameCount@?1??GenerateName@@9@9 DW 01H DUP (?)
	ALIGN	4

_?nMaxLth@?1??GenerateName@@9@9 DW 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CA@CEEE@TranslateNamesToLowerUnderscore?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0CA@CEEE@TranslateNamesToLowerUnderscore?$AA@ DB 'TranslateNamesToL'
	DB	'owerUnderscore', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02IKBN@B_?$AA@
_DATA	SEGMENT
??_C@_02IKBN@B_?$AA@ DB 'B_', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_02IPGJ@Bc?$AA@
_DATA	SEGMENT
??_C@_02IPGJ@Bc?$AA@ DB 'Bc', 00H			; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vDTE$ = 8
_pchName$ = 12
_cMetaType$ = 16
_vDBH_Data$ = -4
_szDBH_DataObjectName$ = -40
_szCreateUnderscore$ = -52
_pch1$ = -48
_pch2$ = -56
_l$ = -44
_nLth$31733 = -60
_GenerateName@12 PROC NEAR

; 5055 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 5056 :    static zSHORT nNameCount;   // Used to keep track of duplicate names.
; 5057 :    static zSHORT nMaxLth;      // Used to keep track of duplicate names.
; 5058 : 
; 5059 :    zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 5060 :    zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 5061 :    zCHAR  szCreateUnderscore[ 2 ];
; 5062 :    zPCHAR pch1;
; 5063 :    zPCHAR pch2;
; 5064 :    zLONG  l;
; 5065 : 
; 5066 :    // Try to get the OI that contains DBH-specific data.
; 5067 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,
; 5068 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );

	push	512					; 00000200H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 5069 : 
; 5070 :    // Eliminate invalid chars.
; 5071 :    for ( pch1 = pch2 = pchName; *pch2; pch2++ )

	mov	ecx, DWORD PTR _pchName$[ebp]
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch2$[ebp]
	mov	DWORD PTR _pch1$[ebp], edx
	jmp	SHORT $L31714
$L31715:
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
$L31714:
	mov	ecx, DWORD PTR _pch2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $L31716

; 5073 :       // Even though SQLBase allows '@', '#', and '$' we don't generate them.
; 5074 :       if ( zisalnum( *pch2 ) || *pch2 == '_' )

	mov	eax, DWORD PTR __imp____mb_cur_max
	cmp	DWORD PTR [eax], 1
	jle	SHORT $L32362
	push	263					; 00000107H
	mov	ecx, DWORD PTR _pch2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___isctype
	add	esp, 8
	mov	DWORD PTR -64+[ebp], eax
	jmp	SHORT $L32363
$L32362:
	mov	eax, DWORD PTR _pch2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR __imp___pctype
	mov	eax, DWORD PTR [edx]
	xor	edx, edx
	mov	dx, WORD PTR [eax+ecx*2]
	and	edx, 263				; 00000107H
	mov	DWORD PTR -64+[ebp], edx
$L32363:
	cmp	DWORD PTR -64+[ebp], 0
	jne	SHORT $L31718
	mov	eax, DWORD PTR _pch2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 95					; 0000005fH
	jne	SHORT $L31717
$L31718:

; 5075 :          *pch1++ = *pch2;  // Copy valid char.

	mov	edx, DWORD PTR _pch1$[ebp]
	mov	eax, DWORD PTR _pch2$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx
$L31717:

; 5076 :    }

	jmp	SHORT $L31715
$L31716:

; 5077 : 
; 5078 :    // Null-terminate string.
; 5079 :    pch1[ 0 ] = 0;

	mov	eax, DWORD PTR _pch1$[ebp]
	mov	BYTE PTR [eax], 0

; 5080 : 
; 5081 :    // KJS 08/07/14 - DG wants to be able to create names Like EntityName to entity_name. This is the ini setting.
; 5082 :    GetStringFromAttribute (szCreateUnderscore, vDTE, "TE_DBMS_Source", "TranslateNamesToLowerUnderscore");

	push	OFFSET FLAT:??_C@_0CA@CEEE@TranslateNamesToLowerUnderscore?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szCreateUnderscore$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 5083 : 
; 5084 :    switch ( cMetaType )
; 5085 :    {

	mov	al, BYTE PTR _cMetaType$[ebp]
	mov	BYTE PTR -68+[ebp], al
	cmp	BYTE PTR -68+[ebp], 65			; 00000041H
	je	SHORT $L31728
	cmp	BYTE PTR -68+[ebp], 69			; 00000045H
	je	SHORT $L31724
	cmp	BYTE PTR -68+[ebp], 88			; 00000058H
	je	$L31732
	jmp	$L31721
$L31724:

; 5086 :       case 'E':      // Meta type is Entity
; 5087 :          nNameCount = 1;

	mov	WORD PTR _?nNameCount@?1??GenerateName@@9@9, 1

; 5088 : 
; 5089 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 5090 :          // not specified use the default length.
; 5091 :          if ( vDBH_Data &&
; 5092 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 5093 :                                        "MaxTableNameLength" ) != -1 )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31725
	push	OFFSET FLAT:??_C@_0BD@KOPE@MaxTableNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	movsx	eax, ax
	cmp	eax, -1
	je	SHORT $L31725

; 5095 :             nMaxLth = (zSHORT) l;

	mov	cx, WORD PTR _l$[ebp]
	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, cx

; 5097 :          else

	jmp	SHORT $L31727
$L31725:

; 5098 :             nMaxLth = MAX_TABLENAME_LTH;

	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, 64 ; 00000040H
$L31727:

; 5099 : 
; 5100 :          break;

	jmp	$L31721
$L31728:

; 5101 : 
; 5102 :       case 'A':      // Meta type is Attribute
; 5103 :          nNameCount = 1;

	mov	WORD PTR _?nNameCount@?1??GenerateName@@9@9, 1

; 5104 : 
; 5105 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 5106 :          // not specified use the default length.
; 5107 :          if ( vDBH_Data &&
; 5108 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 5109 :                                        "MaxColumnNameLength" ) != -1 )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $L31729
	push	OFFSET FLAT:??_C@_0BE@GNCH@MaxColumnNameLength?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $L31729

; 5111 :             nMaxLth = (zSHORT) l;

	mov	dx, WORD PTR _l$[ebp]
	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, dx

; 5113 :          else

	jmp	SHORT $L31731
$L31729:

; 5114 :             nMaxLth = MAX_COLUMNNAME_LTH;

	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, 64 ; 00000040H
$L31731:

; 5115 : 
; 5116 :          break;

	jmp	SHORT $L31721
$L31732:

; 5120 :          zSHORT nLth;
; 5121 : 
; 5122 :          // When generating new names, we just tack on an incrementing
; 5123 :          // number.  For example, "ColName" becomes "ColName02", "ColName02"
; 5124 :          // becomes "ColName03", etc.
; 5125 : 
; 5126 :          nNameCount++;

	mov	ax, WORD PTR _?nNameCount@?1??GenerateName@@9@9
	add	ax, 1
	mov	WORD PTR _?nNameCount@?1??GenerateName@@9@9, ax

; 5127 :          nLth = zstrlen( pchName );

	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$31733[ebp], ax

; 5128 :          if ( nNameCount > 2 )

	movsx	edx, WORD PTR _?nNameCount@?1??GenerateName@@9@9
	cmp	edx, 2
	jle	SHORT $L31734

; 5129 :             nLth = nLth - 2;

	movsx	eax, WORD PTR _nLth$31733[ebp]
	sub	eax, 2
	mov	WORD PTR _nLth$31733[ebp], ax

; 5130 :          else

	jmp	SHORT $L31736
$L31734:

; 5131 :          if ( nLth > nMaxLth - 2 )

	movsx	ecx, WORD PTR _nLth$31733[ebp]
	movsx	edx, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	sub	edx, 2
	cmp	ecx, edx
	jle	SHORT $L31736

; 5132 :             nLth = nMaxLth - 2;

	movsx	eax, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	sub	eax, 2
	mov	WORD PTR _nLth$31733[ebp], ax
$L31736:

; 5133 : 
; 5134 :          zsprintf( pchName + nLth, "%02d", nNameCount );

	movsx	ecx, WORD PTR _?nNameCount@?1??GenerateName@@9@9
	push	ecx
	push	OFFSET FLAT:??_C@_04LGDF@?$CF02d?$AA@	; `string'
	movsx	edx, WORD PTR _nLth$31733[ebp]
	mov	eax, DWORD PTR _pchName$[ebp]
	add	eax, edx
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 12					; 0000000cH

; 5135 : 
; 5136 :          // We know name is short enough and no reserved words contain numbers
; 5137 :          // so just return.
; 5138 :          return( 0 );

	xor	ax, ax
	jmp	SHORT $L31703
$L31721:

; 5141 : 
; 5142 :    if ( nMaxLth >= BUFF_SIZE )

	movsx	ecx, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	cmp	ecx, 256				; 00000100H
	jl	SHORT $L31737

; 5143 :       nMaxLth = BUFF_SIZE - 1;

	mov	WORD PTR _?nMaxLth@?1??GenerateName@@9@9, 255 ; 000000ffH
$L31737:

; 5144 : 
; 5145 :    // Compress the name if it needs it.
; 5146 :    UfCompressName( pchName,   // Original name.
; 5147 :                    pchName,   // New (shorter) name.
; 5148 :                    nMaxLth,   // Max length of string.
; 5149 :                    "",        // Remove embedded spaces.
; 5150 :                    "",        // Ignore '_' (for now).
; 5151 :                    "Bc",      // Remove lower-case vowels starting from back.
; 5152 :                    "B_",      // Remove '_' starting from back.
; 5153 :                    0 );       // Stop when the name is short enough.

	push	0
	push	OFFSET FLAT:??_C@_02IKBN@B_?$AA@	; `string'
	push	OFFSET FLAT:??_C@_02IPGJ@Bc?$AA@	; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	mov	dx, WORD PTR _?nMaxLth@?1??GenerateName@@9@9
	push	edx
	mov	eax, DWORD PTR _pchName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_UfCompressName@32

; 5154 : 
; 5155 :    if ( szCreateUnderscore[ 0 ] == 'Y' )

	movsx	edx, BYTE PTR _szCreateUnderscore$[ebp]
	cmp	edx, 89					; 00000059H
	jne	SHORT $L31740

; 5156 :       // KJS 08/07/14 - Change string to all lower-case if we are creating table/column names with underscore.
; 5157 :       SysTranslateString( pchName, 'L' );

	push	76					; 0000004cH
	mov	eax, DWORD PTR _pchName$[ebp]
	push	eax
	call	_SysTranslateString@8

; 5158 :    else

	jmp	SHORT $L31741
$L31740:

; 5159 :       // Change string to all upper-case.
; 5160 :       SysTranslateString( pchName, 'U' );

	push	85					; 00000055H
	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_SysTranslateString@8
$L31741:

; 5161 : 
; 5162 :    // Make sure generated name doesn't match a reserved word.
; 5163 :    fnChangeReservedName( pchName );

	mov	edx, DWORD PTR _pchName$[ebp]
	push	edx
	call	_fnChangeReservedName@4

; 5164 : 
; 5165 :    return( 0 );

	xor	ax, ax
$L31703:

; 5166 : 
; 5167 : } // GenerateName

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_GenerateName@12 ENDP
_TEXT	ENDS
PUBLIC	_fnSortDataFields@4
PUBLIC	??_C@_0L@PPLE@DATARECORD?$AA@			; `string'
PUBLIC	??_C@_0M@PNOD@CHILDENTITY?$AA@			; `string'
PUBLIC	??_C@_09JEIA@DATAFIELD?$AA@			; `string'
PUBLIC	??_C@_07MPNE@FLDTYPE?$AA@			; `string'
PUBLIC	??_C@_0L@CDIB@XVAATT_TOK?$AA@			; `string'
PUBLIC	??_C@_06BLIJ@ATTRIB?$AA@			; `string'
EXTRN	_SetViewFromView@8:NEAR
EXTRN	_SetViewToSubobject@8:NEAR
EXTRN	_MoveSubobject@24:NEAR
EXTRN	_SetCursorPrevEntity@12:NEAR
EXTRN	_SetCursorLastEntity@12:NEAR
EXTRN	_SetCursorAbsolutePosition@12:NEAR
EXTRN	_GetAbsolutePositionForEntity@12:NEAR
EXTRN	_DefineHierarchicalCursor@8:NEAR
EXTRN	_DropHierarchicalCursor@4:NEAR
EXTRN	_SetCursorNextEntityHierarchical@12:NEAR
;	COMDAT ??_C@_0L@PPLE@DATARECORD?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0L@PPLE@DATARECORD?$AA@ DB 'DATARECORD', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@PNOD@CHILDENTITY?$AA@
_DATA	SEGMENT
??_C@_0M@PNOD@CHILDENTITY?$AA@ DB 'CHILDENTITY', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09JEIA@DATAFIELD?$AA@
_DATA	SEGMENT
??_C@_09JEIA@DATAFIELD?$AA@ DB 'DATAFIELD', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MPNE@FLDTYPE?$AA@
_DATA	SEGMENT
??_C@_07MPNE@FLDTYPE?$AA@ DB 'FLDTYPE', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@CDIB@XVAATT_TOK?$AA@
_DATA	SEGMENT
??_C@_0L@CDIB@XVAATT_TOK?$AA@ DB 'XVAATT_TOK', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06BLIJ@ATTRIB?$AA@
_DATA	SEGMENT
??_C@_06BLIJ@ATTRIB?$AA@ DB 'ATTRIB', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_usReturnLevel$ = -52
_nRC$ = -48
_szEntityName$ = -44
_vXOD$ = -4
_vXOD2$ = -8
_lPos$31756 = -56
_vTZZOXODO$ = 8
_fnSortDataFields@4 PROC NEAR

; 7031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 7032 :    zUSHORT usReturnLevel;
; 7033 :    zSHORT  nRC;
; 7034 :    zCHAR   szEntityName[ 33 ];
; 7035 :    zVIEW   vXOD;
; 7036 :    zVIEW   vXOD2;
; 7037 : 
; 7038 :    // If there is no DATARECORD for the root entity then there is nothing
; 7039 :    // to do (this LOD has no physical info).
; 7040 :    if ( CheckExistenceOfEntity( vTZZOXODO, "DATARECORD" ) != zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L31751

; 7041 :       return( 0 );

	xor	ax, ax
	jmp	$L31745
$L31751:

; 7042 : 
; 7043 :    CreateViewFromViewForTask( &vTZZOXODO, vTZZOXODO, 0 );

	push	0
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 7044 :    CreateViewFromViewForTask( &vXOD, vTZZOXODO, 0 );

	push	0
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 7045 :    CreateViewFromViewForTask( &vXOD2, vTZZOXODO, 0 );

	push	0
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 7046 : 
; 7047 :    // Initialize DATARECORD into szEntityName so that we reference the first
; 7048 :    // ENTITY.
; 7049 :    zstrcpy( szEntityName, "DATARECORD" );

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7050 : 
; 7051 :    for ( nRC = DefineHierarchicalCursor( vTZZOXODO, "DATARECORD" );
; 7052 :          nRC >= zCURSOR_SET;
; 7053 :          nRC = SetCursorNextEntityHierarchical( &usReturnLevel,
; 7054 :                                                 szEntityName, vTZZOXODO ) )

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_DefineHierarchicalCursor@8
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31753
$L31754:
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	lea	eax, DWORD PTR _usReturnLevel$[ebp]
	push	eax
	call	_SetCursorNextEntityHierarchical@12
	mov	WORD PTR _nRC$[ebp], ax
$L31753:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31755

; 7056 :       zLONG lPos;
; 7057 : 
; 7058 :       if ( nRC == zCURSOR_SET_RECURSIVECHILD )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $L31757

; 7059 :          SetViewToSubobject( vTZZOXODO, "CHILDENTITY" );

	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetViewToSubobject@8
$L31757:

; 7060 : 
; 7061 :       if ( zstrcmp( szEntityName, "DATARECORD" ) != 0 )

	movsx	ecx, BYTE PTR _szEntityName$[ebp]
	movsx	edx, BYTE PTR ??_C@_0L@PPLE@DATARECORD?$AA@
	cmp	ecx, edx
	jne	SHORT $L32365
	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -60+[ebp], eax
	jmp	SHORT $L32366
$L32365:
	movsx	ecx, BYTE PTR _szEntityName$[ebp]
	movsx	edx, BYTE PTR ??_C@_0L@PPLE@DATARECORD?$AA@
	sub	ecx, edx
	xor	eax, eax
	test	ecx, ecx
	setle	al
	dec	eax
	and	eax, 2
	add	eax, -1
	mov	DWORD PTR -60+[ebp], eax
$L32366:
	cmp	DWORD PTR -60+[ebp], 0
	je	SHORT $L31765

; 7062 :          continue;

	jmp	$L31754
$L31765:

; 7063 : 
; 7064 :       GetAbsolutePositionForEntity( &lPos, vTZZOXODO, "DATARECORD" );

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lPos$31756[ebp]
	push	edx
	call	_GetAbsolutePositionForEntity@12

; 7065 :       SetCursorAbsolutePosition( szEntityName, vXOD, lPos );

	mov	eax, DWORD PTR _lPos$31756[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_SetCursorAbsolutePosition@12

; 7066 : 
; 7067 :       // Move blob fields to the end.  We'll start at the end and go back
; 7068 :       // to the beginning. We'll skip the very last entity since it's already
; 7069 :       // last.
; 7070 :       SetCursorLastEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorLastEntity@12

; 7071 :       nRC = SetCursorPrevEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31768:

; 7072 :       while ( nRC >= zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $L31769

; 7074 :          SetViewFromView( vXOD2, vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_SetViewFromView@8

; 7075 :          nRC = SetCursorPrevEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 7076 : 
; 7077 :          if ( CompareAttributeToString( vXOD2, "DATAFIELD", "FLDTYPE",
; 7078 :                                         "V" ) == 0 ||
; 7079 :               CompareAttributeToString( vXOD2, "DATAFIELD", "FLDTYPE",
; 7080 :                                         "B" ) == 0 )

	push	OFFSET FLAT:??_C@_01PDMC@V?$AA@		; `string'
	push	OFFSET FLAT:??_C@_07MPNE@FLDTYPE?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD2$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $L31771
	push	OFFSET FLAT:??_C@_01PAOO@B?$AA@		; `string'
	push	OFFSET FLAT:??_C@_07MPNE@FLDTYPE?$AA@	; `string'
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31770
$L31771:

; 7082 :             // Move current DATAFIELD to the end.
; 7083 :             MoveSubobject( vXOD2, "DATAFIELD", vXOD2, "DATAFIELD",
; 7084 :                            zPOS_LAST, zREPOS_PREV );

	push	4
	push	2
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_MoveSubobject@24
$L31770:

; 7086 :       }

	jmp	$L31768
$L31769:

; 7087 : 
; 7088 :       // Move Keys fields to the beginning.  We'll start at the end and go back
; 7089 :       // to the beginning. We'll skip the very first entity since it's already
; 7090 :       // first.
; 7091 :       SetViewFromView( vXOD2, vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_SetViewFromView@8

; 7092 :       SetCursorFirstEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12

; 7093 :       nRC = SetCursorNextEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31775:

; 7094 :       while ( nRC >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31776

; 7096 :          // Find the correct ATTRIB entity.
; 7097 :          SetCursorFirstEntityByAttr( vXOD, "ATTRIB", "XVAATT_TOK",
; 7098 :                                      vXOD, "DATAFIELD", "XVAATT_TOK", 0 );

	push	0
	push	OFFSET FLAT:??_C@_0L@CDIB@XVAATT_TOK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_0L@CDIB@XVAATT_TOK?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_06BLIJ@ATTRIB?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28

; 7099 : 
; 7100 :          SetViewFromView( vXOD2, vXOD );

	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_SetViewFromView@8

; 7101 :          nRC = SetCursorNextEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 7102 : 
; 7103 :          // If the attribute is a key move it to the beginning.
; 7104 :          if ( CompareAttributeToString( vXOD2, "ATTRIB", "KEY", "Y" ) == 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_03PHBO@KEY?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06BLIJ@ATTRIB?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31779

; 7106 : 
; 7107 :             // Move current DATAFIELD to the beginning.
; 7108 :             MoveSubobject( vXOD2, "DATAFIELD", vXOD2, "DATAFIELD",
; 7109 :                            zPOS_FIRST, zREPOS_NEXT );

	push	3
	push	1
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	eax, DWORD PTR _vXOD2$[ebp]
	push	eax
	push	OFFSET FLAT:??_C@_09JEIA@DATAFIELD?$AA@	; `string'
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_MoveSubobject@24
$L31779:

; 7111 :       }

	jmp	$L31775
$L31776:

; 7112 :    }

	jmp	$L31754
$L31755:

; 7113 : 
; 7114 :    DropHierarchicalCursor( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_DropHierarchicalCursor@4

; 7115 :    DropView( vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_DropView@4

; 7116 :    DropView( vXOD2 );

	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_DropView@4

; 7117 :    DropView( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_DropView@4

; 7118 : 
; 7119 :    return( 0 );

	xor	ax, ax
$L31745:

; 7120 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSortDataFields@4 ENDP
_TEXT	ENDS
PUBLIC	_fnSetEntityInformation@12
PUBLIC	??_C@_0BB@NHDL@LOD_EntityParent?$AA@		; `string'
PUBLIC	??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@	; `string'
PUBLIC	??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@		; `string'
PUBLIC	??_C@_0L@KKLH@POD_Entity?$AA@			; `string'
PUBLIC	??_C@_0O@FFFI@ER_RelLinkRec?$AA@		; `string'
PUBLIC	??_C@_07NHPD@CardMax?$AA@			; `string'
PUBLIC	??_C@_09PPA@ERENT_TOK?$AA@			; `string'
PUBLIC	??_C@_09DPNM@ERREL_TOK?$AA@			; `string'
PUBLIC	??_C@_0BA@DPMI@LOD_EntityChild?$AA@		; `string'
PUBLIC	??_C@_0N@NFHJ@ER_EntityRec?$AA@			; `string'
EXTRN	_CompareAttributeToInteger@16:NEAR
EXTRN	_ResetViewFromSubobject@4:NEAR
EXTRN	_SetCursorFirstEntityByInteger@20:NEAR
;	COMDAT ??_C@_0BB@NHDL@LOD_EntityParent?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_0BB@NHDL@LOD_EntityParent?$AA@ DB 'LOD_EntityParent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@
_DATA	SEGMENT
??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@ DB 'TE_DBMS_SourceForEntity', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@
_DATA	SEGMENT
??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@ DB 'SQL_JoinWithParent', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@KKLH@POD_Entity?$AA@
_DATA	SEGMENT
??_C@_0L@KKLH@POD_Entity?$AA@ DB 'POD_Entity', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@FFFI@ER_RelLinkRec?$AA@
_DATA	SEGMENT
??_C@_0O@FFFI@ER_RelLinkRec?$AA@ DB 'ER_RelLinkRec', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_07NHPD@CardMax?$AA@
_DATA	SEGMENT
??_C@_07NHPD@CardMax?$AA@ DB 'CardMax', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PPA@ERENT_TOK?$AA@
_DATA	SEGMENT
??_C@_09PPA@ERENT_TOK?$AA@ DB 'ERENT_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_09DPNM@ERREL_TOK?$AA@
_DATA	SEGMENT
??_C@_09DPNM@ERREL_TOK?$AA@ DB 'ERREL_TOK', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@DPMI@LOD_EntityChild?$AA@
_DATA	SEGMENT
??_C@_0BA@DPMI@LOD_EntityChild?$AA@ DB 'LOD_EntityChild', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@NFHJ@ER_EntityRec?$AA@
_DATA	SEGMENT
??_C@_0N@NFHJ@ER_EntityRec?$AA@ DB 'ER_EntityRec', 00H	; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vTZZOLODO$ = 8
_vTZZOXODO$ = 12
_lDBMS_ZKey$ = 16
_nRC$ = -4
_lER_EntTok$31804 = -8
_lER_RelTok$31805 = -12
_fnSetEntityInformation@12 PROC NEAR

; 7125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 7126 :    zSHORT nRC;
; 7127 : 
; 7128 :    // First, make sure we've got an entity with DB information.
; 7129 :    if ( CheckExistenceOfEntity( vTZZOXODO, "DATARECORD" ) < zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $L31790

; 7130 :       return;

	jmp	$L31803
$L31790:

; 7131 : 
; 7132 :    // Find out if a POD_Entity exists for the DBMS.
; 7133 :    if ( SetCursorFirstEntityByInteger( vTZZOLODO, "TE_DBMS_SourceForEntity",
; 7134 :                                        "ZKey", lDBMS_ZKey,
; 7135 :                                        "LOD_EntityParent" ) == zCURSOR_SET )

	push	OFFSET FLAT:??_C@_0BB@NHDL@LOD_EntityParent?$AA@ ; `string'
	mov	edx, DWORD PTR _lDBMS_ZKey$[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0BI@FMLJ@TE_DBMS_SourceForEntity?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByInteger@20
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31791

; 7137 :       // Got a POD_Entity.  Check the JOIN flag.
; 7138 :       if ( CompareAttributeToString( vTZZOLODO, "POD_Entity",
; 7139 :                                      "SQL_JoinWithParent", "Y" ) == 0 )

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BD@GNEF@SQL_JoinWithParent?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_0L@KKLH@POD_Entity?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31794

; 7141 :          SetAttributeFromString( vTZZOXODO, "DATARECORD", "JOIN", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_04JIJO@JOIN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$L31794:

; 7144 :    else

	jmp	SHORT $L31798
$L31791:

; 7145 :    if ( CheckExistenceOfEntity( vTZZOLODO, "ER_RelLinkRec" ) == zCURSOR_SET &&
; 7146 :         CompareAttributeToInteger( vTZZOLODO, "ER_RelLinkRec",
; 7147 :                                    "CardMax", 1 ) == 0 )

	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31798
	push	1
	push	OFFSET FLAT:??_C@_07NHPD@CardMax?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOLODO$[ebp]
	push	ecx
	call	_CompareAttributeToInteger@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $L31798

; 7149 :       // Join is defaulted to Y if the entity has a x-to-1 relationship
; 7150 :       // with it's parent.
; 7151 :       SetAttributeFromString( vTZZOXODO, "DATARECORD", "JOIN", "Y" );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_04JIJO@JOIN?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0L@PPLE@DATARECORD?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$L31798:

; 7153 : 
; 7154 :    // Now do the same thing for any children.
; 7155 :    for ( nRC = SetCursorFirstEntity( vTZZOXODO, "CHILDENTITY", 0 );
; 7156 :          nRC >= zCURSOR_SET;
; 7157 :          nRC = SetCursorNextEntity( vTZZOXODO, "CHILDENTITY", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31801
$L31802:
	push	0
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31801:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$L31803

; 7159 :       zLONG lER_EntTok;
; 7160 :       zLONG lER_RelTok;
; 7161 : 
; 7162 :       GetIntegerFromAttribute( &lER_EntTok, vTZZOXODO, "CHILDENTITY",
; 7163 :                                "ERENT_TOK" );

	push	OFFSET FLAT:??_C@_09PPA@ERENT_TOK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lER_EntTok$31804[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 7164 :       GetIntegerFromAttribute( &lER_RelTok, vTZZOXODO, "CHILDENTITY",
; 7165 :                                "ERREL_TOK" );

	push	OFFSET FLAT:??_C@_09DPNM@ERREL_TOK?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lER_RelTok$31805[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 7166 : 
; 7167 :       // Find a matching entity in the LOD.
; 7168 :       for ( nRC = SetCursorFirstEntity( vTZZOLODO, "LOD_EntityChild", 0 );
; 7169 :             nRC >= zCURSOR_SET;
; 7170 :             nRC = SetCursorNextEntity( vTZZOLODO, "LOD_EntityChild", 0 ) )

	push	0
	push	OFFSET FLAT:??_C@_0BA@DPMI@LOD_EntityChild?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $L31808
$L31809:
	push	0
	push	OFFSET FLAT:??_C@_0BA@DPMI@LOD_EntityChild?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$L31808:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$L31810

; 7172 :          SetViewToSubobject( vTZZOLODO, "LOD_EntityChild" );

	push	OFFSET FLAT:??_C@_0BA@DPMI@LOD_EntityChild?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_SetViewToSubobject@8

; 7173 : 
; 7174 :          if ( CheckExistenceOfEntity( vTZZOLODO,
; 7175 :                                       "ER_EntityRec" ) == zCURSOR_SET &&
; 7176 :               CompareAttributeToInteger( vTZZOLODO, "ER_EntityRec", "ZKey",
; 7177 :                                          lER_EntTok ) == 0 &&
; 7178 :               CheckExistenceOfEntity( vTZZOLODO,
; 7179 :                                       "ER_RelLinkRec" ) == zCURSOR_SET &&
; 7180 :               CompareAttributeToInteger( vTZZOLODO, "ER_RelLinkRec", "ZKey",
; 7181 :                                          lER_EntTok ) == 0 )

	push	OFFSET FLAT:??_C@_0N@NFHJ@ER_EntityRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31812
	mov	edx, DWORD PTR _lER_EntTok$31804[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0N@NFHJ@ER_EntityRec?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_CompareAttributeToInteger@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $L31812
	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31812
	mov	ecx, DWORD PTR _lER_EntTok$31804[ebp]
	push	ecx
	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0O@FFFI@ER_RelLinkRec?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CompareAttributeToInteger@16
	movsx	eax, ax
	test	eax, eax
	jne	SHORT $L31812

; 7183 :             // We found the child entity that matches the CHILDENTITY
; 7184 :             // in the XOD.  Stop 'for' loop.
; 7185 :             break;

	jmp	SHORT $L31810
$L31812:

; 7187 : 
; 7188 :          // That wasn't the right child so reset the subobject.
; 7189 :          ResetViewFromSubobject( vTZZOLODO );

	mov	ecx, DWORD PTR _vTZZOLODO$[ebp]
	push	ecx
	call	_ResetViewFromSubobject@4

; 7190 :       }

	jmp	$L31809
$L31810:

; 7191 : 
; 7192 :       // Once we get here, "LOD_EntityParent" should match "CHILDENTITY".
; 7193 :       // Move "CHILDENTITY" up and call ourselves recursively.
; 7194 :       SetViewToSubobject( vTZZOXODO, "CHILDENTITY" );

	push	OFFSET FLAT:??_C@_0M@PNOD@CHILDENTITY?$AA@ ; `string'
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_SetViewToSubobject@8

; 7195 :       fnSetEntityInformation( vTZZOLODO, vTZZOXODO, lDBMS_ZKey );

	mov	eax, DWORD PTR _lDBMS_ZKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_fnSetEntityInformation@12

; 7196 : 
; 7197 :       // Now reset the cursors.
; 7198 :       ResetViewFromSubobject( vTZZOLODO );

	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_ResetViewFromSubobject@4

; 7199 :       ResetViewFromSubobject( vTZZOXODO );

	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_ResetViewFromSubobject@4

; 7200 :    }

	jmp	$L31802
$L31803:

; 7201 : 
; 7202 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSetEntityInformation@12 ENDP
_TEXT	ENDS
PUBLIC	_PostXOD_BuildHook@20
PUBLIC	??_C@_08DKCM@TZDBHODO?$AA@			; `string'
PUBLIC	??_C@_0BD@KPGG@TimestampPrecision?$AA@		; `string'
PUBLIC	??_C@_06PIJH@OBJECT?$AA@			; `string'
EXTRN	_SetAttributeFromBlob@20:NEAR
EXTRN	_ResetView@4:NEAR
EXTRN	_memset:NEAR
;	COMDAT ??_C@_08DKCM@TZDBHODO?$AA@
; File C:\10C\a\oe\KZHSQLXB.C
_DATA	SEGMENT
??_C@_08DKCM@TZDBHODO?$AA@ DB 'TZDBHODO', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BD@KPGG@TimestampPrecision?$AA@
_DATA	SEGMENT
??_C@_0BD@KPGG@TimestampPrecision?$AA@ DB 'TimestampPrecision', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PIJH@OBJECT?$AA@
_DATA	SEGMENT
??_C@_06PIJH@OBJECT?$AA@ DB 'OBJECT', 00H		; `string'
_DATA	ENDS
_TEXT	SEGMENT
_vTZTEDBLO$ = 8
_vTZZOXODO$ = 12
_vTZZOLODO$ = 16
_vTZTENVRO_REF$ = 24
_szObjectName$ = -40
_vOI$ = -4
_lDBMS_ZKey$31838 = -44
_sData$31839 = -148
_PostXOD_BuildHook@20 PROC NEAR

; 7216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H

; 7217 :    zCHAR szObjectName[ zZEIDON_NAME_LTH + 1 ];
; 7218 :    zVIEW vOI;
; 7219 : 
; 7220 :    // See if there is a blob stored in DBH_Data for the TE.
; 7221 :    SetOI_FromBlob( &vOI, szObjectName, vTZZOXODO, vTZTENVRO_REF,
; 7222 :                    "TE_DBMS_Source", "DBH_Data", zMULTIPLE );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	eax, DWORD PTR _vTZTENVRO_REF$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 7223 : 
; 7224 :    if ( vOI == 0 )

	cmp	DWORD PTR _vOI$[ebp], 0
	jne	SHORT $L31828

; 7225 :        // No blob in the TE.  Get it from the DB list object.
; 7226 :       SetOI_FromBlob( &vOI, szObjectName, vTZZOXODO, vTZTEDBLO,
; 7227 :                       "TE_DBMS_Source", "DBH_Data", zMULTIPLE );

	push	256					; 00000100H
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	lea	eax, DWORD PTR _szObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28
$L31828:

; 7228 : 
; 7229 :    if ( vOI == 0 )

	cmp	DWORD PTR _vOI$[ebp], 0
	jne	SHORT $L31829

; 7231 :       return( 0 );

	xor	ax, ax
	jmp	$L31825
$L31829:

; 7246 : 
; 7247 :    // Check for ODBC object.
; 7248 :    if ( zstrcmp( szObjectName, "TZDBHODO" ) == 0 )

	movsx	edx, BYTE PTR _szObjectName$[ebp]
	movsx	eax, BYTE PTR ??_C@_08DKCM@TZDBHODO?$AA@
	cmp	edx, eax
	jne	SHORT $L32369
	push	OFFSET FLAT:??_C@_08DKCM@TZDBHODO?$AA@	; `string'
	lea	ecx, DWORD PTR _szObjectName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR -152+[ebp], eax
	jmp	SHORT $L32370
$L32369:
	movsx	edx, BYTE PTR _szObjectName$[ebp]
	movsx	eax, BYTE PTR ??_C@_08DKCM@TZDBHODO?$AA@
	sub	edx, eax
	xor	ecx, ecx
	test	edx, edx
	setle	cl
	dec	ecx
	and	ecx, 2
	add	ecx, -1
	mov	DWORD PTR -152+[ebp], ecx
$L32370:
	cmp	DWORD PTR -152+[ebp], 0
	jne	$L31836

; 7250 :       zLONG                 lDBMS_ZKey;
; 7251 :       ODBC_ObjectDataRecord sData;
; 7252 : 
; 7253 :       // For ODBC databases we need to sort the DataFields so that the VarChar
; 7254 :       // fields come last in each table.  We also need to put keys first.
; 7255 :       fnSortDataFields( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_fnSortDataFields@4

; 7256 : 
; 7257 :       // Set-up ODBC-specific information.
; 7258 :       zmemset( &sData, 0, sizeof( sData ) );

	push	104					; 00000068H
	push	0
	lea	eax, DWORD PTR _sData$31839[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 7259 :       GetIntegerFromAttribute( &sData.nTimestampPrecision,
; 7260 :                                vOI, "ODBC", "TimestampPrecision" );

	push	OFFSET FLAT:??_C@_0BD@KPGG@TimestampPrecision?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sData$31839[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 7261 :       sData.bStoreTimestampAsString =
; 7262 :             ( CompareAttributeToString( vOI, "ODBC",
; 7263 :                                         "TimestampAsString", "Y" ) == 0 );

	push	OFFSET FLAT:??_C@_01PCJP@Y?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0BC@KJKI@TimestampAsString?$AA@ ; `string'
	push	OFFSET FLAT:??_C@_04JENC@ODBC?$AA@	; `string'
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	neg	ecx
	sbb	ecx, ecx
	inc	ecx
	mov	BYTE PTR _sData$31839[ebp+4], cl

; 7264 : 
; 7265 :       SetAttributeFromBlob( vTZZOXODO, "OBJECT", "DBH_Data", (zPVOID) &sData,
; 7266 :                             sizeof( sData ) );

	push	104					; 00000068H
	lea	edx, DWORD PTR _sData$31839[ebp]
	push	edx
	push	OFFSET FLAT:??_C@_08DKGC@DBH_Data?$AA@	; `string'
	push	OFFSET FLAT:??_C@_06PIJH@OBJECT?$AA@	; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetAttributeFromBlob@20

; 7267 : 
; 7268 :       // Go through the LOD and set dbh-specific information for each entity.
; 7269 :       ResetView( vTZZOLODO );

	mov	ecx, DWORD PTR _vTZZOLODO$[ebp]
	push	ecx
	call	_ResetView@4

; 7270 :       ResetView( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_ResetView@4

; 7271 : 
; 7272 :       // Set the cursor to the first non-hidden entity.
; 7273 :       SetCursorFirstEntity( vTZZOXODO, "OBJECT", 0 );

	push	0
	push	OFFSET FLAT:??_C@_06PIJH@OBJECT?$AA@	; `string'
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12

; 7274 : 
; 7275 :       GetIntegerFromAttribute( &lDBMS_ZKey, vTZTENVRO_REF, "TE_DBMS_Source",
; 7276 :                                "ZKey" );

	push	OFFSET FLAT:??_C@_04BBDM@ZKey?$AA@	; `string'
	push	OFFSET FLAT:??_C@_0P@BCDD@TE_DBMS_Source?$AA@ ; `string'
	mov	ecx, DWORD PTR _vTZTENVRO_REF$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lDBMS_ZKey$31838[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 7277 :       fnSetEntityInformation( vTZZOLODO, vTZZOXODO, lDBMS_ZKey );

	mov	eax, DWORD PTR _lDBMS_ZKey$31838[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_fnSetEntityInformation@12
$L31836:

; 7279 : 
; 7280 :    DropView( vOI );

	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_DropView@4

; 7281 : 
; 7282 :    return( 0 );

	xor	ax, ax
$L31825:

; 7283 : 
; 7284 : } // PostXOD_BuildHook

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_PostXOD_BuildHook@20 ENDP
_TEXT	ENDS
EXTRN	__imp__strchr:NEAR
_TEXT	SEGMENT
_pch$ = 8
_pchKlammer$ = -4
_RemoveBrackets PROC NEAR

; 7292 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7293 :    zPCHAR pchKlammer;
; 7294 : 
; 7295 :    pchKlammer = strchr( pch, '[' );

	push	91					; 0000005bH
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchKlammer$[ebp], eax

; 7296 :    if ( pchKlammer )

	cmp	DWORD PTR _pchKlammer$[ebp], 0
	je	SHORT $L31847
$L31849:

; 7298 :       // Klammern [] wegnehmen.
; 7299 :       while ( *(pchKlammer + 1) != ']' && *(pchKlammer + 1) )

	mov	ecx, DWORD PTR _pchKlammer$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 93					; 0000005dH
	je	SHORT $L31850
	mov	eax, DWORD PTR _pchKlammer$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $L31850

; 7301 :          *pchKlammer = *(pchKlammer + 1);

	mov	edx, DWORD PTR _pchKlammer$[ebp]
	mov	eax, DWORD PTR _pchKlammer$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx], cl

; 7302 :          pchKlammer++;

	mov	edx, DWORD PTR _pchKlammer$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchKlammer$[ebp], edx

; 7303 :       }

	jmp	SHORT $L31849
$L31850:

; 7304 : 
; 7305 :       *pchKlammer = 0;

	mov	eax, DWORD PTR _pchKlammer$[ebp]
	mov	BYTE PTR [eax], 0
$L31847:

; 7307 : 
; 7308 : } // RemoveBrackets

	mov	esp, ebp
	pop	ebp
	ret	0
_RemoveBrackets ENDP
_TEXT	ENDS
END
