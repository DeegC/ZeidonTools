; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\a\oe\KZHSQLXB.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_szReservedName
_BSS	SEGMENT
$SG79919 DB	01H DUP (?)
	ALIGN	4

$SG79928 DB	01H DUP (?)
	ALIGN	4

$SG79936 DB	01H DUP (?)
	ALIGN	4

$SG80057 DB	01H DUP (?)
	ALIGN	4

$SG80079 DB	01H DUP (?)
	ALIGN	4

$SG80081 DB	01H DUP (?)
	ALIGN	4

$SG80089 DB	01H DUP (?)
	ALIGN	4

$SG80097 DB	01H DUP (?)
	ALIGN	4

$SG80099 DB	01H DUP (?)
	ALIGN	4

$SG80102 DB	01H DUP (?)
	ALIGN	4

$SG80119 DB	01H DUP (?)
	ALIGN	4

$SG80272 DB	01H DUP (?)
	ALIGN	4

$SG80375 DB	01H DUP (?)
	ALIGN	4

$SG80376 DB	01H DUP (?)
	ALIGN	4

$SG80427 DB	01H DUP (?)
	ALIGN	4

$SG80428 DB	01H DUP (?)
	ALIGN	4

$SG80472 DB	01H DUP (?)
	ALIGN	4

$SG79552 DB	02H DUP (?)
	ALIGN	4

$SG79721 DB	01H DUP (?)
	ALIGN	4

$SG79731 DB	01H DUP (?)
	ALIGN	4

$SG79733 DB	01H DUP (?)
	ALIGN	4

$SG79734 DB	01H DUP (?)
	ALIGN	4

$SG79737 DB	01H DUP (?)
	ALIGN	4

$SG80796 DB	01H DUP (?)
	ALIGN	4

$SG80797 DB	01H DUP (?)
	ALIGN	4

$SG79804 DB	01H DUP (?)
	ALIGN	4

$SG79826 DB	01H DUP (?)
	ALIGN	4

$SG79828 DB	01H DUP (?)
	ALIGN	4

$SG79831 DB	01H DUP (?)
	ALIGN	4

$SG79833 DB	01H DUP (?)
	ALIGN	4

$SG79836 DB	01H DUP (?)
	ALIGN	4

$SG79845 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG80896 DB	'ER_RelLinkRec', 00H
	ORG $+2
$SG80897 DB	'Y', 00H
	ORG $+2
$SG80898 DB	'JOIN', 00H
	ORG $+3
$SG80899 DB	'DATARECORD', 00H
	ORG $+1
$SG80900 DB	'CHILDENTITY', 00H
$SG80901 DB	'CHILDENTITY', 00H
$SG80902 DB	'ERENT_TOK', 00H
	ORG $+2
$SG80903 DB	'CHILDENTITY', 00H
$SG80904 DB	'ERREL_TOK', 00H
	ORG $+2
$SG80905 DB	'CHILDENTITY', 00H
$SG80906 DB	'LOD_EntityChild', 00H
$SG80907 DB	'LOD_EntityChild', 00H
$SG80908 DB	'LOD_EntityChild', 00H
$SG80910 DB	'ER_EntityRec', 00H
	ORG $+3
$SG80911 DB	'ZKey', 00H
	ORG $+3
$SG80912 DB	'ER_EntityRec', 00H
	ORG $+3
$SG80913 DB	'ER_RelLinkRec', 00H
	ORG $+2
$SG80914 DB	'ZKey', 00H
	ORG $+3
$SG80915 DB	'ER_RelLinkRec', 00H
	ORG $+2
$SG79891 DB	'TZTEDBLO', 00H
	ORG $+3
$SG80916 DB	'CHILDENTITY', 00H
$SG79893 DB	'DBMS', 00H
	ORG $+3
$SG79894 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79895 DB	'DBMS', 00H
	ORG $+3
$SG79896 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79897 DB	'DBH_Data', 00H
	ORG $+3
$SG79898 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79899 DB	'DBH_Data', 00H
	ORG $+3
$SG79900 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79903 DB	'MaxTableNameLength', 00H
	ORG $+1
$SG79904 DB	'ODBC', 00H
	ORG $+3
$SG79907 DB	'DefaultOwner', 00H
	ORG $+3
$SG79908 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79911 DB	'Name', 00H
	ORG $+3
$SG79912 DB	'TE_TablRec', 00H
	ORG $+1
$SG79913 DB	'TE_FieldDataRel', 00H
$SG80940 DB	'DBH_Data', 00H
	ORG $+3
$SG79916 DB	'ER_Entity', 00H
	ORG $+2
$SG80941 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79917 DB	'Name', 00H
	ORG $+3
$SG79918 DB	'ER_Entity', 00H
	ORG $+2
$SG80943 DB	'DBH_Data', 00H
	ORG $+3
$SG80944 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79920 DB	'--', 00H
	ORG $+1
$SG79921 DB	'%s Entity - %s %s', 00H
	ORG $+2
$SG80947 DB	'TZDBHODO', 00H
	ORG $+3
$SG79923 DB	'SQL_TableOwner', 00H
	ORG $+1
$SG80948 DB	'TZDBHODO', 00H
	ORG $+3
$SG79924 DB	'TE_TablRec', 00H
	ORG $+1
$SG80949 DB	'TZDBHODO', 00H
	ORG $+3
$SG80950 DB	'TimestampPrecision', 00H
	ORG $+1
$SG80951 DB	'ODBC', 00H
	ORG $+3
$SG79927 DB	'.', 00H
	ORG $+2
$SG80952 DB	'Y', 00H
	ORG $+2
$SG80953 DB	'TimestampAsString', 00H
	ORG $+2
$SG79929 DB	'CREATE TABLE %s%s ( %s', 00H
	ORG $+1
$SG80954 DB	'ODBC', 00H
	ORG $+3
$SG80955 DB	'DBH_Data', 00H
	ORG $+3
$SG79931 DB	' ', 00H
	ORG $+2
$SG80956 DB	'OBJECT', 00H
	ORG $+1
$SG79932 DB	'%*s ', 00H
	ORG $+3
$SG80957 DB	'OBJECT', 00H
	ORG $+1
$SG79933 DB	'TE_FieldDataRel', 00H
$SG80958 DB	'ZKey', 00H
	ORG $+3
$SG80959 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79937 DB	', %s', 00H
	ORG $+3
$SG79938 DB	';', 00H
	ORG $+2
$SG79939 DB	' ) %s', 00H
	ORG $+2
$SG79942 DB	' ', 00H
	ORG $+2
$SG80007 DB	'Y', 00H
	ORG $+2
$SG80008 DB	'N', 00H
	ORG $+2
$SG80009 DB	'Y', 00H
	ORG $+2
$SG80010 DB	'Y', 00H
	ORG $+2
$SG80012 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80013 DB	'TZTEDBLO', 00H
	ORG $+3
$SG80015 DB	'DBMS', 00H
	ORG $+3
$SG80016 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80017 DB	'DBMS', 00H
	ORG $+3
$SG80018 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80019 DB	'DBH_Data', 00H
	ORG $+3
$SG80020 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80021 DB	'DBH_Data', 00H
	ORG $+3
$SG80022 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80025 DB	'MaxTableNameLength', 00H
	ORG $+1
$SG80026 DB	'ODBC', 00H
	ORG $+3
$SG80027 DB	'GenCreateTables', 00H
$SG80028 DB	'ODBC', 00H
	ORG $+3
$SG80029 DB	'DropTables', 00H
	ORG $+1
$SG80030 DB	'ODBC', 00H
	ORG $+3
$SG80031 DB	'GenCreateIdxs', 00H
	ORG $+2
$SG80032 DB	'ODBC', 00H
	ORG $+3
$SG80033 DB	'GenDropIdxs', 00H
$SG80034 DB	'ODBC', 00H
	ORG $+3
$SG80035 DB	'Name', 00H
	ORG $+3
$SG80036 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80038 DB	'.ddl', 00H
	ORG $+3
$SG80040 DB	'Name', 00H
	ORG $+3
$SG80041 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80042 DB	'DefaultOwner', 00H
	ORG $+3
$SG80043 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80047 DB	'TE_TablRec', 00H
	ORG $+1
$SG80048 DB	'TE_TablRec', 00H
	ORG $+1
$SG80049 DB	'Name', 00H
	ORG $+3
$SG80050 DB	'TE_TablRec', 00H
	ORG $+1
$SG80051 DB	'TE_FieldDataRel', 00H
$SG80054 DB	'ER_Entity', 00H
	ORG $+2
$SG80055 DB	'Name', 00H
	ORG $+3
$SG80056 DB	'ER_Entity', 00H
	ORG $+2
$SG80058 DB	'--', 00H
	ORG $+1
$SG80059 DB	'%s Indexes for Entity - %s %s', 00H
	ORG $+2
$SG80061 DB	'SQL_TableOwner', 00H
	ORG $+1
$SG80062 DB	'TE_TablRec', 00H
	ORG $+1
$SG80065 DB	'.', 00H
	ORG $+2
$SG80066 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80067 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80068 DB	'IndexName', 00H
	ORG $+2
$SG80069 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80072 DB	'Name', 00H
	ORG $+3
$SG80073 DB	'TE_TablRec', 00H
	ORG $+1
$SG80074 DB	'Name', 00H
	ORG $+3
$SG80075 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80076 DB	'%s_%s', 00H
	ORG $+2
$SG80077 DB	'%s', 00H
	ORG $+1
$SG80078 DB	'B_AEIOU', 00H
$SG80080 DB	'B', 00H
	ORG $+2
$SG80082 DB	'TE_FieldDataRel', 00H
$SG80083 DB	'TE_FieldDataRel', 00H
$SG80084 DB	'DataOrRelfieldOrSet', 00H
$SG80085 DB	'TE_FieldDataRel', 00H
$SG80087 DB	'Desc', 00H
	ORG $+3
$SG80088 DB	'TE_FieldDataRel', 00H
$SG80090 DB	'--', 00H
	ORG $+1
$SG80091 DB	'%s Index for Relationship - ''%s'' %s', 00H
$SG80093 DB	'Name', 00H
	ORG $+3
$SG80094 DB	'TE_FieldDataRel', 00H
$SG80095 DB	'%s_%s', 00H
	ORG $+2
$SG80096 DB	'B_AEIOU', 00H
$SG80098 DB	'B', 00H
	ORG $+2
$SG80100 DB	'%02d', 00H
	ORG $+3
$SG80104 DB	'TE_TablRec', 00H
	ORG $+1
$SG80105 DB	'TE_TablRec', 00H
	ORG $+1
$SG80106 DB	'TE_FieldDataRel', 00H
$SG80108 DB	'SQL_TableOwner', 00H
	ORG $+1
$SG80109 DB	'TE_TablRec', 00H
	ORG $+1
$SG80112 DB	'.', 00H
	ORG $+2
$SG80113 DB	'Name', 00H
	ORG $+3
$SG80114 DB	'TE_TablRec', 00H
	ORG $+1
$SG80115 DB	';', 00H
	ORG $+2
$SG80116 DB	'DROP TABLE %s%s %s', 00H
	ORG $+1
$SG80121 DB	'TE_TablRec', 00H
	ORG $+1
$SG80122 DB	'TE_TablRec', 00H
	ORG $+1
$SG80125 DB	'TE_TablRec', 00H
	ORG $+1
$SG80126 DB	'TE_TablRec', 00H
	ORG $+1
$SG80127 DB	'Name', 00H
	ORG $+3
$SG80128 DB	'TE_TablRec', 00H
	ORG $+1
$SG80129 DB	'TE_FieldDataRel', 00H
$SG80133 DB	' ', 00H
	ORG $+2
$SG80134 DB	'TE_FieldDataRel', 00H
$SG80135 DB	'TE_FieldDataRel', 00H
$SG80136 DB	'DataOrRelfieldOrSet', 00H
$SG80137 DB	'TE_FieldDataRel', 00H
$SG80141 DB	' ', 00H
	ORG $+2
$SG80143 DB	' ', 00H
	ORG $+2
$SG80147 DB	'File ', 00H
	ORG $+2
$SG80148 DB	' is created successfully!', 00H
	ORG $+2
$SG80149 DB	'Couldn''t create file ', 00H
	ORG $+2
$SG80150 DB	'Generate DDL', 00H
	ORG $+3
$SG79217 DB	'ABSOLUTE', 00H
	ORG $+3
_szReservedName DD FLAT:$SG79217
	DD	FLAT:$SG79218
	DD	FLAT:$SG79219
	DD	FLAT:$SG79220
	DD	FLAT:$SG79221
	DD	FLAT:$SG79222
	DD	FLAT:$SG79223
	DD	FLAT:$SG79224
	DD	FLAT:$SG79225
	DD	FLAT:$SG79226
	DD	FLAT:$SG79227
	DD	FLAT:$SG79228
	DD	FLAT:$SG79229
	DD	FLAT:$SG79230
	DD	FLAT:$SG79231
	DD	FLAT:$SG79232
	DD	FLAT:$SG79233
	DD	FLAT:$SG79234
	DD	FLAT:$SG79235
	DD	FLAT:$SG79236
	DD	FLAT:$SG79237
	DD	FLAT:$SG79238
	DD	FLAT:$SG79239
	DD	FLAT:$SG79240
	DD	FLAT:$SG79241
	DD	FLAT:$SG79242
	DD	FLAT:$SG79243
	DD	FLAT:$SG79244
	DD	FLAT:$SG79245
	DD	FLAT:$SG79246
	DD	FLAT:$SG79247
	DD	FLAT:$SG79248
	DD	FLAT:$SG79249
	DD	FLAT:$SG79250
	DD	FLAT:$SG79251
	DD	FLAT:$SG79252
	DD	FLAT:$SG79253
	DD	FLAT:$SG79254
	DD	FLAT:$SG79255
	DD	FLAT:$SG79256
	DD	FLAT:$SG79257
	DD	FLAT:$SG79258
	DD	FLAT:$SG79259
	DD	FLAT:$SG79260
	DD	FLAT:$SG79261
	DD	FLAT:$SG79262
	DD	FLAT:$SG79263
	DD	FLAT:$SG79264
	DD	FLAT:$SG79265
	DD	FLAT:$SG79266
	DD	FLAT:$SG79267
	DD	FLAT:$SG79268
	DD	FLAT:$SG79269
	DD	FLAT:$SG79270
	DD	FLAT:$SG79271
	DD	FLAT:$SG79272
	DD	FLAT:$SG79273
	DD	FLAT:$SG79274
	DD	FLAT:$SG79275
	DD	FLAT:$SG79276
	DD	FLAT:$SG79277
	DD	FLAT:$SG79278
	DD	FLAT:$SG79279
	DD	FLAT:$SG79280
	DD	FLAT:$SG79281
	DD	FLAT:$SG79282
	DD	FLAT:$SG79283
	DD	FLAT:$SG79284
	DD	FLAT:$SG79285
	DD	FLAT:$SG79286
	DD	FLAT:$SG79287
	DD	FLAT:$SG79288
	DD	FLAT:$SG79289
	DD	FLAT:$SG79290
	DD	FLAT:$SG79291
	DD	FLAT:$SG79292
	DD	FLAT:$SG79293
	DD	FLAT:$SG79294
	DD	FLAT:$SG79295
	DD	FLAT:$SG79296
	DD	FLAT:$SG79297
	DD	FLAT:$SG79298
	DD	FLAT:$SG79299
	DD	FLAT:$SG79300
	DD	FLAT:$SG79301
	DD	FLAT:$SG79302
	DD	FLAT:$SG79303
	DD	FLAT:$SG79304
	DD	FLAT:$SG79305
	DD	FLAT:$SG79306
	DD	FLAT:$SG79307
	DD	FLAT:$SG79308
	DD	FLAT:$SG79309
	DD	FLAT:$SG79310
	DD	FLAT:$SG79311
	DD	FLAT:$SG79312
	DD	FLAT:$SG79313
	DD	FLAT:$SG79314
	DD	FLAT:$SG79315
	DD	FLAT:$SG79316
	DD	FLAT:$SG79317
	DD	FLAT:$SG79318
	DD	FLAT:$SG79319
	DD	FLAT:$SG79320
	DD	FLAT:$SG79321
	DD	FLAT:$SG79322
	DD	FLAT:$SG79323
	DD	FLAT:$SG79324
	DD	FLAT:$SG79325
	DD	FLAT:$SG79326
	DD	FLAT:$SG79327
	DD	FLAT:$SG79328
	DD	FLAT:$SG79329
	DD	FLAT:$SG79330
	DD	FLAT:$SG79331
	DD	FLAT:$SG79332
	DD	FLAT:$SG79333
	DD	FLAT:$SG79334
	DD	FLAT:$SG79335
	DD	FLAT:$SG79336
	DD	FLAT:$SG79337
	DD	FLAT:$SG79338
	DD	FLAT:$SG79339
	DD	FLAT:$SG79340
	DD	FLAT:$SG79341
	DD	FLAT:$SG79342
	DD	FLAT:$SG79343
	DD	FLAT:$SG79344
	DD	FLAT:$SG79345
	DD	FLAT:$SG79346
	DD	FLAT:$SG79347
	DD	FLAT:$SG79348
	DD	FLAT:$SG79349
	DD	FLAT:$SG79350
	DD	FLAT:$SG79351
	DD	FLAT:$SG79352
	DD	FLAT:$SG79353
	DD	FLAT:$SG79354
	DD	FLAT:$SG79355
	DD	FLAT:$SG79356
	DD	FLAT:$SG79357
	DD	FLAT:$SG79358
	DD	FLAT:$SG79359
	DD	FLAT:$SG79360
	DD	FLAT:$SG79361
	DD	FLAT:$SG79362
	DD	FLAT:$SG79363
	DD	FLAT:$SG79364
	DD	FLAT:$SG79365
	DD	FLAT:$SG79366
	DD	FLAT:$SG79367
	DD	FLAT:$SG79368
	DD	FLAT:$SG79369
	DD	FLAT:$SG79370
	DD	FLAT:$SG79371
	DD	FLAT:$SG79372
	DD	FLAT:$SG79373
	DD	FLAT:$SG79374
	DD	FLAT:$SG79375
	DD	FLAT:$SG79376
	DD	FLAT:$SG79377
	DD	FLAT:$SG79378
	DD	FLAT:$SG79379
	DD	FLAT:$SG79380
	DD	FLAT:$SG79381
	DD	FLAT:$SG79382
	DD	FLAT:$SG79383
	DD	FLAT:$SG79384
	DD	FLAT:$SG79385
	DD	FLAT:$SG79386
	DD	FLAT:$SG79387
	DD	FLAT:$SG79388
	DD	FLAT:$SG79389
	DD	FLAT:$SG79390
	DD	FLAT:$SG79391
	DD	FLAT:$SG79392
	DD	FLAT:$SG79393
	DD	FLAT:$SG79394
	DD	FLAT:$SG79395
	DD	FLAT:$SG79396
	DD	FLAT:$SG79397
	DD	FLAT:$SG79398
	DD	FLAT:$SG79399
	DD	FLAT:$SG79400
	DD	FLAT:$SG79401
	DD	FLAT:$SG79402
	DD	FLAT:$SG79403
	DD	FLAT:$SG79404
	DD	FLAT:$SG79405
	DD	FLAT:$SG79406
	DD	FLAT:$SG79407
	DD	FLAT:$SG79408
	DD	FLAT:$SG79409
	DD	FLAT:$SG79410
	DD	FLAT:$SG79411
	DD	FLAT:$SG79412
	DD	FLAT:$SG79413
	DD	FLAT:$SG79414
	DD	FLAT:$SG79415
	DD	FLAT:$SG79416
	DD	FLAT:$SG79417
	DD	FLAT:$SG79418
	DD	FLAT:$SG79419
	DD	FLAT:$SG79420
	DD	FLAT:$SG79421
	DD	FLAT:$SG79422
	DD	FLAT:$SG79423
	DD	FLAT:$SG79424
	DD	FLAT:$SG79425
	DD	FLAT:$SG79426
	DD	FLAT:$SG79427
	DD	FLAT:$SG79428
	DD	FLAT:$SG79429
	DD	FLAT:$SG79430
	DD	FLAT:$SG79431
	DD	FLAT:$SG79432
	DD	FLAT:$SG79433
	DD	FLAT:$SG79434
	DD	FLAT:$SG79435
	DD	FLAT:$SG79436
	DD	FLAT:$SG79437
	DD	FLAT:$SG79438
	DD	FLAT:$SG79439
	DD	FLAT:$SG79440
	DD	FLAT:$SG79441
	DD	FLAT:$SG79442
	DD	FLAT:$SG79443
	DD	FLAT:$SG79444
	DD	FLAT:$SG79445
	DD	FLAT:$SG79446
	DD	FLAT:$SG79447
	DD	FLAT:$SG79448
	DD	FLAT:$SG79449
	DD	FLAT:$SG79450
	DD	FLAT:$SG79451
	DD	FLAT:$SG79452
	DD	FLAT:$SG79453
	DD	FLAT:$SG79454
	DD	FLAT:$SG79455
	DD	FLAT:$SG79456
	DD	FLAT:$SG79457
	DD	FLAT:$SG79458
	DD	FLAT:$SG79459
	DD	FLAT:$SG79460
	DD	FLAT:$SG79461
	DD	FLAT:$SG79462
	DD	FLAT:$SG79463
	DD	FLAT:$SG79464
	DD	FLAT:$SG79465
	DD	FLAT:$SG79466
	DD	FLAT:$SG79467
	DD	FLAT:$SG79468
	DD	FLAT:$SG79469
	DD	FLAT:$SG79470
	DD	FLAT:$SG79471
	DD	FLAT:$SG79472
	DD	FLAT:$SG79473
	DD	FLAT:$SG79474
	DD	FLAT:$SG79475
	DD	FLAT:$SG79476
	DD	FLAT:$SG79477
	DD	FLAT:$SG79478
	DD	FLAT:$SG79479
	DD	FLAT:$SG79480
	DD	FLAT:$SG79481
	DD	FLAT:$SG79482
	DD	FLAT:$SG79483
	DD	FLAT:$SG79484
	DD	FLAT:$SG79485
	DD	FLAT:$SG79486
	DD	FLAT:$SG79487
	DD	FLAT:$SG79488
	DD	FLAT:$SG79489
	DD	FLAT:$SG79490
	DD	FLAT:$SG79491
	DD	FLAT:$SG79492
	DD	FLAT:$SG79493
	DD	FLAT:$SG79494
	DD	FLAT:$SG79495
	DD	FLAT:$SG79496
	DD	FLAT:$SG79497
	DD	FLAT:$SG79498
	DD	FLAT:$SG79499
	DD	FLAT:$SG79500
	DD	FLAT:$SG79501
	DD	FLAT:$SG79502
	DD	FLAT:$SG79503
	DD	FLAT:$SG79504
	DD	FLAT:$SG79505
	DD	FLAT:$SG79506
	DD	FLAT:$SG79507
	DD	FLAT:$SG79508
	DD	FLAT:$SG79509
	DD	FLAT:$SG79510
	DD	FLAT:$SG79511
	DD	FLAT:$SG79512
	DD	FLAT:$SG79513
	DD	FLAT:$SG79514
	DD	FLAT:$SG79515
	DD	FLAT:$SG79516
	DD	FLAT:$SG79517
	DD	FLAT:$SG79518
	DD	FLAT:$SG79519
	DD	FLAT:$SG79520
	DD	FLAT:$SG79521
	DD	FLAT:$SG79522
	DD	FLAT:$SG79523
	DD	FLAT:$SG79524
	DD	FLAT:$SG79525
	DD	FLAT:$SG79526
	DD	FLAT:$SG79527
	DD	FLAT:$SG79528
	DD	FLAT:$SG79529
	DD	FLAT:$SG79530
	DD	FLAT:$SG79531
	DD	FLAT:$SG79532
	DD	FLAT:$SG79533
	DD	FLAT:$SG79534
	DD	FLAT:$SG79535
	DD	FLAT:$SG79536
	DD	FLAT:$SG79537
	DD	FLAT:$SG79538
	DD	FLAT:$SG79539
	DD	FLAT:$SG79540
	DD	FLAT:$SG79541
	DD	FLAT:$SG79542
	DD	FLAT:$SG79543
	DD	FLAT:$SG79544
	DD	FLAT:$SG79545
	DD	FLAT:$SG79546
	DD	FLAT:$SG79547
	DD	FLAT:$SG79548
	DD	FLAT:$SG79549
	DD	FLAT:$SG79550
	DD	FLAT:$SG79551
	DD	FLAT:$SG79552
$SG79218 DB	'ACTION', 00H
	ORG $+1
$SG79219 DB	'ADD', 00H
$SG79220 DB	'ALL', 00H
$SG79221 DB	'ALLOCATE', 00H
	ORG $+3
$SG79222 DB	'ALPHANUMERIC', 00H
	ORG $+3
$SG79223 DB	'ALTER', 00H
	ORG $+2
$SG79224 DB	'AND', 00H
$SG79225 DB	'ANY', 00H
$SG79226 DB	'ARE', 00H
$SG79227 DB	'AS', 00H
	ORG $+1
$SG80252 DB	'Executable', 00H
	ORG $+1
$SG79228 DB	'ASC', 00H
$SG80253 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79229 DB	'ASSERTION', 00H
	ORG $+2
$SG79230 DB	'AT', 00H
	ORG $+1
$SG80255 DB	'RetrieveSchema', 00H
	ORG $+1
$SG79231 DB	'AUTHORIZATION', 00H
	ORG $+2
$SG79232 DB	'AUTOINCREMENT', 00H
	ORG $+2
$SG79233 DB	'AVG', 00H
$SG80258 DB	'Couldn''t find ''BuildSyncDDL'' in Generater Executable', 00H
	ORG $+3
$SG79234 DB	'BEGIN', 00H
	ORG $+2
$SG80259 DB	'Physical Data Model', 00H
$SG79235 DB	'BETWEEN', 00H
$SG80260 DB	'TE00422', 00H
$SG79236 DB	'BINARY', 00H
	ORG $+1
$SG79237 DB	'BIT', 00H
$SG80262 DB	'Name', 00H
	ORG $+3
$SG79238 DB	'BOOLEAN', 00H
$SG80263 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79239 DB	'BOTH', 00H
	ORG $+3
$SG80264 DB	'_alter', 00H
	ORG $+1
$SG79240 DB	'BREAK', 00H
	ORG $+2
$SG79241 DB	'BROWSE', 00H
	ORG $+1
$SG80266 DB	'.ddl', 00H
	ORG $+3
$SG79242 DB	'BULK', 00H
	ORG $+3
$SG79243 DB	'BY', 00H
	ORG $+1
$SG80268 DB	'Name', 00H
	ORG $+3
$SG79244 DB	'BYTE', 00H
	ORG $+3
$SG80269 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79245 DB	'CASCADE', 00H
$SG80270 DB	'Desc', 00H
	ORG $+3
$SG79246 DB	'CASCADED', 00H
	ORG $+3
$SG80271 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79247 DB	'CASE', 00H
	ORG $+3
$SG79248 DB	'CAST', 00H
	ORG $+3
$SG80273 DB	'--', 00H
	ORG $+1
$SG79249 DB	'CATALOG', 00H
$SG80274 DB	'%s Alter script for %s -- %s %s', 00H
$SG79250 DB	'CHAR', 00H
	ORG $+3
$SG79251 DB	'CHARACTER', 00H
	ORG $+2
$SG80276 DB	'DefaultOwner', 00H
	ORG $+3
$SG79252 DB	'CHARACTER_LENGTH', 00H
	ORG $+3
$SG80277 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79253 DB	'CHAR_LENGTH', 00H
$SG79254 DB	'CHECK', 00H
	ORG $+2
$SG79255 DB	'CHECKPOINT', 00H
	ORG $+1
$SG80280 DB	'TE_TablRec', 00H
	ORG $+1
$SG79256 DB	'CLOSE', 00H
	ORG $+2
$SG80281 DB	'TE_TablRec', 00H
	ORG $+1
$SG79257 DB	'CLUSTERED', 00H
	ORG $+2
$SG80282 DB	'N', 00H
	ORG $+2
$SG79258 DB	'COALESCE', 00H
	ORG $+3
$SG80283 DB	'MatchFound', 00H
	ORG $+1
$SG79259 DB	'COLLATE', 00H
$SG80284 DB	'TE_TablRec', 00H
	ORG $+1
$SG79260 DB	'COLLATION', 00H
	ORG $+2
$SG80285 DB	'TE_FieldDataRel', 00H
$SG79261 DB	'COLUMN', 00H
	ORG $+1
$SG80286 DB	'TE_FieldDataRel', 00H
$SG79262 DB	'COMMIT', 00H
	ORG $+1
$SG80287 DB	'N', 00H
	ORG $+2
$SG79263 DB	'COMMITTED', 00H
	ORG $+2
$SG80288 DB	'MatchFound', 00H
	ORG $+1
$SG79264 DB	'COMPUTE', 00H
$SG80289 DB	'TE_FieldDataRel', 00H
$SG79265 DB	'CONFIRM', 00H
$SG80290 DB	'TE_TablRec', 00H
	ORG $+1
$SG79266 DB	'CONNECT', 00H
$SG80291 DB	'TE_TablRec', 00H
	ORG $+1
$SG79267 DB	'CONNECTION', 00H
	ORG $+1
$SG79268 DB	'CONSTRAINT', 00H
	ORG $+1
$SG80293 DB	'Name', 00H
	ORG $+3
$SG79269 DB	'CONSTRAINTS', 00H
$SG80294 DB	'TE_TablRec', 00H
	ORG $+1
$SG79270 DB	'CONTINUE', 00H
	ORG $+3
$SG80295 DB	'Name', 00H
	ORG $+3
$SG79271 DB	'CONTROLROW', 00H
	ORG $+1
$SG80296 DB	'TE_TablRec', 00H
	ORG $+1
$SG79272 DB	'CONVERT', 00H
$SG80297 DB	'Name', 00H
	ORG $+3
$SG79273 DB	'CORRESPONDING', 00H
	ORG $+2
$SG80298 DB	'TE_TablRec', 00H
	ORG $+1
$SG79274 DB	'COUNT', 00H
	ORG $+2
$SG80299 DB	'Y', 00H
	ORG $+2
$SG79275 DB	'COUNTER', 00H
$SG80300 DB	'MatchFound', 00H
	ORG $+1
$SG79276 DB	'CREATE', 00H
	ORG $+1
$SG80301 DB	'TE_TablRec', 00H
	ORG $+1
$SG79277 DB	'CROSS', 00H
	ORG $+2
$SG80302 DB	'Y', 00H
	ORG $+2
$SG79278 DB	'CURRENCY', 00H
	ORG $+3
$SG80303 DB	'MatchFound', 00H
	ORG $+1
$SG79279 DB	'CURRENT', 00H
$SG80304 DB	'TE_TablRec', 00H
	ORG $+1
$SG79280 DB	'CURRENT_DATE', 00H
	ORG $+3
$SG80305 DB	'TE_FieldDataRel', 00H
$SG79281 DB	'CURRENT_TIME', 00H
	ORG $+3
$SG80306 DB	'TE_FieldDataRel', 00H
$SG79282 DB	'CURRENT_TIMESTAMP', 00H
	ORG $+2
$SG79283 DB	'CURRENT_USER', 00H
	ORG $+3
$SG80308 DB	'Name', 00H
	ORG $+3
$SG79284 DB	'CURSOR', 00H
	ORG $+1
$SG80309 DB	'TE_FieldDataRel', 00H
$SG79285 DB	'DATABASE', 00H
	ORG $+3
$SG80310 DB	'Name', 00H
	ORG $+3
$SG79286 DB	'DATE', 00H
	ORG $+3
$SG80311 DB	'TE_FieldDataRel', 00H
$SG79287 DB	'DATETIME', 00H
	ORG $+3
$SG80312 DB	'Name', 00H
	ORG $+3
$SG79288 DB	'DAY', 00H
$SG80313 DB	'TE_FieldDataRel', 00H
$SG79289 DB	'DBAREA', 00H
	ORG $+1
$SG80314 DB	'Length', 00H
	ORG $+1
$SG79290 DB	'DBCC', 00H
	ORG $+3
$SG80315 DB	'TE_FieldDataRel', 00H
$SG79291 DB	'DEALLOCATE', 00H
	ORG $+1
$SG80316 DB	'Length', 00H
	ORG $+1
$SG79292 DB	'DEBUG', 00H
	ORG $+2
$SG80317 DB	'TE_FieldDataRel', 00H
$SG79293 DB	'DECLARE', 00H
$SG80318 DB	'DataType', 00H
	ORG $+3
$SG79294 DB	'DEFAULT', 00H
$SG80319 DB	'TE_FieldDataRel', 00H
$SG79295 DB	'DEFERRABLE', 00H
	ORG $+1
$SG80320 DB	'DataType', 00H
	ORG $+3
$SG79296 DB	'DEFERRED', 00H
	ORG $+3
$SG80321 DB	'TE_FieldDataRel', 00H
$SG79297 DB	'DELETE', 00H
	ORG $+1
$SG79298 DB	'DESC', 00H
	ORG $+3
$SG79299 DB	'DESCRIBE', 00H
	ORG $+3
$SG79300 DB	'DESCRIPTOR', 00H
	ORG $+1
$SG79301 DB	'DIAGNOSTICS', 00H
$SG79302 DB	'DISALLOW', 00H
	ORG $+3
$SG79303 DB	'DISCONNECT', 00H
	ORG $+1
$SG80328 DB	'D', 00H
	ORG $+2
$SG79304 DB	'DISK', 00H
	ORG $+3
$SG80329 DB	'MatchFound', 00H
	ORG $+1
$SG79305 DB	'DISTINCT', 00H
	ORG $+3
$SG80330 DB	'TE_FieldDataRel', 00H
$SG79306 DB	'DISTINCTROW', 00H
$SG80331 DB	'D', 00H
	ORG $+2
$SG79307 DB	'DISTRIBUTED', 00H
$SG80332 DB	'MatchFound', 00H
	ORG $+1
$SG79308 DB	'DOMAIN', 00H
	ORG $+1
$SG80333 DB	'TE_FieldDataRel', 00H
$SG79309 DB	'DOUBLE', 00H
	ORG $+1
$SG80334 DB	'Y', 00H
	ORG $+2
$SG79310 DB	'DROP', 00H
	ORG $+3
$SG80335 DB	'MatchFound', 00H
	ORG $+1
$SG79311 DB	'DUMMY', 00H
	ORG $+2
$SG80336 DB	'TE_FieldDataRel', 00H
$SG79312 DB	'DUMP', 00H
	ORG $+3
$SG80337 DB	'Y', 00H
	ORG $+2
$SG79313 DB	'ELSE', 00H
	ORG $+3
$SG80338 DB	'MatchFound', 00H
	ORG $+1
$SG79314 DB	'END', 00H
$SG80339 DB	'TE_FieldDataRel', 00H
$SG79315 DB	'END_EXEC', 00H
	ORG $+3
$SG80340 DB	'TE_TablRec', 00H
	ORG $+1
$SG79316 DB	'EQV', 00H
$SG80341 DB	'TE_TablRec', 00H
	ORG $+1
$SG79317 DB	'ERRLVL', 00H
	ORG $+1
$SG80342 DB	'Name', 00H
	ORG $+3
$SG79318 DB	'ERROREXIT', 00H
	ORG $+2
$SG80343 DB	'TE_TablRec', 00H
	ORG $+1
$SG79319 DB	'ESCAPE', 00H
	ORG $+1
$SG79320 DB	'EXCEPT', 00H
	ORG $+1
$SG80345 DB	'N', 00H
	ORG $+2
$SG79321 DB	'EXCEPTION', 00H
	ORG $+2
$SG80346 DB	'MatchFound', 00H
	ORG $+1
$SG79322 DB	'EXEC', 00H
	ORG $+3
$SG80347 DB	'TE_TablRec', 00H
	ORG $+1
$SG79323 DB	'EXECUTE', 00H
$SG79324 DB	'EXISTS', 00H
	ORG $+1
$SG79325 DB	'EXIT', 00H
	ORG $+3
$SG80350 DB	'TE_FieldDataRel', 00H
$SG79326 DB	'EXPIREDATE', 00H
	ORG $+1
$SG80351 DB	'TE_FieldDataRel', 00H
$SG79327 DB	'EXTERNAL', 00H
	ORG $+3
$SG80352 DB	'DataOrRelfieldOrSet', 00H
$SG79328 DB	'EXTRACT', 00H
$SG80353 DB	'TE_FieldDataRel', 00H
$SG79329 DB	'FALSE', 00H
	ORG $+2
$SG79330 DB	'FETCH', 00H
	ORG $+2
$SG79331 DB	'FILE', 00H
	ORG $+3
$SG80356 DB	'TE_TablRec', 00H
	ORG $+1
$SG79332 DB	'FILLFACTOR', 00H
	ORG $+1
$SG80357 DB	'TE_TablRec', 00H
	ORG $+1
$SG79333 DB	'FIRST', 00H
	ORG $+2
$SG80358 DB	'Name', 00H
	ORG $+3
$SG79334 DB	'FLOAT', 00H
	ORG $+2
$SG80359 DB	'TE_TablRec', 00H
	ORG $+1
$SG79335 DB	'FLOAT4', 00H
	ORG $+1
$SG79336 DB	'FLOAT8', 00H
	ORG $+1
$SG80361 DB	'N', 00H
	ORG $+2
$SG79337 DB	'FLOPPY', 00H
	ORG $+1
$SG80362 DB	'MatchFound', 00H
	ORG $+1
$SG79338 DB	'FOR', 00H
$SG80363 DB	'TE_TablRec', 00H
	ORG $+1
$SG79339 DB	'FOREIGN', 00H
$SG80364 DB	'TE_FieldDataRel', 00H
$SG79340 DB	'FROM', 00H
	ORG $+3
$SG80365 DB	'TE_FieldDataRel', 00H
$SG79341 DB	'FULL', 00H
	ORG $+3
$SG80366 DB	'MatchFound', 00H
	ORG $+1
$SG79342 DB	'GET', 00H
$SG80367 DB	'TE_FieldDataRel', 00H
$SG79343 DB	'GETDEFAULT', 00H
	ORG $+1
$SG79344 DB	'GLOBAL', 00H
	ORG $+1
$SG79345 DB	'GOTO', 00H
	ORG $+3
$SG79346 DB	'GRANT', 00H
	ORG $+2
$SG80371 DB	'ER_Entity', 00H
	ORG $+2
$SG79347 DB	'GROUP', 00H
	ORG $+2
$SG80372 DB	'Name', 00H
	ORG $+3
$SG79348 DB	'GUID', 00H
	ORG $+3
$SG80373 DB	'ER_Entity', 00H
	ORG $+2
$SG79349 DB	'HAVING', 00H
	ORG $+1
$SG79350 DB	'HOLDLOCK', 00H
	ORG $+3
$SG79351 DB	'HOUR', 00H
	ORG $+3
$SG79352 DB	'IDENTITY', 00H
	ORG $+3
$SG80377 DB	'--', 00H
	ORG $+1
$SG79353 DB	'IDENTITYCOL', 00H
$SG80378 DB	'%s Entity %s %s', 00H
$SG79354 DB	'IDENTITY_INSERT', 00H
$SG79355 DB	'IEEEDOUBLE', 00H
	ORG $+1
$SG80380 DB	'Name', 00H
	ORG $+3
$SG79356 DB	'IEEESINGLE', 00H
	ORG $+1
$SG80381 DB	'TE_FieldDataRel', 00H
$SG79357 DB	'IF', 00H
	ORG $+1
$SG80382 DB	'ALTER TABLE %s ADD COLUMN ', 00H
	ORG $+1
$SG79358 DB	'IGNORE', 00H
	ORG $+1
$SG80383 DB	';', 00H
	ORG $+2
$SG79359 DB	'IMMEDIATE', 00H
	ORG $+2
$SG79360 DB	'IMP', 00H
$SG80385 DB	'DataOrRelfieldOrSet', 00H
$SG79361 DB	'IN', 00H
	ORG $+1
$SG80386 DB	'TE_FieldDataRel', 00H
$SG79362 DB	'INDEX', 00H
	ORG $+2
$SG79363 DB	'INITIALLY', 00H
	ORG $+2
$SG79364 DB	'INNER', 00H
	ORG $+2
$SG80389 DB	'TE_TablRec', 00H
	ORG $+1
$SG79365 DB	'INPUT', 00H
	ORG $+2
$SG80390 DB	'TE_TablRec', 00H
	ORG $+1
$SG79366 DB	'INSENSITIVE', 00H
$SG80391 DB	'Name', 00H
	ORG $+3
$SG79367 DB	'INSERT', 00H
	ORG $+1
$SG80392 DB	'TE_TablRec', 00H
	ORG $+1
$SG79368 DB	'INT', 00H
$SG79369 DB	'INTEGER', 00H
$SG80394 DB	'Y', 00H
	ORG $+2
$SG79370 DB	'INTEGER1', 00H
	ORG $+3
$SG80395 DB	'MatchFound', 00H
	ORG $+1
$SG79371 DB	'INTEGER2', 00H
	ORG $+3
$SG80396 DB	'TE_TablRec', 00H
	ORG $+1
$SG79372 DB	'INTERSECT', 00H
	ORG $+2
$SG80397 DB	';', 00H
	ORG $+2
$SG79373 DB	'INTERVAL', 00H
	ORG $+3
$SG80398 DB	'DROP TABLE %s %s', 00H
	ORG $+3
$SG79374 DB	'INTO', 00H
	ORG $+3
$SG79375 DB	'IS', 00H
	ORG $+1
$SG80400 DB	'TE_TablRec', 00H
	ORG $+1
$SG79376 DB	'ISOLATION', 00H
	ORG $+2
$SG80401 DB	'TE_TablRec', 00H
	ORG $+1
$SG79377 DB	'JOIN', 00H
	ORG $+3
$SG80402 DB	'Name', 00H
	ORG $+3
$SG79378 DB	'KEY', 00H
$SG80403 DB	'TE_TablRec', 00H
	ORG $+1
$SG79379 DB	'KILL', 00H
	ORG $+3
$SG79380 DB	'LAST', 00H
	ORG $+3
$SG80405 DB	'Y', 00H
	ORG $+2
$SG79381 DB	'LEADING', 00H
$SG80406 DB	'MatchFound', 00H
	ORG $+1
$SG79382 DB	'LEFT', 00H
	ORG $+3
$SG80407 DB	'TE_TablRec', 00H
	ORG $+1
$SG79383 DB	'LEVEL', 00H
	ORG $+2
$SG80408 DB	'Name', 00H
	ORG $+3
$SG79384 DB	'LIKE', 00H
	ORG $+3
$SG80409 DB	'TE_TablRec', 00H
	ORG $+1
$SG79385 DB	'LINENO', 00H
	ORG $+1
$SG80410 DB	'Name', 00H
	ORG $+3
$SG79386 DB	'LOAD', 00H
	ORG $+3
$SG80411 DB	'TE_TablRec', 00H
	ORG $+1
$SG79387 DB	'LOCAL', 00H
	ORG $+2
$SG80412 DB	'SQL_TableOwner', 00H
	ORG $+1
$SG79388 DB	'LOGICAL', 00H
$SG80413 DB	'TE_TablRec', 00H
	ORG $+1
$SG79389 DB	'LOGICAL1', 00H
	ORG $+3
$SG79390 DB	'LONG', 00H
	ORG $+3
$SG79391 DB	'LONGBINARY', 00H
	ORG $+1
$SG80416 DB	'.', 00H
	ORG $+2
$SG79392 DB	'LONGTEXT', 00H
	ORG $+3
$SG80417 DB	'TE_FieldDataRel', 00H
$SG79393 DB	'MATCH', 00H
	ORG $+2
$SG80418 DB	'TE_FieldDataRel', 00H
$SG79394 DB	'MAX', 00H
$SG79395 DB	'MEMO', 00H
	ORG $+3
$SG80420 DB	'Y', 00H
	ORG $+2
$SG79396 DB	'MIN', 00H
$SG80421 DB	'MatchFound', 00H
	ORG $+1
$SG79397 DB	'MINUTE', 00H
	ORG $+1
$SG80422 DB	'TE_FieldDataRel', 00H
$SG79398 DB	'MIRROREXIT', 00H
	ORG $+1
$SG79399 DB	'MOD', 00H
$SG80424 DB	'Name', 00H
	ORG $+3
$SG79400 DB	'MONEY', 00H
	ORG $+2
$SG80425 DB	'ER_Entity', 00H
	ORG $+2
$SG79401 DB	'MONTH', 00H
	ORG $+2
$SG79402 DB	'NAMES', 00H
	ORG $+2
$SG79403 DB	'NATIONAL', 00H
	ORG $+3
$SG79404 DB	'NATURAL', 00H
$SG80429 DB	'--', 00H
	ORG $+1
$SG79405 DB	'NCHAR', 00H
	ORG $+2
$SG80430 DB	'%s Entity %s %s', 00H
$SG79406 DB	'NEXT', 00H
	ORG $+3
$SG79407 DB	'NEXTLOG', 00H
$SG80432 DB	'Name', 00H
	ORG $+3
$SG79408 DB	'NO', 00H
	ORG $+1
$SG80433 DB	'TE_FieldDataRel', 00H
$SG79409 DB	'NOCHECK', 00H
$SG80434 DB	'TE_TablRec', 00H
	ORG $+1
$SG79410 DB	'NONCLUSTERED', 00H
	ORG $+3
$SG80435 DB	'Name', 00H
	ORG $+3
$SG79411 DB	'NOT', 00H
$SG80436 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG79412 DB	'NOTE', 00H
	ORG $+3
$SG80437 DB	'TE_TablRec', 00H
	ORG $+1
$SG79413 DB	'NULL', 00H
	ORG $+3
$SG80438 DB	'Name', 00H
	ORG $+3
$SG79414 DB	'NULLIF', 00H
	ORG $+1
$SG80439 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG79415 DB	'NUMBER', 00H
	ORG $+1
$SG80440 DB	'IndexName', 00H
	ORG $+2
$SG79416 DB	'NUMERIC', 00H
$SG80441 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG79417 DB	'OCTET_LENGTH', 00H
	ORG $+3
$SG79418 DB	'OF', 00H
	ORG $+1
$SG79419 DB	'OFF', 00H
$SG80444 DB	'N', 00H
	ORG $+2
$SG79420 DB	'OFFSETS', 00H
$SG80445 DB	'MatchFound', 00H
	ORG $+1
$SG79421 DB	'OLEOBJECT', 00H
	ORG $+2
$SG80446 DB	'TE_FieldDataRel', 00H
$SG79422 DB	'ON', 00H
	ORG $+1
$SG80447 DB	';', 00H
	ORG $+2
$SG79423 DB	'ONCE', 00H
	ORG $+3
$SG80448 DB	'ALTER TABLE %s%s DROP COLUMN %s %s', 00H
	ORG $+1
$SG79424 DB	'ONLY', 00H
	ORG $+3
$SG79425 DB	'OPEN', 00H
	ORG $+3
$SG79426 DB	'OPTION', 00H
	ORG $+1
$SG80451 DB	'D', 00H
	ORG $+2
$SG79427 DB	'OR', 00H
	ORG $+1
$SG80452 DB	'MatchFound', 00H
	ORG $+1
$SG79428 DB	'ORDER', 00H
	ORG $+2
$SG80453 DB	'TE_FieldDataRel', 00H
$SG79429 DB	'OUTER', 00H
	ORG $+2
$SG80454 DB	'ALTER TABLE %s%-*s ALTER COLUMN ', 00H
	ORG $+3
$SG79430 DB	'OUTPUT', 00H
	ORG $+1
$SG80455 DB	';', 00H
	ORG $+2
$SG79431 DB	'OVER', 00H
	ORG $+3
$SG79432 DB	'OVERLAPS', 00H
	ORG $+3
$SG80457 DB	'DataOrRelfieldOrSet', 00H
$SG79433 DB	'OWNERACCESS', 00H
$SG80458 DB	'TE_FieldDataRel', 00H
$SG79434 DB	'PAD', 00H
$SG79435 DB	'PARAMETERS', 00H
	ORG $+1
$SG79436 DB	'PARTIAL', 00H
$SG79437 DB	'PERCENT', 00H
$SG80462 DB	'TE_TablRec', 00H
	ORG $+1
$SG79438 DB	'PERM', 00H
	ORG $+3
$SG80463 DB	'Name', 00H
	ORG $+3
$SG79439 DB	'PERMANENT', 00H
	ORG $+2
$SG80464 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG79440 DB	'PIPE', 00H
	ORG $+3
$SG80465 DB	'TE_TablRec', 00H
	ORG $+1
$SG79441 DB	'PIVOT', 00H
	ORG $+2
$SG80466 DB	'Name', 00H
	ORG $+3
$SG79442 DB	'PLAN', 00H
	ORG $+3
$SG80467 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG79443 DB	'POSITION', 00H
	ORG $+3
$SG79444 DB	'PRECISION', 00H
	ORG $+2
$SG79445 DB	'PREPARE', 00H
$SG80470 DB	'WARNING: The data type for the column %s.%s has been cha'
	DB	'nged and therefore had an index deleted.  The column is NOT a'
	DB	' key and therefore the index was added by the DBA.  An attemp'
	DB	't has been made to recreate the index in the DDL.  Look for '''
	DB	'WARNING'' in the DDL file', 00H
$SG79446 DB	'PRESEVE', 00H
$SG80471 DB	'DDL Generationg Warning', 00H
$SG79447 DB	'PRIMARY', 00H
$SG79448 DB	'PRINT', 00H
	ORG $+2
$SG80473 DB	'--', 00H
	ORG $+1
$SG79449 DB	'PRIOR', 00H
	ORG $+2
$SG79450 DB	'PRIVILEGES', 00H
	ORG $+1
$SG80474 DB	'%s WARNING--Following index may not have the  same the c'
	DB	'olumns as the original index: %s', 00H
	ORG $+3
$SG79451 DB	'PROC', 00H
	ORG $+3
$SG79452 DB	'PROCEDURE', 00H
	ORG $+2
$SG79453 DB	'PROCESSEXIT', 00H
$SG79454 DB	'PUBLIC', 00H
	ORG $+1
$SG79455 DB	'RAISERROR', 00H
	ORG $+2
$SG79456 DB	'READ', 00H
	ORG $+3
$SG79457 DB	'READTEXT', 00H
	ORG $+3
$SG79458 DB	'REAL', 00H
	ORG $+3
$SG79459 DB	'RECONFIGURE', 00H
$SG79460 DB	'REFERENCES', 00H
	ORG $+1
$SG79461 DB	'RELATIVE', 00H
	ORG $+3
$SG79462 DB	'REPEATABLE', 00H
	ORG $+1
$SG79463 DB	'REPLICATION', 00H
$SG79464 DB	'RESTRICT', 00H
	ORG $+3
$SG79465 DB	'RETAINDAY', 00H
	ORG $+2
$SG79466 DB	'RETURN', 00H
	ORG $+1
$SG79467 DB	'REVOKE', 00H
	ORG $+1
$SG80492 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79468 DB	'RIGHT', 00H
	ORG $+2
$SG80493 DB	'S', 00H
	ORG $+2
$SG79469 DB	'ROLLBACK', 00H
	ORG $+3
$SG80494 DB	'InternalName', 00H
	ORG $+3
$SG79470 DB	'ROWCOUNT', 00H
	ORG $+3
$SG80495 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79471 DB	'ROWS', 00H
	ORG $+3
$SG80496 DB	'String', 00H
	ORG $+1
$SG79472 DB	'RULE', 00H
	ORG $+3
$SG80497 DB	'ExternalName', 00H
	ORG $+3
$SG79473 DB	'SAVE', 00H
	ORG $+3
$SG80498 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79474 DB	'SCHEMA', 00H
	ORG $+1
$SG80499 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79475 DB	'SCROLL', 00H
	ORG $+1
$SG80500 DB	'L', 00H
	ORG $+2
$SG79476 DB	'SECOND', 00H
	ORG $+1
$SG80501 DB	'InternalName', 00H
	ORG $+3
$SG79477 DB	'SELECT', 00H
	ORG $+1
$SG80502 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79478 DB	'SERIALIZABLE', 00H
	ORG $+3
$SG80503 DB	'Integer', 00H
$SG79479 DB	'SESSION', 00H
$SG80504 DB	'ExternalName', 00H
	ORG $+3
$SG79480 DB	'SESSION_USER', 00H
	ORG $+3
$SG80505 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79481 DB	'SET', 00H
$SG80506 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79482 DB	'SETUSER', 00H
$SG80507 DB	'M', 00H
	ORG $+2
$SG79483 DB	'SHORT', 00H
	ORG $+2
$SG80508 DB	'InternalName', 00H
	ORG $+3
$SG79484 DB	'SHUTDOWN', 00H
	ORG $+3
$SG80509 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79485 DB	'SINGLE', 00H
	ORG $+1
$SG80510 DB	'Decimal', 00H
$SG79486 DB	'SIZE', 00H
	ORG $+3
$SG80511 DB	'ExternalName', 00H
	ORG $+3
$SG79487 DB	'SMALLINT', 00H
	ORG $+3
$SG80512 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79488 DB	'SOME', 00H
	ORG $+3
$SG80513 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79489 DB	'SPACE', 00H
	ORG $+2
$SG80514 DB	'T', 00H
	ORG $+2
$SG79490 DB	'SQLSTATE', 00H
	ORG $+3
$SG80515 DB	'InternalName', 00H
	ORG $+3
$SG79491 DB	'STATISTICS', 00H
	ORG $+1
$SG80516 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79492 DB	'STDEV', 00H
	ORG $+2
$SG80517 DB	'Timestamp', 00H
	ORG $+2
$SG79493 DB	'STDEVP', 00H
	ORG $+1
$SG80518 DB	'ExternalName', 00H
	ORG $+3
$SG79494 DB	'STRING', 00H
	ORG $+1
$SG80519 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79495 DB	'SUM', 00H
$SG80520 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79496 DB	'SYSTEM_USER', 00H
$SG80521 DB	'X', 00H
	ORG $+2
$SG79497 DB	'TABLE', 00H
	ORG $+2
$SG80522 DB	'InternalName', 00H
	ORG $+3
$SG79498 DB	'TABLEID', 00H
$SG80523 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79499 DB	'TAPE', 00H
	ORG $+3
$SG80524 DB	'TimeStampEx', 00H
$SG79500 DB	'TEMP', 00H
	ORG $+3
$SG80525 DB	'ExternalName', 00H
	ORG $+3
$SG79501 DB	'TEMPORARY', 00H
	ORG $+2
$SG80526 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79502 DB	'TEXT', 00H
	ORG $+3
$SG80527 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79503 DB	'TEXTSIZE', 00H
	ORG $+3
$SG80528 DB	'D', 00H
	ORG $+2
$SG79504 DB	'THEN', 00H
	ORG $+3
$SG80529 DB	'InternalName', 00H
	ORG $+3
$SG79505 DB	'TIME', 00H
	ORG $+3
$SG80530 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79506 DB	'TIMESTAMP', 00H
	ORG $+2
$SG80531 DB	'Date', 00H
	ORG $+3
$SG79507 DB	'TIMEZONE_HOUR', 00H
	ORG $+2
$SG80532 DB	'ExternalName', 00H
	ORG $+3
$SG79508 DB	'TIMEZONE_MINUTE', 00H
$SG80533 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79509 DB	'TO', 00H
	ORG $+1
$SG80534 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79510 DB	'TOP', 00H
$SG80535 DB	'I', 00H
	ORG $+2
$SG79511 DB	'TRAILING', 00H
	ORG $+3
$SG80536 DB	'InternalName', 00H
	ORG $+3
$SG79512 DB	'TRAN', 00H
	ORG $+3
$SG80537 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79513 DB	'TRANSACTION', 00H
$SG80538 DB	'Time', 00H
	ORG $+3
$SG79514 DB	'TRANSFORM', 00H
	ORG $+2
$SG80539 DB	'ExternalName', 00H
	ORG $+3
$SG79515 DB	'TRANSLATE', 00H
	ORG $+2
$SG80540 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79516 DB	'TRANSLATION', 00H
$SG80541 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79517 DB	'TRIGGER', 00H
$SG80542 DB	'F', 00H
	ORG $+2
$SG79518 DB	'TRUE', 00H
	ORG $+3
$SG80543 DB	'InternalName', 00H
	ORG $+3
$SG79519 DB	'TRUNCATE', 00H
	ORG $+3
$SG80544 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79520 DB	'TSEQUAL', 00H
$SG80545 DB	'FixedChar', 00H
	ORG $+2
$SG79521 DB	'UNCOMMITTED', 00H
$SG80546 DB	'ExternalName', 00H
	ORG $+3
$SG79522 DB	'UNION', 00H
	ORG $+2
$SG80547 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79523 DB	'UNIQUE', 00H
	ORG $+1
$SG80548 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79524 DB	'UNKNOWN', 00H
$SG80549 DB	'B', 00H
	ORG $+2
$SG79525 DB	'UPDATE', 00H
	ORG $+1
$SG80550 DB	'InternalName', 00H
	ORG $+3
$SG79526 DB	'UPDATETEXT', 00H
	ORG $+1
$SG80551 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79527 DB	'USAGE', 00H
	ORG $+2
$SG80552 DB	'Blob (Memo)', 00H
$SG79528 DB	'USE', 00H
$SG80553 DB	'ExternalName', 00H
	ORG $+3
$SG79529 DB	'USER', 00H
	ORG $+3
$SG80554 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79530 DB	'USING', 00H
	ORG $+2
$SG80555 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79531 DB	'VALUE', 00H
	ORG $+2
$SG80556 DB	'V', 00H
	ORG $+2
$SG79532 DB	'VALUES', 00H
	ORG $+1
$SG80557 DB	'InternalName', 00H
	ORG $+3
$SG79533 DB	'VAR', 00H
$SG80558 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79534 DB	'VARBINARY', 00H
	ORG $+2
$SG80559 DB	'Memo', 00H
	ORG $+3
$SG79535 DB	'VARCHAR', 00H
$SG80560 DB	'ExternalName', 00H
	ORG $+3
$SG79536 DB	'VARP', 00H
	ORG $+3
$SG80561 DB	'DB_DataTypes', 00H
	ORG $+3
$SG79537 DB	'VARYING', 00H
$SG79538 DB	'VIEW', 00H
	ORG $+3
$SG79539 DB	'VOLUME', 00H
	ORG $+1
$SG79540 DB	'WAITFOR', 00H
$SG79541 DB	'WHEN', 00H
	ORG $+3
$SG79542 DB	'WHERE', 00H
	ORG $+2
$SG79543 DB	'WHILE', 00H
	ORG $+2
$SG79544 DB	'WITH', 00H
	ORG $+3
$SG79545 DB	'WORK', 00H
	ORG $+3
$SG79546 DB	'WRITE', 00H
	ORG $+2
$SG79547 DB	'WRITETEXT', 00H
	ORG $+2
$SG79548 DB	'XOR', 00H
$SG79549 DB	'YEAR', 00H
	ORG $+3
$SG79550 DB	'YESNO', 00H
	ORG $+2
$SG79551 DB	'ZONE', 00H
	ORG $+3
$SG80582 DB	'TZTEDBLO', 00H
	ORG $+3
$SG80584 DB	'DBMS', 00H
	ORG $+3
$SG80585 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80586 DB	'DBMS', 00H
	ORG $+3
$SG80587 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80588 DB	'DBH_Data', 00H
	ORG $+3
$SG80589 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80590 DB	'DBH_Data', 00H
	ORG $+3
$SG80591 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79569 DB	';', 00H
	ORG $+2
$SG80594 DB	'Y', 00H
	ORG $+2
$SG79570 DB	'DROP INDEX %s ON %s%s %s', 00H
	ORG $+3
$SG80595 DB	'TimestampAsString', 00H
	ORG $+2
$SG80596 DB	'ODBC', 00H
	ORG $+3
$SG80598 DB	'Y', 00H
	ORG $+2
$SG80599 DB	'TimestampAsString', 00H
	ORG $+2
$SG80600 DB	'ODBC', 00H
	ORG $+3
$SG80601 DB	'Name', 00H
	ORG $+3
$SG80602 DB	'Domain', 00H
	ORG $+1
$SG80605 DB	'Date', 00H
	ORG $+3
$SG80606 DB	'D', 00H
	ORG $+2
$SG80607 DB	'DataType', 00H
	ORG $+3
$SG80608 DB	'TE_FieldDataRel', 00H
$SG80611 DB	'Time', 00H
	ORG $+3
$SG80612 DB	'I', 00H
	ORG $+2
$SG80613 DB	'DataType', 00H
	ORG $+3
$SG80614 DB	'TE_FieldDataRel', 00H
$SG80617 DB	'TimeStampEx', 00H
$SG80618 DB	'X', 00H
	ORG $+2
$SG80619 DB	'DataType', 00H
	ORG $+3
$SG80620 DB	'TE_FieldDataRel', 00H
$SG80621 DB	'DataType', 00H
	ORG $+3
$SG80622 DB	'Domain', 00H
	ORG $+1
$SG80623 DB	'DataType', 00H
	ORG $+3
$SG80624 DB	'TE_FieldDataRel', 00H
$SG80625 DB	'DataType', 00H
	ORG $+3
$SG80626 DB	'Domain', 00H
	ORG $+1
$SG79603 DB	'TZTEDBLO', 00H
	ORG $+3
$SG80628 DB	'Lth', 00H
$SG80629 DB	'ER_Attribute', 00H
	ORG $+3
$SG79605 DB	'DBMS', 00H
	ORG $+3
$SG79606 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80631 DB	'MaxStringLth', 00H
	ORG $+3
$SG79607 DB	'DBMS', 00H
	ORG $+3
$SG80632 DB	'Domain', 00H
	ORG $+1
$SG79608 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79609 DB	'DBH_Data', 00H
	ORG $+3
$SG80634 DB	'V', 00H
	ORG $+2
$SG79610 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80635 DB	'DataType', 00H
	ORG $+3
$SG79611 DB	'DBH_Data', 00H
	ORG $+3
$SG80636 DB	'TE_FieldDataRel', 00H
$SG79612 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80637 DB	'DataType', 00H
	ORG $+3
$SG80638 DB	'TE_FieldDataRel', 00H
$SG79615 DB	'Y', 00H
	ORG $+2
$SG80640 DB	'Lth', 00H
$SG79616 DB	'TimestampAsString', 00H
	ORG $+2
$SG80641 DB	'ER_Attribute', 00H
	ORG $+3
$SG79617 DB	'ODBC', 00H
	ORG $+3
$SG80643 DB	'MaxStringLth', 00H
	ORG $+3
$SG79619 DB	'MaxColumnNameLength', 00H
$SG80644 DB	'Domain', 00H
	ORG $+1
$SG79620 DB	'ODBC', 00H
	ORG $+3
$SG80645 DB	'Length', 00H
	ORG $+1
$SG80646 DB	'TE_FieldDataRel', 00H
$SG79623 DB	'Y', 00H
	ORG $+2
$SG80648 DB	'Lth', 00H
$SG79624 DB	'TimestampAsString', 00H
	ORG $+2
$SG80649 DB	'ER_Attribute', 00H
	ORG $+3
$SG79625 DB	'ODBC', 00H
	ORG $+3
$SG80650 DB	'Length', 00H
	ORG $+1
$SG80651 DB	'TE_FieldDataRel', 00H
$SG79628 DB	'Name', 00H
	ORG $+3
$SG80653 DB	'Length', 00H
	ORG $+1
$SG79629 DB	'TE_FieldDataRel', 00H
$SG80654 DB	'TE_FieldDataRel', 00H
$SG79630 DB	'DataType', 00H
	ORG $+3
$SG79631 DB	'TE_FieldDataRel', 00H
$SG80656 DB	'Length', 00H
	ORG $+1
$SG79632 DB	'%-*s', 00H
	ORG $+3
$SG80657 DB	'TE_FieldDataRel', 00H
$SG79634 DB	'Length', 00H
	ORG $+1
$SG80659 DB	'Lth', 00H
$SG79635 DB	'TE_FieldDataRel', 00H
$SG80660 DB	'ER_Attribute', 00H
	ORG $+3
$SG79636 DB	' TEXT( %ld )', 00H
	ORG $+3
$SG80662 DB	'MaxStringLth', 00H
	ORG $+3
$SG79638 DB	' LONGBINARY', 00H
$SG80663 DB	'Domain', 00H
	ORG $+1
$SG79640 DB	' INTEGER', 00H
	ORG $+3
$SG80665 DB	'Length', 00H
	ORG $+1
$SG80666 DB	'TE_FieldDataRel', 00H
$SG79642 DB	' DOUBLE', 00H
$SG80670 DB	'S', 00H
	ORG $+2
$SG79646 DB	' TEXT( 25 )', 00H
$SG80671 DB	'DataType', 00H
	ORG $+3
$SG80672 DB	'TE_FieldDataRel', 00H
$SG79648 DB	' DATETIME', 00H
	ORG $+2
$SG80673 DB	'Length', 00H
	ORG $+1
$SG80674 DB	'TE_FieldDataRel', 00H
$SG79650 DB	' TIME', 00H
	ORG $+2
$SG80676 DB	'Length', 00H
	ORG $+1
$SG79652 DB	' DATE', 00H
	ORG $+2
$SG80677 DB	'TE_FieldDataRel', 00H
$SG79654 DB	' MEMO', 00H
	ORG $+2
$SG80679 DB	'Length', 00H
	ORG $+1
$SG80680 DB	'TE_FieldDataRel', 00H
$SG79656 DB	' TEXT( 30 )', 00H
$SG80682 DB	'Length', 00H
	ORG $+1
$SG79658 DB	'Name', 00H
	ORG $+3
$SG80683 DB	'TE_FieldDataRel', 00H
$SG79659 DB	'TE_TablRec', 00H
	ORG $+1
$SG79660 DB	'Invalid DataType ''%s'' for attribute %s.%s', 00H
	ORG $+2
$SG80685 DB	'Length', 00H
	ORG $+1
$SG79661 DB	'SQLBASE DDL Generator', 00H
	ORG $+2
$SG80686 DB	'TE_FieldDataRel', 00H
$SG80688 DB	'(TE) Invalid Physical Data type = ', 00H
	ORG $+1
$SG79664 DB	'Y', 00H
	ORG $+2
$SG80689 DB	'Invalid Physical Data type.', 00H
$SG79665 DB	'SQL_NULLS', 00H
	ORG $+2
$SG80690 DB	'Zeidon TE', 00H
	ORG $+2
$SG79666 DB	'TE_FieldDataRel', 00H
$SG79667 DB	'NOT NULL', 00H
	ORG $+3
$SG79668 DB	'        ', 00H
	ORG $+3
$SG80702 DB	'z_', 00H
	ORG $+1
$SG79691 DB	'DefaultOwner', 00H
	ORG $+3
$SG79692 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79695 DB	'SQL_TableOwner', 00H
	ORG $+1
$SG79696 DB	'TE_TablRec', 00H
	ORG $+1
$SG79699 DB	'.', 00H
	ORG $+2
$SG79700 DB	'TZTEDBLO', 00H
	ORG $+3
$SG79702 DB	'DBMS', 00H
	ORG $+3
$SG79703 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79704 DB	'DBMS', 00H
	ORG $+3
$SG80729 DB	'MaxTableNameLength', 00H
	ORG $+1
$SG79705 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80730 DB	'ODBC', 00H
	ORG $+3
$SG79706 DB	'DBH_Data', 00H
	ORG $+3
$SG79707 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79708 DB	'DBH_Data', 00H
	ORG $+3
$SG79709 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80734 DB	'MaxColumnNameLength', 00H
$SG80735 DB	'ODBC', 00H
	ORG $+3
$SG79712 DB	'MaxTableNameLength', 00H
	ORG $+1
$SG79713 DB	'ODBC', 00H
	ORG $+3
$SG79716 DB	'Name', 00H
	ORG $+3
$SG79717 DB	'TE_TablRec', 00H
	ORG $+1
$SG79718 DB	'Desc', 00H
	ORG $+3
$SG79719 DB	'TE_FieldDataRel', 00H
$SG79722 DB	'--', 00H
	ORG $+1
$SG79723 DB	'%s Index for Relationship - ''%s'' %s', 00H
$SG79725 DB	'ZKey', 00H
	ORG $+3
$SG79726 DB	'TE_FieldDataRel', 00H
$SG79727 DB	'Name', 00H
	ORG $+3
$SG79728 DB	'TE_FieldDataRel', 00H
$SG79729 DB	'%s_%s_%ld0', 00H
	ORG $+1
$SG79730 DB	'B_AEIOUYBCDFGHJKLMNPQRSTVWXZ', 00H
	ORG $+3
$SG79732 DB	'B', 00H
	ORG $+2
$SG79735 DB	'CREATE INDEX %s%s %s', 00H
	ORG $+3
$SG79738 DB	'       ON %s%s ( %s', 00H
$SG79740 DB	';', 00H
	ORG $+2
$SG79741 DB	' ', 00H
	ORG $+2
$SG79742 DB	'%*s %s ) %s', 00H
$SG79745 DB	' ', 00H
	ORG $+2
$SG80772 DB	'DBH_Data', 00H
	ORG $+3
$SG80773 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80776 DB	'TranslateNamesToLowerUnderscore', 00H
$SG80777 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG80781 DB	'MaxTableNameLength', 00H
	ORG $+1
$SG80782 DB	'ODBC', 00H
	ORG $+3
$SG80786 DB	'MaxColumnNameLength', 00H
$SG80787 DB	'ODBC', 00H
	ORG $+3
$SG80792 DB	'%02d', 00H
	ORG $+3
$SG80794 DB	'B_', 00H
	ORG $+1
$SG80795 DB	'Bc', 00H
	ORG $+1
$SG79775 DB	'DefaultOwner', 00H
	ORG $+3
$SG79776 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79779 DB	'SQL_TableOwner', 00H
	ORG $+1
$SG79780 DB	'TE_TablRec', 00H
	ORG $+1
$SG79783 DB	'.', 00H
	ORG $+2
$SG79784 DB	'TZTEDBLO', 00H
	ORG $+3
$SG79786 DB	'DBMS', 00H
	ORG $+3
$SG79787 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79788 DB	'DBMS', 00H
	ORG $+3
$SG79789 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79790 DB	'DBH_Data', 00H
	ORG $+3
$SG79791 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79792 DB	'DBH_Data', 00H
	ORG $+3
$SG79793 DB	'TE_DBMS_Source', 00H
	ORG $+1
$SG79796 DB	'MaxTableNameLength', 00H
	ORG $+1
$SG79797 DB	'ODBC', 00H
	ORG $+3
$SG79801 DB	'ER_Entity', 00H
	ORG $+2
$SG80826 DB	'DATARECORD', 00H
	ORG $+1
$SG79802 DB	'Name', 00H
	ORG $+3
$SG80827 DB	'DATARECORD', 00H
	ORG $+1
$SG79803 DB	'ER_Entity', 00H
	ORG $+2
$SG80828 DB	'DATARECORD', 00H
	ORG $+1
$SG79805 DB	'--', 00H
	ORG $+1
$SG80830 DB	'CHILDENTITY', 00H
$SG79806 DB	'%s Main key for Entity - %s %s', 00H
	ORG $+1
$SG80832 DB	'DATARECORD', 00H
	ORG $+1
$SG79808 DB	'Name', 00H
	ORG $+3
$SG80833 DB	'DATARECORD', 00H
	ORG $+1
$SG79809 DB	'TE_TablRec', 00H
	ORG $+1
$SG80834 DB	'DATARECORD', 00H
	ORG $+1
$SG79810 DB	'IndexName', 00H
	ORG $+2
$SG80835 DB	'DATARECORD', 00H
	ORG $+1
$SG79811 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80836 DB	'DATAFIELD', 00H
	ORG $+2
$SG80837 DB	'DATAFIELD', 00H
	ORG $+2
$SG80838 DB	'DATAFIELD', 00H
	ORG $+2
$SG79814 DB	'Name', 00H
	ORG $+3
$SG79815 DB	'TE_TablRec', 00H
	ORG $+1
$SG79816 DB	'Name', 00H
	ORG $+3
$SG80841 DB	'V', 00H
	ORG $+2
$SG79817 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80842 DB	'FLDTYPE', 00H
$SG79818 DB	'ZKey', 00H
	ORG $+3
$SG80843 DB	'DATAFIELD', 00H
	ORG $+2
$SG79819 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG80844 DB	'B', 00H
	ORG $+2
$SG80845 DB	'FLDTYPE', 00H
$SG80846 DB	'DATAFIELD', 00H
	ORG $+2
$SG79822 DB	'U%s_%s_%ld0', 00H
$SG80847 DB	'DATAFIELD', 00H
	ORG $+2
$SG79823 DB	'%s_%s_%ld0', 00H
	ORG $+1
$SG80848 DB	'DATAFIELD', 00H
	ORG $+2
$SG79824 DB	'%s', 00H
	ORG $+1
$SG80849 DB	'DATAFIELD', 00H
	ORG $+2
$SG79825 DB	'B_AEIOUYBCDFGHJKLMNPQRSTVWXZ', 00H
	ORG $+3
$SG80850 DB	'DATAFIELD', 00H
	ORG $+2
$SG80851 DB	'XVAATT_TOK', 00H
	ORG $+1
$SG79827 DB	'B', 00H
	ORG $+2
$SG80852 DB	'DATAFIELD', 00H
	ORG $+2
$SG80853 DB	'XVAATT_TOK', 00H
	ORG $+1
$SG80854 DB	'ATTRIB', 00H
	ORG $+1
$SG80855 DB	'DATAFIELD', 00H
	ORG $+2
$SG79832 DB	'CREATE UNIQUE INDEX %s%s %s', 00H
$SG80857 DB	'Y', 00H
	ORG $+2
$SG80858 DB	'KEY', 00H
$SG79834 DB	'CREATE INDEX %s%s %s', 00H
	ORG $+3
$SG80859 DB	'ATTRIB', 00H
	ORG $+1
$SG80860 DB	'DATAFIELD', 00H
	ORG $+2
$SG80861 DB	'DATAFIELD', 00H
	ORG $+2
$SG79837 DB	'       ON %s%s ( %s', 00H
$SG79839 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG79840 DB	'Name', 00H
	ORG $+3
$SG79841 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG79842 DB	'TE_FieldDataRelKey', 00H
	ORG $+1
$SG79846 DB	' ', 00H
	ORG $+2
$SG79847 DB	'%*s %s, %s', 00H
	ORG $+1
$SG79848 DB	';', 00H
	ORG $+2
$SG79849 DB	' ', 00H
	ORG $+2
$SG79850 DB	'%*s %s ) %s', 00H
$SG80880 DB	'DATARECORD', 00H
	ORG $+1
$SG80883 DB	'LOD_EntityParent', 00H
	ORG $+3
$SG80884 DB	'ZKey', 00H
	ORG $+3
$SG80885 DB	'TE_DBMS_SourceForEntity', 00H
$SG80887 DB	'Y', 00H
	ORG $+2
$SG79863 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80888 DB	'SQL_JoinWithParent', 00H
	ORG $+1
$SG79864 DB	'TE_TablRecKey', 00H
	ORG $+2
$SG80889 DB	'POD_Entity', 00H
	ORG $+1
$SG80890 DB	'Y', 00H
	ORG $+2
$SG80891 DB	'JOIN', 00H
	ORG $+3
$SG79867 DB	' ', 00H
	ORG $+2
$SG80892 DB	'DATARECORD', 00H
	ORG $+1
$SG80894 DB	'ER_RelLinkRec', 00H
	ORG $+2
$SG80895 DB	'CardMax', 00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnBuildDropIndex@20
PUBLIC	_fnBuildColumn@12
PUBLIC	_fnBuildFK_Index@8
PUBLIC	_fnBuildIndexFromTablRecKey@12
PUBLIC	_fnBuildCreateMainIndex@8
PUBLIC	_fnBuildCreateTable@8
PUBLIC	_BuildDDL@16
PUBLIC	_BuildSyncDDL@20
PUBLIC	_LoadDataTypes@4
PUBLIC	_SetDataType@8
PUBLIC	_fnChangeReservedName@4
PUBLIC	_TranslateToUnderscoreCase@12
PUBLIC	_GenerateName@12
PUBLIC	_fnSortDataFields@4
PUBLIC	_fnSetEntityInformation@12
PUBLIC	_PostXOD_BuildHook@20
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_SetViewFromView@8:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_SetViewToSubobject@8:PROC
EXTRN	_ResetViewFromSubobject@4:PROC
EXTRN	_ResetView@4:PROC
EXTRN	_CheckExistenceOfEntity@8:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_MoveSubobject@24:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorPrevEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorLastEntity@12:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_SetCursorNextEntityByString@20:PROC
EXTRN	_SetCursorFirstEntityByInteger@20:PROC
EXTRN	_SetCursorFirstEntityByAttr@28:PROC
EXTRN	_SetCursorAbsolutePosition@12:PROC
EXTRN	_GetAbsolutePositionForEntity@12:PROC
EXTRN	_DefineHierarchicalCursor@8:PROC
EXTRN	_DropHierarchicalCursor@4:PROC
EXTRN	_SetCursorNextEntityHierarchical@12:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_GetIntegerFromAttribute@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_SetAttributeFromBlob@20:PROC
EXTRN	_SetAttributeFromAttribute@24:PROC
EXTRN	_SetOI_FromBlob@28:PROC
EXTRN	_CompareAttributeToString@16:PROC
EXTRN	_CompareAttributeToInteger@16:PROC
EXTRN	_UfCompressName@32:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_SysCloseFile@12:PROC
EXTRN	_SysFreeLibrary@8:PROC
EXTRN	_SysGetProc@8:PROC
EXTRN	_SysLoadLibrary@8:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysOpenFile@12:PROC
EXTRN	_SysTranslateString@8:PROC
EXTRN	_SysWriteLine@12:PROC
EXTRN	_GetAddrForAttribute@16:PROC
EXTRN	__imp__isalnum:PROC
EXTRN	_MB_SetMessage@12:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

?nNameCount@?1??GenerateName@@9@9 DW 01H DUP (?)	; `GenerateName'::`2'::nNameCount
	ALIGN	4

?nMaxLth@?1??GenerateName@@9@9 DW 01H DUP (?)		; `GenerateName'::`2'::nMaxLth
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_lDBMS_ZKey$1 = -164					; size = 4
tv140 = -160						; size = 4
tv91 = -156						; size = 4
tv90 = -152						; size = 4
_vOI$ = -148						; size = 4
_sData$2 = -144						; size = 104
_szObjectName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_vTZTEDBLO$ = 8						; size = 4
_vTZZOXODO$ = 12					; size = 4
_vTZZOLODO$ = 16					; size = 4
_vTZEREMDO_REF$ = 20					; size = 4
_vTZTENVRO_REF$ = 24					; size = 4
_PostXOD_BuildHook@20 PROC

; 7216 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7217 :    zCHAR szObjectName[ zZEIDON_NAME_LTH + 1 ];
; 7218 :    zVIEW vOI;
; 7219 : 
; 7220 :    // See if there is a blob stored in DBH_Data for the TE.
; 7221 :    SetOI_FromBlob( &vOI, szObjectName, vTZZOXODO, vTZTENVRO_REF,

	push	256					; 00000100H
	push	OFFSET $SG80940
	push	OFFSET $SG80941
	mov	eax, DWORD PTR _vTZTENVRO_REF$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 7222 :                    "TE_DBMS_Source", "DBH_Data", zMULTIPLE );
; 7223 : 
; 7224 :    if ( vOI == 0 )

	cmp	DWORD PTR _vOI$[ebp], 0
	jne	SHORT $LN2@PostXOD_Bu

; 7225 :        // No blob in the TE.  Get it from the DB list object.
; 7226 :       SetOI_FromBlob( &vOI, szObjectName, vTZZOXODO, vTZTEDBLO,

	push	256					; 00000100H
	push	OFFSET $SG80943
	push	OFFSET $SG80944
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	lea	eax, DWORD PTR _szObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28
$LN2@PostXOD_Bu:

; 7227 :                       "TE_DBMS_Source", "DBH_Data", zMULTIPLE );
; 7228 : 
; 7229 :    if ( vOI == 0 )

	cmp	DWORD PTR _vOI$[ebp], 0
	jne	SHORT $LN3@PostXOD_Bu

; 7230 :    {
; 7231 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@PostXOD_Bu
$LN3@PostXOD_Bu:

; 7232 : 
; 7233 :       // DGC 2015-01-07 Removed the following code and just return 0 because this
; 7234 :       // stuff is never used by the JOE and so it's not an error.
; 7235 : #if 0
; 7236 :       // KJS - 08/22/12 - This is being put in because we were getting an 'Invalid View' error on the DropView( vOI ) if
; 7237 :       // a 'Set DBH' hadn't been done on the data source and the db handler was PostgreSQL since TZDBHODO was not ever set.
; 7238 :       // Not actually sure if this is much of an error (should I just put the DropView in the below "If") or if there could
; 7239 :       // be problems if TZDBHODO is not a valid view.
; 7240 :       MessageSend( vTZZOXODO, "PostXOD_BuildHook", "Zeidon Tools",
; 7241 :                    "You need to do a 'Set DBH' for this data source before building the xods.", zMSGQ_SYSTEM_ERROR, TRUE );
; 7242 :       TraceLineS( "*** PostXOD_BuildHook TZDBHODO does not exist. ", "" );
; 7243 :       return( zCALL_ERROR );
; 7244 : #endif
; 7245 :    }
; 7246 : 
; 7247 :    // Check for ODBC object.
; 7248 :    if ( zstrcmp( szObjectName, "TZDBHODO" ) == 0 )

	movsx	edx, BYTE PTR _szObjectName$[ebp]
	movsx	eax, BYTE PTR $SG80947
	cmp	edx, eax
	jne	SHORT $LN8@PostXOD_Bu
	push	OFFSET $SG80948
	lea	ecx, DWORD PTR _szObjectName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv91[ebp], eax
	jmp	SHORT $LN9@PostXOD_Bu
$LN8@PostXOD_Bu:
	movsx	edx, BYTE PTR _szObjectName$[ebp]
	movsx	eax, BYTE PTR $SG80949
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN6@PostXOD_Bu
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN7@PostXOD_Bu
$LN6@PostXOD_Bu:
	mov	DWORD PTR tv90[ebp], -1
$LN7@PostXOD_Bu:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv91[ebp], ecx
$LN9@PostXOD_Bu:
	cmp	DWORD PTR tv91[ebp], 0
	jne	$LN4@PostXOD_Bu

; 7249 :    {
; 7250 :       zLONG                 lDBMS_ZKey;
; 7251 :       ODBC_ObjectDataRecord sData;
; 7252 : 
; 7253 :       // For ODBC databases we need to sort the DataFields so that the VarChar
; 7254 :       // fields come last in each table.  We also need to put keys first.
; 7255 :       fnSortDataFields( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_fnSortDataFields@4

; 7256 : 
; 7257 :       // Set-up ODBC-specific information.
; 7258 :       zmemset( &sData, 0, sizeof( sData ) );

	push	104					; 00000068H
	push	0
	lea	eax, DWORD PTR _sData$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 7259 :       GetIntegerFromAttribute( &sData.nTimestampPrecision,

	push	OFFSET $SG80950
	push	OFFSET $SG80951
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sData$2[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 7260 :                                vOI, "ODBC", "TimestampPrecision" );
; 7261 :       sData.bStoreTimestampAsString =

	push	OFFSET $SG80952
	push	OFFSET $SG80953
	push	OFFSET $SG80954
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN10@PostXOD_Bu
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN11@PostXOD_Bu
$LN10@PostXOD_Bu:
	mov	DWORD PTR tv140[ebp], 0
$LN11@PostXOD_Bu:
	mov	dl, BYTE PTR tv140[ebp]
	mov	BYTE PTR _sData$2[ebp+4], dl

; 7262 :             ( CompareAttributeToString( vOI, "ODBC",
; 7263 :                                         "TimestampAsString", "Y" ) == 0 );
; 7264 : 
; 7265 :       SetAttributeFromBlob( vTZZOXODO, "OBJECT", "DBH_Data", (zPVOID) &sData,

	push	104					; 00000068H
	lea	eax, DWORD PTR _sData$2[ebp]
	push	eax
	push	OFFSET $SG80955
	push	OFFSET $SG80956
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetAttributeFromBlob@20

; 7266 :                             sizeof( sData ) );
; 7267 : 
; 7268 :       // Go through the LOD and set dbh-specific information for each entity.
; 7269 :       ResetView( vTZZOLODO );

	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_ResetView@4

; 7270 :       ResetView( vTZZOXODO );

	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_ResetView@4

; 7271 : 
; 7272 :       // Set the cursor to the first non-hidden entity.
; 7273 :       SetCursorFirstEntity( vTZZOXODO, "OBJECT", 0 );

	push	0
	push	OFFSET $SG80957
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12

; 7274 : 
; 7275 :       GetIntegerFromAttribute( &lDBMS_ZKey, vTZTENVRO_REF, "TE_DBMS_Source",

	push	OFFSET $SG80958
	push	OFFSET $SG80959
	mov	edx, DWORD PTR _vTZTENVRO_REF$[ebp]
	push	edx
	lea	eax, DWORD PTR _lDBMS_ZKey$1[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 7276 :                                "ZKey" );
; 7277 :       fnSetEntityInformation( vTZZOLODO, vTZZOXODO, lDBMS_ZKey );

	mov	ecx, DWORD PTR _lDBMS_ZKey$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_fnSetEntityInformation@12
$LN4@PostXOD_Bu:

; 7278 :    }
; 7279 : 
; 7280 :    DropView( vOI );

	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_DropView@4

; 7281 : 
; 7282 :    return( 0 );

	xor	eax, eax
$LN1@PostXOD_Bu:

; 7283 : 
; 7284 : } // PostXOD_BuildHook

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_PostXOD_BuildHook@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_lER_RelTok$1 = -12					; size = 4
_lER_EntTok$2 = -8					; size = 4
_nRC$ = -4						; size = 2
_vTZZOLODO$ = 8						; size = 4
_vTZZOXODO$ = 12					; size = 4
_lDBMS_ZKey$ = 16					; size = 4
_fnSetEntityInformation@12 PROC

; 7125 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 7126 :    zSHORT nRC;
; 7127 : 
; 7128 :    // First, make sure we've got an entity with DB information.
; 7129 :    if ( CheckExistenceOfEntity( vTZZOXODO, "DATARECORD" ) < zCURSOR_SET )

	push	OFFSET $SG80880
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN8@fnSetEntit

; 7130 :       return;

	jmp	$LN1@fnSetEntit
$LN8@fnSetEntit:

; 7131 : 
; 7132 :    // Find out if a POD_Entity exists for the DBMS.
; 7133 :    if ( SetCursorFirstEntityByInteger( vTZZOLODO, "TE_DBMS_SourceForEntity",
; 7134 :                                        "ZKey", lDBMS_ZKey,
; 7135 :                                        "LOD_EntityParent" ) == zCURSOR_SET )

	push	OFFSET $SG80883
	mov	edx, DWORD PTR _lDBMS_ZKey$[ebp]
	push	edx
	push	OFFSET $SG80884
	push	OFFSET $SG80885
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByInteger@20
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN9@fnSetEntit

; 7136 :    {
; 7137 :       // Got a POD_Entity.  Check the JOIN flag.
; 7138 :       if ( CompareAttributeToString( vTZZOLODO, "POD_Entity",
; 7139 :                                      "SQL_JoinWithParent", "Y" ) == 0 )

	push	OFFSET $SG80887
	push	OFFSET $SG80888
	push	OFFSET $SG80889
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN11@fnSetEntit

; 7140 :       {
; 7141 :          SetAttributeFromString( vTZZOXODO, "DATARECORD", "JOIN", "Y" );

	push	OFFSET $SG80890
	push	OFFSET $SG80891
	push	OFFSET $SG80892
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN11@fnSetEntit:

; 7142 :       }
; 7143 :    }

	jmp	SHORT $LN10@fnSetEntit
$LN9@fnSetEntit:

; 7144 :    else
; 7145 :    if ( CheckExistenceOfEntity( vTZZOLODO, "ER_RelLinkRec" ) == zCURSOR_SET &&

	push	OFFSET $SG80894
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	cwde
	test	eax, eax
	jne	SHORT $LN10@fnSetEntit
	push	1
	push	OFFSET $SG80895
	push	OFFSET $SG80896
	mov	ecx, DWORD PTR _vTZZOLODO$[ebp]
	push	ecx
	call	_CompareAttributeToInteger@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN10@fnSetEntit

; 7146 :         CompareAttributeToInteger( vTZZOLODO, "ER_RelLinkRec",
; 7147 :                                    "CardMax", 1 ) == 0 )
; 7148 :    {
; 7149 :       // Join is defaulted to Y if the entity has a x-to-1 relationship
; 7150 :       // with it's parent.
; 7151 :       SetAttributeFromString( vTZZOXODO, "DATARECORD", "JOIN", "Y" );

	push	OFFSET $SG80897
	push	OFFSET $SG80898
	push	OFFSET $SG80899
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN10@fnSetEntit:

; 7152 :    }
; 7153 : 
; 7154 :    // Now do the same thing for any children.
; 7155 :    for ( nRC = SetCursorFirstEntity( vTZZOXODO, "CHILDENTITY", 0 );

	push	0
	push	OFFSET $SG80900
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnSetEntit
$LN2@fnSetEntit:

; 7157 :          nRC = SetCursorNextEntity( vTZZOXODO, "CHILDENTITY", 0 ) )

	push	0
	push	OFFSET $SG80901
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnSetEntit:

; 7156 :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN1@fnSetEntit

; 7158 :    {
; 7159 :       zLONG lER_EntTok;
; 7160 :       zLONG lER_RelTok;
; 7161 : 
; 7162 :       GetIntegerFromAttribute( &lER_EntTok, vTZZOXODO, "CHILDENTITY",

	push	OFFSET $SG80902
	push	OFFSET $SG80903
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lER_EntTok$2[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 7163 :                                "ERENT_TOK" );
; 7164 :       GetIntegerFromAttribute( &lER_RelTok, vTZZOXODO, "CHILDENTITY",

	push	OFFSET $SG80904
	push	OFFSET $SG80905
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lER_RelTok$1[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 7165 :                                "ERREL_TOK" );
; 7166 : 
; 7167 :       // Find a matching entity in the LOD.
; 7168 :       for ( nRC = SetCursorFirstEntity( vTZZOLODO, "LOD_EntityChild", 0 );

	push	0
	push	OFFSET $SG80906
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN7@fnSetEntit
$LN5@fnSetEntit:

; 7170 :             nRC = SetCursorNextEntity( vTZZOLODO, "LOD_EntityChild", 0 ) )

	push	0
	push	OFFSET $SG80907
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN7@fnSetEntit:

; 7169 :             nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN6@fnSetEntit

; 7171 :       {
; 7172 :          SetViewToSubobject( vTZZOLODO, "LOD_EntityChild" );

	push	OFFSET $SG80908
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_SetViewToSubobject@8

; 7173 : 
; 7174 :          if ( CheckExistenceOfEntity( vTZZOLODO,
; 7175 :                                       "ER_EntityRec" ) == zCURSOR_SET &&
; 7176 :               CompareAttributeToInteger( vTZZOLODO, "ER_EntityRec", "ZKey",
; 7177 :                                          lER_EntTok ) == 0 &&
; 7178 :               CheckExistenceOfEntity( vTZZOLODO,
; 7179 :                                       "ER_RelLinkRec" ) == zCURSOR_SET &&

	push	OFFSET $SG80910
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN13@fnSetEntit
	mov	edx, DWORD PTR _lER_EntTok$2[ebp]
	push	edx
	push	OFFSET $SG80911
	push	OFFSET $SG80912
	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_CompareAttributeToInteger@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN13@fnSetEntit
	push	OFFSET $SG80913
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	cwde
	test	eax, eax
	jne	SHORT $LN13@fnSetEntit
	mov	ecx, DWORD PTR _lER_EntTok$2[ebp]
	push	ecx
	push	OFFSET $SG80914
	push	OFFSET $SG80915
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_CompareAttributeToInteger@16
	cwde
	test	eax, eax
	jne	SHORT $LN13@fnSetEntit

; 7180 :               CompareAttributeToInteger( vTZZOLODO, "ER_RelLinkRec", "ZKey",
; 7181 :                                          lER_EntTok ) == 0 )
; 7182 :          {
; 7183 :             // We found the child entity that matches the CHILDENTITY
; 7184 :             // in the XOD.  Stop 'for' loop.
; 7185 :             break;

	jmp	SHORT $LN6@fnSetEntit
$LN13@fnSetEntit:

; 7186 :          }
; 7187 : 
; 7188 :          // That wasn't the right child so reset the subobject.
; 7189 :          ResetViewFromSubobject( vTZZOLODO );

	mov	ecx, DWORD PTR _vTZZOLODO$[ebp]
	push	ecx
	call	_ResetViewFromSubobject@4

; 7190 :       }

	jmp	$LN5@fnSetEntit
$LN6@fnSetEntit:

; 7191 : 
; 7192 :       // Once we get here, "LOD_EntityParent" should match "CHILDENTITY".
; 7193 :       // Move "CHILDENTITY" up and call ourselves recursively.
; 7194 :       SetViewToSubobject( vTZZOXODO, "CHILDENTITY" );

	push	OFFSET $SG80916
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_SetViewToSubobject@8

; 7195 :       fnSetEntityInformation( vTZZOLODO, vTZZOXODO, lDBMS_ZKey );

	mov	eax, DWORD PTR _lDBMS_ZKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTZZOLODO$[ebp]
	push	edx
	call	_fnSetEntityInformation@12

; 7196 : 
; 7197 :       // Now reset the cursors.
; 7198 :       ResetViewFromSubobject( vTZZOLODO );

	mov	eax, DWORD PTR _vTZZOLODO$[ebp]
	push	eax
	call	_ResetViewFromSubobject@4

; 7199 :       ResetViewFromSubobject( vTZZOXODO );

	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	call	_ResetViewFromSubobject@4

; 7200 :    }

	jmp	$LN2@fnSetEntit
$LN1@fnSetEntit:

; 7201 : 
; 7202 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSetEntityInformation@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_lPos$1 = -68						; size = 4
_usReturnLevel$ = -64					; size = 2
tv136 = -60						; size = 4
tv135 = -56						; size = 4
_vXOD2$ = -52						; size = 4
_vXOD$ = -48						; size = 4
_nRC$ = -44						; size = 2
_szEntityName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_vTZZOXODO$ = 8						; size = 4
_fnSortDataFields@4 PROC

; 7031 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7032 :    zUSHORT usReturnLevel;
; 7033 :    zSHORT  nRC;
; 7034 :    zCHAR   szEntityName[ 33 ];
; 7035 :    zVIEW   vXOD;
; 7036 :    zVIEW   vXOD2;
; 7037 : 
; 7038 :    // If there is no DATARECORD for the root entity then there is nothing
; 7039 :    // to do (this LOD has no physical info).
; 7040 :    if ( CheckExistenceOfEntity( vTZZOXODO, "DATARECORD" ) != zCURSOR_SET )

	push	OFFSET $SG80826
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN9@fnSortData

; 7041 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSortData
$LN9@fnSortData:

; 7042 : 
; 7043 :    CreateViewFromViewForTask( &vTZZOXODO, vTZZOXODO, 0 );

	push	0
	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 7044 :    CreateViewFromViewForTask( &vXOD, vTZZOXODO, 0 );

	push	0
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 7045 :    CreateViewFromViewForTask( &vXOD2, vTZZOXODO, 0 );

	push	0
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 7046 : 
; 7047 :    // Initialize DATARECORD into szEntityName so that we reference the first
; 7048 :    // ENTITY.
; 7049 :    zstrcpy( szEntityName, "DATARECORD" );

	push	OFFSET $SG80827
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7050 : 
; 7051 :    for ( nRC = DefineHierarchicalCursor( vTZZOXODO, "DATARECORD" );

	push	OFFSET $SG80828
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_DefineHierarchicalCursor@8
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnSortData
$LN2@fnSortData:

; 7053 :          nRC = SetCursorNextEntityHierarchical( &usReturnLevel,

	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	lea	eax, DWORD PTR _usReturnLevel$[ebp]
	push	eax
	call	_SetCursorNextEntityHierarchical@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnSortData:

; 7052 :          nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN3@fnSortData

; 7054 :                                                 szEntityName, vTZZOXODO ) )
; 7055 :    {
; 7056 :       zLONG lPos;
; 7057 : 
; 7058 :       if ( nRC == zCURSOR_SET_RECURSIVECHILD )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $LN10@fnSortData

; 7059 :          SetViewToSubobject( vTZZOXODO, "CHILDENTITY" );

	push	OFFSET $SG80830
	mov	eax, DWORD PTR _vTZZOXODO$[ebp]
	push	eax
	call	_SetViewToSubobject@8
$LN10@fnSortData:

; 7060 : 
; 7061 :       if ( zstrcmp( szEntityName, "DATARECORD" ) != 0 )

	movsx	ecx, BYTE PTR _szEntityName$[ebp]
	movsx	edx, BYTE PTR $SG80832
	cmp	ecx, edx
	jne	SHORT $LN18@fnSortData
	push	OFFSET $SG80833
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN19@fnSortData
$LN18@fnSortData:
	movsx	ecx, BYTE PTR _szEntityName$[ebp]
	movsx	edx, BYTE PTR $SG80834
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN16@fnSortData
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN17@fnSortData
$LN16@fnSortData:
	mov	DWORD PTR tv135[ebp], -1
$LN17@fnSortData:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv136[ebp], eax
$LN19@fnSortData:
	cmp	DWORD PTR tv136[ebp], 0
	je	SHORT $LN11@fnSortData

; 7062 :          continue;

	jmp	$LN2@fnSortData
$LN11@fnSortData:

; 7063 : 
; 7064 :       GetAbsolutePositionForEntity( &lPos, vTZZOXODO, "DATARECORD" );

	push	OFFSET $SG80835
	mov	ecx, DWORD PTR _vTZZOXODO$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lPos$1[ebp]
	push	edx
	call	_GetAbsolutePositionForEntity@12

; 7065 :       SetCursorAbsolutePosition( szEntityName, vXOD, lPos );

	mov	eax, DWORD PTR _lPos$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_SetCursorAbsolutePosition@12

; 7066 : 
; 7067 :       // Move blob fields to the end.  We'll start at the end and go back
; 7068 :       // to the beginning. We'll skip the very last entity since it's already
; 7069 :       // last.
; 7070 :       SetCursorLastEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET $SG80836
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorLastEntity@12

; 7071 :       nRC = SetCursorPrevEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET $SG80837
	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN5@fnSortData:

; 7072 :       while ( nRC >= zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN6@fnSortData

; 7073 :       {
; 7074 :          SetViewFromView( vXOD2, vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_SetViewFromView@8

; 7075 :          nRC = SetCursorPrevEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET $SG80838
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 7076 : 
; 7077 :          if ( CompareAttributeToString( vXOD2, "DATAFIELD", "FLDTYPE",
; 7078 :                                         "V" ) == 0 ||

	push	OFFSET $SG80841
	push	OFFSET $SG80842
	push	OFFSET $SG80843
	mov	eax, DWORD PTR _vXOD2$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN13@fnSortData
	push	OFFSET $SG80844
	push	OFFSET $SG80845
	push	OFFSET $SG80846
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN12@fnSortData
$LN13@fnSortData:

; 7079 :               CompareAttributeToString( vXOD2, "DATAFIELD", "FLDTYPE",
; 7080 :                                         "B" ) == 0 )
; 7081 :          {
; 7082 :             // Move current DATAFIELD to the end.
; 7083 :             MoveSubobject( vXOD2, "DATAFIELD", vXOD2, "DATAFIELD",

	push	4
	push	2
	push	OFFSET $SG80847
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	push	OFFSET $SG80848
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_MoveSubobject@24
$LN12@fnSortData:

; 7084 :                            zPOS_LAST, zREPOS_PREV );
; 7085 :          }
; 7086 :       }

	jmp	$LN5@fnSortData
$LN6@fnSortData:

; 7087 : 
; 7088 :       // Move Keys fields to the beginning.  We'll start at the end and go back
; 7089 :       // to the beginning. We'll skip the very first entity since it's already
; 7090 :       // first.
; 7091 :       SetViewFromView( vXOD2, vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_SetViewFromView@8

; 7092 :       SetCursorFirstEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET $SG80849
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12

; 7093 :       nRC = SetCursorNextEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET $SG80850
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN7@fnSortData:

; 7094 :       while ( nRC >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN8@fnSortData

; 7095 :       {
; 7096 :          // Find the correct ATTRIB entity.
; 7097 :          SetCursorFirstEntityByAttr( vXOD, "ATTRIB", "XVAATT_TOK",

	push	0
	push	OFFSET $SG80851
	push	OFFSET $SG80852
	mov	edx, DWORD PTR _vXOD$[ebp]
	push	edx
	push	OFFSET $SG80853
	push	OFFSET $SG80854
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28

; 7098 :                                      vXOD, "DATAFIELD", "XVAATT_TOK", 0 );
; 7099 : 
; 7100 :          SetViewFromView( vXOD2, vXOD );

	mov	ecx, DWORD PTR _vXOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vXOD2$[ebp]
	push	edx
	call	_SetViewFromView@8

; 7101 :          nRC = SetCursorNextEntity( vXOD, "DATAFIELD", 0 );

	push	0
	push	OFFSET $SG80855
	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 7102 : 
; 7103 :          // If the attribute is a key move it to the beginning.
; 7104 :          if ( CompareAttributeToString( vXOD2, "ATTRIB", "KEY", "Y" ) == 0 )

	push	OFFSET $SG80857
	push	OFFSET $SG80858
	push	OFFSET $SG80859
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN14@fnSortData

; 7105 :          {
; 7106 : 
; 7107 :             // Move current DATAFIELD to the beginning.
; 7108 :             MoveSubobject( vXOD2, "DATAFIELD", vXOD2, "DATAFIELD",

	push	3
	push	1
	push	OFFSET $SG80860
	mov	eax, DWORD PTR _vXOD2$[ebp]
	push	eax
	push	OFFSET $SG80861
	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_MoveSubobject@24
$LN14@fnSortData:

; 7109 :                            zPOS_FIRST, zREPOS_NEXT );
; 7110 :          }
; 7111 :       }

	jmp	$LN7@fnSortData
$LN8@fnSortData:

; 7112 :    }

	jmp	$LN2@fnSortData
$LN3@fnSortData:

; 7113 : 
; 7114 :    DropHierarchicalCursor( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_DropHierarchicalCursor@4

; 7115 :    DropView( vXOD );

	mov	eax, DWORD PTR _vXOD$[ebp]
	push	eax
	call	_DropView@4

; 7116 :    DropView( vXOD2 );

	mov	ecx, DWORD PTR _vXOD2$[ebp]
	push	ecx
	call	_DropView@4

; 7117 :    DropView( vTZZOXODO );

	mov	edx, DWORD PTR _vTZZOXODO$[ebp]
	push	edx
	call	_DropView@4

; 7118 : 
; 7119 :    return( 0 );

	xor	eax, eax
$LN1@fnSortData:

; 7120 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnSortDataFields@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_l$ = -68						; size = 4
tv88 = -64						; size = 4
_szCreateUnderscore$ = -60				; size = 2
_pch1$ = -56						; size = 4
_vDBH_Data$ = -52					; size = 4
_pch2$ = -48						; size = 4
_nLth$1 = -44						; size = 2
_szDBH_DataObjectName$ = -40				; size = 33
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_pchName$ = 12						; size = 4
_cMetaType$ = 16					; size = 1
_GenerateName@12 PROC

; 5055 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5056 :    static zSHORT nNameCount;   // Used to keep track of duplicate names.
; 5057 :    static zSHORT nMaxLth;      // Used to keep track of duplicate names.
; 5058 : 
; 5059 :    zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 5060 :    zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 5061 :    zCHAR  szCreateUnderscore[ 2 ];
; 5062 :    zPCHAR pch1;
; 5063 :    zPCHAR pch2;
; 5064 :    zLONG  l;
; 5065 : 
; 5066 :    // Try to get the OI that contains DBH-specific data.
; 5067 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,

	push	512					; 00000200H
	push	OFFSET $SG80772
	push	OFFSET $SG80773
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	edx
	lea	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_SetOI_FromBlob@28

; 5068 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 5069 : 
; 5070 :    // Eliminate invalid chars.
; 5071 :    for ( pch1 = pch2 = pchName; *pch2; pch2++ )

	mov	ecx, DWORD PTR _pchName$[ebp]
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch2$[ebp]
	mov	DWORD PTR _pch1$[ebp], edx
	jmp	SHORT $LN4@GenerateNa
$LN2@GenerateNa:
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
$LN4@GenerateNa:
	mov	ecx, DWORD PTR _pch2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@GenerateNa

; 5072 :    {
; 5073 :       // Even though SQLBase allows '@', '#', and '$' we don't generate them.
; 5074 :       if ( zisalnum( *pch2 ) || *pch2 == '_' )

	mov	eax, DWORD PTR _pch2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@GenerateNa
	mov	edx, DWORD PTR _pch2$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 95					; 0000005fH
	jne	SHORT $LN7@GenerateNa
$LN8@GenerateNa:

; 5075 :          *pch1++ = *pch2;  // Copy valid char.

	mov	ecx, DWORD PTR _pch1$[ebp]
	mov	edx, DWORD PTR _pch2$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch1$[ebp], ecx
$LN7@GenerateNa:

; 5076 :    }

	jmp	SHORT $LN2@GenerateNa
$LN3@GenerateNa:

; 5077 : 
; 5078 :    // Null-terminate string.
; 5079 :    pch1[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pch1$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 5080 : 
; 5081 :    // KJS 08/07/14 - DG wants to be able to create names Like EntityName to entity_name. This is the ini setting.
; 5082 :    GetStringFromAttribute (szCreateUnderscore, vDTE, "TE_DBMS_Source", "TranslateNamesToLowerUnderscore");

	push	OFFSET $SG80776
	push	OFFSET $SG80777
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szCreateUnderscore$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 5083 : 
; 5084 :    switch ( cMetaType )

	mov	cl, BYTE PTR _cMetaType$[ebp]
	mov	BYTE PTR tv88[ebp], cl
	cmp	BYTE PTR tv88[ebp], 65			; 00000041H
	je	SHORT $LN12@GenerateNa
	cmp	BYTE PTR tv88[ebp], 69			; 00000045H
	je	SHORT $LN9@GenerateNa
	cmp	BYTE PTR tv88[ebp], 88			; 00000058H
	je	$LN15@GenerateNa
	jmp	$LN5@GenerateNa
$LN9@GenerateNa:

; 5085 :    {
; 5086 :       case 'E':      // Meta type is Entity
; 5087 :          nNameCount = 1;

	mov	edx, 1
	mov	WORD PTR ?nNameCount@?1??GenerateName@@9@9, dx

; 5088 : 
; 5089 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 5090 :          // not specified use the default length.
; 5091 :          if ( vDBH_Data &&

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN10@GenerateNa
	push	OFFSET $SG80781
	push	OFFSET $SG80782
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $LN10@GenerateNa

; 5092 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 5093 :                                        "MaxTableNameLength" ) != -1 )
; 5094 :          {
; 5095 :             nMaxLth = (zSHORT) l;

	mov	ax, WORD PTR _l$[ebp]
	mov	WORD PTR ?nMaxLth@?1??GenerateName@@9@9, ax

; 5096 :          }

	jmp	SHORT $LN11@GenerateNa
$LN10@GenerateNa:

; 5097 :          else
; 5098 :             nMaxLth = MAX_TABLENAME_LTH;

	mov	ecx, 32					; 00000020H
	mov	WORD PTR ?nMaxLth@?1??GenerateName@@9@9, cx
$LN11@GenerateNa:

; 5099 : 
; 5100 :          break;

	jmp	$LN5@GenerateNa
$LN12@GenerateNa:

; 5101 : 
; 5102 :       case 'A':      // Meta type is Attribute
; 5103 :          nNameCount = 1;

	mov	edx, 1
	mov	WORD PTR ?nNameCount@?1??GenerateName@@9@9, dx

; 5104 : 
; 5105 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 5106 :          // not specified use the default length.
; 5107 :          if ( vDBH_Data &&

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN13@GenerateNa
	push	OFFSET $SG80786
	push	OFFSET $SG80787
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $LN13@GenerateNa

; 5108 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 5109 :                                        "MaxColumnNameLength" ) != -1 )
; 5110 :          {
; 5111 :             nMaxLth = (zSHORT) l;

	mov	ax, WORD PTR _l$[ebp]
	mov	WORD PTR ?nMaxLth@?1??GenerateName@@9@9, ax

; 5112 :          }

	jmp	SHORT $LN14@GenerateNa
$LN13@GenerateNa:

; 5113 :          else
; 5114 :             nMaxLth = MAX_COLUMNNAME_LTH;

	mov	ecx, 32					; 00000020H
	mov	WORD PTR ?nMaxLth@?1??GenerateName@@9@9, cx
$LN14@GenerateNa:

; 5115 : 
; 5116 :          break;

	jmp	SHORT $LN5@GenerateNa
$LN15@GenerateNa:

; 5117 : 
; 5118 :       case 'X':      // pchName is a duplicate, generate a new one.
; 5119 :       {
; 5120 :          zSHORT nLth;
; 5121 : 
; 5122 :          // When generating new names, we just tack on an incrementing
; 5123 :          // number.  For example, "ColName" becomes "ColName02", "ColName02"
; 5124 :          // becomes "ColName03", etc.
; 5125 : 
; 5126 :          nNameCount++;

	mov	dx, WORD PTR ?nNameCount@?1??GenerateName@@9@9
	add	dx, 1
	mov	WORD PTR ?nNameCount@?1??GenerateName@@9@9, dx

; 5127 :          nLth = zstrlen( pchName );

	mov	eax, DWORD PTR _pchName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$1[ebp], ax

; 5128 :          if ( nNameCount > 2 )

	movsx	ecx, WORD PTR ?nNameCount@?1??GenerateName@@9@9
	cmp	ecx, 2
	jle	SHORT $LN16@GenerateNa

; 5129 :             nLth = nLth - 2;

	movsx	edx, WORD PTR _nLth$1[ebp]
	sub	edx, 2
	mov	WORD PTR _nLth$1[ebp], dx
	jmp	SHORT $LN17@GenerateNa
$LN16@GenerateNa:

; 5130 :          else
; 5131 :          if ( nLth > nMaxLth - 2 )

	movsx	eax, WORD PTR _nLth$1[ebp]
	movsx	ecx, WORD PTR ?nMaxLth@?1??GenerateName@@9@9
	sub	ecx, 2
	cmp	eax, ecx
	jle	SHORT $LN17@GenerateNa

; 5132 :             nLth = nMaxLth - 2;

	movsx	edx, WORD PTR ?nMaxLth@?1??GenerateName@@9@9
	sub	edx, 2
	mov	WORD PTR _nLth$1[ebp], dx
$LN17@GenerateNa:

; 5133 : 
; 5134 :          zsprintf( pchName + nLth, "%02d", nNameCount );

	movsx	eax, WORD PTR ?nNameCount@?1??GenerateName@@9@9
	push	eax
	push	OFFSET $SG80792
	movsx	ecx, WORD PTR _nLth$1[ebp]
	add	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 5135 : 
; 5136 :          // We know name is short enough and no reserved words contain numbers
; 5137 :          // so just return.
; 5138 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@GenerateNa
$LN5@GenerateNa:

; 5139 :       }
; 5140 :    }
; 5141 : 
; 5142 :    if ( nMaxLth >= BUFF_SIZE )

	movsx	edx, WORD PTR ?nMaxLth@?1??GenerateName@@9@9
	cmp	edx, 256				; 00000100H
	jl	SHORT $LN19@GenerateNa

; 5143 :       nMaxLth = BUFF_SIZE - 1;

	mov	eax, 255				; 000000ffH
	mov	WORD PTR ?nMaxLth@?1??GenerateName@@9@9, ax
$LN19@GenerateNa:

; 5144 : 
; 5145 :    // Compress the name if it needs it.
; 5146 :    UfCompressName( pchName,   // Original name.

	push	0
	push	OFFSET $SG80794
	push	OFFSET $SG80795
	push	OFFSET $SG80796
	push	OFFSET $SG80797
	movzx	ecx, WORD PTR ?nMaxLth@?1??GenerateName@@9@9
	push	ecx
	mov	edx, DWORD PTR _pchName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchName$[ebp]
	push	eax
	call	_UfCompressName@32

; 5147 :                    pchName,   // New (shorter) name.
; 5148 :                    nMaxLth,   // Max length of string.
; 5149 :                    "",        // Remove embedded spaces.
; 5150 :                    "",        // Ignore '_' (for now).
; 5151 :                    "Bc",      // Remove lower-case vowels starting from back.
; 5152 :                    "B_",      // Remove '_' starting from back.
; 5153 :                    0 );       // Stop when the name is short enough.
; 5154 : 
; 5155 :    if ( szCreateUnderscore[ 0 ] == 'Y' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szCreateUnderscore$[ebp+edx]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN20@GenerateNa

; 5156 :       // KJS 08/07/14 - Change string to all lower-case if we are creating table/column names with underscore.
; 5157 :       SysTranslateString( pchName, 'L' );

	push	76					; 0000004cH
	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	call	_SysTranslateString@8
	jmp	SHORT $LN21@GenerateNa
$LN20@GenerateNa:

; 5158 :    else
; 5159 :       // Change string to all upper-case.
; 5160 :       SysTranslateString( pchName, 'U' );

	push	85					; 00000055H
	mov	edx, DWORD PTR _pchName$[ebp]
	push	edx
	call	_SysTranslateString@8
$LN21@GenerateNa:

; 5161 : 
; 5162 :    // Make sure generated name doesn't match a reserved word.
; 5163 :    fnChangeReservedName( pchName );

	mov	eax, DWORD PTR _pchName$[ebp]
	push	eax
	call	_fnChangeReservedName@4

; 5164 : 
; 5165 :    return( 0 );

	xor	eax, eax
$LN1@GenerateNa:

; 5166 : 
; 5167 : } // GenerateName

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_GenerateName@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_original$ = -288					; size = 4
_targetEnd$ = -284					; size = 4
tv65 = -280						; size = 4
_l$ = -276						; size = 4
_vDBH_Data$ = -272					; size = 4
_nMaxLth$ = -268					; size = 2
_p$ = -264						; size = 4
_sz$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pchSrc$ = 8						; size = 4
_pchTarget$ = 12					; size = 4
_cMetaType$ = 16					; size = 1
_TranslateToUnderscoreCase@12 PROC

; 4929 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4930 :    zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 4931 :    //zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 4932 :    //zCHAR  szCreateUnderscore[ 2 ];
; 4933 :    zLONG  l;
; 4934 :    zPCHAR targetEnd; // = pchTarget + targetLth - 1; // Point to last char in target buffer.
; 4935 :    zPCHAR original = pchSrc;

	mov	eax, DWORD PTR _pchSrc$[ebp]
	mov	DWORD PTR _original$[ebp], eax

; 4936 :    zPCHAR p;
; 4937 :    zCHAR  sz[ 256 ];
; 4938 :    zSHORT nMaxLth;      // Used to keep track of duplicate names.
; 4939 : 
; 4940 :    switch ( cMetaType )

	mov	cl, BYTE PTR _cMetaType$[ebp]
	mov	BYTE PTR tv65[ebp], cl
	cmp	BYTE PTR tv65[ebp], 65			; 00000041H
	je	SHORT $LN9@TranslateT
	cmp	BYTE PTR tv65[ebp], 69			; 00000045H
	je	SHORT $LN6@TranslateT
	jmp	$LN12@TranslateT
$LN6@TranslateT:

; 4941 :    {
; 4942 :       case 'E':      // Meta type is Entity
; 4943 : 
; 4944 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 4945 :          // not specified use the default length.
; 4946 :          if ( vDBH_Data &&

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN7@TranslateT
	push	OFFSET $SG80729
	push	OFFSET $SG80730
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $LN7@TranslateT

; 4947 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 4948 :                                        "MaxTableNameLength" ) != -1 )
; 4949 :          {
; 4950 :             nMaxLth = (zSHORT) l;

	mov	dx, WORD PTR _l$[ebp]
	mov	WORD PTR _nMaxLth$[ebp], dx

; 4951 :          }

	jmp	SHORT $LN8@TranslateT
$LN7@TranslateT:

; 4952 :          else
; 4953 :             nMaxLth = MAX_TABLENAME_LTH;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _nMaxLth$[ebp], ax
$LN8@TranslateT:

; 4954 : 
; 4955 :          break;

	jmp	SHORT $LN2@TranslateT
$LN9@TranslateT:

; 4956 : 
; 4957 :       case 'A':      // Meta type is Attribute
; 4958 : 
; 4959 :          // Try getting the max length from the DBH-Specific OI.  If one is
; 4960 :          // not specified use the default length.
; 4961 :          if ( vDBH_Data &&

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN10@TranslateT
	push	OFFSET $SG80734
	push	OFFSET $SG80735
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16
	cwde
	cmp	eax, -1
	je	SHORT $LN10@TranslateT

; 4962 :               GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 4963 :                                        "MaxColumnNameLength" ) != -1 )
; 4964 :          {
; 4965 :             nMaxLth = (zSHORT) l;

	mov	cx, WORD PTR _l$[ebp]
	mov	WORD PTR _nMaxLth$[ebp], cx

; 4966 :          }

	jmp	SHORT $LN11@TranslateT
$LN10@TranslateT:

; 4967 :          else
; 4968 :             nMaxLth = MAX_COLUMNNAME_LTH;

	mov	edx, 32					; 00000020H
	mov	WORD PTR _nMaxLth$[ebp], dx
$LN11@TranslateT:

; 4969 : 
; 4970 :          break;

	jmp	SHORT $LN2@TranslateT
$LN12@TranslateT:

; 4971 : 
; 4972 : 	  default:
; 4973 : 	     zstrcpy( pchTarget, pchSrc );

	mov	eax, DWORD PTR _pchSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4974 : 		 return 0;

	xor	eax, eax
	jmp	$LN1@TranslateT
$LN2@TranslateT:

; 4975 :    }
; 4976 : 
; 4977 :    if ( nMaxLth >= BUFF_SIZE )

	movsx	edx, WORD PTR _nMaxLth$[ebp]
	cmp	edx, 256				; 00000100H
	jl	SHORT $LN13@TranslateT

; 4978 :       nMaxLth = BUFF_SIZE - 1;

	mov	eax, 255				; 000000ffH
	mov	WORD PTR _nMaxLth$[ebp], ax
$LN13@TranslateT:

; 4979 : 
; 4980 :   targetEnd = pchTarget + nMaxLth - 1;

	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	mov	edx, DWORD PTR _pchTarget$[ebp]
	lea	eax, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR _targetEnd$[ebp], eax

; 4981 : 
; 4982 :   // Defensive programming...
; 4983 :   *targetEnd = 0;

	mov	ecx, DWORD PTR _targetEnd$[ebp]
	mov	BYTE PTR [ecx], 0

; 4984 : 
; 4985 :   if ( (zSHORT) zstrlen( pchSrc ) >= nMaxLth )

	mov	edx, DWORD PTR _pchSrc$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cwde
	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN14@TranslateT

; 4986 :      return zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	jmp	$LN1@TranslateT
$LN14@TranslateT:

; 4987 : 
; 4988 :   zstrcpy( sz, pchSrc );

	mov	edx, DWORD PTR _pchSrc$[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4989 : 
; 4990 :   //p = pchTarget;
; 4991 :   p = sz;

	lea	ecx, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _p$[ebp], ecx

; 4992 : 
; 4993 :   // Copy first char to target.
; 4994 :   *p++ = *pchSrc++;

	mov	edx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _pchSrc$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 1
	mov	DWORD PTR _p$[ebp], edx
	mov	eax, DWORD PTR _pchSrc$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSrc$[ebp], eax
$LN4@TranslateT:

; 4995 :   while ( *pchSrc != 0 )

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN5@TranslateT

; 4996 :   {
; 4997 :       // Do we have enough space to add two more chars?
; 4998 :     if ( p + 2 > targetEnd )

	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 2
	cmp	eax, DWORD PTR _targetEnd$[ebp]
	jbe	SHORT $LN15@TranslateT

; 4999 :   	  return -16;

	mov	eax, -16				; fffffff0H
	jmp	$LN1@TranslateT
$LN15@TranslateT:

; 5000 : 
; 5001 :     if ( *pchSrc >= 'A' && *pchSrc <= 'Z' )

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 65					; 00000041H
	jl	SHORT $LN16@TranslateT
	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 90					; 0000005aH
	jg	SHORT $LN16@TranslateT

; 5002 : 	{
; 5003 : 	  // We have a capital letter.  Is previous letter upper?
; 5004 : 	  if ( *(p-1) < 'A' || *(p-1) > 'Z' )

	mov	edx, DWORD PTR _p$[ebp]
	movsx	eax, BYTE PTR [edx-1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN19@TranslateT
	mov	ecx, DWORD PTR _p$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN17@TranslateT
$LN19@TranslateT:

; 5005 : 	    // No, so copy _.
; 5006 : 	    *p++ = '_';

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 95			; 0000005fH
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	jmp	SHORT $LN16@TranslateT
$LN17@TranslateT:

; 5007 : 	  else
; 5008 : 	    // Previous letter is also upper.  Insert _ if next char is lower.
; 5009 : 	    if ( ( *(pchSrc+1) < 'A' || *(pchSrc+1) > 'Z' ) && *(pchSrc+1) != 0 )

	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 65					; 00000041H
	jl	SHORT $LN21@TranslateT
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 90					; 0000005aH
	jle	SHORT $LN16@TranslateT
$LN21@TranslateT:
	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN16@TranslateT

; 5010 : 			*p++ = '_';

	mov	edx, DWORD PTR _p$[ebp]
	mov	BYTE PTR [edx], 95			; 0000005fH
	mov	eax, DWORD PTR _p$[ebp]
	add	eax, 1
	mov	DWORD PTR _p$[ebp], eax
$LN16@TranslateT:

; 5011 : 	}
; 5012 :       *p++ = *pchSrc++;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	edx, DWORD PTR _pchSrc$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx

; 5013 :     }

	jmp	$LN4@TranslateT
$LN5@TranslateT:

; 5014 : //
; 5015 :   *p++ = 0;

	mov	eax, DWORD PTR _p$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx

; 5016 :   
; 5017 :   // Now convert to all lower.
; 5018 :   SysTranslateString( p, 'L' );

	push	76					; 0000004cH
	mov	edx, DWORD PTR _p$[ebp]
	push	edx
	call	_SysTranslateString@8

; 5019 :   zstrcpy( pchTarget, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5020 : 
; 5021 :   return 0;

	xor	eax, eax
$LN1@TranslateT:

; 5022 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TranslateToUnderscoreCase@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_j$ = -112						; size = 2
_k$ = -108						; size = 2
_szTemp$1 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_pchName$ = 8						; size = 4
_fnChangeReservedName@4 PROC

; 4872 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4873 :    zSHORT   k, j;
; 4874 : 
; 4875 :    // List of reserved names is terminated by a empty string.
; 4876 :    for ( k = 0; szReservedName[ k ][ 0 ]; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@fnChangeRe
$LN2@fnChangeRe:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@fnChangeRe:
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _szReservedName[edx*4]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN1@fnChangeRe

; 4877 :    {
; 4878 :       j = zstrcmpi( szReservedName[ k ], pchName );

	mov	ecx, DWORD PTR _pchName$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _szReservedName[edx*4]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _j$[ebp], ax

; 4879 :       if ( j == 0 )

	movsx	ecx, WORD PTR _j$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@fnChangeRe

; 4880 :       {
; 4881 :          zCHAR szTemp[ 100 ] = "z_";

	mov	dx, WORD PTR $SG80702
	mov	WORD PTR _szTemp$1[ebp], dx
	mov	al, BYTE PTR $SG80702+2
	mov	BYTE PTR _szTemp$1[ebp+2], al
	push	97					; 00000061H
	push	0
	lea	ecx, DWORD PTR _szTemp$1[ebp+3]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 4882 : 
; 4883 :          // Since we know that all the reserved words are at least 2 chars
; 4884 :          // shorter then the max column/table length, then don't worry about
; 4885 :          // compressing the name.
; 4886 :          zstrcat( szTemp, pchName );

	mov	edx, DWORD PTR _pchName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTemp$1[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 4887 :          zstrcpy( pchName, szTemp );

	lea	ecx, DWORD PTR _szTemp$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4888 :          return;

	jmp	SHORT $LN1@fnChangeRe
$LN5@fnChangeRe:

; 4889 :       }
; 4890 : 
; 4891 :       // Reserved words are listed in alphabetical order.  If the compare
; 4892 :       // returned a value greater than 0, then pchName comes before the current
; 4893 :       // szReservedName, which means there cannot be a match.
; 4894 :       if ( j > 0 )

	movsx	eax, WORD PTR _j$[ebp]
	test	eax, eax
	jle	SHORT $LN6@fnChangeRe

; 4895 :          return;

	jmp	SHORT $LN1@fnChangeRe
$LN6@fnChangeRe:

; 4896 :    }

	jmp	$LN2@fnChangeRe
$LN1@fnChangeRe:

; 4897 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnChangeReservedName@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
tv326 = -84						; size = 4
tv142 = -80						; size = 4
tv132 = -76						; size = 4
_pchDomainName$1 = -72					; size = 4
_vTZDBHODO$2 = -68					; size = 4
_vDBH_Data$3 = -64					; size = 4
_vTZTEDBLO$4 = -60					; size = 4
tv239 = -56						; size = 4
_pchDataType$ = -52					; size = 4
_lLth$ = -48						; size = 4
_bTimestampAsString$ = -41				; size = 1
_szDBH_DataObjectName$5 = -40				; size = 33
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_bSetDefault$ = 12					; size = 1
_SetDataType@8 PROC

; 4661 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4662 :    zPCHAR pchDataType;
; 4663 :    zLONG  lLth;
; 4664 :    zBOOL  bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0

; 4665 : 
; 4666 :    if ( bSetDefault )

	movzx	eax, BYTE PTR _bSetDefault$[ebp]
	test	eax, eax
	je	$LN6@SetDataTyp

; 4667 :    {
; 4668 :       zPCHAR pchDomainName;
; 4669 :       zVIEW  vTZTEDBLO;
; 4670 :       zVIEW  vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$2[ebp], 0

; 4671 :       zVIEW  vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$3[ebp], 0

; 4672 :       zCHAR  szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 4673 : 
; 4674 :       // If it exists get the object that defines the dbhandler type.
; 4675 :       GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );  // vDTE added dks 2009.11.11

	push	2
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET $SG80582
	lea	edx, DWORD PTR _vTZTEDBLO$4[ebp]
	push	edx
	call	_GetViewByName@16

; 4676 :       if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$4[ebp], 0
	je	SHORT $LN7@SetDataTyp

; 4677 :          SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",

	push	0
	push	OFFSET $SG80584
	push	OFFSET $SG80585
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG80586
	push	OFFSET $SG80587
	mov	ecx, DWORD PTR _vTZTEDBLO$4[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
$LN7@SetDataTyp:

; 4678 :                                      vDTE,      "TE_DBMS_Source", "DBMS", 0 );
; 4679 : 
; 4680 :       // Try to get the OI that contains DBH-specific data.
; 4681 :       SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,

	push	512					; 00000200H
	push	OFFSET $SG80588
	push	OFFSET $SG80589
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDBH_DataObjectName$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDBH_Data$3[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 4682 :                       "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 4683 : 
; 4684 :       #if defined( ACCESS ) || defined( ODBC )
; 4685 : 
; 4686 :          // Try to get the ODBC definition.
; 4687 :          SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,

	push	512					; 00000200H
	push	OFFSET $SG80590
	push	OFFSET $SG80591
	mov	eax, DWORD PTR _vTZTEDBLO$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _vTZDBHODO$2[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 4688 :                          "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 4689 : 
; 4690 :          // Check to see if there is DBH data set in the TE.
; 4691 :          if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$3[ebp], 0
	je	SHORT $LN8@SetDataTyp

; 4692 :          {
; 4693 :             bTimestampAsString =

	push	OFFSET $SG80594
	push	OFFSET $SG80595
	push	OFFSET $SG80596
	mov	eax, DWORD PTR _vDBH_Data$3[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN37@SetDataTyp
	mov	DWORD PTR tv132[ebp], 1
	jmp	SHORT $LN38@SetDataTyp
$LN37@SetDataTyp:
	mov	DWORD PTR tv132[ebp], 0
$LN38@SetDataTyp:
	mov	dl, BYTE PTR tv132[ebp]
	mov	BYTE PTR _bTimestampAsString$[ebp], dl

; 4694 :                          ( CompareAttributeToString( vDBH_Data, "ODBC",
; 4695 :                                                      "TimestampAsString",
; 4696 :                                                      "Y" ) == 0 );
; 4697 :          }

	jmp	SHORT $LN9@SetDataTyp
$LN8@SetDataTyp:

; 4698 :          else
; 4699 :          // Check to see if there is DBH data set in the DB List object.
; 4700 :          if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$2[ebp], 0
	je	SHORT $LN9@SetDataTyp

; 4701 :          {
; 4702 :                bTimestampAsString =

	push	OFFSET $SG80598
	push	OFFSET $SG80599
	push	OFFSET $SG80600
	mov	eax, DWORD PTR _vTZDBHODO$2[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN39@SetDataTyp
	mov	DWORD PTR tv142[ebp], 1
	jmp	SHORT $LN40@SetDataTyp
$LN39@SetDataTyp:
	mov	DWORD PTR tv142[ebp], 0
$LN40@SetDataTyp:
	mov	dl, BYTE PTR tv142[ebp]
	mov	BYTE PTR _bTimestampAsString$[ebp], dl
$LN9@SetDataTyp:

; 4703 :                          ( CompareAttributeToString( vTZDBHODO, "ODBC",
; 4704 :                                                      "TimestampAsString",
; 4705 :                                                      "Y" ) == 0 );
; 4706 :          }
; 4707 : 
; 4708 :       #endif
; 4709 : 
; 4710 :       // Set the default data type from the ER attribute domain.  If the
; 4711 :       // domain name is "Date" or "Time" then use SqlBase date/time types.
; 4712 :       GetAddrForAttribute( &pchDomainName, vDTE, "Domain", "Name" );

	push	OFFSET $SG80601
	push	OFFSET $SG80602
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDomainName$1[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4713 : 
; 4714 : #if defined( SQLSERVER ) && !defined( QUINSOFT )
; 4715 :       if ( zstrcmpi( pchDomainName, "Date" ) == 0 ||
; 4716 :            zstrcmpi( pchDomainName, "Time" ) == 0 )
; 4717 :       {
; 4718 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "T" );
; 4719 :       }
; 4720 :       else
; 4721 :       if ( zstrcmpi( pchDomainName, "TimeStampEx" ) == 0 )
; 4722 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "X" );
; 4723 :       else
; 4724 :          // Domain is not Date or Time, so just set the default data type the
; 4725 :          // same as the domain's data type.
; 4726 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "DataType",
; 4727 :                                     vDTE, "Domain", "DataType" );
; 4728 : #else
; 4729 :       if ( zstrcmpi( pchDomainName, "Date" ) == 0 )

	push	OFFSET $SG80605
	mov	edx, DWORD PTR _pchDomainName$1[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@SetDataTyp

; 4730 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "D" );

	push	OFFSET $SG80606
	push	OFFSET $SG80607
	push	OFFSET $SG80608
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16
	jmp	$LN12@SetDataTyp
$LN11@SetDataTyp:

; 4731 :       else
; 4732 :       if ( zstrcmpi( pchDomainName, "Time" ) == 0 )

	push	OFFSET $SG80611
	mov	ecx, DWORD PTR _pchDomainName$1[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN13@SetDataTyp

; 4733 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "I" );

	push	OFFSET $SG80612
	push	OFFSET $SG80613
	push	OFFSET $SG80614
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromString@16
	jmp	SHORT $LN12@SetDataTyp
$LN13@SetDataTyp:

; 4734 :       else
; 4735 :       if ( zstrcmpi( pchDomainName, "TimeStampEx" ) == 0 )

	push	OFFSET $SG80617
	mov	eax, DWORD PTR _pchDomainName$1[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@SetDataTyp

; 4736 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "X" );

	push	OFFSET $SG80618
	push	OFFSET $SG80619
	push	OFFSET $SG80620
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
	jmp	SHORT $LN12@SetDataTyp
$LN15@SetDataTyp:

; 4737 : #if defined( MYSQL )
; 4738 :       else
; 4739 :       // If domain is GeneratedKey then use "SERIAL" for default datatype.
; 4740 :       if ( zstrcmpi( pchDomainName, "GeneratedKey" ) == 0 )
; 4741 :       {
; 4742 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "A" );
; 4743 :       }    
; 4744 : #endif
; 4745 :       else
; 4746 :          // Domain is not Date or Time, so just set the default data type the
; 4747 :          // same as the domain's data type.
; 4748 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "DataType",

	push	OFFSET $SG80621
	push	OFFSET $SG80622
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET $SG80623
	push	OFFSET $SG80624
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24
$LN12@SetDataTyp:

; 4749 :                                     vDTE, "Domain", "DataType" );
; 4750 : #endif
; 4751 : 
; 4752 :       // Strings with a length > 254 must have a data type of VarChar.
; 4753 :       GetAddrForAttribute( &pchDataType, vDTE, "Domain", "DataType" );

	push	OFFSET $SG80625
	push	OFFSET $SG80626
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDataType$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4754 :       if ( pchDataType[ 0 ] == zTYPE_STRING )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchDataType$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN6@SetDataTyp

; 4755 :       {
; 4756 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET $SG80628
	push	OFFSET $SG80629
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 4757 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $LN18@SetDataTyp

; 4758 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET $SG80631
	push	OFFSET $SG80632
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lLth$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
$LN18@SetDataTyp:

; 4759 : 
; 4760 :          if ( lLth > MAX_LTH_FOR_STRING )

	cmp	DWORD PTR _lLth$[ebp], 254		; 000000feH
	jle	SHORT $LN6@SetDataTyp

; 4761 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "V" );

	push	OFFSET $SG80634
	push	OFFSET $SG80635
	push	OFFSET $SG80636
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$LN6@SetDataTyp:

; 4762 :       }
; 4763 : 
; 4764 : #if !defined( QUINSOFT) && !defined( SQLSERVER ) && !defined( SQLBASE )
; 4765 :       if ( pchDataType[ 0 ] == zTYPE_BLOB )
; 4766 :          SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "V" );
; 4767 : #endif
; 4768 : 
; 4769 :    }
; 4770 : 
; 4771 :    // Get the data type.
; 4772 :    GetAddrForAttribute( &pchDataType, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET $SG80637
	push	OFFSET $SG80638
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDataType$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4773 : 
; 4774 :    // Now set the length according to the physical data type.
; 4775 :    switch ( pchDataType[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchDataType$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR tv239[ebp], edx
	mov	eax, DWORD PTR tv239[ebp]
	sub	eax, 65					; 00000041H
	mov	DWORD PTR tv239[ebp], eax
	cmp	DWORD PTR tv239[ebp], 23		; 00000017H
	ja	$LN35@SetDataTyp
	mov	ecx, DWORD PTR tv239[ebp]
	movzx	edx, BYTE PTR $LN41@SetDataTyp[ecx]
	jmp	DWORD PTR $LN42@SetDataTyp[edx*4]
$LN20@SetDataTyp:

; 4776 :    {
; 4777 : 
; 4778 :       case zTYPE_STRING:
; 4779 :       case 'V':
; 4780 :       case zTYPE_FIXEDCHAR:
; 4781 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET $SG80640
	push	OFFSET $SG80641
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lLth$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 4782 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $LN21@SetDataTyp

; 4783 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET $SG80643
	push	OFFSET $SG80644
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _lLth$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
$LN21@SetDataTyp:

; 4784 : 
; 4785 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );

	mov	ecx, DWORD PTR _lLth$[ebp]
	push	ecx
	push	OFFSET $SG80645
	push	OFFSET $SG80646
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16

; 4786 :          break;

	jmp	$LN2@SetDataTyp
$LN22@SetDataTyp:

; 4787 : 
; 4788 :       case zTYPE_BLOB:
; 4789 : 
; 4790 : #if defined( DB2 )
; 4791 :          // DB2 needs a blob length.
; 4792 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );
; 4793 :          if ( lLth == 0  )
; 4794 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );
; 4795 : 
; 4796 :          if ( lLth == 0  )
; 4797 :             lLth = 65536;   // Default length for blobs.
; 4798 : 
; 4799 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );
; 4800 : #else
; 4801 :          SetAttributeFromAttribute( vDTE, "TE_FieldDataRel", "Length",

	push	OFFSET $SG80648
	push	OFFSET $SG80649
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG80650
	push	OFFSET $SG80651
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromAttribute@24

; 4802 :                                     vDTE, "ER_Attribute",    "Lth" );
; 4803 : #endif
; 4804 : 
; 4805 :          break;

	jmp	$LN2@SetDataTyp
$LN23@SetDataTyp:

; 4806 : 
; 4807 :       case zTYPE_INTEGER:
; 4808 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET $SG80653
	push	OFFSET $SG80654
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16

; 4809 :          break;

	jmp	$LN2@SetDataTyp
$LN24@SetDataTyp:

; 4810 : 
; 4811 :       case 'A':                // For SERIAL/AUTOINCREMENT
; 4812 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 64 );

	push	64					; 00000040H
	push	OFFSET $SG80656
	push	OFFSET $SG80657
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4813 :          break;

	jmp	$LN2@SetDataTyp
$LN25@SetDataTyp:

; 4814 : 
; 4815 :       case zTYPE_DECIMAL:
; 4816 :          GetIntegerFromAttribute( &lLth, vDTE, "ER_Attribute", "Lth" );

	push	OFFSET $SG80659
	push	OFFSET $SG80660
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lLth$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 4817 :          if ( lLth == 0  )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $LN26@SetDataTyp

; 4818 :          {
; 4819 :             GetIntegerFromAttribute( &lLth, vDTE, "Domain", "MaxStringLth" );

	push	OFFSET $SG80662
	push	OFFSET $SG80663
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lLth$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 4820 :             if ( lLth == 0 )

	cmp	DWORD PTR _lLth$[ebp], 0
	jne	SHORT $LN26@SetDataTyp

; 4821 :                lLth = sizeof( zDECIMAL );

	mov	DWORD PTR _lLth$[ebp], 40		; 00000028H
$LN26@SetDataTyp:

; 4822 :          }
; 4823 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", lLth );

	mov	edx, DWORD PTR _lLth$[ebp]
	push	edx
	push	OFFSET $SG80665
	push	OFFSET $SG80666
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4824 :          break;

	jmp	$LN2@SetDataTyp
$LN28@SetDataTyp:

; 4825 : 
; 4826 :       case zTYPE_DATETIME:
; 4827 :       case zTYPE_TIME:
; 4828 :          if ( bTimestampAsString )

	movzx	ecx, BYTE PTR _bTimestampAsString$[ebp]
	test	ecx, ecx
	je	SHORT $LN29@SetDataTyp

; 4829 :          {
; 4830 :             // This is only true when we are setting the default value of the
; 4831 :             // data type.  Change the datatype to be a string.
; 4832 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "DataType", "S" );

	push	OFFSET $SG80670
	push	OFFSET $SG80671
	push	OFFSET $SG80672
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4833 :             SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 25 );

	push	25					; 00000019H
	push	OFFSET $SG80673
	push	OFFSET $SG80674
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 4834 :          }

	jmp	SHORT $LN30@SetDataTyp
$LN29@SetDataTyp:

; 4835 :          else
; 4836 :          {
; 4837 :             switch ( pchDataType[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchDataType$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR tv326[ebp], cl
	cmp	BYTE PTR tv326[ebp], 73			; 00000049H
	je	SHORT $LN32@SetDataTyp
	cmp	BYTE PTR tv326[ebp], 84			; 00000054H
	je	SHORT $LN31@SetDataTyp
	jmp	SHORT $LN30@SetDataTyp
$LN31@SetDataTyp:

; 4838 :             {
; 4839 :                case zTYPE_DATETIME:
; 4840 :                   SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET $SG80676
	push	OFFSET $SG80677
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16

; 4841 :                   break;

	jmp	SHORT $LN30@SetDataTyp
$LN32@SetDataTyp:

; 4842 : 
; 4843 :                case zTYPE_TIME:
; 4844 :                   SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 8 );

	push	8
	push	OFFSET $SG80679
	push	OFFSET $SG80680
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16
$LN30@SetDataTyp:

; 4845 :                   break;
; 4846 :             }
; 4847 :          }
; 4848 : 
; 4849 :          break;

	jmp	SHORT $LN2@SetDataTyp
$LN33@SetDataTyp:

; 4850 : 
; 4851 :       case zTYPE_DATE:
; 4852 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 4 );

	push	4
	push	OFFSET $SG80682
	push	OFFSET $SG80683
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 4853 :          break;

	jmp	SHORT $LN2@SetDataTyp
$LN34@SetDataTyp:

; 4854 : 
; 4855 :       case 'X':
; 4856 :          SetAttributeFromInteger( vDTE, "TE_FieldDataRel", "Length", 30 );

	push	30					; 0000001eH
	push	OFFSET $SG80685
	push	OFFSET $SG80686
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16

; 4857 :          break;

	jmp	SHORT $LN2@SetDataTyp
$LN35@SetDataTyp:

; 4858 : 
; 4859 :       default:
; 4860 :          TraceLineS( "(TE) Invalid Physical Data type = ", pchDataType );

	mov	eax, DWORD PTR _pchDataType$[ebp]
	push	eax
	push	OFFSET $SG80688
	call	_TraceLineS@8

; 4861 :          SysMessageBox( vDTE, "Zeidon TE", "Invalid Physical Data type.", 1 );

	push	1
	push	OFFSET $SG80689
	push	OFFSET $SG80690
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 4862 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SetDataTyp
$LN2@SetDataTyp:

; 4863 :    }
; 4864 : 
; 4865 :    return( 0 );

	xor	eax, eax
$LN1@SetDataTyp:

; 4866 : 
; 4867 : } // SetDataType

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN42@SetDataTyp:
	DD	$LN24@SetDataTyp
	DD	$LN22@SetDataTyp
	DD	$LN33@SetDataTyp
	DD	$LN20@SetDataTyp
	DD	$LN28@SetDataTyp
	DD	$LN23@SetDataTyp
	DD	$LN25@SetDataTyp
	DD	$LN34@SetDataTyp
	DD	$LN35@SetDataTyp
$LN41@SetDataTyp:
	DB	0
	DB	1
	DB	8
	DB	2
	DB	8
	DB	3
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	5
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	4
	DB	8
	DB	3
	DB	8
	DB	7
_SetDataType@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_vType$ = 8						; size = 4
_LoadDataTypes@4 PROC

; 4501 : {

	push	ebp
	mov	ebp, esp

; 4502 :    //
; 4503 :    // Following are standard types.
; 4504 :    //
; 4505 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80492
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4506 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "S" );

	push	OFFSET $SG80493
	push	OFFSET $SG80494
	push	OFFSET $SG80495
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4507 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",

	push	OFFSET $SG80496
	push	OFFSET $SG80497
	push	OFFSET $SG80498
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4508 :                            "String" );
; 4509 : 
; 4510 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80499
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4511 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "L" );

	push	OFFSET $SG80500
	push	OFFSET $SG80501
	push	OFFSET $SG80502
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4512 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",

	push	OFFSET $SG80503
	push	OFFSET $SG80504
	push	OFFSET $SG80505
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4513 :                            "Integer" );
; 4514 : 
; 4515 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80506
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4516 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "M" );

	push	OFFSET $SG80507
	push	OFFSET $SG80508
	push	OFFSET $SG80509
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4517 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",

	push	OFFSET $SG80510
	push	OFFSET $SG80511
	push	OFFSET $SG80512
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4518 :                            "Decimal" );
; 4519 : 
; 4520 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80513
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4521 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );

	push	OFFSET $SG80514
	push	OFFSET $SG80515
	push	OFFSET $SG80516
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4522 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",

	push	OFFSET $SG80517
	push	OFFSET $SG80518
	push	OFFSET $SG80519
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4523 :                            "Timestamp" );
; 4524 : 
; 4525 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80520
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4526 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "X" );

	push	OFFSET $SG80521
	push	OFFSET $SG80522
	push	OFFSET $SG80523
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4527 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",

	push	OFFSET $SG80524
	push	OFFSET $SG80525
	push	OFFSET $SG80526
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4528 :                            "TimeStampEx" );
; 4529 : 
; 4530 : #if defined( SQLSERVER ) && !defined( QUINSOFT )
; 4531 :    /*
; 4532 :    ** The ODBC-driver for SqlServer doesn't support SQL_DATE and SQL_TIME
; 4533 :    */
; 4534 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4535 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );
; 4536 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Date" );
; 4537 : 
; 4538 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4539 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "T" );
; 4540 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Time" );
; 4541 : #else
; 4542 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80527
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4543 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "D" );

	push	OFFSET $SG80528
	push	OFFSET $SG80529
	push	OFFSET $SG80530
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4544 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Date" );

	push	OFFSET $SG80531
	push	OFFSET $SG80532
	push	OFFSET $SG80533
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4545 : 
; 4546 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80534
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4547 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "I" );

	push	OFFSET $SG80535
	push	OFFSET $SG80536
	push	OFFSET $SG80537
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4548 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Time" );

	push	OFFSET $SG80538
	push	OFFSET $SG80539
	push	OFFSET $SG80540
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4549 : #endif
; 4550 : 
; 4551 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80541
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4552 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "F" );

	push	OFFSET $SG80542
	push	OFFSET $SG80543
	push	OFFSET $SG80544
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4553 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "FixedChar" );

	push	OFFSET $SG80545
	push	OFFSET $SG80546
	push	OFFSET $SG80547
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4554 : 
; 4555 : #if defined( ACCESS )
; 4556 : 
; 4557 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80548
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4558 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );

	push	OFFSET $SG80549
	push	OFFSET $SG80550
	push	OFFSET $SG80551
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4559 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",

	push	OFFSET $SG80552
	push	OFFSET $SG80553
	push	OFFSET $SG80554
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4560 :                            "Blob (Memo)" );     // Blob name.
; 4561 : 
; 4562 :    //
; 4563 :    // Following are DB-specific types.
; 4564 :    //
; 4565 : 
; 4566 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );

	push	2
	push	OFFSET $SG80555
	mov	eax, DWORD PTR _vType$[ebp]
	push	eax
	call	_CreateEntity@12

; 4567 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );

	push	OFFSET $SG80556
	push	OFFSET $SG80557
	push	OFFSET $SG80558
	mov	ecx, DWORD PTR _vType$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4568 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Memo" );

	push	OFFSET $SG80559
	push	OFFSET $SG80560
	push	OFFSET $SG80561
	mov	edx, DWORD PTR _vType$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4569 : 
; 4570 : #elif defined( DB2 )
; 4571 : 
; 4572 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4573 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4574 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Blob" );
; 4575 : 
; 4576 :    //
; 4577 :    // Following are DB-specific types.
; 4578 :    //
; 4579 : 
; 4580 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4581 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4582 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "CLOB" );
; 4583 : 
; 4584 : #elif defined( SQLBASE ) || defined( ODBC )
; 4585 : 
; 4586 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4587 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4588 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4589 :                            "Blob (VarChar)" );     // Blob name.
; 4590 : 
; 4591 :    //
; 4592 :    // Following are DB-specific types.
; 4593 :    //
; 4594 : 
; 4595 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4596 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4597 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "VarChar" );
; 4598 : 
; 4599 : #elif defined( MYSQL )
; 4600 : 
; 4601 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4602 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4603 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4604 :                            "Blob (longblob)" );       // Blob name.
; 4605 : 
; 4606 :    //
; 4607 :    // Following are DB-specific types.
; 4608 :    //
; 4609 : 
; 4610 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4611 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4612 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Text (longtext)" );
; 4613 : 
; 4614 :    // Create a data type that will be autoincrement in MySql
; 4615 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4616 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "A" );
; 4617 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4618 :                            "SERIAL (autoincrement)" );
; 4619 : 
; 4620 : #elif defined( POSTGRESQL ) || defined( SQLSERVER )
; 4621 : 
; 4622 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4623 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "B" );
; 4624 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName",
; 4625 :                            "Blob (bytea)" );       // Blob name.
; 4626 : 
; 4627 :    //
; 4628 :    // Following are DB-specific types.
; 4629 :    //
; 4630 : 
; 4631 :    CreateEntity( vType, "DB_DataTypes", zPOS_LAST );
; 4632 :    SetAttributeFromString( vType, "DB_DataTypes", "InternalName", "V" );
; 4633 :    SetAttributeFromString( vType, "DB_DataTypes", "ExternalName", "Text" );
; 4634 : 
; 4635 : #endif
; 4636 : 
; 4637 :    return( 0 );

	xor	eax, eax

; 4638 : 
; 4639 : } // LoadDataTypes

	pop	ebp
	ret	4
_LoadDataTypes@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_pchColName$1 = -2108					; size = 4
_pchTableName$2 = -2104					; size = 4
_pchDBName$ = -2100					; size = 4
_pchDBDesc$ = -2096					; size = 4
_pchKeyType$3 = -2092					; size = 4
_pchKeyType$4 = -2088					; size = 4
_pchMatchFound$5 = -2084				; size = 4
_pchKeyType$6 = -2080					; size = 4
_pfn$ = -2076						; size = 4
_lDB_Lth$7 = -2072					; size = 4
_lDTE_Lth$8 = -2068					; size = 4
tv369 = -2064						; size = 4
tv370 = -2060						; size = 4
_hLibrary$ = -2056					; size = 4
tv340 = -2052						; size = 4
_vBoth$ = -2048						; size = 8
_nReturn$ = -2040					; size = 2
_pchDefaultOwner$ = -2036				; size = 4
_nLth$ = -2032						; size = 2
_bTableDropped$ = -2027					; size = 1
_bFirstAlterOfTable$9 = -2026				; size = 1
_bFirstAlterForTable$10 = -2025				; size = 1
_nIndexDroppedCount$11 = -2024				; size = 2
_k$ = -2020						; size = 2
_f$ = -2016						; size = 4
_vDB$ = -2012						; size = 4
_nRC$ = -2008						; size = 2
_szMsg$12 = -2004					; size = 1000
_szDLL$ = -1004						; size = 257
_szLine$ = -744						; size = 500
_szEntityName$13 = -244					; size = 33
_szEntityName$14 = -208					; size = 33
_szIndex$15 = -172					; size = 33
_szOwner$ = -136					; size = 33
_szColumnName$ = -100					; size = 33
_szTableName$ = -64					; size = 33
_szDTE_Type$16 = -28					; size = 10
_szDB_Type$17 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_vEMD$ = 12						; size = 4
_vTZTEDBLO$ = 16					; size = 4
_pchFileName$ = 20					; size = 4
_vSubtask$ = 24						; size = 4
_BuildSyncDDL@20 PROC

; 3952 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2108				; 0000083cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3953 :    LPLIBRARY hLibrary;
; 3954 :    zLONG     f = -1;

	mov	DWORD PTR _f$[ebp], -1

; 3955 :    zSHORT    (POPERATION pfn)( zVIEW, zPVIEW );
; 3956 :    zVIEW     vDB = 0;

	mov	DWORD PTR _vDB$[ebp], 0

; 3957 :    zVIEW     vBoth[ 2 ];
; 3958 :    zCHAR     szDLL[ zMAX_FILENAME_LTH + 1 ];
; 3959 :    zCHAR     szTableName[ MAX_TABLENAME_LTH + 1 ];
; 3960 :    zCHAR     szColumnName[ MAX_TABLENAME_LTH + 1 ];
; 3961 :    zCHAR     szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3962 :    zCHAR     szLine[ 500 ];
; 3963 :    zPCHAR    pchDefaultOwner;
; 3964 :    zPCHAR    pchDBName;
; 3965 :    zPCHAR    pchDBDesc;
; 3966 :    zSHORT    k, nRC;
; 3967 :    zSHORT    nLth;
; 3968 :    zSHORT    nReturn = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturn$[ebp], ax

; 3969 :    zBOOL     bTableDropped;
; 3970 : 
; 3971 :    // Make copies of the views so we can safely change the cursors.
; 3972 :    CreateViewFromViewForTask( &vDTE, vDTE, 0 );

	push	0
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 3973 :    CreateViewFromViewForTask( &vEMD, vEMD, 0 );

	push	0
	mov	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vEMD$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 3974 : 
; 3975 :    // First thing we have to do is call the SQL DBH to load the current
; 3976 :    // DB schema.
; 3977 :    GetStringFromAttribute( szDLL,

	push	OFFSET $SG80252
	push	OFFSET $SG80253
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDLL$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3978 :                            vDTE, "TE_DBMS_Source", "Executable" );
; 3979 :    hLibrary = SysLoadLibrary( vSubtask, szDLL );

	lea	ecx, DWORD PTR _szDLL$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3980 :    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $LN46@BuildSyncD

; 3981 :    {
; 3982 :       pfn = SysGetProc( hLibrary, "RetrieveSchema" );

	push	OFFSET $SG80255
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pfn$[ebp], eax

; 3983 :       if ( pfn )

	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $LN47@BuildSyncD

; 3984 :       {
; 3985 :          (*pfn)( vDTE, &vDB );

	lea	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	DWORD PTR _pfn$[ebp]

; 3986 :       }

	jmp	SHORT $LN48@BuildSyncD
$LN47@BuildSyncD:

; 3987 :       else
; 3988 :       {
; 3989 :          MessageSend( vSubtask, "TE00422", "Physical Data Model",

	push	0
	push	300					; 0000012cH
	push	OFFSET $SG80258
	push	OFFSET $SG80259
	push	OFFSET $SG80260
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_MessageSend@24
$LN48@BuildSyncD:

; 3990 :                       "Couldn't find 'BuildSyncDDL' in Generater Executable",
; 3991 :                       zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 );
; 3992 :       }
; 3993 : 
; 3994 :       SysFreeLibrary( vSubtask, hLibrary );

	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysFreeLibrary@8
$LN46@BuildSyncD:

; 3995 :    }
; 3996 : 
; 3997 :    if ( vDB == 0 )

	cmp	DWORD PTR _vDB$[ebp], 0
	jne	SHORT $LN49@BuildSyncD

; 3998 :       return( -1 );

	or	eax, -1
	jmp	$LN1@BuildSyncD
$LN49@BuildSyncD:

; 3999 : 
; 4000 :    //
; 4001 :    // Generate the DDL file name and open it.
; 4002 :    //
; 4003 :    nLth = zstrlen( pchFileName );

	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 4004 :    GetStringFromAttribute( pchFileName + nLth,

	push	OFFSET $SG80262
	push	OFFSET $SG80263
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nLth$[ebp]
	add	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4005 :                            vDTE, "TE_DBMS_Source", "Name" );
; 4006 :    zstrcat( pchFileName, "_alter" );

	push	OFFSET $SG80264
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 4007 : 
; 4008 :    // Make sure the filename isn't too long.
; 4009 :    if ( zstrlen( pchFileName + nLth ) > zBASE_FILENAME_LTH )

	movsx	ecx, WORD PTR _nLth$[ebp]
	add	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jbe	SHORT $LN50@BuildSyncD

; 4010 :       pchFileName[ nLth + zBASE_FILENAME_LTH ] = 0;

	movsx	edx, WORD PTR _nLth$[ebp]
	mov	eax, DWORD PTR _pchFileName$[ebp]
	mov	BYTE PTR [eax+edx+128], 0
$LN50@BuildSyncD:

; 4011 : 
; 4012 :    zstrcat( pchFileName, ".ddl" );

	push	OFFSET $SG80266
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4013 :    if ( (f = SysOpenFile( vDTE, pchFileName, COREFILE_WRITE )) < 0 )

	push	64					; 00000040H
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysOpenFile@12
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jge	SHORT $LN51@BuildSyncD

; 4014 :       goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN51@BuildSyncD:

; 4015 : 
; 4016 :    GetAddrForAttribute( &pchDBName, vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET $SG80268
	push	OFFSET $SG80269
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDBName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4017 :    GetAddrForAttribute( &pchDBDesc, vDTE, "TE_DBMS_Source", "Desc" );

	push	OFFSET $SG80270
	push	OFFSET $SG80271
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDBDesc$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4018 :    zsprintf( szLine, "%s Alter script for %s -- %s %s",

	push	OFFSET $SG80272
	mov	edx, DWORD PTR _pchDBDesc$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchDBName$[ebp]
	push	eax
	push	OFFSET $SG80273
	push	OFFSET $SG80274
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H

; 4019 :              COMMENT_START, pchDBName, pchDBDesc, COMMENT_END );
; 4020 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN52@BuildSyncD

; 4021 :       goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN52@BuildSyncD:

; 4022 : 
; 4023 :    GetAddrForAttribute( &pchDefaultOwner, vDTE,

	push	OFFSET $SG80276
	push	OFFSET $SG80277
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 4024 :                         "TE_DBMS_Source", "DefaultOwner" );
; 4025 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN54@BuildSyncD
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN53@BuildSyncD
$LN54@BuildSyncD:

; 4026 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$LN53@BuildSyncD:

; 4027 : 
; 4028 :    // Turn off the "MatchFound" flag for all the tables/columns.
; 4029 :    vBoth[ 0 ] = vDTE;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _vDTE$[ebp]
	mov	DWORD PTR _vBoth$[ebp+eax], ecx

; 4030 :    vBoth[ 1 ] = vDB;

	mov	edx, 4
	shl	edx, 0
	mov	eax, DWORD PTR _vDB$[ebp]
	mov	DWORD PTR _vBoth$[ebp+edx], eax

; 4031 :    for ( k = 0; k < 2; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@BuildSyncD
$LN2@BuildSyncD:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN4@BuildSyncD:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 2
	jge	$LN3@BuildSyncD

; 4032 :    {
; 4033 :       for ( nRC = SetCursorFirstEntity( vBoth[ k ], "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80280
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vBoth$[ebp+ecx*4]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN7@BuildSyncD
$LN5@BuildSyncD:

; 4035 :             nRC = SetCursorNextEntity( vBoth[ k ], "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80281
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vBoth$[ebp+eax*4]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN7@BuildSyncD:

; 4034 :             nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN6@BuildSyncD

; 4036 :       {
; 4037 :          SetAttributeFromString( vBoth[ k ], "TE_TablRec", "MatchFound", "N" );

	push	OFFSET $SG80282
	push	OFFSET $SG80283
	push	OFFSET $SG80284
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vBoth$[ebp+eax*4]
	push	ecx
	call	_SetAttributeFromString@16

; 4038 : 
; 4039 :          for ( nRC = SetCursorFirstEntity( vBoth[ k ], "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80285
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vBoth$[ebp+edx*4]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN10@BuildSyncD
$LN8@BuildSyncD:

; 4041 :                nRC = SetCursorNextEntity( vBoth[ k ], "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET $SG80286
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vBoth$[ebp+ecx*4]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN10@BuildSyncD:

; 4040 :                nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $LN9@BuildSyncD

; 4042 :          {
; 4043 :             SetAttributeFromString( vBoth[ k ], "TE_FieldDataRel",

	push	OFFSET $SG80287
	push	OFFSET $SG80288
	push	OFFSET $SG80289
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vBoth$[ebp+ecx*4]
	push	edx
	call	_SetAttributeFromString@16

; 4044 :                                     "MatchFound", "N" );
; 4045 :          }

	jmp	SHORT $LN8@BuildSyncD
$LN9@BuildSyncD:

; 4046 :       }

	jmp	$LN5@BuildSyncD
$LN6@BuildSyncD:

; 4047 :    }

	jmp	$LN2@BuildSyncD
$LN3@BuildSyncD:

; 4048 : 
; 4049 :    // Now look for matches.
; 4050 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80290
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN13@BuildSyncD
$LN11@BuildSyncD:

; 4052 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80291
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN13@BuildSyncD:

; 4051 :          nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN12@BuildSyncD

; 4053 :    {
; 4054 :       zPCHAR pchTableName;
; 4055 : 
; 4056 :       if ( SetCursorFirstEntityByAttr( vDB, "TE_TablRec", "Name",
; 4057 :                                        vDTE, "TE_TablRec",
; 4058 :                                        "Name", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET $SG80293
	push	OFFSET $SG80294
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG80295
	push	OFFSET $SG80296
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN55@BuildSyncD

; 4059 :       {
; 4060 :          continue;

	jmp	SHORT $LN11@BuildSyncD
$LN55@BuildSyncD:

; 4061 :       }
; 4062 : 
; 4063 :       GetAddrForAttribute( &pchTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET $SG80297
	push	OFFSET $SG80298
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchTableName$2[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4064 :       SetAttributeFromString( vDTE, "TE_TablRec", "MatchFound", "Y" );

	push	OFFSET $SG80299
	push	OFFSET $SG80300
	push	OFFSET $SG80301
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4065 :       SetAttributeFromString( vDB,  "TE_TablRec", "MatchFound", "Y" );

	push	OFFSET $SG80302
	push	OFFSET $SG80303
	push	OFFSET $SG80304
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4066 : 
; 4067 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80305
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN16@BuildSyncD
$LN14@BuildSyncD:

; 4069 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET $SG80306
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN16@BuildSyncD:

; 4068 :             nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN15@BuildSyncD

; 4070 :       {
; 4071 :          zLONG  lDB_Lth;
; 4072 :          zLONG  lDTE_Lth;
; 4073 :          zCHAR  szDB_Type[ 10 ];
; 4074 :          zCHAR  szDTE_Type[ 10 ];
; 4075 :          zPCHAR pchColName;
; 4076 : 
; 4077 :          // Check to see if there is a field in the DB with the same
; 4078 :          // name.
; 4079 :          if ( SetCursorFirstEntityByAttr( vDB, "TE_FieldDataRel", "Name",
; 4080 :                                           vDTE, "TE_FieldDataRel",
; 4081 :                                           "Name", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET $SG80308
	push	OFFSET $SG80309
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET $SG80310
	push	OFFSET $SG80311
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorFirstEntityByAttr@28
	cwde
	test	eax, eax
	jge	SHORT $LN56@BuildSyncD

; 4082 :          {
; 4083 :             // Nope.  No match found, continue with the next one.
; 4084 :             continue;

	jmp	SHORT $LN14@BuildSyncD
$LN56@BuildSyncD:

; 4085 :          }
; 4086 : 
; 4087 :          GetAddrForAttribute( &pchColName, vDB, "TE_FieldDataRel", "Name" );

	push	OFFSET $SG80312
	push	OFFSET $SG80313
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchColName$1[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4088 :          GetIntegerFromAttribute( &lDB_Lth,  vDB, "TE_FieldDataRel", "Length" );

	push	OFFSET $SG80314
	push	OFFSET $SG80315
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lDB_Lth$7[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 4089 :          GetIntegerFromAttribute( &lDTE_Lth, vDTE, "TE_FieldDataRel", "Length" );

	push	OFFSET $SG80316
	push	OFFSET $SG80317
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _lDTE_Lth$8[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 4090 :          GetStringFromAttribute( szDB_Type,  vDB, "TE_FieldDataRel", "DataType" );

	push	OFFSET $SG80318
	push	OFFSET $SG80319
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDB_Type$17[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4091 :          GetStringFromAttribute( szDTE_Type, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET $SG80320
	push	OFFSET $SG80321
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDTE_Type$16[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4092 : 
; 4093 :          // Some datatypes need to be massaged before we compare them.
; 4094 :          #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 4095 :              defined( POSTGRESQL ) || defined( SQLSERVER )
; 4096 : 
; 4097 :             switch ( szDB_Type[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szDB_Type$17[ebp+eax]
	mov	BYTE PTR tv340[ebp], cl
	cmp	BYTE PTR tv340[ebp], 68			; 00000044H
	je	SHORT $LN57@BuildSyncD
	cmp	BYTE PTR tv340[ebp], 73			; 00000049H
	je	SHORT $LN57@BuildSyncD
	cmp	BYTE PTR tv340[ebp], 84			; 00000054H
	je	SHORT $LN57@BuildSyncD
	jmp	SHORT $LN17@BuildSyncD
$LN57@BuildSyncD:

; 4098 :             {
; 4099 :                case zTYPE_DATE:
; 4100 :                case zTYPE_TIME:
; 4101 :                case zTYPE_DATETIME:
; 4102 :                   // In access, all date/time/timestamps are stored as the same
; 4103 :                   // datatype, so we need to set things up so they compare the same.
; 4104 :                   szDB_Type[ 0 ] = szDTE_Type[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _szDTE_Type$16[ebp+eax]
	mov	BYTE PTR _szDB_Type$17[ebp+edx], al
$LN17@BuildSyncD:

; 4105 :                   break;
; 4106 :             }
; 4107 : 
; 4108 :             // We only care about the length for string types.
; 4109 :             if ( szDB_Type[ 0 ] != zTYPE_STRING || szDB_Type[ 0 ] != zTYPE_FIXEDCHAR )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szDB_Type$17[ebp+edx]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN59@BuildSyncD
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szDB_Type$17[ebp+edx]
	cmp	eax, 70					; 00000046H
	je	SHORT $LN58@BuildSyncD
$LN59@BuildSyncD:

; 4110 :                lDB_Lth = lDTE_Lth;

	mov	ecx, DWORD PTR _lDTE_Lth$8[ebp]
	mov	DWORD PTR _lDB_Lth$7[ebp], ecx
$LN58@BuildSyncD:

; 4111 : 
; 4112 :          #endif
; 4113 : 
; 4114 :          if ( lDB_Lth != lDTE_Lth || zstrcmp( szDB_Type, szDTE_Type ) != 0 )

	mov	edx, DWORD PTR _lDB_Lth$7[ebp]
	cmp	edx, DWORD PTR _lDTE_Lth$8[ebp]
	jne	SHORT $LN62@BuildSyncD
	movsx	eax, BYTE PTR _szDB_Type$17[ebp]
	movsx	ecx, BYTE PTR _szDTE_Type$16[ebp]
	cmp	eax, ecx
	jne	SHORT $LN102@BuildSyncD
	lea	edx, DWORD PTR _szDTE_Type$16[ebp]
	push	edx
	lea	eax, DWORD PTR _szDB_Type$17[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv370[ebp], eax
	jmp	SHORT $LN103@BuildSyncD
$LN102@BuildSyncD:
	movsx	ecx, BYTE PTR _szDB_Type$17[ebp]
	movsx	edx, BYTE PTR _szDTE_Type$16[ebp]
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN100@BuildSyncD
	mov	DWORD PTR tv369[ebp], 1
	jmp	SHORT $LN101@BuildSyncD
$LN100@BuildSyncD:
	mov	DWORD PTR tv369[ebp], -1
$LN101@BuildSyncD:
	mov	eax, DWORD PTR tv369[ebp]
	mov	DWORD PTR tv370[ebp], eax
$LN103@BuildSyncD:
	cmp	DWORD PTR tv370[ebp], 0
	je	SHORT $LN60@BuildSyncD
$LN62@BuildSyncD:

; 4115 :          {
; 4116 :             #if 0
; 4117 :                zCHAR sz[ 500 ];
; 4118 : 
; 4119 :                zsprintf( sz, "%s.%s  TE Datatype = %s, Length = %d",
; 4120 :                          pchTableName, pchColName, szDTE_Type, lDTE_Lth );
; 4121 :                TraceLineS( sz, "" );
; 4122 :                zsprintf( sz, "%s.%s  DB Datatype = %s, Length = %d",
; 4123 :                          pchTableName, pchColName, szDB_Type, lDB_Lth );
; 4124 :                TraceLineS( sz, "" );
; 4125 :             #endif
; 4126 : 
; 4127 :             // Column is different somehow.
; 4128 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "MatchFound", "D" );

	push	OFFSET $SG80328
	push	OFFSET $SG80329
	push	OFFSET $SG80330
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4129 :             SetAttributeFromString( vDB,  "TE_FieldDataRel", "MatchFound", "D" );

	push	OFFSET $SG80331
	push	OFFSET $SG80332
	push	OFFSET $SG80333
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4130 :          }

	jmp	SHORT $LN61@BuildSyncD
$LN60@BuildSyncD:

; 4131 :          else
; 4132 :          {
; 4133 :             SetAttributeFromString( vDTE, "TE_FieldDataRel", "MatchFound", "Y" );

	push	OFFSET $SG80334
	push	OFFSET $SG80335
	push	OFFSET $SG80336
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4134 :             SetAttributeFromString( vDB,  "TE_FieldDataRel", "MatchFound", "Y" );

	push	OFFSET $SG80337
	push	OFFSET $SG80338
	push	OFFSET $SG80339
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN61@BuildSyncD:

; 4135 :          }
; 4136 : 
; 4137 :       }  // For each TE_FieldDataRel

	jmp	$LN14@BuildSyncD
$LN15@BuildSyncD:

; 4138 : 
; 4139 :    }  // For each TE_TablRec

	jmp	$LN11@BuildSyncD
$LN12@BuildSyncD:

; 4140 : 
; 4141 :    //
; 4142 :    // Print results.
; 4143 :    //
; 4144 : 
; 4145 :    // Create tables.
; 4146 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80340
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN21@BuildSyncD
$LN19@BuildSyncD:

; 4148 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80341
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN21@BuildSyncD:

; 4147 :          nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN20@BuildSyncD

; 4149 :    {
; 4150 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG80342
	push	OFFSET $SG80343
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 4151 : 
; 4152 :       // If table is in the DB, we don't need to create it.
; 4153 :       if ( CompareAttributeToString( vDTE, "TE_TablRec", "MatchFound", "N" ) != 0 )

	push	OFFSET $SG80345
	push	OFFSET $SG80346
	push	OFFSET $SG80347
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN63@BuildSyncD

; 4154 :          continue;

	jmp	SHORT $LN19@BuildSyncD
$LN63@BuildSyncD:

; 4155 : 
; 4156 :       if ( fnBuildCreateTable( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildCreateTable@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN64@BuildSyncD

; 4157 :          goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN64@BuildSyncD:

; 4158 : 
; 4159 :       if ( fnBuildCreateMainIndex( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildCreateMainIndex@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN65@BuildSyncD

; 4160 :          goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN65@BuildSyncD:

; 4161 : 
; 4162 :       #if COMMIT_EVERY_TABLE
; 4163 :          if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4164 :             return( -1 );
; 4165 :       #endif
; 4166 : 
; 4167 :       // Create the indexes for the FKs.
; 4168 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80350
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN24@BuildSyncD
$LN22@BuildSyncD:

; 4170 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET $SG80351
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN24@BuildSyncD:

; 4169 :             nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN23@BuildSyncD

; 4171 :       {
; 4172 :          zPCHAR pchKeyType;
; 4173 : 
; 4174 :          GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",

	push	OFFSET $SG80352
	push	OFFSET $SG80353
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$6[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4175 :                               "DataOrRelfieldOrSet" );
; 4176 :          if ( pchKeyType[ 0 ] == 'R' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchKeyType$6[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 82					; 00000052H
	jne	SHORT $LN66@BuildSyncD

; 4177 :          {
; 4178 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildFK_Index@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN66@BuildSyncD

; 4179 :                goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN66@BuildSyncD:

; 4180 :             #if defined( COMMIT_EVERY_TABLE )
; 4181 : 
; 4182 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )
; 4183 :                   goto EndOfFunction;
; 4184 : 
; 4185 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4186 :                   goto EndOfFunction;
; 4187 : 
; 4188 :             #endif
; 4189 :          }
; 4190 : 
; 4191 :       }  // For each TE_FieldDataRel

	jmp	SHORT $LN22@BuildSyncD
$LN23@BuildSyncD:

; 4192 : 
; 4193 :    }  // For each TE_TablRec

	jmp	$LN19@BuildSyncD
$LN20@BuildSyncD:

; 4194 : 
; 4195 :    // Add columns to tables.
; 4196 :    for ( nRC = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80356
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN27@BuildSyncD
$LN25@BuildSyncD:

; 4198 :          nRC = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80357
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN27@BuildSyncD:

; 4197 :          nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN26@BuildSyncD

; 4199 :    {
; 4200 :       zBOOL bFirstAlterOfTable;
; 4201 : 
; 4202 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG80358
	push	OFFSET $SG80359
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4203 : 
; 4204 :       if ( CompareAttributeToString( vDTE, "TE_TablRec", "MatchFound", "N" ) == 0 )

	push	OFFSET $SG80361
	push	OFFSET $SG80362
	push	OFFSET $SG80363
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN68@BuildSyncD

; 4205 :       {
; 4206 :          // We alread created the table, so continue with the next one.
; 4207 :          continue;

	jmp	SHORT $LN25@BuildSyncD
$LN68@BuildSyncD:

; 4208 :       }
; 4209 : 
; 4210 :       bFirstAlterOfTable = TRUE;

	mov	BYTE PTR _bFirstAlterOfTable$9[ebp], 1

; 4211 :       for ( nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80364
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN30@BuildSyncD
$LN28@BuildSyncD:

; 4213 :             nRC = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET $SG80365
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN30@BuildSyncD:

; 4212 :             nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN29@BuildSyncD

; 4214 :       {
; 4215 :          zPCHAR pchMatchFound;
; 4216 : 
; 4217 :          GetAddrForAttribute( &pchMatchFound,

	push	OFFSET $SG80366
	push	OFFSET $SG80367
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchMatchFound$5[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4218 :                               vDTE, "TE_FieldDataRel", "MatchFound" );
; 4219 : 
; 4220 :          if ( pchMatchFound[ 0 ] == 'N' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchMatchFound$5[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	jne	$LN69@BuildSyncD

; 4221 :          {
; 4222 :             zPCHAR pchKeyType;
; 4223 : 
; 4224 :             // Add a blank line to seperate columns from different tables.
; 4225 :             if ( bFirstAlterOfTable )

	movzx	ecx, BYTE PTR _bFirstAlterOfTable$9[ebp]
	test	ecx, ecx
	je	$LN70@BuildSyncD

; 4226 :             {
; 4227 :                zCHAR szEntityName[ zZEIDON_NAME_LTH + 1 ];
; 4228 : 
; 4229 :                bFirstAlterOfTable = FALSE;

	mov	BYTE PTR _bFirstAlterOfTable$9[ebp], 0

; 4230 : 
; 4231 : 			   // KJS 10/16/14 - When I have selected "Keep Physical Characteristics..." for the datasource, and the
; 4232 : 			   // rebuild tables/rels and then "Build Sync DDL", I get to this point and have TE_TablRecs where there
; 4233 : 			   // is no ER_ENTITY. I am not sure why I don't seem to get that when "Keep ..." is not set.
; 4234 : 			   if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) == zCURSOR_SET )

	push	OFFSET $SG80371
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	cwde
	test	eax, eax
	jne	SHORT $LN70@BuildSyncD

; 4235 : 			   {
; 4236 :                GetStringFromAttribute( szEntityName, vDTE, "ER_Entity", "Name" );

	push	OFFSET $SG80372
	push	OFFSET $SG80373
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$13[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4237 : 
; 4238 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET $SG80375
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN72@BuildSyncD

; 4239 :                   goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN72@BuildSyncD:

; 4240 : 
; 4241 :                zsprintf( szLine, "%s Entity %s %s",

	push	OFFSET $SG80376
	lea	edx, DWORD PTR _szEntityName$13[ebp]
	push	edx
	push	OFFSET $SG80377
	push	OFFSET $SG80378
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 4242 :                          COMMENT_START, szEntityName, COMMENT_END );
; 4243 :                if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN70@BuildSyncD

; 4244 :                   goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN70@BuildSyncD:

; 4245 : 			   }
; 4246 :             }
; 4247 : 
; 4248 :             GetStringFromAttribute( szColumnName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET $SG80380
	push	OFFSET $SG80381
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4249 : 
; 4250 :             zsprintf( szLine, "ALTER TABLE %s " ADD_COLUMN_STMT " ", szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	OFFSET $SG80382
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4251 :             fnBuildColumn( vDTE, f, szLine );

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildColumn@12

; 4252 :             zstrcat( szLine, LINE_TERMINATOR );

	push	OFFSET $SG80383
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4253 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN74@BuildSyncD

; 4254 :                goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN74@BuildSyncD:

; 4255 : 
; 4256 :             // If the attribute is not a rel field try the next one.
; 4257 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",

	push	OFFSET $SG80385
	push	OFFSET $SG80386
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$4[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 4258 :                                  "DataOrRelfieldOrSet" );
; 4259 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchKeyType$4[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 82					; 00000052H
	je	SHORT $LN75@BuildSyncD

; 4260 :                continue;

	jmp	$LN28@BuildSyncD
$LN75@BuildSyncD:

; 4261 : 
; 4262 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildFK_Index@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN69@BuildSyncD

; 4263 :                goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN69@BuildSyncD:

; 4264 :          }
; 4265 : 
; 4266 :       }  // For each TE_FieldDataRel

	jmp	$LN28@BuildSyncD
$LN29@BuildSyncD:

; 4267 : 
; 4268 :       #if COMMIT_EVERY_TABLE
; 4269 :          // Commit the table if we altered it.
; 4270 :          if ( bFirstAlterOfTable == FALSE && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4271 :             return( -1 );
; 4272 :       #endif
; 4273 : 
; 4274 :    }  // For each TE_TablRec

	jmp	$LN25@BuildSyncD
$LN26@BuildSyncD:

; 4275 : 
; 4276 :    // Drop tables.
; 4277 :    bTableDropped = FALSE;

	mov	BYTE PTR _bTableDropped$[ebp], 0

; 4278 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80389
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN33@BuildSyncD
$LN31@BuildSyncD:

; 4280 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80390
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN33@BuildSyncD:

; 4279 :          nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN32@BuildSyncD

; 4281 :    {
; 4282 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET $SG80391
	push	OFFSET $SG80392
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4283 :       RemoveBrackets( szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 4284 : 
; 4285 :       if ( CompareAttributeToString( vDB, "TE_TablRec", "MatchFound", "Y" ) != 0 )

	push	OFFSET $SG80394
	push	OFFSET $SG80395
	push	OFFSET $SG80396
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN77@BuildSyncD

; 4286 :       {
; 4287 :          zsprintf( szLine, "DROP TABLE %s %s", szTableName,

	push	OFFSET $SG80397
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET $SG80398
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 4288 :                    LINE_TERMINATOR );
; 4289 : 
; 4290 :          if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN78@BuildSyncD

; 4291 :             goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN78@BuildSyncD:

; 4292 : 
; 4293 :          bTableDropped = TRUE;

	mov	BYTE PTR _bTableDropped$[ebp], 1
$LN77@BuildSyncD:

; 4294 :       }
; 4295 : 
; 4296 :    }  // For each TE_TablRec

	jmp	$LN31@BuildSyncD
$LN32@BuildSyncD:

; 4297 : 
; 4298 :    #if COMMIT_EVERY_TABLE
; 4299 :       if ( bTableDropped && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4300 :          return( -1 );
; 4301 :    #endif
; 4302 : 
; 4303 :    // Drop/alter columns from tables.
; 4304 :    for ( nRC = SetCursorFirstEntity( vDB, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80400
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN36@BuildSyncD
$LN34@BuildSyncD:

; 4306 :          nRC = SetCursorNextEntity( vDB, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80401
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN36@BuildSyncD:

; 4305 :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN35@BuildSyncD

; 4307 :    {
; 4308 :       zBOOL bFirstAlterForTable;
; 4309 : 
; 4310 :       GetStringFromAttribute( szTableName, vDB, "TE_TablRec", "Name" );

	push	OFFSET $SG80402
	push	OFFSET $SG80403
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4311 :       RemoveBrackets( szTableName );

	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 4312 : 
; 4313 :       if ( CompareAttributeToString( vDB, "TE_TablRec", "MatchFound", "Y" ) != 0 )

	push	OFFSET $SG80405
	push	OFFSET $SG80406
	push	OFFSET $SG80407
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN79@BuildSyncD

; 4314 :       {
; 4315 :          // Table deleted, go on to next one.
; 4316 :          continue;

	jmp	SHORT $LN34@BuildSyncD
$LN79@BuildSyncD:

; 4317 :       }
; 4318 : 
; 4319 :       // Set the cursor in the TE to match the one in the DB.
; 4320 :       SetCursorFirstEntityByAttr( vDTE, "TE_TablRec", "Name",

	push	0
	push	OFFSET $SG80408
	push	OFFSET $SG80409
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	push	OFFSET $SG80410
	push	OFFSET $SG80411
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28

; 4321 :                                   vDB,  "TE_TablRec", "Name", 0 );
; 4322 : 
; 4323 :       GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET $SG80412
	push	OFFSET $SG80413
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 4324 :       if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szOwner$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN80@BuildSyncD
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN80@BuildSyncD

; 4325 :          zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN80@BuildSyncD:

; 4326 : 
; 4327 :       if ( szOwner[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szOwner$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN81@BuildSyncD

; 4328 :          zstrcat( szOwner, "." );

	push	OFFSET $SG80416
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN81@BuildSyncD:

; 4329 : 
; 4330 :       bFirstAlterForTable = TRUE;

	mov	BYTE PTR _bFirstAlterForTable$10[ebp], 1

; 4331 :       for ( nRC = SetCursorFirstEntity( vDB, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80417
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN39@BuildSyncD
$LN37@BuildSyncD:

; 4333 :             nRC = SetCursorNextEntity( vDB, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET $SG80418
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN39@BuildSyncD:

; 4332 :             nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN38@BuildSyncD

; 4334 :       {
; 4335 :          zSHORT nIndexDroppedCount;
; 4336 : 
; 4337 :          // If a match was found for the column, we don't need to do anything.
; 4338 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 4339 :                                         "MatchFound", "Y" ) == 0 )

	push	OFFSET $SG80420
	push	OFFSET $SG80421
	push	OFFSET $SG80422
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN82@BuildSyncD

; 4340 :          {
; 4341 :             continue;

	jmp	SHORT $LN37@BuildSyncD
$LN82@BuildSyncD:

; 4342 :          }
; 4343 : 
; 4344 :          // Print out a comment if this is the first ALTER for the current
; 4345 :          // table.
; 4346 :          if ( bFirstAlterForTable )

	movzx	eax, BYTE PTR _bFirstAlterForTable$10[ebp]
	test	eax, eax
	je	$LN83@BuildSyncD

; 4347 :          {
; 4348 :             zCHAR szEntityName[ zZEIDON_NAME_LTH + 1 ];
; 4349 : 
; 4350 :             bFirstAlterForTable = FALSE;

	mov	BYTE PTR _bFirstAlterForTable$10[ebp], 0

; 4351 :             GetStringFromAttribute( szEntityName, vDTE, "ER_Entity", "Name" );

	push	OFFSET $SG80424
	push	OFFSET $SG80425
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$14[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4352 : 
; 4353 :             if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET $SG80427
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN84@BuildSyncD

; 4354 :                goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN84@BuildSyncD:

; 4355 : 
; 4356 :             zsprintf( szLine, "%s Entity %s %s",

	push	OFFSET $SG80428
	lea	edx, DWORD PTR _szEntityName$14[ebp]
	push	edx
	push	OFFSET $SG80429
	push	OFFSET $SG80430
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 4357 :                       COMMENT_START, szEntityName, COMMENT_END );
; 4358 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN83@BuildSyncD

; 4359 :                goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN83@BuildSyncD:

; 4360 :          }
; 4361 : 
; 4362 :          GetStringFromAttribute( szColumnName, vDB, "TE_FieldDataRel", "Name" );

	push	OFFSET $SG80432
	push	OFFSET $SG80433
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 4363 : 
; 4364 :          // Check to see if there is an index on the column.  If there is,
; 4365 :          // then we need to drop it.
; 4366 :          nIndexDroppedCount = 0;

	xor	eax, eax
	mov	WORD PTR _nIndexDroppedCount$11[ebp], ax

; 4367 :          for ( nRC = SetCursorFirstEntityByString( vDB, "TE_FieldDataRelKey",

	push	OFFSET $SG80434
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	push	OFFSET $SG80435
	push	OFFSET $SG80436
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN42@BuildSyncD
$LN40@BuildSyncD:

; 4371 :                nRC = SetCursorNextEntityByString( vDB, "TE_FieldDataRelKey",

	push	OFFSET $SG80437
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	push	OFFSET $SG80438
	push	OFFSET $SG80439
	mov	ecx, DWORD PTR _vDB$[ebp]
	push	ecx
	call	_SetCursorNextEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
$LN42@BuildSyncD:

; 4368 :                                                    "Name", szColumnName,
; 4369 :                                                    "TE_TablRec" );
; 4370 :                nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN41@BuildSyncD

; 4372 :                                                   "Name", szColumnName,
; 4373 :                                                   "TE_TablRec" ) )
; 4374 :          {
; 4375 :             zCHAR szIndex[ MAX_TABLENAME_LTH + 1 ];
; 4376 : 
; 4377 :             GetStringFromAttribute( szIndex, vDB, "TE_TablRecKey", "IndexName" );

	push	OFFSET $SG80440
	push	OFFSET $SG80441
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szIndex$15[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4378 :             fnBuildDropIndex( vDB, szIndex, szOwner, szTableName, f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szIndex$15[ebp]
	push	edx
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_fnBuildDropIndex@20

; 4379 :             nIndexDroppedCount++;

	mov	cx, WORD PTR _nIndexDroppedCount$11[ebp]
	add	cx, 1
	mov	WORD PTR _nIndexDroppedCount$11[ebp], cx

; 4380 :          }

	jmp	$LN40@BuildSyncD
$LN41@BuildSyncD:

; 4381 : 
; 4382 :          // Check to see if the column needs to be altered or dropped.
; 4383 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 4384 :                                         "MatchFound", "N" ) == 0 )

	push	OFFSET $SG80444
	push	OFFSET $SG80445
	push	OFFSET $SG80446
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN86@BuildSyncD

; 4385 :          {
; 4386 :             // Drop the column.
; 4387 :             zsprintf( szLine, "ALTER TABLE %s%s " DROP_COLUMN_STMT " %s %s",

	push	OFFSET $SG80447
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	push	OFFSET $SG80448
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H

; 4388 :                       szOwner, szTableName, szColumnName, LINE_TERMINATOR );
; 4389 : 
; 4390 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN88@BuildSyncD

; 4391 :                goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN88@BuildSyncD:

; 4392 :          }

	jmp	$LN87@BuildSyncD
$LN86@BuildSyncD:

; 4393 :          else
; 4394 :          if ( CompareAttributeToString( vDB, "TE_FieldDataRel",
; 4395 :                                         "MatchFound", "D" ) == 0 )

	push	OFFSET $SG80451
	push	OFFSET $SG80452
	push	OFFSET $SG80453
	mov	edx, DWORD PTR _vDB$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	$LN87@BuildSyncD

; 4396 :          {
; 4397 :             zPCHAR pchKeyType;
; 4398 : 
; 4399 :             // Alter the column to match the datatype in the TE.
; 4400 :             zsprintf( szLine, "ALTER TABLE %s%-*s ALTER COLUMN ",

	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	push	32					; 00000020H
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET $SG80454
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 4401 :                       szOwner, (int) MAX_TABLENAME_LTH, szTableName );
; 4402 : 
; 4403 :             fnBuildColumn( vDB, f, szLine );

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDB$[ebp]
	push	eax
	call	_fnBuildColumn@12

; 4404 :             zstrcat( szLine, LINE_TERMINATOR );

	push	OFFSET $SG80455
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4405 : 
; 4406 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN90@BuildSyncD

; 4407 :                goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN90@BuildSyncD:

; 4408 : 
; 4409 :             // Check to see if we need to re-create any indexes.
; 4410 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",

	push	OFFSET $SG80457
	push	OFFSET $SG80458
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchKeyType$3[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 4411 :                                  "DataOrRelfieldOrSet" );
; 4412 :             if ( pchKeyType[ 0 ] == 'R' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchKeyType$3[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 82					; 00000052H
	jne	SHORT $LN91@BuildSyncD

; 4413 :             {
; 4414 :                if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildFK_Index@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $LN92@BuildSyncD

; 4415 :                  goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN92@BuildSyncD:

; 4416 : 
; 4417 :                // We re-created one of the indexes dropped earlier so decrement
; 4418 :                // count so we'll know if we recreated all the indexes.
; 4419 :                nIndexDroppedCount--;

	mov	dx, WORD PTR _nIndexDroppedCount$11[ebp]
	sub	dx, 1
	mov	WORD PTR _nIndexDroppedCount$11[ebp], dx
$LN91@BuildSyncD:

; 4420 :             }
; 4421 : 
; 4422 :             // If no more indexes need to be recreated, go on to the next col.
; 4423 :             if ( nIndexDroppedCount == 0 )

	movsx	eax, WORD PTR _nIndexDroppedCount$11[ebp]
	test	eax, eax
	jne	SHORT $LN93@BuildSyncD

; 4424 :                continue;

	jmp	$LN37@BuildSyncD
$LN93@BuildSyncD:

; 4425 : 
; 4426 :             // Check to see if the column we altered is contained in the list of
; 4427 :             // identifiers for the table.  If it is we need to recreate
; 4428 :             // the indexes that were dropped above.
; 4429 :             for ( nRC = SetCursorFirstEntityByString( vDTE, "TE_FieldDataRelKey",

	push	OFFSET $SG80462
	lea	ecx, DWORD PTR _szColumnName$[ebp]
	push	ecx
	push	OFFSET $SG80463
	push	OFFSET $SG80464
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN45@BuildSyncD
$LN43@BuildSyncD:

; 4434 :                   nRC = SetCursorNextEntityByString( vDTE, "TE_FieldDataRelKey",

	push	OFFSET $SG80465
	lea	eax, DWORD PTR _szColumnName$[ebp]
	push	eax
	push	OFFSET $SG80466
	push	OFFSET $SG80467
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
$LN45@BuildSyncD:

; 4430 :                                                       "Name", szColumnName,
; 4431 :                                                       "TE_TablRec" );
; 4432 : 
; 4433 :                   nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN44@BuildSyncD

; 4435 :                                                      "Name", szColumnName,
; 4436 :                                                       "TE_TablRec" ) )
; 4437 :             {
; 4438 :                if ( fnBuildIndexFromTablRecKey( vDTE, FALSE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildIndexFromTablRecKey@12
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN94@BuildSyncD

; 4439 :                   goto EndOfFunction;

	jmp	$EndOfFunction$104
$LN94@BuildSyncD:

; 4440 : 
; 4441 :                // We re-created one of the indexes dropped earlier so decrement
; 4442 :                // count so we'll know if we recreated all the indexes.
; 4443 :                nIndexDroppedCount--;

	mov	ax, WORD PTR _nIndexDroppedCount$11[ebp]
	sub	ax, 1
	mov	WORD PTR _nIndexDroppedCount$11[ebp], ax

; 4444 :             }

	jmp	SHORT $LN43@BuildSyncD
$LN44@BuildSyncD:

; 4445 : 
; 4446 :             if ( nIndexDroppedCount )

	movsx	ecx, WORD PTR _nIndexDroppedCount$11[ebp]
	test	ecx, ecx
	je	$LN87@BuildSyncD

; 4447 :             {
; 4448 :                zCHAR szMsg[ 1000 ];
; 4449 : 
; 4450 :                // An index has been dropped for this column because it has been
; 4451 :                // modified but it is not a FK so we don't normally create an
; 4452 :                // index on it.  We'll display a warning and try to create an
; 4453 :                // index for the column.
; 4454 :                zsprintf( szMsg, "WARNING: The data type for the column %s.%s "

	lea	edx, DWORD PTR _szColumnName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	push	OFFSET $SG80470
	lea	ecx, DWORD PTR _szMsg$12[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4455 :                          "has been changed and therefore had an index deleted.  "
; 4456 :                          "The column is NOT a key and therefore the index was "
; 4457 :                          "added by the DBA.  An attempt has been made to "
; 4458 :                          "recreate the index in the DDL.  Look for 'WARNING' "
; 4459 :                          "in the DDL file",
; 4460 :                          szTableName, szColumnName );
; 4461 :                SysMessageBox( vDTE, "DDL Generationg Warning", szMsg, 0 );

	push	0
	lea	edx, DWORD PTR _szMsg$12[ebp]
	push	edx
	push	OFFSET $SG80471
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16

; 4462 : 
; 4463 :                zsprintf( szMsg, "%s WARNING--Following index may not have the "

	push	OFFSET $SG80472
	push	OFFSET $SG80473
	push	OFFSET $SG80474
	lea	ecx, DWORD PTR _szMsg$12[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4464 :                          " same the columns as the original index: %s",
; 4465 :                          COMMENT_START, COMMENT_END );
; 4466 :                if ( fnWriteLine( vDTE, f, szMsg ) < 0 )

	lea	edx, DWORD PTR _szMsg$12[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN96@BuildSyncD

; 4467 :                   goto EndOfFunction;

	jmp	SHORT $EndOfFunction$104
$LN96@BuildSyncD:

; 4468 : 
; 4469 :                if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildFK_Index@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $LN87@BuildSyncD

; 4470 :                  goto EndOfFunction;

	jmp	SHORT $EndOfFunction$104
$LN87@BuildSyncD:

; 4471 :             }
; 4472 :          }
; 4473 : 
; 4474 :       }  // For each TE_FieldDataRel

	jmp	$LN37@BuildSyncD
$LN38@BuildSyncD:

; 4475 : 
; 4476 :       #if COMMIT_EVERY_TABLE
; 4477 :          // Commit the table if we altered it.
; 4478 :          if ( bFirstAlterForTable == FALSE && fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 4479 :             return( -1 );
; 4480 :       #endif
; 4481 : 
; 4482 :    }  // For each TE_TablRec

	jmp	$LN34@BuildSyncD
$LN35@BuildSyncD:

; 4483 : 
; 4484 :    // If we get here, then everything's ok.
; 4485 :    nReturn = 0;

	xor	edx, edx
	mov	WORD PTR _nReturn$[ebp], dx
$EndOfFunction$104:

; 4486 : 
; 4487 : EndOfFunction:
; 4488 :    if ( f >= 0 )

	cmp	DWORD PTR _f$[ebp], 0
	jl	SHORT $LN98@BuildSyncD

; 4489 :       SysCloseFile( vSubtask, f, 0 );

	push	0
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysCloseFile@12
$LN98@BuildSyncD:

; 4490 : 
; 4491 :    // Drop the view copies.
; 4492 :    DropView( vDTE );

	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_DropView@4

; 4493 :    DropView( vEMD );

	mov	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	call	_DropView@4

; 4494 : 
; 4495 :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$LN1@BuildSyncD:

; 4496 : 
; 4497 : } // BuildSyncDDL

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_BuildSyncDDL@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_pchDatabaseName$ = -2984				; size = 4
_vTZDBHODO$ = -2980					; size = 4
_pchKeyType$1 = -2976					; size = 4
_pchKeyType$2 = -2972					; size = 4
_l$3 = -2968						; size = 4
_pchGenCreateIdxs$ = -2964				; size = 4
_pchGenCreateTables$ = -2960				; size = 4
_pchGenDropTables$ = -2956				; size = 4
_pchGenDropIdxs$ = -2952				; size = 4
_vTZTEDBLO$ = -2948					; size = 4
_nLth$ = -2944						; size = 4
_pchTableName$ = -2940					; size = 4
_pch$ = -2936						; size = 4
_pchDefaultOwner$ = -2932				; size = 4
_vDBH_Data$ = -2928					; size = 4
_usForeignKeyCntForTable$4 = -2924			; size = 2
_nMaxTableNameLth$ = -2920				; size = 2
_nRC$ = -2916						; size = 2
_f$ = -2912						; size = 4
_nRCTable$ = -2908					; size = 2
_nLoop$ = -2904						; size = 2
_szWorkIdxName$5 = -2900				; size = 513
_szWorkIdxName$6 = -2384				; size = 513
_szKeyName$7 = -1868					; size = 255
_szMsg$ = -1612						; size = 512
_szTableName$ = -1100					; size = 255
_szEntityName$ = -844					; size = 255
_szLine$ = -588						; size = 256
_szName$8 = -332					; size = 255
_szDBH_DataObjectName$ = -76				; size = 33
_szOwner$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_vEMD$ = 12						; size = 4
_pchFileName$ = 16					; size = 4
_vSubtask$ = 20						; size = 4
_BuildDDL@16 PROC

; 3420 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2984				; 00000ba8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3421 :    zPCHAR   pchTableName;
; 3422 :    zPCHAR   pchDatabaseName;
; 3423 :    zPCHAR   pch;
; 3424 :    zLONG    f = -1;

	mov	DWORD PTR _f$[ebp], -1

; 3425 :    zCHAR    szLine[ 256 ];
; 3426 :    zLONG    nLth;
; 3427 :    zSHORT   nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 3428 :    zSHORT   nRCTable;
; 3429 :    zSHORT   nLoop;
; 3430 :    zVIEW    vTZTEDBLO;
; 3431 :    zVIEW    vDBH_Data = 0;

	mov	DWORD PTR _vDBH_Data$[ebp], 0

; 3432 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 3433 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	ecx, 32					; 00000020H
	mov	WORD PTR _nMaxTableNameLth$[ebp], cx

; 3434 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 3435 :    zCHAR    szEntityName[ MAX_NAME_LTH + 1 ];
; 3436 :    zPCHAR   pchDefaultOwner;
; 3437 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3438 :    zPCHAR   pchGenCreateIdxs   = "Y";

	mov	DWORD PTR _pchGenCreateIdxs$[ebp], OFFSET $SG80007

; 3439 :    zPCHAR   pchGenDropIdxs     = "N";

	mov	DWORD PTR _pchGenDropIdxs$[ebp], OFFSET $SG80008

; 3440 :    zPCHAR   pchGenCreateTables = "Y";

	mov	DWORD PTR _pchGenCreateTables$[ebp], OFFSET $SG80009

; 3441 :    zPCHAR   pchGenDropTables   = "Y";

	mov	DWORD PTR _pchGenDropTables$[ebp], OFFSET $SG80010

; 3442 : 
; 3443 :    zCHAR    szMsg[ 512 ];
; 3444 : 
; 3445 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3446 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 3447 :    zVIEW    vTZDBHODO;
; 3448 : #endif
; 3449 : 
; 3450 :    // If TE_DBMS_Source entity doesn't exist, then nothing to generate.
; 3451 :    if ( CheckExistenceOfEntity( vDTE, "TE_DBMS_Source" ) != zCURSOR_SET )

	push	OFFSET $SG80012
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	cwde
	test	eax, eax
	je	SHORT $LN23@BuildDDL

; 3452 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@BuildDDL
$LN23@BuildDDL:

; 3453 : 
; 3454 :    // If it exists get the object that defines the dbhandler type.
; 3455 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vSubtask, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	OFFSET $SG80013
	lea	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_GetViewByName@16

; 3456 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $LN24@BuildDDL

; 3457 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",

	push	0
	push	OFFSET $SG80015
	push	OFFSET $SG80016
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG80017
	push	OFFSET $SG80018
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
$LN24@BuildDDL:

; 3458 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );
; 3459 : 
; 3460 :    // Try to get the OI that contains DBH-specific data.
; 3461 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,

	push	512					; 00000200H
	push	OFFSET $SG80019
	push	OFFSET $SG80020
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 3462 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 3463 : 
; 3464 : #if defined( SQLITE )
; 3465 : 
; 3466 :    pchGenCreateIdxs   = "N";   // Don't generate indexes for Sqlite.
; 3467 : 
; 3468 : #elif defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3469 :       defined( POSTGRESQL ) || defined( SQLSERVER )
; 3470 : 
; 3471 :    // Try to get the ODBC definition.
; 3472 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,

	push	512					; 00000200H
	push	OFFSET $SG80021
	push	OFFSET $SG80022
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 3473 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 3474 : 
; 3475 :    // Check to see if there is DBH data set in the TE.
; 3476 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	$LN25@BuildDDL

; 3477 :    {
; 3478 :       zLONG l;
; 3479 : 
; 3480 :       // Check to see if there is an max length override.
; 3481 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 3482 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET $SG80025
	push	OFFSET $SG80026
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$3[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $LN26@BuildDDL

; 3483 :       {
; 3484 :          nMaxTableNameLth = (zSHORT) l;

	mov	ax, WORD PTR _l$3[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], ax
$LN26@BuildDDL:

; 3485 :       }
; 3486 : 
; 3487 :       // Get the conditional generate values.
; 3488 :       GetAddrForAttribute( &pchGenCreateTables, vDBH_Data, "ODBC", "GenCreateTables" );

	push	OFFSET $SG80027
	push	OFFSET $SG80028
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchGenCreateTables$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3489 :       GetAddrForAttribute( &pchGenDropTables,   vDBH_Data, "ODBC", "DropTables" );

	push	OFFSET $SG80029
	push	OFFSET $SG80030
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchGenDropTables$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3490 :       GetAddrForAttribute( &pchGenCreateIdxs,   vDBH_Data, "ODBC", "GenCreateIdxs" );

	push	OFFSET $SG80031
	push	OFFSET $SG80032
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchGenCreateIdxs$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3491 :       GetAddrForAttribute( &pchGenDropIdxs,     vDBH_Data, "ODBC", "GenDropIdxs" );

	push	OFFSET $SG80033
	push	OFFSET $SG80034
	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchGenDropIdxs$[ebp]
	push	edx
	call	_GetAddrForAttribute@16
$LN25@BuildDDL:

; 3492 :    }
; 3493 : 
; 3494 : #endif
; 3495 : 
; 3496 :    // Create copies of views so we can safely change the cursors.
; 3497 :    CreateViewFromViewForTask( &vDTE, vDTE, 0 );

	push	0
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 3498 :    CreateViewFromViewForTask( &vEMD, vEMD, 0 );

	push	0
	mov	edx, DWORD PTR _vEMD$[ebp]
	push	edx
	lea	eax, DWORD PTR _vEMD$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 3499 : 
; 3500 :    //
; 3501 :    // Generate the DDL file name and open it.
; 3502 :    //
; 3503 :    nLth = zstrlen( pchFileName );

	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 3504 :    GetStringFromAttribute( pchFileName + nLth,

	push	OFFSET $SG80035
	push	OFFSET $SG80036
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchFileName$[ebp]
	add	eax, DWORD PTR _nLth$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3505 :                            vDTE, "TE_DBMS_Source", "Name" );
; 3506 : 
; 3507 :    // Make sure the filename isn't too long.
; 3508 :    if ( zstrlen( pchFileName + nLth ) > zBASE_FILENAME_LTH )

	mov	ecx, DWORD PTR _pchFileName$[ebp]
	add	ecx, DWORD PTR _nLth$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jbe	SHORT $LN27@BuildDDL

; 3509 :       pchFileName[ nLth + zBASE_FILENAME_LTH ] = 0;

	mov	edx, DWORD PTR _pchFileName$[ebp]
	add	edx, DWORD PTR _nLth$[ebp]
	mov	BYTE PTR [edx+128], 0
$LN27@BuildDDL:

; 3510 : 
; 3511 :    zstrcat( pchFileName, ".ddl" );

	push	OFFSET $SG80038
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3512 :    if ( (f = SysOpenFile( vDTE, pchFileName, COREFILE_WRITE )) < 0 )

	push	64					; 00000040H
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysOpenFile@12
	mov	DWORD PTR _f$[ebp], eax
	cmp	DWORD PTR _f$[ebp], 0
	jge	SHORT $LN28@BuildDDL

; 3513 :       goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN28@BuildDDL:

; 3514 : 
; 3515 :    GetAddrForAttribute( &pchDatabaseName, vDTE, "TE_DBMS_Source", "Name" );

	push	OFFSET $SG80040
	push	OFFSET $SG80041
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDatabaseName$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3516 : 
; 3517 : #ifdef CREATE_DB
; 3518 :    zsprintf( szLine, "%s CREATE DATABASE %s %s %s", COMMENT_START,
; 3519 :              pchDatabaseName, COMMENT_END, LINE_TERMINATOR );
; 3520 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3521 :       goto EndOfFunction;
; 3522 : #endif
; 3523 : 
; 3524 :    //
; 3525 :    // Tell SQL processor what database to use.
; 3526 :    //
; 3527 : 
; 3528 : #if defined( DB2 )
; 3529 : 
; 3530 :    zsprintf( szLine, "CONNECT TO %s %s", pchDatabaseName, LINE_TERMINATOR );
; 3531 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3532 :       goto EndOfFunction;
; 3533 : 
; 3534 : #elif defined( MYSQL) || defined( SQLSERVER )
; 3535 : 
; 3536 :    #ifdef SQLITE
; 3537 :        // Skip the "USE" statement for SQLITE.
; 3538 :    #else
; 3539 :        zsprintf( szLine, "USE %s %s", pchDatabaseName, LINE_TERMINATOR );
; 3540 :        if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3541 :          goto EndOfFunction;
; 3542 :    #endif
; 3543 : 
; 3544 : #elif defined( POSTGRESQL ) 
; 3545 : 
; 3546 :        zsprintf( szLine, "SET SCHEMA '%s' %s", pchDatabaseName, LINE_TERMINATOR );
; 3547 :        if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3548 :          goto EndOfFunction;
; 3549 : 
; 3550 : #endif
; 3551 : 
; 3552 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",

	push	OFFSET $SG80042
	push	OFFSET $SG80043
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3553 :                         "DefaultOwner" );
; 3554 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN30@BuildDDL
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN29@BuildDDL
$LN30@BuildDDL:

; 3555 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$LN29@BuildDDL:

; 3556 : 
; 3557 :    //=================================================================
; 3558 :    //
; 3559 :    // Generate Drop Index statements.
; 3560 :    //
; 3561 :    //=================================================================
; 3562 :    if ( pchGenDropIdxs[ 0 ] != 'N' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchGenDropIdxs$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	je	$LN31@BuildDDL

; 3563 :    {
; 3564 :       // Loop for each of the tables.
; 3565 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80047
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $LN4@BuildDDL
$LN2@BuildDDL:

; 3567 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80048
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$LN4@BuildDDL:

; 3566 :             nRCTable >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRCTable$[ebp]
	test	edx, edx
	jl	$LN31@BuildDDL

; 3568 :       {
; 3569 :          zUSHORT usForeignKeyCntForTable = 0;

	xor	eax, eax
	mov	WORD PTR _usForeignKeyCntForTable$4[ebp], ax

; 3570 : 
; 3571 :          GetStringFromAttribute (szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG80049
	push	OFFSET $SG80050
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3572 :          pchTableName = szTableName;

	lea	eax, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], eax

; 3573 :          RemoveBrackets( pchTableName );

	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3574 : 
; 3575 :          /* Position on the first column of the table */
; 3576 :          nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80051
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3577 :          if ( nLoop < zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jge	SHORT $LN32@BuildDDL

; 3578 :             continue;

	jmp	$LN2@BuildDDL
$LN32@BuildDDL:

; 3579 : 
; 3580 :          // Write comment.
; 3581 :          if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET $SG80054
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	jl	SHORT $LN33@BuildDDL

; 3582 :          {
; 3583 :             GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET $SG80055
	push	OFFSET $SG80056
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3584 :             zsprintf( szLine, "%s Indexes for Entity - %s %s",

	push	OFFSET $SG80057
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	OFFSET $SG80058
	push	OFFSET $SG80059
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3585 :                       COMMENT_START, pch, COMMENT_END );
; 3586 : 
; 3587 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN33@BuildDDL

; 3588 :                goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN33@BuildDDL:

; 3589 :          }
; 3590 : 
; 3591 :          // Determine owner.
; 3592 :          GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET $SG80061
	push	OFFSET $SG80062
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3593 :          if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szOwner$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN35@BuildDDL
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN35@BuildDDL

; 3594 :             zstrcpy( szOwner, pchDefaultOwner );

	mov	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN35@BuildDDL:

; 3595 : 
; 3596 :          if ( szOwner[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szOwner$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN36@BuildDDL

; 3597 :             zstrcat( szOwner, "." );

	push	OFFSET $SG80065
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN36@BuildDDL:

; 3598 : 
; 3599 :          //=================================================================
; 3600 :          //
; 3601 :          // Drop Unique Index.
; 3602 :          //
; 3603 :          //=================================================================
; 3604 : 
; 3605 :          // Loop through each of the keys for the current table.
; 3606 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRecKey", 0 );

	push	0
	push	OFFSET $SG80066
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $LN7@BuildDDL
$LN5@BuildDDL:

; 3608 :                nLoop = SetCursorNextEntity( vDTE, "TE_TablRecKey", 0 ) )

	push	0
	push	OFFSET $SG80067
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$LN7@BuildDDL:

; 3607 :                nLoop >= zCURSOR_SET;

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	$LN6@BuildDDL

; 3609 :          {
; 3610 :             zCHAR  szName[ MAX_NAME_LTH + 1 ];
; 3611 :             zCHAR  szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3612 : 
; 3613 :             // If an IndexName value exists in TE_TablRecKey, use it.  Otherwise
; 3614 :             // us the Name value.
; 3615 :             GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "IndexName");

	push	OFFSET $SG80068
	push	OFFSET $SG80069
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$8[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3616 :             if ( szName[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szName$8[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN37@BuildDDL

; 3617 :             {
; 3618 :                GetStringFromAttribute (szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG80072
	push	OFFSET $SG80073
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3619 :                RemoveBrackets( szEntityName );

	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3620 : 
; 3621 :                GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "Name" );

	push	OFFSET $SG80074
	push	OFFSET $SG80075
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szName$8[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3622 :                RemoveBrackets( szName );

	lea	ecx, DWORD PTR _szName$8[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3623 : 
; 3624 :                zsprintf( szWorkIdxName, "%s_%s", szEntityName, szName );

	lea	edx, DWORD PTR _szName$8[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	push	OFFSET $SG80076
	lea	ecx, DWORD PTR _szWorkIdxName$5[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3625 :             }

	jmp	SHORT $LN38@BuildDDL
$LN37@BuildDDL:

; 3626 :             else
; 3627 :             {
; 3628 :                RemoveBrackets( szName );

	lea	edx, DWORD PTR _szName$8[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3629 : 
; 3630 :                zsprintf( szWorkIdxName, "%s", szName );

	lea	eax, DWORD PTR _szName$8[ebp]
	push	eax
	push	OFFSET $SG80077
	lea	ecx, DWORD PTR _szWorkIdxName$5[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN38@BuildDDL:

; 3631 :             }
; 3632 : 
; 3633 :             // Make sure that the index name is a valid length.
; 3634 :             UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,

	push	1
	push	OFFSET $SG80078
	push	OFFSET $SG80079
	push	OFFSET $SG80080
	push	OFFSET $SG80081
	movzx	edx, WORD PTR _nMaxTableNameLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$5[ebp]
	push	ecx
	call	_UfCompressName@32

; 3635 :                             "", "B", "", "B_AEIOU", 1 );
; 3636 : 
; 3637 :             fnBuildDropIndex( vDTE, szWorkIdxName, szOwner, pchTableName, f );

	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$5[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_fnBuildDropIndex@20

; 3638 : 
; 3639 :          } // for ( "TE_TablRecKey"... )...

	jmp	$LN5@BuildDDL
$LN6@BuildDDL:

; 3640 : 
; 3641 :          //===============================================================
; 3642 :          //
; 3643 :          // Drop Index for ForeignKeys
; 3644 :          //
; 3645 :          //===============================================================
; 3646 : 
; 3647 :          // Loop through each of the keys for the current table.
; 3648 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80082
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $LN10@BuildDDL
$LN8@BuildDDL:

; 3650 :                nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET $SG80083
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$LN10@BuildDDL:

; 3649 :                nLoop >= zCURSOR_SET;

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jl	$LN9@BuildDDL

; 3651 : 
; 3652 :          {
; 3653 :             zCHAR  szKeyName[ MAX_NAME_LTH + 1 ];
; 3654 :             zPCHAR pchKeyType;
; 3655 :             zCHAR  szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3656 : 
; 3657 :             // If the attribute is not a rel field try the next one.
; 3658 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",

	push	OFFSET $SG80084
	push	OFFSET $SG80085
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchKeyType$2[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3659 :                                  "DataOrRelfieldOrSet" );
; 3660 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchKeyType$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 82					; 00000052H
	je	SHORT $LN39@BuildDDL

; 3661 :                continue;

	jmp	SHORT $LN8@BuildDDL
$LN39@BuildDDL:

; 3662 : 
; 3663 :             // generate a comment identifying the relationship
; 3664 :             GetAddrForAttribute( &pch, vDTE, "TE_FieldDataRel", "Desc" );

	push	OFFSET $SG80087
	push	OFFSET $SG80088
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3665 :             zsprintf( szLine, "%s Index for Relationship - '%s' %s",

	push	OFFSET $SG80089
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET $SG80090
	push	OFFSET $SG80091
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3666 :                       COMMENT_START, pch, COMMENT_END );
; 3667 : 
; 3668 :             if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN40@BuildDDL

; 3669 :                goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN40@BuildDDL:

; 3670 : 
; 3671 :             GetStringFromAttribute( szKeyName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET $SG80093
	push	OFFSET $SG80094
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szKeyName$7[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3672 :             RemoveBrackets( szKeyName );

	lea	ecx, DWORD PTR _szKeyName$7[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3673 :             zsprintf( szWorkIdxName, "%s_%s", pchTableName, szKeyName );

	lea	edx, DWORD PTR _szKeyName$7[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	push	OFFSET $SG80095
	lea	ecx, DWORD PTR _szWorkIdxName$6[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3674 : 
; 3675 :             // Make sure that the index name is a valid length.
; 3676 :             // MAX_TABLENAME_LTH - 2 because of numbering the indexname
; 3677 :             // in the last two chars.
; 3678 :             UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,

	push	1
	push	OFFSET $SG80096
	push	OFFSET $SG80097
	push	OFFSET $SG80098
	push	OFFSET $SG80099
	movzx	edx, WORD PTR _nMaxTableNameLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$6[ebp]
	push	ecx
	call	_UfCompressName@32

; 3679 :                             "", "B", "", "B_AEIOU", 1 );
; 3680 :             usForeignKeyCntForTable++;

	mov	dx, WORD PTR _usForeignKeyCntForTable$4[ebp]
	add	dx, 1
	mov	WORD PTR _usForeignKeyCntForTable$4[ebp], dx

; 3681 :             nLth = zstrlen( szWorkIdxName );

	lea	eax, DWORD PTR _szWorkIdxName$6[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 3682 :             zsprintf( &szWorkIdxName[ nLth ], "%02d", usForeignKeyCntForTable );

	movzx	ecx, WORD PTR _usForeignKeyCntForTable$4[ebp]
	push	ecx
	push	OFFSET $SG80100
	mov	edx, DWORD PTR _nLth$[ebp]
	lea	eax, DWORD PTR _szWorkIdxName$6[ebp+edx]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3683 : 
; 3684 :             fnBuildDropIndex( vDTE, szWorkIdxName, szOwner, pchTableName, f );

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTableName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildDropIndex@20

; 3685 : 
; 3686 :          } // for ( "TE_FieldDataRel" )...

	jmp	$LN8@BuildDDL
$LN9@BuildDDL:

; 3687 : 
; 3688 :          if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET $SG80102
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN41@BuildDDL

; 3689 :             goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN41@BuildDDL:

; 3690 : 
; 3691 :       } // for ( "TE_TableRec" )...

	jmp	$LN2@BuildDDL
$LN31@BuildDDL:

; 3692 : 
; 3693 :    } // if ( pchGenDropIdxs[ 0 ] != 'N' )...
; 3694 : 
; 3695 :    //=================================================================
; 3696 :    //
; 3697 :    // Generate Drop Table statements.
; 3698 :    //
; 3699 :    //=================================================================
; 3700 : 
; 3701 :    if ( pchGenDropTables[ 0 ] != 'N' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchGenDropTables$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	je	$LN42@BuildDDL

; 3702 :    {
; 3703 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80104
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $LN13@BuildDDL
$LN11@BuildDDL:

; 3705 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80105
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$LN13@BuildDDL:

; 3704 :             nRCTable >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRCTable$[ebp]
	test	edx, edx
	jl	$LN12@BuildDDL

; 3706 :       {
; 3707 :          /* Position on the first column of the table */
; 3708 :          /* If the table has no columns no DROP statement */
; 3709 :          nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80106
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3710 :          if (nRC < zCURSOR_SET)

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN43@BuildDDL

; 3711 :             continue;

	jmp	SHORT $LN11@BuildDDL
$LN43@BuildDDL:

; 3712 : 
; 3713 :          // Determine owner.
; 3714 :          GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET $SG80108
	push	OFFSET $SG80109
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3715 :          if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szOwner$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN44@BuildDDL
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN44@BuildDDL

; 3716 :             zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN44@BuildDDL:

; 3717 : 
; 3718 :          if ( szOwner[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szOwner$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN45@BuildDDL

; 3719 :             zstrcat( szOwner, "." );

	push	OFFSET $SG80112
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN45@BuildDDL:

; 3720 : 
; 3721 :          GetStringFromAttribute (szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG80113
	push	OFFSET $SG80114
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3722 :          pch = szEntityName;

	lea	eax, DWORD PTR _szEntityName$[ebp]
	mov	DWORD PTR _pch$[ebp], eax

; 3723 :          RemoveBrackets( pch );

	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3724 : 
; 3725 :          #if defined( SQLITE )
; 3726 :             zsprintf( szLine, "DROP TABLE IF EXISTS %s%s %s", szOwner, pch, LINE_TERMINATOR );
; 3727 :          #elif defined( MYSQL )
; 3728 :             zsprintf( szLine, "DROP TABLE IF EXISTS %s%s %s", szOwner, pch, LINE_TERMINATOR );
; 3729 :          #elif defined( POSTGRESQL )
; 3730 :             zsprintf( szLine, "DROP TABLE IF EXISTS %s%s CASCADE%s", szOwner, pch, LINE_TERMINATOR );
; 3731 :          #else
; 3732 :             zsprintf( szLine, "DROP TABLE %s%s %s", szOwner, pch, LINE_TERMINATOR );

	push	OFFSET $SG80115
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	push	OFFSET $SG80116
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3733 : 	 #endif
; 3734 : 
; 3735 :          if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN46@BuildDDL

; 3736 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN46@BuildDDL:

; 3737 :       }

	jmp	$LN11@BuildDDL
$LN12@BuildDDL:

; 3738 : 
; 3739 :    #if defined( COMMIT_EVERY_TABLE )
; 3740 : 
; 3741 :       if ( fnWriteLine( vDTE, f, "" ) < 0 )
; 3742 :          goto EndOfFunction;
; 3743 : 
; 3744 :       if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3745 :          goto EndOfFunction;
; 3746 : 
; 3747 :    #endif
; 3748 : 
; 3749 :       if ( fnWriteLine( vDTE, f, "" ) < 0 )

	push	OFFSET $SG80119
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN42@BuildDDL

; 3750 :          goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN42@BuildDDL:

; 3751 : 
; 3752 :    } // if ( pchGenDropTables[ 0 ] != 'N' )...
; 3753 : 
; 3754 :    //=================================================================
; 3755 :    //
; 3756 :    // Generate Create Table statements.
; 3757 :    //
; 3758 :    //=================================================================
; 3759 : 
; 3760 :    if ( pchGenCreateTables[ 0 ] != 'N' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchGenCreateTables$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 78					; 0000004eH
	je	SHORT $LN48@BuildDDL

; 3761 :    {
; 3762 :       // Loop for each of the tables.
; 3763 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80121
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $LN16@BuildDDL
$LN14@BuildDDL:

; 3765 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80122
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$LN16@BuildDDL:

; 3764 :             nRCTable >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRCTable$[ebp]
	test	edx, edx
	jl	SHORT $LN48@BuildDDL

; 3766 :       {
; 3767 :          if ( fnBuildCreateTable( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildCreateTable@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN49@BuildDDL

; 3768 :             goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN49@BuildDDL:

; 3769 :       } // for ( "TE_TableRec" )...

	jmp	SHORT $LN14@BuildDDL
$LN48@BuildDDL:

; 3770 : 
; 3771 :    } // if ( pchGenCreateTables[ 0 ] != 'N' )...
; 3772 : 
; 3773 :    //=================================================================
; 3774 :    //
; 3775 :    // Generate Create Index statements.
; 3776 :    //
; 3777 :    //=================================================================
; 3778 : 
; 3779 :    if ( pchGenCreateIdxs[ 0 ] != 'N' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchGenCreateIdxs$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 78					; 0000004eH
	je	$LN50@BuildDDL

; 3780 :    {
; 3781 :       // Loop for each of the tables.
; 3782 :       for ( nRCTable = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );

	push	0
	push	OFFSET $SG80125
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
	jmp	SHORT $LN19@BuildDDL
$LN17@BuildDDL:

; 3784 :             nRCTable = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )

	push	0
	push	OFFSET $SG80126
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRCTable$[ebp], ax
$LN19@BuildDDL:

; 3783 :             nRCTable >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRCTable$[ebp]
	test	eax, eax
	jl	$LN50@BuildDDL

; 3785 :       {
; 3786 :          GetStringFromAttribute (szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG80127
	push	OFFSET $SG80128
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3787 :          pchTableName = szTableName;

	lea	eax, DWORD PTR _szTableName$[ebp]
	mov	DWORD PTR _pchTableName$[ebp], eax

; 3788 :          RemoveBrackets( pchTableName );

	mov	ecx, DWORD PTR _pchTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3789 : 
; 3790 :          /* Position on the first column of the table */
; 3791 :          nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80129
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3792 :          if ( nLoop < zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jge	SHORT $LN51@BuildDDL

; 3793 :             continue;

	jmp	SHORT $LN17@BuildDDL
$LN51@BuildDDL:

; 3794 : 
; 3795 :          if ( fnBuildCreateMainIndex( vDTE, f ) == -1 )

	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildCreateMainIndex@8
	cwde
	cmp	eax, -1
	jne	SHORT $LN52@BuildDDL

; 3796 :             goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN52@BuildDDL:

; 3797 : 
; 3798 :          if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET $SG80133
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN53@BuildDDL

; 3799 :             goto EndOfFunction;

	jmp	$EndOfFunction$62
$LN53@BuildDDL:

; 3800 : 
; 3801 :          #if COMMIT_EVERY_TABLE
; 3802 :                if ( fnWriteLine( vDTE, f, " " ) < 0 )
; 3803 :                   goto EndOfFunction;
; 3804 : 
; 3805 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3806 :                   goto EndOfFunction;
; 3807 :          #endif
; 3808 : 
; 3809 :          //===============================================================
; 3810 :          //
; 3811 :          // Generate Index for ForeignKeys
; 3812 :          //
; 3813 :          //===============================================================
; 3814 : 
; 3815 :          // Loop through each of the keys for the current table.
; 3816 : 
; 3817 :          for ( nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG80134
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $LN22@BuildDDL
$LN20@BuildDDL:

; 3819 :                nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 ) )

	push	0
	push	OFFSET $SG80135
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$LN22@BuildDDL:

; 3818 :                nLoop >= zCURSOR_SET;

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	SHORT $LN21@BuildDDL

; 3820 : 
; 3821 :          {
; 3822 :             zPCHAR pchKeyType;
; 3823 : 
; 3824 :             // If the attribute is not a rel field try the next one.
; 3825 :             GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel",

	push	OFFSET $SG80136
	push	OFFSET $SG80137
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchKeyType$1[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3826 :                                  "DataOrRelfieldOrSet" );
; 3827 :             if ( pchKeyType[ 0 ] != 'R' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchKeyType$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 82					; 00000052H
	je	SHORT $LN54@BuildDDL

; 3828 :                continue;

	jmp	SHORT $LN20@BuildDDL
$LN54@BuildDDL:

; 3829 : 
; 3830 :             if ( fnBuildFK_Index( vDTE, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_fnBuildFK_Index@8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN55@BuildDDL

; 3831 :                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$62
$LN55@BuildDDL:

; 3832 : 
; 3833 :             #if defined( COMMIT_EVERY_TABLE )
; 3834 : 
; 3835 :                if ( fnWriteLine( vDTE, f, "" ) < 0 )
; 3836 :                   goto EndOfFunction;
; 3837 : 
; 3838 :                if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3839 :                   goto EndOfFunction;
; 3840 : 
; 3841 :             #endif
; 3842 : 
; 3843 :             if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET $SG80141
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN56@BuildDDL

; 3844 :                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$62
$LN56@BuildDDL:

; 3845 : 
; 3846 :          } // for ( "TE_FieldDataRel" )...

	jmp	$LN20@BuildDDL
$LN21@BuildDDL:

; 3847 : 
; 3848 :    #if COMMIT_EVERY_TABLE
; 3849 :          if ( fnWriteLine( vDTE, f, " " ) < 0 )
; 3850 :             goto EndOfFunction;
; 3851 : 
; 3852 :           if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3853 :             goto EndOfFunction;
; 3854 :    #endif
; 3855 : 
; 3856 :       } // for ( "TE_TableRec" )...

	jmp	$LN17@BuildDDL
$LN50@BuildDDL:

; 3857 : 
; 3858 :    } // if ( pchGenCreateIdxs[ 0 ] != 'N' )...
; 3859 : 
; 3860 :    //=================================================================
; 3861 :    //
; 3862 :    // Loop through the table names again to create the "GRANT ALL" statements.
; 3863 :    //
; 3864 :    //=================================================================
; 3865 : 
; 3866 : #ifdef GRANT_ALL
; 3867 :    for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRec", 0 );
; 3868 :          nLoop >= zCURSOR_SET;
; 3869 :          nLoop = SetCursorNextEntity( vDTE, "TE_TablRec", 0 ) )
; 3870 :    {
; 3871 :       /* Position on the first column of the table */
; 3872 :       /* No GRANT if the are no columns in the table */
; 3873 :       nRC = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );
; 3874 :       if (nRC < zCURSOR_SET)
; 3875 :          continue;
; 3876 : 
; 3877 :       // Determine owner.
; 3878 :       GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );
; 3879 :       if ( szOwner[ 0 ] == 0 && pchDefaultOwner )
; 3880 :          zstrcpy( szOwner, pchDefaultOwner );
; 3881 : 
; 3882 :       if ( szOwner[ 0 ] )
; 3883 :          zstrcat( szOwner, "." );
; 3884 : 
; 3885 :       GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 3886 :       pchTableName = szTableName;
; 3887 :       RemoveBrackets( pchTableName );
; 3888 :       zsprintf( szLine, "GRANT ALL ON %s%s TO PUBLIC %s",
; 3889 :                 szOwner, pchTableName, CONTINUATION_STR );
; 3890 : 
; 3891 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )
; 3892 :          goto EndOfFunction;
; 3893 : 
; 3894 :    } // for ( "TE_TableRec" )...
; 3895 : #endif
; 3896 : 
; 3897 :    if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )

	push	OFFSET $SG80143
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN57@BuildDDL

; 3898 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$62
$LN57@BuildDDL:

; 3899 : 
; 3900 :    // If we get here, then everything is OK.
; 3901 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$EndOfFunction$62:

; 3902 : 
; 3903 : EndOfFunction:
; 3904 :    if ( f != -1 )

	cmp	DWORD PTR _f$[ebp], -1
	je	SHORT $LN58@BuildDDL

; 3905 :       SysCloseFile( vSubtask, f, 0 );

	push	0
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysCloseFile@12
$LN58@BuildDDL:

; 3906 : 
; 3907 :    DropView( vDTE );

	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_DropView@4

; 3908 :    DropView( vEMD );

	mov	edx, DWORD PTR _vEMD$[ebp]
	push	edx
	call	_DropView@4

; 3909 : 
; 3910 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN59@BuildDDL

; 3911 :    {
; 3912 :       zstrcpy( szMsg, "File " );

	push	OFFSET $SG80147
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3913 :       zstrcat( szMsg, pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3914 :       zstrcat( szMsg, " is created successfully!" );

	push	OFFSET $SG80148
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3915 :      MB_SetMessage( vSubtask, 0, szMsg );

	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_MB_SetMessage@12

; 3916 :    }

	jmp	SHORT $LN60@BuildDDL
$LN59@BuildDDL:

; 3917 :    else
; 3918 :    {
; 3919 :        zstrcpy( szMsg, "Couldn't create file " );

	push	OFFSET $SG80149
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3920 :        zstrcat( szMsg, pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3921 :       SysMessageBox( vDTE, "Generate DDL", szMsg, 0 );

	push	0
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	push	OFFSET $SG80150
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysMessageBox@16
$LN60@BuildDDL:

; 3922 :    }
; 3923 : 
; 3924 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@BuildDDL:

; 3925 : 
; 3926 : } // BuildDDL

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_BuildDDL@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_pch$ = -624						; size = 4
_l$1 = -620						; size = 4
_pchEnd$ = -616						; size = 4
_vTZDBHODO$ = -612					; size = 4
_nMaxTableNameLth$ = -608				; size = 2
_vDBH_Data$ = -604					; size = 4
_vTZTEDBLO$ = -600					; size = 4
_pchDefaultOwner$ = -596				; size = 4
_nLoop$ = -592						; size = 2
_szTableName$ = -588					; size = 255
_szDBH_DataObjectName$ = -332				; size = 33
_szLine$ = -296						; size = 256
_szOwner$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_f$ = 12						; size = 4
_fnBuildCreateTable@8 PROC

; 3264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 624				; 00000270H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3265 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 3266 :    zPCHAR   pch;
; 3267 :    zPCHAR   pchEnd;
; 3268 :    zPCHAR   pchDefaultOwner;
; 3269 :    zCHAR    szLine[ 256 ];
; 3270 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3271 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 3272 :    zSHORT   nLoop;
; 3273 :    zVIEW    vDBH_Data;
; 3274 :    zVIEW    vTZTEDBLO = 0;

	mov	DWORD PTR _vTZTEDBLO$[ebp], 0

; 3275 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 3276 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _nMaxTableNameLth$[ebp], ax

; 3277 : 
; 3278 :    // If it exists get the object that defines the dbhandler type.
; 3279 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET $SG79891
	lea	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_GetViewByName@16

; 3280 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $LN4@fnBuildCre

; 3281 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",

	push	0
	push	OFFSET $SG79893
	push	OFFSET $SG79894
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG79895
	push	OFFSET $SG79896
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
$LN4@fnBuildCre:

; 3282 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );
; 3283 : 
; 3284 :    // Try to get the OI that contains DBH-specific data.
; 3285 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,

	push	512					; 00000200H
	push	OFFSET $SG79897
	push	OFFSET $SG79898
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 3286 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 3287 : 
; 3288 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3289 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 3290 : 
; 3291 :    // Try to get the ODBC definition.
; 3292 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,

	push	512					; 00000200H
	push	OFFSET $SG79899
	push	OFFSET $SG79900
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 3293 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 3294 : 
; 3295 :    // Check to see if there is DBH data set in the TE.
; 3296 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN5@fnBuildCre

; 3297 :    {
; 3298 :       zLONG l;
; 3299 : 
; 3300 :       // Check to see if there is an max length override.
; 3301 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 3302 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET $SG79903
	push	OFFSET $SG79904
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$1[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $LN5@fnBuildCre

; 3303 :       {
; 3304 :          nMaxTableNameLth = (zSHORT) l;

	mov	ax, WORD PTR _l$1[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], ax
$LN5@fnBuildCre:

; 3305 :       }
; 3306 :    }
; 3307 : 
; 3308 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $LN7@fnBuildCre

; 3309 :       DropView( vTZDBHODO );

	mov	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_DropView@4
$LN7@fnBuildCre:

; 3310 : 
; 3311 : #endif
; 3312 : 
; 3313 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN8@fnBuildCre

; 3314 :       DropView( vDBH_Data );

	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_DropView@4
$LN8@fnBuildCre:

; 3315 : 
; 3316 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",

	push	OFFSET $SG79907
	push	OFFSET $SG79908
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 3317 :                         "DefaultOwner" );
; 3318 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN10@fnBuildCre
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN9@fnBuildCre
$LN10@fnBuildCre:

; 3319 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$LN9@fnBuildCre:

; 3320 : 
; 3321 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG79911
	push	OFFSET $SG79912
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3322 :    RemoveBrackets( szTableName );

	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3323 : 
; 3324 :    /* Position on the first column of the table */
; 3325 :    nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG79913
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3326 :    if ( nLoop < zCURSOR_SET )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jge	SHORT $LN11@fnBuildCre

; 3327 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnBuildCre
$LN11@fnBuildCre:

; 3328 : 
; 3329 :    // Write the CREATE TABLE Statement and the comment only if
; 3330 :    // there are columns in a table.
; 3331 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET $SG79916
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	cwde
	test	eax, eax
	jl	SHORT $LN12@fnBuildCre

; 3332 :    {
; 3333 :       GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET $SG79917
	push	OFFSET $SG79918
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3334 :       zsprintf( szLine, "%s Entity - %s %s",

	push	OFFSET $SG79919
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET $SG79920
	push	OFFSET $SG79921
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3335 :                 COMMENT_START, pch, COMMENT_END );
; 3336 : 
; 3337 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN12@fnBuildCre

; 3338 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildCre
$LN12@fnBuildCre:

; 3339 :    }
; 3340 : 
; 3341 :    // Determine owner.
; 3342 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET $SG79923
	push	OFFSET $SG79924
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3343 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szOwner$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN14@fnBuildCre
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN14@fnBuildCre

; 3344 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	ecx, DWORD PTR _pchDefaultOwner$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN14@fnBuildCre:

; 3345 : 
; 3346 :    if ( szOwner[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szOwner$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN15@fnBuildCre

; 3347 :       zstrcat( szOwner, "." );

	push	OFFSET $SG79927
	lea	eax, DWORD PTR _szOwner$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN15@fnBuildCre:

; 3348 : 
; 3349 :    zsprintf( szLine, "CREATE TABLE %s%s ( %s",

	push	OFFSET $SG79928
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET $SG79929
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3350 :              szOwner, szTableName, CONTINUATION_STR );
; 3351 : 
; 3352 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN2@fnBuildCre

; 3353 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildCre
$LN2@fnBuildCre:

; 3354 : 
; 3355 :    //=================================================================
; 3356 :    //
; 3357 :    // Generate column definitions.
; 3358 :    //
; 3359 :    //=================================================================
; 3360 : 
; 3361 :    // Loop for each column in the table.
; 3362 :    while ( nLoop >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jl	$LN3@fnBuildCre

; 3363 :    {
; 3364 :       zsprintf( szLine, "%*s ", (zSHORT) COLUMN_INDENT, " " );

	push	OFFSET $SG79931
	push	10					; 0000000aH
	push	OFFSET $SG79932
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3365 :       fnBuildColumn( vDTE, f, szLine );

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildColumn@12

; 3366 : 
; 3367 :       pchEnd = &szLine[ zstrlen( szLine ) ];

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _szLine$[ebp+eax]
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 3368 : 
; 3369 :       nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRel", 0 );

	push	0
	push	OFFSET $SG79933
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3370 :       if ( nLoop >= zCURSOR_SET )

	movsx	eax, WORD PTR _nLoop$[ebp]
	test	eax, eax
	jl	SHORT $LN17@fnBuildCre

; 3371 :          // More columns comming, so add continuation stuff.
; 3372 :          zsprintf( pchEnd, ", %s", CONTINUATION_STR );

	push	OFFSET $SG79936
	push	OFFSET $SG79937
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@fnBuildCre
$LN17@fnBuildCre:

; 3373 :       else
; 3374 :          // No more columns, so terminate line.
; 3375 :          zsprintf( pchEnd, " ) %s", LINE_TERMINATOR );

	push	OFFSET $SG79938
	push	OFFSET $SG79939
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN18@fnBuildCre:

; 3376 : 
; 3377 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN19@fnBuildCre

; 3378 :          return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildCre
$LN19@fnBuildCre:

; 3379 : 
; 3380 :    } // while ( nLoop >= zCURSOR_SET )...

	jmp	$LN2@fnBuildCre
$LN3@fnBuildCre:

; 3381 : 
; 3382 :    // Write a blank line.
; 3383 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET $SG79942
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN20@fnBuildCre

; 3384 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildCre
$LN20@fnBuildCre:

; 3385 : 
; 3386 :    #if COMMIT_EVERY_TABLE
; 3387 :       if ( fnWriteLine( vDTE, f, COMMIT_STR ) < 0 )
; 3388 :          return( -1 );
; 3389 : 
; 3390 :       if ( fnWriteLine( vDTE, f, " " ) < 0 )
; 3391 :          return( -1 );
; 3392 :    #endif
; 3393 : 
; 3394 :    return( 0 );

	xor	eax, eax
$LN1@fnBuildCre:

; 3395 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildCreateTable@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_nLoop$ = -8						; size = 2
_bFirstIndex$ = -1					; size = 1
_vDTE$ = 8						; size = 4
_f$ = 12						; size = 4
_fnBuildCreateMainIndex@8 PROC

; 3237 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3238 :    zBOOL    bFirstIndex;
; 3239 :    zSHORT   nLoop;
; 3240 : 
; 3241 :    // Loop through each of the keys for the current table.
; 3242 :    bFirstIndex = TRUE;

	mov	BYTE PTR _bFirstIndex$[ebp], 1

; 3243 :    for ( nLoop = SetCursorFirstEntity( vDTE, "TE_TablRecKey", 0 );

	push	0
	push	OFFSET $SG79863
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
	jmp	SHORT $LN4@fnBuildCre
$LN2@fnBuildCre:

; 3245 :          nLoop = SetCursorNextEntity( vDTE, "TE_TablRecKey", 0 ) )

	push	0
	push	OFFSET $SG79864
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$LN4@fnBuildCre:

; 3244 :          nLoop >= zCURSOR_SET;

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	SHORT $LN3@fnBuildCre

; 3246 : 
; 3247 :    {
; 3248 :       if ( fnBuildIndexFromTablRecKey( vDTE, bFirstIndex, f ) == -1 )

	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bFirstIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_fnBuildIndexFromTablRecKey@12
	cwde
	cmp	eax, -1
	jne	SHORT $LN5@fnBuildCre

; 3249 :          return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildCre
$LN5@fnBuildCre:

; 3250 : 
; 3251 :       bFirstIndex = FALSE;

	mov	BYTE PTR _bFirstIndex$[ebp], 0

; 3252 : 
; 3253 :    } // for ( "TE_TablRecKey"... )...

	jmp	SHORT $LN2@fnBuildCre
$LN3@fnBuildCre:

; 3254 : 
; 3255 :    // Write a blank line.
; 3256 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET $SG79867
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN6@fnBuildCre

; 3257 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildCre
$LN6@fnBuildCre:

; 3258 : 
; 3259 :    return( 0 );

	xor	eax, eax
$LN1@fnBuildCre:

; 3260 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildCreateMainIndex@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_pch$1 = -1896						; size = 4
_l$2 = -1892						; size = 4
_lZKey$3 = -1888					; size = 4
_vTZDBHODO$ = -1884					; size = 4
_vTZTEDBLO$ = -1880					; size = 4
_vDBH_Data$ = -1876					; size = 4
_pchDefaultOwner$ = -1872				; size = 4
_nMaxTableNameLth$ = -1868				; size = 2
_nLoop$ = -1864						; size = 2
_szTableName$ = -1860					; size = 255
_szWorkIdxName$ = -1604					; size = 513
_szEntityName$4 = -1088					; size = 255
_szLine$ = -832						; size = 500
_szDBH_DataObjectName$ = -332				; size = 33
_szName$ = -296						; size = 255
_szOwner$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_bUnique$ = 12						; size = 1
_f$ = 16						; size = 4
_fnBuildIndexFromTablRecKey@12 PROC

; 3065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1896				; 00000768H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3066 :    zSHORT   nLoop;
; 3067 :    zCHAR    szLine[ 500 ];
; 3068 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 3069 :    zPCHAR   pchDefaultOwner;
; 3070 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 3071 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _nMaxTableNameLth$[ebp], ax

; 3072 :    zVIEW    vDBH_Data;
; 3073 :    zVIEW    vTZTEDBLO;
; 3074 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 3075 :    zCHAR    szTableName[ MAX_NAME_LTH + 1 ];
; 3076 :    zCHAR    szName[ MAX_NAME_LTH + 1 ];
; 3077 :    zCHAR    szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 3078 : 
; 3079 : 
; 3080 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",

	push	OFFSET $SG79775
	push	OFFSET $SG79776
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3081 :                         "DefaultOwner" );
; 3082 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN5@fnBuildInd
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN4@fnBuildInd
$LN5@fnBuildInd:

; 3083 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$LN4@fnBuildInd:

; 3084 : 
; 3085 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET $SG79779
	push	OFFSET $SG79780
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3086 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szOwner$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN6@fnBuildInd
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN6@fnBuildInd

; 3087 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN6@fnBuildInd:

; 3088 : 
; 3089 :    if ( szOwner[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szOwner$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN7@fnBuildInd

; 3090 :       zstrcat( szOwner, "." );

	push	OFFSET $SG79783
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN7@fnBuildInd:

; 3091 : 
; 3092 :    // If it exists get the object that defines the dbhandler type.
; 3093 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG79784
	lea	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 3094 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $LN8@fnBuildInd

; 3095 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",

	push	0
	push	OFFSET $SG79786
	push	OFFSET $SG79787
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET $SG79788
	push	OFFSET $SG79789
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
$LN8@fnBuildInd:

; 3096 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );
; 3097 : 
; 3098 :    // Try to get the OI that contains DBH-specific data.
; 3099 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,

	push	512					; 00000200H
	push	OFFSET $SG79790
	push	OFFSET $SG79791
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 3100 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 3101 : 
; 3102 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 3103 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 3104 : 
; 3105 :    // Try to get the ODBC definition.
; 3106 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,

	push	512					; 00000200H
	push	OFFSET $SG79792
	push	OFFSET $SG79793
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 3107 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 3108 : 
; 3109 :    // Check to see if there is DBH data set in the TE.
; 3110 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN9@fnBuildInd

; 3111 :    {
; 3112 :       zLONG l;
; 3113 : 
; 3114 :       // Check to see if there is an max length override.
; 3115 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 3116 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET $SG79796
	push	OFFSET $SG79797
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$2[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $LN9@fnBuildInd

; 3117 :       {
; 3118 :          nMaxTableNameLth = (zSHORT) l;

	mov	dx, WORD PTR _l$2[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], dx
$LN9@fnBuildInd:

; 3119 :       }
; 3120 :    }
; 3121 : 
; 3122 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $LN11@fnBuildInd

; 3123 :       DropView( vTZDBHODO );

	mov	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_DropView@4
$LN11@fnBuildInd:

; 3124 : #endif
; 3125 : 
; 3126 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN12@fnBuildInd

; 3127 :       DropView( vDBH_Data );

	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_DropView@4
$LN12@fnBuildInd:

; 3128 : 
; 3129 :    // Write comment.
; 3130 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )

	push	OFFSET $SG79801
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	cwde
	test	eax, eax
	jl	SHORT $LN13@fnBuildInd

; 3131 :    {
; 3132 :       zPCHAR pch;
; 3133 : 
; 3134 :       GetAddrForAttribute( &pch, vDTE, "ER_Entity", "Name" );

	push	OFFSET $SG79802
	push	OFFSET $SG79803
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$1[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 3135 :       zsprintf( szLine, "%s Main key for Entity - %s %s",

	push	OFFSET $SG79804
	mov	eax, DWORD PTR _pch$1[ebp]
	push	eax
	push	OFFSET $SG79805
	push	OFFSET $SG79806
	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3136 :                 COMMENT_START, pch, COMMENT_END );
; 3137 : 
; 3138 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN13@fnBuildInd

; 3139 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildInd
$LN13@fnBuildInd:

; 3140 :    }
; 3141 : 
; 3142 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG79808
	push	OFFSET $SG79809
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3143 :    RemoveBrackets( szTableName );

	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3144 : 
; 3145 :    // If an IndexName value exists in TE_TablRecKey, use it.  Otherwise
; 3146 :    // us the Name value.
; 3147 :    GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "IndexName" );

	push	OFFSET $SG79810
	push	OFFSET $SG79811
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3148 :    if ( szName[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szName$[ebp+edx]
	test	eax, eax
	jne	$LN15@fnBuildInd

; 3149 :    {
; 3150 :       zCHAR  szEntityName[ MAX_NAME_LTH + 1 ];
; 3151 :       zLONG  lZKey;
; 3152 : 
; 3153 :       GetStringFromAttribute( szEntityName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG79814
	push	OFFSET $SG79815
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$4[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3154 :       RemoveBrackets( szEntityName );

	lea	eax, DWORD PTR _szEntityName$4[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3155 : 
; 3156 :       GetStringFromAttribute( szName, vDTE, "TE_TablRecKey", "Name" );

	push	OFFSET $SG79816
	push	OFFSET $SG79817
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 3157 :       RemoveBrackets( szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3158 : 
; 3159 :       GetIntegerFromAttribute( &lZKey, vDTE, "TE_FieldDataRelKey", "ZKey" );

	push	OFFSET $SG79818
	push	OFFSET $SG79819
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lZKey$3[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 3160 : 
; 3161 :       // The base name for the index is a concatenation of the table and
; 3162 :       // key name.  To ensure that the index name is unique, we also use the
; 3163 :       // zkey value.
; 3164 :       // NOTE: Becaues of a bug in UfCompressName, we tack on a extra '0' to
; 3165 :       // the name so that the zkey does not get truncated.
; 3166 :       if ( bUnique )

	movzx	eax, BYTE PTR _bUnique$[ebp]
	test	eax, eax
	je	SHORT $LN17@fnBuildInd

; 3167 :          zsprintf( szWorkIdxName, "U%s_%s_%ld0", szEntityName, szName, lZKey );

	mov	ecx, DWORD PTR _lZKey$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szEntityName$4[ebp]
	push	eax
	push	OFFSET $SG79822
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN18@fnBuildInd
$LN17@fnBuildInd:

; 3168 :       else
; 3169 :          zsprintf( szWorkIdxName, "%s_%s_%ld0", szEntityName, szName, lZKey );

	mov	edx, DWORD PTR _lZKey$3[ebp]
	push	edx
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$4[ebp]
	push	ecx
	push	OFFSET $SG79823
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H
$LN18@fnBuildInd:

; 3170 :    }

	jmp	SHORT $LN16@fnBuildInd
$LN15@fnBuildInd:

; 3171 :    else
; 3172 :    {
; 3173 :       RemoveBrackets( szName );

	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_RemoveBrackets
	add	esp, 4

; 3174 :       zsprintf( szWorkIdxName, "%s", szName );

	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET $SG79824
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN16@fnBuildInd:

; 3175 :    }
; 3176 : 
; 3177 :    // Make sure that the index name is a valid length.
; 3178 :    UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,

	push	0
	push	OFFSET $SG79825
	push	OFFSET $SG79826
	push	OFFSET $SG79827
	push	OFFSET $SG79828
	movzx	eax, WORD PTR _nMaxTableNameLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	call	_UfCompressName@32

; 3179 :                    "", "B", "", "B_AEIOUYBCDFGHJKLMNPQRSTVWXZ", 0 );
; 3180 : 
; 3181 :    if ( bUnique )

	movzx	eax, BYTE PTR _bUnique$[ebp]
	test	eax, eax
	je	SHORT $LN19@fnBuildInd

; 3182 :    {
; 3183 :       zsprintf( szLine, "CREATE UNIQUE INDEX %s%s %s",

	push	OFFSET $SG79831
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET $SG79832
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3184 :                 szOwner, szWorkIdxName, CONTINUATION_STR );
; 3185 :    }

	jmp	SHORT $LN20@fnBuildInd
$LN19@fnBuildInd:

; 3186 :    else
; 3187 :       zsprintf( szLine, "CREATE INDEX %s%s %s",

	push	OFFSET $SG79833
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET $SG79834
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
$LN20@fnBuildInd:

; 3188 :                 szOwner, szWorkIdxName, CONTINUATION_STR );
; 3189 : 
; 3190 : 
; 3191 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN21@fnBuildInd

; 3192 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildInd
$LN21@fnBuildInd:

; 3193 : 
; 3194 :    zsprintf( szLine, "       ON %s%s ( %s",

	push	OFFSET $SG79836
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET $SG79837
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3195 :              szOwner, szTableName, CONTINUATION_STR );
; 3196 : 
; 3197 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN22@fnBuildInd

; 3198 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildInd
$LN22@fnBuildInd:

; 3199 : 
; 3200 :    //=================================================================
; 3201 :    //
; 3202 :    // Generate column names for index.
; 3203 :    //
; 3204 :    //=================================================================
; 3205 :    nLoop = SetCursorFirstEntity( vDTE, "TE_FieldDataRelKey", 0 );

	push	0
	push	OFFSET $SG79839
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nLoop$[ebp], ax
$LN2@fnBuildInd:

; 3206 :    while( nLoop >= zCURSOR_SET )

	movsx	edx, WORD PTR _nLoop$[ebp]
	test	edx, edx
	jl	$LN3@fnBuildInd

; 3207 :    {
; 3208 :       GetStringFromAttribute (szName, vDTE, "TE_FieldDataRelKey", "Name" );

	push	OFFSET $SG79840
	push	OFFSET $SG79841
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3209 :       RemoveBrackets( szName );

	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3210 : 
; 3211 :       nLoop = SetCursorNextEntity( vDTE, "TE_FieldDataRelKey", 0 );

	push	0
	push	OFFSET $SG79842
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nLoop$[ebp], ax

; 3212 :       if ( nLoop >= zCURSOR_SET  )

	movsx	ecx, WORD PTR _nLoop$[ebp]
	test	ecx, ecx
	jl	SHORT $LN23@fnBuildInd

; 3213 :       {
; 3214 :          // More keys coming, so print line with continuation stuff.
; 3215 :          zsprintf( szLine, "%*s %s, %s",

	push	OFFSET $SG79845
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	push	OFFSET $SG79846
	push	10					; 0000000aH
	push	OFFSET $SG79847
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H

; 3216 :                    (zSHORT) COLUMN_INDENT, " ",
; 3217 :                    szName, CONTINUATION_STR );
; 3218 :       }

	jmp	SHORT $LN24@fnBuildInd
$LN23@fnBuildInd:

; 3219 :       else
; 3220 :       {
; 3221 :          // No more keys, so end current command.
; 3222 :          zsprintf( szLine, "%*s %s ) %s",

	push	OFFSET $SG79848
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET $SG79849
	push	10					; 0000000aH
	push	OFFSET $SG79850
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H
$LN24@fnBuildInd:

; 3223 :                    (zSHORT) COLUMN_INDENT, " ",
; 3224 :                    szName, LINE_TERMINATOR );
; 3225 :       }
; 3226 : 
; 3227 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN25@fnBuildInd

; 3228 :          return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildInd
$LN25@fnBuildInd:

; 3229 : 
; 3230 :    } // while ( nLoop >= zCURSOR_SET )...

	jmp	$LN2@fnBuildInd
$LN3@fnBuildInd:

; 3231 : 
; 3232 :    return( 0 );

	xor	eax, eax
$LN1@fnBuildInd:

; 3233 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnBuildIndexFromTablRecKey@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_lZKey$ = -1416						; size = 4
_l$1 = -1412						; size = 4
_pch$ = -1408						; size = 4
_vTZDBHODO$ = -1404					; size = 4
_vTZTEDBLO$ = -1400					; size = 4
_vDBH_Data$ = -1396					; size = 4
_pchDefaultOwner$ = -1392				; size = 4
_nMaxTableNameLth$ = -1388				; size = 2
_szWorkIdxName$ = -1384					; size = 513
_szKeyName$ = -868					; size = 255
_szLine$ = -612						; size = 500
_szDBH_DataObjectName$ = -112				; size = 33
_szTableName$ = -76					; size = 33
_szOwner$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_f$ = 12						; size = 4
_fnBuildFK_Index@8 PROC

; 2945 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1416				; 00000588H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2946 :    zCHAR    szLine[ 500 ];
; 2947 :    zPCHAR   pch;
; 2948 :    zCHAR    szKeyName[ MAX_NAME_LTH + 1 ];
; 2949 :    zCHAR    szOwner[ MAX_TABLENAME_LTH + 1 ];
; 2950 :    zCHAR    szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2951 :    zPCHAR   pchDefaultOwner;
; 2952 :    zCHAR    szWorkIdxName[ BUFF_SIZE * 2 + 1 ];
; 2953 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2954 :    zUSHORT  nMaxTableNameLth = MAX_TABLENAME_LTH;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _nMaxTableNameLth$[ebp], ax

; 2955 :    zLONG    lZKey;
; 2956 :    zVIEW    vDBH_Data;
; 2957 :    zVIEW    vTZTEDBLO;
; 2958 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 2959 : 
; 2960 :    GetAddrForAttribute( &pchDefaultOwner, vDTE, "TE_DBMS_Source",

	push	OFFSET $SG79691
	push	OFFSET $SG79692
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchDefaultOwner$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 2961 :                         "DefaultOwner" );
; 2962 :    if ( pchDefaultOwner == 0 || pchDefaultOwner[ 0 ] == 0 )

	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN3@fnBuildFK_
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchDefaultOwner$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@fnBuildFK_
$LN3@fnBuildFK_:

; 2963 :       pchDefaultOwner = 0;

	mov	DWORD PTR _pchDefaultOwner$[ebp], 0
$LN2@fnBuildFK_:

; 2964 : 
; 2965 :    GetStringFromAttribute( szOwner, vDTE, "TE_TablRec", "SQL_TableOwner" );

	push	OFFSET $SG79695
	push	OFFSET $SG79696
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 2966 :    if ( szOwner[ 0 ] == 0 && pchDefaultOwner )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szOwner$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN4@fnBuildFK_
	cmp	DWORD PTR _pchDefaultOwner$[ebp], 0
	je	SHORT $LN4@fnBuildFK_

; 2967 :       zstrcpy( szOwner, pchDefaultOwner );

	mov	eax, DWORD PTR _pchDefaultOwner$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOwner$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN4@fnBuildFK_:

; 2968 : 
; 2969 :    if ( szOwner[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szOwner$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN5@fnBuildFK_

; 2970 :       zstrcat( szOwner, "." );

	push	OFFSET $SG79699
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN5@fnBuildFK_:

; 2971 : 
; 2972 :    // If it exists get the object that defines the dbhandler type.
; 2973 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG79700
	lea	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 2974 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $LN6@fnBuildFK_

; 2975 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",

	push	0
	push	OFFSET $SG79702
	push	OFFSET $SG79703
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	push	OFFSET $SG79704
	push	OFFSET $SG79705
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByAttr@28
$LN6@fnBuildFK_:

; 2976 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );
; 2977 : 
; 2978 :    // Try to get the OI that contains DBH-specific data.
; 2979 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,

	push	512					; 00000200H
	push	OFFSET $SG79706
	push	OFFSET $SG79707
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 2980 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 2981 : 
; 2982 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2983 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2984 : 
; 2985 :    // Try to get the ODBC definition.
; 2986 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,

	push	512					; 00000200H
	push	OFFSET $SG79708
	push	OFFSET $SG79709
	mov	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_SetOI_FromBlob@28

; 2987 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 2988 : 
; 2989 :    // Check to see if there is DBH data set in the TE.
; 2990 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN7@fnBuildFK_

; 2991 :    {
; 2992 :       zLONG l;
; 2993 : 
; 2994 :       // Check to see if there is an max length override.
; 2995 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 2996 :                                     "MaxTableNameLength" ) != -1 )

	push	OFFSET $SG79712
	push	OFFSET $SG79713
	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$1[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $LN7@fnBuildFK_

; 2997 :       {
; 2998 :          nMaxTableNameLth = (zSHORT) l;

	mov	dx, WORD PTR _l$1[ebp]
	mov	WORD PTR _nMaxTableNameLth$[ebp], dx
$LN7@fnBuildFK_:

; 2999 :       }
; 3000 :    }
; 3001 : 
; 3002 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $LN9@fnBuildFK_

; 3003 :       DropView( vTZDBHODO );

	mov	eax, DWORD PTR _vTZDBHODO$[ebp]
	push	eax
	call	_DropView@4
$LN9@fnBuildFK_:

; 3004 : #endif
; 3005 : 
; 3006 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN10@fnBuildFK_

; 3007 :       DropView( vDBH_Data );

	mov	ecx, DWORD PTR _vDBH_Data$[ebp]
	push	ecx
	call	_DropView@4
$LN10@fnBuildFK_:

; 3008 : 
; 3009 :    GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG79716
	push	OFFSET $SG79717
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 3010 :    RemoveBrackets( szTableName );

	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 3011 : 
; 3012 :    // Generate a comment identifying the relationship.
; 3013 :    GetAddrForAttribute( &pch, vDTE, "TE_FieldDataRel", "Desc" );

	push	OFFSET $SG79718
	push	OFFSET $SG79719
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 3014 :    if ( pch && pch[ 0 ] )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN11@fnBuildFK_
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN11@fnBuildFK_

; 3015 :    {
; 3016 :       zsprintf( szLine, "%s Index for Relationship - '%s' %s",

	push	OFFSET $SG79721
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	OFFSET $SG79722
	push	OFFSET $SG79723
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3017 :                 COMMENT_START, pch, COMMENT_END );
; 3018 : 
; 3019 :       if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN11@fnBuildFK_

; 3020 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildFK_
$LN11@fnBuildFK_:

; 3021 :    }
; 3022 : 
; 3023 :    GetIntegerFromAttribute( &lZKey, vDTE, "TE_FieldDataRel", "ZKey" );

	push	OFFSET $SG79725
	push	OFFSET $SG79726
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lZKey$[ebp]
	push	edx
	call	_GetIntegerFromAttribute@16

; 3024 :    GetStringFromAttribute( szKeyName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET $SG79727
	push	OFFSET $SG79728
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 3025 :    RemoveBrackets( szKeyName );

	lea	edx, DWORD PTR _szKeyName$[ebp]
	push	edx
	call	_RemoveBrackets
	add	esp, 4

; 3026 : 
; 3027 :    // The base name for the index is a concatenation of the table and
; 3028 :    // key name.  To ensure that the index name is unique, we also use the
; 3029 :    // zkey value.
; 3030 :    // NOTE: Becaues of a bug in UfCompressName, we tack on a extra '0' to the
; 3031 :    // name so that the zkey does not get truncated.
; 3032 :    zsprintf( szWorkIdxName, "%s_%s_%ld0", szTableName, szKeyName, lZKey );

	mov	eax, DWORD PTR _lZKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$[ebp]
	push	edx
	push	OFFSET $SG79729
	lea	eax, DWORD PTR _szWorkIdxName$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3033 : 
; 3034 :    // Make sure that the index name is a valid length.
; 3035 :    UfCompressName( szWorkIdxName, szWorkIdxName, nMaxTableNameLth,

	push	0
	push	OFFSET $SG79730
	push	OFFSET $SG79731
	push	OFFSET $SG79732
	push	OFFSET $SG79733
	movzx	ecx, WORD PTR _nMaxTableNameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkIdxName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkIdxName$[ebp]
	push	eax
	call	_UfCompressName@32

; 3036 :                    "", "B", "", "B_AEIOUYBCDFGHJKLMNPQRSTVWXZ", 0 );
; 3037 : 
; 3038 :    zsprintf( szLine, "CREATE INDEX %s%s %s",

	push	OFFSET $SG79734
	lea	ecx, DWORD PTR _szWorkIdxName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET $SG79735
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3039 :              szOwner, szWorkIdxName, CONTINUATION_STR );
; 3040 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN13@fnBuildFK_

; 3041 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildFK_
$LN13@fnBuildFK_:

; 3042 : 
; 3043 :    zsprintf( szLine, "       ON %s%s ( %s",

	push	OFFSET $SG79737
	lea	ecx, DWORD PTR _szTableName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOwner$[ebp]
	push	edx
	push	OFFSET $SG79738
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3044 :              szOwner, szTableName, CONTINUATION_STR );
; 3045 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN14@fnBuildFK_

; 3046 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildFK_
$LN14@fnBuildFK_:

; 3047 : 
; 3048 :    // Write Key-Name.
; 3049 :    zsprintf( szLine, "%*s %s ) %s",

	push	OFFSET $SG79740
	lea	ecx, DWORD PTR _szKeyName$[ebp]
	push	ecx
	push	OFFSET $SG79741
	push	10					; 0000000aH
	push	OFFSET $SG79742
	lea	edx, DWORD PTR _szLine$[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 3050 :              (zSHORT) COLUMN_INDENT, " ",
; 3051 :              szKeyName,
; 3052 :              LINE_TERMINATOR );
; 3053 :    if ( fnWriteLine( vDTE, f, szLine ) < 0 )

	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN15@fnBuildFK_

; 3054 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildFK_
$LN15@fnBuildFK_:

; 3055 : 
; 3056 :    // Write a blank line.
; 3057 :    if ( fnWriteLine( vDTE, f, " " ) < 0 )

	push	OFFSET $SG79745
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN16@fnBuildFK_

; 3058 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildFK_
$LN16@fnBuildFK_:

; 3059 : 
; 3060 :    return( 0 );

	xor	eax, eax
$LN1@fnBuildFK_:

; 3061 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnBuildFK_Index@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_nLth$ = -688						; size = 4
_l$1 = -684						; size = 4
tv197 = -680						; size = 4
tv147 = -676						; size = 4
tv130 = -672						; size = 4
_pchDataType$ = -668					; size = 4
tv176 = -664						; size = 4
_vTZTEDBLO$ = -660					; size = 4
_vDBH_Data$ = -656					; size = 4
_vTZDBHODO$ = -652					; size = 4
_nMaxColumnNameLth$ = -648				; size = 2
_pch$ = -644						; size = 4
_bTimestampAsString$ = -637				; size = 1
_pchEnd$ = -636						; size = 4
_szMsg$2 = -632						; size = 300
_szColName$ = -332					; size = 255
_szDBH_DataObjectName$ = -76				; size = 33
_szTableName$3 = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_vDTE$ = 8						; size = 4
_f$ = 12						; size = 4
_pchLine$ = 16						; size = 4
_fnBuildColumn@12 PROC

; 2349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 688				; 000002b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2350 :    zCHAR    szColName[ MAX_NAME_LTH + 1 ];
; 2351 :    zPCHAR   pchDataType;
; 2352 :    zPCHAR   pchKeyType;
; 2353 :    zPCHAR   pchEnd, pch;
; 2354 :    zLONG    nLth;
; 2355 :    zUSHORT  nMaxColumnNameLth = MAX_COLUMNNAME_LTH;

	mov	eax, 32					; 00000020H
	mov	WORD PTR _nMaxColumnNameLth$[ebp], ax

; 2356 :    zCHAR    szDBH_DataObjectName[ zZEIDON_NAME_LTH + 1 ];
; 2357 :    zVIEW    vDBH_Data;
; 2358 :    zVIEW    vTZTEDBLO = 0;

	mov	DWORD PTR _vTZTEDBLO$[ebp], 0

; 2359 :    zVIEW    vTZDBHODO = 0;

	mov	DWORD PTR _vTZDBHODO$[ebp], 0

; 2360 :    zBOOL    bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0

; 2361 : 
; 2362 :    // If it exists get the object that defines the dbhandler type.
; 2363 :    GetViewByName( &vTZTEDBLO, "TZTEDBLO", vDTE, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	OFFSET $SG79603
	lea	edx, DWORD PTR _vTZTEDBLO$[ebp]
	push	edx
	call	_GetViewByName@16

; 2364 :    if ( vTZTEDBLO )

	cmp	DWORD PTR _vTZTEDBLO$[ebp], 0
	je	SHORT $LN9@fnBuildCol

; 2365 :       SetCursorFirstEntityByAttr( vTZTEDBLO, "TE_DBMS_Source", "DBMS",

	push	0
	push	OFFSET $SG79605
	push	OFFSET $SG79606
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	push	OFFSET $SG79607
	push	OFFSET $SG79608
	mov	ecx, DWORD PTR _vTZTEDBLO$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
$LN9@fnBuildCol:

; 2366 :                                   vDTE,      "TE_DBMS_Source", "DBMS", 0 );
; 2367 : 
; 2368 :    // Try to get the OI that contains DBH-specific data.
; 2369 :    SetOI_FromBlob( &vDBH_Data, szDBH_DataObjectName, vDTE, vDTE,

	push	512					; 00000200H
	push	OFFSET $SG79609
	push	OFFSET $SG79610
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szDBH_DataObjectName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 2370 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 2371 : 
; 2372 : #if defined( ACCESS ) || defined( MYSQL ) || defined( ODBC ) || \
; 2373 :     defined( POSTGRESQL ) || defined( SQLSERVER )
; 2374 : 
; 2375 :    // Try to get the ODBC definition.
; 2376 :    SetOI_FromBlob( &vTZDBHODO, 0, vDTE, vTZTEDBLO,

	push	512					; 00000200H
	push	OFFSET $SG79611
	push	OFFSET $SG79612
	mov	eax, DWORD PTR _vTZTEDBLO$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _vTZDBHODO$[ebp]
	push	edx
	call	_SetOI_FromBlob@28

; 2377 :                    "TE_DBMS_Source", "DBH_Data", zNOI_OKAY );
; 2378 : 
; 2379 :    // Check to see if there is DBH data set in the TE.
; 2380 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN10@fnBuildCol

; 2381 :    {
; 2382 :       zLONG l;
; 2383 : 
; 2384 :       bTimestampAsString = ( CompareAttributeToString( vDBH_Data, "ODBC",

	push	OFFSET $SG79615
	push	OFFSET $SG79616
	push	OFFSET $SG79617
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN33@fnBuildCol
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN34@fnBuildCol
$LN33@fnBuildCol:
	mov	DWORD PTR tv130[ebp], 0
$LN34@fnBuildCol:
	mov	dl, BYTE PTR tv130[ebp]
	mov	BYTE PTR _bTimestampAsString$[ebp], dl

; 2385 :                                                        "TimestampAsString",
; 2386 :                                                        "Y" ) == 0 );
; 2387 : 
; 2388 :       if ( GetIntegerFromAttribute( &l, vDBH_Data, "ODBC",
; 2389 :                                     "MaxColumnNameLength" ) != -1 )

	push	OFFSET $SG79619
	push	OFFSET $SG79620
	mov	eax, DWORD PTR _vDBH_Data$[ebp]
	push	eax
	lea	ecx, DWORD PTR _l$1[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
	movsx	edx, ax
	cmp	edx, -1
	je	SHORT $LN12@fnBuildCol

; 2390 :       {
; 2391 :          nMaxColumnNameLth = (zSHORT) l;

	mov	ax, WORD PTR _l$1[ebp]
	mov	WORD PTR _nMaxColumnNameLth$[ebp], ax
$LN12@fnBuildCol:

; 2392 :       }
; 2393 :    }

	jmp	SHORT $LN11@fnBuildCol
$LN10@fnBuildCol:

; 2394 :    else
; 2395 :    // Check to see if there is DBH data set in the DB List object.
; 2396 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $LN13@fnBuildCol

; 2397 :    {
; 2398 :       bTimestampAsString = ( CompareAttributeToString( vTZDBHODO, "ODBC",

	push	OFFSET $SG79623
	push	OFFSET $SG79624
	push	OFFSET $SG79625
	mov	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN35@fnBuildCol
	mov	DWORD PTR tv147[ebp], 1
	jmp	SHORT $LN36@fnBuildCol
$LN35@fnBuildCol:
	mov	DWORD PTR tv147[ebp], 0
$LN36@fnBuildCol:
	mov	al, BYTE PTR tv147[ebp]
	mov	BYTE PTR _bTimestampAsString$[ebp], al

; 2399 :                                                        "TimestampAsString",
; 2400 :                                                        "Y" ) == 0 );
; 2401 :    }

	jmp	SHORT $LN11@fnBuildCol
$LN13@fnBuildCol:

; 2402 :    else
; 2403 :    {
; 2404 :       // If we get here then no info was set for this DBH so use defaults.
; 2405 :       bTimestampAsString = FALSE;

	mov	BYTE PTR _bTimestampAsString$[ebp], 0
$LN11@fnBuildCol:

; 2406 :    }
; 2407 : 
; 2408 :    if ( vTZDBHODO )

	cmp	DWORD PTR _vTZDBHODO$[ebp], 0
	je	SHORT $LN15@fnBuildCol

; 2409 :       DropView( vTZDBHODO );

	mov	ecx, DWORD PTR _vTZDBHODO$[ebp]
	push	ecx
	call	_DropView@4
$LN15@fnBuildCol:

; 2410 : 
; 2411 : #endif
; 2412 : 
; 2413 :    if ( vDBH_Data )

	cmp	DWORD PTR _vDBH_Data$[ebp], 0
	je	SHORT $LN16@fnBuildCol

; 2414 :       DropView( vDBH_Data );

	mov	edx, DWORD PTR _vDBH_Data$[ebp]
	push	edx
	call	_DropView@4
$LN16@fnBuildCol:

; 2415 : 
; 2416 :    GetStringFromAttribute( szColName, vDTE, "TE_FieldDataRel", "Name" );

	push	OFFSET $SG79628
	push	OFFSET $SG79629
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szColName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 2417 :    GetAddrForAttribute( &pchDataType, vDTE, "TE_FieldDataRel", "DataType" );

	push	OFFSET $SG79630
	push	OFFSET $SG79631
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDataType$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 2418 :    RemoveBrackets( szColName );

	lea	ecx, DWORD PTR _szColName$[ebp]
	push	ecx
	call	_RemoveBrackets
	add	esp, 4

; 2419 : 
; 2420 :    pchEnd = pchLine + zstrlen( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 2421 :    zsprintf( pchEnd, "%-*s", nMaxColumnNameLth, szColName );

	lea	eax, DWORD PTR _szColName$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nMaxColumnNameLth$[ebp]
	push	ecx
	push	OFFSET $SG79632
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2422 :    pchEnd = pchEnd + zstrlen( pchEnd );

	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchEnd$[ebp]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 2423 : 
; 2424 : #if defined( ACCESS )
; 2425 : 
; 2426 :    switch ( pchDataType[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchDataType$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR tv176[ebp], ecx
	mov	edx, DWORD PTR tv176[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv176[ebp], edx
	cmp	DWORD PTR tv176[ebp], 22		; 00000016H
	ja	$LN29@fnBuildCol
	mov	eax, DWORD PTR tv176[ebp]
	movzx	ecx, BYTE PTR $LN37@fnBuildCol[eax]
	jmp	DWORD PTR $LN38@fnBuildCol[ecx*4]
$LN17@fnBuildCol:

; 2427 :    {
; 2428 :       case zTYPE_STRING:
; 2429 :       case zTYPE_FIXEDCHAR:
; 2430 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",

	push	OFFSET $SG79634
	push	OFFSET $SG79635
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _nLth$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 2431 :                                   "Length" );
; 2432 :          zsprintf( pchEnd, " TEXT( %ld )", nLth );

	mov	ecx, DWORD PTR _nLth$[ebp]
	push	ecx
	push	OFFSET $SG79636
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2433 : 
; 2434 :          break;

	jmp	$LN2@fnBuildCol
$LN18@fnBuildCol:

; 2435 : 
; 2436 :       case zTYPE_BLOB:
; 2437 :          zsprintf( pchEnd, " LONGBINARY" );

	push	OFFSET $SG79638
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 2438 :          break;

	jmp	$LN2@fnBuildCol
$LN19@fnBuildCol:

; 2439 : 
; 2440 :       case zTYPE_INTEGER:
; 2441 :          zsprintf( pchEnd, " INTEGER" );

	push	OFFSET $SG79640
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 2442 :          break;

	jmp	$LN2@fnBuildCol
$LN20@fnBuildCol:

; 2443 : 
; 2444 :       case zTYPE_DECIMAL:
; 2445 :          zsprintf( pchEnd, " DOUBLE" );

	push	OFFSET $SG79642
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 2446 :          break;

	jmp	$LN2@fnBuildCol
$LN21@fnBuildCol:

; 2447 : 
; 2448 :       case zTYPE_DATETIME:
; 2449 :       case zTYPE_TIME:
; 2450 :          if ( bTimestampAsString )

	movzx	eax, BYTE PTR _bTimestampAsString$[ebp]
	test	eax, eax
	je	SHORT $LN22@fnBuildCol

; 2451 :             zsprintf( pchEnd, " TEXT( 25 )" );

	push	OFFSET $SG79646
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
	jmp	SHORT $LN23@fnBuildCol
$LN22@fnBuildCol:

; 2452 :          else
; 2453 :          {
; 2454 :             switch ( pchDataType[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchDataType$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR tv197[ebp], dl
	cmp	BYTE PTR tv197[ebp], 73			; 00000049H
	je	SHORT $LN25@fnBuildCol
	cmp	BYTE PTR tv197[ebp], 84			; 00000054H
	je	SHORT $LN24@fnBuildCol
	jmp	SHORT $LN23@fnBuildCol
$LN24@fnBuildCol:

; 2455 :             {
; 2456 :                case zTYPE_DATETIME:
; 2457 :                   zsprintf( pchEnd, " DATETIME" );

	push	OFFSET $SG79648
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 2458 :                   break;

	jmp	SHORT $LN23@fnBuildCol
$LN25@fnBuildCol:

; 2459 : 
; 2460 :                case zTYPE_TIME:
; 2461 :                   zsprintf( pchEnd, " TIME" );

	push	OFFSET $SG79650
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8
$LN23@fnBuildCol:

; 2462 :                   break;
; 2463 :             }
; 2464 :          }
; 2465 : 
; 2466 :          break;

	jmp	$LN2@fnBuildCol
$LN26@fnBuildCol:

; 2467 : 
; 2468 :       case zTYPE_DATE:
; 2469 :          zsprintf( pchEnd, " DATE" );

	push	OFFSET $SG79652
	mov	edx, DWORD PTR _pchEnd$[ebp]
	push	edx
	call	_sprintf
	add	esp, 8

; 2470 :          break;

	jmp	$LN2@fnBuildCol
$LN27@fnBuildCol:

; 2471 : 
; 2472 :       // ===
; 2473 :       // === Non-standard types follow here.
; 2474 :       // ===
; 2475 : 
; 2476 :       // Long text fields.
; 2477 :       case 'V':
; 2478 :          zsprintf( pchEnd, " MEMO" );

	push	OFFSET $SG79654
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_sprintf
	add	esp, 8

; 2479 :          break;

	jmp	SHORT $LN2@fnBuildCol
$LN28@fnBuildCol:

; 2480 : 
; 2481 :       // TimeStampEx
; 2482 :       case 'X':
; 2483 :          zsprintf( pchEnd, " TEXT( 30 )" );

	push	OFFSET $SG79656
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 8

; 2484 :          break;

	jmp	SHORT $LN2@fnBuildCol
$LN29@fnBuildCol:

; 2485 : 
; 2486 :       default:
; 2487 :       {
; 2488 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2489 :          zCHAR szMsg[ 300 ];
; 2490 : 
; 2491 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );

	push	OFFSET $SG79658
	push	OFFSET $SG79659
	mov	edx, DWORD PTR _vDTE$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTableName$3[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 2492 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",

	lea	ecx, DWORD PTR _szColName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTableName$3[ebp]
	push	edx
	mov	eax, DWORD PTR _pchDataType$[ebp]
	push	eax
	push	OFFSET $SG79660
	lea	ecx, DWORD PTR _szMsg$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 2493 :                    pchDataType, szTableName, szColName );
; 2494 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	push	OFFSET $SG79661
	mov	eax, DWORD PTR _vDTE$[ebp]
	push	eax
	call	_SysMessageBox@16

; 2495 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnBuildCol
$LN2@fnBuildCol:

; 2496 :       }
; 2497 : 
; 2498 :    } // switch ( pchDataType[ 0 ] )...
; 2499 : 
; 2500 : #elif defined( DB2 )
; 2501 : 
; 2502 :    switch ( pchDataType[ 0 ] )
; 2503 :    {
; 2504 :       case zTYPE_STRING:
; 2505 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2506 :                                   "Length" );
; 2507 :          zsprintf( pchEnd, " VARCHAR( %ld )", nLth );
; 2508 : 
; 2509 :          break;
; 2510 : 
; 2511 :       case zTYPE_FIXEDCHAR:
; 2512 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2513 :                                   "Length" );
; 2514 :          zsprintf( pchEnd, " CHAR( %ld )", nLth );
; 2515 : 
; 2516 :          break;
; 2517 : 
; 2518 :       case zTYPE_BLOB:
; 2519 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2520 :                                   "Length" );
; 2521 :          zsprintf( pchEnd, " BLOB( %ld )", nLth );
; 2522 :          break;
; 2523 : 
; 2524 :       case zTYPE_DATETIME:
; 2525 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2526 :          break;
; 2527 : 
; 2528 :       case zTYPE_INTEGER:
; 2529 :          zsprintf( pchEnd, " INTEGER" );
; 2530 :          break;
; 2531 : 
; 2532 :       case zTYPE_DECIMAL:
; 2533 :       {
; 2534 :          zLONG nScale;
; 2535 : 
; 2536 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2537 :                                   "Length" );
; 2538 :          if ( nLth > 31 )
; 2539 :             nLth = 31;
; 2540 : 
; 2541 :          GetIntegerFromAttribute( &nScale, vDTE, "TE_FieldDataRel",
; 2542 :                                   "SQL_SCALE" );
; 2543 : 
; 2544 :          zsprintf( pchEnd, " DECIMAL( %ld,%ld )", nLth, nScale );
; 2545 :          break;
; 2546 :       }
; 2547 : 
; 2548 :       case zTYPE_DATE:
; 2549 :          zsprintf( pchEnd, " DATE" );
; 2550 :          break;
; 2551 : 
; 2552 :       case zTYPE_TIME:
; 2553 :          zsprintf( pchEnd, " TIME" );
; 2554 :          break;
; 2555 : 
; 2556 :       // ===
; 2557 :       // === Non-standard types follow here.
; 2558 :       // ===
; 2559 : 
; 2560 :       case 'V':
; 2561 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2562 :                                   "Length" );
; 2563 :          zsprintf( pchEnd, " CLOB( %ld )", nLth );
; 2564 :          break;
; 2565 : 
; 2566 :       // TimeStampEx
; 2567 :       case 'X':
; 2568 :          zsprintf( pchEnd, " VARCHAR( 30 )" );
; 2569 :          break;
; 2570 : 
; 2571 :       default:
; 2572 :       {
; 2573 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2574 :          zCHAR szMsg[ 300 ];
; 2575 : 
; 2576 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2577 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2578 :                    pchDataType, szTableName, szColName );
; 2579 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2580 :          return( -1 );
; 2581 :       }
; 2582 : 
; 2583 :    } // switch ( pchDataType[ 0 ] )...
; 2584 : 
; 2585 : #elif defined( MYSQL )
; 2586 : 
; 2587 :    switch ( pchDataType[ 0 ] )
; 2588 :    {
; 2589 :       case zTYPE_STRING:
; 2590 :       case zTYPE_FIXEDCHAR:
; 2591 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2592 :                                   "Length" );
; 2593 :          zsprintf( pchEnd, " varchar( %ld )", nLth );
; 2594 : 
; 2595 :          break;
; 2596 : 
; 2597 :       case zTYPE_BLOB:
; 2598 :          zsprintf( pchEnd, " longblob" );
; 2599 :          break;
; 2600 : 
; 2601 :       case zTYPE_DATETIME:
; 2602 :          zsprintf( pchEnd, " datetime" );
; 2603 :          break;
; 2604 : 
; 2605 :       case zTYPE_INTEGER:
; 2606 :          zsprintf( pchEnd, " int" );
; 2607 :          break;
; 2608 : 
; 2609 :       case zTYPE_DECIMAL:
; 2610 :          zsprintf( pchEnd, " double" );
; 2611 :          break;
; 2612 : 
; 2613 :       case zTYPE_DATE:
; 2614 :          zsprintf( pchEnd, " datetime" );
; 2615 :          break;
; 2616 : 
; 2617 :       case zTYPE_TIME:
; 2618 :          zsprintf( pchEnd, " datetime" );
; 2619 :          break;
; 2620 : 
; 2621 :       // ===
; 2622 :       // === Non-standard types follow here.
; 2623 :       // ===
; 2624 : 
; 2625 :       case 'V':
; 2626 :          zsprintf( pchEnd, " longtext" );
; 2627 :          break;
; 2628 : 
; 2629 :       case 'A':
; 2630 :          GetAddrForAttribute( &pchKeyType, vDTE, "TE_FieldDataRel", "DataOrRelfieldOrSet" );
; 2631 :          if ( pchKeyType[ 0 ] == 'D' )
; 2632 : 	 {
; 2633 :             // The key type is 'D' for data which means it's the main key.
; 2634 :             #if defined( SQLITE )
; 2635 : 	       zsprintf( pchEnd, " INTEGER PRIMARY KEY " );
; 2636 :             #else
; 2637 : 	       zsprintf( pchEnd, " SERIAL" );
; 2638 :             #endif
; 2639 : 	 }
; 2640 : 	 else
; 2641 : 	 {
; 2642 :             // This must be a FK so don't declare it as SERIAL/KEY.
; 2643 :             zsprintf( pchEnd, " INTEGER" );
; 2644 : 	 }
; 2645 : 
; 2646 :          break;
; 2647 : 
; 2648 :       // TimeStampEx
; 2649 :       case 'X':
; 2650 :          zsprintf( pchEnd, " varchar( 30 )" );
; 2651 :          break;
; 2652 : 
; 2653 :       default:
; 2654 :       {
; 2655 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2656 :          zCHAR szMsg[ 300 ];
; 2657 : 
; 2658 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2659 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2660 :                    pchDataType, szTableName, szColName );
; 2661 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );
; 2662 :          return( -1 );
; 2663 :       }
; 2664 : 
; 2665 :    } // switch ( pchDataType[ 0 ] )...
; 2666 : 
; 2667 : #elif defined( SQLBASE ) || defined( ODBC )
; 2668 : 
; 2669 :    switch ( pchDataType[ 0 ] )
; 2670 :    {
; 2671 :       case zTYPE_STRING:
; 2672 :       case zTYPE_FIXEDCHAR:
; 2673 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2674 :                                   "Length" );
; 2675 :          zsprintf( pchEnd, " CHAR( %ld )", nLth );
; 2676 : 
; 2677 :          break;
; 2678 : 
; 2679 :       case zTYPE_BLOB:
; 2680 :          zsprintf( pchEnd, " LONG VARCHAR" );
; 2681 :          break;
; 2682 : 
; 2683 :       case zTYPE_INTEGER:
; 2684 :          zsprintf( pchEnd, " INTEGER" );
; 2685 :          break;
; 2686 : 
; 2687 :       case zTYPE_DECIMAL:
; 2688 :       {
; 2689 :          zLONG nScale;
; 2690 : 
; 2691 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2692 :                                   "Length" );
; 2693 :          GetIntegerFromAttribute( &nScale, vDTE, "TE_FieldDataRel",
; 2694 :                                   "SQL_SCALE" );
; 2695 : 
; 2696 :          zsprintf( pchEnd, " DECIMAL( %ld,%ld )", nLth, nScale );
; 2697 :          break;
; 2698 :       }
; 2699 : 
; 2700 :    #ifdef ODBC
; 2701 : 
; 2702 :       case zTYPE_DATETIME:
; 2703 :       case zTYPE_TIME:
; 2704 :          if ( bTimestampAsString )
; 2705 :             zsprintf( pchEnd, " TEXT( 25 )" );
; 2706 :          else
; 2707 :          {
; 2708 :             switch ( pchDataType[ 0 ] )
; 2709 :             {
; 2710 :                case zTYPE_DATETIME:
; 2711 :                   zsprintf( pchEnd, " DATETIME" );
; 2712 :                   break;
; 2713 : 
; 2714 :                case zTYPE_TIME:
; 2715 :                   zsprintf( pchEnd, " TIME" );
; 2716 :                   break;
; 2717 :             }
; 2718 :          }
; 2719 : 
; 2720 :          break;
; 2721 : 
; 2722 :       case zTYPE_DATE:
; 2723 :          zsprintf( pchEnd, " DATE" );
; 2724 :          break;
; 2725 : 
; 2726 :    #else
; 2727 :       case zTYPE_DATETIME:
; 2728 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2729 :          break;
; 2730 : 
; 2731 :       case zTYPE_DATE:
; 2732 :          zsprintf( pchEnd, " DATE" );
; 2733 :          break;
; 2734 : 
; 2735 :       case zTYPE_TIME:
; 2736 :          zsprintf( pchEnd, " TIME" );
; 2737 :          break;
; 2738 :    #endif
; 2739 : 
; 2740 :       // ===
; 2741 :       // === Non-standard types follow here.
; 2742 :       // ===
; 2743 : 
; 2744 :       case 'V':
; 2745 :          zsprintf( pchEnd, " LONG VARCHAR" );
; 2746 :          break;
; 2747 : 
; 2748 :       // TimeStampEx
; 2749 :       case 'X':
; 2750 :          zsprintf( pchEnd, " CHAR( 30 )" );
; 2751 :          break;
; 2752 : 
; 2753 :       default:
; 2754 :       {
; 2755 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2756 :          zCHAR szMsg[ 300 ];
; 2757 : 
; 2758 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2759 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2760 :                    pchDataType, szTableName, szColName );
; 2761 :          SysMessageBox( vDTE, "SQLBASE DDL Generator", szMsg, 1 );
; 2762 :          return( -1 );
; 2763 :       }
; 2764 : 
; 2765 :    } // switch ( pchDataType[ 0 ] )...
; 2766 : 
; 2767 : #elif defined( POSTGRESQL )
; 2768 : 
; 2769 :    switch ( pchDataType[ 0 ] )
; 2770 :    {
; 2771 :       case zTYPE_STRING:
; 2772 :       case zTYPE_FIXEDCHAR:
; 2773 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2774 :                                   "Length" );
; 2775 :          zsprintf( pchEnd, " VARCHAR( %ld )", nLth );
; 2776 : 
; 2777 :          break;
; 2778 : 
; 2779 :       case zTYPE_BLOB:
; 2780 :          zsprintf( pchEnd, " bytea" );
; 2781 :          //zsprintf( pchEnd, " text" );
; 2782 :          break;
; 2783 : 
; 2784 :       case zTYPE_DATETIME:
; 2785 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2786 :          break;
; 2787 : 
; 2788 :       case zTYPE_INTEGER:
; 2789 :          zsprintf( pchEnd, " INTEGER" );
; 2790 :          break;
; 2791 : 
; 2792 :       case zTYPE_DECIMAL:
; 2793 :          zsprintf( pchEnd, " FLOAT4" );
; 2794 :          break;
; 2795 : 
; 2796 :       case zTYPE_DATE:
; 2797 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2798 :          break;
; 2799 : 
; 2800 :       case zTYPE_TIME:
; 2801 :          zsprintf( pchEnd, " TIMESTAMP" );
; 2802 :          break;
; 2803 : 
; 2804 :       // ===
; 2805 :       // === Non-standard types follow here.
; 2806 :       // ===
; 2807 : 
; 2808 :       case 'V':
; 2809 :          zsprintf( pchEnd, " TEXT" );
; 2810 :          break;
; 2811 : 
; 2812 :       // TimeStampEx
; 2813 :       case 'X':
; 2814 :          zsprintf( pchEnd, " VARCHAR( 30 )" );
; 2815 :          break;
; 2816 : 
; 2817 :       default:
; 2818 :       {
; 2819 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2820 :          zCHAR szMsg[ 300 ];
; 2821 : 
; 2822 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2823 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2824 :                    pchDataType, szTableName, szColName );
; 2825 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );
; 2826 :          return( -1 );
; 2827 :       }
; 2828 : 
; 2829 :    } // switch ( pchDataType[ 0 ] )...
; 2830 : 
; 2831 : #elif defined( SQLSERVER )
; 2832 : 
; 2833 :    switch ( pchDataType[ 0 ] )
; 2834 :    {
; 2835 :       case zTYPE_STRING:
; 2836 :       case zTYPE_FIXEDCHAR:
; 2837 :          GetIntegerFromAttribute( &nLth, vDTE, "TE_FieldDataRel",
; 2838 :                                   "Length" );
; 2839 :          zsprintf( pchEnd, " varchar( %ld )", nLth );
; 2840 : 
; 2841 :          break;
; 2842 : 
; 2843 :       case zTYPE_BLOB:
; 2844 :          zsprintf( pchEnd, " varbinary(max)" );
; 2845 :          break;
; 2846 : 
; 2847 :       case zTYPE_DATETIME:
; 2848 :          zsprintf( pchEnd, " datetime" );
; 2849 :          break;
; 2850 : 
; 2851 :       case zTYPE_INTEGER:
; 2852 :          zsprintf( pchEnd, " int" );
; 2853 :          break;
; 2854 : 
; 2855 :       case zTYPE_DECIMAL:
; 2856 :          zsprintf( pchEnd, " float" );
; 2857 :          break;
; 2858 : 
; 2859 :       case zTYPE_DATE:
; 2860 :          zsprintf( pchEnd, " datetime" );
; 2861 :          break;
; 2862 : 
; 2863 :       case zTYPE_TIME:
; 2864 :          zsprintf( pchEnd, " datetime" );
; 2865 :          break;
; 2866 : 
; 2867 :       // ===
; 2868 :       // === Non-standard types follow here.
; 2869 :       // ===
; 2870 : 
; 2871 :       case 'V':
; 2872 :          zsprintf( pchEnd, " nvarchar(max)" );
; 2873 :          break;
; 2874 : 
; 2875 :       // TimeStampEx
; 2876 :       case 'X':
; 2877 :          zsprintf( pchEnd, " varchar( 30 )" );
; 2878 :          break;
; 2879 : 
; 2880 :       default:
; 2881 :       {
; 2882 :          zCHAR szTableName[ MAX_TABLENAME_LTH + 1 ];
; 2883 :          zCHAR szMsg[ 300 ];
; 2884 : 
; 2885 :          GetStringFromAttribute( szTableName, vDTE, "TE_TablRec", "Name" );
; 2886 :          zsprintf( szMsg, "Invalid DataType '%s' for attribute %s.%s",
; 2887 :                    pchDataType, szTableName, szColName );
; 2888 :          SysMessageBox( vDTE, "SQL DDL Generator", szMsg, 1 );
; 2889 :          return( -1 );
; 2890 :       }
; 2891 : 
; 2892 :    } // switch ( pchDataType[ 0 ] )...
; 2893 : #endif
; 2894 : 
; 2895 :    // Space out the data type string.
; 2896 :    for ( pch = pchEnd + zstrlen( pchEnd );

	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchEnd$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN8@fnBuildCol
$LN6@fnBuildCol:

; 2898 :          pch++ )

	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$LN8@fnBuildCol:

; 2897 :          pch < pchEnd + MAX_DATATYPE_LTH;

	mov	eax, DWORD PTR _pchEnd$[ebp]
	add	eax, 20					; 00000014H
	cmp	DWORD PTR _pch$[ebp], eax
	jae	SHORT $LN7@fnBuildCol

; 2899 :    {
; 2900 :       *pch = ' ';

	mov	ecx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [ecx], 32			; 00000020H

; 2901 :    }

	jmp	SHORT $LN6@fnBuildCol
$LN7@fnBuildCol:

; 2902 : 
; 2903 :    *pch = 0;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 0

; 2904 :    pchEnd = pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 2905 : 
; 2906 :    // Check to see if column can be NULL.
; 2907 :    if ( CompareAttributeToString( vDTE, "TE_FieldDataRel",
; 2908 :                                   "SQL_NULLS", "Y" ) == 0  )

	push	OFFSET $SG79664
	push	OFFSET $SG79665
	push	OFFSET $SG79666
	mov	ecx, DWORD PTR _vDTE$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN30@fnBuildCol

; 2909 :    {
; 2910 :       // KJS 02/16/17 - Do I want to check if this is POSTGRES and the system generated key and if so set to 'PRIMARY KEY'??????
; 2911 : 	  #if defined( POSTGRESQL )
; 2912 :       if ( SetCursorFirstEntityByAttr( vDTE, "TE_FieldDataRelKey", "ZKey",
; 2913 :                                        vDTE, "TE_FieldDataRel", "ZKey", "TE_TablRec" ) >= 0 )
; 2914 : 	  {
; 2915 :    if ( CheckExistenceOfEntity( vDTE, "ER_Entity" ) >= zCURSOR_SET )
; 2916 : 
; 2917 : 	  if ( CheckExistenceOfEntity( vDTE, "ER_EntIdentifier" ) >= zCURSOR_SET &&
; 2918 : 	       CompareAttributeToString( vDTE, "ER_EntIdentifier",
; 2919 : 										  "SystemMaintained", "Y" ) == 0  )
; 2920 : 			{
; 2921 : 			      zstrcat( pchEnd, "PRIMARY KEY" );
; 2922 : 
; 2923 : 			}
; 2924 : 			else
; 2925 : 			      zstrcat( pchEnd, NOT_NULL_FIELD );
; 2926 : 	  }
; 2927 : 	  else
; 2928 : 	        zstrcat( pchEnd, NOT_NULL_FIELD );
; 2929 : 
; 2930 : 	  
; 2931 : 	  #else
; 2932 :       zstrcat( pchEnd, NOT_NULL_FIELD );

	push	OFFSET $SG79667
	mov	eax, DWORD PTR _pchEnd$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2933 : 	  #endif
; 2934 :    }

	jmp	SHORT $LN31@fnBuildCol
$LN30@fnBuildCol:

; 2935 :    else
; 2936 :       zstrcat( pchEnd, NULL_FIELD );

	push	OFFSET $SG79668
	mov	ecx, DWORD PTR _pchEnd$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN31@fnBuildCol:

; 2937 : 
; 2938 :    pchEnd = pchLine + zstrlen( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchEnd$[ebp], eax

; 2939 : 
; 2940 :    return( 0 );

	xor	eax, eax
$LN1@fnBuildCol:

; 2941 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN38@fnBuildCol:
	DD	$LN18@fnBuildCol
	DD	$LN26@fnBuildCol
	DD	$LN17@fnBuildCol
	DD	$LN21@fnBuildCol
	DD	$LN19@fnBuildCol
	DD	$LN20@fnBuildCol
	DD	$LN27@fnBuildCol
	DD	$LN28@fnBuildCol
	DD	$LN29@fnBuildCol
$LN37@fnBuildCol:
	DB	0
	DB	8
	DB	1
	DB	8
	DB	2
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	4
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	2
	DB	3
	DB	8
	DB	6
	DB	8
	DB	7
_fnBuildColumn@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_szLine$ = -504						; size = 500
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_pchIndexName$ = 12					; size = 4
_pchOwner$ = 16						; size = 4
_pchTableName$ = 20					; size = 4
_f$ = 24						; size = 4
_fnBuildDropIndex@20 PROC

; 2330 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 504				; 000001f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2331 :    zCHAR szLine[ 500 ];
; 2332 : 
; 2333 :    #if defined( SQLSERVER )
; 2334 :       zsprintf( szLine, "DROP INDEX %s%s.%s %s",
; 2335 :                 pchOwner, pchTableName, pchIndexName, LINE_TERMINATOR );
; 2336 :    #else
; 2337 :       zsprintf( szLine, "DROP INDEX %s ON %s%s %s",

	push	OFFSET $SG79569
	mov	eax, DWORD PTR _pchTableName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchOwner$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchIndexName$[ebp]
	push	edx
	push	OFFSET $SG79570
	lea	eax, DWORD PTR _szLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H

; 2338 :                 pchIndexName, pchOwner, pchTableName, LINE_TERMINATOR );
; 2339 :    #endif
; 2340 : 
; 2341 :    if ( fnWriteLine( lpTaskView, f, szLine ) < 0 )

	lea	ecx, DWORD PTR _szLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _f$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN2@fnBuildDro

; 2342 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnBuildDro
$LN2@fnBuildDro:

; 2343 : 
; 2344 :    return( 0 );

	xor	eax, eax
$LN1@fnBuildDro:

; 2345 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnBuildDropIndex@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzhsqlxb.c
_TEXT	SEGMENT
_pchKlammer$ = -4					; size = 4
_pch$ = 8						; size = 4
_RemoveBrackets PROC

; 7292 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7293 :    zPCHAR pchKlammer;
; 7294 : 
; 7295 :    pchKlammer = strchr( pch, '[' );

	push	91					; 0000005bH
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchKlammer$[ebp], eax

; 7296 :    if ( pchKlammer )

	cmp	DWORD PTR _pchKlammer$[ebp], 0
	je	SHORT $LN1@RemoveBrac
$LN2@RemoveBrac:

; 7297 :    {
; 7298 :       // Klammern [] wegnehmen.
; 7299 :       while ( *(pchKlammer + 1) != ']' && *(pchKlammer + 1) )

	mov	ecx, DWORD PTR _pchKlammer$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 93					; 0000005dH
	je	SHORT $LN3@RemoveBrac
	mov	eax, DWORD PTR _pchKlammer$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	test	ecx, ecx
	je	SHORT $LN3@RemoveBrac

; 7300 :       {
; 7301 :          *pchKlammer = *(pchKlammer + 1);

	mov	edx, DWORD PTR _pchKlammer$[ebp]
	mov	eax, DWORD PTR _pchKlammer$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR [edx], cl

; 7302 :          pchKlammer++;

	mov	edx, DWORD PTR _pchKlammer$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchKlammer$[ebp], edx

; 7303 :       }

	jmp	SHORT $LN2@RemoveBrac
$LN3@RemoveBrac:

; 7304 : 
; 7305 :       *pchKlammer = 0;

	mov	eax, DWORD PTR _pchKlammer$[ebp]
	mov	BYTE PTR [eax], 0
$LN1@RemoveBrac:

; 7306 :    }
; 7307 : 
; 7308 : } // RemoveBrackets

	mov	esp, ebp
	pop	ebp
	ret	0
_RemoveBrackets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
