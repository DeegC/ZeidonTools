; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEAPAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG14015 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG13700 DB	'(APP) About to create app (0x%08x): %s (%s)  for Task: 0'
	DB	'x%08x   Process: %d', 00H
$SG13731 DB	'Zeidon System', 00H
	ORG $+2
$SG13732 DB	'(APP) About to create app = ', 00H
	ORG $+3
$SG13733 DB	'Zeidon System', 00H
	ORG $+2
$SG13735 DB	'[App.', 00H
	ORG $+2
$SG13736 DB	']', 00H
	ORG $+2
$SG13737 DB	'KeepAlive', 00H
	ORG $+2
$SG13739 DB	'CreateApp KeepAlive: ', 00H
	ORG $+2
$SG13742 DB	'Domains', 00H
$SG13748 DB	'(ap) looking for domains with: ', 00H
$SG13783 DB	'ROOT', 00H
	ORG $+3
$SG13786 DB	'OBJECT', 00H
	ORG $+1
$SG13789 DB	'DomainGroup', 00H
$SG13811 DB	'OPERNAME', 00H
	ORG $+3
$SG13813 DB	'OPERNUMBER', 00H
	ORG $+1
$SG13830 DB	'(ap) More than one default Context for Domain: ', 00H
$SG14014 DB	'(KeepAlive)', 00H
$SG14016 DB	'DeleteApp for App ===================>>>> %s %s', 00H
$SG14020 DB	'fnDeleteApp found Tasks linked to App: ', 00H
$SG14029 DB	'fnDeleteApp found Subtasks linked to App: ', 00H
	ORG $+1
$SG14024 DB	'fnDeleteApp found ViewOD (%s) for task: 0x%08x  linked t'
	DB	'o App: %s', 00H
	ORG $+2
$SG14036 DB	'fnDeleteApp found Domains linked to App: ', 00H
	ORG $+2
$SG14038 DB	'IMPOSSIBLE!!!', 00H
	ORG $+2
$SG14039 DB	'DKS', 00H
$SG14041 DB	'(APP) About to delete App: ', 00H
$SG14045 DB	'(APP) Finished dropping Views for App: ', 00H
$SG14047 DB	'(APP) Finished dropping View Names for App: ', 00H
	ORG $+3
$SG14049 DB	'(APP) Finished dropping App Views for App: ', 00H
$SG14051 DB	'(APP) Finished dropping Domains for App: ', 00H
	ORG $+2
$SG14053 DB	'(APP) Finished dropping Logical Names for App: ', 00H
$SG14055 DB	'(APP) Finished dropping ViewODs for App: ', 00H
	ORG $+2
$SG14057 DB	'(APP) Finished dropping DB Handlers for App: ', 00H
	ORG $+2
$SG14059 DB	'(APP) Finished dropping GK Handlers for App: ', 00H
	ORG $+2
$SG14064 DB	'(APP) DeleteApp SUCCESSFUL for App: ', 00H
	ORG $+3
$SG14084 DB	'KZDBHQUA', 00H
	ORG $+3
$SG14088 DB	'SetDatabaseUser: %s for task: 0x%08x', 00H
	ORG $+3
$SG14089 DB	'EntitySpec', 00H
	ORG $+1
$SG14090 DB	'EntityName', 00H
	ORG $+1
$SG14091 DB	'EntitySpec', 00H
	ORG $+1
$SG14092 DB	'Options', 00H
$SG14093 DB	'EntitySpec', 00H
_DATA	ENDS
PUBLIC	_GetApplDirectoryFromView@16
PUBLIC	_SetDatabaseUser@12
PUBLIC	_SfSetApplicationForSubtask@8
PUBLIC	_SfGetApplicationForSubtask@8
PUBLIC	_fnParseAppString
PUBLIC	_fnCreateApp
PUBLIC	_fnDeleteApp
PUBLIC	_fnDropTableEntry
PUBLIC	_fnDeleteContext
PUBLIC	_fnGetApplicationForSubtask@8
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__atol:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_SysAppendcDirSep@4:PROC
EXTRN	_fnSysCloseFile@12:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_fnSysOpenFile@12:PROC
EXTRN	_SysParseLine@12:PROC
EXTRN	_fnSysReadLine@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SfActivateSysEmptyOI@16:PROC
EXTRN	_fnConvertEnvironmentString@8:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnStoreStringInDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnDeleteViewObject@4:PROC
EXTRN	_fnDropObjectInstance:PROC
EXTRN	_fnGetDBHandlerOper@12:PROC
EXTRN	_fnDropSubtask:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	__imp__isspace:PROC
EXTRN	_fnDropTaskDomain:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_g_hAnchorBlock:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_cDirSep:BYTE
EXTRN	_lNullInteger:DWORD
EXTRN	_szlAppFile:DWORD
EXTRN	_szlDomainFile:DWORD
EXTRN	_szlAPPLICATION:DWORD
EXTRN	_szlDOMAIN:DWORD
EXTRN	_szlCONTEXT:DWORD
EXTRN	_szlNLS_TABLEENTRY:DWORD
EXTRN	_szlTABLEENTRY:DWORD
EXTRN	_szlREGULAREXPRESSION:DWORD
EXTRN	_szlAPP_NAME:DWORD
EXTRN	_szlAPP_DFLT_Dialog:DWORD
EXTRN	_szlAPP_DLL:DWORD
EXTRN	_szlAPP_ADOBIN:DWORD
EXTRN	_szlAPP_LOCAL:DWORD
EXTRN	_szlAPP_SHARED:DWORD
EXTRN	_szlAPP_QLPLR:DWORD
EXTRN	_szlAPP_QXODS:DWORD
EXTRN	_szlAPP_SOURCE:DWORD
EXTRN	_szlCONTEXTRESTRICTION:DWORD
EXTRN	_szlDATATYPE:DWORD
EXTRN	_szlDECIMALFORMAT:DWORD
EXTRN	_szlDLL_NAME:DWORD
EXTRN	_szlDOMAINTYPE:DWORD
EXTRN	_szlEDITSTRING:DWORD
EXTRN	_szlEXTERNALVALUE:DWORD
EXTRN	_szlINTERNALVALUE:DWORD
EXTRN	_szlISDEFAULT:DWORD
EXTRN	_szlLanguageIndex:DWORD
EXTRN	_szlLNAME:DWORD
EXTRN	_szlMAXSTRINGLTH:DWORD
EXTRN	_szlNAME:DWORD
EXTRN	_szlPNAME:DWORD
EXTRN	_szlRESTRICTED:DWORD
EXTRN	_szlText:DWORD
EXTRN	_szlTYPE:DWORD
EXTRN	_szlZKEY:DWORD
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_lpTask$1 = -28						; size = 4
_lpTask$2 = -24						; size = 4
_lpViewOD$3 = -20					; size = 4
_lpViewOD$4 = -16					; size = 4
_lpViewOI$5 = -12					; size = 4
_lpViewCsr$6 = -8					; size = 4
_lpSubtask$7 = -4					; size = 4
_lpApp$ = 8						; size = 4
_lpView$ = 12						; size = 4
_fnGetApplicationForSubtask@8 PROC

; 167  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 168  :    *lpApp = 0;

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [eax], 0

; 169  : 
; 170  :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN2@fnGetAppli

; 171  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAppli
$LN2@fnGetAppli:

; 172  : 
; 173  :    // If this is a subtask view, which it should be, pass the pointer
; 174  :    // to the application.
; 175  :    if ( lpView->hSubtask )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN3@fnGetAppli

; 176  :    {
; 177  :       LPSUBTASK lpSubtask = zGETPTR( lpView->hSubtask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$7[ebp], eax

; 178  :       *lpApp = zGETPTR( lpSubtask->hApp );

	mov	ecx, DWORD PTR _lpSubtask$7[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [ecx], eax

; 179  :    }

	jmp	$LN4@fnGetAppli
$LN3@fnGetAppli:

; 180  :    else
; 181  :    if ( lpView->hViewCsr )  // there is a time when this should be done

	mov	edx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN5@fnGetAppli

; 182  :    {                        // after the lpView->hTask, but I need to
; 183  :       LPVIEWCSR lpViewCsr;  // find it and correct it since this needs to
; 184  :       LPVIEWOD  lpViewOD;   // be ahead of it ... dks 2005.09.26
; 185  :       LPVIEWOI  lpViewOI;   // fixed in fnFindMQInterface ... dks 2005.11.01
; 186  : 
; 187  :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$6[ebp], eax

; 188  :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$6[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$5[ebp], eax

; 189  :       lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$4[ebp], eax

; 190  :       *lpApp    = zGETPTR( lpViewOD->hApp );

	mov	eax, DWORD PTR _lpViewOD$4[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [edx], eax

; 191  :    }

	jmp	$LN4@fnGetAppli
$LN5@fnGetAppli:

; 192  : 
; 193  : // Change by DGC 5/27/96 -- Instead of just a subtask view we will get the
; 194  : // application from any kind of view.
; 195  : 
; 196  : // Change by DGC 10/15/96 -- Look at lpView->hViewOD before lpView->hTask.
; 197  :    else
; 198  :    if ( lpView->hViewOD )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN7@fnGetAppli

; 199  :    {
; 200  :       LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$3[ebp], eax

; 201  :       *lpApp = zGETPTR( lpViewOD->hApp );

	mov	eax, DWORD PTR _lpViewOD$3[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [edx], eax

; 202  :    }

	jmp	SHORT $LN4@fnGetAppli
$LN7@fnGetAppli:

; 203  :    else
; 204  :    if ( lpView->hTask )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $LN9@fnGetAppli

; 205  :    {
; 206  :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 207  :       *lpApp = zGETPTR( lpTask->hApp );

	mov	eax, DWORD PTR _lpTask$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [edx], eax

; 208  :    }

	jmp	SHORT $LN4@fnGetAppli
$LN9@fnGetAppli:

; 209  :    else
; 210  :    {
; 211  :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 212  : 
; 213  :       // We don't have a subtask view, zero the returned application
; 214  :       // pointer, issue an error message, and give an error return code.
; 215  :       *lpApp = 0;

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [edx], 0

; 216  : 
; 217  :       // "KZOEE107 - Invalid Subtask View"
; 218  :       fnIssueCoreError( lpTask, lpView, 8, 107, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	107					; 0000006bH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 219  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnGetAppli
$LN4@fnGetAppli:

; 220  :    }
; 221  : 
; 222  :    return( 0 );

	xor	eax, eax
$LN1@fnGetAppli:

; 223  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnGetApplicationForSubtask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_lpRegExpression$1 = -12				; size = 4
_lpTableEntry$2 = -8					; size = 4
_lpContext$3 = -4					; size = 4
_lpDomain$ = 8						; size = 4
_fnDeleteContext PROC

; 1641 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
$LN2@fnDeleteCo:

; 1642 :    while ( lpDomain->hFirstContext )

	mov	eax, DWORD PTR _lpDomain$[ebp]
	cmp	DWORD PTR [eax+47], 0
	je	$LN3@fnDeleteCo

; 1643 :    {
; 1644 :       zLPCONTEXT      lpContext;
; 1645 :       LPTABLEENTRY    lpTableEntry;
; 1646 :       LPREGEXPRESSION lpRegExpression;
; 1647 : 
; 1648 :       // Delete all table entries for this context.
; 1649 :       lpContext = zGETPTR( lpDomain->hFirstContext );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpContext$3[ebp], eax
$LN4@fnDeleteCo:

; 1650 :       while ( lpContext->hFirstTableEntry )

	mov	eax, DWORD PTR _lpContext$3[ebp]
	cmp	DWORD PTR [eax+47], 0
	je	SHORT $LN6@fnDeleteCo

; 1651 :       {
; 1652 :          lpTableEntry = zGETPTR( lpContext->hFirstTableEntry );

	mov	ecx, DWORD PTR _lpContext$3[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$2[ebp], eax

; 1653 :          lpContext->hFirstTableEntry = lpTableEntry->hNextTableEntry;

	mov	eax, DWORD PTR _lpContext$3[ebp]
	mov	ecx, DWORD PTR _lpTableEntry$2[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+47], edx

; 1654 :          fnDropTableEntry( lpContext, lpTableEntry, 0 );

	push	0
	mov	eax, DWORD PTR _lpTableEntry$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpContext$3[ebp]
	push	ecx
	call	_fnDropTableEntry
	add	esp, 12					; 0000000cH

; 1655 :       }

	jmp	SHORT $LN4@fnDeleteCo
$LN6@fnDeleteCo:

; 1656 : 
; 1657 :       // Delete all regular expressions for this context.
; 1658 :       while ( lpContext->hFirstRegExpression )

	mov	edx, DWORD PTR _lpContext$3[ebp]
	cmp	DWORD PTR [edx+55], 0
	je	SHORT $LN7@fnDeleteCo

; 1659 :       {
; 1660 :          lpRegExpression = zGETPTR( lpContext->hFirstRegExpression );

	mov	eax, DWORD PTR _lpContext$3[ebp]
	mov	ecx, DWORD PTR [eax+55]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRegExpression$1[ebp], eax

; 1661 :          lpContext->hFirstRegExpression = lpRegExpression->hNextRegExpression;

	mov	edx, DWORD PTR _lpContext$3[ebp]
	mov	eax, DWORD PTR _lpRegExpression$1[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+55], ecx

; 1662 :          fnFreeDataspace( lpRegExpression );

	mov	edx, DWORD PTR _lpRegExpression$1[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1663 :       }

	jmp	SHORT $LN6@fnDeleteCo
$LN7@fnDeleteCo:

; 1664 : 
; 1665 :       lpDomain->hFirstContext = lpContext->hNextContext;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR _lpContext$3[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+47], edx

; 1666 :       fnFreeDataspace( zGETPTR( lpContext->hEditString ) );

	mov	eax, DWORD PTR _lpContext$3[ebp]
	mov	ecx, DWORD PTR [eax+59]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1667 :       fnFreeDataspace( lpContext );

	mov	edx, DWORD PTR _lpContext$3[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1668 :    }

	jmp	$LN2@fnDeleteCo
$LN3@fnDeleteCo:

; 1669 : 
; 1670 :    return( 0 );

	xor	eax, eax

; 1671 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDeleteContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_lpNextNLS_TableEntry$ = -16				; size = 4
_lpDomain$ = -12					; size = 4
_lpTempTable$1 = -8					; size = 4
_lpNLS_TableEntry$ = -4					; size = 4
_lpContext$ = 8						; size = 4
_lpTableEntry$ = 12					; size = 4
_nMaintainLinks$ = 16					; size = 2
_fnDropTableEntry PROC

; 1544 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1545 :    LPNLSTABLEENTRY lpNLS_TableEntry;
; 1546 :    LPNLSTABLEENTRY lpNextNLS_TableEntry;
; 1547 :    LPDOMAIN        lpDomain;
; 1548 : 
; 1549 :    // Drop the NLS stuff.
; 1550 :    for ( lpNLS_TableEntry = zGETPTR( lpTableEntry->hFirstNLS_TableEntry );

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNLS_TableEntry$[ebp], eax
	jmp	SHORT $LN4@fnDropTabl
$LN2@fnDropTabl:

; 1552 :          lpNLS_TableEntry = zGETPTR( lpNextNLS_TableEntry ) )

	mov	edx, DWORD PTR _lpNextNLS_TableEntry$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNLS_TableEntry$[ebp], eax
$LN4@fnDropTabl:

; 1551 :          lpNLS_TableEntry;

	cmp	DWORD PTR _lpNLS_TableEntry$[ebp], 0
	je	SHORT $LN3@fnDropTabl

; 1553 :    {
; 1554 :       lpNextNLS_TableEntry = lpNLS_TableEntry->hNextNLS_TableEntry;

	mov	eax, DWORD PTR _lpNLS_TableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _lpNextNLS_TableEntry$[ebp], ecx

; 1555 : 
; 1556 :       if ( lpNLS_TableEntry->pszNLS_Text )

	mov	edx, DWORD PTR _lpNLS_TableEntry$[ebp]
	cmp	DWORD PTR [edx+6], 0
	je	SHORT $LN5@fnDropTabl

; 1557 :          fnFreeDataspace( zGETPTR( lpNLS_TableEntry->pszNLS_Text ) );

	mov	eax, DWORD PTR _lpNLS_TableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN5@fnDropTabl:

; 1558 : 
; 1559 :       fnFreeDataspace( lpNLS_TableEntry );

	mov	edx, DWORD PTR _lpNLS_TableEntry$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1560 :    }

	jmp	SHORT $LN2@fnDropTabl
$LN3@fnDropTabl:

; 1561 : 
; 1562 :    lpDomain = zGETPTR( lpContext->hDomain );

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR [eax+43]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 1563 :    if ( lpDomain->cType != zTYPE_INTEGER &&

	mov	edx, DWORD PTR _lpDomain$[ebp]
	movsx	eax, BYTE PTR [edx+63]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN6@fnDropTabl
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+63]
	cmp	edx, 77					; 0000004dH
	je	SHORT $LN6@fnDropTabl

; 1564 :         lpDomain->cType != zTYPE_DECIMAL )
; 1565 :    {
; 1566 :       if ( lpTableEntry->hExternalValue ==

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [eax+18]
	cmp	edx, DWORD PTR [ecx+26]
	jne	SHORT $LN8@fnDropTabl

; 1567 :                           lpTableEntry->unInternal.hStringValue )
; 1568 :       {
; 1569 :          fnFreeDataspace( zGETPTR( lpTableEntry->unInternal.hStringValue ) );

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1570 :       }

	jmp	SHORT $LN9@fnDropTabl
$LN8@fnDropTabl:

; 1571 :       else
; 1572 :       {
; 1573 :          fnFreeDataspace( zGETPTR( lpTableEntry->hExternalValue ) );

	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1574 :          fnFreeDataspace( zGETPTR( lpTableEntry->unInternal.hStringValue ) );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN9@fnDropTabl:

; 1575 :       }
; 1576 :    }

	jmp	SHORT $LN7@fnDropTabl
$LN6@fnDropTabl:

; 1577 :    else
; 1578 :       fnFreeDataspace( zGETPTR( lpTableEntry->hExternalValue ) );

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN7@fnDropTabl:

; 1579 : 
; 1580 :    if ( nMaintainLinks )

	movsx	edx, WORD PTR _nMaintainLinks$[ebp]
	test	edx, edx
	je	$LN10@fnDropTabl

; 1581 :    {
; 1582 :       LPTABLEENTRY lpTempTable;
; 1583 : 
; 1584 :       if ( lpTableEntry->hNextTableEntry )

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $LN11@fnDropTabl

; 1585 :       {
; 1586 :          // not the tail of the chain
; 1587 : 
; 1588 :          lpTempTable = zGETPTR( lpTableEntry->hNextTableEntry );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempTable$1[ebp], eax

; 1589 :          lpTempTable->hPrevTableEntry = lpTableEntry->hPrevTableEntry;

	mov	eax, DWORD PTR _lpTempTable$1[ebp]
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+6], edx

; 1590 : 
; 1591 :          if ( lpTableEntry->hPrevTableEntry )

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN13@fnDropTabl

; 1592 :          {
; 1593 :             // not the head of the chain
; 1594 :             lpTempTable = zGETPTR( lpTableEntry->hPrevTableEntry );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempTable$1[ebp], eax

; 1595 :             lpTempTable->hNextTableEntry = lpTableEntry->hNextTableEntry;

	mov	eax, DWORD PTR _lpTempTable$1[ebp]
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+2], edx

; 1596 :          }

	jmp	SHORT $LN14@fnDropTabl
$LN13@fnDropTabl:

; 1597 :          else
; 1598 :             // head of the chain
; 1599 :             lpContext->hFirstTableEntry = lpTableEntry->hNextTableEntry;

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+47], edx
$LN14@fnDropTabl:

; 1600 :       }

	jmp	SHORT $LN10@fnDropTabl
$LN11@fnDropTabl:

; 1601 :       else
; 1602 :       {
; 1603 :          // deleting the tail of the chain
; 1604 :          lpContext->hLastTableEntry = lpTableEntry->hPrevTableEntry;

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+51], edx

; 1605 :          if ( lpTableEntry->hPrevTableEntry )

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN15@fnDropTabl

; 1606 :          {
; 1607 :             // not the only entry in the chain
; 1608 :             lpTempTable = zGETPTR( lpTableEntry->hPrevTableEntry );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempTable$1[ebp], eax

; 1609 :             lpTempTable->hNextTableEntry = 0;

	mov	eax, DWORD PTR _lpTempTable$1[ebp]
	mov	DWORD PTR [eax+2], 0

; 1610 :          }

	jmp	SHORT $LN10@fnDropTabl
$LN15@fnDropTabl:

; 1611 :          else
; 1612 :          {
; 1613 :             // only entry in the chain
; 1614 :             lpContext->hFirstTableEntry = 0;

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	DWORD PTR [ecx+47], 0
$LN10@fnDropTabl:

; 1615 :          }
; 1616 :       }
; 1617 :    }
; 1618 : 
; 1619 :    fnFreeDataspace( lpTableEntry );

	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1620 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_lpViewCsr$1 = -84					; size = 4
_lpViewOD$2 = -80					; size = 4
_lpPrevTaskDomain$ = -76				; size = 4
_hApp2$3 = -72						; size = 4
_lpGKHandler$ = -68					; size = 4
_lpDBHandler$ = -64					; size = 4
_lpLName$ = -60						; size = 4
_vTemp$ = -56						; size = 4
_lpViewOD$4 = -52					; size = 4
tv76 = -48						; size = 4
_lpViewName$ = -44					; size = 4
_lpPrevApp$ = -40					; size = 4
_hTask$ = -36						; size = 4
_lpDomain$ = -32					; size = 4
_hApp$ = -28						; size = 4
_lpViewOI$ = -24					; size = 4
_lpTaskDomain$ = -20					; size = 4
_lpSubtask$ = -16					; size = 4
_lpView$ = -12						; size = 4
_pchAppName$ = -8					; size = 4
_lpTask$ = -4						; size = 4
_lpApp$ = 8						; size = 4
_fnDeleteApp PROC

; 1701 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 1702 :    LPAPP          lpPrevApp;
; 1703 :    LPAPP          hApp;
; 1704 :    LPTASK         hTask;
; 1705 :    LPTASK         lpTask;
; 1706 :    LPDBHANDLER    lpDBHandler;
; 1707 :    LPGKHANDLER    lpGKHandler;
; 1708 :    zVIEW          lpView;
; 1709 :    zVIEW          vTemp;
; 1710 :    LPVIEWNAME     lpViewName;
; 1711 :    LPSUBTASK      lpSubtask;
; 1712 :    LPLNAME        lpLName;
; 1713 :    LPTASKDOMAIN   lpTaskDomain;
; 1714 :    LPTASKDOMAIN   lpPrevTaskDomain;
; 1715 :    LPDOMAIN       lpDomain;
; 1716 :    LPVIEWOI       lpViewOI;
; 1717 :    zPCHAR         pchAppName;
; 1718 : 
; 1719 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN31@fnDeleteAp

; 1720 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnDeleteAp
$LN31@fnDeleteAp:

; 1721 : 
; 1722 :    if ( lpApp == 0 || lpApp->nTableID != iApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN33@fnDeleteAp
	mov	eax, DWORD PTR _lpApp$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10003				; 00002713H
	je	SHORT $LN32@fnDeleteAp
$LN33@fnDeleteAp:

; 1723 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnDeleteAp
$LN32@fnDeleteAp:

; 1724 : 
; 1725 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN34@fnDeleteAp

; 1726 :    {
; 1727 :       TraceLine( "DeleteApp for App ===================>>>> %s %s",

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1905]
	and	edx, 1
	je	SHORT $LN68@fnDeleteAp
	mov	DWORD PTR tv76[ebp], OFFSET $SG14014
	jmp	SHORT $LN69@fnDeleteAp
$LN68@fnDeleteAp:
	mov	DWORD PTR tv76[ebp], OFFSET $SG14015
$LN69@fnDeleteAp:
	mov	eax, DWORD PTR tv76[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET $SG14016
	call	_TraceLine
	add	esp, 12					; 0000000cH
$LN34@fnDeleteAp:

; 1728 :                  lpApp->szName, lpApp->bKeepAlive ? "(KeepAlive)" : "" );
; 1729 :    }
; 1730 : 
; 1731 :    // Some apps never get dropped, even if no tasks reference them.  Check
; 1732 :    // to see if this is one of them and just return if it is.
; 1733 :    if ( lpApp->bKeepAlive )

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+1905]
	and	eax, 1
	je	SHORT $LN35@fnDeleteAp

; 1734 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDeleteAp
$LN35@fnDeleteAp:

; 1735 : 
; 1736 :    hApp = zGETHNDL( lpApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hApp$[ebp], eax

; 1737 :    pchAppName = lpApp->szName;

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	mov	DWORD PTR _pchAppName$[ebp], edx

; 1738 : 
; 1739 :    // Loop through the tasks.  Note that we don't need to worry about a
; 1740 :    // task being deleted while we are here because we are protected by
; 1741 :    // the ANCHORBLOCK mutex.
; 1742 :    hTask = AnchorBlock->hFirstTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	mov	DWORD PTR _hTask$[ebp], ecx
$LN2@fnDeleteAp:

; 1743 :    while ( (lpTask = zGETPTR( hTask )) != 0 )

	mov	edx, DWORD PTR _hTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN3@fnDeleteAp

; 1744 :    {
; 1745 :       // Kick out if task is connected to app.
; 1746 :       if ( lpTask->hApp == hApp )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hApp$[ebp]
	jne	SHORT $LN36@fnDeleteAp

; 1747 :       {
; 1748 :          if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN37@fnDeleteAp

; 1749 :             TraceLineS( "fnDeleteApp found Tasks linked to App: ", lpApp->szName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET $SG14020
	call	_TraceLineS@8
$LN37@fnDeleteAp:

; 1750 : 
; 1751 :          return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDeleteAp
$LN36@fnDeleteAp:

; 1752 :       }
; 1753 : 
; 1754 :       // Make sure that no task is using a View OI for one of the object's
; 1755 :       // view instances.
; 1756 :       lpView = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax
$LN4@fnDeleteAp:

; 1757 :       while ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN5@fnDeleteAp

; 1758 :       {
; 1759 :          if ( lpView->hViewOD )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	SHORT $LN38@fnDeleteAp

; 1760 :          {
; 1761 :             LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$4[ebp], eax

; 1762 : 
; 1763 :             // Kick out if ViewOD is connected to app.
; 1764 :             if ( lpViewOD->hApp == hApp )

	mov	ecx, DWORD PTR _lpViewOD$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	cmp	edx, DWORD PTR _hApp$[ebp]
	jne	SHORT $LN38@fnDeleteAp

; 1765 :             {
; 1766 :                if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN40@fnDeleteAp

; 1767 :                {
; 1768 :                   TraceLine( "fnDeleteApp found ViewOD (%s) for task: 0x%08x  linked to App: %s",

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$4[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14024
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN40@fnDeleteAp:

; 1769 :                              lpViewOD->szName, zGETHNDL( lpTask ), lpApp->szName );
; 1770 :                }
; 1771 : 
; 1772 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDeleteAp
$LN38@fnDeleteAp:

; 1773 :             }
; 1774 :          }
; 1775 : 
; 1776 :          lpView = zGETPTR( lpView->hNextView );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 1777 :       }

	jmp	SHORT $LN4@fnDeleteAp
$LN5@fnDeleteAp:

; 1778 : 
; 1779 :       // Make sure none of the active subtasks is using the application to
; 1780 :       // be deleted.
; 1781 :       lpSubtask = zGETPTR( lpTask->hFirstSubtask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax
$LN6@fnDeleteAp:

; 1782 :       while ( lpSubtask )

	cmp	DWORD PTR _lpSubtask$[ebp], 0
	je	$LN7@fnDeleteAp

; 1783 :       {
; 1784 :          // Kick out if subtask is connected to app.
; 1785 :          if ( lpSubtask->hApp == hApp )

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hApp$[ebp]
	jne	SHORT $LN41@fnDeleteAp

; 1786 :          {
; 1787 :             if ( hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _hTask$[ebp]
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $LN42@fnDeleteAp

; 1788 :             {
; 1789 :                // Clean up any subtasks for this app in the Main task.
; 1790 :                fnDropSubtask( lpTask, lpSubtask, -1 );

	push	-1
	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH

; 1791 :                lpSubtask = zGETPTR( lpTask->hFirstSubtask );  // restart

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 1792 :                continue;

	jmp	SHORT $LN6@fnDeleteAp

; 1793 :             }

	jmp	SHORT $LN41@fnDeleteAp
$LN42@fnDeleteAp:

; 1794 :             else
; 1795 :             {
; 1796 :                if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN44@fnDeleteAp

; 1797 :                   TraceLineS( "fnDeleteApp found Subtasks linked to App: ", lpApp->szName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET $SG14029
	call	_TraceLineS@8
$LN44@fnDeleteAp:

; 1798 : 
; 1799 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDeleteAp
$LN41@fnDeleteAp:

; 1800 :             }
; 1801 :          }
; 1802 : 
; 1803 :          lpSubtask = zGETPTR( lpSubtask->hNextSubtask );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 1804 :       }

	jmp	$LN6@fnDeleteAp
$LN7@fnDeleteAp:

; 1805 : 
; 1806 :       if ( lpView || lpSubtask )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN46@fnDeleteAp
	cmp	DWORD PTR _lpSubtask$[ebp], 0
	je	SHORT $LN45@fnDeleteAp
$LN46@fnDeleteAp:

; 1807 :          return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDeleteAp
$LN45@fnDeleteAp:

; 1808 : 
; 1809 :       // Check this for leak ... dks 2005.12.01
; 1810 :       lpPrevTaskDomain = 0;

	mov	DWORD PTR _lpPrevTaskDomain$[ebp], 0

; 1811 :       lpTaskDomain = zGETPTR( lpTask->hFirstTaskDomain );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+126]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDomain$[ebp], eax
$LN8@fnDeleteAp:

; 1812 :       while( lpTaskDomain )

	cmp	DWORD PTR _lpTaskDomain$[ebp], 0
	je	$LN9@fnDeleteAp

; 1813 :       {
; 1814 :          lpDomain = zGETPTR( lpTaskDomain->hDomain );

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 1815 :          if ( lpDomain->hApp == hApp )

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR [edx+43]
	cmp	eax, DWORD PTR _hApp$[ebp]
	jne	SHORT $LN47@fnDeleteAp

; 1816 :          {
; 1817 :             if ( hTask == AnchorBlock->hMainTask )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hTask$[ebp]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN48@fnDeleteAp

; 1818 :             {
; 1819 :                // Clean up any domains for this app in the Main task.
; 1820 :                fnDropTaskDomain( lpTask, lpTaskDomain );

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnDropTaskDomain
	add	esp, 8

; 1821 :                lpTaskDomain = zGETPTR( lpTask->hFirstTaskDomain );  // restart

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+126]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDomain$[ebp], eax

; 1822 :                continue;

	jmp	SHORT $LN8@fnDeleteAp

; 1823 :             }

	jmp	SHORT $LN47@fnDeleteAp
$LN48@fnDeleteAp:

; 1824 :             else
; 1825 :             {
; 1826 :                if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN50@fnDeleteAp

; 1827 :                   TraceLineS( "fnDeleteApp found Domains linked to App: ", lpApp->szName );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	push	OFFSET $SG14036
	call	_TraceLineS@8
$LN50@fnDeleteAp:

; 1828 : 
; 1829 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDeleteAp
$LN47@fnDeleteAp:

; 1830 :             }
; 1831 :          }
; 1832 : 
; 1833 :          lpPrevTaskDomain = lpTaskDomain;

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	DWORD PTR _lpPrevTaskDomain$[ebp], ecx

; 1834 :          lpTaskDomain = zGETPTR( lpTaskDomain->hNextTaskDomainForTask );

	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDomain$[ebp], eax

; 1835 :       }

	jmp	$LN8@fnDeleteAp
$LN9@fnDeleteAp:

; 1836 : 
; 1837 :       hTask = lpTask->hNextTask;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR _hTask$[ebp], edx

; 1838 :    }

	jmp	$LN2@fnDeleteAp
$LN3@fnDeleteAp:

; 1839 : 
; 1840 :    // If lpTask is set, then the application is still in use either by
; 1841 :    // a view in a task chain OR a subtask still active in a task chain.
; 1842 :    // Return that the application is still in use!
; 1843 :    if ( lpTask )    // i don't think it is possible to get here ... but who

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN51@fnDeleteAp

; 1844 :    {                // am i to question such things ... dks  2005.05.04
; 1845 :       SysMessageBox( 0, "DKS", "IMPOSSIBLE!!!", -1 );

	push	-1
	push	OFFSET $SG14038
	push	OFFSET $SG14039
	push	0
	call	_SysMessageBox@16

; 1846 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDeleteAp
$LN51@fnDeleteAp:

; 1847 :    }
; 1848 : 
; 1849 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN52@fnDeleteAp

; 1850 :       TraceLineS( "(APP) About to delete App: ", pchAppName );

	mov	edx, DWORD PTR _pchAppName$[ebp]
	push	edx
	push	OFFSET $SG14041
	call	_TraceLineS@8
$LN52@fnDeleteAp:

; 1851 : 
; 1852 :    // Even though the application is not in use, there may yet be instances
; 1853 :    // tied to the application. Go through all ViewOI's in all tasks and
; 1854 :    // delete any instances which are for this application.
; 1855 :    for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN12@fnDeleteAp
$LN10@fnDeleteAp:

; 1857 :          lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN12@fnDeleteAp:

; 1856 :          lpTask;

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN11@fnDeleteAp

; 1858 :    {
; 1859 :       // Make sure that no task is using a View OI for one of the object's
; 1860 :       // view instances.
; 1861 :       lpViewOI = zGETPTR( lpTask->hFirstViewOI );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+98]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$LN13@fnDeleteAp:

; 1862 :       while ( lpViewOI )

	cmp	DWORD PTR _lpViewOI$[ebp], 0
	je	SHORT $LN14@fnDeleteAp

; 1863 :       {
; 1864 :          LPVIEWOD lpViewOD = zGETPTR( lpViewOI->hViewOD );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$2[ebp], eax

; 1865 : 
; 1866 :          if ( lpViewOD->hApp == hApp )

	mov	edx, DWORD PTR _lpViewOD$2[ebp]
	mov	eax, DWORD PTR [edx+6]
	cmp	eax, DWORD PTR _hApp$[ebp]
	jne	SHORT $LN53@fnDeleteAp

; 1867 :          {
; 1868 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 1869 : 
; 1870 :             lpView   = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 1871 :             lpViewOI = zGETPTR( lpViewOI->hNextViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1872 :             fnDropObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropObjectInstance
	add	esp, 4

; 1873 :          }

	jmp	SHORT $LN54@fnDeleteAp
$LN53@fnDeleteAp:

; 1874 :          else
; 1875 :             lpViewOI = zGETPTR( lpViewOI->hNextViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$LN54@fnDeleteAp:

; 1876 :       }

	jmp	SHORT $LN13@fnDeleteAp
$LN14@fnDeleteAp:

; 1877 :    }

	jmp	$LN10@fnDeleteAp
$LN11@fnDeleteAp:

; 1878 : 
; 1879 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN15@fnDeleteAp

; 1880 :       TraceLineS( "(APP) Finished dropping Views for App: ", pchAppName );

	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	push	OFFSET $SG14045
	call	_TraceLineS@8
$LN15@fnDeleteAp:

; 1881 : 
; 1882 :    // Drop all the view names chained to the application.
; 1883 :    while ( lpApp->hFirstViewName )

	mov	ecx, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [ecx+1893], 0
	je	SHORT $LN16@fnDeleteAp

; 1884 :    {
; 1885 :       lpViewName = zGETPTR( lpApp->hFirstViewName );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+1893]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1886 : 
; 1887 :       // Unchain the current view name.
; 1888 :       lpApp->hFirstViewName = lpViewName->hNextViewName;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+1893], eax

; 1889 : 
; 1890 :       // Decrement the name count in the View referenced by the ViewName.
; 1891 :       vTemp = zGETPTR( lpViewName->hView );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTemp$[ebp], eax

; 1892 :       vTemp->nViewNames--;

	mov	eax, DWORD PTR _vTemp$[ebp]
	mov	cx, WORD PTR [eax+22]
	sub	cx, 1
	mov	edx, DWORD PTR _vTemp$[ebp]
	mov	WORD PTR [edx+22], cx

; 1893 : 
; 1894 :       // Free up storage for name string and the ViewName itself.
; 1895 :       fnFreeDataspace( lpViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1896 :    }

	jmp	SHORT $LN15@fnDeleteAp
$LN16@fnDeleteAp:

; 1897 : 
; 1898 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN17@fnDeleteAp

; 1899 :       TraceLineS( "(APP) Finished dropping View Names for App: ", pchAppName );

	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	push	OFFSET $SG14047
	call	_TraceLineS@8
$LN17@fnDeleteAp:

; 1900 : 
; 1901 :    // Drop all the views chained to the application.
; 1902 :    while ( lpApp->hFirstView )

	mov	ecx, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [ecx+1889], 0
	je	SHORT $LN18@fnDeleteAp

; 1903 :    {
; 1904 :       fnDropView( zGETPTR( lpApp->hFirstView ) );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+1889]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4

; 1905 :    }

	jmp	SHORT $LN17@fnDeleteAp
$LN18@fnDeleteAp:

; 1906 : 
; 1907 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN19@fnDeleteAp

; 1908 :       TraceLineS( "(APP) Finished dropping App Views for App: ", pchAppName );

	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	push	OFFSET $SG14049
	call	_TraceLineS@8
$LN19@fnDeleteAp:

; 1909 : 
; 1910 :    // Clean up application domains.
; 1911 :    while ( lpApp->hFirstDomain )

	mov	ecx, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [ecx+72], 0
	je	SHORT $LN20@fnDeleteAp

; 1912 :    {
; 1913 :       lpDomain = zGETPTR( lpApp->hFirstDomain );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 1914 :       fnDeleteContext( lpDomain );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	call	_fnDeleteContext
	add	esp, 4

; 1915 :       lpApp->hFirstDomain = lpDomain->hNextDomain;

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+72], ecx

; 1916 :       fnFreeDataspace( lpDomain );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1917 :    }

	jmp	SHORT $LN19@fnDeleteAp
$LN20@fnDeleteAp:

; 1918 : 
; 1919 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN21@fnDeleteAp

; 1920 :       TraceLineS( "(APP) Finished dropping Domains for App: ", pchAppName );

	mov	edx, DWORD PTR _pchAppName$[ebp]
	push	edx
	push	OFFSET $SG14051
	call	_TraceLineS@8
$LN21@fnDeleteAp:

; 1921 : 
; 1922 :    // Clean up logical names.
; 1923 :    while ( lpApp->hFirstLName )

	mov	eax, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [eax+1897], 0
	je	SHORT $LN22@fnDeleteAp

; 1924 :    {
; 1925 :       lpLName = zGETPTR( lpApp->hFirstLName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1897]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLName$[ebp], eax

; 1926 :       lpApp->hFirstLName = lpLName->hNextLName;

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR _lpLName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+1897], edx

; 1927 :       fnFreeDataspace( lpLName );

	mov	eax, DWORD PTR _lpLName$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1928 :    }

	jmp	SHORT $LN21@fnDeleteAp
$LN22@fnDeleteAp:

; 1929 : 
; 1930 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN23@fnDeleteAp

; 1931 :       TraceLineS( "(APP) Finished dropping Logical Names for App: ", pchAppName );

	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	push	OFFSET $SG14053
	call	_TraceLineS@8
$LN23@fnDeleteAp:

; 1932 : 
; 1933 :    // Clean up view Objects.
; 1934 :    while ( lpApp->hFirstViewOD )

	mov	ecx, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	je	SHORT $LN24@fnDeleteAp

; 1935 :       fnDeleteViewObject( zGETPTR( lpApp->hFirstViewOD ) );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDeleteViewObject@4
	jmp	SHORT $LN23@fnDeleteAp
$LN24@fnDeleteAp:

; 1936 : 
; 1937 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN25@fnDeleteAp

; 1938 :       TraceLineS( "(APP) Finished dropping ViewODs for App: ", pchAppName );

	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	push	OFFSET $SG14055
	call	_TraceLineS@8
$LN25@fnDeleteAp:

; 1939 : 
; 1940 :    // Clean up application DB Handlers.
; 1941 :    while ( lpApp->hFirstDBHandler )

	mov	ecx, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [ecx+76], 0
	je	SHORT $LN26@fnDeleteAp

; 1942 :    {
; 1943 :       lpDBHandler = zGETPTR( lpApp->hFirstDBHandler );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$[ebp], eax

; 1944 :       lpApp->hFirstDBHandler = lpDBHandler->hNextDBHandler;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR _lpDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+76], eax

; 1945 :       fnFreeDataspace( lpDBHandler );

	mov	ecx, DWORD PTR _lpDBHandler$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 1946 :    }

	jmp	SHORT $LN25@fnDeleteAp
$LN26@fnDeleteAp:

; 1947 : 
; 1948 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN27@fnDeleteAp

; 1949 :       TraceLineS( "(APP) Finished dropping DB Handlers for App: ", pchAppName );

	mov	ecx, DWORD PTR _pchAppName$[ebp]
	push	ecx
	push	OFFSET $SG14057
	call	_TraceLineS@8
$LN27@fnDeleteAp:

; 1950 : 
; 1951 :    // Clean up application GK Handlers.
; 1952 :    while ( lpApp->hFirstGKHandler )

	mov	edx, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN28@fnDeleteAp

; 1953 :    {
; 1954 :       lpGKHandler = zGETPTR( lpApp->hFirstGKHandler );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$[ebp], eax

; 1955 :       lpApp->hFirstGKHandler = lpGKHandler->hNextGKHandler;

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR _lpGKHandler$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+80], ecx

; 1956 :       fnFreeDataspace( lpGKHandler );

	mov	edx, DWORD PTR _lpGKHandler$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1957 :    }

	jmp	SHORT $LN27@fnDeleteAp
$LN28@fnDeleteAp:

; 1958 : 
; 1959 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN62@fnDeleteAp

; 1960 :       TraceLineS( "(APP) Finished dropping GK Handlers for App: ", pchAppName );

	mov	edx, DWORD PTR _pchAppName$[ebp]
	push	edx
	push	OFFSET $SG14059
	call	_TraceLineS@8
$LN62@fnDeleteAp:

; 1961 : 
; 1962 :    // Unchain the application from the Anchor Block.
; 1963 :    if ( AnchorBlock->hFirstApp == hApp )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+126]
	cmp	ecx, DWORD PTR _hApp$[ebp]
	jne	SHORT $LN63@fnDeleteAp

; 1964 :       AnchorBlock->hFirstApp = lpApp->hNextApp;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+126], ecx
	jmp	SHORT $LN64@fnDeleteAp
$LN63@fnDeleteAp:

; 1965 :    else
; 1966 :    {
; 1967 :       LPAPP hApp2;
; 1968 : 
; 1969 :       // It is possible that lpApp is non-zero and also not in the chain
; 1970 :       // beginning at AnchorBlock->hFirstApp.  We had that situation
; 1971 :       // when zeidon.xdm was missing.  We must handle that, otherwise
; 1972 :       // the engine crashes.
; 1973 :       lpPrevApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+126]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevApp$[ebp], eax
$LN29@fnDeleteAp:

; 1974 :       while ( (hApp2 = lpPrevApp->hNextApp) != 0 )

	mov	ecx, DWORD PTR _lpPrevApp$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR _hApp2$3[ebp], edx
	cmp	DWORD PTR _hApp2$3[ebp], 0
	je	SHORT $LN64@fnDeleteAp

; 1975 :       {
; 1976 :          if ( hApp2 == hApp )

	mov	eax, DWORD PTR _hApp2$3[ebp]
	cmp	eax, DWORD PTR _hApp$[ebp]
	jne	SHORT $LN65@fnDeleteAp

; 1977 :          {
; 1978 :             lpPrevApp->hNextApp = lpApp->hNextApp;

	mov	ecx, DWORD PTR _lpPrevApp$[ebp]
	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax

; 1979 :             break;

	jmp	SHORT $LN64@fnDeleteAp
$LN65@fnDeleteAp:

; 1980 :          }
; 1981 : 
; 1982 :          lpPrevApp = zGETPTR( lpPrevApp->hNextApp );

	mov	ecx, DWORD PTR _lpPrevApp$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevApp$[ebp], eax

; 1983 :       }

	jmp	SHORT $LN29@fnDeleteAp
$LN64@fnDeleteAp:

; 1984 : 
; 1985 : //    while ( lpPrevApp && lpPrevApp->hNextApp != hApp )
; 1986 : //       lpPrevApp = zGETPTR( lpPrevApp->hNextApp );
; 1987 : 
; 1988 :       // It's possible the app wasn't added to the chain so be careful ...
; 1989 : //    if ( lpPrevApp )
; 1990 : //       lpPrevApp->hNextApp = lpApp->hNextApp;
; 1991 :    }
; 1992 : 
; 1993 :    // Clean up application.
; 1994 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN66@fnDeleteAp

; 1995 :       TraceLineS( "(APP) DeleteApp SUCCESSFUL for App: ", lpApp->szName );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	push	edx
	push	OFFSET $SG14064
	call	_TraceLineS@8
$LN66@fnDeleteAp:

; 1996 : 
; 1997 :    fnFreeDataspace( lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1998 :    return( 0 );

	xor	eax, eax
$LN1@fnDeleteAp:

; 1999 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDeleteApp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
tv570 = -1336						; size = 4
tv1115 = -1332						; size = 4
_lpTempTable$1 = -1328					; size = 4
tv1130 = -1324						; size = 4
tv291 = -1320						; size = 4
tv290 = -1316						; size = 4
tv274 = -1312						; size = 4
tv463 = -1308						; size = 4
tv686 = -1304						; size = 4
$T2 = -1300						; size = 4
$T3 = -1296						; size = 4
tv488 = -1292						; size = 4
tv487 = -1288						; size = 4
tv464 = -1284						; size = 4
tv273 = -1280						; size = 4
tv440 = -1276						; size = 4
tv439 = -1272						; size = 4
tv416 = -1268						; size = 4
tv415 = -1264						; size = 4
tv392 = -1260						; size = 4
tv391 = -1256						; size = 4
tv368 = -1252						; size = 4
tv367 = -1248						; size = 4
tv344 = -1244						; size = 4
tv343 = -1240						; size = 4
tv323 = -1236						; size = 4
tv322 = -1232						; size = 4
tv307 = -1228						; size = 4
tv306 = -1224						; size = 4
_lpCurrContext$4 = -1220				; size = 4
_lpNextContext$5 = -1216				; size = 4
_lpCurrDomain$ = -1212					; size = 4
_lpNextDomain$ = -1208					; size = 4
tv1071 = -1204						; size = 4
tv1019 = -1200						; size = 4
tv926 = -1196						; size = 4
tv921 = -1192						; size = 4
_hDomain$6 = -1188					; size = 4
_hApp$ = -1184						; size = 4
_hContext$7 = -1180					; size = 4
_lpLName$ = -1176					; size = 4
_nLineNbr$ = -1172					; size = 2
_pvFile$ = -1168					; size = 4
_lpNLS_TableEntry$ = -1164				; size = 4
_nEOF$ = -1160						; size = 4
_lpRegExpression$ = -1156				; size = 4
_k$8 = -1152						; size = 2
_bLName$ = -1145					; size = 1
_hFile$ = -1144						; size = 4
_nCurrState$ = -1140					; size = 2
_nCurrEntity$ = -1136					; size = 2
_lpTableEntry$ = -1132					; size = 4
_hTemp$ = -1128						; size = 4
_bFound$ = -1121					; size = 1
_k$9 = -1120						; size = 2
_lpContext$ = -1116					; size = 4
_lpDomain$ = -1112					; size = 4
_lpApp$ = -1108						; size = 4
_pchLine$ = -1104					; size = 4
_szWorkString2$ = -1100					; size = 512
_szWorkString$ = -588					; size = 512
_szEntityName$ = -76					; size = 33
_szAttrName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_cpcAppName$ = 12					; size = 4
_fnCreateApp PROC

; 582  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1336				; 00000538H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 583  :    LPAPP             lpApp;
; 584  :    zPVOID            hApp;
; 585  :    zPVOID            hTemp;
; 586  :    zPVOID            pvFile;
; 587  :    LPDOMAIN          lpDomain;
; 588  :    LPDOMAIN          lpCurrDomain;
; 589  :    zLONG             hFile;
; 590  :    zCHAR             szWorkString[ zMAX_FILESPEC_LTH ];  // prevent overflow in
; 591  :    zCHAR             szWorkString2[ zMAX_FILESPEC_LTH ]; // fnConvertEnvironnentString
; 592  :    zPCHAR            pchLine;
; 593  :    zSHORT            nCurrState;
; 594  :    zSHORT            nCurrEntity;
; 595  :    zSHORT            nLineNbr;
; 596  :    zCHAR             szEntityName[ 33 ];
; 597  :    zCHAR             szAttrName[ 33 ];
; 598  :    zLPCONTEXT        lpContext;
; 599  :    LPTABLEENTRY      lpTableEntry;
; 600  :    LPNLSTABLEENTRY   lpNLS_TableEntry;
; 601  :    LPREGEXPRESSION   lpRegExpression;
; 602  :    LPLNAME           lpLName;
; 603  :    LPDOMAIN          lpNextDomain;
; 604  :    zBOOL             bFound;
; 605  :    zBOOL             bLName;
; 606  :    int               nEOF;
; 607  : // zCHAR             chMainTask;  // debugging only dks 2005.12.01
; 608  : 
; 609  :    if ( AnchorBlock == 0 || lpTask == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN45@fnCreateAp
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN44@fnCreateAp
$LN45@fnCreateAp:

; 610  :       return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp
$LN44@fnCreateAp:

; 611  : 
; 612  :    // debugging only dks 2005.12.01
; 613  : // if ( zGETHNDL( lpTask ) == AnchorBlock->hMainTask )
; 614  : //    chMainTask = 'Y';
; 615  : // else
; 616  : //    chMainTask = 0;
; 617  : 
; 618  :    // If no application name was passed and the system application
; 619  :    // has been established, return the system application.
; 620  :    if ( (cpcAppName == 0 || cpcAppName[ 0 ] == 0) && AnchorBlock->hSystemApp )

	cmp	DWORD PTR _cpcAppName$[ebp], 0
	je	SHORT $LN47@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcAppName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN46@fnCreateAp
$LN47@fnCreateAp:
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+110], 0
	je	SHORT $LN46@fnCreateAp

; 621  :       return( zGETPTR( AnchorBlock->hSystemApp ) );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+110]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	jmp	$LN207@fnCreateAp
$LN46@fnCreateAp:

; 622  : 
; 623  :    if ( cpcAppName ) // if not a call to load system app

	cmp	DWORD PTR _cpcAppName$[ebp], 0
	je	$LN48@fnCreateAp

; 624  :    {
; 625  :       // First see if application is already running
; 626  :       for ( lpApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+126]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax
	jmp	SHORT $LN4@fnCreateAp
$LN2@fnCreateAp:

; 628  :             lpApp = zGETPTR( lpApp->hNextApp ) )

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax
$LN4@fnCreateAp:

; 627  :             lpApp;

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN3@fnCreateAp

; 629  :       {
; 630  :          if ( zstrcmpi( lpApp->szName, cpcAppName ) == 0 )

	mov	edx, DWORD PTR _cpcAppName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN49@fnCreateAp

; 631  :             return( lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	jmp	$LN207@fnCreateAp
$LN49@fnCreateAp:

; 632  :       }

	jmp	SHORT $LN2@fnCreateAp
$LN3@fnCreateAp:

; 633  : 
; 634  :       // Next see if application is defined to system.
; 635  :       zstrcpy( szWorkString, AnchorBlock->szZeidonLocal );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 138				; 0000008aH
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 636  :       zstrcat( szWorkString, szlAppFile );

	mov	eax, DWORD PTR _szlAppFile
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 637  : 
; 638  :       // Open Application definition file.
; 639  :       bFound = FALSE;

	mov	BYTE PTR _bFound$[ebp], 0

; 640  :       hFile = fnSysOpenFile( lpTask, szWorkString, COREFILE_READ );

	push	128					; 00000080H
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 641  :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN50@fnCreateAp

; 642  :       {
; 643  :          // "KZOEE009 - Error opening application definition file"
; 644  :          fnIssueCoreError( lpTask, 0, 16, 9, 0, szWorkString, 0 );

	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	push	0
	push	9
	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 645  :          return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp
$LN50@fnCreateAp:

; 646  :       }
; 647  : 
; 648  :       // Read in application definition information.
; 649  :       pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 650  :       nEOF = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$[ebp], eax
$LN5@fnCreateAp:

; 651  :       while ( nEOF > 0 )

	cmp	DWORD PTR _nEOF$[ebp], 0
	jle	$LN6@fnCreateAp

; 652  :       {
; 653  :          if ( zstrncmp( pchLine + 1, szlAPPLICATION, 11 ) == 0 )

	push	11					; 0000000bH
	mov	ecx, DWORD PTR _szlAPPLICATION
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN51@fnCreateAp
$LN7@fnCreateAp:

; 654  :          {
; 655  :             while ( (nEOF = fnSysReadLine( lpTask, &pchLine,
; 656  :                                            hFile, &pvFile )) > 0 )

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$[ebp], eax
	cmp	DWORD PTR _nEOF$[ebp], 0
	jle	SHORT $LN8@fnCreateAp

; 657  :             {
; 658  :                if ( zstrncmp( pchLine + 1, szlAPP_NAME, 8 ) == 0 )

	push	8
	mov	ecx, DWORD PTR _szlAPP_NAME
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN52@fnCreateAp

; 659  :                {
; 660  :                   SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12

; 661  :                   if ( zstrcmpi( pchLine, cpcAppName ) == 0  )

	mov	eax, DWORD PTR _cpcAppName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN53@fnCreateAp

; 662  :                      bFound = TRUE;  //  Set found flag

	mov	BYTE PTR _bFound$[ebp], 1
$LN53@fnCreateAp:

; 663  : 
; 664  :                   break;          //  Break to Application search

	jmp	SHORT $LN8@fnCreateAp
$LN52@fnCreateAp:

; 665  :                }
; 666  :             }

	jmp	$LN7@fnCreateAp
$LN8@fnCreateAp:

; 667  : 
; 668  :             if ( bFound )

	movzx	edx, BYTE PTR _bFound$[ebp]
	test	edx, edx
	je	SHORT $LN51@fnCreateAp

; 669  :                break;   // Break to main line

	jmp	SHORT $LN6@fnCreateAp
$LN51@fnCreateAp:

; 670  :          }
; 671  : 
; 672  :          nEOF = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$[ebp], eax

; 673  :       }

	jmp	$LN5@fnCreateAp
$LN6@fnCreateAp:

; 674  : 
; 675  :       // If the application was not found, issue an error and exit.
; 676  :       if ( bFound == FALSE )

	movzx	ecx, BYTE PTR _bFound$[ebp]
	test	ecx, ecx
	jne	SHORT $LN48@fnCreateAp

; 677  :       {
; 678  :          // "KZOEE010 - Requested application not found in "
; 679  :          fnSysCloseFile( lpTask, hFile, 0 );  // Close the Appl Defn file

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 680  :          fnIssueCoreError( lpTask, 0, 16, 10, 0, szlAppFile, cpcAppName );

	mov	ecx, DWORD PTR _cpcAppName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlAppFile
	push	edx
	push	0
	push	10					; 0000000aH
	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 681  :          return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp
$LN48@fnCreateAp:

; 682  :       }
; 683  :    }
; 684  : 
; 685  :    // Otherwise, create the named application (under ANCHORBLOCK mutex).
; 686  :    hApp = (LPAPP) fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,

	push	10003					; 00002713H
	push	0
	push	1
	push	1909					; 00000775H
	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hApp$[ebp], eax

; 687  :                                     sizeof( AppRecord ), 1, 0, iApp );
; 688  :    if ( hApp == 0 )

	cmp	DWORD PTR _hApp$[ebp], 0
	jne	SHORT $LN56@fnCreateAp

; 689  :       return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp
$LN56@fnCreateAp:

; 690  : 
; 691  :    lpApp = zGETPTR( hApp );

	mov	edx, DWORD PTR _hApp$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 692  :    bLName = FALSE;

	mov	BYTE PTR _bLName$[ebp], 0

; 693  :    if ( cpcAppName )   // look for the user application

	cmp	DWORD PTR _cpcAppName$[ebp], 0
	je	$LN57@fnCreateAp

; 694  :    {
; 695  :       if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN59@fnCreateAp

; 696  :          TraceLine( "(APP) About to create app (0x%08x): %s (%s)  for Task: 0x%08x   Process: %d",

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcAppName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hApp$[ebp]
	push	edx
	push	OFFSET $SG13700
	call	_TraceLine
	add	esp, 24					; 00000018H
$LN59@fnCreateAp:

; 697  :                     hApp, cpcAppName, pchLine, zGETHNDL( lpTask ), SysGetProcessID( 0 ) );
; 698  : 
; 699  :       zstrcpy( lpApp->szName, pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	call	_strcpy
	add	esp, 8

; 700  : 
; 701  :       // Load up libraries for application.
; 702  :       nEOF = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	edx, DWORD PTR _pvFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$[ebp], eax
$LN9@fnCreateAp:

; 703  :       while ( nEOF > 0 )

	cmp	DWORD PTR _nEOF$[ebp], 0
	jle	$LN10@fnCreateAp

; 704  :       {
; 705  :          if ( pchLine[ 0 ] == 'e' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 101				; 00000065H
	jne	$LN60@fnCreateAp

; 706  :          {
; 707  :             if ( zstrncmp( pchLine + 1, szlLNAME, 5 ) != 0 )

	push	5
	mov	ecx, DWORD PTR _szlLNAME
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN61@fnCreateAp

; 708  :                break;

	jmp	$LN10@fnCreateAp
$LN61@fnCreateAp:

; 709  : 
; 710  :             bLName = TRUE;

	mov	BYTE PTR _bLName$[ebp], 1

; 711  : 
; 712  :             // Otherwise, create the named application (under ANCHORBLOCK mutex).
; 713  :             hTemp = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10041					; 00002739H
	push	0
	push	1
	push	74					; 0000004aH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTemp$[ebp], eax

; 714  :                                       sizeof( LNameRecord ), 1, 0, iLName );
; 715  :             if ( hTemp )

	cmp	DWORD PTR _hTemp$[ebp], 0
	je	SHORT $LN60@fnCreateAp

; 716  :             {
; 717  :                lpLName = zGETPTR( hTemp );

	mov	edx, DWORD PTR _hTemp$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLName$[ebp], eax

; 718  : 
; 719  :                lpApp->hFirstLName = hTemp;

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR _hTemp$[ebp]
	mov	DWORD PTR [eax+1897], ecx

; 720  :                lpLName->hNextLName = lpApp->hFirstLName;

	mov	edx, DWORD PTR _lpLName$[ebp]
	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+1897]
	mov	DWORD PTR [edx+2], ecx
$LN60@fnCreateAp:

; 721  :             }
; 722  :          }
; 723  : 
; 724  :          if ( pchLine[ 0 ] == 'a' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 97					; 00000061H
	jne	$LN63@fnCreateAp

; 725  :          {
; 726  :             SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12
$LN11@fnCreateAp:

; 727  : 
; 728  :             // Get rid of leading spaces in pchLine.
; 729  :             while ( *pchLine && *pchLine == ' ' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN12@fnCreateAp
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN12@fnCreateAp

; 730  :                pchLine++;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx
	jmp	SHORT $LN11@fnCreateAp
$LN12@fnCreateAp:

; 731  : 
; 732  :             if ( *pchLine == 0 )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN64@fnCreateAp

; 733  :             {
; 734  :                // Do nothing.
; 735  :             }

	jmp	$LN63@fnCreateAp
$LN64@fnCreateAp:

; 736  :             else
; 737  :             if ( bLName )

	movzx	ecx, BYTE PTR _bLName$[ebp]
	test	ecx, ecx
	je	$LN66@fnCreateAp

; 738  :             {
; 739  :                if ( lpLName )

	cmp	DWORD PTR _lpLName$[ebp], 0
	je	$LN68@fnCreateAp

; 740  :                {
; 741  :                   if ( zstrcmp( szWorkString, szlTYPE ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlTYPE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN210@fnCreateAp
	mov	edx, DWORD PTR _szlTYPE
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv274[ebp], eax
	jmp	SHORT $LN211@fnCreateAp
$LN210@fnCreateAp:
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	mov	edx, DWORD PTR _szlTYPE
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN208@fnCreateAp
	mov	DWORD PTR tv273[ebp], 1
	jmp	SHORT $LN209@fnCreateAp
$LN208@fnCreateAp:
	mov	DWORD PTR tv273[ebp], -1
$LN209@fnCreateAp:
	mov	ecx, DWORD PTR tv273[ebp]
	mov	DWORD PTR tv274[ebp], ecx
$LN211@fnCreateAp:
	cmp	DWORD PTR tv274[ebp], 0
	jne	SHORT $LN69@fnCreateAp

; 742  :                      lpLName->nType = (zSHORT) zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpLName$[ebp]
	mov	WORD PTR [ecx+6], ax
	jmp	$LN68@fnCreateAp
$LN69@fnCreateAp:

; 743  :                   else
; 744  :                   if ( zstrcmp( szWorkString, szlLNAME ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlLNAME
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN214@fnCreateAp
	mov	edx, DWORD PTR _szlLNAME
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv291[ebp], eax
	jmp	SHORT $LN215@fnCreateAp
$LN214@fnCreateAp:
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	mov	edx, DWORD PTR _szlLNAME
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN212@fnCreateAp
	mov	DWORD PTR tv290[ebp], 1
	jmp	SHORT $LN213@fnCreateAp
$LN212@fnCreateAp:
	mov	DWORD PTR tv290[ebp], -1
$LN213@fnCreateAp:
	mov	ecx, DWORD PTR tv290[ebp]
	mov	DWORD PTR tv291[ebp], ecx
$LN215@fnCreateAp:
	cmp	DWORD PTR tv291[ebp], 0
	jne	SHORT $LN71@fnCreateAp

; 745  :                      zstrcpy( lpLName->szLName, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLName$[ebp]
	add	eax, 8
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	$LN68@fnCreateAp
$LN71@fnCreateAp:

; 746  :                   else
; 747  :                   if ( zstrcmp( szWorkString, szlPNAME ) == 0 )

	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	mov	edx, DWORD PTR _szlPNAME
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN218@fnCreateAp
	mov	ecx, DWORD PTR _szlPNAME
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv307[ebp], eax
	jmp	SHORT $LN219@fnCreateAp
$LN218@fnCreateAp:
	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlPNAME
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN216@fnCreateAp
	mov	DWORD PTR tv306[ebp], 1
	jmp	SHORT $LN217@fnCreateAp
$LN216@fnCreateAp:
	mov	DWORD PTR tv306[ebp], -1
$LN217@fnCreateAp:
	mov	eax, DWORD PTR tv306[ebp]
	mov	DWORD PTR tv307[ebp], eax
$LN219@fnCreateAp:
	cmp	DWORD PTR tv307[ebp], 0
	jne	SHORT $LN68@fnCreateAp

; 748  :                      zstrcpy( lpLName->szPName, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLName$[ebp]
	add	edx, 41					; 00000029H
	push	edx
	call	_strcpy
	add	esp, 8
$LN68@fnCreateAp:

; 749  :                }
; 750  :             }

	jmp	$LN63@fnCreateAp
$LN66@fnCreateAp:

; 751  :             else
; 752  :             if ( zstrcmp( szWorkString, szlAPP_DFLT_Dialog ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_DFLT_Dialog
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN222@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_DFLT_Dialog
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv323[ebp], eax
	jmp	SHORT $LN223@fnCreateAp
$LN222@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_DFLT_Dialog
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN220@fnCreateAp
	mov	DWORD PTR tv322[ebp], 1
	jmp	SHORT $LN221@fnCreateAp
$LN220@fnCreateAp:
	mov	DWORD PTR tv322[ebp], -1
$LN221@fnCreateAp:
	mov	edx, DWORD PTR tv322[ebp]
	mov	DWORD PTR tv323[ebp], edx
$LN223@fnCreateAp:
	cmp	DWORD PTR tv323[ebp], 0
	jne	SHORT $LN74@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+39]
	test	eax, eax
	jne	SHORT $LN74@fnCreateAp

; 753  :                  lpApp->szDefaultDialog[ 0 ] == 0 )
; 754  :             {
; 755  :                zstrcpy( lpApp->szDefaultDialog, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 39					; 00000027H
	push	edx
	call	_strcpy
	add	esp, 8

; 756  :             }

	jmp	$LN63@fnCreateAp
$LN74@fnCreateAp:

; 757  :             else
; 758  :             if ( zstrcmp( szWorkString, szlAPP_DLL ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_DLL
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN226@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_DLL
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv344[ebp], eax
	jmp	SHORT $LN227@fnCreateAp
$LN226@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_DLL
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN224@fnCreateAp
	mov	DWORD PTR tv343[ebp], 1
	jmp	SHORT $LN225@fnCreateAp
$LN224@fnCreateAp:
	mov	DWORD PTR tv343[ebp], -1
$LN225@fnCreateAp:
	mov	edx, DWORD PTR tv343[ebp]
	mov	DWORD PTR tv344[ebp], edx
$LN227@fnCreateAp:
	cmp	DWORD PTR tv344[ebp], 0
	jne	SHORT $LN76@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+90]
	test	eax, eax
	jne	SHORT $LN76@fnCreateAp

; 759  :                  lpApp->szLibraryDir[ 0 ] == 0 )
; 760  :             {
; 761  :                SysAppendcDirSep( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 762  :                fnConvertEnvironmentString( szWorkString2, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 763  :                zstrcpy( lpApp->szLibraryDir, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 90					; 0000005aH
	push	edx
	call	_strcpy
	add	esp, 8

; 764  :             }

	jmp	$LN63@fnCreateAp
$LN76@fnCreateAp:

; 765  :             else
; 766  :             if ( zstrcmp( szWorkString, szlAPP_ADOBIN ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_ADOBIN
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN230@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_ADOBIN
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv368[ebp], eax
	jmp	SHORT $LN231@fnCreateAp
$LN230@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_ADOBIN
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN228@fnCreateAp
	mov	DWORD PTR tv367[ebp], 1
	jmp	SHORT $LN229@fnCreateAp
$LN228@fnCreateAp:
	mov	DWORD PTR tv367[ebp], -1
$LN229@fnCreateAp:
	mov	edx, DWORD PTR tv367[ebp]
	mov	DWORD PTR tv368[ebp], edx
$LN231@fnCreateAp:
	cmp	DWORD PTR tv368[ebp], 0
	jne	SHORT $LN78@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+347]
	test	eax, eax
	jne	SHORT $LN78@fnCreateAp

; 767  :                  lpApp->szObjectDir[ 0 ] == 0 )
; 768  :             {
; 769  :                SysAppendcDirSep( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 770  :                fnConvertEnvironmentString( szWorkString2, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 771  :                zstrcpy( lpApp->szObjectDir, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	call	_strcpy
	add	esp, 8

; 772  :             }

	jmp	$LN63@fnCreateAp
$LN78@fnCreateAp:

; 773  :             else
; 774  :             if ( zstrcmp( szWorkString, szlAPP_LOCAL ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_LOCAL
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN234@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_LOCAL
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv392[ebp], eax
	jmp	SHORT $LN235@fnCreateAp
$LN234@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_LOCAL
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN232@fnCreateAp
	mov	DWORD PTR tv391[ebp], 1
	jmp	SHORT $LN233@fnCreateAp
$LN232@fnCreateAp:
	mov	DWORD PTR tv391[ebp], -1
$LN233@fnCreateAp:
	mov	edx, DWORD PTR tv391[ebp]
	mov	DWORD PTR tv392[ebp], edx
$LN235@fnCreateAp:
	cmp	DWORD PTR tv392[ebp], 0
	jne	SHORT $LN80@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+604]
	test	eax, eax
	jne	SHORT $LN80@fnCreateAp

; 775  :                  lpApp->szLocalDir[ 0 ] == 0 )
; 776  :             {
; 777  :                SysAppendcDirSep( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 778  :                fnConvertEnvironmentString( szWorkString2, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 779  :                zstrcpy( lpApp->szLocalDir, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 604				; 0000025cH
	push	edx
	call	_strcpy
	add	esp, 8

; 780  :             }

	jmp	$LN63@fnCreateAp
$LN80@fnCreateAp:

; 781  :             else
; 782  :             if ( zstrcmp( szWorkString, szlAPP_SHARED ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_SHARED
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN238@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_SHARED
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv416[ebp], eax
	jmp	SHORT $LN239@fnCreateAp
$LN238@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_SHARED
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN236@fnCreateAp
	mov	DWORD PTR tv415[ebp], 1
	jmp	SHORT $LN237@fnCreateAp
$LN236@fnCreateAp:
	mov	DWORD PTR tv415[ebp], -1
$LN237@fnCreateAp:
	mov	edx, DWORD PTR tv415[ebp]
	mov	DWORD PTR tv416[ebp], edx
$LN239@fnCreateAp:
	cmp	DWORD PTR tv416[ebp], 0
	jne	SHORT $LN82@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+861]
	test	eax, eax
	jne	SHORT $LN82@fnCreateAp

; 783  :                  lpApp->szSharedDir[ 0 ] == 0 )
; 784  :             {
; 785  :                SysAppendcDirSep( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 786  :                fnConvertEnvironmentString( szWorkString2, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 787  :                zstrcpy( lpApp->szSharedDir, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 861				; 0000035dH
	push	edx
	call	_strcpy
	add	esp, 8

; 788  :             }

	jmp	$LN63@fnCreateAp
$LN82@fnCreateAp:

; 789  :             else
; 790  :             if ( zstrcmp( szWorkString, szlAPP_QLPLR ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_QLPLR
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN242@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_QLPLR
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv440[ebp], eax
	jmp	SHORT $LN243@fnCreateAp
$LN242@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_QLPLR
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN240@fnCreateAp
	mov	DWORD PTR tv439[ebp], 1
	jmp	SHORT $LN241@fnCreateAp
$LN240@fnCreateAp:
	mov	DWORD PTR tv439[ebp], -1
$LN241@fnCreateAp:
	mov	edx, DWORD PTR tv439[ebp]
	mov	DWORD PTR tv440[ebp], edx
$LN243@fnCreateAp:
	cmp	DWORD PTR tv440[ebp], 0
	jne	SHORT $LN84@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+1118]
	test	eax, eax
	jne	SHORT $LN84@fnCreateAp

; 791  :                  lpApp->szQLPLR_Dir[ 0 ] == 0 )
; 792  :             {
; 793  :                SysAppendcDirSep( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 794  :                fnConvertEnvironmentString( szWorkString2, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 795  :                zstrcpy( lpApp->szQLPLR_Dir, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 1118				; 0000045eH
	push	edx
	call	_strcpy
	add	esp, 8

; 796  :             }

	jmp	$LN63@fnCreateAp
$LN84@fnCreateAp:

; 797  :             else
; 798  :             if ( zstrcmp( szWorkString, szlAPP_QXODS ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_QXODS
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN246@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_QXODS
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv464[ebp], eax
	jmp	SHORT $LN247@fnCreateAp
$LN246@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_QXODS
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN244@fnCreateAp
	mov	DWORD PTR tv463[ebp], 1
	jmp	SHORT $LN245@fnCreateAp
$LN244@fnCreateAp:
	mov	DWORD PTR tv463[ebp], -1
$LN245@fnCreateAp:
	mov	edx, DWORD PTR tv463[ebp]
	mov	DWORD PTR tv464[ebp], edx
$LN247@fnCreateAp:
	cmp	DWORD PTR tv464[ebp], 0
	jne	SHORT $LN86@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+1375]
	test	eax, eax
	jne	SHORT $LN86@fnCreateAp

; 799  :                  lpApp->szQXODS_Dir[ 0 ] == 0 )
; 800  :             {
; 801  :                SysAppendcDirSep( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 802  :                fnConvertEnvironmentString( szWorkString2, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 803  :                zstrcpy( lpApp->szQXODS_Dir, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 1375				; 0000055fH
	push	edx
	call	_strcpy
	add	esp, 8

; 804  :             }

	jmp	$LN63@fnCreateAp
$LN86@fnCreateAp:

; 805  :             else
; 806  :             if ( zstrcmp( szWorkString, szlAPP_SOURCE ) == 0 &&

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _szlAPP_SOURCE
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN250@fnCreateAp
	mov	eax, DWORD PTR _szlAPP_SOURCE
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv488[ebp], eax
	jmp	SHORT $LN251@fnCreateAp
$LN250@fnCreateAp:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	mov	eax, DWORD PTR _szlAPP_SOURCE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN248@fnCreateAp
	mov	DWORD PTR tv487[ebp], 1
	jmp	SHORT $LN249@fnCreateAp
$LN248@fnCreateAp:
	mov	DWORD PTR tv487[ebp], -1
$LN249@fnCreateAp:
	mov	edx, DWORD PTR tv487[ebp]
	mov	DWORD PTR tv488[ebp], edx
$LN251@fnCreateAp:
	cmp	DWORD PTR tv488[ebp], 0
	jne	SHORT $LN63@fnCreateAp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpApp$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+1632]
	test	eax, eax
	jne	SHORT $LN63@fnCreateAp

; 807  :                  lpApp->szSourceDir[ 0 ] == 0 )
; 808  :             {
; 809  :                SysAppendcDirSep( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 810  :                fnConvertEnvironmentString( szWorkString2, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 811  :                zstrcpy( lpApp->szSourceDir, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 1632				; 00000660H
	push	edx
	call	_strcpy
	add	esp, 8
$LN63@fnCreateAp:

; 812  :             }
; 813  :          }
; 814  : 
; 815  :          nEOF = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$[ebp], eax

; 816  :       }

	jmp	$LN9@fnCreateAp
$LN10@fnCreateAp:

; 817  :    }

	jmp	$LN58@fnCreateAp
$LN57@fnCreateAp:

; 818  :    else       // set up the system application
; 819  :    {
; 820  :       if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN89@fnCreateAp

; 821  :          TraceLineS( "(APP) About to create app = ", "Zeidon System" );

	push	OFFSET $SG13731
	push	OFFSET $SG13732
	call	_TraceLineS@8
$LN89@fnCreateAp:

; 822  : 
; 823  :       zstrcpy( lpApp->szName,       "Zeidon System" );

	push	OFFSET $SG13733
	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	call	_strcpy
	add	esp, 8

; 824  :       zstrcpy( lpApp->szObjectDir,  AnchorBlock->szZeidonSys );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 652				; 0000028cH
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	call	_strcpy
	add	esp, 8

; 825  :       zstrcpy( lpApp->szLibraryDir, AnchorBlock->szZeidonBin );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 395				; 0000018bH
	push	eax
	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 90					; 0000005aH
	push	ecx
	call	_strcpy
	add	esp, 8

; 826  :       zstrcpy( lpApp->szLocalDir,   AnchorBlock->szZeidonLoc );

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 909				; 0000038dH
	push	edx
	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 604				; 0000025cH
	push	eax
	call	_strcpy
	add	esp, 8

; 827  :       zstrcpy( lpApp->szSharedDir,  AnchorBlock->szZeidonShr );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 1166				; 0000048eH
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 861				; 0000035dH
	push	edx
	call	_strcpy
	add	esp, 8
$LN58@fnCreateAp:

; 828  :    }
; 829  : 
; 830  :    if ( cpcAppName )              // if not creating the system app

	cmp	DWORD PTR _cpcAppName$[ebp], 0
	je	SHORT $LN90@fnCreateAp

; 831  :       fnSysCloseFile( lpTask, hFile, 0 );  // Close the file

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12
$LN90@fnCreateAp:

; 832  : 
; 833  :    // Now that the application has been loaded, load the domains
; 834  :    // for the application
; 835  :    zstrcpy( szWorkString, "[App." );

	push	OFFSET $SG13735
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 836  :    zstrcpy( szWorkString + 5, lpApp->szName );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp+5]
	push	ecx
	call	_strcpy
	add	esp, 8

; 837  :    zstrcat( szWorkString, "]" );

	push	OFFSET $SG13736
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 838  :    szWorkString2[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 512			; 00000200H
	jae	SHORT $LN252@fnCreateAp
	jmp	SHORT $LN253@fnCreateAp
$LN252@fnCreateAp:
	call	___report_rangecheckfailure
$LN253@fnCreateAp:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szWorkString2$[ebp+edx], 0

; 839  : 
; 840  :    // Check to see if we should keep the app running at all times.
; 841  :    SysReadZeidonIni( -1, szWorkString, "KeepAlive", szWorkString2 );

	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	push	OFFSET $SG13737
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	push	-1
	call	_SysReadZeidonIni@16

; 842  :    if ( szWorkString2[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szWorkString2$[ebp+eax]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN91@fnCreateAp

; 843  :    {
; 844  :       lpApp->bKeepAlive = TRUE;

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+1905]
	or	eax, 1
	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [ecx+1905], eax

; 845  :       TraceLineS( "CreateApp KeepAlive: ", lpApp->szName );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	push	edx
	push	OFFSET $SG13739
	call	_TraceLineS@8
$LN91@fnCreateAp:

; 846  :    }
; 847  : 
; 848  :    // Look for the application group in the .ini file, and the
; 849  :    // Domains parameter.
; 850  :    if ( zstrchr( szWorkString, ' ' ) )

	push	32					; 00000020H
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN92@fnCreateAp

; 851  :    {
; 852  :       zSHORT k = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$8[ebp], ax
$LN13@fnCreateAp:

; 853  :       while( k-- )

	movsx	edx, WORD PTR _k$8[ebp]
	mov	DWORD PTR tv570[ebp], edx
	mov	ax, WORD PTR _k$8[ebp]
	sub	ax, 1
	mov	WORD PTR _k$8[ebp], ax
	cmp	DWORD PTR tv570[ebp], 0
	je	SHORT $LN92@fnCreateAp

; 854  :       {
; 855  :          if ( szWorkString[ k ] == ' ' )

	movsx	ecx, WORD PTR _k$8[ebp]
	movsx	edx, BYTE PTR _szWorkString$[ebp+ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN93@fnCreateAp

; 856  :             szWorkString[ k ] = '_';

	movsx	eax, WORD PTR _k$8[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 95	; 0000005fH
$LN93@fnCreateAp:

; 857  :       }

	jmp	SHORT $LN13@fnCreateAp
$LN92@fnCreateAp:

; 858  :    }
; 859  : 
; 860  :    SysReadZeidonIni( -1, szWorkString, "Domains", szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	push	OFFSET $SG13742
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	push	-1
	call	_SysReadZeidonIni@16

; 861  : 
; 862  :    // If there is directory separator then assume a path name is specified,
; 863  :    // otherwise, it hopefully is just a filename.ext.
; 864  :    if ( szWorkString2[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szWorkString2$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN94@fnCreateAp

; 865  :    {
; 866  :       if ( zstrchr( szWorkString2, cDirSep ) )

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN96@fnCreateAp

; 867  :          zstrcpy( szWorkString, szWorkString2 );

	lea	edx, DWORD PTR _szWorkString2$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN97@fnCreateAp
$LN96@fnCreateAp:

; 868  :       else
; 869  :       {
; 870  :          zstrcpy( szWorkString, lpApp->szObjectDir );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 347				; 0000015bH
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 871  :          SysAppendcDirSep( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 872  :          zstrcat( szWorkString, szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN97@fnCreateAp:

; 873  :       }
; 874  :    }

	jmp	SHORT $LN95@fnCreateAp
$LN94@fnCreateAp:

; 875  :    else
; 876  :    {
; 877  :       // Build the file name for the application domains.
; 878  :       zstrcpy( szWorkString, lpApp->szObjectDir );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 879  :       SysAppendcDirSep( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 880  :       zstrcat( szWorkString, szlDomainFile );

	mov	eax, DWORD PTR _szlDomainFile
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN95@fnCreateAp:

; 881  : #if 0 // DGC Removed 09/05/2002
; 882  :       if ( cpcAppName )
; 883  :          zstrcat( szWorkString, szlDomainFile );
; 884  :       else
; 885  :          zstrcat( szWorkString, szlSystemDomainFile );
; 886  : #endif
; 887  :    }
; 888  : 
; 889  :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN98@fnCreateAp

; 890  :       TraceLineS( "(ap) looking for domains with: ", szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	push	OFFSET $SG13748
	call	_TraceLineS@8
$LN98@fnCreateAp:

; 891  : 
; 892  :    // Open Domains definition file.
; 893  :    bFound = FALSE;

	mov	BYTE PTR _bFound$[ebp], 0

; 894  :    pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 895  :    hFile = fnSysOpenFile( lpTask, szWorkString, COREFILE_READ );

	push	128					; 00000080H
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 896  :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN99@fnCreateAp

; 897  :    {
; 898  :       if ( cpcAppName == 0 )    // the system app will run w/o domains

	cmp	DWORD PTR _cpcAppName$[ebp], 0
	jne	SHORT $LN100@fnCreateAp

; 899  :          return( lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	jmp	$LN207@fnCreateAp
$LN100@fnCreateAp:

; 900  : 
; 901  :       // "KZOEE011 - Error opening application domains file"
; 902  :       fnIssueCoreError( lpTask, 0, 20, 11, 0, szWorkString, cpcAppName );

	mov	ecx, DWORD PTR _cpcAppName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	push	0
	push	11					; 0000000bH
	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 903  :       fnDeleteApp( lpApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnDeleteApp
	add	esp, 4

; 904  :       return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp
$LN99@fnCreateAp:

; 905  :    }
; 906  : 
; 907  :    // Process the domain file.
; 908  :    nEOF = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	edx, DWORD PTR _pvFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$[ebp], eax

; 909  : 
; 910  :    lpDomain = 0;

	mov	DWORD PTR _lpDomain$[ebp], 0

; 911  :    nCurrEntity = 0;  // no Current entity

	xor	eax, eax
	mov	WORD PTR _nCurrEntity$[ebp], ax

; 912  :    nCurrState = 0;   // Indicate no object in focus

	xor	ecx, ecx
	mov	WORD PTR _nCurrState$[ebp], cx

; 913  : 
; 914  :    //
; 915  :    // nCurrState codes
; 916  :    //    1  we are looking at a entity object line item
; 917  :    //    2  we are looking at a attribute object line item
; 918  :    //   10  invalid entity type
; 919  :    //   99  blank line / invalid line item.
; 920  :    //
; 921  :    // nCurrEntity code
; 922  :    //    1  Domain
; 923  :    //    2  Context
; 924  :    //    3  TableEntry
; 925  :    //    4  RegularExpression
; 926  :    //
; 927  :    nLineNbr = 0;

	xor	edx, edx
	mov	WORD PTR _nLineNbr$[ebp], dx
$LN15@fnCreateAp:

; 928  :    while ( nEOF > 0 )

	cmp	DWORD PTR _nEOF$[ebp], 0
	jle	$LN16@fnCreateAp

; 929  :    {
; 930  :       zPVOID hDomain;
; 931  :       zPVOID hContext;
; 932  : 
; 933  :       nLineNbr++;

	mov	ax, WORD PTR _nLineNbr$[ebp]
	add	ax, 1
	mov	WORD PTR _nLineNbr$[ebp], ax

; 934  :       if ( pchLine[ 0 ] == 'e' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 101				; 00000065H
	jne	SHORT $LN101@fnCreateAp

; 935  :       {
; 936  :          SysParseLine( szEntityName, &pchLine, pchLine + 1 );

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	call	_SysParseLine@12

; 937  :          nCurrState = 1;      // entity line item

	mov	edx, 1
	mov	WORD PTR _nCurrState$[ebp], dx

; 938  :       }

	jmp	$LN102@fnCreateAp
$LN101@fnCreateAp:

; 939  :       else
; 940  :       if ( pchLine[ 0 ] == 'a' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 97					; 00000061H
	jne	$LN103@fnCreateAp

; 941  :       {
; 942  :          zSHORT k;
; 943  : 
; 944  :          // We've got an attribute value.  Some attribute values may have
; 945  :          // leading spaces, so we need to do some special processing and we
; 946  :          // can't use SysParseLine.
; 947  :          for ( k = 0; !zisspace( pchLine[ k + 1 ] ) && pchLine[ k + 1 ]; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$9[ebp], cx
	jmp	SHORT $LN19@fnCreateAp
$LN17@fnCreateAp:
	mov	dx, WORD PTR _k$9[ebp]
	add	dx, 1
	mov	WORD PTR _k$9[ebp], dx
$LN19@fnCreateAp:
	movsx	eax, WORD PTR _k$9[ebp]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+1]
	push	edx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@fnCreateAp
	movsx	eax, WORD PTR _k$9[ebp]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+1]
	test	edx, edx
	je	SHORT $LN18@fnCreateAp

; 948  :             szAttrName[ k ] = pchLine[ k + 1 ];

	movsx	eax, WORD PTR _k$9[ebp]
	movsx	ecx, WORD PTR _k$9[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	al, BYTE PTR [edx+eax+1]
	mov	BYTE PTR _szAttrName$[ebp+ecx], al
	jmp	SHORT $LN17@fnCreateAp
$LN18@fnCreateAp:

; 949  : 
; 950  :          // Set the null term for the attr name.
; 951  :          szAttrName[ k ] = 0;

	movsx	ecx, WORD PTR _k$9[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 33			; 00000021H
	jae	SHORT $LN254@fnCreateAp
	jmp	SHORT $LN255@fnCreateAp
$LN254@fnCreateAp:
	call	___report_rangecheckfailure
$LN255@fnCreateAp:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szAttrName$[ebp+edx], 0

; 952  : 
; 953  :          // Check for a null attribute value.
; 954  :          if ( pchLine[ k + 1 ] == 0 )

	movsx	eax, WORD PTR _k$9[ebp]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+1]
	test	edx, edx
	jne	SHORT $LN105@fnCreateAp

; 955  :             pchLine = pchLine + k + 1;

	movsx	eax, WORD PTR _k$9[ebp]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchLine$[ebp], edx
	jmp	SHORT $LN106@fnCreateAp
$LN105@fnCreateAp:

; 956  :          else
; 957  :          {
; 958  :             // We have an attribute value.  First make sure we've skipped the
; 959  :             // appropriate number of spaces.  Example lines:
; 960  :             //    aZKey      89226532
; 961  :             //    aExternalValue Income
; 962  :             if ( k < 10 )

	movsx	eax, WORD PTR _k$9[ebp]
	cmp	eax, 10					; 0000000aH
	jge	SHORT $LN107@fnCreateAp

; 963  :                pchLine = pchLine + 11;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 11					; 0000000bH
	mov	DWORD PTR _pchLine$[ebp], ecx
	jmp	SHORT $LN106@fnCreateAp
$LN107@fnCreateAp:

; 964  :             else
; 965  :                pchLine = pchLine + k + 2;

	movsx	edx, WORD PTR _k$9[ebp]
	mov	eax, DWORD PTR _pchLine$[ebp]
	lea	ecx, DWORD PTR [eax+edx+2]
	mov	DWORD PTR _pchLine$[ebp], ecx
$LN106@fnCreateAp:

; 966  :          }
; 967  : 
; 968  :          nCurrState = 2;   // attribute line item

	mov	edx, 2
	mov	WORD PTR _nCurrState$[ebp], dx

; 969  :       }

	jmp	SHORT $LN102@fnCreateAp
$LN103@fnCreateAp:

; 970  :       else
; 971  :          nCurrState = 99;  // undefined or blank line

	mov	eax, 99					; 00000063H
	mov	WORD PTR _nCurrState$[ebp], ax
$LN102@fnCreateAp:

; 972  : 
; 973  :       switch ( nCurrState )

	movsx	ecx, WORD PTR _nCurrState$[ebp]
	mov	DWORD PTR tv686[ebp], ecx
	cmp	DWORD PTR tv686[ebp], 1
	je	SHORT $LN109@fnCreateAp
	cmp	DWORD PTR tv686[ebp], 2
	je	$LN137@fnCreateAp
	jmp	$LN20@fnCreateAp
$LN109@fnCreateAp:

; 974  :       {
; 975  :          case 1:
; 976  :             // We have the beginning of an Entity object.
; 977  :             if ( zstrcmpi( szEntityName, szlDOMAIN ) == 0 )

	mov	edx, DWORD PTR _szlDOMAIN
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN110@fnCreateAp

; 978  :             {
; 979  :                // Create the domain (under ANCHORBLOCK mutex).
; 980  :                hDomain = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10004					; 00002714H
	push	0
	push	1
	push	147					; 00000093H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hDomain$6[ebp], eax

; 981  :                                            sizeof( DomainRecord ), 1, 0, iDomain );
; 982  : 
; 983  :                if ( hDomain )

	cmp	DWORD PTR _hDomain$6[ebp], 0
	je	$LN112@fnCreateAp

; 984  :                {
; 985  :                   lpDomain = zGETPTR( hDomain );

	mov	eax, DWORD PTR _hDomain$6[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 986  : 
; 987  :                   lpDomain->hApp = hApp;

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR _hApp$[ebp]
	mov	DWORD PTR [ecx+43], edx

; 988  :                   lpDomain->hNextDomain = lpApp->hFirstDomain;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+2], edx

; 989  :                   lpApp->hFirstDomain = hDomain;

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR _hDomain$6[ebp]
	mov	DWORD PTR [eax+72], ecx

; 990  :                   nCurrEntity = 1;  // indicate working with Domain Entity

	mov	edx, 1
	mov	WORD PTR _nCurrEntity$[ebp], dx

; 991  :                   lpContext = 0;

	mov	DWORD PTR _lpContext$[ebp], 0

; 992  :                   lpTableEntry = 0;

	mov	DWORD PTR _lpTableEntry$[ebp], 0

; 993  :                   lpNLS_TableEntry = 0;

	mov	DWORD PTR _lpNLS_TableEntry$[ebp], 0

; 994  :                   lpRegExpression = 0;

	mov	DWORD PTR _lpRegExpression$[ebp], 0

; 995  :                   nCurrState = 1;   // indicate we are working on a Domain object

	mov	eax, 1
	mov	WORD PTR _nCurrState$[ebp], ax

; 996  :                   break;

	jmp	$LN20@fnCreateAp
$LN112@fnCreateAp:

; 997  :                }
; 998  : 
; 999  :                // "KZOEE012 - Error allocating memory"
; 1000 :                fnIssueCoreError( lpTask, 0, 20, 12, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	push	0
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1001 :                fnDeleteApp( lpApp );

	mov	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_fnDeleteApp
	add	esp, 4

; 1002 :                return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp

; 1003 :             }

	jmp	$LN137@fnCreateAp
$LN110@fnCreateAp:

; 1004 :             else
; 1005 :             if ( zstrcmpi( szEntityName, szlCONTEXT ) == 0 )

	mov	eax, DWORD PTR _szlCONTEXT
	push	eax
	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN113@fnCreateAp

; 1006 :             {
; 1007 :                // Create the context (under ANCHORBLOCK mutex).
; 1008 :                hContext = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10030					; 0000272eH
	push	0
	push	1
	push	69					; 00000045H
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hContext$7[ebp], eax

; 1009 :                                             sizeof( ContextRecord ), 1, 0,
; 1010 :                                             iContext );
; 1011 :                if ( hContext )

	cmp	DWORD PTR _hContext$7[ebp], 0
	je	SHORT $LN115@fnCreateAp

; 1012 :                {
; 1013 :                   lpContext = zGETPTR( hContext );

	mov	ecx, DWORD PTR _hContext$7[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpContext$[ebp], eax

; 1014 :                   lpContext->hDomain = hDomain;

	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	eax, DWORD PTR _hDomain$6[ebp]
	mov	DWORD PTR [edx+43], eax

; 1015 :                   lpContext->hNextContext = lpDomain->hFirstContext;

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR [edx+47]
	mov	DWORD PTR [ecx+2], eax

; 1016 :                   lpContext->nDisplayLength = -1;

	or	ecx, -1
	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	WORD PTR [edx+67], cx

; 1017 :                   lpDomain->hFirstContext = hContext;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR _hContext$7[ebp]
	mov	DWORD PTR [eax+47], ecx

; 1018 :                   lpTableEntry = 0;

	mov	DWORD PTR _lpTableEntry$[ebp], 0

; 1019 :                   lpNLS_TableEntry = 0;

	mov	DWORD PTR _lpNLS_TableEntry$[ebp], 0

; 1020 :                   lpRegExpression = 0;

	mov	DWORD PTR _lpRegExpression$[ebp], 0

; 1021 :                   nCurrEntity = 2;  // indicate working with Context Entity

	mov	edx, 2
	mov	WORD PTR _nCurrEntity$[ebp], dx

; 1022 :                   break;

	jmp	$LN20@fnCreateAp
$LN115@fnCreateAp:

; 1023 :                }
; 1024 : 
; 1025 :                // "KZOEE012 - Error allocating memory"
; 1026 :                fnIssueCoreError( lpTask, 0, 20, 12, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1027 :                fnDeleteApp( lpApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnDeleteApp
	add	esp, 4

; 1028 :                return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp

; 1029 :             }

	jmp	$LN137@fnCreateAp
$LN113@fnCreateAp:

; 1030 :             else
; 1031 :             if ( zstrcmpi( szEntityName, szlTABLEENTRY ) == 0 )

	mov	edx, DWORD PTR _szlTABLEENTRY
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN116@fnCreateAp

; 1032 :             {
; 1033 :                // Create the table entry (under ANCHORBLOCK mutex).
; 1034 :                hTemp = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10031					; 0000272fH
	push	0
	push	1
	push	30					; 0000001eH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTemp$[ebp], eax

; 1035 :                                          sizeof( TableEntryRecord ), 1, 0,
; 1036 :                                          iTableEntry );
; 1037 :                if ( hTemp )

	cmp	DWORD PTR _hTemp$[ebp], 0
	je	$LN118@fnCreateAp

; 1038 :                {
; 1039 :                   lpTableEntry = zGETPTR( hTemp );

	mov	eax, DWORD PTR _hTemp$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$[ebp], eax

; 1040 :                   lpTableEntry->hContext = hContext;

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR _hContext$7[ebp]
	mov	DWORD PTR [ecx+14], edx

; 1041 : 
; 1042 :                   if ( lpDomain->cType == zTYPE_INTEGER ||

	mov	eax, DWORD PTR _lpDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+63]
	cmp	ecx, 76					; 0000004cH
	je	SHORT $LN120@fnCreateAp
	mov	edx, DWORD PTR _lpDomain$[ebp]
	movsx	eax, BYTE PTR [edx+63]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN119@fnCreateAp
$LN120@fnCreateAp:

; 1043 :                        lpDomain->cType == zTYPE_DECIMAL )
; 1044 :                   {
; 1045 :                      lpTableEntry->unInternal.lInteger = lNullInteger;

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR _lNullInteger
	mov	DWORD PTR [ecx+26], edx
$LN119@fnCreateAp:

; 1046 :                   }
; 1047 : 
; 1048 :                   if ( lpContext->hLastTableEntry )

	mov	eax, DWORD PTR _lpContext$[ebp]
	cmp	DWORD PTR [eax+51], 0
	je	SHORT $LN121@fnCreateAp

; 1049 :                   {
; 1050 :                      LPTABLEENTRY lpTempTable;
; 1051 : 
; 1052 :                      lpTempTable = zGETPTR( lpContext->hLastTableEntry );

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+51]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempTable$1[ebp], eax

; 1053 :                      lpTempTable->hNextTableEntry = hTemp;

	mov	eax, DWORD PTR _lpTempTable$1[ebp]
	mov	ecx, DWORD PTR _hTemp$[ebp]
	mov	DWORD PTR [eax+2], ecx
$LN121@fnCreateAp:

; 1054 :                   }
; 1055 : 
; 1056 :                   lpTableEntry->hPrevTableEntry = lpContext->hLastTableEntry;

	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR [eax+51]
	mov	DWORD PTR [edx+6], ecx

; 1057 :                   lpContext->hLastTableEntry = hTemp;

	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	eax, DWORD PTR _hTemp$[ebp]
	mov	DWORD PTR [edx+51], eax

; 1058 : 
; 1059 :                   if ( lpContext->hFirstTableEntry == 0 )

	mov	ecx, DWORD PTR _lpContext$[ebp]
	cmp	DWORD PTR [ecx+47], 0
	jne	SHORT $LN122@fnCreateAp

; 1060 :                      lpContext->hFirstTableEntry = hTemp;

	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	eax, DWORD PTR _hTemp$[ebp]
	mov	DWORD PTR [edx+47], eax
$LN122@fnCreateAp:

; 1061 : 
; 1062 :                   lpRegExpression = 0;

	mov	DWORD PTR _lpRegExpression$[ebp], 0

; 1063 :                   nCurrEntity = 3;  // indicate working with TableEntry Entity

	mov	ecx, 3
	mov	WORD PTR _nCurrEntity$[ebp], cx

; 1064 :                   break;

	jmp	$LN20@fnCreateAp
$LN118@fnCreateAp:

; 1065 :                }
; 1066 : 
; 1067 :                // "KZOEE012 - Error allocating memory"
; 1068 :                fnIssueCoreError( lpTask, 0, 20, 12, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1069 :                fnDeleteApp( lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnDeleteApp
	add	esp, 4

; 1070 :                return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp

; 1071 :             }

	jmp	$LN137@fnCreateAp
$LN116@fnCreateAp:

; 1072 :             else
; 1073 :             if ( zstrcmpi( szEntityName, szlNLS_TABLEENTRY ) == 0 )

	mov	ecx, DWORD PTR _szlNLS_TABLEENTRY
	push	ecx
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN123@fnCreateAp

; 1074 :             {
; 1075 :                // Don't do anything if there isn't a current table entry.
; 1076 :                if ( lpTableEntry )

	cmp	DWORD PTR _lpTableEntry$[ebp], 0
	je	$LN125@fnCreateAp

; 1077 :                {
; 1078 :                   // Create the table entry (under ANCHORBLOCK mutex).
; 1079 :                   hTemp = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10043					; 0000273bH
	push	0
	push	1
	push	12					; 0000000cH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTemp$[ebp], eax

; 1080 :                                             sizeof( NLS_TableEntryRecord ), 1, 0,
; 1081 :                                             iNLS_TableEntry );
; 1082 :                   if ( hTemp )

	cmp	DWORD PTR _hTemp$[ebp], 0
	je	SHORT $LN126@fnCreateAp

; 1083 :                   {
; 1084 :                      lpNLS_TableEntry = zGETPTR( hTemp );

	mov	edx, DWORD PTR _hTemp$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNLS_TableEntry$[ebp], eax

; 1085 : 
; 1086 :                      // Stick lpNLS_TableEntry in the chain.
; 1087 :                      lpNLS_TableEntry->hNextNLS_TableEntry =

	mov	eax, DWORD PTR _lpNLS_TableEntry$[ebp]
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	mov	DWORD PTR [eax+2], edx

; 1088 :                                             lpTableEntry->hFirstNLS_TableEntry;
; 1089 :                      lpTableEntry->hFirstNLS_TableEntry = hTemp;

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR _hTemp$[ebp]
	mov	DWORD PTR [eax+22], ecx

; 1090 : 
; 1091 :                      // indicate working with NLS_TableEntry Entity
; 1092 :                      nCurrEntity = 5;

	mov	edx, 5
	mov	WORD PTR _nCurrEntity$[ebp], dx

; 1093 : 
; 1094 :                      break;

	jmp	$LN20@fnCreateAp
$LN126@fnCreateAp:

; 1095 :                   }
; 1096 : 
; 1097 :                   // "KZOEE012 - Error allocating memory"
; 1098 :                   fnIssueCoreError( lpTask, 0, 20, 12, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1099 :                   fnDeleteApp( lpApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnDeleteApp
	add	esp, 4

; 1100 :                   return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp
$LN125@fnCreateAp:

; 1101 :                }
; 1102 :             }

	jmp	$LN137@fnCreateAp
$LN123@fnCreateAp:

; 1103 :             else
; 1104 :             if ( zstrcmpi( szEntityName, szlREGULAREXPRESSION ) == 0 )

	mov	edx, DWORD PTR _szlREGULAREXPRESSION
	push	edx
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN127@fnCreateAp

; 1105 :             {
; 1106 :                if ( lpDomain && lpContext )

	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	$LN129@fnCreateAp
	cmp	DWORD PTR _lpContext$[ebp], 0
	je	$LN129@fnCreateAp

; 1107 :                {
; 1108 :                   // Create the regular expression entry (under ANCHORBLOCK mutex).
; 1109 :                   hTemp = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10032					; 00002730H
	push	0
	push	1
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTemp$[ebp], eax

; 1110 :                                             sizeof( RegExpressionRecord ), 1, 0,
; 1111 :                                             iRegularExpression );
; 1112 :                   if ( hTemp )

	cmp	DWORD PTR _hTemp$[ebp], 0
	je	SHORT $LN130@fnCreateAp

; 1113 :                   {
; 1114 :                      lpRegExpression = zGETPTR( hTemp );

	mov	eax, DWORD PTR _hTemp$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRegExpression$[ebp], eax

; 1115 :                      lpRegExpression->hContext = hContext;

	mov	ecx, DWORD PTR _lpRegExpression$[ebp]
	mov	edx, DWORD PTR _hContext$7[ebp]
	mov	DWORD PTR [ecx+10], edx

; 1116 :                      lpRegExpression->hNextRegExpression =

	mov	eax, DWORD PTR _lpRegExpression$[ebp]
	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+55]
	mov	DWORD PTR [eax+2], edx

; 1117 :                                                 lpContext->hFirstRegExpression;
; 1118 :                      lpContext->hFirstRegExpression = hTemp;

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR _hTemp$[ebp]
	mov	DWORD PTR [eax+55], ecx

; 1119 : 
; 1120 :                      lpTableEntry = 0;

	mov	DWORD PTR _lpTableEntry$[ebp], 0

; 1121 :                      lpNLS_TableEntry = 0;

	mov	DWORD PTR _lpNLS_TableEntry$[ebp], 0

; 1122 :                      nCurrEntity = 4;  // indicate working with RegularExpression Entity

	mov	edx, 4
	mov	WORD PTR _nCurrEntity$[ebp], dx

; 1123 :                      break;

	jmp	$LN20@fnCreateAp
$LN130@fnCreateAp:

; 1124 :                   }
; 1125 : 
; 1126 :                   // "KZOEE012 - Error allocating memory"
; 1127 :                   fnIssueCoreError( lpTask, 0, 20, 12, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1128 :                   fnDeleteApp( lpApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnDeleteApp
	add	esp, 4

; 1129 :                   return( 0 );

	xor	eax, eax
	jmp	$LN207@fnCreateAp
$LN129@fnCreateAp:

; 1130 :                }
; 1131 :             }

	jmp	$LN137@fnCreateAp
$LN127@fnCreateAp:

; 1132 :             else
; 1133 :             if ( zstrcmpi( szEntityName, "ROOT" ) == 0 )

	push	OFFSET $SG13783
	lea	edx, DWORD PTR _szEntityName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN131@fnCreateAp

; 1134 :             {
; 1135 :                break;

	jmp	$LN20@fnCreateAp

; 1136 :             }

	jmp	$LN137@fnCreateAp
$LN131@fnCreateAp:

; 1137 :             else
; 1138 :             if ( zstrcmpi( szEntityName, "OBJECT" ) == 0 )

	push	OFFSET $SG13786
	lea	eax, DWORD PTR _szEntityName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN133@fnCreateAp

; 1139 :             {
; 1140 :                break;

	jmp	$LN20@fnCreateAp

; 1141 :             }

	jmp	$LN137@fnCreateAp
$LN133@fnCreateAp:

; 1142 :             else
; 1143 :             if ( zstrcmpi( szEntityName, "DomainGroup" ) == 0 )

	push	OFFSET $SG13789
	lea	ecx, DWORD PTR _szEntityName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN135@fnCreateAp

; 1144 :             {
; 1145 :                break;

	jmp	$LN20@fnCreateAp

; 1146 :             }

	jmp	SHORT $LN137@fnCreateAp
$LN135@fnCreateAp:

; 1147 :             else
; 1148 :             {
; 1149 :                // Invalid Entity Name in Domain object
; 1150 :                // "KZOEE018 - Error in Domain file "
; 1151 :                fnIssueCoreError( lpTask, 0, 16, 18, nLineNbr,

	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	movsx	eax, WORD PTR _nLineNbr$[ebp]
	push	eax
	push	18					; 00000012H
	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1152 :                                  szWorkString, 0 );
; 1153 :                lpDomain = 0;

	mov	DWORD PTR _lpDomain$[ebp], 0

; 1154 :                lpContext = 0;

	mov	DWORD PTR _lpContext$[ebp], 0

; 1155 :                lpTableEntry = 0;

	mov	DWORD PTR _lpTableEntry$[ebp], 0

; 1156 :                lpNLS_TableEntry = 0;

	mov	DWORD PTR _lpNLS_TableEntry$[ebp], 0

; 1157 :                lpRegExpression = 0;

	mov	DWORD PTR _lpRegExpression$[ebp], 0

; 1158 :                nCurrEntity = 0;

	xor	edx, edx
	mov	WORD PTR _nCurrEntity$[ebp], dx

; 1159 :                nCurrState = 0;

	xor	eax, eax
	mov	WORD PTR _nCurrState$[ebp], ax

; 1160 :                break;

	jmp	$LN20@fnCreateAp
$LN137@fnCreateAp:

; 1161 :             }
; 1162 : 
; 1163 :          case 2:
; 1164 :             // we have a attribute
; 1165 :             switch ( nCurrEntity )

	movsx	ecx, WORD PTR _nCurrEntity$[ebp]
	mov	DWORD PTR tv921[ebp], ecx
	mov	edx, DWORD PTR tv921[ebp]
	sub	edx, 1
	mov	DWORD PTR tv921[ebp], edx
	cmp	DWORD PTR tv921[ebp], 4
	ja	$LN20@fnCreateAp
	mov	eax, DWORD PTR tv921[ebp]
	jmp	DWORD PTR $LN258@fnCreateAp[eax*4]
$LN138@fnCreateAp:

; 1166 :             {
; 1167 :                case 1:
; 1168 :                   // Current Entity is Domain
; 1169 :                   if ( lpDomain == 0 )

	cmp	DWORD PTR _lpDomain$[ebp], 0
	jne	SHORT $LN139@fnCreateAp

; 1170 :                      break;   // no domain is 'active' skip this attribute

	jmp	$LN20@fnCreateAp
$LN139@fnCreateAp:

; 1171 : 
; 1172 :                   switch ( szAttrName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szAttrName$[ebp+edx]
	mov	DWORD PTR tv926[ebp], eax
	mov	ecx, DWORD PTR tv926[ebp]
	sub	ecx, 67					; 00000043H
	mov	DWORD PTR tv926[ebp], ecx
	cmp	DWORD PTR tv926[ebp], 23		; 00000017H
	ja	$LN24@fnCreateAp
	mov	edx, DWORD PTR tv926[ebp]
	movzx	eax, BYTE PTR $LN256@fnCreateAp[edx]
	jmp	DWORD PTR $LN259@fnCreateAp[eax*4]
$LN140@fnCreateAp:

; 1173 :                   {
; 1174 :                      case 'C':
; 1175 :                         if ( zstrcmpi( szAttrName, szlCONTEXTRESTRICTION ) == 0 )

	mov	ecx, DWORD PTR _szlCONTEXTRESTRICTION
	push	ecx
	lea	edx, DWORD PTR _szAttrName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN141@fnCreateAp

; 1176 :                            lpDomain->cContextRestriction = pchLine[ 0 ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	cl, BYTE PTR [eax+ecx]
	mov	BYTE PTR [edx+66], cl
$LN141@fnCreateAp:

; 1177 : 
; 1178 :                         break;

	jmp	$LN24@fnCreateAp
$LN142@fnCreateAp:

; 1179 : 
; 1180 :                      case 'D':
; 1181 :                         if ( zstrcmpi( szAttrName, szlDOMAINTYPE ) == 0 )

	mov	edx, DWORD PTR _szlDOMAINTYPE
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN143@fnCreateAp

; 1182 :                            lpDomain->cDomainType = pchLine[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax+65], dl
	jmp	$LN144@fnCreateAp
$LN143@fnCreateAp:

; 1183 :                         else
; 1184 :                         if ( zstrcmpi( szAttrName, szlDATATYPE ) == 0 )

	mov	eax, DWORD PTR _szlDATATYPE
	push	eax
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN145@fnCreateAp

; 1185 :                            lpDomain->cType = pchLine[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx+63], al
	jmp	$LN144@fnCreateAp
$LN145@fnCreateAp:

; 1186 :                         else
; 1187 :                         if ( zstrcmpi( szAttrName, szlDECIMALFORMAT ) == 0 )

	mov	ecx, DWORD PTR _szlDECIMALFORMAT
	push	ecx
	lea	edx, DWORD PTR _szAttrName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN147@fnCreateAp

; 1188 :                         {
; 1189 :                            lpDomain->lDecimalFormat = zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	DWORD PTR [ecx+133], eax

; 1190 :                            lpDomain->cDecimal = pchLine[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ecx+64], al

; 1191 :                         }

	jmp	SHORT $LN144@fnCreateAp
$LN147@fnCreateAp:

; 1192 :                         else
; 1193 :                         if ( zstrcmpi( szAttrName, szlDLL_NAME ) == 0 )

	mov	ecx, DWORD PTR _szlDLL_NAME
	push	ecx
	lea	edx, DWORD PTR _szAttrName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN144@fnCreateAp

; 1194 :                            zstrcpy( lpDomain->szLibraryName, pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 67					; 00000043H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN144@fnCreateAp:

; 1195 : 
; 1196 :                         break;

	jmp	$LN24@fnCreateAp

; 1197 : 
; 1198 :                      case 'L':
; 1199 : #if 0
; 1200 :                         if ( zstrcmpi( szAttrName, szlLTH ) == 0 )
; 1201 :                         {
; 1202 :                            lpDomain->ulLth = (zULONG) zatol( pchLine );
; 1203 :                            if ( lpDomain->cType == 'S' && lpDomain->ulLth )
; 1204 :                               lpDomain->ulLth++;
; 1205 :                         }
; 1206 : #endif
; 1207 :                         break;

	jmp	$LN24@fnCreateAp
$LN151@fnCreateAp:

; 1208 : 
; 1209 :                      case 'M':
; 1210 :                         if ( zstrcmpi( szAttrName, szlMAXSTRINGLTH ) == 0 )

	mov	edx, DWORD PTR _szlMAXSTRINGLTH
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN152@fnCreateAp

; 1211 :                            lpDomain->ulMaxStringLth = (zULONG) zatol( pchLine ) + 1;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	add	eax, 1
	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	DWORD PTR [edx+59], eax
$LN152@fnCreateAp:

; 1212 : 
; 1213 :                         break;

	jmp	$LN24@fnCreateAp
$LN153@fnCreateAp:

; 1214 : 
; 1215 :                      case 'N':
; 1216 :                         if ( zstrcmpi( szAttrName, szlNAME ) == 0 )

	mov	eax, DWORD PTR _szlNAME
	push	eax
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN154@fnCreateAp

; 1217 :                            zstrcpy( lpDomain->szName, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	call	_strcpy
	add	esp, 8
$LN154@fnCreateAp:

; 1218 : 
; 1219 :                         break;

	jmp	$LN24@fnCreateAp
$LN155@fnCreateAp:

; 1220 : 
; 1221 :                      case 'O':
; 1222 :                         if ( zstrcmpi( szAttrName, "OPERNAME" ) == 0 )

	push	OFFSET $SG13811
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN156@fnCreateAp

; 1223 :                            zstrcpy( lpDomain->szDomainOper, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN157@fnCreateAp
$LN156@fnCreateAp:

; 1224 :                         else
; 1225 :                         if ( zstrcmpi( szAttrName, "OPERNUMBER" ) == 0 )

	push	OFFSET $SG13813
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN157@fnCreateAp

; 1226 :                            lpDomain->uOperNumber = (zUSHORT) zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	WORD PTR [ecx+145], ax
$LN157@fnCreateAp:

; 1227 : 
; 1228 :                         break;

	jmp	$LN24@fnCreateAp
$LN159@fnCreateAp:

; 1229 : 
; 1230 :                      case 'R':
; 1231 :                         if ( zstrcmpi( szAttrName, szlRESTRICTED ) == 0 &&

	mov	edx, DWORD PTR _szlRESTRICTED
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN160@fnCreateAp
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 89					; 00000059H
	je	SHORT $LN161@fnCreateAp
	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 121				; 00000079H
	jne	SHORT $LN160@fnCreateAp
$LN161@fnCreateAp:

; 1232 :                              (*pchLine == 'Y' || *pchLine == 'y') )
; 1233 :                         {
; 1234 :                            lpDomain->bRestricted = TRUE;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR [edx+141]
	or	eax, 1
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	DWORD PTR [ecx+141], eax
$LN160@fnCreateAp:

; 1235 :                         }
; 1236 : 
; 1237 :                         break;

	jmp	SHORT $LN24@fnCreateAp
$LN162@fnCreateAp:

; 1238 : 
; 1239 :                      case 'Z':
; 1240 :                         if ( zstrcmpi( szAttrName, szlZKEY ) == 0 )

	mov	edx, DWORD PTR _szlZKEY
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@fnCreateAp

; 1241 :                            lpDomain->lApDmTok = zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	DWORD PTR [edx+39], eax
$LN24@fnCreateAp:

; 1242 : 
; 1243 :                         break;
; 1244 :                   }
; 1245 : 
; 1246 :                   break;

	jmp	$LN20@fnCreateAp
$LN164@fnCreateAp:

; 1247 : 
; 1248 :                case 2:
; 1249 :                   // Current Entity is Context
; 1250 :                   if ( lpContext == 0 )

	cmp	DWORD PTR _lpContext$[ebp], 0
	jne	SHORT $LN165@fnCreateAp

; 1251 :                      break;   // no context is 'active' skip this attribute

	jmp	$LN20@fnCreateAp
$LN165@fnCreateAp:

; 1252 : 
; 1253 :                   switch ( szAttrName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szAttrName$[ebp+ecx]
	mov	DWORD PTR tv1019[ebp], edx
	mov	eax, DWORD PTR tv1019[ebp]
	sub	eax, 68					; 00000044H
	mov	DWORD PTR tv1019[ebp], eax
	cmp	DWORD PTR tv1019[ebp], 22		; 00000016H
	ja	$LN26@fnCreateAp
	mov	ecx, DWORD PTR tv1019[ebp]
	movzx	edx, BYTE PTR $LN257@fnCreateAp[ecx]
	jmp	DWORD PTR $LN260@fnCreateAp[edx*4]
$LN166@fnCreateAp:

; 1254 :                   {
; 1255 :                      case 'D':
; 1256 :                         if ( zstrcmpi( szAttrName, szlDECIMALFORMAT ) == 0 )

	mov	eax, DWORD PTR _szlDECIMALFORMAT
	push	eax
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN167@fnCreateAp

; 1257 :                            lpContext->lDecimalFormat = zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	DWORD PTR [ecx+63], eax
$LN167@fnCreateAp:

; 1258 : 
; 1259 :                         break;

	jmp	$LN26@fnCreateAp
$LN168@fnCreateAp:

; 1260 : 
; 1261 :                      case 'E':
; 1262 :                         if ( zstrcmpi( szAttrName, szlEDITSTRING ) == 0 )

	mov	edx, DWORD PTR _szlEDITSTRING
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN169@fnCreateAp

; 1263 :                         {
; 1264 :                            lpContext->hEditString =

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	DWORD PTR [ecx+59], eax
$LN169@fnCreateAp:

; 1265 :                              fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader,
; 1266 :                                                        pchLine );
; 1267 :                         }
; 1268 : 
; 1269 :                         break;

	jmp	$LN26@fnCreateAp
$LN170@fnCreateAp:

; 1270 : 
; 1271 :                      case 'I':
; 1272 :                         if ( zstrcmpi( szAttrName, szlISDEFAULT ) == 0 &&

	mov	edx, DWORD PTR _szlISDEFAULT
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN171@fnCreateAp
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 89					; 00000059H
	je	SHORT $LN172@fnCreateAp
	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 121				; 00000079H
	jne	SHORT $LN171@fnCreateAp
$LN172@fnCreateAp:

; 1273 :                              (*pchLine == 'Y' || *pchLine == 'y') )
; 1274 :                         {
; 1275 :                            if ( lpDomain->lDefaultContextZKey )

	mov	edx, DWORD PTR _lpDomain$[ebp]
	cmp	DWORD PTR [edx+137], 0
	je	SHORT $LN173@fnCreateAp

; 1276 :                               TraceLineS( "(ap) More than one default Context for Domain: ",

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	push	OFFSET $SG13830
	call	_TraceLineS@8
	jmp	SHORT $LN171@fnCreateAp
$LN173@fnCreateAp:

; 1277 :                                           lpDomain->szName );
; 1278 :                            else
; 1279 :                               lpDomain->lDefaultContextZKey = lpContext->lContextTok;

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	eax, DWORD PTR [edx+39]
	mov	DWORD PTR [ecx+137], eax
$LN171@fnCreateAp:

; 1280 :                         }
; 1281 : 
; 1282 :                         break;

	jmp	SHORT $LN26@fnCreateAp
$LN175@fnCreateAp:

; 1283 : 
; 1284 :                      case 'N':
; 1285 :                         if ( zstrcmpi( szAttrName, szlNAME ) == 0 )

	mov	ecx, DWORD PTR _szlNAME
	push	ecx
	lea	edx, DWORD PTR _szAttrName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN176@fnCreateAp

; 1286 :                              zstrcpy( lpContext->szName, pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpContext$[ebp]
	add	ecx, 6
	push	ecx
	call	_strcpy
	add	esp, 8
$LN176@fnCreateAp:

; 1287 : 
; 1288 :                         break;

	jmp	SHORT $LN26@fnCreateAp
$LN177@fnCreateAp:

; 1289 : 
; 1290 :                      case 'Z':
; 1291 :                         if ( zstrcmpi( szAttrName, szlZKEY ) == 0 )

	mov	edx, DWORD PTR _szlZKEY
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN26@fnCreateAp

; 1292 :                              lpContext->lContextTok = zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	DWORD PTR [edx+39], eax
$LN26@fnCreateAp:

; 1293 : 
; 1294 :                         break;
; 1295 :                      }
; 1296 : 
; 1297 :                   break;

	jmp	$LN20@fnCreateAp
$LN179@fnCreateAp:

; 1298 : 
; 1299 :                case 3:
; 1300 :                   // Current Entity is TableEntry
; 1301 :                   if ( lpTableEntry == 0 )

	cmp	DWORD PTR _lpTableEntry$[ebp], 0
	jne	SHORT $LN180@fnCreateAp

; 1302 :                      break;   // no tableentry is 'active' skip this attribute

	jmp	$LN20@fnCreateAp
$LN180@fnCreateAp:

; 1303 : 
; 1304 :                   switch ( szAttrName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _szAttrName$[ebp+ecx]
	mov	BYTE PTR tv1071[ebp], dl
	cmp	BYTE PTR tv1071[ebp], 69		; 00000045H
	je	SHORT $LN181@fnCreateAp
	cmp	BYTE PTR tv1071[ebp], 73		; 00000049H
	je	SHORT $LN183@fnCreateAp
	cmp	BYTE PTR tv1071[ebp], 90		; 0000005aH
	je	$LN188@fnCreateAp
	jmp	$LN28@fnCreateAp
$LN181@fnCreateAp:

; 1305 :                   {
; 1306 :                      case 'E':
; 1307 :                         if ( zstrcmpi( szAttrName, szlEXTERNALVALUE ) == 0 )

	mov	eax, DWORD PTR _szlEXTERNALVALUE
	push	eax
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN182@fnCreateAp

; 1308 :                         {
; 1309 :                            lpTableEntry->hExternalValue =

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	mov	DWORD PTR [edx+18], eax
$LN182@fnCreateAp:

; 1310 :                              fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader,
; 1311 :                                                        pchLine );
; 1312 :                         }
; 1313 : 
; 1314 :                         break;

	jmp	$LN28@fnCreateAp
$LN183@fnCreateAp:

; 1315 : 
; 1316 :                      case 'I':
; 1317 :                         if ( zstrcmpi( szAttrName, szlINTERNALVALUE ) == 0 )

	mov	eax, DWORD PTR _szlINTERNALVALUE
	push	eax
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN184@fnCreateAp

; 1318 :                         {
; 1319 :                            if ( lpDomain->cType == zTYPE_INTEGER ||

	mov	edx, DWORD PTR _lpDomain$[ebp]
	movsx	eax, BYTE PTR [edx+63]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN187@fnCreateAp
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+63]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN185@fnCreateAp
$LN187@fnCreateAp:

; 1320 :                                 lpDomain->cType == zTYPE_DECIMAL )
; 1321 :                            {
; 1322 :                               lpTableEntry->unInternal.lInteger = zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 1323 :                            }

	jmp	SHORT $LN184@fnCreateAp
$LN185@fnCreateAp:

; 1324 :                            else
; 1325 :                            {
; 1326 :                               lpTableEntry->unInternal.hStringValue  =

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	mov	DWORD PTR [edx+26], eax
$LN184@fnCreateAp:

; 1327 :                                fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader,
; 1328 :                                                          pchLine );
; 1329 :                            }
; 1330 :                         }
; 1331 : 
; 1332 :                         break;

	jmp	SHORT $LN28@fnCreateAp
$LN188@fnCreateAp:

; 1333 : 
; 1334 :                      case 'Z':
; 1335 :                         if ( zstrcmpi( szAttrName, szlZKEY ) == 0 )

	mov	eax, DWORD PTR _szlZKEY
	push	eax
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN28@fnCreateAp

; 1336 :                            lpTableEntry->lTableEntryTok = zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	DWORD PTR [ecx+10], eax
$LN28@fnCreateAp:

; 1337 : 
; 1338 :                         break;
; 1339 :                   }
; 1340 : 
; 1341 :                   break;

	jmp	$LN20@fnCreateAp
$LN190@fnCreateAp:

; 1342 : 
; 1343 :                case 4:
; 1344 :                   // Current Entity is RegularExpression
; 1345 :                   if ( lpRegExpression == 0 )

	cmp	DWORD PTR _lpRegExpression$[ebp], 0
	jne	SHORT $LN191@fnCreateAp

; 1346 :                      break;   // no regular expression is 'active' skip this attr

	jmp	$LN20@fnCreateAp
$LN191@fnCreateAp:

; 1347 : 
; 1348 :                   switch ( szAttrName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szAttrName$[ebp+eax]
	mov	BYTE PTR tv1115[ebp], cl
	cmp	BYTE PTR tv1115[ebp], 90		; 0000005aH
	je	SHORT $LN192@fnCreateAp
	jmp	SHORT $LN30@fnCreateAp
$LN192@fnCreateAp:

; 1349 :                   {
; 1350 :                      case 'Z':
; 1351 :                         if ( zstrcmpi( szAttrName, szlZKEY ) == 0 )

	mov	edx, DWORD PTR _szlZKEY
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@fnCreateAp

; 1352 :                            lpTableEntry->lTableEntryTok = zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	mov	DWORD PTR [edx+10], eax
$LN30@fnCreateAp:

; 1353 : 
; 1354 :                      break;
; 1355 :                   }
; 1356 : 
; 1357 :                   break;

	jmp	$LN20@fnCreateAp
$LN194@fnCreateAp:

; 1358 : 
; 1359 :                case 5:
; 1360 :                   // Current Entity is NLS_TableEntry
; 1361 :                   if ( lpNLS_TableEntry == 0 )

	cmp	DWORD PTR _lpNLS_TableEntry$[ebp], 0
	jne	SHORT $LN195@fnCreateAp

; 1362 :                      break;   // no NLS table entry is 'active' skip this attr

	jmp	$LN20@fnCreateAp
$LN195@fnCreateAp:

; 1363 : 
; 1364 :                   switch ( szAttrName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _szAttrName$[ebp+ecx]
	mov	BYTE PTR tv1130[ebp], dl
	cmp	BYTE PTR tv1130[ebp], 76		; 0000004cH
	je	SHORT $LN196@fnCreateAp
	cmp	BYTE PTR tv1130[ebp], 84		; 00000054H
	je	SHORT $LN198@fnCreateAp
	jmp	SHORT $LN20@fnCreateAp
$LN196@fnCreateAp:

; 1365 :                   {
; 1366 :                      case 'L':
; 1367 :                         if ( zstrcmpi( szAttrName, szlLanguageIndex ) == 0 )

	mov	eax, DWORD PTR _szlLanguageIndex
	push	eax
	lea	ecx, DWORD PTR _szAttrName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN197@fnCreateAp

; 1368 :                            lpNLS_TableEntry->nLanguageCode = (zSHORT) zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpNLS_TableEntry$[ebp]
	mov	WORD PTR [ecx+10], ax
$LN197@fnCreateAp:

; 1369 : 
; 1370 :                         break;

	jmp	SHORT $LN20@fnCreateAp
$LN198@fnCreateAp:

; 1371 : 
; 1372 :                      case 'T':
; 1373 :                         if ( zstrcmpi( szAttrName, szlText ) == 0 )

	mov	edx, DWORD PTR _szlText
	push	edx
	lea	eax, DWORD PTR _szAttrName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@fnCreateAp

; 1374 :                         {
; 1375 :                            lpNLS_TableEntry->pszNLS_Text =

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpNLS_TableEntry$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN20@fnCreateAp:

; 1376 :                              fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader,
; 1377 :                                                        pchLine );
; 1378 :                         }
; 1379 : 
; 1380 :                         break;
; 1381 :                   }
; 1382 : 
; 1383 :                   break;
; 1384 :             }
; 1385 : 
; 1386 :             break;
; 1387 : 
; 1388 :          case 99:
; 1389 :             // invalid or blank lines... ignore
; 1390 :             break;
; 1391 : 
; 1392 :       } // end of switch( nCurrState )...
; 1393 : 
; 1394 :       nEOF = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	edx, DWORD PTR _pvFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$[ebp], eax

; 1395 :    }

	jmp	$LN15@fnCreateAp
$LN16@fnCreateAp:

; 1396 : 
; 1397 :    // Scan through domains.  Drop Domains and Contexts
; 1398 :    // that are unnamed.  For table entrys with an internal value, but no
; 1399 :    // external value have the external value point to the internal value.
; 1400 :    // Table entrys that do not have an internal value are dropped.
; 1401 : 
; 1402 :    lpCurrDomain = 0; // last valid domain, 0 means at head of queue

	mov	DWORD PTR _lpCurrDomain$[ebp], 0

; 1403 :    for ( lpDomain = zGETPTR( lpApp->hFirstDomain );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax
	jmp	SHORT $LN36@fnCreateAp
$LN34@fnCreateAp:

; 1405 :          lpDomain = zGETPTR( lpNextDomain ) )

	mov	edx, DWORD PTR _lpNextDomain$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax
$LN36@fnCreateAp:

; 1404 :          lpDomain;

	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	$LN35@fnCreateAp

; 1406 :    {
; 1407 :       zLPCONTEXT   lpCurrContext;
; 1408 :       zLPCONTEXT   lpNextContext;
; 1409 : 
; 1410 :       lpNextDomain = lpDomain->hNextDomain;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _lpNextDomain$[ebp], ecx

; 1411 : 
; 1412 :       if ( lpDomain->szName[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+6]
	test	edx, edx
	jne	$LN201@fnCreateAp

; 1413 :       {
; 1414 :          fnDeleteContext( lpDomain );  // delete all contexts

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	call	_fnDeleteContext
	add	esp, 4

; 1415 :          lpDomain = zGETPTR( lpApp->hFirstDomain );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 1416 :          fnDeleteContext( lpDomain );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	call	_fnDeleteContext
	add	esp, 4

; 1417 :          lpApp->hFirstDomain = lpDomain->hNextDomain;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+72], eax

; 1418 :          fnFreeDataspace( lpDomain );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 1419 :          if ( lpCurrDomain )

	cmp	DWORD PTR _lpCurrDomain$[ebp], 0
	je	SHORT $LN202@fnCreateAp

; 1420 :             lpCurrDomain->hNextDomain = lpNextDomain;

	mov	edx, DWORD PTR _lpCurrDomain$[ebp]
	mov	eax, DWORD PTR _lpNextDomain$[ebp]
	mov	DWORD PTR [edx+2], eax
	jmp	SHORT $LN203@fnCreateAp
$LN202@fnCreateAp:

; 1421 :          else
; 1422 :             lpApp->hFirstDomain = lpNextDomain;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR _lpNextDomain$[ebp]
	mov	DWORD PTR [ecx+72], edx
$LN203@fnCreateAp:

; 1423 : 
; 1424 :          continue;

	jmp	$LN34@fnCreateAp
$LN201@fnCreateAp:

; 1425 :       }
; 1426 : 
; 1427 :       lpCurrDomain = lpDomain;   // indicate curr domain as valid

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	DWORD PTR _lpCurrDomain$[ebp], eax

; 1428 :       lpCurrContext = 0;   // last valid context, 0 means at head of queue

	mov	DWORD PTR _lpCurrContext$4[ebp], 0

; 1429 :       for ( lpContext = zGETPTR( lpDomain->hFirstContext );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpContext$[ebp], eax
	jmp	SHORT $LN39@fnCreateAp
$LN37@fnCreateAp:

; 1431 :             lpContext = zGETPTR( lpNextContext ) )

	mov	eax, DWORD PTR _lpNextContext$5[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpContext$[ebp], eax
$LN39@fnCreateAp:

; 1430 :             lpContext;

	cmp	DWORD PTR _lpContext$[ebp], 0
	je	$LN38@fnCreateAp

; 1432 :       {
; 1433 :          lpNextContext = lpContext->hNextContext;

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR _lpNextContext$5[ebp], edx

; 1434 : 
; 1435 :          if ( lpContext->szName[ 0 ] == 0 )  // if no name, drop it!

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpContext$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+6]
	test	eax, eax
	jne	$LN204@fnCreateAp
$LN40@fnCreateAp:

; 1436 :          {
; 1437 :             // delete all table entries for this context
; 1438 :             while ( lpContext->hFirstTableEntry )

	mov	ecx, DWORD PTR _lpContext$[ebp]
	cmp	DWORD PTR [ecx+47], 0
	je	SHORT $LN42@fnCreateAp

; 1439 :             {
; 1440 :                hTemp = lpContext->hFirstTableEntry;

	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	eax, DWORD PTR [edx+47]
	mov	DWORD PTR _hTemp$[ebp], eax

; 1441 :                lpTableEntry = zGETPTR( lpContext->hFirstTableEntry );

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$[ebp], eax

; 1442 :                lpContext->hFirstTableEntry =

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _lpContext$[ebp]
	mov	DWORD PTR [edx+47], eax

; 1443 :                                     zGETPTR( lpTableEntry->hNextTableEntry );
; 1444 :                fnDropTableEntry( lpContext, hTemp, 0 );

	push	0
	mov	eax, DWORD PTR _hTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpContext$[ebp]
	push	ecx
	call	_fnDropTableEntry
	add	esp, 12					; 0000000cH

; 1445 :             }

	jmp	SHORT $LN40@fnCreateAp
$LN42@fnCreateAp:

; 1446 : 
; 1447 :             // Delete all regular expressions for this context.
; 1448 :             while ( lpContext->hFirstRegExpression )

	mov	edx, DWORD PTR _lpContext$[ebp]
	cmp	DWORD PTR [edx+55], 0
	je	SHORT $LN43@fnCreateAp

; 1449 :             {
; 1450 :                lpRegExpression = zGETPTR( lpContext->hFirstRegExpression );

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR [eax+55]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRegExpression$[ebp], eax

; 1451 :                lpContext->hFirstRegExpression =

	mov	edx, DWORD PTR _lpRegExpression$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	DWORD PTR [ecx+55], eax

; 1452 :                               zGETPTR( lpRegExpression->hNextRegExpression );
; 1453 :                fnFreeDataspace( lpRegExpression );

	mov	edx, DWORD PTR _lpRegExpression$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1454 :             }

	jmp	SHORT $LN42@fnCreateAp
$LN43@fnCreateAp:

; 1455 : 
; 1456 :             lpDomain->hFirstContext = lpContext->hNextContext;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+47], edx

; 1457 :             fnFreeDataspace( zGETPTR( lpContext->hEditString ) );

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR [eax+59]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1458 :             fnFreeDataspace( lpContext );

	mov	edx, DWORD PTR _lpContext$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1459 : 
; 1460 :             // Fix up the context chain.
; 1461 :             if ( lpCurrContext )

	cmp	DWORD PTR _lpCurrContext$4[ebp], 0
	je	SHORT $LN205@fnCreateAp

; 1462 :                lpCurrContext->hNextContext = lpNextContext;

	mov	eax, DWORD PTR _lpCurrContext$4[ebp]
	mov	ecx, DWORD PTR _lpNextContext$5[ebp]
	mov	DWORD PTR [eax+2], ecx
	jmp	SHORT $LN206@fnCreateAp
$LN205@fnCreateAp:

; 1463 :             else
; 1464 :                lpDomain->hFirstContext = lpNextContext;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR _lpNextContext$5[ebp]
	mov	DWORD PTR [edx+47], eax
$LN206@fnCreateAp:

; 1465 : 
; 1466 :             continue;

	jmp	$LN37@fnCreateAp
$LN204@fnCreateAp:

; 1467 :          }
; 1468 : 
; 1469 :          lpCurrContext = lpContext; // indicate curr context as valid

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	DWORD PTR _lpCurrContext$4[ebp], ecx

; 1470 : 
; 1471 : // DGC 2000.11.06
; 1472 : // I removed following code to allow external values to be null.
; 1473 : #if 0
; 1474 :          // Context has a name.  Go check each table entry.
; 1475 :          for ( lpTableEntry = zGETPTR( lpContext->hFirstTableEntry );
; 1476 :                lpTableEntry;
; 1477 :                lpTableEntry = zGETPTR( lpNextTableEntry ) )
; 1478 :          {
; 1479 :             lpNextTableEntry = lpTableEntry->hNextTableEntry;
; 1480 : 
; 1481 :             if ( lpDomain->cType == zTYPE_INTEGER ||
; 1482 :                  lpDomain->cType == zTYPE_DECIMAL )
; 1483 :             {
; 1484 :                if ( lpTableEntry->hExternalValue == 0 &&
; 1485 :                     lpTableEntry->unInternal.lInteger != lNullInteger )
; 1486 :                {
; 1487 :                   zCHAR szWork[ 16 ];
; 1488 : 
; 1489 :                   zltoa( lpTableEntry->unInternal.lInteger, szWork );
; 1490 :                   lpTableEntry->hExternalValue =
; 1491 :                    fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader,
; 1492 :                                              szWork );
; 1493 :                }
; 1494 : 
; 1495 :                continue;
; 1496 :             }
; 1497 : 
; 1498 :             if ( lpTableEntry->hExternalValue == 0 )
; 1499 :             {
; 1500 :                if ( lpTableEntry->unInternal.hStringValue )
; 1501 :                {
; 1502 :                   lpTableEntry->hExternalValue =
; 1503 :                                        lpTableEntry->unInternal.hStringValue;
; 1504 :                }
; 1505 :             }
; 1506 :          }
; 1507 : #endif
; 1508 :       }

	jmp	$LN37@fnCreateAp
$LN38@fnCreateAp:

; 1509 : 
; 1510 :    } // while ( lpDomain )...

	jmp	$LN34@fnCreateAp
$LN35@fnCreateAp:

; 1511 : 
; 1512 :    fnSysCloseFile( lpTask, hFile, 0 ); // Close the domain file

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 1513 : 
; 1514 :    // Add created app to anchor block list (under the ANCHORBLOCK mutex).
; 1515 :    lpApp->hNextApp = AnchorBlock->hFirstApp;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+126]
	mov	DWORD PTR [ecx+2], eax

; 1516 :    AnchorBlock->hFirstApp = hApp;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hApp$[ebp]
	mov	DWORD PTR [ecx+126], edx

; 1517 : 
; 1518 :    return( lpApp );         // return the application

	mov	eax, DWORD PTR _lpApp$[ebp]
$LN207@fnCreateAp:

; 1519 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN258@fnCreateAp:
	DD	$LN138@fnCreateAp
	DD	$LN164@fnCreateAp
	DD	$LN179@fnCreateAp
	DD	$LN190@fnCreateAp
	DD	$LN194@fnCreateAp
$LN259@fnCreateAp:
	DD	$LN140@fnCreateAp
	DD	$LN142@fnCreateAp
	DD	$LN151@fnCreateAp
	DD	$LN153@fnCreateAp
	DD	$LN155@fnCreateAp
	DD	$LN159@fnCreateAp
	DD	$LN162@fnCreateAp
	DD	$LN24@fnCreateAp
$LN256@fnCreateAp:
	DB	0
	DB	1
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	2
	DB	3
	DB	4
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
$LN260@fnCreateAp:
	DD	$LN166@fnCreateAp
	DD	$LN168@fnCreateAp
	DD	$LN170@fnCreateAp
	DD	$LN175@fnCreateAp
	DD	$LN177@fnCreateAp
	DD	$LN26@fnCreateAp
$LN257@fnCreateAp:
	DB	0
	DB	1
	DB	5
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
_fnCreateApp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_pchWdodPtr$ = -288					; size = 4
_pchApplPtr$ = -284					; size = 4
_pchPassPtr$ = -280					; size = 4
_pchUserPtr$ = -276					; size = 4
_pchCmdPtr$ = -272					; size = 4
_chSeparator$ = -265					; size = 1
_pchParsePtr$ = -264					; size = 4
_szWorkAppString$ = -260				; size = 256
__$ArrayPad$ = -4					; size = 4
_pchReturnApp$ = 8					; size = 4
_pchReturnDialog$ = 12					; size = 4
_pchReturnUserID$ = 16					; size = 4
_pchReturnPassword$ = 20				; size = 4
_pchReturnCommand$ = 24					; size = 4
_cpcAppString$ = 28					; size = 4
_fnParseAppString PROC

; 343  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 344  :    zPCHAR  pchParsePtr;
; 345  :    zPCHAR  pchApplPtr;
; 346  :    zPCHAR  pchWdodPtr;
; 347  :    zPCHAR  pchUserPtr;
; 348  :    zPCHAR  pchPassPtr;
; 349  :    zPCHAR  pchCmdPtr;
; 350  :    zCHAR   szWorkAppString[ 256 ];
; 351  :    zCHAR   chSeparator;
; 352  : 
; 353  :    // Null first byte in all return strings
; 354  :    pchReturnApp[ 0 ]      = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnApp$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 355  :    pchReturnDialog[ 0 ]   = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnDialog$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 356  :    pchReturnUserID[ 0 ]   = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnUserID$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 357  :    pchReturnPassword[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnPassword$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 358  :    pchReturnCommand[ 0 ]  = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnCommand$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 359  : 
; 360  :    // return if pointer is null
; 361  :    if ( cpcAppString == 0 || *cpcAppString == 0 )

	cmp	DWORD PTR _cpcAppString$[ebp], 0
	je	SHORT $LN19@fnParseApp
	mov	eax, DWORD PTR _cpcAppString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN18@fnParseApp
$LN19@fnParseApp:

; 362  :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnParseApp
$LN18@fnParseApp:

; 363  : 
; 364  :    // STEP2: Parse the initialization String
; 365  :    pchApplPtr  = 0;

	mov	DWORD PTR _pchApplPtr$[ebp], 0

; 366  :    pchWdodPtr  = 0;

	mov	DWORD PTR _pchWdodPtr$[ebp], 0

; 367  :    pchUserPtr  = 0;

	mov	DWORD PTR _pchUserPtr$[ebp], 0

; 368  :    pchPassPtr  = 0;

	mov	DWORD PTR _pchPassPtr$[ebp], 0

; 369  :    pchCmdPtr   = 0;

	mov	DWORD PTR _pchCmdPtr$[ebp], 0

; 370  : 
; 371  :    // Relocate the application string so we can edit it
; 372  :    zstrcpy( szWorkAppString, cpcAppString );

	mov	edx, DWORD PTR _cpcAppString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkAppString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 373  : 
; 374  :    // Get Pointers to Application Name and the Dialog Name
; 375  :    pchParsePtr = szWorkAppString;

	lea	ecx, DWORD PTR _szWorkAppString$[ebp]
	mov	DWORD PTR _pchParsePtr$[ebp], ecx
$LN2@fnParseApp:

; 376  :    while ( pchParsePtr[ 0 ] == ' ' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN3@fnParseApp

; 377  :       pchParsePtr++;

	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchParsePtr$[ebp], eax
	jmp	SHORT $LN2@fnParseApp
$LN3@fnParseApp:

; 378  : 
; 379  :    chSeparator = *pchParsePtr;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _chSeparator$[ebp], dl

; 380  :    if ( pchParsePtr[ 0 ] == chSeparator && pchParsePtr[ 1 ] == chSeparator )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _chSeparator$[ebp]
	cmp	eax, ecx
	jne	$LN20@fnParseApp
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	movsx	edx, BYTE PTR _chSeparator$[ebp]
	cmp	ecx, edx
	jne	$LN20@fnParseApp

; 381  :    {
; 382  :       pchParsePtr += 2;

	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	add	eax, 2
	mov	DWORD PTR _pchParsePtr$[ebp], eax

; 383  :       pchApplPtr = pchParsePtr;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	mov	DWORD PTR _pchApplPtr$[ebp], ecx
$LN4@fnParseApp:

; 384  :       while ( pchParsePtr[ 0 ] && pchParsePtr[ 0 ] != chSeparator )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN5@fnParseApp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _chSeparator$[ebp]
	cmp	eax, ecx
	je	SHORT $LN5@fnParseApp

; 385  :          pchParsePtr++;

	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchParsePtr$[ebp], edx
	jmp	SHORT $LN4@fnParseApp
$LN5@fnParseApp:

; 386  : 
; 387  :       if ( pchParsePtr[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN22@fnParseApp

; 388  :       {
; 389  :          pchParsePtr[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 390  :          pchParsePtr++;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchParsePtr$[ebp], ecx

; 391  :          if ( pchParsePtr[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN22@fnParseApp

; 392  :          {
; 393  :             if ( pchParsePtr[ 0 ] != ' ' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN24@fnParseApp

; 394  :             {
; 395  :                pchWdodPtr = pchParsePtr;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	mov	DWORD PTR _pchWdodPtr$[ebp], ecx

; 396  :             }

	jmp	SHORT $LN22@fnParseApp
$LN24@fnParseApp:

; 397  :             else
; 398  :             {
; 399  :                pchCmdPtr = pchParsePtr;

	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	mov	DWORD PTR _pchCmdPtr$[ebp], edx
$LN6@fnParseApp:

; 400  :                while ( pchCmdPtr[ 0 ] == ' ' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchCmdPtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN22@fnParseApp

; 401  :                   pchCmdPtr++;

	mov	ecx, DWORD PTR _pchCmdPtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchCmdPtr$[ebp], ecx
	jmp	SHORT $LN6@fnParseApp
$LN22@fnParseApp:

; 402  :             }
; 403  :          }
; 404  :       }
; 405  :    }

	jmp	SHORT $LN21@fnParseApp
$LN20@fnParseApp:

; 406  :    else
; 407  :    {
; 408  :       return( -1 );  // since the separator is now assumed to be the first

	or	eax, -1
	jmp	$LN1@fnParseApp
$LN21@fnParseApp:

; 409  :                      // two characters of the application parameter, the
; 410  :                      // LPLR name must be specified (and therefore preceded
; 411  :                      // by two separator characters).
; 412  : //    pchWdodPtr = pchParsePtr;
; 413  :    }
; 414  : 
; 415  :    // Parse pointer is currently at the first byte of the Dialog
; 416  :    // Name.  Look for trailing null, separator, or blank which
; 417  :    // ends the Dialog Name.
; 418  : 
; 419  :    //  Get the UserID if supplied. First position past the Wdod pointer.
; 420  :    if ( pchCmdPtr == 0 )  // if Command found, we are done.

	cmp	DWORD PTR _pchCmdPtr$[ebp], 0
	jne	$LN26@fnParseApp
$LN8@fnParseApp:

; 421  :    {
; 422  :       while ( pchParsePtr[ 0 ] &&
; 423  :               pchParsePtr[ 0 ] != chSeparator &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN9@fnParseApp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _chSeparator$[ebp]
	cmp	eax, ecx
	je	SHORT $LN9@fnParseApp
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN9@fnParseApp

; 424  :               pchParsePtr[ 0 ] != ' ' )
; 425  :       {
; 426  :          pchParsePtr++;

	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchParsePtr$[ebp], eax

; 427  :       }

	jmp	SHORT $LN8@fnParseApp
$LN9@fnParseApp:

; 428  : 
; 429  :       // if there is a token, see if it is a UserID (denoted by a separator
; 430  :       // followed by a non-blank).
; 431  :       if ( pchParsePtr[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	$LN26@fnParseApp

; 432  :       {
; 433  :          if ( pchParsePtr[ 0 ] == chSeparator && pchParsePtr[ 1 ] &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	movsx	eax, BYTE PTR _chSeparator$[ebp]
	cmp	edx, eax
	jne	SHORT $LN28@fnParseApp
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN28@fnParseApp
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN28@fnParseApp

; 434  :               pchParsePtr[ 1 ] != ' ' )
; 435  :          {
; 436  :             pchUserPtr = pchParsePtr + 1;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchUserPtr$[ebp], ecx

; 437  :          }

	jmp	$LN29@fnParseApp
$LN28@fnParseApp:

; 438  :          else
; 439  :          if ( pchParsePtr[ 0 ] == ' ' ||

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN31@fnParseApp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _chSeparator$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN29@fnParseApp
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN29@fnParseApp
$LN31@fnParseApp:

; 440  :               (pchParsePtr[ 0 ] == chSeparator && pchParsePtr[ 1 ] == ' ') )
; 441  :          {
; 442  :             pchCmdPtr = pchParsePtr;

	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	mov	DWORD PTR _pchCmdPtr$[ebp], edx

; 443  :             if ( pchCmdPtr[ 0 ] == chSeparator )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchCmdPtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _chSeparator$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN10@fnParseApp

; 444  :                pchCmdPtr++;

	mov	edx, DWORD PTR _pchCmdPtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchCmdPtr$[ebp], edx
$LN10@fnParseApp:

; 445  : 
; 446  :             while ( pchCmdPtr[ 0 ] == ' ' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchCmdPtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN29@fnParseApp

; 447  :                pchCmdPtr++;

	mov	ecx, DWORD PTR _pchCmdPtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchCmdPtr$[ebp], ecx
	jmp	SHORT $LN10@fnParseApp
$LN29@fnParseApp:

; 448  :          }
; 449  : 
; 450  :          pchParsePtr[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 451  :          pchParsePtr++;

	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchParsePtr$[ebp], edx
$LN26@fnParseApp:

; 452  :       }
; 453  :    }
; 454  : 
; 455  :    // Get the Password if supplied.  First position past
; 456  :    // the UserID pointer.
; 457  :    if ( pchCmdPtr == 0 )  // if Command found, we are done

	cmp	DWORD PTR _pchCmdPtr$[ebp], 0
	jne	$LN33@fnParseApp

; 458  :    {
; 459  :       if ( pchUserPtr ) // if UserID found

	cmp	DWORD PTR _pchUserPtr$[ebp], 0
	je	SHORT $LN34@fnParseApp
$LN12@fnParseApp:

; 460  :       {
; 461  :          while ( pchParsePtr[ 0 ] && pchParsePtr[ 0 ] != chSeparator &&

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN34@fnParseApp
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	movsx	edx, BYTE PTR _chSeparator$[ebp]
	cmp	ecx, edx
	je	SHORT $LN34@fnParseApp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN34@fnParseApp

; 462  :                  pchParsePtr[ 0 ] != ' ' )
; 463  :          {
; 464  :             pchParsePtr++;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchParsePtr$[ebp], ecx

; 465  :          }

	jmp	SHORT $LN12@fnParseApp
$LN34@fnParseApp:

; 466  :       }
; 467  : 
; 468  :       // if there is a token, see if it is a Password (denoted by a separator
; 469  :       // followed by a non-blank).
; 470  :       if ( pchParsePtr[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	$LN33@fnParseApp

; 471  :       {
; 472  :          if ( pchParsePtr[ 0 ] == chSeparator &&
; 473  :               pchParsePtr[ 1 ] && pchParsePtr[ 1 ] != ' ' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _chSeparator$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN36@fnParseApp
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN36@fnParseApp
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN36@fnParseApp

; 474  :          {
; 475  :             pchPassPtr = pchParsePtr + 1;

	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchPassPtr$[ebp], edx
$LN36@fnParseApp:

; 476  :          }
; 477  : 
; 478  :          pchParsePtr[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 479  :          pchParsePtr++;

	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchParsePtr$[ebp], eax

; 480  : 
; 481  :          // finally, find the command, if any
; 482  :          if ( pchPassPtr )  // if Password found

	cmp	DWORD PTR _pchPassPtr$[ebp], 0
	je	$LN37@fnParseApp
$LN14@fnParseApp:

; 483  :          {
; 484  :             while ( pchParsePtr[ 0 ] && pchParsePtr[ 0 ] != ' ' &&

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN15@fnParseApp
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN15@fnParseApp
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, BYTE PTR _chSeparator$[ebp]
	cmp	eax, ecx
	je	SHORT $LN15@fnParseApp

; 485  :                     pchParsePtr[ 0 ] != chSeparator )
; 486  :             {
; 487  :                pchParsePtr++;

	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchParsePtr$[ebp], edx

; 488  :             }

	jmp	SHORT $LN14@fnParseApp
$LN15@fnParseApp:

; 489  : 
; 490  :             if ( pchParsePtr[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN37@fnParseApp

; 491  :             {
; 492  :                pchParsePtr[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 493  :                pchParsePtr++;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchParsePtr$[ebp], ecx
$LN37@fnParseApp:

; 494  :             }
; 495  :          }
; 496  : 
; 497  :          if ( pchParsePtr[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN33@fnParseApp
$LN16@fnParseApp:

; 498  :          {
; 499  :             while ( pchParsePtr[ 0 ] == ' ' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchParsePtr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN17@fnParseApp

; 500  :                pchParsePtr++;

	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchParsePtr$[ebp], ecx
	jmp	SHORT $LN16@fnParseApp
$LN17@fnParseApp:

; 501  : 
; 502  :             if ( pchParsePtr[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParsePtr$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN33@fnParseApp

; 503  :                pchCmdPtr = pchParsePtr;

	mov	eax, DWORD PTR _pchParsePtr$[ebp]
	mov	DWORD PTR _pchCmdPtr$[ebp], eax
$LN33@fnParseApp:

; 504  :          }
; 505  :       }
; 506  :    }
; 507  : 
; 508  : #if 0
; 509  :    TraceLineS( "Application parse Input String->", cpcAppString );
; 510  :    // Now trace out what we have found
; 511  :    if ( szApplPtr )
; 512  :       TraceLineS( "Application:", szApplPtr );
; 513  :    else
; 514  :       TraceLineS( "Application pointer is ", "NULL" );
; 515  : 
; 516  :    if ( szWdodPtr )
; 517  :       TraceLineS( "Dialog:", szWdodPtr );
; 518  :    else
; 519  :       TraceLineS( "Dialog pointer is ", "NULL" );
; 520  : 
; 521  :    if ( szUserPtr )
; 522  :       TraceLineS( "User:", pchUserPtr );
; 523  :    else
; 524  :       TraceLineS( "User pointer is ", "NULL" );
; 525  : 
; 526  :    if ( pchPassPtr )
; 527  :       TraceLineS( "Password:", pchPassPtr );
; 528  :    else
; 529  :       TraceLineS( "Password pointer is ", "NULL" );
; 530  : 
; 531  :    if ( pchCmdPtr )
; 532  :       TraceLineS( "Command:", pchCmdPtr );
; 533  :    else
; 534  :       TraceLineS( "Command pointer is", "NULL" );
; 535  : #endif
; 536  : 
; 537  :    // Copy the parameters found back for the caller
; 538  :    if ( pchApplPtr )

	cmp	DWORD PTR _pchApplPtr$[ebp], 0
	je	SHORT $LN41@fnParseApp

; 539  :       zstrcpy( pchReturnApp, pchApplPtr );

	mov	ecx, DWORD PTR _pchApplPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnApp$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN41@fnParseApp:

; 540  : 
; 541  :    if ( pchWdodPtr )

	cmp	DWORD PTR _pchWdodPtr$[ebp], 0
	je	SHORT $LN42@fnParseApp

; 542  :       zstrcpy( pchReturnDialog, pchWdodPtr );

	mov	eax, DWORD PTR _pchWdodPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnDialog$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN42@fnParseApp:

; 543  : 
; 544  :    if ( pchUserPtr )

	cmp	DWORD PTR _pchUserPtr$[ebp], 0
	je	SHORT $LN43@fnParseApp

; 545  :       zstrcpy( pchReturnUserID, pchUserPtr );

	mov	edx, DWORD PTR _pchUserPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnUserID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN43@fnParseApp:

; 546  : 
; 547  :    if ( pchPassPtr )

	cmp	DWORD PTR _pchPassPtr$[ebp], 0
	je	SHORT $LN44@fnParseApp

; 548  :       zstrcpy( pchReturnPassword, pchPassPtr );

	mov	ecx, DWORD PTR _pchPassPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnPassword$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN44@fnParseApp:

; 549  : 
; 550  :    if ( pchCmdPtr )

	cmp	DWORD PTR _pchCmdPtr$[ebp], 0
	je	SHORT $LN45@fnParseApp

; 551  :       zstrcpy( pchReturnCommand, pchCmdPtr );

	mov	eax, DWORD PTR _pchCmdPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnCommand$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN45@fnParseApp:

; 552  : 
; 553  :    return( 0 );

	xor	eax, eax
$LN1@fnParseApp:

; 554  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnParseAppString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpApp$ = 8						; size = 4
_lpView$ = 12						; size = 4
_SfGetApplicationForSubtask@8 PROC

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 250  :    LPTASK lpCurrentTask;
; 251  :    zSHORT nRC;
; 252  : 
; 253  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 254  :    if ( (lpCurrentTask = fnOperationCall( iSfGetApplicationForSubtask,
; 255  :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	21					; 00000015H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfGetAppli

; 256  :    {
; 257  :       *lpApp = 0;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [ecx], 0

; 258  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfGetAppli
$LN2@SfGetAppli:

; 259  :    }
; 260  : 
; 261  :    nRC = fnGetApplicationForSubtask( lpApp, lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8
	mov	WORD PTR _nRC$[ebp], ax

; 262  : 
; 263  :    fnOperationReturn( iSfGetApplicationForSubtask, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	21					; 00000015H
	call	_fnOperationReturn
	add	esp, 8

; 264  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfGetAppli:

; 265  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfGetApplicationForSubtask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_lpSubtask$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpApp$ = 12						; size = 4
_SfSetApplicationForSubtask@8 PROC

; 288  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 289  :    LPTASK    lpCurrentTask;
; 290  :    LPSUBTASK lpSubtask;
; 291  :    zSHORT    nRC;
; 292  : 
; 293  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 294  :    if ( (lpCurrentTask = fnOperationCall( iSfSetApplicationForSubtask,
; 295  :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	22					; 00000016H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfSetAppli

; 296  :    {
; 297  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfSetAppli
$LN2@SfSetAppli:

; 298  :    }
; 299  : 
; 300  :    if ( lpView->hSubtask )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN3@SfSetAppli

; 301  :    {
; 302  :       lpSubtask = zGETPTR( lpView->hSubtask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 303  :       lpSubtask->hApp = zGETHNDL( lpApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	DWORD PTR [edx+10], eax

; 304  :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 305  :    }

	jmp	SHORT $LN4@SfSetAppli
$LN3@SfSetAppli:

; 306  :    else
; 307  :       nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN4@SfSetAppli:

; 308  : 
; 309  :    fnOperationReturn( iSfSetApplicationForSubtask, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	22					; 00000016H
	call	_fnOperationReturn
	add	esp, 8

; 310  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfSetAppli:

; 311  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfSetApplicationForSubtask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_pvWork$ = -28						; size = 4
_pOper$ = -24						; size = 4
_lpViewOD$ = -20					; size = 4
_lpTaskDBHandler$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpQualObj$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcUser$ = 12						; size = 4
_cpcPassword$ = 16					; size = 4
_SetDatabaseUser@12 PROC

; 2025 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2026 :    LPTASKDBHANDLER lpTaskDBHandler;
; 2027 :    LPTASK          lpCurrentTask;
; 2028 :    LPVIEWOD        lpViewOD;
; 2029 :    zPDBHOPER       pOper;
; 2030 :    zVIEW           lpQualObj = 0;

	mov	DWORD PTR _lpQualObj$[ebp], 0

; 2031 :    zPVOID          pvWork;
; 2032 :    zSHORT          nRC;
; 2033 : 
; 2034 :    // If task not active or disabled, return zCALL_ERROR.
; 2035 :    if ( (lpCurrentTask = fnOperationCall( iSetDatabaseUser, lpView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	29					; 0000001dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SetDatabas

; 2036 :    {
; 2037 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetDatabas
$LN2@SetDatabas:

; 2038 :    }
; 2039 : 
; 2040 :    nRC = SfActivateSysEmptyOI( &lpQualObj, "KZDBHQUA", lpView, zMULTIPLE );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG14084
	lea	edx, DWORD PTR _lpQualObj$[ebp]
	push	edx
	call	_SfActivateSysEmptyOI@16
	mov	WORD PTR _nRC$[ebp], ax

; 2041 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN3@SetDatabas

; 2042 :    {
; 2043 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 2044 :       goto EndOfFunction;

	jmp	$EndOfFunction$9
$LN3@SetDatabas:

; 2045 :    }
; 2046 : 
; 2047 :    if ( cpcUser == 0 || zstrlen( cpcUser ) > 32 ||
; 2048 :         cpcPassword == 0 || zstrlen( cpcPassword ) > 32 ||

	cmp	DWORD PTR _cpcUser$[ebp], 0
	je	SHORT $LN5@SetDatabas
	mov	edx, DWORD PTR _cpcUser$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	ja	SHORT $LN5@SetDatabas
	cmp	DWORD PTR _cpcPassword$[ebp], 0
	je	SHORT $LN5@SetDatabas
	mov	eax, DWORD PTR _cpcPassword$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 32					; 00000020H
	ja	SHORT $LN5@SetDatabas
	lea	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnGetDBHandlerOper@12
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $LN4@SetDatabas
$LN5@SetDatabas:

; 2049 :         (lpTaskDBHandler = fnGetDBHandlerOper( lpCurrentTask, lpView, &pOper )) == 0 )
; 2050 :    {
; 2051 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 2052 :       goto EndOfFunction;

	jmp	$EndOfFunction$9
$LN4@SetDatabas:

; 2053 :    }
; 2054 : 
; 2055 :    TraceLine( "SetDatabaseUser: %s for task: 0x%08x", cpcUser, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcUser$[ebp]
	push	eax
	push	OFFSET $SG14088
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 2056 : 
; 2057 :    CreateEntity( lpQualObj, "EntitySpec", zPOS_FIRST );

	push	1
	push	OFFSET $SG14089
	mov	ecx, DWORD PTR _lpQualObj$[ebp]
	push	ecx
	call	_CreateEntity@12

; 2058 : 
; 2059 :    // Store user in EntityName.
; 2060 :    SetAttributeFromString( lpQualObj, "EntitySpec", "EntityName", cpcUser );

	mov	edx, DWORD PTR _cpcUser$[ebp]
	push	edx
	push	OFFSET $SG14090
	push	OFFSET $SG14091
	mov	eax, DWORD PTR _lpQualObj$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 2061 : 
; 2062 :    // Store password in Options.
; 2063 :    SetAttributeFromString( lpQualObj, "EntitySpec", "Options", cpcPassword );

	mov	ecx, DWORD PTR _cpcPassword$[ebp]
	push	ecx
	push	OFFSET $SG14092
	push	OFFSET $SG14093
	mov	edx, DWORD PTR _lpQualObj$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 2064 : 
; 2065 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2066 :    nRC = (*pOper)( (zLONG) lpView->hTask,

	lea	edx, DWORD PTR _pvWork$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	513					; 00000201H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 2067 :                    DBH_Database | DBH_SetUser, 0, lpViewOD,
; 2068 :                    0, lpView, lpQualObj, &pvWork );
; 2069 : 
; 2070 :    // nRC = 0 ==> success
; 2071 :    // nRC = 1 ==> unsuccessful, can't close DB because of transaction running
; 2072 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $EndOfFunction$9

; 2073 :    {
; 2074 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$9:

; 2075 :       goto EndOfFunction;
; 2076 :    }
; 2077 : 
; 2078 : EndOfFunction:
; 2079 :    if ( lpQualObj )

	cmp	DWORD PTR _lpQualObj$[ebp], 0
	je	SHORT $LN7@SetDatabas

; 2080 :       DropView( lpQualObj );

	mov	ecx, DWORD PTR _lpQualObj$[ebp]
	push	ecx
	call	_DropView@4
$LN7@SetDatabas:

; 2081 : 
; 2082 :    fnOperationReturn( iSetDatabaseUser, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	29					; 0000001dH
	call	_fnOperationReturn
	add	esp, 8

; 2083 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetDatabas:

; 2084 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetDatabaseUser@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeapaa.c
_TEXT	SEGMENT
_lpViewOD$1 = -28					; size = 4
_lpSubtask$2 = -24					; size = 4
tv87 = -20						; size = 4
_lpCurrentTask$ = -16					; size = 4
_pchDirectory$ = -12					; size = 4
_lpApp$ = -8						; size = 4
_nRC$ = -4						; size = 2
_pchReturnDirectory$ = 8				; size = 4
_lpView$ = 12						; size = 4
_nDirectory$ = 16					; size = 2
_nMaxLth$ = 20						; size = 2
_GetApplDirectoryFromView@16 PROC

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 83   :    LPTASK lpCurrentTask;
; 84   :    LPAPP  lpApp;
; 85   :    zPCHAR pchDirectory;
; 86   :    zSHORT nRC;
; 87   : 
; 88   :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 89   :    if ( (lpCurrentTask = fnOperationCall( iGetApplDirectoryFromView,
; 90   :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	20					; 00000014H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@GetApplDir

; 91   :    {
; 92   :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetApplDir
$LN4@GetApplDir:

; 93   :    }
; 94   : 
; 95   :    if ( lpView->hSubtask )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN5@GetApplDir

; 96   :    {
; 97   :       LPSUBTASK lpSubtask = zGETPTR( lpView->hSubtask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$2[ebp], eax

; 98   : 
; 99   :       lpApp = lpSubtask->hApp;

	mov	ecx, DWORD PTR _lpSubtask$2[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR _lpApp$[ebp], edx

; 100  :    }

	jmp	SHORT $LN6@GetApplDir
$LN5@GetApplDir:

; 101  :    else
; 102  :    if ( lpView->hViewOD )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN7@GetApplDir

; 103  :    {
; 104  :       LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 105  : 
; 106  :       lpApp = lpViewOD->hApp;

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR _lpApp$[ebp], ecx

; 107  :    }

	jmp	SHORT $LN6@GetApplDir
$LN7@GetApplDir:

; 108  :    else
; 109  :       lpApp = lpCurrentTask->hApp;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR _lpApp$[ebp], eax
$LN6@GetApplDir:

; 110  : 
; 111  :    lpApp = zGETPTR( lpApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 112  : 
; 113  :    pchReturnDirectory[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchReturnDirectory$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 114  :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 115  :    switch ( nDirectory )

	movsx	eax, WORD PTR _nDirectory$[ebp]
	mov	DWORD PTR tv87[ebp], eax
	cmp	DWORD PTR tv87[ebp], 6
	ja	SHORT $LN16@GetApplDir
	mov	ecx, DWORD PTR tv87[ebp]
	jmp	DWORD PTR $LN21@GetApplDir[ecx*4]
$LN9@GetApplDir:

; 116  :    {
; 117  :       case zAPPL_DIR_LIB:
; 118  :          pchDirectory = lpApp->szLibraryDir;

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 90					; 0000005aH
	mov	DWORD PTR _pchDirectory$[ebp], edx

; 119  :          break;

	jmp	SHORT $LN2@GetApplDir
$LN10@GetApplDir:

; 120  : 
; 121  :       case zAPPL_DIR_OBJECT:
; 122  :          pchDirectory = lpApp->szObjectDir;

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 347				; 0000015bH
	mov	DWORD PTR _pchDirectory$[ebp], eax

; 123  :          break;

	jmp	SHORT $LN2@GetApplDir
$LN11@GetApplDir:

; 124  : 
; 125  :       case zAPPL_DIR_LOCAL:
; 126  :          pchDirectory = lpApp->szLocalDir;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 604				; 0000025cH
	mov	DWORD PTR _pchDirectory$[ebp], ecx

; 127  :          break;

	jmp	SHORT $LN2@GetApplDir
$LN12@GetApplDir:

; 128  : 
; 129  :       case zAPPL_DIR_SHARED:
; 130  :          pchDirectory = lpApp->szSharedDir;

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 861				; 0000035dH
	mov	DWORD PTR _pchDirectory$[ebp], edx

; 131  :          break;

	jmp	SHORT $LN2@GetApplDir
$LN13@GetApplDir:

; 132  : 
; 133  :       case zAPPL_DIR_QLPLR:
; 134  :          pchDirectory = lpApp->szQLPLR_Dir;

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 1118				; 0000045eH
	mov	DWORD PTR _pchDirectory$[ebp], eax

; 135  :          break;

	jmp	SHORT $LN2@GetApplDir
$LN14@GetApplDir:

; 136  : 
; 137  :       case zAPPL_DIR_SOURCE:
; 138  :          pchDirectory = lpApp->szSourceDir;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 1632				; 00000660H
	mov	DWORD PTR _pchDirectory$[ebp], ecx

; 139  :          break;

	jmp	SHORT $LN2@GetApplDir
$LN15@GetApplDir:

; 140  : 
; 141  :       case zAPPL_NAME:
; 142  :          pchDirectory = lpApp->szName;

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	mov	DWORD PTR _pchDirectory$[ebp], edx

; 143  :          break;

	jmp	SHORT $LN2@GetApplDir
$LN16@GetApplDir:

; 144  : 
; 145  :       default:
; 146  :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 147  :          pchDirectory = 0;

	mov	DWORD PTR _pchDirectory$[ebp], 0
$LN2@GetApplDir:

; 148  :    }
; 149  : 
; 150  :    if ( pchDirectory )

	cmp	DWORD PTR _pchDirectory$[ebp], 0
	je	SHORT $LN17@GetApplDir

; 151  :    {
; 152  :       if ( (zSHORT) zstrlen( pchDirectory ) > (nMaxLth - 1) )

	mov	ecx, DWORD PTR _pchDirectory$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	movsx	edx, ax
	movsx	eax, WORD PTR _nMaxLth$[ebp]
	sub	eax, 1
	cmp	edx, eax
	jle	SHORT $LN18@GetApplDir

; 153  :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN17@GetApplDir
$LN18@GetApplDir:

; 154  :       else
; 155  :          zstrcpy( pchReturnDirectory, pchDirectory );

	mov	edx, DWORD PTR _pchDirectory$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnDirectory$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN17@GetApplDir:

; 156  :    }
; 157  : 
; 158  :    fnOperationReturn( iGetApplDirectoryFromView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	20					; 00000014H
	call	_fnOperationReturn
	add	esp, 8

; 159  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetApplDir:

; 160  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN21@GetApplDir:
	DD	$LN15@GetApplDir
	DD	$LN9@GetApplDir
	DD	$LN10@GetApplDir
	DD	$LN11@GetApplDir
	DD	$LN12@GetApplDir
	DD	$LN13@GetApplDir
	DD	$LN14@GetApplDir
_GetApplDirectoryFromView@16 ENDP
_TEXT	ENDS
END
