; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEATAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
?pfnInterp@?1??DfExecuteXPG@@9@9 DD 01H DUP (?)		; `DfExecuteXPG'::`2'::pfnInterp
$SG15574 DB	01H DUP (?)
	ALIGN	4

$SG16657 DB	01H DUP (?)
	ALIGN	4

$SG17274 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG16607 DB	'DerivedFunction', 00H
$SG16609 DB	'ZeidonVML', 00H
	ORG $+2
$SG16612 DB	'Zeidon_Tools', 00H
	ORG $+3
$SG16613 DB	'ZeidonVML', 00H
	ORG $+2
$SG16614 DB	'StackObject', 00H
$SG16617 DB	'LastXPG', 00H
$SG16620 DB	'MetaName', 00H
	ORG $+3
$SG16621 DB	'VML_XSource', 00H
$SG16623 DB	'TZVSPOOO', 00H
	ORG $+3
$SG16625 DB	'Error reading OI from buffer', 00H
	ORG $+3
$SG16626 DB	'Internal Core Error', 00H
$SG16627 DB	'LastXPG', 00H
$SG16628 DB	'XPG', 00H
$SG16629 DB	'TZVSRTOO', 00H
	ORG $+3
$SG16630 DB	'StackObject', 00H
$SG16631 DB	'OperationCall', 00H
	ORG $+2
$SG16632 DB	'Name', 00H
	ORG $+3
$SG16633 DB	'OperationCall', 00H
	ORG $+2
$SG16634 DB	'Variable', 00H
	ORG $+3
$SG16635 DB	'ID', 00H
	ORG $+1
$SG16636 DB	'Variable', 00H
	ORG $+3
$SG16637 DB	'vSubtask', 00H
	ORG $+3
$SG16638 DB	'Name', 00H
	ORG $+3
$SG16639 DB	'Variable', 00H
	ORG $+3
$SG16640 DB	'Variable', 00H
	ORG $+3
$SG16641 DB	'ID', 00H
	ORG $+1
$SG16642 DB	'Variable', 00H
	ORG $+3
$SG16643 DB	'vView', 00H
	ORG $+2
$SG16644 DB	'Name', 00H
	ORG $+3
$SG16645 DB	'Variable', 00H
	ORG $+3
$SG16646 DB	'Value', 00H
	ORG $+2
$SG16647 DB	'Variable', 00H
	ORG $+3
$SG16648 DB	'StackObject', 00H
$SG16650 DB	'TZVMLOPR', 00H
	ORG $+3
$SG16653 DB	'Could not locate TZVMLOPR.DLL', 00H
	ORG $+2
$SG16654 DB	'Zeidon Interpretor Error', 00H
	ORG $+3
$SG16655 DB	'InvokeInterp', 00H
	ORG $+3
$SG16660 DB	'StackObject', 00H
$SG16719 DB	'DfExprVML', 00H
	ORG $+2
$SG16720 DB	'DfExprVML', 00H
	ORG $+2
$SG16721 DB	'DfExprVML', 00H
	ORG $+2
$SG16723 DB	'*xpg*', 00H
	ORG $+2
$SG16724 DB	'*xpg*', 00H
	ORG $+2
$SG16725 DB	'*xpg*', 00H
	ORG $+2
$SG17763 DB	'TZDMD101', 00H
	ORG $+3
$SG17761 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG17762 DB	'System Error', 00H
	ORG $+3
$SG15822 DB	'(at) Couldn''t read entire file.  Lth = ', 00H
$SG17918 DB	'Type: ', 00H
	ORG $+1
$SG17919 DB	', Domain: ', 00H
	ORG $+1
$SG17920 DB	', ', 00H
	ORG $+1
$SG16896 DB	'Entity Update not allowed', 00H
	ORG $+2
$SG17925 DB	'/', 00H
	ORG $+2
$SG17926 DB	'/', 00H
	ORG $+2
$SG17935 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG17936 DB	'System Error', 00H
	ORG $+3
$SG17937 DB	'TZDMD101', 00H
	ORG $+3
$SG14996 DB	'Binary large object length: %d   exceeds passed length: '
	DB	'%d', 00H
	ORG $+1
$SG16098 DB	' failed.', 00H
	ORG $+3
$SG16099 DB	'(at) in SAFA fnGetAddrForAttribute', 00H
	ORG $+1
$SG15170 DB	', ', 00H
	ORG $+1
$SG15171 DB	', ', 00H
	ORG $+1
$SG17250 DB	'Entity:', 09H, 00H
	ORG $+3
$SG17251 DB	'Attribute:', 09H, 00H
$SG17263 DB	'Type: ', 00H
	ORG $+1
$SG17264 DB	', Domain: ', 00H
	ORG $+1
$SG17265 DB	', ', 00H
	ORG $+1
$SG17271 DB	'.', 00H
	ORG $+2
$SG17272 DB	'.', 00H
	ORG $+2
$SG17273 DB	'.', 00H
	ORG $+2
$SG17275 DB	'Invalid data format.  Your data should be in the format:'
	DB	' ', 00H
	ORG $+2
$SG17276 DB	'361', 00H
$SG17283 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG17284 DB	'System Error', 00H
	ORG $+3
$SG17285 DB	'TZDMD101', 00H
	ORG $+3
$SG18328 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG18329 DB	'System Error', 00H
	ORG $+3
$SG18330 DB	'TZDMD101', 00H
	ORG $+3
$SG17370 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG17371 DB	'System Error', 00H
	ORG $+3
$SG17372 DB	'TZDMD101', 00H
	ORG $+3
$SG18403 DB	'(at) Couldn''t read entire file.  Lth = ', 00H
_DATA	ENDS
PUBLIC	_GetStringFromAttribute@16
PUBLIC	_AttributeUpdated@12
PUBLIC	_GetStringFromAttributeByContext@24
PUBLIC	_GetStructFromEntityAttrs@12
PUBLIC	_SetAttributeFromString@16
PUBLIC	_GetViewFromAttribute@16
PUBLIC	_GetIntegerFromAttribute@16
PUBLIC	_SetAttributeFromInteger@16
PUBLIC	_GetDecimalFromAttribute@16
PUBLIC	_SetAttributeFromDecimal@52
PUBLIC	_GetBlobFromAttribute@20
PUBLIC	_SetAttributeFromBlob@20
PUBLIC	_AddToAttributeFromInteger@16
PUBLIC	_SetAttributeFromAttribute@24
PUBLIC	_SetBlobAttributeFromAttribute@24
PUBLIC	_SetBlobFromEntityAttributes@20
PUBLIC	_SetBlobFromOI@20
PUBLIC	_WriteBlobToFile@16
PUBLIC	_SetBlobFromFile@16
PUBLIC	_SetOI_FromBlob@28
PUBLIC	_SetEntityAttributesFromBlob@20
PUBLIC	_AddToAttributeFromDecimal@52
PUBLIC	_AddToAttributeFromAttribute@24
PUBLIC	_CompareAttributeToAttribute@24
PUBLIC	_CompareAttributeToString@16
PUBLIC	_CompareAttributeToInteger@16
PUBLIC	_CompareAttributeToDecimal@52
PUBLIC	_GetAttributeLength@16
PUBLIC	_GetAttributeDisplayLength@20
PUBLIC	_GetActualAttributeLength@16
PUBLIC	_SetMatchingAttributesByName@20
PUBLIC	_SetAttributeFromVariable@32
PUBLIC	_CompareAttributeToVariable@32
PUBLIC	_GetVariableFromAttribute@36
PUBLIC	_AddToAttributeFromVariable@28
PUBLIC	_GetFirstTableEntryForAttribute@24
PUBLIC	_GetNextTableEntryForAttribute@24
PUBLIC	_SetAttributeValueNext@16
PUBLIC	_SetAttributeValuePrev@16
PUBLIC	_zdSUM@16
PUBLIC	_ziSUM@16
PUBLIC	_GetAddrForAttribute@16
PUBLIC	_StoreValueInRecord@20
PUBLIC	_StoreBytesInRecord@20
PUBLIC	_StoreStringInDerivedAttribute@16
PUBLIC	_StoreValueInDerivedAttribute@20
PUBLIC	_GetValueFromRecord@24
PUBLIC	_StoreStringInRecord@16
PUBLIC	_GetStringFromRecord@20
PUBLIC	_ConvertDecimalToString@52
PUBLIC	_GetAttributeFlags@16
PUBLIC	_fnGetAttribFlagsPtr@8
PUBLIC	_fnSetAttributeFromString
PUBLIC	_fnSetAttributeFromInteger
PUBLIC	_fnAddToAttributeFromInteger
PUBLIC	_fnSetAttributeFromDecimal
PUBLIC	_fnAddToAttributeFromDecimal
PUBLIC	_fnAddToAttributeFromVariable
PUBLIC	_fnValidateAttributeParameters
PUBLIC	_fnGetAttrAddrFromEntityInstance
PUBLIC	_fnStoreValueInEntityInstance
PUBLIC	_fnGetStringFromAttribute
PUBLIC	_fnGetIntegerFromAttribute
PUBLIC	_fnGetDecimalFromAttribute
PUBLIC	_fnGetBlobFromAttribute
PUBLIC	_fnSetAttributeFromBlob
PUBLIC	_fnGetAddrForAttribute
PUBLIC	_fnGetAttributeDisplayLength
PUBLIC	_fnGetAttributeLength
PUBLIC	_fnGetActualAttributeLength
PUBLIC	_fnCreateAttributeRecord
PUBLIC	_fnStoreStringInRecord
PUBLIC	_fnStoreBlobInRecord
PUBLIC	_fnCopyAttributeRecord
PUBLIC	_fnDeleteAttributeRecord
PUBLIC	_fnSetAttributeFromVariable
PUBLIC	_fnGetVariableFromAttribute
PUBLIC	_fnSetAttributeValue
PUBLIC	_fnCompareDateTimeToDateTime
PUBLIC	_fnCompareAttributeToVariable
PUBLIC	_fnAttributeValueNull
PUBLIC	_fnGetTaskDomain
PUBLIC	_fnGetAttribOper
PUBLIC	_fnRecordForEntityAttr
PUBLIC	_fnInvokeDerivedOperation
PUBLIC	_fnSetUpdateIndicator
PUBLIC	_fnGetTextForTableEntry
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnEntityNameFromCsr@4
PUBLIC	_fnEntityNameFromInstance@4
PUBLIC	_fnGetLongExternalLthForContext
PUBLIC	_SetAttributeFromView@16
PUBLIC	_fnRetrieveAttribName@12
PUBLIC	_DfExprVML@16
PUBLIC	_DfExecuteXPG@16
PUBLIC	_sFormatIn
PUBLIC	_sFormatOut
PUBLIC	_fnCompareAttributeToString
PUBLIC	_fnCompareAttributeToInteger
PUBLIC	_fnCompareAttributeToDecimal
PUBLIC	_fnCompareAttributeToBlob
PUBLIC	_fnCompareAttributeToDateTime
PUBLIC	_fnSetBlobFromFile@16
PUBLIC	_fnWriteBlobToFile@16
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncat:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_IssueOE_Error@28:PROC
EXTRN	_ActivateEmptyObjectInstance@16:PROC
EXTRN	_ActivateOI_FromFile@20:PROC
EXTRN	_CommitOI_ToFile@12:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_UfEditFormatString@8:PROC
EXTRN	_UfFormatString@8:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_SysAddDecimalToDecimal@12:PROC
EXTRN	_SysAssignDecimalFromDecimal@8:PROC
EXTRN	_SysAssignDecimalFromNull@4:PROC
EXTRN	_SysCompareDecimalToDecimal@8:PROC
EXTRN	_SysConvertDecimalToLong@8:PROC
EXTRN	_SysCompareDecimalToNull@4:PROC
EXTRN	_SysConvertDecimalToString@12:PROC
EXTRN	_SysConvertLongToDecimal@8:PROC
EXTRN	_SysConvertStringToDecimal@8:PROC
EXTRN	_SysSubtractDecimalFromDecimal@12:PROC
EXTRN	_TableEntryIntToExt@20:PROC
EXTRN	_GetContext@12:PROC
EXTRN	_GetDefaultContext@8:PROC
EXTRN	_SysAllocMemory@20:PROC
EXTRN	_SysCloseFile@12:PROC
EXTRN	_SysCreateTempFileName@4:PROC
EXTRN	_SysFree@4:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysGetFileSize@4:PROC
EXTRN	_SysGetLanguageCode@4:PROC
EXTRN	_SysGetProc@8:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysLoadLibrary@8:PROC
EXTRN	_SysMalloc@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysOpenFile@12:PROC
EXTRN	_SysReadFile@16:PROC
EXTRN	_SysWriteFile@16:PROC
EXTRN	_ActivateViewObject@12:PROC
EXTRN	_SfCreateSubtask@12:PROC
EXTRN	_SfDropSubtask@8:PROC
EXTRN	_UfDateTimeToString@12:PROC
EXTRN	_UfStringToDateTime@8:PROC
EXTRN	_TrueName@8:PROC
EXTRN	_SfLockView@4:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnResetCursorForViewChildren:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_Table_Handler@36:PROC
EXTRN	_fnDomainProcessingRequired:PROC
EXTRN	_fnGetContext:PROC
EXTRN	_fnCallDomainOper@40:PROC
EXTRN	_fnCallDomainOper2@36:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnGetDataspaceLength:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnValidateInstanceParameters:PROC
EXTRN	_fnInstanceVersioned:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnCreateSubtask:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidView:PROC
EXTRN	_fnValidViewCsr:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnValidViewAttrib:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__isalpha:PROC
EXTRN	__imp__isupper:PROC
EXTRN	__imp__isdigit:PROC
EXTRN	__imp__isspace:PROC
EXTRN	__imp__isalnum:PROC
EXTRN	_fnActivateOI_FromBuffer@24:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_g_ulMaxRecordStringLth:DWORD
EXTRN	_szNullS:DWORD
EXTRN	_lNullInteger:DWORD
EXTRN	_stNullDateTime:FWORD
EXTRN	_szlApplicationLogicError:DWORD
EXTRN	_szGAFANullS:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

?dNullDecimal@?1??fnGetAddrForAttribute@@9@9 DB 028H DUP (?) ; `fnGetAddrForAttribute'::`2'::dNullDecimal
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -20						; size = 4
_pchData$ = -16						; size = 4
_ulLth$ = -12						; size = 4
_hFile$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_cpcFileName$ = 20					; size = 4
_fnWriteBlobToFile@16 PROC

; 10741: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 10742:    zLONG   hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 10743:    zULONG  ulLth;
; 10744:    zPCHAR  pchData;
; 10745:    zSHORT  nRC;
; 10746: 
; 10747:    fnGetAddrForAttribute( &pchData, lpView, lpViewEntityCsr, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchData$[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 10748:                           lpViewAttrib );
; 10749: 
; 10750:    fnGetAttributeLength( &ulLth, lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 10751:                          zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 10752:                          lpViewAttrib );
; 10753: 
; 10754:    // If there is no blob data then return -1.
; 10755:    if ( pchData == 0 || ulLth == 0 )

	cmp	DWORD PTR _pchData$[ebp], 0
	je	SHORT $LN3@fnWriteBlo
	cmp	DWORD PTR _ulLth$[ebp], 0
	jne	SHORT $LN2@fnWriteBlo
$LN3@fnWriteBlo:

; 10756:       return( -1 );

	or	eax, -1
	jmp	$LN1@fnWriteBlo
$LN2@fnWriteBlo:

; 10757: 
; 10758:    // Write the blob to a temp file.
; 10759:    hFile = SysOpenFile( lpView, cpcFileName, COREFILE_WRITE );

	push	64					; 00000040H
	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 10760:    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN4@fnWriteBlo

; 10761:    {
; 10762:       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 10763: 
; 10764:       // "KZOEE022 - Error writing file"
; 10765:       fnIssueCoreError( lpTask, lpView, 16, 22, 0, cpcFileName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	push	0
	push	22					; 00000016H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 10766:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnWriteBlo
$LN4@fnWriteBlo:

; 10767:    }
; 10768: 
; 10769:    if ( SysWriteFile( lpView, hFile, pchData, ulLth ) != (int) ulLth )

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchData$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysWriteFile@16
	cmp	eax, DWORD PTR _ulLth$[ebp]
	je	SHORT $LN5@fnWriteBlo

; 10770:       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN6@fnWriteBlo
$LN5@fnWriteBlo:

; 10771:    else
; 10772:       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN6@fnWriteBlo:

; 10773: 
; 10774:    SysCloseFile( lpView, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysCloseFile@12

; 10775:    hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 10776: 
; 10777:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnWriteBlo:

; 10778: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnWriteBlobToFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -20						; size = 4
_hFile$ = -16						; size = 4
_ulLth$ = -12						; size = 4
_pchData$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_cpcFileName$ = 20					; size = 4
_fnSetBlobFromFile@16 PROC

; 10616: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 10617:    zLONG   hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 10618:    zULONG  ulLth;
; 10619:    zPCHAR  pchData = 0;

	mov	DWORD PTR _pchData$[ebp], 0

; 10620:    zSHORT  nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 10621: 
; 10622:    hFile = SysOpenFile( lpView, cpcFileName, COREFILE_READ );

	push	128					; 00000080H
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 10623:    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN2@fnSetBlobF

; 10624:    {
; 10625:       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 10626:       // "KZOEE024190 - Error opening file"
; 10627:       fnIssueCoreError( lpTask, lpView, 16, 24, 0, cpcFileName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	push	0
	push	24					; 00000018H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 10628:       goto EndOfFunction;

	jmp	$EndOfFunction$10
$LN2@fnSetBlobF:

; 10629:    }
; 10630: 
; 10631:    // Get the file length.
; 10632:    ulLth = SysGetFileSize( hFile );

	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	call	_SysGetFileSize@4
	mov	DWORD PTR _ulLth$[ebp], eax

; 10633: 
; 10634:    // Now allocate space big enough to hold the entire file plus a null-terminator.
; 10635:    pchData = SysMalloc( ulLth + 1 );

	mov	eax, DWORD PTR _ulLth$[ebp]
	add	eax, 1
	push	eax
	call	_SysMalloc@4
	mov	DWORD PTR _pchData$[ebp], eax

; 10636:    if ( pchData == 0 )

	cmp	DWORD PTR _pchData$[ebp], 0
	jne	SHORT $LN3@fnSetBlobF

; 10637:       goto EndOfFunction;

	jmp	$EndOfFunction$10
$LN3@fnSetBlobF:

; 10638: 
; 10639:    if ( SysReadFile( lpView, hFile, pchData, ulLth ) != ulLth )

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchData$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysReadFile@16
	cmp	eax, DWORD PTR _ulLth$[ebp]
	je	SHORT $LN4@fnSetBlobF

; 10640:    {
; 10641:       TraceLineI( "(at) Couldn't read entire file.  Lth = ", ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	push	OFFSET $SG18403
	call	_TraceLineI@8

; 10642:       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$10
$LN4@fnSetBlobF:

; 10643:    }
; 10644: 
; 10645:    // Last thing to do--set blob attribute.
; 10646:    if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN5@fnSetBlobF

; 10647:    {
; 10648:       pchData[ ulLth ] = 0;

	mov	edx, DWORD PTR _pchData$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx], 0

; 10649: 
; 10650:       nRC = fnSetAttributeFromString( lpView, lpViewEntityCsr,

	movzx	eax, WORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 10651:                                       lpViewAttrib, pchData, (zSHORT) ulLth );
; 10652:    }

	jmp	SHORT $EndOfFunction$10
$LN5@fnSetBlobF:

; 10653:    else
; 10654:    {
; 10655:       nRC = fnSetAttributeFromBlob( lpView, lpViewEntityCsr,

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$10:

; 10656:                                     lpViewAttrib, pchData, ulLth );
; 10657:    }
; 10658: 
; 10659: EndOfFunction:
; 10660: 
; 10661:    if ( pchData )

	cmp	DWORD PTR _pchData$[ebp], 0
	je	SHORT $LN7@fnSetBlobF

; 10662:       SysFree( pchData );

	mov	ecx, DWORD PTR _pchData$[ebp]
	push	ecx
	call	_SysFree@4
$LN7@fnSetBlobF:

; 10663: 
; 10664:    if ( hFile != -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	je	SHORT $LN8@fnSetBlobF

; 10665:       SysCloseFile( lpView, hFile, 0 );

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysCloseFile@12
$LN8@fnSetBlobF:

; 10666: 
; 10667:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 10668: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSetBlobFromFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_stDT$1 = -60						; size = 6
_lpViewCsr$2 = -52					; size = 4
_lpViewCsr$3 = -48					; size = 4
_lpRecdDateTime$ = -44					; size = 4
_lpExternalP$4 = -40					; size = 4
_lpView$5 = -36						; size = 4
tv148 = -32						; size = 4
_lpView$6 = -28						; size = 4
tv72 = -24						; size = 4
_pchRecord$ = -20					; size = 4
_nRC$ = -16						; size = 2
_stDateTime$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lpDateTime$ = 20					; size = 4
_fnCompareAttributeToDateTime PROC

; 8537 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8538 :    zPCHAR         pchRecord;
; 8539 :    DateTimeRecord stDateTime;
; 8540 :    LPDTINTERNAL   lpRecdDateTime;
; 8541 :    zSHORT         nRC;
; 8542 : 
; 8543 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8544 : 
; 8545 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN6@fnCompareA

; 8546 :    {
; 8547 :       pchRecord += lpViewAttrib->ulRecordOffset;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8548 :       switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv72[ebp], dl
	cmp	BYTE PTR tv72[ebp], 83			; 00000053H
	je	SHORT $LN8@fnCompareA
	cmp	BYTE PTR tv72[ebp], 84			; 00000054H
	je	SHORT $LN11@fnCompareA
	jmp	SHORT $LN12@fnCompareA
$LN8@fnCompareA:

; 8549 :       {
; 8550 :          case zTYPE_STRING:
; 8551 :             if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchRecord$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	SHORT $LN9@fnCompareA

; 8552 :             {
; 8553 :                zCOREMEM  lpExternalP;
; 8554 : 
; 8555 :                lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$4[ebp], ecx

; 8556 :                pchRecord = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$4[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN9@fnCompareA:

; 8557 :             }
; 8558 : 
; 8559 :             nRC = UfStringToDateTime( pchRecord,

	lea	ecx, DWORD PTR _stDateTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	call	_UfStringToDateTime@8
	mov	WORD PTR _nRC$[ebp], ax

; 8560 :                                       (LPDATETIME) &stDateTime );
; 8561 :             if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN10@fnCompareA

; 8562 :             {
; 8563 :                nRC = fnCompareDateTimeToDateTime( (LPDTINTERNAL) &stDateTime,

	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	push	ecx
	lea	edx, DWORD PTR _stDateTime$[ebp]
	push	edx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN10@fnCompareA:

; 8564 :                                                   (LPDTINTERNAL) lpDateTime );
; 8565 :             }
; 8566 : 
; 8567 :             break;

	jmp	SHORT $LN2@fnCompareA
$LN11@fnCompareA:

; 8568 : 
; 8569 :          case zTYPE_DATETIME:
; 8570 :             lpRecdDateTime = (LPDTINTERNAL) pchRecord;

	mov	eax, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR _lpRecdDateTime$[ebp], eax

; 8571 :             nRC = fnCompareDateTimeToDateTime( lpRecdDateTime,

	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRecdDateTime$[ebp]
	push	edx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 8572 :                                                (LPDTINTERNAL) lpDateTime );
; 8573 :             break;

	jmp	SHORT $LN2@fnCompareA
$LN12@fnCompareA:

; 8574 : 
; 8575 :          default:
; 8576 :          {
; 8577 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$3[ebp], eax

; 8578 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$3[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$6[ebp], eax

; 8579 : 
; 8580 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8581 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	eax, DWORD PTR _lpView$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$6[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8582 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8583 :                               lpViewAttrib->szName );
; 8584 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN2@fnCompareA:

; 8585 :          }
; 8586 :       }
; 8587 :    }

	jmp	$LN7@fnCompareA
$LN6@fnCompareA:

; 8588 :    else
; 8589 :    {
; 8590 :       DateTimeInternalRecord stDT;
; 8591 : 
; 8592 :       switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv148[ebp], dl
	cmp	BYTE PTR tv148[ebp], 83			; 00000053H
	jl	SHORT $LN14@fnCompareA
	cmp	BYTE PTR tv148[ebp], 84			; 00000054H
	jle	SHORT $LN13@fnCompareA
	jmp	SHORT $LN14@fnCompareA
$LN13@fnCompareA:

; 8593 :       {
; 8594 :          case zTYPE_STRING:
; 8595 :          case zTYPE_DATETIME:
; 8596 :             stDT.ulDateMinutes = lNullInteger;

	mov	eax, DWORD PTR _lNullInteger
	mov	DWORD PTR _stDT$1[ebp], eax

; 8597 :             stDT.usTSeconds = 0;

	xor	ecx, ecx
	mov	WORD PTR _stDT$1[ebp+4], cx

; 8598 :             nRC = fnCompareDateTimeToDateTime( (LPDTINTERNAL) &stDT,

	mov	edx, DWORD PTR _lpDateTime$[ebp]
	push	edx
	lea	eax, DWORD PTR _stDT$1[ebp]
	push	eax
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 8599 :                                                (LPDTINTERNAL) lpDateTime );
; 8600 :             break;

	jmp	SHORT $LN7@fnCompareA
$LN14@fnCompareA:

; 8601 : 
; 8602 :          default:
; 8603 :          {
; 8604 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 8605 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$2[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$5[ebp], eax

; 8606 : 
; 8607 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8608 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	ecx, DWORD PTR _lpView$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$5[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8609 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8610 :                               lpViewAttrib->szName );
; 8611 :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN7@fnCompareA:

; 8612 :          }
; 8613 :       }
; 8614 :    }
; 8615 : 
; 8616 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 8617 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareAttributeToDateTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewCsr$1 = -44					; size = 4
_lpViewCsr$2 = -40					; size = 4
_lpView$3 = -36						; size = 4
tv148 = -32						; size = 4
_lpView$4 = -28						; size = 4
tv91 = -24						; size = 4
tv83 = -20						; size = 4
_ulAttrBlobLth$ = -16					; size = 4
_lpExternalP$5 = -12					; size = 4
_pchRecord$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpEntityInstance$ = 8					; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_pchBlobValue$ = 20					; size = 4
_ulBlobLth$ = 24					; size = 4
_fnCompareAttributeToBlob PROC

; 8409 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 8410 :    zPCHAR   pchRecord;
; 8411 :    zULONG   ulAttrBlobLth;
; 8412 :    zSHORT   nRC;
; 8413 : 
; 8414 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8415 : 
; 8416 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN2@fnCompareA

; 8417 :    {
; 8418 :       pchRecord += lpViewAttrib->ulRecordOffset;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8419 :       if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	jne	$LN4@fnCompareA

; 8420 :       {
; 8421 :          if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchRecord$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	SHORT $LN6@fnCompareA

; 8422 :          {
; 8423 :             zCOREMEM  lpExternalP;
; 8424 : 
; 8425 :             lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$5[ebp], ecx

; 8426 :             ulAttrBlobLth = *((zPULONG) (lpExternalP + 1));

	mov	edx, DWORD PTR _lpExternalP$5[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ulAttrBlobLth$[ebp], eax

; 8427 :             pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$5[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8428 :             if ( ulAttrBlobLth != ulBlobLth )

	mov	eax, DWORD PTR _ulAttrBlobLth$[ebp]
	cmp	eax, DWORD PTR _ulBlobLth$[ebp]
	je	SHORT $LN8@fnCompareA

; 8429 :                nRC = (ulAttrBlobLth < ulBlobLth) ? -1 : 1;

	mov	ecx, DWORD PTR _ulAttrBlobLth$[ebp]
	cmp	ecx, DWORD PTR _ulBlobLth$[ebp]
	jae	SHORT $LN13@fnCompareA
	mov	DWORD PTR tv83[ebp], -1
	jmp	SHORT $LN14@fnCompareA
$LN13@fnCompareA:
	mov	DWORD PTR tv83[ebp], 1
$LN14@fnCompareA:
	mov	dx, WORD PTR tv83[ebp]
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN9@fnCompareA
$LN8@fnCompareA:

; 8430 :             else
; 8431 :                nRC = zmemcmp( pchRecord, pchBlobValue,

	mov	eax, DWORD PTR _ulBlobLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBlobValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax
$LN9@fnCompareA:

; 8432 :                               (unsigned int) ulBlobLth );
; 8433 :          }

	jmp	SHORT $LN7@fnCompareA
$LN6@fnCompareA:

; 8434 :          else
; 8435 :          {
; 8436 :             // blob is null
; 8437 :             nRC = ( ulBlobLth == 0 ) ? 0 : -1;

	cmp	DWORD PTR _ulBlobLth$[ebp], 0
	jne	SHORT $LN15@fnCompareA
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $LN16@fnCompareA
$LN15@fnCompareA:
	mov	DWORD PTR tv91[ebp], -1
$LN16@fnCompareA:
	mov	ax, WORD PTR tv91[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN7@fnCompareA:

; 8438 :          }
; 8439 :       }

	jmp	SHORT $LN5@fnCompareA
$LN4@fnCompareA:

; 8440 :       else
; 8441 :       {
; 8442 :          LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 8443 :          zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$2[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$4[ebp], eax

; 8444 : 
; 8445 :          // "KZOEE239 - Invalid Operation for attribute type"
; 8446 :          fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	ecx, DWORD PTR _lpView$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$4[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8447 :                            fnEntityNameFromCsr( lpViewEntityCsr ),
; 8448 :                            lpViewAttrib->szName );
; 8449 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN5@fnCompareA:

; 8450 :       }
; 8451 :    }

	jmp	$LN3@fnCompareA
$LN2@fnCompareA:

; 8452 :    else
; 8453 :    {
; 8454 :       if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN10@fnCompareA

; 8455 :          nRC = ( ulBlobLth == 0 ) ? 0 : -1;

	cmp	DWORD PTR _ulBlobLth$[ebp], 0
	jne	SHORT $LN17@fnCompareA
	mov	DWORD PTR tv148[ebp], 0
	jmp	SHORT $LN18@fnCompareA
$LN17@fnCompareA:
	mov	DWORD PTR tv148[ebp], -1
$LN18@fnCompareA:
	mov	cx, WORD PTR tv148[ebp]
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN3@fnCompareA
$LN10@fnCompareA:

; 8456 :       else
; 8457 :       {
; 8458 :          LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 8459 :          zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$3[ebp], eax

; 8460 : 
; 8461 :          // "KZOEE239 - Invalid Operation for attribute type"
; 8462 :          fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$3[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8463 :                            fnEntityNameFromCsr( lpViewEntityCsr ),
; 8464 :                            lpViewAttrib->szName );
; 8465 :          nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN3@fnCompareA:

; 8466 :       }
; 8467 :    }
; 8468 : 
; 8469 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 8470 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareAttributeToBlob ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -84					; size = 4
_lpViewCsr$1 = -80					; size = 4
_lpViewCsr$2 = -76					; size = 4
_lpExternalP$3 = -72					; size = 4
_lpView$4 = -68						; size = 4
_lpView$5 = -64						; size = 4
tv154 = -60						; size = 4
tv75 = -56						; size = 4
_pchRecord$ = -52					; size = 4
_nRC$ = -48						; size = 2
_dWork$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_dDecimalValue$ = 20					; size = 40
_fnCompareAttributeToDecimal PROC

; 8316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8317 :    zPCHAR   pchRecord;
; 8318 :    zDECIMAL dWork;
; 8319 :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8320 :    zSHORT   nRC;
; 8321 : 
; 8322 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8323 : 
; 8324 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN6@fnCompareA

; 8325 :    {
; 8326 :       pchRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchRecord$[ebp], edx

; 8327 :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv75[ebp], cl
	cmp	BYTE PTR tv75[ebp], 76			; 0000004cH
	je	SHORT $LN10@fnCompareA
	cmp	BYTE PTR tv75[ebp], 77			; 0000004dH
	je	SHORT $LN11@fnCompareA
	cmp	BYTE PTR tv75[ebp], 83			; 00000053H
	je	SHORT $LN8@fnCompareA
	jmp	$LN12@fnCompareA
$LN8@fnCompareA:

; 8328 :       {
; 8329 :          case zTYPE_STRING:
; 8330 :             if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN9@fnCompareA

; 8331 :             {
; 8332 :                zCOREMEM  lpExternalP;
; 8333 : 
; 8334 :                lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$3[ebp], eax

; 8335 :                pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$3[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN9@fnCompareA:

; 8336 :             }
; 8337 : 
; 8338 :             SysConvertStringToDecimal( pchRecord, &dWork );

	lea	eax, DWORD PTR _dWork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_SysConvertStringToDecimal@8

; 8339 :             nRC = SysCompareDecimalToDecimal( &dWork, &dDecimalValue );

	lea	edx, DWORD PTR _dDecimalValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _dWork$[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 8340 :             break;

	jmp	$LN2@fnCompareA
$LN10@fnCompareA:

; 8341 : 
; 8342 :          case zTYPE_INTEGER:
; 8343 :             SysConvertLongToDecimal( *((zPLONG) pchRecord), &dWork );

	lea	ecx, DWORD PTR _dWork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SysConvertLongToDecimal@8

; 8344 :             nRC = SysCompareDecimalToDecimal( &dWork, &dDecimalValue );

	lea	ecx, DWORD PTR _dDecimalValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dWork$[ebp]
	push	edx
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 8345 :             break;

	jmp	SHORT $LN2@fnCompareA
$LN11@fnCompareA:

; 8346 : 
; 8347 :          case zTYPE_DECIMAL:
; 8348 :             nRC = SysCompareDecimalToDecimal( (zPDECIMAL) pchRecord,

	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 8349 :                                               &dDecimalValue );
; 8350 :             break;

	jmp	SHORT $LN2@fnCompareA
$LN12@fnCompareA:

; 8351 : 
; 8352 :          default:
; 8353 :          {
; 8354 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 8355 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$2[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$5[ebp], eax

; 8356 : 
; 8357 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8358 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$5[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8359 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8360 :                               lpViewAttrib->szName );
; 8361 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN2@fnCompareA:

; 8362 :          }
; 8363 :       }
; 8364 :    }

	jmp	$LN7@fnCompareA
$LN6@fnCompareA:

; 8365 :    else
; 8366 :    {
; 8367 :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv154[ebp], cl
	cmp	BYTE PTR tv154[ebp], 76			; 0000004cH
	jl	SHORT $LN14@fnCompareA
	cmp	BYTE PTR tv154[ebp], 77			; 0000004dH
	jle	SHORT $LN13@fnCompareA
	cmp	BYTE PTR tv154[ebp], 83			; 00000053H
	je	SHORT $LN13@fnCompareA
	jmp	SHORT $LN14@fnCompareA
$LN13@fnCompareA:

; 8368 :       {
; 8369 :          case zTYPE_STRING:
; 8370 :          case zTYPE_INTEGER:
; 8371 :          case zTYPE_DECIMAL:
; 8372 :             SysConvertLongToDecimal( 0, &dWork );

	lea	edx, DWORD PTR _dWork$[ebp]
	push	edx
	push	0
	call	_SysConvertLongToDecimal@8

; 8373 :             nRC = SysCompareDecimalToDecimal( (zPDECIMAL) pchRecord,

	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 8374 :                                               &dDecimalValue );
; 8375 :             break;

	jmp	SHORT $LN7@fnCompareA
$LN14@fnCompareA:

; 8376 : 
; 8377 :          default:
; 8378 :          {
; 8379 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 8380 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$4[ebp], eax

; 8381 : 
; 8382 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8383 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$4[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8384 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8385 :                               lpViewAttrib->szName );
; 8386 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN7@fnCompareA:

; 8387 :          }
; 8388 :       }
; 8389 :    }
; 8390 : 
; 8391 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 8392 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareAttributeToDecimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -112					; size = 4
_lpViewCsr$1 = -108					; size = 4
_lpViewCsr$2 = -104					; size = 4
_lpExternalP$3 = -100					; size = 4
_lpView$4 = -96						; size = 4
tv165 = -92						; size = 4
tv164 = -88						; size = 4
_lpView$5 = -84						; size = 4
tv95 = -80						; size = 4
tv94 = -76						; size = 4
tv89 = -72						; size = 4
tv88 = -68						; size = 4
tv160 = -64						; size = 4
tv75 = -60						; size = 4
_pchRecord$ = -56					; size = 4
_lWork$ = -52						; size = 4
_nRC$ = -48						; size = 2
_dWork$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lIntegerValue$ = 20					; size = 4
_fnCompareAttributeToInteger PROC

; 8222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8223 :    zPCHAR   pchRecord;
; 8224 :    zLONG    lWork;
; 8225 :    zDECIMAL dWork;
; 8226 :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8227 :    zSHORT   nRC;
; 8228 : 
; 8229 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8230 : 
; 8231 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN6@fnCompareA

; 8232 :    {
; 8233 :       pchRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchRecord$[ebp], edx

; 8234 :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv75[ebp], cl
	cmp	BYTE PTR tv75[ebp], 76			; 0000004cH
	je	$LN10@fnCompareA
	cmp	BYTE PTR tv75[ebp], 77			; 0000004dH
	je	$LN11@fnCompareA
	cmp	BYTE PTR tv75[ebp], 83			; 00000053H
	je	SHORT $LN8@fnCompareA
	jmp	$LN12@fnCompareA
$LN8@fnCompareA:

; 8235 :       {
; 8236 :          case zTYPE_STRING:
; 8237 :             if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN9@fnCompareA

; 8238 :             {
; 8239 :                zCOREMEM  lpExternalP;
; 8240 : 
; 8241 :                lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$3[ebp], eax

; 8242 :                pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$3[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN9@fnCompareA:

; 8243 :             }
; 8244 : 
; 8245 :             lWork = zatol( pchRecord );

	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lWork$[ebp], eax

; 8246 :             lWork -= lIntegerValue;

	mov	ecx, DWORD PTR _lWork$[ebp]
	sub	ecx, DWORD PTR _lIntegerValue$[ebp]
	mov	DWORD PTR _lWork$[ebp], ecx

; 8247 :             nRC = (lWork == 0) ? 0 : (lWork < 0) ? -1 : 1;

	jne	SHORT $LN18@fnCompareA
	mov	DWORD PTR tv89[ebp], 0
	jmp	SHORT $LN19@fnCompareA
$LN18@fnCompareA:
	cmp	DWORD PTR _lWork$[ebp], 0
	jge	SHORT $LN16@fnCompareA
	mov	DWORD PTR tv88[ebp], -1
	jmp	SHORT $LN17@fnCompareA
$LN16@fnCompareA:
	mov	DWORD PTR tv88[ebp], 1
$LN17@fnCompareA:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR tv89[ebp], edx
$LN19@fnCompareA:
	mov	ax, WORD PTR tv89[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 8248 :             break;

	jmp	$LN2@fnCompareA
$LN10@fnCompareA:

; 8249 : 
; 8250 :          case zTYPE_INTEGER:
; 8251 :             lWork = *((zPLONG) pchRecord) - lIntegerValue;

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, DWORD PTR _lIntegerValue$[ebp]
	mov	DWORD PTR _lWork$[ebp], edx

; 8252 :             nRC = (lWork == 0) ? 0 : (lWork < 0) ? -1 : 1;

	jne	SHORT $LN22@fnCompareA
	mov	DWORD PTR tv95[ebp], 0
	jmp	SHORT $LN23@fnCompareA
$LN22@fnCompareA:
	cmp	DWORD PTR _lWork$[ebp], 0
	jge	SHORT $LN20@fnCompareA
	mov	DWORD PTR tv94[ebp], -1
	jmp	SHORT $LN21@fnCompareA
$LN20@fnCompareA:
	mov	DWORD PTR tv94[ebp], 1
$LN21@fnCompareA:
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], eax
$LN23@fnCompareA:
	mov	cx, WORD PTR tv95[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 8253 :             break;

	jmp	SHORT $LN2@fnCompareA
$LN11@fnCompareA:

; 8254 : 
; 8255 :          case zTYPE_DECIMAL:
; 8256 :             SysConvertLongToDecimal( lIntegerValue, &dWork );

	lea	edx, DWORD PTR _dWork$[ebp]
	push	edx
	mov	eax, DWORD PTR _lIntegerValue$[ebp]
	push	eax
	call	_SysConvertLongToDecimal@8

; 8257 :             nRC = SysCompareDecimalToDecimal( (zPDECIMAL) pchRecord, &dWork );

	lea	ecx, DWORD PTR _dWork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 8258 :             break;

	jmp	SHORT $LN2@fnCompareA
$LN12@fnCompareA:

; 8259 : 
; 8260 :          default:
; 8261 :          {
; 8262 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 8263 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$2[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$5[ebp], eax

; 8264 : 
; 8265 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8266 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	eax, DWORD PTR _lpView$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$5[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8267 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8268 :                               lpViewAttrib->szName );
; 8269 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN2@fnCompareA:

; 8270 :          }
; 8271 :       }
; 8272 :    }

	jmp	$LN7@fnCompareA
$LN6@fnCompareA:

; 8273 :    else
; 8274 :    {
; 8275 :       switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv160[ebp], dl
	cmp	BYTE PTR tv160[ebp], 76			; 0000004cH
	jl	SHORT $LN14@fnCompareA
	cmp	BYTE PTR tv160[ebp], 77			; 0000004dH
	jle	SHORT $LN13@fnCompareA
	cmp	BYTE PTR tv160[ebp], 83			; 00000053H
	je	SHORT $LN13@fnCompareA
	jmp	SHORT $LN14@fnCompareA
$LN13@fnCompareA:

; 8276 :       {
; 8277 :          case zTYPE_STRING:
; 8278 :          case zTYPE_INTEGER:
; 8279 :          case zTYPE_DECIMAL:
; 8280 :             lWork = 0;

	mov	DWORD PTR _lWork$[ebp], 0

; 8281 :             lWork -= lIntegerValue;

	mov	eax, DWORD PTR _lWork$[ebp]
	sub	eax, DWORD PTR _lIntegerValue$[ebp]
	mov	DWORD PTR _lWork$[ebp], eax

; 8282 :             nRC = (lWork == 0) ? 0 : (lWork < 0) ? -1 : 1;

	jne	SHORT $LN26@fnCompareA
	mov	DWORD PTR tv165[ebp], 0
	jmp	SHORT $LN27@fnCompareA
$LN26@fnCompareA:
	cmp	DWORD PTR _lWork$[ebp], 0
	jge	SHORT $LN24@fnCompareA
	mov	DWORD PTR tv164[ebp], -1
	jmp	SHORT $LN25@fnCompareA
$LN24@fnCompareA:
	mov	DWORD PTR tv164[ebp], 1
$LN25@fnCompareA:
	mov	ecx, DWORD PTR tv164[ebp]
	mov	DWORD PTR tv165[ebp], ecx
$LN27@fnCompareA:
	mov	dx, WORD PTR tv165[ebp]
	mov	WORD PTR _nRC$[ebp], dx

; 8283 :             break;

	jmp	SHORT $LN7@fnCompareA
$LN14@fnCompareA:

; 8284 : 
; 8285 :          default:
; 8286 :          {
; 8287 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 8288 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$4[ebp], eax

; 8289 : 
; 8290 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8291 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	eax, DWORD PTR _lpView$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$4[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8292 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8293 :                               lpViewAttrib->szName );
; 8294 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN7@fnCompareA:

; 8295 :          }
; 8296 :       }
; 8297 :    }
; 8298 : 
; 8299 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 8300 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareAttributeToInteger ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -144					; size = 4
_lpViewCsr$1 = -140					; size = 4
_lpViewCsr$2 = -136					; size = 4
_lpExternalP$3 = -132					; size = 4
_lpView$4 = -128					; size = 4
tv233 = -124						; size = 4
tv232 = -120						; size = 4
$T5 = -116						; size = 4
_lpView$6 = -112					; size = 4
tv180 = -108						; size = 4
tv179 = -104						; size = 4
_lTemp$ = -100						; size = 4
tv130 = -96						; size = 4
tv129 = -92						; size = 4
tv218 = -88						; size = 4
tv75 = -84						; size = 4
_pchRecord$ = -80					; size = 4
_nRC$ = -76						; size = 2
_dTemp$ = -72						; size = 40
_szWorkString$ = -32					; size = 25
__$ArrayPad$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_pchStringValue$ = 20					; size = 4
_fnCompareAttributeToString PROC

; 8042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 144				; 00000090H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8043 :    zPCHAR   pchRecord;
; 8044 :    zCHAR    szWorkString[ 25 ];
; 8045 :    zDECIMAL dTemp;
; 8046 :    zLONG    lTemp;
; 8047 :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8048 :    zSHORT   nRC;
; 8049 : 
; 8050 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 8051 : 
; 8052 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN6@fnCompareA

; 8053 :    {
; 8054 :       pchRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchRecord$[ebp], edx

; 8055 :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR tv75[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv75[ebp], edx
	cmp	DWORD PTR tv75[ebp], 18			; 00000012H
	ja	$LN35@fnCompareA
	mov	eax, DWORD PTR tv75[ebp]
	movzx	ecx, BYTE PTR $LN59@fnCompareA[eax]
	jmp	DWORD PTR $LN61@fnCompareA[ecx*4]
$LN8@fnCompareA:

; 8056 :       {
; 8057 :          case zTYPE_STRING:
; 8058 :             if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN9@fnCompareA

; 8059 :             {
; 8060 :                zCOREMEM  lpExternalP;
; 8061 : 
; 8062 :                lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$3[ebp], eax

; 8063 :                pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$3[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN9@fnCompareA:

; 8064 :             }
; 8065 : 
; 8066 :             if ( lpViewAttrib->bCaseSens )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN10@fnCompareA

; 8067 :                nRC = zstrcmp( pchRecord, pchStringValue );

	mov	edx, DWORD PTR _pchRecord$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN47@fnCompareA
	mov	eax, DWORD PTR _pchStringValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN48@fnCompareA
$LN47@fnCompareA:
	mov	edx, DWORD PTR _pchRecord$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN45@fnCompareA
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN46@fnCompareA
$LN45@fnCompareA:
	mov	DWORD PTR tv129[ebp], -1
$LN46@fnCompareA:
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv130[ebp], eax
$LN48@fnCompareA:
	mov	cx, WORD PTR tv130[ebp]
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN11@fnCompareA
$LN10@fnCompareA:

; 8068 :             else
; 8069 :                nRC = zstrcmpi( pchRecord, pchStringValue );

	mov	edx, DWORD PTR _pchStringValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN11@fnCompareA:

; 8070 : 
; 8071 :             if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN12@fnCompareA

; 8072 :                nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN13@fnCompareA
$LN12@fnCompareA:

; 8073 :             else
; 8074 :             if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN13@fnCompareA

; 8075 :                nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN13@fnCompareA:

; 8076 : 
; 8077 :             break;

	jmp	$LN2@fnCompareA
$LN15@fnCompareA:

; 8078 : 
; 8079 :          case zTYPE_INTEGER:
; 8080 :             if ( pchStringValue[ 0 ] == 0 &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN16@fnCompareA
	mov	eax, DWORD PTR _pchRecord$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN16@fnCompareA

; 8081 :                  *((zPLONG) pchRecord) == lNullInteger )
; 8082 :             {
; 8083 :                // empty string matches NULL integer
; 8084 :                nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 8085 :                break;

	jmp	$LN2@fnCompareA
$LN16@fnCompareA:

; 8086 :             }
; 8087 : 
; 8088 :             lTemp = zatol( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lTemp$[ebp], eax

; 8089 :             if ( *((zPLONG) pchRecord) < lTemp )

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lTemp$[ebp]
	jge	SHORT $LN17@fnCompareA

; 8090 :                nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN18@fnCompareA
$LN17@fnCompareA:

; 8091 :             else
; 8092 :             if ( *((zPLONG) pchRecord) > lTemp )

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lTemp$[ebp]
	jle	SHORT $LN19@fnCompareA

; 8093 :                nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN18@fnCompareA
$LN19@fnCompareA:

; 8094 :             else
; 8095 :                nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN18@fnCompareA:

; 8096 : 
; 8097 :             break;

	jmp	$LN2@fnCompareA
$LN21@fnCompareA:

; 8098 : 
; 8099 :          case zTYPE_DECIMAL:
; 8100 :             // fnConvertDecimalToString and string comparison
; 8101 :             // is invalid, because the string representation is not unique
; 8102 :             if ( pchStringValue[ 0 ] == 0 &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN22@fnCompareA
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN22@fnCompareA

; 8103 :                  SysCompareDecimalToNull( (zPDECIMAL) pchRecord) == 0 )
; 8104 :             {
; 8105 :                // empty string matches NULL decimal
; 8106 :                nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 8107 :                break;

	jmp	$LN2@fnCompareA
$LN22@fnCompareA:

; 8108 :             }
; 8109 : 
; 8110 :             SysConvertStringToDecimal( pchStringValue, &dTemp );

	lea	eax, DWORD PTR _dTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	push	ecx
	call	_SysConvertStringToDecimal@8

; 8111 :             nRC = SysCompareDecimalToDecimal( (zPDECIMAL) pchRecord, &dTemp );

	lea	edx, DWORD PTR _dTemp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 8112 :             if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN23@fnCompareA

; 8113 :                nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN24@fnCompareA
$LN23@fnCompareA:

; 8114 :             else
; 8115 :             if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN24@fnCompareA

; 8116 :                nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN24@fnCompareA:

; 8117 : 
; 8118 :             break;

	jmp	$LN2@fnCompareA
$LN26@fnCompareA:

; 8119 : 
; 8120 :          case zTYPE_DATETIME:
; 8121 :             UfDateTimeToString( (LPDATETIME) pchRecord, szWorkString, 18 );

	push	18					; 00000012H
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	call	_UfDateTimeToString@12

; 8122 :             nRC = zstrcmp( szWorkString, pchStringValue );

	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	mov	edx, DWORD PTR _pchStringValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN51@fnCompareA
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv180[ebp], eax
	jmp	SHORT $LN52@fnCompareA
$LN51@fnCompareA:
	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN49@fnCompareA
	mov	DWORD PTR tv179[ebp], 1
	jmp	SHORT $LN50@fnCompareA
$LN49@fnCompareA:
	mov	DWORD PTR tv179[ebp], -1
$LN50@fnCompareA:
	mov	eax, DWORD PTR tv179[ebp]
	mov	DWORD PTR tv180[ebp], eax
$LN52@fnCompareA:
	mov	cx, WORD PTR tv180[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 8123 :             if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN27@fnCompareA

; 8124 :                nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN28@fnCompareA
$LN27@fnCompareA:

; 8125 :             else
; 8126 :             if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN28@fnCompareA

; 8127 :                nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN28@fnCompareA:

; 8128 : 
; 8129 :             break;

	jmp	$LN2@fnCompareA
$LN30@fnCompareA:

; 8130 : 
; 8131 :          case zTYPE_BLOB:
; 8132 :             // We only allow a comparison of strings to blobs if the comparison
; 8133 :             // string is NULL.
; 8134 :             if ( pchStringValue == 0 || pchStringValue[ 0 ] == 0 )

	cmp	DWORD PTR _pchStringValue$[ebp], 0
	je	SHORT $LN32@fnCompareA
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchStringValue$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN35@fnCompareA
$LN32@fnCompareA:

; 8135 :             {
; 8136 :               if ( pchRecord[ 0 ] != (zCHAR) '\xff' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	je	SHORT $LN33@fnCompareA

; 8137 :                  nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN34@fnCompareA
$LN33@fnCompareA:

; 8138 :               else
; 8139 :                  nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
$LN34@fnCompareA:

; 8140 : 
; 8141 :               break;

	jmp	SHORT $LN2@fnCompareA
$LN35@fnCompareA:

; 8142 :             }
; 8143 : 
; 8144 :             // NOTE: FALL THROUGH...
; 8145 :             // NOTE: FALL THROUGH...
; 8146 :             // NOTE: FALL THROUGH...
; 8147 : 
; 8148 :          default:
; 8149 :          {
; 8150 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 8151 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$2[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$6[ebp], eax

; 8152 : 
; 8153 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8154 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	ecx, DWORD PTR _lpView$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$6[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8155 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8156 :                               lpViewAttrib->szName );
; 8157 :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnCompareA:

; 8158 :          }
; 8159 :       }
; 8160 :    }

	jmp	$LN7@fnCompareA
$LN6@fnCompareA:

; 8161 :    else
; 8162 :    {
; 8163 :       switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR tv218[ebp], eax
	mov	ecx, DWORD PTR tv218[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv218[ebp], ecx
	cmp	DWORD PTR tv218[ebp], 18		; 00000012H
	ja	$LN43@fnCompareA
	mov	edx, DWORD PTR tv218[ebp]
	movzx	eax, BYTE PTR $LN60@fnCompareA[edx]
	jmp	DWORD PTR $LN62@fnCompareA[eax*4]
$LN36@fnCompareA:

; 8164 :       {
; 8165 :          case zTYPE_STRING:
; 8166 :          case zTYPE_INTEGER:
; 8167 :          case zTYPE_DECIMAL:
; 8168 :          case zTYPE_DATETIME:
; 8169 :             szWorkString[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 25			; 00000019H
	jae	SHORT $LN53@fnCompareA
	jmp	SHORT $LN54@fnCompareA
$LN53@fnCompareA:
	call	___report_rangecheckfailure
$LN54@fnCompareA:
	mov	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0

; 8170 :             nRC = zstrcmp( szWorkString, pchStringValue );

	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	mov	edx, DWORD PTR _pchStringValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN57@fnCompareA
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv233[ebp], eax
	jmp	SHORT $LN58@fnCompareA
$LN57@fnCompareA:
	movsx	eax, BYTE PTR _szWorkString$[ebp]
	mov	ecx, DWORD PTR _pchStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN55@fnCompareA
	mov	DWORD PTR tv232[ebp], 1
	jmp	SHORT $LN56@fnCompareA
$LN55@fnCompareA:
	mov	DWORD PTR tv232[ebp], -1
$LN56@fnCompareA:
	mov	eax, DWORD PTR tv232[ebp]
	mov	DWORD PTR tv233[ebp], eax
$LN58@fnCompareA:
	mov	cx, WORD PTR tv233[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 8171 :             if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN37@fnCompareA

; 8172 :                nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN38@fnCompareA
$LN37@fnCompareA:

; 8173 :             else
; 8174 :             if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN38@fnCompareA

; 8175 :                nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN38@fnCompareA:

; 8176 : 
; 8177 :             break;

	jmp	$LN7@fnCompareA
$LN40@fnCompareA:

; 8178 : 
; 8179 :          case zTYPE_BLOB:
; 8180 :             // We only allow a comparison of strings to blobs if the comparison
; 8181 :             // string is NULL.
; 8182 :             if ( pchStringValue == 0 || pchStringValue[ 0 ] == 0 )

	cmp	DWORD PTR _pchStringValue$[ebp], 0
	je	SHORT $LN42@fnCompareA
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchStringValue$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN43@fnCompareA
$LN42@fnCompareA:

; 8183 :             {
; 8184 :                nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 8185 :                break;

	jmp	SHORT $LN7@fnCompareA
$LN43@fnCompareA:

; 8186 :             }
; 8187 : 
; 8188 :             // NOTE: FALL THROUGH...
; 8189 :             // NOTE: FALL THROUGH...
; 8190 :             // NOTE: FALL THROUGH...
; 8191 : 
; 8192 :          default:
; 8193 :          {
; 8194 :             LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 8195 :             zVIEW     lpView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$4[ebp], eax

; 8196 : 
; 8197 :             // "KZOEE239 - Invalid Operation for attribute type"
; 8198 :             fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$4[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8199 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 8200 :                               lpViewAttrib->szName );
; 8201 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN7@fnCompareA:

; 8202 :          }
; 8203 :       }
; 8204 :    }
; 8205 : 
; 8206 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN44@fnCompareA:

; 8207 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN61@fnCompareA:
	DD	$LN30@fnCompareA
	DD	$LN15@fnCompareA
	DD	$LN21@fnCompareA
	DD	$LN8@fnCompareA
	DD	$LN26@fnCompareA
	DD	$LN35@fnCompareA
$LN59@fnCompareA:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
	npad	1
$LN62@fnCompareA:
	DD	$LN40@fnCompareA
	DD	$LN36@fnCompareA
	DD	$LN43@fnCompareA
$LN60@fnCompareA:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
_fnCompareAttributeToString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
tv77 = -16						; size = 4
_j$ = -12						; size = 2
_k$ = -8						; size = 2
_i$ = -4						; size = 2
_pchString$ = 8						; size = 4
_pchFormat$ = 12					; size = 4
_sFormatOut PROC

; 6415 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 6416 :    zSHORT i, j, k;
; 6417 : 
; 6418 :    i = 0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 6419 :    j = 0;

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx

; 6420 : 
; 6421 :    if ( pchString[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN2@sFormatOut

; 6422 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@sFormatOut
$LN2@sFormatOut:

; 6423 : 
; 6424 :    while ( pchFormat[ i ] )

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pchFormat$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	$LN3@sFormatOut

; 6425 :    {
; 6426 :       switch ( pchFormat[ i ] )

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pchFormat$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	DWORD PTR tv77[ebp], edx
	mov	eax, DWORD PTR tv77[ebp]
	sub	eax, 42					; 0000002aH
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 55			; 00000037H
	ja	SHORT $LN13@sFormatOut
	mov	ecx, DWORD PTR tv77[ebp]
	movzx	edx, BYTE PTR $LN16@sFormatOut[ecx]
	jmp	DWORD PTR $LN17@sFormatOut[edx*4]
$LN11@sFormatOut:

; 6427 :       {
; 6428 :          case  '9':
; 6429 :          case  'A':
; 6430 :          case  'a':
; 6431 :          case  'X':
; 6432 :          case  '*':
; 6433 :             if ( pchString[ j ] == 0 )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN12@sFormatOut

; 6434 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@sFormatOut
$LN12@sFormatOut:

; 6435 : 
; 6436 :             break;

	jmp	$LN4@sFormatOut
$LN13@sFormatOut:

; 6437 : 
; 6438 :          default:
; 6439 :             if ( pchFormat[ i ] == '\\' && pchFormat[ i + 1 ] )

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pchFormat$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 92					; 0000005cH
	jne	SHORT $LN14@sFormatOut
	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pchFormat$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+1]
	test	edx, edx
	je	SHORT $LN14@sFormatOut

; 6440 :                i++;

	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
$LN14@sFormatOut:

; 6441 : 
; 6442 :             k = j;

	mov	cx, WORD PTR _j$[ebp]
	mov	WORD PTR _k$[ebp], cx
$LN6@sFormatOut:

; 6443 :             while ( pchString[ k ] )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN8@sFormatOut

; 6444 :                k++;

	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN6@sFormatOut
$LN8@sFormatOut:

; 6445 : 
; 6446 :             while ( k >= j )

	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN9@sFormatOut

; 6447 :             {
; 6448 :                pchString[ k + 1 ] = pchString[ k ];

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchString$[ebp]
	mov	esi, DWORD PTR _pchString$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax+1], dl

; 6449 :                k--;

	mov	ax, WORD PTR _k$[ebp]
	sub	ax, 1
	mov	WORD PTR _k$[ebp], ax

; 6450 :             }

	jmp	SHORT $LN8@sFormatOut
$LN9@sFormatOut:

; 6451 : 
; 6452 :             pchString[ j ] = pchFormat[ i ];

	movsx	ecx, WORD PTR _i$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pchString$[ebp]
	mov	esi, DWORD PTR _pchFormat$[ebp]
	mov	cl, BYTE PTR [esi+ecx]
	mov	BYTE PTR [eax+edx], cl
$LN4@sFormatOut:

; 6453 :       }
; 6454 : 
; 6455 :       i++;

	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx

; 6456 :       j++;

	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax

; 6457 :    }

	jmp	$LN2@sFormatOut
$LN3@sFormatOut:

; 6458 : 
; 6459 :    return( 0 );

	xor	eax, eax
$LN1@sFormatOut:

; 6460 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN17@sFormatOut:
	DD	$LN11@sFormatOut
	DD	$LN13@sFormatOut
$LN16@sFormatOut:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
_sFormatOut ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
tv73 = -20						; size = 4
_l$ = -16						; size = 2
_i$ = -12						; size = 2
_k$ = -8						; size = 2
_j$ = -4						; size = 2
_pchString$ = 8						; size = 4
_pchFormat$ = 12					; size = 4
_pchEdit$ = 16						; size = 4
_sFormatIn PROC

; 6302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 6303 :    short i, j, k, l;
; 6304 : 
; 6305 :    i = 0;

	xor	eax, eax
	mov	WORD PTR _i$[ebp], ax

; 6306 :    j = 0;

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
$LN2@sFormatIn:

; 6307 :    while ( pchString[ j ] )

	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pchString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	$LN3@sFormatIn

; 6308 :    {
; 6309 :       switch ( pchFormat[ i ] )

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pchFormat$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR tv73[ebp], ecx
	cmp	DWORD PTR tv73[ebp], 97			; 00000061H
	ja	$LN29@sFormatIn
	mov	edx, DWORD PTR tv73[ebp]
	movzx	eax, BYTE PTR $LN34@sFormatIn[edx]
	jmp	DWORD PTR $LN35@sFormatIn[eax*4]
$LN14@sFormatIn:

; 6310 :       {
; 6311 :          case  0:
; 6312 :             return( 1 );

	mov	al, 1
	jmp	$LN1@sFormatIn
$LN15@sFormatIn:

; 6313 : 
; 6314 :          case  '9':
; 6315 :             if ( isdigit( pchString[ j ] ) == FALSE )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@sFormatIn

; 6316 :                return( 1 );

	mov	al, 1
	jmp	$LN1@sFormatIn
$LN16@sFormatIn:

; 6317 : 
; 6318 :             break;

	jmp	$LN4@sFormatIn
$LN17@sFormatIn:

; 6319 : 
; 6320 :          case  'A':
; 6321 :             if ( isupper( pchString[ j ] ) == FALSE )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isupper
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@sFormatIn

; 6322 :                return( 1 );

	mov	al, 1
	jmp	$LN1@sFormatIn
$LN18@sFormatIn:

; 6323 : 
; 6324 :             break;

	jmp	$LN4@sFormatIn
$LN19@sFormatIn:

; 6325 : 
; 6326 :          case  'a':
; 6327 :             if ( isalpha( pchString[ j ] ) == FALSE )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN20@sFormatIn

; 6328 :                return( 1 );

	mov	al, 1
	jmp	$LN1@sFormatIn
$LN20@sFormatIn:

; 6329 : 
; 6330 :             break;

	jmp	$LN4@sFormatIn
$LN21@sFormatIn:

; 6331 : 
; 6332 :          case  'X':
; 6333 :             if ( zisalnum( pchString[ j ] ) == FALSE )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@sFormatIn

; 6334 :                return( 1 );

	mov	al, 1
	jmp	$LN1@sFormatIn
$LN22@sFormatIn:

; 6335 : 
; 6336 :             break;

	jmp	$LN4@sFormatIn
$LN23@sFormatIn:

; 6337 : 
; 6338 :          case  '*':
; 6339 :             break;

	jmp	$LN4@sFormatIn
$LN24@sFormatIn:

; 6340 : 
; 6341 :          case  '\\':
; 6342 :             j--;

	mov	cx, WORD PTR _j$[ebp]
	sub	cx, 1
	mov	WORD PTR _j$[ebp], cx

; 6343 :             break;

	jmp	$LN4@sFormatIn
$LN25@sFormatIn:

; 6344 : 
; 6345 :          case  ' ':
; 6346 :             if ( pchString[ j ] == ' ' )

	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pchString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN26@sFormatIn

; 6347 :             {
; 6348 :                k = j + 1;

	movsx	edx, WORD PTR _j$[ebp]
	add	edx, 1
	mov	WORD PTR _k$[ebp], dx
$LN6@sFormatIn:

; 6349 :                while( pchString[ k ] == ' ' )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN7@sFormatIn

; 6350 :                   k++;

	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN6@sFormatIn
$LN7@sFormatIn:

; 6351 : 
; 6352 :                l = j;

	mov	cx, WORD PTR _j$[ebp]
	mov	WORD PTR _l$[ebp], cx
$LN10@sFormatIn:

; 6353 :                for ( ; ; )
; 6354 :                {
; 6355 :                   pchString[ l++ ] = pchString[ k ];

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _l$[ebp]
	mov	ecx, DWORD PTR _pchString$[ebp]
	mov	esi, DWORD PTR _pchString$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	ax, WORD PTR _l$[ebp]
	add	ax, 1
	mov	WORD PTR _l$[ebp], ax

; 6356 :                   if ( pchString[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN28@sFormatIn

; 6357 :                      break;

	jmp	SHORT $LN9@sFormatIn
$LN28@sFormatIn:

; 6358 : 
; 6359 :                   k++;

	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx

; 6360 :                }

	jmp	SHORT $LN10@sFormatIn
$LN9@sFormatIn:

; 6361 : 
; 6362 :                break;

	jmp	SHORT $LN4@sFormatIn

; 6363 :             }

	jmp	SHORT $LN29@sFormatIn
$LN26@sFormatIn:

; 6364 :             else
; 6365 :                return( 1 );

	mov	al, 1
	jmp	$LN1@sFormatIn
$LN29@sFormatIn:

; 6366 : 
; 6367 :          default:
; 6368 :             if ( pchFormat[ i ] != pchString[ j ] )

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pchFormat$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pchString$[ebp]
	movsx	edx, BYTE PTR [eax+edx]
	cmp	ecx, edx
	je	SHORT $LN30@sFormatIn

; 6369 :                return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@sFormatIn
$LN30@sFormatIn:

; 6370 : 
; 6371 :             k = j;

	mov	ax, WORD PTR _j$[ebp]
	mov	WORD PTR _k$[ebp], ax
$LN13@sFormatIn:

; 6372 :             for ( ; ; )
; 6373 :             {
; 6374 :                pchString[ k ] = pchString[ k + 1 ];

	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchString$[ebp]
	mov	esi, DWORD PTR _pchString$[ebp]
	mov	cl, BYTE PTR [esi+ecx+1]
	mov	BYTE PTR [eax+edx], cl

; 6375 :                if ( pchString[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN31@sFormatIn

; 6376 :                   break;

	jmp	SHORT $LN12@sFormatIn
$LN31@sFormatIn:

; 6377 : 
; 6378 :                k++;

	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 6379 :             }

	jmp	SHORT $LN13@sFormatIn
$LN12@sFormatIn:

; 6380 : 
; 6381 :             j--;

	mov	ax, WORD PTR _j$[ebp]
	sub	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN4@sFormatIn:

; 6382 :         }
; 6383 : 
; 6384 :         i++;

	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx

; 6385 :         j++;

	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx

; 6386 :     }

	jmp	$LN2@sFormatIn
$LN3@sFormatIn:

; 6387 : 
; 6388 :     if ( pchFormat[ i ] )

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pchFormat$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN32@sFormatIn

; 6389 :        return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@sFormatIn
$LN32@sFormatIn:

; 6390 : 
; 6391 :     return( 0 );

	xor	al, al
$LN1@sFormatIn:

; 6392 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN35@sFormatIn:
	DD	$LN14@sFormatIn
	DD	$LN25@sFormatIn
	DD	$LN23@sFormatIn
	DD	$LN15@sFormatIn
	DD	$LN17@sFormatIn
	DD	$LN21@sFormatIn
	DD	$LN24@sFormatIn
	DD	$LN19@sFormatIn
	DD	$LN29@sFormatIn
$LN34@sFormatIn:
	DB	0
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
_sFormatIn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lReturn$ = -80						; size = 4
_vOldStackObject$ = -76					; size = 4
_pchObjectName$ = -72					; size = 4
_lpViewOD$1 = -68					; size = 4
_lpCurrentTask$ = -64					; size = 4
_lpApp$ = -60						; size = 4
_vAppSubtask$ = -56					; size = 4
_hLibrary$2 = -52					; size = 4
_ulLth$ = -48						; size = 4
_vXPG$ = -44						; size = 4
_pchData$ = -40						; size = 4
_nRC$ = -36						; size = 2
_bDropSubtask$ = -29					; size = 1
_vStackObject$ = -28					; size = 4
_vSubtask$ = -24					; size = 4
_szOperName$ = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_nFlag$ = 20						; size = 2
_DfExecuteXPG@16 PROC

; 6014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6015 :    LPAPP  lpApp;
; 6016 :    zVIEW  vSubtask;
; 6017 :    zVIEW  vAppSubtask;
; 6018 :    zVIEW  vXPG;
; 6019 :    zVIEW  vStackObject;
; 6020 :    zVIEW  vOldStackObject;
; 6021 :    LPTASK lpCurrentTask;
; 6022 :    zCHAR  szOperName[] = "DerivedFunction";

	mov	eax, DWORD PTR $SG16607
	mov	DWORD PTR _szOperName$[ebp], eax
	mov	ecx, DWORD PTR $SG16607+4
	mov	DWORD PTR _szOperName$[ebp+4], ecx
	mov	edx, DWORD PTR $SG16607+8
	mov	DWORD PTR _szOperName$[ebp+8], edx
	mov	eax, DWORD PTR $SG16607+12
	mov	DWORD PTR _szOperName$[ebp+12], eax

; 6023 :    zULONG ulLth;
; 6024 :    zPCHAR pchData;
; 6025 :    zPCHAR pchObjectName;
; 6026 :    zLONG  lReturn;
; 6027 :    zBOOL  bDropSubtask;
; 6028 :    zSHORT nRC;
; 6029 : 
; 6030 :    static PFNINTERP pfnInterp = 0;
; 6031 : 
; 6032 :    // We'll never set this attribute.
; 6033 :    if ( nFlag == zDERIVED_SET )

	movsx	ecx, WORD PTR _nFlag$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN2@DfExecuteX

; 6034 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@DfExecuteX
$LN2@DfExecuteX:

; 6035 : 
; 6036 :    lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 6037 : // lpCurrentTask = fnFindTask( 0 );  // dks 2006.05.07  back to 10B
; 6038 : 
; 6039 :    // Set up interpreter.
; 6040 :    // Create the appl subtask.
; 6041 :    fnGetApplicationForSubtask( &lpApp, lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 6042 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 6043 :    vAppSubtask = fnCreateSubtask( lpCurrentTask, lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCreateSubtask
	add	esp, 8
	mov	DWORD PTR _vAppSubtask$[ebp], eax

; 6044 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 6045 : 
; 6046 :    // It's possible that we are being called recursively.  This will happen if
; 6047 :    // a derived expression references another attrib with a derived expr.  We
; 6048 :    // need to make sure that when we leave this function the OIs needed for the
; 6049 :    // parent derived expr are still in place.
; 6050 :    GetViewByName( &vSubtask, "ZeidonVML", lpView, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	OFFSET $SG16609
	lea	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_GetViewByName@16

; 6051 :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $LN3@DfExecuteX

; 6052 :    {
; 6053 :       // No parent derived expr.  Do normal init processing.
; 6054 :       bDropSubtask = TRUE;

	mov	BYTE PTR _bDropSubtask$[ebp], 1

; 6055 :       SfCreateSubtask( &vSubtask, lpView, "Zeidon_Tools" );

	push	OFFSET $SG16612
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SfCreateSubtask@12

; 6056 : 
; 6057 :       // name the ZeidonVML subtask at the task level.
; 6058 :       SetNameForView( vSubtask, "ZeidonVML", lpView, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET $SG16613
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SetNameForView@16

; 6059 :    }

	jmp	SHORT $LN4@DfExecuteX
$LN3@DfExecuteX:

; 6060 :    else
; 6061 :    {
; 6062 :       // We must be in the process of being called recursively.  Don't create
; 6063 :       // a new subtask and save the current stack OI.
; 6064 :       bDropSubtask = FALSE;

	mov	BYTE PTR _bDropSubtask$[ebp], 0

; 6065 : 
; 6066 :       // Save the current stack object OI.
; 6067 :       GetViewByName( &vOldStackObject, "StackObject", vSubtask, zLEVEL_SUBTASK );

	push	1
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET $SG16614
	lea	eax, DWORD PTR _vOldStackObject$[ebp]
	push	eax
	call	_GetViewByName@16
$LN4@DfExecuteX:

; 6068 :    }
; 6069 : 
; 6070 :    // Get a pointer to the begining of the OI data.  For OIs stored as blobs
; 6071 :    // there is some header information that we don't need, so skip over it.
; 6072 :    pchData = (zPCHAR) zGETPTR( lpViewAttrib->hDerivedXPG );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+255]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchData$[ebp], eax

; 6073 :    ulLth  = fnGetDataspaceLength( pchData );

	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	call	_fnGetDataspaceLength
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 6074 :    pchData += sizeof( BlobOI_Record );

	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, 137				; 00000089H
	mov	DWORD PTR _pchData$[ebp], ecx

; 6075 :    ulLth  -= sizeof( BlobOI_Record );

	mov	edx, DWORD PTR _ulLth$[ebp]
	sub	edx, 137				; 00000089H
	mov	DWORD PTR _ulLth$[ebp], edx

; 6076 : 
; 6077 :    // "Activate" the XPG from the binary data.
; 6078 :    if ( GetViewByName( &vXPG, "LastXPG", vSubtask, zLEVEL_TASK ) < 0 )

	push	2
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG16617
	lea	ecx, DWORD PTR _vXPG$[ebp]
	push	ecx
	call	_GetViewByName@16
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN5@DfExecuteX

; 6079 :       nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN6@DfExecuteX
$LN5@DfExecuteX:

; 6080 :    else
; 6081 :    {
; 6082 :       LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 6083 : 
; 6084 :       pchObjectName = lpViewOD->szName;

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR _pchObjectName$[ebp], eax

; 6085 :       if ( CompareAttributeToString( vXPG, "VML_XSource",
; 6086 :                                      "MetaName", pchObjectName ) == 0 )

	mov	ecx, DWORD PTR _pchObjectName$[ebp]
	push	ecx
	push	OFFSET $SG16620
	push	OFFSET $SG16621
	mov	edx, DWORD PTR _vXPG$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN7@DfExecuteX

; 6087 :       {
; 6088 :          nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 6089 :       }

	jmp	SHORT $LN6@DfExecuteX
$LN7@DfExecuteX:

; 6090 :       else
; 6091 :       {
; 6092 :          nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
$LN6@DfExecuteX:

; 6093 :       }
; 6094 :    }
; 6095 : 
; 6096 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN9@DfExecuteX

; 6097 :    {
; 6098 :       nRC = fnActivateOI_FromBuffer( &vXPG, "TZVSPOOO", vSubtask,

	push	0
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchData$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG16623
	lea	ecx, DWORD PTR _vXPG$[ebp]
	push	ecx
	call	_fnActivateOI_FromBuffer@24
	mov	WORD PTR _nRC$[ebp], ax

; 6099 :                                      pchData, ulLth, zSINGLE );
; 6100 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN10@DfExecuteX

; 6101 :       {
; 6102 :          SysMessageBox( lpView, "Internal Core Error",

	push	1
	push	OFFSET $SG16625
	push	OFFSET $SG16626
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 6103 :                         "Error reading OI from buffer", 1 );
; 6104 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DfExecuteX
$LN10@DfExecuteX:

; 6105 :       }
; 6106 : 
; 6107 :       SetNameForView( vXPG, "LastXPG", vSubtask, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	OFFSET $SG16627
	mov	edx, DWORD PTR _vXPG$[ebp]
	push	edx
	call	_SetNameForView@16
$LN9@DfExecuteX:

; 6108 :    }
; 6109 : 
; 6110 :    SetNameForView( vXPG, "XPG", vSubtask, zLEVEL_SUBTASK );

	push	1
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG16628
	mov	ecx, DWORD PTR _vXPG$[ebp]
	push	ecx
	call	_SetNameForView@16

; 6111 : 
; 6112 :    // Initialize the stack object with arguments for the operation.
; 6113 :    ActivateEmptyObjectInstance( &vStackObject, "TZVSRTOO", vSubtask, zSINGLE );

	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET $SG16629
	lea	eax, DWORD PTR _vStackObject$[ebp]
	push	eax
	call	_ActivateEmptyObjectInstance@16

; 6114 :    CreateEntity( vStackObject, "StackObject", zPOS_AFTER );

	push	3
	push	OFFSET $SG16630
	mov	ecx, DWORD PTR _vStackObject$[ebp]
	push	ecx
	call	_CreateEntity@12

; 6115 :    CreateEntity( vStackObject, "OperationCall", zPOS_AFTER );

	push	3
	push	OFFSET $SG16631
	mov	edx, DWORD PTR _vStackObject$[ebp]
	push	edx
	call	_CreateEntity@12

; 6116 :    SetAttributeFromString( vStackObject, "OperationCall", "Name",

	lea	eax, DWORD PTR _szOperName$[ebp]
	push	eax
	push	OFFSET $SG16632
	push	OFFSET $SG16633
	mov	ecx, DWORD PTR _vStackObject$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 6117 :                            szOperName );
; 6118 : 
; 6119 :    CreateEntity( vStackObject, "Variable", zPOS_AFTER );

	push	3
	push	OFFSET $SG16634
	mov	edx, DWORD PTR _vStackObject$[ebp]
	push	edx
	call	_CreateEntity@12

; 6120 :    SetAttributeFromInteger( vStackObject, "Variable", "ID", 1 );

	push	1
	push	OFFSET $SG16635
	push	OFFSET $SG16636
	mov	eax, DWORD PTR _vStackObject$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 6121 :    SetAttributeFromString( vStackObject, "Variable", "Name",

	push	OFFSET $SG16637
	push	OFFSET $SG16638
	push	OFFSET $SG16639
	mov	ecx, DWORD PTR _vStackObject$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 6122 :                            "vSubtask" );
; 6123 : 
; 6124 :    CreateEntity( vStackObject, "Variable", zPOS_AFTER );

	push	3
	push	OFFSET $SG16640
	mov	edx, DWORD PTR _vStackObject$[ebp]
	push	edx
	call	_CreateEntity@12

; 6125 :    SetAttributeFromInteger( vStackObject, "Variable", "ID", 2 );

	push	2
	push	OFFSET $SG16641
	push	OFFSET $SG16642
	mov	eax, DWORD PTR _vStackObject$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 6126 :    SetAttributeFromString( vStackObject, "Variable", "Name",

	push	OFFSET $SG16643
	push	OFFSET $SG16644
	push	OFFSET $SG16645
	mov	ecx, DWORD PTR _vStackObject$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 6127 :                            "vView" );
; 6128 :    SetAttributeFromBlob( vStackObject, "Variable", "Value",

	push	4
	lea	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	OFFSET $SG16646
	push	OFFSET $SG16647
	mov	eax, DWORD PTR _vStackObject$[ebp]
	push	eax
	call	_SetAttributeFromBlob@20

; 6129 :                          (zPVOID) &lpView, sizeof( lpView ) );
; 6130 : 
; 6131 :    // Name the Stack Object
; 6132 :    SetNameForView( vStackObject, "StackObject", vSubtask, zLEVEL_SUBTASK );

	push	1
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	OFFSET $SG16648
	mov	edx, DWORD PTR _vStackObject$[ebp]
	push	edx
	call	_SetNameForView@16

; 6133 : 
; 6134 :    if ( pfnInterp == 0 )

	cmp	DWORD PTR ?pfnInterp@?1??DfExecuteXPG@@9@9, 0
	jne	SHORT $LN11@DfExecuteX

; 6135 :    {
; 6136 :       // Load the library.  We'll let core clean it up for us later.
; 6137 :       LPLIBRARY hLibrary = SysLoadLibrary( vSubtask, "TZVMLOPR" );

	push	OFFSET $SG16650
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$2[ebp], eax

; 6138 : 
; 6139 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$2[ebp], 0
	jne	SHORT $LN12@DfExecuteX

; 6140 :       {
; 6141 :          SysMessageBox( lpView, "Zeidon Interpretor Error",

	push	1
	push	OFFSET $SG16653
	push	OFFSET $SG16654
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 6142 :                         "Could not locate TZVMLOPR.DLL", TRUE );
; 6143 :       }

	jmp	SHORT $LN11@DfExecuteX
$LN12@DfExecuteX:

; 6144 :       else
; 6145 :          pfnInterp = (PFNINTERP) SysGetProc( hLibrary, "InvokeInterp" );

	push	OFFSET $SG16655
	mov	edx, DWORD PTR _hLibrary$2[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR ?pfnInterp@?1??DfExecuteXPG@@9@9, eax
$LN11@DfExecuteX:

; 6146 :    }
; 6147 : 
; 6148 :    if ( pfnInterp )

	cmp	DWORD PTR ?pfnInterp@?1??DfExecuteXPG@@9@9, 0
	je	SHORT $LN14@DfExecuteX

; 6149 :       (*pfnInterp)( vSubtask, vAppSubtask, "", szOperName, &lReturn );

	lea	eax, DWORD PTR _lReturn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOperName$[ebp]
	push	ecx
	push	OFFSET $SG16657
	mov	edx, DWORD PTR _vAppSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	DWORD PTR ?pfnInterp@?1??DfExecuteXPG@@9@9
$LN14@DfExecuteX:

; 6150 : 
; 6151 :    // Drop views.  Note that vXPG has already been dropped by InvokeInterp( ).
; 6152 :    fnDropView( vStackObject );

	mov	ecx, DWORD PTR _vStackObject$[ebp]
	push	ecx
	call	_fnDropView@4

; 6153 :    SfDropSubtask( vAppSubtask, 0 );

	push	0
	mov	edx, DWORD PTR _vAppSubtask$[ebp]
	push	edx
	call	_SfDropSubtask@8

; 6154 :    if ( bDropSubtask )

	movzx	eax, BYTE PTR _bDropSubtask$[ebp]
	test	eax, eax
	je	SHORT $LN15@DfExecuteX

; 6155 :       SfDropSubtask( vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SfDropSubtask@8
	jmp	SHORT $LN16@DfExecuteX
$LN15@DfExecuteX:

; 6156 :    else
; 6157 :       SetNameForView( vOldStackObject, "StackObject", vSubtask, zLEVEL_SUBTASK );

	push	1
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET $SG16660
	mov	eax, DWORD PTR _vOldStackObject$[ebp]
	push	eax
	call	_SetNameForView@16
$LN16@DfExecuteX:

; 6158 : 
; 6159 :    return( 0 );

	xor	eax, eax
$LN1@DfExecuteX:

; 6160 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_DfExecuteXPG@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lNewValue$1 = -2204					; size = 4
$T2 = -2200						; size = 4
$T3 = -2196						; size = 4
$T4 = -2192						; size = 4
$T5 = -2188						; size = 4
$T6 = -2184						; size = 4
_lpSrcViewAttrib$ = -2180				; size = 4
tv156 = -2176						; size = 4
_lIntValue$ = -2172					; size = 4
_pchExpr$ = -2168					; size = 4
_chSign$ = -2162					; size = 1
_bInQuote$ = -2161					; size = 1
_idx$ = -2160						; size = 2
_dNewValue$7 = -2156					; size = 40
_dDecValue$ = -2116					; size = 40
_szConcatBuffer$ = -2076				; size = 2000
_szAttribName$ = -76					; size = 33
_szContextName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_nFlag$ = 20						; size = 2
_DfExprVML@16 PROC

; 5821 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2204				; 0000089cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5822 :    zCHAR        szConcatBuffer[ 2000 ];
; 5823 :    zCHAR        szContextName[ zZEIDON_NAME_LTH + 1 ];
; 5824 :    zCHAR        szAttribName[ zZEIDON_NAME_LTH + 1 ];
; 5825 :    zCHAR        chSign;
; 5826 :    zSHORT       idx;
; 5827 :    zBOOL        bInQuote;
; 5828 :    zLONG        lIntValue;
; 5829 :    zDECIMAL     dDecValue;
; 5830 :    zPCHAR       pchExpr = zGETPTR( lpViewAttrib->hDerivedExpr );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+246]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchExpr$[ebp], eax

; 5831 :    LPVIEWATTRIB lpSrcViewAttrib;
; 5832 : 
; 5833 :    // We'll never set this attribute.
; 5834 :    if ( nFlag == zDERIVED_SET )

	movsx	edx, WORD PTR _nFlag$[ebp]
	cmp	edx, 1
	jne	SHORT $LN9@DfExprVML

; 5835 :       return( 0 );

	xor	eax, eax
	jmp	$LN31@DfExprVML
$LN9@DfExprVML:

; 5836 : 
; 5837 :    // Initialize each of the temp storage areas.
; 5838 :    szConcatBuffer[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T6[ebp], ecx
	cmp	DWORD PTR $T6[ebp], 2000		; 000007d0H
	jae	SHORT $LN32@DfExprVML
	jmp	SHORT $LN33@DfExprVML
$LN32@DfExprVML:
	call	___report_rangecheckfailure
$LN33@DfExprVML:
	mov	edx, DWORD PTR $T6[ebp]
	mov	BYTE PTR _szConcatBuffer$[ebp+edx], 0

; 5839 :    bInQuote            = FALSE;

	mov	BYTE PTR _bInQuote$[ebp], 0

; 5840 :    szContextName[ 0 ]  = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 33			; 00000021H
	jae	SHORT $LN34@DfExprVML
	jmp	SHORT $LN35@DfExprVML
$LN34@DfExprVML:
	call	___report_rangecheckfailure
$LN35@DfExprVML:
	mov	edx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _szContextName$[ebp+edx], 0

; 5841 :    lIntValue           = 0;

	mov	DWORD PTR _lIntValue$[ebp], 0

; 5842 :    SysConvertLongToDecimal( 0, &dDecValue );

	lea	eax, DWORD PTR _dDecValue$[ebp]
	push	eax
	push	0
	call	_SysConvertLongToDecimal@8

; 5843 :    chSign              = 0;

	mov	BYTE PTR _chSign$[ebp], 0

; 5844 : 
; 5845 :    // Loop through the expression and copy values to the concat buffer.
; 5846 :    // Anything in quotes is copied verbatim.  Anything not in quotes had
; 5847 :    // better be an attribute name or + signs.
; 5848 :    // 'idx' points to the null-terminator in szConcatBuffer.
; 5849 :    for ( idx = 0; *pchExpr; pchExpr++ )

	xor	ecx, ecx
	mov	WORD PTR _idx$[ebp], cx
	jmp	SHORT $LN4@DfExprVML
$LN2@DfExprVML:
	mov	edx, DWORD PTR _pchExpr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchExpr$[ebp], edx
$LN4@DfExprVML:
	mov	eax, DWORD PTR _pchExpr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@DfExprVML

; 5850 :    {
; 5851 :       // Check to see if we are inside a quoted string.  If so we just copy
; 5852 :       // the character from the expression to the buffer.
; 5853 :       if ( bInQuote )

	movzx	edx, BYTE PTR _bInQuote$[ebp]
	test	edx, edx
	je	SHORT $LN10@DfExprVML

; 5854 :       {
; 5855 :          if ( *pchExpr == '\"' )

	mov	eax, DWORD PTR _pchExpr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN11@DfExprVML

; 5856 :          {
; 5857 :             bInQuote = FALSE;

	mov	BYTE PTR _bInQuote$[ebp], 0

; 5858 : 
; 5859 :             // We'll terminate the buffer here.
; 5860 :             szConcatBuffer[ idx ] = 0;

	movsx	edx, WORD PTR _idx$[ebp]
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 2000		; 000007d0H
	jae	SHORT $LN36@DfExprVML
	jmp	SHORT $LN37@DfExprVML
$LN36@DfExprVML:
	call	___report_rangecheckfailure
$LN37@DfExprVML:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szConcatBuffer$[ebp+eax], 0

; 5861 :          }

	jmp	SHORT $LN12@DfExprVML
$LN11@DfExprVML:

; 5862 :          else
; 5863 :             szConcatBuffer[ idx++ ] = *pchExpr;

	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _pchExpr$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szConcatBuffer$[ebp+ecx], al
	mov	cx, WORD PTR _idx$[ebp]
	add	cx, 1
	mov	WORD PTR _idx$[ebp], cx
$LN12@DfExprVML:

; 5864 : 
; 5865 :          continue;

	jmp	$LN2@DfExprVML
$LN10@DfExprVML:

; 5866 :       }
; 5867 : 
; 5868 :       // Check for plus or minus sign.
; 5869 :       if ( *pchExpr == '+' || *pchExpr == '-' )

	mov	edx, DWORD PTR _pchExpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 43					; 0000002bH
	je	SHORT $LN14@DfExprVML
	mov	ecx, DWORD PTR _pchExpr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN13@DfExprVML
$LN14@DfExprVML:

; 5870 :       {
; 5871 :          chSign = *pchExpr;

	mov	eax, DWORD PTR _pchExpr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _chSign$[ebp], cl

; 5872 :          continue;

	jmp	$LN2@DfExprVML
$LN13@DfExprVML:

; 5873 :       }
; 5874 : 
; 5875 :       // OK, we're not in a quote or context name.  Check to see if we are
; 5876 :       // starting a quoted section.
; 5877 :       if ( *pchExpr == '\"' )

	mov	edx, DWORD PTR _pchExpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN15@DfExprVML

; 5878 :       {
; 5879 :          bInQuote = TRUE;

	mov	BYTE PTR _bInQuote$[ebp], 1
$LN5@DfExprVML:

; 5880 : 
; 5881 :          // Increment idx so that it points to the null-terminator.  We do
; 5882 :          // this because it's possible that we've added an attribute value
; 5883 :          // before now and we want idx to point to the end of the string.
; 5884 :          while ( szConcatBuffer[ idx ] )

	movsx	ecx, WORD PTR _idx$[ebp]
	movsx	edx, BYTE PTR _szConcatBuffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN6@DfExprVML

; 5885 :             idx++;

	mov	ax, WORD PTR _idx$[ebp]
	add	ax, 1
	mov	WORD PTR _idx$[ebp], ax
	jmp	SHORT $LN5@DfExprVML
$LN6@DfExprVML:

; 5886 : 
; 5887 :          // We're starting a new quoted string.  We'll assume that adding
; 5888 :          // attributes will start from here.
; 5889 :          lIntValue = 0;

	mov	DWORD PTR _lIntValue$[ebp], 0

; 5890 :          SysConvertLongToDecimal( 0, &dDecValue );

	lea	ecx, DWORD PTR _dDecValue$[ebp]
	push	ecx
	push	0
	call	_SysConvertLongToDecimal@8

; 5891 :          continue;

	jmp	$LN2@DfExprVML
$LN15@DfExprVML:

; 5892 :       }
; 5893 : 
; 5894 :       // We'll ignore non-alphanumerics.  We can ignore the '+' sign because
; 5895 :       // we'll assume string concatenation/addition.
; 5896 :       if ( zisalnum( *pchExpr ) == FALSE )

	mov	edx, DWORD PTR _pchExpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@DfExprVML

; 5897 :          continue;

	jmp	$LN2@DfExprVML
$LN16@DfExprVML:

; 5898 : 
; 5899 :       // At this point pchExpr had better be pointing to an attribute name.
; 5900 :       // Retrieve the name.
; 5901 :       if ( fnRetrieveAttribName( &pchExpr, szAttribName, szContextName ) != 0 )

	lea	ecx, DWORD PTR _szContextName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szAttribName$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchExpr$[ebp]
	push	eax
	call	_fnRetrieveAttribName@12
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN17@DfExprVML

; 5902 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN31@DfExprVML
$LN17@DfExprVML:

; 5903 : 
; 5904 :       pchExpr--;  // Go back one to the space.

	mov	edx, DWORD PTR _pchExpr$[ebp]
	sub	edx, 1
	mov	DWORD PTR _pchExpr$[ebp], edx

; 5905 :       lpSrcViewAttrib = fnValidViewAttrib( lpView, lpViewEntity, szAttribName, 0 );

	push	0
	lea	eax, DWORD PTR _szAttribName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax

; 5906 :       if ( lpSrcViewAttrib == 0 )

	cmp	DWORD PTR _lpSrcViewAttrib$[ebp], 0
	jne	SHORT $LN18@DfExprVML

; 5907 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN31@DfExprVML
$LN18@DfExprVML:

; 5908 : 
; 5909 :       // The source attribute type determines how we are going to add a value
; 5910 :       // to the buffer.
; 5911 :       switch ( lpSrcViewAttrib->cType )

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv156[ebp], ecx
	mov	edx, DWORD PTR tv156[ebp]
	sub	edx, 76					; 0000004cH
	mov	DWORD PTR tv156[ebp], edx
	cmp	DWORD PTR tv156[ebp], 8
	ja	$LN7@DfExprVML
	mov	eax, DWORD PTR tv156[ebp]
	movzx	ecx, BYTE PTR $LN42@DfExprVML[eax]
	jmp	DWORD PTR $LN43@DfExprVML[ecx*4]
$LN19@DfExprVML:

; 5912 :       {
; 5913 :          case zTYPE_DATETIME:
; 5914 :          case zTYPE_STRING:
; 5915 :             // We'll just concatenate the attribute's value to the buffer.
; 5916 :             if ( szContextName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szContextName$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN20@DfExprVML

; 5917 :                GetStringFromAttributeByContext( &szConcatBuffer[ idx ], lpView,

	movsx	edx, WORD PTR _idx$[ebp]
	mov	eax, 1999				; 000007cfH
	sub	eax, edx
	push	eax
	lea	ecx, DWORD PTR _szContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	movsx	edx, WORD PTR _idx$[ebp]
	lea	eax, DWORD PTR _szConcatBuffer$[ebp+edx]
	push	eax
	call	_GetStringFromAttributeByContext@24
	jmp	SHORT $LN21@DfExprVML
$LN20@DfExprVML:

; 5918 :                                                 lpViewEntity->szName,
; 5919 :                                                 lpSrcViewAttrib->szName,
; 5920 :                                                 szContextName, 1999 - idx );
; 5921 :             else
; 5922 :                GetStringFromAttribute( &szConcatBuffer[ idx ], lpView,

	lea	ecx, DWORD PTR _szAttribName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	movsx	ecx, WORD PTR _idx$[ebp]
	lea	edx, DWORD PTR _szConcatBuffer$[ebp+ecx]
	push	edx
	call	_GetStringFromAttribute@16
$LN21@DfExprVML:

; 5923 :                                        lpViewEntity->szName, szAttribName );
; 5924 : 
; 5925 :             // Increment idx so that it points to the null-terminator.
; 5926 :             idx += zstrlen( &szConcatBuffer[ idx ] );

	movsx	eax, WORD PTR _idx$[ebp]
	lea	ecx, DWORD PTR _szConcatBuffer$[ebp+eax]
	push	ecx
	call	_strlen
	add	esp, 4
	movsx	edx, WORD PTR _idx$[ebp]
	add	edx, eax
	mov	WORD PTR _idx$[ebp], dx

; 5927 :             break;

	jmp	$LN7@DfExprVML
$LN22@DfExprVML:

; 5928 : 
; 5929 :          case zTYPE_DECIMAL:
; 5930 :          {
; 5931 :             zDECIMAL dNewValue;
; 5932 : 
; 5933 :             // Get the attribute's value as a decimal and add it to the
; 5934 :             // "current" value.
; 5935 :             if ( szContextName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szContextName$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN23@DfExprVML

; 5936 :                szContextName[ 0 ] = 0;  // ignore context on decimals for now

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 33			; 00000021H
	jae	SHORT $LN38@DfExprVML
	jmp	SHORT $LN39@DfExprVML
$LN38@DfExprVML:
	call	___report_rangecheckfailure
$LN39@DfExprVML:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szContextName$[ebp+edx], 0
$LN23@DfExprVML:

; 5937 : 
; 5938 :             GetDecimalFromAttribute( &dNewValue, lpView,

	lea	eax, DWORD PTR _szAttribName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _dNewValue$7[ebp]
	push	eax
	call	_GetDecimalFromAttribute@16

; 5939 :                                      lpViewEntity->szName, szAttribName );
; 5940 : 
; 5941 :             if ( chSign == '-' )

	movsx	ecx, BYTE PTR _chSign$[ebp]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN24@DfExprVML

; 5942 :                SysSubtractDecimalFromDecimal( &dDecValue, &dDecValue, &dNewValue );

	lea	edx, DWORD PTR _dNewValue$7[ebp]
	push	edx
	lea	eax, DWORD PTR _dDecValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dDecValue$[ebp]
	push	ecx
	call	_SysSubtractDecimalFromDecimal@12
	jmp	SHORT $LN25@DfExprVML
$LN24@DfExprVML:

; 5943 :             else
; 5944 :                SysAddDecimalToDecimal( &dDecValue, &dDecValue, &dNewValue );

	lea	edx, DWORD PTR _dNewValue$7[ebp]
	push	edx
	lea	eax, DWORD PTR _dDecValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dDecValue$[ebp]
	push	ecx
	call	_SysAddDecimalToDecimal@12
$LN25@DfExprVML:

; 5945 : 
; 5946 :             // Add the decimal value to the end of the string.
; 5947 :             SysConvertDecimalToString( &dDecValue, &szConcatBuffer[ idx ], 3 );

	push	3
	movsx	edx, WORD PTR _idx$[ebp]
	lea	eax, DWORD PTR _szConcatBuffer$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _dDecValue$[ebp]
	push	ecx
	call	_SysConvertDecimalToString@12

; 5948 : 
; 5949 :             // Convert the value to the temp long variable so that if the next
; 5950 :             // token is a long it will added correctly.
; 5951 :             SysConvertDecimalToLong( &dDecValue, &lIntValue );

	lea	edx, DWORD PTR _lIntValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _dDecValue$[ebp]
	push	eax
	call	_SysConvertDecimalToLong@8

; 5952 : 
; 5953 :             // Note that we *don't* increment idx.  This way if the next token
; 5954 :             // is another decimal attribute we can add the two decimal values
; 5955 :             // together and overwrite the value we just concatenated to the
; 5956 :             // buffer.
; 5957 :             break;

	jmp	$LN7@DfExprVML
$LN26@DfExprVML:

; 5958 :          }
; 5959 : 
; 5960 :          case zTYPE_INTEGER:
; 5961 :          {
; 5962 :             zLONG lNewValue;
; 5963 : 
; 5964 :             // Get the attribute's value as an integer and add it to the
; 5965 :             // "current" value.
; 5966 :             if ( szContextName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szContextName$[ebp+edx]
	test	eax, eax
	je	SHORT $LN27@DfExprVML

; 5967 :                szContextName[ 0 ] = 0;  // ignore context on integers for now

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 33			; 00000021H
	jae	SHORT $LN40@DfExprVML
	jmp	SHORT $LN41@DfExprVML
$LN40@DfExprVML:
	call	___report_rangecheckfailure
$LN41@DfExprVML:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szContextName$[ebp+eax], 0
$LN27@DfExprVML:

; 5968 : 
; 5969 :             GetIntegerFromAttribute( &lNewValue, lpView,

	lea	ecx, DWORD PTR _szAttribName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lNewValue$1[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 5970 :                                      lpViewEntity->szName, szAttribName );
; 5971 :             if ( chSign == '-' )

	movsx	edx, BYTE PTR _chSign$[ebp]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN28@DfExprVML

; 5972 :                lIntValue -= lNewValue;

	mov	eax, DWORD PTR _lIntValue$[ebp]
	sub	eax, DWORD PTR _lNewValue$1[ebp]
	mov	DWORD PTR _lIntValue$[ebp], eax
	jmp	SHORT $LN29@DfExprVML
$LN28@DfExprVML:

; 5973 :             else
; 5974 :                lIntValue += lNewValue;

	mov	ecx, DWORD PTR _lIntValue$[ebp]
	add	ecx, DWORD PTR _lNewValue$1[ebp]
	mov	DWORD PTR _lIntValue$[ebp], ecx
$LN29@DfExprVML:

; 5975 : 
; 5976 :             // Add the integer value to the end of the string.
; 5977 :             zltoa( lIntValue, &szConcatBuffer[ idx ] );

	push	10					; 0000000aH
	movsx	edx, WORD PTR _idx$[ebp]
	lea	eax, DWORD PTR _szConcatBuffer$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _lIntValue$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 5978 : 
; 5979 :             // Convert the value to the temp decimal variable so that if the next
; 5980 :             // token is a decimal it will added correctly.
; 5981 :             SysConvertLongToDecimal( lIntValue, &dDecValue );

	lea	edx, DWORD PTR _dDecValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lIntValue$[ebp]
	push	eax
	call	_SysConvertLongToDecimal@8
$LN7@DfExprVML:

; 5982 : 
; 5983 :             // Note that we *don't* increment idx.  This way if the next token
; 5984 :             // is another integer attribute we can add the two integer values
; 5985 :             // together and overwrite the value we just concatenated to the
; 5986 :             // buffer.
; 5987 : 
; 5988 :             break;
; 5989 :          }
; 5990 :       }
; 5991 : 
; 5992 :       if ( pchExpr[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchExpr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN30@DfExprVML

; 5993 :          break;

	jmp	SHORT $LN3@DfExprVML
$LN30@DfExprVML:

; 5994 : 
; 5995 :    } // for ( idx... )

	jmp	$LN2@DfExprVML
$LN3@DfExprVML:

; 5996 : 
; 5997 :    StoreStringInRecord( lpView, lpViewEntity, lpViewAttrib,

	lea	edx, DWORD PTR _szConcatBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreStringInRecord@16

; 5998 :                         szConcatBuffer );
; 5999 :    return( 0 );

	xor	eax, eax
$LN31@DfExprVML:

; 6000 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	3
$LN43@DfExprVML:
	DD	$LN26@DfExprVML
	DD	$LN22@DfExprVML
	DD	$LN19@DfExprVML
	DD	$LN7@DfExprVML
$LN42@DfExprVML:
	DB	0
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
	DB	2
_DfExprVML@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pchExpr$ = -8						; size = 4
_n$ = -4						; size = 2
_ppchInput$ = 8						; size = 4
_pchAttribName$ = 12					; size = 4
_pchContextName$ = 16					; size = 4
_fnRetrieveAttribName@12 PROC

; 5764 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5765 :    zSHORT n;
; 5766 :    zPCHAR pchExpr = *ppchInput;

	mov	eax, DWORD PTR _ppchInput$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pchExpr$[ebp], ecx

; 5767 : 
; 5768 :    for ( n = 0; zisalnum( *pchExpr ); pchExpr++ )

	xor	edx, edx
	mov	WORD PTR _n$[ebp], dx
	jmp	SHORT $LN4@fnRetrieve
$LN2@fnRetrieve:
	mov	eax, DWORD PTR _pchExpr$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchExpr$[ebp], eax
$LN4@fnRetrieve:
	mov	ecx, DWORD PTR _pchExpr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@fnRetrieve

; 5769 :       pchAttribName[ n++ ] = *pchExpr;

	movsx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _pchAttribName$[ebp]
	mov	edx, DWORD PTR _pchExpr$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	ax, WORD PTR _n$[ebp]
	add	ax, 1
	mov	WORD PTR _n$[ebp], ax
	jmp	SHORT $LN2@fnRetrieve
$LN3@fnRetrieve:

; 5770 : 
; 5771 :    pchAttribName[ n ] = 0;

	movsx	ecx, WORD PTR _n$[ebp]
	mov	edx, DWORD PTR _pchAttribName$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN5@fnRetrieve:

; 5772 : 
; 5773 :    // Skip whitespaces.
; 5774 :    while ( zisspace( *pchExpr ) )

	mov	eax, DWORD PTR _pchExpr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@fnRetrieve

; 5775 :       pchExpr++;

	mov	edx, DWORD PTR _pchExpr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchExpr$[ebp], edx
	jmp	SHORT $LN5@fnRetrieve
$LN6@fnRetrieve:

; 5776 : 
; 5777 :    // Check to see if the character immediately following the attribute name
; 5778 :    // is a [ to indicate that a context is to be used for the get of the attribute.
; 5779 :    if ( *pchExpr == '[' )

	mov	eax, DWORD PTR _pchExpr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 91					; 0000005bH
	jne	$LN14@fnRetrieve

; 5780 :    {
; 5781 :       pchExpr++;

	mov	edx, DWORD PTR _pchExpr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchExpr$[ebp], edx
$LN7@fnRetrieve:

; 5782 : 
; 5783 :       // Skip whitespaces.
; 5784 :       while ( zisspace( *pchExpr ) )

	mov	eax, DWORD PTR _pchExpr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN8@fnRetrieve

; 5785 :          pchExpr++;

	mov	edx, DWORD PTR _pchExpr$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchExpr$[ebp], edx
	jmp	SHORT $LN7@fnRetrieve
$LN8@fnRetrieve:

; 5786 : 
; 5787 :       // Retrieve the context name.  We allow any non-space characters to
; 5788 :       // be part of the context name.
; 5789 :       for ( n = 0;

	xor	eax, eax
	mov	WORD PTR _n$[ebp], ax
	jmp	SHORT $LN11@fnRetrieve
$LN9@fnRetrieve:

; 5791 :             pchExpr++ )

	mov	ecx, DWORD PTR _pchExpr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchExpr$[ebp], ecx
$LN11@fnRetrieve:

; 5790 :             *pchExpr && zisspace( *pchExpr ) == FALSE && *pchExpr != ']';

	mov	edx, DWORD PTR _pchExpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN10@fnRetrieve
	mov	ecx, DWORD PTR _pchExpr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN10@fnRetrieve
	mov	eax, DWORD PTR _pchExpr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	je	SHORT $LN10@fnRetrieve

; 5792 :       {
; 5793 :          pchContextName[ n++ ] = *pchExpr;

	movsx	edx, WORD PTR _n$[ebp]
	mov	eax, DWORD PTR _pchContextName$[ebp]
	mov	ecx, DWORD PTR _pchExpr$[ebp]
	mov	cl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+edx], cl
	mov	dx, WORD PTR _n$[ebp]
	add	dx, 1
	mov	WORD PTR _n$[ebp], dx

; 5794 :       }

	jmp	SHORT $LN9@fnRetrieve
$LN10@fnRetrieve:

; 5795 : 
; 5796 :       pchContextName[ n ] = 0;

	movsx	eax, WORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _pchContextName$[ebp]
	mov	BYTE PTR [ecx+eax], 0
$LN12@fnRetrieve:

; 5797 : 
; 5798 :       // Skip whitespaces.
; 5799 :       while ( zisspace( *pchExpr ) )

	mov	edx, DWORD PTR _pchExpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN13@fnRetrieve

; 5800 :          pchExpr++;

	mov	ecx, DWORD PTR _pchExpr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchExpr$[ebp], ecx
	jmp	SHORT $LN12@fnRetrieve
$LN13@fnRetrieve:

; 5801 : 
; 5802 :       if ( *pchExpr == ']' )

	mov	edx, DWORD PTR _pchExpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN16@fnRetrieve

; 5803 :          pchExpr++;

	mov	ecx, DWORD PTR _pchExpr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchExpr$[ebp], ecx
	jmp	SHORT $LN17@fnRetrieve
$LN16@fnRetrieve:

; 5804 :       else
; 5805 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnRetrieve
$LN17@fnRetrieve:

; 5806 :    }

	jmp	SHORT $LN15@fnRetrieve
$LN14@fnRetrieve:

; 5807 :    else
; 5808 :      *pchContextName = 0;  // No context.

	mov	edx, DWORD PTR _pchContextName$[ebp]
	mov	BYTE PTR [edx], 0
$LN15@fnRetrieve:

; 5809 : 
; 5810 :    *ppchInput = pchExpr;

	mov	eax, DWORD PTR _ppchInput$[ebp]
	mov	ecx, DWORD PTR _pchExpr$[ebp]
	mov	DWORD PTR [eax], ecx

; 5811 : 
; 5812 :    return( 0 );

	xor	eax, eax
$LN1@fnRetrieve:

; 5813 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnRetrieveAttribName@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_vViewValue$ = 20					; size = 4
_SetAttributeFromView@16 PROC

; 2611 : {

	push	ebp
	mov	ebp, esp

; 2612 :    SfLockView( vViewValue );  // we lock this view because it is being stored

	mov	eax, DWORD PTR _vViewValue$[ebp]
	push	eax
	call	_SfLockView@4

; 2613 :                               // in an attribute and we don't want it automatically
; 2614 :                               // cleaned up.
; 2615 :    return( SetAttributeFromInteger( lpView, cpcEntityName,

	mov	ecx, DWORD PTR _vViewValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 2616 :                                     cpcAttributeName, (zLONG) vViewValue ) );
; 2617 : }

	pop	ebp
	ret	16					; 00000010H
_SetAttributeFromView@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_n$ = -16						; size = 4
_pch$ = -12						; size = 4
_nMax$ = -8						; size = 4
_lpTableEntry$ = -4					; size = 4
_lpContext$ = 8						; size = 4
_fnGetLongExternalLthForContext PROC

; 2018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2019 :    zPCHAR         pch;
; 2020 :    zULONG         n, nMax = 0;

	mov	DWORD PTR _nMax$[ebp], 0

; 2021 :    LPTABLEENTRY   lpTableEntry;
; 2022 : 
; 2023 :    for ( lpTableEntry = zGETPTR( lpContext->hFirstTableEntry );

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$[ebp], eax
	jmp	SHORT $LN4@fnGetLongE
$LN2@fnGetLongE:

; 2025 :          lpTableEntry = zGETPTR( lpTableEntry->hNextTableEntry ) )

	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$[ebp], eax
$LN4@fnGetLongE:

; 2024 :          lpTableEntry;

	cmp	DWORD PTR _lpTableEntry$[ebp], 0
	je	SHORT $LN3@fnGetLongE

; 2026 :    {
; 2027 :       pch = fnGetTextForTableEntry( lpTableEntry );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	push	ecx
	call	_fnGetTextForTableEntry
	add	esp, 4
	mov	DWORD PTR _pch$[ebp], eax

; 2028 : 
; 2029 :       if ( pch && (n = zstrlen( pch )) > nMax )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN5@fnGetLongE
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax
	mov	eax, DWORD PTR _n$[ebp]
	cmp	eax, DWORD PTR _nMax$[ebp]
	jbe	SHORT $LN5@fnGetLongE

; 2030 :          nMax = n;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _nMax$[ebp], ecx
$LN5@fnGetLongE:

; 2031 :    }

	jmp	SHORT $LN2@fnGetLongE
$LN3@fnGetLongE:

; 2032 : 
; 2033 :    return( nMax );

	mov	eax, DWORD PTR _nMax$[ebp]

; 2034 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetLongExternalLthForContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnEntityNameFromInstance@4 PROC

; 199  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 200  :    LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 201  :    return( lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH

; 202  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnEntityNameFromInstance@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -4					; size = 4
_lpViewEntityCsr$ = 8					; size = 4
_fnEntityNameFromCsr@4 PROC

; 192  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 193  :    LPVIEWENTITY lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 194  :    return( lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH

; 195  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnEntityNameFromCsr@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpNLS_TableEntry$ = -8					; size = 4
_nLanguageCode$ = -4					; size = 2
_lpTableEntry$ = 8					; size = 4
_fnGetTextForTableEntry PROC

; 1993 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1994 :    zSHORT          nLanguageCode;
; 1995 :    LPNLSTABLEENTRY lpNLS_TableEntry;
; 1996 : 
; 1997 :    // Look for an NLS_TableEntry that matches the current country code.
; 1998 :    SysGetLanguageCode( &nLanguageCode );

	lea	eax, DWORD PTR _nLanguageCode$[ebp]
	push	eax
	call	_SysGetLanguageCode@4

; 1999 :    for ( lpNLS_TableEntry = zGETPTR( lpTableEntry->hFirstNLS_TableEntry );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNLS_TableEntry$[ebp], eax
	jmp	SHORT $LN4@fnGetTextF
$LN2@fnGetTextF:

; 2001 :          lpNLS_TableEntry = zGETPTR( lpNLS_TableEntry->hNextNLS_TableEntry ) )

	mov	eax, DWORD PTR _lpNLS_TableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNLS_TableEntry$[ebp], eax
$LN4@fnGetTextF:

; 2000 :          lpNLS_TableEntry && lpNLS_TableEntry->nLanguageCode != nLanguageCode;

	cmp	DWORD PTR _lpNLS_TableEntry$[ebp], 0
	je	SHORT $LN3@fnGetTextF
	mov	edx, DWORD PTR _lpNLS_TableEntry$[ebp]
	movsx	eax, WORD PTR [edx+10]
	movsx	ecx, WORD PTR _nLanguageCode$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@fnGetTextF

; 2002 :    {
; 2003 :       // nothing needs to be done here.
; 2004 :    }

	jmp	SHORT $LN2@fnGetTextF
$LN3@fnGetTextF:

; 2005 : 
; 2006 :    // If lpNLS_TableEntry is non-null, then a match was found.
; 2007 :    if ( lpNLS_TableEntry )

	cmp	DWORD PTR _lpNLS_TableEntry$[ebp], 0
	je	SHORT $LN5@fnGetTextF

; 2008 :       return( zGETPTR( lpNLS_TableEntry->pszNLS_Text ) );

	mov	edx, DWORD PTR _lpNLS_TableEntry$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $LN1@fnGetTextF
$LN5@fnGetTextF:

; 2009 : 
; 2010 :    // No match found for the current language code, so return the "normal"
; 2011 :    // external value.
; 2012 :    return( zGETPTR( lpTableEntry->hExternalValue ) );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
$LN1@fnGetTextF:

; 2013 : 
; 2014 : } // fnGetTextForTableEntry

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetTextForTableEntry ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpLinkedViewEntity$1 = -24				; size = 4
_lpAttribFlags$2 = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpLinkedOI$3 = -12					; size = 4
_lpLinked$4 = -8					; size = 4
_bPersist$ = -1						; size = 1
_lpViewOI$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_bUpdated$ = 20						; size = 1
_bSetLinked$ = 24					; size = 1
_bUpdateEntity$ = 28					; size = 1
_fnSetUpdateIndicator PROC

; 10875: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 10876:    LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10877:    zBOOL        bPersist;
; 10878: 
; 10879:    // Set update indicator.
; 10880:    if ( bUpdated == FALSE )

	movzx	edx, BYTE PTR _bUpdated$[ebp]
	test	edx, edx
	jne	SHORT $LN5@fnSetUpdat

; 10881:       return;

	jmp	$LN1@fnSetUpdat
$LN5@fnSetUpdat:

; 10882: 
; 10883:    if ( lpViewOI == 0 )

	cmp	DWORD PTR _lpViewOI$[ebp], 0
	jne	SHORT $LN6@fnSetUpdat

; 10884:       lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$LN6@fnSetUpdat:

; 10885: 
; 10886:    if ( lpViewEntity->bDerived || lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	jne	SHORT $LN9@fnSetUpdat
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	je	SHORT $LN7@fnSetUpdat
$LN9@fnSetUpdat:

; 10887:       bPersist = FALSE;

	mov	BYTE PTR _bPersist$[ebp], 0
	jmp	SHORT $LN8@fnSetUpdat
$LN7@fnSetUpdat:

; 10888:    else
; 10889:       bPersist = TRUE;

	mov	BYTE PTR _bPersist$[ebp], 1
$LN8@fnSetUpdat:

; 10890: 
; 10891:    if ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN10@fnSetUpdat

; 10892:    {
; 10893:       LPATTRIBFLAGS lpAttribFlags;
; 10894: 
; 10895:       // If changing a derived attribute then nothing gets changed.
; 10896:       if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+213]
	test	eax, eax
	je	SHORT $LN11@fnSetUpdat

; 10897:          return;

	jmp	$LN1@fnSetUpdat
$LN11@fnSetUpdat:

; 10898: 
; 10899:       if ( lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN12@fnSetUpdat

; 10900:       {
; 10901:          bPersist = FALSE;

	mov	BYTE PTR _bPersist$[ebp], 0

; 10902: 
; 10903:          // If the attribute is not persistent, then we don't want to change
; 10904:          // the updated flags of linked entities.
; 10905:          bSetLinked = FALSE;

	mov	BYTE PTR _bSetLinked$[ebp], 0
$LN12@fnSetUpdat:

; 10906:       }
; 10907: 
; 10908:       lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$2[ebp], eax

; 10909:       lpAttribFlags->u.bFlags.bUpdated = TRUE;

	mov	edx, DWORD PTR _lpAttribFlags$2[ebp]
	mov	eax, DWORD PTR [edx]
	or	eax, 2
	mov	ecx, DWORD PTR _lpAttribFlags$2[ebp]
	mov	DWORD PTR [ecx], eax
$LN10@fnSetUpdat:

; 10910:    }
; 10911: 
; 10912:    // KJS 08/22/14 - I am confused here because fnInstanceVersioned returns 0 if there is no
; 10913:    // versioning, so it would seem that the check should be > 0.
; 10914:    //if ( fnInstanceVersioned( lpEntityInstance ) > 0 )
; 10915:    // KJS 06/25/15 - Not asking for Save in domains when I create a new domain, so going to set this back to original.
; 10916:    if ( fnInstanceVersioned( lpEntityInstance ) == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnInstanceVersioned
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN13@fnSetUpdat

; 10917:    {
; 10918:       lpViewOI->bUpdatedFile = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 10919: 
; 10920:       if ( bPersist )

	movzx	ecx, BYTE PTR _bPersist$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@fnSetUpdat

; 10921:          lpViewOI->bUpdated = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN15@fnSetUpdat:

; 10922:    }

	jmp	SHORT $LN14@fnSetUpdat
$LN13@fnSetUpdat:

; 10923:    else
; 10924:    {
; 10925:       // The entity instance is versioned, set the version updated flags.
; 10926:       lpEntityInstance->u.nInd.bVersionUpdFile = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 33554432				; 02000000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 10927: 
; 10928:       if ( bPersist )

	movzx	edx, BYTE PTR _bPersist$[ebp]
	test	edx, edx
	je	SHORT $LN14@fnSetUpdat

; 10929:          lpEntityInstance->u.nInd.bVersionUpdated = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 16777216				; 01000000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN14@fnSetUpdat:

; 10930:    }
; 10931: 
; 10932:    if ( bUpdateEntity )

	movzx	eax, BYTE PTR _bUpdateEntity$[ebp]
	test	eax, eax
	je	$LN1@fnSetUpdat

; 10933:    {
; 10934:       lpEntityInstance->u.nInd.bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 10935: 
; 10936:       //*******************************************************************
; 10937:       //*******************************************************************
; 10938:       // We shouldn't go through and set the update flags for linked OIs if
; 10939:       // the lpEntityInstance is a subobject version.  Accept should do it.
; 10940:       // This should be changed at some point.
; 10941:       //*******************************************************************
; 10942:       //*******************************************************************
; 10943:       if ( bSetLinked && lpEntityInstance->hNextLinked )

	movzx	ecx, BYTE PTR _bSetLinked$[ebp]
	test	ecx, ecx
	je	$LN1@fnSetUpdat
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	$LN1@fnSetUpdat

; 10944:       {
; 10945:          LPENTITYINSTANCE lpLinked;
; 10946: 
; 10947:          for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$4[ebp], eax
	jmp	SHORT $LN4@fnSetUpdat
$LN2@fnSetUpdat:

; 10949:                lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpLinked$4[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$4[ebp], eax
$LN4@fnSetUpdat:

; 10948:                lpLinked != lpEntityInstance;

	mov	ecx, DWORD PTR _lpLinked$4[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN1@fnSetUpdat

; 10950:          {
; 10951:             LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpLinked->hViewEntity );

	mov	edx, DWORD PTR _lpLinked$4[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$1[ebp], eax

; 10952: 
; 10953:             lpLinked->u.nInd.bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpLinked$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4
	mov	eax, DWORD PTR _lpLinked$4[ebp]
	mov	DWORD PTR [eax+6], edx

; 10954: 
; 10955:             // Now make sure the OI for the linked EI gets flagged as updated.
; 10956:             if ( lpLinkedViewEntity->bDerived == FALSE &&

	mov	ecx, DWORD PTR _lpLinkedViewEntity$1[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	jne	SHORT $LN19@fnSetUpdat
	mov	eax, DWORD PTR _lpLinkedViewEntity$1[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	jne	SHORT $LN19@fnSetUpdat

; 10957:                  lpLinkedViewEntity->bDerivedPath == FALSE )
; 10958:             {
; 10959:                LPVIEWOI lpLinkedOI = zGETPTR( lpLinked->hViewOI );

	mov	edx, DWORD PTR _lpLinked$4[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedOI$3[ebp], eax

; 10960: 
; 10961:                lpLinkedOI->bUpdatedFile = lpLinkedOI->bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpLinkedOI$3[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpLinkedOI$3[ebp]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR _lpLinkedOI$3[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpLinkedOI$3[ebp]
	mov	DWORD PTR [eax+36], edx
$LN19@fnSetUpdat:

; 10962:             }
; 10963:          }

	jmp	$LN2@fnSetUpdat
$LN1@fnSetUpdat:

; 10964:       }
; 10965:    }
; 10966: 
; 10967: } // fnSetUpdateIndicator

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetUpdateIndicator ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pfObjectOper$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lpCurrentTask$ = 20					; size = 4
_nControl$ = 24						; size = 2
_fnInvokeDerivedOperation PROC

; 10602: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10603:    zPOBJOPER pfObjectOper = fnGetAttribOper( lpView, lpViewAttrib,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetAttribOper
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pfObjectOper$[ebp], eax

; 10604:                                              lpCurrentTask );
; 10605:    if ( pfObjectOper )

	cmp	DWORD PTR _pfObjectOper$[ebp], 0
	je	SHORT $LN2@fnInvokeDe

; 10606:       return( (*pfObjectOper)( lpView, lpViewEntity, lpViewAttrib, nControl ) );

	movzx	eax, WORD PTR _nControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _pfObjectOper$[ebp]
	jmp	SHORT $LN1@fnInvokeDe
$LN2@fnInvokeDe:

; 10607: 
; 10608:    return( 0 );

	xor	eax, eax
$LN1@fnInvokeDe:

; 10609: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInvokeDerivedOperation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpEntityInstance$ = 8					; size = 4
_lpViewAttribute$ = 12					; size = 4
_fnRecordForEntityAttr PROC

; 10543: {

	push	ebp
	mov	ebp, esp

; 10544:    // Get record to retrieve from.
; 10545:    if ( lpViewAttribute->bPersist ) // is attribute persistent

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	je	SHORT $LN2@fnRecordFo

; 10546:    {
; 10547: #if 0
; 10548:       if ( SysSendOE_Message( IDM_GETTRACELOGFILE, 0 ) != -1 )
; 10549:       {
; 10550:          LPVIEWENTITY  lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );
; 10551: 
; 10552:          if ( zstrcmp( lpViewEntity->szName, "StudentAccountProfile" ) == 0 &&
; 10553:               zstrcmp( lpViewAttribute->szName, "wTotalInterestToApply" ) == 0 )
; 10554:          {
; 10555:             TraceLine( "RecordForEntityAttr %s.%s: 0x%08x",
; 10556:                        lpViewEntity->szName, lpViewAttribute->szName,
; 10557:                        lpEntityInstance->hPersistRecord );
; 10558:          }
; 10559:       }
; 10560: #endif
; 10561:       return( (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord ) );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $LN1@fnRecordFo

; 10562:    }

	jmp	SHORT $LN1@fnRecordFo
$LN2@fnRecordFo:

; 10563:    else
; 10564:    {
; 10565: #if 0
; 10566:       if ( SysSendOE_Message( IDM_GETTRACELOGFILE, 0 ) != -1 )
; 10567:       {
; 10568:          LPVIEWENTITY  lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );
; 10569: 
; 10570:          if ( zstrcmp( lpViewEntity->szName, "StudentAccountProfile" ) == 0 &&
; 10571:               zstrcmp( lpViewAttribute->szName, "wTotalInterestToApply" ) == 0 )
; 10572:          {
; 10573:             TraceLine( "RecordForEntityAttr (non-persist) %s.%s: 0x%08x",
; 10574:                        lpViewEntity->szName, lpViewAttribute->szName,
; 10575:                        lpEntityInstance->hNonPersistRecord );
; 10576:          }
; 10577:       }
; 10578: #endif
; 10579:       return( (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord ) );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
$LN1@fnRecordFo:

; 10580:    }
; 10581: }

	pop	ebp
	ret	0
_fnRecordForEntityAttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTempOperation$1 = -52				; size = 4
_lpViewOD$ = -48					; size = 4
tv193 = -44						; size = 4
tv192 = -40						; size = 4
tv176 = -36						; size = 4
tv175 = -32						; size = 4
_lProcessID$ = -28					; size = 4
_hLibrary$ = -24					; size = 4
_hCurrentTask$ = -20					; size = 4
_pchOperLibName$ = -16					; size = 4
_hTaskOperation$ = -12					; size = 4
_lpTaskOperation$ = -8					; size = 4
_bMutexLocked$ = -1					; size = 1
_lpView$ = 8						; size = 4
_lpViewAttrib$ = 12					; size = 4
_lpCurrentTask$ = 16					; size = 4
_fnGetAttribOper PROC

; 6174 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 6175 :    LPTASK      hCurrentTask = zGETHNDL( lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hCurrentTask$[ebp], eax

; 6176 :    LPVIEWOD    lpViewOD;
; 6177 :    zPCHAR      pchOperLibName;
; 6178 :    LPLIBRARY   hLibrary;
; 6179 :    zPVOID      hTaskOperation;
; 6180 :    LPTASKOPER  lpTaskOperation;
; 6181 :    zBOOL       bMutexLocked;
; 6182 :    zLONG       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 6183 : 
; 6184 :    // If there is no derived operation pointer, return 0 ==> not found.
; 6185 :    if ( lpViewAttrib->szDerivedOper[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	jne	SHORT $LN5@fnGetAttri

; 6186 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAttri
$LN5@fnGetAttri:

; 6187 : 
; 6188 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6189 : 
; 6190 :    for ( lpTaskOperation = zGETPTR( lpViewAttrib->hFirstTaskOperation );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+185]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
	jmp	SHORT $LN4@fnGetAttri
$LN2@fnGetAttri:

; 6192 :          lpTaskOperation = zGETPTR( lpTaskOperation->hNextTaskOperationForOEA ) )

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
$LN4@fnGetAttri:

; 6191 :          lpTaskOperation;

	cmp	DWORD PTR _lpTaskOperation$[ebp], 0
	je	SHORT $LN3@fnGetAttri

; 6193 :    {
; 6194 :       if ( lpTaskOperation->hTask == hCurrentTask &&

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+14]
	cmp	eax, DWORD PTR _hCurrentTask$[ebp]
	jne	SHORT $LN6@fnGetAttri
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN6@fnGetAttri

; 6195 :            lpTaskOperation->lProcessID == lProcessID )
; 6196 :       {
; 6197 :          return( (zPOBJOPER) lpTaskOperation->pfnTaskOper );

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [eax+30]
	jmp	$LN1@fnGetAttri
$LN6@fnGetAttri:

; 6198 :       }
; 6199 :    }

	jmp	SHORT $LN2@fnGetAttri
$LN3@fnGetAttri:

; 6200 : 
; 6201 :    if ( lpViewAttrib->bDerivedIntrnl )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	je	SHORT $LN7@fnGetAttri

; 6202 :       hLibrary = 0;

	mov	DWORD PTR _hLibrary$[ebp], 0
	jmp	SHORT $LN8@fnGetAttri
$LN7@fnGetAttri:

; 6203 :    else
; 6204 :    {
; 6205 :       // No task object oper exists yet, create one if possible.
; 6206 :       pchOperLibName = lpViewOD->szOperLibname;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 142				; 0000008eH
	mov	DWORD PTR _pchOperLibName$[ebp], eax

; 6207 :       if ( pchOperLibName == 0 || pchOperLibName[ 0 ] == 0 )

	je	SHORT $LN10@fnGetAttri
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchOperLibName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN9@fnGetAttri
$LN10@fnGetAttri:

; 6208 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAttri
$LN9@fnGetAttri:

; 6209 : 
; 6210 :       hLibrary = SysLoadLibrary( lpView, pchOperLibName );  // dks 2006.04.06  back to 10b

	mov	edx, DWORD PTR _pchOperLibName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 6211 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $LN8@fnGetAttri

; 6212 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAttri
$LN8@fnGetAttri:

; 6213 :    }
; 6214 : 
; 6215 :    hTaskOperation = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10034					; 00002732H
	push	0
	push	1
	push	38					; 00000026H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskOperation$[ebp], eax

; 6216 :                                       sizeof( TaskOperationRecord ), 1, 0,
; 6217 :                                       iTaskOperation );
; 6218 :    if ( hTaskOperation == 0 )

	cmp	DWORD PTR _hTaskOperation$[ebp], 0
	jne	SHORT $LN12@fnGetAttri

; 6219 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAttri
$LN12@fnGetAttri:

; 6220 : 
; 6221 :    lpTaskOperation = zGETPTR( hTaskOperation );

	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax

; 6222 :    lpTaskOperation->hViewAttrib = zGETHNDL( lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [edx+26], eax

; 6223 :    lpTaskOperation->hTask       = hCurrentTask;

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR _hCurrentTask$[ebp]
	mov	DWORD PTR [eax+14], ecx

; 6224 :    lpTaskOperation->lProcessID  = lProcessID;

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+34], eax

; 6225 : 
; 6226 :    // Set pointers for TaskOperation chain off of Task structure.
; 6227 :    // Note: this is a single linked list.
; 6228 :    if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hCurrentTask$[ebp]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN13@fnGetAttri

; 6229 :    {
; 6230 :       bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 6231 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 6232 :    }

	jmp	SHORT $LN14@fnGetAttri
$LN13@fnGetAttri:

; 6233 :    else
; 6234 :       bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0
$LN14@fnGetAttri:

; 6235 : 
; 6236 :    lpTaskOperation->hNextTaskOperationForTask =

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+130]
	mov	DWORD PTR [eax+2], edx

; 6237 :                                           lpCurrentTask->hFirstTaskOperation;
; 6238 :    lpCurrentTask->hFirstTaskOperation = hTaskOperation;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [eax+130], ecx

; 6239 : 
; 6240 :    if ( bMutexLocked )

	movzx	edx, BYTE PTR _bMutexLocked$[ebp]
	test	edx, edx
	je	SHORT $LN15@fnGetAttri

; 6241 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN15@fnGetAttri:

; 6242 : 
; 6243 :    if ( lpViewAttrib->bDerivedIntrnl )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 15					; 0000000fH
	and	ecx, 1
	je	$LN16@fnGetAttri

; 6244 :    {
; 6245 :       if ( zstrcmp( lpViewAttrib->szDerivedOper, "DfExprVML" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+213]
	movsx	ecx, BYTE PTR $SG16719
	cmp	eax, ecx
	jne	SHORT $LN26@fnGetAttri
	push	OFFSET $SG16720
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 213				; 000000d5H
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv176[ebp], eax
	jmp	SHORT $LN27@fnGetAttri
$LN26@fnGetAttri:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+213]
	movsx	edx, BYTE PTR $SG16721
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN24@fnGetAttri
	mov	DWORD PTR tv175[ebp], 1
	jmp	SHORT $LN25@fnGetAttri
$LN24@fnGetAttri:
	mov	DWORD PTR tv175[ebp], -1
$LN25@fnGetAttri:
	mov	eax, DWORD PTR tv175[ebp]
	mov	DWORD PTR tv176[ebp], eax
$LN27@fnGetAttri:
	cmp	DWORD PTR tv176[ebp], 0
	jne	SHORT $LN18@fnGetAttri

; 6246 :          lpTaskOperation->pfnTaskOper = (zPVOID) DfExprVML;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+30], OFFSET _DfExprVML@16
	jmp	SHORT $LN19@fnGetAttri
$LN18@fnGetAttri:

; 6247 :       else
; 6248 :       if ( zstrcmp( lpViewAttrib->szDerivedOper, "*xpg*" ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+213]
	movsx	ecx, BYTE PTR $SG16723
	cmp	eax, ecx
	jne	SHORT $LN30@fnGetAttri
	push	OFFSET $SG16724
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 213				; 000000d5H
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN31@fnGetAttri
$LN30@fnGetAttri:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+213]
	movsx	edx, BYTE PTR $SG16725
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN28@fnGetAttri
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN29@fnGetAttri
$LN28@fnGetAttri:
	mov	DWORD PTR tv192[ebp], -1
$LN29@fnGetAttri:
	mov	eax, DWORD PTR tv192[ebp]
	mov	DWORD PTR tv193[ebp], eax
$LN31@fnGetAttri:
	cmp	DWORD PTR tv193[ebp], 0
	jne	SHORT $LN19@fnGetAttri

; 6249 :          lpTaskOperation->pfnTaskOper = (zPVOID) DfExecuteXPG;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+30], OFFSET _DfExecuteXPG@16
$LN19@fnGetAttri:

; 6250 :    }

	jmp	SHORT $LN17@fnGetAttri
$LN16@fnGetAttri:

; 6251 :    else
; 6252 :    {
; 6253 :       lpTaskOperation->pfnTaskOper = SysGetProc( hLibrary,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 213				; 000000d5H
	push	edx
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+30], eax
$LN17@fnGetAttri:

; 6254 :                                                  lpViewAttrib->szDerivedOper );
; 6255 :    }
; 6256 : 
; 6257 :    // Set pointers for TaskOperation chain off of ViewAttrib structure
; 6258 :    // Note: this is a double linked list
; 6259 :    if ( lpViewAttrib->hLastTaskOperation )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [edx+189], 0
	je	SHORT $LN21@fnGetAttri

; 6260 :    {
; 6261 :       LPTASKOPER  lpTempOperation;
; 6262 : 
; 6263 :       lpTempOperation = zGETPTR( lpViewAttrib->hLastTaskOperation );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+189]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempOperation$1[ebp], eax

; 6264 :       lpTempOperation->hNextTaskOperationForOEA = hTaskOperation;

	mov	edx, DWORD PTR _lpTempOperation$1[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+6], eax

; 6265 :       lpTaskOperation->hPrevTaskOperationForOEA =

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+189]
	mov	DWORD PTR [ecx+10], eax

; 6266 :                                             lpViewAttrib->hLastTaskOperation;
; 6267 :       lpViewAttrib->hLastTaskOperation = hTaskOperation;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [ecx+189], edx

; 6268 :    }

	jmp	SHORT $LN22@fnGetAttri
$LN21@fnGetAttri:

; 6269 :    else
; 6270 :    {
; 6271 :       lpViewAttrib->hFirstTaskOperation = hTaskOperation;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [eax+185], ecx

; 6272 :       lpViewAttrib->hLastTaskOperation  = hTaskOperation;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+189], eax
$LN22@fnGetAttri:

; 6273 :    }
; 6274 : 
; 6275 :    return( (zPOBJOPER) lpTaskOperation->pfnTaskOper );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [ecx+30]
$LN1@fnGetAttri:

; 6276 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetAttribOper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpLastTaskDomain$1 = -32				; size = 4
_lProcessID$ = -28					; size = 4
_hCurrentTask$ = -24					; size = 4
tv82 = -20						; size = 4
_hLibrary$ = -16					; size = 4
_hTaskDomain$ = -12					; size = 4
_lpTaskDomain$ = -8					; size = 4
_cDomainType$ = -1					; size = 1
_lpView$ = 8						; size = 4
_lpCurrentTask$ = 12					; size = 4
_lpDomain$ = 16						; size = 4
_fnGetTaskDomain PROC

; 5643 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5644 :    LPTASK         hCurrentTask = zGETHNDL( lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hCurrentTask$[ebp], eax

; 5645 :    LPLIBRARY      hLibrary = 0;

	mov	DWORD PTR _hLibrary$[ebp], 0

; 5646 :    LPTASKDOMAIN   lpTaskDomain;
; 5647 :    zPVOID         hTaskDomain;
; 5648 :    zCHAR          cDomainType;
; 5649 :    zLONG          lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 5650 : 
; 5651 :    if ( lpDomain == 0 )  // no domain pointer ...

	cmp	DWORD PTR _lpDomain$[ebp], 0
	jne	SHORT $LN6@fnGetTaskD

; 5652 :       return( 0 );       //   return not found!

	xor	eax, eax
	jmp	$LN1@fnGetTaskD
$LN6@fnGetTaskD:

; 5653 : 
; 5654 :    lpTaskDomain = zGETPTR( lpDomain->hFirstTaskDomain );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR [ecx+51]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDomain$[ebp], eax
$LN2@fnGetTaskD:

; 5655 :    while ( lpTaskDomain )

	cmp	DWORD PTR _lpTaskDomain$[ebp], 0
	je	SHORT $LN3@fnGetTaskD

; 5656 :    {
; 5657 :       if ( lpTaskDomain->hTask == hCurrentTask &&

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	cmp	ecx, DWORD PTR _hCurrentTask$[ebp]
	jne	SHORT $LN7@fnGetTaskD
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	mov	eax, DWORD PTR [edx+22]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN7@fnGetTaskD

; 5658 :            lpTaskDomain->lProcessID == lProcessID )
; 5659 :       {
; 5660 :          return( lpTaskDomain );

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	jmp	$LN1@fnGetTaskD
$LN7@fnGetTaskD:

; 5661 :       }
; 5662 : 
; 5663 :       lpTaskDomain = zGETPTR( lpTaskDomain->hNextTaskDomainForDomain );

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDomain$[ebp], eax

; 5664 :    }

	jmp	SHORT $LN2@fnGetTaskD
$LN3@fnGetTaskD:

; 5665 : 
; 5666 :    cDomainType = lpDomain->cDomainType;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	cl, BYTE PTR [eax+65]
	mov	BYTE PTR _cDomainType$[ebp], cl

; 5667 : 
; 5668 :    switch ( cDomainType )

	movsx	edx, BYTE PTR _cDomainType$[ebp]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR tv82[ebp]
	sub	eax, 65					; 00000041H
	mov	DWORD PTR tv82[ebp], eax
	cmp	DWORD PTR tv82[ebp], 19			; 00000013H
	ja	$LN4@fnGetTaskD
	mov	ecx, DWORD PTR tv82[ebp]
	movzx	edx, BYTE PTR $LN21@fnGetTaskD[ecx]
	jmp	DWORD PTR $LN22@fnGetTaskD[edx*4]
$LN8@fnGetTaskD:

; 5669 :    {
; 5670 :       case zDM_TYPE_EXPRESSION:
; 5671 :       case zDM_TYPE_ALGORITHM:
; 5672 :          if ( lpDomain->szLibraryName[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+67]
	test	eax, eax
	jne	SHORT $LN9@fnGetTaskD

; 5673 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetTaskD
$LN9@fnGetTaskD:

; 5674 : 
; 5675 :          hLibrary = SysLoadLibrary( lpView, lpDomain->szLibraryName );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 67					; 00000043H
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 5676 :          if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $LN11@fnGetTaskD

; 5677 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetTaskD
$LN11@fnGetTaskD:

; 5678 : 
; 5679 :          // Yes, we should fall through.
; 5680 : 
; 5681 :       case zDM_TYPE_TABLE:
; 5682 :       case zDM_TYPE_FORMAT:
; 5683 :       {
; 5684 :          // If a table Domain has an operation, make sure the library routine
; 5685 :          // is properly accessed, the same as for Algorithm above.
; 5686 :          if ( cDomainType == zDM_TYPE_TABLE &&
; 5687 :               lpDomain->szDomainOper[ 0 ] && lpDomain->szLibraryName[ 0 ] )

	movsx	eax, BYTE PTR _cDomainType$[ebp]
	cmp	eax, 84					; 00000054H
	jne	SHORT $LN12@fnGetTaskD
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+100]
	test	ecx, ecx
	je	SHORT $LN12@fnGetTaskD
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+67]
	test	edx, edx
	je	SHORT $LN12@fnGetTaskD

; 5688 :          {
; 5689 :             hLibrary = SysLoadLibrary( lpView, lpDomain->szLibraryName );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 67					; 00000043H
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax
$LN12@fnGetTaskD:

; 5690 :          }
; 5691 : 
; 5692 :          hTaskDomain = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10008					; 00002718H
	push	0
	push	1
	push	34					; 00000022H
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskDomain$[ebp], eax

; 5693 :                                          sizeof( TaskDomainRecord ), 1, 0,
; 5694 :                                          iTaskDomain );
; 5695 :          if ( hTaskDomain == 0 )

	cmp	DWORD PTR _hTaskDomain$[ebp], 0
	jne	SHORT $LN13@fnGetTaskD

; 5696 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetTaskD
$LN13@fnGetTaskD:

; 5697 : 
; 5698 :          lpTaskDomain = zGETPTR( hTaskDomain );

	mov	ecx, DWORD PTR _hTaskDomain$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDomain$[ebp], eax

; 5699 : 
; 5700 :          lpTaskDomain->hDomain    = zGETHNDL( lpDomain );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 5701 :          lpTaskDomain->hTask      = hCurrentTask;

	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	mov	eax, DWORD PTR _hCurrentTask$[ebp]
	mov	DWORD PTR [edx+18], eax

; 5702 :          lpTaskDomain->lProcessID = lProcessID;

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [ecx+22], edx

; 5703 :          lpTaskDomain->hLibrary   = hLibrary;

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [eax+26], ecx

; 5704 : 
; 5705 :          // Set pointers for TaskDomain chain off of Task structure.
; 5706 :          // Note: this is a single linked list.
; 5707 :          if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _hCurrentTask$[ebp]
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $LN14@fnGetTaskD

; 5708 :             zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4
$LN14@fnGetTaskD:

; 5709 : 
; 5710 :          lpTaskDomain->hNextTaskDomainForTask = lpCurrentTask->hFirstTaskDomain;

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+126]
	mov	DWORD PTR [ecx+2], eax

; 5711 :          lpCurrentTask->hFirstTaskDomain = hTaskDomain;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR _hTaskDomain$[ebp]
	mov	DWORD PTR [ecx+126], edx

; 5712 : 
; 5713 :          if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hCurrentTask$[ebp]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN15@fnGetTaskD

; 5714 :             zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN15@fnGetTaskD:

; 5715 : #if 0
; 5716 :          // debugging only dks 2005.12.01
; 5717 :          if ( lpTaskDomain->hTask == AnchorBlock->hMainTask )
; 5718 :          {
; 5719 :             LPAPP lpApp = zGETPTR( lpDomain->hApp );
; 5720 :             if ( zstricmp( lpApp->szName, "ZENCAS" ) == 0 )
; 5721 :                TraceLineS( "", "" );
; 5722 :          }
; 5723 : #endif
; 5724 :          // Set pointers for TaskDomain chain off of Domain structure.
; 5725 :          // Note: this is a double linked list.
; 5726 :          if ( lpDomain->hLastTaskDomain )

	mov	edx, DWORD PTR _lpDomain$[ebp]
	cmp	DWORD PTR [edx+55], 0
	je	SHORT $LN16@fnGetTaskD

; 5727 :          {
; 5728 :             LPTASKDOMAIN lpLastTaskDomain;
; 5729 : 
; 5730 :             lpLastTaskDomain = zGETPTR( lpDomain->hLastTaskDomain );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR [eax+55]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastTaskDomain$1[ebp], eax

; 5731 :             lpLastTaskDomain->hNextTaskDomainForDomain = hTaskDomain;

	mov	edx, DWORD PTR _lpLastTaskDomain$1[ebp]
	mov	eax, DWORD PTR _hTaskDomain$[ebp]
	mov	DWORD PTR [edx+6], eax

; 5732 :             lpTaskDomain->hPrevTaskDomainForDomain =

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR [edx+55]
	mov	DWORD PTR [ecx+10], eax

; 5733 :                                           lpDomain->hLastTaskDomain;
; 5734 :             lpDomain->hLastTaskDomain = hTaskDomain;

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	edx, DWORD PTR _hTaskDomain$[ebp]
	mov	DWORD PTR [ecx+55], edx

; 5735 :          }

	jmp	SHORT $LN17@fnGetTaskD
$LN16@fnGetTaskD:

; 5736 :          else
; 5737 :          {
; 5738 :             lpDomain->hFirstTaskDomain = hTaskDomain;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR _hTaskDomain$[ebp]
	mov	DWORD PTR [eax+51], ecx

; 5739 :             lpDomain->hLastTaskDomain  = hTaskDomain;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR _hTaskDomain$[ebp]
	mov	DWORD PTR [edx+55], eax
$LN17@fnGetTaskD:

; 5740 :          }
; 5741 : 
; 5742 :          if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	SHORT $LN4@fnGetTaskD

; 5743 :          {
; 5744 :          // LPLIBRARY lpLibrary = zGETPTR( hLibrary );
; 5745 :          // TraceLine( "fnGetTaskDomain Task: 0x%08x   Domain: 0x%08x   Lib: %s",
; 5746 :          //            lpView->hTask, lpTaskDomain, lpLibrary->szName );
; 5747 :             if ( lpDomain->szDomainOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+100]
	test	ecx, ecx
	je	SHORT $LN4@fnGetTaskD

; 5748 :             {
; 5749 :                lpTaskDomain->pfDomainOper =

	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	DWORD PTR [ecx+30], eax
$LN4@fnGetTaskD:

; 5750 :                               (zPDMOPER) SysGetProc( hLibrary,
; 5751 :                                                      lpDomain->szDomainOper );
; 5752 :             }
; 5753 :          }
; 5754 :       }
; 5755 :    }
; 5756 : 
; 5757 :    return( lpTaskDomain );

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
$LN1@fnGetTaskD:

; 5758 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@fnGetTaskD:
	DD	$LN8@fnGetTaskD
	DD	$LN11@fnGetTaskD
	DD	$LN4@fnGetTaskD
$LN21@fnGetTaskD:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
_fnGetTaskDomain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -36						; size = 4
_lpViewEntity$2 = -32					; size = 4
tv93 = -28						; size = 4
tv90 = -24						; size = 4
tv86 = -20						; size = 4
tv79 = -16						; size = 4
tv73 = -12						; size = 4
tv71 = -8						; size = 4
_lpAttrValue$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_fnAttributeValueNull PROC

; 10491: {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 10492:    zPVOID   lpAttrValue;
; 10493: 
; 10494:    fnGetAddrForAttribute( (zCOREMEM) &lpAttrValue, lpView, 0, lpEntityInstance,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpAttrValue$[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 10495:                           lpViewAttrib );
; 10496:    switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv71[ebp], edx
	mov	eax, DWORD PTR tv71[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 18			; 00000012H
	ja	$LN9@fnAttribut
	mov	ecx, DWORD PTR tv71[ebp]
	movzx	edx, BYTE PTR $LN21@fnAttribut[ecx]
	jmp	DWORD PTR $LN22@fnAttribut[edx*4]
$LN4@fnAttribut:

; 10497:    {
; 10498:       case zTYPE_INTEGER:
; 10499:          return( (*((zPLONG) lpAttrValue) == lNullInteger) ? 1 : 0 );

	mov	eax, DWORD PTR _lpAttrValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN11@fnAttribut
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN12@fnAttribut
$LN11@fnAttribut:
	mov	DWORD PTR tv73[ebp], 0
$LN12@fnAttribut:
	mov	ax, WORD PTR tv73[ebp]
	jmp	$LN1@fnAttribut
$LN5@fnAttribut:

; 10500: 
; 10501:       case zTYPE_DECIMAL:
; 10502:          return( SysCompareDecimalToNull( (zPDECIMAL) lpAttrValue ) == 0 ? 1 : 0 );

	mov	edx, DWORD PTR _lpAttrValue$[ebp]
	push	edx
	call	_SysCompareDecimalToNull@4
	cwde
	test	eax, eax
	jne	SHORT $LN13@fnAttribut
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN14@fnAttribut
$LN13@fnAttribut:
	mov	DWORD PTR tv79[ebp], 0
$LN14@fnAttribut:
	mov	ax, WORD PTR tv79[ebp]
	jmp	$LN1@fnAttribut
$LN6@fnAttribut:

; 10503: 
; 10504:       case zTYPE_DATETIME:
; 10505:          return( (fnCompareDateTimeToDateTime( (LPDTINTERNAL) lpAttrValue,

	push	OFFSET _stNullDateTime
	mov	ecx, DWORD PTR _lpAttrValue$[ebp]
	push	ecx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN15@fnAttribut
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN16@fnAttribut
$LN15@fnAttribut:
	mov	DWORD PTR tv86[ebp], 0
$LN16@fnAttribut:
	mov	ax, WORD PTR tv86[ebp]
	jmp	$LN1@fnAttribut
$LN7@fnAttribut:

; 10506:                              (LPDTINTERNAL) &stNullDateTime ) == 0 ) ? 1 : 0 );
; 10507: 
; 10508:       case zTYPE_STRING:
; 10509:          return( (*((zPCHAR) lpAttrValue) == 0) ? 1 : 0 );

	mov	eax, DWORD PTR _lpAttrValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN17@fnAttribut
	mov	DWORD PTR tv90[ebp], 1
	jmp	SHORT $LN18@fnAttribut
$LN17@fnAttribut:
	mov	DWORD PTR tv90[ebp], 0
$LN18@fnAttribut:
	mov	ax, WORD PTR tv90[ebp]
	jmp	SHORT $LN1@fnAttribut
$LN8@fnAttribut:

; 10510: 
; 10511:       case zTYPE_BLOB:
; 10512:          return( (lpAttrValue == 0) ? 1 : 0 );

	cmp	DWORD PTR _lpAttrValue$[ebp], 0
	jne	SHORT $LN19@fnAttribut
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN20@fnAttribut
$LN19@fnAttribut:
	mov	DWORD PTR tv93[ebp], 0
$LN20@fnAttribut:
	mov	ax, WORD PTR tv93[ebp]
	jmp	SHORT $LN1@fnAttribut
$LN9@fnAttribut:

; 10513: 
; 10514:       default:
; 10515:       {
; 10516:          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 10517:          LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 10518: 
; 10519:          // "KZOEE246 - Invalid Attribute type "
; 10520:          fnIssueCoreError( lpTask, lpView, 8, 246, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	246					; 000000f6H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 10521:                            lpViewEntity->szName, lpViewAttrib->szName );
; 10522:          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@fnAttribut:

; 10523:       }
; 10524:    }
; 10525: }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@fnAttribut:
	DD	$LN8@fnAttribut
	DD	$LN4@fnAttribut
	DD	$LN5@fnAttribut
	DD	$LN7@fnAttribut
	DD	$LN6@fnAttribut
	DD	$LN9@fnAttribut
$LN21@fnAttribut:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnAttributeValueNull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pdDecimal$ = -556					; size = 4
_plInteger$ = -552					; size = 4
_lpTask$1 = -548					; size = 4
_lpTaskDomain$ = -544					; size = 4
$T2 = -540						; size = 4
_lpDomain$ = -536					; size = 4
_lpViewEntity$ = -532					; size = 4
tv89 = -528						; size = 4
tv163 = -524						; size = 4
_lpEntityInstance$ = -520				; size = 4
_szTempStr$ = -516					; size = 2
_cDomainType$ = -509					; size = 1
_nRC$ = -508						; size = 2
_szMsg$3 = -504						; size = 500
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lpVariable$ = 20					; size = 4
_cVariableType$ = 24					; size = 1
_ulVariableLth$ = 28					; size = 4
_cpcContextName$ = 32					; size = 4
_lpCurrentTask$ = 36					; size = 4
_nFlag$ = 40						; size = 2
_fnCompareAttributeToVariable PROC

; 8719 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 8720 :    LPVIEWENTITY      lpViewEntity;
; 8721 :    LPENTITYINSTANCE  lpEntityInstance;
; 8722 :    LPDOMAIN          lpDomain;
; 8723 :    LPTASKDOMAIN      lpTaskDomain;
; 8724 :    zCHAR             cDomainType;
; 8725 :    zCHAR             szTempStr[ 2 ];
; 8726 :    zPLONG            plInteger;
; 8727 :    zPDECIMAL         pdDecimal;
; 8728 :    zSHORT            nRC;
; 8729 : 
; 8730 :    // Get view Entity from cursor
; 8731 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 8732 : 
; 8733 :    // If there is an object operation for this attribute,
; 8734 :    // invoke it now...
; 8735 :    if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+213]
	test	edx, edx
	je	SHORT $LN6@fnCompareA

; 8736 :    {
; 8737 :       nRC = fnInvokeDerivedOperation( lpView, lpViewEntity, lpViewAttrib,

	push	2
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 8738 :                                       lpCurrentTask, zDERIVED_GET );
; 8739 :       if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN6@fnCompareA

; 8740 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN18@fnCompareA
$LN6@fnCompareA:

; 8741 :    }
; 8742 : 
; 8743 :    lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 8744 :    cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 8745 :                                              lpCurrentTask, lpDomain );
; 8746 :    switch ( cDomainType )

	mov	dl, BYTE PTR _cDomainType$[ebp]
	mov	BYTE PTR tv89[ebp], dl
	cmp	BYTE PTR tv89[ebp], 65			; 00000041H
	je	SHORT $LN9@fnCompareA
	cmp	BYTE PTR tv89[ebp], 69			; 00000045H
	je	SHORT $LN9@fnCompareA
	cmp	BYTE PTR tv89[ebp], 84			; 00000054H
	je	SHORT $LN8@fnCompareA
	jmp	$LN11@fnCompareA
$LN8@fnCompareA:

; 8747 :    {
; 8748 :       case zDM_TYPE_TABLE:
; 8749 :          nRC = Table_Handler( (zLONG) zDME_COMPARE_ATTRIBUTE,

	push	0
	movsx	eax, WORD PTR _ulVariableLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	movzx	eax, BYTE PTR _cVariableType$[ebp]
	push	eax
	push	3
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 8750 :                               cVariableType,
; 8751 :                               lpVariable,
; 8752 :                               cpcContextName,
; 8753 :                               lpView,
; 8754 :                               lpViewEntity,
; 8755 :                               lpViewAttrib,
; 8756 :                               (zSHORT) ulVariableLth,
; 8757 :                               (zPVOID) 0 );
; 8758 :          break;

	jmp	$LN2@fnCompareA
$LN9@fnCompareA:

; 8759 : 
; 8760 :       case zDM_TYPE_EXPRESSION:
; 8761 :       case zDM_TYPE_ALGORITHM:
; 8762 :          nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	mov	ecx, DWORD PTR _ulVariableLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _cVariableType$[ebp]
	push	ecx
	push	3
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 8763 :                                  zDME_COMPARE_ATTRIBUTE,
; 8764 :                                  cVariableType,
; 8765 :                                  lpVariable,
; 8766 :                                  cpcContextName,
; 8767 :                                  lpView,
; 8768 :                                  lpViewEntity,
; 8769 :                                  lpViewAttrib,
; 8770 :                                  ulVariableLth );
; 8771 : 
; 8772 :          if ( nRC == zDME_NOT_HANDLED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -10				; fffffff6H
	jne	SHORT $LN10@fnCompareA

; 8773 :          {
; 8774 :             zCHAR szMsg[ 500 ];
; 8775 : 
; 8776 :             zsprintf( szMsg, "Operation '%s' does not handle an Entry "

	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	push	3
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET $SG17761
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 8777 :                       "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 8778 :                       zDME_COMPARE_ATTRIBUTE, lpDomain->szName );
; 8779 :             MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	edx, DWORD PTR _szMsg$3[ebp]
	push	edx
	push	OFFSET $SG17762
	push	OFFSET $SG17763
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MessageSend@24

; 8780 :                          szMsg, zMSGQ_DOMAIN_ERROR, 0 );
; 8781 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN18@fnCompareA
$LN10@fnCompareA:

; 8782 :          }
; 8783 : 
; 8784 :          break;

	jmp	$LN2@fnCompareA
$LN11@fnCompareA:

; 8785 : 
; 8786 :       case zDM_TYPE_FORMAT:
; 8787 :       default:
; 8788 :          // Get Entity Instance pointer
; 8789 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8790 : 
; 8791 :          // do it without a domain...
; 8792 :          switch ( cVariableType )

	movsx	eax, BYTE PTR _cVariableType$[ebp]
	mov	DWORD PTR tv163[ebp], eax
	mov	ecx, DWORD PTR tv163[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv163[ebp], ecx
	cmp	DWORD PTR tv163[ebp], 18		; 00000012H
	ja	$LN17@fnCompareA
	mov	edx, DWORD PTR tv163[ebp]
	movzx	eax, BYTE PTR $LN21@fnCompareA[edx]
	jmp	DWORD PTR $LN22@fnCompareA[eax*4]
$LN12@fnCompareA:

; 8793 :          {
; 8794 :             case zTYPE_STRING:
; 8795 :                nRC = fnCompareAttributeToString( lpEntityInstance,

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnCompareAttributeToString
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 8796 :                                                  lpViewEntityCsr,
; 8797 :                                                  lpViewAttrib,
; 8798 :                                                  (zPCHAR) lpVariable );
; 8799 :                break;

	jmp	$LN2@fnCompareA
$LN13@fnCompareA:

; 8800 : 
; 8801 :             case zTYPE_BLOB:
; 8802 :                nRC = fnCompareAttributeToBlob( lpEntityInstance,

	mov	edx, DWORD PTR _ulVariableLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnCompareAttributeToBlob
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 8803 :                                                lpViewEntityCsr,
; 8804 :                                                lpViewAttrib,
; 8805 :                                                (zPCHAR) lpVariable,
; 8806 :                                                ulVariableLth );
; 8807 :                break;

	jmp	$LN2@fnCompareA
$LN14@fnCompareA:

; 8808 : 
; 8809 :             case zTYPE_INTEGER:
; 8810 :                plInteger = (zPLONG) lpVariable;

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _plInteger$[ebp], ecx

; 8811 :                nRC = fnCompareAttributeToInteger( lpEntityInstance,

	mov	edx, DWORD PTR _lpVariable$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnCompareAttributeToInteger
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 8812 :                                                   lpViewEntityCsr,
; 8813 :                                                   lpViewAttrib,
; 8814 :                                                   *((zPLONG) lpVariable) );
; 8815 :                break;

	jmp	$LN2@fnCompareA
$LN15@fnCompareA:

; 8816 : 
; 8817 :             case zTYPE_DECIMAL:
; 8818 :                pdDecimal = (zPDECIMAL) lpVariable;

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _pdDecimal$[ebp], ecx

; 8819 :                nRC = fnCompareAttributeToDecimal( lpEntityInstance,

	mov	esi, DWORD PTR _lpVariable$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnCompareAttributeToDecimal
	add	esp, 52					; 00000034H
	mov	WORD PTR _nRC$[ebp], ax

; 8820 :                                                   lpViewEntityCsr,
; 8821 :                                                   lpViewAttrib,
; 8822 :                                                   *((zPDECIMAL) lpVariable) );
; 8823 :                break;

	jmp	$LN2@fnCompareA
$LN16@fnCompareA:

; 8824 : 
; 8825 :             case zTYPE_DATETIME:
; 8826 :                nRC = fnCompareAttributeToDateTime( lpEntityInstance,

	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnCompareAttributeToDateTime
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 8827 :                                                    lpViewEntityCsr,
; 8828 :                                                    lpViewAttrib,
; 8829 :                                                    (LPDATETIME) lpVariable );
; 8830 :                break;

	jmp	SHORT $LN2@fnCompareA
$LN17@fnCompareA:

; 8831 : 
; 8832 :             default:
; 8833 :             {
; 8834 :                LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 8835 :                szTempStr[ 0 ] = cVariableType;

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _cVariableType$[ebp]
	mov	BYTE PTR _szTempStr$[ebp+eax], cl

; 8836 :                szTempStr[ 1 ] = '\x00';

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 2
	jae	SHORT $LN19@fnCompareA
	jmp	SHORT $LN20@fnCompareA
$LN19@fnCompareA:
	call	___report_rangecheckfailure
$LN20@fnCompareA:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szTempStr$[ebp+edx], 0

; 8837 :                // "KZOEE241 - Invalid Variable Type"
; 8838 :                fnIssueCoreError( lpTask, lpView, 8, 241, 0, szTempStr, 0 );

	push	0
	lea	eax, DWORD PTR _szTempStr$[ebp]
	push	eax
	push	0
	push	241					; 000000f1H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8839 :                nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN2@fnCompareA:

; 8840 :             }
; 8841 :          }
; 8842 :    }
; 8843 : 
; 8844 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN18@fnCompareA:

; 8845 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN22@fnCompareA:
	DD	$LN13@fnCompareA
	DD	$LN14@fnCompareA
	DD	$LN15@fnCompareA
	DD	$LN12@fnCompareA
	DD	$LN16@fnCompareA
	DD	$LN17@fnCompareA
$LN21@fnCompareA:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnCompareAttributeToVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
tv88 = -12						; size = 4
tv79 = -8						; size = 4
_nRC$ = -4						; size = 2
_lpDateTime1$ = 8					; size = 4
_lpDateTime2$ = 12					; size = 4
_fnCompareDateTimeToDateTime PROC

; 8490 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8491 :    zSHORT   nRC;
; 8492 : 
; 8493 :    if ( lpDateTime1->ulDateMinutes == lpDateTime2->ulDateMinutes )

	mov	eax, DWORD PTR _lpDateTime1$[ebp]
	mov	ecx, DWORD PTR _lpDateTime2$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@fnCompareD

; 8494 :    {
; 8495 :       if ( (zLONG) lpDateTime1->ulDateMinutes == lNullInteger ||

	mov	eax, DWORD PTR _lpDateTime1$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	je	SHORT $LN6@fnCompareD
	mov	edx, DWORD PTR _lpDateTime1$[ebp]
	movzx	eax, WORD PTR [edx+4]
	mov	ecx, DWORD PTR _lpDateTime2$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	cmp	eax, edx
	jne	SHORT $LN4@fnCompareD
$LN6@fnCompareD:

; 8496 :            lpDateTime1->usTSeconds == lpDateTime2->usTSeconds )
; 8497 :       {
; 8498 :          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 8499 :       }

	jmp	SHORT $LN5@fnCompareD
$LN4@fnCompareD:

; 8500 :       else
; 8501 :          nRC = (lpDateTime1->usTSeconds < lpDateTime2->usTSeconds) ? -1 : 1;

	mov	ecx, DWORD PTR _lpDateTime1$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _lpDateTime2$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	cmp	edx, ecx
	jge	SHORT $LN12@fnCompareD
	mov	DWORD PTR tv79[ebp], -1
	jmp	SHORT $LN13@fnCompareD
$LN12@fnCompareD:
	mov	DWORD PTR tv79[ebp], 1
$LN13@fnCompareD:
	mov	dx, WORD PTR tv79[ebp]
	mov	WORD PTR _nRC$[ebp], dx
$LN5@fnCompareD:

; 8502 :    }

	jmp	SHORT $LN3@fnCompareD
$LN2@fnCompareD:

; 8503 :    else
; 8504 :    {
; 8505 :       if ( (zLONG) lpDateTime1->ulDateMinutes == lNullInteger )

	mov	eax, DWORD PTR _lpDateTime1$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN7@fnCompareD

; 8506 :          nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN3@fnCompareD
$LN7@fnCompareD:

; 8507 :       else
; 8508 :          if ( (zLONG) lpDateTime2->ulDateMinutes == lNullInteger )

	mov	eax, DWORD PTR _lpDateTime2$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN9@fnCompareD

; 8509 :             nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN3@fnCompareD
$LN9@fnCompareD:

; 8510 :          else
; 8511 :             nRC = (lpDateTime1->ulDateMinutes < lpDateTime2->ulDateMinutes) ? -1 : 1;

	mov	eax, DWORD PTR _lpDateTime1$[ebp]
	mov	ecx, DWORD PTR _lpDateTime2$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN14@fnCompareD
	mov	DWORD PTR tv88[ebp], -1
	jmp	SHORT $LN15@fnCompareD
$LN14@fnCompareD:
	mov	DWORD PTR tv88[ebp], 1
$LN15@fnCompareD:
	mov	ax, WORD PTR tv88[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN3@fnCompareD:

; 8512 :    }
; 8513 : 
; 8514 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 8515 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareDateTimeToDateTime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTaskDomain$ = -552					; size = 4
tv140 = -548						; size = 4
_lpViewEntityCsr$ = -544				; size = 4
_lpAttrValue$ = -540					; size = 4
_lpDomain$ = -536					; size = 4
_lDomainEntryType$ = -532				; size = 4
_lpViewEntity$ = -528					; size = 4
tv147 = -524						; size = 4
_lpViewAttrib$ = -520					; size = 4
_cDomainType$ = -513					; size = 1
_lpCurrentTask$ = -512					; size = 4
_nRC$ = -508						; size = 2
_szMsg$1 = -504						; size = 500
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcContextName$ = 20					; size = 4
_iOperationID$ = 24					; size = 2
_fnSetAttributeValue PROC

; 10348: {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 10349:    LPTASK            lpCurrentTask;
; 10350:    LPVIEWENTITY      lpViewEntity;
; 10351:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10352:    LPVIEWATTRIB      lpViewAttrib;
; 10353:    zPVOID            lpAttrValue;
; 10354:    LPTASKDOMAIN      lpTaskDomain;
; 10355:    LPDOMAIN          lpDomain;
; 10356:    zCHAR             cDomainType;
; 10357:    zLONG             lDomainEntryType;
; 10358:    zSHORT            nRC;
; 10359: 
; 10360:    // Validate parameters
; 10361:    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	movzx	eax, WORD PTR _iOperationID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 10362:                                         &lpViewEntity,
; 10363:                                         &lpViewEntityCsr,
; 10364:                                         &lpViewAttrib,
; 10365:                                         iOperationID, // next prev
; 10366:                                         1,   // We intend to update
; 10367:                                         lpView,
; 10368:                                         cpcEntityName,
; 10369:                                         cpcAttributeName, 0 );
; 10370:    if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN4@fnSetAttri

; 10371:       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetAttri
$LN4@fnSetAttri:

; 10372: 
; 10373:    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN5@fnSetAttri

; 10374:    {
; 10375:       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8

; 10376:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetAttri
$LN5@fnSetAttri:

; 10377:    }
; 10378: 
; 10379:    if ( lpViewAttrib->hDomain == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	jne	SHORT $LN6@fnSetAttri

; 10380:    {
; 10381:       // "KZOEE244 - Attribute has no Domain"
; 10382: //    fnIssueCoreError( lpTask, lpView, 8, 244, 0, cpcEntityName, cpcAttributeName );
; 10383:       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8

; 10384:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetAttri
$LN6@fnSetAttri:

; 10385:    }
; 10386: 
; 10387:    lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 10388: 
; 10389:    fnGetAddrForAttribute( (zCOREMEM) &lpAttrValue, lpView, lpViewEntityCsr, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpAttrValue$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 10390:                           lpViewAttrib );
; 10391:    if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN7@fnSetAttri

; 10392:    {
; 10393:       if ( *((zPCHAR) lpAttrValue) == 0 )

	mov	edx, DWORD PTR _lpAttrValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@fnSetAttri

; 10394:       {
; 10395:          // Attribute value is null, it cannot be set to prev/next value
; 10396:          fnOperationReturn( iOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8

; 10397:          return( -1 );

	or	eax, -1
	jmp	$LN1@fnSetAttri
$LN9@fnSetAttri:

; 10398:       }
; 10399:    }

	jmp	SHORT $LN8@fnSetAttri
$LN7@fnSetAttri:

; 10400:    else
; 10401:    {
; 10402:       // we must be working with an integer type if it isn't a string
; 10403:       if ( *((zPLONG) lpAttrValue) == lNullInteger )

	mov	eax, DWORD PTR _lpAttrValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN8@fnSetAttri

; 10404:       {
; 10405:          // Attribute value is null, it cannot be set to prev/next value
; 10406:          fnOperationReturn( iOperationID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movzx	eax, WORD PTR _iOperationID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8

; 10407:          return( -1 );

	or	eax, -1
	jmp	$LN1@fnSetAttri
$LN8@fnSetAttri:

; 10408:       }
; 10409:    }
; 10410: 
; 10411:    // Get view Entity from cursor.
; 10412:    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10413: 
; 10414:    lDomainEntryType = (iOperationID == iSetAttributeValueNext) ?

	movsx	eax, WORD PTR _iOperationID$[ebp]
	cmp	eax, 282				; 0000011aH
	jne	SHORT $LN16@fnSetAttri
	mov	DWORD PTR tv140[ebp], 6
	jmp	SHORT $LN17@fnSetAttri
$LN16@fnSetAttri:
	mov	DWORD PTR tv140[ebp], 7
$LN17@fnSetAttri:
	mov	ecx, DWORD PTR tv140[ebp]
	mov	DWORD PTR _lDomainEntryType$[ebp], ecx

; 10415:       zDME_SET_ATTRIBUTE_VALUE_NEXT : zDME_SET_ATTRIBUTE_VALUE_PREV ;
; 10416: 
; 10417:    cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 10418:                                              lpCurrentTask, lpDomain );
; 10419:    switch ( cDomainType )

	mov	al, BYTE PTR _cDomainType$[ebp]
	mov	BYTE PTR tv147[ebp], al
	cmp	BYTE PTR tv147[ebp], 65			; 00000041H
	je	SHORT $LN12@fnSetAttri
	cmp	BYTE PTR tv147[ebp], 69			; 00000045H
	je	SHORT $LN12@fnSetAttri
	cmp	BYTE PTR tv147[ebp], 84			; 00000054H
	je	SHORT $LN11@fnSetAttri
	jmp	$LN14@fnSetAttri
$LN11@fnSetAttri:

; 10420:    {
; 10421:       case zDM_TYPE_TABLE:
; 10422:          nRC = Table_Handler( lDomainEntryType,

	push	0
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _lDomainEntryType$[ebp]
	push	edx
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 10423:                               0,
; 10424:                               0,
; 10425:                               cpcContextName,
; 10426:                               lpView,
; 10427:                               lpViewEntity,
; 10428:                               lpViewAttrib,
; 10429:                               0,
; 10430:                               (zPVOID) 0 );
; 10431:          break;

	jmp	$LN2@fnSetAttri
$LN12@fnSetAttri:

; 10432: 
; 10433:       case zDM_TYPE_EXPRESSION:
; 10434:       case zDM_TYPE_ALGORITHM:
; 10435:          nRC = fnCallDomainOper( lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _lDomainEntryType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 10436:                                  lpTaskDomain,
; 10437:                                  lDomainEntryType,
; 10438:                                  0,
; 10439:                                  0,
; 10440:                                  cpcContextName,
; 10441:                                  lpView,
; 10442:                                  lpViewEntity,
; 10443:                                  lpViewAttrib,
; 10444:                                  0 );
; 10445:          if ( nRC == zDME_NOT_HANDLED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -10				; fffffff6H
	jne	SHORT $LN13@fnSetAttri

; 10446:          {
; 10447:             zCHAR szMsg[ 500 ];
; 10448: 
; 10449:             zsprintf( szMsg, "Operation '%s' does not handle an Entry "

	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lDomainEntryType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	push	OFFSET $SG18328
	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 10450:                       "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 10451:                       lDomainEntryType, lpDomain->szName );
; 10452:             MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	push	OFFSET $SG18329
	push	OFFSET $SG18330
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MessageSend@24

; 10453:                          szMsg, zMSGQ_DOMAIN_ERROR, 0 );
; 10454:             fnOperationReturn( iOperationID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movzx	eax, WORD PTR _iOperationID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8

; 10455:             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSetAttri
$LN13@fnSetAttri:

; 10456:          }
; 10457: 
; 10458:          break;

	jmp	SHORT $LN2@fnSetAttri
$LN14@fnSetAttri:

; 10459: 
; 10460:       case zDM_TYPE_FORMAT:
; 10461:       default:
; 10462:          nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnSetAttri:

; 10463:    }
; 10464: 
; 10465:    fnOperationReturn( iOperationID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movzx	eax, WORD PTR _iOperationID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8

; 10466:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSetAttri:

; 10467: }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpEntityInstance$ = -936				; size = 4
_lpTask$1 = -932					; size = 4
_pdDecimal$ = -928					; size = 4
_plInteger$ = -924					; size = 4
_lpTaskDomain$ = -920					; size = 4
_lpTask$2 = -916					; size = 4
_lpTask$3 = -912					; size = 4
tv266 = -908						; size = 4
_lpTask$4 = -904					; size = 4
_lpTask$5 = -900					; size = 4
_lpTask$6 = -896					; size = 4
_lpTask$7 = -892					; size = 4
$T8 = -888						; size = 4
_lpContext$9 = -884					; size = 4
$T10 = -880						; size = 4
_u$11 = -876						; size = 2
tv369 = -872						; size = 4
_lpContext$12 = -868					; size = 4
tv142 = -864						; size = 4
_lpViewEntity$ = -860					; size = 4
_szTempStr$ = -856					; size = 2
_lpDomain$ = -852					; size = 4
_cDomainType$ = -845					; size = 1
_nRC$ = -844						; size = 2
_szMsg$13 = -840					; size = 500
_sz2$14 = -340						; size = 100
_sz1$15 = -240						; size = 100
_sz1$16 = -140						; size = 66
_sz2$17 = -72						; size = 66
__$ArrayPad$ = -4					; size = 4
_lpVariable$ = 8					; size = 4
_pulReturnLth$ = 12					; size = 4
_cVariableType$ = 16					; size = 1
_ulVariableLth$ = 20					; size = 4
_lpView$ = 24						; size = 4
_lpViewEntityCsr$ = 28					; size = 4
_lpViewAttrib$ = 32					; size = 4
_cpcContextName$ = 36					; size = 4
_lpCurrentTask$ = 40					; size = 4
_nFlag$ = 44						; size = 2
_fnGetVariableFromAttribute PROC

; 9018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 936				; 000003a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9019 :    LPVIEWENTITY      lpViewEntity;
; 9020 :    LPENTITYINSTANCE  lpEntityInstance;
; 9021 :    LPTASKDOMAIN      lpTaskDomain;
; 9022 :    LPDOMAIN          lpDomain;
; 9023 :    zCHAR             cDomainType;
; 9024 :    zCHAR             szTempStr[ 2 ];
; 9025 :    zPLONG            plInteger;
; 9026 :    zPDECIMAL         pdDecimal;
; 9027 :    zSHORT            nRC;
; 9028 : 
; 9029 :    // Get view Entity from cursor.
; 9030 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9031 : 
; 9032 :    // Get Entity Instance pointer.
; 9033 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 9034 : 
; 9035 :    // If return variable is a string, init to null.
; 9036 :    if ( cVariableType == zTYPE_STRING || cVariableType == zTYPE_PIC )

	movsx	ecx, BYTE PTR _cVariableType$[ebp]
	cmp	ecx, 83					; 00000053H
	je	SHORT $LN9@fnGetVaria
	movsx	edx, BYTE PTR _cVariableType$[ebp]
	cmp	edx, 80					; 00000050H
	jne	SHORT $LN8@fnGetVaria
$LN9@fnGetVaria:

; 9037 :       *((zPCHAR) lpVariable) = 0;

	mov	eax, DWORD PTR _lpVariable$[ebp]
	mov	BYTE PTR [eax], 0
$LN8@fnGetVaria:

; 9038 : 
; 9039 :    // If there is an object operation for this attribute, invoke it now ...
; 9040 :    if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN10@fnGetVaria

; 9041 :    {
; 9042 :       nRC = fnInvokeDerivedOperation( lpView, lpViewEntity, lpViewAttrib,

	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 9043 :                                       lpCurrentTask, zDERIVED_GET );
; 9044 :       if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN10@fnGetVaria

; 9045 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN53@fnGetVaria
$LN10@fnGetVaria:

; 9046 :    }
; 9047 : 
; 9048 :    lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+198]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 9049 :    cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTaskDomain$[ebp]
	push	eax
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 9050 :                                              lpCurrentTask, lpDomain );
; 9051 : 
; 9052 :    // If cVariableType is zTYPE_STRING or if the cVariableType matches the
; 9053 :    // internal data type, and there is no Context Name specified, just
; 9054 :    // return the internal value.
; 9055 :    if ( cDomainType &&
; 9056 :         (cVariableType == zTYPE_STRING ||
; 9057 :          cVariableType == lpViewAttrib->cType) &&
; 9058 :         (cpcContextName == 0 || *cpcContextName == 0) &&

	movsx	ecx, BYTE PTR _cDomainType$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@fnGetVaria
	movsx	edx, BYTE PTR _cVariableType$[ebp]
	cmp	edx, 83					; 00000053H
	je	SHORT $LN13@fnGetVaria
	movsx	eax, BYTE PTR _cVariableType$[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	eax, edx
	jne	SHORT $LN12@fnGetVaria
$LN13@fnGetVaria:
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN14@fnGetVaria
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN12@fnGetVaria
$LN14@fnGetVaria:
	movsx	edx, WORD PTR _nFlag$[ebp]
	and	edx, 8
	jne	SHORT $LN12@fnGetVaria

; 9059 :         (nFlag & zUSE_DEFAULT_CONTEXT) == 0 )
; 9060 :    {
; 9061 :       cDomainType = 0;

	mov	BYTE PTR _cDomainType$[ebp], 0
$LN12@fnGetVaria:

; 9062 :    }
; 9063 : 
; 9064 :    switch ( cDomainType )

	movsx	eax, BYTE PTR _cDomainType$[ebp]
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR tv142[ebp]
	sub	ecx, 65					; 00000041H
	mov	DWORD PTR tv142[ebp], ecx
	cmp	DWORD PTR tv142[ebp], 19		; 00000013H
	ja	$LN41@fnGetVaria
	mov	edx, DWORD PTR tv142[ebp]
	movzx	eax, BYTE PTR $LN58@fnGetVaria[edx]
	jmp	DWORD PTR $LN60@fnGetVaria[eax*4]
$LN15@fnGetVaria:

; 9065 :    {
; 9066 :       case zDM_TYPE_TABLE:
; 9067 :          nRC = Table_Handler( (zLONG) zDME_GET_VARIABLE,

	push	0
	mov	ecx, DWORD PTR _ulVariableLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _cVariableType$[ebp]
	push	ecx
	push	2
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 9068 :                               cVariableType,
; 9069 :                               lpVariable,
; 9070 :                               cpcContextName,
; 9071 :                               lpView,
; 9072 :                               lpViewEntity,
; 9073 :                               lpViewAttrib,
; 9074 :                               ulVariableLth,
; 9075 :                               (zPVOID) 0 );
; 9076 :          if ( nRC == 0 && cVariableType == zTYPE_STRING && pulReturnLth )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN16@fnGetVaria
	movsx	eax, BYTE PTR _cVariableType$[ebp]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN16@fnGetVaria
	cmp	DWORD PTR _pulReturnLth$[ebp], 0
	je	SHORT $LN16@fnGetVaria

; 9077 :             *pulReturnLth = zstrlen( (zPCHAR) lpVariable );

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], eax
$LN16@fnGetVaria:

; 9078 : 
; 9079 :          break;

	jmp	$LN2@fnGetVaria
$LN17@fnGetVaria:

; 9080 : 
; 9081 :       case zDM_TYPE_FORMAT:
; 9082 :          if ( cVariableType == zTYPE_PIC )

	movsx	eax, BYTE PTR _cVariableType$[ebp]
	cmp	eax, 80					; 00000050H
	jne	$LN18@fnGetVaria

; 9083 :          {
; 9084 :             zLPCONTEXT lpContext = fnGetContext( lpDomain, cpcContextName );

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpContext$12[ebp], eax

; 9085 :             if ( lpContext )

	cmp	DWORD PTR _lpContext$12[ebp], 0
	je	$LN20@fnGetVaria

; 9086 :             {
; 9087 :                if ( lpContext->hEditString )

	mov	eax, DWORD PTR _lpContext$12[ebp]
	cmp	DWORD PTR [eax+59], 0
	je	$LN22@fnGetVaria

; 9088 :                {
; 9089 :                   zUSHORT u = zstrlen( zGETPTR( lpContext->hEditString ) );

	mov	ecx, DWORD PTR _lpContext$12[ebp]
	mov	edx, DWORD PTR [ecx+59]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _u$11[ebp], ax

; 9090 :                   if ( u > ulVariableLth )

	movzx	eax, WORD PTR _u$11[ebp]
	cmp	eax, DWORD PTR _ulVariableLth$[ebp]
	jbe	SHORT $LN24@fnGetVaria

; 9091 :                   {
; 9092 :                      LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$7[ebp], eax

; 9093 :                      // "KZOEE364 - Picture length exceeds input length "
; 9094 :                      fnIssueCoreError( lpTask, lpView, 8, 364, 0,

	push	1
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	call	_TrueName@8
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 6
	push	ecx
	push	0
	push	364					; 0000016cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$7[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9095 :                                        lpDomain->szName,
; 9096 :                                        TrueName( cpcContextName, zSHOW_ZKEY ));
; 9097 :                      nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 9098 :                   }

	jmp	SHORT $LN25@fnGetVaria
$LN24@fnGetVaria:

; 9099 :                   else
; 9100 :                   {
; 9101 :                      zstrcpy( (zPCHAR) lpVariable,

	mov	edx, DWORD PTR _lpContext$12[ebp]
	mov	eax, DWORD PTR [edx+59]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 9102 :                               zGETPTR( lpContext->hEditString ) );
; 9103 :                      nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 9104 :                      if ( pulReturnLth )

	cmp	DWORD PTR _pulReturnLth$[ebp], 0
	je	SHORT $LN25@fnGetVaria

; 9105 :                         *pulReturnLth = zstrlen( (zPCHAR) lpVariable );

	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], eax
$LN25@fnGetVaria:

; 9106 :                   }
; 9107 :                }

	jmp	SHORT $LN23@fnGetVaria
$LN22@fnGetVaria:

; 9108 :                else
; 9109 :                {
; 9110 :                   LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$6[ebp], eax

; 9111 :                   // "KZOEE363 - Context Edit string is invalid "
; 9112 :                   fnIssueCoreError( lpTask, lpView, 8, 363, 0,

	push	1
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	call	_TrueName@8
	push	eax
	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	push	0
	push	363					; 0000016bH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$6[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9113 :                                     lpDomain->szName,
; 9114 :                                     TrueName( cpcContextName, zSHOW_ZKEY ));
; 9115 :                   nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN23@fnGetVaria:

; 9116 :                }
; 9117 :             }

	jmp	SHORT $LN21@fnGetVaria
$LN20@fnGetVaria:

; 9118 :             else
; 9119 :             {
; 9120 :                LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$5[ebp], eax

; 9121 :                // "KZOEE350 - Context Not Valid for Domain"
; 9122 :                fnIssueCoreError( lpTask, lpView, 8, 350, 0, lpDomain->szName,

	push	1
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	call	_TrueName@8
	push	eax
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	push	0
	push	350					; 0000015eH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$5[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9123 :                                  TrueName( cpcContextName, zSHOW_ZKEY ));
; 9124 :                nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN21@fnGetVaria:

; 9125 :             }
; 9126 :          }

	jmp	$LN19@fnGetVaria
$LN18@fnGetVaria:

; 9127 :          else
; 9128 :          if ( cVariableType != zTYPE_STRING )

	movsx	ecx, BYTE PTR _cVariableType$[ebp]
	cmp	ecx, 83					; 00000053H
	je	$LN27@fnGetVaria

; 9129 :          {
; 9130 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$4[ebp], eax

; 9131 :             zCHAR sz1[ 100 ];
; 9132 :             zCHAR sz2[ 100 ];
; 9133 : 
; 9134 :             zstrcpy( sz1, "Type: " );

	push	OFFSET $SG17918
	lea	ecx, DWORD PTR _sz1$15[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 9135 :             sz1[ 6 ] = cVariableType;

	mov	edx, 1
	imul	eax, edx, 6
	mov	cl, BYTE PTR _cVariableType$[ebp]
	mov	BYTE PTR _sz1$15[ebp+eax], cl

; 9136 :             sz1[ 7 ] = 0;

	mov	edx, 1
	imul	eax, edx, 7
	mov	DWORD PTR $T10[ebp], eax
	cmp	DWORD PTR $T10[ebp], 100		; 00000064H
	jae	SHORT $LN54@fnGetVaria
	jmp	SHORT $LN55@fnGetVaria
$LN54@fnGetVaria:
	call	___report_rangecheckfailure
$LN55@fnGetVaria:
	mov	ecx, DWORD PTR $T10[ebp]
	mov	BYTE PTR _sz1$15[ebp+ecx], 0

; 9137 :             zstrcat( sz1, ", Domain: " );

	push	OFFSET $SG17919
	lea	edx, DWORD PTR _sz1$15[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 9138 :             zstrcat( sz1, lpDomain->szName );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _sz1$15[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 9139 :             zstrcpy( sz2, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _sz2$14[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 9140 :             zstrcpy( sz2, ", " );

	push	OFFSET $SG17920
	lea	ecx, DWORD PTR _sz2$14[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 9141 :             zstrcpy( sz2, lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz2$14[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 9142 :             // "KZOEE362 - Variable Type not allowed for this Domain Type "
; 9143 :             fnIssueCoreError( lpTask, lpView, 8, 362, 0, sz1, sz2 );

	lea	ecx, DWORD PTR _sz2$14[ebp]
	push	ecx
	lea	edx, DWORD PTR _sz1$15[ebp]
	push	edx
	push	0
	push	362					; 0000016aH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$4[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9144 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 9145 :          }

	jmp	$LN19@fnGetVaria
$LN27@fnGetVaria:

; 9146 :          else
; 9147 :          {
; 9148 :             nRC = fnGetStringFromAttribute( (zPCHAR) lpVariable,

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _ulVariableLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 9149 :                                             ulVariableLth,
; 9150 :                                             lpView, lpViewEntityCsr,
; 9151 :                                             lpViewAttrib, 0 );
; 9152 :             switch ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv266[ebp], edx
	cmp	DWORD PTR tv266[ebp], 0
	je	SHORT $LN29@fnGetVaria
	jmp	$LN4@fnGetVaria
$LN29@fnGetVaria:

; 9153 :             {
; 9154 :                case 0:
; 9155 :                {
; 9156 :                   zLPCONTEXT lpContext = fnGetContext( lpDomain, cpcContextName );

	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpContext$9[ebp], eax

; 9157 :                   if ( lpContext )

	cmp	DWORD PTR _lpContext$9[ebp], 0
	je	$LN30@fnGetVaria

; 9158 :                   {
; 9159 :                      if ( UfFormatString( (zPCHAR) lpVariable,

	mov	edx, DWORD PTR _lpContext$9[ebp]
	mov	eax, DWORD PTR [edx+59]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	call	_UfFormatString@8
	movsx	edx, ax
	test	edx, edx
	je	$LN32@fnGetVaria

; 9160 :                                           zGETPTR( lpContext->hEditString ) ) )
; 9161 :                      {
; 9162 :                         LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 9163 :                         zCHAR sz1[ 66 ];
; 9164 :                         zCHAR sz2[ 66 ];
; 9165 : 
; 9166 :                         zstrcpy( sz1, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _sz1$16[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 9167 :                         zstrcat( sz1, "/" );

	push	OFFSET $SG17925
	lea	ecx, DWORD PTR _sz1$16[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 9168 :                         zstrcat( sz1, lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz1$16[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 9169 :                         zstrcpy( sz2, lpDomain->szName );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 6
	push	ecx
	lea	edx, DWORD PTR _sz2$17[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 9170 :                         zstrcat( sz2, "/" );

	push	OFFSET $SG17926
	lea	eax, DWORD PTR _sz2$17[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 9171 :                         zstrcat( sz2, TrueName( cpcContextName, 0 ) );

	push	0
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	call	_TrueName@8
	push	eax
	lea	edx, DWORD PTR _sz2$17[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 9172 :                         // "KZOEE361 - Could not process variable
; 9173 :                         //  with Context Format "
; 9174 :                         fnIssueCoreError( lpTask, lpView, 8, 361, 0, sz1, sz2 );

	lea	eax, DWORD PTR _sz2$17[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz1$16[ebp]
	push	ecx
	push	0
	push	361					; 00000169H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$3[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9175 :                         nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN32@fnGetVaria:

; 9176 :                      }
; 9177 :                   }

	jmp	SHORT $LN4@fnGetVaria
$LN30@fnGetVaria:

; 9178 :                   else
; 9179 :                   {
; 9180 :                      LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 9181 :                      // "KZOEE350 - Context Not Valid for Domain"
; 9182 :                      fnIssueCoreError( lpTask, lpView, 8, 350, 0, lpDomain->szName,

	push	1
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	call	_TrueName@8
	push	eax
	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	push	0
	push	350					; 0000015eH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9183 :                                        TrueName( cpcContextName, zSHOW_ZKEY ));
; 9184 :                      nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN4@fnGetVaria:

; 9185 :                   }
; 9186 : 
; 9187 :                   break;
; 9188 :                }
; 9189 : 
; 9190 :                case -1:
; 9191 :                   break;
; 9192 : 
; 9193 :             } // end switch ( nRC )
; 9194 : 
; 9195 :             if ( pulReturnLth )

	cmp	DWORD PTR _pulReturnLth$[ebp], 0
	je	SHORT $LN19@fnGetVaria

; 9196 :             {
; 9197 :                if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN35@fnGetVaria

; 9198 :                   *pulReturnLth = zstrlen( (zPCHAR) lpVariable );

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN19@fnGetVaria
$LN35@fnGetVaria:

; 9199 :                else
; 9200 :                   *pulReturnLth = 0;

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 0
$LN19@fnGetVaria:

; 9201 :             }
; 9202 :          }
; 9203 : 
; 9204 :          break;

	jmp	$LN2@fnGetVaria
$LN37@fnGetVaria:

; 9205 : 
; 9206 :       case zDM_TYPE_EXPRESSION:
; 9207 :       case zDM_TYPE_ALGORITHM:
; 9208 :          nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	mov	ecx, DWORD PTR _ulVariableLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _cVariableType$[ebp]
	push	ecx
	push	2
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 9209 :                                  zDME_GET_VARIABLE,
; 9210 :                                  cVariableType,
; 9211 :                                  lpVariable,
; 9212 :                                  cpcContextName,
; 9213 :                                  lpView,
; 9214 :                                  lpViewEntity,
; 9215 :                                  lpViewAttrib,
; 9216 :                                  ulVariableLth );
; 9217 : 
; 9218 :          if ( nRC == 0 && cVariableType == zTYPE_STRING && pulReturnLth )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN38@fnGetVaria
	movsx	edx, BYTE PTR _cVariableType$[ebp]
	cmp	edx, 83					; 00000053H
	jne	SHORT $LN38@fnGetVaria
	cmp	DWORD PTR _pulReturnLth$[ebp], 0
	je	SHORT $LN38@fnGetVaria

; 9219 :             *pulReturnLth = zstrlen( (zPCHAR) lpVariable );

	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN39@fnGetVaria
$LN38@fnGetVaria:

; 9220 :          else
; 9221 :          if ( nRC == zDME_NOT_HANDLED )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -10				; fffffff6H
	jne	SHORT $LN39@fnGetVaria

; 9222 :          {
; 9223 :             zCHAR szMsg[ 500 ];
; 9224 : 
; 9225 :             zsprintf( szMsg, "Operation '%s' does not handle an Entry "

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	push	2
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	push	OFFSET $SG17935
	lea	edx, DWORD PTR _szMsg$13[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 9226 :                       "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 9227 :                       zDME_GET_VARIABLE, lpDomain->szName );
; 9228 :             MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	eax, DWORD PTR _szMsg$13[ebp]
	push	eax
	push	OFFSET $SG17936
	push	OFFSET $SG17937
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MessageSend@24

; 9229 :                          szMsg, zMSGQ_DOMAIN_ERROR, 0 );
; 9230 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN53@fnGetVaria
$LN39@fnGetVaria:

; 9231 :          }
; 9232 : 
; 9233 :          break;

	jmp	$LN2@fnGetVaria
$LN41@fnGetVaria:

; 9234 : 
; 9235 :       default:
; 9236 :       {
; 9237 :          if ( cVariableType == zTYPE_STRING && lpViewAttrib->cType == zTYPE_BLOB )

	movsx	edx, BYTE PTR _cVariableType$[ebp]
	cmp	edx, 83					; 00000053H
	jne	SHORT $LN42@fnGetVaria
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN42@fnGetVaria

; 9238 :          {
; 9239 :             cVariableType = zTYPE_BLOB;  // dks 2007.01.11  permit blob to be set from string

	mov	BYTE PTR _cVariableType$[ebp], 66	; 00000042H

; 9240 :             if ( ulVariableLth == 0 )

	cmp	DWORD PTR _ulVariableLth$[ebp], 0
	jne	SHORT $LN42@fnGetVaria

; 9241 :                ulVariableLth = zstrlen( (zPCHAR) lpVariable );

	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulVariableLth$[ebp], eax
$LN42@fnGetVaria:

; 9242 :          }
; 9243 : 
; 9244 :          // do it without a domain...
; 9245 :          switch ( cVariableType )

	movsx	eax, BYTE PTR _cVariableType$[ebp]
	mov	DWORD PTR tv369[ebp], eax
	mov	ecx, DWORD PTR tv369[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv369[ebp], ecx
	cmp	DWORD PTR tv369[ebp], 17		; 00000011H
	ja	$LN52@fnGetVaria
	mov	edx, DWORD PTR tv369[ebp]
	movzx	eax, BYTE PTR $LN59@fnGetVaria[edx]
	jmp	DWORD PTR $LN61@fnGetVaria[eax*4]
$LN44@fnGetVaria:

; 9246 :          {
; 9247 :             case zTYPE_STRING:
; 9248 :                nRC = fnGetStringFromAttribute( (zPCHAR) lpVariable, ulVariableLth,

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulVariableLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 9249 :                                                lpView, lpViewEntityCsr,
; 9250 :                                                lpViewAttrib,
; 9251 :                                                cpcContextName );
; 9252 :                if ( pulReturnLth )

	cmp	DWORD PTR _pulReturnLth$[ebp], 0
	je	SHORT $LN45@fnGetVaria

; 9253 :                {
; 9254 :                   if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN46@fnGetVaria

; 9255 :                      *pulReturnLth = zstrlen( (zPCHAR) lpVariable );

	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN45@fnGetVaria
$LN46@fnGetVaria:

; 9256 :                   else
; 9257 :                      *pulReturnLth = 0;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], 0
$LN45@fnGetVaria:

; 9258 :                }
; 9259 : 
; 9260 :                break;

	jmp	$LN2@fnGetVaria
$LN48@fnGetVaria:

; 9261 : 
; 9262 :             case zTYPE_BLOB:
; 9263 :                *pulReturnLth = ulVariableLth;   // set max size for next call below

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	ecx, DWORD PTR _ulVariableLth$[ebp]
	mov	DWORD PTR [eax], ecx

; 9264 :                nRC = fnGetBlobFromAttribute( lpVariable, pulReturnLth,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	call	_fnGetBlobFromAttribute
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 9265 :                                              lpView, lpViewEntityCsr,
; 9266 :                                              lpViewAttrib );
; 9267 :                break;

	jmp	$LN2@fnGetVaria
$LN49@fnGetVaria:

; 9268 : 
; 9269 :             case zTYPE_INTEGER:
; 9270 :                plInteger = (zPLONG) lpVariable;

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _plInteger$[ebp], ecx

; 9271 :                nRC = fnGetIntegerFromAttribute( plInteger,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _plInteger$[ebp]
	push	edx
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 9272 :                                                 lpView, lpViewEntityCsr,
; 9273 :                                                 lpViewAttrib );
; 9274 :                break;

	jmp	$LN2@fnGetVaria
$LN50@fnGetVaria:

; 9275 : 
; 9276 :             case zTYPE_DECIMAL:
; 9277 :                pdDecimal = (zPDECIMAL) lpVariable;

	mov	eax, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _pdDecimal$[ebp], eax

; 9278 :                nRC = fnGetDecimalFromAttribute( pdDecimal,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdDecimal$[ebp]
	push	ecx
	call	_fnGetDecimalFromAttribute
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 9279 :                                                 lpView, lpViewEntityCsr,
; 9280 :                                                 lpViewAttrib );
; 9281 :                break;

	jmp	$LN2@fnGetVaria
$LN51@fnGetVaria:

; 9282 : 
; 9283 :             case zTYPE_PIC:
; 9284 :                nRC = fnGetAttributeLength( pulReturnLth, lpView,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	push	eax
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 9285 :                                            zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 9286 :                                            lpViewAttrib );
; 9287 :                break;

	jmp	SHORT $LN2@fnGetVaria
$LN52@fnGetVaria:

; 9288 : 
; 9289 :             default:
; 9290 :             {
; 9291 :                LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 9292 :                szTempStr[ 0 ] = cVariableType;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _cVariableType$[ebp]
	mov	BYTE PTR _szTempStr$[ebp+ecx], dl

; 9293 :                szTempStr[ 1 ] = '\x00';

	mov	DWORD PTR $T8[ebp], 1
	cmp	DWORD PTR $T8[ebp], 2
	jae	SHORT $LN56@fnGetVaria
	jmp	SHORT $LN57@fnGetVaria
$LN56@fnGetVaria:
	call	___report_rangecheckfailure
$LN57@fnGetVaria:
	mov	eax, DWORD PTR $T8[ebp]
	mov	BYTE PTR _szTempStr$[ebp+eax], 0

; 9294 :                // "KZOEE241 - Invalid Variable Type"
; 9295 :                fnIssueCoreError( lpTask, lpView, 8, 241, 0, szTempStr, 0 );

	push	0
	lea	ecx, DWORD PTR _szTempStr$[ebp]
	push	ecx
	push	0
	push	241					; 000000f1H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9296 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN53@fnGetVaria
$LN2@fnGetVaria:

; 9297 :             }
; 9298 :          }
; 9299 :       }
; 9300 :    }
; 9301 : 
; 9302 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN53@fnGetVaria:

; 9303 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN60@fnGetVaria:
	DD	$LN37@fnGetVaria
	DD	$LN17@fnGetVaria
	DD	$LN15@fnGetVaria
	DD	$LN41@fnGetVaria
$LN58@fnGetVaria:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	0
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
$LN61@fnGetVaria:
	DD	$LN48@fnGetVaria
	DD	$LN49@fnGetVaria
	DD	$LN50@fnGetVaria
	DD	$LN51@fnGetVaria
	DD	$LN44@fnGetVaria
	DD	$LN52@fnGetVaria
$LN59@fnGetVaria:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	4
_fnGetVariableFromAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pdDecimal$ = -1672					; size = 4
_plInteger$ = -1668					; size = 4
_lpTaskDomain$ = -1664					; size = 4
$T1 = -1660						; size = 4
tv267 = -1656						; size = 4
_ul$2 = -1652						; size = 4
$T3 = -1648						; size = 4
_hndl$4 = -1644						; size = 4
_lpContext$5 = -1640					; size = 4
tv314 = -1636						; size = 4
_lDomainEntryType$ = -1632				; size = 4
tv149 = -1628						; size = 4
_pch$6 = -1624						; size = 4
_szTempStr$ = -1620					; size = 2
_lpViewEntity$ = -1616					; size = 4
_lpDomain$ = -1612					; size = 4
_cDomainType$ = -1606					; size = 1
_bValidationOnly$ = -1605				; size = 1
_nRC$ = -1604						; size = 2
_sz$7 = -1600						; size = 256
_szMsg$8 = -1344					; size = 500
_szEntityName$9 = -844					; size = 255
_szAttribName$10 = -588					; size = 255
_sz2$11 = -332						; size = 100
_sz1$12 = -232						; size = 100
_sz1$13 = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lpVariable$ = 20					; size = 4
_cVariableType$ = 24					; size = 1
_ulVariableLth$ = 28					; size = 4
_cpcContextName$ = 32					; size = 4
_lpCurrentTask$ = 36					; size = 4
_nFlag$ = 40						; size = 2
_fnSetAttributeFromVariable PROC

; 7509 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1672				; 00000688H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 7510 :    LPVIEWENTITY      lpViewEntity;
; 7511 :    LPTASKDOMAIN      lpTaskDomain;
; 7512 :    LPDOMAIN          lpDomain;
; 7513 :    zCHAR             cDomainType;
; 7514 :    zCHAR             szTempStr[ 2 ];
; 7515 :    zPLONG            plInteger;
; 7516 :    zPDOUBLE          pdDecimal;
; 7517 :    zBOOL             bValidationOnly;
; 7518 :    zLONG             lDomainEntryType;
; 7519 :    zSHORT            nRC;
; 7520 : 
; 7521 :    // Get view Entity from cursor
; 7522 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7523 : 
; 7524 :    // If the attribute is marked as required and the input variable
; 7525 :    // type is a string, we do not allow a null pointer or a pointer
; 7526 :    // to a null string as input.
; 7527 :    if ( lpViewAttrib->bRequired &&
; 7528 :         cVariableType == zTYPE_STRING &&

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 4
	and	eax, 1
	je	$LN6@fnSetAttri
	movsx	ecx, BYTE PTR _cVariableType$[ebp]
	cmp	ecx, 83					; 00000053H
	jne	$LN6@fnSetAttri
	cmp	DWORD PTR _lpVariable$[ebp], 0
	je	SHORT $LN7@fnSetAttri
	mov	edx, DWORD PTR _lpVariable$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN6@fnSetAttri
$LN7@fnSetAttri:

; 7529 :         (lpVariable == 0 || *((zPCHAR) lpVariable) == 0) )
; 7530 :    {
; 7531 :       zCHAR  szEntityName[ 255 ];
; 7532 :       zCHAR  szAttribName[ 255 ];
; 7533 : 
; 7534 :       strcpy( szEntityName, "Entity:\t" );

	push	OFFSET $SG17250
	lea	ecx, DWORD PTR _szEntityName$9[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7535 :       strcat( szEntityName, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _szEntityName$9[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7536 : 
; 7537 :       strcpy( szAttribName, "Attribute:\t" );

	push	OFFSET $SG17251
	lea	ecx, DWORD PTR _szAttribName$10[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7538 :       strcat( szAttribName, lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szAttribName$10[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7539 : 
; 7540 :       // "KZOEE245 - Null string not allowed for a required attribute"
; 7541 :       IssueOE_Error( lpView, 8, 245,

	lea	ecx, DWORD PTR _szAttribName$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _szEntityName$9[ebp]
	push	edx
	push	0
	push	400					; 00000190H
	push	245					; 000000f5H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_IssueOE_Error@28

; 7542 :                      zMSGQ_REQUIRED_DATA_ITEM_ERROR,
; 7543 :                      0, szEntityName,
; 7544 :                      szAttribName );
; 7545 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSetAttri
$LN6@fnSetAttri:

; 7546 :    }
; 7547 : 
; 7548 :    // See if we are only doing validation.
; 7549 :    if ( nFlag & zVALIDATE )

	movsx	ecx, WORD PTR _nFlag$[ebp]
	and	ecx, 4
	je	SHORT $LN8@fnSetAttri

; 7550 :    {
; 7551 :       bValidationOnly = TRUE;

	mov	BYTE PTR _bValidationOnly$[ebp], 1

; 7552 :       lDomainEntryType = (zLONG) zDME_VALIDATE_LPDATA;

	mov	DWORD PTR _lDomainEntryType$[ebp], 10	; 0000000aH

; 7553 :    }

	jmp	SHORT $LN9@fnSetAttri
$LN8@fnSetAttri:

; 7554 :    else
; 7555 :    {
; 7556 :       bValidationOnly = FALSE;

	mov	BYTE PTR _bValidationOnly$[ebp], 0

; 7557 :       lDomainEntryType = (zLONG) zDME_SET_ATTRIBUTE;

	mov	DWORD PTR _lDomainEntryType$[ebp], 1
$LN9@fnSetAttri:

; 7558 :    }
; 7559 : 
; 7560 :    // If the input type is string and if the value is null, then we
; 7561 :    // want to call fnSetAttributeFromString with the null value, which
; 7562 :    // will set the attribute to null, without going through the Domain.
; 7563 :    // Note that we have already gone through the validation to check
; 7564 :    // whether or not the attribute can be set to null, so if we have
; 7565 :    // gotton this far, it is ok.
; 7566 :    // To force the call to fnSetAttributeFromString, we only need to set
; 7567 :    // the variable cDomainType to 0. This causes the CASE structure
; 7568 :    // below to drop through to the default, which will call the operation.
; 7569 : 
; 7570 :    if ( cVariableType == zTYPE_STRING &&

	movsx	edx, BYTE PTR _cVariableType$[ebp]
	cmp	edx, 83					; 00000053H
	jne	SHORT $LN10@fnSetAttri
	cmp	DWORD PTR _lpVariable$[ebp], 0
	je	SHORT $LN12@fnSetAttri
	mov	eax, DWORD PTR _lpVariable$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN10@fnSetAttri
$LN12@fnSetAttri:

; 7571 :         (lpVariable == 0 || *((zPCHAR) lpVariable) == 0) )
; 7572 :    {
; 7573 :       cDomainType = 0;

	mov	BYTE PTR _cDomainType$[ebp], 0

; 7574 :    }

	jmp	SHORT $LN11@fnSetAttri
$LN10@fnSetAttri:

; 7575 :    else
; 7576 :    {
; 7577 :       lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 7578 :       cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 7579 :                                                 lpCurrentTask,
; 7580 :                                                 lpDomain );
; 7581 : 
; 7582 :       if ( cDomainType && cDomainType == zDM_TYPE_FORMAT &&

	movsx	edx, BYTE PTR _cDomainType$[ebp]
	test	edx, edx
	je	SHORT $LN11@fnSetAttri
	movsx	eax, BYTE PTR _cDomainType$[ebp]
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN11@fnSetAttri
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN14@fnSetAttri
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN11@fnSetAttri
$LN14@fnSetAttri:

; 7583 :            (cpcContextName == 0 || *cpcContextName == 0) )
; 7584 :       {
; 7585 :          cDomainType = 0;

	mov	BYTE PTR _cDomainType$[ebp], 0
$LN11@fnSetAttri:

; 7586 :       }
; 7587 :    }
; 7588 : 
; 7589 :    switch ( cDomainType )

	movsx	eax, BYTE PTR _cDomainType$[ebp]
	mov	DWORD PTR tv149[ebp], eax
	mov	ecx, DWORD PTR tv149[ebp]
	sub	ecx, 65					; 00000041H
	mov	DWORD PTR tv149[ebp], ecx
	cmp	DWORD PTR tv149[ebp], 19		; 00000013H
	ja	$LN30@fnSetAttri
	mov	edx, DWORD PTR tv149[ebp]
	movzx	eax, BYTE PTR $LN53@fnSetAttri[edx]
	jmp	DWORD PTR $LN55@fnSetAttri[eax*4]
$LN15@fnSetAttri:

; 7590 :    {
; 7591 :       case zDM_TYPE_TABLE:
; 7592 :          nRC = Table_Handler( lDomainEntryType,

	push	0
	mov	ecx, DWORD PTR _ulVariableLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _cVariableType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lDomainEntryType$[ebp]
	push	edx
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 7593 :                               cVariableType,
; 7594 :                               (zPVOID) lpVariable,
; 7595 :                               cpcContextName,
; 7596 :                               lpView,
; 7597 :                               lpViewEntity,
; 7598 :                               lpViewAttrib,
; 7599 :                               ulVariableLth,
; 7600 :                               (zPVOID) 0 );
; 7601 :          break;

	jmp	$LN2@fnSetAttri
$LN16@fnSetAttri:

; 7602 : 
; 7603 :       case zDM_TYPE_FORMAT:
; 7604 :          if ( cVariableType != zTYPE_STRING )

	movsx	eax, BYTE PTR _cVariableType$[ebp]
	cmp	eax, 83					; 00000053H
	je	$LN17@fnSetAttri

; 7605 :          {
; 7606 :             zCHAR sz1[ 100 ];
; 7607 :             zCHAR sz2[ 100 ];
; 7608 : 
; 7609 :             zstrcpy( sz1, "Type: " );

	push	OFFSET $SG17263
	lea	ecx, DWORD PTR _sz1$12[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7610 :             sz1[ 6 ] = cVariableType;

	mov	edx, 1
	imul	eax, edx, 6
	mov	cl, BYTE PTR _cVariableType$[ebp]
	mov	BYTE PTR _sz1$12[ebp+eax], cl

; 7611 :             sz1[ 7 ] = 0;

	mov	edx, 1
	imul	eax, edx, 7
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 100			; 00000064H
	jae	SHORT $LN47@fnSetAttri
	jmp	SHORT $LN48@fnSetAttri
$LN47@fnSetAttri:
	call	___report_rangecheckfailure
$LN48@fnSetAttri:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _sz1$12[ebp+ecx], 0

; 7612 :             zstrcat( sz1, ", Domain: " );

	push	OFFSET $SG17264
	lea	edx, DWORD PTR _sz1$12[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 7613 :             zstrcat( sz1, lpDomain->szName );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _sz1$12[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 7614 :             zstrcpy( sz2, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _sz2$11[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7615 :             zstrcpy( sz2, ", " );

	push	OFFSET $SG17265
	lea	ecx, DWORD PTR _sz2$11[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7616 :             zstrcpy( sz2, lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz2$11[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7617 :             // "KZOEE362 - Variable Type not allowed for this Domain Type "
; 7618 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 362, 0, sz1, sz2 );

	lea	ecx, DWORD PTR _sz2$11[ebp]
	push	ecx
	lea	edx, DWORD PTR _sz1$12[ebp]
	push	edx
	push	0
	push	362					; 0000016aH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 7619 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 7620 :          }

	jmp	$LN18@fnSetAttri
$LN17@fnSetAttri:

; 7621 :          else
; 7622 :          {
; 7623 :             zLPCONTEXT   lpContext;
; 7624 : 
; 7625 :             lpContext = fnGetContext( lpDomain, cpcContextName );

	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpContext$5[ebp], eax

; 7626 : 
; 7627 :             if ( lpContext == 0 )

	cmp	DWORD PTR _lpContext$5[ebp], 0
	jne	SHORT $LN19@fnSetAttri

; 7628 :             {
; 7629 :                // "KZOEE350 - Context Not Valid for Domain"
; 7630 :                fnIssueCoreError( lpCurrentTask, lpView, 8, 350, 0,

	push	1
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	call	_TrueName@8
	push	eax
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	push	0
	push	350					; 0000015eH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 7631 :                                  lpDomain->szName,
; 7632 :                                  TrueName( cpcContextName, zSHOW_ZKEY ));
; 7633 :                nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 7634 :             }

	jmp	$LN18@fnSetAttri
$LN19@fnSetAttri:

; 7635 :             else
; 7636 :             {
; 7637 :                zCHAR    sz[ 256 ];
; 7638 :                zPCHAR   pch;
; 7639 :                zPVOID   hndl = 0;

	mov	DWORD PTR _hndl$4[ebp], 0

; 7640 :                zULONG   ul;
; 7641 : 
; 7642 :                ul = zstrlen( (zPCHAR) lpVariable ) + 1;

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _ul$2[ebp], eax

; 7643 :                if ( ul > sizeof( sz ) )

	cmp	DWORD PTR _ul$2[ebp], 256		; 00000100H
	jbe	SHORT $LN21@fnSetAttri

; 7644 :                {
; 7645 :                   hndl = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10102					; 00002776H
	push	0
	push	0
	mov	edx, DWORD PTR _ul$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$4[ebp], eax

; 7646 :                                            ul, 0, 0, iAttributeString );
; 7647 :                   pch = zGETPTR( hndl );

	mov	edx, DWORD PTR _hndl$4[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pch$6[ebp], eax

; 7648 :                }

	jmp	SHORT $LN22@fnSetAttri
$LN21@fnSetAttri:

; 7649 :                else
; 7650 :                   pch = sz;

	lea	eax, DWORD PTR _sz$7[ebp]
	mov	DWORD PTR _pch$6[ebp], eax
$LN22@fnSetAttri:

; 7651 : 
; 7652 :                zstrcpy( pch, (zPCHAR) lpVariable );

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$6[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7653 :                nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 7654 :                if ( UfEditFormatString( pch, zGETPTR( lpContext->hEditString ) ) )

	mov	ecx, DWORD PTR _lpContext$5[ebp]
	mov	edx, DWORD PTR [ecx+59]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _pch$6[ebp]
	push	eax
	call	_UfEditFormatString@8
	movsx	ecx, ax
	test	ecx, ecx
	je	$LN23@fnSetAttri

; 7655 :                {
; 7656 :                   zCHAR sz1[ 128 ];
; 7657 : 
; 7658 :                   zstrcpy( sz1, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _sz1$13[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7659 :                   zstrcat( sz1, "." );

	push	OFFSET $SG17271
	lea	ecx, DWORD PTR _sz1$13[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 7660 :                   zstrcat( sz1, lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz1$13[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7661 :                   zstrcat( sz1, "." );

	push	OFFSET $SG17272
	lea	ecx, DWORD PTR _sz1$13[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 7662 :                   zstrcpy( sz1, lpDomain->szName );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	lea	eax, DWORD PTR _sz1$13[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7663 :                   zstrcat( sz1, "." );

	push	OFFSET $SG17273
	lea	ecx, DWORD PTR _sz1$13[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 7664 :                   zstrcat( sz1, TrueName( cpcContextName, 0 ) );

	push	0
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	call	_TrueName@8
	push	eax
	lea	eax, DWORD PTR _sz1$13[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7665 :               // KJS 06/26/09 - We were calling IssueOE_Error but the error sent
; 7666 :               // to the user is too detailed.  We think this error should be more like
; 7667 :               // the domain errors.  So instead we will issue the MessageSend here.
; 7668 :                   TraceLineS( sz1, "" );

	push	OFFSET $SG17274
	lea	ecx, DWORD PTR _sz1$13[ebp]
	push	ecx
	call	_TraceLineS@8

; 7669 :                   // "KZOEE361 - Invalid data Format
; 7670 :                // IssueOE_Error( lpView, 4, 361, 0, 0,
; 7671 :                //                zGETPTR( lpContext->hEditString ),
; 7672 :                //                sz1 );
; 7673 :                   zstrcpy( sz1, "Invalid data format.  Your data should be in the format: " );

	push	OFFSET $SG17275
	lea	edx, DWORD PTR _sz1$13[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7674 :                   zstrcat( sz1, zGETPTR( lpContext->hEditString ) );

	mov	eax, DWORD PTR _lpContext$5[ebp]
	mov	ecx, DWORD PTR [eax+59]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	lea	edx, DWORD PTR _sz1$13[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 7675 : 
; 7676 :                   //return( MessageSend( zView, szMsgID, pchTitle, szMsg, lMsgType, 0 ) );
; 7677 :                   MessageSend( lpView, "361",

	push	0
	push	4
	lea	eax, DWORD PTR _sz1$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlApplicationLogicError
	push	ecx
	push	OFFSET $SG17276
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MessageSend@24

; 7678 :                                szlApplicationLogicError,
; 7679 :                                sz1, 4, 0 );
; 7680 :                   nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN23@fnSetAttri:

; 7681 :                }
; 7682 : 
; 7683 :                if ( bValidationOnly )

	movzx	ecx, BYTE PTR _bValidationOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LN24@fnSetAttri

; 7684 :                   nRC = (nRC == 0) ? 0 : nRC;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN49@fnSetAttri
	mov	DWORD PTR tv267[ebp], 0
	jmp	SHORT $LN50@fnSetAttri
$LN49@fnSetAttri:
	movsx	eax, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv267[ebp], eax
$LN50@fnSetAttri:
	mov	cx, WORD PTR tv267[ebp]
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN25@fnSetAttri
$LN24@fnSetAttri:

; 7685 :                else
; 7686 :                {
; 7687 :                   if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN25@fnSetAttri

; 7688 :                      nRC = fnSetAttributeFromString( lpView, lpViewEntityCsr,

	push	0
	mov	eax, DWORD PTR _pch$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN25@fnSetAttri:

; 7689 :                                                      lpViewAttrib, pch, 0 );
; 7690 :                }
; 7691 : 
; 7692 :                if ( hndl )

	cmp	DWORD PTR _hndl$4[ebp], 0
	je	SHORT $LN18@fnSetAttri

; 7693 :                   fnFreeDataspace( pch );

	mov	ecx, DWORD PTR _pch$6[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
$LN18@fnSetAttri:

; 7694 :             }
; 7695 :          }
; 7696 : 
; 7697 :          break;

	jmp	$LN2@fnSetAttri
$LN28@fnSetAttri:

; 7698 : 
; 7699 :       case zDM_TYPE_EXPRESSION:
; 7700 :       case zDM_TYPE_ALGORITHM:
; 7701 :          nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	mov	edx, DWORD PTR _ulVariableLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _cVariableType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lDomainEntryType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 7702 :                                  lDomainEntryType,
; 7703 :                                  cVariableType,
; 7704 :                                  (zPVOID) lpVariable,
; 7705 :                                  cpcContextName,
; 7706 :                                  lpView,
; 7707 :                                  lpViewEntity,
; 7708 :                                  lpViewAttrib,
; 7709 :                                  ulVariableLth );
; 7710 :          if ( nRC == zDME_NOT_HANDLED )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -10				; fffffff6H
	jne	SHORT $LN29@fnSetAttri

; 7711 :          {
; 7712 :             zCHAR szMsg[ 500 ];
; 7713 : 
; 7714 :             zsprintf( szMsg, "Operation '%s' does not handle an Entry "

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _lDomainEntryType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET $SG17283
	lea	ecx, DWORD PTR _szMsg$8[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 7715 :                       "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 7716 :                       lDomainEntryType, lpDomain->szName );
; 7717 :             MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	edx, DWORD PTR _szMsg$8[ebp]
	push	edx
	push	OFFSET $SG17284
	push	OFFSET $SG17285
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MessageSend@24

; 7718 :                          szMsg, zMSGQ_DOMAIN_ERROR, 0 );
; 7719 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN46@fnSetAttri
$LN29@fnSetAttri:

; 7720 :          }
; 7721 : 
; 7722 :          break;

	jmp	$LN2@fnSetAttri
$LN30@fnSetAttri:

; 7723 : 
; 7724 :       default:
; 7725 :       {
; 7726 :          if ( cVariableType == zTYPE_STRING && lpViewAttrib->cType == zTYPE_BLOB )

	movsx	ecx, BYTE PTR _cVariableType$[ebp]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN31@fnSetAttri
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN31@fnSetAttri

; 7727 :          {
; 7728 :             cVariableType = zTYPE_BLOB;  // dks 2007.01.11  permit blob to be set from string

	mov	BYTE PTR _cVariableType$[ebp], 66	; 00000042H

; 7729 :             ulVariableLth = zstrlen( (zPCHAR) lpVariable ) + 1;

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _ulVariableLth$[ebp], eax
$LN31@fnSetAttri:

; 7730 :          }
; 7731 : 
; 7732 :          // do it without a domain ...
; 7733 :          switch ( cVariableType )

	movsx	edx, BYTE PTR _cVariableType$[ebp]
	mov	DWORD PTR tv314[ebp], edx
	mov	eax, DWORD PTR tv314[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv314[ebp], eax
	cmp	DWORD PTR tv314[ebp], 17		; 00000011H
	ja	$LN44@fnSetAttri
	mov	ecx, DWORD PTR tv314[ebp]
	movzx	edx, BYTE PTR $LN54@fnSetAttri[ecx]
	jmp	DWORD PTR $LN56@fnSetAttri[edx*4]
$LN32@fnSetAttri:

; 7734 :          {
; 7735 :             case zTYPE_STRING:
; 7736 :                if ( bValidationOnly )

	movzx	eax, BYTE PTR _bValidationOnly$[ebp]
	test	eax, eax
	je	SHORT $LN33@fnSetAttri

; 7737 :                   nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN34@fnSetAttri
$LN33@fnSetAttri:

; 7738 :                else
; 7739 :                   nRC = fnSetAttributeFromString( lpView, lpViewEntityCsr,

	push	0
	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN34@fnSetAttri:

; 7740 :                                                   lpViewAttrib,
; 7741 :                                                   (zPCHAR) lpVariable, 0 );
; 7742 :                break;

	jmp	$LN2@fnSetAttri
$LN35@fnSetAttri:

; 7743 : 
; 7744 :             case zTYPE_BLOB:
; 7745 :                if ( bValidationOnly )

	movzx	eax, BYTE PTR _bValidationOnly$[ebp]
	test	eax, eax
	je	SHORT $LN36@fnSetAttri

; 7746 :                   nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN37@fnSetAttri
$LN36@fnSetAttri:

; 7747 :                else
; 7748 :                   nRC = fnSetAttributeFromBlob( lpView, lpViewEntityCsr,

	mov	edx, DWORD PTR _ulVariableLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN37@fnSetAttri:

; 7749 :                                                 lpViewAttrib,
; 7750 :                                                 (zPVOID) lpVariable,
; 7751 :                                                 ulVariableLth );
; 7752 :                break;

	jmp	$LN2@fnSetAttri
$LN38@fnSetAttri:

; 7753 : 
; 7754 :             case zTYPE_INTEGER:
; 7755 :                if ( bValidationOnly )

	movzx	ecx, BYTE PTR _bValidationOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LN39@fnSetAttri

; 7756 :                   nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN40@fnSetAttri
$LN39@fnSetAttri:

; 7757 :                else
; 7758 :                {
; 7759 :                   plInteger = (zPLONG) lpVariable;

	mov	eax, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _plInteger$[ebp], eax

; 7760 :                   nRC = fnSetAttributeFromInteger( lpView,

	mov	ecx, DWORD PTR _plInteger$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromInteger
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax
$LN40@fnSetAttri:

; 7761 :                                                    lpViewEntityCsr,
; 7762 :                                                    lpViewAttrib,
; 7763 :                                                    *plInteger );
; 7764 :                }
; 7765 : 
; 7766 :                break;

	jmp	$LN2@fnSetAttri
$LN41@fnSetAttri:

; 7767 : 
; 7768 :             case zTYPE_DECIMAL:
; 7769 :                if ( bValidationOnly )

	movzx	eax, BYTE PTR _bValidationOnly$[ebp]
	test	eax, eax
	je	SHORT $LN42@fnSetAttri

; 7770 :                   nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN43@fnSetAttri
$LN42@fnSetAttri:

; 7771 :                else
; 7772 :                {
; 7773 :                   pdDecimal = (zPDECIMAL) lpVariable;

	mov	edx, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _pdDecimal$[ebp], edx

; 7774 :                   nRC = fnSetAttributeFromDecimal( zGETPTR( lpView->hTask ),

	mov	esi, DWORD PTR _pdDecimal$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSetAttributeFromDecimal
	add	esp, 52					; 00000034H
	mov	WORD PTR _nRC$[ebp], ax
$LN43@fnSetAttri:

; 7775 :                                                    lpViewEntityCsr,
; 7776 :                                                    lpViewAttrib,
; 7777 :                                                    *pdDecimal );
; 7778 :                }
; 7779 : 
; 7780 :                break;

	jmp	SHORT $LN2@fnSetAttri
$LN44@fnSetAttri:

; 7781 : 
; 7782 :             default:
; 7783 :                szTempStr[ 0 ] = cVariableType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _cVariableType$[ebp]
	mov	BYTE PTR _szTempStr$[ebp+edx], al

; 7784 :                szTempStr[ 1 ] = '\x00';

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 2
	jae	SHORT $LN51@fnSetAttri
	jmp	SHORT $LN52@fnSetAttri
$LN51@fnSetAttri:
	call	___report_rangecheckfailure
$LN52@fnSetAttri:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szTempStr$[ebp+ecx], 0

; 7785 :                // "KZOEE241 - Invalid Variable Type"
; 7786 :                fnIssueCoreError( lpCurrentTask, lpView, 8, 241, 0, szTempStr, 0 );

	push	0
	lea	edx, DWORD PTR _szTempStr$[ebp]
	push	edx
	push	0
	push	241					; 000000f1H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 7787 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN46@fnSetAttri
$LN2@fnSetAttri:

; 7788 :          }
; 7789 :       }
; 7790 :    }
; 7791 : 
; 7792 :    // If there is an object operation for this attribute,
; 7793 :    // invoke it now...
; 7794 :    if ( nRC == 0 && bValidationOnly == FALSE &&

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN45@fnSetAttri
	movzx	eax, BYTE PTR _bValidationOnly$[ebp]
	test	eax, eax
	jne	SHORT $LN45@fnSetAttri
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN45@fnSetAttri

; 7795 :         lpViewAttrib->szDerivedOper[ 0 ] )
; 7796 :    {
; 7797 :       nRC = fnInvokeDerivedOperation( lpView, lpViewEntity, lpViewAttrib,

	push	1
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN45@fnSetAttri:

; 7798 :                                       lpCurrentTask, zDERIVED_SET );
; 7799 :    }
; 7800 : 
; 7801 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN46@fnSetAttri:

; 7802 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN55@fnSetAttri:
	DD	$LN28@fnSetAttri
	DD	$LN16@fnSetAttri
	DD	$LN15@fnSetAttri
	DD	$LN30@fnSetAttri
$LN53@fnSetAttri:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	0
	DB	1
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	2
$LN56@fnSetAttri:
	DD	$LN35@fnSetAttri
	DD	$LN38@fnSetAttri
	DD	$LN41@fnSetAttri
	DD	$LN32@fnSetAttri
	DD	$LN44@fnSetAttri
$LN54@fnSetAttri:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnSetAttributeFromVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpExternalP$1 = -16					; size = 4
_pchRecord$ = -12					; size = 4
_pchRecordString$2 = -8					; size = 4
_lpViewAttrib$ = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_lpEntityInstance$ = 12					; size = 4
_bPersist$ = 16						; size = 1
_fnDeleteAttributeRecord PROC

; 7250 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 7251 :    LPVIEWATTRIB lpViewAttrib;
; 7252 :    zPCHAR       pchRecord;
; 7253 : 
; 7254 :    if ( bPersist )

	movzx	eax, BYTE PTR _bPersist$[ebp]
	test	eax, eax
	je	SHORT $LN5@fnDeleteAt

; 7255 :    {
; 7256 :       // Drop the record *UNLESS* it has a previous version and the entity
; 7257 :       // is not updatable.  If it's not updatable then we never create
; 7258 :       // another record for temporal entities so skip dropping this one.
; 7259 :       // It will be dropped when the original EI is dropped.
; 7260 :       if ( lpEntityInstance->hPrevVsn && lpViewEntity->bUpdate == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN7@fnDeleteAt
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 2
	and	eax, 1
	jne	SHORT $LN7@fnDeleteAt

; 7261 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDeleteAt
$LN7@fnDeleteAt:

; 7262 : 
; 7263 :       pchRecord = zGETPTR( lpEntityInstance->hPersistRecord );  // dks 2006.09.18 error while cleaning up client OE

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 7264 :    }

	jmp	SHORT $LN6@fnDeleteAt
$LN5@fnDeleteAt:

; 7265 :    else
; 7266 :       pchRecord = zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN6@fnDeleteAt:

; 7267 : 
; 7268 :    if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN8@fnDeleteAt

; 7269 :       return( 0 ); // skip if record is null

	xor	eax, eax
	jmp	$LN1@fnDeleteAt
$LN8@fnDeleteAt:

; 7270 : 
; 7271 :    // Get first attribute.
; 7272 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnDeleteAt
$LN2@fnDeleteAt:

; 7274 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnDeleteAt:

; 7273 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnDeleteAt

; 7275 :    {
; 7276 :       zPCHAR    pchRecordString;
; 7277 :       zCOREMEM  lpExternalP;
; 7278 : 
; 7279 :       if ( (lpViewAttrib->cType == 'S' || lpViewAttrib->cType == 'B') &&

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	je	SHORT $LN10@fnDeleteAt
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN9@fnDeleteAt
$LN10@fnDeleteAt:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	movzx	eax, BYTE PTR _bPersist$[ebp]
	cmp	edx, eax
	jne	SHORT $LN9@fnDeleteAt

; 7280 :            (lpViewAttrib->bPersist == bPersist) )
; 7281 :       {
; 7282 :          pchRecordString = pchRecord + lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchRecordString$2[ebp], edx

; 7283 :          if ( pchRecordString[ 0 ] == (zCHAR) '\xff' ) // suballoc'd?

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchRecordString$2[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	SHORT $LN9@fnDeleteAt

; 7284 :          {
; 7285 :             pchRecordString[ 0 ] = (zCHAR) '\x00'; // clear suballoc flag

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchRecordString$2[ebp]
	mov	BYTE PTR [eax+edx], 0

; 7286 :             lpExternalP = (zCOREMEM) (pchRecordString + 1);

	mov	ecx, DWORD PTR _pchRecordString$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$1[ebp], ecx

; 7287 :             pchRecordString = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$1[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecordString$2[ebp], eax

; 7288 :             fnFreeDataspace( pchRecordString ); // free associated area

	mov	ecx, DWORD PTR _pchRecordString$2[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 7289 :             zmemset( lpExternalP, 0, 6 ); // clear ptr and lth

	push	6
	push	0
	mov	edx, DWORD PTR _lpExternalP$1[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN9@fnDeleteAt:

; 7290 :          }
; 7291 :       }
; 7292 :    }

	jmp	$LN2@fnDeleteAt
$LN3@fnDeleteAt:

; 7293 : 
; 7294 :    // Now free the record itself.
; 7295 :    fnFreeDataspace( pchRecord );

	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 7296 : 
; 7297 :    if ( bPersist )

	movzx	ecx, BYTE PTR _bPersist$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@fnDeleteAt

; 7298 :       lpEntityInstance->hPersistRecord = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+60], 0
	jmp	SHORT $LN13@fnDeleteAt
$LN12@fnDeleteAt:

; 7299 :    else
; 7300 :       lpEntityInstance->hNonPersistRecord = 0;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+64], 0
$LN13@fnDeleteAt:

; 7301 : 
; 7302 :    return( 0 );  // return success

	xor	eax, eax
$LN1@fnDeleteAt:

; 7303 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDeleteAttributeRecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pchNewExtString$ = -52					; size = 4
_pchRecordStringT$ = -48				; size = 4
_hNewRecord$ = -44					; size = 4
_lpExternalPS$ = -40					; size = 4
_pulLth$ = -36						; size = 4
_lpExternalPT$ = -32					; size = 4
_hndl$1 = -28						; size = 4
_pchRecordStringS$ = -24				; size = 4
tv129 = -20						; size = 4
tv92 = -16						; size = 4
_pchNewRecord$ = -12					; size = 4
_ulBytes$ = -8						; size = 4
_lpViewAttrib$ = -4					; size = 4
_lpAllocTask$ = 8					; size = 4
_lpSrcViewEntity$ = 12					; size = 4
_cpcSrcRecord$ = 16					; size = 4
_bPersist$ = 20						; size = 1
_fnCopyAttributeRecord PROC

; 7156 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 7157 :    zULONG         ulBytes;
; 7158 :    zPCHAR         pchNewRecord;
; 7159 :    zPVOID         hNewRecord;
; 7160 :    LPVIEWATTRIB   lpViewAttrib;
; 7161 :    zPCHAR         pchRecordStringS;
; 7162 :    zPCHAR         pchRecordStringT;
; 7163 :    zPCHAR         pchNewExtString;
; 7164 :    zCOREMEM       lpExternalPS;
; 7165 :    zCOREMEM       lpExternalPT;
; 7166 :    zPULONG        pulLth;
; 7167 : 
; 7168 :    // If record pointer is null, return null.
; 7169 :    if ( cpcSrcRecord == 0 )

	cmp	DWORD PTR _cpcSrcRecord$[ebp], 0
	jne	SHORT $LN7@fnCopyAttr

; 7170 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCopyAttr
$LN7@fnCopyAttr:

; 7171 : 
; 7172 :    // Get size of record to allocate
; 7173 :    if ( bPersist )

	movzx	eax, BYTE PTR _bPersist$[ebp]
	test	eax, eax
	je	SHORT $LN8@fnCopyAttr

; 7174 :       ulBytes = lpSrcViewEntity->ulRecordSize;

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+207]
	mov	DWORD PTR _ulBytes$[ebp], edx
	jmp	SHORT $LN9@fnCopyAttr
$LN8@fnCopyAttr:

; 7175 :    else
; 7176 :       ulBytes = lpSrcViewEntity->ulNonPersistSize;

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+211]
	mov	DWORD PTR _ulBytes$[ebp], ecx
$LN9@fnCopyAttr:

; 7177 : 
; 7178 :    hNewRecord = fnAllocDataspace( lpAllocTask->hFirstDataHeader,

	push	10100					; 00002774H
	push	0
	push	0
	mov	edx, DWORD PTR _ulBytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNewRecord$[ebp], eax

; 7179 :                                   ulBytes, 0, 0, iAttributeRecord );
; 7180 :    pchNewRecord = zGETPTR( hNewRecord );

	mov	edx, DWORD PTR _hNewRecord$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchNewRecord$[ebp], eax

; 7181 :    if ( pchNewRecord == 0 )

	cmp	DWORD PTR _pchNewRecord$[ebp], 0
	jne	SHORT $LN10@fnCopyAttr

; 7182 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCopyAttr
$LN10@fnCopyAttr:

; 7183 : 
; 7184 :    // Copy the old record to the new record.  This will cause all non
; 7185 :    // blob/string attributes to be copied.
; 7186 :    zmemcpy( pchNewRecord, cpcSrcRecord, ulBytes );

	mov	eax, DWORD PTR _ulBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchNewRecord$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7187 : 
; 7188 :    // Now that a new record has been created, go through all
; 7189 :    // the attributes and copy any external strings.
; 7190 :    for ( lpViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnCopyAttr
$LN2@fnCopyAttr:

; 7192 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnCopyAttr:

; 7191 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnCopyAttr

; 7193 :    {
; 7194 :       if ( !lpViewAttrib->bPersist == bPersist )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN17@fnCopyAttr
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN18@fnCopyAttr
$LN17@fnCopyAttr:
	mov	DWORD PTR tv92[ebp], 0
$LN18@fnCopyAttr:
	movzx	eax, BYTE PTR _bPersist$[ebp]
	cmp	DWORD PTR tv92[ebp], eax
	jne	SHORT $LN11@fnCopyAttr

; 7195 :          continue;

	jmp	SHORT $LN2@fnCopyAttr
$LN11@fnCopyAttr:

; 7196 : 
; 7197 :       switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv129[ebp], dl
	cmp	BYTE PTR tv129[ebp], 66			; 00000042H
	je	SHORT $LN12@fnCopyAttr
	cmp	BYTE PTR tv129[ebp], 83			; 00000053H
	je	SHORT $LN12@fnCopyAttr
	jmp	$LN5@fnCopyAttr
$LN12@fnCopyAttr:

; 7198 :       {
; 7199 :          case zTYPE_STRING:
; 7200 :          case zTYPE_BLOB:
; 7201 :             pchRecordStringS = (zPCHAR)

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _cpcSrcRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _pchRecordStringS$[ebp], ecx

; 7202 :                         (cpcSrcRecord + lpViewAttrib->ulRecordOffset);
; 7203 :             if ( pchRecordStringS[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecordStringS$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	$LN5@fnCopyAttr

; 7204 :             {
; 7205 :                zPVOID hndl;
; 7206 : 
; 7207 :                pchRecordStringT = (zPCHAR)

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _pchNewRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _pchRecordStringT$[ebp], ecx

; 7208 :                         (pchNewRecord + lpViewAttrib->ulRecordOffset);
; 7209 :                lpExternalPS = (zCOREMEM) (pchRecordStringS + 1);

	mov	edx, DWORD PTR _pchRecordStringS$[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalPS$[ebp], edx

; 7210 :                lpExternalPT = (zCOREMEM) (pchRecordStringT + 1);

	mov	eax, DWORD PTR _pchRecordStringT$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalPT$[ebp], eax

; 7211 :                pulLth = (zPULONG) (lpExternalPS + 1);

	mov	ecx, DWORD PTR _lpExternalPS$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pulLth$[ebp], ecx

; 7212 :                hndl = fnAllocDataspace( lpAllocTask->hFirstDataHeader,

	push	10102					; 00002776H
	push	0
	push	0
	mov	edx, DWORD PTR _pulLth$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$1[ebp], eax

; 7213 :                                         *pulLth, 0, 0, iAttributeString );
; 7214 :                *lpExternalPT = hndl;

	mov	eax, DWORD PTR _lpExternalPT$[ebp]
	mov	ecx, DWORD PTR _hndl$1[ebp]
	mov	DWORD PTR [eax], ecx

; 7215 :                pchNewExtString = zGETPTR( hndl );

	mov	edx, DWORD PTR _hndl$1[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchNewExtString$[ebp], eax

; 7216 :                if ( *lpExternalPT )

	mov	eax, DWORD PTR _lpExternalPT$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@fnCopyAttr

; 7217 :                {
; 7218 :                   zmemcpy( pchNewExtString,

	mov	ecx, DWORD PTR _pulLth$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpExternalPS$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _pchNewExtString$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN5@fnCopyAttr:

; 7219 :                            zGETPTR( *lpExternalPS ), (unsigned int) *pulLth );
; 7220 :                }
; 7221 :             }
; 7222 : 
; 7223 :             break;
; 7224 : 
; 7225 :          default:
; 7226 :             break;
; 7227 :       }
; 7228 :    }

	jmp	$LN2@fnCopyAttr
$LN3@fnCopyAttr:

; 7229 : 
; 7230 :    // return the new record created
; 7231 :    return( hNewRecord );

	mov	eax, DWORD PTR _hNewRecord$[ebp]
$LN1@fnCopyAttr:

; 7232 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCopyAttributeRecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_ulFreespaceLth$1 = -20					; size = 4
_hndl$2 = -16						; size = 4
_lpExternalP$ = -12					; size = 4
_pchExternal$ = -8					; size = 4
_pulLth$ = -4						; size = 4
_lpAllocTask$ = 8					; size = 4
_pchRecord$ = 12					; size = 4
_ulOffset$ = 16						; size = 4
_pBlob$ = 20						; size = 4
_ulBlobLth$ = 24					; size = 4
_fnStoreBlobInRecord PROC

; 6949 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 6950 :    zPULONG     pulLth;
; 6951 :    zCOREMEM    lpExternalP;
; 6952 :    zPCHAR      pchExternal;
; 6953 : 
; 6954 :    lpExternalP = (zCOREMEM) ((zPCHAR) pchRecord + ulOffset + 1);

	mov	eax, DWORD PTR _ulOffset$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _lpExternalP$[ebp], edx

; 6955 :    pulLth = (zPULONG) (lpExternalP + 1);

	mov	eax, DWORD PTR _lpExternalP$[ebp]
	add	eax, 4
	mov	DWORD PTR _pulLth$[ebp], eax

; 6956 :    if ( pchRecord[ ulOffset ] == (zCHAR) '\xff' )

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR _ulOffset$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, -1
	jne	SHORT $LN2@fnStoreBlo

; 6957 :    {
; 6958 :       zULONG ulFreespaceLth;
; 6959 : 
; 6960 :       pchExternal  = zGETPTR( *lpExternalP );

	mov	eax, DWORD PTR _lpExternalP$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchExternal$[ebp], eax

; 6961 :       ulFreespaceLth = fnGetDataspaceLength( pchExternal );

	mov	edx, DWORD PTR _pchExternal$[ebp]
	push	edx
	call	_fnGetDataspaceLength
	add	esp, 4
	mov	DWORD PTR _ulFreespaceLth$1[ebp], eax

; 6962 : 
; 6963 :       // See if this space is big enough to hold the new blob.
; 6964 :       if ( ulFreespaceLth < ulBlobLth || ulBlobLth == 0 )

	mov	eax, DWORD PTR _ulFreespaceLth$1[ebp]
	cmp	eax, DWORD PTR _ulBlobLth$[ebp]
	jb	SHORT $LN6@fnStoreBlo
	cmp	DWORD PTR _ulBlobLth$[ebp], 0
	jne	SHORT $LN4@fnStoreBlo
$LN6@fnStoreBlo:

; 6965 :       {
; 6966 :          *pulLth = 0;

	mov	ecx, DWORD PTR _pulLth$[ebp]
	mov	DWORD PTR [ecx], 0

; 6967 :          fnFreeDataspace( pchExternal );

	mov	edx, DWORD PTR _pchExternal$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 6968 :       }

	jmp	SHORT $LN5@fnStoreBlo
$LN4@fnStoreBlo:

; 6969 :       else
; 6970 :       {
; 6971 :          *pulLth = ulBlobLth;

	mov	eax, DWORD PTR _pulLth$[ebp]
	mov	ecx, DWORD PTR _ulBlobLth$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@fnStoreBlo:

; 6972 :       }
; 6973 :    }

	jmp	SHORT $LN3@fnStoreBlo
$LN2@fnStoreBlo:

; 6974 :    else
; 6975 :    {
; 6976 :       // A blob does not exist, set *pulLth to 0 so memory allocation
; 6977 :       // takes place below if the Blob length is non-zero.
; 6978 :       *pulLth = 0;

	mov	edx, DWORD PTR _pulLth$[ebp]
	mov	DWORD PTR [edx], 0
$LN3@fnStoreBlo:

; 6979 :    }
; 6980 : 
; 6981 :    // Get out if there is no data to store.
; 6982 :    if ( ulBlobLth == 0 )

	cmp	DWORD PTR _ulBlobLth$[ebp], 0
	jne	SHORT $LN7@fnStoreBlo

; 6983 :    {
; 6984 :       pchRecord[ ulOffset ] = 0;

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR _ulOffset$[ebp]
	mov	BYTE PTR [eax], 0

; 6985 :       *lpExternalP = 0;

	mov	ecx, DWORD PTR _lpExternalP$[ebp]
	mov	DWORD PTR [ecx], 0

; 6986 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnStoreBlo
$LN7@fnStoreBlo:

; 6987 :    }
; 6988 : 
; 6989 :    // Now check lpuShort to see if we must allocate a new space.
; 6990 :    if ( *pulLth == 0 )

	mov	edx, DWORD PTR _pulLth$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@fnStoreBlo

; 6991 :    {
; 6992 :       zPVOID hndl;
; 6993 : 
; 6994 :       hndl = fnAllocDataspace( lpAllocTask->hFirstDataHeader,

	push	10101					; 00002775H
	push	0
	push	0
	mov	eax, DWORD PTR _ulBlobLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$2[ebp], eax

; 6995 :                                ulBlobLth, 0, 0, iBlob );
; 6996 :       pchExternal = zGETPTR( hndl );

	mov	eax, DWORD PTR _hndl$2[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchExternal$[ebp], eax

; 6997 :       if ( pchExternal == 0 )

	cmp	DWORD PTR _pchExternal$[ebp], 0
	jne	SHORT $LN9@fnStoreBlo

; 6998 :       {
; 6999 :          pchRecord[ ulOffset ] = 0;

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR _ulOffset$[ebp]
	mov	BYTE PTR [ecx], 0

; 7000 :          *lpExternalP = 0;

	mov	edx, DWORD PTR _lpExternalP$[ebp]
	mov	DWORD PTR [edx], 0

; 7001 :          return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnStoreBlo
$LN9@fnStoreBlo:

; 7002 :       }
; 7003 : 
; 7004 :       pchRecord[ ulOffset ] = (zCHAR) '\xff';

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR _ulOffset$[ebp]
	mov	BYTE PTR [eax], -1

; 7005 :       *lpExternalP = hndl;

	mov	ecx, DWORD PTR _lpExternalP$[ebp]
	mov	edx, DWORD PTR _hndl$2[ebp]
	mov	DWORD PTR [ecx], edx

; 7006 :       *pulLth = ulBlobLth;

	mov	eax, DWORD PTR _pulLth$[ebp]
	mov	ecx, DWORD PTR _ulBlobLth$[ebp]
	mov	DWORD PTR [eax], ecx
$LN8@fnStoreBlo:

; 7007 :    }
; 7008 : 
; 7009 :    // Copy the Blob data
; 7010 :    if ( pBlob )

	cmp	DWORD PTR _pBlob$[ebp], 0
	je	SHORT $LN10@fnStoreBlo

; 7011 :       zmemcpy( pchExternal, pBlob, ulBlobLth );

	mov	edx, DWORD PTR _ulBlobLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchExternal$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN11@fnStoreBlo
$LN10@fnStoreBlo:

; 7012 :    else
; 7013 :       zmemset( pchExternal, 0, *pulLth );  // null out memory

	mov	edx, DWORD PTR _pulLth$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pchExternal$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
$LN11@fnStoreBlo:

; 7014 : 
; 7015 :    return( 1 );   // return that new blob has been stored

	mov	eax, 1
$LN1@fnStoreBlo:

; 7016 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnStoreBlobInRecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_uCmprLth$ = -40					; size = 4
_ulFreespaceLth$1 = -36					; size = 4
tv182 = -32						; size = 4
tv181 = -28						; size = 4
_hndl$2 = -24						; size = 4
tv134 = -20						; size = 4
tv133 = -16						; size = 4
_lpExternalP$ = -12					; size = 4
_pulLth$ = -8						; size = 4
_pchExternal$ = -4					; size = 4
_lpAllocTask$ = 8					; size = 4
_pchRecord$ = 12					; size = 4
_ulOffset$ = 16						; size = 4
_cpcString$ = 20					; size = 4
_ulLth$ = 24						; size = 4
_bNullTerminated$ = 28					; size = 2
_fnStoreStringInRecord PROC

; 7039 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 7040 :    zULONG     uCmprLth;
; 7041 :    zPULONG    pulLth;
; 7042 :    zCOREMEM   lpExternalP;
; 7043 :    zPCHAR     pchExternal;
; 7044 : 
; 7045 :    // If the length is 0, get out fast.
; 7046 :    if ( ulLth == 0 && bNullTerminated == FALSE )

	cmp	DWORD PTR _ulLth$[ebp], 0
	jne	SHORT $LN2@fnStoreStr
	movsx	eax, WORD PTR _bNullTerminated$[ebp]
	test	eax, eax
	jne	SHORT $LN2@fnStoreStr

; 7047 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnStoreStr
$LN2@fnStoreStr:

; 7048 : 
; 7049 :    // Initialize pchExternal to 0
; 7050 :    pchExternal = 0;

	mov	DWORD PTR _pchExternal$[ebp], 0

; 7051 : 
; 7052 :    // If data is to null terminated, add one for the null.
; 7053 :    uCmprLth = ulLth;

	mov	ecx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR _uCmprLth$[ebp], ecx

; 7054 :    if ( bNullTerminated )

	movsx	edx, WORD PTR _bNullTerminated$[ebp]
	test	edx, edx
	je	SHORT $LN3@fnStoreStr

; 7055 :       ulLth++;

	mov	eax, DWORD PTR _ulLth$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulLth$[ebp], eax
$LN3@fnStoreStr:

; 7056 : 
; 7057 :    // Check length to see if it is too big for record.
; 7058 :    if ( cpcString[ 0 ] == (zCHAR) '\xff' ||
; 7059 :         ulLth > g_ulMaxRecordStringLth ||

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	je	SHORT $LN6@fnStoreStr
	mov	edx, DWORD PTR _ulLth$[ebp]
	cmp	edx, DWORD PTR _g_ulMaxRecordStringLth
	ja	SHORT $LN6@fnStoreStr
	movsx	eax, WORD PTR _bNullTerminated$[ebp]
	test	eax, eax
	jne	$LN4@fnStoreStr
$LN6@fnStoreStr:

; 7060 :         bNullTerminated == FALSE )
; 7061 :    {
; 7062 :       zULONG ulFreespaceLth;
; 7063 : 
; 7064 :       lpExternalP = (zCOREMEM) ((zPCHAR) pchRecord + ulOffset + 1);

	mov	ecx, DWORD PTR _ulOffset$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _lpExternalP$[ebp], eax

; 7065 :       pulLth = (zPULONG) (lpExternalP + 1);

	mov	ecx, DWORD PTR _lpExternalP$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pulLth$[ebp], ecx

; 7066 :       if ( pchRecord[ ulOffset ] == (zCHAR) '\xff' )

	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR _ulOffset$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, -1
	jne	$LN7@fnStoreStr

; 7067 :       {
; 7068 :          pchExternal  = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchExternal$[ebp], eax

; 7069 :          ulFreespaceLth = fnGetDataspaceLength( pchExternal );

	mov	eax, DWORD PTR _pchExternal$[ebp]
	push	eax
	call	_fnGetDataspaceLength
	add	esp, 4
	mov	DWORD PTR _ulFreespaceLth$1[ebp], eax

; 7070 : 
; 7071 :          // See if this space is big enough to hold the new length.
; 7072 :          if ( ulFreespaceLth < ulLth )

	mov	ecx, DWORD PTR _ulFreespaceLth$1[ebp]
	cmp	ecx, DWORD PTR _ulLth$[ebp]
	jae	SHORT $LN9@fnStoreStr

; 7073 :          {
; 7074 :             fnFreeDataspace( pchExternal );

	mov	edx, DWORD PTR _pchExternal$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 7075 :             *pulLth = 0;

	mov	eax, DWORD PTR _pulLth$[ebp]
	mov	DWORD PTR [eax], 0

; 7076 :          }

	jmp	SHORT $LN10@fnStoreStr
$LN9@fnStoreStr:

; 7077 :          else
; 7078 :          {
; 7079 :             if ( *pulLth == ulLth &&

	mov	ecx, DWORD PTR _pulLth$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _ulLth$[ebp]
	jne	SHORT $LN11@fnStoreStr
	mov	eax, DWORD PTR _pchExternal$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _cpcString$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN22@fnStoreStr
	mov	ecx, DWORD PTR _cpcString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchExternal$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN23@fnStoreStr
$LN22@fnStoreStr:
	mov	eax, DWORD PTR _pchExternal$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _cpcString$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN20@fnStoreStr
	mov	DWORD PTR tv133[ebp], 1
	jmp	SHORT $LN21@fnStoreStr
$LN20@fnStoreStr:
	mov	DWORD PTR tv133[ebp], -1
$LN21@fnStoreStr:
	mov	ecx, DWORD PTR tv133[ebp]
	mov	DWORD PTR tv134[ebp], ecx
$LN23@fnStoreStr:
	cmp	DWORD PTR tv134[ebp], 0
	jne	SHORT $LN11@fnStoreStr

; 7080 :                  zstrcmp( pchExternal, cpcString ) == 0 )
; 7081 :             {
; 7082 :                return( 0 );  // return 0, data has not changed

	xor	eax, eax
	jmp	$LN1@fnStoreStr
$LN11@fnStoreStr:

; 7083 :             }
; 7084 : 
; 7085 :             *pulLth = ulLth;

	mov	edx, DWORD PTR _pulLth$[ebp]
	mov	eax, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR [edx], eax
$LN10@fnStoreStr:

; 7086 :          }
; 7087 :       }

	jmp	SHORT $LN8@fnStoreStr
$LN7@fnStoreStr:

; 7088 :       else
; 7089 :          *pulLth = 0;

	mov	ecx, DWORD PTR _pulLth$[ebp]
	mov	DWORD PTR [ecx], 0
$LN8@fnStoreStr:

; 7090 : 
; 7091 :       // Now check pulLth to see if we must allocate a new space.
; 7092 :       if ( *pulLth == 0 )

	mov	edx, DWORD PTR _pulLth$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN12@fnStoreStr

; 7093 :       {
; 7094 :          zPVOID hndl;
; 7095 : 
; 7096 :          hndl = fnAllocDataspace( lpAllocTask->hFirstDataHeader, ulLth, 0, 0,

	push	10102					; 00002776H
	push	0
	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$2[ebp], eax

; 7097 :                                   iAttributeString );
; 7098 :          pchExternal = zGETPTR( hndl );

	mov	eax, DWORD PTR _hndl$2[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchExternal$[ebp], eax

; 7099 :          if ( pchExternal == 0 )

	cmp	DWORD PTR _pchExternal$[ebp], 0
	jne	SHORT $LN13@fnStoreStr

; 7100 :          {
; 7101 :             pchRecord[ ulOffset ] = 0;

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR _ulOffset$[ebp]
	mov	BYTE PTR [ecx], 0

; 7102 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnStoreStr
$LN13@fnStoreStr:

; 7103 :          }
; 7104 : 
; 7105 :          pchRecord[ ulOffset ] = (zCHAR) '\xff';

	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR _ulOffset$[ebp]
	mov	BYTE PTR [edx], -1

; 7106 :          *lpExternalP = hndl;

	mov	eax, DWORD PTR _lpExternalP$[ebp]
	mov	ecx, DWORD PTR _hndl$2[ebp]
	mov	DWORD PTR [eax], ecx
$LN12@fnStoreStr:

; 7107 :       }
; 7108 : 
; 7109 :       // Set length and copy data.
; 7110 :       zmemcpy( pchExternal, cpcString, (unsigned int) ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchExternal$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7111 :       *pulLth = ulLth;

	mov	edx, DWORD PTR _pulLth$[ebp]
	mov	eax, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR [edx], eax

; 7112 : 
; 7113 :       // Add null if requested.
; 7114 :       if ( bNullTerminated )

	movsx	ecx, WORD PTR _bNullTerminated$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@fnStoreStr

; 7115 :          pchExternal[ ulLth - 1 ] = 0;

	mov	edx, DWORD PTR _pchExternal$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx-1], 0
$LN14@fnStoreStr:

; 7116 :    }

	jmp	$LN5@fnStoreStr
$LN4@fnStoreStr:

; 7117 :    else
; 7118 :    {
; 7119 :       if ( pchRecord[ ulOffset ] == (zCHAR) '\xff' )

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR _ulOffset$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	jne	SHORT $LN15@fnStoreStr

; 7120 :       {
; 7121 :          lpExternalP = (zCOREMEM) ((zPCHAR) pchRecord + ulOffset + 1);

	mov	edx, DWORD PTR _ulOffset$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	mov	DWORD PTR _lpExternalP$[ebp], ecx

; 7122 :          pchExternal = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchExternal$[ebp], eax

; 7123 :          fnFreeDataspace( pchExternal );

	mov	ecx, DWORD PTR _pchExternal$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 7124 :       }

	jmp	SHORT $LN16@fnStoreStr
$LN15@fnStoreStr:

; 7125 :       else
; 7126 :       if ( zstrcmp( pchRecord + ulOffset, cpcString ) == 0 )

	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR _ulOffset$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _cpcString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN26@fnStoreStr
	mov	eax, DWORD PTR _cpcString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR _ulOffset$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN27@fnStoreStr
$LN26@fnStoreStr:
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR _ulOffset$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _cpcString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN24@fnStoreStr
	mov	DWORD PTR tv181[ebp], 1
	jmp	SHORT $LN25@fnStoreStr
$LN24@fnStoreStr:
	mov	DWORD PTR tv181[ebp], -1
$LN25@fnStoreStr:
	mov	eax, DWORD PTR tv181[ebp]
	mov	DWORD PTR tv182[ebp], eax
$LN27@fnStoreStr:
	cmp	DWORD PTR tv182[ebp], 0
	jne	SHORT $LN16@fnStoreStr

; 7127 :          return( 0 ); // Return 0 if string has not changed

	xor	eax, eax
	jmp	SHORT $LN1@fnStoreStr
$LN16@fnStoreStr:

; 7128 : 
; 7129 :       zmemcpy( pchRecord + ulOffset, cpcString, (unsigned int) ulLth );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcString$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR _ulOffset$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7130 : 
; 7131 :       // Ensure null if data is null terminated.
; 7132 :       if ( bNullTerminated )

	movsx	ecx, WORD PTR _bNullTerminated$[ebp]
	test	ecx, ecx
	je	SHORT $LN5@fnStoreStr

; 7133 :          pchRecord[ ulOffset + (ulLth - 1) ] = 0;

	mov	edx, DWORD PTR _ulLth$[ebp]
	mov	eax, DWORD PTR _ulOffset$[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN5@fnStoreStr:

; 7134 :    }
; 7135 : 
; 7136 :    return( 1 ); // return that new string has been stored

	mov	eax, 1
$LN1@fnStoreStr:

; 7137 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnStoreStringInRecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pchChar$ = -40						; size = 4
_lpdDecimal$ = -36					; size = 4
_lplLong$ = -32						; size = 4
_lpDateTime$ = -28					; size = 4
_ulBytes$ = -24						; size = 4
_lpLinkedEntityInstance$1 = -20				; size = 4
_pchRecord$ = -16					; size = 4
tv128 = -12						; size = 4
_hRecord$ = -8						; size = 4
_lpViewAttrib$ = -4					; size = 4
_lpAllocTask$ = 8					; size = 4
_lpViewEntity$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_fnCreateAttributeRecord PROC

; 6834 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 6835 :    zPCHAR         pchRecord;
; 6836 :    zPCHAR         pchChar;
; 6837 :    zPVOID         hRecord;
; 6838 :    zPLONG         lplLong;
; 6839 :    zPDECIMAL      lpdDecimal;
; 6840 :    LPDTINTERNAL   lpDateTime;
; 6841 :    LPVIEWATTRIB   lpViewAttrib;
; 6842 :    zULONG         ulBytes;
; 6843 : 
; 6844 :    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN9@fnCreateAt

; 6845 :       ulBytes = lpViewEntity->ulRecordSize;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+207]
	mov	DWORD PTR _ulBytes$[ebp], ecx
	jmp	SHORT $LN10@fnCreateAt
$LN9@fnCreateAt:

; 6846 :    else
; 6847 :       ulBytes = lpViewEntity->ulNonPersistSize;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+211]
	mov	DWORD PTR _ulBytes$[ebp], eax
$LN10@fnCreateAt:

; 6848 : 
; 6849 :    hRecord = fnAllocDataspace( lpAllocTask->hFirstDataHeader, ulBytes, 1, 0,

	push	10100					; 00002774H
	push	0
	push	1
	mov	ecx, DWORD PTR _ulBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAllocTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hRecord$[ebp], eax

; 6850 :                                iAttributeRecord );
; 6851 :    if ( hRecord == 0 )

	cmp	DWORD PTR _hRecord$[ebp], 0
	jne	SHORT $LN11@fnCreateAt

; 6852 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCreateAt
$LN11@fnCreateAt:

; 6853 : 
; 6854 :    pchRecord = zGETPTR( hRecord );

	mov	ecx, DWORD PTR _hRecord$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 6855 : 
; 6856 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnCreateAt
$LN2@fnCreateAt:

; 6858 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnCreateAt:

; 6857 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnCreateAt

; 6859 :    {
; 6860 :       if ( (lpEntityInstance && lpViewAttrib->bPersist) ||

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN14@fnCreateAt
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	jne	SHORT $LN13@fnCreateAt
$LN14@fnCreateAt:
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	$LN12@fnCreateAt
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	jne	$LN12@fnCreateAt
$LN13@fnCreateAt:

; 6861 :            (lpEntityInstance == 0 && lpViewAttrib->bPersist == FALSE) )
; 6862 :       {
; 6863 :          if ( lpViewAttrib->hInit )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [ecx+209], 0
	je	SHORT $LN15@fnCreateAt

; 6864 :          {
; 6865 :             // Do the initialization thing
; 6866 :          }

	jmp	$LN12@fnCreateAt
$LN15@fnCreateAt:

; 6867 :          else
; 6868 :          {
; 6869 :             switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv128[ebp], ecx
	cmp	DWORD PTR tv128[ebp], 18		; 00000012H
	ja	$LN12@fnCreateAt
	mov	edx, DWORD PTR tv128[ebp]
	movzx	eax, BYTE PTR $LN25@fnCreateAt[edx]
	jmp	DWORD PTR $LN26@fnCreateAt[eax*4]
$LN17@fnCreateAt:

; 6870 :             {
; 6871 :                case 'L':
; 6872 :                   lplLong = (zLONG zFAR *)

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lplLong$[ebp], edx

; 6873 :                               (pchRecord + lpViewAttrib->ulRecordOffset);
; 6874 :                   *lplLong = lNullInteger;

	mov	eax, DWORD PTR _lplLong$[ebp]
	mov	ecx, DWORD PTR _lNullInteger
	mov	DWORD PTR [eax], ecx

; 6875 :                   break;

	jmp	SHORT $LN12@fnCreateAt
$LN18@fnCreateAt:

; 6876 : 
; 6877 :                case zTYPE_DECIMAL:
; 6878 :                   lpdDecimal = (zDECIMAL zFAR *)

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpdDecimal$[ebp], eax

; 6879 :                               (pchRecord + lpViewAttrib->ulRecordOffset);
; 6880 :                   SysAssignDecimalFromNull( lpdDecimal );

	mov	ecx, DWORD PTR _lpdDecimal$[ebp]
	push	ecx
	call	_SysAssignDecimalFromNull@4

; 6881 :                   break;

	jmp	SHORT $LN12@fnCreateAt
$LN19@fnCreateAt:

; 6882 : 
; 6883 :                case 'T':
; 6884 :                   lpDateTime =

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpDateTime$[ebp], eax

; 6885 :                     (LPDTINTERNAL) (pchRecord + lpViewAttrib->ulRecordOffset);
; 6886 :                   lpDateTime->ulDateMinutes = lNullInteger;

	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	mov	edx, DWORD PTR _lNullInteger
	mov	DWORD PTR [ecx], edx

; 6887 :                   lpDateTime->usTSeconds = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	mov	WORD PTR [ecx+4], ax

; 6888 :                   break;

	jmp	SHORT $LN12@fnCreateAt
$LN20@fnCreateAt:

; 6889 : 
; 6890 :                case 'B':
; 6891 :                   pchChar = (zCHAR zFAR *)

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchChar$[ebp], eax

; 6892 :                            (pchRecord + lpViewAttrib->ulRecordOffset);
; 6893 :                   *pchChar = '\x00';

	mov	ecx, DWORD PTR _pchChar$[ebp]
	mov	BYTE PTR [ecx], 0
$LN12@fnCreateAt:

; 6894 :                   break;
; 6895 : 
; 6896 :                default:
; 6897 :                   break;
; 6898 :             }
; 6899 :          }
; 6900 :       }
; 6901 :    }

	jmp	$LN2@fnCreateAt
$LN3@fnCreateAt:

; 6902 : 
; 6903 :    // Now that the record has been created, put the record into the Entity
; 6904 :    // instance created and any linked instances associated with the entity.
; 6905 :    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN22@fnCreateAt

; 6906 :    {
; 6907 :       LPENTITYINSTANCE lpLinkedEntityInstance;
; 6908 : 
; 6909 :       // Set the record pointer in the entity instance and copy the record
; 6910 :       // pointer to all linked versions of the entity instance.  If no entity
; 6911 :       // instance is marked as the record owner (should be load situation
; 6912 :       // only!), then mark the current instance as the record owner.
; 6913 :       lpEntityInstance->hPersistRecord = hRecord;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _hRecord$[ebp]
	mov	DWORD PTR [edx+60], eax

; 6914 :       if ( lpEntityInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN22@fnCreateAt

; 6915 :       {
; 6916 :          lpLinkedEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedEntityInstance$1[ebp], eax
$LN7@fnCreateAt:

; 6917 :          while ( lpLinkedEntityInstance != lpEntityInstance )

	mov	ecx, DWORD PTR _lpLinkedEntityInstance$1[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN22@fnCreateAt

; 6918 :          {
; 6919 :             lpLinkedEntityInstance->hPersistRecord = hRecord;

	mov	edx, DWORD PTR _lpLinkedEntityInstance$1[ebp]
	mov	eax, DWORD PTR _hRecord$[ebp]
	mov	DWORD PTR [edx+60], eax

; 6920 :             lpLinkedEntityInstance =

	mov	ecx, DWORD PTR _lpLinkedEntityInstance$1[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedEntityInstance$1[ebp], eax

; 6921 :                             zGETPTR( lpLinkedEntityInstance->hNextLinked );
; 6922 :          }

	jmp	SHORT $LN7@fnCreateAt
$LN22@fnCreateAt:

; 6923 :       }
; 6924 :    }
; 6925 : 
; 6926 :    return( hRecord );

	mov	eax, DWORD PTR _hRecord$[ebp]
$LN1@fnCreateAt:

; 6927 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN26@fnCreateAt:
	DD	$LN20@fnCreateAt
	DD	$LN17@fnCreateAt
	DD	$LN18@fnCreateAt
	DD	$LN19@fnCreateAt
	DD	$LN12@fnCreateAt
$LN25@fnCreateAt:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnCreateAttributeRecord ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -36						; size = 4
_pulLong$2 = -32					; size = 4
_lpExternalP$3 = -28					; size = 4
_pulLong$4 = -24					; size = 4
_lpExternalP$5 = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
tv66 = -12						; size = 4
_pchRecord$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pulReturnLth$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_fnGetActualAttributeLength PROC

; 2338 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2339 :    LPENTITYINSTANCE  lpEntityInstance;
; 2340 :    zPCHAR            pchRecord;
; 2341 :    zSHORT            nRC;
; 2342 : 
; 2343 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2344 :    switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv66[ebp], edx
	mov	eax, DWORD PTR tv66[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 18			; 00000012H
	ja	$LN14@fnGetActua
	mov	ecx, DWORD PTR tv66[ebp]
	movzx	edx, BYTE PTR $LN16@fnGetActua[ecx]
	jmp	DWORD PTR $LN17@fnGetActua[edx*4]
$LN4@fnGetActua:

; 2345 :    {
; 2346 :       case zTYPE_STRING:
; 2347 :       {
; 2348 :          zCOREMEM lpExternalP;
; 2349 :          zPULONG pulLong;
; 2350 : 
; 2351 :          // Default return length to 0
; 2352 :          *pulReturnLth = 0;

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 0

; 2353 : 
; 2354 :          // Get Entity Instance pointer
; 2355 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2356 : 
; 2357 :          // Get record to retrieve from
; 2358 :          pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 2359 : 
; 2360 :          if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	SHORT $LN5@fnGetActua

; 2361 :          {
; 2362 :             pchRecord = pchRecord + lpViewAttrib->ulRecordOffset;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchRecord$[ebp], eax

; 2363 :             if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	jne	SHORT $LN6@fnGetActua

; 2364 :             {
; 2365 :                lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$5[ebp], edx

; 2366 :                pulLong = (zPULONG) (lpExternalP + 1);

	mov	eax, DWORD PTR _lpExternalP$5[ebp]
	add	eax, 4
	mov	DWORD PTR _pulLong$4[ebp], eax

; 2367 :                *pulReturnLth = *pulLong;

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	edx, DWORD PTR _pulLong$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 2368 :             }

	jmp	SHORT $LN5@fnGetActua
$LN6@fnGetActua:

; 2369 :             else
; 2370 :                *pulReturnLth = zstrlen( pchRecord ) + 1;

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], eax
$LN5@fnGetActua:

; 2371 :          }
; 2372 : 
; 2373 :          break;

	jmp	$LN2@fnGetActua
$LN8@fnGetActua:

; 2374 :       }
; 2375 : 
; 2376 :       case zTYPE_INTEGER:
; 2377 :          *pulReturnLth = sizeof( zLONG );

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 4

; 2378 :          break;

	jmp	$LN2@fnGetActua
$LN9@fnGetActua:

; 2379 : 
; 2380 :       case zTYPE_DECIMAL:
; 2381 :          *pulReturnLth = sizeof( zDECIMAL );

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], 40			; 00000028H

; 2382 :          break;

	jmp	$LN2@fnGetActua
$LN10@fnGetActua:

; 2383 : 
; 2384 :       case zTYPE_DATETIME:
; 2385 :          *pulReturnLth = sizeof( DateTimeInternalRecord );

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], 6

; 2386 :          break;

	jmp	$LN2@fnGetActua
$LN11@fnGetActua:

; 2387 : 
; 2388 :       case zTYPE_BLOB:
; 2389 : 
; 2390 :          // Default return length to 0
; 2391 :          *pulReturnLth = 0;

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 0

; 2392 : 
; 2393 :          // Get Entity Instance pointer.
; 2394 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2395 : 
; 2396 :          // Get record to retrieve from
; 2397 :          pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 2398 : 
; 2399 :          // if a record exists, copy it to the return variable
; 2400 :          if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	SHORT $LN12@fnGetActua

; 2401 :          {
; 2402 :             pchRecord += lpViewAttrib->ulRecordOffset;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchRecord$[ebp], eax

; 2403 :             if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	jne	SHORT $LN12@fnGetActua

; 2404 :             {
; 2405 :                zPULONG    pulLong;
; 2406 :                zCOREMEM   lpExternalP;
; 2407 : 
; 2408 :                lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$3[ebp], edx

; 2409 :                pulLong = (zPULONG) (lpExternalP + 1);

	mov	eax, DWORD PTR _lpExternalP$3[ebp]
	add	eax, 4
	mov	DWORD PTR _pulLong$2[ebp], eax

; 2410 :                *pulReturnLth = *pulLong;

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	edx, DWORD PTR _pulLong$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
$LN12@fnGetActua:

; 2411 :             }
; 2412 :          }
; 2413 : 
; 2414 :          break;

	jmp	SHORT $LN2@fnGetActua
$LN14@fnGetActua:

; 2415 : 
; 2416 :       default:
; 2417 :       {
; 2418 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 2419 :          // "KZOEE239 - Invalid Operation for attribute type"
; 2420 :          fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2421 :                            fnEntityNameFromCsr( lpViewEntityCsr ),
; 2422 :                            lpViewAttrib->szName );
; 2423 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnGetActua:

; 2424 :       }
; 2425 :    }
; 2426 : 
; 2427 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2428 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN17@fnGetActua:
	DD	$LN11@fnGetActua
	DD	$LN8@fnGetActua
	DD	$LN9@fnGetActua
	DD	$LN4@fnGetActua
	DD	$LN10@fnGetActua
	DD	$LN14@fnGetActua
$LN16@fnGetActua:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnGetActualAttributeLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -28						; size = 4
_lpViewEntity$2 = -24					; size = 4
_pulLong$3 = -20					; size = 4
_lpExternalP$4 = -16					; size = 4
tv66 = -12						; size = 4
_pchRecord$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pulReturnLth$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpEntityInstance$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_fnGetAttributeLength PROC

; 2208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2209 :    zPCHAR  pchRecord;
; 2210 :    zSHORT  nRC;
; 2211 : 
; 2212 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2213 :    switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv66[ebp], edx
	mov	eax, DWORD PTR tv66[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 18			; 00000012H
	ja	$LN12@fnGetAttri
	mov	ecx, DWORD PTR tv66[ebp]
	movzx	edx, BYTE PTR $LN14@fnGetAttri[ecx]
	jmp	DWORD PTR $LN15@fnGetAttri[edx*4]
$LN4@fnGetAttri:

; 2214 :    {
; 2215 :       case zTYPE_STRING:
; 2216 :          *pulReturnLth = lpViewAttrib->ulLth - 1;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+203]
	sub	ecx, 1
	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], ecx

; 2217 :          break;

	jmp	$LN2@fnGetAttri
$LN5@fnGetAttri:

; 2218 : 
; 2219 :       case zTYPE_INTEGER:
; 2220 :          *pulReturnLth = 16;

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 16			; 00000010H

; 2221 :          break;

	jmp	$LN2@fnGetAttri
$LN6@fnGetAttri:

; 2222 : 
; 2223 :       case zTYPE_DECIMAL:
; 2224 :          *pulReturnLth = 24;

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], 24			; 00000018H

; 2225 :          break;

	jmp	$LN2@fnGetAttri
$LN7@fnGetAttri:

; 2226 : 
; 2227 :       case zTYPE_DATETIME:
; 2228 :          *pulReturnLth = 17;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], 17			; 00000011H

; 2229 :          break;

	jmp	$LN2@fnGetAttri
$LN8@fnGetAttri:

; 2230 : 
; 2231 :       case zTYPE_BLOB:
; 2232 :          *pulReturnLth = 0;    // Default return length to 0

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 0

; 2233 : 
; 2234 :          if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN9@fnGetAttri

; 2235 :             break;

	jmp	$LN2@fnGetAttri
$LN9@fnGetAttri:

; 2236 : 
; 2237 :          // Get record to retrieve from.
; 2238 :          pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 2239 : 
; 2240 :          // If a record exists, copy it to the return variable.
; 2241 :          if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	SHORT $LN10@fnGetAttri

; 2242 :          {
; 2243 :             pchRecord += lpViewAttrib->ulRecordOffset;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _pchRecord$[ebp], ecx

; 2244 :             if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN10@fnGetAttri

; 2245 :             {
; 2246 :                zPULONG   pulLong;
; 2247 :                zCOREMEM  lpExternalP;
; 2248 : 
; 2249 :                lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$4[ebp], eax

; 2250 :                pulLong = (zPULONG) (lpExternalP + 1);

	mov	ecx, DWORD PTR _lpExternalP$4[ebp]
	add	ecx, 4
	mov	DWORD PTR _pulLong$3[ebp], ecx

; 2251 :                *pulReturnLth = *pulLong;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	eax, DWORD PTR _pulLong$3[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
$LN10@fnGetAttri:

; 2252 :             }
; 2253 :          }
; 2254 : 
; 2255 :          break;

	jmp	SHORT $LN2@fnGetAttri
$LN12@fnGetAttri:

; 2256 : 
; 2257 :       default:
; 2258 :       {
; 2259 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 2260 :          LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 2261 : 
; 2262 :          // "KZOEE239 - Invalid Operation for attribute type"
; 2263 :          fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2264 :                            lpViewEntity->szName, lpViewAttrib->szName );
; 2265 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnGetAttri:

; 2266 :       }
; 2267 :    }
; 2268 : 
; 2269 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2270 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@fnGetAttri:
	DD	$LN8@fnGetAttri
	DD	$LN5@fnGetAttri
	DD	$LN6@fnGetAttri
	DD	$LN4@fnGetAttri
	DD	$LN7@fnGetAttri
	DD	$LN12@fnGetAttri
$LN14@fnGetAttri:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnGetAttributeLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -32						; size = 4
_pchEditString$ = -28					; size = 4
_lpTaskDomain$ = -24					; size = 4
tv149 = -20						; size = 4
_lpDomain$ = -16					; size = 4
_ulLth$ = -12						; size = 4
_nRC$ = -8						; size = 2
_cDomainType$ = -1					; size = 1
_pulReturnLth$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_lpContext$ = 24					; size = 4
_lpCurrentTask$ = 28					; size = 4
_fnGetAttributeDisplayLength PROC

; 2051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2052 :    LPDOMAIN          lpDomain;
; 2053 :    zULONG            ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0

; 2054 :    zPCHAR            pchEditString;
; 2055 :    zCHAR             cDomainType;
; 2056 :    LPTASKDOMAIN      lpTaskDomain;
; 2057 :    zSHORT            nRC = 0; // default to okay

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2058 : 
; 2059 :    lpDomain = zGETPTR( lpContext->hDomain );

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+43]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 2060 :    cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTaskDomain$[ebp]
	push	eax
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 2061 :                                              lpCurrentTask, lpDomain );
; 2062 : 
; 2063 :    if ( lpDomain->szDomainOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+100]
	test	ecx, ecx
	je	SHORT $LN4@fnGetAttri

; 2064 :    {
; 2065 :       if ( lpTaskDomain == 0 )

	cmp	DWORD PTR _lpTaskDomain$[ebp], 0
	jne	SHORT $LN5@fnGetAttri

; 2066 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetAttri
$LN5@fnGetAttri:

; 2067 : 
; 2068 :       nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	push	0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpContext$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	push	ecx
	push	0
	push	13					; 0000000dH
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 2069 :                               zDME_GET_ATTR_DISPLAY_LENGTH,
; 2070 :                               0, (zPCHAR) pulReturnLth, lpContext->szName,
; 2071 :                               lpView, zGETPTR( lpViewAttrib->hViewEntity ),
; 2072 :                               lpViewAttrib, 0 );
; 2073 :       if ( nRC != zDME_NOT_HANDLED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -10				; fffffff6H
	je	SHORT $LN4@fnGetAttri

; 2074 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAttri
$LN4@fnGetAttri:

; 2075 :    }
; 2076 : 
; 2077 :    if ( lpDomain->cDomainType == zDM_TYPE_FORMAT )

	mov	edx, DWORD PTR _lpDomain$[ebp]
	movsx	eax, BYTE PTR [edx+65]
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN7@fnGetAttri

; 2078 :    {
; 2079 :       pchEditString = zGETPTR( lpContext->hEditString );

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+59]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchEditString$[ebp], eax

; 2080 :       ulLth = zstrlen( pchEditString );

	mov	eax, DWORD PTR _pchEditString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 2081 :    }

	jmp	SHORT $LN8@fnGetAttri
$LN7@fnGetAttri:

; 2082 :    else
; 2083 :    if ( lpDomain->cDomainType == zDM_TYPE_TABLE )

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+65]
	cmp	edx, 84					; 00000054H
	jne	SHORT $LN8@fnGetAttri

; 2084 :    {
; 2085 :       if ( lpContext->nDisplayLength == -1 )

	mov	eax, DWORD PTR _lpContext$[ebp]
	movsx	ecx, WORD PTR [eax+67]
	cmp	ecx, -1
	jne	SHORT $LN10@fnGetAttri

; 2086 :       {
; 2087 :          ulLth = fnGetLongExternalLthForContext( lpContext );

	mov	edx, DWORD PTR _lpContext$[ebp]
	push	edx
	call	_fnGetLongExternalLthForContext
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 2088 :          lpContext->nDisplayLength = (zUSHORT) ulLth;

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	cx, WORD PTR _ulLth$[ebp]
	mov	WORD PTR [eax+67], cx

; 2089 :       }

	jmp	SHORT $LN8@fnGetAttri
$LN10@fnGetAttri:

; 2090 :       else
; 2091 :          ulLth = lpContext->nDisplayLength;

	mov	edx, DWORD PTR _lpContext$[ebp]
	movsx	eax, WORD PTR [edx+67]
	mov	DWORD PTR _ulLth$[ebp], eax
$LN8@fnGetAttri:

; 2092 :    }
; 2093 : 
; 2094 :    // If the length is still 0 try another way.
; 2095 :    if ( ulLth == 0 )

	cmp	DWORD PTR _ulLth$[ebp], 0
	jne	$LN12@fnGetAttri

; 2096 :    {
; 2097 :       switch ( lpDomain->cType )

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+63]
	mov	DWORD PTR tv149[ebp], edx
	mov	eax, DWORD PTR tv149[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv149[ebp], eax
	cmp	DWORD PTR tv149[ebp], 18		; 00000012H
	ja	SHORT $LN18@fnGetAttri
	mov	ecx, DWORD PTR tv149[ebp]
	movzx	edx, BYTE PTR $LN20@fnGetAttri[ecx]
	jmp	DWORD PTR $LN21@fnGetAttri[edx*4]
$LN13@fnGetAttri:

; 2098 :       {
; 2099 :          case zTYPE_STRING:
; 2100 :             ulLth = lpViewAttrib->ulLth - 1;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+203]
	sub	ecx, 1
	mov	DWORD PTR _ulLth$[ebp], ecx

; 2101 :             break;

	jmp	SHORT $LN12@fnGetAttri
$LN14@fnGetAttri:

; 2102 : 
; 2103 :          case zTYPE_INTEGER:
; 2104 :             ulLth = 16;

	mov	DWORD PTR _ulLth$[ebp], 16		; 00000010H

; 2105 :             break;

	jmp	SHORT $LN12@fnGetAttri
$LN15@fnGetAttri:

; 2106 : 
; 2107 :          case zTYPE_DECIMAL:
; 2108 :             ulLth = 24;

	mov	DWORD PTR _ulLth$[ebp], 24		; 00000018H

; 2109 :             break;

	jmp	SHORT $LN12@fnGetAttri
$LN16@fnGetAttri:

; 2110 : 
; 2111 :          case zTYPE_DATETIME:
; 2112 :             ulLth = 25;

	mov	DWORD PTR _ulLth$[ebp], 25		; 00000019H

; 2113 :             break;

	jmp	SHORT $LN12@fnGetAttri
$LN17@fnGetAttri:

; 2114 : 
; 2115 :          case zTYPE_BLOB:
; 2116 :             ulLth = -1;

	mov	DWORD PTR _ulLth$[ebp], -1

; 2117 :             break;

	jmp	SHORT $LN12@fnGetAttri
$LN18@fnGetAttri:

; 2118 : 
; 2119 :          default:
; 2120 :          {
; 2121 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 2122 :             // "KZOEE239 - Invalid Operation for attribute type"
; 2123 :             fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2124 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 2125 :                               lpViewAttrib->szName );
; 2126 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN12@fnGetAttri:

; 2127 :          }
; 2128 :       }
; 2129 :    }
; 2130 : 
; 2131 :    *pulReturnLth = ulLth;

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	ecx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR [eax], ecx

; 2132 : 
; 2133 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnGetAttri:

; 2134 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN21@fnGetAttri:
	DD	$LN17@fnGetAttri
	DD	$LN14@fnGetAttri
	DD	$LN15@fnGetAttri
	DD	$LN13@fnGetAttri
	DD	$LN16@fnGetAttri
	DD	$LN18@fnGetAttri
$LN20@fnGetAttri:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnGetAttributeDisplayLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -24						; size = 4
_lpViewEntity$2 = -20					; size = 4
_lpExternalP$3 = -16					; size = 4
_lpExternalP$4 = -12					; size = 4
tv128 = -8						; size = 4
_pchRecord$ = -4					; size = 4
_lpReturnAddr$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpEntityInstance$ = 20					; size = 4
_lpViewAttrib$ = 24					; size = 4
_fnGetAddrForAttribute PROC

; 1788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1789 :    zPCHAR          pchRecord;
; 1790 :    static zDECIMAL dNullDecimal;
; 1791 : 
; 1792 :    // Get Entity Instance pointer.
; 1793 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN4@fnGetAddrF

; 1794 :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnGetAddrF:

; 1795 : 
; 1796 :    // Get record to retrieve from.
; 1797 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 1798 : 
; 1799 :    // If a record exists, copy it to the return variable.
; 1800 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN5@fnGetAddrF

; 1801 :    {
; 1802 :       pchRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchRecord$[ebp], edx

; 1803 :       if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN7@fnGetAddrF

; 1804 :       {
; 1805 :          if ( pchRecord[ 0 ] != (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	je	SHORT $LN9@fnGetAddrF

; 1806 :             *lpReturnAddr = 0;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [eax], 0
	jmp	SHORT $LN10@fnGetAddrF
$LN9@fnGetAddrF:

; 1807 :          else
; 1808 :          {
; 1809 :             zCOREMEM  lpExternalP;
; 1810 : 
; 1811 :             lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$4[ebp], ecx

; 1812 :             pchRecord = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$4[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 1813 :             *lpReturnAddr = pchRecord;

	mov	ecx, DWORD PTR _lpReturnAddr$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR [ecx], edx
$LN10@fnGetAddrF:

; 1814 :          }
; 1815 :       }

	jmp	SHORT $LN8@fnGetAddrF
$LN7@fnGetAddrF:

; 1816 :       else
; 1817 :       {
; 1818 :          if ( lpViewAttrib->cType == zTYPE_STRING &&

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN11@fnGetAddrF
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN11@fnGetAddrF

; 1819 :               pchRecord[ 0 ] == (zCHAR) '\xff' )
; 1820 :          {
; 1821 :             zCOREMEM  lpExternalP;
; 1822 : 
; 1823 :             lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$3[ebp], eax

; 1824 :             pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$3[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 1825 :             *lpReturnAddr = pchRecord;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR [eax], ecx

; 1826 :          }

	jmp	SHORT $LN8@fnGetAddrF
$LN11@fnGetAddrF:

; 1827 :          else
; 1828 :             *lpReturnAddr = pchRecord;

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR [edx], eax
$LN8@fnGetAddrF:

; 1829 :       }
; 1830 :    }

	jmp	$LN6@fnGetAddrF
$LN5@fnGetAddrF:

; 1831 :    else
; 1832 :    {
; 1833 :       switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv128[ebp], edx
	mov	eax, DWORD PTR tv128[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv128[ebp], eax
	cmp	DWORD PTR tv128[ebp], 18		; 00000012H
	ja	SHORT $LN18@fnGetAddrF
	mov	ecx, DWORD PTR tv128[ebp]
	movzx	edx, BYTE PTR $LN20@fnGetAddrF[ecx]
	jmp	DWORD PTR $LN21@fnGetAddrF[edx*4]
$LN13@fnGetAddrF:

; 1834 :       {
; 1835 :          case zTYPE_STRING:
; 1836 :             *lpReturnAddr = szNullS;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	ecx, DWORD PTR _szNullS
	mov	DWORD PTR [eax], ecx

; 1837 :             break;

	jmp	$LN6@fnGetAddrF
$LN14@fnGetAddrF:

; 1838 : 
; 1839 :          case zTYPE_INTEGER:
; 1840 :             *lpReturnAddr = (zPCHAR) &lNullInteger;

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [edx], OFFSET _lNullInteger

; 1841 :             break;

	jmp	SHORT $LN6@fnGetAddrF
$LN15@fnGetAddrF:

; 1842 : 
; 1843 :          case zTYPE_DECIMAL:
; 1844 :             SysAssignDecimalFromNull( &dNullDecimal );

	push	OFFSET ?dNullDecimal@?1??fnGetAddrForAttribute@@9@9
	call	_SysAssignDecimalFromNull@4

; 1845 :             *lpReturnAddr = (zPCHAR) &dNullDecimal;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [eax], OFFSET ?dNullDecimal@?1??fnGetAddrForAttribute@@9@9

; 1846 :             break;

	jmp	SHORT $LN6@fnGetAddrF
$LN16@fnGetAddrF:

; 1847 : 
; 1848 :          case zTYPE_DATETIME:
; 1849 :             *lpReturnAddr = (zPCHAR) &stNullDateTime;

	mov	ecx, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [ecx], OFFSET _stNullDateTime

; 1850 :             break;

	jmp	SHORT $LN6@fnGetAddrF
$LN17@fnGetAddrF:

; 1851 : 
; 1852 :          case zTYPE_BLOB:
; 1853 :             *lpReturnAddr = 0;

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [edx], 0

; 1854 :             break;

	jmp	SHORT $LN6@fnGetAddrF
$LN18@fnGetAddrF:

; 1855 : 
; 1856 :          default:
; 1857 :          {
; 1858 :             LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 1859 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 1860 : 
; 1861 :             // This error should never happen.
; 1862 :             // "KZOEE246 - Invalid Attribute type "
; 1863 :             fnIssueCoreError( lpTask, lpView, 8, 246, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$2[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	246					; 000000f6H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1864 :                               lpViewEntity->szName, lpViewAttrib->szName );
; 1865 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnGetAddrF
$LN6@fnGetAddrF:

; 1866 :          }
; 1867 :       }
; 1868 :    }
; 1869 : 
; 1870 :    return( 0 );

	xor	eax, eax
$LN1@fnGetAddrF:

; 1871 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN21@fnGetAddrF:
	DD	$LN17@fnGetAddrF
	DD	$LN14@fnGetAddrF
	DD	$LN15@fnGetAddrF
	DD	$LN13@fnGetAddrF
	DD	$LN16@fnGetAddrF
	DD	$LN18@fnGetAddrF
$LN20@fnGetAddrF:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnGetAddrForAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -36						; size = 4
_lpViewCsr$ = -32					; size = 4
_lpViewOI$ = -28					; size = 4
_lpAllocTask$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_pchRecord$ = -12					; size = 4
_nRC$ = -8						; size = 2
_bUpdated$ = -1						; size = 1
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_pBlobValue$ = 20					; size = 4
_uBlobLth$ = 24						; size = 4
_fnSetAttributeFromBlob PROC

; 4228 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 4229 :    LPTASK            lpAllocTask;
; 4230 :    LPVIEWENTITY      lpViewEntity;
; 4231 :    LPENTITYINSTANCE  lpEntityInstance;
; 4232 :    LPVIEWCSR         lpViewCsr;
; 4233 :    LPVIEWOI          lpViewOI;
; 4234 :    zPCHAR            pchRecord;
; 4235 :    zBOOL             bUpdated;
; 4236 :    zSHORT            nRC;
; 4237 : 
; 4238 :    // Get view Entity from cursor
; 4239 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4240 :    lpViewCsr    = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4241 :    lpViewOI     = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4242 :    lpAllocTask  = zGETPTR( lpViewOI->hAllocTask );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 4243 : 
; 4244 :    // Get Entity Instance pointer
; 4245 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 4246 : 
; 4247 :    // Make sure target attribute is a Blob
; 4248 :    if ( lpViewAttrib->cType != zTYPE_BLOB )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	je	SHORT $LN2@fnSetAttri

; 4249 :    {
; 4250 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 4251 :       // "KZOEE239 - Invalid Operation for attribute type"
; 4252 :       fnIssueCoreError( lpTask, lpView, 8, 239, 0, lpViewEntity->szName,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4253 :                         lpViewAttrib->szName );
; 4254 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetAttri
$LN2@fnSetAttri:

; 4255 :    }
; 4256 : 
; 4257 :    // Get record to store into
; 4258 :    if ( lpViewAttrib->bPersist ) // is attribute persistent

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	je	SHORT $LN3@fnSetAttri

; 4259 :    {
; 4260 :       pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 4261 :       if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN5@fnSetAttri

; 4262 :       {
; 4263 :          fnCreateAttributeRecord( lpAllocTask,

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	push	eax
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH

; 4264 :                                   lpViewEntity, lpEntityInstance );
; 4265 :          pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 4266 :          if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN5@fnSetAttri

; 4267 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetAttri
$LN5@fnSetAttri:

; 4268 :       }
; 4269 :    }

	jmp	SHORT $LN4@fnSetAttri
$LN3@fnSetAttri:

; 4270 :    else
; 4271 :    {
; 4272 :       pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 4273 :       if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN4@fnSetAttri

; 4274 :       {
; 4275 :          lpEntityInstance->hNonPersistRecord =

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	push	eax
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 4276 :                      fnCreateAttributeRecord( lpAllocTask, lpViewEntity, 0 );
; 4277 :          pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 4278 :          if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN4@fnSetAttri

; 4279 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSetAttri
$LN4@fnSetAttri:

; 4280 :       }
; 4281 :    }
; 4282 : 
; 4283 :    // Set attrib from string.
; 4284 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 4285 :    bUpdated = FALSE;

	mov	BYTE PTR _bUpdated$[ebp], 0

; 4286 : 
; 4287 :    nRC = fnStoreBlobInRecord( lpAllocTask,      // so allocation can be done

	mov	edx, DWORD PTR _uBlobLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBlobValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+250]
	push	edx
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	push	ecx
	call	_fnStoreBlobInRecord
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 4288 :                               pchRecord,        // Attribute record
; 4289 :                               lpViewAttrib->ulRecordOffset,   // Offset
; 4290 :                               pBlobValue,       // Blob value to store
; 4291 :                               uBlobLth );       // Length to store
; 4292 :    // Check return code
; 4293 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN9@fnSetAttri

; 4294 :    {
; 4295 :       if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $LN9@fnSetAttri

; 4296 :       {
; 4297 :          bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1

; 4298 :          nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN9@fnSetAttri:

; 4299 :       }
; 4300 :    }
; 4301 : 
; 4302 :    // Set update indicator.
; 4303 :    fnSetUpdateIndicator( lpViewOI, lpEntityInstance, lpViewAttrib,

	push	1
	push	1
	movzx	edx, BYTE PTR _bUpdated$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H

; 4304 :                          bUpdated, TRUE, TRUE );
; 4305 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSetAttri:

; 4306 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetAttributeFromBlob ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pchPtr$ = -24						; size = 4
_lpTask$1 = -20						; size = 4
_lpEntityInstance$ = -16				; size = 4
_lpTask$2 = -12						; size = 4
_ulLth$ = -8						; size = 4
_nRC$ = -4						; size = 2
_pReturnBlob$ = 8					; size = 4
_pulMaxLth$ = 12					; size = 4
_lpView$ = 16						; size = 4
_lpViewEntityCsr$ = 20					; size = 4
_lpViewAttrib$ = 24					; size = 4
_fnGetBlobFromAttribute PROC

; 1440 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1441 :    zSHORT            nRC;
; 1442 :    LPENTITYINSTANCE  lpEntityInstance;
; 1443 :    zPCHAR            pchPtr;
; 1444 :    zULONG            ulLth;
; 1445 : 
; 1446 :    // Get Entity Instance pointer
; 1447 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1448 : 
; 1449 :    if ( lpViewAttrib->cType != zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	je	SHORT $LN2@fnGetBlobF

; 1450 :    {
; 1451 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 1452 :       // "KZOEE239 - Invalid Operation for attribute type"
; 1453 :       fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1454 :                         fnEntityNameFromCsr( lpViewEntityCsr ),
; 1455 :                         lpViewAttrib->szName );
; 1456 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetBlobF
$LN2@fnGetBlobF:

; 1457 :    }
; 1458 : 
; 1459 :    nRC = fnGetAttrAddrFromEntityInstance( &pchPtr, &ulLth, lpEntityInstance,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchPtr$[ebp]
	push	ecx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 1460 :                                           lpViewAttrib );
; 1461 : 
; 1462 :    // If a record exists, copy it to the return variable.
; 1463 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN3@fnGetBlobF

; 1464 :    {
; 1465 :       if ( ulLth > *pulMaxLth )

	mov	eax, DWORD PTR _pulMaxLth$[ebp]
	mov	ecx, DWORD PTR _ulLth$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LN5@fnGetBlobF

; 1466 :       {
; 1467 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 1468 : 
; 1469 :          TraceLine( "Binary large object length: %d   exceeds passed length: %d",

	mov	ecx, DWORD PTR _pulMaxLth$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	push	OFFSET $SG14996
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 1470 :                     ulLth, *pulMaxLth );
; 1471 :          // "KZOEE240 - Binary large object (Blob) exceeds passed "
; 1472 :          // "           length"
; 1473 :          fnIssueCoreError( lpTask, lpView, 8, 240, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	240					; 000000f0H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1474 :                            fnEntityNameFromCsr( lpViewEntityCsr ),
; 1475 :                            lpViewAttrib->szName );
; 1476 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnGetBlobF

; 1477 :       }

	jmp	SHORT $LN6@fnGetBlobF
$LN5@fnGetBlobF:

; 1478 :       else
; 1479 :       {
; 1480 :          *pulMaxLth = ulLth;

	mov	edx, DWORD PTR _pulMaxLth$[ebp]
	mov	eax, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR [edx], eax

; 1481 :          zmemcpy( pReturnBlob, pchPtr, (unsigned int) ulLth );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pReturnBlob$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN6@fnGetBlobF:

; 1482 :       }
; 1483 :    }

	jmp	SHORT $LN4@fnGetBlobF
$LN3@fnGetBlobF:

; 1484 :    else
; 1485 :    {
; 1486 :       *((zPVOID zFAR *) pReturnBlob) = 0;

	mov	ecx, DWORD PTR _pReturnBlob$[ebp]
	mov	DWORD PTR [ecx], 0

; 1487 :       *pulMaxLth = 0;

	mov	edx, DWORD PTR _pulMaxLth$[ebp]
	mov	DWORD PTR [edx], 0
$LN4@fnGetBlobF:

; 1488 :    }
; 1489 : 
; 1490 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnGetBlobF:

; 1491 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetBlobFromAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_ulLth$ = -36						; size = 4
_lpViewOI$ = -32					; size = 4
_lpTask$1 = -28						; size = 4
_lpTask$2 = -24						; size = 4
_lpEntityInstance$ = -20				; size = 4
tv146 = -16						; size = 4
tv83 = -12						; size = 4
_pchPtr$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpdReturnDecimal$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_fnGetDecimalFromAttribute PROC

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1279 :    LPENTITYINSTANCE  lpEntityInstance;
; 1280 :    zULONG            ulLth;
; 1281 :    zPCHAR            pchPtr;
; 1282 :    LPVIEWOI          lpViewOI;
; 1283 :    zSHORT            nRC;
; 1284 : 
; 1285 :    // Get Entity Instance pointer.
; 1286 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1287 :    lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1288 : 
; 1289 :    // Initialize return value to 0.
; 1290 :    SysConvertLongToDecimal( 0, lpdReturnDecimal );

	mov	ecx, DWORD PTR _lpdReturnDecimal$[ebp]
	push	ecx
	push	0
	call	_SysConvertLongToDecimal@8

; 1291 : 
; 1292 :    nRC = fnGetAttrAddrFromEntityInstance( &pchPtr, &ulLth, lpEntityInstance,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchPtr$[ebp]
	push	edx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 1293 :                                           lpViewAttrib );
; 1294 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN6@fnGetDecim

; 1295 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetDecim
$LN6@fnGetDecim:

; 1296 : 
; 1297 :    // If a value exists, copy it to the return variable.
; 1298 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN7@fnGetDecim

; 1299 :    {
; 1300 :       switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv83[ebp], al
	cmp	BYTE PTR tv83[ebp], 76			; 0000004cH
	je	SHORT $LN12@fnGetDecim
	cmp	BYTE PTR tv83[ebp], 77			; 0000004dH
	je	SHORT $LN13@fnGetDecim
	cmp	BYTE PTR tv83[ebp], 83			; 00000053H
	je	SHORT $LN9@fnGetDecim
	jmp	SHORT $LN14@fnGetDecim
$LN9@fnGetDecim:

; 1301 :       {
; 1302 :          case zTYPE_STRING:
; 1303 :             if ( pchPtr[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchPtr$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN10@fnGetDecim

; 1304 :                SysConvertStringToDecimal( pchPtr, lpdReturnDecimal );

	mov	edx, DWORD PTR _lpdReturnDecimal$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchPtr$[ebp]
	push	eax
	call	_SysConvertStringToDecimal@8
	jmp	SHORT $LN11@fnGetDecim
$LN10@fnGetDecim:

; 1305 :             else
; 1306 :                nRC = -1;   // indicate attribute null

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN11@fnGetDecim:

; 1307 : 
; 1308 :             break;

	jmp	SHORT $LN2@fnGetDecim
$LN12@fnGetDecim:

; 1309 : 
; 1310 :          case zTYPE_INTEGER:
; 1311 :             SysConvertLongToDecimal( *((zPLONG) pchPtr), lpdReturnDecimal );

	mov	edx, DWORD PTR _lpdReturnDecimal$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchPtr$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 1312 :             break;

	jmp	SHORT $LN2@fnGetDecim
$LN13@fnGetDecim:

; 1313 : 
; 1314 :          case zTYPE_DECIMAL:
; 1315 :             SysAssignDecimalFromDecimal( lpdReturnDecimal, (zPDECIMAL) pchPtr );

	mov	edx, DWORD PTR _pchPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdReturnDecimal$[ebp]
	push	eax
	call	_SysAssignDecimalFromDecimal@8

; 1316 :             break;

	jmp	SHORT $LN2@fnGetDecim
$LN14@fnGetDecim:

; 1317 : 
; 1318 :          default:
; 1319 :          {
; 1320 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 1321 :             // "KZOEE239 - Invalid Operation for attribute type"
; 1322 :             fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1323 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 1324 :                               lpViewAttrib->szName );
; 1325 :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnGetDecim:

; 1326 :          }
; 1327 :       }
; 1328 :    }

	jmp	SHORT $LN8@fnGetDecim
$LN7@fnGetDecim:

; 1329 :    else
; 1330 :    {
; 1331 :       switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv146[ebp], al
	cmp	BYTE PTR tv146[ebp], 76			; 0000004cH
	jl	SHORT $LN16@fnGetDecim
	cmp	BYTE PTR tv146[ebp], 77			; 0000004dH
	jle	SHORT $LN15@fnGetDecim
	cmp	BYTE PTR tv146[ebp], 83			; 00000053H
	je	SHORT $LN15@fnGetDecim
	jmp	SHORT $LN16@fnGetDecim
$LN15@fnGetDecim:

; 1332 :       {
; 1333 :          case zTYPE_STRING:
; 1334 :          case zTYPE_INTEGER:
; 1335 :          case zTYPE_DECIMAL:
; 1336 :             nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx

; 1337 :             break;

	jmp	SHORT $LN8@fnGetDecim
$LN16@fnGetDecim:

; 1338 : 
; 1339 :          default:
; 1340 :          {
; 1341 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 1342 :             // "KZOEE239 - Invalid Operation for attribute type"
; 1343 :             fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1344 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 1345 :                               lpViewAttrib->szName );
; 1346 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN8@fnGetDecim:

; 1347 :          }
; 1348 :       }
; 1349 :    }
; 1350 : 
; 1351 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnGetDecim:

; 1352 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetDecimalFromAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_ulLth$ = -92						; size = 4
_lpViewOI$ = -88					; size = 4
_lpTask$1 = -84						; size = 4
_lpTask$2 = -80						; size = 4
_lpTask$3 = -76						; size = 4
_lpTask$4 = -72						; size = 4
_lpEntityInstance$ = -68				; size = 4
tv178 = -64						; size = 4
_lpdDecimal$5 = -60					; size = 4
_pchPtr$ = -56						; size = 4
tv81 = -52						; size = 4
_nRC$ = -48						; size = 2
_dLong$6 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lplReturnInteger$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_fnGetIntegerFromAttribute PROC

; 1098 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1099 :    LPENTITYINSTANCE  lpEntityInstance;
; 1100 :    zPCHAR            pchPtr;
; 1101 :    LPVIEWOI          lpViewOI;
; 1102 :    zULONG            ulLth;
; 1103 :    zSHORT            nRC;
; 1104 : 
; 1105 :    *lplReturnInteger = 0;  // initialize return value to 0

	mov	eax, DWORD PTR _lplReturnInteger$[ebp]
	mov	DWORD PTR [eax], 0

; 1106 : 
; 1107 :    // Get Entity Instance pointer.
; 1108 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1109 :    lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1110 : 
; 1111 :    nRC = fnGetAttrAddrFromEntityInstance( &pchPtr, &ulLth, lpEntityInstance,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchPtr$[ebp]
	push	edx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 1112 :                                           lpViewAttrib );
; 1113 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN6@fnGetInteg

; 1114 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetInteg
$LN6@fnGetInteg:

; 1115 : 
; 1116 :    // If a value exists, copy it to the return variable.
; 1117 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN7@fnGetInteg

; 1118 :    {
; 1119 :       switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv81[ebp], al
	cmp	BYTE PTR tv81[ebp], 76			; 0000004cH
	je	SHORT $LN10@fnGetInteg
	cmp	BYTE PTR tv81[ebp], 77			; 0000004dH
	je	SHORT $LN11@fnGetInteg
	cmp	BYTE PTR tv81[ebp], 83			; 00000053H
	je	SHORT $LN9@fnGetInteg
	jmp	$LN16@fnGetInteg
$LN9@fnGetInteg:

; 1120 :       {
; 1121 :          case zTYPE_STRING:
; 1122 :             *lplReturnInteger = zatol( pchPtr );

	mov	ecx, DWORD PTR _pchPtr$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lplReturnInteger$[ebp]
	mov	DWORD PTR [edx], eax

; 1123 :             break;

	jmp	$LN2@fnGetInteg
$LN10@fnGetInteg:

; 1124 : 
; 1125 :          case zTYPE_INTEGER:
; 1126 :             *lplReturnInteger = *((zPLONG) pchPtr);

	mov	eax, DWORD PTR _lplReturnInteger$[ebp]
	mov	ecx, DWORD PTR _pchPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1127 :             break;

	jmp	$LN2@fnGetInteg
$LN11@fnGetInteg:

; 1128 : 
; 1129 :          case zTYPE_DECIMAL:
; 1130 :          {
; 1131 :             zPDECIMAL lpdDecimal;
; 1132 :             zDECIMAL  dLong;
; 1133 : 
; 1134 :             lpdDecimal = (zPDECIMAL) pchPtr;

	mov	eax, DWORD PTR _pchPtr$[ebp]
	mov	DWORD PTR _lpdDecimal$5[ebp], eax

; 1135 : 
; 1136 :             SysConvertLongToDecimal( LONG_MAX, &dLong );

	lea	ecx, DWORD PTR _dLong$6[ebp]
	push	ecx
	push	2147483647				; 7fffffffH
	call	_SysConvertLongToDecimal@8

; 1137 :             if ( SysCompareDecimalToDecimal( lpdDecimal, &dLong ) == 1 )

	lea	edx, DWORD PTR _dLong$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdDecimal$5[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	movsx	ecx, ax
	cmp	ecx, 1
	jne	SHORT $LN12@fnGetInteg

; 1138 :             {
; 1139 :                LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$4[ebp], eax

; 1140 :                //  "KZOEE235 - Integer overflow"
; 1141 :                fnIssueCoreError( lpTask, lpView, 16, 235, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	235					; 000000ebH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$4[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1142 :                                  fnEntityNameFromCsr( lpViewEntityCsr ),
; 1143 :                                  lpViewAttrib->szName );
; 1144 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 1145 :             }

	jmp	SHORT $LN13@fnGetInteg
$LN12@fnGetInteg:

; 1146 :             else
; 1147 :             {
; 1148 :                SysConvertLongToDecimal( LONG_MIN, &dLong );

	lea	eax, DWORD PTR _dLong$6[ebp]
	push	eax
	push	-2147483648				; 80000000H
	call	_SysConvertLongToDecimal@8

; 1149 :                if ( SysCompareDecimalToDecimal( lpdDecimal, &dLong ) == -1 )

	lea	ecx, DWORD PTR _dLong$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpdDecimal$5[ebp]
	push	edx
	call	_SysCompareDecimalToDecimal@8
	cwde
	cmp	eax, -1
	jne	SHORT $LN14@fnGetInteg

; 1150 :                {
; 1151 :                   LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 1152 :                   //  "KZOEE236 - Integer underflow"
; 1153 :                   fnIssueCoreError( lpTask, lpView, 16, 236, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	236					; 000000ecH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$3[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1154 :                                     fnEntityNameFromCsr( lpViewEntityCsr ),
; 1155 :                                     lpViewAttrib->szName );
; 1156 :                   nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 1157 :                }

	jmp	SHORT $LN13@fnGetInteg
$LN14@fnGetInteg:

; 1158 :                else
; 1159 :                {
; 1160 :                   SysConvertDecimalToLong( lpdDecimal, lplReturnInteger );

	mov	edx, DWORD PTR _lplReturnInteger$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdDecimal$5[ebp]
	push	eax
	call	_SysConvertDecimalToLong@8
$LN13@fnGetInteg:

; 1161 :                }
; 1162 :             }
; 1163 : 
; 1164 :             break;

	jmp	SHORT $LN2@fnGetInteg
$LN16@fnGetInteg:

; 1165 :          }
; 1166 : 
; 1167 :          default:
; 1168 :          {
; 1169 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 1170 :             // "KZOEE239 - Invalid Operation for attribute type"
; 1171 :             fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1172 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 1173 :                               lpViewAttrib->szName );
; 1174 :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnGetInteg:

; 1175 :          }
; 1176 :       }
; 1177 :    } // if ( nRC == 0 )...

	jmp	SHORT $LN8@fnGetInteg
$LN7@fnGetInteg:

; 1178 :    else
; 1179 :    {
; 1180 :       switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv178[ebp], al
	cmp	BYTE PTR tv178[ebp], 76			; 0000004cH
	jl	SHORT $LN18@fnGetInteg
	cmp	BYTE PTR tv178[ebp], 77			; 0000004dH
	jle	SHORT $LN17@fnGetInteg
	cmp	BYTE PTR tv178[ebp], 83			; 00000053H
	je	SHORT $LN17@fnGetInteg
	jmp	SHORT $LN18@fnGetInteg
$LN17@fnGetInteg:

; 1181 :       {
; 1182 :          case zTYPE_STRING:
; 1183 :          case zTYPE_INTEGER:
; 1184 :          case zTYPE_DECIMAL:
; 1185 :             nRC = -1;         // indicate null attribute

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx

; 1186 :             break;

	jmp	SHORT $LN8@fnGetInteg
$LN18@fnGetInteg:

; 1187 : 
; 1188 :          default:
; 1189 :          {
; 1190 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 1191 :             // "KZOEE239 - Invalid Operation for attribute type"
; 1192 :             fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1193 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 1194 :                               lpViewAttrib->szName );
; 1195 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN8@fnGetInteg:

; 1196 :          }
; 1197 :       }
; 1198 :    }
; 1199 : 
; 1200 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnGetInteg:

; 1201 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetIntegerFromAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -440					; size = 4
_lpTask$2 = -436					; size = 4
_lpEntityInstance$ = -432				; size = 4
_ulLth$ = -428						; size = 4
tv177 = -424						; size = 4
tv80 = -420						; size = 4
_nTempLth$3 = -416					; size = 2
_pchPtr$ = -412						; size = 4
_nRC$ = -408						; size = 2
_szTemp$4 = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_pchReturnString$ = 8					; size = 4
_ulMaxLth$ = 12						; size = 4
_lpView$ = 16						; size = 4
_lpViewEntityCsr$ = 20					; size = 4
_lpViewAttrib$ = 24					; size = 4
_cpcContextName$ = 28					; size = 4
_fnGetStringFromAttribute PROC

; 874  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 440				; 000001b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 875  :    LPENTITYINSTANCE  lpEntityInstance;
; 876  :    zPCHAR            pchPtr;
; 877  :    zULONG            ulLth;
; 878  :    zSHORT            nRC;
; 879  : 
; 880  :    pchReturnString[ 0 ] = 0; // initialize return value

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 881  :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 882  : 
; 883  :    // Get Entity Instance pointer.
; 884  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 885  : 
; 886  :    nRC = fnGetAttrAddrFromEntityInstance( &pchPtr, &ulLth, lpEntityInstance,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchPtr$[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 887  :                                           lpViewAttrib );
; 888  :    if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN6@fnGetStrin

; 889  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetStrin
$LN6@fnGetStrin:

; 890  : 
; 891  :    // If a value exists, copy it to the return variable.
; 892  :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN7@fnGetStrin

; 893  :    {
; 894  :       zCHAR szTemp[ 400 ];
; 895  : 
; 896  :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv80[ebp], ecx
	mov	edx, DWORD PTR tv80[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv80[ebp], edx
	cmp	DWORD PTR tv80[ebp], 18			; 00000012H
	ja	$LN22@fnGetStrin
	mov	eax, DWORD PTR tv80[ebp]
	movzx	ecx, BYTE PTR $LN26@fnGetStrin[eax]
	jmp	DWORD PTR $LN28@fnGetStrin[ecx*4]
$LN9@fnGetStrin:

; 897  :       {
; 898  :          case zTYPE_STRING:
; 899  :          {
; 900  :             if ( ulMaxLth == 0 )

	cmp	DWORD PTR _ulMaxLth$[ebp], 0
	jne	SHORT $LN10@fnGetStrin

; 901  :                zstrcpy( pchReturnString, pchPtr );

	mov	edx, DWORD PTR _pchPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN11@fnGetStrin
$LN10@fnGetStrin:

; 902  :             else
; 903  :             {
; 904  :                pchReturnString[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 905  : 
; 906  :                // DKS 1997.10.14: get string of correct length
; 907  :                zstrncat( pchReturnString, pchPtr, (unsigned int) ulMaxLth - 1 );

	mov	ecx, DWORD PTR _ulMaxLth$[ebp]
	sub	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _pchPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
$LN11@fnGetStrin:

; 908  : //             pchReturnString[ ulMaxLth - 1 ] = 0;
; 909  :             }
; 910  : 
; 911  :             break;

	jmp	$LN2@fnGetStrin
$LN12@fnGetStrin:

; 912  :          }
; 913  : 
; 914  :          case zTYPE_INTEGER:
; 915  :             if ( ulMaxLth == 0 )

	cmp	DWORD PTR _ulMaxLth$[ebp], 0
	jne	SHORT $LN13@fnGetStrin

; 916  :                zltoa( *((zPLONG) pchPtr), pchReturnString );

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN14@fnGetStrin
$LN13@fnGetStrin:

; 917  :             else
; 918  :             {
; 919  :                pchReturnString[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 920  :                zltoa( *((zPLONG) pchPtr), szTemp );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _szTemp$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 921  :                zstrncat( pchReturnString, szTemp, (unsigned int) ulMaxLth - 1 );

	mov	ecx, DWORD PTR _ulMaxLth$[ebp]
	sub	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _szTemp$4[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
$LN14@fnGetStrin:

; 922  :             }
; 923  : 
; 924  :             break;

	jmp	$LN2@fnGetStrin
$LN15@fnGetStrin:

; 925  : 
; 926  :          case zTYPE_DECIMAL:
; 927  :             if ( ulMaxLth == 0 )

	cmp	DWORD PTR _ulMaxLth$[ebp], 0
	jne	SHORT $LN16@fnGetStrin

; 928  :             {
; 929  :                ConvertDecimalToString( pchReturnString, lpViewAttrib,

	push	0
	mov	esi, DWORD PTR _pchPtr$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	call	_ConvertDecimalToString@52

; 930  :                                        *((zPDECIMAL) pchPtr), 0 );
; 931  :             }

	jmp	SHORT $LN17@fnGetStrin
$LN16@fnGetStrin:

; 932  :             else
; 933  :             {
; 934  :                pchReturnString[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 935  :                ConvertDecimalToString( szTemp, lpViewAttrib,

	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	esi, DWORD PTR _pchPtr$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTemp$4[ebp]
	push	edx
	call	_ConvertDecimalToString@52

; 936  :                                        *((zPDECIMAL) pchPtr), cpcContextName );
; 937  :                zstrncat( pchReturnString, szTemp, (unsigned int) ulMaxLth - 1 );

	mov	eax, DWORD PTR _ulMaxLth$[ebp]
	sub	eax, 1
	push	eax
	lea	ecx, DWORD PTR _szTemp$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
$LN17@fnGetStrin:

; 938  :             }
; 939  : 
; 940  :             break;

	jmp	$LN2@fnGetStrin
$LN18@fnGetStrin:

; 941  : 
; 942  :          case zTYPE_DATETIME:
; 943  :          {
; 944  :             zSHORT nTempLth;
; 945  : 
; 946  :             if ( ulMaxLth > 100 )

	cmp	DWORD PTR _ulMaxLth$[ebp], 100		; 00000064H
	jbe	SHORT $LN19@fnGetStrin

; 947  :                nTempLth = 100;

	mov	eax, 100				; 00000064H
	mov	WORD PTR _nTempLth$3[ebp], ax
	jmp	SHORT $LN20@fnGetStrin
$LN19@fnGetStrin:

; 948  :             else
; 949  :                nTempLth = (zSHORT) ulMaxLth;

	mov	cx, WORD PTR _ulMaxLth$[ebp]
	mov	WORD PTR _nTempLth$3[ebp], cx
$LN20@fnGetStrin:

; 950  : 
; 951  :             nRC = UfDateTimeToString( (LPDATETIME) pchPtr,

	movzx	edx, WORD PTR _nTempLth$3[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchPtr$[ebp]
	push	ecx
	call	_UfDateTimeToString@12
	mov	WORD PTR _nRC$[ebp], ax

; 952  :                                       pchReturnString, nTempLth );
; 953  :             break;

	jmp	SHORT $LN2@fnGetStrin
$LN21@fnGetStrin:

; 954  :          }
; 955  : 
; 956  :          case zTYPE_BLOB:
; 957  :             // Copy memory from blob to string buffer.
; 958  :             zmemcpy( pchReturnString, pchPtr, (unsigned int) ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 959  : 
; 960  :             // Make sure buffer has null-terminator.
; 961  :             pchReturnString[ ulLth ] = 0;

	mov	edx, DWORD PTR _pchReturnString$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx], 0

; 962  :             break;

	jmp	SHORT $LN2@fnGetStrin
$LN22@fnGetStrin:

; 963  : 
; 964  :          default:
; 965  :          {
; 966  :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 967  : 
; 968  :             // "KZOEE239 - Invalid Operation for attribute type"
; 969  :             fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 970  :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 971  :                               lpViewAttrib->szName );
; 972  :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN2@fnGetStrin:

; 973  :          }
; 974  :       }
; 975  :    }

	jmp	$LN8@fnGetStrin
$LN7@fnGetStrin:

; 976  :    else
; 977  :    {
; 978  :       switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv177[ebp], edx
	mov	eax, DWORD PTR tv177[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv177[ebp], eax
	cmp	DWORD PTR tv177[ebp], 18		; 00000012H
	ja	SHORT $LN24@fnGetStrin
	mov	ecx, DWORD PTR tv177[ebp]
	movzx	edx, BYTE PTR $LN27@fnGetStrin[ecx]
	jmp	DWORD PTR $LN29@fnGetStrin[edx*4]
$LN23@fnGetStrin:

; 979  :       {
; 980  :          case zTYPE_STRING:
; 981  :          case zTYPE_INTEGER:
; 982  :          case zTYPE_DECIMAL:
; 983  :          case zTYPE_DATETIME:
; 984  :          case zTYPE_BLOB:
; 985  :             nRC = -1;   // indicate null attribute

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax

; 986  :             break;

	jmp	SHORT $LN8@fnGetStrin
$LN24@fnGetStrin:

; 987  : 
; 988  :          default:
; 989  :          {
; 990  :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 991  :             // "KZOEE239 - Invalid Operation for attribute type"
; 992  :             fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 993  :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 994  :                               lpViewAttrib->szName );
; 995  :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN8@fnGetStrin:

; 996  :          }
; 997  :       }
; 998  :    }
; 999  : 
; 1000 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnGetStrin:

; 1001 : 
; 1002 : } // fnGetStringFromAttribute

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN28@fnGetStrin:
	DD	$LN21@fnGetStrin
	DD	$LN12@fnGetStrin
	DD	$LN15@fnGetStrin
	DD	$LN9@fnGetStrin
	DD	$LN18@fnGetStrin
	DD	$LN22@fnGetStrin
$LN26@fnGetStrin:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
	npad	1
$LN29@fnGetStrin:
	DD	$LN23@fnGetStrin
	DD	$LN24@fnGetStrin
$LN27@fnGetStrin:
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
	DB	1
	DB	1
	DB	1
	DB	1
	DB	1
	DB	0
	DB	0
_fnGetStringFromAttribute ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -64					; size = 4
_lpDateTimeInput$1 = -60				; size = 4
_lpdDecimalInput$2 = -56				; size = 4
_lplLongInput$3 = -52					; size = 4
_pchAttribValue$ = -48					; size = 4
_ulLth$ = -44						; size = 4
_lpAllocTask$ = -40					; size = 4
_lpdDecimal$4 = -36					; size = 4
_lplLong$5 = -32					; size = 4
tv131 = -28						; size = 4
_lpDateTime$6 = -24					; size = 4
_pchRecord$ = -20					; size = 4
_k$7 = -16						; size = 2
_k$8 = -12						; size = 2
_nRC$ = -8						; size = 2
_bUpdated$ = -1						; size = 1
_lpEntityInstance$ = 8					; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttribute$ = 16					; size = 4
_lpValue$ = 20						; size = 4
_ulLength$ = 24						; size = 4
_fnStoreValueInEntityInstance PROC

; 527  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 528  :    zBOOL        bUpdated;
; 529  :    zPCHAR       pchRecord;
; 530  :    LPVIEWOI     lpViewOI;
; 531  :    LPTASK       lpAllocTask;
; 532  :    zULONG       ulLth;
; 533  :    zPCHAR       pchAttribValue;
; 534  :    zSHORT       nRC;
; 535  : 
; 536  :    lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 537  : 
; 538  :    // Get Task owning the view object instance
; 539  :    lpAllocTask = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 540  : 
; 541  :    // Get record to store into
; 542  :    if ( lpViewAttribute->bPersist ) // is attribute persistent

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	je	SHORT $LN4@fnStoreVal

; 543  :    {
; 544  :       pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 545  :       if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN6@fnStoreVal

; 546  :       {
; 547  :          fnCreateAttributeRecord( lpAllocTask,

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	push	ecx
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH

; 548  :                                   lpViewEntity, lpEntityInstance );
; 549  :          pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 550  :          if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN6@fnStoreVal

; 551  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnStoreVal
$LN6@fnStoreVal:

; 552  :       }
; 553  :    }

	jmp	SHORT $LN5@fnStoreVal
$LN4@fnStoreVal:

; 554  :    else
; 555  :    {
; 556  :       pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 557  :       if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN5@fnStoreVal

; 558  :       {
; 559  :          lpEntityInstance->hNonPersistRecord =

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	push	ecx
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+64], eax

; 560  :                      fnCreateAttributeRecord( lpAllocTask, lpViewEntity, 0 );
; 561  :          pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 562  :          if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN5@fnStoreVal

; 563  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnStoreVal
$LN5@fnStoreVal:

; 564  :       }
; 565  :       else
; 566  :       {
; 567  :          // dks 2004.09.30 ... not persistent, so should always be updated.
; 568  :          // dks 2004.09.30 ... not sure this is needed so will comment out for now.
; 569  :       // *(pchRecord + lpViewAttribute->ulRecordOffset) = 0;
; 570  :       }
; 571  :    }
; 572  : 
; 573  :    // Set attrib from string.
; 574  :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 575  :    bUpdated = FALSE;

	mov	BYTE PTR _bUpdated$[ebp], 0

; 576  : 
; 577  :    switch ( lpViewAttribute->cType )

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv131[ebp], ecx
	mov	edx, DWORD PTR tv131[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv131[ebp], edx
	cmp	DWORD PTR tv131[ebp], 18		; 00000012H
	ja	$LN37@fnStoreVal
	mov	eax, DWORD PTR tv131[ebp]
	movzx	ecx, BYTE PTR $LN39@fnStoreVal[eax]
	jmp	DWORD PTR $LN40@fnStoreVal[ecx*4]
$LN11@fnStoreVal:

; 578  :    {
; 579  :       case zTYPE_STRING:
; 580  :       {
; 581  :          zSHORT k;
; 582  : 
; 583  :          if ( (zPCHAR) lpValue )

	cmp	DWORD PTR _lpValue$[ebp], 0
	je	SHORT $LN12@fnStoreVal

; 584  :             pchAttribValue = (zPCHAR) lpValue;

	mov	edx, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _pchAttribValue$[ebp], edx
	jmp	SHORT $LN13@fnStoreVal
$LN12@fnStoreVal:

; 585  :          else
; 586  :             pchAttribValue = szNullS;

	mov	eax, DWORD PTR _szNullS
	mov	DWORD PTR _pchAttribValue$[ebp], eax
$LN13@fnStoreVal:

; 587  : 
; 588  :          ulLth = zstrlen( pchAttribValue );

	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 589  : 
; 590  :          // truncate string if necessary
; 591  :          if ( ulLth >= lpViewAttribute->ulLth )

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	eax, DWORD PTR _ulLth$[ebp]
	cmp	eax, DWORD PTR [edx+203]
	jb	SHORT $LN14@fnStoreVal

; 592  :             ulLth = lpViewAttribute->ulLth - 1;      // subtract 1 for null

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR [ecx+203]
	sub	edx, 1
	mov	DWORD PTR _ulLth$[ebp], edx
$LN14@fnStoreVal:

; 593  : 
; 594  :          k = fnStoreStringInRecord( lpAllocTask, // so allocation can be done

	push	1
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	eax, DWORD PTR [edx+250]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAllocTask$[ebp]
	push	edx
	call	_fnStoreStringInRecord
	add	esp, 24					; 00000018H
	mov	WORD PTR _k$8[ebp], ax

; 595  :                                     pchRecord,       // Attribute record
; 596  :                                     lpViewAttribute->ulRecordOffset,   // Offset
; 597  :                                     pchAttribValue,  // Attribute value to store
; 598  :                                     ulLth,           // Maximum length to store
; 599  :                                     1 );             // Null terminate data
; 600  :          // Check return code
; 601  :          if ( k )

	movsx	eax, WORD PTR _k$8[ebp]
	test	eax, eax
	je	SHORT $LN15@fnStoreVal

; 602  :          {
; 603  :             if ( k == 1 )

	movsx	ecx, WORD PTR _k$8[ebp]
	cmp	ecx, 1
	jne	SHORT $LN16@fnStoreVal

; 604  :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
	jmp	SHORT $LN15@fnStoreVal
$LN16@fnStoreVal:

; 605  :             else
; 606  :                nRC = k;

	mov	dx, WORD PTR _k$8[ebp]
	mov	WORD PTR _nRC$[ebp], dx
$LN15@fnStoreVal:

; 607  :          }
; 608  : 
; 609  :          break;

	jmp	$LN2@fnStoreVal
$LN18@fnStoreVal:

; 610  :       }
; 611  : 
; 612  :       case zTYPE_INTEGER:
; 613  :       {
; 614  :          zPLONG   lplLong;
; 615  :          zPLONG   lplLongInput;
; 616  : 
; 617  :          lplLongInput = (zPLONG) lpValue;

	mov	eax, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _lplLongInput$3[ebp], eax

; 618  :          lplLong = (zPLONG) (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lplLong$5[ebp], edx

; 619  :          if ( *lplLongInput == lNullInteger )

	mov	eax, DWORD PTR _lplLongInput$3[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN19@fnStoreVal

; 620  :          {
; 621  :             if ( *lplLong != lNullInteger )

	mov	edx, DWORD PTR _lplLong$5[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	je	SHORT $LN21@fnStoreVal

; 622  :             {
; 623  :                *lplLong = lNullInteger;

	mov	ecx, DWORD PTR _lplLong$5[ebp]
	mov	edx, DWORD PTR _lNullInteger
	mov	DWORD PTR [ecx], edx

; 624  :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN21@fnStoreVal:

; 625  :             }
; 626  :          }

	jmp	SHORT $LN20@fnStoreVal
$LN19@fnStoreVal:

; 627  :          else
; 628  :          if ( *lplLong != *lplLongInput )

	mov	eax, DWORD PTR _lplLong$5[ebp]
	mov	ecx, DWORD PTR _lplLongInput$3[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN20@fnStoreVal

; 629  :          {
; 630  :             *lplLong = *lplLongInput;

	mov	eax, DWORD PTR _lplLong$5[ebp]
	mov	ecx, DWORD PTR _lplLongInput$3[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 631  :             bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN20@fnStoreVal:

; 632  :          }
; 633  : 
; 634  :          break;

	jmp	$LN2@fnStoreVal
$LN23@fnStoreVal:

; 635  :       }
; 636  : 
; 637  :       case zTYPE_DECIMAL:
; 638  :       {
; 639  :          zPDECIMAL lpdDecimal;
; 640  :          zPDECIMAL lpdDecimalInput;
; 641  : 
; 642  :          lpdDecimalInput = (zPDECIMAL) lpValue;

	mov	eax, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _lpdDecimalInput$2[ebp], eax

; 643  :          lpdDecimal = (zPDECIMAL) (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lpdDecimal$4[ebp], edx

; 644  :          if ( SysCompareDecimalToNull( lpdDecimalInput ) == 0 )

	mov	eax, DWORD PTR _lpdDecimalInput$2[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN24@fnStoreVal

; 645  :          {
; 646  :             if ( SysCompareDecimalToNull( lpdDecimal ) != 0 )

	mov	edx, DWORD PTR _lpdDecimal$4[ebp]
	push	edx
	call	_SysCompareDecimalToNull@4
	cwde
	test	eax, eax
	je	SHORT $LN26@fnStoreVal

; 647  :             {
; 648  :                SysAssignDecimalFromNull( lpdDecimal );

	mov	ecx, DWORD PTR _lpdDecimal$4[ebp]
	push	ecx
	call	_SysAssignDecimalFromNull@4

; 649  :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN26@fnStoreVal:

; 650  :             }
; 651  :          }

	jmp	SHORT $LN25@fnStoreVal
$LN24@fnStoreVal:

; 652  :          else
; 653  :          if ( SysCompareDecimalToDecimal( lpdDecimal, lpdDecimalInput ) != 0 )

	mov	edx, DWORD PTR _lpdDecimalInput$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdDecimal$4[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN25@fnStoreVal

; 654  :          {
; 655  :             SysAssignDecimalFromDecimal( lpdDecimal, lpdDecimalInput );

	mov	edx, DWORD PTR _lpdDecimalInput$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdDecimal$4[ebp]
	push	eax
	call	_SysAssignDecimalFromDecimal@8

; 656  :             bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN25@fnStoreVal:

; 657  :          }
; 658  : 
; 659  :          break;

	jmp	$LN2@fnStoreVal
$LN28@fnStoreVal:

; 660  :       }
; 661  : 
; 662  :       case zTYPE_BLOB:
; 663  :       {
; 664  :          zSHORT k;
; 665  : 
; 666  :          k = fnStoreBlobInRecord( lpAllocTask, // so allocation can be done

	mov	ecx, DWORD PTR _ulLength$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	ecx, DWORD PTR [eax+250]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	push	eax
	call	_fnStoreBlobInRecord
	add	esp, 20					; 00000014H
	mov	WORD PTR _k$7[ebp], ax

; 667  :                                   pchRecord,       // Attribute record
; 668  :                                   lpViewAttribute->ulRecordOffset, // Offset
; 669  :                                   lpValue,        // Blob value to store
; 670  :                                   ulLength );     // Length to store
; 671  :          // Check return code
; 672  :          if ( k )

	movsx	ecx, WORD PTR _k$7[ebp]
	test	ecx, ecx
	je	SHORT $LN29@fnStoreVal

; 673  :          {
; 674  :             if ( k == 1 )

	movsx	edx, WORD PTR _k$7[ebp]
	cmp	edx, 1
	jne	SHORT $LN30@fnStoreVal

; 675  :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
	jmp	SHORT $LN29@fnStoreVal
$LN30@fnStoreVal:

; 676  :             else
; 677  :                nRC = k;

	mov	ax, WORD PTR _k$7[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN29@fnStoreVal:

; 678  :          }
; 679  : 
; 680  :          break;

	jmp	SHORT $LN2@fnStoreVal
$LN32@fnStoreVal:

; 681  :       }
; 682  : 
; 683  :       case zTYPE_DATETIME:
; 684  :       {
; 685  :          LPDTINTERNAL  lpDateTime;
; 686  :          LPDTINTERNAL  lpDateTimeInput;
; 687  : 
; 688  :          lpDateTimeInput = (LPDTINTERNAL) lpValue;

	mov	ecx, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _lpDateTimeInput$1[ebp], ecx

; 689  :          lpDateTime = (LPDTINTERNAL)

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpDateTime$6[ebp], eax

; 690  :                               (pchRecord + lpViewAttribute->ulRecordOffset);
; 691  :          if ( lpDateTimeInput->ulDateMinutes == (zULONG) lNullInteger )

	mov	ecx, DWORD PTR _lpDateTimeInput$1[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	jne	SHORT $LN33@fnStoreVal

; 692  :          {
; 693  :             if ( lpDateTime->ulDateMinutes != (zULONG) lNullInteger )

	mov	eax, DWORD PTR _lpDateTime$6[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	je	SHORT $LN35@fnStoreVal

; 694  :             {
; 695  :                lpDateTime->ulDateMinutes = (zULONG) lNullInteger;

	mov	edx, DWORD PTR _lpDateTime$6[ebp]
	mov	eax, DWORD PTR _lNullInteger
	mov	DWORD PTR [edx], eax

; 696  :                lpDateTime->usTSeconds = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _lpDateTime$6[ebp]
	mov	WORD PTR [edx+4], cx

; 697  :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN35@fnStoreVal:

; 698  :             }
; 699  :          }

	jmp	SHORT $LN34@fnStoreVal
$LN33@fnStoreVal:

; 700  :          else
; 701  :          if ( zmemcmp( lpDateTime, lpDateTimeInput,
; 702  :                        sizeof( DateTimeRecord ) ) != 0 )

	push	6
	mov	eax, DWORD PTR _lpDateTimeInput$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDateTime$6[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN34@fnStoreVal

; 703  :          {
; 704  :             zmemcpy( lpDateTime, lpDateTimeInput, sizeof( DateTimeRecord ) );

	push	6
	mov	edx, DWORD PTR _lpDateTimeInput$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDateTime$6[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 705  :             bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN34@fnStoreVal:

; 706  :          }
; 707  : 
; 708  :          break;

	jmp	SHORT $LN2@fnStoreVal
$LN37@fnStoreVal:

; 709  :       }
; 710  : 
; 711  :       default:
; 712  :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnStoreVal:

; 713  :    }
; 714  : 
; 715  :    // Set update indicator.
; 716  :    fnSetUpdateIndicator( lpViewOI, lpEntityInstance, lpViewAttribute,

	push	1
	push	1
	movzx	edx, BYTE PTR _bUpdated$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H

; 717  :                          bUpdated, TRUE, TRUE );
; 718  : 
; 719  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnStoreVal:

; 720  : } // fnStoreValueInEntityInstance

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN40@fnStoreVal:
	DD	$LN28@fnStoreVal
	DD	$LN18@fnStoreVal
	DD	$LN23@fnStoreVal
	DD	$LN11@fnStoreVal
	DD	$LN32@fnStoreVal
	DD	$LN37@fnStoreVal
$LN39@fnStoreVal:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnStoreValueInEntityInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -44					; size = 4
_lpuLong$1 = -40					; size = 4
_lpuLong$2 = -36					; size = 4
_lpExternalP$3 = -32					; size = 4
tv88 = -28						; size = 4
_lpExternalP$4 = -24					; size = 4
_pchBlob$5 = -20					; size = 4
tv73 = -16						; size = 4
_pchRecord$ = -12					; size = 4
_pchRecordString$6 = -8					; size = 4
_nRC$ = -4						; size = 2
_lpReturnAddr$ = 8					; size = 4
_pulReturnLth$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_lpViewAttribute$ = 20					; size = 4
_fnGetAttrAddrFromEntityInstance PROC

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 230  :    zPCHAR   pchRecord;
; 231  :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 232  :    zSHORT   nRC;
; 233  : 
; 234  :    // Get record to retrieve from.
; 235  :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttribute );

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 236  : 
; 237  :    if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN4@fnGetAttrA

; 238  :    {
; 239  :       *lpReturnAddr = 0;

	mov	ecx, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [ecx], 0

; 240  :       *pulReturnLth = 0;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], 0

; 241  :       nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax

; 242  :    }

	jmp	$LN5@fnGetAttrA
$LN4@fnGetAttrA:

; 243  :    else
; 244  :    {
; 245  :       switch ( lpViewAttribute->cType )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv73[ebp], edx
	mov	eax, DWORD PTR tv73[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv73[ebp], eax
	cmp	DWORD PTR tv73[ebp], 18			; 00000012H
	ja	$LN21@fnGetAttrA
	mov	ecx, DWORD PTR tv73[ebp]
	movzx	edx, BYTE PTR $LN25@fnGetAttrA[ecx]
	jmp	DWORD PTR $LN26@fnGetAttrA[edx*4]
$LN6@fnGetAttrA:

; 246  :       {
; 247  :          case zTYPE_STRING:
; 248  :          {
; 249  :             zPCHAR   pchRecordString;
; 250  :             zCOREMEM lpExternalP;
; 251  :             zPULONG  lpuLong;
; 252  : 
; 253  :             pchRecordString = pchRecord + lpViewAttribute->ulRecordOffset;

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _pchRecordString$6[ebp], ecx

; 254  :             if ( pchRecordString[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecordString$6[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN7@fnGetAttrA

; 255  :             {
; 256  :                lpExternalP = (zCOREMEM) (pchRecordString + 1);

	mov	eax, DWORD PTR _pchRecordString$6[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$4[ebp], eax

; 257  :                lpuLong = (zPULONG) (lpExternalP + 1);

	mov	ecx, DWORD PTR _lpExternalP$4[ebp]
	add	ecx, 4
	mov	DWORD PTR _lpuLong$2[ebp], ecx

; 258  :                *pulReturnLth = *lpuLong;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	eax, DWORD PTR _lpuLong$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 259  :                pchRecordString = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$4[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecordString$6[ebp], eax

; 260  :                *lpReturnAddr = pchRecordString;

	mov	ecx, DWORD PTR _lpReturnAddr$[ebp]
	mov	edx, DWORD PTR _pchRecordString$6[ebp]
	mov	DWORD PTR [ecx], edx

; 261  :             }

	jmp	SHORT $LN8@fnGetAttrA
$LN7@fnGetAttrA:

; 262  :             else
; 263  :             {
; 264  :                *lpReturnAddr = pchRecordString;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	ecx, DWORD PTR _pchRecordString$6[ebp]
	mov	DWORD PTR [eax], ecx

; 265  :                *pulReturnLth = zstrlen( pchRecordString ) + 1;

	mov	edx, DWORD PTR _pchRecordString$6[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], eax
$LN8@fnGetAttrA:

; 266  :             }
; 267  : 
; 268  :             nRC = (*pulReturnLth == 1) ? -1 : 0;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	cmp	DWORD PTR [edx], 1
	jne	SHORT $LN23@fnGetAttrA
	mov	DWORD PTR tv88[ebp], -1
	jmp	SHORT $LN24@fnGetAttrA
$LN23@fnGetAttrA:
	mov	DWORD PTR tv88[ebp], 0
$LN24@fnGetAttrA:
	mov	ax, WORD PTR tv88[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 269  :             break;

	jmp	$LN5@fnGetAttrA
$LN9@fnGetAttrA:

; 270  :          }
; 271  : 
; 272  :          case zTYPE_INTEGER:
; 273  :             *lpReturnAddr = (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [eax], edx

; 274  :             *pulReturnLth = 0;

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], 0

; 275  :             if ( *(zPLONG) *(zPLONG zFAR *) lpReturnAddr == lNullInteger )

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN10@fnGetAttrA

; 276  :                nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN11@fnGetAttrA
$LN10@fnGetAttrA:

; 277  :             else
; 278  :                nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN11@fnGetAttrA:

; 279  : 
; 280  :             break;

	jmp	$LN5@fnGetAttrA
$LN12@fnGetAttrA:

; 281  : 
; 282  :          case zTYPE_DECIMAL:
; 283  :             *lpReturnAddr = (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [eax], edx

; 284  :             *pulReturnLth = sizeof( zDECIMAL );

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], 40			; 00000028H

; 285  :             if ( SysCompareDecimalToNull( *((zPPDECIMAL) lpReturnAddr) ) == 0 )

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN13@fnGetAttrA

; 286  :                nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN14@fnGetAttrA
$LN13@fnGetAttrA:

; 287  :             else
; 288  :                nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN14@fnGetAttrA:

; 289  : 
; 290  :             break;

	jmp	$LN5@fnGetAttrA
$LN15@fnGetAttrA:

; 291  : 
; 292  :          case zTYPE_BLOB:
; 293  :          {
; 294  :             zPCHAR   pchBlob;
; 295  :             zCOREMEM lpExternalP;
; 296  :             zPULONG  lpuLong;
; 297  : 
; 298  :             pchBlob = pchRecord + lpViewAttribute->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchBlob$5[ebp], edx

; 299  :             if ( pchBlob[ 0 ] == (zCHAR) '\xff' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchBlob$5[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	SHORT $LN16@fnGetAttrA

; 300  :             {
; 301  :                lpExternalP = (zCOREMEM) (pchBlob + 1);

	mov	ecx, DWORD PTR _pchBlob$5[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$3[ebp], ecx

; 302  :                lpuLong = (zPULONG) (lpExternalP + 1);

	mov	edx, DWORD PTR _lpExternalP$3[ebp]
	add	edx, 4
	mov	DWORD PTR _lpuLong$1[ebp], edx

; 303  :                *pulReturnLth = *lpuLong;

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	ecx, DWORD PTR _lpuLong$1[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 304  :                pchBlob = zGETPTR( *lpExternalP );

	mov	eax, DWORD PTR _lpExternalP$3[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchBlob$5[ebp], eax

; 305  :                *lpReturnAddr = pchBlob;

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	eax, DWORD PTR _pchBlob$5[ebp]
	mov	DWORD PTR [edx], eax

; 306  :                nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 307  :             }

	jmp	SHORT $LN17@fnGetAttrA
$LN16@fnGetAttrA:

; 308  :             else
; 309  :             {
; 310  :                *pulReturnLth = 0;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], 0

; 311  :                nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
$LN17@fnGetAttrA:

; 312  :             }
; 313  : 
; 314  :             break;

	jmp	SHORT $LN5@fnGetAttrA
$LN18@fnGetAttrA:

; 315  :          }
; 316  : 
; 317  :          case zTYPE_DATETIME:
; 318  :             *lpReturnAddr = (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [eax], edx

; 319  :             *pulReturnLth = sizeof( DateTimeRecord );

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], 6

; 320  :             if ( fnCompareDateTimeToDateTime(
; 321  :                            *((LPDTINTERNAL zFAR *) lpReturnAddr),
; 322  :                            (LPDTINTERNAL) &stNullDateTime ) == 0 )

	push	OFFSET _stNullDateTime
	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN19@fnGetAttrA

; 323  :                nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN20@fnGetAttrA
$LN19@fnGetAttrA:

; 324  :             else
; 325  :                nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN20@fnGetAttrA:

; 326  :             break;

	jmp	SHORT $LN5@fnGetAttrA
$LN21@fnGetAttrA:

; 327  : 
; 328  :          default:
; 329  :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN5@fnGetAttrA:

; 330  : 
; 331  :       } // switch ( lpViewAttribute->cType )...
; 332  :    } // if ( pchRecord == 0 )...else...
; 333  : 
; 334  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 335  : 
; 336  : } // fnGetAttrAddrFromEntityInstance

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN26@fnGetAttrA:
	DD	$LN15@fnGetAttrA
	DD	$LN9@fnGetAttrA
	DD	$LN12@fnGetAttrA
	DD	$LN6@fnGetAttrA
	DD	$LN18@fnGetAttrA
	DD	$LN21@fnGetAttrA
$LN25@fnGetAttrA:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnGetAttrAddrFromEntityInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -40					; size = 4
_lpNextVsn$1 = -36					; size = 4
_lpTempEI$2 = -32					; size = 4
_lpViewCsr$ = -28					; size = 4
_lpVsnInstance$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_lpEntityInstance$ = -4					; size = 4
_lpReturnTask$ = 8					; size = 4
_pvReturnViewEntity$ = 12				; size = 4
_pvReturnViewEntityCsr$ = 16				; size = 4
_pvReturnViewAttrib$ = 20				; size = 4
_iOperationID$ = 24					; size = 2
_bUpdate$ = 28						; size = 2
_lpView$ = 32						; size = 4
_cpcEntityName$ = 36					; size = 4
_cpcAttributeName$ = 40					; size = 4
_nFlag$ = 44						; size = 2
_fnValidateAttributeParameters PROC

; 6489 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 6490 :    LPTASK            lpCurrentTask;
; 6491 :    LPVIEWOI          lpViewOI;
; 6492 :    LPVIEWCSR         lpViewCsr;
; 6493 :    LPVIEWENTITY      lpViewEntity;
; 6494 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 6495 :    LPVIEWATTRIB      lpViewAttrib;
; 6496 :    LPENTITYINSTANCE  lpEntityInstance;
; 6497 :    LPENTITYINSTANCE  lpVsnInstance;
; 6498 : 
; 6499 :    if ( nFlag & zUSE_TASK ) // Oper id already passed

	movsx	eax, WORD PTR _nFlag$[ebp]
	and	eax, 4096				; 00001000H
	je	SHORT $LN17@fnValidate

; 6500 :    {
; 6501 :       lpCurrentTask = *lpReturnTask;

	mov	ecx, DWORD PTR _lpReturnTask$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpCurrentTask$[ebp], edx

; 6502 :       if ( fnValidViewCsr( lpCurrentTask, lpView ) == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN19@fnValidate

; 6503 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN19@fnValidate:

; 6504 :    }

	jmp	SHORT $LN18@fnValidate
$LN17@fnValidate:

; 6505 :    else
; 6506 :    {
; 6507 :       // If task not active or disabled, or view csr invalid, return 1.
; 6508 :       if ( (lpCurrentTask = fnOperationCall( iOperationID, lpView,
; 6509 :                                              zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	movzx	ecx, WORD PTR _iOperationID$[ebp]
	push	ecx
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN20@fnValidate

; 6510 :       {
; 6511 :          return( 1 );  // no need to call fnOperationReturn

	mov	eax, 1
	jmp	$LN1@fnValidate
$LN20@fnValidate:

; 6512 :       }
; 6513 : 
; 6514 :       *lpReturnTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpReturnTask$[ebp]
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx], eax
$LN18@fnValidate:

; 6515 :    }
; 6516 : 
; 6517 :    // Get the view Object Instance for the view.
; 6518 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6519 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6520 : 
; 6521 :    // Validate that the entity exists
; 6522 :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 6523 :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN21@fnValidate

; 6524 :    {
; 6525 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN21@fnValidate:

; 6526 :    }
; 6527 : 
; 6528 :    // Set View Entity and View Entity Cursor for caller.
; 6529 :    *pvReturnViewEntity     = lpViewEntity;

	mov	edx, DWORD PTR _pvReturnViewEntity$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx], eax

; 6530 :    *pvReturnViewEntityCsr  = lpViewEntityCsr;

	mov	ecx, DWORD PTR _pvReturnViewEntityCsr$[ebp]
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx], edx

; 6531 : 
; 6532 :    // Validate that the attribute exists.
; 6533 :    if ( cpcAttributeName == 0 )

	cmp	DWORD PTR _cpcAttributeName$[ebp], 0
	jne	SHORT $LN22@fnValidate

; 6534 :    {
; 6535 :       lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 6536 :       if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN24@fnValidate

; 6537 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN24@fnValidate:

; 6538 :    }

	jmp	SHORT $LN23@fnValidate
$LN22@fnValidate:

; 6539 :    else
; 6540 :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 6541 :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN23@fnValidate

; 6542 :    {
; 6543 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN23@fnValidate:

; 6544 :    }
; 6545 : 
; 6546 :    // If intent is update, fail the call unless the attribute is a work attr.
; 6547 :    if ( bUpdate && lpView->bReadOnly && lpViewAttrib->bPersist &&

	movsx	edx, WORD PTR _bUpdate$[ebp]
	test	edx, edx
	je	SHORT $LN26@fnValidate
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN26@fnValidate
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	je	SHORT $LN26@fnValidate
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	SHORT $LN26@fnValidate

; 6548 :         lpViewEntity->bDerivedPath == FALSE )
; 6549 :    {
; 6550 :       // "KZOEE119 - Invalid View, View is Read Only"
; 6551 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 119, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	119					; 00000077H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6552 :                         lpViewEntity->szName,
; 6553 :                         lpViewAttrib->szName );
; 6554 :    // fnOperationReturn( iOperationID, lpCurrentTask );
; 6555 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN26@fnValidate:

; 6556 :    }
; 6557 : 
; 6558 :    // Set return view attrib, NOTE that this parameter is optional
; 6559 :    // because the validation done by this function is also used by other
; 6560 :    // operations such as IncludeSubobjectFromSubobject.
; 6561 :    if ( pvReturnViewAttrib )

	cmp	DWORD PTR _pvReturnViewAttrib$[ebp], 0
	je	SHORT $LN27@fnValidate

; 6562 :    {
; 6563 :       // Set attribute pointer for caller
; 6564 :       *pvReturnViewAttrib = lpViewAttrib;

	mov	ecx, DWORD PTR _pvReturnViewAttrib$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx], edx
$LN27@fnValidate:

; 6565 :    }
; 6566 : 
; 6567 :    // Get Entity Instance pointer.
; 6568 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnValidate:

; 6569 : 
; 6570 :    // This for loop is here so we can retry to establish an undefined
; 6571 :    // cursor when retrieving attribute information!
; 6572 :    for ( ; ; )
; 6573 :    {
; 6574 :       if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN28@fnValidate

; 6575 :          lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN28@fnValidate:

; 6576 : 
; 6577 :       // Now make sure a cursor exists for the view entity.
; 6578 :       if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	$LN29@fnValidate
$LN5@fnValidate:

; 6579 :       {
; 6580 :          // Make sure parent to NULL cursor is defined.
; 6581 :          while ( lpViewEntityCsr && lpViewEntityCsr->hEntityInstance == 0 )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN6@fnValidate
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN6@fnValidate

; 6582 :             lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $LN5@fnValidate
$LN6@fnValidate:

; 6583 : 
; 6584 :          if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN30@fnValidate

; 6585 :          {
; 6586 :             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 6587 :             if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN32@fnValidate

; 6588 :                lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN32@fnValidate:

; 6589 :          }

	jmp	SHORT $LN31@fnValidate
$LN30@fnValidate:

; 6590 :          else
; 6591 :             lpEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN31@fnValidate:

; 6592 : 
; 6593 :          if ( lpEntityInstance == 0 ||

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN34@fnValidate
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN29@fnValidate
$LN34@fnValidate:

; 6594 : // DGC 12/09/98
; 6595 : // I have no idea why we check for a hidden entity but DON'T CHANGE IT!.
; 6596 :               lpEntityInstance->u.nInd.bHidden == FALSE )
; 6597 :          {
; 6598 :             if ( nFlag & zACCEPT_NULL_ENTITY )

	movsx	ecx, WORD PTR _nFlag$[ebp]
	and	ecx, 1
	je	SHORT $LN35@fnValidate

; 6599 :                return( -2 );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@fnValidate
	jmp	SHORT $LN29@fnValidate
$LN35@fnValidate:

; 6600 :             else
; 6601 :             {
; 6602 :                //  "KZOEE253 - Entity cursor is NULL"
; 6603 :                fnIssueCoreError( lpCurrentTask, lpView, 8, 253, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	253					; 000000fdH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6604 :                                  lpViewEntity->szName,
; 6605 :                                  lpViewAttrib->szName );
; 6606 :             // fnOperationReturn( iOperationID, lpCurrentTask );
; 6607 :                return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN29@fnValidate:

; 6608 :             }
; 6609 :          }
; 6610 :       }
; 6611 : 
; 6612 :       // If the user wants to update the attribute but the attribute is part of
; 6613 :       // a hanging entity return an error.
; 6614 :       if ( bUpdate && lpEntityInstance->u.nInd.bHangingEntity )

	movsx	eax, WORD PTR _bUpdate$[ebp]
	test	eax, eax
	je	SHORT $LN37@fnValidate
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, 1
	je	SHORT $LN37@fnValidate

; 6615 :       {
; 6616 :          //  "KZOEE237 - Attempt to update a non-updateable attribute"
; 6617 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 237, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	237					; 000000edH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6618 :                            fnEntityNameFromCsr( lpViewEntityCsr ),
; 6619 :                            lpViewAttrib->szName );
; 6620 :       // fnOperationReturn( iOperationID, lpCurrentTask );
; 6621 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN37@fnValidate:

; 6622 :       }
; 6623 : 
; 6624 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	$LN38@fnValidate

; 6625 :       {
; 6626 :          // If we are attempting to update something with an undefined
; 6627 :          // cursor, or the highest level cursor in the view is undefined,
; 6628 :          // issue an undefined error.
; 6629 :          if ( bUpdate || lpViewEntityCsr == 0 )

	movsx	eax, WORD PTR _bUpdate$[ebp]
	test	eax, eax
	jne	SHORT $LN42@fnValidate
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	jne	SHORT $LN7@fnValidate
$LN42@fnValidate:

; 6630 :          {
; 6631 :             //  "KZOEE254 - Entity cursor is undefined"
; 6632 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 254, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	254					; 000000feH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6633 :                               lpViewEntity->szName,
; 6634 :                               lpViewAttrib->szName );
; 6635 :          // fnOperationReturn( iOperationID, lpCurrentTask );
; 6636 :             return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate

; 6637 :          }

	jmp	$LN41@fnValidate
$LN7@fnValidate:

; 6638 :          else
; 6639 :          {
; 6640 :             // We have found an undefined cursor, try and establish the
; 6641 :             // cursor on the next or previous entity at the highest level.
; 6642 :             while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN8@fnValidate

; 6643 :             {
; 6644 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 6645 :                if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN43@fnValidate

; 6646 :                   break;

	jmp	SHORT $LN8@fnValidate
$LN43@fnValidate:

; 6647 :             }

	jmp	SHORT $LN7@fnValidate
$LN8@fnValidate:

; 6648 : 
; 6649 :             if ( lpEntityInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN44@fnValidate
$LN9@fnValidate:

; 6650 :             {
; 6651 :                while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN44@fnValidate

; 6652 :                {
; 6653 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 6654 :                   if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN45@fnValidate

; 6655 :                      break;

	jmp	SHORT $LN44@fnValidate
$LN45@fnValidate:

; 6656 :                }

	jmp	SHORT $LN9@fnValidate
$LN44@fnValidate:

; 6657 :             }
; 6658 : 
; 6659 :             // If we found a cursor we can establish, try and re-establish
; 6660 :             // it before moving on.
; 6661 :             if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	$LN46@fnValidate

; 6662 :             {
; 6663 :                LPENTITYINSTANCE lpTempEI;
; 6664 : 
; 6665 :                lpViewEntityCsr->hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 6666 :             // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 6667 :             //    SysMessageBox( 0, "ValidateAttribute", "UNSET_CSR", -1 );
; 6668 : 
; 6669 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 6670 :                lpViewEntityCsr = *pvReturnViewEntityCsr;

	mov	ecx, DWORD PTR _pvReturnViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 6671 :                lpTempEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempEI$2[ebp], eax

; 6672 :                if ( lpTempEI == 0 || lpTempEI == UNSET_CSR )

	cmp	DWORD PTR _lpTempEI$2[ebp], 0
	je	SHORT $LN49@fnValidate
	cmp	DWORD PTR _lpTempEI$2[ebp], 1
	jne	SHORT $LN48@fnValidate
$LN49@fnValidate:

; 6673 :                {
; 6674 :                   if ( nFlag & zACCEPT_NULL_ENTITY )

	movsx	edx, WORD PTR _nFlag$[ebp]
	and	edx, 1
	je	SHORT $LN50@fnValidate

; 6675 :                      return( -2 );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@fnValidate
	jmp	SHORT $LN48@fnValidate
$LN50@fnValidate:

; 6676 :                   else
; 6677 :                   {
; 6678 :                      // "KZOEE254 - Entity cursor is undefined"
; 6679 :                      fnIssueCoreError( lpCurrentTask, lpView, 8, 254, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	254					; 000000feH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6680 :                                        lpViewEntity->szName,
; 6681 :                                        lpViewAttrib->szName );
; 6682 :                   // fnOperationReturn( iOperationID, lpCurrentTask );
; 6683 :                      return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN48@fnValidate:

; 6684 :                   }
; 6685 :                }
; 6686 :             }

	jmp	SHORT $LN41@fnValidate
$LN46@fnValidate:

; 6687 :             else
; 6688 :             {
; 6689 :                if ( nFlag & zACCEPT_NULL_ENTITY )

	movsx	ecx, WORD PTR _nFlag$[ebp]
	and	ecx, 1
	je	SHORT $LN52@fnValidate

; 6690 :                   return( -2 );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@fnValidate
	jmp	SHORT $LN41@fnValidate
$LN52@fnValidate:

; 6691 :                else
; 6692 :                {
; 6693 :                   //  "KZOEE254 - Entity cursor is undefined"
; 6694 :                   fnIssueCoreError( lpCurrentTask, lpView, 8, 254, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	254					; 000000feH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6695 :                                     lpViewEntity->szName,
; 6696 :                                     lpViewAttrib->szName );
; 6697 :                // fnOperationReturn( iOperationID, lpCurrentTask );
; 6698 :                   return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN41@fnValidate:

; 6699 :                }
; 6700 :             }
; 6701 :          }
; 6702 :       }

	jmp	SHORT $LN39@fnValidate
$LN38@fnValidate:

; 6703 :       else
; 6704 :          break;

	jmp	SHORT $LN3@fnValidate
$LN39@fnValidate:

; 6705 :    }

	jmp	$LN4@fnValidate
$LN3@fnValidate:

; 6706 : 
; 6707 :    if ( bUpdate )

	movsx	eax, WORD PTR _bUpdate$[ebp]
	test	eax, eax
	je	$LN54@fnValidate

; 6708 :    {
; 6709 :       // If the entity doesn't have update authority then fail the check
; 6710 :       // unless the attribute is a work attribute.
; 6711 :       if ( lpViewEntity->bUpdate == FALSE && lpViewAttrib->bPersist )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 2
	and	edx, 1
	jne	SHORT $LN55@fnValidate
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	je	SHORT $LN55@fnValidate

; 6712 :       {
; 6713 :          // "KZOEE106 - Rules violation"
; 6714 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 106, 0,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG16896
	push	0
	push	106					; 0000006aH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6715 :                            "Entity Update not allowed",
; 6716 :                            lpViewEntity->szName );
; 6717 :       // fnOperationReturn( iOperationID, lpCurrentTask );
; 6718 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN55@fnValidate:

; 6719 :       }
; 6720 : 
; 6721 :       if ( lpEntityInstance->u.nInd.bPrevVersion )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 8
	and	eax, 1
	je	$LN56@fnValidate

; 6722 :       {
; 6723 :          // We've found an entity instance which may be a previous
; 6724 :          // version. Check that it is a non-updateable record version
; 6725 :          // by finding the record pointer for the newer version
; 6726 :          lpVsnInstance = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpVsnInstance$[ebp], ecx

; 6727 :          if ( lpEntityInstance->hNextVsn == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	jne	SHORT $LN57@fnValidate

; 6728 :          {
; 6729 :             lpVsnInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVsnInstance$[ebp], eax

; 6730 :             if ( lpVsnInstance )

	cmp	DWORD PTR _lpVsnInstance$[ebp], 0
	je	SHORT $LN57@fnValidate
$LN13@fnValidate:

; 6731 :             {
; 6732 :                // Look for a linked instance which is versioned and has
; 6733 :                // a record pointer which is different then the entity's
; 6734 :                // record pointer ( meaning the record has update auth. ).
; 6735 :                for ( ; ; )
; 6736 :                {
; 6737 :                   if ( lpVsnInstance == lpEntityInstance )

	mov	edx, DWORD PTR _lpVsnInstance$[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	jne	SHORT $LN59@fnValidate

; 6738 :                   {
; 6739 :                      lpVsnInstance = 0;

	mov	DWORD PTR _lpVsnInstance$[ebp], 0

; 6740 :                      break;

	jmp	SHORT $LN57@fnValidate
$LN59@fnValidate:

; 6741 :                   }
; 6742 : 
; 6743 :                   if ( lpVsnInstance->hNextVsn )

	mov	eax, DWORD PTR _lpVsnInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	SHORT $LN60@fnValidate

; 6744 :                   {
; 6745 :                      LPENTITYINSTANCE lpNextVsn =

	mov	ecx, DWORD PTR _lpVsnInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$1[ebp], eax

; 6746 :                                           zGETPTR( lpVsnInstance->hNextVsn );
; 6747 : 
; 6748 :                      if ( lpNextVsn->hPersistRecord != lpEntityInstance->hPersistRecord )

	mov	eax, DWORD PTR _lpNextVsn$1[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+60]
	cmp	edx, DWORD PTR [ecx+60]
	je	SHORT $LN60@fnValidate

; 6749 :                         break;

	jmp	SHORT $LN57@fnValidate
$LN60@fnValidate:

; 6750 :                   }
; 6751 : 
; 6752 :                   lpVsnInstance = zGETPTR( lpVsnInstance->hNextLinked );

	mov	eax, DWORD PTR _lpVsnInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVsnInstance$[ebp], eax

; 6753 :                }

	jmp	SHORT $LN13@fnValidate
$LN57@fnValidate:

; 6754 :             }
; 6755 :          }
; 6756 : 
; 6757 :          if ( lpVsnInstance )

	cmp	DWORD PTR _lpVsnInstance$[ebp], 0
	je	SHORT $LN56@fnValidate

; 6758 :          {
; 6759 :             //  "KZOEE255 - Attempt to update a previous entity version"
; 6760 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 255, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	255					; 000000ffH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6761 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 6762 :                               lpViewAttrib->szName );
; 6763 :          // fnOperationReturn( iOperationID, lpCurrentTask );
; 6764 :             return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
$LN56@fnValidate:

; 6765 :          }
; 6766 :       }
; 6767 : 
; 6768 :       // Check to make sure attributes are updateable. If cpcAttributeName is
; 6769 :       // non-null then we only need to check 1 attribute; otherwise we need
; 6770 :       // to check all the attributes.
; 6771 :       for ( ;

	jmp	SHORT $LN16@fnValidate
$LN14@fnValidate:

; 6773 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN16@fnValidate:

; 6772 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN54@fnValidate

; 6774 :       {
; 6775 :          // Check to see if we should ignore key attributes.
; 6776 :          if ( (nFlag & zIGNORE_KEYS) && lpViewAttrib->bKey )

	movsx	edx, WORD PTR _nFlag$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN63@fnValidate
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN63@fnValidate

; 6777 :          {
; 6778 :             if ( cpcAttributeName )

	cmp	DWORD PTR _cpcAttributeName$[ebp], 0
	je	SHORT $LN64@fnValidate

; 6779 :                break;  // We only needed to check 1 attr so break 'for' loop.

	jmp	$LN54@fnValidate
	jmp	SHORT $LN63@fnValidate
$LN64@fnValidate:

; 6780 :             else
; 6781 :                continue;

	jmp	SHORT $LN14@fnValidate
$LN63@fnValidate:

; 6782 :          }
; 6783 : 
; 6784 :          if ( lpViewAttrib->bNoUpdate )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	je	SHORT $LN66@fnValidate

; 6785 :          {
; 6786 :             //  "KZOEE237 - Attempt to update a non-updateable attribute"
; 6787 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 237, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	237					; 000000edH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6788 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 6789 :                               lpViewAttrib->szName );
; 6790 :          // fnOperationReturn( iOperationID, lpCurrentTask );
; 6791 :             return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnValidate
$LN66@fnValidate:

; 6792 :          }
; 6793 : 
; 6794 :          if ( lpViewAttrib->bNoPersistUpd &&

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	je	SHORT $LN67@fnValidate
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN67@fnValidate

; 6795 :               lpEntityInstance->u.nInd.bCreated == FALSE )
; 6796 :          {
; 6797 :             //  "KZOEE238 - Attempt to update a non-updateable persistent "
; 6798 :             //  "           attribute"
; 6799 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 237, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	237					; 000000edH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6800 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 6801 :                               lpViewAttrib->szName );
; 6802 :          // fnOperationReturn( iOperationID, lpCurrentTask );
; 6803 :             return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@fnValidate
$LN67@fnValidate:

; 6804 :          }
; 6805 : 
; 6806 :          // We only need to check 1 attribute if cpcAttributeName is non-null.
; 6807 :          if ( cpcAttributeName )

	cmp	DWORD PTR _cpcAttributeName$[ebp], 0
	je	SHORT $LN68@fnValidate

; 6808 :             break;

	jmp	SHORT $LN54@fnValidate
$LN68@fnValidate:

; 6809 : 
; 6810 :       } // for...

	jmp	$LN14@fnValidate
$LN54@fnValidate:

; 6811 : 
; 6812 :    } // if ( bUpdate )
; 6813 : 
; 6814 :    // Everything is AOK, return
; 6815 :    return( 0 );

	xor	eax, eax
$LN1@fnValidate:

; 6816 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidateAttributeParameters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pdDecimal$ = -592					; size = 4
_plInteger$ = -588					; size = 4
_lIntegerValue$1 = -584					; size = 4
_lpTaskDomain$ = -580					; size = 4
$T2 = -576						; size = 4
_lpViewEntity$ = -572					; size = 4
_lpDomain$ = -568					; size = 4
tv76 = -564						; size = 4
tv146 = -560						; size = 4
_szTempStr$ = -556					; size = 2
_cDomainType$ = -549					; size = 1
_nRC$ = -548						; size = 2
_dDecimalValue$3 = -544					; size = 40
_szMsg$4 = -504						; size = 500
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lpVariable$ = 20					; size = 4
_cVariableType$ = 24					; size = 1
_ulVariableLth$ = 28					; size = 4
_cpcContextName$ = 32					; size = 4
_lpCurrentTask$ = 36					; size = 4
_fnAddToAttributeFromVariable PROC

; 7900 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 592				; 00000250H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 7901 :    LPVIEWENTITY      lpViewEntity;
; 7902 :    LPTASKDOMAIN      lpTaskDomain;
; 7903 :    LPDOMAIN          lpDomain;
; 7904 :    zCHAR             cDomainType;
; 7905 :    zCHAR             szTempStr[ 2 ];
; 7906 :    zPLONG            plInteger;
; 7907 :    zPDOUBLE          pdDecimal;
; 7908 :    zSHORT            nRC;
; 7909 : 
; 7910 :    // Get view Entity from cursor
; 7911 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7912 : 
; 7913 :    lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 7914 :    cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 7915 :                                              lpCurrentTask, lpDomain );
; 7916 :    switch ( cDomainType )

	mov	dl, BYTE PTR _cDomainType$[ebp]
	mov	BYTE PTR tv76[ebp], dl
	cmp	BYTE PTR tv76[ebp], 65			; 00000041H
	je	SHORT $LN7@fnAddToAtt
	cmp	BYTE PTR tv76[ebp], 69			; 00000045H
	je	SHORT $LN7@fnAddToAtt
	cmp	BYTE PTR tv76[ebp], 84			; 00000054H
	je	SHORT $LN6@fnAddToAtt
	jmp	$LN9@fnAddToAtt
$LN6@fnAddToAtt:

; 7917 :    {
; 7918 :       case zDM_TYPE_TABLE:
; 7919 :          nRC = Table_Handler( (zLONG) zDME_ADD_TO_ATTRIBUTE,

	push	0
	mov	eax, DWORD PTR _ulVariableLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	movzx	eax, BYTE PTR _cVariableType$[ebp]
	push	eax
	push	8
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 7920 :                               cVariableType,
; 7921 :                               lpVariable,
; 7922 :                               cpcContextName,
; 7923 :                               lpView,
; 7924 :                               lpViewEntity,
; 7925 :                               lpViewAttrib,
; 7926 :                               ulVariableLth,
; 7927 :                               (zPVOID) 0 );
; 7928 :          break;

	jmp	$LN2@fnAddToAtt
$LN7@fnAddToAtt:

; 7929 : 
; 7930 :       case zDM_TYPE_EXPRESSION:
; 7931 :       case zDM_TYPE_ALGORITHM:
; 7932 :          nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	mov	ecx, DWORD PTR _ulVariableLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVariable$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _cVariableType$[ebp]
	push	ecx
	push	8
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 7933 :                                  zDME_ADD_TO_ATTRIBUTE,
; 7934 :                                  cVariableType,
; 7935 :                                  lpVariable,
; 7936 :                                  cpcContextName,
; 7937 :                                  lpView,
; 7938 :                                  lpViewEntity,
; 7939 :                                  lpViewAttrib,
; 7940 :                                  ulVariableLth );
; 7941 :          if ( nRC == zDME_NOT_HANDLED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -10				; fffffff6H
	jne	SHORT $LN8@fnAddToAtt

; 7942 :          {
; 7943 :             zCHAR szMsg[ 500 ];
; 7944 : 
; 7945 :             zsprintf( szMsg, "Operation '%s' does not handle an Entry "

	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	push	8
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET $SG17370
	lea	ecx, DWORD PTR _szMsg$4[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 7946 :                       "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 7947 :                       zDME_ADD_TO_ATTRIBUTE, lpDomain->szName );
; 7948 :             MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	edx, DWORD PTR _szMsg$4[ebp]
	push	edx
	push	OFFSET $SG17371
	push	OFFSET $SG17372
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MessageSend@24

; 7949 :                          szMsg, zMSGQ_DOMAIN_ERROR, 0 );
; 7950 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN20@fnAddToAtt
$LN8@fnAddToAtt:

; 7951 :          }
; 7952 : 
; 7953 :          break;

	jmp	$LN2@fnAddToAtt
$LN9@fnAddToAtt:

; 7954 : 
; 7955 :       case zDM_TYPE_FORMAT:
; 7956 :       default:
; 7957 :          // do it without a domain...
; 7958 :          switch ( cVariableType )

	movsx	ecx, BYTE PTR _cVariableType$[ebp]
	mov	DWORD PTR tv146[ebp], ecx
	mov	edx, DWORD PTR tv146[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv146[ebp], edx
	cmp	DWORD PTR tv146[ebp], 17		; 00000011H
	ja	$LN19@fnAddToAtt
	mov	eax, DWORD PTR tv146[ebp]
	movzx	ecx, BYTE PTR $LN23@fnAddToAtt[eax]
	jmp	DWORD PTR $LN24@fnAddToAtt[ecx*4]
$LN10@fnAddToAtt:

; 7959 :          {
; 7960 :           case zTYPE_STRING:
; 7961 :             if ( *((zPCHAR) lpVariable) == 0 )

	mov	edx, DWORD PTR _lpVariable$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN11@fnAddToAtt

; 7962 :             {
; 7963 :                // a null string, don't bother adding
; 7964 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 7965 :                break;

	jmp	$LN2@fnAddToAtt
$LN11@fnAddToAtt:

; 7966 :             }
; 7967 : 
; 7968 :             if ( lpViewAttrib->cType == zTYPE_DECIMAL )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN12@fnAddToAtt

; 7969 :             {
; 7970 :                zDECIMAL  dDecimalValue;
; 7971 : 
; 7972 :                SysConvertStringToDecimal( (zPCHAR) lpVariable,

	lea	ecx, DWORD PTR _dDecimalValue$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	call	_SysConvertStringToDecimal@8

; 7973 :                                           &dDecimalValue );
; 7974 :                nRC = fnAddToAttributeFromDecimal( lpView,

	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _dDecimalValue$3[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnAddToAttributeFromDecimal
	add	esp, 52					; 00000034H
	mov	WORD PTR _nRC$[ebp], ax

; 7975 :                                                   lpViewEntityCsr,
; 7976 :                                                   lpViewAttrib,
; 7977 :                                                   dDecimalValue );
; 7978 :             }

	jmp	SHORT $LN13@fnAddToAtt
$LN12@fnAddToAtt:

; 7979 :             else
; 7980 :             if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	SHORT $LN14@fnAddToAtt

; 7981 :             {
; 7982 :                // convert string to long, then add
; 7983 :                zLONG lIntegerValue;
; 7984 : 
; 7985 :                lIntegerValue = zatol( (zPCHAR) lpVariable );

	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lIntegerValue$1[ebp], eax

; 7986 :                nRC = fnAddToAttributeFromInteger( lpView,

	mov	eax, DWORD PTR _lIntegerValue$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAddToAttributeFromInteger
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 7987 :                                                   lpViewEntityCsr,
; 7988 :                                                   lpViewAttrib,
; 7989 :                                                   lIntegerValue );
; 7990 :             }

	jmp	SHORT $LN13@fnAddToAtt
$LN14@fnAddToAtt:

; 7991 :             else
; 7992 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN13@fnAddToAtt:

; 7993 : 
; 7994 :             break;

	jmp	$LN2@fnAddToAtt
$LN16@fnAddToAtt:

; 7995 : 
; 7996 :           case zTYPE_BLOB:
; 7997 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 7998 :             break;

	jmp	$LN2@fnAddToAtt
$LN17@fnAddToAtt:

; 7999 : 
; 8000 :           case zTYPE_INTEGER:
; 8001 :             plInteger = (zPLONG) lpVariable;

	mov	eax, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _plInteger$[ebp], eax

; 8002 :             nRC = fnAddToAttributeFromInteger( lpView,

	mov	ecx, DWORD PTR _plInteger$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnAddToAttributeFromInteger
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 8003 :                                                lpViewEntityCsr,
; 8004 :                                                lpViewAttrib,
; 8005 :                                                *plInteger );
; 8006 :             break;

	jmp	$LN2@fnAddToAtt
$LN18@fnAddToAtt:

; 8007 : 
; 8008 :           case zTYPE_DECIMAL:
; 8009 :             pdDecimal = (zPDECIMAL) lpVariable;

	mov	eax, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR _pdDecimal$[ebp], eax

; 8010 :             nRC = fnAddToAttributeFromDecimal( lpView,

	mov	esi, DWORD PTR _pdDecimal$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAddToAttributeFromDecimal
	add	esp, 52					; 00000034H
	mov	WORD PTR _nRC$[ebp], ax

; 8011 :                                                lpViewEntityCsr,
; 8012 :                                                lpViewAttrib,
; 8013 :                                                *pdDecimal );
; 8014 :             break;

	jmp	SHORT $LN2@fnAddToAtt
$LN19@fnAddToAtt:

; 8015 : 
; 8016 :           default:
; 8017 :             szTempStr[ 0 ] = cVariableType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _cVariableType$[ebp]
	mov	BYTE PTR _szTempStr$[ebp+edx], al

; 8018 :             szTempStr[ 1 ] = '\x00';

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 2
	jae	SHORT $LN21@fnAddToAtt
	jmp	SHORT $LN22@fnAddToAtt
$LN21@fnAddToAtt:
	call	___report_rangecheckfailure
$LN22@fnAddToAtt:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szTempStr$[ebp+ecx], 0

; 8019 :             // "KZOEE241 - Invalid Variable Type"
; 8020 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 241, 0, szTempStr, 0 );

	push	0
	lea	edx, DWORD PTR _szTempStr$[ebp]
	push	edx
	push	0
	push	241					; 000000f1H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8021 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN20@fnAddToAtt
$LN2@fnAddToAtt:

; 8022 :          }
; 8023 :    }
; 8024 : 
; 8025 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN20@fnAddToAtt:

; 8026 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN24@fnAddToAtt:
	DD	$LN16@fnAddToAtt
	DD	$LN17@fnAddToAtt
	DD	$LN18@fnAddToAtt
	DD	$LN10@fnAddToAtt
	DD	$LN19@fnAddToAtt
$LN23@fnAddToAtt:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnAddToAttributeFromVariable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -168					; size = 4
_lpTask$1 = -164					; size = 4
_lpTask$2 = -160					; size = 4
_lpTask$3 = -156					; size = 4
_lpViewCsr$ = -152					; size = 4
_lpEntityInstance$ = -148				; size = 4
_pchRecord$ = -144					; size = 4
_lplLong$4 = -140					; size = 4
_lpdDecimal$5 = -136					; size = 4
_nRC$ = -132						; size = 2
_bUpdated$ = -125					; size = 1
_dDec$6 = -124						; size = 40
_dLong$7 = -84						; size = 40
_dNewValue$8 = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_dDecimalValue$ = 20					; size = 40
_fnAddToAttributeFromDecimal PROC

; 3135 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 168				; 000000a8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3136 :    LPENTITYINSTANCE  lpEntityInstance;
; 3137 :    LPVIEWCSR         lpViewCsr;
; 3138 :    LPVIEWOI          lpViewOI;
; 3139 :    zPCHAR            pchRecord;
; 3140 :    zBOOL             bUpdated;
; 3141 :    zSHORT            nRC;
; 3142 : 
; 3143 :    lpViewCsr        = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3144 :    lpViewOI         = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 3145 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 3146 : 
; 3147 :    // Get record to store into
; 3148 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 3149 : 
; 3150 :    // Default nRC to 0
; 3151 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 3152 :    bUpdated = FALSE;

	mov	BYTE PTR _bUpdated$[ebp], 0

; 3153 :    if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	$LN2@fnAddToAtt

; 3154 :    {
; 3155 :       zPLONG    lplLong;
; 3156 :       zDECIMAL  dNewValue;
; 3157 :       zDECIMAL  dLong;
; 3158 : 
; 3159 :       lplLong = (zPLONG) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lplLong$4[ebp], eax

; 3160 : 
; 3161 :       // Add lplLong to Decimal unless the integer is null, in which case
; 3162 :       // the integer will simply assume the passed value.
; 3163 :       if ( *lplLong != lNullInteger )

	mov	ecx, DWORD PTR _lplLong$4[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	je	SHORT $LN4@fnAddToAtt

; 3164 :       {
; 3165 :          SysConvertLongToDecimal( *lplLong, &dNewValue );

	lea	eax, DWORD PTR _dNewValue$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lplLong$4[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SysConvertLongToDecimal@8

; 3166 :          SysAddDecimalToDecimal( &dNewValue, &dNewValue, &dDecimalValue );

	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dNewValue$8[ebp]
	push	ecx
	lea	edx, DWORD PTR _dNewValue$8[ebp]
	push	edx
	call	_SysAddDecimalToDecimal@12

; 3167 :       }

	jmp	SHORT $LN5@fnAddToAtt
$LN4@fnAddToAtt:

; 3168 :       else
; 3169 :          SysAssignDecimalFromDecimal( &dNewValue, &dDecimalValue );

	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dNewValue$8[ebp]
	push	ecx
	call	_SysAssignDecimalFromDecimal@8
$LN5@fnAddToAtt:

; 3170 : 
; 3171 :       SysConvertLongToDecimal( LONG_MAX, &dLong );

	lea	edx, DWORD PTR _dLong$7[ebp]
	push	edx
	push	2147483647				; 7fffffffH
	call	_SysConvertLongToDecimal@8

; 3172 :       if ( SysCompareDecimalToDecimal( &dNewValue, &dLong ) > 0 )

	lea	eax, DWORD PTR _dLong$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _dNewValue$8[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jle	SHORT $LN6@fnAddToAtt

; 3173 :       {
; 3174 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 3175 :          //  "KZOEE235 - Integer overflow"
; 3176 :          fnIssueCoreError( lpTask, lpView, 16, 235, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	235					; 000000ebH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$3[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3177 :                            fnEntityNameFromCsr( lpViewEntityCsr ),
; 3178 :                            lpViewAttrib->szName );
; 3179 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnAddToAtt
$LN6@fnAddToAtt:

; 3180 :       }
; 3181 : 
; 3182 :       SysConvertLongToDecimal( LONG_MIN, &dLong );

	lea	eax, DWORD PTR _dLong$7[ebp]
	push	eax
	push	-2147483648				; 80000000H
	call	_SysConvertLongToDecimal@8

; 3183 :       if ( SysCompareDecimalToDecimal( &dNewValue, &dLong ) < 0 )

	lea	ecx, DWORD PTR _dLong$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _dNewValue$8[ebp]
	push	edx
	call	_SysCompareDecimalToDecimal@8
	cwde
	test	eax, eax
	jge	SHORT $LN7@fnAddToAtt

; 3184 :       {
; 3185 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 3186 :          //  "KZOEE236 - Integer underflow"
; 3187 :          fnIssueCoreError( lpTask, lpView, 16, 236, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	236					; 000000ecH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3188 :                            fnEntityNameFromCsr( lpViewEntityCsr ),
; 3189 :                            lpViewAttrib->szName );
; 3190 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnAddToAtt
$LN7@fnAddToAtt:

; 3191 :       }
; 3192 : 
; 3193 :       SysConvertLongToDecimal( *lplLong, &dLong );

	lea	ecx, DWORD PTR _dLong$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _lplLong$4[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SysConvertLongToDecimal@8

; 3194 :       if ( SysCompareDecimalToDecimal( &dNewValue, &dLong ) != 0 )

	lea	ecx, DWORD PTR _dLong$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _dNewValue$8[ebp]
	push	edx
	call	_SysCompareDecimalToDecimal@8
	cwde
	test	eax, eax
	je	SHORT $LN8@fnAddToAtt

; 3195 :       {
; 3196 :          SysConvertDecimalToLong( &dNewValue, lplLong );

	mov	ecx, DWORD PTR _lplLong$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _dNewValue$8[ebp]
	push	edx
	call	_SysConvertDecimalToLong@8

; 3197 :          bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN8@fnAddToAtt:

; 3198 :       }
; 3199 :    }

	jmp	$LN3@fnAddToAtt
$LN2@fnAddToAtt:

; 3200 :    else
; 3201 :    if ( lpViewAttrib->cType == zTYPE_DECIMAL ) // Internal Decimal type

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 77					; 0000004dH
	jne	$LN9@fnAddToAtt

; 3202 :    {
; 3203 :       zPDECIMAL lpdDecimal;
; 3204 :       zDECIMAL  dDec;
; 3205 : 
; 3206 :       lpdDecimal = (zPDECIMAL) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpdDecimal$5[ebp], eax

; 3207 : 
; 3208 :       // If either a non-zero addend is coming in or the attribute
; 3209 :       // is currently null, set the update indicator to true
; 3210 :       SysConvertLongToDecimal( 0, &dDec );

	lea	ecx, DWORD PTR _dDec$6[ebp]
	push	ecx
	push	0
	call	_SysConvertLongToDecimal@8

; 3211 :       if ( SysCompareDecimalToNull( lpdDecimal ) == 0 ||

	mov	edx, DWORD PTR _lpdDecimal$5[ebp]
	push	edx
	call	_SysCompareDecimalToNull@4
	cwde
	test	eax, eax
	je	SHORT $LN12@fnAddToAtt
	lea	ecx, DWORD PTR _dDec$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _dDecimalValue$[ebp]
	push	edx
	call	_SysCompareDecimalToDecimal@8
	cwde
	test	eax, eax
	je	SHORT $LN11@fnAddToAtt
$LN12@fnAddToAtt:

; 3212 :            SysCompareDecimalToDecimal( &dDecimalValue, &dDec ) != 0 )
; 3213 :       {
; 3214 :          bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1

; 3215 : 
; 3216 :          // if the current attribute is null, set it to 0 for the add
; 3217 :          if ( SysCompareDecimalToNull( lpdDecimal ) == 0 )

	mov	ecx, DWORD PTR _lpdDecimal$5[ebp]
	push	ecx
	call	_SysCompareDecimalToNull@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN11@fnAddToAtt

; 3218 :             SysConvertLongToDecimal( 0, lpdDecimal );

	mov	eax, DWORD PTR _lpdDecimal$5[ebp]
	push	eax
	push	0
	call	_SysConvertLongToDecimal@8
$LN11@fnAddToAtt:

; 3219 :       }
; 3220 : 
; 3221 :       SysAddDecimalToDecimal( lpdDecimal, lpdDecimal, &dDecimalValue );

	lea	ecx, DWORD PTR _dDecimalValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpdDecimal$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdDecimal$5[ebp]
	push	eax
	call	_SysAddDecimalToDecimal@12

; 3222 :    }

	jmp	SHORT $LN3@fnAddToAtt
$LN9@fnAddToAtt:

; 3223 :    else
; 3224 :    {
; 3225 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 3226 :       //  "KZOEE234 - Attempt to add integer or decimal to invalid
; 3227 :       //              attribute type"
; 3228 :       fnIssueCoreError( lpTask, lpView, 8, 234, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	234					; 000000eaH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3229 :                         fnEntityNameFromCsr( lpViewEntityCsr ),
; 3230 :                         lpViewAttrib->szName );
; 3231 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN3@fnAddToAtt:

; 3232 :    }
; 3233 : 
; 3234 :    // Set update indicator.
; 3235 :    fnSetUpdateIndicator( lpViewOI, lpEntityInstance, lpViewAttrib,

	push	1
	push	1
	movzx	edx, BYTE PTR _bUpdated$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H

; 3236 :                          bUpdated, TRUE, TRUE );
; 3237 : 
; 3238 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnAddToAtt:

; 3239 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnAddToAttributeFromDecimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -76						; size = 4
_lTempLong$2 = -72					; size = 4
_lpViewEntity$ = -68					; size = 4
_lpEntityInstance$ = -64				; size = 4
_nRC$ = -60						; size = 2
_szAttribValue$3 = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_dDecimalValue$ = 20					; size = 40
_fnSetAttributeFromDecimal PROC

; 2999 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3000 :    LPENTITYINSTANCE  lpEntityInstance;
; 3001 :    LPVIEWENTITY      lpViewEntity;
; 3002 :    zSHORT            nRC;
; 3003 : 
; 3004 :    lpViewEntity     = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 3005 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 3006 : 
; 3007 :    // Convert the decimal value to match the domain for the attribute and
; 3008 :    // call fnStoreValueInEntityInstance to store the value.
; 3009 : 
; 3010 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 3011 :    if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN2@fnSetAttri

; 3012 :    {
; 3013 :       zCHAR szAttribValue[ 50 ] = "";

	mov	cl, BYTE PTR $SG15574
	mov	BYTE PTR _szAttribValue$3[ebp], cl
	push	49					; 00000031H
	push	0
	lea	edx, DWORD PTR _szAttribValue$3[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3014 : 
; 3015 :       // Convert decimal coming in to a string for storing in the record
; 3016 :       if ( SysCompareDecimalToNull( &dDecimalValue ) != 0 )

	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN4@fnSetAttri

; 3017 :          SysConvertDecimalToString( &dDecimalValue, szAttribValue, 0 );

	push	0
	lea	edx, DWORD PTR _szAttribValue$3[ebp]
	push	edx
	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	call	_SysConvertDecimalToString@12
$LN4@fnSetAttri:

; 3018 : 
; 3019 :       nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	ecx, DWORD PTR _szAttribValue$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 3020 :                                           lpViewEntity,
; 3021 :                                           lpViewAttrib,
; 3022 :                                           szAttribValue, 0 );
; 3023 :    }

	jmp	$LN3@fnSetAttri
$LN2@fnSetAttri:

; 3024 :    else
; 3025 :    if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN5@fnSetAttri

; 3026 :    {
; 3027 :       zLONG lTempLong;
; 3028 : 
; 3029 :       if ( SysCompareDecimalToNull( &dDecimalValue ) == 0 )

	lea	ecx, DWORD PTR _dDecimalValue$[ebp]
	push	ecx
	call	_SysCompareDecimalToNull@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN7@fnSetAttri

; 3030 :          lTempLong = lNullInteger;

	mov	eax, DWORD PTR _lNullInteger
	mov	DWORD PTR _lTempLong$2[ebp], eax
	jmp	SHORT $LN8@fnSetAttri
$LN7@fnSetAttri:

; 3031 :       else
; 3032 :          SysConvertDecimalToLong( &dDecimalValue, &lTempLong );

	lea	ecx, DWORD PTR _lTempLong$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _dDecimalValue$[ebp]
	push	edx
	call	_SysConvertDecimalToLong@8
$LN8@fnSetAttri:

; 3033 : 
; 3034 :       nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	eax, DWORD PTR _lTempLong$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 3035 :                                           lpViewEntity,
; 3036 :                                           lpViewAttrib,
; 3037 :                                           &lTempLong, 0 );
; 3038 :    }

	jmp	SHORT $LN3@fnSetAttri
$LN5@fnSetAttri:

; 3039 :    else
; 3040 :    if ( lpViewAttrib->cType == zTYPE_DECIMAL ) // Internal Decimal type

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN9@fnSetAttri

; 3041 :    {
; 3042 :       nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 3043 :                                           lpViewEntity,
; 3044 :                                           lpViewAttrib,
; 3045 :                                           &dDecimalValue, 0 );
; 3046 :    }

	jmp	SHORT $LN3@fnSetAttri
$LN9@fnSetAttri:

; 3047 :    else
; 3048 :    {
; 3049 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 3050 :       // "KZOEE239 - Invalid Operation for attribute type"
; 3051 :       fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnEntityNameFromInstance@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3052 :                         fnEntityNameFromInstance( lpEntityInstance ),
; 3053 :                         lpViewAttrib->szName );
; 3054 :       nRC = zCALL_ERROR;   // Operation not allowed for other types.

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN3@fnSetAttri:

; 3055 :    }
; 3056 : 
; 3057 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 3058 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetAttributeFromDecimal ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -96					; size = 4
_lpTask$1 = -92						; size = 4
_lpTask$2 = -88						; size = 4
_lpTask$3 = -84						; size = 4
_lpViewCsr$ = -80					; size = 4
_lpEntityInstance$ = -76				; size = 4
_pchRecord$ = -72					; size = 4
_l2$4 = -68						; size = 4
_l1$5 = -64						; size = 4
_lpdDecimal$6 = -60					; size = 4
_nRC$ = -56						; size = 2
_lplLong$7 = -52					; size = 4
_bUpdated$ = -45					; size = 1
_dDec$8 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lIntegerValue$ = 20					; size = 4
_fnAddToAttributeFromInteger PROC

; 2828 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2829 :    LPENTITYINSTANCE  lpEntityInstance;
; 2830 :    LPVIEWCSR         lpViewCsr;
; 2831 :    LPVIEWOI          lpViewOI;
; 2832 :    zPCHAR            pchRecord;
; 2833 :    zBOOL             bUpdated;
; 2834 :    zSHORT            nRC;
; 2835 : 
; 2836 :    lpViewCsr        = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2837 :    lpViewOI         = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2838 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2839 : 
; 2840 :    // Get record to store into
; 2841 :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 2842 : 
; 2843 :    // Default RC to 0 and attempt add
; 2844 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 2845 :    bUpdated = FALSE;

	mov	BYTE PTR _bUpdated$[ebp], 0

; 2846 :    if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	$LN2@fnAddToAtt

; 2847 :    {
; 2848 :       zPLONG   lplLong;
; 2849 : 
; 2850 :       lplLong = (zPLONG) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lplLong$7[ebp], eax

; 2851 :       if ( *lplLong != lNullInteger )

	mov	ecx, DWORD PTR _lplLong$7[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	je	$LN4@fnAddToAtt

; 2852 :       {
; 2853 :          // Check to make sure that we're not overflowing.  We divide
; 2854 :          // everything by two so we don't have to convert longs to
; 2855 :          // decimals.
; 2856 :          zLONG l1 = *lplLong / 2;

	mov	eax, DWORD PTR _lplLong$7[ebp]
	mov	eax, DWORD PTR [eax]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _l1$5[ebp], eax

; 2857 :          zLONG l2 = lIntegerValue / 2;

	mov	eax, DWORD PTR _lIntegerValue$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _l2$4[ebp], eax

; 2858 : 
; 2859 :          if ( l1 + l2 > LONG_MAX / 2 )

	mov	ecx, DWORD PTR _l1$5[ebp]
	add	ecx, DWORD PTR _l2$4[ebp]
	cmp	ecx, 1073741823				; 3fffffffH
	jle	SHORT $LN5@fnAddToAtt

; 2860 :          {
; 2861 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 2862 :             //  "KZOEE235 - Integer overflow"
; 2863 :             fnIssueCoreError( lpTask, lpView, 16, 235, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	235					; 000000ebH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$3[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2864 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 2865 :                               lpViewAttrib->szName );
; 2866 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnAddToAtt

; 2867 :          }

	jmp	SHORT $LN4@fnAddToAtt
$LN5@fnAddToAtt:

; 2868 :          else
; 2869 :          if ( l1 + l2 < LONG_MIN / 2 )

	mov	edx, DWORD PTR _l1$5[ebp]
	add	edx, DWORD PTR _l2$4[ebp]
	cmp	edx, -1073741824			; c0000000H
	jge	SHORT $LN4@fnAddToAtt

; 2870 :          {
; 2871 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 2872 :             //  "KZOEE236 - Integer underflow"
; 2873 :             fnIssueCoreError( lpTask, lpView, 16, 236, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	236					; 000000ecH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2874 :                               fnEntityNameFromCsr( lpViewEntityCsr ),
; 2875 :                               lpViewAttrib->szName );
; 2876 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnAddToAtt
$LN4@fnAddToAtt:

; 2877 :          }
; 2878 :       }
; 2879 : 
; 2880 :       // do the addition
; 2881 :       if ( *lplLong == lNullInteger || lIntegerValue )

	mov	eax, DWORD PTR _lplLong$7[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	je	SHORT $LN9@fnAddToAtt
	cmp	DWORD PTR _lIntegerValue$[ebp], 0
	je	SHORT $LN8@fnAddToAtt
$LN9@fnAddToAtt:

; 2882 :       {
; 2883 :          bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1

; 2884 :          if ( *lplLong == lNullInteger )

	mov	edx, DWORD PTR _lplLong$7[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	jne	SHORT $LN8@fnAddToAtt

; 2885 :             *lplLong = 0;

	mov	ecx, DWORD PTR _lplLong$7[ebp]
	mov	DWORD PTR [ecx], 0
$LN8@fnAddToAtt:

; 2886 :       }
; 2887 : 
; 2888 :       *lplLong += lIntegerValue;

	mov	edx, DWORD PTR _lplLong$7[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _lIntegerValue$[ebp]
	mov	ecx, DWORD PTR _lplLong$7[ebp]
	mov	DWORD PTR [ecx], eax

; 2889 :    }

	jmp	$LN3@fnAddToAtt
$LN2@fnAddToAtt:

; 2890 :    else
; 2891 :    if ( lpViewAttrib->cType == zTYPE_DECIMAL )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN11@fnAddToAtt

; 2892 :    {
; 2893 :       zPDECIMAL lpdDecimal;
; 2894 :       zDECIMAL  dDec;
; 2895 : 
; 2896 :       lpdDecimal = (zPDECIMAL) ( pchRecord + lpViewAttrib->ulRecordOffset );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lpdDecimal$6[ebp], edx

; 2897 : 
; 2898 :       // do the addition
; 2899 :       if ( SysCompareDecimalToNull( lpdDecimal ) == 0 ||

	mov	eax, DWORD PTR _lpdDecimal$6[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN14@fnAddToAtt
	cmp	DWORD PTR _lIntegerValue$[ebp], 0
	je	SHORT $LN13@fnAddToAtt
$LN14@fnAddToAtt:

; 2900 :            lIntegerValue )
; 2901 :       {
; 2902 :          bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1

; 2903 :          if ( SysCompareDecimalToNull( lpdDecimal ) == 0 )

	mov	edx, DWORD PTR _lpdDecimal$6[ebp]
	push	edx
	call	_SysCompareDecimalToNull@4
	cwde
	test	eax, eax
	jne	SHORT $LN13@fnAddToAtt

; 2904 :             SysConvertLongToDecimal( 0, lpdDecimal );

	mov	ecx, DWORD PTR _lpdDecimal$6[ebp]
	push	ecx
	push	0
	call	_SysConvertLongToDecimal@8
$LN13@fnAddToAtt:

; 2905 :       }
; 2906 : 
; 2907 :       SysConvertLongToDecimal( lIntegerValue, &dDec );

	lea	edx, DWORD PTR _dDec$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lIntegerValue$[ebp]
	push	eax
	call	_SysConvertLongToDecimal@8

; 2908 :       SysAddDecimalToDecimal( lpdDecimal, lpdDecimal, &dDec );

	lea	ecx, DWORD PTR _dDec$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpdDecimal$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdDecimal$6[ebp]
	push	eax
	call	_SysAddDecimalToDecimal@12

; 2909 :    }

	jmp	SHORT $LN3@fnAddToAtt
$LN11@fnAddToAtt:

; 2910 :    else
; 2911 :    {
; 2912 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 2913 :       //  "KZOEE234 - Attempt to add integer or decimal to invalid
; 2914 :       //              attribute type"
; 2915 :       fnIssueCoreError( lpTask, lpView, 8, 234, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	234					; 000000eaH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2916 :                         fnEntityNameFromCsr( lpViewEntityCsr ),
; 2917 :                         lpViewAttrib->szName );
; 2918 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN3@fnAddToAtt:

; 2919 :    }
; 2920 : 
; 2921 :    // Set update indicator.
; 2922 :    fnSetUpdateIndicator( lpViewOI, lpEntityInstance, lpViewAttrib,

	push	1
	push	1
	movzx	edx, BYTE PTR _bUpdated$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H

; 2923 :                          bUpdated, TRUE, TRUE );
; 2924 : 
; 2925 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnAddToAtt:

; 2926 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnAddToAttributeFromInteger ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTask$1 = -96						; size = 4
$T2 = -92						; size = 4
_lpViewEntity$ = -88					; size = 4
_lpEntityInstance$ = -84				; size = 4
_nRC$ = -80						; size = 2
_dDecimal$3 = -76					; size = 40
_szAttribValue$4 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lIntegerValue$ = 20					; size = 4
_fnSetAttributeFromInteger PROC

; 2690 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2691 :    LPENTITYINSTANCE  lpEntityInstance;
; 2692 :    LPVIEWENTITY      lpViewEntity;
; 2693 :    zSHORT            nRC;
; 2694 : 
; 2695 :    lpViewEntity     = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2696 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2697 : 
; 2698 :    // set attrib from string
; 2699 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 2700 :    if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN2@fnSetAttri

; 2701 :    {
; 2702 :       zCHAR szAttribValue[ 32 ];
; 2703 : 
; 2704 :       szAttribValue[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 32			; 00000020H
	jae	SHORT $LN12@fnSetAttri
	jmp	SHORT $LN13@fnSetAttri
$LN12@fnSetAttri:
	call	___report_rangecheckfailure
$LN13@fnSetAttri:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szAttribValue$4[ebp+eax], 0

; 2705 : 
; 2706 :       // Convert integer coming in to a string for storing in the record
; 2707 :       if ( lIntegerValue != lNullInteger )

	mov	ecx, DWORD PTR _lIntegerValue$[ebp]
	cmp	ecx, DWORD PTR _lNullInteger
	je	SHORT $LN4@fnSetAttri

; 2708 :          zltoa( lIntegerValue, szAttribValue );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _szAttribValue$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lIntegerValue$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN4@fnSetAttri:

; 2709 : 
; 2710 :       nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	ecx, DWORD PTR _szAttribValue$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2711 :                                           lpViewEntity,
; 2712 :                                           lpViewAttrib,
; 2713 :                                           szAttribValue, 0 );
; 2714 :    }

	jmp	$LN3@fnSetAttri
$LN2@fnSetAttri:

; 2715 :    else
; 2716 :    if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN5@fnSetAttri

; 2717 :    {
; 2718 :       nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	ecx, DWORD PTR _lIntegerValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2719 :                                           lpViewEntity,
; 2720 :                                           lpViewAttrib,
; 2721 :                                           &lIntegerValue, 0 );
; 2722 :    }

	jmp	$LN3@fnSetAttri
$LN5@fnSetAttri:

; 2723 :    else
; 2724 :    if ( lpViewAttrib->cType == zTYPE_DECIMAL ) // Internal Decimal type

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN7@fnSetAttri

; 2725 :    {
; 2726 :       zDECIMAL dDecimal;
; 2727 : 
; 2728 :       if ( lIntegerValue == lNullInteger )

	mov	ecx, DWORD PTR _lIntegerValue$[ebp]
	cmp	ecx, DWORD PTR _lNullInteger
	jne	SHORT $LN9@fnSetAttri

; 2729 :          SysAssignDecimalFromNull( &dDecimal );

	lea	edx, DWORD PTR _dDecimal$3[ebp]
	push	edx
	call	_SysAssignDecimalFromNull@4
	jmp	SHORT $LN10@fnSetAttri
$LN9@fnSetAttri:

; 2730 :       else
; 2731 :          SysConvertLongToDecimal( lIntegerValue, &dDecimal );

	lea	eax, DWORD PTR _dDecimal$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lIntegerValue$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8
$LN10@fnSetAttri:

; 2732 : 
; 2733 :       nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	edx, DWORD PTR _dDecimal$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2734 :                                           lpViewEntity,
; 2735 :                                           lpViewAttrib,
; 2736 :                                           &dDecimal, 0 );
; 2737 :    }

	jmp	SHORT $LN3@fnSetAttri
$LN7@fnSetAttri:

; 2738 :    else
; 2739 :    {
; 2740 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 2741 :       // "KZOEE239 - Invalid Operation for attribute type"
; 2742 :       fnIssueCoreError( lpTask, lpView, 8, 239, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityNameFromInstance@4
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2743 :                         fnEntityNameFromInstance( lpEntityInstance ),
; 2744 :                         lpViewAttrib->szName );
; 2745 :       nRC = zCALL_ERROR;   // Operation not allowed for other types.

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN3@fnSetAttri:

; 2746 :    }
; 2747 : 
; 2748 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN11@fnSetAttri:

; 2749 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetAttributeFromInteger ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -96					; size = 4
_stDTLocal$1 = -92					; size = 6
_lpViewCsr$ = -84					; size = 4
_lpDTLocal$2 = -80					; size = 4
_lWork$3 = -76						; size = 4
_pchWorkStr$ = -72					; size = 4
_lpEntityInstance$ = -68				; size = 4
_lpViewEntity$ = -64					; size = 4
tv81 = -60						; size = 4
_pchAttribValue$ = -56					; size = 4
_szNull$ = -49						; size = 1
_nRC$ = -48						; size = 2
_dDecimal$4 = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_cpcStringValue$ = 20					; size = 4
_bProcessDomain$ = 24					; size = 2
_fnSetAttributeFromString PROC

; 2501 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2502 :    LPVIEWENTITY      lpViewEntity;
; 2503 :    LPENTITYINSTANCE  lpEntityInstance;
; 2504 :    LPVIEWCSR         lpViewCsr;
; 2505 :    LPVIEWOI          lpViewOI;
; 2506 :    zPCHAR            pchAttribValue;
; 2507 :    zCHAR             szNull[ 1 ];
; 2508 :    zPCHAR            pchWorkStr;
; 2509 :    zSHORT            nRC;
; 2510 : 
; 2511 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2512 :    lpViewCsr    = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2513 :    lpViewOI     = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2514 : 
; 2515 :    // Get Entity Instance pointer
; 2516 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2517 : 
; 2518 :    pchWorkStr = (zPCHAR) cpcStringValue;

	mov	edx, DWORD PTR _cpcStringValue$[ebp]
	mov	DWORD PTR _pchWorkStr$[ebp], edx

; 2519 : 
; 2520 :    // If a null pointer was passed, assume attempt to null out string.
; 2521 :    if ( pchWorkStr == 0 )

	cmp	DWORD PTR _pchWorkStr$[ebp], 0
	jne	SHORT $LN4@fnSetAttri

; 2522 :    {
; 2523 :       szNull[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szNull$[ebp+ecx], 0

; 2524 :       pchWorkStr = szNull;

	lea	edx, DWORD PTR _szNull$[ebp]
	mov	DWORD PTR _pchWorkStr$[ebp], edx
$LN4@fnSetAttri:

; 2525 :    }
; 2526 : 
; 2527 :    // Set pchAttribValue to string coming in before domain processing
; 2528 :    pchAttribValue = pchWorkStr;

	mov	eax, DWORD PTR _pchWorkStr$[ebp]
	mov	DWORD PTR _pchAttribValue$[ebp], eax

; 2529 : 
; 2530 :    // set attrib from string
; 2531 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 2532 :    switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR tv81[ebp], eax
	mov	ecx, DWORD PTR tv81[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR tv81[ebp], ecx
	cmp	DWORD PTR tv81[ebp], 8
	ja	$LN15@fnSetAttri
	mov	edx, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $LN17@fnSetAttri[edx*4]
$LN5@fnSetAttri:

; 2533 :    {
; 2534 :       case zTYPE_STRING:
; 2535 :          nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2536 :                                              lpViewEntity,
; 2537 :                                              lpViewAttrib,
; 2538 :                                              pchAttribValue, 0 );
; 2539 :          break;

	jmp	$LN2@fnSetAttri
$LN6@fnSetAttri:

; 2540 : 
; 2541 :       case zTYPE_INTEGER:
; 2542 :       {
; 2543 :          zLONG lWork;
; 2544 : 
; 2545 :          if ( pchAttribValue[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN7@fnSetAttri

; 2546 :             lWork = lNullInteger;

	mov	edx, DWORD PTR _lNullInteger
	mov	DWORD PTR _lWork$3[ebp], edx
	jmp	SHORT $LN8@fnSetAttri
$LN7@fnSetAttri:

; 2547 :          else
; 2548 :             lWork = zatol( pchAttribValue );

	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lWork$3[ebp], eax
$LN8@fnSetAttri:

; 2549 : 
; 2550 :          nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	ecx, DWORD PTR _lWork$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2551 :                                              lpViewEntity,
; 2552 :                                              lpViewAttrib,
; 2553 :                                              (zPVOID) &lWork, 0 );
; 2554 :       }
; 2555 : 
; 2556 :       break;

	jmp	$LN2@fnSetAttri
$LN9@fnSetAttri:

; 2557 : 
; 2558 :       case zTYPE_DECIMAL:
; 2559 :       {
; 2560 :          zDECIMAL   dDecimal;
; 2561 : 
; 2562 :          if ( pchAttribValue[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN10@fnSetAttri

; 2563 :             SysAssignDecimalFromNull( &dDecimal );

	lea	eax, DWORD PTR _dDecimal$4[ebp]
	push	eax
	call	_SysAssignDecimalFromNull@4
	jmp	SHORT $LN11@fnSetAttri
$LN10@fnSetAttri:

; 2564 :          else
; 2565 :             SysConvertStringToDecimal( pchAttribValue, &dDecimal );

	lea	ecx, DWORD PTR _dDecimal$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	push	edx
	call	_SysConvertStringToDecimal@8
$LN11@fnSetAttri:

; 2566 : 
; 2567 :          nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	lea	eax, DWORD PTR _dDecimal$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2568 :                                              lpViewEntity,
; 2569 :                                              lpViewAttrib,
; 2570 :                                              (zPVOID) &dDecimal, 0 );
; 2571 :       }
; 2572 : 
; 2573 :       break;

	jmp	SHORT $LN2@fnSetAttri
$LN12@fnSetAttri:

; 2574 : 
; 2575 :       case zTYPE_DATETIME:
; 2576 :       {
; 2577 :          DateTimeInternalRecord  stDTLocal;
; 2578 :          LPDTINTERNAL            lpDTLocal;
; 2579 : 
; 2580 :          lpDTLocal = &stDTLocal;

	lea	ecx, DWORD PTR _stDTLocal$1[ebp]
	mov	DWORD PTR _lpDTLocal$2[ebp], ecx

; 2581 :          if ( pchAttribValue[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN13@fnSetAttri

; 2582 :          {
; 2583 :             stDTLocal.ulDateMinutes = (zULONG) lNullInteger;

	mov	eax, DWORD PTR _lNullInteger
	mov	DWORD PTR _stDTLocal$1[ebp], eax

; 2584 :             stDTLocal.usTSeconds = 0;

	xor	ecx, ecx
	mov	WORD PTR _stDTLocal$1[ebp+4], cx

; 2585 :          }

	jmp	SHORT $LN14@fnSetAttri
$LN13@fnSetAttri:

; 2586 :          else
; 2587 :          {
; 2588 :             nRC = UfStringToDateTime( pchAttribValue, (LPDATETIME) lpDTLocal );

	mov	edx, DWORD PTR _lpDTLocal$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	push	eax
	call	_UfStringToDateTime@8
	mov	WORD PTR _nRC$[ebp], ax
$LN14@fnSetAttri:

; 2589 :          }
; 2590 : 
; 2591 :          nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	mov	ecx, DWORD PTR _lpDTLocal$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2592 :                                              lpViewEntity,
; 2593 :                                              lpViewAttrib,
; 2594 :                                              (zPVOID) lpDTLocal, 0 );
; 2595 :       }
; 2596 : 
; 2597 :       break;

	jmp	SHORT $LN2@fnSetAttri
$LN15@fnSetAttri:

; 2598 : 
; 2599 :       default:
; 2600 :          nRC = zCALL_ERROR;   // function not supported for other types

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN2@fnSetAttri:

; 2601 :    }
; 2602 : 
; 2603 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2604 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN17@fnSetAttri:
	DD	$LN6@fnSetAttri
	DD	$LN9@fnSetAttri
	DD	$LN15@fnSetAttri
	DD	$LN15@fnSetAttri
	DD	$LN15@fnSetAttri
	DD	$LN15@fnSetAttri
	DD	$LN15@fnSetAttri
	DD	$LN5@fnSetAttri
	DD	$LN12@fnSetAttri
_fnSetAttributeFromString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$1 = -16					; size = 4
_lpAllocTask$2 = -12					; size = 4
_lpViewEntity$3 = -8					; size = 4
_pchRecord$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_lpViewAttrib$ = 12					; size = 4
_fnGetAttribFlagsPtr@8 PROC

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 342  :    zPCHAR   pchRecord;
; 343  : 
; 344  :    // Get record to retrieve from.
; 345  :    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 346  : 
; 347  :    // If we didn't find a Record then create one.
; 348  :    if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	$LN2@fnGetAttri

; 349  :    {
; 350  :       LPVIEWOI     lpViewOI     = zGETPTR( lpEntityInstance->hViewOI );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$1[ebp], eax

; 351  :       LPTASK       lpAllocTask  = zGETPTR( lpViewOI->hAllocTask );

	mov	ecx, DWORD PTR _lpViewOI$1[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$2[ebp], eax

; 352  :       LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$3[ebp], eax

; 353  : 
; 354  :       // Allocate the data records (data sticks).
; 355  :       if ( lpViewAttrib->bPersist )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	je	SHORT $LN3@fnGetAttri

; 356  :       {
; 357  :          fnCreateAttributeRecord( lpAllocTask, lpViewEntity,

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$2[ebp]
	push	eax
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH

; 358  :                                   lpEntityInstance );
; 359  :       }

	jmp	SHORT $LN4@fnGetAttri
$LN3@fnGetAttri:

; 360  :       else
; 361  :       {
; 362  :          lpEntityInstance->hNonPersistRecord =

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAllocTask$2[ebp]
	push	edx
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+64], eax
$LN4@fnGetAttri:

; 363  :                      fnCreateAttributeRecord( lpAllocTask, lpViewEntity, 0 );
; 364  :       }
; 365  : 
; 366  :       // Try to get the pchRecord again.  It had better be there!
; 367  :       pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 368  :       if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN2@fnGetAttri

; 369  :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetAttri
$LN2@fnGetAttri:

; 370  :    }
; 371  : 
; 372  :    return( (LPATTRIBFLAGS) (pchRecord +

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+250]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	lea	eax, DWORD PTR [eax+edx-4]
$LN1@fnGetAttri:

; 373  :                lpViewAttrib->ulRecordOffset - sizeof( AttribFlagsRecord )) );
; 374  : 
; 375  : } // fnGetAttribFlagsPtr

	mov	esp, ebp
	pop	ebp
	ret	8
_fnGetAttribFlagsPtr@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_plpAttribFlags$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_GetAttributeFlags@16 PROC

; 400  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 401  :    LPTASK            lpCurrentTask;
; 402  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 403  :    LPVIEWOI          lpViewOI;
; 404  :    LPVIEWCSR         lpViewCsr;
; 405  :    zSHORT            nRC;
; 406  : 
; 407  :    *plpAttribFlags = 0;

	mov	eax, DWORD PTR _plpAttribFlags$[ebp]
	mov	DWORD PTR [eax], 0

; 408  : 
; 409  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 410  :    if ( (lpCurrentTask = fnOperationCall( iGetAttributeFlags, lpView,
; 411  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	254					; 000000feH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@GetAttribu

; 412  :    {
; 413  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetAttribu
$LN4@GetAttribu:

; 414  :    }
; 415  : 
; 416  :    do   // purist's goto
; 417  :    {
; 418  :       // Set lpViewCsr.
; 419  :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 420  :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 421  : 
; 422  :       // Validate that the entity exists.
; 423  :       if ( fnValidViewEntity( &lpViewEntityCsr, lpView,
; 424  :                               lpViewEntity->szName, 0 ) == 0 )

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	test	eax, eax
	jne	SHORT $LN6@GetAttribu

; 425  :       {
; 426  :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 427  :          break;

	jmp	SHORT $LN3@GetAttribu
$LN6@GetAttribu:

; 428  :       }
; 429  : 
; 430  :       *plpAttribFlags =

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	ecx, DWORD PTR _plpAttribFlags$[ebp]
	mov	DWORD PTR [ecx], eax

; 431  :             fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 432  :                                  lpViewAttrib );
; 433  :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 434  : 
; 435  :    } while ( FALSE );

	xor	eax, eax
	jne	SHORT $LN4@GetAttribu
$LN3@GetAttribu:

; 436  : 
; 437  :    fnOperationReturn( iGetAttributeFlags, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	254					; 000000feH
	call	_fnOperationReturn
	add	esp, 8

; 438  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetAttribu:

; 439  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetAttributeFlags@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpContext$ = -16					; size = 4
$T1 = -12						; size = 4
_szDecimal$2 = -8					; size = 2
_nPrecision$ = -4					; size = 2
_pchReturnString$ = 8					; size = 4
_lpViewAttrib$ = 12					; size = 4
_dDecimal$ = 16						; size = 40
_cpcContextName$ = 56					; size = 4
_ConvertDecimalToString@52 PROC

; 7343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 7344 :    zSHORT      nPrecision;
; 7345 :    zLPCONTEXT  lpContext;
; 7346 : 
; 7347 :    nPrecision = -1;

	or	eax, -1
	mov	WORD PTR _nPrecision$[ebp], ax

; 7348 :    if ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN2@ConvertDec

; 7349 :    {
; 7350 :       if ( GetContext( &lpContext, zGETPTR( lpViewAttrib->hDomain ),

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	lea	ecx, DWORD PTR _lpContext$[ebp]
	push	ecx
	call	_GetContext@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@ConvertDec

; 7351 :                        cpcContextName ) )
; 7352 :          nPrecision = (zSHORT) lpContext->lDecimalFormat;

	mov	eax, DWORD PTR _lpContext$[ebp]
	mov	cx, WORD PTR [eax+63]
	mov	WORD PTR _nPrecision$[ebp], cx
	jmp	SHORT $LN2@ConvertDec
$LN3@ConvertDec:

; 7353 :       else
; 7354 :       if ( lpViewAttrib->cType == zTYPE_DECIMAL )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN5@ConvertDec

; 7355 :       {
; 7356 :          zCHAR szDecimal[ 2 ];
; 7357 : 
; 7358 :          szDecimal[ 0 ] = lpViewAttrib->cDecimal;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+207]
	mov	BYTE PTR _szDecimal$2[ebp+edx], cl

; 7359 :          szDecimal[ 1 ] = 0;

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 2
	jae	SHORT $LN9@ConvertDec
	jmp	SHORT $LN10@ConvertDec
$LN9@ConvertDec:
	call	___report_rangecheckfailure
$LN10@ConvertDec:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szDecimal$2[ebp+edx], 0

; 7360 :          nPrecision = (zSHORT) zatol( szDecimal );

	lea	eax, DWORD PTR _szDecimal$2[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nPrecision$[ebp], ax

; 7361 :       }

	jmp	SHORT $LN2@ConvertDec
$LN5@ConvertDec:

; 7362 :       else
; 7363 :       if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN2@ConvertDec

; 7364 :          nPrecision = 0;

	xor	eax, eax
	mov	WORD PTR _nPrecision$[ebp], ax
$LN2@ConvertDec:

; 7365 :    }
; 7366 : 
; 7367 :    SysConvertDecimalToString( &dDecimal, pchReturnString, nPrecision );

	movzx	ecx, WORD PTR _nPrecision$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	lea	eax, DWORD PTR _dDecimal$[ebp]
	push	eax
	call	_SysConvertDecimalToString@12
$LN8@ConvertDec:

; 7368 : 
; 7369 : }  /* End of fnConvertDecimalToString */

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_ConvertDecimalToString@52 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityTemp$ = -16				; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttribute$ = 16					; size = 4
_pchReturnString$ = 20					; size = 4
_uMaxLength$ = 24					; size = 4
_GetStringFromRecord@20 PROC

; 10296: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 10297:    LPTASK            lpCurrentTask;
; 10298:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10299:    LPVIEWENTITY      lpViewEntityTemp;
; 10300:    zSHORT            nRC;
; 10301: 
; 10302:    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	288					; 00000120H
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityTemp$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@GetStringF

; 10303:                                       &lpViewEntityTemp,
; 10304:                                       &lpViewEntityCsr,
; 10305:                                       iGetStringFromRecord,
; 10306:                                       lpView,
; 10307:                                       lpViewEntity->szName, 0 ) )
; 10308:    {
; 10309:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetStringF
$LN2@GetStringF:

; 10310:    }
; 10311: 
; 10312:    nRC = fnGetStringFromAttribute( pchReturnString, uMaxLength, lpView,

	push	0
	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _uMaxLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10313:                                    lpViewEntityCsr, lpViewAttribute, 0 );
; 10314: 
; 10315:    fnOperationReturn( iGetStringFromRecord, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	288					; 00000120H
	call	_fnOperationReturn
	add	esp, 8

; 10316:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetStringF:

; 10317: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GetStringFromRecord@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityTemp$ = -16				; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttribute$ = 16					; size = 4
_cpcValue$ = 20						; size = 4
_StoreStringInRecord@16 PROC

; 10248: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 10249:    LPTASK            lpCurrentTask;
; 10250:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10251:    LPVIEWENTITY      lpViewEntityTemp;
; 10252:    zSHORT            nRC;
; 10253: 
; 10254:    lpCurrentTask = fnOperationCall( iStoreStringInRecord, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	287					; 0000011fH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 10255: 
; 10256:    // We have already validated the ViewEntity prior to invoking the
; 10257:    // Domain function.  We are doing the call again so that we may
; 10258:    // easily retrieve the lpViewEntityCsr.
; 10259:    lpViewEntityTemp = fnValidViewEntity( &lpViewEntityCsr, lpView,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntityTemp$[ebp], eax

; 10260:                                          lpViewEntity->szName, 0 );
; 10261:    nRC = fnSetAttributeFromString( lpView, lpViewEntityCsr, lpViewAttribute,

	push	0
	mov	ecx, DWORD PTR _cpcValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 10262:                                    cpcValue, 0 );
; 10263: 
; 10264:    fnOperationReturn( iStoreStringInRecord, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	287					; 0000011fH
	call	_fnOperationReturn
	add	esp, 8

; 10265:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 10266: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_StoreStringInRecord@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -60					; size = 4
_lpViewEntityTemp$ = -56				; size = 4
_lpCurrentTask$ = -52					; size = 4
_pulLth$1 = -48						; size = 4
_pulLth$2 = -44						; size = 4
_lpEntityInstance$ = -40				; size = 4
_lpViewEntityCsr$ = -36					; size = 4
_lpViewCsr$ = -32					; size = 4
_lpExternalP$3 = -28					; size = 4
_lpExternalP$4 = -24					; size = 4
_pchBlob$5 = -20					; size = 4
tv90 = -16						; size = 4
_pchRecord$ = -12					; size = 4
_pchRecordString$6 = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttribute$ = 16					; size = 4
_lpReturnAddr$ = 20					; size = 4
_pchReturnType$ = 24					; size = 4
_pulReturnLth$ = 28					; size = 4
_GetValueFromRecord@24 PROC

; 10101: {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 10102:    LPTASK            lpCurrentTask;
; 10103:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10104:    LPVIEWENTITY      lpViewEntityTemp;
; 10105:    LPVIEWCSR         lpViewCsr;
; 10106:    LPVIEWOI          lpViewOI;
; 10107:    LPENTITYINSTANCE  lpEntityInstance;
; 10108:    zPCHAR            pchRecord;
; 10109:    zSHORT            nRC;
; 10110: 
; 10111:    lpCurrentTask = fnOperationCall( iGetValueFromRecord, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	286					; 0000011eH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 10112: 
; 10113: #if 0
; 10114:    // This check is done to ensure that the invocation of the operation
; 10115:    // is from a domain or database handler function.  No outsiders allowed!
; 10116:    if ( lpCurrentTask->nOperIdx < 1 )
; 10117:    {
; 10118:       // "KZOEE020 - Invalid Operation call "
; 10119:       fnIssueCoreError( lpCurrentTask, lpView, 8, 20, 0, 0, 0 );
; 10120:       fnOperationReturn( iGetValueFromRecord, lpCurrentTask );
; 10121:       return( zCALL_ERROR );
; 10122:    }
; 10123: #endif
; 10124: 
; 10125:    // We have already validated the ViewEntity prior to invoking the
; 10126:    // Domain function.  We are doing the call again so that we may
; 10127:    // easily retrieve the lpViewEntityCsr.
; 10128:    lpViewEntityTemp = fnValidViewEntity( &lpViewEntityCsr, lpView,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntityTemp$[ebp], eax

; 10129:                                          lpViewEntity->szName, 0 );
; 10130: 
; 10131:    lpViewCsr    = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 10132:    lpViewOI     = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 10133: 
; 10134:    // Get Entity Instance pointer.
; 10135:    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 10136: 
; 10137:    // Get record to retrieve from.
; 10138:    pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttribute );

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 10139: 
; 10140:    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 10141:    *pchReturnType = lpViewAttribute->cType; // return internal type

	mov	ecx, DWORD PTR _pchReturnType$[ebp]
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR [ecx], al

; 10142:    if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN4@GetValueFr

; 10143:    {
; 10144:       *lpReturnAddr = 0;

	mov	ecx, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [ecx], 0

; 10145:       *pulReturnLth = 0;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], 0

; 10146:    }

	jmp	$LN5@GetValueFr
$LN4@GetValueFr:

; 10147:    else
; 10148:    {
; 10149:       switch ( lpViewAttribute->cType )

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv90[ebp], ecx
	mov	edx, DWORD PTR tv90[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv90[ebp], edx
	cmp	DWORD PTR tv90[ebp], 18			; 00000012H
	ja	$LN15@GetValueFr
	mov	eax, DWORD PTR tv90[ebp]
	movzx	ecx, BYTE PTR $LN17@GetValueFr[eax]
	jmp	DWORD PTR $LN18@GetValueFr[ecx*4]
$LN6@GetValueFr:

; 10150:       {
; 10151:          case zTYPE_STRING:
; 10152:          {
; 10153:             zPCHAR   pchRecordString;
; 10154:             zCOREMEM lpExternalP;
; 10155:             zPULONG  pulLth;
; 10156: 
; 10157:             pchRecordString = pchRecord + lpViewAttribute->ulRecordOffset;

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchRecordString$6[ebp], eax

; 10158:             if ( pchRecordString[ 0 ] == (zCHAR) '\xff' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchRecordString$6[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	jne	SHORT $LN7@GetValueFr

; 10159:             {
; 10160:                lpExternalP = (zCOREMEM) (pchRecordString + 1);

	mov	edx, DWORD PTR _pchRecordString$6[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$4[ebp], edx

; 10161:                pulLth = (zPULONG) (lpExternalP + 1);

	mov	eax, DWORD PTR _lpExternalP$4[ebp]
	add	eax, 4
	mov	DWORD PTR _pulLth$2[ebp], eax

; 10162:                *pulReturnLth = *pulLth;

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	edx, DWORD PTR _pulLth$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 10163:                pchRecordString = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$4[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecordString$6[ebp], eax

; 10164:                *lpReturnAddr = pchRecordString;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	ecx, DWORD PTR _pchRecordString$6[ebp]
	mov	DWORD PTR [eax], ecx

; 10165:             }

	jmp	SHORT $LN8@GetValueFr
$LN7@GetValueFr:

; 10166:             else
; 10167:             {
; 10168:                *lpReturnAddr = pchRecordString;

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	eax, DWORD PTR _pchRecordString$6[ebp]
	mov	DWORD PTR [edx], eax

; 10169:                *pulReturnLth = zstrlen( pchRecordString ) + 1;

	mov	ecx, DWORD PTR _pchRecordString$6[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], eax
$LN8@GetValueFr:

; 10170:             }
; 10171: 
; 10172:             break;

	jmp	$LN5@GetValueFr
$LN9@GetValueFr:

; 10173:          }
; 10174: 
; 10175:          case zTYPE_INTEGER:
; 10176:             *lpReturnAddr = (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [edx], ecx

; 10177:             *pulReturnLth = sizeof( zLONG );

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 4

; 10178:             break;

	jmp	$LN5@GetValueFr
$LN10@GetValueFr:

; 10179: 
; 10180:          case zTYPE_DECIMAL:
; 10181:             *lpReturnAddr = (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [eax], edx

; 10182:             *pulReturnLth = sizeof( zDECIMAL );

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], 40			; 00000028H

; 10183:             break;

	jmp	$LN5@GetValueFr
$LN11@GetValueFr:

; 10184: 
; 10185:          case zTYPE_BLOB:
; 10186:          {
; 10187:             zPCHAR   pchBlob;
; 10188:             zCOREMEM lpExternalP;
; 10189:             zPULONG pulLth;
; 10190: 
; 10191:             pchBlob = pchRecord + lpViewAttribute->ulRecordOffset;

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchBlob$5[ebp], eax

; 10192:             if ( pchBlob[ 0 ] == (zCHAR) '\xff' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchBlob$5[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	jne	SHORT $LN12@GetValueFr

; 10193:             {
; 10194:                lpExternalP = (zCOREMEM) (pchBlob + 1);

	mov	edx, DWORD PTR _pchBlob$5[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$3[ebp], edx

; 10195:                pulLth = (zPULONG) (lpExternalP + 1);

	mov	eax, DWORD PTR _lpExternalP$3[ebp]
	add	eax, 4
	mov	DWORD PTR _pulLth$1[ebp], eax

; 10196:                *pulReturnLth = *pulLth;

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	edx, DWORD PTR _pulLth$1[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 10197:                pchBlob = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$3[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchBlob$5[ebp], eax

; 10198:                *lpReturnAddr = pchBlob;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	ecx, DWORD PTR _pchBlob$5[ebp]
	mov	DWORD PTR [eax], ecx

; 10199:             }

	jmp	SHORT $LN13@GetValueFr
$LN12@GetValueFr:

; 10200:             else
; 10201:             {
; 10202:                *lpReturnAddr = 0;

	mov	edx, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [edx], 0

; 10203:                *pulReturnLth = 0;

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 0
$LN13@GetValueFr:

; 10204:             }
; 10205: 
; 10206:             break;

	jmp	SHORT $LN5@GetValueFr
$LN14@GetValueFr:

; 10207:          }
; 10208: 
; 10209:          case zTYPE_DATETIME:
; 10210:             *lpReturnAddr = (pchRecord + lpViewAttribute->ulRecordOffset);

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	DWORD PTR [eax], edx

; 10211:             *pulReturnLth = sizeof( DateTimeRecord );

	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], 6

; 10212:             break;

	jmp	SHORT $LN5@GetValueFr
$LN15@GetValueFr:

; 10213: 
; 10214:          default:
; 10215:             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN5@GetValueFr:

; 10216:       }
; 10217:    }
; 10218: 
; 10219:    fnOperationReturn( iGetValueFromRecord, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	286					; 0000011eH
	call	_fnOperationReturn
	add	esp, 8

; 10220:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 10221: }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	3
$LN18@GetValueFr:
	DD	$LN11@GetValueFr
	DD	$LN9@GetValueFr
	DD	$LN10@GetValueFr
	DD	$LN6@GetValueFr
	DD	$LN14@GetValueFr
	DD	$LN15@GetValueFr
$LN17@GetValueFr:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_GetValueFromRecord@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntity$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_pchEntityName$ = 12					; size = 4
_pchAttribName$ = 16					; size = 4
_lpValue$ = 20						; size = 4
_ulLength$ = 24						; size = 4
_StoreValueInDerivedAttribute@20 PROC

; 9985 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 9986 :    LPTASK          lpCurrentTask;
; 9987 :    LPVIEWENTITY    lpViewEntity;
; 9988 :    LPVIEWATTRIB    lpViewAttrib;
; 9989 :    LPVIEWENTITYCSR lpViewEntityCsr;
; 9990 :    zSHORT          nRC;
; 9991 : 
; 9992 :    lpCurrentTask = fnOperationCall( iStoreValueInDerivedAttribute, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	298					; 0000012aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 9993 : 
; 9994 :    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9995 :    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN2@StoreValue

; 9996 :    {
; 9997 :       fnOperationReturn( iStoreValueInDerivedAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	298					; 0000012aH
	call	_fnOperationReturn
	add	esp, 8

; 9998 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@StoreValue
$LN2@StoreValue:

; 9999 :    }
; 10000: 
; 10001:    lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity, pchAttribName, 0 );

	push	0
	mov	edx, DWORD PTR _pchAttribName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 10002:    if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@StoreValue

; 10003:    {
; 10004:       fnOperationReturn( iStoreValueInDerivedAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	298					; 0000012aH
	call	_fnOperationReturn
	add	esp, 8

; 10005:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@StoreValue
$LN3@StoreValue:

; 10006:    }
; 10007: 
; 10008:    nRC = StoreValueInRecord( lpView, lpViewEntity, lpViewAttrib,

	mov	eax, DWORD PTR _ulLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_StoreValueInRecord@20
	mov	WORD PTR _nRC$[ebp], ax

; 10009:                              lpValue, ulLength );
; 10010: 
; 10011:    fnOperationReturn( iStoreValueInDerivedAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	298					; 0000012aH
	call	_fnOperationReturn
	add	esp, 8

; 10012:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@StoreValue:

; 10013: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_StoreValueInDerivedAttribute@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntity$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_pchEntityName$ = 12					; size = 4
_pchAttribName$ = 16					; size = 4
_pchStr$ = 20						; size = 4
_StoreStringInDerivedAttribute@16 PROC

; 10041: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 10042:    LPTASK          lpCurrentTask;
; 10043:    LPVIEWENTITY    lpViewEntity;
; 10044:    LPVIEWATTRIB    lpViewAttrib;
; 10045:    LPVIEWENTITYCSR lpViewEntityCsr;
; 10046:    zSHORT          nRC;
; 10047: 
; 10048:    lpCurrentTask = fnOperationCall( iStoreStringInDerivedAttribute, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	299					; 0000012bH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 10049: 
; 10050:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10051:    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN2@StoreStrin

; 10052:    {
; 10053:       fnOperationReturn( iStoreStringInDerivedAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	299					; 0000012bH
	call	_fnOperationReturn
	add	esp, 8

; 10054:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@StoreStrin
$LN2@StoreStrin:

; 10055:    }
; 10056: 
; 10057:    lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity, pchAttribName, 0 );

	push	0
	mov	edx, DWORD PTR _pchAttribName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 10058:    if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@StoreStrin

; 10059:    {
; 10060:       fnOperationReturn( iStoreStringInDerivedAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	299					; 0000012bH
	call	_fnOperationReturn
	add	esp, 8

; 10061:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@StoreStrin
$LN3@StoreStrin:

; 10062:    }
; 10063: 
; 10064:    nRC = StoreStringInRecord( lpView, lpViewEntity, lpViewAttrib, pchStr );

	mov	eax, DWORD PTR _pchStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_StoreStringInRecord@16
	mov	WORD PTR _nRC$[ebp], ax

; 10065: 
; 10066:    fnOperationReturn( iStoreStringInDerivedAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	299					; 0000012bH
	call	_fnOperationReturn
	add	esp, 8

; 10067:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@StoreStrin:

; 10068: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_StoreStringInDerivedAttribute@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpDateTime$1 = -32					; size = 4
_lpdDecimal$2 = -28					; size = 4
_lplLong$3 = -24					; size = 4
_lpViewOI$ = -20					; size = 4
_lpViewCsr$ = -16					; size = 4
_lpAllocTask$ = -12					; size = 4
_pchAttribValue$4 = -8					; size = 4
tv75 = -4						; size = 4
_lpView$ = 8						; size = 4
_lpViewAttrib$ = 12					; size = 4
_lpValue$ = 16						; size = 4
_ulLength$ = 20						; size = 4
_pchRecord$ = 24					; size = 4
_StoreBytesInRecord@20 PROC

; 9876 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 9877 :    LPVIEWCSR lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 9878 :    LPVIEWOI  lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 9879 :    LPTASK    lpAllocTask = zGETPTR( lpViewOI->hAllocTask );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 9880 : 
; 9881 :    switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR tv75[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv75[ebp], edx
	cmp	DWORD PTR tv75[ebp], 18			; 00000012H
	ja	$LN2@StoreBytes
	mov	eax, DWORD PTR tv75[ebp]
	movzx	ecx, BYTE PTR $LN14@StoreBytes[eax]
	jmp	DWORD PTR $LN15@StoreBytes[ecx*4]
$LN4@StoreBytes:

; 9882 :    {
; 9883 :       case zTYPE_STRING:
; 9884 :       {
; 9885 :          zPCHAR pchAttribValue;
; 9886 : 
; 9887 :          if ( lpValue )

	cmp	DWORD PTR _lpValue$[ebp], 0
	je	SHORT $LN5@StoreBytes

; 9888 :             pchAttribValue = (zPCHAR) lpValue;

	mov	edx, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _pchAttribValue$4[ebp], edx
	jmp	SHORT $LN6@StoreBytes
$LN5@StoreBytes:

; 9889 :          else
; 9890 :             pchAttribValue = szNullS;

	mov	eax, DWORD PTR _szNullS
	mov	DWORD PTR _pchAttribValue$4[ebp], eax
$LN6@StoreBytes:

; 9891 : 
; 9892 :          if ( ulLength == 0 )

	cmp	DWORD PTR _ulLength$[ebp], 0
	jne	SHORT $LN7@StoreBytes

; 9893 :             ulLength = zstrlen( pchAttribValue );

	mov	ecx, DWORD PTR _pchAttribValue$4[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulLength$[ebp], eax
$LN7@StoreBytes:

; 9894 : 
; 9895 :          // truncate string if necessary
; 9896 :          if ( ulLength >= lpViewAttrib->ulLth )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _ulLength$[ebp]
	cmp	eax, DWORD PTR [edx+203]
	jb	SHORT $LN8@StoreBytes

; 9897 :             ulLength = lpViewAttrib->ulLth - 1;  // subtract 1 for null

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+203]
	sub	edx, 1
	mov	DWORD PTR _ulLength$[ebp], edx
$LN8@StoreBytes:

; 9898 : 
; 9899 :          fnStoreStringInRecord( lpAllocTask,  // so allocation can be done

	push	1
	mov	eax, DWORD PTR _ulLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttribValue$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+250]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAllocTask$[ebp]
	push	edx
	call	_fnStoreStringInRecord
	add	esp, 24					; 00000018H

; 9900 :                                 pchRecord,       // Attribute record
; 9901 :                                 lpViewAttrib->ulRecordOffset,   // Offset
; 9902 :                                 pchAttribValue,  // Attribute value to store
; 9903 :                                 ulLength,        // Maximum length to store
; 9904 :                                 1 );             // Null terminate data
; 9905 :          break;

	jmp	$LN2@StoreBytes
$LN9@StoreBytes:

; 9906 :       }
; 9907 : 
; 9908 :       case zTYPE_INTEGER:
; 9909 :       {
; 9910 :          zPLONG   lplLong;
; 9911 : 
; 9912 :          lplLong = (zPLONG) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _lplLong$3[ebp], ecx

; 9913 :          *lplLong = *((zPLONG) lpValue);

	mov	edx, DWORD PTR _lplLong$3[ebp]
	mov	eax, DWORD PTR _lpValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 9914 : 
; 9915 :          break;

	jmp	SHORT $LN2@StoreBytes
$LN10@StoreBytes:

; 9916 :       }
; 9917 : 
; 9918 :       case zTYPE_DECIMAL:
; 9919 :       {
; 9920 :          zPDECIMAL lpdDecimal;
; 9921 : #if 0
; 9922 :          lpdDecimalInput = (zPDECIMAL) lpValue;
; 9923 :          lpdDecimal = (zPDECIMAL) (pchRecord + lpViewAttrib->ulRecordOffset);
; 9924 :          SysAssignDecimalFromDecimal( lpdDecimal, (zPDECIMAL) lpValue );
; 9925 : #else
; 9926 :          lpdDecimal = (zPDECIMAL) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpdDecimal$2[ebp], eax

; 9927 :          zmemcpy( lpdDecimal, lpValue, sizeof( zDECIMAL ) );

	push	40					; 00000028H
	mov	ecx, DWORD PTR _lpValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpdDecimal$2[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 9928 : #endif
; 9929 : 
; 9930 :          break;

	jmp	SHORT $LN2@StoreBytes
$LN11@StoreBytes:

; 9931 :       }
; 9932 : 
; 9933 :       case zTYPE_BLOB:
; 9934 :       {
; 9935 :          fnStoreBlobInRecord( lpAllocTask,  // so allocation can be done

	mov	eax, DWORD PTR _ulLength$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+250]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAllocTask$[ebp]
	push	edx
	call	_fnStoreBlobInRecord
	add	esp, 20					; 00000014H

; 9936 :                               pchRecord,       // Attribute record
; 9937 :                               lpViewAttrib->ulRecordOffset, // Offset
; 9938 :                               lpValue,        // Blob value to store
; 9939 :                               ulLength );      // Length to store
; 9940 :          break;

	jmp	SHORT $LN2@StoreBytes
$LN12@StoreBytes:

; 9941 :       }
; 9942 : 
; 9943 :       case zTYPE_DATETIME:
; 9944 :       {
; 9945 :          LPDTINTERNAL  lpDateTime;
; 9946 : 
; 9947 :          lpDateTime = (LPDTINTERNAL) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _lpDateTime$1[ebp], ecx

; 9948 :          zmemcpy( lpDateTime, lpValue, sizeof( DateTimeInternalRecord ) );

	push	6
	mov	edx, DWORD PTR _lpValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDateTime$1[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN2@StoreBytes:

; 9949 : 
; 9950 :          break;
; 9951 :       }
; 9952 : 
; 9953 :    } // switch...
; 9954 : 
; 9955 :    return( 0 );

	xor	eax, eax

; 9956 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN15@StoreBytes:
	DD	$LN11@StoreBytes
	DD	$LN9@StoreBytes
	DD	$LN10@StoreBytes
	DD	$LN4@StoreBytes
	DD	$LN12@StoreBytes
	DD	$LN2@StoreBytes
$LN14@StoreBytes:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_StoreBytesInRecord@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityTemp$ = -88				; size = 4
_lpViewCsr$ = -84					; size = 4
_lpViewOI$ = -80					; size = 4
_hndl$1 = -76						; size = 4
_lpViewEntityCsr$ = -72					; size = 4
_lpDateTimeInput$2 = -68				; size = 4
_lpdDecimalInput$3 = -64				; size = 4
_lplLongInput$4 = -60					; size = 4
_pchAttribValue$ = -56					; size = 4
_ulLth$ = -52						; size = 4
_lpAllocTask$ = -48					; size = 4
_lpdDecimal$5 = -44					; size = 4
_lplLong$6 = -40					; size = 4
tv167 = -36						; size = 4
_lpCurrentTask$ = -32					; size = 4
_lpDateTime$7 = -28					; size = 4
_lpEntityInstance$ = -24				; size = 4
_pchRecord$ = -20					; size = 4
_k$8 = -16						; size = 2
_k$9 = -12						; size = 2
_nRC$ = -8						; size = 2
_bUpdated$ = -1						; size = 1
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttrib$ = 16					; size = 4
_lpValue$ = 20						; size = 4
_ulLength$ = 24						; size = 4
_StoreValueInRecord@20 PROC

; 9619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 9620 :    LPTASK            lpCurrentTask;
; 9621 :    LPTASK            lpAllocTask;
; 9622 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 9623 :    LPVIEWENTITY      lpViewEntityTemp;
; 9624 :    LPVIEWCSR         lpViewCsr;
; 9625 :    LPVIEWOI          lpViewOI;
; 9626 :    LPENTITYINSTANCE  lpEntityInstance;
; 9627 :    zPCHAR            pchRecord;
; 9628 :    zULONG            ulLth;
; 9629 :    zPCHAR            pchAttribValue;
; 9630 :    zBOOL             bUpdated;
; 9631 :    zSHORT            nRC;
; 9632 : 
; 9633 :    lpCurrentTask = fnOperationCall( iStoreValueInRecord, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	284					; 0000011cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 9634 : 
; 9635 :    // We have already validated the ViewEntity prior to invoking the
; 9636 :    // Domain function.  We are doing the call again so that we may
; 9637 :    // easily retrieve the lpViewEntityCsr.
; 9638 :    lpViewEntityTemp = fnValidViewEntity( &lpViewEntityCsr, lpView,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntityTemp$[ebp], eax

; 9639 :                                          lpViewEntity->szName, 0 );
; 9640 : 
; 9641 :    lpViewCsr    = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 9642 :    lpViewOI     = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 9643 :    lpAllocTask  = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 9644 : 
; 9645 :    // Get Entity Instance pointer
; 9646 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 9647 : 
; 9648 :    // If the entity instance containing the attribute in which the value
; 9649 :    // is to be stored is null, then return an error message.
; 9650 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN4@StoreValue

; 9651 :    {
; 9652 :       // "KZOEE253 - Invalid Operation call "
; 9653 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 253, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	253					; 000000fdH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9654 :       fnOperationReturn( iStoreValueInRecord, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	284					; 0000011cH
	call	_fnOperationReturn
	add	esp, 8

; 9655 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@StoreValue
$LN4@StoreValue:

; 9656 :    }
; 9657 : 
; 9658 :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN5@StoreValue

; 9659 :       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN5@StoreValue:

; 9660 : 
; 9661 :    // Get record to store into.
; 9662 :    if ( lpViewAttrib->bPersist ) // is attribute persistent

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	je	SHORT $LN6@StoreValue

; 9663 :    {
; 9664 :       pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 9665 :       if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN8@StoreValue

; 9666 :       {
; 9667 :          zPVOID hndl = fnCreateAttributeRecord( lpAllocTask,

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	push	ecx
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hndl$1[ebp], eax

; 9668 :                                                 lpViewEntity,
; 9669 :                                                 lpEntityInstance );
; 9670 :          if ( hndl == 0 || hndl != lpEntityInstance->hPersistRecord  )

	cmp	DWORD PTR _hndl$1[ebp], 0
	je	SHORT $LN10@StoreValue
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _hndl$1[ebp]
	cmp	eax, DWORD PTR [edx+60]
	je	SHORT $LN9@StoreValue
$LN10@StoreValue:

; 9671 :          {
; 9672 :             fnOperationReturn( iStoreValueInRecord, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	284					; 0000011cH
	call	_fnOperationReturn
	add	esp, 8

; 9673 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@StoreValue
$LN9@StoreValue:

; 9674 :          }
; 9675 : 
; 9676 :          pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN8@StoreValue:

; 9677 :       }
; 9678 :    }

	jmp	SHORT $LN7@StoreValue
$LN6@StoreValue:

; 9679 :    else
; 9680 :    {
; 9681 :       pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 9682 :       if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN7@StoreValue

; 9683 :       {
; 9684 :          lpEntityInstance->hNonPersistRecord =

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	push	ecx
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+64], eax

; 9685 :                      fnCreateAttributeRecord( lpAllocTask, lpViewEntity, 0 );
; 9686 :          pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 9687 :          if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN7@StoreValue

; 9688 :          {
; 9689 :             fnOperationReturn( iStoreValueInRecord, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	284					; 0000011cH
	call	_fnOperationReturn
	add	esp, 8

; 9690 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@StoreValue
$LN7@StoreValue:

; 9691 :          }
; 9692 :       }
; 9693 :    }
; 9694 : 
; 9695 :    // Set attrib from string.
; 9696 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 9697 :    bUpdated = FALSE;

	mov	BYTE PTR _bUpdated$[ebp], 0

; 9698 : 
; 9699 :    switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv167[ebp], edx
	mov	eax, DWORD PTR tv167[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv167[ebp], eax
	cmp	DWORD PTR tv167[ebp], 18		; 00000012H
	ja	$LN39@StoreValue
	mov	ecx, DWORD PTR tv167[ebp]
	movzx	edx, BYTE PTR $LN41@StoreValue[ecx]
	jmp	DWORD PTR $LN42@StoreValue[edx*4]
$LN13@StoreValue:

; 9700 :    {
; 9701 :       case zTYPE_STRING:
; 9702 :       {
; 9703 :          zSHORT k;
; 9704 : 
; 9705 :          if ( lpValue )

	cmp	DWORD PTR _lpValue$[ebp], 0
	je	SHORT $LN14@StoreValue

; 9706 :             pchAttribValue = (zPCHAR) lpValue;

	mov	eax, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _pchAttribValue$[ebp], eax
	jmp	SHORT $LN15@StoreValue
$LN14@StoreValue:

; 9707 :          else
; 9708 :             pchAttribValue = szNullS;

	mov	ecx, DWORD PTR _szNullS
	mov	DWORD PTR _pchAttribValue$[ebp], ecx
$LN15@StoreValue:

; 9709 : 
; 9710 :          ulLth = zstrlen( pchAttribValue );

	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 9711 : 
; 9712 :          // Truncate string if necessary.
; 9713 :          if ( ulLth >= lpViewAttrib->ulLth )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _ulLth$[ebp]
	cmp	ecx, DWORD PTR [eax+203]
	jb	SHORT $LN16@StoreValue

; 9714 :             ulLth = lpViewAttrib->ulLth - 1;     // subtract 1 for null

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+203]
	sub	eax, 1
	mov	DWORD PTR _ulLth$[ebp], eax
$LN16@StoreValue:

; 9715 : 
; 9716 :          k = fnStoreStringInRecord( lpAllocTask, // so allocation can be done

	push	1
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+250]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	push	eax
	call	_fnStoreStringInRecord
	add	esp, 24					; 00000018H
	mov	WORD PTR _k$9[ebp], ax

; 9717 :                                     pchRecord,       // Attribute record
; 9718 :                                     lpViewAttrib->ulRecordOffset,   // Offset
; 9719 :                                     pchAttribValue,  // Attribute value to store
; 9720 :                                     ulLth,           // Maximum length to store
; 9721 :                                     1 );            // Null terminate data
; 9722 :          // Check return code.
; 9723 :          if ( k )

	movsx	ecx, WORD PTR _k$9[ebp]
	test	ecx, ecx
	je	SHORT $LN17@StoreValue

; 9724 :          {
; 9725 :             if ( k == 1 )

	movsx	edx, WORD PTR _k$9[ebp]
	cmp	edx, 1
	jne	SHORT $LN18@StoreValue

; 9726 :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
	jmp	SHORT $LN17@StoreValue
$LN18@StoreValue:

; 9727 :             else
; 9728 :                nRC = k;

	mov	ax, WORD PTR _k$9[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN17@StoreValue:

; 9729 :          }
; 9730 : 
; 9731 :          break;

	jmp	$LN2@StoreValue
$LN20@StoreValue:

; 9732 :       }
; 9733 : 
; 9734 :       case zTYPE_INTEGER:
; 9735 :       {
; 9736 :          zPLONG   lplLong;
; 9737 :          zPLONG   lplLongInput;
; 9738 : 
; 9739 :          lplLongInput = (zPLONG) lpValue;

	mov	ecx, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _lplLongInput$4[ebp], ecx

; 9740 :          lplLong = (zPLONG) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lplLong$6[ebp], eax

; 9741 :          if ( *lplLongInput == lNullInteger )

	mov	ecx, DWORD PTR _lplLongInput$4[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	jne	SHORT $LN21@StoreValue

; 9742 :          {
; 9743 :             if ( *lplLong != lNullInteger )

	mov	eax, DWORD PTR _lplLong$6[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lNullInteger
	je	SHORT $LN23@StoreValue

; 9744 :             {
; 9745 :                *lplLong = lNullInteger;

	mov	edx, DWORD PTR _lplLong$6[ebp]
	mov	eax, DWORD PTR _lNullInteger
	mov	DWORD PTR [edx], eax

; 9746 :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN23@StoreValue:

; 9747 :             }
; 9748 :          }

	jmp	SHORT $LN22@StoreValue
$LN21@StoreValue:

; 9749 :          else
; 9750 :          if ( *lplLong != *lplLongInput )

	mov	ecx, DWORD PTR _lplLong$6[ebp]
	mov	edx, DWORD PTR _lplLongInput$4[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN22@StoreValue

; 9751 :          {
; 9752 :             *lplLong = *lplLongInput;

	mov	ecx, DWORD PTR _lplLong$6[ebp]
	mov	edx, DWORD PTR _lplLongInput$4[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 9753 :             bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN22@StoreValue:

; 9754 :          }
; 9755 : 
; 9756 :          break;

	jmp	$LN2@StoreValue
$LN25@StoreValue:

; 9757 :       }
; 9758 : 
; 9759 :       case zTYPE_DECIMAL:
; 9760 :       {
; 9761 :          zPDECIMAL lpdDecimal;
; 9762 :          zPDECIMAL lpdDecimalInput;
; 9763 : 
; 9764 :          lpdDecimalInput = (zPDECIMAL) lpValue;

	mov	ecx, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _lpdDecimalInput$3[ebp], ecx

; 9765 :          lpdDecimal = (zPDECIMAL) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpdDecimal$5[ebp], eax

; 9766 :          if ( SysCompareDecimalToNull( lpdDecimalInput ) == 0 )

	mov	ecx, DWORD PTR _lpdDecimalInput$3[ebp]
	push	ecx
	call	_SysCompareDecimalToNull@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN26@StoreValue

; 9767 :          {
; 9768 :             if ( SysCompareDecimalToNull( lpdDecimal ) != 0 )

	mov	eax, DWORD PTR _lpdDecimal$5[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN28@StoreValue

; 9769 :             {
; 9770 :                SysAssignDecimalFromNull( lpdDecimal );

	mov	edx, DWORD PTR _lpdDecimal$5[ebp]
	push	edx
	call	_SysAssignDecimalFromNull@4

; 9771 :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN28@StoreValue:

; 9772 :             }
; 9773 :          }

	jmp	SHORT $LN27@StoreValue
$LN26@StoreValue:

; 9774 :          else
; 9775 :          if ( SysCompareDecimalToDecimal( lpdDecimal,
; 9776 :                                           lpdDecimalInput ) != 0 )

	mov	eax, DWORD PTR _lpdDecimalInput$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpdDecimal$5[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN27@StoreValue

; 9777 :          {
; 9778 :             SysAssignDecimalFromDecimal( lpdDecimal, lpdDecimalInput );

	mov	eax, DWORD PTR _lpdDecimalInput$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpdDecimal$5[ebp]
	push	ecx
	call	_SysAssignDecimalFromDecimal@8

; 9779 :             bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN27@StoreValue:

; 9780 :          }
; 9781 : 
; 9782 :          break;

	jmp	$LN2@StoreValue
$LN30@StoreValue:

; 9783 :       }
; 9784 : 
; 9785 :       case zTYPE_BLOB:
; 9786 :       {
; 9787 :          zSHORT k;
; 9788 : 
; 9789 :          k = fnStoreBlobInRecord( lpAllocTask, // so allocation can be done

	mov	edx, DWORD PTR _ulLength$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+250]
	push	edx
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	push	ecx
	call	_fnStoreBlobInRecord
	add	esp, 20					; 00000014H
	mov	WORD PTR _k$8[ebp], ax

; 9790 :                                   pchRecord,       // Attribute record
; 9791 :                                   lpViewAttrib->ulRecordOffset, // Offset
; 9792 :                                   lpValue,        // Blob value to store
; 9793 :                                   ulLength );      // Length to store
; 9794 :          // Check return code
; 9795 :          if ( k )

	movsx	edx, WORD PTR _k$8[ebp]
	test	edx, edx
	je	SHORT $LN31@StoreValue

; 9796 :          {
; 9797 :             if ( k == 1 )

	movsx	eax, WORD PTR _k$8[ebp]
	cmp	eax, 1
	jne	SHORT $LN32@StoreValue

; 9798 :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
	jmp	SHORT $LN31@StoreValue
$LN32@StoreValue:

; 9799 :             else
; 9800 :                nRC = k;

	mov	cx, WORD PTR _k$8[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN31@StoreValue:

; 9801 :          }
; 9802 : 
; 9803 :          break;

	jmp	$LN2@StoreValue
$LN34@StoreValue:

; 9804 :       }
; 9805 : 
; 9806 :       case zTYPE_DATETIME:
; 9807 :       {
; 9808 :          LPDTINTERNAL  lpDateTime;
; 9809 :          LPDTINTERNAL  lpDateTimeInput;
; 9810 : 
; 9811 :          lpDateTimeInput = (LPDTINTERNAL) lpValue;

	mov	edx, DWORD PTR _lpValue$[ebp]
	mov	DWORD PTR _lpDateTimeInput$2[ebp], edx

; 9812 :          lpDateTime = (LPDTINTERNAL)

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _lpDateTime$7[ebp], ecx

; 9813 :                               (pchRecord + lpViewAttrib->ulRecordOffset);
; 9814 :          if ( lpDateTimeInput->ulDateMinutes == (zULONG) lNullInteger )

	mov	edx, DWORD PTR _lpDateTimeInput$2[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	jne	SHORT $LN35@StoreValue

; 9815 :          {
; 9816 :             if ( lpDateTime->ulDateMinutes != (zULONG) lNullInteger )

	mov	ecx, DWORD PTR _lpDateTime$7[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	je	SHORT $LN37@StoreValue

; 9817 :             {
; 9818 :                lpDateTime->ulDateMinutes = (zULONG) lNullInteger;

	mov	eax, DWORD PTR _lpDateTime$7[ebp]
	mov	ecx, DWORD PTR _lNullInteger
	mov	DWORD PTR [eax], ecx

; 9819 :                lpDateTime->usTSeconds = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpDateTime$7[ebp]
	mov	WORD PTR [eax+4], dx

; 9820 :                bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN37@StoreValue:

; 9821 :             }
; 9822 :          }

	jmp	SHORT $LN36@StoreValue
$LN35@StoreValue:

; 9823 :          else
; 9824 :          if ( zmemcmp( lpDateTime, lpDateTimeInput,
; 9825 :                        sizeof( DateTimeInternalRecord ) ) != 0 )

	push	6
	mov	ecx, DWORD PTR _lpDateTimeInput$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDateTime$7[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN36@StoreValue

; 9826 :          {
; 9827 :             zmemcpy( lpDateTime, lpDateTimeInput,

	push	6
	mov	eax, DWORD PTR _lpDateTimeInput$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDateTime$7[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 9828 :                      sizeof( DateTimeInternalRecord ) );
; 9829 :             bUpdated = TRUE;

	mov	BYTE PTR _bUpdated$[ebp], 1
$LN36@StoreValue:

; 9830 :          }
; 9831 : 
; 9832 :          break;

	jmp	SHORT $LN2@StoreValue
$LN39@StoreValue:

; 9833 :       }
; 9834 : 
; 9835 :       default:
; 9836 :          nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN2@StoreValue:

; 9837 :    }
; 9838 : 
; 9839 :    // Set update indicator.
; 9840 :    fnSetUpdateIndicator( lpViewOI, lpEntityInstance, lpViewAttrib,

	push	1
	push	1
	movzx	eax, BYTE PTR _bUpdated$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H

; 9841 :                          bUpdated, TRUE, TRUE );
; 9842 : 
; 9843 :    fnOperationReturn( iStoreValueInRecord, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	284					; 0000011cH
	call	_fnOperationReturn
	add	esp, 8

; 9844 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@StoreValue:

; 9845 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN42@StoreValue:
	DD	$LN30@StoreValue
	DD	$LN20@StoreValue
	DD	$LN25@StoreValue
	DD	$LN13@StoreValue
	DD	$LN34@StoreValue
	DD	$LN39@StoreValue
$LN41@StoreValue:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_StoreValueInRecord@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpReturnAddr$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_GetAddrForAttribute@16 PROC

; 1723 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1724 :    LPTASK            lpCurrentTask;
; 1725 :    LPVIEWENTITY      lpViewEntity;
; 1726 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1727 :    LPVIEWATTRIB      lpViewAttrib;
; 1728 :    zSHORT            nRC;
; 1729 : 
; 1730 :    // initialize returned address to null
; 1731 :    *lpReturnAddr = szGAFANullS;

	mov	eax, DWORD PTR _lpReturnAddr$[ebp]
	mov	ecx, DWORD PTR _szGAFANullS
	mov	DWORD PTR [eax], ecx

; 1732 : 
; 1733 :    // Validate parameters
; 1734 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	push	259					; 00000103H
	lea	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 1735 :                                         &lpViewEntity,
; 1736 :                                         &lpViewEntityCsr,
; 1737 :                                         &lpViewAttrib,
; 1738 :                                         iGetAddrForAttribute,
; 1739 :                                         0,   // We do not intend to update
; 1740 :                                         lpView,
; 1741 :                                         cpcEntityName,
; 1742 :                                         cpcAttributeName, 0 );
; 1743 :    if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN2@GetAddrFor

; 1744 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetAddrFor
$LN2@GetAddrFor:

; 1745 : 
; 1746 :    if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN3@GetAddrFor

; 1747 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN4@GetAddrFor
$LN3@GetAddrFor:

; 1748 :    else
; 1749 :    {
; 1750 :       // If there is an object operation for the sourced attribute,
; 1751 :       // invoke it now...
; 1752 :       if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+213]
	test	eax, eax
	je	SHORT $LN5@GetAddrFor

; 1753 :       {
; 1754 :          nRC = fnInvokeDerivedOperation( lpView, lpViewEntity, lpViewAttrib,

	push	2
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 1755 :                                          lpCurrentTask, zDERIVED_GET );
; 1756 :          if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN5@GetAddrFor

; 1757 :          {
; 1758 :             fnOperationReturn( iGetAddrForAttribute, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	259					; 00000103H
	call	_fnOperationReturn
	add	esp, 8

; 1759 :             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@GetAddrFor
$LN5@GetAddrFor:

; 1760 :          }
; 1761 :       }
; 1762 : 
; 1763 :       nRC = fnGetAddrForAttribute( lpReturnAddr, lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpReturnAddr$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@GetAddrFor:

; 1764 :                                    lpViewEntityCsr, 0, lpViewAttrib );
; 1765 :    }
; 1766 : 
; 1767 :    fnOperationReturn( iGetAddrForAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	259					; 00000103H
	call	_fnOperationReturn
	add	esp, 8

; 1768 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetAddrFor:

; 1769 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetAddrForAttribute@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_l$ = -12						; size = 4
_lTotal$ = -8						; size = 4
_nRC$ = -4						; size = 2
_vView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttrName$ = 16					; size = 4
_cpcScopingEntity$ = 20					; size = 4
_ziSUM@16 PROC

; 11005: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 11006:    zLONG   l;
; 11007:    zLONG   lTotal = 0;

	mov	DWORD PTR _lTotal$[ebp], 0

; 11008:    zSHORT  nRC;
; 11009: 
; 11010:    CreateViewFromViewForTask( &vView, vView, 0 );

	push	0
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 11011: 
; 11012:    for ( nRC = SetCursorFirstEntity( vView, cpcEntityName, cpcScopingEntity );

	mov	edx, DWORD PTR _cpcScopingEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@ziSUM
$LN2@ziSUM:

; 11014:          nRC = SetCursorNextEntity( vView, cpcEntityName, cpcScopingEntity ) )

	mov	edx, DWORD PTR _cpcScopingEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@ziSUM:

; 11013:          nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN3@ziSUM

; 11015:    {
; 11016:       GetIntegerFromAttribute( &l, vView, cpcEntityName, cpcAttrName );

	mov	eax, DWORD PTR _cpcAttrName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 11017:       lTotal += l;

	mov	ecx, DWORD PTR _lTotal$[ebp]
	add	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR _lTotal$[ebp], ecx

; 11018:    }

	jmp	SHORT $LN2@ziSUM
$LN3@ziSUM:

; 11019: 
; 11020:    DropView( vView );

	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_DropView@4

; 11021:    return( lTotal );

	mov	eax, DWORD PTR _lTotal$[ebp]

; 11022: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ziSUM@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_nRC$ = -88						; size = 2
_d$ = -84						; size = 40
_dTotal$ = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
$T1 = 8							; size = 4
_vView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttrName$ = 20					; size = 4
_cpcScopingEntity$ = 24					; size = 4
_zdSUM@16 PROC

; 10979: {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 10980:    zDECIMAL d;
; 10981:    zDECIMAL dTotal;
; 10982:    zSHORT   nRC;
; 10983: 
; 10984:    SysConvertLongToDecimal( 0L, &dTotal );

	lea	eax, DWORD PTR _dTotal$[ebp]
	push	eax
	push	0
	call	_SysConvertLongToDecimal@8

; 10985: 
; 10986:    CreateViewFromViewForTask( &vView, vView, 0 );

	push	0
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 10987: 
; 10988:    for ( nRC = SetCursorFirstEntity( vView, cpcEntityName, cpcScopingEntity );

	mov	eax, DWORD PTR _cpcScopingEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@zdSUM
$LN2@zdSUM:

; 10990:          nRC = SetCursorNextEntity( vView, cpcEntityName, cpcScopingEntity ) )

	mov	eax, DWORD PTR _cpcScopingEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@zdSUM:

; 10989:          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $LN3@zdSUM

; 10991:    {
; 10992:       GetDecimalFromAttribute( &d, vView, cpcEntityName, cpcAttrName );

	mov	ecx, DWORD PTR _cpcAttrName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _d$[ebp]
	push	ecx
	call	_GetDecimalFromAttribute@16

; 10993:       SysAddDecimalToDecimal( &dTotal, &dTotal, &d );

	lea	edx, DWORD PTR _d$[ebp]
	push	edx
	lea	eax, DWORD PTR _dTotal$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dTotal$[ebp]
	push	ecx
	call	_SysAddDecimalToDecimal@12

; 10994:    }

	jmp	SHORT $LN2@zdSUM
$LN3@zdSUM:

; 10995: 
; 10996:    DropView( vView );

	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_DropView@4

; 10997:    return( dTotal );

	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _dTotal$[ebp]
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	eax, DWORD PTR $T1[ebp]

; 10998: }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zdSUM@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcContextName$ = 20					; size = 4
_SetAttributeValuePrev@16 PROC

; 9585 : {

	push	ebp
	mov	ebp, esp

; 9586 :    return( fnSetAttributeValue( lpView, cpcEntityName, cpcAttributeName,

	push	283					; 0000011bH
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeValue
	add	esp, 20					; 00000014H

; 9587 :                                  cpcContextName, iSetAttributeValuePrev ) );
; 9588 : }

	pop	ebp
	ret	16					; 00000010H
_SetAttributeValuePrev@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcContextName$ = 20					; size = 4
_SetAttributeValueNext@16 PROC

; 9545 : {

	push	ebp
	mov	ebp, esp

; 9546 :    return( fnSetAttributeValue( lpView, cpcEntityName, cpcAttributeName,

	push	282					; 0000011aH
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeValue
	add	esp, 20					; 00000014H

; 9547 :                                  cpcContextName, iSetAttributeValueNext ) );
; 9548 : }

	pop	ebp
	ret	16					; 00000010H
_SetAttributeValueNext@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTaskDomain$ = -44					; size = 4
_lpViewEntityCsr$ = -40					; size = 4
_lpDomain$1 = -36					; size = 4
_lpViewEntity$ = -32					; size = 4
$T2 = -28						; size = 4
_lpViewAttrib$ = -24					; size = 4
tv92 = -20						; size = 4
_lpCurrentTask$ = -16					; size = 4
_sz$3 = -12						; size = 2
_nRC$ = -8						; size = 2
_cDomainType$ = -1					; size = 1
_pchReturnString$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_cpcContextName$ = 24					; size = 4
_ppvTablePosition$ = 28					; size = 4
_GetNextTableEntryForAttribute@24 PROC

; 9437 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 9438 :    LPTASK            lpCurrentTask;
; 9439 :    LPVIEWENTITY      lpViewEntity;
; 9440 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 9441 :    LPVIEWATTRIB      lpViewAttrib;
; 9442 :    LPTASKDOMAIN      lpTaskDomain;
; 9443 :    zCHAR             cDomainType;
; 9444 :    zSHORT            nRC;
; 9445 : 
; 9446 :    // Validate parameters
; 9447 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	1
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	281					; 00000119H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 9448 :                                         &lpViewEntity,
; 9449 :                                         &lpViewEntityCsr,
; 9450 :                                         &lpViewAttrib,
; 9451 :                                         iGetNextTableEntryForAttribute,
; 9452 :                                         0,   // We do not intend to update
; 9453 :                                         lpView,
; 9454 :                                         cpcEntityName,
; 9455 :                                         cpcAttributeName,
; 9456 :                                         zACCEPT_NULL_ENTITY );
; 9457 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN4@GetNextTab

; 9458 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN9@GetNextTab
$LN4@GetNextTab:

; 9459 : 
; 9460 :    if ( nRC && nRC != -2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN5@GetNextTab
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN5@GetNextTab

; 9461 :    {
; 9462 :       fnOperationReturn( iGetNextTableEntryForAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	281					; 00000119H
	call	_fnOperationReturn
	add	esp, 8

; 9463 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN9@GetNextTab
$LN5@GetNextTab:

; 9464 :    }
; 9465 : 
; 9466 :    nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 9467 :    cDomainType = fnDomainProcessingRequired( &lpTaskDomain,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 9468 :                                              lpView,
; 9469 :                                              lpCurrentTask,
; 9470 :                                              zGETPTR( lpViewAttrib->hDomain ) );
; 9471 :    switch ( cDomainType )

	movsx	edx, BYTE PTR _cDomainType$[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR tv92[ebp]
	sub	eax, 65					; 00000041H
	mov	DWORD PTR tv92[ebp], eax
	cmp	DWORD PTR tv92[ebp], 19			; 00000013H
	ja	$LN8@GetNextTab
	mov	ecx, DWORD PTR tv92[ebp]
	movzx	edx, BYTE PTR $LN12@GetNextTab[ecx]
	jmp	DWORD PTR $LN13@GetNextTab[edx*4]
$LN6@GetNextTab:

; 9472 :    {
; 9473 :       case zDM_TYPE_EXPRESSION:
; 9474 :       case zDM_TYPE_ALGORITHM:
; 9475 :       case zDM_TYPE_TABLE:
; 9476 :          nRC = Table_Handler( (zLONG) zDME_GET_NEXT_TBL_ENT_FOR_ATTR,

	mov	eax, DWORD PTR _ppvTablePosition$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	push	0
	push	5
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 9477 :                               0,
; 9478 :                               pchReturnString,
; 9479 :                               cpcContextName,
; 9480 :                               lpView,
; 9481 :                               lpViewEntity,
; 9482 :                               lpViewAttrib,
; 9483 :                               0,
; 9484 :                               (zPVOID) ppvTablePosition );
; 9485 :          break;

	jmp	$LN2@GetNextTab
$LN7@GetNextTab:

; 9486 : 
; 9487 :       case zDM_TYPE_FORMAT:
; 9488 :       {
; 9489 :          zCHAR    sz[ 2 ];
; 9490 :          LPDOMAIN lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$1[ebp], eax

; 9491 : 
; 9492 :          // "KZOEE355 - Table_Handler invalid for this Domain Type "
; 9493 :          sz[ 0 ] = cDomainType;

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _cDomainType$[ebp]
	mov	BYTE PTR _sz$3[ebp+eax], cl

; 9494 :          sz[ 1 ] = 0;

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 2
	jae	SHORT $LN10@GetNextTab
	jmp	SHORT $LN11@GetNextTab
$LN10@GetNextTab:
	call	___report_rangecheckfailure
$LN11@GetNextTab:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _sz$3[ebp+edx], 0

; 9495 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 355, 0, sz, lpDomain->szName );

	mov	eax, DWORD PTR _lpDomain$1[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _sz$3[ebp]
	push	ecx
	push	0
	push	355					; 00000163H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9496 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 9497 :          break;

	jmp	SHORT $LN2@GetNextTab
$LN8@GetNextTab:

; 9498 :       }
; 9499 : 
; 9500 :       default:
; 9501 :          // "KZOEE244 - Attribute has no Domain"
; 9502 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 244, 0, cpcEntityName, cpcAttributeName );

	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	0
	push	244					; 000000f4H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9503 :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN2@GetNextTab:

; 9504 :    }
; 9505 : 
; 9506 :    fnOperationReturn( iGetNextTableEntryForAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	281					; 00000119H
	call	_fnOperationReturn
	add	esp, 8

; 9507 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN9@GetNextTab:

; 9508 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN13@GetNextTab:
	DD	$LN6@GetNextTab
	DD	$LN7@GetNextTab
	DD	$LN8@GetNextTab
$LN12@GetNextTab:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
_GetNextTableEntryForAttribute@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTaskDomain$ = -44					; size = 4
_lpViewEntityCsr$ = -40					; size = 4
_lpDomain$1 = -36					; size = 4
_lpViewEntity$ = -32					; size = 4
$T2 = -28						; size = 4
_lpViewAttrib$ = -24					; size = 4
tv92 = -20						; size = 4
_lpCurrentTask$ = -16					; size = 4
_sz$3 = -12						; size = 2
_nRC$ = -8						; size = 2
_cDomainType$ = -1					; size = 1
_pchReturnString$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_cpcContextName$ = 24					; size = 4
_ppvTablePosition$ = 28					; size = 4
_GetFirstTableEntryForAttribute@24 PROC

; 9334 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 9335 :    LPTASK            lpCurrentTask;
; 9336 :    LPVIEWENTITY      lpViewEntity;
; 9337 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 9338 :    LPVIEWATTRIB      lpViewAttrib;
; 9339 :    LPTASKDOMAIN      lpTaskDomain;
; 9340 :    zCHAR             cDomainType;
; 9341 :    zSHORT            nRC;
; 9342 : 
; 9343 :    // Validate parameters
; 9344 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	1
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	280					; 00000118H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 9345 :                                         &lpViewEntity,
; 9346 :                                         &lpViewEntityCsr,
; 9347 :                                         &lpViewAttrib,
; 9348 :                                         iGetFirstTableEntryForAttribute,
; 9349 :                                         0,   // We do not intend to update
; 9350 :                                         lpView,
; 9351 :                                         cpcEntityName,
; 9352 :                                         cpcAttributeName, zACCEPT_NULL_ENTITY );
; 9353 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN4@GetFirstTa

; 9354 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN9@GetFirstTa
$LN4@GetFirstTa:

; 9355 : 
; 9356 :    if ( nRC && nRC != -2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN5@GetFirstTa
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN5@GetFirstTa

; 9357 :    {
; 9358 :       fnOperationReturn( iGetFirstTableEntryForAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	280					; 00000118H
	call	_fnOperationReturn
	add	esp, 8

; 9359 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN9@GetFirstTa
$LN5@GetFirstTa:

; 9360 :    }
; 9361 : 
; 9362 :    nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 9363 : 
; 9364 :    cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 9365 :                                              lpCurrentTask,
; 9366 :                                              zGETPTR( lpViewAttrib->hDomain ) );
; 9367 :    switch ( cDomainType )

	movsx	edx, BYTE PTR _cDomainType$[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR tv92[ebp]
	sub	eax, 65					; 00000041H
	mov	DWORD PTR tv92[ebp], eax
	cmp	DWORD PTR tv92[ebp], 19			; 00000013H
	ja	$LN8@GetFirstTa
	mov	ecx, DWORD PTR tv92[ebp]
	movzx	edx, BYTE PTR $LN12@GetFirstTa[ecx]
	jmp	DWORD PTR $LN13@GetFirstTa[edx*4]
$LN6@GetFirstTa:

; 9368 :    {
; 9369 :       case zDM_TYPE_EXPRESSION:
; 9370 :       case zDM_TYPE_ALGORITHM:
; 9371 :       case zDM_TYPE_TABLE:
; 9372 :          nRC = Table_Handler( (zLONG) zDME_GET_FIRST_TBL_ENT_FOR_ATTR,

	mov	eax, DWORD PTR _ppvTablePosition$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	push	0
	push	4
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 9373 :                               0,
; 9374 :                               pchReturnString,
; 9375 :                               cpcContextName,
; 9376 :                               lpView,
; 9377 :                               lpViewEntity,
; 9378 :                               lpViewAttrib,
; 9379 :                               0,
; 9380 :                               (zPVOID) ppvTablePosition );
; 9381 :          break;

	jmp	$LN2@GetFirstTa
$LN7@GetFirstTa:

; 9382 : 
; 9383 :       case zDM_TYPE_FORMAT:
; 9384 :       {
; 9385 :          zCHAR sz[ 2 ];
; 9386 :          LPDOMAIN lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$1[ebp], eax

; 9387 : 
; 9388 :          // "KZOEE355 - Table_Handler invalid for this Domain Type "
; 9389 :          sz[ 0 ] = cDomainType;

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _cDomainType$[ebp]
	mov	BYTE PTR _sz$3[ebp+eax], cl

; 9390 :          sz[ 1 ] = 0;

	mov	DWORD PTR $T2[ebp], 1
	cmp	DWORD PTR $T2[ebp], 2
	jae	SHORT $LN10@GetFirstTa
	jmp	SHORT $LN11@GetFirstTa
$LN10@GetFirstTa:
	call	___report_rangecheckfailure
$LN11@GetFirstTa:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _sz$3[ebp+edx], 0

; 9391 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 355, 0, sz, lpDomain->szName );

	mov	eax, DWORD PTR _lpDomain$1[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _sz$3[ebp]
	push	ecx
	push	0
	push	355					; 00000163H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9392 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 9393 :          break;

	jmp	SHORT $LN2@GetFirstTa
$LN8@GetFirstTa:

; 9394 :       }
; 9395 : 
; 9396 :       default:
; 9397 :          // "KZOEE244 - Attribute has no Domain"
; 9398 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 244, 0, cpcEntityName,

	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	0
	push	244					; 000000f4H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9399 :                            cpcAttributeName );
; 9400 :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN2@GetFirstTa:

; 9401 :    }
; 9402 : 
; 9403 :    fnOperationReturn( iGetFirstTableEntryForAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	280					; 00000118H
	call	_fnOperationReturn
	add	esp, 8

; 9404 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN9@GetFirstTa:

; 9405 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN13@GetFirstTa:
	DD	$LN6@GetFirstTa
	DD	$LN7@GetFirstTa
	DD	$LN8@GetFirstTa
$LN12@GetFirstTa:
	DB	0
	DB	2
	DB	2
	DB	2
	DB	0
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	0
_GetFirstTableEntryForAttribute@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lpVariable$ = 20					; size = 4
_cVariableType$ = 24					; size = 1
_ulVariableLth$ = 28					; size = 4
_cpcContextName$ = 32					; size = 4
_AddToAttributeFromVariable@28 PROC

; 7843 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 7844 :    LPTASK            lpCurrentTask;
; 7845 :    LPVIEWENTITY      lpViewEntity;
; 7846 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 7847 :    LPVIEWATTRIB      lpViewAttrib;
; 7848 :    zSHORT            nRC;
; 7849 : 
; 7850 :    // Validate parameters
; 7851 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	285					; 0000011dH
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 7852 :                                         &lpViewEntity,
; 7853 :                                         &lpViewEntityCsr,
; 7854 :                                         &lpViewAttrib,
; 7855 :                                         iAddToAttributeFromVariable,
; 7856 :                                         1,   // We intend to update
; 7857 :                                         lpView,
; 7858 :                                         cpcEntityName,
; 7859 :                                         cpcAttributeName, 0 );
; 7860 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@AddToAttri

; 7861 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@AddToAttri
$LN2@AddToAttri:

; 7862 : 
; 7863 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@AddToAttri

; 7864 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@AddToAttri
$LN3@AddToAttri:

; 7865 :    else
; 7866 :    {
; 7867 :       // Call fnAddToAttributeFromVariable to do the setting.
; 7868 :       nRC = fnAddToAttributeFromVariable( lpView, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _ulVariableLth$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _cVariableType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnAddToAttributeFromVariable
	add	esp, 32					; 00000020H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@AddToAttri:

; 7869 :                                           lpViewAttrib,
; 7870 :                                           lpVariable, cVariableType,
; 7871 :                                           ulVariableLth, cpcContextName,
; 7872 :                                           lpCurrentTask );
; 7873 :    }
; 7874 : 
; 7875 :    fnOperationReturn( iAddToAttributeFromVariable, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	285					; 0000011dH
	call	_fnOperationReturn
	add	esp, 8

; 7876 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@AddToAttri:

; 7877 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_AddToAttributeFromVariable@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -32					; size = 4
_lpViewEntity$ = -28					; size = 4
_lpDefaultContext$ = -24				; size = 4
tv144 = -20						; size = 4
_lpViewAttrib$ = -16					; size = 4
tv86 = -12						; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpVariable$ = 8					; size = 4
_pulReturnLth$ = 12					; size = 4
_cVariableType$ = 16					; size = 1
_ulVariableLth$ = 20					; size = 4
_lpView$ = 24						; size = 4
_cpcEntityName$ = 28					; size = 4
_cpcAttributeName$ = 32					; size = 4
_cpcContextName$ = 36					; size = 4
_nFlag$ = 40						; size = 2
_GetVariableFromAttribute@36 PROC

; 8911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 8912 :    LPTASK            lpCurrentTask;
; 8913 :    LPVIEWENTITY      lpViewEntity;
; 8914 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 8915 :    LPVIEWATTRIB      lpViewAttrib;
; 8916 :    zLPCONTEXT        lpDefaultContext;
; 8917 :    zSHORT            nRC;
; 8918 : 
; 8919 :    // Validate parameters
; 8920 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	movzx	eax, WORD PTR _nFlag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	push	279					; 00000117H
	lea	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 8921 :                                         &lpViewEntity,
; 8922 :                                         &lpViewEntityCsr,
; 8923 :                                         &lpViewAttrib,
; 8924 :                                         iGetVariableFromAttribute,
; 8925 :                                         0,   // We do not intend to update
; 8926 :                                         lpView,
; 8927 :                                         cpcEntityName,
; 8928 :                                         cpcAttributeName, nFlag );
; 8929 : 
; 8930 :    if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN4@GetVariabl

; 8931 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetVariabl
$LN4@GetVariabl:

; 8932 : 
; 8933 :    if ( nRC && nRC != -2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN5@GetVariabl
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -2					; fffffffeH
	je	SHORT $LN5@GetVariabl

; 8934 :    {
; 8935 :       fnOperationReturn( iGetVariableFromAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	279					; 00000117H
	call	_fnOperationReturn
	add	esp, 8

; 8936 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetVariabl
$LN5@GetVariabl:

; 8937 :    }
; 8938 : 
; 8939 :    if ( nRC == -2 ) // entity is null

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN6@GetVariabl

; 8940 :    {
; 8941 :       switch ( cVariableType )

	movsx	ecx, BYTE PTR _cVariableType$[ebp]
	mov	DWORD PTR tv86[ebp], ecx
	mov	edx, DWORD PTR tv86[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv86[ebp], edx
	cmp	DWORD PTR tv86[ebp], 17			; 00000011H
	ja	SHORT $LN2@GetVariabl
	mov	eax, DWORD PTR tv86[ebp]
	movzx	ecx, BYTE PTR $LN18@GetVariabl[eax]
	jmp	DWORD PTR $LN19@GetVariabl[ecx*4]
$LN8@GetVariabl:

; 8942 :       {
; 8943 :          case zTYPE_STRING:
; 8944 :             *((zPCHAR) lpVariable) = 0;

	mov	edx, DWORD PTR _lpVariable$[ebp]
	mov	BYTE PTR [edx], 0

; 8945 :             break;

	jmp	SHORT $LN2@GetVariabl
$LN9@GetVariabl:

; 8946 : 
; 8947 :          case zTYPE_INTEGER:
; 8948 :             *((zPLONG) lpVariable) = 0;

	mov	eax, DWORD PTR _lpVariable$[ebp]
	mov	DWORD PTR [eax], 0

; 8949 :             break;

	jmp	SHORT $LN2@GetVariabl
$LN10@GetVariabl:

; 8950 : 
; 8951 :          case zTYPE_DECIMAL:
; 8952 :             SysConvertLongToDecimal( 0, (zPDECIMAL) lpVariable );

	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	push	0
	call	_SysConvertLongToDecimal@8

; 8953 :             break;

	jmp	SHORT $LN2@GetVariabl
$LN11@GetVariabl:

; 8954 : 
; 8955 :          case zTYPE_BLOB:
; 8956 :             *pulReturnLth = 0;

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [edx], 0

; 8957 :             *((zPCHAR) lpVariable) = 0;

	mov	eax, DWORD PTR _lpVariable$[ebp]
	mov	BYTE PTR [eax], 0
$LN2@GetVariabl:

; 8958 :             break;
; 8959 :       }
; 8960 :    }

	jmp	$LN7@GetVariabl
$LN6@GetVariabl:

; 8961 :    else
; 8962 :    {
; 8963 :       if ( nFlag & zUSE_DEFAULT_CONTEXT )

	movsx	ecx, WORD PTR _nFlag$[ebp]
	and	ecx, 8
	je	$LN12@GetVariabl

; 8964 :       {
; 8965 :          if ( GetDefaultContext( &lpDefaultContext,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	lea	ecx, DWORD PTR _lpDefaultContext$[ebp]
	push	ecx
	call	_GetDefaultContext@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN13@GetVariabl

; 8966 :                                  zGETPTR( lpViewAttrib->hDomain ) ) )
; 8967 :          {
; 8968 :             cpcContextName = lpDefaultContext->szName;

	mov	eax, DWORD PTR _lpDefaultContext$[ebp]
	add	eax, 6
	mov	DWORD PTR _cpcContextName$[ebp], eax

; 8969 :          }

	jmp	SHORT $LN12@GetVariabl
$LN13@GetVariabl:

; 8970 :          else
; 8971 :          {
; 8972 :             // "KZOEE232 - Operation indicates use default context,
; 8973 :             // none found"
; 8974 :             fnIssueCoreError( lpCurrentTask, lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [ecx+198], 0
	je	SHORT $LN16@GetVariabl
	mov	DWORD PTR tv144[ebp], 16		; 00000010H
	jmp	SHORT $LN17@GetVariabl
$LN16@GetVariabl:
	mov	DWORD PTR tv144[ebp], 8
$LN17@GetVariabl:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	232					; 000000e8H
	movzx	ecx, WORD PTR tv144[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8975 :                               (zSHORT) (lpViewAttrib->hDomain ? 16 : 8),
; 8976 :                               232, 0L, lpViewEntity->szName,
; 8977 :                               lpViewAttrib->szName );
; 8978 :             fnOperationReturn( iGetVariableFromAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	279					; 00000117H
	call	_fnOperationReturn
	add	esp, 8

; 8979 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetVariabl
$LN12@GetVariabl:

; 8980 :          }
; 8981 :       }
; 8982 : 
; 8983 :       // Call fnGetVariableFromAttribute for the actual retrieval
; 8984 :       nRC = fnGetVariableFromAttribute( lpVariable, pulReturnLth,

	movzx	edx, WORD PTR _nFlag$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulVariableLth$[ebp]
	push	edx
	movzx	eax, BYTE PTR _cVariableType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpVariable$[ebp]
	push	edx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN7@GetVariabl:

; 8985 :                                         cVariableType,
; 8986 :                                         ulVariableLth,
; 8987 :                                         lpView, lpViewEntityCsr,
; 8988 :                                         lpViewAttrib,
; 8989 :                                         cpcContextName,
; 8990 :                                         lpCurrentTask, nFlag );
; 8991 :    }
; 8992 : 
; 8993 :    fnOperationReturn( iGetVariableFromAttribute, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	279					; 00000117H
	call	_fnOperationReturn
	add	esp, 8

; 8994 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetVariabl:

; 8995 : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
$LN19@GetVariabl:
	DD	$LN11@GetVariabl
	DD	$LN9@GetVariabl
	DD	$LN10@GetVariabl
	DD	$LN8@GetVariabl
	DD	$LN2@GetVariabl
$LN18@GetVariabl:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_GetVariableFromAttribute@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_zVariable$ = 20					; size = 4
_cVariableType$ = 24					; size = 1
_ulVariableLth$ = 28					; size = 4
_cpcContextName$ = 32					; size = 4
_nFlag$ = 36						; size = 2
_CompareAttributeToVariable@32 PROC

; 8662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8663 :    LPTASK            lpCurrentTask;
; 8664 :    LPVIEWENTITY      lpViewEntity;
; 8665 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 8666 :    LPVIEWATTRIB      lpViewAttrib;
; 8667 :    zSHORT            nRC;
; 8668 : 
; 8669 :    // Validate parameters
; 8670 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	278					; 00000116H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 8671 :                                         &lpViewEntity,
; 8672 :                                         &lpViewEntityCsr,
; 8673 :                                         &lpViewAttrib,
; 8674 :                                         iCompareAttributeToVariable,
; 8675 :                                         0,   // We do not intend to update
; 8676 :                                         lpView,
; 8677 :                                         cpcEntityName,
; 8678 :                                         cpcAttributeName, 0 );
; 8679 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@CompareAtt

; 8680 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareAtt
$LN2@CompareAtt:

; 8681 : 
; 8682 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@CompareAtt

; 8683 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@CompareAtt
$LN3@CompareAtt:

; 8684 :    else
; 8685 :    {
; 8686 :       // Call fnCompareAttributeToVariable to do the comparing
; 8687 :       nRC = fnCompareAttributeToVariable( lpView, lpViewEntityCsr,

	movzx	ecx, WORD PTR _nFlag$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulVariableLth$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _cVariableType$[ebp]
	push	edx
	mov	eax, DWORD PTR _zVariable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@CompareAtt:

; 8688 :                                           lpViewAttrib,
; 8689 :                                           (zPVOID) zVariable, cVariableType,
; 8690 :                                           ulVariableLth,
; 8691 :                                           cpcContextName, lpCurrentTask,
; 8692 :                                           nFlag );
; 8693 :    }
; 8694 : 
; 8695 :    fnOperationReturn( iCompareAttributeToVariable, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	278					; 00000116H
	call	_fnOperationReturn
	add	esp, 8

; 8696 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareAtt:

; 8697 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_CompareAttributeToVariable@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpDefaultContext$ = -20				; size = 4
tv132 = -16						; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lpVariable$ = 20					; size = 4
_cVariableType$ = 24					; size = 1
_ulVariableLth$ = 28					; size = 4
_cpcContextName$ = 32					; size = 4
_nFlag$ = 36						; size = 2
_SetAttributeFromVariable@32 PROC

; 7428 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 7429 :    LPTASK            lpCurrentTask;
; 7430 :    LPVIEWENTITY      lpViewEntity;
; 7431 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 7432 :    LPVIEWATTRIB      lpViewAttrib;
; 7433 :    zLPCONTEXT        lpDefaultContext;
; 7434 :    zSHORT            nRC;
; 7435 : 
; 7436 : // if ( zstrcmp( cpcEntityName, "QMsg" ) == 0 && cVariableType == 'B' )
; 7437 : //    TraceLineS( "", "" );
; 7438 : 
; 7439 :    // Validate parameters
; 7440 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	277					; 00000115H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 7441 :                                         &lpViewEntity,
; 7442 :                                         &lpViewEntityCsr,
; 7443 :                                         &lpViewAttrib,
; 7444 :                                         iSetAttributeFromVariable,
; 7445 :                                         1,   // We intend to update
; 7446 :                                         lpView,
; 7447 :                                         cpcEntityName,
; 7448 :                                         cpcAttributeName, 0 );
; 7449 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@SetAttribu

; 7450 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetAttribu
$LN2@SetAttribu:

; 7451 : 
; 7452 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@SetAttribu

; 7453 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	$LN4@SetAttribu
$LN3@SetAttribu:

; 7454 :    else
; 7455 :    {
; 7456 :       if ( nFlag & zUSE_DEFAULT_CONTEXT )

	movsx	ecx, WORD PTR _nFlag$[ebp]
	and	ecx, 8
	je	$LN5@SetAttribu

; 7457 :       {
; 7458 :          if ( GetDefaultContext( &lpDefaultContext,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	lea	ecx, DWORD PTR _lpDefaultContext$[ebp]
	push	ecx
	call	_GetDefaultContext@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN6@SetAttribu

; 7459 :                                  zGETPTR( lpViewAttrib->hDomain ) ) )
; 7460 :          {
; 7461 :             cpcContextName = lpDefaultContext->szName;

	mov	eax, DWORD PTR _lpDefaultContext$[ebp]
	add	eax, 6
	mov	DWORD PTR _cpcContextName$[ebp], eax

; 7462 :          }

	jmp	SHORT $LN5@SetAttribu
$LN6@SetAttribu:

; 7463 :          else
; 7464 :          {
; 7465 :             // "KZOEE232 - Operation indicates use default context,
; 7466 :             //  none found"
; 7467 :             fnIssueCoreError( lpCurrentTask, lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [ecx+198], 0
	je	SHORT $LN9@SetAttribu
	mov	DWORD PTR tv132[ebp], 16		; 00000010H
	jmp	SHORT $LN10@SetAttribu
$LN9@SetAttribu:
	mov	DWORD PTR tv132[ebp], 8
$LN10@SetAttribu:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	232					; 000000e8H
	movzx	ecx, WORD PTR tv132[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 7468 :                               (zSHORT) (lpViewAttrib->hDomain ? 16 : 8),
; 7469 :                               232, 0L, lpViewEntity->szName,
; 7470 :                               lpViewAttrib->szName );
; 7471 :             fnOperationReturn( iSetAttributeFromVariable, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	277					; 00000115H
	call	_fnOperationReturn
	add	esp, 8

; 7472 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetAttribu
$LN5@SetAttribu:

; 7473 :          }
; 7474 :       }
; 7475 : 
; 7476 :       // Call fnSetAttributeFromVariable to do the setting
; 7477 :       nRC = fnSetAttributeFromVariable( lpView, lpViewEntityCsr,

	movzx	edx, WORD PTR _nFlag$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulVariableLth$[ebp]
	push	edx
	movzx	eax, BYTE PTR _cVariableType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpVariable$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@SetAttribu:

; 7478 :                                         lpViewAttrib, lpVariable, cVariableType,
; 7479 :                                         ulVariableLth,
; 7480 :                                         cpcContextName,
; 7481 :                                         lpCurrentTask, nFlag );
; 7482 :    }
; 7483 : 
; 7484 :    fnOperationReturn( iSetAttributeFromVariable, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	277					; 00000115H
	call	_fnOperationReturn
	add	esp, 8

; 7485 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetAttribu:

; 7486 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_SetAttributeFromVariable@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_uReturnLth$1 = -104					; size = 4
_lpTgtViewEntity$ = -100				; size = 4
_uReturnLth$2 = -96					; size = 4
_lpTgtEntityInstance$ = -92				; size = 4
$T3 = -88						; size = 4
_lpSrcViewEntityCsr$ = -84				; size = 4
tv237 = -80						; size = 4
tv236 = -76						; size = 4
_lpSrcViewEntity$ = -72					; size = 4
tv210 = -68						; size = 4
tv209 = -64						; size = 4
$T4 = -60						; size = 4
_lpCurrentTask$ = -56					; size = 4
_lpTgtViewEntityCsr$ = -52				; size = 4
_nRCa$ = -48						; size = 2
_nRC$ = -44						; size = 2
_lpTgtViewAttrib$ = -40					; size = 4
_lpSrcViewAttrib$ = -36					; size = 4
_szWorkString$5 = -32					; size = 16
_szWorkString$6 = -16					; size = 9
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_nControl$ = 24						; size = 2
_SetMatchingAttributesByName@20 PROC

; 4769 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4770 :    LPTASK            lpCurrentTask;
; 4771 :    LPVIEWENTITY      lpSrcViewEntity;
; 4772 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 4773 :    LPVIEWATTRIB      lpSrcViewAttrib;
; 4774 :    LPVIEWENTITY      lpTgtViewEntity;
; 4775 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 4776 :    LPVIEWATTRIB      lpTgtViewAttrib;
; 4777 :    LPENTITYINSTANCE  lpTgtEntityInstance;
; 4778 :    zSHORT            nRCa;
; 4779 :    zSHORT            nRC;
; 4780 : 
; 4781 :    // Validate parameters for source attribute.
; 4782 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	0
	push	275					; 00000113H
	lea	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 4783 :                                         &lpSrcViewEntity,
; 4784 :                                         &lpSrcViewEntityCsr,
; 4785 :                                         &lpSrcViewAttrib,
; 4786 :                                         iSetMatchingAttributesByName,
; 4787 :                                         0,   // We do not intend to update
; 4788 :                                         lpSrcView,
; 4789 :                                         cpcSrcEntityName,
; 4790 :                                         0, 0 );
; 4791 :    if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN9@SetMatchin

; 4792 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN36@SetMatchin
$LN9@SetMatchin:

; 4793 : 
; 4794 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN10@SetMatchin

; 4795 :    {
; 4796 :       // Validate parameters for target attribute.
; 4797 :       nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	4112					; 00001010H
	push	0
	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	push	1
	push	275					; 00000113H
	lea	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN10@SetMatchin:

; 4798 :                                            &lpTgtViewEntity,
; 4799 :                                            &lpTgtViewEntityCsr,
; 4800 :                                            &lpTgtViewAttrib,
; 4801 :                                            iSetMatchingAttributesByName,
; 4802 :                                            1,   // We DO intend to update
; 4803 :                                            lpTgtView,
; 4804 :                                            cpcTgtEntityName,
; 4805 :                                            0,
; 4806 :                                            zIGNORE_KEYS |
; 4807 :                                              zUSE_TASK ); // Oper id already passed
; 4808 :    }
; 4809 : 
; 4810 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN11@SetMatchin

; 4811 :    {
; 4812 :       fnOperationReturn( iSetMatchingAttributesByName, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	275					; 00000113H
	call	_fnOperationReturn
	add	esp, 8

; 4813 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN36@SetMatchin
$LN11@SetMatchin:

; 4814 :    }
; 4815 : 
; 4816 :    nRC = 0; // Initialize to no errors

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 4817 : 
; 4818 :    // For each target view attrib, see if there is a matching
; 4819 :    // entity in the source. NOTE, we attempt to pick up the source view
; 4820 :    // attribute from where we left off to optimize attribute setting when
; 4821 :    // the attribute lists are essentially the same and the order is
; 4822 :    // also preserved.
; 4823 :    for ( lpTgtEntityInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
	jmp	SHORT $LN4@SetMatchin
$LN2@SetMatchin:

; 4825 :          lpTgtViewAttrib = zGETPTR( lpTgtViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewAttrib$[ebp], eax
$LN4@SetMatchin:

; 4824 :          lpTgtViewAttrib;

	cmp	DWORD PTR _lpTgtViewAttrib$[ebp], 0
	je	$LN3@SetMatchin

; 4826 :    {
; 4827 :       // Don't set the attribute if one of the following occurs:
; 4828 :       //    o  Target attribute is hidden.
; 4829 :       //    o  Target attribute does not allow updates.
; 4830 :       //    o  Target attribute is a derived attribute.
; 4831 :       //    o  Target entity was not just created (this means that the entity
; 4832 :       //       has been committed to the database) AND the attribute cannot
; 4833 :       //       be updated once it has been committed.
; 4834 :       //
; 4835 :       // If any of these conditions occur, just continue the loop.
; 4836 :       if ( lpTgtViewAttrib->bHidden            ||
; 4837 :            lpTgtViewAttrib->szDerivedOper[ 0 ] ||
; 4838 :            lpTgtViewAttrib->bNoUpdate          ||

	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN13@SetMatchin
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+213]
	test	edx, edx
	jne	SHORT $LN13@SetMatchin
	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	jne	SHORT $LN13@SetMatchin
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN12@SetMatchin
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	je	SHORT $LN12@SetMatchin
$LN13@SetMatchin:

; 4839 :            (lpTgtEntityInstance->u.nInd.bCreated == FALSE &&
; 4840 :             lpTgtViewAttrib->bNoPersistUpd) )
; 4841 :       {
; 4842 :          continue;

	jmp	SHORT $LN2@SetMatchin
$LN12@SetMatchin:

; 4843 :       }
; 4844 : 
; 4845 :       if ( lpTgtViewAttrib->bKey )

	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN14@SetMatchin

; 4846 :       {
; 4847 :          // Attribute is a 'key', see if user wants to copy keys.  If not,
; 4848 :          // continue looping.
; 4849 :          if ( (nControl & zSET_KEYS ) == 0 )

	movsx	edx, WORD PTR _nControl$[ebp]
	and	edx, 1
	jne	SHORT $LN14@SetMatchin

; 4850 :          {
; 4851 : #if 0
; 4852 :             // Test code dks 2008.12.23
; 4853 :             zCHAR szWorkString[ 16 ];
; 4854 : 
; 4855 :             // Minimum Length for return string is 9, if the attribute
; 4856 :             // is of type DateTime ... maybe -2,000,000,000 would be 11.
; 4857 :             nRCa = fnGetStringFromAttribute( szWorkString, 16, lpTgtView,
; 4858 :                                              lpTgtViewEntityCsr,
; 4859 :                                              lpTgtViewAttrib, 0 );
; 4860 :             if ( nRCa == -1 )
; 4861 :                szWorkString[ 0 ] = 0;
; 4862 :             // End: Test code dks 2008.12.23
; 4863 : #endif
; 4864 :             continue; // Ignore the key.

	jmp	$LN2@SetMatchin
$LN14@SetMatchin:

; 4865 :          }
; 4866 :       }
; 4867 : 
; 4868 :       // Check to see if user wants to over-write non-null values.
; 4869 :       if ( (nControl & zSET_NOTNULL) == 0 )

	movsx	eax, WORD PTR _nControl$[ebp]
	and	eax, 2
	jne	$LN16@SetMatchin

; 4870 :       {
; 4871 :          // The user does NOT want attributes in the target entity that
; 4872 :          // already have values (i.e. they are not null) to be over-written
; 4873 :          // with values from the source entity.  Check the target entity's
; 4874 :          // value.  If it is not null, then continue looping.
; 4875 : 
; 4876 :          if ( lpTgtViewAttrib->cType == zTYPE_BLOB )

	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	jne	SHORT $LN17@SetMatchin

; 4877 :          {
; 4878 :             zULONG  uReturnLth;
; 4879 : 
; 4880 :             fnGetAttributeLength( &uReturnLth,

	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uReturnLth$2[ebp]
	push	ecx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 4881 :                                   lpTgtView,
; 4882 :                                   zGETPTR( lpTgtViewEntityCsr->hEntityInstance ),
; 4883 :                                   lpTgtViewAttrib );
; 4884 :             if ( uReturnLth > 0 )

	cmp	DWORD PTR _uReturnLth$2[ebp], 0
	jbe	SHORT $LN19@SetMatchin

; 4885 :                // Length of blob is > 0, so attribute is NOT null.
; 4886 :                continue;

	jmp	$LN2@SetMatchin
$LN19@SetMatchin:

; 4887 :          }

	jmp	SHORT $LN16@SetMatchin
$LN17@SetMatchin:

; 4888 :          else
; 4889 :          {
; 4890 :             zCHAR szWorkString[ 16 ];
; 4891 : 
; 4892 :             // Minimum Length for return string is 9, if the attribute
; 4893 :             // is of type DateTime ... maybe -2,000,000,000 would be 11.
; 4894 :             nRCa = fnGetStringFromAttribute( szWorkString, 16, lpTgtView,

	push	0
	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	push	16					; 00000010H
	lea	edx, DWORD PTR _szWorkString$5[ebp]
	push	edx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRCa$[ebp], ax

; 4895 :                                              lpTgtViewEntityCsr,
; 4896 :                                              lpTgtViewAttrib, 0 );
; 4897 : 
; 4898 :             // If the return code is -1, the attribute is null, so set szWorkString to null.
; 4899 :             if ( nRCa == -1 )

	movsx	eax, WORD PTR _nRCa$[ebp]
	cmp	eax, -1
	jne	SHORT $LN20@SetMatchin

; 4900 :                szWorkString[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 16			; 00000010H
	jae	SHORT $LN37@SetMatchin
	jmp	SHORT $LN38@SetMatchin
$LN37@SetMatchin:
	call	___report_rangecheckfailure
$LN38@SetMatchin:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szWorkString$5[ebp+eax], 0
$LN20@SetMatchin:

; 4901 : 
; 4902 :             // If the first char of szWorkString is NOT null, then the target attribute is
; 4903 :             // NOT null, so continue looping.
; 4904 :             if ( szWorkString[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szWorkString$5[ebp+edx]
	test	eax, eax
	je	SHORT $LN16@SetMatchin

; 4905 :                continue;

	jmp	$LN2@SetMatchin
$LN16@SetMatchin:

; 4906 :          }
; 4907 :       }
; 4908 : 
; 4909 :       if ( lpSrcViewEntity == lpTgtViewEntity )

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	cmp	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	jne	SHORT $LN5@SetMatchin

; 4910 :          lpSrcViewAttrib = lpTgtViewAttrib;

	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], edx
	jmp	$LN23@SetMatchin
$LN5@SetMatchin:

; 4911 :       else
; 4912 :       {
; 4913 :          // Try and pick up search from where we left off
; 4914 :          while ( lpSrcViewAttrib )

	cmp	DWORD PTR _lpSrcViewAttrib$[ebp], 0
	je	SHORT $LN6@SetMatchin

; 4915 :          {
; 4916 :             if ( zstrcmp( lpSrcViewAttrib->szName,
; 4917 :                           lpTgtViewAttrib->szName ) == 0 )

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	ecx, eax
	jne	SHORT $LN41@SetMatchin
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv210[ebp], eax
	jmp	SHORT $LN42@SetMatchin
$LN41@SetMatchin:
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN39@SetMatchin
	mov	DWORD PTR tv209[ebp], 1
	jmp	SHORT $LN40@SetMatchin
$LN39@SetMatchin:
	mov	DWORD PTR tv209[ebp], -1
$LN40@SetMatchin:
	mov	ecx, DWORD PTR tv209[ebp]
	mov	DWORD PTR tv210[ebp], ecx
$LN42@SetMatchin:
	cmp	DWORD PTR tv210[ebp], 0
	jne	SHORT $LN24@SetMatchin

; 4918 :             {
; 4919 :                break;

	jmp	SHORT $LN6@SetMatchin
$LN24@SetMatchin:

; 4920 :             }
; 4921 : 
; 4922 :             lpSrcViewAttrib = zGETPTR( lpSrcViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax

; 4923 :          }

	jmp	SHORT $LN5@SetMatchin
$LN6@SetMatchin:

; 4924 : 
; 4925 :          // If search failed, restart search from beginning of attrs
; 4926 :          if ( lpSrcViewAttrib == 0 )

	cmp	DWORD PTR _lpSrcViewAttrib$[ebp], 0
	jne	$LN23@SetMatchin

; 4927 :          {
; 4928 :             lpSrcViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax
$LN7@SetMatchin:

; 4929 :             while ( lpSrcViewAttrib )

	cmp	DWORD PTR _lpSrcViewAttrib$[ebp], 0
	je	SHORT $LN23@SetMatchin

; 4930 :             {
; 4931 :                if ( zstrcmp( lpSrcViewAttrib->szName,
; 4932 :                              lpTgtViewAttrib->szName ) == 0 )

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	ecx, eax
	jne	SHORT $LN45@SetMatchin
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv237[ebp], eax
	jmp	SHORT $LN46@SetMatchin
$LN45@SetMatchin:
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN43@SetMatchin
	mov	DWORD PTR tv236[ebp], 1
	jmp	SHORT $LN44@SetMatchin
$LN43@SetMatchin:
	mov	DWORD PTR tv236[ebp], -1
$LN44@SetMatchin:
	mov	ecx, DWORD PTR tv236[ebp]
	mov	DWORD PTR tv237[ebp], ecx
$LN46@SetMatchin:
	cmp	DWORD PTR tv237[ebp], 0
	jne	SHORT $LN26@SetMatchin

; 4933 :                {
; 4934 :                   break;

	jmp	SHORT $LN23@SetMatchin
$LN26@SetMatchin:

; 4935 :                }
; 4936 : 
; 4937 :                lpSrcViewAttrib = zGETPTR( lpSrcViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax

; 4938 :             }

	jmp	SHORT $LN7@SetMatchin
$LN23@SetMatchin:

; 4939 :          }
; 4940 :       }
; 4941 : 
; 4942 :       // Source attribute cannot be hidden or derived either.
; 4943 :       if ( lpSrcViewAttrib == 0 ||
; 4944 :            lpSrcViewAttrib->bHidden || lpSrcViewAttrib->szDerivedOper[ 0 ] )

	cmp	DWORD PTR _lpSrcViewAttrib$[ebp], 0
	je	SHORT $LN28@SetMatchin
	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN28@SetMatchin
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+213]
	test	eax, eax
	je	SHORT $LN27@SetMatchin
$LN28@SetMatchin:

; 4945 :       {
; 4946 :          continue;

	jmp	$LN2@SetMatchin
$LN27@SetMatchin:

; 4947 :       }
; 4948 : 
; 4949 :       if ( nControl & zSET_SRCNOTNULL )

	movsx	ecx, WORD PTR _nControl$[ebp]
	and	ecx, 4
	je	$LN29@SetMatchin

; 4950 :       {
; 4951 :          // User doesn't want NULL source attributes to be copied.
; 4952 :          if ( lpSrcViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN30@SetMatchin

; 4953 :          {
; 4954 :             zULONG  uReturnLth;
; 4955 : 
; 4956 :             fnGetAttributeLength( &uReturnLth,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uReturnLth$1[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 4957 :                                   lpSrcView,
; 4958 :                                   zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),
; 4959 :                                   lpSrcViewAttrib );
; 4960 :             if ( uReturnLth == 0 )

	cmp	DWORD PTR _uReturnLth$1[ebp], 0
	jne	SHORT $LN32@SetMatchin

; 4961 :                // Length of blob is == 0, so attribute is null.
; 4962 :                continue;

	jmp	$LN2@SetMatchin
$LN32@SetMatchin:

; 4963 :          }

	jmp	SHORT $LN29@SetMatchin
$LN30@SetMatchin:

; 4964 :          else
; 4965 :          {
; 4966 : 
; 4967 :             zCHAR szWorkString[ 9 ];
; 4968 : 
; 4969 :             // Minimum Length for return string is 9, if the attribute
; 4970 :             // is of type DateTime.
; 4971 :             nRCa = fnGetStringFromAttribute( szWorkString, 9, lpSrcView,

	push	0
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	9
	lea	eax, DWORD PTR _szWorkString$6[ebp]
	push	eax
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRCa$[ebp], ax

; 4972 :                                              lpSrcViewEntityCsr,
; 4973 :                                              lpSrcViewAttrib, 0 );
; 4974 : 
; 4975 :             // If the return code is -1, the attribute is null, so set
; 4976 :             // szWorkString to null.
; 4977 :             if ( nRCa == -1 )

	movsx	ecx, WORD PTR _nRCa$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN33@SetMatchin

; 4978 :                szWorkString[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 9
	jae	SHORT $LN47@SetMatchin
	jmp	SHORT $LN48@SetMatchin
$LN47@SetMatchin:
	call	___report_rangecheckfailure
$LN48@SetMatchin:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szWorkString$6[ebp+ecx], 0
$LN33@SetMatchin:

; 4979 : 
; 4980 :             // If first char of szWorkString is null, then the source
; 4981 :             // attribute is null, so continue looping.
; 4982 :             if ( szWorkString[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szWorkString$6[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN29@SetMatchin

; 4983 :                continue;

	jmp	$LN2@SetMatchin
$LN29@SetMatchin:

; 4984 :          }
; 4985 :       }
; 4986 : 
; 4987 :       // If we found a matching attribute, call SetAttributeFromAttribute
; 4988 :       // to copy the attribute
; 4989 :       nRCa = SetAttributeFromAttribute( lpTgtView, cpcTgtEntityName,

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_SetAttributeFromAttribute@24
	mov	WORD PTR _nRCa$[ebp], ax

; 4990 :                                         lpTgtViewAttrib->szName,
; 4991 :                                         lpSrcView, cpcSrcEntityName,
; 4992 :                                         lpSrcViewAttrib->szName );
; 4993 :       if ( nRC == 0 && nRCa )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN35@SetMatchin
	movsx	eax, WORD PTR _nRCa$[ebp]
	test	eax, eax
	je	SHORT $LN35@SetMatchin

; 4994 :          nRC = nRCa;

	mov	cx, WORD PTR _nRCa$[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN35@SetMatchin:

; 4995 : 
; 4996 :    } // for ( lpViewAttribute... )...

	jmp	$LN2@SetMatchin
$LN3@SetMatchin:

; 4997 : 
; 4998 :    fnOperationReturn( iSetMatchingAttributesByName, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	275					; 00000113H
	call	_fnOperationReturn
	add	esp, 8

; 4999 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN36@SetMatchin:

; 5000 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetMatchingAttributesByName@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pulReturnLth$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_GetActualAttributeLength@16 PROC

; 2295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2296 :    LPTASK            lpCurrentTask;
; 2297 :    LPVIEWENTITY      lpViewEntity;
; 2298 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2299 :    LPVIEWATTRIB      lpViewAttrib;
; 2300 :    zSHORT            nRC;
; 2301 : 
; 2302 :    // Validate parameters
; 2303 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	289					; 00000121H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 2304 :                                         &lpViewEntity,
; 2305 :                                         &lpViewEntityCsr,
; 2306 :                                         &lpViewAttrib,
; 2307 :                                         iGetActualAttributeLength,
; 2308 :                                         0,   // We do not intend to update
; 2309 :                                         lpView,
; 2310 :                                         cpcEntityName,
; 2311 :                                         cpcAttributeName, 0 );
; 2312 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@GetActualA

; 2313 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetActualA
$LN2@GetActualA:

; 2314 : 
; 2315 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@GetActualA

; 2316 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@GetActualA
$LN3@GetActualA:

; 2317 :    else
; 2318 :       nRC = fnGetActualAttributeLength( pulReturnLth, lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	push	ecx
	call	_fnGetActualAttributeLength
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@GetActualA:

; 2319 :                                         lpViewEntityCsr, lpViewAttrib );
; 2320 : 
; 2321 :    fnOperationReturn( iGetActualAttributeLength, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	289					; 00000121H
	call	_fnOperationReturn
	add	esp, 8

; 2322 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetActualA:

; 2323 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetActualAttributeLength@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -140					; size = 4
_lpTask$1 = -136					; size = 4
_lpDomain$2 = -132					; size = 4
_lpViewEntityCsr$ = -128				; size = 4
_lpContext$3 = -124					; size = 4
_lpCurrentTask$ = -120					; size = 4
_lpViewAttrib$ = -116					; size = 4
_nRC$ = -112						; size = 2
_sz$4 = -108						; size = 102
__$ArrayPad$ = -4					; size = 4
_pulReturnLth$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_cpcContextName$ = 24					; size = 4
_GetAttributeDisplayLength@20 PROC

; 1904 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1905 :    LPTASK            lpCurrentTask;
; 1906 :    LPVIEWENTITY      lpViewEntity;
; 1907 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1908 :    LPVIEWATTRIB      lpViewAttrib;
; 1909 :    zSHORT            nRC;
; 1910 : 
; 1911 :    *pulReturnLth = 0; // initialize to 0.

	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [eax], 0

; 1912 : 
; 1913 :    // Validate parameters
; 1914 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	1
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	push	293					; 00000125H
	lea	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 1915 :                                         &lpViewEntity,
; 1916 :                                         &lpViewEntityCsr,
; 1917 :                                         &lpViewAttrib,
; 1918 :                                         iGetAttributeDisplayLength,
; 1919 :                                         0,   // We do not intend to update
; 1920 :                                         lpView,
; 1921 :                                         cpcEntityName,
; 1922 :                                         cpcAttributeName,
; 1923 :                                         zACCEPT_NULL_ENTITY );
; 1924 : 
; 1925 :    if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN2@GetAttribu

; 1926 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetAttribu
$LN2@GetAttribu:

; 1927 : 
; 1928 :    // We need to know the length even if the entity instance is null.
; 1929 :    // Therefore when domains are performing GetVariable processing for
; 1930 :    // a chType of zTYPE_PIC, they should not try to retrieve any data
; 1931 :    // from the entity instance.
; 1932 : 
; 1933 :    if ( nRC && nRC != -2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN3@GetAttribu
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -2					; fffffffeH
	je	SHORT $LN3@GetAttribu

; 1934 :    {
; 1935 :       fnOperationReturn( iGetAttributeDisplayLength, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	293					; 00000125H
	call	_fnOperationReturn
	add	esp, 8

; 1936 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetAttribu
$LN3@GetAttribu:

; 1937 :    }
; 1938 : 
; 1939 :    if ( lpViewAttrib->hDomain )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	je	$LN4@GetAttribu

; 1940 :    {
; 1941 :       zLPCONTEXT   lpContext;
; 1942 : 
; 1943 :       if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN8@GetAttribu
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN6@GetAttribu
$LN8@GetAttribu:

; 1944 :       {
; 1945 :          nRC = GetDefaultContext( &lpContext,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	lea	ecx, DWORD PTR _lpContext$3[ebp]
	push	ecx
	call	_GetDefaultContext@8
	mov	WORD PTR _nRC$[ebp], ax

; 1946 :                                   zGETPTR( lpViewAttrib->hDomain ) );
; 1947 :       }

	jmp	SHORT $LN7@GetAttribu
$LN6@GetAttribu:

; 1948 :       else
; 1949 :       {
; 1950 :          nRC = GetContext( &lpContext, zGETPTR( lpViewAttrib->hDomain ),

	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	lea	edx, DWORD PTR _lpContext$3[ebp]
	push	edx
	call	_GetContext@12
	mov	WORD PTR _nRC$[ebp], ax
$LN7@GetAttribu:

; 1951 :                            cpcContextName );
; 1952 :       }
; 1953 : 
; 1954 :       if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN9@GetAttribu

; 1955 :       {
; 1956 :          nRC = fnGetAttributeDisplayLength( pulReturnLth, lpView,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpContext$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	push	eax
	call	_fnGetAttributeDisplayLength
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 1957 :                                             lpViewEntityCsr, lpViewAttrib,
; 1958 :                                             lpContext, lpCurrentTask );
; 1959 :       }

	jmp	$LN10@GetAttribu
$LN9@GetAttribu:

; 1960 :       else
; 1961 :       {
; 1962 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 1963 :          zCHAR  sz[ 102 ];
; 1964 :          LPDOMAIN lpDomain;
; 1965 : 
; 1966 :          zstrcpy( sz, cpcEntityName );

	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1967 :          zstrcat( sz, ", " );

	push	OFFSET $SG15170
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1968 :          zstrcat( sz, cpcAttributeName );

	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1969 :          zstrcat( sz, ", " );

	push	OFFSET $SG15171
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1970 :          lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$2[ebp], eax

; 1971 :          zstrcat( sz, lpDomain->szName );

	mov	edx, DWORD PTR _lpDomain$2[ebp]
	add	edx, 6
	push	edx
	lea	eax, DWORD PTR _sz$4[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1972 : 
; 1973 :          // "KZOEE350 - Context Not Valid for Domain"
; 1974 :          fnIssueCoreError( lpTask, lpView, 8, 350, 0, sz, cpcContextName );

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	push	0
	push	350					; 0000015eH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1975 :          nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN10@GetAttribu:

; 1976 :       }
; 1977 :    }

	jmp	SHORT $LN5@GetAttribu
$LN4@GetAttribu:

; 1978 :    else
; 1979 :    {
; 1980 :       nRC = fnGetAttributeLength( pulReturnLth, lpView,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	push	ecx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax
$LN5@GetAttribu:

; 1981 :                                   zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 1982 :                                   lpViewAttrib );
; 1983 :    }
; 1984 : 
; 1985 :    fnOperationReturn( iGetAttributeDisplayLength, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	293					; 00000125H
	call	_fnOperationReturn
	add	esp, 8

; 1986 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetAttribu:

; 1987 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GetAttributeDisplayLength@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pulReturnLth$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_GetAttributeLength@16 PROC

; 2161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2162 :    LPTASK            lpCurrentTask;
; 2163 :    LPVIEWENTITY      lpViewEntity;
; 2164 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2165 :    LPVIEWATTRIB      lpViewAttrib;
; 2166 :    zSHORT            nRC;
; 2167 : 
; 2168 :    // Validate parameters
; 2169 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	274					; 00000112H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 2170 :                                         &lpViewEntity,
; 2171 :                                         &lpViewEntityCsr,
; 2172 :                                         &lpViewAttrib,
; 2173 :                                         iGetAttributeLength,
; 2174 :                                         0,   // We do not intend to update
; 2175 :                                         lpView,
; 2176 :                                         cpcEntityName,
; 2177 :                                         cpcAttributeName, 0 );
; 2178 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@GetAttribu

; 2179 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetAttribu
$LN2@GetAttribu:

; 2180 : 
; 2181 :    if ( nRC && nRC != -2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@GetAttribu
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN3@GetAttribu

; 2182 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN4@GetAttribu
$LN3@GetAttribu:

; 2183 :    else
; 2184 :    {
; 2185 :       nRC = fnGetAttributeLength( pulReturnLth,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pulReturnLth$[ebp]
	push	eax
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@GetAttribu:

; 2186 :                                   lpView,
; 2187 :                                   zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 2188 :                                   lpViewAttrib );
; 2189 :    }
; 2190 : 
; 2191 :    fnOperationReturn( iGetAttributeLength, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	274					; 00000112H
	call	_fnOperationReturn
	add	esp, 8

; 2192 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetAttribu:

; 2193 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetAttributeLength@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_dSrcDecimal$ = 20					; size = 40
_CompareAttributeToDecimal@52 PROC

; 5599 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 5600 :    LPTASK            lpCurrentTask;
; 5601 :    LPVIEWENTITY      lpViewEntity;
; 5602 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 5603 :    LPVIEWATTRIB      lpViewAttrib;
; 5604 :    zSHORT            nRC;
; 5605 : 
; 5606 :    // Validate parameters for source attribute
; 5607 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	272					; 00000110H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 5608 :                                         &lpViewEntity,
; 5609 :                                         &lpViewEntityCsr,
; 5610 :                                         &lpViewAttrib,
; 5611 :                                         iCompareAttributeToDecimal,
; 5612 :                                         0,   // We do not intend to update
; 5613 :                                         lpView,
; 5614 :                                         cpcEntityName,
; 5615 :                                         cpcAttributeName, 0 );
; 5616 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@CompareAtt

; 5617 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareAtt
$LN2@CompareAtt:

; 5618 : 
; 5619 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@CompareAtt

; 5620 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@CompareAtt
$LN3@CompareAtt:

; 5621 :    else
; 5622 :       nRC = fnCompareAttributeToVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	77					; 0000004dH
	lea	edx, DWORD PTR _dSrcDecimal$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@CompareAtt:

; 5623 :                                           (zPVOID) &dSrcDecimal, zTYPE_DECIMAL,
; 5624 :                                           0, 0, lpCurrentTask, 0 );
; 5625 : 
; 5626 :    fnOperationReturn( iCompareAttributeToDecimal, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	272					; 00000110H
	call	_fnOperationReturn
	add	esp, 8

; 5627 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareAtt:

; 5628 : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_CompareAttributeToDecimal@52 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lSrcInteger$ = 20					; size = 4
_CompareAttributeToInteger@16 PROC

; 5543 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 5544 :    LPTASK            lpCurrentTask;
; 5545 :    LPVIEWENTITY      lpViewEntity;
; 5546 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 5547 :    LPVIEWATTRIB      lpViewAttrib;
; 5548 :    zSHORT            nRC;
; 5549 : 
; 5550 :    // Validate parameters for source attribute
; 5551 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	271					; 0000010fH
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 5552 :                                         &lpViewEntity,
; 5553 :                                         &lpViewEntityCsr,
; 5554 :                                         &lpViewAttrib,
; 5555 :                                         iCompareAttributeToInteger,
; 5556 :                                         0,   // We do not intend to update
; 5557 :                                         lpView,
; 5558 :                                         cpcEntityName,
; 5559 :                                         cpcAttributeName, 0 );
; 5560 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@CompareAtt

; 5561 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareAtt
$LN2@CompareAtt:

; 5562 : 
; 5563 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@CompareAtt

; 5564 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@CompareAtt
$LN3@CompareAtt:

; 5565 :    else
; 5566 :       nRC = fnCompareAttributeToVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	76					; 0000004cH
	lea	edx, DWORD PTR _lSrcInteger$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@CompareAtt:

; 5567 :                                           (zPVOID) &lSrcInteger, zTYPE_INTEGER,
; 5568 :                                           0, 0, lpCurrentTask, 0 );
; 5569 : 
; 5570 :    fnOperationReturn( iCompareAttributeToInteger, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	271					; 0000010fH
	call	_fnOperationReturn
	add	esp, 8

; 5571 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareAtt:

; 5572 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CompareAttributeToInteger@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcSrcString$ = 20					; size = 4
_CompareAttributeToString@16 PROC

; 5487 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 5488 :    LPTASK            lpCurrentTask;
; 5489 :    LPVIEWENTITY      lpViewEntity;
; 5490 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 5491 :    LPVIEWATTRIB      lpViewAttrib;
; 5492 :    zSHORT            nRC;
; 5493 : 
; 5494 :    // Validate parameters for source attribute
; 5495 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	270					; 0000010eH
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 5496 :                                         &lpViewEntity,
; 5497 :                                         &lpViewEntityCsr,
; 5498 :                                         &lpViewAttrib,
; 5499 :                                         iCompareAttributeToString,
; 5500 :                                         0,   // We do not intend to update
; 5501 :                                         lpView,
; 5502 :                                         cpcEntityName,
; 5503 :                                         cpcAttributeName, 0 );
; 5504 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@CompareAtt

; 5505 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareAtt
$LN2@CompareAtt:

; 5506 : 
; 5507 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@CompareAtt

; 5508 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@CompareAtt
$LN3@CompareAtt:

; 5509 :    else
; 5510 :       nRC = fnCompareAttributeToVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	83					; 00000053H
	mov	edx, DWORD PTR _cpcSrcString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@CompareAtt:

; 5511 :                                           (zPVOID) cpcSrcString, zTYPE_STRING,
; 5512 :                                           0, 0, lpCurrentTask, 0 );
; 5513 : 
; 5514 :    fnOperationReturn( iCompareAttributeToString, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	270					; 0000010eH
	call	_fnOperationReturn
	add	esp, 8

; 5515 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareAtt:

; 5516 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CompareAttributeToString@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTgtTaskDomain$ = -131560				; size = 4
_SrcBlobAddr$1 = -131556				; size = 4
_lpSrcViewEntity$ = -131552				; size = 4
_lTempValue$2 = -131548					; size = 4
_lpDomain$3 = -131544					; size = 4
_lpTgtViewEntity$ = -131540				; size = 4
_lpTgtDateTime$4 = -131536				; size = 4
_lpSrcDateTime$5 = -131532				; size = 4
_TgtBlobAddr$6 = -131528				; size = 4
tv347 = -131524						; size = 4
_ulSrcBlobLength$7 = -131520				; size = 4
_ulReturnSrcLth$8 = -131516				; size = 4
_lpSrcTaskDomain$ = -131512				; size = 4
tv146 = -131508						; size = 4
tv462 = -131504						; size = 4
tv461 = -131500						; size = 4
tv415 = -131496						; size = 4
tv414 = -131492						; size = 4
_plTarget$9 = -131488					; size = 4
_plSource$10 = -131484					; size = 4
_pchRecord$ = -131480					; size = 4
_lpSrcDomain$11 = -131476				; size = 4
_pchTgtString$12 = -131472				; size = 4
_pchSrcString$13 = -131468				; size = 4
_ulTgtBlobLength$14 = -131464				; size = 4
_pchContextName$15 = -131460				; size = 4
_nRC2$16 = -131456					; size = 2
_bMustDoDomains$ = -131452				; size = 2
_lpSrcViewEntityCsr$ = -131448				; size = 4
_lpTgtViewEntityCsr$ = -131444				; size = 4
_lpCurrentTask$ = -131440				; size = 4
_nRC1$17 = -131436					; size = 2
_cSrcDomainType$ = -131429				; size = 1
_lpTgtViewAttrib$ = -131428				; size = 4
_lpSrcViewAttrib$ = -131424				; size = 4
_cTgtDomainType$ = -131417				; size = 1
_nRC$ = -131416						; size = 2
_dTgtCompare$18 = -131412				; size = 40
_dSrcCompare$19 = -131372				; size = 40
_szSrcCompare$20 = -131332				; size = 65535
_szTgtCompare$21 = -65796				; size = 65535
_szTemp$22 = -260					; size = 254
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_cpcTgtAttributeName$ = 16				; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_cpcSrcAttributeName$ = 28				; size = 4
_CompareAttributeToAttribute@24 PROC

; 5110 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 131560				; 000201e8H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5111 :    LPTASK            lpCurrentTask;
; 5112 :    LPVIEWENTITY      lpTgtViewEntity;
; 5113 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 5114 :    LPVIEWATTRIB      lpTgtViewAttrib;
; 5115 :    LPVIEWENTITY      lpSrcViewEntity;
; 5116 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 5117 :    LPVIEWATTRIB      lpSrcViewAttrib;
; 5118 :    LPTASKDOMAIN      lpSrcTaskDomain;
; 5119 :    LPTASKDOMAIN      lpTgtTaskDomain;
; 5120 :    zCHAR             cSrcDomainType;
; 5121 :    zCHAR             cTgtDomainType;
; 5122 :    zSHORT            bMustDoDomains;
; 5123 :    zPCHAR            pchRecord;
; 5124 :    zSHORT            nRC;
; 5125 : 
; 5126 :    // Validate parameters for target attribute.
; 5127 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	push	0
	push	273					; 00000111H
	lea	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 5128 :                                         &lpTgtViewEntity,
; 5129 :                                         &lpTgtViewEntityCsr,
; 5130 :                                         &lpTgtViewAttrib,
; 5131 :                                         iCompareAttributeToAttribute,
; 5132 :                                         0,   // We do not intend to update
; 5133 :                                         lpTgtView,
; 5134 :                                         cpcTgtEntityName,
; 5135 :                                         cpcTgtAttributeName, 0 );
; 5136 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@CompareAtt

; 5137 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CompareAtt
$LN2@CompareAtt:

; 5138 : 
; 5139 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN3@CompareAtt

; 5140 :    {
; 5141 :       // Validate parameters for source attribute.
; 5142 :       nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	4096					; 00001000H
	mov	eax, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	0
	push	273					; 00000111H
	lea	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN3@CompareAtt:

; 5143 :                                            &lpSrcViewEntity,
; 5144 :                                            &lpSrcViewEntityCsr,
; 5145 :                                            &lpSrcViewAttrib,
; 5146 :                                            iCompareAttributeToAttribute,
; 5147 :                                            0,   // We do not intend to update
; 5148 :                                            lpSrcView,
; 5149 :                                            cpcSrcEntityName,
; 5150 :                                            cpcSrcAttributeName,
; 5151 :                                            zUSE_TASK ); // Oper id already passed
; 5152 :    }
; 5153 : 
; 5154 :    if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@CompareAtt

; 5155 :    {
; 5156 :       fnOperationReturn( iCompareAttributeToAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	273					; 00000111H
	call	_fnOperationReturn
	add	esp, 8

; 5157 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CompareAtt
$LN4@CompareAtt:

; 5158 :    }
; 5159 : 
; 5160 :    // Invoke derived operation for Src.
; 5161 :    if ( lpSrcViewAttrib->szDerivedOper[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+213]
	test	eax, eax
	je	SHORT $LN5@CompareAtt

; 5162 :       fnInvokeDerivedOperation( lpSrcView, lpSrcViewEntity,

	push	2
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
$LN5@CompareAtt:

; 5163 :                                 lpSrcViewAttrib, lpCurrentTask,
; 5164 :                                 zDERIVED_GET );
; 5165 : 
; 5166 :    cTgtDomainType = fnDomainProcessingRequired( &lpTgtTaskDomain,

	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtTaskDomain$[ebp]
	push	eax
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cTgtDomainType$[ebp], al

; 5167 :                                                 lpTgtView,
; 5168 :                                                 lpCurrentTask,
; 5169 :                                                 zGETPTR( lpTgtViewAttrib->hDomain ) );
; 5170 : 
; 5171 :    bMustDoDomains = cTgtDomainType ? 1 : 0;

	movsx	ecx, BYTE PTR _cTgtDomainType$[ebp]
	test	ecx, ecx
	je	SHORT $LN66@CompareAtt
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $LN67@CompareAtt
$LN66@CompareAtt:
	mov	DWORD PTR tv146[ebp], 0
$LN67@CompareAtt:
	mov	dx, WORD PTR tv146[ebp]
	mov	WORD PTR _bMustDoDomains$[ebp], dx

; 5172 : 
; 5173 :    // Just to get the SrcTaskDomain pointer.
; 5174 :    cSrcDomainType = fnDomainProcessingRequired( &lpSrcTaskDomain,

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cSrcDomainType$[ebp], al

; 5175 :                                                 lpSrcView, lpCurrentTask,
; 5176 :                                                 zGETPTR( lpSrcViewAttrib->hDomain ) );
; 5177 : 
; 5178 :    if ( bMustDoDomains &&

	movsx	edx, WORD PTR _bMustDoDomains$[ebp]
	test	edx, edx
	je	SHORT $LN6@CompareAtt
	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	edx, DWORD PTR [eax+198]
	cmp	edx, DWORD PTR [ecx+198]
	jne	SHORT $LN6@CompareAtt

; 5179 :         lpTgtViewAttrib->hDomain == lpSrcViewAttrib->hDomain )
; 5180 :    {
; 5181 :       bMustDoDomains = 0;

	xor	eax, eax
	mov	WORD PTR _bMustDoDomains$[ebp], ax
$LN6@CompareAtt:

; 5182 :    }
; 5183 : 
; 5184 :    if ( bMustDoDomains )

	movsx	ecx, WORD PTR _bMustDoDomains$[ebp]
	test	ecx, ecx
	je	$LN7@CompareAtt

; 5185 :    {
; 5186 :       zPCHAR   pchContextName;
; 5187 :       zULONG   ulReturnSrcLth;
; 5188 :       LPDOMAIN lpSrcDomain;
; 5189 : 
; 5190 :       // We will not use the Domain Name as a Context Name if the target is a
; 5191 :       // format domain or if only one of the source/target domains is a table.
; 5192 :       if ( (cTgtDomainType == zDM_TYPE_FORMAT) ||
; 5193 :            (cTgtDomainType == zDM_TYPE_TABLE && cSrcDomainType != zDM_TYPE_TABLE) ||

	movsx	edx, BYTE PTR _cTgtDomainType$[ebp]
	cmp	edx, 70					; 00000046H
	je	SHORT $LN11@CompareAtt
	movsx	eax, BYTE PTR _cTgtDomainType$[ebp]
	cmp	eax, 84					; 00000054H
	jne	SHORT $LN12@CompareAtt
	movsx	ecx, BYTE PTR _cSrcDomainType$[ebp]
	cmp	ecx, 84					; 00000054H
	jne	SHORT $LN11@CompareAtt
$LN12@CompareAtt:
	movsx	edx, BYTE PTR _cSrcDomainType$[ebp]
	cmp	edx, 84					; 00000054H
	jne	SHORT $LN9@CompareAtt
	movsx	eax, BYTE PTR _cTgtDomainType$[ebp]
	cmp	eax, 84					; 00000054H
	je	SHORT $LN9@CompareAtt
$LN11@CompareAtt:

; 5194 :            (cSrcDomainType == zDM_TYPE_TABLE && cTgtDomainType != zDM_TYPE_TABLE) )
; 5195 :       {
; 5196 :          pchContextName = 0;

	mov	DWORD PTR _pchContextName$15[ebp], 0

; 5197 :       }

	jmp	SHORT $LN10@CompareAtt
$LN9@CompareAtt:

; 5198 :       else
; 5199 :       if ( lpSrcTaskDomain )

	cmp	DWORD PTR _lpSrcTaskDomain$[ebp], 0
	je	SHORT $LN13@CompareAtt

; 5200 :       {
; 5201 :          LPDOMAIN lpDomain = zGETPTR( lpSrcTaskDomain->hDomain );

	mov	ecx, DWORD PTR _lpSrcTaskDomain$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$3[ebp], eax

; 5202 : 
; 5203 :          pchContextName = lpDomain->szName;

	mov	eax, DWORD PTR _lpDomain$3[ebp]
	add	eax, 6
	mov	DWORD PTR _pchContextName$15[ebp], eax

; 5204 :       }

	jmp	SHORT $LN10@CompareAtt
$LN13@CompareAtt:

; 5205 :       else
; 5206 :          pchContextName = 0;

	mov	DWORD PTR _pchContextName$15[ebp], 0
$LN10@CompareAtt:

; 5207 : 
; 5208 :       fnGetActualAttributeLength( &ulReturnSrcLth, lpSrcView,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulReturnSrcLth$8[ebp]
	push	ecx
	call	_fnGetActualAttributeLength
	add	esp, 16					; 00000010H

; 5209 :                                   lpSrcViewEntityCsr, lpSrcViewAttrib );
; 5210 : 
; 5211 :       fnGetAddrForAttribute( (zCOREMEM) &pchRecord, lpSrcView,

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5212 :                              lpSrcViewEntityCsr, 0, lpSrcViewAttrib );
; 5213 : 
; 5214 :       // If both the source and target domains are tables, we will get the
; 5215 :       // value of the source as an external value and pass it to the target
; 5216 :       // domain.
; 5217 :       if ( cSrcDomainType == zDM_TYPE_TABLE &&

	movsx	eax, BYTE PTR _cSrcDomainType$[ebp]
	cmp	eax, 84					; 00000054H
	jne	$LN15@CompareAtt
	movsx	ecx, BYTE PTR _cTgtDomainType$[ebp]
	cmp	ecx, 84					; 00000054H
	jne	$LN15@CompareAtt

; 5218 :            cTgtDomainType == zDM_TYPE_TABLE )
; 5219 :       {
; 5220 :          zLONG lTempValue;
; 5221 :          zCHAR szTemp[ 254 ];
; 5222 : 
; 5223 :          lpSrcDomain = zGETPTR( lpSrcViewAttrib->hDomain );

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcDomain$11[ebp], eax

; 5224 :          if ( lpSrcDomain->cType == zTYPE_DECIMAL )

	mov	ecx, DWORD PTR _lpSrcDomain$11[ebp]
	movsx	edx, BYTE PTR [ecx+63]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN17@CompareAtt

; 5225 :          {
; 5226 :             SysConvertDecimalToLong( (zPDECIMAL) pchRecord,

	lea	eax, DWORD PTR _lTempValue$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8

; 5227 :                                      &lTempValue );
; 5228 :             TableEntryIntToExt( (zPVOID) szTemp, lpSrcView,

	lea	edx, DWORD PTR _lTempValue$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pchContextName$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcDomain$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTemp$22[ebp]
	push	eax
	call	_TableEntryIntToExt@20

; 5229 :                                 lpSrcDomain,
; 5230 :                                 pchContextName,
; 5231 :                                 &lTempValue );
; 5232 :          }

	jmp	SHORT $LN18@CompareAtt
$LN17@CompareAtt:

; 5233 :          else
; 5234 :          {
; 5235 :             TableEntryIntToExt( (zPVOID) szTemp, lpSrcView,

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchContextName$15[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcDomain$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTemp$22[ebp]
	push	edx
	call	_TableEntryIntToExt@20
$LN18@CompareAtt:

; 5236 :                                 lpSrcDomain,
; 5237 :                                 pchContextName,
; 5238 :                                 pchRecord );
; 5239 :          }
; 5240 : 
; 5241 :          nRC = fnCompareAttributeToVariable( lpTgtView,

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchContextName$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulReturnSrcLth$8[ebp]
	push	edx
	push	83					; 00000053H
	lea	eax, DWORD PTR _szTemp$22[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax

; 5242 :                                              lpTgtViewEntityCsr,
; 5243 :                                              lpTgtViewAttrib,
; 5244 :                                              (zPVOID) szTemp,
; 5245 :                                              zTYPE_STRING,
; 5246 :                                              ulReturnSrcLth,  // not really used
; 5247 :                                              pchContextName,
; 5248 :                                              lpCurrentTask, 0 );
; 5249 :       }

	jmp	SHORT $LN16@CompareAtt
$LN15@CompareAtt:

; 5250 :       else
; 5251 :       {
; 5252 :          nRC = fnCompareAttributeToVariable( lpTgtView,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchContextName$15[ebp]
	push	edx
	mov	eax, DWORD PTR _ulReturnSrcLth$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movzx	edx, BYTE PTR [ecx+202]
	push	edx
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN16@CompareAtt:

; 5253 :                                              lpTgtViewEntityCsr,
; 5254 :                                              lpTgtViewAttrib,
; 5255 :                                              pchRecord,
; 5256 :                                              lpSrcViewAttrib->cType,
; 5257 :                                              ulReturnSrcLth,
; 5258 :                                              pchContextName,
; 5259 :                                              lpCurrentTask, 0 );
; 5260 :       }
; 5261 :    }

	jmp	$LN8@CompareAtt
$LN7@CompareAtt:

; 5262 :    else
; 5263 :    {
; 5264 :       // do the stuff below...
; 5265 : 
; 5266 :       /* Determine the type of compare to do based on the internal types
; 5267 :          of the Attributes.  If either type is a Numeric type ( int, zLONG,
; 5268 :          decimal ) then a numeric compare is done. Else if either type is
; 5269 :          a date, then an internal date numeric compare is done. Otherwise
; 5270 :          a string compare is done.                                     */
; 5271 : 
; 5272 :       //
; 5273 :       // invoke derived operation for Tgt
; 5274 :       //
; 5275 :       if ( lpTgtViewAttrib->szDerivedOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN19@CompareAtt

; 5276 :          fnInvokeDerivedOperation( lpTgtView, lpTgtViewEntity,

	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
$LN19@CompareAtt:

; 5277 :                                    lpTgtViewAttrib, lpCurrentTask,
; 5278 :                                    zDERIVED_GET );
; 5279 : 
; 5280 :       nRC = zCALL_ERROR;   // Default nRC to zCALL_ERROR

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 5281 : 
; 5282 :       if ( lpTgtViewAttrib->cType == zTYPE_INTEGER &&

	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	jne	$LN20@CompareAtt
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	$LN20@CompareAtt

; 5283 :            lpSrcViewAttrib->cType == zTYPE_INTEGER )
; 5284 :       {
; 5285 :          zPLONG plTarget;
; 5286 :          zPLONG plSource;
; 5287 : 
; 5288 :          fnGetAddrForAttribute( (zCOREMEM) &plSource, lpSrcView,

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _plSource$10[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5289 :                                 lpSrcViewEntityCsr, 0, lpSrcViewAttrib );
; 5290 :          fnGetAddrForAttribute( (zCOREMEM) &plTarget, lpTgtView,

	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _plTarget$9[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5291 :                                 lpTgtViewEntityCsr, 0, lpTgtViewAttrib );
; 5292 :          if ( *plSource == *plTarget )

	mov	ecx, DWORD PTR _plSource$10[ebp]
	mov	edx, DWORD PTR _plTarget$9[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN22@CompareAtt

; 5293 :             nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN23@CompareAtt
$LN22@CompareAtt:

; 5294 :          else
; 5295 :          if ( *plTarget == lNullInteger )

	mov	edx, DWORD PTR _plTarget$9[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	jne	SHORT $LN24@CompareAtt

; 5296 :             nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN23@CompareAtt
$LN24@CompareAtt:

; 5297 :          else
; 5298 :          if ( *plSource == lNullInteger || *plSource < *plTarget )

	mov	edx, DWORD PTR _plSource$10[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	je	SHORT $LN28@CompareAtt
	mov	ecx, DWORD PTR _plSource$10[ebp]
	mov	edx, DWORD PTR _plTarget$9[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jge	SHORT $LN26@CompareAtt
$LN28@CompareAtt:

; 5299 :             nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN23@CompareAtt
$LN26@CompareAtt:

; 5300 :          else
; 5301 :             nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
$LN23@CompareAtt:

; 5302 :       }

	jmp	$LN8@CompareAtt
$LN20@CompareAtt:

; 5303 :       else
; 5304 :       // If either of the attrs are decimals we will compare them both as
; 5305 :       // decimals
; 5306 :       if ( lpTgtViewAttrib->cType == zTYPE_DECIMAL ||

	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 77					; 0000004dH
	je	SHORT $LN31@CompareAtt
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	$LN29@CompareAtt
$LN31@CompareAtt:

; 5307 :            lpSrcViewAttrib->cType == zTYPE_DECIMAL )
; 5308 :       {
; 5309 :          zDECIMAL dTgtCompare;
; 5310 :          zDECIMAL dSrcCompare;
; 5311 :          zSHORT   nRC1, nRC2;
; 5312 : 
; 5313 :          nRC1 = fnGetDecimalFromAttribute( &dTgtCompare,

	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dTgtCompare$18[ebp]
	push	ecx
	call	_fnGetDecimalFromAttribute
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC1$17[ebp], ax

; 5314 :                                            lpTgtView,
; 5315 :                                            lpTgtViewEntityCsr,
; 5316 :                                            lpTgtViewAttrib );
; 5317 : 
; 5318 :          nRC2 = fnGetDecimalFromAttribute( &dSrcCompare,

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dSrcCompare$19[ebp]
	push	edx
	call	_fnGetDecimalFromAttribute
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC2$16[ebp], ax

; 5319 :                                            lpSrcView,
; 5320 :                                            lpSrcViewEntityCsr,
; 5321 :                                            lpSrcViewAttrib );
; 5322 :          if ( nRC1 == zCALL_ERROR || nRC2 == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC1$17[ebp]
	cmp	eax, -16				; fffffff0H
	je	SHORT $LN34@CompareAtt
	movsx	ecx, WORD PTR _nRC2$16[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN32@CompareAtt
$LN34@CompareAtt:

; 5323 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN33@CompareAtt
$LN32@CompareAtt:

; 5324 :          else
; 5325 :          {
; 5326 :             // If we get here then nRCx must be either -1 (attr is null) or
; 5327 :             // 0 (not-null).
; 5328 :             if ( nRC1 == -1 && nRC2 == -1 )

	movsx	eax, WORD PTR _nRC1$17[ebp]
	cmp	eax, -1
	jne	SHORT $LN35@CompareAtt
	movsx	ecx, WORD PTR _nRC2$16[ebp]
	cmp	ecx, -1
	jne	SHORT $LN35@CompareAtt

; 5329 :                nRC = 0;    // Both attrs are null so return EQUAL.

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN33@CompareAtt
$LN35@CompareAtt:

; 5330 :             else
; 5331 :             if ( nRC1 == 0 && nRC2 == 0 )

	movsx	eax, WORD PTR _nRC1$17[ebp]
	test	eax, eax
	jne	SHORT $LN37@CompareAtt
	movsx	ecx, WORD PTR _nRC2$16[ebp]
	test	ecx, ecx
	jne	SHORT $LN37@CompareAtt

; 5332 :                // Both values are not null so call func to compare 'em.
; 5333 :                nRC = SysCompareDecimalToDecimal( &dTgtCompare,

	lea	edx, DWORD PTR _dSrcCompare$19[ebp]
	push	edx
	lea	eax, DWORD PTR _dTgtCompare$18[ebp]
	push	eax
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN33@CompareAtt
$LN37@CompareAtt:

; 5334 :                                                  &dSrcCompare );
; 5335 :             else
; 5336 :             {
; 5337 :                // Only one of the values is null.  Find which one it is and
; 5338 :                // set the return code accordingly (null < non-null).
; 5339 :                if ( nRC1 == -1 )

	movsx	ecx, WORD PTR _nRC1$17[ebp]
	cmp	ecx, -1
	jne	SHORT $LN39@CompareAtt

; 5340 :                   nRC = -1;  // Target is null so it's "less than".

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN33@CompareAtt
$LN39@CompareAtt:

; 5341 :                else
; 5342 :                   nRC = 1;   // Source is null so it's "less than".

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN33@CompareAtt:

; 5343 :             }
; 5344 :          }
; 5345 :       }

	jmp	$LN8@CompareAtt
$LN29@CompareAtt:

; 5346 :       else
; 5347 :       if ( lpTgtViewAttrib->cType == zTYPE_BLOB &&

	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	jne	$LN41@CompareAtt
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	jne	$LN41@CompareAtt

; 5348 :            lpSrcViewAttrib->cType == zTYPE_BLOB )
; 5349 :       {
; 5350 :          //compare blobs
; 5351 :          zULONG  ulTgtBlobLength;
; 5352 :          zULONG  ulSrcBlobLength;
; 5353 : 
; 5354 :          fnGetAttributeLength( &ulTgtBlobLength, lpTgtView,

	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulTgtBlobLength$14[ebp]
	push	eax
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 5355 :                                zGETPTR( lpTgtViewEntityCsr->hEntityInstance ),
; 5356 :                                lpTgtViewAttrib );
; 5357 :          fnGetAttributeLength( &ulSrcBlobLength, lpSrcView,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ulSrcBlobLength$7[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 5358 :                                zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),
; 5359 :                                lpSrcViewAttrib );
; 5360 :          if ( ulTgtBlobLength != ulSrcBlobLength )

	mov	eax, DWORD PTR _ulTgtBlobLength$14[ebp]
	cmp	eax, DWORD PTR _ulSrcBlobLength$7[ebp]
	je	SHORT $LN43@CompareAtt

; 5361 :             nRC = ( ulTgtBlobLength < ulSrcBlobLength ) ? -1 : 1;

	mov	ecx, DWORD PTR _ulTgtBlobLength$14[ebp]
	cmp	ecx, DWORD PTR _ulSrcBlobLength$7[ebp]
	jae	SHORT $LN68@CompareAtt
	mov	DWORD PTR tv347[ebp], -1
	jmp	SHORT $LN69@CompareAtt
$LN68@CompareAtt:
	mov	DWORD PTR tv347[ebp], 1
$LN69@CompareAtt:
	mov	dx, WORD PTR tv347[ebp]
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN44@CompareAtt
$LN43@CompareAtt:

; 5362 :          else
; 5363 :          {
; 5364 :             if ( ulTgtBlobLength )

	cmp	DWORD PTR _ulTgtBlobLength$14[ebp], 0
	je	SHORT $LN45@CompareAtt

; 5365 :             {
; 5366 :                zPVOID TgtBlobAddr;
; 5367 :                zPVOID SrcBlobAddr;
; 5368 : 
; 5369 :                fnGetAddrForAttribute( (zCOREMEM) &TgtBlobAddr, lpTgtView,

	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _TgtBlobAddr$6[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5370 :                                       lpTgtViewEntityCsr, 0, lpTgtViewAttrib );
; 5371 :                fnGetAddrForAttribute( (zCOREMEM) &SrcBlobAddr, lpSrcView,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SrcBlobAddr$1[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5372 :                                       lpSrcViewEntityCsr, 0, lpSrcViewAttrib );
; 5373 :                nRC = zmemcmp( TgtBlobAddr, SrcBlobAddr,

	mov	edx, DWORD PTR _ulTgtBlobLength$14[ebp]
	push	edx
	mov	eax, DWORD PTR _SrcBlobAddr$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _TgtBlobAddr$6[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 5374 :                               (unsigned int) ulTgtBlobLength );
; 5375 :             }

	jmp	SHORT $LN44@CompareAtt
$LN45@CompareAtt:

; 5376 :             else
; 5377 :                nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN44@CompareAtt:

; 5378 :          }
; 5379 :       }

	jmp	$LN8@CompareAtt
$LN41@CompareAtt:

; 5380 :       else   // We need some sort of date compare here
; 5381 :       if ( lpTgtViewAttrib->cType == zTYPE_DATETIME &&

	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 84					; 00000054H
	jne	SHORT $LN47@CompareAtt
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 84					; 00000054H
	jne	SHORT $LN47@CompareAtt

; 5382 :            lpSrcViewAttrib->cType == zTYPE_DATETIME )
; 5383 :       {
; 5384 :          LPDTINTERNAL lpSrcDateTime;
; 5385 :          LPDTINTERNAL lpTgtDateTime;
; 5386 : 
; 5387 :          fnGetAddrForAttribute( (zCOREMEM) &lpSrcDateTime, lpSrcView,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcDateTime$5[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5388 :                                 lpSrcViewEntityCsr, 0, lpSrcViewAttrib );
; 5389 :          fnGetAddrForAttribute( (zCOREMEM) &lpTgtDateTime, lpTgtView,

	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtDateTime$4[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5390 :                                 lpTgtViewEntityCsr, 0, lpTgtViewAttrib );
; 5391 :          nRC = fnCompareDateTimeToDateTime( lpTgtDateTime, lpSrcDateTime );

	mov	eax, DWORD PTR _lpSrcDateTime$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtDateTime$4[ebp]
	push	ecx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 5392 :       }

	jmp	$LN8@CompareAtt
$LN47@CompareAtt:

; 5393 :       else   // Compare the strings
; 5394 :       if ( lpTgtViewAttrib->cType == zTYPE_STRING &&

	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	$LN49@CompareAtt
	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 83					; 00000053H
	jne	$LN49@CompareAtt

; 5395 :            lpSrcViewAttrib->cType == zTYPE_STRING )
; 5396 :       {
; 5397 :          zPCHAR pchSrcString;
; 5398 :          zPCHAR pchTgtString;
; 5399 : 
; 5400 :          fnGetAddrForAttribute( (zCOREMEM) &pchSrcString, lpSrcView,

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSrcString$13[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5401 :                                 lpSrcViewEntityCsr, 0, lpSrcViewAttrib );
; 5402 :          fnGetAddrForAttribute( (zCOREMEM) &pchTgtString, lpTgtView,

	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchTgtString$12[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 5403 :                                 lpTgtViewEntityCsr, 0, lpTgtViewAttrib );
; 5404 :          if ( lpTgtViewAttrib->bCaseSens )

	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN51@CompareAtt

; 5405 :             nRC = zstrcmp( pchTgtString, pchSrcString );

	mov	ecx, DWORD PTR _pchTgtString$12[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchSrcString$13[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN72@CompareAtt
	mov	edx, DWORD PTR _pchSrcString$13[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTgtString$12[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv415[ebp], eax
	jmp	SHORT $LN73@CompareAtt
$LN72@CompareAtt:
	mov	ecx, DWORD PTR _pchTgtString$12[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchSrcString$13[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN70@CompareAtt
	mov	DWORD PTR tv414[ebp], 1
	jmp	SHORT $LN71@CompareAtt
$LN70@CompareAtt:
	mov	DWORD PTR tv414[ebp], -1
$LN71@CompareAtt:
	mov	edx, DWORD PTR tv414[ebp]
	mov	DWORD PTR tv415[ebp], edx
$LN73@CompareAtt:
	mov	ax, WORD PTR tv415[ebp]
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN52@CompareAtt
$LN51@CompareAtt:

; 5406 :          else
; 5407 :             nRC = zstrcmpi( pchTgtString, pchSrcString );

	mov	ecx, DWORD PTR _pchSrcString$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTgtString$12[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN52@CompareAtt:

; 5408 : 
; 5409 :          if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN53@CompareAtt

; 5410 :             nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN54@CompareAtt
$LN53@CompareAtt:

; 5411 :          else
; 5412 :          if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN54@CompareAtt

; 5413 :             nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN54@CompareAtt:

; 5414 :       }

	jmp	$LN8@CompareAtt
$LN49@CompareAtt:

; 5415 :       else
; 5416 :       {
; 5417 :          // all else has failed (mixed internal types),
; 5418 :          // we will compare by 'converting' both type to strings
; 5419 :          // NOTE: with mixed type we assume that the first 64K
; 5420 :          //       will be enough to tell.  This will work for all
; 5421 :          //       cases except a "BLOB to STRING" compare where
; 5422 :          //       one of these would be truncated AND the first
; 5423 :          //       64K are the same.  In the future, we can check
; 5424 :          //       for this special case and do dynamic allocations.
; 5425 :          //
; 5426 :          zCHAR  szTgtCompare[ 65535 ];
; 5427 :          zCHAR  szSrcCompare[ 65535 ];
; 5428 :          nRC = fnGetStringFromAttribute( szTgtCompare, 65535,

	push	0
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	push	65535					; 0000ffffH
	lea	ecx, DWORD PTR _szTgtCompare$21[ebp]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 5429 :                                          lpTgtView,
; 5430 :                                          lpTgtViewEntityCsr,
; 5431 :                                          lpTgtViewAttrib, 0 );
; 5432 :          if ( nRC == 0 || nRC == -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN57@CompareAtt
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jne	$LN8@CompareAtt
$LN57@CompareAtt:

; 5433 :          {
; 5434 :             nRC = fnGetStringFromAttribute( szSrcCompare, 65535,

	push	0
	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	push	65535					; 0000ffffH
	lea	ecx, DWORD PTR _szSrcCompare$20[ebp]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 5435 :                                             lpSrcView,
; 5436 :                                             lpSrcViewEntityCsr,
; 5437 :                                             lpSrcViewAttrib, 0 );
; 5438 :             if ( nRC == 0 || nRC == -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN59@CompareAtt
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jne	$LN8@CompareAtt
$LN59@CompareAtt:

; 5439 :             {
; 5440 :                if ( lpTgtViewAttrib->bCaseSens )

	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN60@CompareAtt

; 5441 :                   nRC = zstrcmp( szTgtCompare, szSrcCompare );

	movsx	eax, BYTE PTR _szTgtCompare$21[ebp]
	movsx	ecx, BYTE PTR _szSrcCompare$20[ebp]
	cmp	eax, ecx
	jne	SHORT $LN76@CompareAtt
	lea	edx, DWORD PTR _szSrcCompare$20[ebp]
	push	edx
	lea	eax, DWORD PTR _szTgtCompare$21[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv462[ebp], eax
	jmp	SHORT $LN77@CompareAtt
$LN76@CompareAtt:
	movsx	ecx, BYTE PTR _szTgtCompare$21[ebp]
	movsx	edx, BYTE PTR _szSrcCompare$20[ebp]
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN74@CompareAtt
	mov	DWORD PTR tv461[ebp], 1
	jmp	SHORT $LN75@CompareAtt
$LN74@CompareAtt:
	mov	DWORD PTR tv461[ebp], -1
$LN75@CompareAtt:
	mov	eax, DWORD PTR tv461[ebp]
	mov	DWORD PTR tv462[ebp], eax
$LN77@CompareAtt:
	mov	cx, WORD PTR tv462[ebp]
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN61@CompareAtt
$LN60@CompareAtt:

; 5442 :                else
; 5443 :                   nRC = zstrcmpi( szTgtCompare, szSrcCompare );

	lea	edx, DWORD PTR _szSrcCompare$20[ebp]
	push	edx
	lea	eax, DWORD PTR _szTgtCompare$21[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN61@CompareAtt:

; 5444 : 
; 5445 :                if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN62@CompareAtt

; 5446 :                   nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN8@CompareAtt
$LN62@CompareAtt:

; 5447 :                else
; 5448 :                if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN8@CompareAtt

; 5449 :                   nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN8@CompareAtt:

; 5450 :             }
; 5451 :          }
; 5452 :       }
; 5453 :    }
; 5454 : 
; 5455 :    fnOperationReturn( iCompareAttributeToAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	273					; 00000111H
	call	_fnOperationReturn
	add	esp, 8

; 5456 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareAtt:

; 5457 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_CompareAttributeToAttribute@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpSrcViewEntity$ = -64					; size = 4
_lpCurrentTask$ = -60					; size = 4
_lpSrcViewEntityCsr$ = -56				; size = 4
_lpSrcViewAttrib$ = -52					; size = 4
_nRC$ = -48						; size = 2
_dSrcDecimal$ = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_cpcTgtAttributeName$ = 16				; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_cpcSrcAttributeName$ = 28				; size = 4
_AddToAttributeFromAttribute@24 PROC

; 5029 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 5030 :    LPTASK            lpCurrentTask;
; 5031 :    LPVIEWENTITY      lpSrcViewEntity;
; 5032 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 5033 :    LPVIEWATTRIB      lpSrcViewAttrib;
; 5034 :    zDECIMAL          dSrcDecimal;
; 5035 :    zSHORT            nRC;
; 5036 : 
; 5037 :    // Validate parameters for source attribute
; 5038 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	0
	push	268					; 0000010cH
	lea	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 5039 :                                         &lpSrcViewEntity,
; 5040 :                                         &lpSrcViewEntityCsr,
; 5041 :                                         &lpSrcViewAttrib,
; 5042 :                                         iAddToAttributeFromAttribute,
; 5043 :                                         0,   // We won't update source
; 5044 :                                         lpSrcView,
; 5045 :                                         cpcSrcEntityName,
; 5046 :                                         cpcSrcAttributeName, 0 );
; 5047 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@AddToAttri

; 5048 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@AddToAttri
$LN2@AddToAttri:

; 5049 : 
; 5050 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@AddToAttri

; 5051 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@AddToAttri
$LN3@AddToAttri:

; 5052 :    else
; 5053 :    {
; 5054 :       // Get the source attribute as a decimal and add it to the target as
; 5055 :       // a decimal value.
; 5056 :       nRC = fnGetDecimalFromAttribute( &dSrcDecimal,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dSrcDecimal$[ebp]
	push	ecx
	call	_fnGetDecimalFromAttribute
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 5057 :                                        lpSrcView,
; 5058 :                                        lpSrcViewEntityCsr,
; 5059 :                                        lpSrcViewAttrib );
; 5060 :       // If Source attr value is null, skip the Add, but give ok return code.
; 5061 :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN5@AddToAttri

; 5062 :       {
; 5063 :          nRC = AddToAttributeFromDecimal( lpTgtView,

	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _dSrcDecimal$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_AddToAttributeFromDecimal@52
	mov	WORD PTR _nRC$[ebp], ax

; 5064 :                                           cpcTgtEntityName,
; 5065 :                                           cpcTgtAttributeName,
; 5066 :                                           dSrcDecimal );
; 5067 :       }

	jmp	SHORT $LN4@AddToAttri
$LN5@AddToAttri:

; 5068 :       else
; 5069 :       if ( nRC == -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jne	SHORT $LN4@AddToAttri

; 5070 :          nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN4@AddToAttri:

; 5071 :    }
; 5072 : 
; 5073 :    fnOperationReturn( iAddToAttributeFromAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	268					; 0000010cH
	call	_fnOperationReturn
	add	esp, 8

; 5074 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@AddToAttri:

; 5075 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_AddToAttributeFromAttribute@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_dDecimalValue$ = 20					; size = 40
_AddToAttributeFromDecimal@52 PROC

; 3084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3085 :    LPTASK            lpCurrentTask;
; 3086 :    LPVIEWENTITY      lpViewEntity;
; 3087 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 3088 :    LPVIEWATTRIB      lpViewAttrib;
; 3089 :    zSHORT            nRC;
; 3090 : 
; 3091 :    // If decimal coming in is NULL, short circuit.
; 3092 :    if ( SysCompareDecimalToNull( &dDecimalValue ) == 0 )

	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN2@AddToAttri

; 3093 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@AddToAttri
$LN2@AddToAttri:

; 3094 : 
; 3095 :    // Validate parameters
; 3096 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	1
	push	267					; 0000010bH
	lea	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 3097 :                                         &lpViewEntity,
; 3098 :                                         &lpViewEntityCsr,
; 3099 :                                         &lpViewAttrib,
; 3100 :                                         iAddToAttributeFromDecimal,
; 3101 :                                         1,   // We intend to update
; 3102 :                                         lpView,
; 3103 :                                         cpcEntityName,
; 3104 :                                         cpcAttributeName, 0 );
; 3105 :    if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN3@AddToAttri

; 3106 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@AddToAttri
$LN3@AddToAttri:

; 3107 : 
; 3108 :    if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN4@AddToAttri

; 3109 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN5@AddToAttri
$LN4@AddToAttri:

; 3110 :    else
; 3111 :       nRC = fnAddToAttributeFromVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	77					; 0000004dH
	lea	ecx, DWORD PTR _dDecimalValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnAddToAttributeFromVariable
	add	esp, 32					; 00000020H
	mov	WORD PTR _nRC$[ebp], ax
$LN5@AddToAttri:

; 3112 :                                           (zPVOID) &dDecimalValue, zTYPE_DECIMAL,
; 3113 :                                           0, 0, lpCurrentTask );
; 3114 : 
; 3115 :    fnOperationReturn( iAddToAttributeFromDecimal, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	267					; 0000010bH
	call	_fnOperationReturn
	add	esp, 8

; 3116 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@AddToAttri:

; 3117 : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_AddToAttributeFromDecimal@52 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTgtViewOI$ = -88					; size = 4
_lpTask$1 = -84						; size = 4
_lpTgtViewEntityCsr$ = -80				; size = 4
_lpSrcViewEntityCsr$ = -76				; size = 4
_lpViewCsr$ = -72					; size = 4
_lpTask$2 = -68						; size = 4
_lpSrcViewEntity$ = -64					; size = 4
_lpExternalP$ = -60					; size = 4
_lpSrcEntityInstance$ = -56				; size = 4
_lplLong$ = -52						; size = 4
tv257 = -48						; size = 4
_lpLinkedInstance$ = -44				; size = 4
_lpulLth$ = -40						; size = 4
_lpViewAttrib$ = -36					; size = 4
_lpCurrentTask$ = -32					; size = 4
_lpTgtViewEntity$ = -28					; size = 4
_lpTgtEntityInstance$ = -24				; size = 4
_pchRecord$ = -20					; size = 4
_lpWrkViewAttrib$ = -16					; size = 4
_ulLth$ = -12						; size = 4
_pchBlob$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_cpcAttributeName$ = 24					; size = 4
_SetEntityAttributesFromBlob@20 PROC

; 3788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 3789 :    LPTASK            lpCurrentTask;
; 3790 :    LPVIEWCSR         lpViewCsr;
; 3791 :    LPVIEWOI          lpTgtViewOI;
; 3792 :    LPVIEWENTITY      lpSrcViewEntity;
; 3793 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 3794 :    LPVIEWENTITY      lpTgtViewEntity;
; 3795 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 3796 :    LPVIEWATTRIB      lpViewAttrib;
; 3797 :    LPVIEWATTRIB      lpWrkViewAttrib;
; 3798 :    LPENTITYINSTANCE  lpSrcEntityInstance;
; 3799 :    LPENTITYINSTANCE  lpTgtEntityInstance;
; 3800 :    LPENTITYINSTANCE  lpLinkedInstance;
; 3801 :    zULONG            ulLth;
; 3802 :    zPCHAR            pchBlob;
; 3803 :    zCOREMEM          lpExternalP;
; 3804 :    zPULONG           lpulLth;
; 3805 :    zPLONG            lplLong;
; 3806 :    zPCHAR            pchRecord;
; 3807 :    zSHORT            nRC;
; 3808 : 
; 3809 :    // Validate parameters.
; 3810 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	0
	push	292					; 00000124H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 3811 :                                         &lpSrcViewEntity,
; 3812 :                                         &lpSrcViewEntityCsr,
; 3813 :                                         &lpViewAttrib,
; 3814 :                                         iSetEntityAttributesFromBlob,
; 3815 :                                         0,   // We do not intend to update
; 3816 :                                         lpSrcView,
; 3817 :                                         cpcSrcEntityName,
; 3818 :                                         cpcAttributeName, 0 );
; 3819 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN10@SetEntityA

; 3820 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityA
	jmp	SHORT $LN11@SetEntityA
$LN10@SetEntityA:

; 3821 :    else
; 3822 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN11@SetEntityA

; 3823 :    {
; 3824 :       // Validate parameters.  For now we'll ignore checking the keys.
; 3825 :       nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	4112					; 00001010H
	push	0
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	push	1
	push	292					; 00000124H
	push	0
	lea	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN11@SetEntityA:

; 3826 :                                            &lpTgtViewEntity,
; 3827 :                                            &lpTgtViewEntityCsr,
; 3828 :                                            0,
; 3829 :                                            iSetEntityAttributesFromBlob,
; 3830 :                                            1,   // We intend to update
; 3831 :                                            lpTgtView,
; 3832 :                                            cpcTgtEntityName,
; 3833 :                                            0,
; 3834 :                                            zIGNORE_KEYS |
; 3835 :                                              zUSE_TASK ); // Oper id already passed
; 3836 :    }
; 3837 : 
; 3838 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN13@SetEntityA

; 3839 :    {
; 3840 :       fnOperationReturn( iSetEntityAttributesFromBlob, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	292					; 00000124H
	call	_fnOperationReturn
	add	esp, 8

; 3841 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityA
$LN13@SetEntityA:

; 3842 :    }
; 3843 : 
; 3844 :    // Validate that the attribute is a blob.
; 3845 :    if ( lpViewAttrib->cType != zTYPE_BLOB )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	je	SHORT $LN14@SetEntityA

; 3846 :    {
; 3847 :       LPTASK lpTask = zGETPTR( lpSrcView->hTask );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 3848 :       // "KZOEE239 - Invalid Operation for attribute type"
; 3849 :       fnIssueCoreError( lpTask, lpSrcView, 8, 239, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	239					; 000000efH
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3850 :                         lpSrcViewEntity->szName,
; 3851 :                         lpViewAttrib->szName );
; 3852 :       fnOperationReturn( iSetEntityAttributesFromBlob, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	292					; 00000124H
	call	_fnOperationReturn
	add	esp, 8

; 3853 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityA
$LN14@SetEntityA:

; 3854 :    }
; 3855 : 
; 3856 :    lpViewCsr           = zGETPTR( lpTgtView->hViewCsr );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3857 :    lpTgtViewOI         = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 3858 :    lpSrcEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 3859 :    lpTgtEntityInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 3860 :    pchRecord = 0;

	mov	DWORD PTR _pchRecord$[ebp], 0

; 3861 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 3862 : 
; 3863 :    // This should never be true, but is here for protection.
; 3864 :    if ( lpSrcEntityInstance == 0 || lpTgtEntityInstance == 0 )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN16@SetEntityA
	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	jne	SHORT $LN15@SetEntityA
$LN16@SetEntityA:

; 3865 :    {
; 3866 :       fnOperationReturn( iSetEntityAttributesFromBlob, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	292					; 00000124H
	call	_fnOperationReturn
	add	esp, 8

; 3867 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SetEntityA
$LN15@SetEntityA:

; 3868 :    }
; 3869 : 
; 3870 :    // Get the address of the blob and validate that the blob was created
; 3871 :    // from the entity in the first place
; 3872 :    pchRecord = fnRecordForEntityAttr( lpSrcEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 3873 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN17@SetEntityA

; 3874 :    {
; 3875 :       pchRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchRecord$[ebp], edx

; 3876 :       if ( pchRecord[ 0 ] != (zCHAR) '\xff' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchRecord$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	je	SHORT $LN18@SetEntityA

; 3877 :          pchRecord = 0;

	mov	DWORD PTR _pchRecord$[ebp], 0
	jmp	$LN17@SetEntityA
$LN18@SetEntityA:

; 3878 :       else
; 3879 :       {
; 3880 :          // Get the address of the blob and ensure that the beginning of
; 3881 :          // the blob is the ER_Entity Token of the target entity
; 3882 :          lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$[ebp], ecx

; 3883 :          lpulLth     = (zPULONG) (lpExternalP + 1);

	mov	edx, DWORD PTR _lpExternalP$[ebp]
	add	edx, 4
	mov	DWORD PTR _lpulLth$[ebp], edx

; 3884 :          ulLth       = *lpulLth;

	mov	eax, DWORD PTR _lpulLth$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ulLth$[ebp], ecx

; 3885 :          pchBlob      = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchBlob$[ebp], eax

; 3886 :          lplLong     = (zPLONG) pchBlob;

	mov	ecx, DWORD PTR _pchBlob$[ebp]
	mov	DWORD PTR _lplLong$[ebp], ecx

; 3887 :          if ( ulLth < sizeof ( zLONG ) ||

	cmp	DWORD PTR _ulLth$[ebp], 4
	jb	SHORT $LN21@SetEntityA
	mov	edx, DWORD PTR _lplLong$[ebp]
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $LN20@SetEntityA
$LN21@SetEntityA:

; 3888 :               *lplLong != lpTgtViewEntity->lEREntTok )
; 3889 :          {
; 3890 :             LPTASK lpTask = zGETPTR( lpSrcView->hTask );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 3891 :             // "KZOEE247 - Blob Attribute does not match Target Entity Type"
; 3892 :             fnIssueCoreError( lpTask, lpSrcView, 8, 247, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	247					; 000000f7H
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3893 :                               lpSrcViewEntity->szName,
; 3894 :                               lpViewAttrib->szName );
; 3895 :             fnOperationReturn( iSetEntityAttributesFromBlob, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	292					; 00000124H
	call	_fnOperationReturn
	add	esp, 8

; 3896 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityA
$LN20@SetEntityA:

; 3897 :          }
; 3898 : 
; 3899 :          ulLth -= sizeof( zLONG );

	mov	eax, DWORD PTR _ulLth$[ebp]
	sub	eax, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 3900 :          pchBlob += sizeof( zLONG );

	mov	ecx, DWORD PTR _pchBlob$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchBlob$[ebp], ecx
$LN17@SetEntityA:

; 3901 :       }
; 3902 :    }
; 3903 : 
; 3904 :    // If we get here, then all the edits have passed, delete the target
; 3905 :    // entity information before moving on
; 3906 :    fnDeleteAttributeRecord( lpTgtViewEntity, lpTgtEntityInstance, FALSE );

	push	0
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 3907 :    fnDeleteAttributeRecord( lpTgtViewEntity, lpTgtEntityInstance, TRUE );

	push	1
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 3908 :    if ( lpTgtEntityInstance->hNextLinked )

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	SHORT $LN22@SetEntityA

; 3909 :    {
; 3910 :       lpLinkedInstance = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedInstance$[ebp], eax
$LN2@SetEntityA:

; 3911 :       while ( lpLinkedInstance != lpTgtEntityInstance )

	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	je	SHORT $LN22@SetEntityA

; 3912 :       {
; 3913 :          lpLinkedInstance->hPersistRecord = 0;

	mov	ecx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 3914 :          lpLinkedInstance = zGETPTR( lpLinkedInstance->hNextLinked );

	mov	edx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedInstance$[ebp], eax

; 3915 :       }

	jmp	SHORT $LN2@SetEntityA
$LN22@SetEntityA:

; 3916 :    }
; 3917 : 
; 3918 :    // If a source blob exists, go through the attributes stored in the
; 3919 :    // blob, match them up to the attributes in the target entity and reset
; 3920 :    // the target attributes found if the target type has not changed.
; 3921 :    // NOTE: Attributes not found in the target are ignored.
; 3922 :    if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN23@SetEntityA
$LN4@SetEntityA:

; 3923 :    {
; 3924 :       while ( nRC == 0 && ulLth > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN23@SetEntityA
	cmp	DWORD PTR _ulLth$[ebp], 0
	jbe	$LN23@SetEntityA

; 3925 :       {
; 3926 :          lplLong = (zPLONG) pchBlob;

	mov	edx, DWORD PTR _pchBlob$[ebp]
	mov	DWORD PTR _lplLong$[ebp], edx

; 3927 :          pchBlob += sizeof( zLONG );

	mov	eax, DWORD PTR _pchBlob$[ebp]
	add	eax, 4
	mov	DWORD PTR _pchBlob$[ebp], eax

; 3928 :          ulLth  -= sizeof( zLONG );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _ulLth$[ebp], ecx

; 3929 :          lpWrkViewAttrib = zGETPTR( lpTgtViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewAttrib$[ebp], eax
$LN6@SetEntityA:

; 3930 :          while ( lpWrkViewAttrib &&

	cmp	DWORD PTR _lpWrkViewAttrib$[ebp], 0
	je	SHORT $LN7@SetEntityA
	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	edx, DWORD PTR _lplLong$[ebp]
	mov	eax, DWORD PTR [ecx+177]
	cmp	eax, DWORD PTR [edx]
	je	SHORT $LN7@SetEntityA

; 3931 :                  lpWrkViewAttrib->lERAttTok != *lplLong )
; 3932 :          {
; 3933 :             lpWrkViewAttrib = zGETPTR( lpWrkViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewAttrib$[ebp], eax

; 3934 :          }

	jmp	SHORT $LN6@SetEntityA
$LN7@SetEntityA:

; 3935 : 
; 3936 :          if ( lpWrkViewAttrib && lpWrkViewAttrib->cType == pchBlob[ 0 ] )

	cmp	DWORD PTR _lpWrkViewAttrib$[ebp], 0
	je	$LN24@SetEntityA
	mov	eax, DWORD PTR _lpWrkViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	edx, 1
	imul	eax, edx, 0
	mov	edx, DWORD PTR _pchBlob$[ebp]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	ecx, eax
	jne	SHORT $LN24@SetEntityA

; 3937 :          {
; 3938 :             if ( pchBlob[ 0 ] != zTYPE_BLOB )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchBlob$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN25@SetEntityA

; 3939 :             {
; 3940 :                // Assign the attribute in the target Entity
; 3941 :                StoreValueInRecord( lpTgtView,

	push	0
	mov	edx, DWORD PTR _pchBlob$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _lpWrkViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_StoreValueInRecord@20

; 3942 :                                    lpTgtViewEntity, lpWrkViewAttrib,
; 3943 :                                    pchBlob + 1, 0 );
; 3944 :             }

	jmp	SHORT $LN26@SetEntityA
$LN25@SetEntityA:

; 3945 :             else
; 3946 :             {
; 3947 :                // Get address of length data
; 3948 :                lpulLth = (zPULONG) pchBlob + 1;

	mov	eax, DWORD PTR _pchBlob$[ebp]
	add	eax, 4
	mov	DWORD PTR _lpulLth$[ebp], eax

; 3949 : 
; 3950 :                // Assign the attribute in the target Entity
; 3951 :                StoreValueInRecord( lpTgtView,

	mov	ecx, DWORD PTR _lpulLth$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pchBlob$[ebp]
	add	eax, 5
	push	eax
	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_StoreValueInRecord@20
$LN26@SetEntityA:

; 3952 :                                    lpTgtViewEntity, lpWrkViewAttrib,
; 3953 :                                    pchBlob + 1 + sizeof( zULONG ), *lpulLth );
; 3954 :             }
; 3955 : 
; 3956 :             fnSetUpdateIndicator( lpTgtViewOI, lpTgtEntityInstance,

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	push	eax
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$LN24@SetEntityA:

; 3957 :                                   lpWrkViewAttrib, TRUE, TRUE, TRUE );
; 3958 : 
; 3959 :          }
; 3960 : 
; 3961 :          switch ( pchBlob[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchBlob$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR tv257[ebp], ecx
	mov	edx, DWORD PTR tv257[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv257[ebp], edx
	cmp	DWORD PTR tv257[ebp], 18		; 00000012H
	ja	$LN32@SetEntityA
	mov	eax, DWORD PTR tv257[ebp]
	movzx	ecx, BYTE PTR $LN34@SetEntityA[eax]
	jmp	DWORD PTR $LN35@SetEntityA[ecx*4]
$LN27@SetEntityA:

; 3962 :          {
; 3963 :             // If the attribute is a string, we get the length of the
; 3964 :             // string plus the preceding type character 'S' and add 1 for
; 3965 :             // the null terminator at the end of the string; Otherwise,
; 3966 :             // take the attribute length and add 1 for the attribute type
; 3967 :             case zTYPE_STRING:
; 3968 :                ulLth  -= zstrlen( pchBlob ) + 1;

	mov	edx, DWORD PTR _pchBlob$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	ecx, DWORD PTR _ulLth$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _ulLth$[ebp], ecx

; 3969 :                pchBlob += zstrlen( pchBlob ) + 1;

	mov	edx, DWORD PTR _pchBlob$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchBlob$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchBlob$[ebp], edx

; 3970 :                break;

	jmp	SHORT $LN8@SetEntityA
$LN28@SetEntityA:

; 3971 : 
; 3972 :             case zTYPE_INTEGER:
; 3973 :                ulLth  -= sizeof( zLONG ) + 1;

	mov	eax, DWORD PTR _ulLth$[ebp]
	sub	eax, 5
	mov	DWORD PTR _ulLth$[ebp], eax

; 3974 :                pchBlob += sizeof( zLONG ) + 1;

	mov	ecx, DWORD PTR _pchBlob$[ebp]
	add	ecx, 5
	mov	DWORD PTR _pchBlob$[ebp], ecx

; 3975 :                break;

	jmp	SHORT $LN8@SetEntityA
$LN29@SetEntityA:

; 3976 : 
; 3977 :             case zTYPE_DECIMAL:
; 3978 :                ulLth  -= sizeof( zDECIMAL ) + 1;

	mov	edx, DWORD PTR _ulLth$[ebp]
	sub	edx, 41					; 00000029H
	mov	DWORD PTR _ulLth$[ebp], edx

; 3979 :                pchBlob += sizeof( zDECIMAL ) + 1;

	mov	eax, DWORD PTR _pchBlob$[ebp]
	add	eax, 41					; 00000029H
	mov	DWORD PTR _pchBlob$[ebp], eax

; 3980 :                break;

	jmp	SHORT $LN8@SetEntityA
$LN30@SetEntityA:

; 3981 : 
; 3982 :             case zTYPE_DATETIME:
; 3983 :                ulLth  -= sizeof( DateTimeInternalRecord ) + 1;

	mov	ecx, DWORD PTR _ulLth$[ebp]
	sub	ecx, 7
	mov	DWORD PTR _ulLth$[ebp], ecx

; 3984 :                pchBlob += sizeof( DateTimeInternalRecord ) + 1;

	mov	edx, DWORD PTR _pchBlob$[ebp]
	add	edx, 7
	mov	DWORD PTR _pchBlob$[ebp], edx

; 3985 :                break;

	jmp	SHORT $LN8@SetEntityA
$LN31@SetEntityA:

; 3986 : 
; 3987 :             case zTYPE_BLOB:
; 3988 :                ulLth  -= *lpulLth + sizeof( zULONG ) + 1;

	mov	eax, DWORD PTR _lpulLth$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 5
	mov	edx, DWORD PTR _ulLth$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _ulLth$[ebp], edx

; 3989 :                pchBlob += *lpulLth + sizeof( zULONG ) + 1;

	mov	eax, DWORD PTR _lpulLth$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pchBlob$[ebp]
	lea	eax, DWORD PTR [edx+ecx+5]
	mov	DWORD PTR _pchBlob$[ebp], eax

; 3990 :                break;

	jmp	SHORT $LN8@SetEntityA
$LN32@SetEntityA:

; 3991 : 
; 3992 :             default:
; 3993 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN8@SetEntityA:

; 3994 :                break;
; 3995 :          }
; 3996 :       }

	jmp	$LN4@SetEntityA
$LN23@SetEntityA:

; 3997 :    }
; 3998 : 
; 3999 :    fnOperationReturn( iSetEntityAttributesFromBlob, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	292					; 00000124H
	call	_fnOperationReturn
	add	esp, 8

; 4000 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetEntityA:

; 4001 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN35@SetEntityA:
	DD	$LN31@SetEntityA
	DD	$LN28@SetEntityA
	DD	$LN29@SetEntityA
	DD	$LN27@SetEntityA
	DD	$LN30@SetEntityA
	DD	$LN32@SetEntityA
$LN34@SetEntityA:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_SetEntityAttributesFromBlob@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpSrcViewEntity$ = -308				; size = 4
_lpSrcViewEntityCsr$ = -304				; size = 4
_lpViewAttrib$ = -300					; size = 4
_lpOI_Data$ = -296					; size = 4
_pch$ = -292						; size = 4
_ulLth$ = -288						; size = 4
_lpCurrentTask$ = -284					; size = 4
_hFile$ = -280						; size = 4
_pchData$ = -276					; size = 4
_bFileCreated$ = -269					; size = 1
_nRC$ = -268						; size = 2
_szFileName$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_plpTgtView$ = 8					; size = 4
_pchReturnViewOD_Name$ = 12				; size = 4
_vSubtask$ = 16						; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_cpcAttributeName$ = 28					; size = 4
_lControl$ = 32						; size = 4
_SetOI_FromBlob@28 PROC

; 4076 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4077 :    LPTASK            lpCurrentTask;
; 4078 :    LPVIEWENTITY      lpSrcViewEntity;
; 4079 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 4080 :    LPVIEWATTRIB      lpViewAttrib;
; 4081 :    zCHAR             szFileName[ zMAX_FILENAME_LTH + 1 ];
; 4082 :    zBOOL             bFileCreated = FALSE;

	mov	BYTE PTR _bFileCreated$[ebp], 0

; 4083 :    zLONG             hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 4084 :    zULONG            ulLth;
; 4085 :    zPCHAR            pchData;
; 4086 :    zPCHAR            pch;
; 4087 :    LPBLOBOI_RECORD   lpOI_Data;
; 4088 :    zSHORT            nRC;
; 4089 : 
; 4090 :    *plpTgtView = 0;

	mov	eax, DWORD PTR _plpTgtView$[ebp]
	mov	DWORD PTR [eax], 0

; 4091 :    if ( pchReturnViewOD_Name && (lControl & zNEW_OBJECT_NAME) == 0 )

	cmp	DWORD PTR _pchReturnViewOD_Name$[ebp], 0
	je	SHORT $LN2@SetOI_From
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 33554432				; 02000000H
	jne	SHORT $LN2@SetOI_From

; 4092 :       *pchReturnViewOD_Name = 0;

	mov	edx, DWORD PTR _pchReturnViewOD_Name$[ebp]
	mov	BYTE PTR [edx], 0
$LN2@SetOI_From:

; 4093 : 
; 4094 :    // Validate parameters
; 4095 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	0
	push	295					; 00000127H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 4096 :                                         &lpSrcViewEntity,
; 4097 :                                         &lpSrcViewEntityCsr,
; 4098 :                                         &lpViewAttrib,
; 4099 :                                         iSetOI_FromBlob,
; 4100 :                                         0,   // We do not intend to update
; 4101 :                                         lpSrcView,
; 4102 :                                         cpcSrcEntityName,
; 4103 :                                         cpcAttributeName, 0 );
; 4104 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN3@SetOI_From

; 4105 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetOI_From
$LN3@SetOI_From:

; 4106 : 
; 4107 :    if ( nRC || fnValidView( lpCurrentTask, vSubtask ) == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN5@SetOI_From
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN4@SetOI_From
$LN5@SetOI_From:

; 4108 :    {
; 4109 :       fnOperationReturn( iSetOI_FromBlob, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	295					; 00000127H
	call	_fnOperationReturn
	add	esp, 8

; 4110 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetOI_From
$LN4@SetOI_From:

; 4111 :    }
; 4112 : 
; 4113 :    nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 4114 :    if ( lControl & zNEW_OBJECT_NAME )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 33554432				; 02000000H
	je	SHORT $LN6@SetOI_From

; 4115 :    {
; 4116 :       if ( pchReturnViewOD_Name == 0 )

	cmp	DWORD PTR _pchReturnViewOD_Name$[ebp], 0
	jne	SHORT $LN7@SetOI_From

; 4117 :       {
; 4118 :          fnOperationReturn( iSetOI_FromBlob, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	295					; 00000127H
	call	_fnOperationReturn
	add	esp, 8

; 4119 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetOI_From
$LN7@SetOI_From:

; 4120 :       }
; 4121 : 
; 4122 :       if ( ActivateViewObject( vSubtask, pchReturnViewOD_Name, 0 ) == 0 )

	push	0
	mov	ecx, DWORD PTR _pchReturnViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $LN6@SetOI_From

; 4123 :       {
; 4124 :          fnOperationReturn( iSetOI_FromBlob, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	295					; 00000127H
	call	_fnOperationReturn
	add	esp, 8

; 4125 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetOI_From
$LN6@SetOI_From:

; 4126 :       }
; 4127 :    }
; 4128 : 
; 4129 :    SysCreateTempFileName( szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysCreateTempFileName@4

; 4130 : 
; 4131 :    fnGetAddrForAttribute( &pchData, lpSrcView, lpSrcViewEntityCsr, 0,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchData$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 4132 :                           lpViewAttrib );
; 4133 : 
; 4134 :    fnGetAttributeLength( &ulLth, lpSrcView,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 4135 :                          zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),
; 4136 :                          lpViewAttrib );
; 4137 : 
; 4138 :    // If there is no blob data then return -1.
; 4139 :    if ( pchData == 0 || ulLth == 0 )

	cmp	DWORD PTR _pchData$[ebp], 0
	je	SHORT $LN10@SetOI_From
	cmp	DWORD PTR _ulLth$[ebp], 0
	jne	SHORT $LN9@SetOI_From
$LN10@SetOI_From:

; 4140 :    {
; 4141 :       nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx

; 4142 :       goto EndOfFunction;

	jmp	$EndOfFunction$24
$LN9@SetOI_From:

; 4143 :    }
; 4144 : 
; 4145 :    // Get header information at the beginning of the blob.
; 4146 :    pch = zstrchr( pchData, ' ' );  // ensure OD name is terminated ... dks 2011.08.19

	push	32					; 00000020H
	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pch$[ebp], eax

; 4147 :    if ( pch && (pch - pchData) < zZEIDON_NAME_LTH)

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN11@SetOI_From
	mov	ecx, DWORD PTR _pch$[ebp]
	sub	ecx, DWORD PTR _pchData$[ebp]
	cmp	ecx, 32					; 00000020H
	jge	SHORT $LN11@SetOI_From

; 4148 :       *pch = 0;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 0
	jmp	SHORT $LN12@SetOI_From
$LN11@SetOI_From:

; 4149 :    else
; 4150 :       *(pchData + zZEIDON_NAME_LTH) = 0;

	mov	eax, DWORD PTR _pchData$[ebp]
	mov	BYTE PTR [eax+32], 0
$LN12@SetOI_From:

; 4151 : 
; 4152 :    lpOI_Data = (LPBLOBOI_RECORD) pchData;

	mov	ecx, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _lpOI_Data$[ebp], ecx

; 4153 :    pchData += sizeof( BlobOI_Record );

	mov	edx, DWORD PTR _pchData$[ebp]
	add	edx, 137				; 00000089H
	mov	DWORD PTR _pchData$[ebp], edx

; 4154 :    ulLth  -= sizeof( BlobOI_Record );

	mov	eax, DWORD PTR _ulLth$[ebp]
	sub	eax, 137				; 00000089H
	mov	DWORD PTR _ulLth$[ebp], eax

; 4155 : 
; 4156 :    if ( lControl & zNEW_OBJECT_NAME )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 33554432				; 02000000H
	je	SHORT $LN13@SetOI_From

; 4157 :       zstrcpy( lpOI_Data->cpcViewOD_Name, pchReturnViewOD_Name );

	mov	edx, DWORD PTR _pchReturnViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOI_Data$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN14@SetOI_From
$LN13@SetOI_From:

; 4158 :    else
; 4159 :    if ( pchReturnViewOD_Name )

	cmp	DWORD PTR _pchReturnViewOD_Name$[ebp], 0
	je	SHORT $LN14@SetOI_From

; 4160 :       zstrcpy( pchReturnViewOD_Name, lpOI_Data->cpcViewOD_Name );

	mov	ecx, DWORD PTR _lpOI_Data$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnViewOD_Name$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN14@SetOI_From:

; 4161 : 
; 4162 :    // Write the blob to a temp file.
; 4163 :    hFile = SysOpenFile( vSubtask, szFileName, COREFILE_WRITE );

	push	64					; 00000040H
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 4164 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN16@SetOI_From

; 4165 :    {
; 4166 :       // "KZOEE190 - Error opening temporary file"
; 4167 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 16, 190, 0, szFileName, 0 );

	push	0
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	0
	push	190					; 000000beH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4168 :       goto EndOfFunction;

	jmp	$EndOfFunction$24
$LN16@SetOI_From:

; 4169 :    }
; 4170 : 
; 4171 :    if ( SysWriteFile( vSubtask, hFile, pchData, ulLth ) != (int) ulLth )

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysWriteFile@16
	cmp	eax, DWORD PTR _ulLth$[ebp]
	je	SHORT $LN17@SetOI_From

; 4172 :       goto EndOfFunction;

	jmp	$EndOfFunction$24
$LN17@SetOI_From:

; 4173 : 
; 4174 :    SysCloseFile( vSubtask, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysCloseFile@12

; 4175 :    hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 4176 : 
; 4177 :    bFileCreated = TRUE;

	mov	BYTE PTR _bFileCreated$[ebp], 1

; 4178 : 
; 4179 :    // Last thing to do--read the file into an OI.
; 4180 :    nRC = ActivateOI_FromFile( plpTgtView, lpOI_Data->cpcViewOD_Name,

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOI_Data$[ebp]
	push	edx
	mov	eax, DWORD PTR _plpTgtView$[ebp]
	push	eax
	call	_ActivateOI_FromFile@20
	mov	WORD PTR _nRC$[ebp], ax

; 4181 :                               vSubtask, szFileName, lControl );
; 4182 :    if ( nRC == -1 && *plpTgtView )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN18@SetOI_From
	mov	edx, DWORD PTR _plpTgtView$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN18@SetOI_From

; 4183 :    {
; 4184 :       // No OI was activated but we were returned an empty OI.  Drop the
; 4185 :       // empty OI and reset plpTgtView.
; 4186 :       fnDropView( *plpTgtView );

	mov	eax, DWORD PTR _plpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnDropView@4

; 4187 :       *plpTgtView = 0;

	mov	edx, DWORD PTR _plpTgtView$[ebp]
	mov	DWORD PTR [edx], 0

; 4188 :    }

	jmp	SHORT $EndOfFunction$24
$LN18@SetOI_From:

; 4189 :    else
; 4190 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $EndOfFunction$24

; 4191 :    {
; 4192 :       // "KZOEE096 - Error retrieving OI from blob."
; 4193 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 16, 96, 0, lpSrcViewEntity->szName,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	96					; 00000060H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$EndOfFunction$24:

; 4194 :                         lpViewAttrib->szName );
; 4195 :    }
; 4196 : 
; 4197 : EndOfFunction:
; 4198 : 
; 4199 :    if ( hFile != -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	je	SHORT $LN21@SetOI_From

; 4200 :       SysCloseFile( vSubtask, hFile, 0 );

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysCloseFile@12
$LN21@SetOI_From:

; 4201 : 
; 4202 :    if ( bFileCreated )

	movzx	ecx, BYTE PTR _bFileCreated$[ebp]
	test	ecx, ecx
	je	SHORT $LN22@SetOI_From

; 4203 :       SysOpenFile( vSubtask, szFileName, COREFILE_DELETE );

	push	8
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysOpenFile@12
$LN22@SetOI_From:

; 4204 : 
; 4205 :    // Return the results
; 4206 :    fnOperationReturn( iSetOI_FromBlob, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	295					; 00000127H
	call	_fnOperationReturn
	add	esp, 8

; 4207 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetOI_From:

; 4208 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_SetOI_FromBlob@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcFileName$ = 20					; size = 4
_SetBlobFromFile@16 PROC

; 10693: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 10694:    LPTASK            lpCurrentTask;
; 10695:    LPVIEWENTITY      lpViewEntity;
; 10696:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10697:    LPVIEWATTRIB      lpViewAttrib;
; 10698:    zSHORT            nRC;
; 10699: 
; 10700:    // Validate parameters
; 10701:    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	296					; 00000128H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 10702:                                         &lpViewEntity,
; 10703:                                         &lpViewEntityCsr,
; 10704:                                         &lpViewAttrib,
; 10705:                                         iSetBlobFromFile,
; 10706:                                         1,   // We intend to update
; 10707:                                         lpView,
; 10708:                                         cpcEntityName,
; 10709:                                         cpcAttributeName, 0 );
; 10710:    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@SetBlobFro

; 10711:       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobFro
$LN2@SetBlobFro:

; 10712: 
; 10713:    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@SetBlobFro

; 10714:    {
; 10715:       fnOperationReturn( iSetBlobFromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	296					; 00000128H
	call	_fnOperationReturn
	add	esp, 8

; 10716:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobFro
$LN3@SetBlobFro:

; 10717:    }
; 10718: 
; 10719:    if ( lpViewAttrib->cType != zTYPE_BLOB &&

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	je	SHORT $LN4@SetBlobFro
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	je	SHORT $LN4@SetBlobFro

; 10720:         lpViewAttrib->cType != zTYPE_STRING )
; 10721:    {
; 10722:       // "KZOEE191 - Attribute must be a Blob or String for this operation."
; 10723:       fnIssueCoreError( lpCurrentTask, lpView, 16, 191, 0, cpcFileName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	push	0
	push	191					; 000000bfH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 10724:       fnOperationReturn( iSetBlobFromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	296					; 00000128H
	call	_fnOperationReturn
	add	esp, 8

; 10725:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetBlobFro
$LN4@SetBlobFro:

; 10726:    }
; 10727: 
; 10728:    // Call fnSetBlobFromFile to do the setting
; 10729:    nRC = fnSetBlobFromFile( lpView, lpViewEntityCsr,

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetBlobFromFile@16
	mov	WORD PTR _nRC$[ebp], ax

; 10730:                             lpViewAttrib, cpcFileName );
; 10731: 
; 10732:    fnOperationReturn( iSetBlobFromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	296					; 00000128H
	call	_fnOperationReturn
	add	esp, 8

; 10733:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetBlobFro:

; 10734: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetBlobFromFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcFileName$ = 20					; size = 4
_WriteBlobToFile@16 PROC

; 10804: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 10805:    LPTASK            lpCurrentTask;
; 10806:    LPVIEWENTITY      lpViewEntity;
; 10807:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10808:    LPVIEWATTRIB      lpViewAttrib;
; 10809:    zSHORT            nRC;
; 10810: 
; 10811:    // Validate parameters
; 10812:    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	297					; 00000129H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 10813:                                         &lpViewEntity,
; 10814:                                         &lpViewEntityCsr,
; 10815:                                         &lpViewAttrib,
; 10816:                                         iWriteBlobToFile,
; 10817:                                         1,   // We intend to update
; 10818:                                         lpView,
; 10819:                                         cpcEntityName,
; 10820:                                         cpcAttributeName, 0 );
; 10821:    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@WriteBlobT

; 10822:       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteBlobT
$LN2@WriteBlobT:

; 10823: 
; 10824:    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@WriteBlobT

; 10825:    {
; 10826:       fnOperationReturn( iWriteBlobToFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	297					; 00000129H
	call	_fnOperationReturn
	add	esp, 8

; 10827:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@WriteBlobT
$LN3@WriteBlobT:

; 10828:    }
; 10829: 
; 10830:    if ( lpViewAttrib->cType != zTYPE_BLOB )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	je	SHORT $LN4@WriteBlobT

; 10831:    {
; 10832:       // "KZOEE191 - Attribute must be a Blob for this operation."
; 10833:       fnIssueCoreError( lpCurrentTask, lpView, 16, 191, 0, cpcFileName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	push	0
	push	191					; 000000bfH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 10834:       fnOperationReturn( iWriteBlobToFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	297					; 00000129H
	call	_fnOperationReturn
	add	esp, 8

; 10835:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@WriteBlobT
$LN4@WriteBlobT:

; 10836:    }
; 10837: 
; 10838:    // Call fnWriteBlobToFile to do the setting
; 10839:    nRC = fnWriteBlobToFile( lpView, lpViewEntityCsr,

	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnWriteBlobToFile@16
	mov	WORD PTR _nRC$[ebp], ax

; 10840:                             lpViewAttrib, cpcFileName );
; 10841: 
; 10842:    fnOperationReturn( iWriteBlobToFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	297					; 00000129H
	call	_fnOperationReturn
	add	esp, 8

; 10843:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@WriteBlobT:

; 10844: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WriteBlobToFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpTgtViewEntity$ = -312				; size = 4
_lpTgtViewEntityCsr$ = -308				; size = 4
_lpViewAttrib$ = -304					; size = 4
_lpViewOD$ = -300					; size = 4
_lpBlobOI$ = -296					; size = 4
_pchData$ = -292					; size = 4
_lpCurrentTask$ = -288					; size = 4
_hMem$ = -284						; size = 4
_ulLth$ = -280						; size = 4
_hFile$ = -276						; size = 4
_nRC$ = -272						; size = 2
_bFileCreated$ = -265					; size = 1
_szFileName$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lpSrcView$ = 20					; size = 4
_lControl$ = 24						; size = 4
_SetBlobFromOI@20 PROC

; 3668 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3669 :    LPTASK            lpCurrentTask;
; 3670 :    LPVIEWOD          lpViewOD;
; 3671 :    LPVIEWENTITY      lpTgtViewEntity;
; 3672 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 3673 :    LPVIEWATTRIB      lpViewAttrib;
; 3674 :    zSHORT            nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 3675 :    zCHAR             szFileName[ zMAX_FILENAME_LTH + 1 ];
; 3676 :    zBOOL             bFileCreated = FALSE;

	mov	BYTE PTR _bFileCreated$[ebp], 0

; 3677 :    zLONG             hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 3678 :    zULONG            ulLth;
; 3679 :    zLONG             hMem = 0;

	mov	DWORD PTR _hMem$[ebp], 0

; 3680 :    zPCHAR            pchData;
; 3681 :    LPBLOBOI_RECORD   lpBlobOI;
; 3682 : 
; 3683 :    // Validate parameters
; 3684 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	push	1
	push	294					; 00000126H
	lea	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 3685 :                                         &lpTgtViewEntity,
; 3686 :                                         &lpTgtViewEntityCsr,
; 3687 :                                         &lpViewAttrib,
; 3688 :                                         iSetBlobFromOI,
; 3689 :                                         1,   // We intend to update
; 3690 :                                         lpTgtView,
; 3691 :                                         cpcTgtEntityName,
; 3692 :                                         cpcAttributeName, 0 );
; 3693 :    if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN2@SetBlobFro

; 3694 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobFro
$LN2@SetBlobFro:

; 3695 : 
; 3696 :    if ( nRC < 0 || fnValidView( lpCurrentTask, lpSrcView ) == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $LN4@SetBlobFro
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN3@SetBlobFro
$LN4@SetBlobFro:

; 3697 :    {
; 3698 :       fnOperationReturn( iSetBlobFromOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	294					; 00000126H
	call	_fnOperationReturn
	add	esp, 8

; 3699 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobFro
$LN3@SetBlobFro:

; 3700 :    }
; 3701 : 
; 3702 :    lpViewOD = zGETPTR( lpSrcView->hViewOD );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3703 : 
; 3704 :    SysCreateTempFileName( szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysCreateTempFileName@4

; 3705 : 
; 3706 :    // Now store the OI as a temporary file.
; 3707 :    if ( CommitOI_ToFile( lpSrcView, szFileName, lControl ) != 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_CommitOI_ToFile@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN5@SetBlobFro

; 3708 :       goto EndOfFunction;

	jmp	$EndOfFunction$13
$LN5@SetBlobFro:

; 3709 : 
; 3710 :    bFileCreated = TRUE;

	mov	BYTE PTR _bFileCreated$[ebp], 1

; 3711 : 
; 3712 :    hFile = SysOpenFile( lpSrcView, szFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 3713 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN6@SetBlobFro

; 3714 :    {
; 3715 :       // "KZOEE190 - Error opening temporary file"
; 3716 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 16, 190, 0, szFileName, 0 );

	push	0
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	0
	push	190					; 000000beH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3717 :       goto EndOfFunction;

	jmp	$EndOfFunction$13
$LN6@SetBlobFro:

; 3718 :    }
; 3719 : 
; 3720 :    // Get the file length.
; 3721 :    ulLth = SysGetFileSize( hFile );

	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	call	_SysGetFileSize@4
	mov	DWORD PTR _ulLth$[ebp], eax

; 3722 : 
; 3723 :    // Now allocate space big enough to hold the entire file.
; 3724 :    hMem = SysAllocMemory( (zCOREMEM) &pchData, ulLth + sizeof( BlobOI_Record ),

	push	0
	push	32768					; 00008000H
	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	add	eax, 137				; 00000089H
	push	eax
	lea	ecx, DWORD PTR _pchData$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 3725 :                           0, zCOREMEM_ALLOC, 0 );
; 3726 :    if ( hMem == 0 )

	cmp	DWORD PTR _hMem$[ebp], 0
	jne	SHORT $LN7@SetBlobFro

; 3727 :       goto EndOfFunction;

	jmp	$EndOfFunction$13
$LN7@SetBlobFro:

; 3728 : 
; 3729 :    // Set header information.
; 3730 :    lpBlobOI = (LPBLOBOI_RECORD) pchData;

	mov	edx, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _lpBlobOI$[ebp], edx

; 3731 :    zmemset( lpBlobOI, '*', sizeof( BlobOI_Record ) );

	push	137					; 00000089H
	push	42					; 0000002aH
	mov	eax, DWORD PTR _lpBlobOI$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3732 :    zstrcpy( lpBlobOI->cpcViewOD_Name, lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpBlobOI$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3733 : 
; 3734 :    if ( SysReadFile( lpSrcView, hFile,
; 3735 :                      pchData + sizeof( BlobOI_Record ), ulLth ) != ulLth )

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, 137				; 00000089H
	push	ecx
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_SysReadFile@16
	cmp	eax, DWORD PTR _ulLth$[ebp]
	je	SHORT $LN8@SetBlobFro

; 3736 :    {
; 3737 :       TraceLineI( "(at) Couldn't read entire file.  Lth = ", ulLth );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	push	OFFSET $SG15822
	call	_TraceLineI@8

; 3738 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$13
$LN8@SetBlobFro:

; 3739 :    }
; 3740 : 
; 3741 :    // Last thing to do--set blob attribute.
; 3742 :    nRC = fnSetAttributeFromBlob( lpTgtView, lpTgtViewEntityCsr,

	mov	edx, DWORD PTR _ulLth$[ebp]
	add	edx, 137				; 00000089H
	push	edx
	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$13:

; 3743 :                                  lpViewAttrib, pchData,
; 3744 :                                  ulLth + sizeof( BlobOI_Record ) );
; 3745 : 
; 3746 : EndOfFunction:
; 3747 : 
; 3748 :    if ( hMem )

	cmp	DWORD PTR _hMem$[ebp], 0
	je	SHORT $LN9@SetBlobFro

; 3749 :       SysFreeMemory( hMem );

	mov	ecx, DWORD PTR _hMem$[ebp]
	push	ecx
	call	_SysFreeMemory@4
$LN9@SetBlobFro:

; 3750 : 
; 3751 :    if ( hFile != -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	je	SHORT $LN10@SetBlobFro

; 3752 :       SysCloseFile( lpSrcView, hFile, 0 );

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_SysCloseFile@12
$LN10@SetBlobFro:

; 3753 : 
; 3754 :    if ( bFileCreated )

	movzx	ecx, BYTE PTR _bFileCreated$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@SetBlobFro

; 3755 :       SysOpenFile( lpSrcView, szFileName, COREFILE_DELETE );

	push	8
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_SysOpenFile@12
$LN11@SetBlobFro:

; 3756 : 
; 3757 :    // Return the results
; 3758 :    fnOperationReturn( iSetBlobFromOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	294					; 00000126H
	call	_fnOperationReturn
	add	esp, 8

; 3759 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetBlobFro:

; 3760 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetBlobFromOI@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewOI$ = -96					; size = 4
_lpTgtViewEntity$ = -92					; size = 4
_lpTgtEntityInstance$ = -88				; size = 4
_lpdDecimal$ = -84					; size = 4
_lpSrcViewEntityCsr$ = -80				; size = 4
_lpViewCsr$ = -76					; size = 4
_hBlob$ = -72						; size = 4
_lpdDecimal2$ = -68					; size = 4
_lpSrcEntityInstance$ = -64				; size = 4
_lpViewAttrib$ = -60					; size = 4
_lpTgtViewEntityCsr$ = -56				; size = 4
_lpSrcViewEntity$ = -52					; size = 4
_lpuBlobLth$ = -48					; size = 4
_lpExternalP$ = -44					; size = 4
_lplLong2$ = -40					; size = 4
tv155 = -36						; size = 4
_lpCurrentTask$ = -32					; size = 4
_lplLong$ = -28						; size = 4
_pchBlob$ = -24						; size = 4
_lpWrkViewAttrib$ = -20					; size = 4
_pchRecord$ = -16					; size = 4
_ulLth$ = -12						; size = 4
_pchWork$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_SetBlobFromEntityAttributes@20 PROC

; 3326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 96					; 00000060H

; 3327 :    LPTASK            lpCurrentTask;
; 3328 :    LPVIEWCSR         lpViewCsr;
; 3329 :    LPVIEWOI          lpViewOI;
; 3330 :    LPVIEWENTITY      lpSrcViewEntity;
; 3331 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 3332 :    LPVIEWENTITY      lpTgtViewEntity;
; 3333 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 3334 :    LPVIEWATTRIB      lpViewAttrib;
; 3335 :    LPVIEWATTRIB      lpWrkViewAttrib;
; 3336 :    LPENTITYINSTANCE  lpSrcEntityInstance;
; 3337 :    LPENTITYINSTANCE  lpTgtEntityInstance;
; 3338 :    zULONG            ulLth;
; 3339 :    zPCHAR            pchBlob;
; 3340 :    zPVOID            hBlob;
; 3341 :    zPCHAR            pchWork;
; 3342 :    zCOREMEM          lpExternalP;
; 3343 :    zPULONG           lpuBlobLth;
; 3344 :    zPLONG            lplLong;
; 3345 :    zPLONG            lplLong2;
; 3346 :    zPDECIMAL         lpdDecimal;
; 3347 :    zPDECIMAL         lpdDecimal2;
; 3348 :    zPCHAR            pchRecord;
; 3349 :    zSHORT            nRC;
; 3350 : 
; 3351 :    // Validate parameters
; 3352 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	push	0
	push	291					; 00000123H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 3353 :                                         &lpTgtViewEntity,
; 3354 :                                         &lpTgtViewEntityCsr,
; 3355 :                                         &lpViewAttrib,
; 3356 :                                         iSetBlobFromEntityAttributes,
; 3357 :                                         0,   // We no not intend to update
; 3358 :                                         lpTgtView,
; 3359 :                                         cpcTgtEntityName,
; 3360 :                                         cpcAttributeName, 0 );
; 3361 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN6@SetBlobFro

; 3362 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobFro
$LN6@SetBlobFro:

; 3363 : 
; 3364 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN7@SetBlobFro

; 3365 :    {
; 3366 :       fnOperationReturn( iSetBlobFromEntityAttributes, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	291					; 00000123H
	call	_fnOperationReturn
	add	esp, 8

; 3367 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobFro
$LN7@SetBlobFro:

; 3368 :    }
; 3369 : 
; 3370 :    // Validate parameters.
; 3371 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	4096					; 00001000H
	push	0
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	0
	push	291					; 00000123H
	push	0
	lea	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 3372 :                                         &lpSrcViewEntity,
; 3373 :                                         &lpSrcViewEntityCsr,
; 3374 :                                         0,
; 3375 :                                         iSetBlobFromEntityAttributes,
; 3376 :                                         0,   // We do not intend to update
; 3377 :                                         lpSrcView,
; 3378 :                                         cpcSrcEntityName,
; 3379 :                                         0,
; 3380 :                                         zUSE_TASK ); // Oper id already passed
; 3381 :    if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN8@SetBlobFro

; 3382 :    {
; 3383 :       fnOperationReturn( iSetBlobFromEntityAttributes, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	291					; 00000123H
	call	_fnOperationReturn
	add	esp, 8

; 3384 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobFro
$LN8@SetBlobFro:

; 3385 :    }
; 3386 : 
; 3387 :    lpViewCsr           = zGETPTR( lpTgtView->hViewCsr );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3388 :    lpViewOI            = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 3389 :    lpSrcEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 3390 :    lpTgtEntityInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 3391 :    pchBlob = 0;

	mov	DWORD PTR _pchBlob$[ebp], 0

; 3392 :    ulLth   = 0;

	mov	DWORD PTR _ulLth$[ebp], 0

; 3393 : 
; 3394 :    // If there is data, make two passes through the attributes, the first
; 3395 :    // to calculate the length of the blob to be created and the second to
; 3396 :    // actually create the data
; 3397 :    if ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	$LN9@SetBlobFro

; 3398 :    {
; 3399 :       lpWrkViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewAttrib$[ebp], eax
$LN2@SetBlobFro:

; 3400 :       while ( lpWrkViewAttrib )

	cmp	DWORD PTR _lpWrkViewAttrib$[ebp], 0
	je	$LN9@SetBlobFro

; 3401 :       {
; 3402 :          pchRecord = fnRecordForEntityAttr( lpSrcEntityInstance,

	mov	eax, DWORD PTR _lpWrkViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 3403 :                                             lpWrkViewAttrib );
; 3404 :          if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	$LN10@SetBlobFro

; 3405 :          {
; 3406 :             pchRecord += lpWrkViewAttrib->ulRecordOffset;

	mov	edx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _pchRecord$[ebp], eax

; 3407 :             if ( pchBlob )

	cmp	DWORD PTR _pchBlob$[ebp], 0
	je	SHORT $LN11@SetBlobFro

; 3408 :             {
; 3409 :                lplLong = (zPLONG) pchWork;

	mov	ecx, DWORD PTR _pchWork$[ebp]
	mov	DWORD PTR _lplLong$[ebp], ecx

; 3410 :                *lplLong = lpWrkViewAttrib->lERAttTok;

	mov	edx, DWORD PTR _lplLong$[ebp]
	mov	eax, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+177]
	mov	DWORD PTR [edx], ecx
$LN11@SetBlobFro:

; 3411 :             }
; 3412 : 
; 3413 :             switch ( lpWrkViewAttrib->cType )

	mov	edx, DWORD PTR _lpWrkViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR tv155[ebp], eax
	mov	ecx, DWORD PTR tv155[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv155[ebp], ecx
	cmp	DWORD PTR tv155[ebp], 18		; 00000012H
	ja	$LN10@SetBlobFro
	mov	edx, DWORD PTR tv155[ebp]
	movzx	eax, BYTE PTR $LN40@SetBlobFro[edx]
	jmp	DWORD PTR $LN41@SetBlobFro[eax*4]
$LN12@SetBlobFro:

; 3414 :             {
; 3415 :                case zTYPE_STRING:
; 3416 :                   // if the attribute is not null
; 3417 :                   if ( pchRecord[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	$LN13@SetBlobFro

; 3418 :                   {
; 3419 :                      if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN14@SetBlobFro

; 3420 :                      {
; 3421 :                         lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$[ebp], eax

; 3422 :                         pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN14@SetBlobFro:

; 3423 :                      }
; 3424 : 
; 3425 :                      // if this is the blob creation pass, set the data
; 3426 :                      // in the blob
; 3427 :                      if ( pchBlob )

	cmp	DWORD PTR _pchBlob$[ebp], 0
	je	SHORT $LN15@SetBlobFro

; 3428 :                      {
; 3429 :                         // Bump work blob pointer past attribute token
; 3430 :                         pchWork += sizeof( zLONG );

	mov	eax, DWORD PTR _pchWork$[ebp]
	add	eax, 4
	mov	DWORD PTR _pchWork$[ebp], eax

; 3431 : 
; 3432 :                         // Set Attribute type
; 3433 :                         pchWork[ 0 ] = lpWrkViewAttrib->cType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchWork$[ebp]
	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	cl, BYTE PTR [ecx+202]
	mov	BYTE PTR [eax+edx], cl

; 3434 : 
; 3435 :                         // Bump past attribute type
; 3436 :                         pchWork++;

	mov	edx, DWORD PTR _pchWork$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchWork$[ebp], edx

; 3437 :                         zstrcpy( pchWork, pchRecord );

	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchWork$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3438 :                         pchWork += zstrlen( pchWork ) + 1;

	mov	edx, DWORD PTR _pchWork$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchWork$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchWork$[ebp], edx

; 3439 :                      }

	jmp	SHORT $LN13@SetBlobFro
$LN15@SetBlobFro:

; 3440 :                      else
; 3441 :                      {
; 3442 :                         // Bump the length and blob pointers
; 3443 :                         ulLth += sizeof( zLONG ) + 1;

	mov	eax, DWORD PTR _ulLth$[ebp]
	add	eax, 5
	mov	DWORD PTR _ulLth$[ebp], eax

; 3444 :                         ulLth += zstrlen( pchRecord ) + 1;

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _ulLth$[ebp]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _ulLth$[ebp], eax
$LN13@SetBlobFro:

; 3445 :                      }
; 3446 :                   }
; 3447 : 
; 3448 :                   break;

	jmp	$LN10@SetBlobFro
$LN17@SetBlobFro:

; 3449 : 
; 3450 :                case zTYPE_INTEGER:
; 3451 :                   lplLong2 = (zPLONG) pchRecord;

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR _lplLong2$[ebp], ecx

; 3452 :                   if ( *lplLong2 != lNullInteger )

	mov	edx, DWORD PTR _lplLong2$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	je	SHORT $LN18@SetBlobFro

; 3453 :                   {
; 3454 :                      if ( pchBlob )

	cmp	DWORD PTR _pchBlob$[ebp], 0
	je	SHORT $LN19@SetBlobFro

; 3455 :                      {
; 3456 :                         // Bump work blob pointer past attribute token
; 3457 :                         pchWork += sizeof( zLONG );

	mov	ecx, DWORD PTR _pchWork$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchWork$[ebp], ecx

; 3458 : 
; 3459 :                         // Set Attribute type
; 3460 :                         pchWork[ 0 ] = lpWrkViewAttrib->cType;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchWork$[ebp]
	mov	edx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	dl, BYTE PTR [edx+202]
	mov	BYTE PTR [ecx+eax], dl

; 3461 : 
; 3462 :                         // Bump past attribute type
; 3463 :                         pchWork++;

	mov	eax, DWORD PTR _pchWork$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchWork$[ebp], eax

; 3464 : 
; 3465 :                         // Set long pointer for assignment
; 3466 :                         lplLong = (zPLONG) pchWork;

	mov	ecx, DWORD PTR _pchWork$[ebp]
	mov	DWORD PTR _lplLong$[ebp], ecx

; 3467 :                         *lplLong = *lplLong2;

	mov	edx, DWORD PTR _lplLong$[ebp]
	mov	eax, DWORD PTR _lplLong2$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 3468 :                         pchWork += sizeof( zLONG );

	mov	edx, DWORD PTR _pchWork$[ebp]
	add	edx, 4
	mov	DWORD PTR _pchWork$[ebp], edx

; 3469 :                      }

	jmp	SHORT $LN18@SetBlobFro
$LN19@SetBlobFro:

; 3470 :                      else
; 3471 :                      {
; 3472 :                         // Increment length for attribute token, attribute
; 3473 :                         // type and attribute value
; 3474 :                         ulLth += (2 * sizeof( zLONG )) + 1;

	mov	eax, DWORD PTR _ulLth$[ebp]
	add	eax, 9
	mov	DWORD PTR _ulLth$[ebp], eax
$LN18@SetBlobFro:

; 3475 :                      }
; 3476 :                   }
; 3477 : 
; 3478 :                   break;

	jmp	$LN10@SetBlobFro
$LN21@SetBlobFro:

; 3479 : 
; 3480 :                case zTYPE_DECIMAL:
; 3481 :                   lpdDecimal2 = (zPDECIMAL) pchRecord;

	mov	ecx, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR _lpdDecimal2$[ebp], ecx

; 3482 :                   if ( SysCompareDecimalToNull( lpdDecimal2 ) != 0 )

	mov	edx, DWORD PTR _lpdDecimal2$[ebp]
	push	edx
	call	_SysCompareDecimalToNull@4
	cwde
	test	eax, eax
	je	SHORT $LN22@SetBlobFro

; 3483 :                   {
; 3484 :                      if ( pchBlob )

	cmp	DWORD PTR _pchBlob$[ebp], 0
	je	SHORT $LN23@SetBlobFro

; 3485 :                      {
; 3486 :                         // Bump work blob pointer past attribute token
; 3487 :                         pchWork += sizeof( zLONG );

	mov	ecx, DWORD PTR _pchWork$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchWork$[ebp], ecx

; 3488 : 
; 3489 :                         // Set Attribute type
; 3490 :                         pchWork[ 0 ] = lpWrkViewAttrib->cType;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchWork$[ebp]
	mov	edx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	dl, BYTE PTR [edx+202]
	mov	BYTE PTR [ecx+eax], dl

; 3491 : 
; 3492 :                         // Bump past attribute type
; 3493 :                         pchWork++;

	mov	eax, DWORD PTR _pchWork$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchWork$[ebp], eax

; 3494 : 
; 3495 :                         // Set long pointer for assignment
; 3496 :                         lpdDecimal = (zPDECIMAL) pchWork;

	mov	ecx, DWORD PTR _pchWork$[ebp]
	mov	DWORD PTR _lpdDecimal$[ebp], ecx

; 3497 :                         SysAssignDecimalFromDecimal( lpdDecimal,

	mov	edx, DWORD PTR _lpdDecimal2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdDecimal$[ebp]
	push	eax
	call	_SysAssignDecimalFromDecimal@8

; 3498 :                                                      lpdDecimal2 );
; 3499 :                         pchWork += sizeof( zDECIMAL );

	mov	ecx, DWORD PTR _pchWork$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _pchWork$[ebp], ecx

; 3500 :                      }

	jmp	SHORT $LN22@SetBlobFro
$LN23@SetBlobFro:

; 3501 :                      else
; 3502 :                      {
; 3503 :                         // Increment length for attribute token, attribute
; 3504 :                         // type and attribute value
; 3505 :                         ulLth += sizeof( zDECIMAL ) + sizeof( zLONG ) + 1;

	mov	edx, DWORD PTR _ulLth$[ebp]
	add	edx, 45					; 0000002dH
	mov	DWORD PTR _ulLth$[ebp], edx
$LN22@SetBlobFro:

; 3506 :                      }
; 3507 :                   }
; 3508 : 
; 3509 :                   break;

	jmp	$LN10@SetBlobFro
$LN25@SetBlobFro:

; 3510 : 
; 3511 :                case zTYPE_DATETIME:
; 3512 :                   lplLong2 = (zPLONG) pchRecord;

	mov	eax, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR _lplLong2$[ebp], eax

; 3513 :                   if ( *lplLong2 != lNullInteger )

	mov	ecx, DWORD PTR _lplLong2$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	je	SHORT $LN26@SetBlobFro

; 3514 :                   {
; 3515 :                      if ( pchBlob )

	cmp	DWORD PTR _pchBlob$[ebp], 0
	je	SHORT $LN27@SetBlobFro

; 3516 :                      {
; 3517 :                         // Bump work blob pointer past attribute token
; 3518 :                         pchWork += sizeof( zLONG );

	mov	eax, DWORD PTR _pchWork$[ebp]
	add	eax, 4
	mov	DWORD PTR _pchWork$[ebp], eax

; 3519 : 
; 3520 :                         // Set Attribute type
; 3521 :                         pchWork[ 0 ] = lpWrkViewAttrib->cType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchWork$[ebp]
	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	cl, BYTE PTR [ecx+202]
	mov	BYTE PTR [eax+edx], cl

; 3522 : 
; 3523 :                         // Bump past attribute type
; 3524 :                         pchWork++;

	mov	edx, DWORD PTR _pchWork$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchWork$[ebp], edx

; 3525 : 
; 3526 :                         // Set long pointer for assignment
; 3527 :                         zstrncpy( pchWork, pchRecord,

	push	6
	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchWork$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 3528 :                                   sizeof( DateTimeInternalRecord ) );
; 3529 :                         pchWork[ sizeof( DateTimeInternalRecord ) ] = 0;

	mov	edx, 1
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _pchWork$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 3530 :                         pchWork += sizeof( DateTimeInternalRecord );

	mov	edx, DWORD PTR _pchWork$[ebp]
	add	edx, 6
	mov	DWORD PTR _pchWork$[ebp], edx

; 3531 :                      }

	jmp	SHORT $LN26@SetBlobFro
$LN27@SetBlobFro:

; 3532 :                      else
; 3533 :                      {
; 3534 :                         // Increment length for attribute token, attribute
; 3535 :                         // type and attribute value
; 3536 :                         ulLth += sizeof( zLONG ) + 1 +

	mov	eax, DWORD PTR _ulLth$[ebp]
	add	eax, 11					; 0000000bH
	mov	DWORD PTR _ulLth$[ebp], eax
$LN26@SetBlobFro:

; 3537 :                                           sizeof( DateTimeInternalRecord );
; 3538 :                      }
; 3539 :                   }
; 3540 : 
; 3541 :                   break;

	jmp	$LN10@SetBlobFro
$LN29@SetBlobFro:

; 3542 : 
; 3543 :                case zTYPE_BLOB:   // Blob attribute
; 3544 :                   if ( pchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	jne	$LN10@SetBlobFro

; 3545 :                   {
; 3546 :                      lpExternalP  = (zCOREMEM) (pchRecord + 1);

	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$[ebp], edx

; 3547 :                      lpuBlobLth  = (zPULONG) (lpExternalP + 1);

	mov	eax, DWORD PTR _lpExternalP$[ebp]
	add	eax, 4
	mov	DWORD PTR _lpuBlobLth$[ebp], eax

; 3548 :                      pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax

; 3549 :                      if ( pchBlob )

	cmp	DWORD PTR _pchBlob$[ebp], 0
	je	SHORT $LN31@SetBlobFro

; 3550 :                      {
; 3551 :                         // Bump work blob pointer past attribute token.
; 3552 :                         pchWork += sizeof( zLONG );

	mov	eax, DWORD PTR _pchWork$[ebp]
	add	eax, 4
	mov	DWORD PTR _pchWork$[ebp], eax

; 3553 : 
; 3554 :                         // Set Attribute type
; 3555 :                         pchWork[ 0 ] = lpWrkViewAttrib->cType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchWork$[ebp]
	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	cl, BYTE PTR [ecx+202]
	mov	BYTE PTR [eax+edx], cl

; 3556 : 
; 3557 :                         // Bump past attribute type.
; 3558 :                         pchWork++;

	mov	edx, DWORD PTR _pchWork$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchWork$[ebp], edx

; 3559 : 
; 3560 :                         // Copy blob data to output blob.
; 3561 :                         zmemcpy( pchWork, (zPCHAR) lpuBlobLth,

	push	4
	mov	eax, DWORD PTR _lpuBlobLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchWork$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3562 :                                  sizeof( zULONG ) );
; 3563 :                         pchWork += sizeof( zULONG );

	mov	edx, DWORD PTR _pchWork$[ebp]
	add	edx, 4
	mov	DWORD PTR _pchWork$[ebp], edx

; 3564 :                         zmemcpy( pchWork, pchRecord, (unsigned int) *lpuBlobLth );

	mov	eax, DWORD PTR _lpuBlobLth$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchWork$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3565 :                         pchWork += *lpuBlobLth;

	mov	ecx, DWORD PTR _lpuBlobLth$[ebp]
	mov	edx, DWORD PTR _pchWork$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pchWork$[ebp], edx

; 3566 :                      }

	jmp	SHORT $LN10@SetBlobFro
$LN31@SetBlobFro:

; 3567 :                      else
; 3568 :                      {
; 3569 :                         // Increment length for attribute token, attribute
; 3570 :                         // type and attribute value
; 3571 :                         ulLth += sizeof( zLONG ) + 1 +

	mov	eax, DWORD PTR _lpuBlobLth$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ulLth$[ebp]
	lea	eax, DWORD PTR [edx+ecx+9]
	mov	DWORD PTR _ulLth$[ebp], eax
$LN10@SetBlobFro:

; 3572 :                                           sizeof( zULONG ) + *lpuBlobLth;
; 3573 :                      }
; 3574 :                   }
; 3575 : 
; 3576 :                   break;
; 3577 : 
; 3578 :                default:
; 3579 :                   break;
; 3580 :             }
; 3581 :          }
; 3582 : 
; 3583 :          lpWrkViewAttrib = zGETPTR( lpWrkViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpWrkViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewAttrib$[ebp], eax

; 3584 : 
; 3585 :          // If we've passed all the attributes and a blob has yet to be
; 3586 :          // created, allocate the blob now and create the blob data
; 3587 :          if ( lpWrkViewAttrib == 0 && pchBlob == 0 && ulLth )

	cmp	DWORD PTR _lpWrkViewAttrib$[ebp], 0
	jne	$LN34@SetBlobFro
	cmp	DWORD PTR _pchBlob$[ebp], 0
	jne	$LN34@SetBlobFro
	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN34@SetBlobFro

; 3588 :          {
; 3589 :             ulLth += sizeof( zLONG ); // Add 4 to length for entity token

	mov	eax, DWORD PTR _ulLth$[ebp]
	add	eax, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 3590 : 
; 3591 :             // We allocate extra bytes for setting attribute tokens
; 3592 :             // in the event the last attribute is null and we've already
; 3593 :             // filled up the blob space calculated
; 3594 :             hBlob = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _ulLth$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hBlob$[ebp], eax

; 3595 :                                       ulLth + sizeof( zLONG ), 0, 0, 0 );
; 3596 :             pchBlob = zGETPTR( hBlob );

	mov	ecx, DWORD PTR _hBlob$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchBlob$[ebp], eax

; 3597 :             if ( pchBlob )

	cmp	DWORD PTR _pchBlob$[ebp], 0
	je	SHORT $LN35@SetBlobFro

; 3598 :             {
; 3599 :                // First store the ER Entity token in the blob
; 3600 :                pchWork = pchBlob;

	mov	edx, DWORD PTR _pchBlob$[ebp]
	mov	DWORD PTR _pchWork$[ebp], edx

; 3601 :                lplLong = (zPLONG) pchWork;

	mov	eax, DWORD PTR _pchWork$[ebp]
	mov	DWORD PTR _lplLong$[ebp], eax

; 3602 :                *lplLong = lpSrcViewEntity->lEREntTok;

	mov	ecx, DWORD PTR _lplLong$[ebp]
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+195]
	mov	DWORD PTR [ecx], eax

; 3603 :                pchWork += sizeof( zLONG );

	mov	ecx, DWORD PTR _pchWork$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchWork$[ebp], ecx

; 3604 :                lpWrkViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewAttrib$[ebp], eax

; 3605 :             }

	jmp	SHORT $LN34@SetBlobFro
$LN35@SetBlobFro:

; 3606 :             else
; 3607 :             {
; 3608 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 3609 :                break;

	jmp	SHORT $LN9@SetBlobFro
$LN34@SetBlobFro:

; 3610 :             }
; 3611 :          }
; 3612 :       }

	jmp	$LN2@SetBlobFro
$LN9@SetBlobFro:

; 3613 :    }
; 3614 : 
; 3615 :    // Call fnSetAttributeFromBlob to do the setting.
; 3616 :    if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN37@SetBlobFro

; 3617 :    {
; 3618 :       nRC = fnSetAttributeFromBlob( lpTgtView, lpTgtViewEntityCsr,

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBlob$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 3619 :                                     lpViewAttrib, pchBlob, ulLth );
; 3620 :       fnFreeDataspace( zGETPTR( hBlob ) );

	mov	ecx, DWORD PTR _hBlob$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 3621 :    }

	jmp	SHORT $LN38@SetBlobFro
$LN37@SetBlobFro:

; 3622 :    else
; 3623 :    {
; 3624 :       nRC = fnSetAttributeFromBlob( lpTgtView, lpTgtViewEntityCsr,

	push	4
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 195				; 000000c3H
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN38@SetBlobFro:

; 3625 :                                     lpViewAttrib,
; 3626 :                                     &lpSrcViewEntity->lEREntTok,
; 3627 :                                     sizeof( zLONG ) );
; 3628 :    }
; 3629 : 
; 3630 :    fnSetUpdateIndicator( 0, lpTgtEntityInstance, lpViewAttrib, 1, TRUE, TRUE );

	push	1
	push	1
	push	1
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	push	0
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H

; 3631 : 
; 3632 :    // Return the results.
; 3633 :    fnOperationReturn( iSetBlobFromEntityAttributes, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	291					; 00000123H
	call	_fnOperationReturn
	add	esp, 8

; 3634 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetBlobFro:

; 3635 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN41@SetBlobFro:
	DD	$LN29@SetBlobFro
	DD	$LN17@SetBlobFro
	DD	$LN21@SetBlobFro
	DD	$LN12@SetBlobFro
	DD	$LN25@SetBlobFro
	DD	$LN10@SetBlobFro
$LN40@SetBlobFro:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_SetBlobFromEntityAttributes@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -28					; size = 4
_lpCurrentTask$ = -24					; size = 4
_pvBlob$ = -20						; size = 4
_ulLth$ = -16						; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_cpcTgtAttributeName$ = 16				; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_cpcSrcAttributeName$ = 28				; size = 4
_SetBlobAttributeFromAttribute@24 PROC

; 4680 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 4681 :    LPTASK            lpCurrentTask;
; 4682 :    LPVIEWENTITY      lpViewEntity;
; 4683 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 4684 :    LPVIEWATTRIB      lpViewAttrib;
; 4685 :    zPVOID            pvBlob;
; 4686 :    zULONG            ulLth;
; 4687 :    zSHORT            nRC;
; 4688 : 
; 4689 :    // Validate parameters
; 4690 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	0
	push	276					; 00000114H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 4691 :                                         &lpViewEntity,
; 4692 :                                         &lpViewEntityCsr,
; 4693 :                                         &lpViewAttrib,
; 4694 :                                         iSetBlobAttributeFromAttribute,
; 4695 :                                         0,   // We do not intend to update
; 4696 :                                         lpSrcView,
; 4697 :                                         cpcSrcEntityName,
; 4698 :                                         cpcSrcAttributeName, 0 );
; 4699 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@SetBlobAtt

; 4700 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetBlobAtt
	jmp	SHORT $LN3@SetBlobAtt
$LN2@SetBlobAtt:

; 4701 :    else
; 4702 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN4@SetBlobAtt

; 4703 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN3@SetBlobAtt
$LN4@SetBlobAtt:

; 4704 :    else
; 4705 :    {
; 4706 :       // Get the length of the source attribute.
; 4707 :       fnGetActualAttributeLength( &ulLth, lpSrcView, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	call	_fnGetActualAttributeLength
	add	esp, 16					; 00000010H

; 4708 :                                   lpViewAttrib );
; 4709 :       if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN3@SetBlobAtt

; 4710 :       {
; 4711 :          nRC = fnGetAddrForAttribute( (zCOREMEM) &pvBlob, lpSrcView,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvBlob$[ebp]
	push	edx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 4712 :                                       lpViewEntityCsr, 0, lpViewAttrib );
; 4713 : 
; 4714 :          nRC = SetAttributeFromBlob( lpTgtView, cpcTgtEntityName,

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvBlob$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_SetAttributeFromBlob@20
	mov	WORD PTR _nRC$[ebp], ax
$LN3@SetBlobAtt:

; 4715 :                                      cpcTgtAttributeName,
; 4716 :                                      pvBlob, ulLth );
; 4717 :       }
; 4718 :    }
; 4719 : 
; 4720 :    fnOperationReturn( iSetBlobAttributeFromAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	276					; 00000114H
	call	_fnOperationReturn
	add	esp, 8

; 4721 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetBlobAtt:

; 4722 : 
; 4723 : }  /* SetBlobAttributeFromAttribute */

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SetBlobAttributeFromAttribute@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pvBlob$1 = -124					; size = 4
_lpdDecimal$2 = -120					; size = 4
_lplLong$3 = -116					; size = 4
_lpExternalP$4 = -112					; size = 4
_ulReturnSrcLth$5 = -108				; size = 4
_lpSrcTaskDomain$ = -104				; size = 4
_lpTgtTaskDomain$ = -100				; size = 4
_ulLth$6 = -96						; size = 4
_lpTgtViewEntityCsr$ = -92				; size = 4
tv139 = -88						; size = 4
_lpEntityInstance$ = -84				; size = 4
_lpTgtViewEntity$ = -80					; size = 4
_lpSrcViewEntity$ = -76					; size = 4
_lpSrcDomain$ = -72					; size = 4
_lpTgtDomain$ = -68					; size = 4
_cSrcDomainType$ = -61					; size = 1
tv263 = -60						; size = 4
_lpSrcViewEntityCsr$ = -56				; size = 4
_lpTgtViewAttrib$ = -52					; size = 4
_bMustDoDomains$ = -48					; size = 2
_lpCurrentTask$ = -44					; size = 4
_lpSrcViewAttrib$ = -40					; size = 4
_cTgtDomainType$ = -33					; size = 1
_pchRecord$ = -32					; size = 4
_nRC$ = -28						; size = 2
_szDateTime$7 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_cpcTgtAttributeName$ = 16				; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_cpcSrcAttributeName$ = 28				; size = 4
_SetAttributeFromAttribute@24 PROC

; 4335 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 4336 :    LPTASK            lpCurrentTask;
; 4337 :    LPVIEWENTITY      lpSrcViewEntity;
; 4338 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 4339 :    LPVIEWATTRIB      lpSrcViewAttrib;
; 4340 :    LPENTITYINSTANCE  lpEntityInstance;
; 4341 :    zPCHAR            pchRecord;
; 4342 :    LPVIEWENTITY      lpTgtViewEntity;
; 4343 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 4344 :    LPVIEWATTRIB      lpTgtViewAttrib;
; 4345 :    LPTASKDOMAIN      lpSrcTaskDomain;
; 4346 :    LPTASKDOMAIN      lpTgtTaskDomain;
; 4347 :    LPDOMAIN          lpSrcDomain;
; 4348 :    LPDOMAIN          lpTgtDomain;
; 4349 :    zCHAR             cSrcDomainType;
; 4350 :    zCHAR             cTgtDomainType;
; 4351 :    zSHORT            bMustDoDomains;
; 4352 :    zSHORT            nRC;
; 4353 : 
; 4354 :    // Validate parameters
; 4355 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	0
	push	264					; 00000108H
	lea	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 4356 :                                         &lpSrcViewEntity,
; 4357 :                                         &lpSrcViewEntityCsr,
; 4358 :                                         &lpSrcViewAttrib,
; 4359 :                                         iSetAttributeFromAttribute,
; 4360 :                                         0,   // We do not intend to update
; 4361 :                                         lpSrcView,
; 4362 :                                         cpcSrcEntityName,
; 4363 :                                         cpcSrcAttributeName, 0 );
; 4364 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN4@SetAttribu

; 4365 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetAttribu
$LN4@SetAttribu:

; 4366 : 
; 4367 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN5@SetAttribu

; 4368 :    {
; 4369 :       // Validate parameters
; 4370 :       nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	4096					; 00001000H
	mov	eax, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	push	1
	push	264					; 00000108H
	lea	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN5@SetAttribu:

; 4371 :                                            &lpTgtViewEntity,
; 4372 :                                            &lpTgtViewEntityCsr,
; 4373 :                                            &lpTgtViewAttrib,
; 4374 :                                            iSetAttributeFromAttribute,
; 4375 :                                            1,   // We do intend to update
; 4376 :                                            lpTgtView,
; 4377 :                                            cpcTgtEntityName,
; 4378 :                                            cpcTgtAttributeName,
; 4379 :                                            zUSE_TASK ); // Oper id already passed
; 4380 :    }
; 4381 : 
; 4382 :    if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@SetAttribu

; 4383 :    {
; 4384 :       fnOperationReturn( iSetAttributeFromAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	264					; 00000108H
	call	_fnOperationReturn
	add	esp, 8

; 4385 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetAttribu
$LN6@SetAttribu:

; 4386 :    }
; 4387 : 
; 4388 :    lpSrcDomain = zGETPTR( lpSrcViewAttrib->hDomain );

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcDomain$[ebp], eax

; 4389 :    lpTgtDomain = zGETPTR( lpTgtViewAttrib->hDomain );

	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtDomain$[ebp], eax

; 4390 : 
; 4391 :    cTgtDomainType = fnDomainProcessingRequired( &lpTgtTaskDomain,

	mov	ecx, DWORD PTR _lpTgtDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTgtTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cTgtDomainType$[ebp], al

; 4392 :                                                 lpTgtView,
; 4393 :                                                 lpCurrentTask,
; 4394 :                                                 lpTgtDomain );
; 4395 :    bMustDoDomains = cTgtDomainType ? 1 : 0;

	movsx	edx, BYTE PTR _cTgtDomainType$[ebp]
	test	edx, edx
	je	SHORT $LN37@SetAttribu
	mov	DWORD PTR tv139[ebp], 1
	jmp	SHORT $LN38@SetAttribu
$LN37@SetAttribu:
	mov	DWORD PTR tv139[ebp], 0
$LN38@SetAttribu:
	mov	ax, WORD PTR tv139[ebp]
	mov	WORD PTR _bMustDoDomains$[ebp], ax

; 4396 : 
; 4397 :    // Do this just to get the pointer to TaskDomain for Source
; 4398 :    cSrcDomainType = fnDomainProcessingRequired( &lpSrcTaskDomain,

	mov	ecx, DWORD PTR _lpSrcDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcTaskDomain$[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cSrcDomainType$[ebp], al

; 4399 :                                                 lpSrcView,
; 4400 :                                                 lpCurrentTask,
; 4401 :                                                 lpSrcDomain );
; 4402 :    if ( bMustDoDomains &&
; 4403 :         lpTgtDomain == lpSrcDomain &&

	movsx	edx, WORD PTR _bMustDoDomains$[ebp]
	test	edx, edx
	je	SHORT $LN7@SetAttribu
	mov	eax, DWORD PTR _lpTgtDomain$[ebp]
	cmp	eax, DWORD PTR _lpSrcDomain$[ebp]
	jne	SHORT $LN7@SetAttribu
	movsx	ecx, BYTE PTR _cTgtDomainType$[ebp]
	cmp	ecx, 84					; 00000054H
	je	SHORT $LN7@SetAttribu

; 4404 :         cTgtDomainType != zDM_TYPE_TABLE )
; 4405 :    {
; 4406 :       bMustDoDomains = 0;

	xor	edx, edx
	mov	WORD PTR _bMustDoDomains$[ebp], dx
$LN7@SetAttribu:

; 4407 :    }
; 4408 : 
; 4409 :    // If there is an object operation for the sourced attribute,
; 4410 :    // invoke it now...
; 4411 :    if ( lpSrcViewAttrib->szDerivedOper[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+213]
	test	eax, eax
	je	SHORT $LN8@SetAttribu

; 4412 :    {
; 4413 :       nRC = fnInvokeDerivedOperation( lpSrcView, lpSrcViewEntity,

	push	2
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 4414 :                                       lpSrcViewAttrib,
; 4415 :                                       lpCurrentTask, zDERIVED_GET );
; 4416 :       if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN8@SetAttribu

; 4417 :       {
; 4418 :          fnOperationReturn( iSetAttributeFromAttribute, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	264					; 00000108H
	call	_fnOperationReturn
	add	esp, 8

; 4419 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetAttribu
$LN8@SetAttribu:

; 4420 :       }
; 4421 :    }
; 4422 : 
; 4423 :    // Try calling the target domain operation to set attribute from attribute.
; 4424 :    if ( lpTgtDomain->szDomainOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTgtDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+100]
	test	ecx, ecx
	je	SHORT $LN10@SetAttribu

; 4425 :    {
; 4426 :       nRC = fnCallDomainOper2( lpCurrentTask, lpTgtTaskDomain,

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	push	11					; 0000000bH
	mov	edx, DWORD PTR _lpTgtTaskDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCallDomainOper2@36
	mov	WORD PTR _nRC$[ebp], ax

; 4427 :                                zDME_SET_ATTR_FROM_ATTR,
; 4428 :                                lpTgtView,
; 4429 :                                lpTgtViewEntity,
; 4430 :                                lpTgtViewAttrib,
; 4431 :                                lpSrcView,
; 4432 :                                lpSrcViewEntity,
; 4433 :                                lpSrcViewAttrib );
; 4434 : 
; 4435 :       // If the domain operation handled this call then we're done.
; 4436 :       if ( nRC != zDME_NOT_HANDLED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -10				; fffffff6H
	je	SHORT $LN10@SetAttribu

; 4437 :       {
; 4438 :          fnOperationReturn( iSetAttributeFromAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	264					; 00000108H
	call	_fnOperationReturn
	add	esp, 8

; 4439 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetAttribu
$LN10@SetAttribu:

; 4440 :       }
; 4441 :    }
; 4442 : 
; 4443 :    // Try calling the source domain operation to set attribute from attribute.
; 4444 :    if ( lpSrcDomain->szDomainOper[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSrcDomain$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+100]
	test	eax, eax
	je	SHORT $LN12@SetAttribu

; 4445 :    {
; 4446 :       nRC = fnCallDomainOper2( lpCurrentTask, lpSrcTaskDomain,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _lpSrcTaskDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCallDomainOper2@36
	mov	WORD PTR _nRC$[ebp], ax

; 4447 :                                zDME_SET_ATTR_TO_ATTR,
; 4448 :                                lpTgtView,
; 4449 :                                lpTgtViewEntity,
; 4450 :                                lpTgtViewAttrib,
; 4451 :                                lpSrcView,
; 4452 :                                lpSrcViewEntity,
; 4453 :                                lpSrcViewAttrib );
; 4454 : 
; 4455 :       // If the domain operation handled this call then we're done.
; 4456 :       if ( nRC != zDME_NOT_HANDLED )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -10				; fffffff6H
	je	SHORT $LN12@SetAttribu

; 4457 :       {
; 4458 :          fnOperationReturn( iSetAttributeFromAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	264					; 00000108H
	call	_fnOperationReturn
	add	esp, 8

; 4459 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetAttribu
$LN12@SetAttribu:

; 4460 :       }
; 4461 :    }
; 4462 : 
; 4463 :    // If domains are involved we will jump through some hoops,
; 4464 :    // otherwise we should try to use the original code, as to eliminate
; 4465 :    // some unnecessary memory transfers.
; 4466 :    if ( bMustDoDomains )

	movsx	edx, WORD PTR _bMustDoDomains$[ebp]
	test	edx, edx
	je	$LN14@SetAttribu

; 4467 :    {
; 4468 :       zULONG   ulReturnSrcLth;
; 4469 : 
; 4470 :       fnGetActualAttributeLength( &ulReturnSrcLth, lpSrcView,

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulReturnSrcLth$5[ebp]
	push	eax
	call	_fnGetActualAttributeLength
	add	esp, 16					; 00000010H

; 4471 :                                   lpSrcViewEntityCsr, lpSrcViewAttrib );
; 4472 : 
; 4473 :       fnGetAddrForAttribute( (zCOREMEM) &pchRecord, lpSrcView,

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchRecord$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 4474 :                              lpSrcViewEntityCsr, 0, lpSrcViewAttrib );
; 4475 : 
; 4476 : 
; 4477 :       if ( cTgtDomainType == zDM_TYPE_TABLE &&

	movsx	edx, BYTE PTR _cTgtDomainType$[ebp]
	cmp	edx, 84					; 00000054H
	jne	SHORT $LN16@SetAttribu
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	ecx, DWORD PTR _lpTgtViewAttrib$[ebp]
	mov	edx, DWORD PTR [eax+198]
	cmp	edx, DWORD PTR [ecx+198]
	jne	SHORT $LN16@SetAttribu

; 4478 :            lpSrcViewAttrib->hDomain == lpTgtViewAttrib->hDomain )
; 4479 :       {
; 4480 :          lpEntityInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 4481 :          nRC = fnStoreValueInEntityInstance( lpEntityInstance,

	push	0
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 4482 :                                              lpTgtViewEntity,
; 4483 :                                              lpTgtViewAttrib,
; 4484 :                                              (zPVOID) pchRecord, 0);
; 4485 : 
; 4486 :          fnOperationReturn( iSetAttributeFromAttribute, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	264					; 00000108H
	call	_fnOperationReturn
	add	esp, 8

; 4487 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetAttribu

; 4488 :       }

	jmp	SHORT $LN17@SetAttribu
$LN16@SetAttribu:

; 4489 :       else
; 4490 :       {
; 4491 :          // Pass the Source Attribute Domain Name as the Context for the
; 4492 :          // Target Attribute
; 4493 :          nRC = fnSetAttributeFromVariable( lpTgtView, lpTgtViewEntityCsr,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ulReturnSrcLth$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movzx	ecx, BYTE PTR [eax+202]
	push	ecx
	mov	edx, DWORD PTR _pchRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN17@SetAttribu:

; 4494 :                                            lpTgtViewAttrib,
; 4495 :                                            (zPVOID) pchRecord,
; 4496 :                                            lpSrcViewAttrib->cType,
; 4497 :                                            ulReturnSrcLth,
; 4498 :                                            0, // no context, internal value
; 4499 :                                            lpCurrentTask, 0 );
; 4500 :       }
; 4501 :    }

	jmp	$LN15@SetAttribu
$LN14@SetAttribu:

; 4502 :    else
; 4503 :    {
; 4504 :       // do the stuff below...
; 4505 : 
; 4506 :       // Get Entity Instance pointer
; 4507 :       lpEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 4508 : 
; 4509 :       // Get record to retrieve from
; 4510 :       pchRecord = fnRecordForEntityAttr( lpEntityInstance, lpSrcViewAttrib );

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchRecord$[ebp], eax

; 4511 : 
; 4512 :       // if a record exists get the attr pointer.
; 4513 :       if ( pchRecord )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	je	SHORT $LN18@SetAttribu

; 4514 :       {
; 4515 :          pchRecord += lpSrcViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchRecord$[ebp], edx

; 4516 :          if ( lpSrcViewAttrib->cType == zTYPE_STRING &&

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN18@SetAttribu
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN18@SetAttribu

; 4517 :               pchRecord[ 0 ] == (zCHAR) '\xff' )
; 4518 :          {
; 4519 :             zCOREMEM  lpExternalP;
; 4520 : 
; 4521 :             lpExternalP = (zCOREMEM) (pchRecord + 1);

	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$4[ebp], eax

; 4522 :             pchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$4[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN18@SetAttribu:

; 4523 :          }
; 4524 :       }
; 4525 : 
; 4526 :       // Now call the appropriate setting routine with the attribute
; 4527 :       switch ( lpSrcViewAttrib->cType )

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv263[ebp], ecx
	mov	edx, DWORD PTR tv263[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv263[ebp], edx
	cmp	DWORD PTR tv263[ebp], 18		; 00000012H
	ja	$LN35@SetAttribu
	mov	eax, DWORD PTR tv263[ebp]
	movzx	ecx, BYTE PTR $LN39@SetAttribu[eax]
	jmp	DWORD PTR $LN40@SetAttribu[ecx*4]
$LN20@SetAttribu:

; 4528 :       {
; 4529 :          case zTYPE_STRING:
; 4530 :             if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN21@SetAttribu

; 4531 :                pchRecord = szNullS;

	mov	edx, DWORD PTR _szNullS
	mov	DWORD PTR _pchRecord$[ebp], edx
$LN21@SetAttribu:

; 4532 : 
; 4533 :             nRC = SetAttributeFromString( lpTgtView, cpcTgtEntityName,

	mov	eax, DWORD PTR _pchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
	mov	WORD PTR _nRC$[ebp], ax

; 4534 :                                           cpcTgtAttributeName, pchRecord );
; 4535 :             break;

	jmp	$LN15@SetAttribu
$LN22@SetAttribu:

; 4536 : 
; 4537 :          case zTYPE_INTEGER:
; 4538 :          {
; 4539 :             zPLONG lplLong;
; 4540 : 
; 4541 :             if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN23@SetAttribu

; 4542 :             {
; 4543 :                nRC = SetAttributeFromString( lpTgtView,

	mov	ecx, DWORD PTR _szNullS
	push	ecx
	mov	edx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
	mov	WORD PTR _nRC$[ebp], ax

; 4544 :                                              cpcTgtEntityName,
; 4545 :                                              cpcTgtAttributeName,
; 4546 :                                              szNullS );
; 4547 :             }

	jmp	SHORT $LN24@SetAttribu
$LN23@SetAttribu:

; 4548 :             else
; 4549 :             {
; 4550 :                lplLong = (zPLONG) pchRecord;

	mov	edx, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR _lplLong$3[ebp], edx

; 4551 :                nRC = SetAttributeFromInteger( lpTgtView,

	mov	eax, DWORD PTR _lplLong$3[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16
	mov	WORD PTR _nRC$[ebp], ax
$LN24@SetAttribu:

; 4552 :                                              cpcTgtEntityName,
; 4553 :                                              cpcTgtAttributeName,
; 4554 :                                              *lplLong );
; 4555 :             }
; 4556 : 
; 4557 :             break;

	jmp	$LN15@SetAttribu
$LN25@SetAttribu:

; 4558 :          }
; 4559 : 
; 4560 :          case zTYPE_DECIMAL:
; 4561 :          {
; 4562 :             zPDECIMAL lpdDecimal;
; 4563 : 
; 4564 :             if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN26@SetAttribu

; 4565 :             {
; 4566 :                nRC = SetAttributeFromString( lpTgtView,

	mov	edx, DWORD PTR _szNullS
	push	edx
	mov	eax, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
	mov	WORD PTR _nRC$[ebp], ax

; 4567 :                                              cpcTgtEntityName,
; 4568 :                                              cpcTgtAttributeName,
; 4569 :                                              szNullS );
; 4570 :             }

	jmp	SHORT $LN27@SetAttribu
$LN26@SetAttribu:

; 4571 :             else
; 4572 :             {
; 4573 :                lpdDecimal = (zPDECIMAL) pchRecord;

	mov	eax, DWORD PTR _pchRecord$[ebp]
	mov	DWORD PTR _lpdDecimal$2[ebp], eax

; 4574 :                nRC = SetAttributeFromDecimal( lpTgtView,

	mov	esi, DWORD PTR _lpdDecimal$2[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_SetAttributeFromDecimal@52
	mov	WORD PTR _nRC$[ebp], ax
$LN27@SetAttribu:

; 4575 :                                               cpcTgtEntityName,
; 4576 :                                               cpcTgtAttributeName,
; 4577 :                                               *lpdDecimal );
; 4578 :             }
; 4579 : 
; 4580 :             break;

	jmp	$LN15@SetAttribu
$LN28@SetAttribu:

; 4581 :          }
; 4582 : 
; 4583 :          case zTYPE_BLOB:
; 4584 :          {
; 4585 :             zPVOID  pvBlob;
; 4586 :             zULONG  ulLth;
; 4587 : 
; 4588 :             // Get the length of the source BLOB
; 4589 :             nRC = GetAttributeLength( &ulLth, lpSrcView, cpcSrcEntityName,

	mov	ecx, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$6[ebp]
	push	ecx
	call	_GetAttributeLength@16
	mov	WORD PTR _nRC$[ebp], ax

; 4590 :                                       cpcSrcAttributeName );
; 4591 :             if ( nRC == 0 && ulLth )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN29@SetAttribu
	cmp	DWORD PTR _ulLth$6[ebp], 0
	je	SHORT $LN29@SetAttribu

; 4592 :             {
; 4593 :                nRC = fnGetAddrForAttribute( (zCOREMEM) &pvBlob,

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvBlob$1[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 4594 :                                             lpSrcView,
; 4595 :                                             lpSrcViewEntityCsr, 0,
; 4596 :                                             lpSrcViewAttrib );
; 4597 :                if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@SetAttribu

; 4598 :                {
; 4599 :                   TraceLineS( "(at) in SAFA fnGetAddrForAttribute",

	push	OFFSET $SG16098
	push	OFFSET $SG16099
	call	_TraceLineS@8

; 4600 :                               " failed." );
; 4601 :                   break;

	jmp	$LN15@SetAttribu

; 4602 :                }

	jmp	SHORT $LN29@SetAttribu
$LN30@SetAttribu:

; 4603 :                else
; 4604 :                   nRC = SetAttributeFromBlob( lpTgtView,

	mov	edx, DWORD PTR _ulLth$6[ebp]
	push	edx
	mov	eax, DWORD PTR _pvBlob$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_SetAttributeFromBlob@20
	mov	WORD PTR _nRC$[ebp], ax
$LN29@SetAttribu:

; 4605 :                                               cpcTgtEntityName,
; 4606 :                                               cpcTgtAttributeName,
; 4607 :                                               pvBlob,
; 4608 :                                               ulLth );
; 4609 : 
; 4610 : //             TraceLineI( "(at) in SAFA SetAttrFromBlob nRC-", nRC );
; 4611 :             }
; 4612 : 
; 4613 :             break;

	jmp	SHORT $LN15@SetAttribu
$LN32@SetAttribu:

; 4614 :          }
; 4615 : 
; 4616 :          case zTYPE_DATETIME:
; 4617 :          {
; 4618 :             if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN33@SetAttribu

; 4619 :             {
; 4620 :                nRC = SetAttributeFromString( lpTgtView,

	mov	ecx, DWORD PTR _szNullS
	push	ecx
	mov	edx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
	mov	WORD PTR _nRC$[ebp], ax

; 4621 :                                              cpcTgtEntityName,
; 4622 :                                              cpcTgtAttributeName,
; 4623 :                                              szNullS );
; 4624 :             }

	jmp	SHORT $LN34@SetAttribu
$LN33@SetAttribu:

; 4625 :             else
; 4626 :             {
; 4627 :                zCHAR    szDateTime[ 18 ];
; 4628 : 
; 4629 :                fnGetStringFromAttribute( szDateTime, 18, lpSrcView,

	push	0
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	18					; 00000012H
	lea	edx, DWORD PTR _szDateTime$7[ebp]
	push	edx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H

; 4630 :                                          lpSrcViewEntityCsr,
; 4631 :                                          lpSrcViewAttrib, 0 );
; 4632 : 
; 4633 :                nRC = SetAttributeFromString( lpTgtView, cpcTgtEntityName,

	lea	eax, DWORD PTR _szDateTime$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
	mov	WORD PTR _nRC$[ebp], ax
$LN34@SetAttribu:

; 4634 :                                              cpcTgtAttributeName,
; 4635 :                                              szDateTime );
; 4636 :             }
; 4637 : 
; 4638 :             break;

	jmp	SHORT $LN15@SetAttribu
$LN35@SetAttribu:

; 4639 :          }
; 4640 : 
; 4641 :          default:
; 4642 :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN15@SetAttribu:

; 4643 :       }
; 4644 :    }
; 4645 : 
; 4646 :    fnOperationReturn( iSetAttributeFromAttribute, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	264					; 00000108H
	call	_fnOperationReturn
	add	esp, 8

; 4647 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetAttribu:

; 4648 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN40@SetAttribu:
	DD	$LN28@SetAttribu
	DD	$LN22@SetAttribu
	DD	$LN25@SetAttribu
	DD	$LN20@SetAttribu
	DD	$LN32@SetAttribu
	DD	$LN35@SetAttribu
$LN39@SetAttribu:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_SetAttributeFromAttribute@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lIntegerValue$ = 20					; size = 4
_AddToAttributeFromInteger@16 PROC

; 2775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2776 :    LPTASK            lpCurrentTask;
; 2777 :    LPVIEWENTITY      lpViewEntity;
; 2778 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2779 :    LPVIEWATTRIB      lpViewAttrib;
; 2780 :    zSHORT            nRC;
; 2781 : 
; 2782 :    // If integer coming in is null, short circuit.
; 2783 :    if ( lIntegerValue == lNullInteger )

	mov	eax, DWORD PTR _lIntegerValue$[ebp]
	cmp	eax, DWORD PTR _lNullInteger
	jne	SHORT $LN2@AddToAttri

; 2784 :    {
; 2785 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@AddToAttri
$LN2@AddToAttri:

; 2786 :    }
; 2787 : 
; 2788 :    // Validate parameters
; 2789 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	1
	push	266					; 0000010aH
	lea	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 2790 :                                         &lpViewEntity,
; 2791 :                                         &lpViewEntityCsr,
; 2792 :                                         &lpViewAttrib,
; 2793 :                                         iAddToAttributeFromInteger,
; 2794 :                                         1,   // We intend to update
; 2795 :                                         lpView,
; 2796 :                                         cpcEntityName,
; 2797 :                                         cpcAttributeName, 0 );
; 2798 :    if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN3@AddToAttri

; 2799 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@AddToAttri
$LN3@AddToAttri:

; 2800 : 
; 2801 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN4@AddToAttri

; 2802 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN5@AddToAttri
$LN4@AddToAttri:

; 2803 :    else
; 2804 :       nRC = fnAddToAttributeFromVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	76					; 0000004cH
	lea	eax, DWORD PTR _lIntegerValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAddToAttributeFromVariable
	add	esp, 32					; 00000020H
	mov	WORD PTR _nRC$[ebp], ax
$LN5@AddToAttri:

; 2805 :                                           (zPVOID) &lIntegerValue, zTYPE_INTEGER,
; 2806 :                                           0, 0, lpCurrentTask );
; 2807 : 
; 2808 :    fnOperationReturn( iAddToAttributeFromInteger, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	266					; 0000010aH
	call	_fnOperationReturn
	add	esp, 8

; 2809 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@AddToAttri:

; 2810 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_AddToAttributeFromInteger@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_pBlobValue$ = 20					; size = 4
_ulLth$ = 24						; size = 4
_SetAttributeFromBlob@20 PROC

; 3267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3268 :    LPTASK            lpCurrentTask;
; 3269 :    LPVIEWENTITY      lpViewEntity;
; 3270 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 3271 :    LPVIEWATTRIB      lpViewAttrib;
; 3272 :    zSHORT            nRC;
; 3273 : 
; 3274 :    // Validate parameters
; 3275 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	263					; 00000107H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 3276 :                                         &lpViewEntity,
; 3277 :                                         &lpViewEntityCsr,
; 3278 :                                         &lpViewAttrib,
; 3279 :                                         iSetAttributeFromBlob,
; 3280 :                                         1,   // We intend to update
; 3281 :                                         lpView,
; 3282 :                                         cpcEntityName,
; 3283 :                                         cpcAttributeName, 0 );
; 3284 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@SetAttribu

; 3285 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetAttribu
$LN2@SetAttribu:

; 3286 : 
; 3287 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@SetAttribu

; 3288 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@SetAttribu
$LN3@SetAttribu:

; 3289 :    else
; 3290 :    {
; 3291 :       // Call fnSetAttributeFromBlob to do the setting
; 3292 :       nRC = fnSetAttributeFromBlob( lpView, lpViewEntityCsr,

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBlobValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@SetAttribu:

; 3293 :                                     lpViewAttrib, pBlobValue, ulLth );
; 3294 :    }
; 3295 : 
; 3296 :    fnOperationReturn( iSetAttributeFromBlob, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	263					; 00000107H
	call	_fnOperationReturn
	add	esp, 8

; 3297 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetAttribu:

; 3298 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetAttributeFromBlob@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -24					; size = 4
_ulLth$ = -20						; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pReturnBlob$ = 8					; size = 4
_pulMaxLth$ = 12					; size = 4
_lpView$ = 16						; size = 4
_cpcEntityName$ = 20					; size = 4
_cpcAttributeName$ = 24					; size = 4
_GetBlobFromAttribute@20 PROC

; 1383 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1384 :    LPTASK            lpCurrentTask;
; 1385 :    LPVIEWENTITY      lpViewEntity;
; 1386 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1387 :    LPVIEWATTRIB      lpViewAttrib;
; 1388 :    zULONG            ulLth;
; 1389 :    zSHORT            nRC;
; 1390 : 
; 1391 :    // Validate parameters
; 1392 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	253					; 000000fdH
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 1393 :                                         &lpViewEntity,
; 1394 :                                         &lpViewEntityCsr,
; 1395 :                                         &lpViewAttrib,
; 1396 :                                         iGetBlobFromAttribute,
; 1397 :                                         0,   // We do not intend to update
; 1398 :                                         lpView,
; 1399 :                                         cpcEntityName,
; 1400 :                                         cpcAttributeName, 0 );
; 1401 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@GetBlobFro

; 1402 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetBlobFro
$LN2@GetBlobFro:

; 1403 : 
; 1404 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@GetBlobFro

; 1405 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@GetBlobFro
$LN3@GetBlobFro:

; 1406 :    else
; 1407 :    {
; 1408 :       if ( pulMaxLth == 0 )

	cmp	DWORD PTR _pulMaxLth$[ebp], 0
	jne	SHORT $LN5@GetBlobFro

; 1409 :       {
; 1410 :          fnGetAttributeLength( &ulLth, lpView,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 1411 :                                zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 1412 :                                lpViewAttrib );
; 1413 :          pulMaxLth = &ulLth;

	lea	eax, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR _pulMaxLth$[ebp], eax
$LN5@GetBlobFro:

; 1414 :       }
; 1415 : 
; 1416 :       nRC = fnGetVariableFromAttribute( (zPVOID) pReturnBlob, pulMaxLth,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pulMaxLth$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	66					; 00000042H
	mov	ecx, DWORD PTR _pulMaxLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pReturnBlob$[ebp]
	push	edx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@GetBlobFro:

; 1417 :                                         zTYPE_BLOB,
; 1418 :                                         *pulMaxLth, lpView, lpViewEntityCsr,
; 1419 :                                         lpViewAttrib, 0, lpCurrentTask, 0 );
; 1420 :    }
; 1421 : 
; 1422 :    fnOperationReturn( iGetBlobFromAttribute, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	253					; 000000fdH
	call	_fnOperationReturn
	add	esp, 8

; 1423 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetBlobFro:

; 1424 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GetBlobFromAttribute@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_dDecimalValue$ = 20					; size = 40
_SetAttributeFromDecimal@52 PROC

; 2951 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2952 :    LPTASK            lpCurrentTask;
; 2953 :    LPVIEWENTITY      lpViewEntity;
; 2954 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2955 :    LPVIEWATTRIB      lpViewAttrib;
; 2956 :    zSHORT            nRC;
; 2957 : 
; 2958 :    // Validate parameters
; 2959 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	262					; 00000106H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 2960 :                                         &lpViewEntity,
; 2961 :                                         &lpViewEntityCsr,
; 2962 :                                         &lpViewAttrib,
; 2963 :                                         iSetAttributeFromDecimal,
; 2964 :                                         1,   // We intend to update
; 2965 :                                         lpView,
; 2966 :                                         cpcEntityName,
; 2967 :                                         cpcAttributeName, 0 );
; 2968 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@SetAttribu

; 2969 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetAttribu
$LN2@SetAttribu:

; 2970 : 
; 2971 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@SetAttribu

; 2972 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@SetAttribu
$LN3@SetAttribu:

; 2973 :    else
; 2974 :       nRC = fnSetAttributeFromVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	77					; 0000004dH
	lea	edx, DWORD PTR _dDecimalValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@SetAttribu:

; 2975 :                                         (zPVOID) &dDecimalValue,
; 2976 :                                         zTYPE_DECIMAL, 0, 0,
; 2977 :                                         lpCurrentTask, 0 );
; 2978 : 
; 2979 :    fnOperationReturn( iSetAttributeFromDecimal, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	262					; 00000106H
	call	_fnOperationReturn
	add	esp, 8

; 2980 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetAttribu:

; 2981 : }

	mov	esp, ebp
	pop	ebp
	ret	52					; 00000034H
_SetAttributeFromDecimal@52 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_ulTossOut$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpdReturnDecimal$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_GetDecimalFromAttribute@16 PROC

; 1229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1230 :    LPTASK            lpCurrentTask;
; 1231 :    LPVIEWENTITY      lpViewEntity;
; 1232 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1233 :    LPVIEWATTRIB      lpViewAttrib;
; 1234 :    zULONG            ulTossOut;
; 1235 :    zSHORT            nRC;
; 1236 : 
; 1237 :    // Validate parameters
; 1238 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	252					; 000000fcH
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 1239 :                                         &lpViewEntity,
; 1240 :                                         &lpViewEntityCsr,
; 1241 :                                         &lpViewAttrib,
; 1242 :                                         iGetDecimalFromAttribute,
; 1243 :                                         0,   // We do not intend to update
; 1244 :                                         lpView,
; 1245 :                                         cpcEntityName,
; 1246 :                                         cpcAttributeName, 0 );
; 1247 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@GetDecimal

; 1248 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetDecimal
$LN2@GetDecimal:

; 1249 : 
; 1250 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@GetDecimal

; 1251 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@GetDecimal
$LN3@GetDecimal:

; 1252 :    else
; 1253 :    {
; 1254 :       nRC = fnGetVariableFromAttribute( (zPVOID) lpdReturnDecimal,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	push	77					; 0000004dH
	lea	edx, DWORD PTR _ulTossOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpdReturnDecimal$[ebp]
	push	eax
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@GetDecimal:

; 1255 :                                         &ulTossOut,
; 1256 :                                         zTYPE_DECIMAL,
; 1257 :                                         0, lpView, lpViewEntityCsr,
; 1258 :                                         lpViewAttrib, 0, lpCurrentTask, 0 );
; 1259 :    }
; 1260 : 
; 1261 :    fnOperationReturn( iGetDecimalFromAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	252					; 000000fcH
	call	_fnOperationReturn
	add	esp, 8

; 1262 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetDecimal:

; 1263 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetDecimalFromAttribute@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lIntegerValue$ = 20					; size = 4
_SetAttributeFromInteger@16 PROC

; 2643 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2644 :    LPTASK            lpCurrentTask;
; 2645 :    LPVIEWENTITY      lpViewEntity;
; 2646 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2647 :    LPVIEWATTRIB      lpViewAttrib;
; 2648 :    zSHORT            nRC;
; 2649 : 
; 2650 :    // Validate parameters
; 2651 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	261					; 00000105H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 2652 :                                         &lpViewEntity,
; 2653 :                                         &lpViewEntityCsr,
; 2654 :                                         &lpViewAttrib,
; 2655 :                                         iSetAttributeFromInteger,
; 2656 :                                         1,   // We intend to update
; 2657 :                                         lpView,
; 2658 :                                         cpcEntityName,
; 2659 :                                         cpcAttributeName, 0 );
; 2660 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@SetAttribu

; 2661 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetAttribu
$LN2@SetAttribu:

; 2662 : 
; 2663 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@SetAttribu

; 2664 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@SetAttribu
$LN3@SetAttribu:

; 2665 :    else
; 2666 :       nRC = fnSetAttributeFromVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	76					; 0000004cH
	lea	edx, DWORD PTR _lIntegerValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@SetAttribu:

; 2667 :                                         (zPVOID) &lIntegerValue, 'L', 0, 0,
; 2668 :                                         lpCurrentTask, 0 );
; 2669 : 
; 2670 :    fnOperationReturn( iSetAttributeFromInteger, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	261					; 00000105H
	call	_fnOperationReturn
	add	esp, 8

; 2671 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetAttribu:

; 2672 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetAttributeFromInteger@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_ulTossOut$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lplReturnInteger$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_GetIntegerFromAttribute@16 PROC

; 1040 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1041 :    LPTASK            lpCurrentTask;
; 1042 :    LPVIEWENTITY      lpViewEntity;
; 1043 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1044 :    LPVIEWATTRIB      lpViewAttrib;
; 1045 :    zULONG            ulTossOut;
; 1046 :    zSHORT            nRC;
; 1047 : 
; 1048 :    *lplReturnInteger = 0;   // initialize return value to zero

	mov	eax, DWORD PTR _lplReturnInteger$[ebp]
	mov	DWORD PTR [eax], 0

; 1049 : 
; 1050 :    // Validate parameters
; 1051 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	1
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	push	251					; 000000fbH
	lea	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 1052 :                                         &lpViewEntity,
; 1053 :                                         &lpViewEntityCsr,
; 1054 :                                         &lpViewAttrib,
; 1055 :                                         iGetIntegerFromAttribute,
; 1056 :                                         0,   // We do not intend to update
; 1057 :                                         lpView,
; 1058 :                                         cpcEntityName,
; 1059 :                                         cpcAttributeName,
; 1060 :                                         zACCEPT_NULL_ENTITY );
; 1061 : 
; 1062 :    if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN2@GetInteger

; 1063 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetInteger
$LN2@GetInteger:

; 1064 : 
; 1065 :    if ( nRC == -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jne	SHORT $LN3@GetInteger

; 1066 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN4@GetInteger
$LN3@GetInteger:

; 1067 :    else
; 1068 :    if ( nRC != -2 )   // not a NULL entity.

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN4@GetInteger

; 1069 :    {
; 1070 :       nRC = fnGetVariableFromAttribute( (zPVOID) lplReturnInteger,

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	push	76					; 0000004cH
	lea	ecx, DWORD PTR _ulTossOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lplReturnInteger$[ebp]
	push	edx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@GetInteger:

; 1071 :                                         &ulTossOut,
; 1072 :                                         zTYPE_INTEGER,
; 1073 :                                         0, lpView, lpViewEntityCsr,
; 1074 :                                         lpViewAttrib, 0, lpCurrentTask, 0 );
; 1075 :    }
; 1076 : 
; 1077 :    fnOperationReturn( iGetIntegerFromAttribute, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	251					; 000000fbH
	call	_fnOperationReturn
	add	esp, 8

; 1078 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetInteger:

; 1079 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetIntegerFromAttribute@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_pvReturnView$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_GetViewFromAttribute@16 PROC

; 1009 : {

	push	ebp
	mov	ebp, esp

; 1010 :    return( GetIntegerFromAttribute( (zPLONG) pvReturnView, lpView,

	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 1011 :                                     cpcEntityName, cpcAttributeName ) );
; 1012 : }

	pop	ebp
	ret	16					; 00000010H
_GetViewFromAttribute@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcStringValue$ = 20					; size = 4
_SetAttributeFromString@16 PROC

; 2453 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2454 :    LPTASK            lpCurrentTask;
; 2455 :    LPVIEWENTITY      lpViewEntity;
; 2456 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2457 :    LPVIEWATTRIB      lpViewAttrib;
; 2458 :    zSHORT            nRC;
; 2459 : 
; 2460 :    // Validate parameters
; 2461 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	1
	push	260					; 00000104H
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 2462 :                                         &lpViewEntity,
; 2463 :                                         &lpViewEntityCsr,
; 2464 :                                         &lpViewAttrib,
; 2465 :                                         iSetAttributeFromString,
; 2466 :                                         1,   // We intend to update
; 2467 :                                         lpView,
; 2468 :                                         cpcEntityName,
; 2469 :                                         cpcAttributeName, 0 );
; 2470 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@SetAttribu

; 2471 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetAttribu
$LN2@SetAttribu:

; 2472 : 
; 2473 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@SetAttribu

; 2474 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@SetAttribu
$LN3@SetAttribu:

; 2475 :    else
; 2476 :       nRC = fnSetAttributeFromVariable( lpView, lpViewEntityCsr, lpViewAttrib,

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	83					; 00000053H
	mov	edx, DWORD PTR _cpcStringValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@SetAttribu:

; 2477 :                                         (zPVOID) cpcStringValue, 'S', 0, 0,
; 2478 :                                         lpCurrentTask, 0 );
; 2479 : 
; 2480 :    fnOperationReturn( iSetAttributeFromString, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	260					; 00000104H
	call	_fnOperationReturn
	add	esp, 8

; 2481 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetAttribu:

; 2482 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetAttributeFromString@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -76					; size = 4
_lpCurrentTask$ = -72					; size = 4
_lpBlob$1 = -68						; size = 4
_pchChar$2 = -64					; size = 4
_lpdDecimal2$3 = -60					; size = 4
_lpExternalP$4 = -56					; size = 4
_lpViewEntityCsr$ = -52					; size = 4
_lpReturnBlob$5 = -48					; size = 4
_lplLong2$6 = -44					; size = 4
_lplLong$7 = -40					; size = 4
_lpEntityInstance$ = -36				; size = 4
_lpdDecimal$8 = -32					; size = 4
_pchRecordString$9 = -28				; size = 4
tv142 = -24						; size = 4
_pchRecord$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_nIndex$10 = -12					; size = 2
_nRC$ = -8						; size = 2
_bBlobType$11 = -1					; size = 1
_pchReturnStruct$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_GetStructFromEntityAttrs@12 PROC

; 1519 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 1520 :    LPTASK            lpCurrentTask;
; 1521 :    LPVIEWENTITY      lpViewEntity;
; 1522 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1523 :    LPVIEWATTRIB      lpViewAttrib;
; 1524 :    LPENTITYINSTANCE  lpEntityInstance;
; 1525 :    zPCHAR            pchRecord;
; 1526 :    zSHORT            nRC;
; 1527 : 
; 1528 :    // Validate parameters
; 1529 :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	push	258					; 00000102H
	lea	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 1530 :                                         &lpViewEntity,
; 1531 :                                         &lpViewEntityCsr,
; 1532 :                                         &lpViewAttrib,
; 1533 :                                         iGetStructFromEntityAttrs,
; 1534 :                                         0,   // We do not intend to update
; 1535 :                                         lpView,
; 1536 :                                         cpcEntityName,
; 1537 :                                         0, 0 );
; 1538 :    if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN10@GetStructF

; 1539 :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetStructF
$LN10@GetStructF:

; 1540 : 
; 1541 :    if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN11@GetStructF

; 1542 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
	jmp	$LN12@GetStructF
$LN11@GetStructF:

; 1543 :    else
; 1544 :    {
; 1545 :       zBOOL bBlobType;
; 1546 : 
; 1547 :       // Get Entity Instance pointer.
; 1548 :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1549 : 
; 1550 : #ifdef TRACE_STRUCT
; 1551 :       {
; 1552 :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );
; 1553 :          TraceLine( "GetStructFromEntityAttrs Def: %s   Entity: %s",
; 1554 :                     cpcEntityName, lpViewOD->szName );
; 1555 :       }
; 1556 : #endif
; 1557 : 
; 1558 :       // If a record exists, copy it to the return variable.
; 1559 :       for ( nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN4@GetStructF
$LN2@GetStructF:

; 1561 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@GetStructF:

; 1560 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN12@GetStructF

; 1562 :       {
; 1563 :          bBlobType = FALSE;

	mov	BYTE PTR _bBlobType$11[ebp], 0

; 1564 : 
; 1565 :          // Get record to retrieve from.
; 1566 :          if ( lpViewAttrib->bPersist )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	je	SHORT $LN13@GetStructF

; 1567 :             pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
	jmp	SHORT $LN14@GetStructF
$LN13@GetStructF:

; 1568 :          else
; 1569 :             pchRecord = (zPCHAR) zGETPTR( lpEntityInstance->hNonPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecord$[ebp], eax
$LN14@GetStructF:

; 1570 : 
; 1571 :          // If pchRecord is null, then there are no attribute values.
; 1572 :          if ( pchRecord == 0 )

	cmp	DWORD PTR _pchRecord$[ebp], 0
	jne	SHORT $LN15@GetStructF

; 1573 :          {
; 1574 : #ifdef TRACE_STRUCT
; 1575 :             TraceLine( "   Attrib: %s   NULL", lpViewAttrib->szName );
; 1576 : #endif
; 1577 :             if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN17@GetStructF

; 1578 :                pchReturnStruct[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchReturnStruct$[ebp]
	mov	BYTE PTR [eax+edx], 0
	jmp	SHORT $LN18@GetStructF
$LN17@GetStructF:

; 1579 :             else
; 1580 :             {
; 1581 :                zUSHORT nIndex;
; 1582 :                for ( nIndex = 0; nIndex < lpViewAttrib->ulLth; nIndex++ )

	xor	ecx, ecx
	mov	WORD PTR _nIndex$10[ebp], cx
	jmp	SHORT $LN7@GetStructF
$LN5@GetStructF:
	mov	dx, WORD PTR _nIndex$10[ebp]
	add	dx, 1
	mov	WORD PTR _nIndex$10[ebp], dx
$LN7@GetStructF:
	movzx	eax, WORD PTR _nIndex$10[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	cmp	eax, DWORD PTR [ecx+203]
	jae	SHORT $LN18@GetStructF

; 1583 :                   pchReturnStruct[ nIndex ] = 0;

	movzx	edx, WORD PTR _nIndex$10[ebp]
	mov	eax, DWORD PTR _pchReturnStruct$[ebp]
	mov	BYTE PTR [eax+edx], 0
	jmp	SHORT $LN5@GetStructF
$LN18@GetStructF:

; 1584 :             }
; 1585 :          }

	jmp	$LN16@GetStructF
$LN15@GetStructF:

; 1586 :          else
; 1587 :          {
; 1588 :             switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	DWORD PTR tv142[ebp], edx
	mov	eax, DWORD PTR tv142[ebp]
	sub	eax, 66					; 00000042H
	mov	DWORD PTR tv142[ebp], eax
	cmp	DWORD PTR tv142[ebp], 17		; 00000011H
	ja	$LN16@GetStructF
	mov	ecx, DWORD PTR tv142[ebp]
	movzx	edx, BYTE PTR $LN34@GetStructF[ecx]
	jmp	DWORD PTR $LN35@GetStructF[edx*4]
$LN19@GetStructF:

; 1589 :             {
; 1590 :                case zTYPE_STRING:
; 1591 :                {
; 1592 :                   zPCHAR    pchRecordString;
; 1593 :                   zCOREMEM  lpExternalP;
; 1594 : 
; 1595 :                   pchRecordString = pchRecord + lpViewAttrib->ulRecordOffset;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _pchRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _pchRecordString$9[ebp], ecx

; 1596 :                   if ( pchRecordString[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRecordString$9[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN20@GetStructF

; 1597 :                   {
; 1598 :                      lpExternalP = (zCOREMEM) (pchRecordString + 1);

	mov	eax, DWORD PTR _pchRecordString$9[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$4[ebp], eax

; 1599 :                      pchRecordString = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$4[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchRecordString$9[ebp], eax
$LN20@GetStructF:

; 1600 :                   }
; 1601 : 
; 1602 :                   zstrcpy( pchReturnStruct, pchRecordString );

	mov	eax, DWORD PTR _pchRecordString$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnStruct$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1603 : #ifdef TRACE_STRUCT
; 1604 :                   TraceLine( "   Attrib: %s   %s", lpViewAttrib->szName, pchRecordString );
; 1605 : #endif
; 1606 :                }
; 1607 : 
; 1608 :                break;

	jmp	$LN16@GetStructF
$LN21@GetStructF:

; 1609 : 
; 1610 :                case zTYPE_INTEGER:
; 1611 :                {
; 1612 :                   zPLONG   lplLong;
; 1613 :                   zPLONG   lplLong2;
; 1614 : 
; 1615 :                   lplLong = (zPLONG) (pchRecord + lpViewAttrib->ulRecordOffset);

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lplLong$7[ebp], eax

; 1616 :                   lplLong2 = (zPLONG) pchReturnStruct;

	mov	ecx, DWORD PTR _pchReturnStruct$[ebp]
	mov	DWORD PTR _lplLong2$6[ebp], ecx

; 1617 :                   if ( *lplLong != lNullInteger )

	mov	edx, DWORD PTR _lplLong$7[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	je	SHORT $LN22@GetStructF

; 1618 :                      *lplLong2 = *lplLong;

	mov	ecx, DWORD PTR _lplLong2$6[ebp]
	mov	edx, DWORD PTR _lplLong$7[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN23@GetStructF
$LN22@GetStructF:

; 1619 :                   else
; 1620 :                      *lplLong2 = 0;

	mov	ecx, DWORD PTR _lplLong2$6[ebp]
	mov	DWORD PTR [ecx], 0
$LN23@GetStructF:

; 1621 : 
; 1622 : #ifdef TRACE_STRUCT
; 1623 :                   TraceLine( "   Attrib: %s   %d", lpViewAttrib->szName, *lplLong2 );
; 1624 : #endif
; 1625 :                }
; 1626 : 
; 1627 :                break;

	jmp	$LN16@GetStructF
$LN24@GetStructF:

; 1628 : 
; 1629 :                case zTYPE_DECIMAL:
; 1630 :                {
; 1631 :                   zPDECIMAL lpdDecimal;
; 1632 :                   zPDECIMAL lpdDecimal2;
; 1633 : 
; 1634 :                   lpdDecimal = (zPDECIMAL) (pchRecord +

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpdDecimal$8[ebp], eax

; 1635 :                                                    lpViewAttrib->ulRecordOffset);
; 1636 :                   lpdDecimal2 = (zPDECIMAL) pchReturnStruct;

	mov	ecx, DWORD PTR _pchReturnStruct$[ebp]
	mov	DWORD PTR _lpdDecimal2$3[ebp], ecx

; 1637 :                   if ( SysCompareDecimalToNull( lpdDecimal ) == 0 )

	mov	edx, DWORD PTR _lpdDecimal$8[ebp]
	push	edx
	call	_SysCompareDecimalToNull@4
	cwde
	test	eax, eax
	jne	SHORT $LN25@GetStructF

; 1638 :                   {
; 1639 :                      SysAssignDecimalFromDecimal( lpdDecimal2, lpdDecimal );

	mov	ecx, DWORD PTR _lpdDecimal$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpdDecimal2$3[ebp]
	push	edx
	call	_SysAssignDecimalFromDecimal@8

; 1640 :                   }

	jmp	SHORT $LN26@GetStructF
$LN25@GetStructF:

; 1641 :                   else
; 1642 :                   {
; 1643 :                      SysConvertLongToDecimal( 0, lpdDecimal );

	mov	eax, DWORD PTR _lpdDecimal$8[ebp]
	push	eax
	push	0
	call	_SysConvertLongToDecimal@8
$LN26@GetStructF:

; 1644 :                   }
; 1645 : 
; 1646 : #ifdef TRACE_STRUCT
; 1647 :                   TraceLine( "   Attrib: %s   DECIMAL", lpViewAttrib->szName );
; 1648 : #endif
; 1649 :                }
; 1650 : 
; 1651 :                break;

	jmp	SHORT $LN16@GetStructF
$LN27@GetStructF:

; 1652 : 
; 1653 :                case zTYPE_BLOB:
; 1654 :                {
; 1655 :                   zPCHAR   pchChar;
; 1656 :                   zCOREMEM lpBlob;
; 1657 :                   zCOREMEM lpReturnBlob;
; 1658 : 
; 1659 :                   pchChar = pchRecord + lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _pchChar$2[ebp], edx

; 1660 :                   lpBlob = (zCOREMEM) (pchRecord + lpViewAttrib->ulRecordOffset + 1);

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+250]
	mov	edx, DWORD PTR _pchRecord$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _lpBlob$1[ebp], eax

; 1661 :                   lpReturnBlob = (zCOREMEM) pchReturnStruct;

	mov	ecx, DWORD PTR _pchReturnStruct$[ebp]
	mov	DWORD PTR _lpReturnBlob$5[ebp], ecx

; 1662 : 
; 1663 :                   if ( *pchChar == '\xff' )

	mov	edx, DWORD PTR _pchChar$2[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, -1
	jne	SHORT $LN28@GetStructF

; 1664 :                      *lpReturnBlob = zGETPTR( *lpBlob );

	mov	ecx, DWORD PTR _lpBlob$1[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _lpReturnBlob$5[ebp]
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN29@GetStructF
$LN28@GetStructF:

; 1665 :                   else
; 1666 :                      *lpReturnBlob = 0;

	mov	edx, DWORD PTR _lpReturnBlob$5[ebp]
	mov	DWORD PTR [edx], 0
$LN29@GetStructF:

; 1667 : 
; 1668 :                   bBlobType = TRUE;

	mov	BYTE PTR _bBlobType$11[ebp], 1
$LN16@GetStructF:

; 1669 : 
; 1670 : #ifdef TRACE_STRUCT
; 1671 :                   TraceLine( "   Attrib: %s   BLOB", lpViewAttrib->szName );
; 1672 : #endif
; 1673 :                }
; 1674 : 
; 1675 :                break;
; 1676 : 
; 1677 :                case zTYPE_DATETIME:
; 1678 :                   // a work in progress...
; 1679 : #ifdef TRACE_STRUCT
; 1680 :                   TraceLine( "   Attrib: %s   DATETIME", lpViewAttrib->szName );
; 1681 : #endif
; 1682 :                   break;
; 1683 : 
; 1684 :             } // switch (...)...
; 1685 : 
; 1686 :          } // if ( pchRecord == 0 )...
; 1687 : 
; 1688 :          if ( bBlobType )

	movzx	eax, BYTE PTR _bBlobType$11[ebp]
	test	eax, eax
	je	SHORT $LN31@GetStructF

; 1689 :             pchReturnStruct += sizeof( zPVOID );

	mov	ecx, DWORD PTR _pchReturnStruct$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchReturnStruct$[ebp], ecx
	jmp	SHORT $LN32@GetStructF
$LN31@GetStructF:

; 1690 :          else
; 1691 :             pchReturnStruct += lpViewAttrib->ulLth;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _pchReturnStruct$[ebp]
	add	eax, DWORD PTR [edx+203]
	mov	DWORD PTR _pchReturnStruct$[ebp], eax
$LN32@GetStructF:

; 1692 : 
; 1693 :       } // for ( lpViewAttrib...)...

	jmp	$LN2@GetStructF
$LN12@GetStructF:

; 1694 :    }
; 1695 : 
; 1696 :    fnOperationReturn( iGetStructFromEntityAttrs, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	258					; 00000102H
	call	_fnOperationReturn
	add	esp, 8

; 1697 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetStructF:

; 1698 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN35@GetStructF:
	DD	$LN27@GetStructF
	DD	$LN21@GetStructF
	DD	$LN24@GetStructF
	DD	$LN19@GetStructF
	DD	$LN16@GetStructF
$LN34@GetStructF:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_GetStructFromEntityAttrs@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_ulTossOut$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pchReturnString$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_cpcContextName$ = 24					; size = 4
_ulLth$ = 28						; size = 4
_GetStringFromAttributeByContext@24 PROC

; 753  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 754  :    zULONG            ulTossOut;
; 755  :    zSHORT            nRC;
; 756  : 
; 757  :    // If a Context is passed to this routine, use it.
; 758  :    // If the Context is null or blank, issue the call with default context.
; 759  :    if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN4@GetStringF
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@GetStringF
$LN4@GetStringF:

; 760  :    {
; 761  :       nRC = GetVariableFromAttribute( pchReturnString,

	push	8
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	push	83					; 00000053H
	lea	eax, DWORD PTR _ulTossOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_GetVariableFromAttribute@36
	mov	WORD PTR _nRC$[ebp], ax

; 762  :                                       &ulTossOut,
; 763  :                                       zTYPE_STRING,
; 764  :                                       ulLth,
; 765  :                                       lpView,
; 766  :                                       cpcEntityName,
; 767  :                                       cpcAttributeName,
; 768  :                                       cpcContextName,
; 769  :                                       zUSE_DEFAULT_CONTEXT );
; 770  :    }

	jmp	SHORT $LN3@GetStringF
$LN2@GetStringF:

; 771  :    else
; 772  :    {
; 773  :       nRC = GetVariableFromAttribute( pchReturnString,

	push	0
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	push	83					; 00000053H
	lea	ecx, DWORD PTR _ulTossOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	call	_GetVariableFromAttribute@36
	mov	WORD PTR _nRC$[ebp], ax
$LN3@GetStringF:

; 774  :                                       &ulTossOut,
; 775  :                                       zTYPE_STRING,
; 776  :                                       ulLth,
; 777  :                                       lpView,
; 778  :                                       cpcEntityName,
; 779  :                                       cpcAttributeName,
; 780  :                                       cpcContextName,
; 781  :                                       0 );
; 782  :    }
; 783  : 
; 784  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 785  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_GetStringFromAttributeByContext@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_lpViewEntity$ = -24					; size = 4
_lpCurrentTask$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpAttribFlags$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_pchEntityName$ = 12					; size = 4
_pchAttribName$ = 16					; size = 4
_AttributeUpdated@12 PROC

; 463  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 464  :    LPTASK            lpCurrentTask;
; 465  :    LPVIEWENTITY      lpViewEntity;
; 466  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 467  :    LPVIEWATTRIB      lpViewAttrib;
; 468  :    LPATTRIBFLAGS     lpAttribFlags;
; 469  :    zSHORT            nRC;
; 470  : 
; 471  :    // Validate parameters.
; 472  :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _pchAttribName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	push	255					; 000000ffH
	lea	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 473  :                                         &lpViewEntity,
; 474  :                                         &lpViewEntityCsr,
; 475  :                                         &lpViewAttrib,
; 476  :                                         iAttributeUpdated,
; 477  :                                         0,   // We do not intend to update
; 478  :                                         lpView,
; 479  :                                         pchEntityName,
; 480  :                                         pchAttribName, 0 );
; 481  : 
; 482  :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN2@AttributeU

; 483  :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@AttributeU
$LN2@AttributeU:

; 484  : 
; 485  :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@AttributeU

; 486  :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@AttributeU
$LN3@AttributeU:

; 487  :    else
; 488  : // if ( nRC == 0 )
; 489  :    {
; 490  :       lpAttribFlags =

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$[ebp], eax

; 491  :             fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 492  :                                  lpViewAttrib );
; 493  : 
; 494  :       if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $LN4@AttributeU

; 495  :          nRC = lpAttribFlags->u.bFlags.bUpdated;

	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 1
	and	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN4@AttributeU:

; 496  :    }
; 497  : 
; 498  :    fnOperationReturn( iAttributeUpdated, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	255					; 000000ffH
	call	_fnOperationReturn
	add	esp, 8

; 499  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@AttributeU:

; 500  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_AttributeUpdated@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeataa.c
_TEXT	SEGMENT
_ulTossOut$ = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpCurrentTask$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_ulStringLth$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pchReturnString$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_cpcAttributeName$ = 20					; size = 4
_GetStringFromAttribute@16 PROC

; 814  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 815  :    LPTASK            lpCurrentTask;
; 816  :    LPVIEWENTITY      lpViewEntity;
; 817  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 818  :    LPVIEWATTRIB      lpViewAttrib;
; 819  :    zULONG            ulStringLth;
; 820  :    zULONG            ulTossOut;
; 821  :    zSHORT            nRC;
; 822  : 
; 823  :    *pchReturnString = 0;  // initialize return string to empty

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 824  : 
; 825  :    // Validate parameters.
; 826  :    nRC = fnValidateAttributeParameters( &lpCurrentTask,

	push	0
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	push	250					; 000000faH
	lea	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateAttributeParameters
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 827  :                                         &lpViewEntity,
; 828  :                                         &lpViewEntityCsr,
; 829  :                                         &lpViewAttrib,
; 830  :                                         iGetStringFromAttribute,
; 831  :                                         0,   // We do not intend to update
; 832  :                                         lpView,
; 833  :                                         cpcEntityName,
; 834  :                                         cpcAttributeName, 0 );
; 835  : 
; 836  :    if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN2@GetStringF

; 837  :       return( zCALL_ERROR );   // don't call fnOperationReturn

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetStringF
$LN2@GetStringF:

; 838  : 
; 839  :    if ( nRC == -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jne	SHORT $LN3@GetStringF

; 840  :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN4@GetStringF
$LN3@GetStringF:

; 841  :    else
; 842  :    if ( nRC != -2 )   // not a NULL entity.

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN4@GetStringF

; 843  :    {
; 844  :       fnGetAttributeLength( &ulStringLth, lpView,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulStringLth$[ebp]
	push	ecx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 845  :                             zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 846  :                             lpViewAttrib );
; 847  : 
; 848  :       nRC = fnGetVariableFromAttribute( (zPVOID) pchReturnString, &ulTossOut,

	mov	edx, DWORD PTR _ulStringLth$[ebp]
	add	edx, 1
	mov	DWORD PTR _ulStringLth$[ebp], edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulStringLth$[ebp]
	push	ecx
	push	83					; 00000053H
	lea	edx, DWORD PTR _ulTossOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax
$LN4@GetStringF:

; 849  :                                         zTYPE_STRING,
; 850  :                                         ++ulStringLth, lpView,
; 851  :                                         lpViewEntityCsr,
; 852  :                                         lpViewAttrib, 0, lpCurrentTask, 0 );
; 853  :    }
; 854  : 
; 855  :    fnOperationReturn( iGetStringFromAttribute, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	250					; 000000faH
	call	_fnOperationReturn
	add	esp, 8

; 856  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetStringF:

; 857  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetStringFromAttribute@16 ENDP
_TEXT	ENDS
END
