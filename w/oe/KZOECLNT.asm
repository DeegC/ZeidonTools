; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\w\oe\KZOECLNT.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_szClassName
PUBLIC	_g_bRunningTest
PUBLIC	_g_lTestCount
PUBLIC	_g_bContinueThreadTest
PUBLIC	_g_bTestThreadStarted
PUBLIC	_g_hTestThread
PUBLIC	_g_dwTestThreadID
PUBLIC	_bThreadRegistered
_DATA	SEGMENT
COMM	_hInst:DWORD
COMM	_hListWnd:DWORD
COMM	_hMainWnd:DWORD
COMM	_wClientMessage:WORD
COMM	_nNoUnregister:DWORD
COMM	_vSubtask:DWORD
_DATA	ENDS
_BSS	SEGMENT
_g_bRunningTest DB 01H DUP (?)
	ALIGN	4

_g_lTestCount DD 01H DUP (?)
_g_bContinueThreadTest DB 01H DUP (?)
	ALIGN	4

_g_bTestThreadStarted DB 01H DUP (?)
	ALIGN	4

_g_hTestThread DD 01H DUP (?)
_g_dwTestThreadID DD 01H DUP (?)
_BSS	ENDS
_TLS	SEGMENT
_bThreadRegistered DB 00H
_TLS	ENDS
_DATA	SEGMENT
_szClassName DB	'KZOECLNTClass', 00H
	ORG $+2
$SG93896 DB	'%d: %s', 00H
	ORG $+1
$SG93915 DB	'Starting thread test', 00H
	ORG $+3
$SG93918 DB	'\\Zencas\', 00H
	ORG $+2
$SG93919 DB	'Completed thread register', 00H
	ORG $+2
$SG93920 DB	'mUser', 00H
	ORG $+2
$SG93923 DB	'----- ERROR activating mUser --------- ', 00H
$SG93924 DB	'Thread test #%d, rc = %d', 00H
	ORG $+3
$SG93926 DB	'Completed thread UN(!)register', 00H
	ORG $+1
$SG93928 DB	'Completed thread UN(!)register', 00H
	ORG $+1
$SG93929 DB	'Completed thread test', 00H
	ORG $+2
$SG93961 DB	'Zencas', 00H
	ORG $+1
$SG93963 DB	'mMedCode', 00H
	ORG $+3
$SG93964 DB	'Done with test %ld', 00H
	ORG $+1
$SG93989 DB	'Close running test', 00H
	ORG $+1
$SG93990 DB	'Test In Progress', 00H
	ORG $+3
$SG93992 DB	'zWinSock', 00H
	ORG $+3
$SG93993 DB	'zWinSock', 00H
	ORG $+3
$SG93999 DB	'Where yourself', 00H
	ORG $+1
$SG94000 DB	'?', 00H
	ORG $+2
$SG94003 DB	'\\Zencas\', 00H
	ORG $+2
$SG94025 DB	'KZOECLNT', 00H
	ORG $+3
$SG94048 DB	'KZOECLNT', 00H
	ORG $+3
$SG94049 DB	'Test Client', 00H
$SG94051 DB	'Trace Window', 00H
	ORG $+3
$SG94052 DB	'ListBox', 00H
$SG94053 DB	'KZOECLNT', 00H
	ORG $+3
$SG94055 DB	'\\Zencas', 00H
	ORG $+3
$SG94056 DB	'laskjdflkasjdflkjasdlfkjasdlkfj', 00H
$SG94057 DB	'Done registering', 00H
_DATA	ENDS
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_InitInstance
PUBLIC	_InitApplication
PUBLIC	_MainWndProc@16
PUBLIC	_fnTrace
PUBLIC	_fnThreadProc2@4
PUBLIC	_TimerProc@16
EXTRN	_strcpy:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__HeapAlloc@12:PROC
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__LoadMenuA@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_ActivateObjectInstance@20:PROC
EXTRN	_DropView@4:PROC
EXTRN	_NetClose@8:PROC
EXTRN	_NetStatus@8:PROC
EXTRN	_RegisterZeidonApplication@28:PROC
EXTRN	_ProcessZeidonMessage@8:PROC
EXTRN	_UnregisterZeidonApplication@4:PROC
EXTRN	_SysAllocMemory@20:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysGetDateTime@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SfCreateSubtask@12:PROC
EXTRN	_SfDropSubtask@8:PROC
EXTRN	__beginthreadex:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoeclnt.c
_TEXT	SEGMENT
_vLocalSubtask$ = -148					; size = 4
tv87 = -144						; size = 4
_vView$ = -140						; size = 4
_szMsg$ = -136						; size = 100
_szDateTime$1 = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_idEvent$ = 16						; size = 4
_dwTime$ = 20						; size = 4
_TimerProc@16 PROC

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 217  :    zVIEW  vView;
; 218  :    zVIEW  vLocalSubtask;
; 219  :    zCHAR  szMsg[ 100 ];
; 220  : 
; 221  :    if ( g_lTestCount % 50 == 0 )

	mov	eax, DWORD PTR _g_lTestCount
	xor	edx, edx
	mov	ecx, 50					; 00000032H
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@TimerProc

; 222  :       SendMessage( hListWnd, LB_RESETCONTENT, 0, 0 );

	push	0
	push	0
	push	388					; 00000184H
	mov	edx, DWORD PTR _hListWnd
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
$LN2@TimerProc:

; 223  : 
; 224  :    SfCreateSubtask( &vLocalSubtask, vSubtask, "Zencas" );

	push	OFFSET $SG93961
	mov	eax, DWORD PTR _vSubtask
	push	eax
	lea	ecx, DWORD PTR _vLocalSubtask$[ebp]
	push	ecx
	call	_SfCreateSubtask@12

; 225  :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask, 0
	je	SHORT $LN3@TimerProc

; 226  :    {
; 227  :       zCHAR szDateTime[ 30 ];
; 228  : 
; 229  :       SysGetDateTime( szDateTime );

	lea	edx, DWORD PTR _szDateTime$1[ebp]
	push	edx
	call	_SysGetDateTime@4

; 230  :       TRACE( 0, szDateTime );

	lea	eax, DWORD PTR _szDateTime$1[ebp]
	push	eax
	push	0
	call	_fnTrace
	add	esp, 8

; 231  : 
; 232  :       ActivateObjectInstance( &vView, "mMedCode", vSubtask, 0, zSINGLE );

	push	0
	push	0
	mov	ecx, DWORD PTR _vSubtask
	push	ecx
	push	OFFSET $SG93963
	lea	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_ActivateObjectInstance@20

; 233  :       DropView( vView );

	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_DropView@4

; 234  :       SfDropSubtask( vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _vSubtask
	push	ecx
	call	_SfDropSubtask@8
$LN3@TimerProc:

; 235  :    }
; 236  : 
; 237  : 
; 238  :    zsprintf( szMsg, "Done with test %ld", g_lTestCount++ );

	mov	edx, DWORD PTR _g_lTestCount
	mov	DWORD PTR tv87[ebp], edx
	mov	eax, DWORD PTR _g_lTestCount
	add	eax, 1
	mov	DWORD PTR _g_lTestCount, eax
	mov	ecx, DWORD PTR tv87[ebp]
	push	ecx
	push	OFFSET $SG93964
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 239  :    TRACE( 0, szMsg );

	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	0
	call	_fnTrace
	add	esp, 8

; 240  : 
; 241  :    if ( !g_bRunningTest )

	movzx	ecx, BYTE PTR _g_bRunningTest
	test	ecx, ecx
	jne	SHORT $LN1@TimerProc

; 242  :       KillTimer( hWnd, idEvent );

	mov	edx, DWORD PTR _idEvent$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__KillTimer@8
$LN1@TimerProc:

; 243  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TimerProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoeclnt.c
_TEXT	SEGMENT
tv144 = -260						; size = 4
_vView$ = -256						; size = 4
_nCount$ = -252						; size = 4
_vSubtask$ = -248					; size = 4
_nRC$ = -244						; size = 2
_nThreadNumber$ = -240					; size = 2
_szMsg$ = -236						; size = 200
_szDateTime$1 = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_fnThreadProc2@4 PROC

; 91   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 92   :    zVIEW  vSubtask;
; 93   :    zLONG  nCount = 0;

	mov	DWORD PTR _nCount$[ebp], 0

; 94   :    zVIEW  vView;
; 95   :    char   szMsg[ 200 ];
; 96   :    zSHORT nRC;
; 97   :    zSHORT nThreadNumber = (zSHORT) p;

	mov	ax, WORD PTR _p$[ebp]
	mov	WORD PTR _nThreadNumber$[ebp], ax

; 98   : 
; 99   :    TRACE( nThreadNumber, "Starting thread test" );

	push	OFFSET $SG93915
	movzx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	call	_fnTrace
	add	esp, 8
$LN2@fnThreadPr:

; 100  : 
; 101  :    while ( g_bContinueThreadTest )

	movzx	edx, BYTE PTR _g_bContinueThreadTest
	test	edx, edx
	je	$LN3@fnThreadPr

; 102  :    {
; 103  :       zCHAR szDateTime[ 30 ];
; 104  : 
; 105  :       if ( !bThreadRegistered )

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	movzx	eax, BYTE PTR _bThreadRegistered[edx]
	test	eax, eax
	jne	SHORT $LN4@fnThreadPr

; 106  :       {
; 107  :          if ( RegisterZeidonApplication( &vSubtask,
; 108  :                                          (zLONG) hInst,
; 109  :                                          (zLONG) hMainWnd,
; 110  :                                          (zLONG) wClientMessage,
; 111  :                                          "\\\\Zencas\\", 0, 0 ) == zCALL_ERROR )

	push	0
	push	0
	push	OFFSET $SG93918
	movzx	ecx, WORD PTR _wClientMessage
	push	ecx
	mov	edx, DWORD PTR _hMainWnd
	push	edx
	mov	eax, DWORD PTR _hInst
	push	eax
	lea	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_RegisterZeidonApplication@28
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN5@fnThreadPr

; 112  :          {
; 113  :             g_dwTestThreadID = 0;

	mov	DWORD PTR _g_dwTestThreadID, 0

; 114  :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnThreadPr
$LN5@fnThreadPr:

; 115  :          }
; 116  : 
; 117  :          bThreadRegistered = TRUE;

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	BYTE PTR _bThreadRegistered[edx], 1

; 118  :          TRACE( nThreadNumber, "Completed thread register" );

	push	OFFSET $SG93919
	movzx	eax, WORD PTR _nThreadNumber$[ebp]
	push	eax
	call	_fnTrace
	add	esp, 8
$LN4@fnThreadPr:

; 119  :       }
; 120  : 
; 121  :    // if ( nThreadNumber == 2 )
; 122  :    //    Sleep( 500 );
; 123  :       Sleep( 100 * ((nThreadNumber % 5) + 1) );

	movsx	eax, WORD PTR _nThreadNumber$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	add	edx, 1
	imul	edx, edx, 100
	push	edx
	call	DWORD PTR __imp__Sleep@4

; 124  : 
; 125  :    // SysMutexLock( "KZOECLNT/1", 0, 0 );
; 126  :    // TRACE( nThreadNumber, "Mutex locked" );
; 127  : 
; 128  :       SysGetDateTime( szDateTime );

	lea	eax, DWORD PTR _szDateTime$1[ebp]
	push	eax
	call	_SysGetDateTime@4

; 129  :       TRACE( nThreadNumber, szDateTime );

	lea	ecx, DWORD PTR _szDateTime$1[ebp]
	push	ecx
	movzx	edx, WORD PTR _nThreadNumber$[ebp]
	push	edx
	call	_fnTrace
	add	esp, 8

; 130  : 
; 131  :       nRC = ActivateObjectInstance( &vView, "mUser", vSubtask, 0, zSINGLE );

	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG93920
	lea	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _nRC$[ebp], ax

; 132  :       if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN6@fnThreadPr

; 133  :          DropView( vView );

	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_DropView@4
	jmp	SHORT $LN7@fnThreadPr
$LN6@fnThreadPr:

; 134  :       else
; 135  :          TRACE( nThreadNumber, "----- ERROR activating mUser --------- " );

	push	OFFSET $SG93923
	movzx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	call	_fnTrace
	add	esp, 8
$LN7@fnThreadPr:

; 136  : 
; 137  :       zsprintf( szMsg, "Thread test #%d, rc = %d", nCount++, nRC );

	mov	edx, DWORD PTR _nCount$[ebp]
	mov	DWORD PTR tv144[ebp], edx
	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv144[ebp]
	push	ecx
	push	OFFSET $SG93924
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _nCount$[ebp], eax

; 138  :       TRACE( nThreadNumber, szMsg );

	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nThreadNumber$[ebp]
	push	edx
	call	_fnTrace
	add	esp, 8

; 139  : 
; 140  :    // SysMutexUnlock( "KZOECLNT/1" );
; 141  :    // TRACE( nThreadNumber, "Mutex unlocked" );
; 142  : 
; 143  :       // Unregister every third time or so.
; 144  :       if ( nCount % 3 == 0 )

	mov	eax, DWORD PTR _nCount$[ebp]
	cdq
	mov	ecx, 3
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN8@fnThreadPr

; 145  :       {
; 146  :          UnregisterZeidonApplication( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_UnregisterZeidonApplication@4

; 147  :          vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 148  :          bThreadRegistered = FALSE;

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	BYTE PTR _bThreadRegistered[edx], 0

; 149  :          TRACE( nThreadNumber, "Completed thread UN(!)register" );

	push	OFFSET $SG93926
	movzx	eax, WORD PTR _nThreadNumber$[ebp]
	push	eax
	call	_fnTrace
	add	esp, 8
$LN8@fnThreadPr:

; 150  :       }
; 151  :    }

	jmp	$LN2@fnThreadPr
$LN3@fnThreadPr:

; 152  : 
; 153  :    if ( bThreadRegistered )

	mov	ecx, DWORD PTR __tls_index
	mov	edx, DWORD PTR fs:__tls_array
	mov	eax, DWORD PTR [edx+ecx*4]
	movzx	ecx, BYTE PTR _bThreadRegistered[eax]
	test	ecx, ecx
	je	SHORT $LN9@fnThreadPr

; 154  :    {
; 155  :       UnregisterZeidonApplication( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_UnregisterZeidonApplication@4

; 156  :       vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 157  :       bThreadRegistered = FALSE;

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	BYTE PTR _bThreadRegistered[edx], 0

; 158  :       TRACE( nThreadNumber, "Completed thread UN(!)register" );

	push	OFFSET $SG93928
	movzx	eax, WORD PTR _nThreadNumber$[ebp]
	push	eax
	call	_fnTrace
	add	esp, 8
$LN9@fnThreadPr:

; 159  :    }
; 160  : 
; 161  :    g_dwTestThreadID = 0;

	mov	DWORD PTR _g_dwTestThreadID, 0

; 162  :    TRACE( nThreadNumber, "Completed thread test" );

	push	OFFSET $SG93929
	movzx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	call	_fnTrace
	add	esp, 8

; 163  : 
; 164  :    return( 0 );

	xor	eax, eax
$LN1@fnThreadPr:

; 165  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnThreadProc2@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoeclnt.c
_TEXT	SEGMENT
_wItemCount$ = -2008					; size = 2
_szMsg$ = -2004						; size = 2000
__$ArrayPad$ = -4					; size = 4
_nThreadNumber$ = 8					; size = 2
_pchMsg$ = 12						; size = 4
_fnTrace PROC

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2008				; 000007d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 75   :    WORD wItemCount;
; 76   :    char szMsg[ 2000 ];
; 77   : 
; 78   :    zsprintf( szMsg, "%d: %s", nThreadNumber, pchMsg );

	mov	eax, DWORD PTR _pchMsg$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	push	OFFSET $SG93896
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 79   :    wItemCount = (WORD) SendMessage( hListWnd, LB_ADDSTRING, 0, (zLONG) szMsg );

	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	0
	push	384					; 00000180H
	mov	ecx, DWORD PTR _hListWnd
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wItemCount$[ebp], ax

; 80   :    if ( wItemCount > 4000 )

	movzx	edx, WORD PTR _wItemCount$[ebp]
	cmp	edx, 4000				; 00000fa0H
	jle	SHORT $LN2@fnTrace

; 81   :    {
; 82   :       SendMessage( hListWnd, LB_RESETCONTENT, 0, 0 );

	push	0
	push	0
	push	388					; 00000184H
	mov	eax, DWORD PTR _hListWnd
	push	eax
	call	DWORD PTR __imp__SendMessageA@16

; 83   :       wItemCount = 0;

	xor	ecx, ecx
	mov	WORD PTR _wItemCount$[ebp], cx
$LN2@fnTrace:

; 84   :    }
; 85   : 
; 86   :    SendMessage( hListWnd, LB_SETCURSEL, wItemCount, 0L );

	push	0
	movzx	edx, WORD PTR _wItemCount$[ebp]
	push	edx
	push	390					; 00000186H
	mov	eax, DWORD PTR _hListWnd
	push	eax
	call	DWORD PTR __imp__SendMessageA@16

; 87   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoeclnt.c
_TEXT	SEGMENT
_k$1 = -8						; size = 4
tv64 = -4						; size = 4
_hWnd$ = 8						; size = 4
_message$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainWndProc@16 PROC

; 261  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 262  :    switch ( message )

	mov	eax, DWORD PTR _message$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	ja	SHORT $LN32@MainWndPro
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	je	$LN27@MainWndPro
	cmp	DWORD PTR tv64[ebp], 2
	je	$LN11@MainWndPro
	cmp	DWORD PTR tv64[ebp], 16			; 00000010H
	je	SHORT $LN7@MainWndPro
	jmp	$LN29@MainWndPro
$LN32@MainWndPro:
	cmp	DWORD PTR tv64[ebp], 260		; 00000104H
	je	$LN27@MainWndPro
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	$LN12@MainWndPro
	jmp	$LN29@MainWndPro
$LN7@MainWndPro:

; 263  :    {
; 264  :       case WM_CLOSE:
; 265  :          // Check to see if the network is up.
; 266  :          if ( g_bRunningTest )

	movzx	ecx, BYTE PTR _g_bRunningTest
	test	ecx, ecx
	je	SHORT $LN8@MainWndPro

; 267  :          {
; 268  :             SysMessageBox( 0, "Test In Progress", "Close running test", -1 );

	push	-1
	push	OFFSET $SG93989
	push	OFFSET $SG93990
	push	0
	call	_SysMessageBox@16

; 269  :             return( 0 );

	xor	eax, eax
	jmp	$LN1@MainWndPro
$LN8@MainWndPro:

; 270  :          }
; 271  : 
; 272  :          if ( vSubtask && NetStatus( vSubtask, "zWinSock" ) != 0 )

	cmp	DWORD PTR _vSubtask, 0
	je	SHORT $LN9@MainWndPro
	push	OFFSET $SG93992
	mov	edx, DWORD PTR _vSubtask
	push	edx
	call	_NetStatus@8
	cwde
	test	eax, eax
	je	SHORT $LN9@MainWndPro

; 273  :             NetClose( vSubtask, "zWinSock" );

	push	OFFSET $SG93993
	mov	ecx, DWORD PTR _vSubtask
	push	ecx
	call	_NetClose@8
$LN9@MainWndPro:

; 274  : 
; 275  :          // It's OK to leave, Shutdown Object Services
; 276  :          if ( nNoUnregister != 99 && vSubtask )

	cmp	DWORD PTR _nNoUnregister, 99		; 00000063H
	je	SHORT $LN10@MainWndPro
	cmp	DWORD PTR _vSubtask, 0
	je	SHORT $LN10@MainWndPro

; 277  :             UnregisterZeidonApplication( vSubtask );

	mov	edx, DWORD PTR _vSubtask
	push	edx
	call	_UnregisterZeidonApplication@4
$LN10@MainWndPro:

; 278  : 
; 279  :          return( DefWindowProc( hWnd, message, wParam, lParam ));

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
	jmp	$LN1@MainWndPro
$LN11@MainWndPro:

; 280  : 
; 281  : 
; 282  :       case WM_DESTROY:        // message: window being destroyed
; 283  :          PostQuitMessage( 0 );

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 284  :          break;

	jmp	$LN2@MainWndPro
$LN12@MainWndPro:

; 285  : 
; 286  :       case WM_COMMAND:
; 287  :          if ( wParam == 110 )

	cmp	DWORD PTR _wParam$[ebp], 110		; 0000006eH
	jne	SHORT $LN13@MainWndPro

; 288  :          {
; 289  :             SysMessageBox( 0, "?", "Where yourself", -1 );

	push	-1
	push	OFFSET $SG93999
	push	OFFSET $SG94000
	push	0
	call	_SysMessageBox@16

; 290  :          }

	jmp	$LN14@MainWndPro
$LN13@MainWndPro:

; 291  :          else
; 292  :          if ( wParam == 111 )

	cmp	DWORD PTR _wParam$[ebp], 111		; 0000006fH
	jne	SHORT $LN15@MainWndPro

; 293  :          {
; 294  :             RegisterZeidonApplication( &vSubtask,

	push	0
	push	0
	push	OFFSET $SG94003
	movzx	ecx, WORD PTR _wClientMessage
	push	ecx
	mov	edx, DWORD PTR _hMainWnd
	push	edx
	mov	eax, DWORD PTR _hInst
	push	eax
	push	OFFSET _vSubtask
	call	_RegisterZeidonApplication@28

; 295  :                                        (zLONG) hInst,
; 296  :                                        (zLONG) hMainWnd,
; 297  :                                        (zLONG) wClientMessage,
; 298  :                                        "\\\\Zencas\\", 0, 0 );
; 299  :          }

	jmp	$LN14@MainWndPro
$LN15@MainWndPro:

; 300  :          else
; 301  :          if ( wParam == 112 )

	cmp	DWORD PTR _wParam$[ebp], 112		; 00000070H
	jne	SHORT $LN17@MainWndPro

; 302  :          {
; 303  :             UnregisterZeidonApplication( vSubtask );

	mov	ecx, DWORD PTR _vSubtask
	push	ecx
	call	_UnregisterZeidonApplication@4

; 304  :             vSubtask = 0;

	mov	DWORD PTR _vSubtask, 0

; 305  :          }

	jmp	$LN14@MainWndPro
$LN17@MainWndPro:

; 306  :          else
; 307  :          if ( wParam == 113 )

	cmp	DWORD PTR _wParam$[ebp], 113		; 00000071H
	jne	SHORT $LN19@MainWndPro

; 308  :          {
; 309  :             nNoUnregister = 99;

	mov	DWORD PTR _nNoUnregister, 99		; 00000063H

; 310  :             PostMessage( hWnd, WM_CLOSE, 0, 0L );

	push	0
	push	0
	push	16					; 00000010H
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__PostMessageA@16

; 311  :          }

	jmp	$LN14@MainWndPro
$LN19@MainWndPro:

; 312  :          else
; 313  :          if ( wParam == 114 )

	cmp	DWORD PTR _wParam$[ebp], 114		; 00000072H
	jne	SHORT $LN21@MainWndPro

; 314  :          {
; 315  :             PostMessage( hWnd, WM_CLOSE, 0, 0L );

	push	0
	push	0
	push	16					; 00000010H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__PostMessageA@16

; 316  :          }

	jmp	$LN14@MainWndPro
$LN21@MainWndPro:

; 317  :          else
; 318  :          if ( wParam == 115 )  // ID_TEST

	cmp	DWORD PTR _wParam$[ebp], 115		; 00000073H
	jne	SHORT $LN14@MainWndPro

; 319  :          {
; 320  :             if ( g_bRunningTest )

	movzx	ecx, BYTE PTR _g_bRunningTest
	test	ecx, ecx
	je	SHORT $LN24@MainWndPro

; 321  :             {
; 322  :                g_bRunningTest = FALSE;

	mov	BYTE PTR _g_bRunningTest, 0

; 323  :                g_bContinueThreadTest = FALSE;

	mov	BYTE PTR _g_bContinueThreadTest, 0

; 324  :             }

	jmp	SHORT $LN14@MainWndPro
$LN24@MainWndPro:

; 325  :             else
; 326  :             {
; 327  :                int k;
; 328  : 
; 329  :                g_bRunningTest = TRUE;

	mov	BYTE PTR _g_bRunningTest, 1

; 330  :             // SetTimer( hWnd, 0, 100, (TIMERPROC) TimerProc );
; 331  : 
; 332  :                g_bContinueThreadTest = TRUE;

	mov	BYTE PTR _g_bContinueThreadTest, 1

; 333  : 
; 334  :                for ( k = 1; k <= NUM_THREADS; k++ )

	mov	DWORD PTR _k$1[ebp], 1
	jmp	SHORT $LN6@MainWndPro
$LN4@MainWndPro:
	mov	edx, DWORD PTR _k$1[ebp]
	add	edx, 1
	mov	DWORD PTR _k$1[ebp], edx
$LN6@MainWndPro:
	cmp	DWORD PTR _k$1[ebp], 1
	jg	SHORT $LN14@MainWndPro

; 335  :                {
; 336  :                   g_hTestThread = _beginthreadex( NULL, 0, fnThreadProc2,

	push	OFFSET _g_dwTestThreadID
	push	0
	mov	eax, DWORD PTR _k$1[ebp]
	push	eax
	push	OFFSET _fnThreadProc2@4
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _g_hTestThread, eax

; 337  :                                                   (void *) k, 0, &g_dwTestThreadID );
; 338  :                   if ( g_hTestThread )

	cmp	DWORD PTR _g_hTestThread, 0
	je	SHORT $LN26@MainWndPro

; 339  :                      CloseHandle( (HANDLE) g_hTestThread );

	mov	ecx, DWORD PTR _g_hTestThread
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
$LN26@MainWndPro:

; 340  :                }

	jmp	SHORT $LN4@MainWndPro
$LN14@MainWndPro:

; 341  :             }
; 342  :          }
; 343  : 
; 344  :          break;

	jmp	SHORT $LN2@MainWndPro
$LN27@MainWndPro:

; 345  : 
; 346  :       case WM_KEYDOWN:
; 347  :       case WM_SYSKEYDOWN:
; 348  :          if ( wParam == VK_F3 )

	cmp	DWORD PTR _wParam$[ebp], 114		; 00000072H
	jne	SHORT $LN28@MainWndPro

; 349  :             PostMessage( hWnd, WM_CLOSE, 0, 0L );

	push	0
	push	0
	push	16					; 00000010H
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__PostMessageA@16
$LN28@MainWndPro:

; 350  : 
; 351  :          break;

	jmp	SHORT $LN2@MainWndPro
$LN29@MainWndPro:

; 352  : 
; 353  :     default:
; 354  :       if ( message == wClientMessage )

	movzx	eax, WORD PTR _wClientMessage
	cmp	DWORD PTR _message$[ebp], eax
	jne	SHORT $LN2@MainWndPro

; 355  :          ProcessZeidonMessage( wParam, lParam );

	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	call	_ProcessZeidonMessage@8
$LN2@MainWndPro:

; 356  : 
; 357  :       break;
; 358  :    }
; 359  : 
; 360  :    return( DefWindowProc( hWnd, message, wParam, lParam ));

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _message$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
$LN1@MainWndPro:

; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MainWndProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoeclnt.c
_TEXT	SEGMENT
_wc$ = -40						; size = 40
_hInstance$ = 8						; size = 4
_InitApplication PROC

; 372  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 373  :    WNDCLASS  wc;
; 374  : 
; 375  :    // Fill in window class structure with parameters that describe the
; 376  :    // main window.
; 377  : 
; 378  :    wc.style = 0;                       // Class style(s).

	mov	DWORD PTR _wc$[ebp], 0

; 379  :    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for

	mov	DWORD PTR _wc$[ebp+4], OFFSET _MainWndProc@16

; 380  :                                        // windows of this class.
; 381  :    wc.cbClsExtra = 0;                  // No per-class extra data.

	mov	DWORD PTR _wc$[ebp+8], 0

; 382  :    wc.cbWndExtra = 0;                  // No per-window extra data.

	mov	DWORD PTR _wc$[ebp+12], 0

; 383  :    wc.hInstance = hInstance;           // Application that owns the class.

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wc$[ebp+16], eax

; 384  :    wc.hIcon = LoadIcon( hInstance, "KZOECLNT" );

	push	OFFSET $SG94025
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wc$[ebp+20], eax

; 385  :    wc.hCursor = LoadCursor( 0, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 386  :    wc.hbrBackground = GetStockObject( WHITE_BRUSH );

	push	0
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 387  :    wc.lpszMenuName =  0;               // Name of menu resource in .RC file.

	mov	DWORD PTR _wc$[ebp+32], 0

; 388  :    wc.lpszClassName = szClassName;     // Name used in call to CreateWindow.

	mov	DWORD PTR _wc$[ebp+36], OFFSET _szClassName

; 389  : 
; 390  :    // Register the window class and return success/failure code.
; 391  :    return( RegisterClass( &wc ) );

	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	eax, ax

; 392  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InitApplication ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoeclnt.c
_TEXT	SEGMENT
_h$1 = -60						; size = 4
_psz$2 = -56						; size = 4
_pv2$3 = -52						; size = 4
_pv$4 = -48						; size = 4
_dw$5 = -44						; size = 4
_nPosX$ = -40						; size = 4
_nPosY$ = -36						; size = 4
_ph$6 = -32						; size = 4
_nWidth$ = -28						; size = 4
_nHeight$ = -24						; size = 4
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
_lpCmdLine$ = 16					; size = 4
_InitInstance PROC

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 415  :    int            nHeight, nPosY;
; 416  :    int            nWidth, nPosX;
; 417  :    RECT           rect;
; 418  : 
; 419  :    // Save the instance handle in static variable, which will be used in
; 420  :    // many subsequence calls from this application to Windows.
; 421  : 
; 422  :    hInst = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hInst, eax

; 423  : 
; 424  :    // Get the dimensions of the screen
; 425  :    nWidth = GetSystemMetrics( SM_CXSCREEN );

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nWidth$[ebp], eax

; 426  :    nHeight = GetSystemMetrics( SM_CYSCREEN );

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nHeight$[ebp], eax

; 427  :    nWidth /= 2;

	mov	eax, DWORD PTR _nWidth$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nWidth$[ebp], eax

; 428  :    nHeight /= 2;

	mov	eax, DWORD PTR _nHeight$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nHeight$[ebp], eax

; 429  :    nWidth -= 40;

	mov	ecx, DWORD PTR _nWidth$[ebp]
	sub	ecx, 40					; 00000028H
	mov	DWORD PTR _nWidth$[ebp], ecx

; 430  :    nHeight -= 20;

	mov	edx, DWORD PTR _nHeight$[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR _nHeight$[ebp], edx

; 431  :    nPosX = nWidth / 2;

	mov	eax, DWORD PTR _nWidth$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosX$[ebp], eax

; 432  :    nPosY = nHeight / 2;

	mov	eax, DWORD PTR _nHeight$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosY$[ebp], eax

; 433  :    nPosX -= 8; // So it doesn't occupy same space as object services

	mov	eax, DWORD PTR _nPosX$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nPosX$[ebp], eax

; 434  :    nPosY -= 8;

	mov	ecx, DWORD PTR _nPosY$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _nPosY$[ebp], ecx

; 435  : 
; 436  :    // Create a main window for this application instance.
; 437  :    hMainWnd = CreateWindow( szClassName,                    // See RegisterClass( ) call.

	push	0
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	push	OFFSET $SG94048
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadMenuA@8
	push	eax
	push	0
	mov	ecx, DWORD PTR _nHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _nPosY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nPosX$[ebp]
	push	ecx
	push	13565952				; 00cf0000H
	push	OFFSET $SG94049
	push	OFFSET _szClassName
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _hMainWnd, eax

; 438  :                             "Test Client",                  // Text for window title bar.
; 439  :                             WS_OVERLAPPEDWINDOW,            // Window style.
; 440  :                             nPosX,                          // Default horizontal position.
; 441  :                             nPosY,                          // Default vertical position.
; 442  :                             nWidth,                         // Default width.
; 443  :                             nHeight,                        // Default height.
; 444  :                             0,                              // Overlapped windows have no parent.
; 445  :                             LoadMenu( hInstance, "KZOECLNT" ), // Menu for trace window
; 446  :                          // 0,                              // Use default menu
; 447  :                             hInstance,                      // This instance owns this window.
; 448  :                             0 );                            // Pointer not needed.
; 449  : 
; 450  :    // If window could not be created, return "failure"
; 451  : 
; 452  :    if ( !hMainWnd )

	cmp	DWORD PTR _hMainWnd, 0
	jne	SHORT $LN2@InitInstan

; 453  :       return( FALSE );

	xor	eax, eax
	jmp	$LN1@InitInstan
$LN2@InitInstan:

; 454  : 
; 455  :    GetClientRect( hMainWnd, &rect );

	lea	edx, DWORD PTR _rect$[ebp]
	push	edx
	mov	eax, DWORD PTR _hMainWnd
	push	eax
	call	DWORD PTR __imp__GetClientRect@8

; 456  :    hListWnd = CreateWindow( "ListBox",                      // See RegisterClass( ) call.

	push	0
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _hMainWnd
	push	edx
	mov	eax, DWORD PTR _rect$[ebp+12]
	sub	eax, DWORD PTR _rect$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _rect$[ebp+8]
	sub	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rect$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _rect$[ebp]
	push	eax
	push	1358168064				; 50f40000H
	push	OFFSET $SG94051
	push	OFFSET $SG94052
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _hListWnd, eax

; 457  :                             "Trace Window",                 // Text for window title bar.
; 458  :                             WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_HSCROLL |
; 459  :                             WS_THICKFRAME | WS_CAPTION,
; 460  :                             rect.left,                      // Default horizontal position.
; 461  :                             rect.top,                       // Default vertical position.
; 462  :                             (rect.right - rect.left),       // Default width.
; 463  :                             (rect.bottom - rect.top),       // Default height.
; 464  :                             hMainWnd,                       // Parent Window
; 465  :                             0,                              // Use the window class menu.
; 466  :                             hInstance,                      // This instance owns this window.
; 467  :                             0 );                            // Pointer not needed.
; 468  : 
; 469  :    SendMessage( hListWnd, WM_SETFONT,

	push	0
	push	16					; 00000010H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	ecx, DWORD PTR _hListWnd
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 470  :                 (WPARAM) GetStockObject( SYSTEM_FIXED_FONT ), 0 );
; 471  : 
; 472  :    wClientMessage = RegisterWindowMessage( "KZOECLNT" );

	push	OFFSET $SG94053
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	WORD PTR _wClientMessage, ax

; 473  : 
; 474  :    if ( RegisterZeidonApplication( &vSubtask, (zLONG) hInst,
; 475  :                                    (zLONG) hMainWnd,
; 476  :                                    (zLONG) wClientMessage,
; 477  :                                    "\\\\Zencas", 0, 0 ) != 0 )

	push	0
	push	0
	push	OFFSET $SG94055
	movzx	edx, WORD PTR _wClientMessage
	push	edx
	mov	eax, DWORD PTR _hMainWnd
	push	eax
	mov	ecx, DWORD PTR _hInst
	push	ecx
	push	OFFSET _vSubtask
	call	_RegisterZeidonApplication@28
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@InitInstan

; 478  :                                    //lpCmdLine, 0, 0 ) != 0 )
; 479  :    {
; 480  :       DestroyWindow( hMainWnd );

	mov	eax, DWORD PTR _hMainWnd
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4

; 481  :       return( FALSE );

	xor	eax, eax
	jmp	$LN1@InitInstan
$LN3@InitInstan:

; 482  :    }
; 483  : 
; 484  :    ShowWindow( hMainWnd, SW_SHOW );  // Show the window

	push	5
	mov	ecx, DWORD PTR _hMainWnd
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 485  :    {
; 486  :       zPCHAR psz;
; 487  :       zLONG  h = SysAllocMemory( &psz, 100, 0, zCOREMEM_ALLOC, 0 );

	push	0
	push	32768					; 00008000H
	push	0
	push	100					; 00000064H
	lea	edx, DWORD PTR _psz$2[ebp]
	push	edx
	call	_SysAllocMemory@20
	mov	DWORD PTR _h$1[ebp], eax

; 488  :       HANDLE ph = GetProcessHeap( );

	call	DWORD PTR __imp__GetProcessHeap@0
	mov	DWORD PTR _ph$6[ebp], eax

; 489  :       LPVOID pv;
; 490  :       LPVOID pv2;
; 491  :       DWORD  dw;
; 492  : 
; 493  :       pv = HeapAlloc( ph, 0, 100 );

	push	100					; 00000064H
	push	0
	mov	eax, DWORD PTR _ph$6[ebp]
	push	eax
	call	DWORD PTR __imp__HeapAlloc@12
	mov	DWORD PTR _pv$4[ebp], eax

; 494  :       dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$5[ebp], eax

; 495  :       pv2 = HeapAlloc( ph, 0, 100 );

	push	100					; 00000064H
	push	0
	mov	ecx, DWORD PTR _ph$6[ebp]
	push	ecx
	call	DWORD PTR __imp__HeapAlloc@12
	mov	DWORD PTR _pv2$3[ebp], eax

; 496  :       dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$5[ebp], eax

; 497  : 
; 498  :       HeapFree( ph, 0, pv );

	mov	edx, DWORD PTR _pv$4[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _ph$6[ebp]
	push	eax
	call	DWORD PTR __imp__HeapFree@12

; 499  :       dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$5[ebp], eax

; 500  :       HeapFree( ph, 0, pv2 );

	mov	ecx, DWORD PTR _pv2$3[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _ph$6[ebp]
	push	edx
	call	DWORD PTR __imp__HeapFree@12

; 501  :       dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$5[ebp], eax

; 502  : 
; 503  :       zstrcpy( psz, "laskjdflkasjdflkjasdlfkjasdlkfj" );

	push	OFFSET $SG94056
	mov	eax, DWORD PTR _psz$2[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 504  :       SysFreeMemory( h );

	mov	ecx, DWORD PTR _h$1[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 505  :    }
; 506  : 
; 507  :    TRACE( 0, "Done registering" );

	push	OFFSET $SG94057
	push	0
	call	_fnTrace
	add	esp, 8

; 508  : 
; 509  :    // Make the window visible; update its client area; and return "success"
; 510  :    return( hMainWnd );            // Returns the value from PostQuitMessage

	mov	eax, DWORD PTR _hMainWnd
$LN1@InitInstan:

; 511  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_InitInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	___stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoeclnt.c
_TEXT	SEGMENT
_msg$ = -32						; size = 28
_hWnd$ = -4						; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC

; 182  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 183  :    MSG msg;                       // message
; 184  :    HWND hWnd;                     // Main window handle
; 185  : 
; 186  :    if (!hPrevInstance)                  // Other instances of app running?

	cmp	DWORD PTR _hPrevInstance$[ebp], 0
	jne	SHORT $LN4@WinMain

; 187  :    {
; 188  :       if (!InitApplication( hInstance )) // Initialize shared things

	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	_InitApplication
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@WinMain

; 189  :          return( FALSE );               // Exits if unable to initialize

	xor	eax, eax
	jmp	SHORT $LN1@WinMain
$LN4@WinMain:

; 190  :    }
; 191  : 
; 192  :    // Perform initializations that apply to a specific instance
; 193  : 
; 194  :    if ( !(hWnd = InitInstance( hInstance, nCmdShow, lpCmdLine )) )

	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nCmdShow$[ebp]
	push	edx
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	_InitInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hWnd$[ebp], eax
	cmp	DWORD PTR _hWnd$[ebp], 0
	jne	SHORT $LN6@WinMain

; 195  :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@WinMain
$LN6@WinMain:

; 196  : 
; 197  :    // Set nNoUnregister to 0
; 198  :    nNoUnregister = 0;

	mov	DWORD PTR _nNoUnregister, 0
$LN2@WinMain:

; 199  : 
; 200  :    // Acquire and dispatch messages until a WM_QUIT message is received.
; 201  : 
; 202  :    while ( GetMessage( &msg,    // message structure

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetMessageA@16
	test	eax, eax
	je	SHORT $LN3@WinMain

; 203  :                        0,       // handle of window receiving the message
; 204  :                        0,       // lowest message to examine
; 205  :                        0 ) )    // highest message to examine
; 206  :    {
; 207  :       TranslateMessage( &msg ); // Translate message

	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__TranslateMessage@4

; 208  :       DispatchMessage( &msg );  // Dispatches message to window

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4

; 209  :    }

	jmp	SHORT $LN2@WinMain
$LN3@WinMain:

; 210  : 
; 211  :    return( msg.wParam );        // Returns the value from PostQuitMessage

	mov	eax, DWORD PTR _msg$[ebp+8]
$LN1@WinMain:

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
