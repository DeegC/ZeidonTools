; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOECMAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG15510 DB	'(cm) ERROR Unexpected Recursive call to fnEstablishCurso'
	DB	'rForView', 00H
	ORG $+3
$SG15511 DB	'Internal Error', 00H
	ORG $+1
$SG13615 DB	'(S->DT), ', 00H
	ORG $+2
$SG13618 DB	'Failure during standard call, but would have been succes'
	DB	'sful if the default context was used.', 0aH, 'Probable User E'
	DB	'rror.', 00H
	ORG $+1
$SG13619 DB	0aH, 'Object Def: ', 00H
	ORG $+2
$SG13620 DB	0aH, 'Entity: ', 00H
	ORG $+2
$SG13621 DB	0aH, 'Attribute: ', 00H
	ORG $+3
$SG13622 DB	'SetCursorFirstEntityByString', 00H
	ORG $+3
$SG13663 DB	'(S->DT), ', 00H
	ORG $+2
$SG13668 DB	0aH, 'Entity: ', 00H
	ORG $+2
$SG13666 DB	'Failure during standard call, but would have been succes'
	DB	'sful if the default context was used.', 0aH, 'Probable User E'
	DB	'rror.', 00H
	ORG $+1
$SG13667 DB	0aH, 'Object Def: ', 00H
	ORG $+2
$SG13669 DB	0aH, 'Attribute: ', 00H
	ORG $+3
$SG13670 DB	'SetCursorNextEntityByString', 00H
$SG14700 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG14701 DB	'System Error', 00H
	ORG $+3
$SG14702 DB	'TZDMD101', 00H
	ORG $+3
$SG14710 DB	', ', 00H
	ORG $+1
$SG14711 DB	', ', 00H
	ORG $+1
$SG14720 DB	'fnSetEntityCursor', 00H
	ORG $+2
$SG14721 DB	'(cm) Invalid qualification type with context:', 00H
	ORG $+2
$SG14731 DB	'TZDMD101', 00H
	ORG $+3
$SG14729 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG14730 DB	'System Error', 00H
	ORG $+3
$SG14743 DB	', ', 00H
	ORG $+1
$SG14744 DB	', ', 00H
	ORG $+1
$SG14752 DB	'(L->', 00H
	ORG $+3
$SG14753 DB	'), ', 00H
$SG14756 DB	'(?->DT), ', 00H
	ORG $+2
$SG14765 DB	'(S->L), ', 00H
	ORG $+3
$SG14772 DB	'(S->M), ', 00H
	ORG $+3
$SG14774 DB	'(S->', 00H
	ORG $+3
$SG14775 DB	'), ', 00H
$SG14781 DB	'(M->', 00H
	ORG $+3
$SG14782 DB	'), ', 00H
_DATA	ENDS
PUBLIC	_SetCursorNextEntity@12
PUBLIC	_SetCursorPrevEntity@12
PUBLIC	_SetCursorFirstEntity@12
PUBLIC	_SetCursorLastEntity@12
PUBLIC	_SetCursorScopeOI@12
PUBLIC	_SetCursorFirstEntityByString@20
PUBLIC	_SetCursorNextEntityByString@20
PUBLIC	_SetCursorFirstEntityByInteger@20
PUBLIC	_SetCursorNextEntityByInteger@20
PUBLIC	_SetCursorFirstEntityByDecimal@56
PUBLIC	_SetCursorNextEntityByDecimal@56
PUBLIC	_SetCursorFirstEntityByAttr@28
PUBLIC	_SetCursorNextEntityByAttr@28
PUBLIC	_SetCursorFirstEntityByEntityCsr@20
PUBLIC	_SetCursorNextEntityByEntityCsr@20
PUBLIC	_SetEntityCursor@40
PUBLIC	_SetCursorRelativeEntity@16
PUBLIC	_GetRelativeEntityNumber@16
PUBLIC	_SetCursorAbsolutePosition@12
PUBLIC	_GetAbsolutePositionForEntity@12
PUBLIC	_DefineHierarchicalCursor@8
PUBLIC	_DropHierarchicalCursor@4
PUBLIC	_SetCursorNextEntityHierarchical@12
PUBLIC	_GetEntityNameForHierarchicalCsr@16
PUBLIC	_GetEntityKeyForHierarchicalCsr@16
PUBLIC	_SetSelectSetForView@8
PUBLIC	_GetSelectStateOfEntityForSet@12
PUBLIC	_GetSelectStateOfEntity@8
PUBLIC	_SetCursorFirstSelectedEntity@12
PUBLIC	_SetCursorNextSelectedEntity@12
PUBLIC	_SetAllSelStatesForEntityForSet@20
PUBLIC	_SetAllSelectStatesForEntity@16
PUBLIC	_SetSelectStateOfEntityForSet@16
PUBLIC	_SetSelectStateOfEntity@12
PUBLIC	_AddCursorListener@12
PUBLIC	_RemoveCursorListener@12
PUBLIC	_fnScanEI_Scoping
PUBLIC	_fnScanEI_NoScoping
PUBLIC	_fnSetEntityCursor
PUBLIC	_fnQualifiedInstance
PUBLIC	_fnSelectedInstanceFarbler
PUBLIC	_fnValidateCursorParameters
PUBLIC	_fnNullCursorForViewChildren
PUBLIC	_fnResetCursorForViewChildren
PUBLIC	_fnEstablishCursorForView
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnCallListeners
PUBLIC	_fnQualOperatorMatchesRC
PUBLIC	_fnStringMatchesAttributeValue
PUBLIC	_fnAttrValueMatchesAttrValue
PUBLIC	_fnIntegerMatchesAttributeValue
PUBLIC	_fnDecimalMatchesAttributeValue
PUBLIC	_fnDateTimeMatchesAttributeValue@16
PUBLIC	_fnInstanceMatchesInstance
PUBLIC	_fnSetChildCursors
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_DropView@4:PROC
EXTRN	_SetViewToSubobject@8:PROC
EXTRN	_CheckExistenceOfEntity@8:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_SysAssignDecimalFromNull@4:PROC
EXTRN	_SysCompareDecimalToDecimal@8:PROC
EXTRN	_SysConvertDecimalToLong@8:PROC
EXTRN	_SysConvertLongToDecimal@8:PROC
EXTRN	_GetDefaultContext@8:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_ConvertDecimalToString@52:PROC
EXTRN	_UfStringToDateTime@8:PROC
EXTRN	_fnGetVariableFromAttribute:PROC
EXTRN	_fnCompareDateTimeToDateTime:PROC
EXTRN	_fnCompareAttributeToVariable:PROC
EXTRN	_fnAttributeValueNull:PROC
EXTRN	_fnRecordForEntityAttr:PROC
EXTRN	_fnInvokeDerivedOperation:PROC
EXTRN	_Table_Handler@36:PROC
EXTRN	_fnDomainProcessingRequired:PROC
EXTRN	_fnCallDomainOper@40:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnEstablishViewForInstance:PROC
EXTRN	_fnReclaimHiddenInstances@4:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidViewCsr:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnValidViewAttrib:PROC
EXTRN	_fnValidNumericString:PROC
EXTRN	_fnValidDecimalString:PROC
EXTRN	_fnResetViewFromSubobject:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_szNullS:DWORD
EXTRN	_lNullInteger:DWORD
EXTRN	_stNullDateTime:FWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpResetViewEntityCsr$ = -12				; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRootLevel$ = -4					; size = 2
_lpViewEntityCsr$ = 8					; size = 4
_fnSetChildCursors PROC

; 5917 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5918 :    LPVIEWENTITYCSR  lpResetViewEntityCsr;
; 5919 :    LPENTITYINSTANCE lpEntityInstance;
; 5920 :    zSHORT           nRootLevel;
; 5921 : 
; 5922 :    // We need to keep track of the level of the parent EI.
; 5923 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5924 :    nRootLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nRootLevel$[ebp], ax

; 5925 : 
; 5926 :    for ( lpResetViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetViewEntityCsr$[ebp], eax
	jmp	SHORT $LN4@fnSetChild
$LN2@fnSetChild:

; 5928 :             lpResetViewEntityCsr->nLevel > lpViewEntityCsr->nLevel;
; 5929 :          lpResetViewEntityCsr = zGETPTR( lpResetViewEntityCsr->hNextHier ) )

	mov	eax, DWORD PTR _lpResetViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetViewEntityCsr$[ebp], eax
$LN4@fnSetChild:

; 5927 :          lpResetViewEntityCsr &&

	cmp	DWORD PTR _lpResetViewEntityCsr$[ebp], 0
	je	$LN1@fnSetChild
	mov	edx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jle	$LN1@fnSetChild

; 5930 :    {
; 5931 :       // We only care about cursors that are immediate children of the parent.
; 5932 :       if ( lpResetViewEntityCsr->nLevel != lpViewEntityCsr->nLevel + 1 )

	mov	eax, DWORD PTR _lpResetViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	add	eax, 1
	cmp	ecx, eax
	je	SHORT $LN8@fnSetChild

; 5933 :          continue;

	jmp	SHORT $LN2@fnSetChild
$LN8@fnSetChild:

; 5934 : 
; 5935 :       // Find the first lpEntityInstance that has the same hViewEntity as
; 5936 :       // the lpResetViewEntityCsr.
; 5937 :       for ( lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN7@fnSetChild
$LN5@fnSetChild:

; 5939 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnSetChild:

; 5938 :             lpEntityInstance && lpEntityInstance->nLevel > nRootLevel;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN6@fnSetChild
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nRootLevel$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN6@fnSetChild

; 5940 :       {
; 5941 :          if ( lpEntityInstance->hViewEntity == lpResetViewEntityCsr->hViewEntity )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpResetViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [edx+2]
	cmp	ecx, DWORD PTR [eax+14]
	jne	SHORT $LN9@fnSetChild

; 5942 :          {
; 5943 :             // We found a match.  Set the cursor.
; 5944 :             lpResetViewEntityCsr->hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 5945 :          // if ( lpResetViewEntityCsr->hEntityInstance == UNSET_CSR )
; 5946 :          //    SysMessageBox( 0, "fnSetChildCursors", "UNSET_CSR", -1 );
; 5947 : 
; 5948 :             // Call this function again to set the children of lpResetViewEntityCsr.
; 5949 :             fnSetChildCursors( lpResetViewEntityCsr );

	mov	edx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	push	edx
	call	_fnSetChildCursors
	add	esp, 4

; 5950 : 
; 5951 :             // We're done with this cursor so break.
; 5952 :             break;

	jmp	SHORT $LN6@fnSetChild
$LN9@fnSetChild:

; 5953 :          }
; 5954 : 
; 5955 :       } // for each lpEntityInstance....

	jmp	SHORT $LN5@fnSetChild
$LN6@fnSetChild:

; 5956 : 
; 5957 :    } // for each csr...

	jmp	$LN2@fnSetChild
$LN1@fnSetChild:

; 5958 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetChildCursors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpWrkEntityInstance$ = -4				; size = 4
_lpCompareInstance$ = 8					; size = 4
_lpSearchInstance$ = 12					; size = 4
_fnInstanceMatchesInstance PROC

; 1707 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1708 :    LPENTITYINSTANCE lpWrkEntityInstance;
; 1709 : 
; 1710 :    if ( lpSearchInstance == lpCompareInstance )

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	cmp	eax, DWORD PTR _lpCompareInstance$[ebp]
	jne	SHORT $LN2@fnInstance

; 1711 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnInstance
$LN2@fnInstance:

; 1712 : 
; 1713 :    while ( lpSearchInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpSearchInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN4@fnInstance

; 1714 :       lpSearchInstance = zGETPTR( lpSearchInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$[ebp], eax
	jmp	SHORT $LN2@fnInstance
$LN4@fnInstance:

; 1715 : 
; 1716 :    while ( lpCompareInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpCompareInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN6@fnInstance

; 1717 :       lpCompareInstance = zGETPTR( lpCompareInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpCompareInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareInstance$[ebp], eax
	jmp	SHORT $LN4@fnInstance
$LN6@fnInstance:

; 1718 : 
; 1719 :    while ( lpSearchInstance )

	cmp	DWORD PTR _lpSearchInstance$[ebp], 0
	je	$LN7@fnInstance

; 1720 :    {
; 1721 :       if ( lpSearchInstance == lpCompareInstance )

	mov	ecx, DWORD PTR _lpSearchInstance$[ebp]
	cmp	ecx, DWORD PTR _lpCompareInstance$[ebp]
	jne	SHORT $LN14@fnInstance

; 1722 :          return( 1 );

	mov	eax, 1
	jmp	$LN1@fnInstance
$LN14@fnInstance:

; 1723 : 
; 1724 :       if ( lpSearchInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN15@fnInstance

; 1725 :       {
; 1726 :          for ( lpWrkEntityInstance = zGETPTR( lpSearchInstance->hNextLinked );

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
	jmp	SHORT $LN10@fnInstance
$LN8@fnInstance:

; 1728 :                lpWrkEntityInstance =

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN10@fnInstance:

; 1727 :                lpWrkEntityInstance != lpSearchInstance;

	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpSearchInstance$[ebp]
	je	SHORT $LN15@fnInstance

; 1729 :                               zGETPTR( lpWrkEntityInstance->hNextLinked ) )
; 1730 :          {
; 1731 :             if ( lpWrkEntityInstance == lpCompareInstance )

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	edx, DWORD PTR _lpCompareInstance$[ebp]
	jne	SHORT $LN16@fnInstance

; 1732 :                return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnInstance
$LN16@fnInstance:

; 1733 :          }

	jmp	SHORT $LN8@fnInstance
$LN15@fnInstance:

; 1734 :       }
; 1735 : 
; 1736 :       if ( lpCompareInstance->hNextVsn )

	mov	eax, DWORD PTR _lpCompareInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	SHORT $LN17@fnInstance

; 1737 :          lpCompareInstance = zGETPTR( lpCompareInstance->hNextVsn );

	mov	ecx, DWORD PTR _lpCompareInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareInstance$[ebp], eax
	jmp	SHORT $LN18@fnInstance
$LN17@fnInstance:

; 1738 :       else
; 1739 :       {
; 1740 :          lpSearchInstance = zGETPTR( lpSearchInstance->hNextVsn );

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$[ebp], eax
$LN11@fnInstance:

; 1741 :          while ( lpCompareInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpCompareInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN18@fnInstance

; 1742 :             lpCompareInstance = zGETPTR( lpCompareInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpCompareInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareInstance$[ebp], eax
	jmp	SHORT $LN11@fnInstance
$LN18@fnInstance:

; 1743 :       }
; 1744 :    }

	jmp	$LN6@fnInstance
$LN7@fnInstance:

; 1745 : 
; 1746 :    return( 0 );  // failure

	xor	eax, eax
$LN1@fnInstance:

; 1747 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInstanceMatchesInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
tv91 = -20						; size = 4
tv86 = -16						; size = 4
_lpTempDateTime$ = -12					; size = 4
_lpRecord$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpDateTime$ = 8					; size = 4
_lOperator$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_fnDateTimeMatchesAttributeValue@16 PROC

; 970  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 971  :    LPDTINTERNAL lpTempDateTime;
; 972  :    zSHORT       nRC;
; 973  :    zPCHAR       lpRecord;
; 974  : 
; 975  :    lpRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _lpRecord$[ebp], eax

; 976  : 
; 977  :    if ( lpRecord && lpViewAttrib->cType == zTYPE_DATETIME )

	cmp	DWORD PTR _lpRecord$[ebp], 0
	je	$LN2@fnDateTime
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 84					; 00000054H
	jne	$LN2@fnDateTime

; 978  :    {
; 979  :       lpRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _lpRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lpRecord$[ebp], edx

; 980  :       lpTempDateTime = (LPDTINTERNAL) lpRecord;

	mov	eax, DWORD PTR _lpRecord$[ebp]
	mov	DWORD PTR _lpTempDateTime$[ebp], eax

; 981  :       if ( lpTempDateTime->ulDateMinutes == lpDateTime->ulDateMinutes )

	mov	ecx, DWORD PTR _lpTempDateTime$[ebp]
	mov	edx, DWORD PTR _lpDateTime$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@fnDateTime

; 982  :       {
; 983  :          if ( lpTempDateTime->usTSeconds == lpDateTime->usTSeconds )

	mov	ecx, DWORD PTR _lpTempDateTime$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _lpDateTime$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	cmp	edx, ecx
	jne	SHORT $LN5@fnDateTime

; 984  :             nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN6@fnDateTime
$LN5@fnDateTime:

; 985  :          else
; 986  :             nRC = (lpTempDateTime->usTSeconds <

	mov	eax, DWORD PTR _lpTempDateTime$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	mov	edx, DWORD PTR _lpDateTime$[ebp]
	movzx	eax, WORD PTR [edx+4]
	cmp	ecx, eax
	jge	SHORT $LN8@fnDateTime
	mov	DWORD PTR tv86[ebp], -1
	jmp	SHORT $LN9@fnDateTime
$LN8@fnDateTime:
	mov	DWORD PTR tv86[ebp], 1
$LN9@fnDateTime:
	mov	cx, WORD PTR tv86[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN6@fnDateTime:

; 987  :                                        lpDateTime->usTSeconds) ? -1 : 1;
; 988  :       }

	jmp	SHORT $LN4@fnDateTime
$LN3@fnDateTime:

; 989  :       else
; 990  :          nRC = (lpTempDateTime->ulDateMinutes <

	mov	edx, DWORD PTR _lpTempDateTime$[ebp]
	mov	eax, DWORD PTR _lpDateTime$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN10@fnDateTime
	mov	DWORD PTR tv91[ebp], -1
	jmp	SHORT $LN11@fnDateTime
$LN10@fnDateTime:
	mov	DWORD PTR tv91[ebp], 1
$LN11@fnDateTime:
	mov	dx, WORD PTR tv91[ebp]
	mov	WORD PTR _nRC$[ebp], dx
$LN4@fnDateTime:

; 991  :                                          lpDateTime->ulDateMinutes) ? -1 : 1;
; 992  : 
; 993  :       return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lOperator$[ebp]
	push	ecx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	SHORT $LN1@fnDateTime
$LN2@fnDateTime:

; 994  :    }
; 995  : 
; 996  :    return( 0 );  // failure

	xor	eax, eax
$LN1@fnDateTime:

; 997  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnDateTimeMatchesAttributeValue@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewOI$ = -16					; size = 4
_lpDecimal$ = -12					; size = 4
_lpRecord$ = -8						; size = 4
_nRC$ = -4						; size = 2
_dDecimalValue$ = 8					; size = 40
_lOperator$ = 48					; size = 4
_lpEntityInstance$ = 52					; size = 4
_lpViewAttrib$ = 56					; size = 4
_fnDecimalMatchesAttributeValue PROC

; 931  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 932  :    zSHORT    nRC;
; 933  :    zPDECIMAL lpDecimal;
; 934  :    zPCHAR    lpRecord;
; 935  :    LPVIEWOI  lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 936  : 
; 937  :    lpRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _lpRecord$[ebp], eax

; 938  : 
; 939  :    if ( lpRecord && lpViewAttrib->cType == zTYPE_DECIMAL )

	cmp	DWORD PTR _lpRecord$[ebp], 0
	je	SHORT $LN2@fnDecimalM
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN2@fnDecimalM

; 940  :    {
; 941  :       lpRecord += lpViewAttrib->ulRecordOffset;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _lpRecord$[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _lpRecord$[ebp], ecx

; 942  :       lpDecimal  = (zPDECIMAL) lpRecord;

	mov	edx, DWORD PTR _lpRecord$[ebp]
	mov	DWORD PTR _lpDecimal$[ebp], edx

; 943  :       nRC = SysCompareDecimalToDecimal( lpDecimal, &dDecimalValue );

	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDecimal$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 944  :       return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	mov	eax, DWORD PTR _lOperator$[ebp]
	push	eax
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	SHORT $LN1@fnDecimalM
$LN2@fnDecimalM:

; 945  :    }
; 946  : 
; 947  :    return( 0 );  // failure

	xor	eax, eax
$LN1@fnDecimalM:

; 948  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDecimalMatchesAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
tv75 = -16						; size = 4
_lplLong$ = -12						; size = 4
_lpRecord$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lIntegerValue$ = 8					; size = 4
_lOperator$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_fnIntegerMatchesAttributeValue PROC

; 889  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 890  :    zPLONG   lplLong;
; 891  :    zPCHAR   lpRecord;
; 892  :    zSHORT   nRC;
; 893  : 
; 894  :    lpRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _lpRecord$[ebp], eax

; 895  : 
; 896  :    if ( lpRecord && lpViewAttrib->cType == 'L' )

	cmp	DWORD PTR _lpRecord$[ebp], 0
	je	SHORT $LN2@fnIntegerM
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN2@fnIntegerM

; 897  :    {
; 898  :       lpRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _lpRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lpRecord$[ebp], edx

; 899  :       lplLong  = (zPLONG) lpRecord;

	mov	eax, DWORD PTR _lpRecord$[ebp]
	mov	DWORD PTR _lplLong$[ebp], eax

; 900  :       if ( *lplLong == lIntegerValue )

	mov	ecx, DWORD PTR _lplLong$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lIntegerValue$[ebp]
	jne	SHORT $LN3@fnIntegerM

; 901  :          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnIntegerM
$LN3@fnIntegerM:

; 902  :       else
; 903  :          nRC = (*lplLong < lIntegerValue) ? -1 : 1;

	mov	ecx, DWORD PTR _lplLong$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lIntegerValue$[ebp]
	jge	SHORT $LN6@fnIntegerM
	mov	DWORD PTR tv75[ebp], -1
	jmp	SHORT $LN7@fnIntegerM
$LN6@fnIntegerM:
	mov	DWORD PTR tv75[ebp], 1
$LN7@fnIntegerM:
	mov	ax, WORD PTR tv75[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnIntegerM:

; 904  : 
; 905  :       return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lOperator$[ebp]
	push	edx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	SHORT $LN1@fnIntegerM
$LN2@fnIntegerM:

; 906  :    }
; 907  : 
; 908  :    return( 0 );  // failure

	xor	eax, eax
$LN1@fnIntegerM:

; 909  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnIntegerMatchesAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_ulTossOut$1 = -368					; size = 4
_lpViewCsr$2 = -364					; size = 4
_lpViewEntityCsrForDomain$3 = -360			; size = 4
_lpuSearchBlobLth$4 = -356				; size = 4
_lpExternalP$5 = -352					; size = 4
_lpExternalP$6 = -348					; size = 4
_lpViewEntityCsrDA$7 = -344				; size = 4
$T8 = -340						; size = 4
_lpDomain$9 = -336					; size = 4
_lpuSrcBlobLth$10 = -332				; size = 4
tv187 = -328						; size = 4
tv171 = -324						; size = 4
tv170 = -320						; size = 4
tv141 = -316						; size = 4
_lpExternalP$11 = -312					; size = 4
_lpSearchRecord$ = -308					; size = 4
_lpSrcRecord$ = -304					; size = 4
_nRC$ = -300						; size = 2
_szWorkString$ = -296					; size = 255
_szContext$12 = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_vAttrView$ = 8						; size = 4
_lOperator$ = 12					; size = 4
_lpSrcViewEntityCsr$ = 16				; size = 4
_lpSrcEntityInstance$ = 20				; size = 4
_lpSrcViewAttrib$ = 24					; size = 4
_lpSearchViewEntityCsr$ = 28				; size = 4
_lpSearchEntityInstance$ = 32				; size = 4
_lpSearchViewAttrib$ = 36				; size = 4
_lpCurrentTask$ = 40					; size = 4
_fnAttrValueMatchesAttrValue PROC

; 435  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 368				; 00000170H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 436  :    zSHORT   nRC;
; 437  :    zPCHAR   lpSrcRecord;
; 438  :    zPCHAR   lpSearchRecord;
; 439  :    zCHAR    szWorkString[ 255 ];
; 440  : 
; 441  :    lpSrcRecord = fnRecordForEntityAttr( lpSrcEntityInstance,

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _lpSrcRecord$[ebp], eax

; 442  :                                         lpSrcViewAttrib );
; 443  : 
; 444  :    lpSearchRecord = fnRecordForEntityAttr( lpSearchEntityInstance,

	mov	edx, DWORD PTR _lpSearchViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _lpSearchRecord$[ebp], eax

; 445  :                                            lpSearchViewAttrib );
; 446  : 
; 447  :    // If both lpRecord are NULL then the attributes are NULL so they match.
; 448  :    if ( lpSrcRecord == 0 && lpSearchRecord == 0 )

	cmp	DWORD PTR _lpSrcRecord$[ebp], 0
	jne	SHORT $LN4@fnAttrValu
	cmp	DWORD PTR _lpSearchRecord$[ebp], 0
	jne	SHORT $LN4@fnAttrValu

; 449  :       return( 1 );

	mov	eax, 1
	jmp	$LN33@fnAttrValu
$LN4@fnAttrValu:

; 450  : 
; 451  :    // If only one of them is NULL, then they don't match.
; 452  :    if ( lpSrcRecord == 0 || lpSearchRecord == 0 )

	cmp	DWORD PTR _lpSrcRecord$[ebp], 0
	je	SHORT $LN6@fnAttrValu
	cmp	DWORD PTR _lpSearchRecord$[ebp], 0
	jne	SHORT $LN5@fnAttrValu
$LN6@fnAttrValu:

; 453  :       return( 0 );

	xor	eax, eax
	jmp	$LN33@fnAttrValu
$LN5@fnAttrValu:

; 454  : 
; 455  :    if ( lpSrcViewAttrib->cType == lpSearchViewAttrib->cType &&

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	mov	eax, DWORD PTR _lpSearchViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	edx, ecx
	jne	$LN7@fnAttrValu
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	eax, DWORD PTR _lpSearchViewAttrib$[ebp]
	mov	ecx, DWORD PTR [edx+198]
	cmp	ecx, DWORD PTR [eax+198]
	jne	$LN7@fnAttrValu

; 456  :         lpSrcViewAttrib->hDomain == lpSearchViewAttrib->hDomain )
; 457  :    {
; 458  :       // If derived attribute for src, invoke operation now.
; 459  :       // If search attribute is derived, that was done at the
; 460  :       // beginning of fnSetEntityCursor.
; 461  :       if ( lpSrcViewAttrib->szDerivedOper[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+213]
	test	edx, edx
	je	SHORT $LN9@fnAttrValu

; 462  :       {
; 463  :          LPVIEWENTITYCSR lpViewEntityCsrDA =

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsrDA$7[ebp], eax

; 464  :                            fnEstablishViewForInstance( vAttrView, 0,
; 465  :                                                        lpSrcEntityInstance );
; 466  : 
; 467  :          nRC = fnInvokeDerivedOperation( vAttrView,

	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsrDA$7[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 468  :                                          zGETPTR( lpViewEntityCsrDA->
; 469  :                                                             hViewEntity ),
; 470  :                                          lpSrcViewAttrib,
; 471  :                                          lpCurrentTask, zDERIVED_GET );
; 472  :          if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN9@fnAttrValu

; 473  :             return( nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	jmp	$LN33@fnAttrValu
$LN9@fnAttrValu:

; 474  :       }
; 475  : 
; 476  :       lpSrcRecord += lpSrcViewAttrib->ulRecordOffset;

	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	eax, DWORD PTR _lpSrcRecord$[ebp]
	add	eax, DWORD PTR [edx+250]
	mov	DWORD PTR _lpSrcRecord$[ebp], eax

; 477  :       lpSearchRecord += lpSearchViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpSearchViewAttrib$[ebp]
	mov	edx, DWORD PTR _lpSearchRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lpSearchRecord$[ebp], edx

; 478  :       switch ( lpSrcViewAttrib->cType )

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv141[ebp], ecx
	mov	edx, DWORD PTR tv141[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv141[ebp], edx
	cmp	DWORD PTR tv141[ebp], 18		; 00000012H
	ja	$LN2@fnAttrValu
	mov	eax, DWORD PTR tv141[ebp]
	movzx	ecx, BYTE PTR $LN42@fnAttrValu[eax]
	jmp	DWORD PTR $LN43@fnAttrValu[ecx*4]
$LN11@fnAttrValu:

; 479  :       {
; 480  :          case zTYPE_STRING:
; 481  :             if ( lpSrcRecord[ 0 ] == (zCHAR) '\xff' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSrcRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	SHORT $LN12@fnAttrValu

; 482  :             {
; 483  :                zCOREMEM  lpExternalP;
; 484  : 
; 485  :                lpExternalP = (zCOREMEM) ( lpSrcRecord + 1 );

	mov	eax, DWORD PTR _lpSrcRecord$[ebp]
	add	eax, 1
	mov	DWORD PTR _lpExternalP$6[ebp], eax

; 486  :                lpSrcRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$6[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcRecord$[ebp], eax
$LN12@fnAttrValu:

; 487  :             }
; 488  : 
; 489  :             if ( lpSearchRecord[ 0 ] == (zCHAR) '\xff' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSearchRecord$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	SHORT $LN13@fnAttrValu

; 490  :             {
; 491  :                zCOREMEM  lpExternalP;
; 492  : 
; 493  :                lpExternalP = (zCOREMEM) ( lpSearchRecord + 1 );

	mov	ecx, DWORD PTR _lpSearchRecord$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$5[ebp], ecx

; 494  :                lpSearchRecord = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$5[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchRecord$[ebp], eax
$LN13@fnAttrValu:

; 495  :             }
; 496  : 
; 497  :             if ( lpSrcViewAttrib->bCaseSens )

	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN14@fnAttrValu

; 498  :                nRC = zstrcmp( lpSrcRecord, lpSearchRecord );

	mov	eax, DWORD PTR _lpSrcRecord$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpSearchRecord$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN36@fnAttrValu
	mov	ecx, DWORD PTR _lpSearchRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcRecord$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN37@fnAttrValu
$LN36@fnAttrValu:
	mov	eax, DWORD PTR _lpSrcRecord$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpSearchRecord$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN34@fnAttrValu
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN35@fnAttrValu
$LN34@fnAttrValu:
	mov	DWORD PTR tv170[ebp], -1
$LN35@fnAttrValu:
	mov	ecx, DWORD PTR tv170[ebp]
	mov	DWORD PTR tv171[ebp], ecx
$LN37@fnAttrValu:
	mov	dx, WORD PTR tv171[ebp]
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN15@fnAttrValu
$LN14@fnAttrValu:

; 499  :             else
; 500  :                nRC = zstrcmpi( lpSrcRecord, lpSearchRecord );

	mov	eax, DWORD PTR _lpSearchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcRecord$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN15@fnAttrValu:

; 501  : 
; 502  :          // nRC = (nRC > 0) ? 1 : ((nRC < 0) ? -1 : 0);
; 503  :             if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN16@fnAttrValu

; 504  :                nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN17@fnAttrValu
$LN16@fnAttrValu:

; 505  :             else
; 506  :             if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN17@fnAttrValu

; 507  :                nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN17@fnAttrValu:

; 508  : 
; 509  :             return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lOperator$[ebp]
	push	ecx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	$LN33@fnAttrValu
$LN19@fnAttrValu:

; 510  : 
; 511  :          case zTYPE_INTEGER:
; 512  :             if ( *((zPLONG) lpSrcRecord) == *((zPLONG) lpSearchRecord) )

	mov	edx, DWORD PTR _lpSrcRecord$[ebp]
	mov	eax, DWORD PTR _lpSearchRecord$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN20@fnAttrValu

; 513  :                nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN21@fnAttrValu
$LN20@fnAttrValu:

; 514  :             else
; 515  :                nRC = (*((zPLONG) lpSrcRecord) <

	mov	eax, DWORD PTR _lpSrcRecord$[ebp]
	mov	ecx, DWORD PTR _lpSearchRecord$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN38@fnAttrValu
	mov	DWORD PTR tv187[ebp], -1
	jmp	SHORT $LN39@fnAttrValu
$LN38@fnAttrValu:
	mov	DWORD PTR tv187[ebp], 1
$LN39@fnAttrValu:
	mov	ax, WORD PTR tv187[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN21@fnAttrValu:

; 516  :                                           *((zPLONG) lpSearchRecord) ) ? -1 : 1;
; 517  : 
; 518  :             return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lOperator$[ebp]
	push	edx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	$LN33@fnAttrValu
$LN22@fnAttrValu:

; 519  : 
; 520  :          case zTYPE_DECIMAL:
; 521  :             nRC = SysCompareDecimalToDecimal( (zPDECIMAL) lpSrcRecord,

	mov	eax, DWORD PTR _lpSearchRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcRecord$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	mov	WORD PTR _nRC$[ebp], ax

; 522  :                                               (zPDECIMAL) lpSearchRecord );
; 523  :             return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	mov	eax, DWORD PTR _lOperator$[ebp]
	push	eax
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	$LN33@fnAttrValu
$LN23@fnAttrValu:

; 524  : 
; 525  :          case zTYPE_DATETIME:
; 526  :             nRC = fnCompareDateTimeToDateTime( (LPDTINTERNAL) lpSrcRecord,

	mov	ecx, DWORD PTR _lpSearchRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcRecord$[ebp]
	push	edx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 527  :                                                (LPDTINTERNAL) lpSearchRecord );
; 528  :             return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lOperator$[ebp]
	push	ecx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	$LN33@fnAttrValu
$LN24@fnAttrValu:

; 529  : 
; 530  :          case zTYPE_BLOB:
; 531  :             if ( lpSrcRecord[ 0 ] == (zCHAR) '\xff' &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSrcRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	jne	$LN25@fnAttrValu
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSearchRecord$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	$LN25@fnAttrValu

; 532  :                  lpSearchRecord[ 0 ] == (zCHAR) '\xff' )
; 533  :             {
; 534  :                zPULONG  lpuSrcBlobLth;
; 535  :                zPULONG  lpuSearchBlobLth;
; 536  :                zCOREMEM lpExternalP;
; 537  : 
; 538  :                lpExternalP = (zCOREMEM) (lpSrcRecord + 1);

	mov	ecx, DWORD PTR _lpSrcRecord$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$11[ebp], ecx

; 539  :                lpuSrcBlobLth  = (zPULONG) (lpExternalP + 1);

	mov	edx, DWORD PTR _lpExternalP$11[ebp]
	add	edx, 4
	mov	DWORD PTR _lpuSrcBlobLth$10[ebp], edx

; 540  :                lpSrcRecord = zGETPTR( *lpExternalP );

	mov	eax, DWORD PTR _lpExternalP$11[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcRecord$[ebp], eax

; 541  :                lpExternalP = (zCOREMEM) (lpSearchRecord + 1);

	mov	edx, DWORD PTR _lpSearchRecord$[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$11[ebp], edx

; 542  :                lpuSearchBlobLth  = (zPULONG) (lpExternalP + 1);

	mov	eax, DWORD PTR _lpExternalP$11[ebp]
	add	eax, 4
	mov	DWORD PTR _lpuSearchBlobLth$4[ebp], eax

; 543  :                lpSearchRecord = zGETPTR( *lpExternalP );

	mov	ecx, DWORD PTR _lpExternalP$11[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchRecord$[ebp], eax

; 544  : 
; 545  :                if ( *lpuSrcBlobLth != *lpuSearchBlobLth )

	mov	eax, DWORD PTR _lpuSrcBlobLth$10[ebp]
	mov	ecx, DWORD PTR _lpuSearchBlobLth$4[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	je	SHORT $LN27@fnAttrValu

; 546  :                   break;

	jmp	SHORT $LN2@fnAttrValu
$LN27@fnAttrValu:

; 547  : 
; 548  :                if ( zmemcmp( lpSrcRecord, lpSearchRecord,
; 549  :                              (int) *lpuSrcBlobLth ) == 0 )

	mov	eax, DWORD PTR _lpuSrcBlobLth$10[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpSearchRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcRecord$[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN28@fnAttrValu

; 550  :                {
; 551  :                   return( 1 );

	mov	eax, 1
	jmp	$LN33@fnAttrValu
$LN28@fnAttrValu:

; 552  :                }
; 553  : 
; 554  :                break;

	jmp	SHORT $LN2@fnAttrValu

; 555  :             }

	jmp	SHORT $LN2@fnAttrValu
$LN25@fnAttrValu:

; 556  :             else
; 557  :             if ( lpSrcRecord[ 0 ] != (zCHAR) '\xff' &&

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpSrcRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	je	SHORT $LN2@fnAttrValu
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSearchRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, -1
	je	SHORT $LN2@fnAttrValu

; 558  :                  lpSearchRecord[ 0 ] != (zCHAR) '\xff' )
; 559  :             {
; 560  :                return( 1 );

	mov	eax, 1
	jmp	$LN33@fnAttrValu
$LN2@fnAttrValu:

; 561  :             }
; 562  : 
; 563  :             break;
; 564  : 
; 565  :       } // end of switch ( lpSrcViewAttrib->cType )
; 566  :    }

	jmp	$LN8@fnAttrValu
$LN7@fnAttrValu:

; 567  :    else
; 568  :    // Attributes differ in chType and/or Domain
; 569  :    // Compare the Search to the Src in the context of the Src's Domain
; 570  :    {
; 571  :       zULONG          ulTossOut;
; 572  :       LPVIEWENTITYCSR lpViewEntityCsrForDomain =

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsrForDomain$3[ebp], eax

; 573  :                            fnEstablishViewForInstance( vAttrView, 0,
; 574  :                                                        lpSrcEntityInstance );
; 575  : 
; 576  :       nRC = fnGetVariableFromAttribute( (zPVOID) szWorkString,

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsrForDomain$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _vAttrView$[ebp]
	push	edx
	push	255					; 000000ffH
	push	83					; 00000053H
	lea	eax, DWORD PTR _ulTossOut$1[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 577  :                                         &ulTossOut,
; 578  :                                         zTYPE_STRING,
; 579  :                                         sizeof( szWorkString ),
; 580  :                                         vAttrView,
; 581  :                                         lpViewEntityCsrForDomain,
; 582  :                                         lpSrcViewAttrib,
; 583  :                                         0, lpCurrentTask, 0 );
; 584  :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN8@fnAttrValu

; 585  :       {
; 586  :          zCHAR     szContext[ 33 ];
; 587  :          LPDOMAIN  lpDomain = zGETPTR( lpSrcViewAttrib->hDomain );

	mov	eax, DWORD PTR _lpSrcViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$9[ebp], eax

; 588  :          LPVIEWCSR lpViewCsr = zGETPTR( lpSearchViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpSearchViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 589  : 
; 590  :          if ( lpDomain )

	cmp	DWORD PTR _lpDomain$9[ebp], 0
	je	SHORT $LN31@fnAttrValu

; 591  :             zstrcpy( szContext, lpDomain->szName );

	mov	ecx, DWORD PTR _lpDomain$9[ebp]
	add	ecx, 6
	push	ecx
	lea	edx, DWORD PTR _szContext$12[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN32@fnAttrValu
$LN31@fnAttrValu:

; 592  :          else
; 593  :             szContext[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T8[ebp], ecx
	cmp	DWORD PTR $T8[ebp], 33			; 00000021H
	jae	SHORT $LN40@fnAttrValu
	jmp	SHORT $LN41@fnAttrValu
$LN40@fnAttrValu:
	call	___report_rangecheckfailure
$LN41@fnAttrValu:
	mov	edx, DWORD PTR $T8[ebp]
	mov	BYTE PTR _szContext$12[ebp+edx], 0
$LN32@fnAttrValu:

; 594  : 
; 595  :          nRC = fnCompareAttributeToVariable( zGETPTR( lpViewCsr->hView ),

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szContext$12[ebp]
	push	ecx
	push	0
	push	83					; 00000053H
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSearchViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCsr$2[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax

; 596  :                                              lpSearchViewEntityCsr,
; 597  :                                              lpSearchViewAttrib,
; 598  :                                              (zPVOID) szWorkString,
; 599  :                                              zTYPE_STRING,
; 600  :                                              0,
; 601  :                                              szContext,
; 602  :                                              lpCurrentTask, 0 );
; 603  :          return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lOperator$[ebp]
	push	edx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	SHORT $LN33@fnAttrValu
$LN8@fnAttrValu:

; 604  :       }
; 605  :    }
; 606  : 
; 607  :    // We should never get here.
; 608  :    return( 0 );

	xor	eax, eax
$LN33@fnAttrValu:

; 609  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN43@fnAttrValu:
	DD	$LN24@fnAttrValu
	DD	$LN19@fnAttrValu
	DD	$LN22@fnAttrValu
	DD	$LN11@fnAttrValu
	DD	$LN23@fnAttrValu
	DD	$LN2@fnAttrValu
$LN42@fnAttrValu:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnAttrValueMatchesAttrValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpExternalP$1 = -20					; size = 4
tv95 = -16						; size = 4
tv94 = -12						; size = 4
_lpRecord$ = -8						; size = 4
_nRC$ = -4						; size = 2
_cpcStringValue$ = 8					; size = 4
_lOperator$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_fnStringMatchesAttributeValue PROC

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 380  :    zPCHAR   lpRecord;
; 381  :    zSHORT   nRC;
; 382  : 
; 383  :    lpRecord = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _lpRecord$[ebp], eax

; 384  : 
; 385  :    if ( lpRecord && lpViewAttrib->cType == 'S' )

	cmp	DWORD PTR _lpRecord$[ebp], 0
	je	$LN2@fnStringMa
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	$LN2@fnStringMa

; 386  :    {
; 387  :       lpRecord += lpViewAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _lpRecord$[ebp]
	add	edx, DWORD PTR [ecx+250]
	mov	DWORD PTR _lpRecord$[ebp], edx

; 388  :       if ( lpRecord[ 0 ] == (zCHAR) '\xff' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpRecord$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	SHORT $LN3@fnStringMa

; 389  :       {
; 390  :          zCOREMEM  lpExternalP;
; 391  : 
; 392  :          lpExternalP = (zCOREMEM) (lpRecord + 1);

	mov	ecx, DWORD PTR _lpRecord$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lpExternalP$1[ebp], ecx

; 393  :          lpRecord = zGETPTR( *lpExternalP );

	mov	edx, DWORD PTR _lpExternalP$1[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecord$[ebp], eax
$LN3@fnStringMa:

; 394  :       }
; 395  : 
; 396  :       if ( lpViewAttrib->bCaseSens )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN4@fnStringMa

; 397  :          nRC = zstrcmp( lpRecord, cpcStringValue );

	mov	eax, DWORD PTR _lpRecord$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _cpcStringValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN14@fnStringMa
	mov	ecx, DWORD PTR _cpcStringValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRecord$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN15@fnStringMa
$LN14@fnStringMa:
	mov	eax, DWORD PTR _lpRecord$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _cpcStringValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN12@fnStringMa
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN13@fnStringMa
$LN12@fnStringMa:
	mov	DWORD PTR tv94[ebp], -1
$LN13@fnStringMa:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], ecx
$LN15@fnStringMa:
	mov	dx, WORD PTR tv95[ebp]
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN5@fnStringMa
$LN4@fnStringMa:

; 398  :       else
; 399  :          nRC = zstrcmpi( lpRecord, cpcStringValue );

	mov	eax, DWORD PTR _cpcStringValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRecord$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN5@fnStringMa:

; 400  : 
; 401  :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN6@fnStringMa

; 402  :          nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN7@fnStringMa
$LN6@fnStringMa:

; 403  :       else
; 404  :       if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN7@fnStringMa

; 405  :          nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN7@fnStringMa:

; 406  : 
; 407  :       return( fnQualOperatorMatchesRC( lOperator, nRC ) );

	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lOperator$[ebp]
	push	ecx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	cwde
	jmp	SHORT $LN1@fnStringMa
$LN2@fnStringMa:

; 408  :    }
; 409  : 
; 410  :    // If the lpRecord is NULL and the string value is NULL, then they match.
; 411  :    if ( lpRecord == 0 && (cpcStringValue == 0 || *cpcStringValue == 0) )

	cmp	DWORD PTR _lpRecord$[ebp], 0
	jne	SHORT $LN9@fnStringMa
	cmp	DWORD PTR _cpcStringValue$[ebp], 0
	je	SHORT $LN10@fnStringMa
	mov	edx, DWORD PTR _cpcStringValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN9@fnStringMa
$LN10@fnStringMa:

; 412  :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnStringMa
$LN9@fnStringMa:

; 413  : 
; 414  :    return( 0 ); // failure

	xor	eax, eax
$LN1@fnStringMa:

; 415  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnStringMatchesAttributeValue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
tv65 = -4						; size = 4
_lOperator$ = 8						; size = 4
_nRC$ = 12						; size = 2
_fnQualOperatorMatchesRC PROC

; 330  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 331  :    switch ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR tv65[ebp], ecx
	cmp	DWORD PTR tv65[ebp], 17			; 00000011H
	ja	SHORT $LN2@fnQualOper
	mov	edx, DWORD PTR tv65[ebp]
	movzx	eax, BYTE PTR $LN14@fnQualOper[edx]
	jmp	DWORD PTR $LN15@fnQualOper[eax*4]
$LN4@fnQualOper:

; 332  :    {
; 333  :       case -1:
; 334  :          if ( (lOperator & zQUAL_LESS_THAN) ||

	mov	ecx, DWORD PTR _lOperator$[ebp]
	and	ecx, 64					; 00000040H
	jne	SHORT $LN6@fnQualOper
	cmp	DWORD PTR _lOperator$[ebp], 144		; 00000090H
	jne	SHORT $LN5@fnQualOper
$LN6@fnQualOper:

; 335  :                lOperator == (zQUAL_NOT | zQUAL_EQUAL) )
; 336  :          {
; 337  :             return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnQualOper
$LN5@fnQualOper:

; 338  :          }
; 339  : 
; 340  :          break;

	jmp	SHORT $LN2@fnQualOper
$LN7@fnQualOper:

; 341  : 
; 342  :       case 0:
; 343  :          if ( (lOperator & zQUAL_EQUAL) && (lOperator & zQUAL_NOT) == 0 )

	mov	edx, DWORD PTR _lOperator$[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN8@fnQualOper
	mov	eax, DWORD PTR _lOperator$[ebp]
	and	eax, 128				; 00000080H
	jne	SHORT $LN8@fnQualOper

; 344  :          {
; 345  :             return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnQualOper
$LN8@fnQualOper:

; 346  :          }
; 347  : 
; 348  :          break;

	jmp	SHORT $LN2@fnQualOper
$LN9@fnQualOper:

; 349  : 
; 350  :       case 1:
; 351  :          if ( (lOperator & zQUAL_GREATER_THAN) ||

	mov	ecx, DWORD PTR _lOperator$[ebp]
	and	ecx, 32					; 00000020H
	jne	SHORT $LN11@fnQualOper
	cmp	DWORD PTR _lOperator$[ebp], 144		; 00000090H
	jne	SHORT $LN10@fnQualOper
$LN11@fnQualOper:

; 352  :                lOperator == (zQUAL_NOT | zQUAL_EQUAL) )
; 353  :          {
; 354  :             return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnQualOper
$LN10@fnQualOper:

; 355  :          }
; 356  : 
; 357  :          break;

	jmp	SHORT $LN2@fnQualOper
$LN12@fnQualOper:

; 358  : 
; 359  :       case zCALL_ERROR:
; 360  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnQualOper
$LN2@fnQualOper:

; 361  :    }
; 362  : 
; 363  :    return( 0 );

	xor	eax, eax
$LN1@fnQualOper:

; 364  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@fnQualOper:
	DD	$LN12@fnQualOper
	DD	$LN4@fnQualOper
	DD	$LN7@fnQualOper
	DD	$LN9@fnQualOper
	DD	$LN2@fnQualOper
$LN14@fnQualOper:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	3
_fnQualOperatorMatchesRC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_hCsrListener$ = -12					; size = 4
_lListenerProcess$ = -8					; size = 4
_lpCsrListener$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_fnCallListeners PROC

; 6286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6287 :    LPCURSORLISTENER lpCsrListener;
; 6288 :    LPCURSORLISTENER hCsrListener;
; 6289 :    zLONG            lListenerProcess = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lListenerProcess$[ebp], eax

; 6290 : 
; 6291 :    lpCsrListener = zGETPTR( lpView->hFirstCursorListener );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$[ebp], eax
$LN2@fnCallList:

; 6292 :    while ( lpCsrListener )

	cmp	DWORD PTR _lpCsrListener$[ebp], 0
	je	SHORT $LN1@fnCallList

; 6293 :    {
; 6294 :       // We cannot issue a callback to another task.
; 6295 :    // if ( lpCsrListener->hListenerTask == hCurrentTask &&
; 6296 :       if ( lpCsrListener->lListenerProcess == lListenerProcess )

	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _lListenerProcess$[ebp]
	jne	SHORT $LN4@fnCallList

; 6297 :       {
; 6298 :          // call back
; 6299 :          (*lpCsrListener->lpfnCursorListener)
; 6300 :                   ( lpView, cpcEntityName, lpCsrListener->pvListenerInstance );

	mov	ecx, DWORD PTR _lpCsrListener$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	add	esp, 12					; 0000000cH
$LN4@fnCallList:

; 6301 :       }
; 6302 : 
; 6303 :       // There appears to be a bug in Microsoft's compiler.  If the following
; 6304 :       // are done in one line the resulting code crashes.
; 6305 :       hCsrListener = lpCsrListener->hNextCursorListener;

	mov	ecx, DWORD PTR _lpCsrListener$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _hCsrListener$[ebp], edx

; 6306 :       lpCsrListener = zGETPTR( hCsrListener );

	mov	eax, DWORD PTR _hCsrListener$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$[ebp], eax

; 6307 :    }

	jmp	SHORT $LN2@fnCallList
$LN1@fnCallList:

; 6308 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCallListeners ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpView$1 = -48						; size = 4
_nSearchLevel$ = -44					; size = 4
_bFound$ = -40						; size = 4
_lpSearchViewEntity$ = -36				; size = 4
_nSetLevel$ = -32					; size = 4
_lpViewCsr$ = -28					; size = 4
_lpScanEntityInstance$ = -24				; size = 4
_lpViewSubobject$ = -20					; size = 4
_lpSetEntityInstance$ = -16				; size = 4
_lpScanViewEntityCsr$ = -12				; size = 4
_lpSetViewEntityCsr$ = -8				; size = 4
_lpSearchEntityInstance$ = -4				; size = 4
_lpViewEntityCsr$ = 8					; size = 4
_fnEstablishCursorForView PROC

; 6045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 6046 :    LPVIEWCSR        lpViewCsr;
; 6047 :    LPVIEWENTITY     lpSearchViewEntity;
; 6048 :    LPVIEWENTITYCSR  lpSetViewEntityCsr;
; 6049 :    LPVIEWENTITYCSR  lpScanViewEntityCsr;
; 6050 :    LPVIEWSUBOBJECT  lpViewSubobject;
; 6051 :    LPENTITYINSTANCE lpSetEntityInstance;
; 6052 :    LPENTITYINSTANCE lpSearchEntityInstance;
; 6053 :    LPENTITYINSTANCE lpScanEntityInstance;
; 6054 :    int              nSetLevel;
; 6055 :    int              nSearchLevel;
; 6056 :    int              bFound;
; 6057 : 
; 6058 :    lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6059 :    lpSetViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSetViewEntityCsr$[ebp], eax

; 6060 :    if ( lpSetViewEntityCsr &&

	cmp	DWORD PTR _lpSetViewEntityCsr$[ebp], 0
	je	SHORT $LN10@fnEstablis
	mov	ecx, DWORD PTR _lpSetViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN10@fnEstablis

; 6061 :         lpSetViewEntityCsr->hEntityInstance == UNSET_CSR )
; 6062 :    {
; 6063 :       fnEstablishCursorForView( lpSetViewEntityCsr );

	mov	edx, DWORD PTR _lpSetViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4

; 6064 :       if ( lpSetViewEntityCsr->hEntityInstance == NULL_CSR )

	mov	eax, DWORD PTR _lpSetViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN10@fnEstablis

; 6065 :       {
; 6066 :          lpViewEntityCsr->hEntityInstance = NULL_CSR;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 6067 :          return( NULL_CSR );

	xor	eax, eax
	jmp	$LN1@fnEstablis
$LN10@fnEstablis:

; 6068 :       }
; 6069 :    }
; 6070 : 
; 6071 :    // If we do not find a set cursor in the parent chain, then the
; 6072 :    // view MUST be on a subobject and the parent cursor to the view
; 6073 :    // is used as the set entity instance for establishing the cursor.
; 6074 :    if ( lpSetViewEntityCsr )

	cmp	DWORD PTR _lpSetViewEntityCsr$[ebp], 0
	je	SHORT $LN12@fnEstablis

; 6075 :    {
; 6076 :       lpSetEntityInstance = zGETPTR( lpSetViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpSetViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSetEntityInstance$[ebp], eax

; 6077 :       nSetLevel           = lpSetViewEntityCsr->nLevel;

	mov	ecx, DWORD PTR _lpSetViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	DWORD PTR _nSetLevel$[ebp], edx

; 6078 :    }

	jmp	SHORT $LN13@fnEstablis
$LN12@fnEstablis:

; 6079 :    else
; 6080 :    {
; 6081 :       lpSetEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSetEntityInstance$[ebp], eax

; 6082 :       nSetLevel           = lpSetEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpSetEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	DWORD PTR _nSetLevel$[ebp], eax
$LN13@fnEstablis:

; 6083 :    }
; 6084 : 
; 6085 :    nSearchLevel    = lpViewEntityCsr->nLevel;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	DWORD PTR _nSearchLevel$[ebp], edx

; 6086 :    lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 6087 : 
; 6088 :    // Determine the view entity we need to look for, 99% of the time
; 6089 :    // it will be the view entity for the view cursor, otherwise it may
; 6090 :    // be the recursive entity for a folded up cursor when the current
; 6091 :    // view entity has no parent and is the root
; 6092 :    if ( lpViewEntityCsr->hParent || lpViewSubobject == 0 ||
; 6093 :         lpViewSubobject->hRecursViewEntity == 0 ||

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	SHORT $LN16@fnEstablis
	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	je	SHORT $LN16@fnEstablis
	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN16@fnEstablis
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	edx, DWORD PTR [ecx+14]
	je	SHORT $LN14@fnEstablis
$LN16@fnEstablis:

; 6094 :         lpViewEntityCsr != lpViewSubobject->hRootCsr )
; 6095 :    {
; 6096 :       lpSearchViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$[ebp], eax

; 6097 :    }

	jmp	SHORT $LN15@fnEstablis
$LN14@fnEstablis:

; 6098 :    else
; 6099 :       lpSearchViewEntity = zGETPTR( lpViewSubobject->hRecursViewEntity );

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$[ebp], eax
$LN15@fnEstablis:

; 6100 : 
; 6101 :    if ( lpSetEntityInstance )

	cmp	DWORD PTR _lpSetEntityInstance$[ebp], 0
	je	SHORT $LN17@fnEstablis

; 6102 :       lpSearchEntityInstance = zGETPTR( lpSetEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpSetEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN18@fnEstablis
$LN17@fnEstablis:

; 6103 :    else
; 6104 :       lpSearchEntityInstance = 0;

	mov	DWORD PTR _lpSearchEntityInstance$[ebp], 0
$LN18@fnEstablis:

; 6105 : 
; 6106 :    bFound = FALSE;

	mov	DWORD PTR _bFound$[ebp], 0
$LN2@fnEstablis:

; 6107 :    while ( lpSearchEntityInstance &&

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN3@fnEstablis
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	ecx, DWORD PTR _nSetLevel$[ebp]
	jle	SHORT $LN3@fnEstablis

; 6108 :            lpSearchEntityInstance->nLevel > nSetLevel )
; 6109 :    {
; 6110 :       if ( lpSearchEntityInstance->nLevel == nSearchLevel &&

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	eax, DWORD PTR _nSearchLevel$[ebp]
	jne	SHORT $LN19@fnEstablis
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSearchViewEntity$[ebp]
	jne	SHORT $LN19@fnEstablis

; 6111 :            zGETPTR( lpSearchEntityInstance->hViewEntity ) == lpSearchViewEntity )
; 6112 :       {
; 6113 :          bFound = TRUE;

	mov	DWORD PTR _bFound$[ebp], 1

; 6114 :          break;

	jmp	SHORT $LN3@fnEstablis
$LN19@fnEstablis:

; 6115 :       }
; 6116 : 
; 6117 :       lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 6118 :    }

	jmp	SHORT $LN2@fnEstablis
$LN3@fnEstablis:

; 6119 : 
; 6120 :    // We're out of the loop, if found, set all cursors up to the set parent.
; 6121 :    if ( bFound )

	cmp	DWORD PTR _bFound$[ebp], 0
	je	$LN20@fnEstablis

; 6122 :    {
; 6123 :       // If the found instance is hidden and the parent is not hidden go to
; 6124 :       // the first twin which is not hidden.
; 6125 :       if ( lpSearchEntityInstance->u.nInd.bHidden &&

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN22@fnEstablis
	mov	ecx, DWORD PTR _lpSetEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN22@fnEstablis
$LN4@fnEstablis:

; 6126 :            lpSetEntityInstance->u.nInd.bHidden == FALSE )
; 6127 :       {
; 6128 :          while ( lpSearchEntityInstance->u.nInd.bHidden &&

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN6@fnEstablis
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN6@fnEstablis

; 6129 :                  lpSearchEntityInstance->hNextTwin )
; 6130 :          {
; 6131 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 6132 :          }

	jmp	SHORT $LN4@fnEstablis
$LN6@fnEstablis:

; 6133 : 
; 6134 :          // If a non-hidden twin was not found, return to the first twin.
; 6135 :          while ( lpSearchEntityInstance->u.nInd.bHidden &&

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN22@fnEstablis
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN22@fnEstablis

; 6136 :                  lpSearchEntityInstance->hPrevTwin )
; 6137 :          {
; 6138 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 6139 :          }

	jmp	SHORT $LN6@fnEstablis
$LN22@fnEstablis:

; 6140 :       }
; 6141 : 
; 6142 :       lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 6143 :    // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 6144 :    //    SysMessageBox( 0, "fnEstablishCursorForView", "UNSET_CSR", -1 );
; 6145 : 
; 6146 :       lpScanViewEntityCsr  = zGETPTR( lpViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanViewEntityCsr$[ebp], eax

; 6147 :       lpScanEntityInstance = zGETPTR( lpSearchEntityInstance->hParent );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEntityInstance$[ebp], eax
$LN8@fnEstablis:

; 6148 :       while( lpScanViewEntityCsr != lpSetViewEntityCsr )

	mov	ecx, DWORD PTR _lpScanViewEntityCsr$[ebp]
	cmp	ecx, DWORD PTR _lpSetViewEntityCsr$[ebp]
	je	SHORT $LN9@fnEstablis

; 6149 :       {
; 6150 :          lpScanViewEntityCsr->hEntityInstance = zGETHNDL( lpScanEntityInstance );

	mov	edx, DWORD PTR _lpScanEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpScanViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 6151 :       // if ( lpScanViewEntityCsr->hEntityInstance == UNSET_CSR )
; 6152 :       //    SysMessageBox( 0, "fnEstablishCursorForView2", "UNSET_CSR", -1 );
; 6153 : 
; 6154 :          lpScanViewEntityCsr  = zGETPTR( lpScanViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpScanViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanViewEntityCsr$[ebp], eax

; 6155 :          lpScanEntityInstance = zGETPTR( lpScanEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpScanEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEntityInstance$[ebp], eax

; 6156 :       }

	jmp	SHORT $LN8@fnEstablis
$LN9@fnEstablis:

; 6157 :    }

	jmp	SHORT $LN21@fnEstablis
$LN20@fnEstablis:

; 6158 :    else
; 6159 :    {
; 6160 :       // If no cursor found, set cursor to null and recursively call ourself
; 6161 :       // to set our parent.
; 6162 :       lpSearchEntityInstance = 0;

	mov	DWORD PTR _lpSearchEntityInstance$[ebp], 0

; 6163 :       lpViewEntityCsr->hEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+26], 0

; 6164 :       lpScanViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanViewEntityCsr$[ebp], eax

; 6165 :       if ( lpScanViewEntityCsr != lpSetViewEntityCsr )

	mov	eax, DWORD PTR _lpScanViewEntityCsr$[ebp]
	cmp	eax, DWORD PTR _lpSetViewEntityCsr$[ebp]
	je	SHORT $LN21@fnEstablis

; 6166 :       {
; 6167 :          zVIEW lpView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$1[ebp], eax

; 6168 :          SysMessageBox( lpView, "Internal Error",

	push	1
	push	OFFSET $SG15510
	push	OFFSET $SG15511
	mov	eax, DWORD PTR _lpView$1[ebp]
	push	eax
	call	_SysMessageBox@16

; 6169 :                         "(cm) ERROR Unexpected Recursive "
; 6170 :                         "call to fnEstablishCursorForView", 1 );
; 6171 :          fnEstablishCursorForView( lpScanViewEntityCsr );

	mov	ecx, DWORD PTR _lpScanViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN21@fnEstablis:

; 6172 :       }
; 6173 :    }
; 6174 : 
; 6175 :    return( lpSearchEntityInstance );  // return instance set

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
$LN1@fnEstablis:

; 6176 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnEstablishCursorForView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpResetViewEntityCsr$ = -4				; size = 4
_lpViewEntityCsr$ = 8					; size = 4
_fnResetCursorForViewChildren PROC

; 5975 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5976 :    LPVIEWENTITYCSR  lpResetViewEntityCsr;
; 5977 : 
; 5978 :    // First set all the cursors to UNSET.
; 5979 :    for ( lpResetViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetViewEntityCsr$[ebp], eax
	jmp	SHORT $LN4@fnResetCur
$LN2@fnResetCur:

; 5981 :          lpResetViewEntityCsr = zGETPTR( lpResetViewEntityCsr->hNextHier ) )

	mov	edx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetViewEntityCsr$[ebp], eax
$LN4@fnResetCur:

; 5980 :          lpResetViewEntityCsr && lpResetViewEntityCsr->nLevel > lpViewEntityCsr->nLevel;

	cmp	DWORD PTR _lpResetViewEntityCsr$[ebp], 0
	je	SHORT $LN3@fnResetCur
	mov	ecx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	cmp	edx, ecx
	jle	SHORT $LN3@fnResetCur

; 5982 :    {
; 5983 :       lpResetViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	edx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], 1

; 5984 :    // if ( lpResetViewEntityCsr->hEntityInstance == UNSET_CSR )  // happens way too much
; 5985 :    //    SysMessageBox( 0, "fnResetCursorForViewChildren", "UNSET_CSR", -1 );
; 5986 :    }

	jmp	SHORT $LN2@fnResetCur
$LN3@fnResetCur:

; 5987 : 
; 5988 :    // If the root entity cursor is unset then we can't set any
; 5989 :    // child cursors to point to EI's because there are no child EI's.
; 5990 :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR ||

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	je	SHORT $LN6@fnResetCur
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $LN5@fnResetCur
$LN6@fnResetCur:

; 5991 :         lpViewEntityCsr->hEntityInstance == 0 )
; 5992 :    {
; 5993 :       return;

	jmp	SHORT $LN1@fnResetCur
$LN5@fnResetCur:

; 5994 :    }
; 5995 : 
; 5996 :    // We'll have to use a recursive call to set the child entities.  Each call
; 5997 :    // sets the cursors for the immediate children.
; 5998 :    fnSetChildCursors( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnSetChildCursors
	add	esp, 4
$LN1@fnResetCur:

; 5999 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnResetCursorForViewChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpResetViewEntityCsr$ = -4				; size = 4
_lpViewEntityCsr$ = 8					; size = 4
_fnNullCursorForViewChildren PROC

; 6016 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6017 :    LPVIEWENTITYCSR  lpResetViewEntityCsr;
; 6018 : 
; 6019 :    lpResetViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetViewEntityCsr$[ebp], eax
$LN2@fnNullCurs:

; 6020 : 
; 6021 :    while ( lpResetViewEntityCsr &&

	cmp	DWORD PTR _lpResetViewEntityCsr$[ebp], 0
	je	SHORT $LN1@fnNullCurs
	mov	edx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jle	SHORT $LN1@fnNullCurs

; 6022 :            lpResetViewEntityCsr->nLevel > lpViewEntityCsr->nLevel )
; 6023 :    {
; 6024 :       lpResetViewEntityCsr->hEntityInstance = 0;

	mov	eax, DWORD PTR _lpResetViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+26], 0

; 6025 :       lpResetViewEntityCsr = zGETPTR( lpResetViewEntityCsr->hNextHier );

	mov	ecx, DWORD PTR _lpResetViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetViewEntityCsr$[ebp], eax

; 6026 :    }

	jmp	SHORT $LN2@fnNullCurs
$LN1@fnNullCurs:

; 6027 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnNullCursorForViewChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewOI$ = -92					; size = 4
_lpTask$1 = -88						; size = 4
_lpTempViewEntity1$2 = -84				; size = 4
_lpTempViewEntity2$3 = -80				; size = 4
_lpTask$4 = -76						; size = 4
_lpTask$5 = -72						; size = 4
_lpTask$6 = -68						; size = 4
_lpHierRootEntityInstance$7 = -64			; size = 4
_lpTask$8 = -60						; size = 4
_lpTask$9 = -56						; size = 4
_lpParent$10 = -52					; size = 4
tv139 = -48						; size = 4
tv138 = -44						; size = 4
_lpEntityInstance$ = -40				; size = 4
_lpViewCsr$ = -36					; size = 4
_lpViewEntity$ = -32					; size = 4
_lpScopingViewEntity$ = -28				; size = 4
_lpViewEntityCsr$ = -24					; size = 4
_lpWorkViewEntityCsr$ = -20				; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpScopingEntityInstance$ = -8				; size = 4
_bOperationIdxSet$ = -1					; size = 1
_plpReturnTask$ = 8					; size = 4
_ppvReturnViewEntity$ = 12				; size = 4
_plpReturnScopingViewEntity$ = 16			; size = 4
_ppvReturnViewEntityCsr$ = 20				; size = 4
_plpReturnScopingViewEntityCsr$ = 24			; size = 4
_nOperationID$ = 28					; size = 2
_lpView$ = 32						; size = 4
_cpcEntityName$ = 36					; size = 4
_cpcScopingEntity$ = 40					; size = 4
_fnValidateCursorParameters PROC

; 5563 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 5564 :    LPTASK            lpCurrentTask;
; 5565 :    LPVIEWCSR         lpViewCsr;
; 5566 :    LPVIEWOI          lpViewOI;
; 5567 :    LPVIEWENTITY      lpViewEntity;
; 5568 :    LPVIEWENTITY      lpScopingViewEntity;
; 5569 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 5570 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 5571 :    LPVIEWENTITYCSR   lpWorkViewEntityCsr;
; 5572 :    LPENTITYINSTANCE  lpEntityInstance;
; 5573 :    LPENTITYINSTANCE  lpScopingEntityInstance;
; 5574 :    zBOOL             bOperationIdxSet = FALSE;

	mov	BYTE PTR _bOperationIdxSet$[ebp], 0

; 5575 : 
; 5576 :    // If task not active or disabled, return zCALL_ERROR.
; 5577 :    if ( nOperationID == 0 )

	movsx	eax, WORD PTR _nOperationID$[ebp]
	test	eax, eax
	jne	SHORT $LN17@fnValidate

; 5578 :    {
; 5579 :       lpCurrentTask = *plpReturnTask;

	mov	ecx, DWORD PTR _plpReturnTask$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpCurrentTask$[ebp], edx

; 5580 :       if ( fnValidViewCsr( lpCurrentTask, lpView ) == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN19@fnValidate

; 5581 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN19@fnValidate:

; 5582 :    }

	jmp	SHORT $LN18@fnValidate
$LN17@fnValidate:

; 5583 :    else
; 5584 :    {
; 5585 :       if ( (lpCurrentTask = fnOperationCall( nOperationID, lpView,
; 5586 :                                              zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nOperationID$[ebp]
	push	ecx
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN20@fnValidate

; 5587 :       {
; 5588 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN20@fnValidate:

; 5589 :       }
; 5590 : 
; 5591 :       bOperationIdxSet = TRUE;

	mov	BYTE PTR _bOperationIdxSet$[ebp], 1

; 5592 :       *plpReturnTask = lpCurrentTask;

	mov	edx, DWORD PTR _plpReturnTask$[ebp]
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [edx], eax
$LN18@fnValidate:

; 5593 :    }
; 5594 : 
; 5595 :    // Get the view Object Instance for the view.
; 5596 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5597 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5598 : 
; 5599 :    // Validate that the entity exists.
; 5600 :    lpViewEntity    = 0;

	mov	DWORD PTR _lpViewEntity$[ebp], 0

; 5601 :    lpViewEntityCsr = 0;

	mov	DWORD PTR _lpViewEntityCsr$[ebp], 0

; 5602 :    if ( cpcEntityName &&

	cmp	DWORD PTR _cpcEntityName$[ebp], 0
	je	SHORT $LN21@fnValidate
	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN21@fnValidate

; 5603 :         (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 5604 :                                            lpView, cpcEntityName, 0 )) == 0 )
; 5605 :    {
; 5606 :       if ( bOperationIdxSet )

	movzx	edx, BYTE PTR _bOperationIdxSet$[ebp]
	test	edx, edx
	je	SHORT $LN22@fnValidate

; 5607 :          fnOperationReturn( nOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8
$LN22@fnValidate:

; 5608 : 
; 5609 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN21@fnValidate:

; 5610 :    }
; 5611 : 
; 5612 :    // Validate that the entity scoping exists and is valid.
; 5613 :    lpScopingViewEntity    = 0;

	mov	DWORD PTR _lpScopingViewEntity$[ebp], 0

; 5614 :    lpScopingViewEntityCsr = 0;

	mov	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0

; 5615 :    if ( lpViewEntity && (zLONG) cpcScopingEntity != (zLONG) zSCOPE_OI )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$LN23@fnValidate
	cmp	DWORD PTR _cpcScopingEntity$[ebp], 1
	je	$LN23@fnValidate

; 5616 :    {
; 5617 : #if 0 // DGC 1998.8.13 -- Following no longer needed?
; 5618 :       if ( (zLONG) cpcScopingEntity == (zLONG) zSCOPE_OI )
; 5619 :       {
; 5620 :          if ( lpViewOI->bMultipleRootLevels )
; 5621 :             ; // should be ok, continue
; 5622 :          else
; 5623 :          {
; 5624 :             //  "KZOEE105 - Invalid scoping Entity name for View"
; 5625 :             fnIssueCoreError( lpTask, lpView, 8, 105, 0,
; 5626 :                               lpViewEntity->szName, 0 );
; 5627 :             if ( bOperationIdxSet )
; 5628 :                fnOperationReturn( nOperationID, lpCurrentTask );
; 5629 : 
; 5630 :             return( zCALL_ERROR );
; 5631 :          }
; 5632 :       }
; 5633 :       else
; 5634 : #endif
; 5635 : 
; 5636 :       // If the scoping entity is the same as the target entity then we'll
; 5637 :       // just assume that there is no scoping entity.
; 5638 :       if ( cpcScopingEntity && zstrcmp( cpcScopingEntity, cpcEntityName ) == 0 )

	cmp	DWORD PTR _cpcScopingEntity$[ebp], 0
	je	SHORT $LN24@fnValidate
	mov	edx, DWORD PTR _cpcScopingEntity$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN66@fnValidate
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcScopingEntity$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN67@fnValidate
$LN66@fnValidate:
	mov	edx, DWORD PTR _cpcScopingEntity$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN64@fnValidate
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN65@fnValidate
$LN64@fnValidate:
	mov	DWORD PTR tv138[ebp], -1
$LN65@fnValidate:
	mov	eax, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv139[ebp], eax
$LN67@fnValidate:
	cmp	DWORD PTR tv139[ebp], 0
	jne	SHORT $LN24@fnValidate

; 5639 :          cpcScopingEntity = 0;

	mov	DWORD PTR _cpcScopingEntity$[ebp], 0
$LN24@fnValidate:

; 5640 : 
; 5641 :       if ( cpcScopingEntity && cpcScopingEntity[ 0 ] )

	cmp	DWORD PTR _cpcScopingEntity$[ebp], 0
	je	$LN25@fnValidate
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcScopingEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	$LN25@fnValidate

; 5642 :       {
; 5643 :          if ( (lpScopingViewEntity =
; 5644 :                          fnValidViewEntity( &lpScopingViewEntityCsr,
; 5645 :                                             lpView, cpcScopingEntity, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _cpcScopingEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpScopingViewEntity$[ebp], eax
	cmp	DWORD PTR _lpScopingViewEntity$[ebp], 0
	jne	SHORT $LN27@fnValidate

; 5646 :          {
; 5647 :             if ( bOperationIdxSet )

	movzx	edx, BYTE PTR _bOperationIdxSet$[ebp]
	test	edx, edx
	je	SHORT $LN28@fnValidate

; 5648 :                fnOperationReturn( nOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8
$LN28@fnValidate:

; 5649 : 
; 5650 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN27@fnValidate:

; 5651 :          }
; 5652 : 
; 5653 :          lpWorkViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$[ebp], eax
$LN2@fnValidate:

; 5654 :          while ( lpWorkViewEntityCsr &&

	cmp	DWORD PTR _lpWorkViewEntityCsr$[ebp], 0
	je	SHORT $LN3@fnValidate
	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$[ebp]
	cmp	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	je	SHORT $LN3@fnValidate

; 5655 :                  lpWorkViewEntityCsr != lpScopingViewEntityCsr )
; 5656 :          {
; 5657 :             lpWorkViewEntityCsr = zGETPTR( lpWorkViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpWorkViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$[ebp], eax

; 5658 :          }

	jmp	SHORT $LN2@fnValidate
$LN3@fnValidate:

; 5659 : 
; 5660 :          if ( lpWorkViewEntityCsr == 0 )

	cmp	DWORD PTR _lpWorkViewEntityCsr$[ebp], 0
	jne	SHORT $LN29@fnValidate

; 5661 :          {
; 5662 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9[ebp], eax

; 5663 :             //  "KZOEE105 - Invalid scoping Entity name for View"
; 5664 :             fnIssueCoreError( lpTask, lpView, 8, 105, 0,

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	105					; 00000069H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$9[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5665 :                               lpViewEntity->szName, 0 );
; 5666 :             if ( bOperationIdxSet )

	movzx	eax, BYTE PTR _bOperationIdxSet$[ebp]
	test	eax, eax
	je	SHORT $LN30@fnValidate

; 5667 :                fnOperationReturn( nOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8
$LN30@fnValidate:

; 5668 : 
; 5669 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN29@fnValidate:

; 5670 :          }
; 5671 :       }

	jmp	SHORT $LN23@fnValidate
$LN25@fnValidate:

; 5672 :       else
; 5673 :       {
; 5674 :          lpScopingViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingViewEntityCsr$[ebp], eax

; 5675 :          lpScopingViewEntity    = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingViewEntity$[ebp], eax
$LN4@fnValidate:

; 5676 :          while ( lpScopingViewEntityCsr && lpScopingViewEntity->bHidden )

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN23@fnValidate
	mov	ecx, DWORD PTR _lpScopingViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN23@fnValidate

; 5677 :          {
; 5678 :             lpScopingViewEntityCsr = zGETPTR( lpScopingViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingViewEntityCsr$[ebp], eax

; 5679 :             lpScopingViewEntity    = zGETPTR( lpScopingViewEntity->hParent );

	mov	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingViewEntity$[ebp], eax

; 5680 :          }

	jmp	SHORT $LN4@fnValidate
$LN23@fnValidate:

; 5681 :       }
; 5682 :    }
; 5683 : 
; 5684 :    // Validate that operation is consistent with hierarchical mode
; 5685 :    // of cursor.
; 5686 :    if ( lpViewCsr->hHierRootEntityInstance )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	$LN31@fnValidate

; 5687 :    {
; 5688 :       LPENTITYINSTANCE lpHierRootEntityInstance =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpHierRootEntityInstance$7[ebp], eax

; 5689 :                            zGETPTR( lpViewCsr->hHierRootEntityInstance );
; 5690 : 
; 5691 :       if ( nOperationID < iDefineHierarchicalCursor &&

	movsx	ecx, WORD PTR _nOperationID$[ebp]
	cmp	ecx, 190				; 000000beH
	jge	SHORT $LN33@fnValidate
	movsx	edx, WORD PTR _nOperationID$[ebp]
	cmp	edx, 186				; 000000baH
	je	SHORT $LN33@fnValidate

; 5692 :            nOperationID != iGetAbsolutePositionForEntity )
; 5693 :       {
; 5694 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8[ebp], eax

; 5695 :          // "KZOEE264 - Invalid Operation for Hierarchical processing"
; 5696 :          fnIssueCoreError( lpTask, lpView, 8, 264, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	264					; 00000108H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$8[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5697 :          if ( bOperationIdxSet )

	movzx	ecx, BYTE PTR _bOperationIdxSet$[ebp]
	test	ecx, ecx
	je	SHORT $LN34@fnValidate

; 5698 :             fnOperationReturn( nOperationID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movzx	eax, WORD PTR _nOperationID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8
$LN34@fnValidate:

; 5699 : 
; 5700 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN33@fnValidate:

; 5701 :       }
; 5702 : 
; 5703 :       if ( lpHierRootEntityInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpHierRootEntityInstance$7[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN35@fnValidate

; 5704 :       {
; 5705 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$6[ebp], eax

; 5706 :          // "KZOEE267 - Hierarchical cursor is undefined"
; 5707 :          fnIssueCoreError( lpTask, lpView, 8, 267, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	267					; 0000010bH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$6[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5708 :          if ( bOperationIdxSet )

	movzx	ecx, BYTE PTR _bOperationIdxSet$[ebp]
	test	ecx, ecx
	je	SHORT $LN36@fnValidate

; 5709 :             fnOperationReturn( nOperationID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movzx	eax, WORD PTR _nOperationID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8
$LN36@fnValidate:

; 5710 : 
; 5711 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN35@fnValidate:

; 5712 :       }
; 5713 :    }

	jmp	SHORT $LN32@fnValidate
$LN31@fnValidate:

; 5714 :    else
; 5715 :    {
; 5716 :       if ( nOperationID > iDefineHierarchicalCursor )

	movsx	ecx, WORD PTR _nOperationID$[ebp]
	cmp	ecx, 190				; 000000beH
	jle	SHORT $LN32@fnValidate

; 5717 :       {
; 5718 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$5[ebp], eax

; 5719 :          // "KZOEE265 - Invalid Operation for non-Hierarchical processing"
; 5720 :          fnIssueCoreError( lpTask, lpView, 8, 265, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	265					; 00000109H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$5[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5721 :          if ( bOperationIdxSet )

	movzx	eax, BYTE PTR _bOperationIdxSet$[ebp]
	test	eax, eax
	je	SHORT $LN38@fnValidate

; 5722 :             fnOperationReturn( nOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8
$LN38@fnValidate:

; 5723 : 
; 5724 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN32@fnValidate:

; 5725 :       }
; 5726 :    }
; 5727 : 
; 5728 :    // Set View Entity and View Entity Cursor for caller
; 5729 :    if ( ppvReturnViewEntity )

	cmp	DWORD PTR _ppvReturnViewEntity$[ebp], 0
	je	SHORT $LN39@fnValidate

; 5730 :    {
; 5731 :       *ppvReturnViewEntity            = lpViewEntity;

	mov	eax, DWORD PTR _ppvReturnViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax], ecx

; 5732 :       *ppvReturnViewEntityCsr         = lpViewEntityCsr;

	mov	edx, DWORD PTR _ppvReturnViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx], eax
$LN39@fnValidate:

; 5733 :    }
; 5734 : 
; 5735 :    if ( plpReturnScopingViewEntity )

	cmp	DWORD PTR _plpReturnScopingViewEntity$[ebp], 0
	je	SHORT $LN40@fnValidate

; 5736 :    {
; 5737 :       *plpReturnScopingViewEntity     = lpScopingViewEntity;

	mov	ecx, DWORD PTR _plpReturnScopingViewEntity$[ebp]
	mov	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	mov	DWORD PTR [ecx], edx

; 5738 :       *plpReturnScopingViewEntityCsr  = lpScopingViewEntityCsr;

	mov	eax, DWORD PTR _plpReturnScopingViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	DWORD PTR [eax], ecx
$LN40@fnValidate:

; 5739 :    }
; 5740 : 
; 5741 :    // Establish any cursors marked as needing to be established
; 5742 :    // up the parent chain.
; 5743 :    lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0

; 5744 :    if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	$LN41@fnValidate

; 5745 :    {
; 5746 :       lpWorkViewEntityCsr = lpViewEntityCsr;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpWorkViewEntityCsr$[ebp], edx
$LN8@fnValidate:

; 5747 :       for ( ; ; )
; 5748 :       {
; 5749 :          if ( lpWorkViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	eax, DWORD PTR _lpWorkViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	jne	SHORT $LN42@fnValidate

; 5750 :          {
; 5751 :             fnEstablishCursorForView( lpWorkViewEntityCsr );

	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4

; 5752 :             break;

	jmp	SHORT $LN7@fnValidate
$LN42@fnValidate:

; 5753 :          }
; 5754 : 
; 5755 :          if ( lpWorkViewEntityCsr == lpScopingViewEntityCsr )

	mov	edx, DWORD PTR _lpWorkViewEntityCsr$[ebp]
	cmp	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	jne	SHORT $LN43@fnValidate

; 5756 :          {
; 5757 :             break;

	jmp	SHORT $LN7@fnValidate
$LN43@fnValidate:

; 5758 :          }
; 5759 : 
; 5760 :          lpWorkViewEntityCsr = zGETPTR( lpWorkViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpWorkViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$[ebp], eax

; 5761 : 
; 5762 :          if ( lpWorkViewEntityCsr == 0 )

	cmp	DWORD PTR _lpWorkViewEntityCsr$[ebp], 0
	jne	SHORT $LN44@fnValidate

; 5763 :             break;

	jmp	SHORT $LN7@fnValidate
$LN44@fnValidate:

; 5764 :       }

	jmp	SHORT $LN8@fnValidate
$LN7@fnValidate:

; 5765 : 
; 5766 :       // Get Entity Instance pointer for scoping entity instance
; 5767 :       if ( lpScopingViewEntityCsr ) // set cursor for root of view

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN45@fnValidate

; 5768 :          lpScopingEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], eax
	jmp	SHORT $LN46@fnValidate
$LN45@fnValidate:

; 5769 :       else
; 5770 :          lpScopingEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], eax
$LN46@fnValidate:

; 5771 : 
; 5772 :       if ( lpScopingEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 1
	jne	SHORT $LN47@fnValidate

; 5773 :          lpScopingEntityInstance = 0;

	mov	DWORD PTR _lpScopingEntityInstance$[ebp], 0
$LN47@fnValidate:

; 5774 : 
; 5775 :       if ( lpScopingEntityInstance == 0 )

	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 0
	jne	SHORT $LN48@fnValidate
$LN9@fnValidate:

; 5776 :       {
; 5777 :          // If the scoping cursor looks NULL, then we have an either a NULL
; 5778 :          // cursor error or an undefined cursor error. Look up the parent
; 5779 :          // entity instance chain to see if the parent entity instance to
; 5780 :          // the NULL cursor has been deleted. If so then issue the undefined
; 5781 :          // error because issuing a NULL error in this case would be
; 5782 :          // confusing!!!
; 5783 : 
; 5784 :          // See if we can find a parent entity instance to the cursor by
; 5785 :          // giong up the scoping entity cursor chain
; 5786 :          while ( lpScopingViewEntityCsr &&

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN10@fnValidate
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN10@fnValidate

; 5787 :                  lpScopingViewEntityCsr->hEntityInstance == 0 )
; 5788 :          {
; 5789 :             lpScopingViewEntityCsr = zGETPTR( lpScopingViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingViewEntityCsr$[ebp], eax

; 5790 :          }

	jmp	SHORT $LN9@fnValidate
$LN10@fnValidate:

; 5791 : 
; 5792 :          // if no cursor was found for the NULL scoping entity instances
; 5793 :          // parent entity type, then use the ViewParentEntityInstance as
; 5794 :          // the scoping entity instances parent.
; 5795 :          if ( lpScopingViewEntityCsr )

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN49@fnValidate

; 5796 :          {
; 5797 :             lpScopingEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], eax

; 5798 :          }

	jmp	SHORT $LN48@fnValidate
$LN49@fnValidate:

; 5799 :          else
; 5800 :             lpScopingEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], eax
$LN48@fnValidate:

; 5801 :       }
; 5802 : 
; 5803 :       if ( lpScopingEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 1
	jne	SHORT $LN51@fnValidate

; 5804 :          lpScopingEntityInstance = 0;

	mov	DWORD PTR _lpScopingEntityInstance$[ebp], 0
$LN51@fnValidate:

; 5805 : 
; 5806 :       // Validate that the scoping entity instance has not been deleted. Note
; 5807 :       // that lpScopingEntityInstance may in fact be the a NULL
; 5808 :       // Scoping entity instances parent as a result of the above check.
; 5809 :       if ( lpScopingEntityInstance && lpScopingEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 0
	je	$LN52@fnValidate
	mov	ecx, DWORD PTR _lpScopingEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	$LN52@fnValidate
$LN11@fnValidate:

; 5810 :       {
; 5811 :          LPENTITYINSTANCE  lpParent;
; 5812 : 
; 5813 :          // A hidden cursor has been found, the cursor is undefined ONLY if
; 5814 :          // one of its twins is NOT hidden at the highest hidden parent
; 5815 :          // level.
; 5816 :          while ( lpScopingEntityInstance->hParent )

	mov	eax, DWORD PTR _lpScopingEntityInstance$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN13@fnValidate

; 5817 :          {
; 5818 :             lpParent = zGETPTR( lpScopingEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpScopingEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$10[ebp], eax

; 5819 :             if ( lpParent->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpParent$10[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN53@fnValidate

; 5820 :                break;

	jmp	SHORT $LN13@fnValidate
$LN53@fnValidate:

; 5821 : 
; 5822 :             lpScopingEntityInstance = lpParent;

	mov	edx, DWORD PTR _lpParent$10[ebp]
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], edx

; 5823 :          }

	jmp	SHORT $LN11@fnValidate
$LN13@fnValidate:

; 5824 : 
; 5825 :          while ( lpScopingEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpScopingEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN15@fnValidate

; 5826 :             lpScopingEntityInstance =

	mov	ecx, DWORD PTR _lpScopingEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], eax
	jmp	SHORT $LN13@fnValidate
$LN15@fnValidate:

; 5827 :                               zGETPTR( lpScopingEntityInstance->hPrevTwin );
; 5828 : 
; 5829 :          while ( lpScopingEntityInstance )

	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 0
	je	SHORT $LN16@fnValidate

; 5830 :          {
; 5831 :             if ( lpScopingEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpScopingEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN54@fnValidate

; 5832 :                break;

	jmp	SHORT $LN16@fnValidate
$LN54@fnValidate:

; 5833 : 
; 5834 :             lpScopingEntityInstance =

	mov	edx, DWORD PTR _lpScopingEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], eax

; 5835 :                               zGETPTR( lpScopingEntityInstance->hNextTwin );
; 5836 :          }

	jmp	SHORT $LN15@fnValidate
$LN16@fnValidate:

; 5837 : 
; 5838 :          if ( lpScopingEntityInstance )

	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 0
	je	SHORT $LN52@fnValidate

; 5839 :          {
; 5840 :             if ( bOperationIdxSet )

	movzx	ecx, BYTE PTR _bOperationIdxSet$[ebp]
	test	ecx, ecx
	je	SHORT $LN56@fnValidate

; 5841 :                fnOperationReturn( nOperationID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movzx	eax, WORD PTR _nOperationID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8
$LN56@fnValidate:

; 5842 : 
; 5843 :             return( zCURSOR_UNDEFINED );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@fnValidate
$LN52@fnValidate:

; 5844 :          }
; 5845 :       }
; 5846 : 
; 5847 :       // Get Entity Instance pointer
; 5848 :       if ( lpScopingViewEntityCsr && lpScopingEntityInstance == 0 )

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN57@fnValidate
	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 0
	jne	SHORT $LN57@fnValidate

; 5849 :          lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0
	jmp	SHORT $LN58@fnValidate
$LN57@fnValidate:

; 5850 :       else
; 5851 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN58@fnValidate:

; 5852 : 
; 5853 :       // Now make sure a cursor exists for the view entity
; 5854 :       if ( lpEntityInstance == 0 &&
; 5855 :            nOperationID != iSetCursorFirstEntity           &&
; 5856 :            nOperationID != iSetCursorFirstEntityByAttr     &&
; 5857 :            nOperationID != iSetCursorFirstEntityByString   &&
; 5858 :            nOperationID != iSetCursorFirstEntityByInteger  &&
; 5859 :            nOperationID != iSetCursorFirstEntityByDecimal  &&
; 5860 :            nOperationID != iSetCursorFirstEntityByEntityCs &&
; 5861 :            nOperationID != iSetCursorFirstSelectedEntity   &&
; 5862 :            nOperationID != iSetAllSelectStatesForEntity    &&
; 5863 :            nOperationID != iSetEntityCursor                &&
; 5864 :            nOperationID != iSetCursorLastEntity            &&
; 5865 :            nOperationID != iGetRelativeEntityNumber        &&

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	$LN41@fnValidate
	movsx	eax, WORD PTR _nOperationID$[ebp]
	cmp	eax, 152				; 00000098H
	je	$LN41@fnValidate
	movsx	ecx, WORD PTR _nOperationID$[ebp]
	cmp	ecx, 176				; 000000b0H
	je	$LN41@fnValidate
	movsx	edx, WORD PTR _nOperationID$[ebp]
	cmp	edx, 170				; 000000aaH
	je	$LN41@fnValidate
	movsx	eax, WORD PTR _nOperationID$[ebp]
	cmp	eax, 172				; 000000acH
	je	$LN41@fnValidate
	movsx	ecx, WORD PTR _nOperationID$[ebp]
	cmp	ecx, 174				; 000000aeH
	je	$LN41@fnValidate
	movsx	edx, WORD PTR _nOperationID$[ebp]
	cmp	edx, 178				; 000000b2H
	je	$LN41@fnValidate
	movsx	eax, WORD PTR _nOperationID$[ebp]
	cmp	eax, 180				; 000000b4H
	je	$LN41@fnValidate
	movsx	ecx, WORD PTR _nOperationID$[ebp]
	cmp	ecx, 113				; 00000071H
	je	$LN41@fnValidate
	movsx	edx, WORD PTR _nOperationID$[ebp]
	cmp	edx, 184				; 000000b8H
	je	SHORT $LN41@fnValidate
	movsx	eax, WORD PTR _nOperationID$[ebp]
	cmp	eax, 153				; 00000099H
	je	SHORT $LN41@fnValidate
	movsx	ecx, WORD PTR _nOperationID$[ebp]
	cmp	ecx, 183				; 000000b7H
	je	SHORT $LN41@fnValidate
	movsx	edx, WORD PTR _nOperationID$[ebp]
	cmp	edx, 112				; 00000070H
	je	SHORT $LN41@fnValidate

; 5866 :            nOperationID != iGetSelectStateOfEntity )
; 5867 :       {
; 5868 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$4[ebp], eax

; 5869 :          //  "KZOEE253 - Entity cursor is NULL"
; 5870 :          fnIssueCoreError( lpTask, lpView, 8, 253, 0,

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	253					; 000000fdH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$4[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5871 :                            lpViewEntity->szName, 0 );
; 5872 :          if ( bOperationIdxSet )

	movzx	edx, BYTE PTR _bOperationIdxSet$[ebp]
	test	edx, edx
	je	SHORT $LN60@fnValidate

; 5873 :             fnOperationReturn( nOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8
$LN60@fnValidate:

; 5874 : 
; 5875 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN41@fnValidate:

; 5876 :       }
; 5877 :    }
; 5878 : 
; 5879 :    // Finally, make sure that the target entity instance
; 5880 :    // version indicator matches the scoping entity instance
; 5881 :    // version indicator. If not, then the target entity instance
; 5882 :    // is versioned and the scoping entity is not versioned. The target
; 5883 :    // entity instance must be set to the current version prior to
; 5884 :    // any normal cursor navigation can continue. If the indicators match,
; 5885 :    // then navigation can continue regardless of whether the target
; 5886 :    // and scoping entities are on a current or previous version.
; 5887 :    if ( lpEntityInstance && lpScopingEntityInstance &&
; 5888 :         lpEntityInstance->hNextVsn &&

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN61@fnValidate
	cmp	DWORD PTR _lpScopingEntityInstance$[ebp], 0
	je	$LN61@fnValidate
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	$LN61@fnValidate
	mov	eax, DWORD PTR _lpScopingEntityInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	jne	SHORT $LN61@fnValidate

; 5889 :         lpScopingEntityInstance->hNextVsn == 0 )
; 5890 :    {
; 5891 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 5892 :       LPVIEWENTITY lpTempViewEntity1 =

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntity1$2[ebp], eax

; 5893 :                            zGETPTR( lpScopingViewEntityCsr->hViewEntity );
; 5894 :       LPVIEWENTITY lpTempViewEntity2 =

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntity2$3[ebp], eax

; 5895 :                            zGETPTR( lpViewEntityCsr->hViewEntity );
; 5896 : 
; 5897 :       // NOTE: This check is NOT BULLETPROOF, It needs some work to
; 5898 :       // Accurately determine a versioning mismatch!!!
; 5899 : 
; 5900 :       //  "KZOEE257 - Version mismatch between scoping and target "
; 5901 :       //  "           Entities"
; 5902 :       fnIssueCoreError( lpTask, lpView, 8, 257, 0,

	mov	ecx, DWORD PTR _lpTempViewEntity2$3[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpTempViewEntity1$2[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	257					; 00000101H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5903 :                         lpTempViewEntity1->szName,
; 5904 :                         lpTempViewEntity2->szName );
; 5905 :       if ( bOperationIdxSet )

	movzx	edx, BYTE PTR _bOperationIdxSet$[ebp]
	test	edx, edx
	je	SHORT $LN62@fnValidate

; 5906 :          fnOperationReturn( nOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8
$LN62@fnValidate:

; 5907 : 
; 5908 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnValidate
$LN61@fnValidate:

; 5909 :    }
; 5910 : 
; 5911 :    // Everything is AOK, return
; 5912 :    return( 0 );

	xor	eax, eax
$LN1@fnValidate:

; 5913 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidateCursorParameters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpOwningTask$1 = -48					; size = 4
_lpViewOI$2 = -44					; size = 4
_lpView$3 = -40						; size = 4
_hViewEntity$ = -36					; size = 4
tv191 = -32						; size = 4
_hInstance$4 = -28					; size = 4
tv77 = -24						; size = 4
_lpPickSelectedInstance$ = -20				; size = 4
_lpEntityInstance$5 = -16				; size = 4
_lpPrevSelectedInstance$ = -12				; size = 4
_lpSrchSelectedInstance$ = -8				; size = 4
_nRC$ = -4						; size = 2
_lpViewCsr$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_hEntityInstance$ = 16					; size = 4
_nFunction$ = 20					; size = 2
_fnSelectedInstanceFarbler PROC

; 5345 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 5346 :    LPSELECTEDINSTANCE lpSrchSelectedInstance;
; 5347 :    LPSELECTEDINSTANCE lpPrevSelectedInstance;
; 5348 :    LPSELECTEDINSTANCE lpPickSelectedInstance;
; 5349 :    LPVIEWENTITY       hViewEntity = zGETHNDL( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewEntity$[ebp], eax

; 5350 :    zSHORT             nRC;
; 5351 : 
; 5352 :    lpSrchSelectedInstance = zGETPTR( lpViewCsr->hFirstSelectedInstance );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], eax

; 5353 :    lpPrevSelectedInstance = 0;

	mov	DWORD PTR _lpPrevSelectedInstance$[ebp], 0

; 5354 :    nRC = 0;    // default to not successful

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN2@fnSelected:

; 5355 : 
; 5356 :    // Scan through the SelectedInstance chain.
; 5357 :    while ( lpSrchSelectedInstance )

	cmp	DWORD PTR _lpSrchSelectedInstance$[ebp], 0
	je	$LN3@fnSelected

; 5358 :    {
; 5359 :       if ( hEntityInstance == lpSrchSelectedInstance->xEntityInstance &&

	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	jne	$LN8@fnSelected
	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR _hViewEntity$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	$LN8@fnSelected

; 5360 :            hViewEntity == lpSrchSelectedInstance->hViewEntity )
; 5361 :       {
; 5362 :          LPENTITYINSTANCE lpEntityInstance = zGETPTR( hEntityInstance );

	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$5[ebp], eax

; 5363 : 
; 5364 :          // We have found the SelectedInstance, currently in the chain
; 5365 :          switch ( nFunction )

	movsx	eax, WORD PTR _nFunction$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 1
	je	SHORT $LN9@fnSelected
	cmp	DWORD PTR tv77[ebp], 2
	je	$LN17@fnSelected
	cmp	DWORD PTR tv77[ebp], 3
	je	$LN23@fnSelected
	jmp	$LN8@fnSelected
$LN9@fnSelected:

; 5366 :          {
; 5367 :             case 1: // search function
; 5368 :                if ( lpEntityInstance->nTableID != iEntityInstance ||

	mov	ecx, DWORD PTR _lpEntityInstance$5[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	edx, 10024				; 00002728H
	jne	SHORT $LN12@fnSelected
	mov	eax, DWORD PTR _lpEntityInstance$5[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN10@fnSelected
$LN12@fnSelected:

; 5369 :                     lpEntityInstance->u.nInd.bHidden )
; 5370 :                {
; 5371 :                   // We've found the selected instance and the
; 5372 :                   // instance is either hidden or invalid, delete the
; 5373 :                   // select instance and pretend we never found it
; 5374 :                   if ( lpPrevSelectedInstance )

	cmp	DWORD PTR _lpPrevSelectedInstance$[ebp], 0
	je	SHORT $LN13@fnSelected

; 5375 :                   {
; 5376 :                      lpPrevSelectedInstance->hNextSelectedInstance =

	mov	edx, DWORD PTR _lpPrevSelectedInstance$[ebp]
	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx

; 5377 :                         lpSrchSelectedInstance->hNextSelectedInstance;
; 5378 :                      lpPickSelectedInstance =

	mov	edx, DWORD PTR _lpPrevSelectedInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPickSelectedInstance$[ebp], eax

; 5379 :                         zGETPTR( lpPrevSelectedInstance->hNextSelectedInstance );
; 5380 :                   }

	jmp	SHORT $LN14@fnSelected
$LN13@fnSelected:

; 5381 :                   else
; 5382 :                   {
; 5383 :                      lpViewCsr->hFirstSelectedInstance =

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+42], eax

; 5384 :                         lpSrchSelectedInstance->hNextSelectedInstance;
; 5385 :                      lpPickSelectedInstance =

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPickSelectedInstance$[ebp], eax
$LN14@fnSelected:

; 5386 :                         zGETPTR( lpViewCsr->hFirstSelectedInstance );
; 5387 :                   }
; 5388 : 
; 5389 :                   fnFreeDataspace( lpSrchSelectedInstance );

	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 5390 :                   nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx

; 5391 : 
; 5392 :                   // Error message?
; 5393 :                }

	jmp	SHORT $LN11@fnSelected
$LN10@fnSelected:

; 5394 :                else
; 5395 :                {
; 5396 :                   // find is successful, make sure the instance is selected
; 5397 :                   // for the requested select set
; 5398 :                   if ( lpViewCsr->nCurrentSelectSet &

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	movsx	eax, WORD PTR [edx+36]
	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	movsx	edx, WORD PTR [ecx+6]
	and	eax, edx
	je	SHORT $LN15@fnSelected

; 5399 :                            lpSrchSelectedInstance->nSelectSet )
; 5400 :                   {
; 5401 :                      nRC = 1; // find was successful

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 5402 :                   }

	jmp	SHORT $LN11@fnSelected
$LN15@fnSelected:

; 5403 :                   else
; 5404 :                      nRC = 0; // find was un-successful

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN11@fnSelected:

; 5405 :                }
; 5406 : 
; 5407 :                break;

	jmp	$LN8@fnSelected
$LN17@fnSelected:

; 5408 : 
; 5409 :             case 2: // add function
; 5410 :                if ( lpEntityInstance->nTableID != iEntityInstance ||

	mov	edx, DWORD PTR _lpEntityInstance$5[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10024				; 00002728H
	jne	SHORT $LN20@fnSelected
	mov	ecx, DWORD PTR _lpEntityInstance$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN18@fnSelected
$LN20@fnSelected:

; 5411 :                     lpEntityInstance->u.nInd.bHidden )
; 5412 :                {
; 5413 :                   // Drop from chain.
; 5414 :                   if ( lpPrevSelectedInstance )

	cmp	DWORD PTR _lpPrevSelectedInstance$[ebp], 0
	je	SHORT $LN21@fnSelected

; 5415 :                   {
; 5416 :                      lpPrevSelectedInstance->hNextSelectedInstance=

	mov	eax, DWORD PTR _lpPrevSelectedInstance$[ebp]
	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+2], edx

; 5417 :                         lpSrchSelectedInstance->hNextSelectedInstance;
; 5418 :                      lpPickSelectedInstance =

	mov	eax, DWORD PTR _lpPrevSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPickSelectedInstance$[ebp], eax

; 5419 :                         zGETPTR( lpPrevSelectedInstance->hNextSelectedInstance );
; 5420 :                   }

	jmp	SHORT $LN22@fnSelected
$LN21@fnSelected:

; 5421 :                   else
; 5422 :                   {
; 5423 :                      lpViewCsr->hFirstSelectedInstance =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+42], ecx

; 5424 :                         lpSrchSelectedInstance->hNextSelectedInstance;
; 5425 :                      lpPickSelectedInstance =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPickSelectedInstance$[ebp], eax
$LN22@fnSelected:

; 5426 :                         zGETPTR( lpViewCsr->hFirstSelectedInstance );
; 5427 :                   }
; 5428 : 
; 5429 :                   fnFreeDataspace( lpSrchSelectedInstance );

	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 5430 :                   nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx

; 5431 : 
; 5432 :                   // Error message, if any, should go in next switch statement.
; 5433 :                }

	jmp	SHORT $LN19@fnSelected
$LN18@fnSelected:

; 5434 :                else
; 5435 :                {
; 5436 :                   lpSrchSelectedInstance->nSelectSet |=

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	movsx	eax, WORD PTR [edx+6]
	or	eax, ecx
	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	WORD PTR [ecx+6], ax

; 5437 :                                                 lpViewCsr->nCurrentSelectSet;
; 5438 :                   nRC = 2;

	mov	edx, 2
	mov	WORD PTR _nRC$[ebp], dx
$LN19@fnSelected:

; 5439 :                }
; 5440 : 
; 5441 :                break;

	jmp	SHORT $LN8@fnSelected
$LN23@fnSelected:

; 5442 : 
; 5443 :             case 3: // delete function
; 5444 :                // Drop from chain.
; 5445 :                lpSrchSelectedInstance->nSelectSet &=

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	mov	edx, 65535				; 0000ffffH
	sub	edx, ecx
	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	and	ecx, edx
	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	WORD PTR [edx+6], cx

; 5446 :                                      (0xffff - lpViewCsr->nCurrentSelectSet);
; 5447 :                if ( lpSrchSelectedInstance->nSelectSet == 0 )

	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	test	ecx, ecx
	jne	SHORT $LN24@fnSelected

; 5448 :                {
; 5449 :                   if ( lpPrevSelectedInstance )

	cmp	DWORD PTR _lpPrevSelectedInstance$[ebp], 0
	je	SHORT $LN25@fnSelected

; 5450 :                      lpPrevSelectedInstance->hNextSelectedInstance=

	mov	edx, DWORD PTR _lpPrevSelectedInstance$[ebp]
	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx
	jmp	SHORT $LN26@fnSelected
$LN25@fnSelected:

; 5451 :                         lpSrchSelectedInstance->hNextSelectedInstance;
; 5452 :                   else
; 5453 :                      lpViewCsr->hFirstSelectedInstance =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+42], ecx
$LN26@fnSelected:

; 5454 :                         lpSrchSelectedInstance->hNextSelectedInstance;
; 5455 : 
; 5456 :                   fnFreeDataspace( lpSrchSelectedInstance );

	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$LN24@fnSelected:

; 5457 :                }
; 5458 : 
; 5459 :                nRC = 1; // deselect was successful

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN8@fnSelected:

; 5460 :                break;
; 5461 :          }
; 5462 :       }
; 5463 : 
; 5464 :       // -1 occurs on a search/add function and the EntityInstance is
; 5465 :       // hidden.
; 5466 :       if ( nRC == -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN27@fnSelected

; 5467 :       {
; 5468 :          lpSrchSelectedInstance = lpPickSelectedInstance;

	mov	edx, DWORD PTR _lpPickSelectedInstance$[ebp]
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], edx

; 5469 :          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 5470 :       }

	jmp	SHORT $LN28@fnSelected
$LN27@fnSelected:

; 5471 :       else
; 5472 :       {
; 5473 :          if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN29@fnSelected

; 5474 :             break;

	jmp	SHORT $LN3@fnSelected
$LN29@fnSelected:

; 5475 : 
; 5476 :          lpPrevSelectedInstance = lpSrchSelectedInstance;

	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	DWORD PTR _lpPrevSelectedInstance$[ebp], edx

; 5477 :          lpSrchSelectedInstance =

	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], eax
$LN28@fnSelected:

; 5478 :             zGETPTR( lpSrchSelectedInstance->hNextSelectedInstance );
; 5479 :       }
; 5480 :    }

	jmp	$LN2@fnSelected
$LN3@fnSelected:

; 5481 : 
; 5482 :    // If nRC is 0, then the EntityInstance is not currently in the chain.
; 5483 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN30@fnSelected

; 5484 :    {
; 5485 :       LPTASK   lpOwningTask;
; 5486 :       LPVIEWOI lpViewOI;
; 5487 :       zPVOID   hInstance;
; 5488 : 
; 5489 :       switch ( nFunction )

	movsx	eax, WORD PTR _nFunction$[ebp]
	mov	DWORD PTR tv191[ebp], eax
	cmp	DWORD PTR tv191[ebp], 2
	je	SHORT $LN32@fnSelected
	cmp	DWORD PTR tv191[ebp], 3
	je	$LN37@fnSelected
	jmp	$LN30@fnSelected

; 5490 :       {
; 5491 :          case 1: // search function
; 5492 :             break;

	jmp	$LN30@fnSelected
$LN32@fnSelected:

; 5493 : 
; 5494 :          case 2: // add function
; 5495 :             //
; 5496 :             // Adding to the SelectedInstance chain...
; 5497 :             //
; 5498 :             lpViewOI     = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$2[ebp], eax

; 5499 :             lpOwningTask = zGETPTR( lpViewOI->hTask );

	mov	eax, DWORD PTR _lpViewOI$2[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$1[ebp], eax

; 5500 : 
; 5501 :             hInstance = fnAllocDataspace( lpOwningTask->hFirstDataHeader,

	push	10033					; 00002731H
	push	0
	push	1
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpOwningTask$1[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hInstance$4[ebp], eax

; 5502 :                                           sizeof( SelectedInstanceRecord ),
; 5503 :                                           1, 0, iSelectedInstance );
; 5504 :             lpSrchSelectedInstance = zGETPTR( hInstance );

	mov	ecx, DWORD PTR _hInstance$4[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], eax

; 5505 :             if ( lpSrchSelectedInstance )

	cmp	DWORD PTR _lpSrchSelectedInstance$[ebp], 0
	je	SHORT $LN33@fnSelected

; 5506 :             {
; 5507 :                if ( lpPrevSelectedInstance )

	cmp	DWORD PTR _lpPrevSelectedInstance$[ebp], 0
	je	SHORT $LN35@fnSelected

; 5508 :                   lpPrevSelectedInstance->hNextSelectedInstance = hInstance;

	mov	edx, DWORD PTR _lpPrevSelectedInstance$[ebp]
	mov	eax, DWORD PTR _hInstance$4[ebp]
	mov	DWORD PTR [edx+2], eax
	jmp	SHORT $LN36@fnSelected
$LN35@fnSelected:

; 5509 :                else
; 5510 :                   lpViewCsr->hFirstSelectedInstance = hInstance;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _hInstance$4[ebp]
	mov	DWORD PTR [ecx+42], edx
$LN36@fnSelected:

; 5511 : 
; 5512 :                lpSrchSelectedInstance->hViewEntity     = hViewEntity;

	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR _hViewEntity$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 5513 :                lpSrchSelectedInstance->xEntityInstance = hEntityInstance;

	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+12], eax

; 5514 :                lpSrchSelectedInstance->nSelectSet = lpViewCsr->nCurrentSelectSet;

	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	ax, WORD PTR [edx+36]
	mov	WORD PTR [ecx+6], ax

; 5515 : 
; 5516 :                nRC = 1; // select was successful

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 5517 :             }

	jmp	SHORT $LN34@fnSelected
$LN33@fnSelected:

; 5518 :             else
; 5519 :             {
; 5520 :                // "KZOEE012 - Error allocating memory"
; 5521 :                zVIEW lpView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$3[ebp], eax

; 5522 :                fnIssueCoreError( zGETPTR( lpView->hTask ), lpView,

	push	0
	push	0
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	mov	ecx, DWORD PTR _lpView$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$3[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5523 :                                  20, 12, 0, 0, 0 );
; 5524 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSelected
$LN34@fnSelected:

; 5525 :             }
; 5526 : 
; 5527 :             break;

	jmp	SHORT $LN30@fnSelected
$LN37@fnSelected:

; 5528 : 
; 5529 :          case 3: // delete function
; 5530 :             nRC = 2;

	mov	ecx, 2
	mov	WORD PTR _nRC$[ebp], cx
$LN30@fnSelected:

; 5531 :             break;
; 5532 :       }
; 5533 :    }
; 5534 : 
; 5535 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSelected:

; 5536 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSelectedInstanceFarbler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewEntityCsrForDomain$1 = -32			; size = 4
_lpViewEntityCsrForDomain$2 = -28			; size = 4
_lpViewEntityCsrForDomain$3 = -24			; size = 4
_lpViewEntityCsrForDomain$4 = -20			; size = 4
_lpViewEntityCsrDA$5 = -16				; size = 4
tv129 = -12						; size = 4
tv94 = -8						; size = 4
_nRC$ = -4						; size = 2
_vAttrView$ = 8						; size = 4
_lQualRequest$ = 12					; size = 4
_lQualOperator$ = 16					; size = 4
_pQualValue$ = 20					; size = 4
_lpSearchEntityInstance$ = 24				; size = 4
_lpViewEntityCsr$ = 28					; size = 4
_lpViewAttrib$ = 32					; size = 4
_lpSrcEntityInstance$ = 36				; size = 4
_lpSrcViewEntityCsr$ = 40				; size = 4
_lpSrcViewAttrib$ = 44					; size = 4
_cpcContextName$ = 48					; size = 4
_lpCurrentTask$ = 52					; size = 4
_fnQualifiedInstance PROC

; 5191 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi

; 5192 :    zSHORT   nRC;
; 5193 : 
; 5194 :    if ( lpViewAttrib && lpViewAttrib->szDerivedOper[ 0 ] &&
; 5195 :         lQualRequest != zQUAL_ENTITYCSR &&
; 5196 :         lQualRequest != zQUAL_ENTITYATTR &&

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN4@fnQualifie
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+213]
	test	eax, eax
	je	$LN4@fnQualifie
	cmp	DWORD PTR _lQualRequest$[ebp], 2097152	; 00200000H
	je	SHORT $LN4@fnQualifie
	cmp	DWORD PTR _lQualRequest$[ebp], 4096	; 00001000H
	je	SHORT $LN4@fnQualifie
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [ecx+198], 0
	je	SHORT $LN5@fnQualifie
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN5@fnQualifie
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN4@fnQualifie
$LN5@fnQualifie:

; 5197 :         !(lpViewAttrib->hDomain && cpcContextName && cpcContextName[ 0 ]) )
; 5198 :    {
; 5199 :       LPVIEWENTITYCSR lpViewEntityCsrDA =

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsrDA$5[ebp], eax

; 5200 :                         fnEstablishViewForInstance( vAttrView, 0,
; 5201 :                                                     lpSearchEntityInstance );
; 5202 :       nRC = fnInvokeDerivedOperation( vAttrView,

	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsrDA$5[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 5203 :                                       zGETPTR( lpViewEntityCsrDA->hViewEntity ),
; 5204 :                                       lpViewAttrib,
; 5205 :                                       lpCurrentTask, zDERIVED_GET );
; 5206 :       if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN4@fnQualifie

; 5207 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnQualifie
$LN4@fnQualifie:

; 5208 :    }
; 5209 : 
; 5210 :    switch ( lQualRequest )

	mov	edx, DWORD PTR _lQualRequest$[ebp]
	mov	DWORD PTR tv94[ebp], edx
	cmp	DWORD PTR tv94[ebp], 2048		; 00000800H
	jg	SHORT $LN21@fnQualifie
	cmp	DWORD PTR tv94[ebp], 2048		; 00000800H
	je	$LN12@fnQualifie
	cmp	DWORD PTR tv94[ebp], 256		; 00000100H
	je	SHORT $LN8@fnQualifie
	cmp	DWORD PTR tv94[ebp], 512		; 00000200H
	je	$LN10@fnQualifie
	cmp	DWORD PTR tv94[ebp], 1024		; 00000400H
	je	$LN14@fnQualifie
	jmp	$LN2@fnQualifie
$LN21@fnQualifie:
	cmp	DWORD PTR tv94[ebp], 4096		; 00001000H
	je	$LN17@fnQualifie
	cmp	DWORD PTR tv94[ebp], 2097152		; 00200000H
	je	$LN16@fnQualifie
	cmp	DWORD PTR tv94[ebp], 8388608		; 00800000H
	je	SHORT $LN7@fnQualifie
	jmp	$LN2@fnQualifie
$LN7@fnQualifie:

; 5211 :    {
; 5212 :       case zQUAL_ENTITYKEY:
; 5213 :          return( lpSearchEntityInstance->ulKey == *((zPULONG) pQualValue) );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	mov	edx, DWORD PTR [eax+50]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN19@fnQualifie
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN20@fnQualifie
$LN19@fnQualifie:
	mov	DWORD PTR tv129[ebp], 0
$LN20@fnQualifie:
	mov	ax, WORD PTR tv129[ebp]
	jmp	$LN1@fnQualifie
$LN8@fnQualifie:

; 5214 : 
; 5215 :       case zQUAL_INTEGER:
; 5216 :          if ( lpViewAttrib->hDomain && cpcContextName && *cpcContextName )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	je	SHORT $LN9@fnQualifie
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN9@fnQualifie
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@fnQualifie

; 5217 :          {
; 5218 :             LPVIEWENTITYCSR lpViewEntityCsrForDomain =

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsrForDomain$4[ebp], eax

; 5219 :                         fnEstablishViewForInstance( vAttrView, 0,
; 5220 :                                                     lpSearchEntityInstance );
; 5221 :             nRC = fnCompareAttributeToVariable( vAttrView,

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	push	0
	push	76					; 0000004cH
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsrForDomain$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax

; 5222 :                                                 lpViewEntityCsrForDomain,
; 5223 :                                                 lpViewAttrib, pQualValue,
; 5224 :                                                 zTYPE_INTEGER, 0,
; 5225 :                                                 cpcContextName,
; 5226 :                                                 lpCurrentTask, 0 );
; 5227 :             return( fnQualOperatorMatchesRC( lQualOperator, nRC ) );

	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	mov	eax, DWORD PTR _lQualOperator$[ebp]
	push	eax
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	jmp	$LN1@fnQualifie
$LN9@fnQualifie:

; 5228 :          }
; 5229 : 
; 5230 :          return( fnIntegerMatchesAttributeValue( *((zPLONG) pQualValue),

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lQualOperator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnIntegerMatchesAttributeValue
	add	esp, 16					; 00000010H
	jmp	$LN1@fnQualifie
$LN10@fnQualifie:

; 5231 :                                                  lQualOperator,
; 5232 :                                                  lpSearchEntityInstance,
; 5233 :                                                  lpViewAttrib ) );
; 5234 : 
; 5235 :       case zQUAL_DECIMAL:
; 5236 :          if ( lpViewAttrib->hDomain && cpcContextName && *cpcContextName )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	je	SHORT $LN11@fnQualifie
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN11@fnQualifie
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN11@fnQualifie

; 5237 :          {
; 5238 :             LPVIEWENTITYCSR lpViewEntityCsrForDomain =

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsrForDomain$3[ebp], eax

; 5239 :                         fnEstablishViewForInstance( vAttrView, 0,
; 5240 :                                                     lpSearchEntityInstance );
; 5241 :             nRC = fnCompareAttributeToVariable( vAttrView,

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	push	0
	push	77					; 0000004dH
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsrForDomain$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax

; 5242 :                                                 lpViewEntityCsrForDomain,
; 5243 :                                                 lpViewAttrib, pQualValue,
; 5244 :                                                 zTYPE_DECIMAL, 0,
; 5245 :                                                 cpcContextName, lpCurrentTask, 0 );
; 5246 :             return( fnQualOperatorMatchesRC( lQualOperator, nRC ) );

	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	mov	eax, DWORD PTR _lQualOperator$[ebp]
	push	eax
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	jmp	$LN1@fnQualifie
$LN11@fnQualifie:

; 5247 :          }
; 5248 : 
; 5249 :          return( fnDecimalMatchesAttributeValue( *((zPDECIMAL) pQualValue),

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lQualOperator$[ebp]
	push	eax
	mov	esi, DWORD PTR _pQualValue$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	call	_fnDecimalMatchesAttributeValue
	add	esp, 52					; 00000034H
	jmp	$LN1@fnQualifie
$LN12@fnQualifie:

; 5250 :                                                  lQualOperator,
; 5251 :                                                  lpSearchEntityInstance,
; 5252 :                                                  lpViewAttrib ) );
; 5253 : 
; 5254 :       case zQUAL_DATETIME:
; 5255 :          if ( lpViewAttrib->hDomain && cpcContextName && *cpcContextName )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [ecx+198], 0
	je	SHORT $LN13@fnQualifie
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN13@fnQualifie
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN13@fnQualifie

; 5256 :          {
; 5257 :             LPVIEWENTITYCSR lpViewEntityCsrForDomain =

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vAttrView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsrForDomain$2[ebp], eax

; 5258 :                         fnEstablishViewForInstance( vAttrView, 0,
; 5259 :                                                     lpSearchEntityInstance );
; 5260 :             nRC = fnCompareAttributeToVariable( vAttrView,

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	push	0
	push	84					; 00000054H
	mov	edx, DWORD PTR _pQualValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsrForDomain$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _vAttrView$[ebp]
	push	edx
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax

; 5261 :                                                 lpViewEntityCsrForDomain,
; 5262 :                                                 lpViewAttrib, pQualValue,
; 5263 :                                                 zTYPE_DATETIME,
; 5264 :                                                 0, cpcContextName,
; 5265 :                                                 lpCurrentTask, 0 );
; 5266 :             return( fnQualOperatorMatchesRC( lQualOperator, nRC ) );

	movzx	eax, WORD PTR _nRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lQualOperator$[ebp]
	push	ecx
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	jmp	$LN1@fnQualifie
$LN13@fnQualifie:

; 5267 :          }
; 5268 : 
; 5269 :          return( fnDateTimeMatchesAttributeValue( (LPDTINTERNAL) pQualValue,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lQualOperator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pQualValue$[ebp]
	push	edx
	call	_fnDateTimeMatchesAttributeValue@16
	jmp	$LN1@fnQualifie
$LN14@fnQualifie:

; 5270 :                                                   lQualOperator,
; 5271 :                                                   lpSearchEntityInstance,
; 5272 :                                                   lpViewAttrib ) );
; 5273 : 
; 5274 :       case zQUAL_STRING:
; 5275 :          if ( lpViewAttrib->hDomain && cpcContextName && *cpcContextName )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	je	SHORT $LN15@fnQualifie
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN15@fnQualifie
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN15@fnQualifie

; 5276 :          {
; 5277 :             LPVIEWENTITYCSR lpViewEntityCsrForDomain =

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsrForDomain$1[ebp], eax

; 5278 :                         fnEstablishViewForInstance( vAttrView, 0,
; 5279 :                                                     lpSearchEntityInstance );
; 5280 :             nRC = fnCompareAttributeToVariable( vAttrView,

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsrForDomain$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_fnCompareAttributeToVariable
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax

; 5281 :                                                 lpViewEntityCsrForDomain,
; 5282 :                                                 lpViewAttrib, pQualValue,
; 5283 :                                                 zTYPE_STRING,
; 5284 :                                                 0, cpcContextName,
; 5285 :                                                 lpCurrentTask, 0 );
; 5286 :             return( fnQualOperatorMatchesRC( lQualOperator, nRC ) );

	movzx	edx, WORD PTR _nRC$[ebp]
	push	edx
	mov	eax, DWORD PTR _lQualOperator$[ebp]
	push	eax
	call	_fnQualOperatorMatchesRC
	add	esp, 8
	jmp	SHORT $LN1@fnQualifie
$LN15@fnQualifie:

; 5287 :          }
; 5288 : 
; 5289 :          return( fnStringMatchesAttributeValue( (zCPCHAR) pQualValue,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lQualOperator$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	call	_fnStringMatchesAttributeValue
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@fnQualifie
$LN16@fnQualifie:

; 5290 :                                                 lQualOperator,
; 5291 :                                                 lpSearchEntityInstance,
; 5292 :                                                 lpViewAttrib ) );
; 5293 : 
; 5294 :       case zQUAL_ENTITYCSR:
; 5295 :          return( fnInstanceMatchesInstance( lpSrcEntityInstance,

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	call	_fnInstanceMatchesInstance
	add	esp, 8
	jmp	SHORT $LN1@fnQualifie
$LN17@fnQualifie:

; 5296 :                                             lpSearchEntityInstance ) );
; 5297 : 
; 5298 :       case zQUAL_ENTITYATTR:
; 5299 :          return( fnAttrValueMatchesAttrValue( vAttrView,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lQualOperator$[ebp]
	push	edx
	mov	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_fnAttrValueMatchesAttrValue
	add	esp, 36					; 00000024H
	jmp	SHORT $LN1@fnQualifie
$LN2@fnQualifie:

; 5300 :                                               lQualOperator,
; 5301 :                                               lpSrcViewEntityCsr,
; 5302 :                                               lpSrcEntityInstance,
; 5303 :                                               lpSrcViewAttrib,
; 5304 :                                               lpViewEntityCsr,
; 5305 :                                               lpSearchEntityInstance,
; 5306 :                                               lpViewAttrib,
; 5307 :                                               lpCurrentTask ) );
; 5308 :    }
; 5309 : 
; 5310 :    return( 0 );

	xor	eax, eax
$LN1@fnQualifie:

; 5311 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnQualifiedInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_ulTossout$1 = -2980					; size = 4
_lpDomain$2 = -2976					; size = 4
_lpViewCsr$ = -2972					; size = 4
tv70 = -2968						; size = 4
tv66 = -2964						; size = 4
_lpViewOI$ = -2960					; size = 4
_lpSrcEntityInstance$ = -2956				; size = 4
_lAbsPosition$ = -2952					; size = 4
tv577 = -2948						; size = 4
tv499 = -2944						; size = 4
tv443 = -2940						; size = 4
_lpTaskDomain$3 = -2936					; size = 4
_lpDomain$4 = -2932					; size = 4
_lpTaskDomain$5 = -2928					; size = 4
$T6 = -2924						; size = 4
tv82 = -2920						; size = 4
tv74 = -2916						; size = 4
tv399 = -2912						; size = 4
tv133 = -2908						; size = 4
tv281 = -2904						; size = 4
tv388 = -2900						; size = 4
_lTemp$ = -2896						; size = 4
_lpDomain$7 = -2892					; size = 4
tv437 = -2888						; size = 4
_nDesiredSelectState$ = -2884				; size = 2
tv318 = -2880						; size = 4
_lQualOperator$ = -2876					; size = 4
_vAttrView$ = -2872					; size = 4
_bRecurse$ = -2866					; size = 1
_bSameParentKeepChildren$ = -2865			; size = 1
_n$8 = -2864						; size = 2
_n$9 = -2860						; size = 2
_n$10 = -2856						; size = 2
_bCursorTest$ = -2849					; size = 1
_bSelectRelevant$ = -2848				; size = 1
_bRelPosition$ = -2847					; size = 1
_bSkipDomain$11 = -2846					; size = 1
_cVariableType$ = -2845					; size = 1
_lQualRequest$ = -2844					; size = 4
_cDomainType$ = -2837					; size = 1
_nRC$ = -2836						; size = 2
_unTemp$ = -2832					; size = 256
_szMsg$12 = -2576					; size = 500
_szMsg$13 = -2076					; size = 500
_sz$14 = -1576						; size = 256
_sz$15 = -1320						; size = 256
_sz$16 = -1064						; size = 256
_sz$17 = -808						; size = 256
_sz$18 = -552						; size = 256
_sz$19 = -296						; size = 256
_szContext$20 = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpViewEntityAttrib$ = 20				; size = 4
_lControl$ = 24						; size = 4
_pQualValue$ = 28					; size = 4
_lpSrcViewEntityCsr$ = 32				; size = 4
_lpSrcViewEntityAttrib$ = 36				; size = 4
_lRelPosition$ = 40					; size = 4
_lpScopingViewEntityCsr$ = 44				; size = 4
_cpcContextName$ = 48					; size = 4
_lpCurrentTask$ = 52					; size = 4
_fnSetEntityCursor PROC

; 3613 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2980				; 00000ba4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 3614 :    LPENTITYINSTANCE  lpSrcEntityInstance;
; 3615 :    LPVIEWCSR         lpViewCsr;
; 3616 :    LPVIEWOI          lpViewOI;
; 3617 :    zLONG    lAbsPosition;        // type of 'absolute' positioning
; 3618 :    zLONG    lQualRequest;        // type of qualified request
; 3619 :    zLONG    lQualOperator;       // qualification operator <,>,=,<=,>=,~...
; 3620 :    zSHORT   nDesiredSelectState; // 0 - unselected, 1 - selected
; 3621 :    zBOOL    bSelectRelevant;     // Set if select state of entity is relevent
; 3622 :    zBOOL    bRelPosition;        // Set if relative positioning to be done
; 3623 :    zBOOL    bSameParentKeepChildren; // This one's for you...
; 3624 :    zBOOL    bRecurse;            // if Set, search recursive subobject
; 3625 :    zBOOL    bCursorTest;         // if Set, only the return code for setting
; 3626 :                                  // the cursor is set, actual cursors are not
; 3627 :                                  // moved.
; 3628 :    zVIEW    vAttrView = 0;       // Used by fnQualifiedInstance, for use

	mov	DWORD PTR _vAttrView$[ebp], 0

; 3629 :                                  // with domains and derived attributes.
; 3630 :    zCHAR    cDomainType;
; 3631 :    zCHAR    cVariableType;
; 3632 :    union
; 3633 :    {
; 3634 :       zDECIMAL dDecimal;
; 3635 :       zLONG    lInteger;
; 3636 :       zCHAR    szString[ 256 ];
; 3637 :    } unTemp;
; 3638 : 
; 3639 :    zLONG    lTemp;
; 3640 :    zSHORT   nRC;
; 3641 : 
; 3642 :    // Check for recursive request
; 3643 :    bRecurse = lControl & zRECURS ? 1 : 0;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	je	SHORT $LN124@fnSetEntit
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN125@fnSetEntit
$LN124@fnSetEntit:
	mov	DWORD PTR tv66[ebp], 0
$LN125@fnSetEntit:
	mov	cl, BYTE PTR tv66[ebp]
	mov	BYTE PTR _bRecurse$[ebp], cl

; 3644 : 
; 3645 :    // Check for Test Cursor movement option
; 3646 :    bCursorTest = lControl & zTEST_CSR_RESULT ? 1 : 0;

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	je	SHORT $LN126@fnSetEntit
	mov	DWORD PTR tv70[ebp], 1
	jmp	SHORT $LN127@fnSetEntit
$LN126@fnSetEntit:
	mov	DWORD PTR tv70[ebp], 0
$LN127@fnSetEntit:
	mov	al, BYTE PTR tv70[ebp]
	mov	BYTE PTR _bCursorTest$[ebp], al

; 3647 : 
; 3648 :    // Check for possibility of keeping the child cursors intact.
; 3649 :    bSameParentKeepChildren = lControl & zSPARENT_KEEPCHILDREN ? 1 : 0;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1048576				; 00100000H
	je	SHORT $LN128@fnSetEntit
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN129@fnSetEntit
$LN128@fnSetEntit:
	mov	DWORD PTR tv74[ebp], 0
$LN129@fnSetEntit:
	mov	dl, BYTE PTR tv74[ebp]
	mov	BYTE PTR _bSameParentKeepChildren$[ebp], dl

; 3650 : 
; 3651 :    // Check for "Entity Selected State " request
; 3652 :    lTemp = lControl & (zQUAL_SELECTED | zQUAL_UNSELECTED);

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 24576				; 00006000H
	mov	DWORD PTR _lTemp$[ebp], eax

; 3653 : 
; 3654 :    // If Selected and Unselected entities are requested, then the
; 3655 :    // Select state of the entity is not relevent.
; 3656 :    if ( lTemp && (-lTemp & lTemp) == lTemp )

	je	SHORT $LN20@fnSetEntit
	mov	ecx, DWORD PTR _lTemp$[ebp]
	neg	ecx
	and	ecx, DWORD PTR _lTemp$[ebp]
	cmp	ecx, DWORD PTR _lTemp$[ebp]
	jne	SHORT $LN20@fnSetEntit

; 3657 :    {
; 3658 :       nDesiredSelectState = (lTemp == zQUAL_SELECTED);

	cmp	DWORD PTR _lTemp$[ebp], 8192		; 00002000H
	jne	SHORT $LN130@fnSetEntit
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN131@fnSetEntit
$LN130@fnSetEntit:
	mov	DWORD PTR tv82[ebp], 0
$LN131@fnSetEntit:
	mov	dx, WORD PTR tv82[ebp]
	mov	WORD PTR _nDesiredSelectState$[ebp], dx

; 3659 :       bSelectRelevant = TRUE;

	mov	BYTE PTR _bSelectRelevant$[ebp], 1

; 3660 :    }

	jmp	SHORT $LN21@fnSetEntit
$LN20@fnSetEntit:

; 3661 :    else
; 3662 :       bSelectRelevant = FALSE;

	mov	BYTE PTR _bSelectRelevant$[ebp], 0
$LN21@fnSetEntit:

; 3663 : 
; 3664 :    // Relative and Absolute positioning requests may both be specified.
; 3665 : 
; 3666 :    // Relative positioning requested.
; 3667 :    if ( lControl & zPOS_RELATIVE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 8
	je	SHORT $LN22@fnSetEntit

; 3668 :       bRelPosition = TRUE;

	mov	BYTE PTR _bRelPosition$[ebp], 1
	jmp	SHORT $LN23@fnSetEntit
$LN22@fnSetEntit:

; 3669 :    else
; 3670 :       bRelPosition = FALSE;

	mov	BYTE PTR _bRelPosition$[ebp], 0
$LN23@fnSetEntit:

; 3671 : 
; 3672 :    // Set Absolute positioning request.
; 3673 :    lAbsPosition = lControl & zPOS_ABS;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 7
	mov	DWORD PTR _lAbsPosition$[ebp], ecx

; 3674 : 
; 3675 :    // Set Qualification request
; 3676 :    lQualRequest = lControl & (zQUAL_INTEGER | zQUAL_DECIMAL | zQUAL_DATETIME |

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 10526464				; 00a09f00H
	mov	DWORD PTR _lQualRequest$[ebp], edx

; 3677 :                               zQUAL_STRING  | zQUAL_ENTITYCSR | zQUAL_ENTITYKEY |
; 3678 :                               zQUAL_ATTR_NULL | zQUAL_ENTITYATTR);
; 3679 : 
; 3680 :    // Set Qualification operator.
; 3681 :    if ( lQualRequest )

	je	SHORT $LN24@fnSetEntit

; 3682 :    {
; 3683 :       lQualOperator = lControl & zQUAL_OPERATOR;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 240				; 000000f0H
	mov	DWORD PTR _lQualOperator$[ebp], eax

; 3684 :       if ( (lQualOperator & (zQUAL_OPERATOR - zQUAL_NOT)) == 0 )

	mov	ecx, DWORD PTR _lQualOperator$[ebp]
	and	ecx, 112				; 00000070H
	jne	SHORT $LN25@fnSetEntit

; 3685 :          lQualOperator |= zQUAL_EQUAL;

	mov	edx, DWORD PTR _lQualOperator$[ebp]
	or	edx, 16					; 00000010H
	mov	DWORD PTR _lQualOperator$[ebp], edx
	jmp	SHORT $LN24@fnSetEntit
$LN25@fnSetEntit:

; 3686 :       else
; 3687 :       {
; 3688 :          if ( (lQualOperator & zQUAL_NOT) == zQUAL_NOT &&

	mov	eax, DWORD PTR _lQualOperator$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN24@fnSetEntit
	cmp	DWORD PTR _lQualOperator$[ebp], 144	; 00000090H
	je	SHORT $LN24@fnSetEntit

; 3689 :               lQualOperator != (zQUAL_NOT | zQUAL_EQUAL) )
; 3690 :          {
; 3691 :             lQualOperator = -lQualOperator & zQUAL_OPERATOR;

	mov	ecx, DWORD PTR _lQualOperator$[ebp]
	neg	ecx
	and	ecx, 240				; 000000f0H
	mov	DWORD PTR _lQualOperator$[ebp], ecx
$LN24@fnSetEntit:

; 3692 :          }
; 3693 :       }
; 3694 :    }
; 3695 : 
; 3696 :    if ( lQualRequest == zQUAL_ATTR_NULL )

	cmp	DWORD PTR _lQualRequest$[ebp], 32768	; 00008000H
	jne	$LN28@fnSetEntit

; 3697 :       switch ( lpViewEntityAttrib->cType )

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR tv133[ebp], eax
	mov	ecx, DWORD PTR tv133[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv133[ebp], ecx
	cmp	DWORD PTR tv133[ebp], 18		; 00000012H
	ja	SHORT $LN28@fnSetEntit
	mov	edx, DWORD PTR tv133[ebp]
	movzx	eax, BYTE PTR $LN136@fnSetEntit[edx]
	jmp	DWORD PTR $LN137@fnSetEntit[eax*4]
$LN29@fnSetEntit:

; 3698 :       {
; 3699 :          case zTYPE_INTEGER:
; 3700 :             pQualValue = (zPVOID) &lNullInteger;

	mov	DWORD PTR _pQualValue$[ebp], OFFSET _lNullInteger

; 3701 :             lQualRequest = zQUAL_INTEGER;

	mov	DWORD PTR _lQualRequest$[ebp], 256	; 00000100H

; 3702 :             break;

	jmp	SHORT $LN28@fnSetEntit
$LN30@fnSetEntit:

; 3703 : 
; 3704 :          case zTYPE_DECIMAL:
; 3705 :             SysAssignDecimalFromNull( &unTemp.dDecimal );

	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	call	_SysAssignDecimalFromNull@4

; 3706 :             pQualValue = (zPVOID) &unTemp.dDecimal;

	lea	edx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], edx

; 3707 :             lQualRequest = zQUAL_DECIMAL;

	mov	DWORD PTR _lQualRequest$[ebp], 512	; 00000200H

; 3708 :             break;

	jmp	SHORT $LN28@fnSetEntit
$LN31@fnSetEntit:

; 3709 : 
; 3710 :          case zTYPE_STRING:
; 3711 :             pQualValue = (zPVOID) szNullS;

	mov	eax, DWORD PTR _szNullS
	mov	DWORD PTR _pQualValue$[ebp], eax

; 3712 :             lQualRequest = zQUAL_STRING;

	mov	DWORD PTR _lQualRequest$[ebp], 1024	; 00000400H

; 3713 :             break;

	jmp	SHORT $LN28@fnSetEntit
$LN32@fnSetEntit:

; 3714 : 
; 3715 :          case zTYPE_DATETIME:
; 3716 :             pQualValue = (zPVOID) &stNullDateTime;

	mov	DWORD PTR _pQualValue$[ebp], OFFSET _stNullDateTime

; 3717 :             lQualRequest = zQUAL_DATETIME;

	mov	DWORD PTR _lQualRequest$[ebp], 2048	; 00000800H

; 3718 :             break;

	jmp	SHORT $LN28@fnSetEntit
$LN33@fnSetEntit:

; 3719 : 
; 3720 :          case zTYPE_BLOB:
; 3721 :             // Search for null attribute not supported for these attribute types.
; 3722 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN28@fnSetEntit:

; 3723 :       }
; 3724 : 
; 3725 :    // If Qualification request uses a source view, set the pointer to
; 3726 :    // the source entity instance.
; 3727 :    if ( lQualRequest & (zQUAL_ENTITYCSR | zQUAL_ENTITYATTR) )

	mov	ecx, DWORD PTR _lQualRequest$[ebp]
	and	ecx, 2101248				; 00201000H
	je	$LN34@fnSetEntit

; 3728 :    {
; 3729 :       lpSrcEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 3730 : 
; 3731 :       // If the search argument is a derived attribute, set it now.
; 3732 :       if ( lQualRequest == zQUAL_ENTITYATTR )

	cmp	DWORD PTR _lQualRequest$[ebp], 4096	; 00001000H
	jne	$LN34@fnSetEntit

; 3733 :       {
; 3734 :          if ( lpSrcViewEntityAttrib->szDerivedOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN36@fnSetEntit

; 3735 :          {
; 3736 :             nRC = fnInvokeDerivedOperation( (zVIEW) pQualValue,

	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	call	_fnInvokeDerivedOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 3737 :                                             zGETPTR( lpSrcViewEntityCsr->
; 3738 :                                                                hViewEntity ),
; 3739 :                                             lpSrcViewEntityAttrib,
; 3740 :                                             lpCurrentTask, zDERIVED_GET );
; 3741 :             if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN36@fnSetEntit

; 3742 :                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN123@fnSetEntit
$LN36@fnSetEntit:

; 3743 :          }
; 3744 : 
; 3745 :          if ( lpSrcViewEntityAttrib->cType != lpViewEntityAttrib->cType ||

	mov	edx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	eax, edx
	jne	SHORT $LN39@fnSetEntit
	mov	eax, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	edx, DWORD PTR [eax+198]
	cmp	edx, DWORD PTR [ecx+198]
	je	$LN34@fnSetEntit
$LN39@fnSetEntit:

; 3746 :               lpSrcViewEntityAttrib->hDomain != lpViewEntityAttrib->hDomain )
; 3747 :          {
; 3748 :             zULONG   ulTossout;
; 3749 : 
; 3750 :             nRC = fnGetVariableFromAttribute( (zPVOID) &unTemp,

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	push	256					; 00000100H
	push	83					; 00000053H
	lea	ecx, DWORD PTR _ulTossout$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H
	mov	WORD PTR _nRC$[ebp], ax

; 3751 :                                               &ulTossout,
; 3752 :                                               zTYPE_STRING,
; 3753 :                                               sizeof( unTemp.szString ),
; 3754 :                                               (zVIEW) pQualValue,
; 3755 :                                               lpSrcViewEntityCsr,
; 3756 :                                               lpSrcViewEntityAttrib,
; 3757 :                                               0, lpCurrentTask, 0 );
; 3758 :             if ( nRC == 0 || nRC == zVAR_NULL )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN41@fnSetEntit
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jne	$LN34@fnSetEntit
$LN41@fnSetEntit:

; 3759 :             {
; 3760 :                zCHAR          szContext[ 33 ];
; 3761 :                LPTASKDOMAIN   lpTaskDomain;
; 3762 :                LPDOMAIN       lpDomain;
; 3763 : 
; 3764 :                szContext[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T6[ebp], eax
	cmp	DWORD PTR $T6[ebp], 33			; 00000021H
	jae	SHORT $LN132@fnSetEntit
	jmp	SHORT $LN133@fnSetEntit
$LN132@fnSetEntit:
	call	___report_rangecheckfailure
$LN133@fnSetEntit:
	mov	ecx, DWORD PTR $T6[ebp]
	mov	BYTE PTR _szContext$20[ebp+ecx], 0

; 3765 :                if ( cpcContextName && *cpcContextName )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN42@fnSetEntit
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN42@fnSetEntit

; 3766 :                   zstrcpy( szContext, cpcContextName );

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szContext$20[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN43@fnSetEntit
$LN42@fnSetEntit:

; 3767 :                else
; 3768 :                if ( lpSrcViewEntityAttrib->hDomain )

	mov	eax, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	je	SHORT $LN43@fnSetEntit

; 3769 :                {
; 3770 :                   lpDomain = zGETPTR( lpSrcViewEntityAttrib->hDomain );

	mov	ecx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+198]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$7[ebp], eax

; 3771 :                   zstrcpy( szContext, lpDomain->szName );

	mov	eax, DWORD PTR _lpDomain$7[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _szContext$20[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN43@fnSetEntit:

; 3772 :                }
; 3773 : 
; 3774 :                cDomainType =

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTaskDomain$5[ebp]
	push	eax
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 3775 :                  fnDomainProcessingRequired( &lpTaskDomain,
; 3776 :                                              lpView,
; 3777 :                                              lpCurrentTask,
; 3778 :                                              zGETPTR( lpViewEntityAttrib->hDomain ) );
; 3779 :                if ( cDomainType && cDomainType != zDM_TYPE_FORMAT )

	movsx	ecx, BYTE PTR _cDomainType$[ebp]
	test	ecx, ecx
	je	$LN34@fnSetEntit
	movsx	edx, BYTE PTR _cDomainType$[ebp]
	cmp	edx, 70					; 00000046H
	je	$LN34@fnSetEntit

; 3780 :                {
; 3781 :                   if ( cDomainType == zDM_TYPE_TABLE )

	movsx	eax, BYTE PTR _cDomainType$[ebp]
	cmp	eax, 84					; 00000054H
	jne	SHORT $LN46@fnSetEntit

; 3782 :                   {
; 3783 :                      nRC = Table_Handler( zDME_GET_COMPARE_VALUE,

	push	0
	push	256					; 00000100H
	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szContext$20[ebp]
	push	ecx
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	push	83					; 00000053H
	push	9
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 3784 :                                           zTYPE_STRING,
; 3785 :                                           (zPVOID) &unTemp,
; 3786 :                                           szContext,
; 3787 :                                           lpView,
; 3788 :                                           lpViewEntity,
; 3789 :                                           lpViewEntityAttrib,
; 3790 :                                           sizeof( unTemp ),
; 3791 :                                           (zPVOID) 0 );
; 3792 :                   }

	jmp	$LN47@fnSetEntit
$LN46@fnSetEntit:

; 3793 :                   else
; 3794 :                   {
; 3795 :                      nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	push	256					; 00000100H
	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _szContext$20[ebp]
	push	eax
	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	push	83					; 00000053H
	push	9
	mov	edx, DWORD PTR _lpTaskDomain$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 3796 :                                              zDME_GET_COMPARE_VALUE,
; 3797 :                                              zTYPE_STRING,
; 3798 :                                              (zPVOID) &unTemp,
; 3799 :                                              szContext,
; 3800 :                                              lpView,
; 3801 :                                              lpViewEntity,
; 3802 :                                              lpViewEntityAttrib,
; 3803 :                                              sizeof( unTemp ) );
; 3804 :                      if ( nRC == zDME_NOT_HANDLED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -10				; fffffff6H
	jne	SHORT $LN47@fnSetEntit

; 3805 :                      {
; 3806 :                         zCHAR szMsg[ 500 ];
; 3807 : 
; 3808 :                         zsprintf( szMsg, "Operation '%s' does not handle an Entry "

	mov	edx, DWORD PTR _lpDomain$7[ebp]
	add	edx, 6
	push	edx
	push	9
	mov	eax, DWORD PTR _lpDomain$7[ebp]
	add	eax, 100				; 00000064H
	push	eax
	push	OFFSET $SG14700
	lea	ecx, DWORD PTR _szMsg$12[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3809 :                                   "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 3810 :                                   zDME_GET_COMPARE_VALUE, lpDomain->szName );
; 3811 :                         MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	edx, DWORD PTR _szMsg$12[ebp]
	push	edx
	push	OFFSET $SG14701
	push	OFFSET $SG14702
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MessageSend@24

; 3812 :                                      szMsg, zMSGQ_DOMAIN_ERROR, 0 );
; 3813 :                         return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN47@fnSetEntit:

; 3814 :                      }
; 3815 :                   }
; 3816 : 
; 3817 :                   switch ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv281[ebp], ecx
	mov	edx, DWORD PTR tv281[ebp]
	add	edx, 2
	mov	DWORD PTR tv281[ebp], edx
	cmp	DWORD PTR tv281[ebp], 5
	ja	$LN56@fnSetEntit
	mov	eax, DWORD PTR tv281[ebp]
	jmp	DWORD PTR $LN138@fnSetEntit[eax*4]
$LN49@fnSetEntit:

; 3818 :                   {
; 3819 :                      case -2:
; 3820 :                         // This means we are going to do a lot of extra
; 3821 :                         // processing for domains (down in
; 3822 :                         // fnQualifiedInstance)
; 3823 :                         // Create 'Temporary' view for derived attribute
; 3824 :                         // and also for domain processing.
; 3825 :                         nRC = CreateViewFromViewForTask( &vAttrView, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vAttrView$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax

; 3826 :                         if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN50@fnSetEntit

; 3827 :                            return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN123@fnSetEntit
$LN50@fnSetEntit:

; 3828 : 
; 3829 :                         break;

	jmp	$LN34@fnSetEntit
$LN51@fnSetEntit:

; 3830 : 
; 3831 :                      case 0:
; 3832 :                      case 1:
; 3833 :                         lQualRequest = zQUAL_STRING;

	mov	DWORD PTR _lQualRequest$[ebp], 1024	; 00000400H

; 3834 :                         pQualValue = &unTemp.szString;

	lea	ecx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], ecx

; 3835 :                         cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0

; 3836 :                         break;

	jmp	$LN34@fnSetEntit
$LN52@fnSetEntit:

; 3837 : 
; 3838 :                      case 2:
; 3839 :                         lQualRequest = zQUAL_INTEGER;

	mov	DWORD PTR _lQualRequest$[ebp], 256	; 00000100H

; 3840 :                         pQualValue = &unTemp.lInteger;

	lea	edx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], edx

; 3841 :                         cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0

; 3842 :                         break;

	jmp	$LN34@fnSetEntit
$LN53@fnSetEntit:

; 3843 : 
; 3844 :                      case 3:
; 3845 :                         lQualRequest = zQUAL_DECIMAL;

	mov	DWORD PTR _lQualRequest$[ebp], 512	; 00000200H

; 3846 :                         pQualValue = &unTemp.dDecimal;

	lea	eax, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], eax

; 3847 :                         cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0

; 3848 :                         break;

	jmp	$LN34@fnSetEntit
$LN54@fnSetEntit:

; 3849 : 
; 3850 :                      case -1:
; 3851 :                         // If we get here and we're dealing with a table
; 3852 :                         // domain then the qual value is not a valid domain
; 3853 :                         // value.  Show an error message UNLESS the caller
; 3854 :                         // indicated that this is OK.
; 3855 :                         if ( cDomainType == zDM_TYPE_TABLE &&

	movsx	ecx, BYTE PTR _cDomainType$[ebp]
	cmp	ecx, 84					; 00000054H
	jne	$LN56@fnSetEntit
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 4194304				; 00400000H
	jne	$LN56@fnSetEntit

; 3856 :                              ( lControl & zIGNORE_ERROR_358 ) == 0 )
; 3857 :                         {
; 3858 :                            lpDomain = zGETPTR( lpTaskDomain->hDomain );

	mov	eax, DWORD PTR _lpTaskDomain$5[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$7[ebp], eax

; 3859 :                            zstrcat( unTemp.szString, ", " );

	push	OFFSET $SG14710
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3860 :                            zstrcat( unTemp.szString,

	mov	eax, DWORD PTR _lpDomain$7[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3861 :                                     lpDomain->szName );
; 3862 :                            zstrcat( unTemp.szString, ", " );

	push	OFFSET $SG14711
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3863 :                            zstrcat( unTemp.szString,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3864 :                                     lpViewEntity->szName );
; 3865 :                            // "KZOEE358 - Value not in Context for Domain "
; 3866 :                            fnIssueCoreError( lpCurrentTask, lpView, 0, 358, 0,

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _unTemp$[ebp]
	push	eax
	push	0
	push	358					; 00000166H
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN56@fnSetEntit:

; 3867 :                                              unTemp.szString,
; 3868 :                                              lpViewEntityAttrib->szName );
; 3869 :                         }
; 3870 : 
; 3871 :                      default:
; 3872 :                         // error message should have been issued by domain.
; 3873 :                         return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN34@fnSetEntit:

; 3874 :                   }
; 3875 : 
; 3876 :                } // if ( cDomainType && cDomainType != zDM_TYPE_FORMAT )...
; 3877 : 
; 3878 :             } // if ( nRC == 0 || nRC == zVAR_NULL )
; 3879 : 
; 3880 :          } // if ( lpSrcViewEntityAttrib->cType != lpViewEntityAttrib->cType...
; 3881 : 
; 3882 :       } // if ( lQualRequest == zQUAL_ENTITYATTR )...
; 3883 : 
; 3884 :    } // if ( lQualRequest & ( zQUAL_ENTITYCSR | zQUAL_ENTITYATTR ) )...
; 3885 : 
; 3886 :    // If a context name is specified, see if the domain will give us a
; 3887 :    // simple internal data type to compare for, rather than call the
; 3888 :    // domain for every entity instance looked at.
; 3889 :    cDomainType = 0;

	mov	BYTE PTR _cDomainType$[ebp], 0

; 3890 :    if ( cpcContextName && *cpcContextName )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	$LN57@fnSetEntit
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN57@fnSetEntit

; 3891 :    {
; 3892 :       LPTASKDOMAIN   lpTaskDomain;
; 3893 :       zBOOL          bSkipDomain = FALSE;

	mov	BYTE PTR _bSkipDomain$11[ebp], 0

; 3894 : 
; 3895 :       switch ( lQualRequest )

	mov	edx, DWORD PTR _lQualRequest$[ebp]
	mov	DWORD PTR tv318[ebp], edx
	cmp	DWORD PTR tv318[ebp], 1024		; 00000400H
	jg	SHORT $LN134@fnSetEntit
	cmp	DWORD PTR tv318[ebp], 1024		; 00000400H
	je	SHORT $LN60@fnSetEntit
	cmp	DWORD PTR tv318[ebp], 256		; 00000100H
	je	SHORT $LN59@fnSetEntit
	cmp	DWORD PTR tv318[ebp], 512		; 00000200H
	je	SHORT $LN61@fnSetEntit
	jmp	SHORT $LN63@fnSetEntit
$LN134@fnSetEntit:
	cmp	DWORD PTR tv318[ebp], 4096		; 00001000H
	je	SHORT $LN62@fnSetEntit
	cmp	DWORD PTR tv318[ebp], 2097152		; 00200000H
	je	SHORT $LN62@fnSetEntit
	jmp	SHORT $LN63@fnSetEntit
$LN59@fnSetEntit:

; 3896 :       {
; 3897 :          case zQUAL_INTEGER:
; 3898 :             unTemp.lInteger = *((zPLONG) pQualValue);

	mov	eax, DWORD PTR _pQualValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _unTemp$[ebp], ecx

; 3899 :             cVariableType = zTYPE_INTEGER;

	mov	BYTE PTR _cVariableType$[ebp], 76	; 0000004cH

; 3900 :             break;

	jmp	SHORT $LN6@fnSetEntit
$LN60@fnSetEntit:

; 3901 : 
; 3902 :          case zQUAL_STRING:
; 3903 :             zstrcpy( unTemp.szString, (zPCHAR) pQualValue );

	mov	edx, DWORD PTR _pQualValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _unTemp$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 3904 :             cVariableType = zTYPE_STRING;

	mov	BYTE PTR _cVariableType$[ebp], 83	; 00000053H

; 3905 :             break;

	jmp	SHORT $LN6@fnSetEntit
$LN61@fnSetEntit:

; 3906 : 
; 3907 :          case zQUAL_DECIMAL:
; 3908 :             unTemp.dDecimal = *((zPDECIMAL) pQualValue);

	mov	ecx, 10					; 0000000aH
	mov	esi, DWORD PTR _pQualValue$[ebp]
	lea	edi, DWORD PTR _unTemp$[ebp]
	rep movsd

; 3909 :             cVariableType = zTYPE_DECIMAL;

	mov	BYTE PTR _cVariableType$[ebp], 77	; 0000004dH

; 3910 :             break;

	jmp	SHORT $LN6@fnSetEntit
$LN62@fnSetEntit:

; 3911 : 
; 3912 :          case zQUAL_ENTITYCSR:
; 3913 :          case zQUAL_ENTITYATTR:
; 3914 :             bSkipDomain = TRUE;

	mov	BYTE PTR _bSkipDomain$11[ebp], 1

; 3915 :             break;

	jmp	SHORT $LN6@fnSetEntit
$LN63@fnSetEntit:

; 3916 : 
; 3917 :          default:
; 3918 :             TraceLineS( "(cm) Invalid qualification type with context:",

	push	OFFSET $SG14720
	push	OFFSET $SG14721
	call	_TraceLineS@8

; 3919 :                         "fnSetEntityCursor" );
; 3920 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN6@fnSetEntit:

; 3921 :       }
; 3922 : 
; 3923 :       if ( lpViewEntityAttrib->hDomain && bSkipDomain == FALSE )

	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	cmp	DWORD PTR [ecx+198], 0
	je	$LN64@fnSetEntit
	movzx	edx, BYTE PTR _bSkipDomain$11[ebp]
	test	edx, edx
	jne	$LN64@fnSetEntit

; 3924 :       {
; 3925 :          cDomainType = fnDomainProcessingRequired( &lpTaskDomain, lpView,

	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTaskDomain$3[ebp]
	push	ecx
	call	_fnDomainProcessingRequired
	add	esp, 16					; 00000010H
	mov	BYTE PTR _cDomainType$[ebp], al

; 3926 :                                                    lpCurrentTask,
; 3927 :                                                    zGETPTR( lpViewEntityAttrib->
; 3928 :                                                                   hDomain ) );
; 3929 :          if ( cDomainType && cDomainType != zDM_TYPE_FORMAT )

	movsx	edx, BYTE PTR _cDomainType$[ebp]
	test	edx, edx
	je	$LN66@fnSetEntit
	movsx	eax, BYTE PTR _cDomainType$[ebp]
	cmp	eax, 70					; 00000046H
	je	$LN66@fnSetEntit

; 3930 :          {
; 3931 :             if ( cDomainType == zDM_TYPE_TABLE )

	movsx	ecx, BYTE PTR _cDomainType$[ebp]
	cmp	ecx, 84					; 00000054H
	jne	SHORT $LN68@fnSetEntit

; 3932 :             {
; 3933 :                nRC = Table_Handler( (zLONG) zDME_GET_COMPARE_VALUE,

	push	0
	push	256					; 00000100H
	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	lea	eax, DWORD PTR _unTemp$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _cVariableType$[ebp]
	push	ecx
	push	9
	call	_Table_Handler@36
	mov	WORD PTR _nRC$[ebp], ax

; 3934 :                                     cVariableType,
; 3935 :                                     &unTemp,
; 3936 :                                     cpcContextName,
; 3937 :                                     lpView,
; 3938 :                                     lpViewEntity,
; 3939 :                                     lpViewEntityAttrib,
; 3940 :                                     sizeof( unTemp ),
; 3941 :                                     (zPVOID) 0 );
; 3942 :             }

	jmp	$LN69@fnSetEntit
$LN68@fnSetEntit:

; 3943 :             else
; 3944 :             {
; 3945 :                LPDOMAIN lpDomain = zGETPTR( lpViewEntityAttrib->hDomain );

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$4[ebp], eax

; 3946 : 
; 3947 :                nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	push	256					; 00000100H
	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	movzx	eax, BYTE PTR _cVariableType$[ebp]
	push	eax
	push	9
	mov	ecx, DWORD PTR _lpTaskDomain$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 3948 :                                        zDME_GET_COMPARE_VALUE,
; 3949 :                                        cVariableType,
; 3950 :                                        &unTemp,
; 3951 :                                        cpcContextName,
; 3952 :                                        lpView,
; 3953 :                                        lpViewEntity,
; 3954 :                                        lpViewEntityAttrib,
; 3955 :                                        sizeof( unTemp ) );
; 3956 :                if ( nRC == zDME_NOT_HANDLED )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -10				; fffffff6H
	jne	SHORT $LN69@fnSetEntit

; 3957 :                {
; 3958 :                   zCHAR szMsg[ 500 ];
; 3959 : 
; 3960 :                   zsprintf( szMsg, "Operation '%s' does not handle an Entry "

	mov	ecx, DWORD PTR _lpDomain$4[ebp]
	add	ecx, 6
	push	ecx
	push	9
	mov	edx, DWORD PTR _lpDomain$4[ebp]
	add	edx, 100				; 00000064H
	push	edx
	push	OFFSET $SG14729
	lea	eax, DWORD PTR _szMsg$13[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3961 :                             "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 3962 :                             zDME_GET_COMPARE_VALUE, lpDomain->szName );
; 3963 :                   MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	ecx, DWORD PTR _szMsg$13[ebp]
	push	ecx
	push	OFFSET $SG14730
	push	OFFSET $SG14731
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MessageSend@24

; 3964 :                                szMsg, zMSGQ_DOMAIN_ERROR, 0 );
; 3965 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN69@fnSetEntit:

; 3966 :                }
; 3967 :             }
; 3968 : 
; 3969 : //         -2 - lpData ignored, this tells SetEntityCursor that
; 3970 : //              it should invoked domain processing with the
; 3971 : //              zDME_COMPARE_ATTRIBUTE entry type, each time
; 3972 : //              that is determining if the EntityInstance
; 3973 : //              matches the requested qualifications.
; 3974 : //         -1 - lpData invalid
; 3975 : //          0 - lpData unchanged, okay to use as is.
; 3976 : //          1 - lpData returned, string value
; 3977 : //          2 - lpData returned, integer value
; 3978 : //          3 - lpData returned, decimal value
; 3979 : 
; 3980 :             switch ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv388[ebp], eax
	mov	ecx, DWORD PTR tv388[ebp]
	add	ecx, 2
	mov	DWORD PTR tv388[ebp], ecx
	cmp	DWORD PTR tv388[ebp], 5
	ja	$LN82@fnSetEntit
	mov	edx, DWORD PTR tv388[ebp]
	jmp	DWORD PTR $LN139@fnSetEntit[edx*4]
$LN71@fnSetEntit:

; 3981 :             {
; 3982 :                case -2:
; 3983 :                   // Create 'Temporary' view for derived attribute
; 3984 :                   // and also for domain processing.
; 3985 :                   nRC = CreateViewFromViewForTask( &vAttrView, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax

; 3986 :                   if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN72@fnSetEntit

; 3987 :                      return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN123@fnSetEntit
$LN72@fnSetEntit:

; 3988 : 
; 3989 :                   break;

	jmp	$LN8@fnSetEntit
$LN73@fnSetEntit:

; 3990 : 
; 3991 :                case 0:
; 3992 :                   cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0

; 3993 :                   break;

	jmp	$LN8@fnSetEntit
$LN74@fnSetEntit:

; 3994 : 
; 3995 :                case 1:
; 3996 :                   cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0

; 3997 :                   lQualRequest = zQUAL_STRING;

	mov	DWORD PTR _lQualRequest$[ebp], 1024	; 00000400H

; 3998 :                   pQualValue = &unTemp.szString;

	lea	eax, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], eax

; 3999 :                   break;

	jmp	$LN8@fnSetEntit
$LN75@fnSetEntit:

; 4000 : 
; 4001 :                case 2:
; 4002 :                   cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0

; 4003 :                   lQualRequest = zQUAL_INTEGER;

	mov	DWORD PTR _lQualRequest$[ebp], 256	; 00000100H

; 4004 :                   pQualValue = &unTemp.lInteger;

	lea	ecx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], ecx

; 4005 :                   break;

	jmp	$LN8@fnSetEntit
$LN76@fnSetEntit:

; 4006 : 
; 4007 :                case 3:
; 4008 :                   cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0

; 4009 :                   lQualRequest = zQUAL_DECIMAL;

	mov	DWORD PTR _lQualRequest$[ebp], 512	; 00000200H

; 4010 :                   pQualValue = &unTemp.dDecimal;

	lea	edx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], edx

; 4011 :                   break;

	jmp	$LN8@fnSetEntit
$LN77@fnSetEntit:

; 4012 : 
; 4013 :                case -1:
; 4014 :                   if ( cDomainType == zDM_TYPE_TABLE &&

	movsx	eax, BYTE PTR _cDomainType$[ebp]
	cmp	eax, 84					; 00000054H
	jne	$LN82@fnSetEntit
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 4194304				; 00400000H
	jne	$LN82@fnSetEntit

; 4015 :                        (lControl & zIGNORE_ERROR_358) == 0 )
; 4016 :                   {
; 4017 :                      LPDOMAIN lpDomain;
; 4018 : 
; 4019 :                      switch ( lQualRequest )

	mov	edx, DWORD PTR _lQualRequest$[ebp]
	mov	DWORD PTR tv399[ebp], edx
	cmp	DWORD PTR tv399[ebp], 256		; 00000100H
	je	SHORT $LN80@fnSetEntit
	cmp	DWORD PTR tv399[ebp], 512		; 00000200H
	je	SHORT $LN81@fnSetEntit
	cmp	DWORD PTR tv399[ebp], 1024		; 00000400H
	je	SHORT $LN79@fnSetEntit
	jmp	SHORT $LN10@fnSetEntit
$LN79@fnSetEntit:

; 4020 :                      {
; 4021 :                         case zQUAL_STRING:
; 4022 :                            zstrcpy( unTemp.szString, (zPCHAR) pQualValue );

	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4023 :                            break;

	jmp	SHORT $LN10@fnSetEntit
$LN80@fnSetEntit:

; 4024 : 
; 4025 :                         case zQUAL_INTEGER:
; 4026 :                            zltoa( *((zPLONG) pQualValue), unTemp.szString );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQualValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 4027 :                            break;

	jmp	SHORT $LN10@fnSetEntit
$LN81@fnSetEntit:

; 4028 : 
; 4029 :                         case zQUAL_DECIMAL:
; 4030 :                            ConvertDecimalToString( unTemp.szString, 0,

	push	0
	mov	esi, DWORD PTR _pQualValue$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	0
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_ConvertDecimalToString@52
$LN10@fnSetEntit:

; 4031 :                                                    *((zPDECIMAL) pQualValue),
; 4032 :                                                    0 );
; 4033 :                            break;
; 4034 :                      }
; 4035 : 
; 4036 :                      lpDomain = zGETPTR( lpTaskDomain->hDomain );

	mov	eax, DWORD PTR _lpTaskDomain$3[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$2[ebp], eax

; 4037 : 
; 4038 :                      zstrcat( unTemp.szString, ", " );

	push	OFFSET $SG14743
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4039 :                      zstrcat( unTemp.szString,

	mov	eax, DWORD PTR _lpDomain$2[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4040 :                               lpDomain->szName );
; 4041 :                      zstrcat( unTemp.szString, ", " );

	push	OFFSET $SG14744
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4042 :                      zstrcat( unTemp.szString, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4043 :                      // "KZOEE358 - Value not in Context for Domain "
; 4044 :                      fnIssueCoreError( lpCurrentTask, lpView, 0, 358, 0,

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _unTemp$[ebp]
	push	eax
	push	0
	push	358					; 00000166H
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN82@fnSetEntit:

; 4045 :                                        unTemp.szString,
; 4046 :                                        lpViewEntityAttrib->szName );
; 4047 :                   }
; 4048 : 
; 4049 :                default:
; 4050 :                   // error message should have been issued by domain.
; 4051 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN8@fnSetEntit:

; 4052 :             }
; 4053 :          }

	jmp	SHORT $LN67@fnSetEntit
$LN66@fnSetEntit:

; 4054 :          else
; 4055 :          {
; 4056 :             // When we have a context and the domain is a format type, we
; 4057 :             // want to honor the format!   dks ... 2005.04.27
; 4058 :          // if ( cDomainType == zDM_TYPE_FORMAT &&
; 4059 :          //      cpcContextName && *cpcContextName )
; 4060 :          // {
; 4061 :          // }
; 4062 :          // else
; 4063 :             {
; 4064 :                cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0
$LN67@fnSetEntit:

; 4065 :                // if Domain not located or
; 4066 :                //    no operation entry point and domain not a table type domain
; 4067 :                // then we fall through and function as if there is no domain
; 4068 :                // processing to be done...
; 4069 :             }
; 4070 :          }
; 4071 :       }

	jmp	SHORT $LN65@fnSetEntit
$LN64@fnSetEntit:

; 4072 :       else
; 4073 :          if ( bSkipDomain == FALSE )

	movzx	eax, BYTE PTR _bSkipDomain$11[ebp]
	test	eax, eax
	jne	SHORT $LN65@fnSetEntit

; 4074 :             cpcContextName = 0;

	mov	DWORD PTR _cpcContextName$[ebp], 0
$LN65@fnSetEntit:

; 4075 :    }

	jmp	$LN58@fnSetEntit
$LN57@fnSetEntit:

; 4076 :    else
; 4077 :    {
; 4078 :       // No context specified.  If this is a qualified request for a
; 4079 :       // string, integer or decimal; insure that the attribute data
; 4080 :       // type matches, if not try to convert the qualifying value to
; 4081 :       // match the attribute value.
; 4082 :       switch ( lQualRequest )

	mov	ecx, DWORD PTR _lQualRequest$[ebp]
	mov	DWORD PTR tv437[ebp], ecx
	cmp	DWORD PTR tv437[ebp], 1024		; 00000400H
	jg	SHORT $LN135@fnSetEntit
	cmp	DWORD PTR tv437[ebp], 1024		; 00000400H
	je	$LN91@fnSetEntit
	cmp	DWORD PTR tv437[ebp], 256		; 00000100H
	je	SHORT $LN84@fnSetEntit
	cmp	DWORD PTR tv437[ebp], 512		; 00000200H
	je	$LN106@fnSetEntit
	jmp	$LN58@fnSetEntit
$LN135@fnSetEntit:
	cmp	DWORD PTR tv437[ebp], 2048		; 00000800H
	je	$LN89@fnSetEntit
	jmp	$LN58@fnSetEntit
$LN84@fnSetEntit:

; 4083 :       {
; 4084 :          case zQUAL_INTEGER:
; 4085 :             if ( lpViewEntityAttrib->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN85@fnSetEntit

; 4086 :                break;

	jmp	$LN58@fnSetEntit
$LN85@fnSetEntit:

; 4087 : 
; 4088 :             switch ( lpViewEntityAttrib->cType )

	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv443[ebp], dl
	cmp	BYTE PTR tv443[ebp], 77			; 0000004dH
	je	SHORT $LN87@fnSetEntit
	cmp	BYTE PTR tv443[ebp], 83			; 00000053H
	je	SHORT $LN86@fnSetEntit
	jmp	SHORT $LN88@fnSetEntit
$LN86@fnSetEntit:

; 4089 :             {
; 4090 :                case zTYPE_STRING:
; 4091 :                   // convert integer qualifier to a string
; 4092 :                   zltoa( *((zPLONG) pQualValue), unTemp.szString );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _unTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 4093 :                   lQualRequest = zQUAL_STRING;

	mov	DWORD PTR _lQualRequest$[ebp], 1024	; 00000400H

; 4094 :                   pQualValue = &unTemp;

	lea	eax, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], eax

; 4095 :                   break;

	jmp	$LN14@fnSetEntit
$LN87@fnSetEntit:

; 4096 : 
; 4097 :                case zTYPE_DECIMAL:
; 4098 :                   // convert integer qualifier to decimal
; 4099 :                   SysConvertLongToDecimal( *((zPLONG) pQualValue),

	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pQualValue$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SysConvertLongToDecimal@8

; 4100 :                                            &unTemp.dDecimal );
; 4101 :                   lQualRequest = zQUAL_DECIMAL;

	mov	DWORD PTR _lQualRequest$[ebp], 512	; 00000200H

; 4102 :                   pQualValue = &unTemp;

	lea	ecx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], ecx

; 4103 :                   break;

	jmp	$LN14@fnSetEntit
$LN88@fnSetEntit:

; 4104 : 
; 4105 :                default:
; 4106 :                {
; 4107 :                   zCHAR    sz[ 256 ];
; 4108 :                   zSHORT   n;
; 4109 : 
; 4110 :                   // "KZOEE263 - Input Qualifier cannot be converted to
; 4111 :                   //  internal attribute data type"
; 4112 :                   zstrcpy( sz, "(L->" );

	push	OFFSET $SG14752
	lea	edx, DWORD PTR _sz$19[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4113 :                   n = zstrlen( sz );

	lea	eax, DWORD PTR _sz$19[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n$10[ebp], ax

; 4114 :                   *( sz + n++ ) = lpViewEntityAttrib->cType;

	movsx	ecx, WORD PTR _n$10[ebp]
	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR _sz$19[ebp+ecx], al
	mov	cx, WORD PTR _n$10[ebp]
	add	cx, 1
	mov	WORD PTR _n$10[ebp], cx

; 4115 :                   *( sz + n++ ) = 0;

	movsx	edx, WORD PTR _n$10[ebp]
	mov	BYTE PTR _sz$19[ebp+edx], 0
	mov	ax, WORD PTR _n$10[ebp]
	add	ax, 1
	mov	WORD PTR _n$10[ebp], ax

; 4116 :                   zstrcat( sz, "), " );

	push	OFFSET $SG14753
	lea	ecx, DWORD PTR _sz$19[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4117 :                   zstrcat( sz, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _sz$19[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 4118 :                   fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz,

	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _sz$19[ebp]
	push	edx
	push	0
	push	263					; 00000107H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4119 :                                     lpViewEntityAttrib->szName );
; 4120 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN14@fnSetEntit:

; 4121 :                }
; 4122 :             }
; 4123 : 
; 4124 :             break;

	jmp	$LN58@fnSetEntit
$LN89@fnSetEntit:

; 4125 : 
; 4126 :          case zQUAL_DATETIME:
; 4127 :          {
; 4128 :             zCHAR    sz[ 256 ];
; 4129 : 
; 4130 :             if ( lpViewEntityAttrib->cType == zTYPE_DATETIME )

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 84					; 00000054H
	jne	SHORT $LN90@fnSetEntit

; 4131 :                break;

	jmp	$LN58@fnSetEntit
$LN90@fnSetEntit:

; 4132 : 
; 4133 :             // "KZOEE263 - Input Qualifier cannot be converted to
; 4134 :             //  internal attribute data type"
; 4135 :             zstrcpy( sz, "(?->DT), " );

	push	OFFSET $SG14756
	lea	ecx, DWORD PTR _sz$14[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4136 :             zstrcat( sz, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _sz$14[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 4137 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz,

	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _sz$14[ebp]
	push	edx
	push	0
	push	263					; 00000107H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4138 :                               lpViewEntityAttrib->szName );
; 4139 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN91@fnSetEntit:

; 4140 :          }
; 4141 : 
; 4142 :          case zQUAL_STRING:
; 4143 :             if ( lpViewEntityAttrib->cType == zTYPE_STRING )

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN92@fnSetEntit

; 4144 :                break;

	jmp	$LN58@fnSetEntit
$LN92@fnSetEntit:

; 4145 : 
; 4146 :             switch ( lpViewEntityAttrib->cType )

	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv499[ebp], dl
	cmp	BYTE PTR tv499[ebp], 76			; 0000004cH
	je	SHORT $LN93@fnSetEntit
	cmp	BYTE PTR tv499[ebp], 77			; 0000004dH
	je	$LN99@fnSetEntit
	jmp	$LN105@fnSetEntit
$LN93@fnSetEntit:

; 4147 :             {
; 4148 :                case zTYPE_INTEGER:
; 4149 :                   // convert string qualifier to integer
; 4150 :                   if ( pQualValue == 0 || *((zPCHAR) pQualValue) == 0 )

	cmp	DWORD PTR _pQualValue$[ebp], 0
	je	SHORT $LN96@fnSetEntit
	mov	eax, DWORD PTR _pQualValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN94@fnSetEntit
$LN96@fnSetEntit:

; 4151 :                   {
; 4152 :                      lQualRequest = zQUAL_INTEGER;

	mov	DWORD PTR _lQualRequest$[ebp], 256	; 00000100H

; 4153 :                      unTemp.lInteger = lNullInteger;

	mov	edx, DWORD PTR _lNullInteger
	mov	DWORD PTR _unTemp$[ebp], edx

; 4154 :                      pQualValue = &unTemp;

	lea	eax, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], eax

; 4155 :                   }

	jmp	$LN95@fnSetEntit
$LN94@fnSetEntit:

; 4156 :                   else
; 4157 :                   if ( fnValidNumericString( &unTemp.lInteger,

	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_fnValidNumericString
	add	esp, 8
	cwde
	test	eax, eax
	je	SHORT $LN97@fnSetEntit

; 4158 :                                              (zCPCHAR) pQualValue ) )
; 4159 :                   {
; 4160 :                      lQualRequest = zQUAL_INTEGER;

	mov	DWORD PTR _lQualRequest$[ebp], 256	; 00000100H

; 4161 :                      pQualValue = &unTemp.lInteger;

	lea	ecx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], ecx

; 4162 :                   }

	jmp	SHORT $LN95@fnSetEntit
$LN97@fnSetEntit:

; 4163 :                   else
; 4164 :                   {
; 4165 :                      zCHAR    sz[ 256 ];
; 4166 :                      // "KZOEE263 - Input Qualifier cannot be converted to
; 4167 :                      //  internal attribute data type"
; 4168 :                      zstrcpy( sz, "(S->L), " );

	push	OFFSET $SG14765
	lea	edx, DWORD PTR _sz$15[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4169 :                      zstrcat( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$15[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4170 :                      fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz,

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz$15[ebp]
	push	eax
	push	0
	push	263					; 00000107H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4171 :                                        lpViewEntityAttrib->szName );
; 4172 :                      return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN95@fnSetEntit:

; 4173 :                   }
; 4174 : 
; 4175 :                   break;

	jmp	$LN16@fnSetEntit
$LN99@fnSetEntit:

; 4176 : 
; 4177 :                case zTYPE_DECIMAL:
; 4178 :                   // convert string qualifier to decimal
; 4179 :                   if ( pQualValue == 0 || *((zPCHAR) pQualValue) == 0 )

	cmp	DWORD PTR _pQualValue$[ebp], 0
	je	SHORT $LN102@fnSetEntit
	mov	eax, DWORD PTR _pQualValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN100@fnSetEntit
$LN102@fnSetEntit:

; 4180 :                   {
; 4181 :                      lQualRequest = zQUAL_DECIMAL;

	mov	DWORD PTR _lQualRequest$[ebp], 512	; 00000200H

; 4182 :                      SysAssignDecimalFromNull( &unTemp.dDecimal );

	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_SysAssignDecimalFromNull@4

; 4183 :                      pQualValue = &unTemp;

	lea	eax, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], eax

; 4184 :                   }

	jmp	$LN101@fnSetEntit
$LN100@fnSetEntit:

; 4185 :                   else
; 4186 :                   if ( fnValidDecimalString( &unTemp.dDecimal,

	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _unTemp$[ebp]
	push	edx
	call	_fnValidDecimalString
	add	esp, 8
	cwde
	test	eax, eax
	je	SHORT $LN103@fnSetEntit

; 4187 :                                              (zCPCHAR) pQualValue ) )
; 4188 :                   {
; 4189 :                      lQualRequest = zQUAL_DECIMAL;

	mov	DWORD PTR _lQualRequest$[ebp], 512	; 00000200H

; 4190 :                      pQualValue = &unTemp;

	lea	ecx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], ecx

; 4191 :                   }

	jmp	SHORT $LN101@fnSetEntit
$LN103@fnSetEntit:

; 4192 :                   else
; 4193 :                   {
; 4194 :                      zCHAR    sz[ 256 ];
; 4195 : 
; 4196 :                      // "KZOEE263 - Input Qualifier cannot be converted to
; 4197 :                      //  internal attribute data type"
; 4198 :                      zstrcpy( sz, "(S->M), " );

	push	OFFSET $SG14772
	lea	edx, DWORD PTR _sz$16[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4199 :                      zstrcat( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$16[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4200 :                      fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz,

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz$16[ebp]
	push	eax
	push	0
	push	263					; 00000107H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4201 :                                        lpViewEntityAttrib->szName );
; 4202 :                      return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN101@fnSetEntit:

; 4203 :                   }
; 4204 : 
; 4205 :                   break;

	jmp	$LN16@fnSetEntit
$LN105@fnSetEntit:

; 4206 : 
; 4207 :                default:
; 4208 :                {
; 4209 :                   zCHAR    sz[ 256 ];
; 4210 :                   zSHORT   n;
; 4211 : 
; 4212 :                   // "KZOEE263 - Input Qualifier cannot be converted to
; 4213 :                   //  internal attribute data type"
; 4214 :                   zstrcpy( sz, "(S->" );

	push	OFFSET $SG14774
	lea	eax, DWORD PTR _sz$18[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4215 :                   n = zstrlen( sz );

	lea	ecx, DWORD PTR _sz$18[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n$9[ebp], ax

; 4216 :                   *( sz + n++ ) = lpViewEntityAttrib->cType;

	movsx	edx, WORD PTR _n$9[ebp]
	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR _sz$18[ebp+edx], cl
	mov	dx, WORD PTR _n$9[ebp]
	add	dx, 1
	mov	WORD PTR _n$9[ebp], dx

; 4217 :                   *( sz + n++ ) = 0;

	movsx	eax, WORD PTR _n$9[ebp]
	mov	BYTE PTR _sz$18[ebp+eax], 0
	mov	cx, WORD PTR _n$9[ebp]
	add	cx, 1
	mov	WORD PTR _n$9[ebp], cx

; 4218 :                   zstrcat( sz, "), " );

	push	OFFSET $SG14775
	lea	edx, DWORD PTR _sz$18[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4219 :                   zstrcat( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$18[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4220 :                   fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz,

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz$18[ebp]
	push	eax
	push	0
	push	263					; 00000107H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4221 :                                     lpViewEntityAttrib->szName );
; 4222 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN16@fnSetEntit:

; 4223 :                }
; 4224 :             }
; 4225 : 
; 4226 :             break;

	jmp	$LN58@fnSetEntit
$LN106@fnSetEntit:

; 4227 : 
; 4228 :          case zQUAL_DECIMAL:
; 4229 :             if ( lpViewEntityAttrib->cType == zTYPE_DECIMAL )

	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 77					; 0000004dH
	jne	SHORT $LN107@fnSetEntit

; 4230 :                break;

	jmp	$LN58@fnSetEntit
$LN107@fnSetEntit:

; 4231 : 
; 4232 :             switch ( lpViewEntityAttrib->cType )

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv577[ebp], al
	cmp	BYTE PTR tv577[ebp], 76			; 0000004cH
	je	SHORT $LN108@fnSetEntit
	cmp	BYTE PTR tv577[ebp], 83			; 00000053H
	je	SHORT $LN109@fnSetEntit
	jmp	SHORT $LN110@fnSetEntit
$LN108@fnSetEntit:

; 4233 :             {
; 4234 :                case zTYPE_INTEGER:
; 4235 :                   // convert decimal qualifier to integer
; 4236 :                   SysConvertDecimalToLong( (zPDECIMAL) pQualValue,

	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pQualValue$[ebp]
	push	edx
	call	_SysConvertDecimalToLong@8

; 4237 :                                            &unTemp.lInteger );
; 4238 :                   lQualRequest = zQUAL_INTEGER;

	mov	DWORD PTR _lQualRequest$[ebp], 256	; 00000100H

; 4239 :                   pQualValue = &unTemp;

	lea	eax, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], eax

; 4240 :                   break;

	jmp	$LN18@fnSetEntit
$LN109@fnSetEntit:

; 4241 : 
; 4242 :                case zTYPE_STRING:
; 4243 :                   // convert decimal qualifier to string
; 4244 :                   ConvertDecimalToString( unTemp.szString, 0,

	push	0
	mov	esi, DWORD PTR _pQualValue$[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	0
	lea	ecx, DWORD PTR _unTemp$[ebp]
	push	ecx
	call	_ConvertDecimalToString@52

; 4245 :                                           *((zPDECIMAL)pQualValue), 0 );
; 4246 :                   lQualRequest = zQUAL_STRING;

	mov	DWORD PTR _lQualRequest$[ebp], 1024	; 00000400H

; 4247 :                   pQualValue = &unTemp;

	lea	edx, DWORD PTR _unTemp$[ebp]
	mov	DWORD PTR _pQualValue$[ebp], edx

; 4248 :                   break;

	jmp	$LN18@fnSetEntit
$LN110@fnSetEntit:

; 4249 : 
; 4250 :                default:
; 4251 :                {
; 4252 :                   zCHAR   sz[ 256 ];
; 4253 :                   zSHORT  n;
; 4254 : 
; 4255 :                   // "KZOEE263 - Input Qualifier cannot be converted to
; 4256 :                   //  internal attribute data type"
; 4257 :                   zstrcpy( sz, "(M->" );

	push	OFFSET $SG14781
	lea	eax, DWORD PTR _sz$17[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4258 :                   n = zstrlen( sz );

	lea	ecx, DWORD PTR _sz$17[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n$8[ebp], ax

; 4259 :                   *(sz + n++) = lpViewEntityAttrib->cType;

	movsx	edx, WORD PTR _n$8[ebp]
	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR _sz$17[ebp+edx], cl
	mov	dx, WORD PTR _n$8[ebp]
	add	dx, 1
	mov	WORD PTR _n$8[ebp], dx

; 4260 :                   *(sz + n++) = 0;

	movsx	eax, WORD PTR _n$8[ebp]
	mov	BYTE PTR _sz$17[ebp+eax], 0
	mov	cx, WORD PTR _n$8[ebp]
	add	cx, 1
	mov	WORD PTR _n$8[ebp], cx

; 4261 :                   zstrcat( sz, "), " );

	push	OFFSET $SG14782
	lea	edx, DWORD PTR _sz$17[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4262 :                   zstrcat( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$17[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4263 :                   fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz,

	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _sz$17[ebp]
	push	eax
	push	0
	push	263					; 00000107H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4264 :                                     lpViewEntityAttrib->szName );
; 4265 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN123@fnSetEntit
$LN18@fnSetEntit:

; 4266 :                }
; 4267 :             }
; 4268 : 
; 4269 :             unTemp.dDecimal = *((zPDECIMAL) pQualValue);

	mov	ecx, 10					; 0000000aH
	mov	esi, DWORD PTR _pQualValue$[ebp]
	lea	edi, DWORD PTR _unTemp$[ebp]
	rep movsd
$LN58@fnSetEntit:

; 4270 :             break;
; 4271 : 
; 4272 :          case zQUAL_ENTITYCSR:
; 4273 :          case zQUAL_ENTITYATTR:
; 4274 :          default:
; 4275 :             break;
; 4276 :       }
; 4277 :    }
; 4278 : 
; 4279 :    // The following is necessary when we are not going to perform domain
; 4280 :    // processing, but the attribute is derived.
; 4281 : // if ( vAttrView == 0 &&
; 4282 : //      (((cpcContextName == 0 || cpcContextName[ 0 ] == 0) &&
; 4283 : //        lpViewEntityAttrib && lpViewEntityAttrib->szDerivedOper[ 0 ]) ||
; 4284 : //       (cDomainType == zDM_TYPE_FORMAT && cpcContextName && *cpcContextName)) )
; 4285 :    if ( vAttrView == 0 &&

	cmp	DWORD PTR _vAttrView$[ebp], 0
	jne	SHORT $LN112@fnSetEntit
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN113@fnSetEntit
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN112@fnSetEntit
$LN113@fnSetEntit:
	cmp	DWORD PTR _lpViewEntityAttrib$[ebp], 0
	je	SHORT $LN112@fnSetEntit
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN112@fnSetEntit

; 4286 :         ((cpcContextName == 0 || cpcContextName[ 0 ] == 0) &&
; 4287 :          lpViewEntityAttrib && lpViewEntityAttrib->szDerivedOper[ 0 ]) )
; 4288 :    {
; 4289 :       // Create 'Temporary' view for derived attribute.
; 4290 :       nRC = CreateViewFromViewForTask( &vAttrView, lpView, 0 );

	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax

; 4291 :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN112@fnSetEntit

; 4292 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN123@fnSetEntit
$LN112@fnSetEntit:

; 4293 :    }
; 4294 : 
; 4295 :    // DGC 10/9/96 - Tried to fix a bug.  The problem occurs when we are
; 4296 :    // setting a cursor from an attribute.  If the target attribute has a
; 4297 :    // domain different from the source attribute, then fnScanEI_NoScoping
; 4298 :    // will try to do something with vAttrView.  The problem is that vAttrView
; 4299 :    // is sometimes 0.  As a hack, we will set vAttrView to something.  This
; 4300 :    // shouldn't have any adverse affects.  Checking for zQUAL_ENTITYATTR
; 4301 :    // means that pQualValue is really a view.
; 4302 :    if ( lQualRequest == zQUAL_ENTITYATTR && vAttrView == 0 && pQualValue &&

	cmp	DWORD PTR _lQualRequest$[ebp], 4096	; 00001000H
	jne	SHORT $LN115@fnSetEntit
	cmp	DWORD PTR _vAttrView$[ebp], 0
	jne	SHORT $LN115@fnSetEntit
	cmp	DWORD PTR _pQualValue$[ebp], 0
	je	SHORT $LN115@fnSetEntit
	mov	edx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	mov	ecx, DWORD PTR [edx+198]
	cmp	ecx, DWORD PTR [eax+198]
	je	SHORT $LN115@fnSetEntit

; 4303 :         lpSrcViewEntityAttrib->hDomain != lpViewEntityAttrib->hDomain )
; 4304 :    {
; 4305 :       nRC = CreateViewFromViewForTask( &vAttrView, (zVIEW) pQualValue, 0 );

	push	0
	mov	edx, DWORD PTR _pQualValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax

; 4306 :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN115@fnSetEntit

; 4307 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN123@fnSetEntit
$LN115@fnSetEntit:

; 4308 :    }
; 4309 : 
; 4310 :    // See if scoping entity is the parent of the target entity.
; 4311 :    if ( lpScopingViewEntityCsr == 0 ||

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN119@fnSetEntit
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	jne	$LN117@fnSetEntit
	movzx	ecx, BYTE PTR _bRecurse$[ebp]
	test	ecx, ecx
	jne	$LN117@fnSetEntit
$LN119@fnSetEntit:

; 4312 :         (zGETPTR( lpViewEntityCsr->hParent ) == lpScopingViewEntityCsr &&
; 4313 :          bRecurse == FALSE) )
; 4314 :    {
; 4315 :       nRC = fnScanEI_NoScoping( lpView,

	movzx	edx, BYTE PTR _bCursorTest$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bSameParentKeepChildren$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bRelPosition$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bSelectRelevant$[ebp]
	push	edx
	movzx	eax, WORD PTR _nDesiredSelectState$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lQualOperator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lQualRequest$[ebp]
	push	edx
	mov	eax, DWORD PTR _lAbsPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vAttrView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lRelPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnScanEI_NoScoping
	add	esp, 84					; 00000054H
	mov	WORD PTR _nRC$[ebp], ax

; 4316 :                                 lpViewEntity,
; 4317 :                                 lpViewEntityCsr,
; 4318 :                                 lpViewEntityAttrib,
; 4319 :                                 pQualValue,
; 4320 :                                 lpSrcViewEntityCsr,
; 4321 :                                 lpSrcViewEntityAttrib,
; 4322 :                                 lRelPosition,
; 4323 :                                 lpScopingViewEntityCsr,
; 4324 :                                 cpcContextName,
; 4325 :                                 lpCurrentTask,
; 4326 :                                 lpSrcEntityInstance,
; 4327 :                                 vAttrView,
; 4328 :                                 lAbsPosition,
; 4329 :                                 lQualRequest,
; 4330 :                                 lQualOperator,
; 4331 :                                 nDesiredSelectState,
; 4332 :                                 bSelectRelevant,
; 4333 :                                 bRelPosition,
; 4334 :                                 bSameParentKeepChildren,
; 4335 :                                 bCursorTest );
; 4336 :    }

	jmp	$LN118@fnSetEntit
$LN117@fnSetEntit:

; 4337 :    else
; 4338 :    {
; 4339 :       nRC = fnScanEI_Scoping( lpView,

	movzx	edx, BYTE PTR _bCursorTest$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bRecurse$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _bSameParentKeepChildren$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bRelPosition$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bSelectRelevant$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nDesiredSelectState$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lQualOperator$[ebp]
	push	edx
	mov	eax, DWORD PTR _lQualRequest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lAbsPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vAttrView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lRelPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnScanEI_Scoping
	add	esp, 88					; 00000058H
	mov	WORD PTR _nRC$[ebp], ax
$LN118@fnSetEntit:

; 4340 :                               lpViewEntity,
; 4341 :                               lpViewEntityCsr,
; 4342 :                               lpViewEntityAttrib,
; 4343 :                               pQualValue,
; 4344 :                               lpSrcViewEntityCsr,
; 4345 :                               lpSrcViewEntityAttrib,
; 4346 :                               lRelPosition,
; 4347 :                               lpScopingViewEntityCsr,
; 4348 :                               cpcContextName,
; 4349 :                               lpCurrentTask,
; 4350 :                               lpSrcEntityInstance,
; 4351 :                               vAttrView,
; 4352 :                               lAbsPosition,
; 4353 :                               lQualRequest,
; 4354 :                               lQualOperator,
; 4355 :                               nDesiredSelectState,
; 4356 :                               bSelectRelevant,
; 4357 :                               bRelPosition,
; 4358 :                               bSameParentKeepChildren,
; 4359 :                               bRecurse,
; 4360 :                               bCursorTest );
; 4361 :    }
; 4362 : 
; 4363 :    // Drop 'Temporary' view for derived attribute and also for
; 4364 :    // domain processing.
; 4365 :    if ( vAttrView )

	cmp	DWORD PTR _vAttrView$[ebp], 0
	je	SHORT $LN120@fnSetEntit

; 4366 :       DropView( vAttrView );

	mov	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_DropView@4
$LN120@fnSetEntit:

; 4367 : 
; 4368 :    // We have set the cursor so it should point to a valid entity or the
; 4369 :    // result is undefined.  Now is a good time to try and clean up "dead"
; 4370 :    // entity instances.
; 4371 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4372 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4373 :    if ( lpViewOI->nHiddenCount > __RECLAIM_LIMIT__ )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+24]
	cmp	eax, 20					; 00000014H
	jle	SHORT $LN121@fnSetEntit

; 4374 :       fnReclaimHiddenInstances( lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	_fnReclaimHiddenInstances@4
$LN121@fnSetEntit:

; 4375 : 
; 4376 :    // Maintain the last accessed entity, so that it is possible to determine
; 4377 :    // which entity was accessed by the last successful "SET CURSOR".
; 4378 :    // Note:  we asked for the cursor to be set ...  so if it is unchanged it
; 4379 :    // is set!  zCURSOR_SET  // dks 2004.03.17
; 4380 :    if ( nRC >= zCURSOR_UNCHANGED && bCursorTest == FALSE )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $LN122@fnSetEntit
	movzx	eax, BYTE PTR _bCursorTest$[ebp]
	test	eax, eax
	jne	SHORT $LN122@fnSetEntit

; 4381 :       fnCallListeners( lpView, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCallListeners
	add	esp, 8
$LN122@fnSetEntit:

; 4382 : 
; 4383 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN123@fnSetEntit:

; 4384 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN137@fnSetEntit:
	DD	$LN33@fnSetEntit
	DD	$LN29@fnSetEntit
	DD	$LN30@fnSetEntit
	DD	$LN31@fnSetEntit
	DD	$LN32@fnSetEntit
	DD	$LN28@fnSetEntit
$LN136@fnSetEntit:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
	npad	1
$LN138@fnSetEntit:
	DD	$LN49@fnSetEntit
	DD	$LN54@fnSetEntit
	DD	$LN51@fnSetEntit
	DD	$LN51@fnSetEntit
	DD	$LN52@fnSetEntit
	DD	$LN53@fnSetEntit
$LN139@fnSetEntit:
	DD	$LN71@fnSetEntit
	DD	$LN77@fnSetEntit
	DD	$LN73@fnSetEntit
	DD	$LN74@fnSetEntit
	DD	$LN75@fnSetEntit
	DD	$LN76@fnSetEntit
_fnSetEntityCursor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpEntityInstance$1 = -44				; size = 4
_lpViewEntity$2 = -40					; size = 4
tv240 = -36						; size = 4
tv219 = -32						; size = 4
tv217 = -28						; size = 4
tv66 = -24						; size = 4
tv71 = -20						; size = 4
_lCurrRelPosition$ = -16				; size = 4
_lpSearchEntityInstance$ = -12				; size = 4
_nRC$ = -8						; size = 2
_bFound$3 = -4						; size = 1
_bForward$4 = -3					; size = 1
_bDoRelPosition$ = -2					; size = 1
_bAbsPosition_Forward$ = -1				; size = 1
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpViewEntityAttrib$ = 20				; size = 4
_pQualValue$ = 24					; size = 4
_lpSrcViewEntityCsr$ = 28				; size = 4
_lpSrcViewEntityAttrib$ = 32				; size = 4
_lRelPosition$ = 36					; size = 4
_lpScopingViewEntityCsr$ = 40				; size = 4
_cpcContextName$ = 44					; size = 4
_lpCurrentTask$ = 48					; size = 4
_lpSrcEntityInstance$ = 52				; size = 4
_vAttrView$ = 56					; size = 4
_lAbsPosition$ = 60					; size = 4
_lQualRequest$ = 64					; size = 4
_lQualOperator$ = 68					; size = 4
_nDesiredSelectState$ = 72				; size = 2
_bSelectRelevant$ = 76					; size = 1
_bRelPosition$ = 80					; size = 1
_bSameParentKeepChildren$ = 84				; size = 1
_bCursorTest$ = 88					; size = 1
_fnScanEI_NoScoping PROC

; 4408 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 4409 :    LPENTITYINSTANCE lpSearchEntityInstance;
; 4410 :    zBOOL    bAbsPosition_Forward; // indicates direction of 'absolute' positioning
; 4411 :    zBOOL    bDoRelPosition = 0;

	mov	BYTE PTR _bDoRelPosition$[ebp], 0

; 4412 :    zLONG    lCurrRelPosition;
; 4413 :    zSHORT   nRC = zCURSOR_NULL;

	mov	eax, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], ax

; 4414 : 
; 4415 :    // Relative positioning requested.
; 4416 :    lCurrRelPosition = bRelPosition ? lRelPosition : 0;

	movzx	ecx, BYTE PTR _bRelPosition$[ebp]
	test	ecx, ecx
	je	SHORT $LN46@fnScanEI_N
	mov	edx, DWORD PTR _lRelPosition$[ebp]
	mov	DWORD PTR tv66[ebp], edx
	jmp	SHORT $LN47@fnScanEI_N
$LN46@fnScanEI_N:
	mov	DWORD PTR tv66[ebp], 0
$LN47@fnScanEI_N:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR _lCurrRelPosition$[ebp], eax

; 4417 : 
; 4418 :    lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4419 :    if ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	$LN12@fnScanEI_N

; 4420 :    {
; 4421 :       switch ( lAbsPosition )

	mov	eax, DWORD PTR _lAbsPosition$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR tv71[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv71[ebp], ecx
	cmp	DWORD PTR tv71[ebp], 3
	ja	SHORT $LN17@fnScanEI_N
	mov	edx, DWORD PTR tv71[ebp]
	jmp	DWORD PTR $LN54@fnScanEI_N[edx*4]
$LN13@fnScanEI_N:

; 4422 :       {
; 4423 :          case zPOS_FIRST:
; 4424 :             // Back up to beginning of chain.
; 4425 :             bAbsPosition_Forward = TRUE;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 1
$LN4@fnScanEI_N:

; 4426 :             while ( lpSearchEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN5@fnScanEI_N

; 4427 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnScanEI_N
$LN5@fnScanEI_N:

; 4428 : 
; 4429 :             break;

	jmp	SHORT $LN8@fnScanEI_N
$LN14@fnScanEI_N:

; 4430 : 
; 4431 :          case zPOS_NEXT:
; 4432 :             // Bump to next twin.
; 4433 :             bAbsPosition_Forward = TRUE;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 1

; 4434 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4435 :             break;

	jmp	SHORT $LN8@fnScanEI_N
$LN15@fnScanEI_N:

; 4436 : 
; 4437 :          case zPOS_PREV:
; 4438 :             // Bump to prev twin.
; 4439 :             bAbsPosition_Forward = FALSE;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 0

; 4440 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4441 :             break;

	jmp	SHORT $LN8@fnScanEI_N
$LN16@fnScanEI_N:

; 4442 : 
; 4443 :          case zPOS_LAST:
; 4444 :             // Go to the end of the chain.
; 4445 :             bAbsPosition_Forward = FALSE;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 0
$LN6@fnScanEI_N:

; 4446 :             while ( lpSearchEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN7@fnScanEI_N

; 4447 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN6@fnScanEI_N
$LN7@fnScanEI_N:

; 4448 : 
; 4449 :             break;

	jmp	SHORT $LN8@fnScanEI_N
$LN17@fnScanEI_N:

; 4450 : 
; 4451 :          default:
; 4452 :             // Relative positioning only ...
; 4453 :             lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN8@fnScanEI_N:

; 4454 :             break;
; 4455 :       }
; 4456 : 
; 4457 :       while ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	$LN9@fnScanEI_N

; 4458 :       {
; 4459 :          if ( lpSearchEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	$LN18@fnScanEI_N

; 4460 :          {
; 4461 :             // SelectState
; 4462 :             if ( (bSelectRelevant == FALSE ||
; 4463 :                  ((fnSelectedInstanceFarbler( zGETPTR( lpViewEntityCsr->hViewCsr ),
; 4464 :                                               zGETPTR( lpSearchEntityInstance->hViewEntity ),
; 4465 :                                               zGETHNDL( lpSearchEntityInstance ), 1 )
; 4466 :                               == nDesiredSelectState))) &&

	movzx	edx, BYTE PTR _bSelectRelevant$[ebp]
	test	edx, edx
	je	SHORT $LN20@fnScanEI_N
	push	1
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	movsx	edx, ax
	movsx	eax, WORD PTR _nDesiredSelectState$[ebp]
	cmp	edx, eax
	jne	SHORT $LN18@fnScanEI_N
$LN20@fnScanEI_N:
	cmp	DWORD PTR _lQualRequest$[ebp], 0
	je	SHORT $LN21@fnScanEI_N
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lQualOperator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lQualRequest$[ebp]
	push	edx
	mov	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_fnQualifiedInstance
	add	esp, 48					; 00000030H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN18@fnScanEI_N
$LN21@fnScanEI_N:

; 4467 :                 // Qualification
; 4468 :                 // Determine if this lpSearchEntityInstance matches the
; 4469 :                 // requested qualifications.
; 4470 :                  (lQualRequest == 0 ||
; 4471 :                   fnQualifiedInstance( vAttrView,
; 4472 :                                        lQualRequest,
; 4473 :                                        lQualOperator,
; 4474 :                                        pQualValue,
; 4475 :                                        lpSearchEntityInstance,
; 4476 :                                        lpViewEntityCsr,
; 4477 :                                        lpViewEntityAttrib,
; 4478 :                                        lpSrcEntityInstance,
; 4479 :                                        lpSrcViewEntityCsr,
; 4480 :                                        lpSrcViewEntityAttrib,
; 4481 :                                        cpcContextName,
; 4482 :                                        lpCurrentTask )) )
; 4483 :             {
; 4484 :                // We have satisfied Select state and Qualification criteria,
; 4485 :                // see if we need to perform any relative positioning ...
; 4486 :                if ( bRelPosition )

	movzx	edx, BYTE PTR _bRelPosition$[ebp]
	test	edx, edx
	je	SHORT $LN22@fnScanEI_N

; 4487 :                   if ( lCurrRelPosition == 0 )

	cmp	DWORD PTR _lCurrRelPosition$[ebp], 0
	jne	SHORT $LN24@fnScanEI_N

; 4488 :                      break;

	jmp	$LN9@fnScanEI_N
	jmp	SHORT $LN25@fnScanEI_N
$LN24@fnScanEI_N:

; 4489 :                   else
; 4490 :                   {
; 4491 :                      // If we are here, we are about to perform a
; 4492 :                      // relative positioning.
; 4493 :                      bDoRelPosition = TRUE;

	mov	BYTE PTR _bDoRelPosition$[ebp], 1
$LN25@fnScanEI_N:

; 4494 :                   }

	jmp	SHORT $LN18@fnScanEI_N
$LN22@fnScanEI_N:

; 4495 :                else
; 4496 :                   break;

	jmp	SHORT $LN9@fnScanEI_N
$LN18@fnScanEI_N:

; 4497 :             }
; 4498 :          }
; 4499 : 
; 4500 :          if ( bDoRelPosition )

	movzx	eax, BYTE PTR _bDoRelPosition$[ebp]
	test	eax, eax
	je	SHORT $LN26@fnScanEI_N

; 4501 :          {
; 4502 :             // Time to perform a relative positioning move ...
; 4503 :             if ( lCurrRelPosition > 0 )

	cmp	DWORD PTR _lCurrRelPosition$[ebp], 0
	jle	SHORT $LN28@fnScanEI_N

; 4504 :             {
; 4505 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4506 :                lCurrRelPosition--;

	mov	eax, DWORD PTR _lCurrRelPosition$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lCurrRelPosition$[ebp], eax

; 4507 :             }

	jmp	SHORT $LN29@fnScanEI_N
$LN28@fnScanEI_N:

; 4508 :             else
; 4509 :             {
; 4510 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4511 :                lCurrRelPosition++;

	mov	eax, DWORD PTR _lCurrRelPosition$[ebp]
	add	eax, 1
	mov	DWORD PTR _lCurrRelPosition$[ebp], eax
$LN29@fnScanEI_N:

; 4512 :             }
; 4513 : 
; 4514 :             bDoRelPosition = 0;  // reset indicator

	mov	BYTE PTR _bDoRelPosition$[ebp], 0

; 4515 :          }

	jmp	SHORT $LN27@fnScanEI_N
$LN26@fnScanEI_N:

; 4516 :          else
; 4517 :          {
; 4518 :             if ( bAbsPosition_Forward )

	movzx	ecx, BYTE PTR _bAbsPosition_Forward$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@fnScanEI_N

; 4519 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN27@fnScanEI_N
$LN30@fnScanEI_N:

; 4520 :             else
; 4521 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN27@fnScanEI_N:

; 4522 :          }
; 4523 :       } // end of while ( lpSearchEntityInstance )

	jmp	$LN8@fnScanEI_N
$LN9@fnScanEI_N:

; 4524 : 
; 4525 :       // We are now at the requested link in the chain, or we have
; 4526 :       // gone off one of the ends...
; 4527 :       if ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN32@fnScanEI_N

; 4528 :       {
; 4529 :          if ( lAbsPosition == 0 && lRelPosition == 0 )

	cmp	DWORD PTR _lAbsPosition$[ebp], 0
	jne	SHORT $LN34@fnScanEI_N
	cmp	DWORD PTR _lRelPosition$[ebp], 0
	jne	SHORT $LN34@fnScanEI_N

; 4530 :          {
; 4531 :             LPVIEWENTITY lpViewEntity = zGETPTR( lpSearchEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 4532 : 
; 4533 :             // This is when only Relative positioning is requested and
; 4534 :             // the relative position specified was zero ...
; 4535 :             return( CheckExistenceOfEntity( lpView, lpViewEntity->szName ) );

	mov	edx, DWORD PTR _lpViewEntity$2[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_CheckExistenceOfEntity@8
	jmp	$LN1@fnScanEI_N
$LN34@fnScanEI_N:

; 4536 :          }
; 4537 : 
; 4538 :          nRC = zCURSOR_SET;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 4539 :          if ( bCursorTest == FALSE )

	movzx	edx, BYTE PTR _bCursorTest$[ebp]
	test	edx, edx
	jne	SHORT $LN35@fnScanEI_N

; 4540 :          {
; 4541 :             if ( bSameParentKeepChildren == FALSE ||

	movzx	eax, BYTE PTR _bSameParentKeepChildren$[ebp]
	test	eax, eax
	je	SHORT $LN37@fnScanEI_N
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	je	SHORT $LN35@fnScanEI_N
$LN37@fnScanEI_N:

; 4542 :                  zGETPTR( lpViewEntityCsr->hEntityInstance ) != lpSearchEntityInstance )
; 4543 :             {
; 4544 :                lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 4545 :             // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 4546 :             //    SysMessageBox( 0, "ScanEI_NoScoping", "UNSET_CSR", -1 );
; 4547 : 
; 4548 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN35@fnScanEI_N:

; 4549 :             }
; 4550 :          }
; 4551 :       }

	jmp	$LN12@fnScanEI_N
$LN32@fnScanEI_N:

; 4552 :       else
; 4553 :       {
; 4554 :          LPENTITYINSTANCE lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$1[ebp], eax

; 4555 : 
; 4556 :          // We didn't find anything yet, so position on the first
; 4557 :          // unhidden entity instance and indicate zCURSOR_UNCHANGED.
; 4558 :          // If no unhidden entity instance exists, return zCURSOR_NULL.
; 4559 : 
; 4560 :          // If the current entity instance is not hidden, leave the sleeping
; 4561 :          // dogs alone, otherwise scan for a twin that is not hidden.
; 4562 :          if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	$LN38@fnScanEI_N

; 4563 :          {
; 4564 :             zBOOL bFound;
; 4565 :             zBOOL bForward;   // True, if we have been trying to move forward
; 4566 :                               // in the chain.
; 4567 :             bFound = FALSE;

	mov	BYTE PTR _bFound$3[ebp], 0

; 4568 :             bForward = lAbsPosition ? bAbsPosition_Forward : (lRelPosition > 0);

	cmp	DWORD PTR _lAbsPosition$[ebp], 0
	je	SHORT $LN50@fnScanEI_N
	movzx	ecx, BYTE PTR _bAbsPosition_Forward$[ebp]
	mov	DWORD PTR tv219[ebp], ecx
	jmp	SHORT $LN51@fnScanEI_N
$LN50@fnScanEI_N:
	cmp	DWORD PTR _lRelPosition$[ebp], 0
	jle	SHORT $LN48@fnScanEI_N
	mov	DWORD PTR tv217[ebp], 1
	jmp	SHORT $LN49@fnScanEI_N
$LN48@fnScanEI_N:
	mov	DWORD PTR tv217[ebp], 0
$LN49@fnScanEI_N:
	mov	edx, DWORD PTR tv217[ebp]
	mov	DWORD PTR tv219[ebp], edx
$LN51@fnScanEI_N:
	mov	al, BYTE PTR tv219[ebp]
	mov	BYTE PTR _bForward$4[ebp], al

; 4569 : 
; 4570 :             lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN10@fnScanEI_N:

; 4571 :             while ( (bForward && lpSearchEntityInstance->hPrevTwin) ||

	movzx	eax, BYTE PTR _bForward$4[ebp]
	test	eax, eax
	je	SHORT $LN41@fnScanEI_N
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $LN40@fnScanEI_N
$LN41@fnScanEI_N:
	movzx	edx, BYTE PTR _bForward$4[ebp]
	test	edx, edx
	jne	SHORT $LN11@fnScanEI_N
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN11@fnScanEI_N
$LN40@fnScanEI_N:

; 4572 :                     (bForward == FALSE && lpSearchEntityInstance->hNextTwin) )
; 4573 :             {
; 4574 :                lpSearchEntityInstance = bForward ?

	movzx	ecx, BYTE PTR _bForward$4[ebp]
	test	ecx, ecx
	je	SHORT $LN52@fnScanEI_N
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv240[ebp], eax
	jmp	SHORT $LN53@fnScanEI_N
$LN52@fnScanEI_N:
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv240[ebp], eax
$LN53@fnScanEI_N:
	mov	eax, DWORD PTR tv240[ebp]
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4575 :                                zGETPTR( lpSearchEntityInstance->hPrevTwin ) :
; 4576 :                                zGETPTR( lpSearchEntityInstance->hNextTwin );
; 4577 :                if ( lpSearchEntityInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN42@fnScanEI_N

; 4578 :                {
; 4579 :                   bFound = TRUE;

	mov	BYTE PTR _bFound$3[ebp], 1

; 4580 :                   break;

	jmp	SHORT $LN11@fnScanEI_N
$LN42@fnScanEI_N:

; 4581 :                }
; 4582 :             }

	jmp	SHORT $LN10@fnScanEI_N
$LN11@fnScanEI_N:

; 4583 : 
; 4584 :             if ( bFound )

	movzx	eax, BYTE PTR _bFound$3[ebp]
	test	eax, eax
	je	SHORT $LN43@fnScanEI_N

; 4585 :             {
; 4586 :                if ( bCursorTest == FALSE )

	movzx	ecx, BYTE PTR _bCursorTest$[ebp]
	test	ecx, ecx
	jne	SHORT $LN44@fnScanEI_N

; 4587 :                {
; 4588 :                   lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 4589 :                // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 4590 :                //    SysMessageBox( 0, "ScanEI_NoScoping2", "UNSET_CSR", -1 );
; 4591 : 
; 4592 :                   fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN44@fnScanEI_N:

; 4593 :                }
; 4594 : 
; 4595 :                nRC = zCURSOR_UNCHANGED;  // to my way of thinking, this should not

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
$LN43@fnScanEI_N:

; 4596 :                                          // be UNCHANGED this should be SET, but
; 4597 :                                          // I'm probably wrong ... dks 2004.09.09
; 4598 :             }
; 4599 : // initialize to zCURSOR_NULL at the beginning
; 4600 : //          else
; 4601 : //             nRC = zCURSOR_NULL;
; 4602 :          }

	jmp	SHORT $LN12@fnScanEI_N
$LN38@fnScanEI_N:

; 4603 :          else
; 4604 :             nRC = zCURSOR_UNCHANGED; // Not NULL and Not Found is UNCHANGED

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN12@fnScanEI_N:

; 4605 :       }
; 4606 :    }
; 4607 : 
; 4608 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnScanEI_N:

; 4609 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN54@fnScanEI_N:
	DD	$LN13@fnScanEI_N
	DD	$LN16@fnScanEI_N
	DD	$LN14@fnScanEI_N
	DD	$LN15@fnScanEI_N
_fnScanEI_NoScoping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpFoundEntityInstance$1 = -80				; size = 4
tv511 = -76						; size = 4
tv493 = -72						; size = 4
tv491 = -68						; size = 4
tv66 = -64						; size = 4
_lpParent$2 = -60					; size = 4
_lpNextHier$3 = -56					; size = 4
_lpPrevHier$4 = -52					; size = 4
_lpResetInstance$5 = -48				; size = 4
_lpSrchViewEntity$6 = -44				; size = 4
tv68 = -40						; size = 4
_lCurrRelPosition$ = -36				; size = 4
_lpTempEntityCsr$7 = -32				; size = 4
_lpResetCsr$8 = -28					; size = 4
_lpRecursChild$ = -24					; size = 4
_lpSearchEntityInstance$ = -20				; size = 4
_nStopLevel$ = -16					; size = 2
_nRC$ = -12						; size = 2
_bFound$9 = -7						; size = 1
_bForward$10 = -6					; size = 1
_bRebuild$11 = -5					; size = 1
_bFound$ = -4						; size = 1
_bDoRelPosition$ = -3					; size = 1
_bAbsPosition_Forward$ = -2				; size = 1
_bNewParent$ = -1					; size = 1
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_lpViewEntityAttrib$ = 20				; size = 4
_pQualValue$ = 24					; size = 4
_lpSrcViewEntityCsr$ = 28				; size = 4
_lpSrcViewEntityAttrib$ = 32				; size = 4
_lRelPosition$ = 36					; size = 4
_lpScopingViewEntityCsr$ = 40				; size = 4
_cpcContextName$ = 44					; size = 4
_lpCurrentTask$ = 48					; size = 4
_lpSrcEntityInstance$ = 52				; size = 4
_vAttrView$ = 56					; size = 4
_lAbsPosition$ = 60					; size = 4
_lQualRequest$ = 64					; size = 4
_lQualOperator$ = 68					; size = 4
_nDesiredSelectState$ = 72				; size = 2
_bSelectRelevant$ = 76					; size = 1
_bRelPosition$ = 80					; size = 1
_bSameParentKeepChildren$ = 84				; size = 1
_bRecurse$ = 88						; size = 1
_bCursorTest$ = 92					; size = 1
_fnScanEI_Scoping PROC

; 4634 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 4635 :    //
; 4636 :    // This processing occurs only when we have a Scoping Entity!
; 4637 :    //
; 4638 :    LPENTITYINSTANCE  lpSearchEntityInstance;
; 4639 :    zBOOL    bAbsPosition_Forward;// indicates direction of 'absolute' positioning
; 4640 :    zBOOL    bDoRelPosition = 0;

	mov	BYTE PTR _bDoRelPosition$[ebp], 0

; 4641 :    zLONG    lCurrRelPosition;
; 4642 :    zSHORT   nRC = zCURSOR_NULL;

	mov	eax, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], ax

; 4643 : 
; 4644 :    zSHORT         nStopLevel;
; 4645 :    zBOOL          bNewParent;
; 4646 :    zBOOL          bFound;
; 4647 :    LPVIEWENTITY   lpRecursChild;
; 4648 : 
; 4649 : #ifdef  __CURSOR_PERFORMANCE__
; 4650 :    zBOOL          bDoTwins;
; 4651 :    zSHORT         nStopHier;
; 4652 :    LPVIEWCSR      lpViewCsr;
; 4653 :    LPVIEWOI       lpViewOI;
; 4654 :    LPVIEWENTITY   lpWkViewEntity;
; 4655 : 
; 4656 :    bDoTwins = !fnEntityInRecursivePath( lpViewEntity );
; 4657 :    nStopHier = 0;
; 4658 :    lpViewCsr = zGETPTR( lpView->hViewCsr );
; 4659 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );
; 4660 :    if ( lpViewOI->bMultipleRootLevels == FALSE )
; 4661 :    {
; 4662 :       lpWkViewEntity = zGETPTR( lpViewEntity->hNextHier );
; 4663 :       while ( lpWkViewEntity && lpWkViewEntity->nLevel != 2 )
; 4664 :          lpWkViewEntity = zGETPTR( lpWkViewEntity->hNextHier );
; 4665 :       if ( lpWkViewEntity )
; 4666 :          nStopHier = lpWkViewEntity->nHierNbr;
; 4667 :    }
; 4668 : #endif
; 4669 : 
; 4670 :    // Relative positioning requested
; 4671 :    lCurrRelPosition = bRelPosition ? lRelPosition : 0;

	movzx	ecx, BYTE PTR _bRelPosition$[ebp]
	test	ecx, ecx
	je	SHORT $LN109@fnScanEI_S
	mov	edx, DWORD PTR _lRelPosition$[ebp]
	mov	DWORD PTR tv66[ebp], edx
	jmp	SHORT $LN110@fnScanEI_S
$LN109@fnScanEI_S:
	mov	DWORD PTR tv66[ebp], 0
$LN110@fnScanEI_S:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR _lCurrRelPosition$[ebp], eax

; 4672 : 
; 4673 :    nStopLevel = lpScopingViewEntityCsr->nLevel;

	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	dx, WORD PTR [ecx+22]
	mov	WORD PTR _nStopLevel$[ebp], dx

; 4674 :    bNewParent = 0;

	mov	BYTE PTR _bNewParent$[ebp], 0

; 4675 :    bFound = FALSE;

	mov	BYTE PTR _bFound$[ebp], 0

; 4676 : 
; 4677 :    switch ( lAbsPosition )

	mov	eax, DWORD PTR _lAbsPosition$[ebp]
	mov	DWORD PTR tv68[ebp], eax
	mov	ecx, DWORD PTR tv68[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv68[ebp], ecx
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN44@fnScanEI_S
	mov	edx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN117@fnScanEI_S[edx*4]
$LN20@fnScanEI_S:

; 4678 :    {
; 4679 :       case zPOS_FIRST:
; 4680 :          bAbsPosition_Forward = TRUE;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 1

; 4681 :          lpSearchEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4682 :          if ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN4@fnScanEI_S

; 4683 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN4@fnScanEI_S:

; 4684 : 
; 4685 :          // go to the start of the chain
; 4686 :          while ( lpSearchEntityInstance &&

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN5@fnScanEI_S
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStopLevel$[ebp]
	cmp	edx, eax
	jle	SHORT $LN5@fnScanEI_S

; 4687 :                  lpSearchEntityInstance->nLevel > nStopLevel )
; 4688 :          {
; 4689 :             if ( lpSearchEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN22@fnScanEI_S

; 4690 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN23@fnScanEI_S
$LN22@fnScanEI_S:

; 4691 :             else
; 4692 :             {
; 4693 :                LPENTITYINSTANCE lpPrevHier = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$4[ebp], eax

; 4694 : 
; 4695 :                if ( lpPrevHier && lpPrevHier->nLevel > nStopLevel )

	cmp	DWORD PTR _lpPrevHier$4[ebp], 0
	je	SHORT $LN24@fnScanEI_S
	mov	eax, DWORD PTR _lpPrevHier$4[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStopLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN24@fnScanEI_S

; 4696 :                   lpSearchEntityInstance = lpPrevHier;

	mov	eax, DWORD PTR _lpPrevHier$4[ebp]
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN23@fnScanEI_S
$LN24@fnScanEI_S:

; 4697 :                else
; 4698 :                   break;

	jmp	SHORT $LN5@fnScanEI_S
$LN23@fnScanEI_S:

; 4699 :             }
; 4700 :          }

	jmp	SHORT $LN4@fnScanEI_S
$LN5@fnScanEI_S:

; 4701 : 
; 4702 :          break;

	jmp	$LN2@fnScanEI_S
$LN26@fnScanEI_S:

; 4703 : 
; 4704 :       case zPOS_NEXT:
; 4705 :          bAbsPosition_Forward = TRUE;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 1

; 4706 :          lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4707 :          if ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN27@fnScanEI_S

; 4708 :          {
; 4709 :             if ( bRecurse )

	movzx	eax, BYTE PTR _bRecurse$[ebp]
	test	eax, eax
	je	SHORT $LN28@fnScanEI_S

; 4710 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN27@fnScanEI_S
$LN28@fnScanEI_S:

; 4711 :             else
; 4712 :             if ( lpSearchEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN30@fnScanEI_S

; 4713 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN27@fnScanEI_S
$LN30@fnScanEI_S:

; 4714 :             else
; 4715 :             {
; 4716 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4717 :                bNewParent = TRUE;

	mov	BYTE PTR _bNewParent$[ebp], 1
$LN27@fnScanEI_S:

; 4718 :             }
; 4719 :          }
; 4720 : 
; 4721 :          break;

	jmp	$LN2@fnScanEI_S
$LN32@fnScanEI_S:

; 4722 : 
; 4723 :       case zPOS_PREV:
; 4724 :          bAbsPosition_Forward = 0;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 0

; 4725 :          lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4726 :          if ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN33@fnScanEI_S

; 4727 :          {
; 4728 :             if ( bRecurse )

	movzx	ecx, BYTE PTR _bRecurse$[ebp]
	test	ecx, ecx
	je	SHORT $LN34@fnScanEI_S

; 4729 :             {
; 4730 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4731 :             }

	jmp	SHORT $LN33@fnScanEI_S
$LN34@fnScanEI_S:

; 4732 :             else
; 4733 :             if ( lpSearchEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN36@fnScanEI_S

; 4734 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN33@fnScanEI_S
$LN36@fnScanEI_S:

; 4735 :             else
; 4736 :             {
; 4737 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4738 :                bNewParent = TRUE;

	mov	BYTE PTR _bNewParent$[ebp], 1
$LN33@fnScanEI_S:

; 4739 :             }
; 4740 :          }
; 4741 : 
; 4742 :          break;

	jmp	$LN2@fnScanEI_S
$LN38@fnScanEI_S:

; 4743 : 
; 4744 :       case zPOS_LAST:
; 4745 :          bAbsPosition_Forward = 0;

	mov	BYTE PTR _bAbsPosition_Forward$[ebp], 0

; 4746 :          lpSearchEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4747 : 
; 4748 :          if ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN6@fnScanEI_S

; 4749 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN6@fnScanEI_S:

; 4750 : 
; 4751 :          // Go to the end of the chain.
; 4752 :          while ( lpSearchEntityInstance &&

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN7@fnScanEI_S
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStopLevel$[ebp]
	cmp	edx, eax
	jle	SHORT $LN7@fnScanEI_S

; 4753 :                  lpSearchEntityInstance->nLevel > nStopLevel )
; 4754 :          {
; 4755 :             if ( lpSearchEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN40@fnScanEI_S

; 4756 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN41@fnScanEI_S
$LN40@fnScanEI_S:

; 4757 :             else
; 4758 :             {
; 4759 :                LPENTITYINSTANCE lpNextHier = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$3[ebp], eax

; 4760 : 
; 4761 :                if ( lpNextHier && lpNextHier->nLevel > nStopLevel )

	cmp	DWORD PTR _lpNextHier$3[ebp], 0
	je	SHORT $LN42@fnScanEI_S
	mov	eax, DWORD PTR _lpNextHier$3[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStopLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN42@fnScanEI_S

; 4762 :                   lpSearchEntityInstance = lpNextHier;

	mov	eax, DWORD PTR _lpNextHier$3[ebp]
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN41@fnScanEI_S
$LN42@fnScanEI_S:

; 4763 :                else
; 4764 :                   break;

	jmp	SHORT $LN7@fnScanEI_S
$LN41@fnScanEI_S:

; 4765 :             }
; 4766 :          }

	jmp	SHORT $LN6@fnScanEI_S
$LN7@fnScanEI_S:

; 4767 : 
; 4768 :          break;

	jmp	SHORT $LN2@fnScanEI_S
$LN44@fnScanEI_S:

; 4769 : 
; 4770 :       default:
; 4771 :          // Relative positioning only ...
; 4772 :          lpSearchEntityInstance  = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN2@fnScanEI_S:

; 4773 :          break;
; 4774 :    }
; 4775 : 
; 4776 :    lpRecursChild = 0;

	mov	DWORD PTR _lpRecursChild$[ebp], 0

; 4777 :    if ( bRecurse )

	movzx	eax, BYTE PTR _bRecurse$[ebp]
	test	eax, eax
	je	$LN10@fnScanEI_S

; 4778 :    {
; 4779 :       lpRecursChild = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursChild$[ebp], eax
$LN8@fnScanEI_S:

; 4780 :       while ( lpRecursChild &&
; 4781 :               lpRecursChild->nLevel > lpViewEntity->nLevel &&

	cmp	DWORD PTR _lpRecursChild$[ebp], 0
	je	SHORT $LN9@fnScanEI_S
	mov	eax, DWORD PTR _lpRecursChild$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jle	SHORT $LN9@fnScanEI_S
	mov	ecx, DWORD PTR _lpRecursChild$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $LN46@fnScanEI_S
	mov	ecx, DWORD PTR _lpRecursChild$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN9@fnScanEI_S
$LN46@fnScanEI_S:

; 4782 :               (lpRecursChild->lEREntTok != lpViewEntity->lEREntTok ||
; 4783 :                lpRecursChild->bRecursive == FALSE) )
; 4784 :       {
; 4785 :          lpRecursChild = zGETPTR( lpRecursChild->hNextHier );

	mov	eax, DWORD PTR _lpRecursChild$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursChild$[ebp], eax

; 4786 :       }

	jmp	SHORT $LN8@fnScanEI_S
$LN9@fnScanEI_S:

; 4787 : 
; 4788 :       if ( lpRecursChild == 0 || lpRecursChild->nLevel <= lpViewEntity->nLevel )

	cmp	DWORD PTR _lpRecursChild$[ebp], 0
	je	SHORT $LN48@fnScanEI_S
	mov	edx, DWORD PTR _lpRecursChild$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $LN10@fnScanEI_S
$LN48@fnScanEI_S:

; 4789 :          lpRecursChild = 0;

	mov	DWORD PTR _lpRecursChild$[ebp], 0
$LN10@fnScanEI_S:

; 4790 :    }
; 4791 : 
; 4792 : 
; 4793 :    while ( lpSearchEntityInstance &&

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	$LN11@fnScanEI_S
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStopLevel$[ebp]
	cmp	ecx, edx
	jle	$LN11@fnScanEI_S

; 4794 :            lpSearchEntityInstance->nLevel > nStopLevel )
; 4795 :    {
; 4796 :       LPVIEWENTITY   lpSrchViewEntity;
; 4797 : 
; 4798 :       lpSrchViewEntity = zGETPTR( lpSearchEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$6[ebp], eax

; 4799 :       if ( lpSearchEntityInstance->u.nInd.bHidden == FALSE &&
; 4800 : 
; 4801 :            (lpSrchViewEntity == lpViewEntity ||
; 4802 :             lpSrchViewEntity == lpRecursChild) &&
; 4803 : 
; 4804 :            (bRecurse ||
; 4805 :             lpSearchEntityInstance->nLevel == lpViewEntityCsr->nLevel) &&
; 4806 : 
; 4807 :            // SelectState
; 4808 :            (bSelectRelevant == FALSE ||
; 4809 :             (fnSelectedInstanceFarbler( zGETPTR( lpViewEntityCsr->hViewCsr ),
; 4810 :                                         zGETPTR( lpSearchEntityInstance->hViewEntity ),
; 4811 :                                         zGETHNDL( lpSearchEntityInstance ), 1 )
; 4812 :                                                    == nDesiredSelectState)) &&

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	$LN49@fnScanEI_S
	mov	ecx, DWORD PTR _lpSrchViewEntity$6[ebp]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN50@fnScanEI_S
	mov	edx, DWORD PTR _lpSrchViewEntity$6[ebp]
	cmp	edx, DWORD PTR _lpRecursChild$[ebp]
	jne	$LN49@fnScanEI_S
$LN50@fnScanEI_S:
	movzx	eax, BYTE PTR _bRecurse$[ebp]
	test	eax, eax
	jne	SHORT $LN51@fnScanEI_S
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	cmp	edx, ecx
	jne	$LN49@fnScanEI_S
$LN51@fnScanEI_S:
	movzx	edx, BYTE PTR _bSelectRelevant$[ebp]
	test	edx, edx
	je	SHORT $LN52@fnScanEI_S
	push	1
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	movsx	edx, ax
	movsx	eax, WORD PTR _nDesiredSelectState$[ebp]
	cmp	edx, eax
	jne	SHORT $LN49@fnScanEI_S
$LN52@fnScanEI_S:
	cmp	DWORD PTR _lQualRequest$[ebp], 0
	je	SHORT $LN53@fnScanEI_S
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lQualOperator$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lQualRequest$[ebp]
	push	edx
	mov	eax, DWORD PTR _vAttrView$[ebp]
	push	eax
	call	_fnQualifiedInstance
	add	esp, 48					; 00000030H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN49@fnScanEI_S
$LN53@fnScanEI_S:

; 4813 : 
; 4814 :            // Qualification
; 4815 :            (lQualRequest == 0 ||
; 4816 :             fnQualifiedInstance( vAttrView,
; 4817 :                                  lQualRequest,
; 4818 :                                  lQualOperator,
; 4819 :                                  pQualValue,
; 4820 :                                  lpSearchEntityInstance,
; 4821 :                                  lpViewEntityCsr,
; 4822 :                                  lpViewEntityAttrib,
; 4823 :                                  lpSrcEntityInstance,
; 4824 :                                  lpSrcViewEntityCsr,
; 4825 :                                  lpSrcViewEntityAttrib,
; 4826 :                                  cpcContextName,
; 4827 :                                  lpCurrentTask )) )
; 4828 :       {
; 4829 :          // We have satisfied Select state and Qualification criteria, see
; 4830 :          // if we need to perform any relative positioning ...
; 4831 :          if ( bRelPosition )

	movzx	edx, BYTE PTR _bRelPosition$[ebp]
	test	edx, edx
	je	SHORT $LN54@fnScanEI_S

; 4832 :          {
; 4833 :             if ( lCurrRelPosition == 0 )

	cmp	DWORD PTR _lCurrRelPosition$[ebp], 0
	jne	SHORT $LN56@fnScanEI_S

; 4834 :             {
; 4835 :                bFound = TRUE;

	mov	BYTE PTR _bFound$[ebp], 1

; 4836 :                break;

	jmp	$LN11@fnScanEI_S

; 4837 :             }

	jmp	SHORT $LN57@fnScanEI_S
$LN56@fnScanEI_S:

; 4838 :             else
; 4839 :             {
; 4840 :                // If we are in here, we are about to perform relative positioning.
; 4841 :                bDoRelPosition = TRUE;

	mov	BYTE PTR _bDoRelPosition$[ebp], 1
$LN57@fnScanEI_S:

; 4842 :             }
; 4843 :          }

	jmp	SHORT $LN49@fnScanEI_S
$LN54@fnScanEI_S:

; 4844 :          else
; 4845 :          {
; 4846 :             bFound = TRUE;

	mov	BYTE PTR _bFound$[ebp], 1

; 4847 :             break;

	jmp	$LN11@fnScanEI_S
$LN49@fnScanEI_S:

; 4848 :          }
; 4849 :       }
; 4850 : 
; 4851 :       if ( bDoRelPosition )

	movzx	eax, BYTE PTR _bDoRelPosition$[ebp]
	test	eax, eax
	je	$LN58@fnScanEI_S

; 4852 :       {
; 4853 :          // Time to perform a relative positioning move ...
; 4854 :          if ( lCurrRelPosition > 0 )

	cmp	DWORD PTR _lCurrRelPosition$[ebp], 0
	jle	SHORT $LN60@fnScanEI_S

; 4855 :          {
; 4856 :             if ( bRecurse )

	movzx	ecx, BYTE PTR _bRecurse$[ebp]
	test	ecx, ecx
	je	SHORT $LN62@fnScanEI_S

; 4857 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN63@fnScanEI_S
$LN62@fnScanEI_S:

; 4858 :             else
; 4859 :             if ( lpSearchEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN64@fnScanEI_S

; 4860 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN63@fnScanEI_S
$LN64@fnScanEI_S:

; 4861 :             else
; 4862 :             {
; 4863 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4864 :                bNewParent = TRUE;

	mov	BYTE PTR _bNewParent$[ebp], 1
$LN63@fnScanEI_S:

; 4865 :             }
; 4866 : 
; 4867 :             lCurrRelPosition--;

	mov	eax, DWORD PTR _lCurrRelPosition$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lCurrRelPosition$[ebp], eax

; 4868 :          }

	jmp	SHORT $LN61@fnScanEI_S
$LN60@fnScanEI_S:

; 4869 :          else
; 4870 :          {
; 4871 :             if ( bRecurse )

	movzx	ecx, BYTE PTR _bRecurse$[ebp]
	test	ecx, ecx
	je	SHORT $LN66@fnScanEI_S

; 4872 :             {
; 4873 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4874 :             }

	jmp	SHORT $LN67@fnScanEI_S
$LN66@fnScanEI_S:

; 4875 :             else
; 4876 :             {
; 4877 :                if ( lpSearchEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN68@fnScanEI_S

; 4878 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN67@fnScanEI_S
$LN68@fnScanEI_S:

; 4879 :                else
; 4880 :                {
; 4881 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4882 :                   bNewParent = TRUE;

	mov	BYTE PTR _bNewParent$[ebp], 1
$LN67@fnScanEI_S:

; 4883 :                }
; 4884 :             }
; 4885 : 
; 4886 :             lCurrRelPosition++;

	mov	eax, DWORD PTR _lCurrRelPosition$[ebp]
	add	eax, 1
	mov	DWORD PTR _lCurrRelPosition$[ebp], eax
$LN61@fnScanEI_S:

; 4887 :          }
; 4888 : 
; 4889 :          bDoRelPosition = 0;  // reset indicator

	mov	BYTE PTR _bDoRelPosition$[ebp], 0

; 4890 :       }

	jmp	$LN59@fnScanEI_S
$LN58@fnScanEI_S:

; 4891 :       else
; 4892 :       {
; 4893 :          //
; 4894 :          // perform absolute positioning fore or aft...
; 4895 :          //
; 4896 :          if ( bAbsPosition_Forward )

	movzx	ecx, BYTE PTR _bAbsPosition_Forward$[ebp]
	test	ecx, ecx
	je	SHORT $LN70@fnScanEI_S

; 4897 :          {
; 4898 :             if ( bRecurse )

	movzx	edx, BYTE PTR _bRecurse$[ebp]
	test	edx, edx
	je	SHORT $LN72@fnScanEI_S

; 4899 :             {
; 4900 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4901 : #ifdef  __CURSOR_PERFORMANCE__
; 4902 :                if ( nStopHier && lpSearchEntityInstance )
; 4903 :                {
; 4904 :                   LPVIEWENTITY lpTempViewEntity = zGETPTR( lpSearchEntityInstance->hViewEntity );
; 4905 : 
; 4906 :                   if ( lpTempViewEntity->nHierNbr >= nStopHier )
; 4907 :                      lpSearchEntityInstance = 0;
; 4908 :                }
; 4909 : #endif
; 4910 :             }

	jmp	SHORT $LN73@fnScanEI_S
$LN72@fnScanEI_S:

; 4911 :             else
; 4912 :             {
; 4913 : #ifdef  __CURSOR_PERFORMANCE__
; 4914 :                if ( bDoTwins && lpSrchViewEntity == lpViewEntity )
; 4915 :                {
; 4916 :                   if ( lpSearchEntityInstance->hNextTwin )
; 4917 :                   {
; 4918 :                      lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );
; 4919 :                   }
; 4920 :                   else
; 4921 :                   {
; 4922 :                      bNewParent = TRUE;
; 4923 :                      while ( lpSearchEntityInstance &&
; 4924 :                              lpSearchEntityInstance->hNextTwin == 0 )
; 4925 :                      {
; 4926 :                         lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hParent );
; 4927 :                      }
; 4928 : 
; 4929 :                      if ( lpSearchEntityInstance )
; 4930 :                      {
; 4931 :                         lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );
; 4932 :                      }
; 4933 :                   }
; 4934 :                }
; 4935 :                else
; 4936 : #endif
; 4937 :                if ( lpSrchViewEntity == lpViewEntity &&
; 4938 :                     lpSearchEntityInstance->nLevel == lpViewEntityCsr->nLevel &&

	mov	edx, DWORD PTR _lpSrchViewEntity$6[ebp]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN74@fnScanEI_S
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	cmp	ecx, eax
	jne	SHORT $LN74@fnScanEI_S
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN74@fnScanEI_S

; 4939 :                     lpSearchEntityInstance->hNextTwin )
; 4940 :                {
; 4941 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4942 :                }

	jmp	SHORT $LN73@fnScanEI_S
$LN74@fnScanEI_S:

; 4943 :                else
; 4944 :                {
; 4945 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4946 :                   bNewParent = TRUE;

	mov	BYTE PTR _bNewParent$[ebp], 1
$LN73@fnScanEI_S:

; 4947 : #ifdef  __CURSOR_PERFORMANCE__
; 4948 :                   if ( nStopHier && lpSearchEntityInstance )
; 4949 :                   {
; 4950 :                      LPVIEWENTITY lpTempViewEntity =
; 4951 :                               zGETPTR( lpSearchEntityInstance->hViewEntity );
; 4952 : 
; 4953 :                      if ( lpTempViewEntity->nHierNbr >= nStopHier )
; 4954 :                         lpSearchEntityInstance = 0;
; 4955 :                   }
; 4956 : #endif
; 4957 :                }
; 4958 :             }
; 4959 :          }

	jmp	SHORT $LN59@fnScanEI_S
$LN70@fnScanEI_S:

; 4960 :          else
; 4961 :          {
; 4962 :             if ( bRecurse )

	movzx	eax, BYTE PTR _bRecurse$[ebp]
	test	eax, eax
	je	SHORT $LN76@fnScanEI_S

; 4963 :             {
; 4964 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4965 :             }

	jmp	SHORT $LN59@fnScanEI_S
$LN76@fnScanEI_S:

; 4966 :             else
; 4967 :             {
; 4968 :                if ( lpSrchViewEntity == lpViewEntity &&
; 4969 :                     lpSearchEntityInstance->nLevel == lpViewEntityCsr->nLevel &&

	mov	eax, DWORD PTR _lpSrchViewEntity$6[ebp]
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN78@fnScanEI_S
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	cmp	edx, ecx
	jne	SHORT $LN78@fnScanEI_S
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN78@fnScanEI_S

; 4970 :                     lpSearchEntityInstance->hPrevTwin )
; 4971 :                {
; 4972 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4973 :                }

	jmp	SHORT $LN59@fnScanEI_S
$LN78@fnScanEI_S:

; 4974 :                else
; 4975 :                {
; 4976 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 4977 :                   bNewParent = TRUE;

	mov	BYTE PTR _bNewParent$[ebp], 1
$LN59@fnScanEI_S:

; 4978 :                }
; 4979 :             }
; 4980 :          }
; 4981 :       }
; 4982 :    } // end of while (lpSearchEntityInstance)

	jmp	$LN10@fnScanEI_S
$LN11@fnScanEI_S:

; 4983 :    //      for when we have a scoping entity...
; 4984 : 
; 4985 :    if ( bFound )

	movzx	ecx, BYTE PTR _bFound$[ebp]
	test	ecx, ecx
	je	$LN80@fnScanEI_S

; 4986 :    {
; 4987 :       if ( bRecurse )

	movzx	edx, BYTE PTR _bRecurse$[ebp]
	test	edx, edx
	je	$LN82@fnScanEI_S

; 4988 :       {
; 4989 :          LPVIEWENTITYCSR   lpTempEntityCsr;
; 4990 :          LPENTITYINSTANCE  lpFoundEntityInstance;
; 4991 :          zBOOL             bRebuild;
; 4992 : 
; 4993 :          nRC = zCURSOR_SET;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 4994 :          bRebuild = FALSE;

	mov	BYTE PTR _bRebuild$11[ebp], 0

; 4995 :          lpFoundEntityInstance = lpSearchEntityInstance;

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	DWORD PTR _lpFoundEntityInstance$1[ebp], ecx

; 4996 : 
; 4997 :          // First, try scanning up the to see if parentage and
; 4998 :          // ViewSubobjects are intact, if not chuck it out and then
; 4999 :          // rebuild it.
; 5000 :          if ( lpSearchEntityInstance->nLevel == lpViewEntityCsr->nLevel )

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jne	$LN84@fnScanEI_S

; 5001 :          {
; 5002 :             if ( bCursorTest == FALSE )

	movzx	eax, BYTE PTR _bCursorTest$[ebp]
	test	eax, eax
	jne	SHORT $LN86@fnScanEI_S

; 5003 :             {
; 5004 :                if ( bSameParentKeepChildren == FALSE ||

	movzx	ecx, BYTE PTR _bSameParentKeepChildren$[ebp]
	test	ecx, ecx
	je	SHORT $LN88@fnScanEI_S
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	je	SHORT $LN86@fnScanEI_S
$LN88@fnScanEI_S:

; 5005 :                     zGETPTR( lpViewEntityCsr->hEntityInstance ) != lpSearchEntityInstance )
; 5006 :                {
; 5007 :                   lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 5008 :                   fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN86@fnScanEI_S:

; 5009 :                }
; 5010 :             }
; 5011 : 
; 5012 :             lpTempEntityCsr = lpViewEntityCsr;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpTempEntityCsr$7[ebp], ecx
$LN12@fnScanEI_S:

; 5013 :             while ( lpTempEntityCsr->hParent &&

	mov	edx, DWORD PTR _lpTempEntityCsr$7[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN13@fnScanEI_S
	mov	eax, DWORD PTR _lpTempEntityCsr$7[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	je	SHORT $LN13@fnScanEI_S

; 5014 :                     zGETPTR( lpTempEntityCsr->hParent ) != lpScopingViewEntityCsr )
; 5015 :             {
; 5016 :                lpTempEntityCsr = zGETPTR( lpTempEntityCsr->hParent );

	mov	edx, DWORD PTR _lpTempEntityCsr$7[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempEntityCsr$7[ebp], eax

; 5017 :                lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 5018 : 
; 5019 :                if ( (lpTempEntityCsr->hEntityInstance == UNSET_CSR ) ||
; 5020 :                     (zGETPTR( lpTempEntityCsr->hEntityInstance ) !=
; 5021 :                                                 lpSearchEntityInstance ) ||

	mov	eax, DWORD PTR _lpTempEntityCsr$7[ebp]
	cmp	DWORD PTR [eax+26], 1
	je	SHORT $LN90@fnScanEI_S
	mov	ecx, DWORD PTR _lpTempEntityCsr$7[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	jne	SHORT $LN90@fnScanEI_S
	mov	eax, DWORD PTR _lpTempEntityCsr$7[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	je	SHORT $LN89@fnScanEI_S
$LN90@fnScanEI_S:

; 5022 :                     (lpTempEntityCsr->nLevel != lpSearchEntityInstance->nLevel ) )
; 5023 :                {
; 5024 :                   bRebuild = TRUE;

	mov	BYTE PTR _bRebuild$11[ebp], 1

; 5025 :                   break;

	jmp	SHORT $LN13@fnScanEI_S
$LN89@fnScanEI_S:

; 5026 :                }
; 5027 :             }

	jmp	SHORT $LN12@fnScanEI_S
$LN13@fnScanEI_S:

; 5028 :          }

	jmp	SHORT $LN85@fnScanEI_S
$LN84@fnScanEI_S:

; 5029 :          else
; 5030 :             bRebuild = TRUE;

	mov	BYTE PTR _bRebuild$11[ebp], 1
$LN85@fnScanEI_S:

; 5031 : 
; 5032 :          // if the entity instance level matches the view entity csr level,
; 5033 :          // then we should be okay.
; 5034 :          if ( bRebuild )

	movzx	ecx, BYTE PTR _bRebuild$11[ebp]
	test	ecx, ecx
	je	SHORT $LN91@fnScanEI_S

; 5035 :          {
; 5036 :          // TraceLineS( "(cm) Levels do NOT match", " leveling..." );
; 5037 :             nRC = zCURSOR_SET_NEWPARENT;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 5038 :             if ( bCursorTest == FALSE )

	movzx	eax, BYTE PTR _bCursorTest$[ebp]
	test	eax, eax
	jne	SHORT $LN91@fnScanEI_S

; 5039 :                fnEstablishViewForInstance( lpView, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpFoundEntityInstance$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
$LN91@fnScanEI_S:

; 5040 :                                            lpFoundEntityInstance );
; 5041 :          }
; 5042 :       }

	jmp	$LN83@fnScanEI_S
$LN82@fnScanEI_S:

; 5043 :       else
; 5044 :       {
; 5045 :          nRC = zCURSOR_SET;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 5046 :          if ( lpSearchEntityInstance == zGETPTR( lpViewEntityCsr->hEntityInstance ) )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jne	SHORT $LN93@fnScanEI_S

; 5047 :          {
; 5048 :             if ( bCursorTest == FALSE && bSameParentKeepChildren == FALSE )

	movzx	ecx, BYTE PTR _bCursorTest$[ebp]
	test	ecx, ecx
	jne	SHORT $LN95@fnScanEI_S
	movzx	edx, BYTE PTR _bSameParentKeepChildren$[ebp]
	test	edx, edx
	jne	SHORT $LN95@fnScanEI_S

; 5049 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN95@fnScanEI_S:

; 5050 :          }

	jmp	$LN83@fnScanEI_S
$LN93@fnScanEI_S:

; 5051 :          else
; 5052 :          {
; 5053 :             LPENTITYINSTANCE lpResetInstance;
; 5054 :             LPVIEWENTITYCSR  lpParent;
; 5055 :             LPVIEWENTITYCSR  lpResetCsr;
; 5056 : 
; 5057 :             lpResetCsr      = lpViewEntityCsr;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpResetCsr$8[ebp], ecx

; 5058 :             lpResetInstance = lpSearchEntityInstance;

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	DWORD PTR _lpResetInstance$5[ebp], edx

; 5059 :             lpParent        = zGETPTR( lpResetCsr->hParent );

	mov	eax, DWORD PTR _lpResetCsr$8[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$2[ebp], eax
$LN14@fnScanEI_S:

; 5060 : 
; 5061 :             // Need to check for presence of parent, in order to
; 5062 :             // handle multiple roots.
; 5063 :             while ( lpParent &&

	cmp	DWORD PTR _lpParent$2[ebp], 0
	je	SHORT $LN15@fnScanEI_S
	mov	edx, DWORD PTR _lpParent$2[ebp]
	mov	eax, DWORD PTR _lpResetInstance$5[ebp]
	mov	ecx, DWORD PTR [edx+26]
	cmp	ecx, DWORD PTR [eax+30]
	je	SHORT $LN15@fnScanEI_S

; 5064 :                     lpParent->hEntityInstance != lpResetInstance->hParent )
; 5065 :             {
; 5066 :                lpResetCsr      = zGETPTR( lpResetCsr->hParent );

	mov	edx, DWORD PTR _lpResetCsr$8[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetCsr$8[ebp], eax

; 5067 :                lpResetInstance = zGETPTR( lpResetInstance->hParent );

	mov	ecx, DWORD PTR _lpResetInstance$5[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpResetInstance$5[ebp], eax

; 5068 :                lpParent        = zGETPTR( lpResetCsr->hParent );

	mov	eax, DWORD PTR _lpResetCsr$8[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$2[ebp], eax

; 5069 :             }

	jmp	SHORT $LN14@fnScanEI_S
$LN15@fnScanEI_S:

; 5070 : 
; 5071 :             if ( bCursorTest )

	movzx	edx, BYTE PTR _bCursorTest$[ebp]
	test	edx, edx
	je	SHORT $LN96@fnScanEI_S

; 5072 :             {
; 5073 :                if ( lpResetCsr != lpViewEntityCsr )

	mov	eax, DWORD PTR _lpResetCsr$8[ebp]
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	je	SHORT $LN98@fnScanEI_S

; 5074 :                   nRC = zCURSOR_SET_NEWPARENT;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN98@fnScanEI_S:

; 5075 :             }

	jmp	$LN83@fnScanEI_S
$LN96@fnScanEI_S:

; 5076 :             else
; 5077 :             {
; 5078 :                lpResetCsr->hEntityInstance = zGETHNDL( lpResetInstance );

	mov	edx, DWORD PTR _lpResetInstance$5[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpResetCsr$8[ebp]
	mov	DWORD PTR [ecx+26], eax

; 5079 :             // if ( lpResetCsr->hEntityInstance == UNSET_CSR )
; 5080 :             //    SysMessageBox( 0, "ScanEI_Scoping", "UNSET_CSR", -1 );
; 5081 : 
; 5082 :                fnResetCursorForViewChildren( lpResetCsr );

	mov	edx, DWORD PTR _lpResetCsr$8[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 5083 :                if ( lpResetCsr != lpViewEntityCsr )

	mov	eax, DWORD PTR _lpResetCsr$8[ebp]
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	je	SHORT $LN83@fnScanEI_S

; 5084 :                {
; 5085 :                   nRC = zCURSOR_SET_NEWPARENT;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 5086 :                   lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 5087 :                // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 5088 :                //    SysMessageBox( 0, "ScanEI_Scoping2", "UNSET_CSR", -1 );
; 5089 : 
; 5090 :                   lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 5091 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN16@fnScanEI_S:

; 5092 :                   while ( lpViewEntityCsr != lpResetCsr )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	eax, DWORD PTR _lpResetCsr$8[ebp]
	je	SHORT $LN83@fnScanEI_S

; 5093 :                   {
; 5094 :                      lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 5095 :                   // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 5096 :                   //    SysMessageBox( 0, "ScanEI_Scoping3", "UNSET_CSR", -1 );
; 5097 : 
; 5098 :                      lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 5099 :                      lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hParent );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 5100 :                   }

	jmp	SHORT $LN16@fnScanEI_S
$LN83@fnScanEI_S:

; 5101 :                }
; 5102 :             }
; 5103 :          }
; 5104 :       }
; 5105 :    }

	jmp	$LN81@fnScanEI_S
$LN80@fnScanEI_S:

; 5106 :    else
; 5107 :    {
; 5108 :       // We didn't find anything yet, so position on the first
; 5109 :       // unhidden entity instance and indicate zCURSOR_UNCHANGED.
; 5110 :       // If no unhidden entity instance exists, return zCURSOR_NULL.
; 5111 : 
; 5112 :       // If the current entity instance is not hidden, leave the
; 5113 :       // sleeping dogs alone, otherwise scan for a twin that is not hidden.
; 5114 :       lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 5115 :       if ( lpSearchEntityInstance && lpSearchEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	$LN100@fnScanEI_S
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	$LN100@fnScanEI_S

; 5116 :       {
; 5117 :          zBOOL bFound;
; 5118 :          zBOOL bForward;   // True, if we have been trying to move
; 5119 :                            // forward in the chain
; 5120 : 
; 5121 :          bFound = FALSE;

	mov	BYTE PTR _bFound$9[ebp], 0

; 5122 :          bForward = lAbsPosition ? bAbsPosition_Forward :

	cmp	DWORD PTR _lAbsPosition$[ebp], 0
	je	SHORT $LN113@fnScanEI_S
	movzx	edx, BYTE PTR _bAbsPosition_Forward$[ebp]
	mov	DWORD PTR tv493[ebp], edx
	jmp	SHORT $LN114@fnScanEI_S
$LN113@fnScanEI_S:
	cmp	DWORD PTR _lRelPosition$[ebp], 0
	jle	SHORT $LN111@fnScanEI_S
	mov	DWORD PTR tv491[ebp], 1
	jmp	SHORT $LN112@fnScanEI_S
$LN111@fnScanEI_S:
	mov	DWORD PTR tv491[ebp], 0
$LN112@fnScanEI_S:
	mov	eax, DWORD PTR tv491[ebp]
	mov	DWORD PTR tv493[ebp], eax
$LN114@fnScanEI_S:
	mov	cl, BYTE PTR tv493[ebp]
	mov	BYTE PTR _bForward$10[ebp], cl
$LN18@fnScanEI_S:

; 5123 :                                    (lRelPosition > 0);
; 5124 : 
; 5125 :          while ( (bForward && lpSearchEntityInstance->hPrevTwin) ||

	movzx	edx, BYTE PTR _bForward$10[ebp]
	test	edx, edx
	je	SHORT $LN103@fnScanEI_S
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN102@fnScanEI_S
$LN103@fnScanEI_S:
	movzx	ecx, BYTE PTR _bForward$10[ebp]
	test	ecx, ecx
	jne	SHORT $LN19@fnScanEI_S
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN19@fnScanEI_S
$LN102@fnScanEI_S:

; 5126 :                  (bForward == FALSE && lpSearchEntityInstance->hNextTwin) )
; 5127 :          {
; 5128 :             lpSearchEntityInstance = bForward ?

	movzx	eax, BYTE PTR _bForward$10[ebp]
	test	eax, eax
	je	SHORT $LN115@fnScanEI_S
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv511[ebp], eax
	jmp	SHORT $LN116@fnScanEI_S
$LN115@fnScanEI_S:
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv511[ebp], eax
$LN116@fnScanEI_S:
	mov	edx, DWORD PTR tv511[ebp]
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], edx

; 5129 :                                zGETPTR( lpSearchEntityInstance->hPrevTwin ) :
; 5130 :                                zGETPTR( lpSearchEntityInstance->hNextTwin );
; 5131 :             if ( lpSearchEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN104@fnScanEI_S

; 5132 :             {
; 5133 :                bFound = TRUE;

	mov	BYTE PTR _bFound$9[ebp], 1

; 5134 :                break;

	jmp	SHORT $LN19@fnScanEI_S
$LN104@fnScanEI_S:

; 5135 :             }
; 5136 :          }

	jmp	SHORT $LN18@fnScanEI_S
$LN19@fnScanEI_S:

; 5137 : 
; 5138 :          if ( bFound )

	movzx	edx, BYTE PTR _bFound$9[ebp]
	test	edx, edx
	je	SHORT $LN105@fnScanEI_S

; 5139 :          {
; 5140 :             if ( bCursorTest == FALSE )

	movzx	eax, BYTE PTR _bCursorTest$[ebp]
	test	eax, eax
	jne	SHORT $LN106@fnScanEI_S

; 5141 :             {
; 5142 :                lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 5143 :             // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 5144 :             //    SysMessageBox( 0, "ScanEI_Scoping4", "UNSET_CSR", -1 );
; 5145 : 
; 5146 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN106@fnScanEI_S:

; 5147 :             }
; 5148 : 
; 5149 :             nRC = zCURSOR_UNCHANGED;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN105@fnScanEI_S:

; 5150 :          }
; 5151 : // set at beginning
; 5152 : //       else
; 5153 : //          nRC = zCURSOR_NULL;
; 5154 :       }

	jmp	SHORT $LN81@fnScanEI_S
$LN100@fnScanEI_S:

; 5155 :       else
; 5156 :       if ( lpViewEntityCsr->hEntityInstance )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN81@fnScanEI_S

; 5157 :          nRC = zCURSOR_UNCHANGED; // Not NULL and Not found is UNCHANGED

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
$LN81@fnScanEI_S:

; 5158 : 
; 5159 :    } // end of if ( bFound )...
; 5160 : 
; 5161 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 5162 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN117@fnScanEI_S:
	DD	$LN20@fnScanEI_S
	DD	$LN38@fnScanEI_S
	DD	$LN26@fnScanEI_S
	DD	$LN32@fnScanEI_S
_fnScanEI_Scoping ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lListenerProcess$ = -12				; size = 4
_lpPrevCsrListener$ = -8				; size = 4
_lpCsrListener$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpfnCursorListener$ = 12				; size = 4
_pvInstance$ = 16					; size = 4
_RemoveCursorListener@12 PROC

; 6251 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6252 :    zLONG            lListenerProcess = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lListenerProcess$[ebp], eax

; 6253 :    LPCURSORLISTENER lpCsrListener;
; 6254 :    LPCURSORLISTENER lpPrevCsrListener = 0;

	mov	DWORD PTR _lpPrevCsrListener$[ebp], 0

; 6255 : 
; 6256 : // TraceLine( "RemoveCursorListener for view: 0x%08x", lpView );
; 6257 : 
; 6258 :    // Look for the cursor listener.
; 6259 :    for ( lpCsrListener = zGETPTR( lpView->hFirstCursorListener );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$[ebp], eax
	jmp	SHORT $LN4@RemoveCurs
$LN2@RemoveCurs:

; 6261 :          lpCsrListener = zGETPTR( lpCsrListener->hNextCursorListener ) )

	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$[ebp], eax
$LN4@RemoveCurs:

; 6260 :          lpCsrListener;

	cmp	DWORD PTR _lpCsrListener$[ebp], 0
	je	SHORT $LN3@RemoveCurs

; 6262 :    {
; 6263 :       if ( lpCsrListener->lpfnCursorListener == lpfnCursorListener &&
; 6264 :            lpCsrListener->pvListenerInstance == pvInstance &&

	mov	ecx, DWORD PTR _lpCsrListener$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _lpfnCursorListener$[ebp]
	jne	SHORT $LN5@RemoveCurs
	mov	eax, DWORD PTR _lpCsrListener$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _pvInstance$[ebp]
	jne	SHORT $LN5@RemoveCurs
	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _lListenerProcess$[ebp]
	jne	SHORT $LN5@RemoveCurs

; 6265 :            lpCsrListener->lListenerProcess == lListenerProcess )
; 6266 :       {
; 6267 :          // If prev is 0 then we found the very first one.
; 6268 :          if ( lpPrevCsrListener == 0 )

	cmp	DWORD PTR _lpPrevCsrListener$[ebp], 0
	jne	SHORT $LN6@RemoveCurs

; 6269 :             lpView->hFirstCursorListener = lpCsrListener->hNextCursorListener;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+34], eax
	jmp	SHORT $LN7@RemoveCurs
$LN6@RemoveCurs:

; 6270 :          else
; 6271 :             lpPrevCsrListener->hNextCursorListener = lpCsrListener->hNextCursorListener;

	mov	ecx, DWORD PTR _lpPrevCsrListener$[ebp]
	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax
$LN7@RemoveCurs:

; 6272 : 
; 6273 :          fnFreeDataspace( lpCsrListener );

	mov	ecx, DWORD PTR _lpCsrListener$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 6274 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@RemoveCurs
$LN5@RemoveCurs:

; 6275 :       }
; 6276 : 
; 6277 :       lpPrevCsrListener = lpCsrListener;

	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	DWORD PTR _lpPrevCsrListener$[ebp], edx

; 6278 :    }

	jmp	SHORT $LN2@RemoveCurs
$LN3@RemoveCurs:

; 6279 : 
; 6280 :    return( -1 ); // not found

	or	eax, -1
$LN1@RemoveCurs:

; 6281 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_RemoveCursorListener@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -16					; size = 4
_lListenerProcess$ = -12				; size = 4
_hCsrListener$ = -8					; size = 4
_lpCsrListener$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpfnCursorListener$ = 12				; size = 4
_pvInstance$ = 16					; size = 4
_AddCursorListener@12 PROC

; 6196 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 6197 :    LPTASK           lpCurrentTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 6198 :    zLONG            lListenerProcess = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lListenerProcess$[ebp], eax

; 6199 :    LPCURSORLISTENER lpCsrListener;
; 6200 :    LPCURSORLISTENER hCsrListener;
; 6201 : 
; 6202 : // TraceLine( "AddCursorListener for view: 0x%08x", lpView );
; 6203 : 
; 6204 :    // Check to see if it's already in the list.
; 6205 :    for ( lpCsrListener = zGETPTR( lpView->hFirstCursorListener );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$[ebp], eax
	jmp	SHORT $LN4@AddCursorL
$LN2@AddCursorL:

; 6207 :          lpCsrListener = zGETPTR( lpCsrListener->hNextCursorListener ) )

	mov	ecx, DWORD PTR _lpCsrListener$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$[ebp], eax
$LN4@AddCursorL:

; 6206 :          lpCsrListener;

	cmp	DWORD PTR _lpCsrListener$[ebp], 0
	je	SHORT $LN3@AddCursorL

; 6208 :    {
; 6209 :       if ( lpCsrListener->lpfnCursorListener == lpfnCursorListener &&
; 6210 :            lpCsrListener->pvListenerInstance == pvInstance &&

	mov	eax, DWORD PTR _lpCsrListener$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _lpfnCursorListener$[ebp]
	jne	SHORT $LN5@AddCursorL
	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _pvInstance$[ebp]
	jne	SHORT $LN5@AddCursorL
	mov	ecx, DWORD PTR _lpCsrListener$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lListenerProcess$[ebp]
	jne	SHORT $LN5@AddCursorL

; 6211 :            lpCsrListener->lListenerProcess == lListenerProcess )
; 6212 :       {
; 6213 :          // The listener is already registered - just return.
; 6214 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@AddCursorL
$LN5@AddCursorL:

; 6215 :       }
; 6216 :    }

	jmp	SHORT $LN2@AddCursorL
$LN3@AddCursorL:

; 6217 : 
; 6218 :    hCsrListener = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	0
	push	0
	push	1
	push	20					; 00000014H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hCsrListener$[ebp], eax

; 6219 :                                     sizeof( CursorListenerRecord ),
; 6220 :                                     1, 0, 0 );
; 6221 :    lpCsrListener = zGETPTR( hCsrListener );

	mov	edx, DWORD PTR _hCsrListener$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$[ebp], eax

; 6222 :    lpCsrListener->hNextCursorListener = lpView->hFirstCursorListener;

	mov	eax, DWORD PTR _lpCsrListener$[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	mov	DWORD PTR [eax], edx

; 6223 :    lpView->hFirstCursorListener = hCsrListener;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR _hCsrListener$[ebp]
	mov	DWORD PTR [eax+34], ecx

; 6224 : 
; 6225 :    lpCsrListener->lpfnCursorListener = lpfnCursorListener;

	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR _lpfnCursorListener$[ebp]
	mov	DWORD PTR [edx+4], eax

; 6226 :    lpCsrListener->pvListenerInstance = pvInstance;

	mov	ecx, DWORD PTR _lpCsrListener$[ebp]
	mov	edx, DWORD PTR _pvInstance$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 6227 :    lpCsrListener->lListenerProcess   = lListenerProcess;

	mov	eax, DWORD PTR _lpCsrListener$[ebp]
	mov	ecx, DWORD PTR _lListenerProcess$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 6228 :    lpCsrListener->hListenerTask      = lpView->hTask;

	mov	edx, DWORD PTR _lpCsrListener$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+16], ecx

; 6229 : 
; 6230 :    return( 0 );

	xor	eax, eax
$LN1@AddCursorL:

; 6231 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_AddCursorListener@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -28					; size = 4
tv174 = -24						; size = 4
tv150 = -20						; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpEntityInstance$ = -12				; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nState$ = 16						; size = 2
_SetSelectStateOfEntity@12 PROC

; 3100 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3101 :    LPTASK             lpCurrentTask;
; 3102 : // LPVIEWOI           lpViewOI;
; 3103 :    LPVIEWENTITY       lpViewEntity;
; 3104 :    LPVIEWENTITYCSR    lpViewEntityCsr;
; 3105 :    LPENTITYINSTANCE   lpEntityInstance;
; 3106 : // LPENTITYINSTANCE   lpScanEntityInstance;
; 3107 :    zSHORT             nRC;
; 3108 : 
; 3109 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 3110 :                                            &lpViewEntity,
; 3111 :                                            0,
; 3112 :                                            &lpViewEntityCsr,
; 3113 :                                            0,
; 3114 :                                            iSetSelectStateOfEntity,
; 3115 :                                            lpView,
; 3116 :                                            cpcEntityName,
; 3117 :                                            0 )) != 0 )

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	114					; 00000072H
	push	0
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetSelectS

; 3118 :    {
; 3119 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetSelectS
$LN2@SetSelectS:

; 3120 :    }
; 3121 : 
; 3122 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 3123 : 
; 3124 :    // Scan to see if Entity is in the SelectedInstance chain.
; 3125 :    nRC = fnSelectedInstanceFarbler( zGETPTR( lpViewEntityCsr->hViewCsr ),

	push	1
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 3126 :                                     zGETPTR( lpEntityInstance->hViewEntity ),
; 3127 :                                     lpViewEntityCsr->hEntityInstance, 1 );
; 3128 :    if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN3@SetSelectS

; 3129 :    {
; 3130 :       fnOperationReturn( iSetSelectStateOfEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	114					; 00000072H
	call	_fnOperationReturn
	add	esp, 8

; 3131 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetSelectS
$LN3@SetSelectS:

; 3132 :    }
; 3133 : 
; 3134 :    // DGC 6/2/97
; 3135 :    // It's possible that fnSelectedInstanceFarbler could change the selected
; 3136 :    // entity instance for lpViewEntityCsr.  Just in case get it again.
; 3137 :    // It's possible that this is not needed--I might know if I understood
; 3138 :    // fnSelectedInstanceFarbler more.
; 3139 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 3140 : 
; 3141 :    if ( nRC == 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jne	SHORT $LN4@SetSelectS

; 3142 :    {
; 3143 :       // Entity found in selected instance chain.
; 3144 : 
; 3145 :       if ( nState == 0 ) // deselect the instance

	movsx	ecx, WORD PTR _nState$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@SetSelectS

; 3146 :       {
; 3147 :          // remove Entity from the SelectedInstance chain
; 3148 :          nRC = fnSelectedInstanceFarbler( zGETPTR( lpViewEntityCsr->hViewCsr ),

	push	3
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 3149 :                                           zGETPTR( lpEntityInstance->
; 3150 :                                                             hViewEntity ),
; 3151 :                                           lpViewEntityCsr->hEntityInstance, 3 );
; 3152 :          nRC = (nRC > 0) ? (nRC - 1) : zCALL_ERROR; // indicate success,

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN11@SetSelectS
	movsx	eax, WORD PTR _nRC$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv150[ebp], eax
	jmp	SHORT $LN12@SetSelectS
$LN11@SetSelectS:
	mov	DWORD PTR tv150[ebp], -16		; fffffff0H
$LN12@SetSelectS:
	mov	cx, WORD PTR tv150[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN6@SetSelectS:

; 3153 :                                                       // hopefully
; 3154 :       }
; 3155 : #if 0
; 3156 :       else
; 3157 :       //  if we get here the return code is already set to
; 3158 :       //  indicate instance already selected
; 3159 :          ; // null on purpose
; 3160 : #endif
; 3161 :    }

	jmp	$LN5@SetSelectS
$LN4@SetSelectS:

; 3162 :    else
; 3163 :    {
; 3164 :       // Entity not in selected instance chain
; 3165 : 
; 3166 :       if ( nState ) // select the instance

	movsx	edx, WORD PTR _nState$[ebp]
	test	edx, edx
	je	SHORT $LN7@SetSelectS

; 3167 :       {
; 3168 :          // add to the chain
; 3169 :          nRC = fnSelectedInstanceFarbler( zGETPTR( lpViewEntityCsr->hViewCsr ),

	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 3170 :                                           zGETPTR( lpEntityInstance->hViewEntity ),
; 3171 :                                           lpViewEntityCsr->hEntityInstance, 2 );
; 3172 :          if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN9@SetSelectS

; 3173 :          {
; 3174 :             fnOperationReturn( iSetSelectStateOfEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	114					; 00000072H
	call	_fnOperationReturn
	add	esp, 8

; 3175 :             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetSelectS
$LN9@SetSelectS:

; 3176 :          }
; 3177 : 
; 3178 :          nRC = (nRC > 0) ? (nRC - 1) : zCALL_ERROR; // indicate success,

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN13@SetSelectS
	movsx	eax, WORD PTR _nRC$[ebp]
	sub	eax, 1
	mov	DWORD PTR tv174[ebp], eax
	jmp	SHORT $LN14@SetSelectS
$LN13@SetSelectS:
	mov	DWORD PTR tv174[ebp], -16		; fffffff0H
$LN14@SetSelectS:
	mov	cx, WORD PTR tv174[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 3179 :                                                     // hopefully
; 3180 :       }

	jmp	SHORT $LN5@SetSelectS
$LN7@SetSelectS:

; 3181 :       else
; 3182 :          nRC = 1; // indicate already deselected

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN5@SetSelectS:

; 3183 :    }
; 3184 : 
; 3185 :    fnOperationReturn( iSetSelectStateOfEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	114					; 00000072H
	call	_fnOperationReturn
	add	esp, 8

; 3186 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetSelectS:

; 3187 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetSelectStateOfEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nState$ = 16						; size = 2
_nSelectSet$ = 20					; size = 2
_SetSelectStateOfEntityForSet@16 PROC

; 3053 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3054 :    zSHORT nRC;
; 3055 : 
; 3056 :    nRC = SetSelectSetForView( lpView, nSelectSet );

	movzx	eax, WORD PTR _nSelectSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetSelectSetForView@8
	mov	WORD PTR _nRC$[ebp], ax

; 3057 :    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN2@SetSelectS

; 3058 :    {
; 3059 :       nSelectSet = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nSelectSet$[ebp], ax

; 3060 :       nRC = SetSelectStateOfEntity( lpView, cpcEntityName, nState );

	movzx	ecx, WORD PTR _nState$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetSelectStateOfEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3061 :       SetSelectSetForView( lpView, nSelectSet );

	movzx	ecx, WORD PTR _nSelectSet$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetSelectSetForView@8
$LN2@SetSelectS:

; 3062 :    }
; 3063 : 
; 3064 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 3065 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetSelectStateOfEntityForSet@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -84				; size = 4
_nStopLevel$1 = -80					; size = 4
_lpScopingEntityInstance$ = -76				; size = 4
_lpSearchViewEntity$2 = -72				; size = 4
_lpViewOI$ = -68					; size = 4
_lpSelectedInstancePrev$3 = -64				; size = 4
_lpSearchViewEntity$4 = -60				; size = 4
tv229 = -56						; size = 4
_lpViewEntity$ = -52					; size = 4
tv198 = -48						; size = 4
_lpSearchViewEntity$5 = -44				; size = 4
tv162 = -40						; size = 4
_lpCurrentTask$ = -36					; size = 4
_hSelectedInstancePrev$6 = -32				; size = 4
_lpViewEntityCsr$ = -28					; size = 4
_lpScopingViewEntityCsr$ = -24				; size = 4
_lpViewCsr$ = -20					; size = 4
_lpSelectedInstance$7 = -16				; size = 4
_hSelectedInstance$8 = -12				; size = 4
_lpSearchEntityInstance$ = -8				; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nState$ = 16						; size = 2
_cpcScopingEntityName$ = 20				; size = 4
_SetAllSelectStatesForEntity@16 PROC

; 2857 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 2858 :    LPTASK            lpCurrentTask;
; 2859 :    LPVIEWENTITY      lpViewEntity;
; 2860 :    LPVIEWENTITY      lpScopingViewEntity;
; 2861 :    LPVIEWCSR         lpViewCsr;
; 2862 :    LPVIEWOI          lpViewOI;
; 2863 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2864 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 2865 :    LPENTITYINSTANCE  lpScopingEntityInstance;
; 2866 :    LPENTITYINSTANCE  lpSearchEntityInstance;
; 2867 :    zSHORT            nRC;
; 2868 : 
; 2869 :    // Validate parameters
; 2870 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 2871 :                                            &lpViewEntity,
; 2872 :                                            &lpScopingViewEntity,
; 2873 :                                            &lpViewEntityCsr,
; 2874 :                                            &lpScopingViewEntityCsr,
; 2875 :                                            iSetAllSelectStatesForEntity,
; 2876 :                                            lpView,
; 2877 :                                            cpcEntityName,
; 2878 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	113					; 00000071H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN13@SetAllSele

; 2879 :    {
; 2880 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetAllSele
$LN13@SetAllSele:

; 2881 :    }
; 2882 : 
; 2883 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2884 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2885 : 
; 2886 :    if ( nState == 0 && (cpcEntityName == 0 || cpcEntityName[ 0 ] == 0) )

	movsx	ecx, WORD PTR _nState$[ebp]
	test	ecx, ecx
	jne	$LN14@SetAllSele
	cmp	DWORD PTR _cpcEntityName$[ebp], 0
	je	SHORT $LN15@SetAllSele
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	$LN14@SetAllSele
$LN15@SetAllSele:

; 2887 :    {
; 2888 :       // This condition causes a deselect of all SelectedInstances for the
; 2889 :       // current select set for a view.
; 2890 :       LPSELECTEDINSTANCE hSelectedInstance = lpViewCsr->hFirstSelectedInstance;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR _hSelectedInstance$8[ebp], ecx

; 2891 :       LPSELECTEDINSTANCE hSelectedInstancePrev = 0;

	mov	DWORD PTR _hSelectedInstancePrev$6[ebp], 0
$LN2@SetAllSele:

; 2892 :       LPSELECTEDINSTANCE lpSelectedInstancePrev;
; 2893 :       LPSELECTEDINSTANCE lpSelectedInstance;
; 2894 : 
; 2895 :       while ( hSelectedInstance )

	cmp	DWORD PTR _hSelectedInstance$8[ebp], 0
	je	$LN3@SetAllSele

; 2896 :       {
; 2897 :          lpSelectedInstance = zGETPTR( hSelectedInstance );

	mov	edx, DWORD PTR _hSelectedInstance$8[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstance$7[ebp], eax

; 2898 : 
; 2899 :          // If the entity is selected for the current select set, drop the
; 2900 :          // selection for the current select set.  If there are no other
; 2901 :          // select bits set for the selected instance, drop the instance.
; 2902 : 
; 2903 :          lpSelectedInstance->nSelectSet &= ~(lpViewCsr->nCurrentSelectSet);

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	movsx	ecx, WORD PTR [eax+36]
	not	ecx
	mov	edx, DWORD PTR _lpSelectedInstance$7[ebp]
	movsx	eax, WORD PTR [edx+6]
	and	eax, ecx
	mov	ecx, DWORD PTR _lpSelectedInstance$7[ebp]
	mov	WORD PTR [ecx+6], ax

; 2904 :          if ( lpSelectedInstance->nSelectSet == 0 )

	mov	edx, DWORD PTR _lpSelectedInstance$7[ebp]
	movsx	eax, WORD PTR [edx+6]
	test	eax, eax
	jne	SHORT $LN16@SetAllSele

; 2905 :          {
; 2906 :             if ( hSelectedInstancePrev )

	cmp	DWORD PTR _hSelectedInstancePrev$6[ebp], 0
	je	SHORT $LN18@SetAllSele

; 2907 :             {
; 2908 :                lpSelectedInstancePrev = zGETPTR( hSelectedInstancePrev );

	mov	ecx, DWORD PTR _hSelectedInstancePrev$6[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstancePrev$3[ebp], eax

; 2909 :                hSelectedInstance = lpSelectedInstance->hNextSelectedInstance;

	mov	edx, DWORD PTR _lpSelectedInstance$7[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR _hSelectedInstance$8[ebp], eax

; 2910 :                lpSelectedInstancePrev->hNextSelectedInstance = hSelectedInstance;

	mov	ecx, DWORD PTR _lpSelectedInstancePrev$3[ebp]
	mov	edx, DWORD PTR _hSelectedInstance$8[ebp]
	mov	DWORD PTR [ecx+2], edx

; 2911 :             }

	jmp	SHORT $LN19@SetAllSele
$LN18@SetAllSele:

; 2912 :             else
; 2913 :             {
; 2914 :                hSelectedInstance = lpSelectedInstance->hNextSelectedInstance;

	mov	eax, DWORD PTR _lpSelectedInstance$7[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _hSelectedInstance$8[ebp], ecx

; 2915 :                lpViewCsr->hFirstSelectedInstance = hSelectedInstance;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _hSelectedInstance$8[ebp]
	mov	DWORD PTR [edx+42], eax
$LN19@SetAllSele:

; 2916 :             }
; 2917 : 
; 2918 :             fnFreeDataspace( lpSelectedInstance );

	mov	ecx, DWORD PTR _lpSelectedInstance$7[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 2919 :          }

	jmp	SHORT $LN17@SetAllSele
$LN16@SetAllSele:

; 2920 :          else
; 2921 :          {
; 2922 :             hSelectedInstancePrev = hSelectedInstance;

	mov	edx, DWORD PTR _hSelectedInstance$8[ebp]
	mov	DWORD PTR _hSelectedInstancePrev$6[ebp], edx

; 2923 :             hSelectedInstance = lpSelectedInstance->hNextSelectedInstance;

	mov	eax, DWORD PTR _lpSelectedInstance$7[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _hSelectedInstance$8[ebp], ecx
$LN17@SetAllSele:

; 2924 :          }
; 2925 :       }

	jmp	$LN2@SetAllSele
$LN3@SetAllSele:

; 2926 : 
; 2927 :    // LPSELECTEDINSTANCE lpSelectedInstance;
; 2928 : 
; 2929 :    // while ( lpViewCsr->hFirstSelectedInstance )
; 2930 :    // {
; 2931 :    //    lpSelectedInstance = zGETPTR( lpViewCsr->hFirstSelectedInstance );
; 2932 :    //    lpViewCsr->hFirstSelectedInstance =
; 2933 :    //                      lpSelectedInstance->hNextSelectedInstance;
; 2934 :    //    fnFreeDataspace( lpSelectedInstance );
; 2935 :    // }
; 2936 : 
; 2937 :       fnOperationReturn( iSetAllSelectStatesForEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	113					; 00000071H
	call	_fnOperationReturn
	add	esp, 8

; 2938 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SetAllSele
$LN14@SetAllSele:

; 2939 :    }
; 2940 : 
; 2941 :    // If scoping is zSCOPE_OI then we're changing all occurrences of cpcEntity.
; 2942 :    if ( cpcScopingEntityName == zSCOPE_OI )

	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 1
	jne	$LN20@SetAllSele

; 2943 :    {
; 2944 :       LPVIEWENTITY lpSearchViewEntity;
; 2945 : 
; 2946 :       for ( lpSearchEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN6@SetAllSele
$LN4@SetAllSele:

; 2948 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN6@SetAllSele:

; 2947 :             lpSearchEntityInstance;

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN5@SetAllSele

; 2949 :       {
; 2950 :          lpSearchViewEntity = zGETPTR( lpSearchEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$5[ebp], eax

; 2951 :          if ( lpSearchViewEntity == lpViewEntity )

	mov	eax, DWORD PTR _lpSearchViewEntity$5[ebp]
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN21@SetAllSele

; 2952 :          {
; 2953 :             // We are not checking for hidden instances here, that
; 2954 :             // is being done in the Farbler routine to allow for
; 2955 :             // dynamic garbage collection.
; 2956 :             fnSelectedInstanceFarbler( lpViewCsr,

	movsx	ecx, WORD PTR _nState$[ebp]
	test	ecx, ecx
	jle	SHORT $LN29@SetAllSele
	mov	DWORD PTR tv162[ebp], 2
	jmp	SHORT $LN30@SetAllSele
$LN29@SetAllSele:
	mov	DWORD PTR tv162[ebp], 3
$LN30@SetAllSele:
	movzx	edx, WORD PTR tv162[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	ecx, DWORD PTR _lpSearchViewEntity$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
$LN21@SetAllSele:

; 2957 :                                        lpSearchViewEntity,
; 2958 :                                        zGETHNDL( lpSearchEntityInstance ),
; 2959 :                                        (zSHORT) (nState > 0 ? 2 : 3 ) );
; 2960 :          }
; 2961 :       }

	jmp	SHORT $LN4@SetAllSele
$LN5@SetAllSele:

; 2962 : 
; 2963 :       fnOperationReturn( iSetAllSelectStatesForEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	113					; 00000071H
	call	_fnOperationReturn
	add	esp, 8

; 2964 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SetAllSele
$LN20@SetAllSele:

; 2965 :    }
; 2966 : 
; 2967 :    // See if scoping entity is the parent of the target entity.
; 2968 :    if ( lpScopingViewEntityCsr )

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN22@SetAllSele

; 2969 :       lpScopingEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingEntityInstance$[ebp], eax
	jmp	SHORT $LN23@SetAllSele
$LN22@SetAllSele:

; 2970 :    else
; 2971 :       lpScopingViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScopingViewEntityCsr$[ebp], eax
$LN23@SetAllSele:

; 2972 : 
; 2973 :    if ( zGETPTR( lpViewEntityCsr->hParent ) == lpScopingViewEntityCsr )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	jne	$LN24@SetAllSele

; 2974 :    {
; 2975 :       LPVIEWENTITY lpSearchViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$2[ebp], eax

; 2976 : 
; 2977 :       lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 2978 :       if ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN26@SetAllSele
$LN7@SetAllSele:

; 2979 :       {
; 2980 :          while ( lpSearchEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN9@SetAllSele

; 2981 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN7@SetAllSele
$LN9@SetAllSele:

; 2982 : 
; 2983 :          while ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN26@SetAllSele

; 2984 :          {
; 2985 :             // We are not checking for hidden instances here, that
; 2986 :             // is being done in the Farbler routine to allow for
; 2987 :             // dynamic garbage collection.
; 2988 :             fnSelectedInstanceFarbler( lpViewCsr,

	movsx	edx, WORD PTR _nState$[ebp]
	test	edx, edx
	jle	SHORT $LN31@SetAllSele
	mov	DWORD PTR tv198[ebp], 2
	jmp	SHORT $LN32@SetAllSele
$LN31@SetAllSele:
	mov	DWORD PTR tv198[ebp], 3
$LN32@SetAllSele:
	movzx	eax, WORD PTR tv198[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	edx, DWORD PTR _lpSearchViewEntity$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H

; 2989 :                                        lpSearchViewEntity,
; 2990 :                                        zGETHNDL( lpSearchEntityInstance ),
; 2991 :                                        (zSHORT) (nState > 0 ? 2 : 3 ) );
; 2992 : 
; 2993 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 2994 :          }

	jmp	SHORT $LN9@SetAllSele
$LN26@SetAllSele:

; 2995 :       }
; 2996 :    }

	jmp	$LN25@SetAllSele
$LN24@SetAllSele:

; 2997 :    else
; 2998 :    {
; 2999 :       int nStopLevel = lpScopingViewEntityCsr->nLevel;

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	DWORD PTR _nStopLevel$1[ebp], ecx

; 3000 : 
; 3001 :       lpSearchEntityInstance = zGETPTR( lpScopingEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpScopingEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN11@SetAllSele:

; 3002 :       while ( lpSearchEntityInstance &&

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	$LN25@SetAllSele
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, DWORD PTR _nStopLevel$1[ebp]
	jle	SHORT $LN25@SetAllSele

; 3003 :               lpSearchEntityInstance->nLevel > nStopLevel )
; 3004 :       {
; 3005 :          LPVIEWENTITY lpSearchViewEntity = zGETPTR( lpSearchEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$4[ebp], eax

; 3006 : 
; 3007 :          if ( lpSearchViewEntity == lpViewEntity &&

	mov	edx, DWORD PTR _lpSearchViewEntity$4[ebp]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN27@SetAllSele
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	cmp	ecx, eax
	jne	SHORT $LN27@SetAllSele

; 3008 :               lpSearchEntityInstance->nLevel == lpViewEntityCsr->nLevel )
; 3009 :          {
; 3010 :             // We are not checking for hidden instances here, that
; 3011 :             // is being done in the Farbler routine to allow for
; 3012 :             // dynamic garbage collection.
; 3013 :             fnSelectedInstanceFarbler( lpViewCsr, lpSearchViewEntity,

	movsx	ecx, WORD PTR _nState$[ebp]
	test	ecx, ecx
	jle	SHORT $LN33@SetAllSele
	mov	DWORD PTR tv229[ebp], 2
	jmp	SHORT $LN34@SetAllSele
$LN33@SetAllSele:
	mov	DWORD PTR tv229[ebp], 3
$LN34@SetAllSele:
	movzx	edx, WORD PTR tv229[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	ecx, DWORD PTR _lpSearchViewEntity$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
$LN27@SetAllSele:

; 3014 :                                        zGETHNDL( lpSearchEntityInstance ),
; 3015 :                                        (zSHORT) (nState > 0 ? 2 : 3 ) );
; 3016 :          }
; 3017 : 
; 3018 :          lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 3019 :       }

	jmp	$LN11@SetAllSele
$LN25@SetAllSele:

; 3020 :    }
; 3021 : 
; 3022 :    fnOperationReturn( iSetAllSelectStatesForEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	113					; 00000071H
	call	_fnOperationReturn
	add	esp, 8

; 3023 :    return( 0 );

	xor	eax, eax
$LN1@SetAllSele:

; 3024 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetAllSelectStatesForEntity@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nState$ = 16						; size = 2
_nSelectSet$ = 20					; size = 2
_cpcScopingEntityName$ = 24				; size = 4
_SetAllSelStatesForEntityForSet@20 PROC

; 2814 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2815 :    zSHORT nRC;
; 2816 : 
; 2817 :    nRC = SetSelectSetForView( lpView, nSelectSet );

	movzx	eax, WORD PTR _nSelectSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetSelectSetForView@8
	mov	WORD PTR _nRC$[ebp], ax

; 2818 :    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN2@SetAllSelS

; 2819 :    {
; 2820 :       nSelectSet = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nSelectSet$[ebp], ax

; 2821 :       nRC = SetAllSelectStatesForEntity( lpView, cpcEntityName,

	mov	ecx, DWORD PTR _cpcScopingEntityName$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nState$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetAllSelectStatesForEntity@16
	mov	WORD PTR _nRC$[ebp], ax

; 2822 :                                          nState, cpcScopingEntityName );
; 2823 :       SetSelectSetForView( lpView, nSelectSet );

	movzx	edx, WORD PTR _nSelectSet$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetSelectSetForView@8
$LN2@SetAllSelS:

; 2824 :    }
; 2825 : 
; 2826 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2827 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetAllSelStatesForEntityForSet@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_SetCursorNextSelectedEntity@12 PROC

; 2580 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2581 :    LPTASK            lpCurrentTask;
; 2582 :    LPVIEWENTITY      lpViewEntity;
; 2583 :    LPVIEWENTITY      lpScopingViewEntity;
; 2584 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2585 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 2586 :    zSHORT            nRC;
; 2587 : 
; 2588 :    // Validate parameters
; 2589 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 2590 :                                            &lpViewEntity,
; 2591 :                                            &lpScopingViewEntity,
; 2592 :                                            &lpViewEntityCsr,
; 2593 :                                            &lpScopingViewEntityCsr,
; 2594 :                                            iSetCursorNextSelectedEntity,
; 2595 :                                            lpView,
; 2596 :                                            cpcEntityName,
; 2597 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	181					; 000000b5H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorN

; 2598 :    {
; 2599 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetCursorN
$LN2@SetCursorN:

; 2600 :    }
; 2601 : 
; 2602 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr, 0,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	8195					; 00002003H
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 2603 :                             (zLONG) (zPOS_NEXT | zQUAL_SELECTED),
; 2604 :                             0, 0,
; 2605 :                             0, 0,
; 2606 :                             lpScopingViewEntityCsr, 0,
; 2607 :                             lpCurrentTask );
; 2608 : 
; 2609 :    fnOperationReturn( iSetCursorNextSelectedEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	181					; 000000b5H
	call	_fnOperationReturn
	add	esp, 8

; 2610 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 2611 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorNextSelectedEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_SetCursorFirstSelectedEntity@12 PROC

; 2517 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2518 :    LPTASK            lpCurrentTask;
; 2519 :    LPVIEWENTITY      lpViewEntity;
; 2520 :    LPVIEWENTITY      lpScopingViewEntity;
; 2521 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2522 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 2523 :    zSHORT            nRC;
; 2524 : 
; 2525 :    // Validate parameters
; 2526 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 2527 :                                            &lpViewEntity,
; 2528 :                                            &lpScopingViewEntity,
; 2529 :                                            &lpViewEntityCsr,
; 2530 :                                            &lpScopingViewEntityCsr,
; 2531 :                                            iSetCursorFirstSelectedEntity,
; 2532 :                                            lpView,
; 2533 :                                            cpcEntityName,
; 2534 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	180					; 000000b4H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorF

; 2535 :    {
; 2536 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetCursorF
$LN2@SetCursorF:

; 2537 :    }
; 2538 : 
; 2539 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr, 0,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	8193					; 00002001H
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 2540 :                             (zLONG) (zPOS_FIRST | zQUAL_SELECTED),
; 2541 :                             0, 0,
; 2542 :                             0, 0,
; 2543 :                             lpScopingViewEntityCsr, 0,
; 2544 :                             lpCurrentTask );
; 2545 : 
; 2546 :    fnOperationReturn( iSetCursorFirstSelectedEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	180					; 000000b4H
	call	_fnOperationReturn
	add	esp, 8

; 2547 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorF:

; 2548 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorFirstSelectedEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpEntityInstance$ = -12				; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_GetSelectStateOfEntity@8 PROC

; 2751 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2752 :    LPVIEWENTITY       lpViewEntity;
; 2753 :    LPVIEWENTITYCSR    lpViewEntityCsr;
; 2754 :    LPENTITYINSTANCE   lpEntityInstance;
; 2755 :    LPTASK             lpCurrentTask;
; 2756 :    zSHORT             nRC;
; 2757 : 
; 2758 :    if ( fnValidateCursorParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	112					; 00000070H
	push	0
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@GetSelectS

; 2759 :                                     &lpViewEntity,
; 2760 :                                     0,
; 2761 :                                     &lpViewEntityCsr,
; 2762 :                                     0,
; 2763 :                                     iGetSelectStateOfEntity,
; 2764 :                                     lpView,
; 2765 :                                     cpcEntityName,
; 2766 :                                     0 ) )
; 2767 :    {
; 2768 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetSelectS
$LN2@GetSelectS:

; 2769 :    }
; 2770 : 
; 2771 :    // Scan to see if Entity is in the SelectedInstance chain
; 2772 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2773 :    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN3@GetSelectS

; 2774 :    {
; 2775 :       nRC = fnSelectedInstanceFarbler( zGETPTR( lpViewEntityCsr->hViewCsr ),

	push	1
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 2776 :                                        zGETPTR( lpEntityInstance->hViewEntity ),
; 2777 :                                        lpViewEntityCsr->hEntityInstance,
; 2778 :                                        1 );
; 2779 :    }

	jmp	SHORT $LN4@GetSelectS
$LN3@GetSelectS:

; 2780 :    else
; 2781 :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN4@GetSelectS:

; 2782 : 
; 2783 :    fnOperationReturn( iGetSelectStateOfEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	112					; 00000070H
	call	_fnOperationReturn
	add	esp, 8

; 2784 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetSelectS:

; 2785 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_GetSelectStateOfEntity@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nSelectSet$ = 16					; size = 2
_GetSelectStateOfEntityForSet@12 PROC

; 2711 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2712 :    zSHORT nRC;
; 2713 : 
; 2714 :    nRC = SetSelectSetForView( lpView, nSelectSet );

	movzx	eax, WORD PTR _nSelectSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetSelectSetForView@8
	mov	WORD PTR _nRC$[ebp], ax

; 2715 :    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN2@GetSelectS

; 2716 :    {
; 2717 :       nSelectSet = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nSelectSet$[ebp], ax

; 2718 :       nRC = GetSelectStateOfEntity( lpView, cpcEntityName );

	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_GetSelectStateOfEntity@8
	mov	WORD PTR _nRC$[ebp], ax

; 2719 :       SetSelectSetForView( lpView, nSelectSet );

	movzx	eax, WORD PTR _nSelectSet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetSelectSetForView@8
$LN2@GetSelectS:

; 2720 :    }
; 2721 : 
; 2722 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2723 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_GetSelectStateOfEntityForSet@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_nRC$ = -8						; size = 2
_nWk$ = -4						; size = 2
_lpView$ = 8						; size = 4
_nSelectSetID$ = 12					; size = 2
_SetSelectSetForView@8 PROC

; 2637 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2638 :    LPTASK            lpCurrentTask;
; 2639 :    LPVIEWCSR         lpViewCsr;
; 2640 :    zSHORT            nRC, nWk;
; 2641 : 
; 2642 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2643 :    if ( (lpCurrentTask = fnOperationCall( iSetSelectSetForView,
; 2644 :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	129					; 00000081H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN7@SetSelectS

; 2645 :    {
; 2646 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetSelectS
$LN7@SetSelectS:

; 2647 :    }
; 2648 : 
; 2649 :    if ( nSelectSetID < 1 || nSelectSetID > 16 )

	movsx	ecx, WORD PTR _nSelectSetID$[ebp]
	cmp	ecx, 1
	jl	SHORT $LN9@SetSelectS
	movsx	edx, WORD PTR _nSelectSetID$[ebp]
	cmp	edx, 16					; 00000010H
	jle	SHORT $LN8@SetSelectS
$LN9@SetSelectS:

; 2650 :    {
; 2651 :       // "KZOEE269 - Invalid Select Set ID, ID="
; 2652 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 269, ( zLONG ) nSelectSetID, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nSelectSetID$[ebp]
	push	eax
	push	269					; 0000010dH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2653 :       fnOperationReturn( iSetSelectSetForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	129					; 00000081H
	call	_fnOperationReturn
	add	esp, 8

; 2654 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetSelectS
$LN8@SetSelectS:

; 2655 :    }
; 2656 : 
; 2657 :    // Get the view csr
; 2658 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2659 : 
; 2660 :    // Determine the current select set
; 2661 :    nWk = lpViewCsr->nCurrentSelectSet;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	cx, WORD PTR [eax+36]
	mov	WORD PTR _nWk$[ebp], cx

; 2662 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN2@SetSelectS:

; 2663 :    while ( nWk )

	movsx	eax, WORD PTR _nWk$[ebp]
	test	eax, eax
	je	SHORT $LN3@SetSelectS

; 2664 :    {
; 2665 :       nWk >>= 1;

	mov	cx, WORD PTR _nWk$[ebp]
	sar	cx, 1
	mov	WORD PTR _nWk$[ebp], cx

; 2666 :       nRC++;

	mov	dx, WORD PTR _nRC$[ebp]
	add	dx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 2667 :    }

	jmp	SHORT $LN2@SetSelectS
$LN3@SetSelectS:

; 2668 : 
; 2669 :    if ( nRC != nSelectSetID )

	movsx	eax, WORD PTR _nRC$[ebp]
	movsx	ecx, WORD PTR _nSelectSetID$[ebp]
	cmp	eax, ecx
	je	SHORT $LN10@SetSelectS

; 2670 :    {
; 2671 :       nWk = 0x0001;

	mov	edx, 1
	mov	WORD PTR _nWk$[ebp], dx
$LN6@SetSelectS:

; 2672 :       for ( ; ; )
; 2673 :       {
; 2674 :          nSelectSetID--;

	mov	ax, WORD PTR _nSelectSetID$[ebp]
	sub	ax, 1
	mov	WORD PTR _nSelectSetID$[ebp], ax

; 2675 :          if ( nSelectSetID == 0 )

	movsx	ecx, WORD PTR _nSelectSetID$[ebp]
	test	ecx, ecx
	jne	SHORT $LN11@SetSelectS

; 2676 :             break;

	jmp	SHORT $LN5@SetSelectS
$LN11@SetSelectS:

; 2677 : 
; 2678 :          nWk <<= 1;

	mov	dx, WORD PTR _nWk$[ebp]
	shl	dx, 1
	mov	WORD PTR _nWk$[ebp], dx

; 2679 :       }

	jmp	SHORT $LN6@SetSelectS
$LN5@SetSelectS:

; 2680 : 
; 2681 :       lpViewCsr->nCurrentSelectSet = nWk;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	cx, WORD PTR _nWk$[ebp]
	mov	WORD PTR [eax+36], cx
$LN10@SetSelectS:

; 2682 :    }
; 2683 : 
; 2684 :    fnOperationReturn( iSetSelectSetForView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	129					; 00000081H
	call	_fnOperationReturn
	add	esp, 8

; 2685 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetSelectS:

; 2686 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SetSelectSetForView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -20					; size = 4
_lpViewEntity$1 = -16					; size = 4
_lpViewCsr$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pulReturnLevel$ = 8					; size = 4
_pchReturnEntityName$ = 12				; size = 4
_pulEntityKey$ = 16					; size = 4
_lpView$ = 20						; size = 4
_GetEntityKeyForHierarchicalCsr@16 PROC

; 2446 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2447 :    LPTASK            lpCurrentTask;
; 2448 :    LPVIEWCSR         lpViewCsr;
; 2449 :    LPENTITYINSTANCE  lpEntityInstance;
; 2450 :    zSHORT            nRC;
; 2451 : 
; 2452 :    *pulReturnLevel      = 0;

	mov	eax, DWORD PTR _pulReturnLevel$[ebp]
	mov	DWORD PTR [eax], 0

; 2453 :    *pchReturnEntityName = 0;

	mov	ecx, DWORD PTR _pchReturnEntityName$[ebp]
	mov	BYTE PTR [ecx], 0

; 2454 :    *pulEntityKey        = 0;

	mov	edx, DWORD PTR _pulEntityKey$[ebp]
	mov	DWORD PTR [edx], 0

; 2455 : 
; 2456 :    // Validate parameters.
; 2457 :    if ( fnValidateCursorParameters( &lpCurrentTask, 0, 0, 0, 0,

	push	0
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	194					; 000000c2H
	push	0
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@GetEntityK

; 2458 :                                     iGetEntityKeyForHierarchicalCsr,
; 2459 :                                     lpView, 0, 0 ) )
; 2460 :    {
; 2461 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetEntityK
$LN2@GetEntityK:

; 2462 :    }
; 2463 : 
; 2464 :    // Get View Cursor.
; 2465 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2466 :    lpEntityInstance = zGETPTR( lpViewCsr->hHierEntityInstance );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2467 :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN3@GetEntityK

; 2468 :    {
; 2469 :       nRC = zCURSOR_UNDEFINED;

	mov	ecx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], cx

; 2470 :    }

	jmp	SHORT $LN4@GetEntityK
$LN3@GetEntityK:

; 2471 :    else
; 2472 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN5@GetEntityK

; 2473 :    {
; 2474 :       nRC = zCURSOR_NULL;

	mov	edx, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], dx

; 2475 :    }

	jmp	SHORT $LN4@GetEntityK
$LN5@GetEntityK:

; 2476 :    else
; 2477 :    {
; 2478 :       LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 2479 : 
; 2480 :       zstrcpy( pchReturnEntityName, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$1[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _pchReturnEntityName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2481 :       *pulReturnLevel = lpEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _pulReturnLevel$[ebp]
	mov	DWORD PTR [eax], edx

; 2482 :       *pulEntityKey = lpEntityInstance->ulKey;

	mov	ecx, DWORD PTR _pulEntityKey$[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	mov	DWORD PTR [ecx], eax

; 2483 :       nRC = zCURSOR_SET;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN4@GetEntityK:

; 2484 :    }
; 2485 : 
; 2486 :    fnOperationReturn( iGetEntityKeyForHierarchicalCsr, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	194					; 000000c2H
	call	_fnOperationReturn
	add	esp, 8

; 2487 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetEntityK:

; 2488 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetEntityKeyForHierarchicalCsr@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -20					; size = 4
_lpViewEntity$1 = -16					; size = 4
_lpViewCsr$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_puReturnLevel$ = 8					; size = 4
_pchReturnEntityName$ = 12				; size = 4
_pulAbsolutePosition$ = 16				; size = 4
_lpView$ = 20						; size = 4
_GetEntityNameForHierarchicalCsr@16 PROC

; 2372 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2373 :    LPTASK            lpCurrentTask;
; 2374 :    LPVIEWCSR         lpViewCsr;
; 2375 :    LPENTITYINSTANCE  lpEntityInstance;
; 2376 :    zSHORT            nRC;
; 2377 : 
; 2378 :    *pchReturnEntityName = 0;

	mov	eax, DWORD PTR _pchReturnEntityName$[ebp]
	mov	BYTE PTR [eax], 0

; 2379 :    *pulAbsolutePosition = 0;

	mov	ecx, DWORD PTR _pulAbsolutePosition$[ebp]
	mov	DWORD PTR [ecx], 0

; 2380 :    *puReturnLevel      = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _puReturnLevel$[ebp]
	mov	WORD PTR [eax], dx

; 2381 : 
; 2382 :    // Validate parameters.
; 2383 :    if ( fnValidateCursorParameters( &lpCurrentTask, 0, 0, 0, 0,

	push	0
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	193					; 000000c1H
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	cwde
	test	eax, eax
	je	SHORT $LN5@GetEntityN

; 2384 :                                     iGetEntityNameForHierarchicalCsr,
; 2385 :                                     lpView, 0, 0 ) )
; 2386 :    {
; 2387 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetEntityN
$LN5@GetEntityN:

; 2388 :    }
; 2389 : 
; 2390 :    // Get View Cursor.
; 2391 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2392 :    lpEntityInstance = zGETPTR( lpViewCsr->hHierEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2393 :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN6@GetEntityN

; 2394 :    {
; 2395 :       nRC = zCURSOR_UNDEFINED;

	mov	edx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], dx

; 2396 :    }

	jmp	SHORT $LN7@GetEntityN
$LN6@GetEntityN:

; 2397 :    else
; 2398 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN8@GetEntityN

; 2399 :    {
; 2400 :       nRC = zCURSOR_NULL;

	mov	eax, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], ax

; 2401 :    }

	jmp	SHORT $LN7@GetEntityN
$LN8@GetEntityN:

; 2402 :    else
; 2403 :    {
; 2404 :       LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 2405 : 
; 2406 :       zstrcpy( pchReturnEntityName, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$1[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _pchReturnEntityName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2407 :       *puReturnLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _puReturnLevel$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR [edx], cx

; 2408 : 
; 2409 :       // We need to count previous entities.
; 2410 :       for ( ;

	jmp	SHORT $LN4@GetEntityN
$LN2@GetEntityN:

; 2412 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@GetEntityN:

; 2411 :             lpEntityInstance->hPrevHier;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN3@GetEntityN

; 2413 :       {
; 2414 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN10@GetEntityN

; 2415 :             (*pulAbsolutePosition)++;

	mov	ecx, DWORD PTR _pulAbsolutePosition$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _pulAbsolutePosition$[ebp]
	mov	DWORD PTR [eax], edx
$LN10@GetEntityN:

; 2416 :       }

	jmp	SHORT $LN2@GetEntityN
$LN3@GetEntityN:

; 2417 : 
; 2418 :       nRC = zCURSOR_SET;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN7@GetEntityN:

; 2419 :    }
; 2420 : 
; 2421 :    fnOperationReturn( iGetEntityNameForHierarchicalCsr, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	193					; 000000c1H
	call	_fnOperationReturn
	add	esp, 8

; 2422 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetEntityN:

; 2423 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetEntityNameForHierarchicalCsr@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -32					; size = 4
_lpHierRootEntityInstance$1 = -28			; size = 4
_lpViewEntity$2 = -24					; size = 4
_lpViewCsr$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpEntityInstance$ = -12				; size = 4
_nStartLevel$ = -8					; size = 2
_nRC$ = -4						; size = 2
_lpnReturnLevel$ = 8					; size = 4
_pchReturnEntityName$ = 12				; size = 4
_lpView$ = 16						; size = 4
_SetCursorNextEntityHierarchical@12 PROC

; 2242 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2243 :    LPTASK            lpCurrentTask;
; 2244 :    LPVIEWCSR         lpViewCsr;
; 2245 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2246 :    LPENTITYINSTANCE  lpEntityInstance;
; 2247 :    zSHORT            nStartLevel;
; 2248 :    zSHORT            nRC;
; 2249 : 
; 2250 :    // Validate parameters.
; 2251 :    if ( fnValidateCursorParameters( &lpCurrentTask,

	push	0
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	192					; 000000c0H
	push	0
	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@SetCursorN

; 2252 :                                     0, 0, 0, 0,
; 2253 :                                     iSetCursorNextEntityHierarchica,
; 2254 :                                     lpView, 0, 0 ) )
; 2255 :    {
; 2256 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorN
$LN12@SetCursorN:

; 2257 :    }
; 2258 : 
; 2259 :    // Default RC to zCURSOR_SET
; 2260 :    nRC = zCURSOR_SET;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2261 : 
; 2262 :    // Get View Cursor
; 2263 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2264 :    lpEntityInstance = zGETPTR( lpViewCsr->hHierEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2265 :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN13@SetCursorN

; 2266 :    {
; 2267 :       lpEntityInstance = zGETPTR( lpViewCsr->hHierRootEntityInstance );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2268 :       lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 2269 :    }

	jmp	$LN14@SetCursorN
$LN13@SetCursorN:

; 2270 :    else
; 2271 :    {
; 2272 :       nStartLevel = lpEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nStartLevel$[ebp], cx

; 2273 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@SetCursorN:

; 2274 :       for ( ; ; )
; 2275 :       {
; 2276 :          LPENTITYINSTANCE lpHierRootEntityInstance =

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpHierRootEntityInstance$1[ebp], eax

; 2277 :                               zGETPTR( lpViewCsr->hHierRootEntityInstance );
; 2278 : 
; 2279 :          // Check to see if the EI is out of view.  This happens if the EI has
; 2280 :          // a level <= to the HierRoot EI *unless* the root level is 1.  If the
; 2281 :          // level is 1 then we have a multi-root OI and this is OK.
; 2282 :          if ( lpEntityInstance == 0 ||

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN16@SetCursorN
	mov	eax, DWORD PTR _lpHierRootEntityInstance$1[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	ecx, 1
	jle	SHORT $LN15@SetCursorN
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpHierRootEntityInstance$1[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jg	SHORT $LN15@SetCursorN
$LN16@SetCursorN:

; 2283 :               ( lpHierRootEntityInstance->nLevel > 1 &&
; 2284 :                 lpEntityInstance->nLevel <= lpHierRootEntityInstance->nLevel ) )
; 2285 :          {
; 2286 :             nRC = zCURSOR_UNCHANGED;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax

; 2287 :             break;

	jmp	$LN14@SetCursorN
$LN15@SetCursorN:

; 2288 :          }
; 2289 : 
; 2290 :          // If entity instance is not deleted or excluded, look for
; 2291 :          // a View entity cursor which matches the entity instance.
; 2292 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	$LN17@SetCursorN
$LN5@SetCursorN:

; 2293 :          {
; 2294 :             while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN10@SetCursorN

; 2295 :             {
; 2296 :                for ( lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $LN9@SetCursorN
$LN7@SetCursorN:

; 2298 :                      lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$LN9@SetCursorN:

; 2297 :                      lpViewEntityCsr;

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN8@SetCursorN

; 2299 :                {
; 2300 :                   if ( lpEntityInstance->hViewEntity ==

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [edx+2]
	cmp	ecx, DWORD PTR [eax+14]
	jne	SHORT $LN18@SetCursorN

; 2301 :                                               lpViewEntityCsr->hViewEntity )
; 2302 :                   {
; 2303 :                      break;

	jmp	SHORT $LN8@SetCursorN
$LN18@SetCursorN:

; 2304 :                   }
; 2305 :                }

	jmp	SHORT $LN7@SetCursorN
$LN8@SetCursorN:

; 2306 : 
; 2307 :                if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN19@SetCursorN

; 2308 :                   break;

	jmp	SHORT $LN10@SetCursorN
$LN19@SetCursorN:

; 2309 : 
; 2310 :                fnResetViewFromSubobject( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 2311 :             }

	jmp	SHORT $LN5@SetCursorN
$LN10@SetCursorN:

; 2312 : 
; 2313 :             while ( lpViewEntityCsr->nLevel > lpEntityInstance->nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jle	SHORT $LN11@SetCursorN

; 2314 :                fnResetViewFromSubobject( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetViewFromSubobject
	add	esp, 4
	jmp	SHORT $LN10@SetCursorN
$LN11@SetCursorN:

; 2315 : 
; 2316 :             if ( lpViewEntityCsr->nLevel == lpEntityInstance->nLevel )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jne	SHORT $LN17@SetCursorN

; 2317 :                break;

	jmp	SHORT $LN14@SetCursorN
$LN17@SetCursorN:

; 2318 :          }
; 2319 : 
; 2320 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2321 :       }

	jmp	$LN4@SetCursorN
$LN14@SetCursorN:

; 2322 :    }
; 2323 : 
; 2324 :    // If nRC is zCURSOR_SET, set the entity instance in the cursor and reset
; 2325 :    // the cursor's children.
; 2326 :    if ( nRC == zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN21@SetCursorN

; 2327 :    {
; 2328 :       LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 2329 : 
; 2330 :       lpViewEntityCsr->hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 2331 :    // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 2332 :    //    SysMessageBox( 0, "SetCursorAbsolutePosition", "UNSET_CSR", -1 );
; 2333 : 
; 2334 :       lpViewCsr->hHierEntityInstance = lpViewEntityCsr->hEntityInstance;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 2335 :       fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 2336 :       *lpnReturnLevel = lpEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpnReturnLevel$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR [eax], dx

; 2337 :       zstrcpy( pchReturnEntityName, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$2[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _pchReturnEntityName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2338 : 
; 2339 :       lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 2340 :       if ( lpViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN22@SetCursorN

; 2341 :          nRC = zCURSOR_SET_RECURSIVECHILD;

	mov	eax, 2
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN21@SetCursorN
$LN22@SetCursorN:

; 2342 :       else
; 2343 :       if ( lpEntityInstance->nLevel < nStartLevel )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jge	SHORT $LN21@SetCursorN

; 2344 :          nRC = zCURSOR_SET_NEWPARENT;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN21@SetCursorN:

; 2345 :    }
; 2346 : 
; 2347 :    fnOperationReturn( iSetCursorNextEntityHierarchica, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	192					; 000000c0H
	call	_fnOperationReturn
	add	esp, 8

; 2348 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 2349 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorNextEntityHierarchical@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_lpViewCsr$ = -4					; size = 4
_lpView$ = 8						; size = 4
_DropHierarchicalCursor@4 PROC

; 2186 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2187 :    LPTASK    lpCurrentTask;
; 2188 :    LPVIEWCSR lpViewCsr;
; 2189 : 
; 2190 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2191 :    if ( (lpCurrentTask = fnOperationCall( iDropHierarchicalCursor,
; 2192 :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	191					; 000000bfH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@DropHierar

; 2193 :    {
; 2194 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@DropHierar
$LN2@DropHierar:

; 2195 :    }
; 2196 : 
; 2197 :    // We drop the cursor regardless of whether is is currently set or not.
; 2198 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2199 :    lpViewCsr->hHierRootEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [eax+22], 0

; 2200 :    lpViewCsr->hHierEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 2201 : 
; 2202 :    fnOperationReturn( iDropHierarchicalCursor, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	191					; 000000bfH
	call	_fnOperationReturn
	add	esp, 8

; 2203 :    return( 0 );

	xor	eax, eax
$LN1@DropHierar:

; 2204 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropHierarchicalCursor@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpRootViewEntityCsr$ = -12				; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_lpViewCsr$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_DefineHierarchicalCursor@8 PROC

; 2137 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2138 :    LPTASK           lpCurrentTask;
; 2139 :    LPVIEWCSR        lpViewCsr;
; 2140 :    LPVIEWENTITY     lpViewEntity;
; 2141 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 2142 :    LPVIEWENTITYCSR  lpRootViewEntityCsr;
; 2143 : 
; 2144 :    if ( fnValidateCursorParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	190					; 000000beH
	push	0
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@DefineHier

; 2145 :                                     &lpViewEntity,
; 2146 :                                     0,
; 2147 :                                     &lpViewEntityCsr,
; 2148 :                                     0,
; 2149 :                                     iDefineHierarchicalCursor,
; 2150 :                                     lpView,
; 2151 :                                     cpcEntityName,
; 2152 :                                     0 ) )
; 2153 :    {
; 2154 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@DefineHier
$LN2@DefineHier:

; 2155 :    }
; 2156 : 
; 2157 :    // Now that the parameters look OK set the hierarchical cursor in
; 2158 :    // the ViewCsr
; 2159 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2160 :    lpRootViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$[ebp], eax

; 2161 :    lpViewCsr->hHierRootEntityInstance = lpRootViewEntityCsr->hEntityInstance;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpRootViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	mov	DWORD PTR [ecx+22], eax

; 2162 :    if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN3@DefineHier

; 2163 :       lpViewCsr->hHierEntityInstance = lpViewEntityCsr->hEntityInstance;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	mov	DWORD PTR [ecx+26], eax
	jmp	SHORT $LN4@DefineHier
$LN3@DefineHier:

; 2164 :    else
; 2165 :       lpViewCsr->hHierEntityInstance = UNSET_CSR;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+26], 1
$LN4@DefineHier:

; 2166 : 
; 2167 :    fnOperationReturn( iDefineHierarchicalCursor, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	190					; 000000beH
	call	_fnOperationReturn
	add	esp, 8

; 2168 :    return( 0 );

	xor	eax, eax
$LN1@DefineHier:

; 2169 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DefineHierarchicalCursor@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpViewEntityCsr$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lCount$ = -12						; size = 4
_lpSearchEntityInstance$ = -8				; size = 4
_nRC$ = -4						; size = 2
_plReturnPosition$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_GetAbsolutePositionForEntity@12 PROC

; 1636 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1637 :    LPTASK            lpCurrentTask;
; 1638 :    LPVIEWCSR         lpViewCsr;
; 1639 :    LPVIEWENTITY      lpViewEntity;
; 1640 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1641 :    LPENTITYINSTANCE  lpSearchEntityInstance;
; 1642 :    zLONG             lCount;
; 1643 :    zSHORT            nRC;
; 1644 : 
; 1645 :    *plReturnPosition = -1;   // init to -1

	mov	eax, DWORD PTR _plReturnPosition$[ebp]
	mov	DWORD PTR [eax], -1

; 1646 : 
; 1647 :    // Validate parameters
; 1648 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1649 :                                            &lpViewEntity,
; 1650 :                                            0,
; 1651 :                                            &lpViewEntityCsr,
; 1652 :                                            0,
; 1653 :                                            iGetAbsolutePositionForEntity,
; 1654 :                                            lpView,
; 1655 :                                            cpcEntityName,
; 1656 :                                            0 )) != 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	186					; 000000baH
	push	0
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN4@GetAbsolut

; 1657 :    {
; 1658 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@GetAbsolut
$LN4@GetAbsolut:

; 1659 :    }
; 1660 : 
; 1661 :    // Entity cursor and scoping entity established, now look
; 1662 :    // for a previous entity of the entity type within the
; 1663 :    // scoping entity
; 1664 :    lCount = 0;

	mov	DWORD PTR _lCount$[ebp], 0

; 1665 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1666 :    lpSearchEntityInstance  = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 1667 :    if ( lpSearchEntityInstance == 0 )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	jne	SHORT $LN5@GetAbsolut

; 1668 :    {
; 1669 :       fnOperationReturn( iGetAbsolutePositionForEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	186					; 000000baH
	call	_fnOperationReturn
	add	esp, 8

; 1670 :       return( zCURSOR_NULL );

	mov	eax, -3					; fffffffdH
	jmp	$LN1@GetAbsolut
$LN5@GetAbsolut:

; 1671 :    }
; 1672 : 
; 1673 :    if ( lpSearchEntityInstance == UNSET_CSR ||

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 1
	je	SHORT $LN7@GetAbsolut
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN6@GetAbsolut
$LN7@GetAbsolut:

; 1674 :         lpSearchEntityInstance->u.nInd.bHidden )
; 1675 :    {
; 1676 :       fnOperationReturn( iGetAbsolutePositionForEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	186					; 000000baH
	call	_fnOperationReturn
	add	esp, 8

; 1677 :       return( zCURSOR_UNDEFINED );

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@GetAbsolut
$LN6@GetAbsolut:

; 1678 :    }
; 1679 : 
; 1680 :    // We need to count entities.
; 1681 :    lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN2@GetAbsolut:

; 1682 :    while ( lpSearchEntityInstance )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	SHORT $LN3@GetAbsolut

; 1683 :    {
; 1684 :       if ( lpSearchEntityInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN8@GetAbsolut

; 1685 :          lCount++;

	mov	ecx, DWORD PTR _lCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lCount$[ebp], ecx
$LN8@GetAbsolut:

; 1686 : 
; 1687 :       lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 1688 :    }

	jmp	SHORT $LN2@GetAbsolut
$LN3@GetAbsolut:

; 1689 : 
; 1690 :    *plReturnPosition = lCount;

	mov	ecx, DWORD PTR _plReturnPosition$[ebp]
	mov	edx, DWORD PTR _lCount$[ebp]
	mov	DWORD PTR [ecx], edx

; 1691 : 
; 1692 :    fnOperationReturn( iGetAbsolutePositionForEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	186					; 000000baH
	call	_fnOperationReturn
	add	esp, 8

; 1693 :    return( 0 );

	xor	eax, eax
$LN1@GetAbsolut:

; 1694 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_GetAbsolutePositionForEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpViewOI$ = -32					; size = 4
_lpCurrentTask$ = -28					; size = 4
_lpViewEntity$1 = -24					; size = 4
_lpSearchViewEntity$2 = -20				; size = 4
_lpViewCsr$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpSearchEntityInstance$ = -8				; size = 4
_nRC$ = -4						; size = 2
_pchReturnEntityName$ = 8				; size = 4
_lpView$ = 12						; size = 4
_lPosition$ = 16					; size = 4
_SetCursorAbsolutePosition@12 PROC

; 1488 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1489 :    LPTASK            lpCurrentTask;
; 1490 :    LPVIEWCSR         lpViewCsr;
; 1491 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1492 :    LPENTITYINSTANCE  lpSearchEntityInstance;
; 1493 :    LPVIEWOI          lpViewOI;
; 1494 :    zSHORT            nRC;
; 1495 : 
; 1496 :    // initial return entity name
; 1497 :    *pchReturnEntityName = 0;

	mov	eax, DWORD PTR _pchReturnEntityName$[ebp]
	mov	BYTE PTR [eax], 0

; 1498 : 
; 1499 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 1500 :    if ( (lpCurrentTask = fnOperationCall( iSetCursorAbsolutePosition,
; 1501 :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	187					; 000000bbH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN14@SetCursorA

; 1502 :    {
; 1503 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorA
$LN14@SetCursorA:

; 1504 :    }
; 1505 : 
; 1506 :    // Position must be greater than or equal zero.
; 1507 :    if ( lPosition < 0 )

	cmp	DWORD PTR _lPosition$[ebp], 0
	jge	SHORT $LN15@SetCursorA

; 1508 :    {
; 1509 :       fnOperationReturn( iSetCursorAbsolutePosition, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	187					; 000000bbH
	call	_fnOperationReturn
	add	esp, 8

; 1510 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorA
$LN15@SetCursorA:

; 1511 :    }
; 1512 : 
; 1513 :    // Get the root entity instance
; 1514 :    lpViewCsr              = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1515 :    lpViewOI               = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1516 :    lpSearchEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 1517 : 
; 1518 :    if ( lpSearchEntityInstance == 0 )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	jne	SHORT $LN2@SetCursorA

; 1519 :    {
; 1520 :       fnOperationReturn( iSetCursorAbsolutePosition, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	187					; 000000bbH
	call	_fnOperationReturn
	add	esp, 8

; 1521 :       return( zCURSOR_NULL );

	mov	eax, -3					; fffffffdH
	jmp	$LN1@SetCursorA
$LN2@SetCursorA:

; 1522 :    }
; 1523 : 
; 1524 :    // count down the number of instances that are not hidden
; 1525 :    while ( lPosition > 0 || lpSearchEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lPosition$[ebp], 0
	jg	SHORT $LN17@SetCursorA
	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN3@SetCursorA
$LN17@SetCursorA:

; 1526 :    {
; 1527 :       if ( lpSearchEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN18@SetCursorA

; 1528 :          lPosition--;

	mov	edx, DWORD PTR _lPosition$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lPosition$[ebp], edx
$LN18@SetCursorA:

; 1529 : 
; 1530 :       lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 1531 :       if ( lpSearchEntityInstance == 0 )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	jne	SHORT $LN19@SetCursorA

; 1532 :          break;

	jmp	SHORT $LN3@SetCursorA
$LN19@SetCursorA:

; 1533 :    }

	jmp	SHORT $LN2@SetCursorA
$LN3@SetCursorA:

; 1534 : 
; 1535 :    if ( lPosition == 0 &&
; 1536 :         lpSearchEntityInstance && lpSearchEntityInstance->u.nInd.bHidden == FALSE )

	cmp	DWORD PTR _lPosition$[ebp], 0
	jne	$LN20@SetCursorA
	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	$LN20@SetCursorA
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	$LN20@SetCursorA

; 1537 :    {
; 1538 :       LPVIEWENTITY lpViewEntity = zGETPTR( lpSearchEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 1539 : 
; 1540 :       // success
; 1541 : 
; 1542 :       // Check to see if the cursor is a hierarchical cursor.
; 1543 :       if ( lpViewCsr->hHierRootEntityInstance )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	$LN22@SetCursorA
$LN4@SetCursorA:

; 1544 :       {
; 1545 :          // Look for a View entity cursor which matches the entity instance.
; 1546 :          while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN9@SetCursorA

; 1547 :          {
; 1548 :             for ( lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $LN8@SetCursorA
$LN6@SetCursorA:

; 1550 :                   lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$LN8@SetCursorA:

; 1549 :                   lpViewEntityCsr;

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN7@SetCursorA

; 1551 :             {
; 1552 :                if ( lpSearchEntityInstance->hViewEntity ==

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [eax+2]
	cmp	edx, DWORD PTR [ecx+14]
	jne	SHORT $LN24@SetCursorA

; 1553 :                                                 lpViewEntityCsr->hViewEntity )
; 1554 :                {
; 1555 :                   break;

	jmp	SHORT $LN7@SetCursorA
$LN24@SetCursorA:

; 1556 :                }
; 1557 :             }

	jmp	SHORT $LN6@SetCursorA
$LN7@SetCursorA:

; 1558 : 
; 1559 :             if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN25@SetCursorA

; 1560 :                break;

	jmp	SHORT $LN9@SetCursorA
$LN25@SetCursorA:

; 1561 : 
; 1562 :             fnResetViewFromSubobject( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnResetViewFromSubobject
	add	esp, 4

; 1563 :          }

	jmp	SHORT $LN4@SetCursorA
$LN9@SetCursorA:

; 1564 : 
; 1565 :          while ( lpViewEntityCsr->nLevel > lpSearchEntityInstance->nLevel )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jle	SHORT $LN10@SetCursorA

; 1566 :             fnResetViewFromSubobject( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4
	jmp	SHORT $LN9@SetCursorA
$LN10@SetCursorA:

; 1567 : 
; 1568 :          lpViewEntityCsr->hEntityInstance = zGETHNDL( lpSearchEntityInstance );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 1569 :          lpViewCsr->hHierEntityInstance = lpViewEntityCsr->hEntityInstance;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 1570 :       // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 1571 :       //    SysMessageBox( 0, "SetCursorAbsolutePosition", "UNSET_CSR", -1 );
; 1572 : 
; 1573 :          fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 1574 :          zstrcpy( pchReturnEntityName, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$1[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _pchReturnEntityName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1575 :          nRC = zCURSOR_SET;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 1576 :       }

	jmp	$LN23@SetCursorA
$LN22@SetCursorA:

; 1577 :       else
; 1578 :       {
; 1579 :          lpViewEntityCsr = fnEstablishViewForInstance( lpView, 0,

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 1580 :                                                        lpSearchEntityInstance );
; 1581 :          if ( lpViewEntity->bRecursive &&

	mov	edx, DWORD PTR _lpViewEntity$1[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN26@SetCursorA
	mov	ecx, DWORD PTR _lpViewEntity$1[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetViewToSubobject@8
	cwde
	test	eax, eax
	jne	SHORT $LN26@SetCursorA

; 1582 :               SetViewToSubobject( lpView, lpViewEntity->szName ) == 0 )
; 1583 :          {
; 1584 :             LPVIEWENTITY lpSearchViewEntity;
; 1585 : 
; 1586 :             // Find the recursive parent name.
; 1587 :             for ( lpSearchViewEntity = zGETPTR( lpSearchEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$2[ebp], eax
	jmp	SHORT $LN13@SetCursorA
$LN11@SetCursorA:

; 1589 :                   lpSearchViewEntity = zGETPTR( lpSearchViewEntity->hParent ) )

	mov	eax, DWORD PTR _lpSearchViewEntity$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$2[ebp], eax
$LN13@SetCursorA:

; 1588 :                   lpSearchViewEntity->bRecursivePar == FALSE;

	mov	edx, DWORD PTR _lpSearchViewEntity$2[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 29					; 0000001dH
	and	eax, 1
	jne	SHORT $LN12@SetCursorA

; 1590 :             {
; 1591 :                ; // nothing needs to be done here.
; 1592 :             }

	jmp	SHORT $LN11@SetCursorA
$LN12@SetCursorA:

; 1593 : 
; 1594 :             zstrcpy( pchReturnEntityName, lpSearchViewEntity->szName );

	mov	ecx, DWORD PTR _lpSearchViewEntity$2[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _pchReturnEntityName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1595 :             nRC = zCURSOR_SET_RECURSIVECHILD;

	mov	eax, 2
	mov	WORD PTR _nRC$[ebp], ax

; 1596 :          }

	jmp	SHORT $LN23@SetCursorA
$LN26@SetCursorA:

; 1597 :          else
; 1598 :          {
; 1599 :             zstrcpy( pchReturnEntityName, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$1[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _pchReturnEntityName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1600 :             nRC = zCURSOR_SET;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN23@SetCursorA:

; 1601 :          }
; 1602 :       }
; 1603 : 
; 1604 :       fnCallListeners( lpView, pchReturnEntityName );

	mov	ecx, DWORD PTR _pchReturnEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCallListeners
	add	esp, 8

; 1605 :    }

	jmp	SHORT $LN21@SetCursorA
$LN20@SetCursorA:

; 1606 :    else
; 1607 :    {
; 1608 :       // failure, just return zCURSOR_NULL for now...
; 1609 :       nRC = zCURSOR_NULL;

	mov	eax, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], ax
$LN21@SetCursorA:

; 1610 :    }
; 1611 : 
; 1612 :    fnOperationReturn( iSetCursorAbsolutePosition, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	187					; 000000bbH
	call	_fnOperationReturn
	add	esp, 8

; 1613 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorA:

; 1614 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorAbsolutePosition@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -56				; size = 4
_lpViewCsr$ = -52					; size = 4
tv85 = -48						; size = 4
_lpCurrentTask$ = -44					; size = 4
_lpViewEntity$ = -40					; size = 4
_lpViewEntityCsr$ = -36					; size = 4
_lpScopingViewEntityCsr$ = -32				; size = 4
_lCount$ = -28						; size = 4
_l$ = -24						; size = 4
_lpSearchEntityInstance$ = -20				; size = 4
_nDesiredSelectState$ = -16				; size = 2
_nStopLevel$ = -12					; size = 2
_nRC$ = -8						; size = 2
_bSelectRelevant$ = -1					; size = 1
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_lFlag$ = 20						; size = 4
_GetRelativeEntityNumber@16 PROC

; 1343 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 1344 :    LPTASK            lpCurrentTask;
; 1345 :    LPVIEWCSR         lpViewCsr;
; 1346 :    LPVIEWENTITY      lpViewEntity;
; 1347 :    LPVIEWENTITY      lpScopingViewEntity;
; 1348 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1349 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1350 :    LPENTITYINSTANCE  lpSearchEntityInstance;
; 1351 :    zSHORT            nRC;
; 1352 :    zLONG             lCount;
; 1353 :    zSHORT            nStopLevel;
; 1354 :    zBOOL             bSelectRelevant;
; 1355 :    zSHORT            nDesiredSelectState;
; 1356 :    zLONG             l;
; 1357 : 
; 1358 :    if ( lFlag & zQUAL_SCOPE_OI )

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 524288				; 00080000H
	je	SHORT $LN7@GetRelativ

; 1359 :       cpcScopingEntityName = (zCPCHAR) zSCOPE_OI;

	mov	DWORD PTR _cpcScopingEntityName$[ebp], 1
$LN7@GetRelativ:

; 1360 : 
; 1361 :    // Validate parameters
; 1362 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1363 :                                            &lpViewEntity,
; 1364 :                                            &lpScopingViewEntity,
; 1365 :                                            &lpViewEntityCsr,
; 1366 :                                            &lpScopingViewEntityCsr,
; 1367 :                                            iGetRelativeEntityNumber,
; 1368 :                                            lpView,
; 1369 :                                            cpcEntityName,
; 1370 :                                            cpcScopingEntityName )) != 0 )

	mov	ecx, DWORD PTR _cpcScopingEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	183					; 000000b7H
	lea	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpScopingViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN8@GetRelativ

; 1371 :    {
; 1372 :       return( nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	jmp	$LN1@GetRelativ
$LN8@GetRelativ:

; 1373 :    }
; 1374 : 
; 1375 :    // If Selected and Unselected entities are requested, then the
; 1376 :    // Select state of the entity is not relevent.
; 1377 :    l = lFlag & (zQUAL_SELECTED | zQUAL_UNSELECTED);

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 24576				; 00006000H
	mov	DWORD PTR _l$[ebp], ecx

; 1378 :    if ( l && (-l & l) == l )

	je	SHORT $LN9@GetRelativ
	mov	edx, DWORD PTR _l$[ebp]
	neg	edx
	and	edx, DWORD PTR _l$[ebp]
	cmp	edx, DWORD PTR _l$[ebp]
	jne	SHORT $LN9@GetRelativ

; 1379 :    {
; 1380 :       bSelectRelevant = TRUE;

	mov	BYTE PTR _bSelectRelevant$[ebp], 1

; 1381 :       nDesiredSelectState = (l == zQUAL_SELECTED);

	cmp	DWORD PTR _l$[ebp], 8192		; 00002000H
	jne	SHORT $LN28@GetRelativ
	mov	DWORD PTR tv85[ebp], 1
	jmp	SHORT $LN29@GetRelativ
$LN28@GetRelativ:
	mov	DWORD PTR tv85[ebp], 0
$LN29@GetRelativ:
	mov	ax, WORD PTR tv85[ebp]
	mov	WORD PTR _nDesiredSelectState$[ebp], ax

; 1382 :    }

	jmp	SHORT $LN10@GetRelativ
$LN9@GetRelativ:

; 1383 :    else
; 1384 :       bSelectRelevant = 0;

	mov	BYTE PTR _bSelectRelevant$[ebp], 0
$LN10@GetRelativ:

; 1385 : 
; 1386 :    // Entity cursor and scoping entity established, now look
; 1387 :    // for a previous entity of the entity type within the
; 1388 :    // scoping entity
; 1389 :    lCount = 0;

	mov	DWORD PTR _lCount$[ebp], 0

; 1390 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1391 :    lpSearchEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 1392 :    if ( lpSearchEntityInstance == 0 )

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	jne	SHORT $LN11@GetRelativ

; 1393 :    {
; 1394 :       fnOperationReturn( iGetRelativeEntityNumber, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	183					; 000000b7H
	call	_fnOperationReturn
	add	esp, 8

; 1395 :       return( zCURSOR_NULL );

	mov	eax, -3					; fffffffdH
	jmp	$LN1@GetRelativ

; 1396 :    }

	jmp	SHORT $LN12@GetRelativ
$LN11@GetRelativ:

; 1397 :    else
; 1398 :    if ( lpSearchEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN12@GetRelativ

; 1399 :    {
; 1400 :       fnOperationReturn( iGetRelativeEntityNumber, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	183					; 000000b7H
	call	_fnOperationReturn
	add	esp, 8

; 1401 :       return( zCURSOR_UNDEFINED );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@GetRelativ
$LN12@GetRelativ:

; 1402 :    }
; 1403 : 
; 1404 :    if ( cpcScopingEntityName != zSCOPE_OI &&

	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 1
	je	SHORT $LN14@GetRelativ
	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN2@GetRelativ
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], eax
	jne	SHORT $LN14@GetRelativ
$LN2@GetRelativ:

; 1405 :         (lpScopingViewEntityCsr == 0 ||
; 1406 :          lpScopingViewEntityCsr == zGETPTR( lpViewEntityCsr->hParent )) )
; 1407 :    {
; 1408 :       while ( lpSearchEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN3@GetRelativ

; 1409 :       {
; 1410 :          lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax

; 1411 :          if ( lpSearchEntityInstance->u.nInd.bHidden == FALSE &&

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN17@GetRelativ
	movzx	ecx, BYTE PTR _bSelectRelevant$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@GetRelativ
	push	1
	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	movsx	edx, ax
	movsx	eax, WORD PTR _nDesiredSelectState$[ebp]
	cmp	edx, eax
	jne	SHORT $LN17@GetRelativ
$LN18@GetRelativ:

; 1412 :               (bSelectRelevant == FALSE ||
; 1413 :                (fnSelectedInstanceFarbler( lpViewCsr,
; 1414 :                                            lpViewEntity,
; 1415 :                                            zGETHNDL( lpSearchEntityInstance ), 1 )
; 1416 :                   == nDesiredSelectState)) )
; 1417 :          {
; 1418 :             lCount++;

	mov	ecx, DWORD PTR _lCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lCount$[ebp], ecx
$LN17@GetRelativ:

; 1419 :          }
; 1420 :       }

	jmp	SHORT $LN2@GetRelativ
$LN3@GetRelativ:

; 1421 :    }

	jmp	$LN15@GetRelativ
$LN14@GetRelativ:

; 1422 :    else
; 1423 :    {
; 1424 :       // We need to count within a scoping view entity csr
; 1425 :       if ( cpcScopingEntityName == zSCOPE_OI )

	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 1
	jne	SHORT $LN19@GetRelativ

; 1426 :          nStopLevel = 0;

	xor	edx, edx
	mov	WORD PTR _nStopLevel$[ebp], dx
	jmp	SHORT $LN20@GetRelativ
$LN19@GetRelativ:

; 1427 :       else
; 1428 :          nStopLevel = lpScopingViewEntityCsr->nLevel;

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	cx, WORD PTR [eax+22]
	mov	WORD PTR _nStopLevel$[ebp], cx
$LN20@GetRelativ:

; 1429 : 
; 1430 :       for ( lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
	jmp	SHORT $LN6@GetRelativ
$LN4@GetRelativ:

; 1432 :             lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hPrevHier ) )

	mov	ecx, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$[ebp], eax
$LN6@GetRelativ:

; 1431 :             lpSearchEntityInstance;

	cmp	DWORD PTR _lpSearchEntityInstance$[ebp], 0
	je	$LN15@GetRelativ

; 1433 :       {
; 1434 :          if ( lpSearchEntityInstance->nLevel <= nStopLevel )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStopLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN21@GetRelativ

; 1435 :             break;

	jmp	SHORT $LN15@GetRelativ
$LN21@GetRelativ:

; 1436 : 
; 1437 :          if ( zGETPTR( lpSearchEntityInstance->hViewEntity ) != lpViewEntity )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN22@GetRelativ

; 1438 :             continue;

	jmp	SHORT $LN4@GetRelativ
$LN22@GetRelativ:

; 1439 : 
; 1440 :          if ( lpSearchEntityInstance->nLevel != lpViewEntityCsr->nLevel )

	mov	edx, DWORD PTR _lpSearchEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	je	SHORT $LN23@GetRelativ

; 1441 :             continue;

	jmp	SHORT $LN4@GetRelativ
$LN23@GetRelativ:

; 1442 : 
; 1443 :          if ( lpSearchEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN24@GetRelativ

; 1444 :             continue;

	jmp	SHORT $LN4@GetRelativ
$LN24@GetRelativ:

; 1445 : 
; 1446 :          if ( bSelectRelevant == FALSE ||

	movzx	edx, BYTE PTR _bSelectRelevant$[ebp]
	test	edx, edx
	je	SHORT $LN26@GetRelativ
	push	1
	mov	eax, DWORD PTR _lpSearchEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H
	cwde
	movsx	ecx, WORD PTR _nDesiredSelectState$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN25@GetRelativ
$LN26@GetRelativ:

; 1447 :               fnSelectedInstanceFarbler( lpViewCsr, lpViewEntity,
; 1448 :                                          zGETHNDL( lpSearchEntityInstance ),
; 1449 :                                          1 ) == nDesiredSelectState )
; 1450 :          {
; 1451 :             lCount++;

	mov	edx, DWORD PTR _lCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCount$[ebp], edx
$LN25@GetRelativ:

; 1452 :          }
; 1453 :       }

	jmp	$LN4@GetRelativ
$LN15@GetRelativ:

; 1454 :    }
; 1455 : 
; 1456 :    fnOperationReturn( iGetRelativeEntityNumber, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	183					; 000000b7H
	call	_fnOperationReturn
	add	esp, 8

; 1457 :    return( lCount );

	mov	eax, DWORD PTR _lCount$[ebp]
$LN1@GetRelativ:

; 1458 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetRelativeEntityNumber@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_lPositionChange$ = 16					; size = 4
_cpcScopingEntityName$ = 20				; size = 4
_SetCursorRelativeEntity@16 PROC

; 1279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1280 :    LPTASK            lpCurrentTask;
; 1281 :    LPVIEWENTITY      lpViewEntity;
; 1282 :    LPVIEWENTITY      lpScopingViewEntity;
; 1283 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1284 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1285 :    zSHORT            nRC;
; 1286 : 
; 1287 :    // Validate parameters
; 1288 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1289 :                                            &lpViewEntity,
; 1290 :                                            &lpScopingViewEntity,
; 1291 :                                            &lpViewEntityCsr,
; 1292 :                                            &lpScopingViewEntityCsr,
; 1293 :                                            iSetCursorRelativeEntity,
; 1294 :                                            lpView,
; 1295 :                                            cpcEntityName,
; 1296 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	182					; 000000b6H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorR

; 1297 :    {
; 1298 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetCursorR
$LN2@SetCursorR:

; 1299 :    }
; 1300 : 
; 1301 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr, 0,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lPositionChange$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	8
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1302 :                             (zLONG) zPOS_RELATIVE, 0,
; 1303 :                             0, 0, lPositionChange,
; 1304 :                             lpScopingViewEntityCsr, 0,
; 1305 :                             lpCurrentTask );
; 1306 : 
; 1307 :    fnOperationReturn( iSetCursorRelativeEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	182					; 000000b6H
	call	_fnOperationReturn
	add	esp, 8

; 1308 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorR:

; 1309 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetCursorRelativeEntity@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpTempViewCsr$1 = -92					; size = 4
_lpScopingViewEntity$ = -88				; size = 4
_hTempViewEntityCsr$2 = -84				; size = 4
_lpNextHier$3 = -80					; size = 4
_hTempEntityInstance$4 = -76				; size = 4
_hTempViewEntity$5 = -72				; size = 4
_lAttribControl$6 = -68					; size = 4
_lAttribControl$7 = -64					; size = 4
_lpSearchEntityInstance$8 = -60				; size = 4
_lpViewEntityCsr$ = -56					; size = 4
_lpSrcViewEntityCsr$ = -52				; size = 4
_lpTempViewEntity$9 = -48				; size = 4
_lpTempEntityInstance$10 = -44				; size = 4
_lpSrcViewEntity$ = -40					; size = 4
_lpViewEntityAttrib$ = -36				; size = 4
_lpViewEntity$ = -32					; size = 4
_lpSrcViewEntityAttrib$ = -28				; size = 4
_lpScopingViewEntityCsr$ = -24				; size = 4
_lpTempViewEntityCsr$11 = -20				; size = 4
_lQualRequest$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_nRC$ = -8						; size = 2
_bScopeOI$ = -1						; size = 1
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lControl$ = 20						; size = 4
_pQualValue$ = 24					; size = 4
_cpcSrcEntityName$ = 28					; size = 4
_cpcSrcAttributeName$ = 32				; size = 4
_lRelPosition$ = 36					; size = 4
_cpcScopingEntityName$ = 40				; size = 4
_cpcContextName$ = 44					; size = 4
_SetEntityCursor@40 PROC

; 3334 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 3335 :    LPTASK            lpCurrentTask;
; 3336 :    LPVIEWENTITY      lpViewEntity;
; 3337 :    LPVIEWENTITY      lpSrcViewEntity;
; 3338 :    LPVIEWENTITY      lpScopingViewEntity;
; 3339 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 3340 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 3341 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 3342 :    LPVIEWATTRIB      lpViewEntityAttrib;
; 3343 :    LPVIEWATTRIB      lpSrcViewEntityAttrib;
; 3344 :    zLONG             lQualRequest;        // type of qualified request
; 3345 :    zBOOL             bScopeOI = FALSE;    // Scope OI

	mov	BYTE PTR _bScopeOI$[ebp], 0

; 3346 :    zSHORT            nRC;
; 3347 : 
; 3348 :    // First validate the lControl field to ensure that there are no
; 3349 :    // conflicting specifications.
; 3350 :    //
; 3351 :    // lControl must have at least one zPOS_ indicator set...
; 3352 : 
; 3353 :    if ( (lControl & (zPOS_ABS | zPOS_RELATIVE)) == 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 15					; 0000000fH
	jne	SHORT $LN2@SetEntityC

; 3354 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityC
$LN2@SetEntityC:

; 3355 : 
; 3356 :    // Check for more than one qualifier request from 'set 1'
; 3357 :    lQualRequest = lControl & (zQUAL_OPERAND | zQUAL_ENTITYCSR);

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2137856				; 00209f00H
	mov	DWORD PTR _lQualRequest$[ebp], ecx

; 3358 :    if ( lQualRequest )

	je	SHORT $LN3@SetEntityC

; 3359 :    {
; 3360 :       if ( (-(lQualRequest) & lQualRequest) != lQualRequest &&

	mov	edx, DWORD PTR _lQualRequest$[ebp]
	neg	edx
	and	edx, DWORD PTR _lQualRequest$[ebp]
	cmp	edx, DWORD PTR _lQualRequest$[ebp]
	je	SHORT $LN4@SetEntityC
	cmp	DWORD PTR _lQualRequest$[ebp], 36864	; 00009000H
	je	SHORT $LN4@SetEntityC

; 3361 :            lQualRequest != (zQUAL_ATTR_NULL | zQUAL_ENTITYATTR) )
; 3362 :       {
; 3363 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityC
$LN4@SetEntityC:

; 3364 :       }
; 3365 : 
; 3366 :       if ( (lControl & (zQUAL_GREATER_THAN | zQUAL_LESS_THAN)) ==

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 96					; 00000060H
	cmp	eax, 96					; 00000060H
	jne	SHORT $LN3@SetEntityC

; 3367 :                                      (zQUAL_GREATER_THAN | zQUAL_LESS_THAN) )
; 3368 :       {
; 3369 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityC
$LN3@SetEntityC:

; 3370 :       }
; 3371 :    }
; 3372 : 
; 3373 :    // Another Doug special ...
; 3374 :    if ( lControl & (zQUAL_SCOPE_OI | zQUAL_ENTITYKEY) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 8912896				; 00880000H
	je	SHORT $LN6@SetEntityC

; 3375 :    {
; 3376 :       if ( (lControl & zQUAL_SCOPE_OI) ||
; 3377 :            cpcScopingEntityName == zSCOPE_OI ||
; 3378 :            cpcScopingEntityName == 0 || *cpcScopingEntityName == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 524288				; 00080000H
	jne	SHORT $LN9@SetEntityC
	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 1
	je	SHORT $LN9@SetEntityC
	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 0
	je	SHORT $LN9@SetEntityC
	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN8@SetEntityC
$LN9@SetEntityC:

; 3379 :       {
; 3380 :          cpcScopingEntityName = zSCOPE_OI;

	mov	DWORD PTR _cpcScopingEntityName$[ebp], 1

; 3381 :          bScopeOI = TRUE;

	mov	BYTE PTR _bScopeOI$[ebp], 1
$LN8@SetEntityC:

; 3382 :       }
; 3383 :    }

	jmp	SHORT $LN7@SetEntityC
$LN6@SetEntityC:

; 3384 :    else
; 3385 :    if ( cpcScopingEntityName == zSCOPE_OI )

	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 1
	jne	SHORT $LN7@SetEntityC

; 3386 :       bScopeOI = TRUE;

	mov	BYTE PTR _bScopeOI$[ebp], 1
$LN7@SetEntityC:

; 3387 : 
; 3388 :    // Validate parameters.
; 3389 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 3390 :                                            &lpViewEntity,
; 3391 :                                            &lpScopingViewEntity,
; 3392 :                                            &lpViewEntityCsr,
; 3393 :                                            &lpScopingViewEntityCsr,
; 3394 :                                            iSetEntityCursor,
; 3395 :                                            lpView,
; 3396 :                                            cpcEntityName,
; 3397 :                                            cpcScopingEntityName )) != 0 )

	mov	edx, DWORD PTR _cpcScopingEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	184					; 000000b8H
	lea	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@SetEntityC

; 3398 :    {
; 3399 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetEntityC
$LN11@SetEntityC:

; 3400 :    }
; 3401 : 
; 3402 :    // If we turned on SCOPE_OI via zQUAL_ENTITYKEY, but there is no scoping
; 3403 :    // view entity cursor, turn it back off (dks 2004.05.03)!
; 3404 :    if ( (lControl & zQUAL_ENTITYKEY) &&
; 3405 :         (lControl & zQUAL_SCOPE_OI) == 0 && // SCOPE_OI on ... not via zQUAL_ENTITYKEY
; 3406 :         (lControl & zRECURS) == 0 &&

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 8388608				; 00800000H
	je	SHORT $LN12@SetEntityC
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 524288				; 00080000H
	jne	SHORT $LN12@SetEntityC
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	jne	SHORT $LN12@SetEntityC
	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 1
	jne	SHORT $LN12@SetEntityC

; 3407 :         cpcScopingEntityName == (zCPCHAR) zSCOPE_OI )
; 3408 :    {
; 3409 :       if ( lpScopingViewEntityCsr )

	cmp	DWORD PTR _lpScopingViewEntityCsr$[ebp], 0
	je	SHORT $LN13@SetEntityC

; 3410 :       {
; 3411 :          LPENTITYINSTANCE lpSearchEntityInstance =

	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$8[ebp], eax

; 3412 :                              zGETPTR( lpScopingViewEntityCsr->hEntityInstance );
; 3413 :          if ( lpSearchEntityInstance == 0 || lpSearchEntityInstance->hNextHier == 0 )

	cmp	DWORD PTR _lpSearchEntityInstance$8[ebp], 0
	je	SHORT $LN16@SetEntityC
	mov	ecx, DWORD PTR _lpSearchEntityInstance$8[ebp]
	cmp	DWORD PTR [ecx+14], 0
	jne	SHORT $LN15@SetEntityC
$LN16@SetEntityC:

; 3414 :          {
; 3415 :             cpcScopingEntityName = 0;

	mov	DWORD PTR _cpcScopingEntityName$[ebp], 0

; 3416 :             bScopeOI = FALSE;

	mov	BYTE PTR _bScopeOI$[ebp], 0
$LN15@SetEntityC:

; 3417 :          }
; 3418 :       }

	jmp	SHORT $LN12@SetEntityC
$LN13@SetEntityC:

; 3419 :       else
; 3420 :       {
; 3421 :          cpcScopingEntityName = 0;

	mov	DWORD PTR _cpcScopingEntityName$[ebp], 0

; 3422 :          bScopeOI = FALSE;

	mov	BYTE PTR _bScopeOI$[ebp], 0
$LN12@SetEntityC:

; 3423 :       }
; 3424 :    }
; 3425 : 
; 3426 :    if ( lQualRequest & zQUAL_OPERAND )

	mov	edx, DWORD PTR _lQualRequest$[ebp]
	and	edx, 40704				; 00009f00H
	je	SHORT $LN17@SetEntityC

; 3427 :    {
; 3428 :       zLONG lAttribControl = 0;

	mov	DWORD PTR _lAttribControl$7[ebp], 0

; 3429 : 
; 3430 :       // Check to see if we should use hidden attributes.
; 3431 :       if ( lControl & zQUAL_ATTR_HIDDEN )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN19@SetEntityC

; 3432 :          lAttribControl = zALLOW_HIDDEN;

	mov	DWORD PTR _lAttribControl$7[ebp], 1
$LN19@SetEntityC:

; 3433 : 
; 3434 :       if ( (lpViewEntityAttrib =
; 3435 :             fnValidViewAttrib( lpView, lpViewEntity,
; 3436 :                                cpcAttributeName, lAttribControl )) == 0 )

	mov	ecx, DWORD PTR _lAttribControl$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewEntityAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewEntityAttrib$[ebp], 0
	jne	SHORT $LN20@SetEntityC

; 3437 :       {
; 3438 :          fnOperationReturn( iSetEntityCursor, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	184					; 000000b8H
	call	_fnOperationReturn
	add	esp, 8

; 3439 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityC
$LN20@SetEntityC:

; 3440 :       }
; 3441 :    }

	jmp	SHORT $LN18@SetEntityC
$LN17@SetEntityC:

; 3442 :    else
; 3443 :       lpViewEntityAttrib = 0;

	mov	DWORD PTR _lpViewEntityAttrib$[ebp], 0
$LN18@SetEntityC:

; 3444 : 
; 3445 :    if ( lQualRequest & (zQUAL_ENTITYCSR | zQUAL_ENTITYATTR) )

	mov	eax, DWORD PTR _lQualRequest$[ebp]
	and	eax, 2101248				; 00201000H
	je	$LN21@SetEntityC

; 3446 :    {
; 3447 :       // Validate parameters
; 3448 :       if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 3449 :                                               &lpSrcViewEntity,
; 3450 :                                               0, // No scoping view entity
; 3451 :                                               &lpSrcViewEntityCsr,
; 3452 :                                               0,
; 3453 :                                               0, // do not pass oper id
; 3454 :                                               (zVIEW) pQualValue,
; 3455 :                                               cpcSrcEntityName,
; 3456 :                                               0 )) != 0 ) // no scoping entity

	push	0
	mov	ecx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pQualValue$[ebp]
	push	edx
	push	0
	push	0
	lea	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN22@SetEntityC

; 3457 :       {
; 3458 :          fnOperationReturn( iSetEntityCursor, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	184					; 000000b8H
	call	_fnOperationReturn
	add	esp, 8

; 3459 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetEntityC
$LN22@SetEntityC:

; 3460 :       }
; 3461 : 
; 3462 :       if ( lQualRequest & zQUAL_ENTITYATTR )

	mov	edx, DWORD PTR _lQualRequest$[ebp]
	and	edx, 4096				; 00001000H
	je	$LN23@SetEntityC

; 3463 :       {
; 3464 :          zLONG lAttribControl = 0;

	mov	DWORD PTR _lAttribControl$6[ebp], 0

; 3465 : 
; 3466 :          // Check to see if we should use hidden attributes.
; 3467 :          if ( lControl & zQUAL_ATTR_HIDDEN )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 16777216				; 01000000H
	je	SHORT $LN25@SetEntityC

; 3468 :             lAttribControl = zALLOW_HIDDEN;

	mov	DWORD PTR _lAttribControl$6[ebp], 1
$LN25@SetEntityC:

; 3469 : 
; 3470 :          lpSrcViewEntityAttrib =

	mov	ecx, DWORD PTR _lAttribControl$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQualValue$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpSrcViewEntityAttrib$[ebp], eax

; 3471 :                    fnValidViewAttrib( (zVIEW) pQualValue, lpSrcViewEntity,
; 3472 :                                       cpcSrcAttributeName, lAttribControl );
; 3473 :          if ( lpSrcViewEntityAttrib == 0 )

	cmp	DWORD PTR _lpSrcViewEntityAttrib$[ebp], 0
	jne	SHORT $LN26@SetEntityC

; 3474 :          {
; 3475 :             fnOperationReturn( iSetEntityCursor, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	184					; 000000b8H
	call	_fnOperationReturn
	add	esp, 8

; 3476 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityC
$LN26@SetEntityC:

; 3477 :          }
; 3478 : 
; 3479 :          // If SrcAttribute value is null, then the zQUAL_ATTR_NULL
; 3480 :          // qualifier must have been specified, else error...
; 3481 :          if ( fnAttributeValueNull( (zVIEW) pQualValue,
; 3482 :                                     zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),
; 3483 :                                     lpSrcViewEntityAttrib ) &&

	mov	eax, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN27@SetEntityC
	mov	edx, DWORD PTR _lQualRequest$[ebp]
	and	edx, 32768				; 00008000H
	jne	SHORT $LN27@SetEntityC

; 3484 :               (lQualRequest & zQUAL_ATTR_NULL) == 0 )
; 3485 :          {
; 3486 :             fnOperationReturn( iSetEntityCursor, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	184					; 000000b8H
	call	_fnOperationReturn
	add	esp, 8

; 3487 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityC

; 3488 :          }

	jmp	SHORT $LN28@SetEntityC
$LN27@SetEntityC:

; 3489 :          else
; 3490 :             lControl &= zLBITS - zQUAL_ATTR_NULL; // turn off ...

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, -32769				; ffff7fffH
	mov	DWORD PTR _lControl$[ebp], ecx
$LN28@SetEntityC:

; 3491 :       }

	jmp	SHORT $LN24@SetEntityC
$LN23@SetEntityC:

; 3492 :       else
; 3493 :       {
; 3494 :          lpSrcViewEntityAttrib = 0;

	mov	DWORD PTR _lpSrcViewEntityAttrib$[ebp], 0
$LN24@SetEntityC:

; 3495 :       }
; 3496 : 
; 3497 :       // Make sure the source view entity and the target view entity are
; 3498 :       // the same Entity type.
; 3499 :       if ( lQualRequest & zQUAL_ENTITYCSR &&

	mov	edx, DWORD PTR _lQualRequest$[ebp]
	and	edx, 2097152				; 00200000H
	je	SHORT $LN21@SetEntityC
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN21@SetEntityC

; 3500 :            lpViewEntity->lEREntTok != lpSrcViewEntity->lEREntTok )
; 3501 :       {
; 3502 :          // "KZOEE268 - Source and target entity types do not match"
; 3503 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 268, 0,

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	268					; 0000010cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3504 :                            lpViewEntity->szName,
; 3505 :                            lpSrcViewEntity->szName );
; 3506 :          fnOperationReturn( iSetEntityCursor, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	184					; 000000b8H
	call	_fnOperationReturn
	add	esp, 8

; 3507 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetEntityC
$LN21@SetEntityC:

; 3508 :       }
; 3509 :    }
; 3510 : 
; 3511 :    if ( cpcScopingEntityName == zSCOPE_OI )

	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 1
	jne	$LN30@SetEntityC

; 3512 :    {
; 3513 :       LPVIEWENTITYCSR      lpTempViewEntityCsr;
; 3514 :       LPENTITYINSTANCE     lpTempEntityInstance;
; 3515 :       LPVIEWENTITYCSR      lpNextHier;
; 3516 :       LPVIEWENTITY         lpTempViewEntity;
; 3517 :       LPVIEWCSR            lpTempViewCsr;
; 3518 :       zPVOID               hTempViewEntityCsr;
; 3519 :       zPVOID               hTempEntityInstance;
; 3520 :       zPVOID               hTempViewEntity;
; 3521 : 
; 3522 :       hTempViewEntityCsr  = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10023					; 00002727H
	push	0
	push	1
	push	30					; 0000001eH
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTempViewEntityCsr$2[ebp], eax

; 3523 :                                               sizeof( ViewEntityCsrRecord ),
; 3524 :                                               1, 0, iViewEntityCsr );
; 3525 :       hTempEntityInstance = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10024					; 00002728H
	push	0
	push	1
	push	68					; 00000044H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTempEntityInstance$4[ebp], eax

; 3526 :                                               sizeof( EntityInstanceRecord ),
; 3527 :                                               1, 0, iEntityInstance );
; 3528 :       hTempViewEntity     = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10012					; 0000271cH
	push	0
	push	1
	push	251					; 000000fbH
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTempViewEntity$5[ebp], eax

; 3529 :                                               sizeof( ViewEntityRecord ),
; 3530 :                                               1, 0, iViewEntity );
; 3531 : 
; 3532 :       lpTempViewEntityCsr  = zGETPTR( hTempViewEntityCsr );

	mov	edx, DWORD PTR _hTempViewEntityCsr$2[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntityCsr$11[ebp], eax

; 3533 :       lpTempEntityInstance = zGETPTR( hTempEntityInstance );

	mov	eax, DWORD PTR _hTempEntityInstance$4[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempEntityInstance$10[ebp], eax

; 3534 :       lpTempViewEntity     = zGETPTR( hTempViewEntity );

	mov	ecx, DWORD PTR _hTempViewEntity$5[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntity$9[ebp], eax

; 3535 : 
; 3536 :       lpScopingViewEntityCsr = lpTempViewEntityCsr;

	mov	edx, DWORD PTR _lpTempViewEntityCsr$11[ebp]
	mov	DWORD PTR _lpScopingViewEntityCsr$[ebp], edx

; 3537 :       lpScopingViewEntity    = lpTempViewEntity;

	mov	eax, DWORD PTR _lpTempViewEntity$9[ebp]
	mov	DWORD PTR _lpScopingViewEntity$[ebp], eax

; 3538 : 
; 3539 :       lpTempViewEntityCsr->hViewEntity     = hTempViewEntity;

	mov	ecx, DWORD PTR _lpTempViewEntityCsr$11[ebp]
	mov	edx, DWORD PTR _hTempViewEntity$5[ebp]
	mov	DWORD PTR [ecx+14], edx

; 3540 :       lpTempViewEntityCsr->hEntityInstance = hTempEntityInstance;

	mov	eax, DWORD PTR _lpTempViewEntityCsr$11[ebp]
	mov	ecx, DWORD PTR _hTempEntityInstance$4[ebp]
	mov	DWORD PTR [eax+26], ecx

; 3541 :    // if ( lpTempViewEntityCsr->hEntityInstance == UNSET_CSR )
; 3542 :    //    SysMessageBox( 0, "SetEntityCursor", "UNSET_CSR", -1 );
; 3543 : 
; 3544 :       // Set lpNextHier for ViewEntityCsr
; 3545 :       // Set lpScopingViewEntityCsr->hNextHier
; 3546 :       lpTempViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewCsr$1[ebp], eax

; 3547 :       lpTempViewEntityCsr->hNextHier = lpTempViewCsr->hRootViewEntityCsr; // ???

	mov	ecx, DWORD PTR _lpTempViewEntityCsr$11[ebp]
	mov	edx, DWORD PTR _lpTempViewCsr$1[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR [ecx+2], eax

; 3548 : 
; 3549 :       // Set lpScopingViewEntityCsr->hEntityInstance->hViewEntity.
; 3550 :       lpTempEntityInstance->hViewEntity = lpTempViewEntityCsr->hViewEntity;

	mov	ecx, DWORD PTR _lpTempEntityInstance$10[ebp]
	mov	edx, DWORD PTR _lpTempViewEntityCsr$11[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+2], eax

; 3551 : 
; 3552 :       // set lpNextHier for ViewEntity
; 3553 :       // set lpScopingViewEntity->hNextHier
; 3554 :       lpNextHier = zGETPTR( lpTempViewEntityCsr->hNextHier );

	mov	ecx, DWORD PTR _lpTempViewEntityCsr$11[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$3[ebp], eax

; 3555 :       lpTempViewEntity->hNextHier = lpNextHier->hViewEntity;

	mov	eax, DWORD PTR _lpTempViewEntity$9[ebp]
	mov	ecx, DWORD PTR _lpNextHier$3[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR [eax+2], edx

; 3556 : 
; 3557 :       // Set lpNextHier for EntityInstance.
; 3558 :       // Set lpScopingViewEntityCsr->hEntityInstance->hNextHier.
; 3559 :       lpTempEntityInstance->hNextHier = lpNextHier->hEntityInstance;

	mov	eax, DWORD PTR _lpTempEntityInstance$10[ebp]
	mov	ecx, DWORD PTR _lpNextHier$3[ebp]
	mov	edx, DWORD PTR [ecx+26]
	mov	DWORD PTR [eax+14], edx

; 3560 : 
; 3561 :       nRC = fnSetEntityCursor( lpView, lpViewEntity,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lRelPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 3562 :                                lpViewEntityCsr, lpViewEntityAttrib,
; 3563 :                                lControl, (zPVOID) pQualValue,
; 3564 :                                lpSrcViewEntityCsr, lpSrcViewEntityAttrib,
; 3565 :                                lRelPosition,
; 3566 :                                lpScopingViewEntityCsr,
; 3567 :                                cpcContextName,
; 3568 :                                lpCurrentTask );
; 3569 : 
; 3570 :       fnFreeDataspace( lpTempViewEntityCsr );

	mov	eax, DWORD PTR _lpTempViewEntityCsr$11[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 3571 :       fnFreeDataspace( lpTempEntityInstance );

	mov	ecx, DWORD PTR _lpTempEntityInstance$10[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 3572 :       fnFreeDataspace( lpTempViewEntity );

	mov	edx, DWORD PTR _lpTempViewEntity$9[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3573 :    }

	jmp	SHORT $LN31@SetEntityC
$LN30@SetEntityC:

; 3574 :    else
; 3575 :    {
; 3576 :       nRC = fnSetEntityCursor( lpView, lpViewEntity,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lRelPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQualValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax
$LN31@SetEntityC:

; 3577 :                                lpViewEntityCsr, lpViewEntityAttrib,
; 3578 :                                lControl, (zPVOID) pQualValue,
; 3579 :                                lpSrcViewEntityCsr, lpSrcViewEntityAttrib,
; 3580 :                                lRelPosition,
; 3581 :                                lpScopingViewEntityCsr,
; 3582 :                                cpcContextName,
; 3583 :                                lpCurrentTask );
; 3584 :    }
; 3585 : 
; 3586 :    fnOperationReturn( iSetEntityCursor, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	184					; 000000b8H
	call	_fnOperationReturn
	add	esp, 8

; 3587 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetEntityC:

; 3588 : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_SetEntityCursor@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -32				; size = 4
_lpViewEntityCsr$ = -28					; size = 4
_lpSrcViewEntityCsr$ = -24				; size = 4
_lpScopingViewEntityCsr$ = -20				; size = 4
_lpSrcViewEntity$ = -16					; size = 4
_lpViewEntity$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_cpcScopingEntityName$ = 24				; size = 4
_SetCursorNextEntityByEntityCsr@20 PROC

; 2051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2052 :    LPTASK            lpCurrentTask;
; 2053 :    LPVIEWENTITY      lpViewEntity;
; 2054 :    LPVIEWENTITY      lpSrcViewEntity;
; 2055 :    LPVIEWENTITY      lpScopingViewEntity;
; 2056 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2057 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 2058 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 2059 :    zSHORT            nRC;
; 2060 : 
; 2061 :    // Validate parameters
; 2062 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 2063 :                                            &lpViewEntity,
; 2064 :                                            &lpScopingViewEntity,
; 2065 :                                            &lpViewEntityCsr,
; 2066 :                                            &lpScopingViewEntityCsr,
; 2067 :                                            iSetCursorNextEntityByEntityCsr,
; 2068 :                                            lpView,
; 2069 :                                            cpcEntityName,
; 2070 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	179					; 000000b3H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorN

; 2071 :    {
; 2072 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorN
$LN2@SetCursorN:

; 2073 :    }
; 2074 : 
; 2075 :    // Validate parameters
; 2076 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 2077 :                                            &lpSrcViewEntity,
; 2078 :                                            0, // No scoping view entity
; 2079 :                                            &lpSrcViewEntityCsr,
; 2080 :                                            0,
; 2081 :                                            0, // do not pass oper id
; 2082 :                                            lpSrcView,
; 2083 :                                            cpcSrcEntityName,
; 2084 :                                            0 )) != 0 ) // no scoping entity

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@SetCursorN

; 2085 :    {
; 2086 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorN
$LN3@SetCursorN:

; 2087 :    }
; 2088 : 
; 2089 :    // Make sure the source view entity and the target view entity are
; 2090 :    // the same Entity type
; 2091 :    if ( lpViewEntity->lEREntTok != lpSrcViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN4@SetCursorN

; 2092 :    {
; 2093 :       // "KZOEE268 - Source and target entity types do not match"
; 2094 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 268, 0,

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	268					; 0000010cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2095 :                         lpViewEntity->szName,
; 2096 :                         lpSrcViewEntity->szName );
; 2097 :       fnOperationReturn( iSetCursorNextEntityByEntityCsr, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	179					; 000000b3H
	call	_fnOperationReturn
	add	esp, 8

; 2098 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorN
$LN4@SetCursorN:

; 2099 :    }
; 2100 : 
; 2101 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr, 0,

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	2097155					; 00200003H
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 2102 :                             (zLONG) (zPOS_NEXT | zQUAL_ENTITYCSR),
; 2103 :                             (zPVOID) lpSrcView, lpSrcViewEntityCsr,
; 2104 :                             0, 0,
; 2105 :                             lpScopingViewEntityCsr, 0,
; 2106 :                             lpCurrentTask );
; 2107 : 
; 2108 :    fnOperationReturn( iSetCursorNextEntityByEntityCsr, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	179					; 000000b3H
	call	_fnOperationReturn
	add	esp, 8

; 2109 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 2110 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetCursorNextEntityByEntityCsr@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -32				; size = 4
_lpViewEntityCsr$ = -28					; size = 4
_lpSrcViewEntityCsr$ = -24				; size = 4
_lpScopingViewEntityCsr$ = -20				; size = 4
_lpSrcViewEntity$ = -16					; size = 4
_lpViewEntity$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_cpcScopingEntityName$ = 24				; size = 4
_SetCursorFirstEntityByEntityCsr@20 PROC

; 1964 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1965 :    LPTASK            lpCurrentTask;
; 1966 :    LPVIEWENTITY      lpViewEntity;
; 1967 :    LPVIEWENTITY      lpSrcViewEntity;
; 1968 :    LPVIEWENTITY      lpScopingViewEntity;
; 1969 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1970 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 1971 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1972 :    zSHORT            nRC;
; 1973 : 
; 1974 :    // Validate parameters
; 1975 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1976 :                                            &lpViewEntity,
; 1977 :                                            &lpScopingViewEntity,
; 1978 :                                            &lpViewEntityCsr,
; 1979 :                                            &lpScopingViewEntityCsr,
; 1980 :                                            iSetCursorFirstEntityByEntityCs,
; 1981 :                                            lpView,
; 1982 :                                            cpcEntityName,
; 1983 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	178					; 000000b2H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorF

; 1984 :    {
; 1985 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorF
$LN2@SetCursorF:

; 1986 :    }
; 1987 : 
; 1988 :    // Validate parameters
; 1989 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1990 :                                            &lpSrcViewEntity,
; 1991 :                                            0, // No scoping view entity
; 1992 :                                            &lpSrcViewEntityCsr,
; 1993 :                                            0,
; 1994 :                                            0, // do not pass oper id
; 1995 :                                            lpSrcView,
; 1996 :                                            cpcSrcEntityName,
; 1997 :                                            0 )) != 0 ) // no scoping entity

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@SetCursorF

; 1998 :    {
; 1999 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorF
$LN3@SetCursorF:

; 2000 :    }
; 2001 : 
; 2002 :    // Make sure the source view entity and the target view entity are
; 2003 :    // the same Entity type
; 2004 :    if ( lpViewEntity->lEREntTok != lpSrcViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN4@SetCursorF

; 2005 :    {
; 2006 :       // "KZOEE268 - Source and target entity types do not match"
; 2007 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 268, 0,

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	268					; 0000010cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2008 :                         lpViewEntity->szName,
; 2009 :                         lpSrcViewEntity->szName );
; 2010 :       fnOperationReturn( iSetCursorFirstEntityByEntityCs, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	178					; 000000b2H
	call	_fnOperationReturn
	add	esp, 8

; 2011 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorF
$LN4@SetCursorF:

; 2012 :    }
; 2013 : 
; 2014 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr, 0,

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	push	2097153					; 00200001H
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 2015 :                             (zLONG) (zPOS_FIRST | zQUAL_ENTITYCSR),
; 2016 :                             (zPVOID) lpSrcView, lpSrcViewEntityCsr,
; 2017 :                             0, 0,
; 2018 :                             lpScopingViewEntityCsr, 0,
; 2019 :                             lpCurrentTask );
; 2020 : 
; 2021 :    fnOperationReturn( iSetCursorFirstEntityByEntityCs, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	178					; 000000b2H
	call	_fnOperationReturn
	add	esp, 8

; 2022 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorF:

; 2023 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetCursorFirstEntityByEntityCsr@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -40				; size = 4
_lpViewEntityCsr$ = -36					; size = 4
_lpSrcViewEntityCsr$ = -32				; size = 4
_lpScopingViewEntityCsr$ = -28				; size = 4
_lpSrcViewEntity$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpSrcViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_cpcSrcAttributeName$ = 28				; size = 4
_cpcScopingEntityName$ = 32				; size = 4
_SetCursorNextEntityByAttr@28 PROC

; 1871 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1872 :    LPTASK               lpCurrentTask;
; 1873 :    LPVIEWENTITY         lpViewEntity;
; 1874 :    LPVIEWENTITY         lpSrcViewEntity;
; 1875 :    LPVIEWENTITY         lpScopingViewEntity;
; 1876 :    LPVIEWENTITYCSR      lpViewEntityCsr;
; 1877 :    LPVIEWENTITYCSR      lpSrcViewEntityCsr;
; 1878 :    LPVIEWENTITYCSR      lpScopingViewEntityCsr;
; 1879 :    LPVIEWATTRIB         lpViewAttrib;
; 1880 :    LPVIEWATTRIB         lpSrcViewAttrib;
; 1881 :    zSHORT               nRC;
; 1882 : 
; 1883 :    // Validate parameters
; 1884 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1885 :                                            &lpViewEntity,
; 1886 :                                            &lpScopingViewEntity,
; 1887 :                                            &lpViewEntityCsr,
; 1888 :                                            &lpScopingViewEntityCsr,
; 1889 :                                            iSetCursorNextEntityByAttr,
; 1890 :                                            lpView,
; 1891 :                                            cpcEntityName,
; 1892 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	177					; 000000b1H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorN

; 1893 :    {
; 1894 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorN
$LN2@SetCursorN:

; 1895 :    }
; 1896 : 
; 1897 :    // Validate parameters
; 1898 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1899 :                                            &lpSrcViewEntity,
; 1900 :                                            0, // No scoping view entity
; 1901 :                                            &lpSrcViewEntityCsr,
; 1902 :                                            0,
; 1903 :                                            0, // do not pass oper id
; 1904 :                                            lpSrcView,
; 1905 :                                            cpcSrcEntityName,
; 1906 :                                            0 )) != 0 ) //  no scoping entity

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@SetCursorN

; 1907 :    {
; 1908 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorN
$LN3@SetCursorN:

; 1909 :    }
; 1910 : 
; 1911 :    // Validate the search attribute
; 1912 :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 1913 :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN4@SetCursorN

; 1914 :    {
; 1915 :       fnOperationReturn( iSetCursorNextEntityByAttr, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	177					; 000000b1H
	call	_fnOperationReturn
	add	esp, 8

; 1916 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorN
$LN4@SetCursorN:

; 1917 :    }
; 1918 : 
; 1919 :    // Validate the qualification attribute
; 1920 :    if ( (lpSrcViewAttrib = fnValidViewAttrib( lpSrcView, lpSrcViewEntity,
; 1921 :                                               cpcSrcAttributeName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpSrcViewAttrib$[ebp], 0
	jne	SHORT $LN5@SetCursorN

; 1922 :    {
; 1923 :       fnOperationReturn( iSetCursorNextEntityByAttr, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	177					; 000000b1H
	call	_fnOperationReturn
	add	esp, 8

; 1924 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorN
$LN5@SetCursorN:

; 1925 :    }
; 1926 : 
; 1927 :    // Now, position the cursor
; 1928 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	push	4099					; 00001003H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1929 :                             lpViewAttrib,
; 1930 :                             (zLONG) (zPOS_NEXT | zQUAL_ENTITYATTR),
; 1931 :                             (zPVOID) lpSrcView, lpSrcViewEntityCsr,
; 1932 :                             lpSrcViewAttrib, 0,
; 1933 :                             lpScopingViewEntityCsr, 0,
; 1934 :                             lpCurrentTask );
; 1935 : 
; 1936 :    fnOperationReturn( iSetCursorNextEntityByAttr, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	177					; 000000b1H
	call	_fnOperationReturn
	add	esp, 8

; 1937 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 1938 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_SetCursorNextEntityByAttr@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -40				; size = 4
_lpViewEntityCsr$ = -36					; size = 4
_lpSrcViewEntityCsr$ = -32				; size = 4
_lpScopingViewEntityCsr$ = -28				; size = 4
_lpSrcViewEntity$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpSrcViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lpSrcView$ = 20					; size = 4
_cpcSrcEntityName$ = 24					; size = 4
_cpcSrcAttributeName$ = 28				; size = 4
_cpcScopingEntityName$ = 32				; size = 4
_SetCursorFirstEntityByAttr@28 PROC

; 1775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1776 :    LPTASK               lpCurrentTask;
; 1777 :    LPVIEWENTITY         lpViewEntity;
; 1778 :    LPVIEWENTITY         lpSrcViewEntity;
; 1779 :    LPVIEWENTITY         lpScopingViewEntity;
; 1780 :    LPVIEWENTITYCSR      lpViewEntityCsr;
; 1781 :    LPVIEWENTITYCSR      lpSrcViewEntityCsr;
; 1782 :    LPVIEWENTITYCSR      lpScopingViewEntityCsr;
; 1783 :    LPVIEWATTRIB         lpViewAttrib;
; 1784 :    LPVIEWATTRIB         lpSrcViewAttrib;
; 1785 :    zSHORT               nRC;
; 1786 : 
; 1787 :    // Validate parameters
; 1788 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1789 :                                            &lpViewEntity,
; 1790 :                                            &lpScopingViewEntity,
; 1791 :                                            &lpViewEntityCsr,
; 1792 :                                            &lpScopingViewEntityCsr,
; 1793 :                                            iSetCursorFirstEntityByAttr,
; 1794 :                                            lpView,
; 1795 :                                            cpcEntityName,
; 1796 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	176					; 000000b0H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorF

; 1797 :    {
; 1798 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorF
$LN2@SetCursorF:

; 1799 :    }
; 1800 : 
; 1801 :    // Validate parameters
; 1802 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1803 :                                            &lpSrcViewEntity,
; 1804 :                                            0, // No scoping view entity
; 1805 :                                            &lpSrcViewEntityCsr,
; 1806 :                                            0,
; 1807 :                                            0, // do not pass oper id
; 1808 :                                            lpSrcView,
; 1809 :                                            cpcSrcEntityName,
; 1810 :                                            0 )) != 0 ) // No Src scoping ent

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN3@SetCursorF

; 1811 :    {
; 1812 :       fnOperationReturn( iSetCursorFirstEntityByAttr, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	176					; 000000b0H
	call	_fnOperationReturn
	add	esp, 8

; 1813 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorF
$LN3@SetCursorF:

; 1814 :    }
; 1815 : 
; 1816 :    // Validate the search attribute
; 1817 :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 1818 :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN4@SetCursorF

; 1819 :    {
; 1820 :       fnOperationReturn( iSetCursorFirstEntityByAttr, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	176					; 000000b0H
	call	_fnOperationReturn
	add	esp, 8

; 1821 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorF
$LN4@SetCursorF:

; 1822 :    }
; 1823 : 
; 1824 :    // Validate the qualification attribute
; 1825 :    if ( (lpSrcViewAttrib = fnValidViewAttrib( lpSrcView, lpSrcViewEntity,
; 1826 :                                               cpcSrcAttributeName, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _cpcSrcAttributeName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpSrcViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpSrcViewAttrib$[ebp], 0
	jne	SHORT $LN5@SetCursorF

; 1827 :    {
; 1828 :       fnOperationReturn( iSetCursorFirstEntityByAttr, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	176					; 000000b0H
	call	_fnOperationReturn
	add	esp, 8

; 1829 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorF
$LN5@SetCursorF:

; 1830 :    }
; 1831 : 
; 1832 :    // Now, position the cursor
; 1833 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpSrcViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	4097					; 00001001H
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1834 :                             lpViewAttrib,
; 1835 :                             (zLONG) (zPOS_FIRST | zQUAL_ENTITYATTR),
; 1836 :                             (zPVOID) lpSrcView, lpSrcViewEntityCsr,
; 1837 :                             lpSrcViewAttrib, 0,
; 1838 :                             lpScopingViewEntityCsr, 0,
; 1839 :                             lpCurrentTask );
; 1840 : 
; 1841 :    fnOperationReturn( iSetCursorFirstEntityByAttr, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	176					; 000000b0H
	call	_fnOperationReturn
	add	esp, 8

; 1842 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorF:

; 1843 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_SetCursorFirstEntityByAttr@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -28				; size = 4
_lpViewEntityCsr$ = -24					; size = 4
_lpScopingViewEntityCsr$ = -20				; size = 4
_lpViewEntity$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_dDecimalValue$ = 20					; size = 40
_cpcScopingEntityName$ = 60				; size = 4
_SetCursorNextEntityByDecimal@56 PROC

; 1214 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1215 :    LPTASK            lpCurrentTask;
; 1216 :    LPVIEWENTITY      lpViewEntity;
; 1217 :    LPVIEWATTRIB      lpViewAttrib;
; 1218 :    LPVIEWENTITY      lpScopingViewEntity;
; 1219 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1220 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1221 :    zSHORT            nRC;
; 1222 : 
; 1223 :    // Validate parameters
; 1224 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1225 :                                            &lpViewEntity,
; 1226 :                                            &lpScopingViewEntity,
; 1227 :                                            &lpViewEntityCsr,
; 1228 :                                            &lpScopingViewEntityCsr,
; 1229 :                                            iSetCursorNextEntityByDecimal,
; 1230 :                                            lpView,
; 1231 :                                            cpcEntityName,
; 1232 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	175					; 000000afH
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorN

; 1233 :    {
; 1234 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorN
$LN2@SetCursorN:

; 1235 :    }
; 1236 : 
; 1237 :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 1238 :                                            cpcAttributeName, 0  )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@SetCursorN

; 1239 :    {
; 1240 :       fnOperationReturn( iSetCursorNextEntityByDecimal, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	175					; 000000afH
	call	_fnOperationReturn
	add	esp, 8

; 1241 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorN
$LN3@SetCursorN:

; 1242 :    }
; 1243 : 
; 1244 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	push	515					; 00000203H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1245 :                             lpViewAttrib,
; 1246 :                             (zLONG) (zPOS_NEXT | zQUAL_DECIMAL),
; 1247 :                             (zPVOID) &dDecimalValue,
; 1248 :                             0, 0, 0, lpScopingViewEntityCsr, 0,
; 1249 :                             lpCurrentTask );
; 1250 : 
; 1251 :    fnOperationReturn( iSetCursorNextEntityByDecimal, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	175					; 000000afH
	call	_fnOperationReturn
	add	esp, 8

; 1252 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 1253 : }

	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_SetCursorNextEntityByDecimal@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -28				; size = 4
_lpViewEntityCsr$ = -24					; size = 4
_lpScopingViewEntityCsr$ = -20				; size = 4
_lpViewEntity$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_dDecimalValue$ = 20					; size = 40
_cpcScopingEntityName$ = 60				; size = 4
_SetCursorFirstEntityByDecimal@56 PROC

; 1149 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1150 :    LPTASK            lpCurrentTask;
; 1151 :    LPVIEWENTITY      lpViewEntity;
; 1152 :    LPVIEWATTRIB      lpViewAttrib;
; 1153 :    LPVIEWENTITY      lpScopingViewEntity;
; 1154 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1155 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1156 :    zSHORT            nRC;
; 1157 : 
; 1158 :    // Validate parameters
; 1159 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1160 :                                            &lpViewEntity,
; 1161 :                                            &lpScopingViewEntity,
; 1162 :                                            &lpViewEntityCsr,
; 1163 :                                            &lpScopingViewEntityCsr,
; 1164 :                                            iSetCursorFirstEntityByDecimal,
; 1165 :                                            lpView,
; 1166 :                                            cpcEntityName,
; 1167 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	174					; 000000aeH
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorF

; 1168 :    {
; 1169 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorF
$LN2@SetCursorF:

; 1170 :    }
; 1171 : 
; 1172 :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 1173 :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@SetCursorF

; 1174 :    {
; 1175 :       fnOperationReturn( iSetCursorFirstEntityByDecimal, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	174					; 000000aeH
	call	_fnOperationReturn
	add	esp, 8

; 1176 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorF
$LN3@SetCursorF:

; 1177 :    }
; 1178 : 
; 1179 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _dDecimalValue$[ebp]
	push	eax
	push	513					; 00000201H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1180 :                             lpViewAttrib,
; 1181 :                             (zLONG) (zPOS_FIRST | zQUAL_DECIMAL),
; 1182 :                             (zPVOID) &dDecimalValue,
; 1183 :                             0, 0, 0, lpScopingViewEntityCsr, 0,
; 1184 :                             lpCurrentTask );
; 1185 : 
; 1186 :    fnOperationReturn( iSetCursorFirstEntityByDecimal, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	174					; 000000aeH
	call	_fnOperationReturn
	add	esp, 8

; 1187 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorF:

; 1188 : }

	mov	esp, ebp
	pop	ebp
	ret	56					; 00000038H
_SetCursorFirstEntityByDecimal@56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -28				; size = 4
_lpViewEntityCsr$ = -24					; size = 4
_lpScopingViewEntityCsr$ = -20				; size = 4
_lpViewEntity$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lIntegerValue$ = 20					; size = 4
_cpcScopingEntityName$ = 24				; size = 4
_SetCursorNextEntityByInteger@20 PROC

; 1086 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1087 :    LPTASK            lpCurrentTask;
; 1088 :    LPVIEWENTITY      lpViewEntity;
; 1089 :    LPVIEWATTRIB      lpViewAttrib;
; 1090 :    LPVIEWENTITY      lpScopingViewEntity;
; 1091 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1092 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1093 :    zSHORT            nRC;
; 1094 : 
; 1095 :    // Validate parameters
; 1096 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1097 :                                            &lpViewEntity,
; 1098 :                                            &lpScopingViewEntity,
; 1099 :                                            &lpViewEntityCsr,
; 1100 :                                            &lpScopingViewEntityCsr,
; 1101 :                                            iSetCursorNextEntityByInteger,
; 1102 :                                            lpView,
; 1103 :                                            cpcEntityName,
; 1104 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	173					; 000000adH
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorN

; 1105 :    {
; 1106 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorN
$LN2@SetCursorN:

; 1107 :    }
; 1108 : 
; 1109 :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 1110 :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@SetCursorN

; 1111 :    {
; 1112 :       fnOperationReturn( iSetCursorNextEntityByInteger, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	173					; 000000adH
	call	_fnOperationReturn
	add	esp, 8

; 1113 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorN
$LN3@SetCursorN:

; 1114 :    }
; 1115 : 
; 1116 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _lIntegerValue$[ebp]
	push	eax
	push	259					; 00000103H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1117 :                             lpViewAttrib,
; 1118 :                             (zLONG) (zPOS_NEXT | zQUAL_INTEGER),
; 1119 :                             (zPVOID) &lIntegerValue,
; 1120 :                             0, 0, 0, lpScopingViewEntityCsr, 0,
; 1121 :                             lpCurrentTask );
; 1122 : 
; 1123 :    fnOperationReturn( iSetCursorNextEntityByInteger, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	173					; 000000adH
	call	_fnOperationReturn
	add	esp, 8

; 1124 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 1125 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetCursorNextEntityByInteger@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -28				; size = 4
_lpViewEntityCsr$ = -24					; size = 4
_lpScopingViewEntityCsr$ = -20				; size = 4
_lpViewEntity$ = -16					; size = 4
_lpViewAttrib$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_lIntegerValue$ = 20					; size = 4
_cpcScopingEntityName$ = 24				; size = 4
_SetCursorFirstEntityByInteger@20 PROC

; 1021 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1022 :    LPTASK            lpCurrentTask;
; 1023 :    LPVIEWENTITY      lpViewEntity;
; 1024 :    LPVIEWATTRIB      lpViewAttrib;
; 1025 :    LPVIEWENTITY      lpScopingViewEntity;
; 1026 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1027 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1028 :    zSHORT            nRC;
; 1029 : 
; 1030 :    // Validate parameters
; 1031 :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 1032 :                                            &lpViewEntity,
; 1033 :                                            &lpScopingViewEntity,
; 1034 :                                            &lpViewEntityCsr,
; 1035 :                                            &lpScopingViewEntityCsr,
; 1036 :                                            iSetCursorFirstEntityByInteger,
; 1037 :                                            lpView,
; 1038 :                                            cpcEntityName,
; 1039 :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	172					; 000000acH
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorF

; 1040 :    {
; 1041 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorF
$LN2@SetCursorF:

; 1042 :    }
; 1043 : 
; 1044 :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 1045 :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@SetCursorF

; 1046 :    {
; 1047 :       fnOperationReturn( iSetCursorFirstEntityByInteger, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	172					; 000000acH
	call	_fnOperationReturn
	add	esp, 8

; 1048 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetCursorF
$LN3@SetCursorF:

; 1049 :    }
; 1050 : 
; 1051 :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _lIntegerValue$[ebp]
	push	eax
	push	257					; 00000101H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1052 :                             lpViewAttrib,
; 1053 :                             (zLONG) (zPOS_FIRST | zQUAL_INTEGER),
; 1054 :                             (zPVOID) &lIntegerValue,
; 1055 :                             0, 0, 0, lpScopingViewEntityCsr, 0,
; 1056 :                             lpCurrentTask );
; 1057 : 
; 1058 :    fnOperationReturn( iSetCursorFirstEntityByInteger, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	172					; 000000acH
	call	_fnOperationReturn
	add	esp, 8

; 1059 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorF:

; 1060 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetCursorFirstEntityByInteger@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -832				; size = 4
_stInternalDateTime$ = -828				; size = 6
_lpViewOD$1 = -820					; size = 4
_lpDefaultContext$ = -816				; size = 4
_lpViewEntityCsr$ = -812				; size = 4
_lpScopingViewEntityCsr$ = -808				; size = 4
tv176 = -804						; size = 4
_lpDomain$ = -800					; size = 4
_nRC2$2 = -796						; size = 2
_lpViewEntity$ = -792					; size = 4
_lpCurrentTask$ = -788					; size = 4
_lpViewAttrib$ = -784					; size = 4
_lControl$ = -780					; size = 4
_nRC$ = -776						; size = 2
_sz$3 = -772						; size = 256
_sz$4 = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcStringValue$ = 20					; size = 4
_cpcScopingEntityName$ = 24				; size = 4
_SetCursorNextEntityByString@20 PROC

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 832				; 00000340H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 764  :    LPTASK                 lpCurrentTask;
; 765  :    LPVIEWENTITY           lpViewEntity;
; 766  :    LPVIEWATTRIB           lpViewAttrib;
; 767  :    LPVIEWENTITY           lpScopingViewEntity;
; 768  :    LPVIEWENTITYCSR        lpViewEntityCsr;
; 769  :    LPVIEWENTITYCSR        lpScopingViewEntityCsr;
; 770  :    zLPCONTEXT             lpDefaultContext;
; 771  :    LPDOMAIN               lpDomain;
; 772  :    zSHORT                 nRC;
; 773  :    zLONG                  lControl = zPOS_NEXT;

	mov	DWORD PTR _lControl$[ebp], 3

; 774  :    DateTimeInternalRecord stInternalDateTime;
; 775  : 
; 776  :    // Validate parameters
; 777  :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 778  :                                            &lpViewEntity,
; 779  :                                            &lpScopingViewEntity,
; 780  :                                            &lpViewEntityCsr,
; 781  :                                            &lpScopingViewEntityCsr,
; 782  :                                            iSetCursorNextEntityByString,
; 783  :                                            lpView,
; 784  :                                            cpcEntityName,
; 785  :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	171					; 000000abH
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorN

; 786  :    {
; 787  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorN
$LN2@SetCursorN:

; 788  :    }
; 789  : 
; 790  :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 791  :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@SetCursorN

; 792  :    {
; 793  :       fnOperationReturn( iSetCursorNextEntityByString, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	171					; 000000abH
	call	_fnOperationReturn
	add	esp, 8

; 794  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorN
$LN3@SetCursorN:

; 795  :    }
; 796  : 
; 797  :    if ( cpcStringValue && *cpcStringValue )

	cmp	DWORD PTR _cpcStringValue$[ebp], 0
	je	$LN4@SetCursorN
	mov	ecx, DWORD PTR _cpcStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN4@SetCursorN

; 798  :    {
; 799  :       // Check to see if the attribute is really a date/time field.  This is
; 800  :       // kind of a hack to allow setting cursors by datetimes.
; 801  :       if ( lpViewAttrib->cType == zTYPE_DATETIME )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 84					; 00000054H
	jne	$LN6@SetCursorN

; 802  :       {
; 803  :          lControl |= zQUAL_DATETIME;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 2048				; 00000800H
	mov	DWORD PTR _lControl$[ebp], edx

; 804  :          if ( UfStringToDateTime( cpcStringValue,
; 805  :                                   (LPDATETIME) &stInternalDateTime ) != 0 )

	lea	eax, DWORD PTR _stInternalDateTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcStringValue$[ebp]
	push	ecx
	call	_UfStringToDateTime@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN8@SetCursorN

; 806  :          {
; 807  :             zCHAR sz[ 256 ];
; 808  : 
; 809  :             // "KZOEE263 - Input Qualifier cannot be converted to
; 810  :             //  internal attribute data type"
; 811  :             zstrcpy( sz, "(S->DT), " );

	push	OFFSET $SG13663
	lea	eax, DWORD PTR _sz$3[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 812  :             zstrcat( sz, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _sz$3[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 813  :             fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz, lpViewAttrib->szName );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _sz$3[ebp]
	push	ecx
	push	0
	push	263					; 00000107H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 814  : 
; 815  :             fnOperationReturn( iSetCursorFirstEntityByString, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	170					; 000000aaH
	call	_fnOperationReturn
	add	esp, 8

; 816  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorN
$LN8@SetCursorN:

; 817  :          }
; 818  : 
; 819  :          // Change StringValue to point to internal datetime struct.
; 820  :          cpcStringValue = (zPCHAR) &stInternalDateTime;

	lea	edx, DWORD PTR _stInternalDateTime$[ebp]
	mov	DWORD PTR _cpcStringValue$[ebp], edx

; 821  :       }

	jmp	SHORT $LN7@SetCursorN
$LN6@SetCursorN:

; 822  :       else
; 823  :          lControl |= zQUAL_STRING;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax
$LN7@SetCursorN:

; 824  :    }

	jmp	SHORT $LN5@SetCursorN
$LN4@SetCursorN:

; 825  :    else
; 826  :       lControl |= zQUAL_ATTR_NULL;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 32768				; 00008000H
	mov	DWORD PTR _lControl$[ebp], ecx
$LN5@SetCursorN:

; 827  : 
; 828  :    lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 829  :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _cpcStringValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4194304				; 00400000H
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 830  :                             lpViewAttrib, lControl | zIGNORE_ERROR_358,
; 831  :                             (zPVOID) cpcStringValue,
; 832  :                             0, 0, 0, lpScopingViewEntityCsr,
; 833  :                             0, lpCurrentTask );
; 834  :    if ( nRC < zCURSOR_SET && lpDomain &&

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	$LN9@SetCursorN
	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	$LN9@SetCursorN
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+65]
	cmp	edx, 84					; 00000054H
	jne	$LN9@SetCursorN

; 835  :         lpDomain->cDomainType == zDM_TYPE_TABLE )
; 836  :    {
; 837  :       zSHORT nRC2;
; 838  : 
; 839  :       nRC2 = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpDefaultContext$[ebp]
	push	ecx
	call	_GetDefaultContext@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@SetCursorN
	mov	eax, DWORD PTR _lpDefaultContext$[ebp]
	add	eax, 6
	mov	DWORD PTR tv176[ebp], eax
	jmp	SHORT $LN13@SetCursorN
$LN12@SetCursorN:
	mov	DWORD PTR tv176[ebp], 0
$LN13@SetCursorN:
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv176[ebp]
	push	edx
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _cpcStringValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 65536				; 00010000H
	or	edx, 4194304				; 00400000H
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC2$2[ebp], ax

; 840  :                                 lpViewAttrib,
; 841  :                                 lControl | zTEST_CSR_RESULT | zIGNORE_ERROR_358,
; 842  :                                 (zPVOID) cpcStringValue,
; 843  :                                 0, 0, 0, lpScopingViewEntityCsr,
; 844  :                                 (GetDefaultContext( &lpDefaultContext, lpDomain )
; 845  :                                   ? lpDefaultContext->szName : 0),
; 846  :                                 lpCurrentTask );
; 847  :       if ( nRC2 >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nRC2$2[ebp]
	test	ecx, ecx
	jl	$LN9@SetCursorN

; 848  :       {
; 849  :          zCHAR    sz[ 512 ];
; 850  :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 851  : 
; 852  :          zstrcpy( sz, "Failure during standard call, but would have been "

	push	OFFSET $SG13666
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 853  :                       "successful if the default context was used.\n"
; 854  :                       "Probable User Error." );
; 855  :          zstrcat( sz, "\nObject Def: " );

	push	OFFSET $SG13667
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 856  :          zstrcat( sz, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 857  :          zstrcat( sz, "\nEntity: " );

	push	OFFSET $SG13668
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 858  :          zstrcat( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 859  :          zstrcat( sz, "\nAttribute: " );

	push	OFFSET $SG13669
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 860  :          zstrcat( sz, lpViewAttrib->szName );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 861  :          SysMessageBox( lpView, "SetCursorNextEntityByString", sz, 1 );

	push	1
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	push	OFFSET $SG13670
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16
$LN9@SetCursorN:

; 862  :       }
; 863  :    }
; 864  : 
; 865  :    fnOperationReturn( iSetCursorNextEntityByString, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	171					; 000000abH
	call	_fnOperationReturn
	add	esp, 8

; 866  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 867  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetCursorNextEntityByString@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -832				; size = 4
_stInternalDateTime$ = -828				; size = 6
_lpViewOD$1 = -820					; size = 4
_lpDefaultContext$ = -816				; size = 4
_lpViewEntityCsr$ = -812				; size = 4
_lpScopingViewEntityCsr$ = -808				; size = 4
tv176 = -804						; size = 4
_lpDomain$ = -800					; size = 4
_nRC2$2 = -796						; size = 2
_lpViewEntity$ = -792					; size = 4
_lpCurrentTask$ = -788					; size = 4
_lpViewAttrib$ = -784					; size = 4
_lControl$ = -780					; size = 4
_nRC$ = -776						; size = 2
_sz$3 = -772						; size = 256
_sz$4 = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_cpcStringValue$ = 20					; size = 4
_cpcScopingEntityName$ = 24				; size = 4
_SetCursorFirstEntityByString@20 PROC

; 633  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 832				; 00000340H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 634  :    LPTASK                 lpCurrentTask;
; 635  :    LPVIEWENTITY           lpViewEntity;
; 636  :    LPVIEWATTRIB           lpViewAttrib;
; 637  :    LPVIEWENTITY           lpScopingViewEntity;
; 638  :    LPVIEWENTITYCSR        lpViewEntityCsr;
; 639  :    LPVIEWENTITYCSR        lpScopingViewEntityCsr;
; 640  :    zLPCONTEXT             lpDefaultContext;
; 641  :    LPDOMAIN               lpDomain;
; 642  :    zSHORT                 nRC;
; 643  :    zLONG                  lControl = zPOS_FIRST;

	mov	DWORD PTR _lControl$[ebp], 1

; 644  :    DateTimeInternalRecord stInternalDateTime;
; 645  : 
; 646  :    // Validate parameters
; 647  :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 648  :                                            &lpViewEntity,
; 649  :                                            &lpScopingViewEntity,
; 650  :                                            &lpViewEntityCsr,
; 651  :                                            &lpScopingViewEntityCsr,
; 652  :                                            iSetCursorFirstEntityByString,
; 653  :                                            lpView,
; 654  :                                            cpcEntityName,
; 655  :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	170					; 000000aaH
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorF

; 656  :    {
; 657  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SetCursorF
$LN2@SetCursorF:

; 658  :    }
; 659  : 
; 660  :    if ( (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 661  :                                            cpcAttributeName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN3@SetCursorF

; 662  :    {
; 663  :       fnOperationReturn( iSetCursorFirstEntityByString, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	170					; 000000aaH
	call	_fnOperationReturn
	add	esp, 8

; 664  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorF
$LN3@SetCursorF:

; 665  :    }
; 666  : 
; 667  :    if ( cpcStringValue && *cpcStringValue )

	cmp	DWORD PTR _cpcStringValue$[ebp], 0
	je	$LN4@SetCursorF
	mov	ecx, DWORD PTR _cpcStringValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN4@SetCursorF

; 668  :    {
; 669  :       // Check to see if the attribute is really a date/time field.  This is
; 670  :       // kind of a hack to allow setting cursors by datetimes.
; 671  :       if ( lpViewAttrib->cType == zTYPE_DATETIME )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 84					; 00000054H
	jne	$LN6@SetCursorF

; 672  :       {
; 673  :          lControl |= zQUAL_DATETIME;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 2048				; 00000800H
	mov	DWORD PTR _lControl$[ebp], edx

; 674  :          if ( UfStringToDateTime( cpcStringValue,
; 675  :                                   (LPDATETIME) &stInternalDateTime ) != 0 )

	lea	eax, DWORD PTR _stInternalDateTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcStringValue$[ebp]
	push	ecx
	call	_UfStringToDateTime@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN8@SetCursorF

; 676  :          {
; 677  :             zCHAR sz[ 256 ];
; 678  : 
; 679  :             // "KZOEE263 - Input Qualifier cannot be converted to
; 680  :             //  internal attribute data type"
; 681  :             zstrcpy( sz, "(S->DT), " );

	push	OFFSET $SG13615
	lea	eax, DWORD PTR _sz$3[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 682  :             zstrcat( sz, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _sz$3[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 683  :             fnIssueCoreError( lpCurrentTask, lpView, 8, 263, 0, sz, lpViewAttrib->szName );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _sz$3[ebp]
	push	ecx
	push	0
	push	263					; 00000107H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 684  : 
; 685  :             fnOperationReturn( iSetCursorFirstEntityByString, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	170					; 000000aaH
	call	_fnOperationReturn
	add	esp, 8

; 686  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetCursorF
$LN8@SetCursorF:

; 687  :          }
; 688  : 
; 689  :          // Change StringValue to point to internal datetime struct.
; 690  :          cpcStringValue = (zPCHAR) &stInternalDateTime;

	lea	edx, DWORD PTR _stInternalDateTime$[ebp]
	mov	DWORD PTR _cpcStringValue$[ebp], edx

; 691  :       }

	jmp	SHORT $LN7@SetCursorF
$LN6@SetCursorF:

; 692  :       else
; 693  :          lControl |= zQUAL_STRING;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax
$LN7@SetCursorF:

; 694  :    }

	jmp	SHORT $LN5@SetCursorF
$LN4@SetCursorF:

; 695  :    else
; 696  :       lControl |= zQUAL_ATTR_NULL;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 32768				; 00008000H
	mov	DWORD PTR _lControl$[ebp], ecx
$LN5@SetCursorF:

; 697  : 
; 698  :    lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 699  :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _cpcStringValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4194304				; 00400000H
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 700  :                             lpViewAttrib, lControl | zIGNORE_ERROR_358,
; 701  :                             (zPVOID) cpcStringValue,
; 702  :                             0, 0, 0, lpScopingViewEntityCsr,
; 703  :                             0, lpCurrentTask );
; 704  :    if ( nRC < zCURSOR_SET && lpDomain &&

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	$LN9@SetCursorF
	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	$LN9@SetCursorF
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+65]
	cmp	edx, 84					; 00000054H
	jne	$LN9@SetCursorF

; 705  :         lpDomain->cDomainType == zDM_TYPE_TABLE )
; 706  :    {
; 707  :       zSHORT nRC2;
; 708  : 
; 709  :       nRC2 = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpDefaultContext$[ebp]
	push	ecx
	call	_GetDefaultContext@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@SetCursorF
	mov	eax, DWORD PTR _lpDefaultContext$[ebp]
	add	eax, 6
	mov	DWORD PTR tv176[ebp], eax
	jmp	SHORT $LN13@SetCursorF
$LN12@SetCursorF:
	mov	DWORD PTR tv176[ebp], 0
$LN13@SetCursorF:
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv176[ebp]
	push	edx
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _cpcStringValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 65536				; 00010000H
	or	edx, 4194304				; 00400000H
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC2$2[ebp], ax

; 710  :                                 lpViewAttrib,
; 711  :                                 lControl | zTEST_CSR_RESULT | zIGNORE_ERROR_358,
; 712  :                                 (zPVOID) cpcStringValue,
; 713  :                                 0, 0, 0, lpScopingViewEntityCsr,
; 714  :                                 (GetDefaultContext( &lpDefaultContext, lpDomain )
; 715  :                                   ? lpDefaultContext->szName : 0),
; 716  :                                 lpCurrentTask );
; 717  :       if ( nRC2 >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nRC2$2[ebp]
	test	ecx, ecx
	jl	$LN9@SetCursorF

; 718  :       {
; 719  :          zCHAR    sz[ 512 ];
; 720  :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 721  : 
; 722  :          zstrcpy( sz, "Failure during standard call, but would have been "

	push	OFFSET $SG13618
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 723  :                       "successful if the default context was used.\n"
; 724  :                       "Probable User Error." );
; 725  :          zstrcat( sz, "\nObject Def: " );

	push	OFFSET $SG13619
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 726  :          zstrcat( sz, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 727  :          zstrcat( sz, "\nEntity: " );

	push	OFFSET $SG13620
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 728  :          zstrcat( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 729  :          zstrcat( sz, "\nAttribute: " );

	push	OFFSET $SG13621
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 730  :          zstrcat( sz, lpViewAttrib->szName );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _sz$4[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 731  :          SysMessageBox( lpView, "SetCursorFirstEntityByString", sz, 1 );

	push	1
	lea	edx, DWORD PTR _sz$4[ebp]
	push	edx
	push	OFFSET $SG13622
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16
$LN9@SetCursorF:

; 732  :       }
; 733  :    }
; 734  : 
; 735  :    fnOperationReturn( iSetCursorFirstEntityByString, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	170					; 000000aaH
	call	_fnOperationReturn
	add	esp, 8

; 736  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorF:

; 737  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SetCursorFirstEntityByString@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nPos$ = 16						; size = 2
_SetCursorScopeOI@12 PROC

; 207  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 208  :    zSHORT nRC = SetEntityCursor( lpView, cpcEntityName, 0,

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	movsx	eax, WORD PTR _nPos$[ebp]
	or	eax, 524288				; 00080000H
	push	eax
	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetEntityCursor@40
	mov	WORD PTR _nRC$[ebp], ax

; 209  :                                  nPos | zQUAL_SCOPE_OI,
; 210  :                                  0, 0, 0, 0, 0, 0 );
; 211  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 212  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorScopeOI@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_SetCursorLastEntity@12 PROC

; 283  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 284  :    LPTASK            lpCurrentTask;
; 285  :    LPVIEWENTITY      lpViewEntity;
; 286  :    LPVIEWENTITY      lpScopingViewEntity;
; 287  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 288  :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 289  :    zSHORT            nRC;
; 290  : 
; 291  :    // Validate parameters
; 292  :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 293  :                                            &lpViewEntity,
; 294  :                                            &lpScopingViewEntity,
; 295  :                                            &lpViewEntityCsr,
; 296  :                                            &lpScopingViewEntityCsr,
; 297  :                                            iSetCursorLastEntity,
; 298  :                                            lpView,
; 299  :                                            cpcEntityName,
; 300  :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	153					; 00000099H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorL

; 301  :    {
; 302  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetCursorL
$LN2@SetCursorL:

; 303  :    }
; 304  : 
; 305  :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	2
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 306  :                             0, (zLONG) zPOS_LAST,
; 307  :                             0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 308  :                             lpCurrentTask );
; 309  : 
; 310  :    fnOperationReturn( iSetCursorLastEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	153					; 00000099H
	call	_fnOperationReturn
	add	esp, 8

; 311  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorL:

; 312  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorLastEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_SetCursorFirstEntity@12 PROC

; 233  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 234  :    LPTASK            lpCurrentTask;
; 235  :    LPVIEWENTITY      lpViewEntity;
; 236  :    LPVIEWENTITY      lpScopingViewEntity;
; 237  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 238  :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 239  :    zSHORT            nRC;
; 240  : 
; 241  :    // Validate parameters
; 242  :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 243  :                                            &lpViewEntity,
; 244  :                                            &lpScopingViewEntity,
; 245  :                                            &lpViewEntityCsr,
; 246  :                                            &lpScopingViewEntityCsr,
; 247  :                                            iSetCursorFirstEntity,
; 248  :                                            lpView,
; 249  :                                            cpcEntityName,
; 250  :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	152					; 00000098H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorF

; 251  :    {
; 252  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetCursorF
$LN2@SetCursorF:

; 253  :    }
; 254  : 
; 255  :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 256  :                             0, (zLONG) zPOS_FIRST,
; 257  :                             0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 258  :                             lpCurrentTask );
; 259  : 
; 260  :    fnOperationReturn( iSetCursorFirstEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	152					; 00000098H
	call	_fnOperationReturn
	add	esp, 8

; 261  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorF:

; 262  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorFirstEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_SetCursorPrevEntity@12 PROC

; 157  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 158  :    LPTASK            lpCurrentTask;
; 159  :    LPVIEWENTITY      lpViewEntity;
; 160  :    LPVIEWENTITY      lpScopingViewEntity;
; 161  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 162  :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 163  :    zSHORT            nRC;
; 164  : 
; 165  :    // Validate parameters
; 166  :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 167  :                                            &lpViewEntity,
; 168  :                                            &lpScopingViewEntity,
; 169  :                                            &lpViewEntityCsr,
; 170  :                                            &lpScopingViewEntityCsr,
; 171  :                                            iSetCursorPrevEntity,
; 172  :                                            lpView,
; 173  :                                            cpcEntityName,
; 174  :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	151					; 00000097H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorP

; 175  :    {
; 176  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetCursorP
$LN2@SetCursorP:

; 177  :    }
; 178  : 
; 179  :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	4
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 180  :                             0, (zLONG) zPOS_PREV,
; 181  :                             0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 182  :                             lpCurrentTask );
; 183  : 
; 184  :    fnOperationReturn( iSetCursorPrevEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	151					; 00000097H
	call	_fnOperationReturn
	add	esp, 8

; 185  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorP:

; 186  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorPrevEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoecmaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpScopingViewEntityCsr$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_SetCursorNextEntity@12 PROC

; 103  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 104  :    LPTASK            lpCurrentTask;
; 105  :    LPVIEWENTITY      lpViewEntity;
; 106  :    LPVIEWENTITY      lpScopingViewEntity;
; 107  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 108  :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 109  :    zSHORT            nRC;
; 110  : 
; 111  :    // Validate parameters
; 112  :    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 113  :                                            &lpViewEntity,
; 114  :                                            &lpScopingViewEntity,
; 115  :                                            &lpViewEntityCsr,
; 116  :                                            &lpScopingViewEntityCsr,
; 117  :                                            iSetCursorNextEntity,
; 118  :                                            lpView,
; 119  :                                            cpcEntityName,
; 120  :                                            cpcScopingEntityName )) != 0 )

	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	150					; 00000096H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN2@SetCursorN

; 121  :    {
; 122  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SetCursorN
$LN2@SetCursorN:

; 123  :    }
; 124  : 
; 125  :    nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	3
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 126  :                             0, (zLONG) zPOS_NEXT,
; 127  :                             0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 128  :                             lpCurrentTask );
; 129  : 
; 130  :    fnOperationReturn( iSetCursorNextEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	150					; 00000096H
	call	_fnOperationReturn
	add	esp, 8

; 131  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetCursorN:

; 132  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetCursorNextEntity@12 ENDP
_TEXT	ENDS
END
