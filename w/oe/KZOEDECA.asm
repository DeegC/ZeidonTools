; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEDECA.CPP
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?EncryptA@@3PAEA				; EncryptA
PUBLIC	?EncryptB@@3PAEA				; EncryptB
PUBLIC	?EncryptNonAlpha@@3PAEA				; EncryptNonAlpha
_DATA	SEGMENT
?EncryptA@@3PAEA DB 016H				; EncryptA
	DB	01fH
	DB	05H
	DB	0dH
	DB	01aH
	DB	010H
	DB	0fH
	DB	01cH
	DB	00H
	DB	06H
	DB	017H
	DB	02H
	DB	013H
	DB	0cH
	DB	09H
	DB	0aH
	DB	01eH
	DB	01H
	DB	019H
	DB	04H
	DB	01dH
	DB	011H
	DB	07H
	DB	012H
	DB	01bH
	DB	0bH
	DB	015H
	DB	0eH
	DB	018H
	DB	014H
	DB	03H
	DB	08H
?EncryptB@@3PAEA DB 0aH					; EncryptB
	DB	09H
	DB	011H
	DB	04H
	DB	01fH
	DB	016H
	DB	01H
	DB	06H
	DB	01dH
	DB	014H
	DB	0dH
	DB	0cH
	DB	013H
	DB	05H
	DB	018H
	DB	08H
	DB	01aH
	DB	0fH
	DB	07H
	DB	01eH
	DB	017H
	DB	02H
	DB	0bH
	DB	01cH
	DB	015H
	DB	01bH
	DB	0eH
	DB	00H
	DB	019H
	DB	03H
	DB	010H
	DB	012H
?EncryptNonAlpha@@3PAEA DB 00H				; EncryptNonAlpha
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	022H
	DB	040H
	DB	025H
	DB	034H
	DB	026H
	DB	024H
	DB	027H
	DB	033H
	DB	05bH
	DB	028H
	DB	03aH
	DB	035H
	DB	02bH
	DB	021H
	DB	023H
	DB	03fH
	DB	07cH
	DB	02eH
	DB	02fH
	DB	060H
	DB	036H
	DB	02cH
	DB	037H
	DB	02dH
	DB	039H
	DB	038H
	DB	02aH
	DB	031H
	DB	03bH
	DB	03eH
	DB	03cH
	DB	029H
	DB	020H
	DB	068H
	DB	06bH
	DB	06eH
	DB	062H
	DB	072H
	DB	074H
	DB	076H
	DB	065H
	DB	079H
	DB	067H
	DB	069H
	DB	06cH
	DB	061H
	DB	070H
	DB	073H
	DB	064H
	DB	077H
	DB	078H
	DB	066H
	DB	07aH
	DB	06aH
	DB	06dH
	DB	06fH
	DB	071H
	DB	063H
	DB	075H
	DB	07dH
	DB	03dH
	DB	032H
	DB	07bH
	DB	05cH
	DB	05dH
	DB	04bH
	DB	045H
	DB	04fH
	DB	051H
	DB	043H
	DB	055H
	DB	047H
	DB	058H
	DB	049H
	DB	05aH
	DB	04cH
	DB	04dH
	DB	042H
	DB	052H
	DB	054H
	DB	046H
	DB	057H
	DB	048H
	DB	059H
	DB	04aH
	DB	041H
	DB	04eH
	DB	050H
	DB	044H
	DB	053H
	DB	056H
	DB	05eH
	DB	05fH
	DB	07eH
	DB	030H
_DATA	ENDS
CONST	SEGMENT
$SG15684 DB	'Don2Cam9Pas1Gig3Dks5Dgc8Kat2Mik3Jab1Mat2', 00H
	ORG $+3
$SG15711 DB	'C', 0c8H, '!', 0d3H, 0f4H, 0b3H, 010H, '''', 09H, 0aaH, 018H
	DB	'V', 00H
	ORG $+3
$SG15808 DB	'Length Error Encrypting String', 00H
	ORG $+1
$SG15809 DB	'Zeidon Internal Error', 00H
	ORG $+2
$SG15817 DB	'Null Error Encrypting String', 00H
	ORG $+3
$SG15818 DB	'Zeidon Internal Error', 00H
	ORG $+2
$SG15841 DB	'Length Error Encrypting String', 00H
	ORG $+1
$SG15842 DB	'Zeidon Internal Error', 00H
	ORG $+2
$SG15890 DB	'Length Error Decrypting String: (%d:%d)  "%s"', 00H
	ORG $+2
$SG15891 DB	'Zeidon Internal Error', 00H
	ORG $+2
$SG15914 DB	'Length Error Encrypting String', 00H
	ORG $+1
$SG15915 DB	'Zeidon Internal Error', 00H
	ORG $+2
$SG15947 DB	'zDecimalOperation', 00H
	ORG $+2
$SG15948 DB	'(ZDecimal) Error calling INIT function in ', 00H
CONST	ENDS
PUBLIC	_UfEncryptStringLong@16
PUBLIC	_UfDecryptStringLong@16
PUBLIC	_UfEncryptStringUL@16
PUBLIC	_UfDecryptStringUL@16
PUBLIC	_SysAddDecimalToDecimal@12
PUBLIC	_SysAssignDecimalFromDecimal@8
PUBLIC	_SysAssignDecimalFromNull@4
PUBLIC	_SysCallDecimalOperation@16
PUBLIC	_SysCompareDecimalToDecimal@8
PUBLIC	_SysCompareDecimalToDouble@12
PUBLIC	_SysConvertDecimalToLong@8
PUBLIC	_SysCompareDecimalToNull@4
PUBLIC	_SysConvertDecimalToDouble@8
PUBLIC	_SysConvertDecimalToString@12
PUBLIC	_SysConvertDoubleToDecimal@12
PUBLIC	_SysConvertLongToDecimal@8
PUBLIC	_SysConvertStringToDecimal@8
PUBLIC	_SysDivideDecimalByDecimal@12
PUBLIC	_SysMultiplyDecimalByDecimal@12
PUBLIC	_SysRoundDecimal@8
PUBLIC	_SysSubtractDecimalFromDecimal@12
PUBLIC	??0ZDecimal@@QAE@XZ				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@UDecimalStruct@@@Z		; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@PAUDecimalStruct@@@Z		; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@PAD@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@J@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@K@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@F@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@G@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@N@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@H@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@I@Z				; ZDecimal::ZDecimal
PUBLIC	??0ZDecimal@@QAE@PBD@Z				; ZDecimal::ZDecimal
PUBLIC	??1ZDecimal@@QAE@XZ				; ZDecimal::~ZDecimal
PUBLIC	??4ZDecimal@@QAE?AV0@V0@@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@J@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@K@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@F@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@G@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@N@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QBE?AV0@N@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@PAD@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@PBD@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@PAX@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@UDecimalStruct@@@Z		; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@PAUDecimalStruct@@@Z	; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@H@Z			; ZDecimal::operator=
PUBLIC	??4ZDecimal@@QAE?AV0@I@Z			; ZDecimal::operator=
PUBLIC	??BZDecimal@@QAENXZ				; ZDecimal::operator double
PUBLIC	??BZDecimal@@QAEJXZ				; ZDecimal::operator long
PUBLIC	??BZDecimal@@QAEKXZ				; ZDecimal::operator unsigned long
PUBLIC	??BZDecimal@@QAEFXZ				; ZDecimal::operator short
PUBLIC	??BZDecimal@@QAEGXZ				; ZDecimal::operator unsigned short
PUBLIC	??BZDecimal@@QAEPADXZ				; ZDecimal::operator char *
PUBLIC	?IsNull@ZDecimal@@QAEEXZ			; ZDecimal::IsNull
PUBLIC	??N@YGDVZDecimal@@0@Z				; operator<=
PUBLIC	??M@YGDVZDecimal@@0@Z				; operator<
PUBLIC	??P@YGDVZDecimal@@0@Z				; operator>=
PUBLIC	??O@YGDVZDecimal@@0@Z				; operator>
PUBLIC	??8@YGDVZDecimal@@0@Z				; operator==
PUBLIC	??9@YGDVZDecimal@@0@Z				; operator!=
PUBLIC	??7@YGDVZDecimal@@@Z				; operator!
PUBLIC	??H@YG?AVZDecimal@@V0@0@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@J@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@JV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@K@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@KV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@F@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@FV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@G@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@GV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@H@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@HV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@I@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@IV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@D@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@DV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@E@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@EV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@N@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@NV0@@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@V0@M@Z			; operator+
PUBLIC	??H@YG?AVZDecimal@@MV0@@Z			; operator+
PUBLIC	??G@YG?AVZDecimal@@V0@0@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@J@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@JV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@K@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@KV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@F@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@FV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@G@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@GV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@H@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@HV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@I@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@IV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@D@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@DV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@E@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@EV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@N@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@NV0@@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@V0@M@Z			; operator-
PUBLIC	??G@YG?AVZDecimal@@MV0@@Z			; operator-
PUBLIC	??D@YG?AVZDecimal@@V0@0@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@J@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@JV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@K@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@KV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@F@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@FV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@G@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@GV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@H@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@HV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@I@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@IV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@D@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@DV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@E@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@EV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@N@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@NV0@@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@V0@M@Z			; operator*
PUBLIC	??D@YG?AVZDecimal@@MV0@@Z			; operator*
PUBLIC	??K@YG?AVZDecimal@@V0@0@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@J@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@JV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@K@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@KV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@F@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@FV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@G@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@GV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@H@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@HV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@I@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@IV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@D@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@DV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@E@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@EV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@N@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@NV0@@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@V0@M@Z			; operator/
PUBLIC	??K@YG?AVZDecimal@@MV0@@Z			; operator/
PUBLIC	??P@YGDJVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@J@Z				; operator>=
PUBLIC	??P@YGDKVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@K@Z				; operator>=
PUBLIC	??P@YGDFVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@F@Z				; operator>=
PUBLIC	??P@YGDGVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@G@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@H@Z				; operator>=
PUBLIC	??P@YGDHVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@I@Z				; operator>=
PUBLIC	??P@YGDIVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@D@Z				; operator>=
PUBLIC	??P@YGDDVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDEVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@E@Z				; operator>=
PUBLIC	??P@YGDNVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@N@Z				; operator>=
PUBLIC	??P@YGDMVZDecimal@@@Z				; operator>=
PUBLIC	??P@YGDVZDecimal@@M@Z				; operator>=
PUBLIC	??O@YGDJVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@J@Z				; operator>
PUBLIC	??O@YGDKVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@K@Z				; operator>
PUBLIC	??O@YGDFVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@F@Z				; operator>
PUBLIC	??O@YGDGVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@G@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@H@Z				; operator>
PUBLIC	??O@YGDHVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@I@Z				; operator>
PUBLIC	??O@YGDIVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@D@Z				; operator>
PUBLIC	??O@YGDDVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDEVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@E@Z				; operator>
PUBLIC	??O@YGDNVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@N@Z				; operator>
PUBLIC	??O@YGDMVZDecimal@@@Z				; operator>
PUBLIC	??O@YGDVZDecimal@@M@Z				; operator>
PUBLIC	??N@YGDJVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@J@Z				; operator<=
PUBLIC	??N@YGDKVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@K@Z				; operator<=
PUBLIC	??N@YGDFVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@F@Z				; operator<=
PUBLIC	??N@YGDGVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@G@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@H@Z				; operator<=
PUBLIC	??N@YGDHVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@I@Z				; operator<=
PUBLIC	??N@YGDIVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@D@Z				; operator<=
PUBLIC	??N@YGDDVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDEVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@E@Z				; operator<=
PUBLIC	??N@YGDNVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@N@Z				; operator<=
PUBLIC	??N@YGDMVZDecimal@@@Z				; operator<=
PUBLIC	??N@YGDVZDecimal@@M@Z				; operator<=
PUBLIC	??M@YGDJVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@J@Z				; operator<
PUBLIC	??M@YGDKVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@K@Z				; operator<
PUBLIC	??M@YGDFVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@F@Z				; operator<
PUBLIC	??M@YGDGVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@G@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@H@Z				; operator<
PUBLIC	??M@YGDHVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@I@Z				; operator<
PUBLIC	??M@YGDIVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@D@Z				; operator<
PUBLIC	??M@YGDDVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDEVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@E@Z				; operator<
PUBLIC	??M@YGDNVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@N@Z				; operator<
PUBLIC	??M@YGDMVZDecimal@@@Z				; operator<
PUBLIC	??M@YGDVZDecimal@@M@Z				; operator<
PUBLIC	??8@YGDJVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@J@Z				; operator==
PUBLIC	??8@YGDKVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@K@Z				; operator==
PUBLIC	??8@YGDFVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@F@Z				; operator==
PUBLIC	??8@YGDGVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@G@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@H@Z				; operator==
PUBLIC	??8@YGDHVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@I@Z				; operator==
PUBLIC	??8@YGDIVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@D@Z				; operator==
PUBLIC	??8@YGDDVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDEVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@E@Z				; operator==
PUBLIC	??8@YGDNVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@N@Z				; operator==
PUBLIC	??8@YGDMVZDecimal@@@Z				; operator==
PUBLIC	??8@YGDVZDecimal@@M@Z				; operator==
PUBLIC	??9@YGDJVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@J@Z				; operator!=
PUBLIC	??9@YGDKVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@K@Z				; operator!=
PUBLIC	??9@YGDFVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@F@Z				; operator!=
PUBLIC	??9@YGDGVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@G@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@H@Z				; operator!=
PUBLIC	??9@YGDHVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@I@Z				; operator!=
PUBLIC	??9@YGDIVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@D@Z				; operator!=
PUBLIC	??9@YGDDVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDEVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@E@Z				; operator!=
PUBLIC	??9@YGDNVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@N@Z				; operator!=
PUBLIC	??9@YGDMVZDecimal@@@Z				; operator!=
PUBLIC	??9@YGDVZDecimal@@M@Z				; operator!=
PUBLIC	??Y@YG?AVZDecimal@@AAV0@V0@@Z			; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@J@Z			; operator+=
PUBLIC	??Y@YGJAAJVZDecimal@@@Z				; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@K@Z			; operator+=
PUBLIC	??Y@YGKKVZDecimal@@@Z				; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@F@Z			; operator+=
PUBLIC	??Y@YGFFVZDecimal@@@Z				; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@G@Z			; operator+=
PUBLIC	??Y@YGGGVZDecimal@@@Z				; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@H@Z			; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@I@Z			; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@D@Z			; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@E@Z			; operator+=
PUBLIC	??Y@YG?AVZDecimal@@V0@N@Z			; operator+=
PUBLIC	??Z@YG?AVZDecimal@@AAV0@V0@@Z			; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@J@Z			; operator-=
PUBLIC	??Z@YGJAAJVZDecimal@@@Z				; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@K@Z			; operator-=
PUBLIC	??Z@YGKKVZDecimal@@@Z				; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@F@Z			; operator-=
PUBLIC	??Z@YGFFVZDecimal@@@Z				; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@G@Z			; operator-=
PUBLIC	??Z@YGGGVZDecimal@@@Z				; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@H@Z			; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@I@Z			; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@D@Z			; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@E@Z			; operator-=
PUBLIC	??Z@YG?AVZDecimal@@V0@N@Z			; operator-=
PUBLIC	??X@YG?AVZDecimal@@AAV0@V0@@Z			; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@J@Z			; operator*=
PUBLIC	??X@YGJAAJVZDecimal@@@Z				; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@K@Z			; operator*=
PUBLIC	??X@YGKKVZDecimal@@@Z				; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@F@Z			; operator*=
PUBLIC	??X@YGFFVZDecimal@@@Z				; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@G@Z			; operator*=
PUBLIC	??X@YGGGVZDecimal@@@Z				; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@H@Z			; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@I@Z			; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@D@Z			; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@E@Z			; operator*=
PUBLIC	??X@YG?AVZDecimal@@V0@N@Z			; operator*=
PUBLIC	??_0@YG?AVZDecimal@@AAV0@V0@@Z			; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@J@Z			; operator/=
PUBLIC	??_0@YGJAAJVZDecimal@@@Z			; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@K@Z			; operator/=
PUBLIC	??_0@YGKKVZDecimal@@@Z				; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@F@Z			; operator/=
PUBLIC	??_0@YGFFVZDecimal@@@Z				; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@G@Z			; operator/=
PUBLIC	??_0@YGGGVZDecimal@@@Z				; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@H@Z			; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@I@Z			; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@D@Z			; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@E@Z			; operator/=
PUBLIC	??_0@YG?AVZDecimal@@V0@N@Z			; operator/=
PUBLIC	?CommitMultipleOIs@@YGFJFPAFJ@Z			; CommitMultipleOIs
PUBLIC	??0ARACrypt@@QAE@XZ				; ARACrypt::ARACrypt
PUBLIC	?TransformString@ARACrypt@@UAEXPADPBD@Z		; ARACrypt::TransformString
PUBLIC	?SetKey@ARACrypt@@UAEXPBD@Z			; ARACrypt::SetKey
PUBLIC	?GetKey@ARACrypt@@UAEXPAD@Z			; ARACrypt::GetKey
PUBLIC	?TransformChar@ARACrypt@@UAEXAAE@Z		; ARACrypt::TransformChar
PUBLIC	??1ARACrypt@@UAE@XZ				; ARACrypt::~ARACrypt
PUBLIC	??_GARACrypt@@UAEPAXI@Z				; ARACrypt::`scalar deleting destructor'
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?fnEncryptStringUL@@YAFPAD00GE@Z		; fnEncryptStringUL
PUBLIC	?fnDecryptStringUL@@YGFPAD00GE@Z		; fnDecryptStringUL
PUBLIC	_fnCallDecOper@16
PUBLIC	??_7ARACrypt@@6B@				; ARACrypt::`vftable'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_R4ARACrypt@@6B@				; ARACrypt::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVARACrypt@@@8				; ARACrypt `RTTI Type Descriptor'
PUBLIC	??_R3ARACrypt@@8				; ARACrypt::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ARACrypt@@8				; ARACrypt::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ARACrypt@@8			; ARACrypt::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__rand:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_CommitMultipleOIs@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	??_EARACrypt@@UAEPAXI@Z:PROC			; ARACrypt::`vector deleting destructor'
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_DecimalOperation@16:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@ARACrypt@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ARACrypt@@8 DD FLAT:??_R0?AVARACrypt@@@8	; ARACrypt::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ARACrypt@@8
rdata$r	ENDS
;	COMDAT ??_R2ARACrypt@@8
rdata$r	SEGMENT
??_R2ARACrypt@@8 DD FLAT:??_R1A@?0A@EA@ARACrypt@@8	; ARACrypt::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ARACrypt@@8
rdata$r	SEGMENT
??_R3ARACrypt@@8 DD 00H					; ARACrypt::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ARACrypt@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVARACrypt@@@8
data$r	SEGMENT
??_R0?AVARACrypt@@@8 DD FLAT:??_7type_info@@6B@		; ARACrypt `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVARACrypt@@', 00H
data$r	ENDS
;	COMDAT ??_R4ARACrypt@@6B@
rdata$r	SEGMENT
??_R4ARACrypt@@6B@ DD 00H				; ARACrypt::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVARACrypt@@@8
	DD	FLAT:??_R3ARACrypt@@8
rdata$r	ENDS
;	COMDAT ??_7ARACrypt@@6B@
CONST	SEGMENT
??_7ARACrypt@@6B@ DD FLAT:??_R4ARACrypt@@6B@		; ARACrypt::`vftable'
	DD	FLAT:?TransformString@ARACrypt@@UAEXPADPBD@Z
	DD	FLAT:?SetKey@ARACrypt@@UAEXPBD@Z
	DD	FLAT:?GetKey@ARACrypt@@UAEXPAD@Z
	DD	FLAT:?TransformChar@ARACrypt@@UAEXAAE@Z
	DD	FLAT:??_EARACrypt@@UAEPAXI@Z
CONST	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pfn$ = -8						; size = 4
_nRC$ = -4						; size = 2
_pvReturn$ = 8						; size = 4
_pvDecimal$ = 12					; size = 4
_pvInfo$ = 16						; size = 4
_lControl$ = 20						; size = 4
_fnCallDecOper@16 PROC

; 3347 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3348 :    zSHORT    nRC;
; 3349 :    zDECOPER  pfn;
; 3350 : 
; 3351 : #if 1
; 3352 : 
; 3353 : // pfn = fnDecimalOperation;   // in kzoesyaa.c
; 3354 :    pfn = DecimalOperation;     // in zdecimal.c

	mov	DWORD PTR _pfn$[ebp], OFFSET _DecimalOperation@16

; 3355 : 
; 3356 :    // Call function to initialize.
; 3357 :    nRC = (*pfn) ( 0, 0, 0, zDEC_CMD_INIT );

	push	6
	push	0
	push	0
	push	0
	call	DWORD PTR _pfn$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3358 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN2@fnCallDecO

; 3359 :    {
; 3360 :       TraceLineS( "(ZDecimal) Error calling INIT function in ",

	push	OFFSET $SG15947
	push	OFFSET $SG15948
	call	_TraceLineS@8
$LN2@fnCallDecO:

; 3361 :                   "zDecimalOperation" );
; 3362 :    }
; 3363 : 
; 3364 : #else
; 3365 : 
; 3366 :    LPLIBRARY lpLibrary;
; 3367 : 
; 3368 :    if ( lpTask && lpTask->pfnDecOper )
; 3369 :       pfn = (zDECOPER) lpTask->pfnDecOper;
; 3370 :    else
; 3371 :    {
; 3372 :       char szValue[ zMAX_FILENAME_LTH + 1 ];
; 3373 : 
; 3374 :       lpLibrary = fnSysLoadLibraryWithErrFlag( lpTask, "zdecimal", 0 );
; 3375 :       if ( lpLibrary != 0 )
; 3376 :       {
; 3377 :          pfn = (zDECOPER) SysGetProc( lpLibrary, "zDecimalOperation" );
; 3378 :          if ( pfn == 0 )
; 3379 :          {
; 3380 :             fnSysFreeLibrary( lpTask, lpLibrary );
; 3381 :             lpLibrary = 0;
; 3382 :          }
; 3383 :       }
; 3384 : 
; 3385 :       // If lpLibrary is 0 then we couldn't find zDecimalOperation in the
; 3386 :       // decimal DLL so we'll use the default one.
; 3387 :       if ( lpLibrary == 0 )
; 3388 :          pfn = fnDecimalOperation;   // in kzoesyaa.c
; 3389 : 
; 3390 :       // Call function to initialize.
; 3391 :       nRC = (*pfn)( 0, 0, 0, zDEC_CMD_INIT );
; 3392 :       if ( nRC == zCALL_ERROR )
; 3393 :       {
; 3394 :          fnSysFreeLibrary( lpTask, lpLibrary );
; 3395 :          lpLibrary = 0;
; 3396 : 
; 3397 :          TraceLineS( "(ZDecimal) Error calling INIT function in ",
; 3398 :                      "zDecimalOperation" );
; 3399 :          pfn = fnDecimalOperation;   // in kzoesyaa.c
; 3400 :       }
; 3401 : 
; 3402 :       // It's a little late to pop up the message but this allows the INIT
; 3403 :       // command to take place so we can write any pertinent info to trace.
; 3404 :       if ( lpLibrary == 0 )
; 3405 :       {
; 3406 :          SysReadZeidonIni( -1, "[Zeidon]", "DefaultDecimalOK", szValue );
; 3407 :          zstrupper( szValue );
; 3408 : 
; 3409 :          if ( szValue[ 0 ] != 'Y' &&
; 3410 :               szValue[ 0 ] != '1' && szValue[ 0 ] != 'T' )
; 3411 :          {
; 3412 :             fnSysMessageBox( lpTask, szlOE_SystemError,
; 3413 :                              "Couldn't find zDecimalOperation().\n"
; 3414 :                              "Using default of 'double'.", 1 );
; 3415 :          }
; 3416 :       }
; 3417 : 
; 3418 :       if ( lpTask )
; 3419 :       {
; 3420 :          lpTask->lpDecLibrary = lpLibrary;
; 3421 :          lpTask->pfnDecOper   = (zPOPER) pfn;
; 3422 :       }
; 3423 :    }
; 3424 : 
; 3425 : #endif
; 3426 : 
; 3427 :    return( (*pfn)( pvReturn, pvDecimal, pvInfo, lControl ) );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvDecimal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	push	ecx
	call	DWORD PTR _pfn$[ebp]

; 3428 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnCallDecOper@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -552						; size = 4
$T2 = -548						; size = 4
$T3 = -544						; size = 2
$T4 = -542						; size = 2
$T5 = -540						; size = 2
_uCrypt$ = -537						; size = 1
_uChar$ = -536						; size = 2
_nKeyLth$6 = -532					; size = 2
_nReturnLth$ = -528					; size = 2
_nOrderIdx$ = -524					; size = 2
_nInLth$ = -520						; size = 2
_crypt$ = -516						; size = 117
_szMsg$ = -396						; size = 256
_szKey$7 = -140						; size = 65
_szNewKey$8 = -72					; size = 65
__$ArrayPad$ = -4					; size = 4
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_pchKey$ = 16						; size = 4
_uLth$ = 20						; size = 2
_bEncodeLth$ = 24					; size = 1
?fnDecryptStringUL@@YGFPAD00GE@Z PROC			; fnDecryptStringUL

; 3157 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3158 :    ARACrypt crypt;

	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??0ARACrypt@@QAE@XZ			; ARACrypt::ARACrypt

; 3159 :    zUCHAR   uCrypt;
; 3160 :    zUSHORT  uChar;
; 3161 :    zSHORT   nOrderIdx;
; 3162 :    zSHORT   nInLth;
; 3163 :    zSHORT   nReturnLth;
; 3164 :    char     szMsg[ 256 ];
; 3165 : 
; 3166 : // zsprintf( szMsg, "UfDecryptStringUL Length: %d   In: \"%s\"", uLth, pchIn );
; 3167 : // TraceLineS( szMsg, "" );
; 3168 : 
; 3169 :    if ( *pchIn == 0 )

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN10@fnDecryptS

; 3170 :    {
; 3171 :       *pchOut = 0;

	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], 0

; 3172 :       return( 0 );

	xor	eax, eax
	mov	WORD PTR $T5[ebp], ax
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??1ARACrypt@@UAE@XZ			; ARACrypt::~ARACrypt
	mov	ax, WORD PTR $T5[ebp]
	jmp	$LN20@fnDecryptS
$LN10@fnDecryptS:

; 3173 :    }
; 3174 : 
; 3175 :    // Set up the encryption key.
; 3176 :    if ( pchKey && *pchKey )

	cmp	DWORD PTR _pchKey$[ebp], 0
	je	$LN11@fnDecryptS
	mov	ecx, DWORD PTR _pchKey$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN11@fnDecryptS

; 3177 :    {
; 3178 :       char   szKey[ 65 ];
; 3179 :       char   szNewKey[ 65 ];
; 3180 :       zSHORT nKeyLth;
; 3181 : 
; 3182 :       zstrncpy( szNewKey, pchKey, sizeof( szNewKey ) - 1 );

	push	64					; 00000040H
	mov	eax, DWORD PTR _pchKey$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szNewKey$8[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 3183 :       szNewKey[ sizeof( szNewKey ) - 1 ] = 0;  // force null terminator

	mov	edx, 1
	shl	edx, 6
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 65			; 00000041H
	jae	SHORT $LN21@fnDecryptS
	jmp	SHORT $LN22@fnDecryptS
$LN21@fnDecryptS:
	call	___report_rangecheckfailure
$LN22@fnDecryptS:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szNewKey$8[ebp+eax], 0

; 3184 :       nInLth = zstrlen( szNewKey );

	lea	ecx, DWORD PTR _szNewKey$8[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nInLth$[ebp], ax

; 3185 : 
; 3186 :       crypt.GetKey( szKey );

	lea	edx, DWORD PTR _szKey$7[ebp]
	push	edx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	?GetKey@ARACrypt@@UAEXPAD@Z		; ARACrypt::GetKey

; 3187 :       nKeyLth = zstrlen( szKey );

	lea	eax, DWORD PTR _szKey$7[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nKeyLth$6[ebp], ax

; 3188 :       if ( nKeyLth + nInLth > sizeof( szKey ) - 1 )

	movsx	ecx, WORD PTR _nKeyLth$6[ebp]
	movsx	edx, WORD PTR _nInLth$[ebp]
	add	ecx, edx
	cmp	ecx, 64					; 00000040H
	jbe	SHORT $LN12@fnDecryptS

; 3189 :          nKeyLth = sizeof( szKey ) - 1 - nInLth;

	movsx	eax, WORD PTR _nInLth$[ebp]
	mov	ecx, 64					; 00000040H
	sub	ecx, eax
	mov	WORD PTR _nKeyLth$6[ebp], cx
$LN12@fnDecryptS:

; 3190 : 
; 3191 :       if ( nKeyLth > 0 )

	movsx	edx, WORD PTR _nKeyLth$6[ebp]
	test	edx, edx
	jle	SHORT $LN11@fnDecryptS

; 3192 :       {
; 3193 :          zstrncpy( szNewKey + nInLth, pchKey, nKeyLth );

	movsx	eax, WORD PTR _nKeyLth$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchKey$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nInLth$[ebp]
	lea	eax, DWORD PTR _szNewKey$8[ebp+edx]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 3194 :          szNewKey[ sizeof( szKey ) - 1 ] = 0;  // force null terminator

	mov	ecx, 1
	shl	ecx, 6
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 65			; 00000041H
	jae	SHORT $LN23@fnDecryptS
	jmp	SHORT $LN24@fnDecryptS
$LN23@fnDecryptS:
	call	___report_rangecheckfailure
$LN24@fnDecryptS:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szNewKey$8[ebp+edx], 0

; 3195 :          crypt.SetKey( szNewKey );

	lea	eax, DWORD PTR _szNewKey$8[ebp]
	push	eax
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	?SetKey@ARACrypt@@UAEXPBD@Z		; ARACrypt::SetKey
$LN11@fnDecryptS:

; 3196 :       }
; 3197 :    }
; 3198 : 
; 3199 :    uChar = 0;

	xor	ecx, ecx
	mov	WORD PTR _uChar$[ebp], cx

; 3200 :    nOrderIdx = 0;

	xor	edx, edx
	mov	WORD PTR _nOrderIdx$[ebp], dx

; 3201 :    if ( bEncodeLth )

	movzx	eax, BYTE PTR _bEncodeLth$[ebp]
	test	eax, eax
	je	$LN14@fnDecryptS
$LN2@fnDecryptS:

; 3202 :    {
; 3203 :       while ( EncryptB[ nOrderIdx ] > (uLth - 1) )

	movsx	ecx, WORD PTR _nOrderIdx$[ebp]
	movzx	edx, BYTE PTR ?EncryptB@@3PAEA[ecx]
	movzx	eax, WORD PTR _uLth$[ebp]
	sub	eax, 1
	cmp	edx, eax
	jle	SHORT $LN3@fnDecryptS

; 3204 :          nOrderIdx++;

	mov	cx, WORD PTR _nOrderIdx$[ebp]
	add	cx, 1
	mov	WORD PTR _nOrderIdx$[ebp], cx
	jmp	SHORT $LN2@fnDecryptS
$LN3@fnDecryptS:

; 3205 : 
; 3206 :       nInLth = (zSHORT) (((zUCHAR) pchIn[ EncryptB[ nOrderIdx ] ]) - 'a');

	movsx	edx, WORD PTR _nOrderIdx$[ebp]
	movzx	eax, BYTE PTR ?EncryptB@@3PAEA[edx]
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	sub	edx, 97					; 00000061H
	mov	WORD PTR _nInLth$[ebp], dx

; 3207 :       if ( uLth > zMAXEL ||
; 3208 :            (bEncodeLth && nInLth >= uLth) ||
; 3209 :            (bEncodeLth == FALSE && nInLth > uLth) ||

	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN17@fnDecryptS
	movzx	ecx, BYTE PTR _bEncodeLth$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@fnDecryptS
	movsx	edx, WORD PTR _nInLth$[ebp]
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	edx, eax
	jge	SHORT $LN17@fnDecryptS
$LN18@fnDecryptS:
	movzx	ecx, BYTE PTR _bEncodeLth$[ebp]
	test	ecx, ecx
	jne	SHORT $LN19@fnDecryptS
	movsx	edx, WORD PTR _nInLth$[ebp]
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	edx, eax
	jg	SHORT $LN17@fnDecryptS
$LN19@fnDecryptS:
	movsx	ecx, WORD PTR _nInLth$[ebp]
	test	ecx, ecx
	jge	SHORT $LN16@fnDecryptS
$LN17@fnDecryptS:

; 3210 :            nInLth < 0 )
; 3211 :       {
; 3212 :          zsprintf( szMsg, "Length Error Decrypting String: (%d:%d)  \"%s\"", uLth, nInLth, pchIn );

	mov	edx, DWORD PTR _pchIn$[ebp]
	push	edx
	movsx	eax, WORD PTR _nInLth$[ebp]
	push	eax
	movzx	ecx, WORD PTR _uLth$[ebp]
	push	ecx
	push	OFFSET $SG15890
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3213 :          SysMessageBox( 0, "Zeidon Internal Error", szMsg, 0 );

	push	0
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	OFFSET $SG15891
	push	0
	call	_SysMessageBox@16

; 3214 :          return( zCALL_ERROR );

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR $T4[ebp], cx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??1ARACrypt@@UAE@XZ			; ARACrypt::~ARACrypt
	mov	ax, WORD PTR $T4[ebp]
	jmp	$LN20@fnDecryptS
$LN16@fnDecryptS:

; 3215 :       }
; 3216 : 
; 3217 :       nReturnLth = 0;

	xor	edx, edx
	mov	WORD PTR _nReturnLth$[ebp], dx
$LN4@fnDecryptS:

; 3218 :       while ( EncryptA[ nReturnLth ] != (zUCHAR) nInLth )

	movsx	eax, WORD PTR _nReturnLth$[ebp]
	movzx	ecx, BYTE PTR ?EncryptA@@3PAEA[eax]
	movzx	edx, BYTE PTR _nInLth$[ebp]
	cmp	ecx, edx
	je	SHORT $LN5@fnDecryptS

; 3219 :          nReturnLth++;

	mov	ax, WORD PTR _nReturnLth$[ebp]
	add	ax, 1
	mov	WORD PTR _nReturnLth$[ebp], ax
	jmp	SHORT $LN4@fnDecryptS
$LN5@fnDecryptS:

; 3220 : 
; 3221 :       nInLth = (zCHAR) nReturnLth;

	movsx	cx, BYTE PTR _nReturnLth$[ebp]
	mov	WORD PTR _nInLth$[ebp], cx

; 3222 :       nOrderIdx++;

	mov	dx, WORD PTR _nOrderIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nOrderIdx$[ebp], dx

; 3223 :    }
; 3224 :    else

	jmp	SHORT $LN6@fnDecryptS
$LN14@fnDecryptS:

; 3225 :    {
; 3226 :       nReturnLth = uLth;

	mov	ax, WORD PTR _uLth$[ebp]
	mov	WORD PTR _nReturnLth$[ebp], ax

; 3227 :       nInLth = uLth;

	mov	cx, WORD PTR _uLth$[ebp]
	mov	WORD PTR _nInLth$[ebp], cx
$LN6@fnDecryptS:

; 3228 :    }
; 3229 : 
; 3230 :    while ( nInLth )

	movsx	edx, WORD PTR _nInLth$[ebp]
	test	edx, edx
	je	$LN7@fnDecryptS
$LN8@fnDecryptS:

; 3231 :    {
; 3232 :       while ( EncryptB[ nOrderIdx ] > (uLth - 1) )

	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR ?EncryptB@@3PAEA[eax]
	movzx	edx, WORD PTR _uLth$[ebp]
	sub	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN9@fnDecryptS

; 3233 :          nOrderIdx++;

	mov	ax, WORD PTR _nOrderIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nOrderIdx$[ebp], ax
	jmp	SHORT $LN8@fnDecryptS
$LN9@fnDecryptS:

; 3234 : 
; 3235 :       uCrypt = pchIn[ EncryptB[ nOrderIdx ] ];

	movsx	ecx, WORD PTR _nOrderIdx$[ebp]
	movzx	edx, BYTE PTR ?EncryptB@@3PAEA[ecx]
	mov	eax, DWORD PTR _pchIn$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR _uCrypt$[ebp], cl

; 3236 :       pchOut[ uChar ] = uCrypt;

	movzx	edx, WORD PTR _uChar$[ebp]
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR _uCrypt$[ebp]
	mov	BYTE PTR [eax+edx], cl

; 3237 : 
; 3238 :       nInLth--;

	mov	dx, WORD PTR _nInLth$[ebp]
	sub	dx, 1
	mov	WORD PTR _nInLth$[ebp], dx

; 3239 :       uChar++;

	mov	ax, WORD PTR _uChar$[ebp]
	add	ax, 1
	mov	WORD PTR _uChar$[ebp], ax

; 3240 :       nOrderIdx++;

	mov	cx, WORD PTR _nOrderIdx$[ebp]
	add	cx, 1
	mov	WORD PTR _nOrderIdx$[ebp], cx

; 3241 :    }

	jmp	$LN6@fnDecryptS
$LN7@fnDecryptS:

; 3242 : 
; 3243 :    pchOut[ uLth ] = 0;

	movzx	edx, WORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 3244 :    crypt.TransformString( pchOut );

	push	0
	mov	ecx, DWORD PTR _pchOut$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	?TransformString@ARACrypt@@UAEXPADPBD@Z	; ARACrypt::TransformString

; 3245 :    pchOut[ uChar ] = 0;

	movzx	edx, WORD PTR _uChar$[ebp]
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 3246 : // zsprintf( szMsg, "UfDecryptStringUL Out: \"%s\"", pchOut );
; 3247 : // TraceLineS( szMsg, "" );
; 3248 :    return( nReturnLth );

	mov	cx, WORD PTR _nReturnLth$[ebp]
	mov	WORD PTR $T3[ebp], cx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??1ARACrypt@@UAE@XZ			; ARACrypt::~ARACrypt
	mov	ax, WORD PTR $T3[ebp]
$LN20@fnDecryptS:

; 3249 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?fnDecryptStringUL@@YGFPAD00GE@Z ENDP			; fnDecryptStringUL
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -316						; size = 4
$T2 = -312						; size = 4
$T3 = -308						; size = 4
$T4 = -304						; size = 4
$T5 = -298						; size = 2
$T6 = -296						; size = 2
$T7 = -294						; size = 2
_uTempLth$ = -292					; size = 2
_uCrypt$ = -285						; size = 1
_pch$ = -284						; size = 4
_uChar$ = -280						; size = 2
_nKeyLth$8 = -276					; size = 2
_k$ = -272						; size = 4
_nOrderIdx$ = -268					; size = 2
_nInLth$ = -264						; size = 2
_crypt$ = -260						; size = 117
_szKey$9 = -140						; size = 65
_szNewKey$10 = -72					; size = 65
__$ArrayPad$ = -4					; size = 4
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_pchKey$ = 16						; size = 4
_uLth$ = 20						; size = 2
_bEncodeLth$ = 24					; size = 1
?fnEncryptStringUL@@YAFPAD00GE@Z PROC			; fnEncryptStringUL

; 2925 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2926 :    ARACrypt crypt;

	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??0ARACrypt@@QAE@XZ			; ARACrypt::ARACrypt

; 2927 :    zPCHAR   pch;
; 2928 :    zUCHAR   uCrypt;
; 2929 :    zUSHORT  uChar;
; 2930 :    zUSHORT  uTempLth;
; 2931 :    zSHORT   nOrderIdx;
; 2932 :    zSHORT   nInLth;
; 2933 : // zCHAR    cChar;
; 2934 :    int      k;
; 2935 : // char     szMsg[ 256 ];
; 2936 : 
; 2937 : // if ( uLth == 20 )
; 2938 : //    return( UfEncryptString( pchOut, pchIn, uLth ) );
; 2939 : 
; 2940 : // zsprintf( szMsg, "UfEncryptStringUL Length: %d   In: \"%s\"", uLth, pchIn );
; 2941 : // TraceLineS( szMsg, "" );
; 2942 : 
; 2943 :    // Set up the encryption key.
; 2944 :    if ( pchKey && *pchKey )

	cmp	DWORD PTR _pchKey$[ebp], 0
	je	$LN18@fnEncryptS
	mov	eax, DWORD PTR _pchKey$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN18@fnEncryptS

; 2945 :    {
; 2946 :       char   szKey[ 65 ];
; 2947 :       char   szNewKey[ 65 ];
; 2948 :       zSHORT nKeyLth;
; 2949 : 
; 2950 :       zstrncpy( szNewKey, pchKey, sizeof( szNewKey ) - 1 );

	push	64					; 00000040H
	mov	edx, DWORD PTR _pchKey$[ebp]
	push	edx
	lea	eax, DWORD PTR _szNewKey$10[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 2951 :       szNewKey[ sizeof( szNewKey ) - 1 ] = 0;  // force null terminator

	mov	ecx, 1
	shl	ecx, 6
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 65			; 00000041H
	jae	SHORT $LN31@fnEncryptS
	jmp	SHORT $LN32@fnEncryptS
$LN31@fnEncryptS:
	call	___report_rangecheckfailure
$LN32@fnEncryptS:
	mov	edx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szNewKey$10[ebp+edx], 0

; 2952 :       nInLth = zstrlen( szNewKey );

	lea	eax, DWORD PTR _szNewKey$10[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nInLth$[ebp], ax

; 2953 : 
; 2954 :       crypt.GetKey( szKey );

	lea	ecx, DWORD PTR _szKey$9[ebp]
	push	ecx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	?GetKey@ARACrypt@@UAEXPAD@Z		; ARACrypt::GetKey

; 2955 :       nKeyLth = zstrlen( szKey );

	lea	edx, DWORD PTR _szKey$9[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nKeyLth$8[ebp], ax

; 2956 :       if ( nKeyLth + nInLth > sizeof( szKey ) - 1 )

	movsx	eax, WORD PTR _nKeyLth$8[ebp]
	movsx	ecx, WORD PTR _nInLth$[ebp]
	add	eax, ecx
	cmp	eax, 64					; 00000040H
	jbe	SHORT $LN19@fnEncryptS

; 2957 :          nKeyLth = sizeof( szKey ) - 1 - nInLth;

	movsx	edx, WORD PTR _nInLth$[ebp]
	mov	eax, 64					; 00000040H
	sub	eax, edx
	mov	WORD PTR _nKeyLth$8[ebp], ax
$LN19@fnEncryptS:

; 2958 : 
; 2959 :       if ( nKeyLth > 0 )

	movsx	ecx, WORD PTR _nKeyLth$8[ebp]
	test	ecx, ecx
	jle	SHORT $LN18@fnEncryptS

; 2960 :       {
; 2961 :          zstrncpy( szNewKey + nInLth, pchKey, nKeyLth );

	movsx	edx, WORD PTR _nKeyLth$8[ebp]
	push	edx
	mov	eax, DWORD PTR _pchKey$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nInLth$[ebp]
	lea	edx, DWORD PTR _szNewKey$10[ebp+ecx]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 2962 :          szNewKey[ sizeof( szKey ) - 1 ] = 0;  // force null terminator

	mov	eax, 1
	shl	eax, 6
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 65			; 00000041H
	jae	SHORT $LN33@fnEncryptS
	jmp	SHORT $LN34@fnEncryptS
$LN33@fnEncryptS:
	call	___report_rangecheckfailure
$LN34@fnEncryptS:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szNewKey$10[ebp+ecx], 0

; 2963 :          crypt.SetKey( szNewKey );

	lea	edx, DWORD PTR _szNewKey$10[ebp]
	push	edx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	?SetKey@ARACrypt@@UAEXPBD@Z		; ARACrypt::SetKey
$LN18@fnEncryptS:

; 2964 :       }
; 2965 :    }
; 2966 : 
; 2967 :    pchOut[ uLth ] = 0;

	movzx	eax, WORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 2968 :    nInLth = zstrlen( pchIn );

	mov	edx, DWORD PTR _pchIn$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nInLth$[ebp], ax

; 2969 :    if ( uLth > zMAXEL ||
; 2970 :         (bEncodeLth && nInLth >= uLth) ||

	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	eax, 32					; 00000020H
	jg	SHORT $LN22@fnEncryptS
	movzx	ecx, BYTE PTR _bEncodeLth$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@fnEncryptS
	movsx	edx, WORD PTR _nInLth$[ebp]
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	edx, eax
	jge	SHORT $LN22@fnEncryptS
$LN23@fnEncryptS:
	movzx	ecx, BYTE PTR _bEncodeLth$[ebp]
	test	ecx, ecx
	jne	SHORT $LN21@fnEncryptS
	movsx	edx, WORD PTR _nInLth$[ebp]
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	edx, eax
	jle	SHORT $LN21@fnEncryptS
$LN22@fnEncryptS:

; 2971 :         (bEncodeLth == FALSE && nInLth > uLth) )
; 2972 :    {
; 2973 :       SysMessageBox( 0, "Zeidon Internal Error",

	push	0
	push	OFFSET $SG15808
	push	OFFSET $SG15809
	push	0
	call	_SysMessageBox@16

; 2974 :                      "Length Error Encrypting String", 0 );
; 2975 :       return( zCALL_ERROR );

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR $T7[ebp], cx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??1ARACrypt@@UAE@XZ			; ARACrypt::~ARACrypt
	mov	ax, WORD PTR $T7[ebp]
	jmp	$LN30@fnEncryptS
$LN21@fnEncryptS:

; 2976 :    }
; 2977 : 
; 2978 :    pch = new char[ uLth + 1 ];

	movzx	edx, WORD PTR _uLth$[ebp]
	add	edx, 1
	push	edx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR _pch$[ebp], eax

; 2979 :    zstrcpy( pch, pchIn );

	mov	ecx, DWORD PTR _pchIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 2980 : 
; 2981 :    // Seed the random-number generator with current time so that
; 2982 :    // the numbers will be different every time we run.
; 2983 : // srand( (unsigned) time( NULL ) );
; 2984 : 
; 2985 :    // Seed the random-number generator with the same data so that
; 2986 :    // the numbers will be same every time we run with the same data.
; 2987 :    if ( nInLth > sizeof( unsigned ) )

	movsx	eax, WORD PTR _nInLth$[ebp]
	cmp	eax, 4
	jbe	SHORT $LN24@fnEncryptS

; 2988 :       k = nInLth - sizeof( unsigned );

	movsx	ecx, WORD PTR _nInLth$[ebp]
	sub	ecx, 4
	mov	DWORD PTR _k$[ebp], ecx

; 2989 :    else

	jmp	SHORT $LN25@fnEncryptS
$LN24@fnEncryptS:

; 2990 :    {
; 2991 :       k = nInLth + 1;

	movsx	edx, WORD PTR _nInLth$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN2@fnEncryptS:

; 2992 :       while ( k < sizeof( unsigned ) )

	cmp	DWORD PTR _k$[ebp], 4
	jae	SHORT $LN3@fnEncryptS

; 2993 :          pch[ k++ ] = 0;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $LN2@fnEncryptS
$LN3@fnEncryptS:

; 2994 : 
; 2995 :       k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN25@fnEncryptS:

; 2996 :    }
; 2997 : 
; 2998 :    srand( (unsigned) *((unsigned *) ((char *) pch + k)) ); // set a random starting point

	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp__srand
	add	esp, 4

; 2999 : 
; 3000 :    for ( k = nInLth; k < uLth; k++ )  // set "empty" cells to random values

	movsx	ecx, WORD PTR _nInLth$[ebp]
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $LN6@fnEncryptS
$LN4@fnEncryptS:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN6@fnEncryptS:
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	DWORD PTR _k$[ebp], eax
	jge	SHORT $LN5@fnEncryptS
$LN9@fnEncryptS:

; 3001 :    {
; 3002 :       do
; 3003 :       {
; 3004 :          pch[ k ] = (char) rand( );

	call	DWORD PTR __imp__rand
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR [ecx], al

; 3005 : 
; 3006 :       } while ( pch[ k ] == 0 );

	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN9@fnEncryptS

; 3007 :    }

	jmp	SHORT $LN4@fnEncryptS
$LN5@fnEncryptS:

; 3008 : 
; 3009 :    pch[ uLth ] = 0;

	movzx	ecx, WORD PTR _uLth$[ebp]
	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 3010 :    pchOut[ uLth ] = 0;

	movzx	eax, WORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 3011 :    crypt.TransformString( pch );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	?TransformString@ARACrypt@@UAEXPADPBD@Z	; ARACrypt::TransformString

; 3012 :    uChar = 0;

	xor	eax, eax
	mov	WORD PTR _uChar$[ebp], ax

; 3013 :    nOrderIdx = 0;

	xor	ecx, ecx
	mov	WORD PTR _nOrderIdx$[ebp], cx

; 3014 : 
; 3015 :    if ( bEncodeLth )

	movzx	edx, BYTE PTR _bEncodeLth$[ebp]
	test	edx, edx
	je	$LN26@fnEncryptS
$LN10@fnEncryptS:

; 3016 :    {
; 3017 :       while ( EncryptB[ nOrderIdx ] > (uLth - 1) )

	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR ?EncryptB@@3PAEA[eax]
	movzx	edx, WORD PTR _uLth$[ebp]
	sub	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN12@fnEncryptS

; 3018 :          nOrderIdx++;

	mov	ax, WORD PTR _nOrderIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nOrderIdx$[ebp], ax
	jmp	SHORT $LN10@fnEncryptS
$LN12@fnEncryptS:

; 3019 : 
; 3020 :       while ( (zUSHORT) nInLth > uLth || nInLth > zMAXEL )

	movzx	ecx, WORD PTR _nInLth$[ebp]
	movzx	edx, WORD PTR _uLth$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN28@fnEncryptS
	movsx	eax, WORD PTR _nInLth$[ebp]
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN13@fnEncryptS
$LN28@fnEncryptS:

; 3021 :          nInLth -= uLth;

	movzx	ecx, WORD PTR _uLth$[ebp]
	movsx	edx, WORD PTR _nInLth$[ebp]
	sub	edx, ecx
	mov	WORD PTR _nInLth$[ebp], dx
	jmp	SHORT $LN12@fnEncryptS
$LN13@fnEncryptS:

; 3022 : 
; 3023 :       pchOut[ EncryptB[ nOrderIdx ] ] = EncryptA[ nInLth ] + 'a';

	movsx	eax, WORD PTR _nInLth$[ebp]
	movzx	ecx, BYTE PTR ?EncryptA@@3PAEA[eax]
	add	ecx, 97					; 00000061H
	movsx	edx, WORD PTR _nOrderIdx$[ebp]
	movzx	eax, BYTE PTR ?EncryptB@@3PAEA[edx]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx+eax], cl

; 3024 :    // zsprintf( szMsg, "UfEncryptStringUL Idx: %d   EncryptIdx: %d   Value: %2x",
; 3025 :    //           nOrderIdx, EncryptB[ nOrderIdx ], pchOut[ EncryptB[ nOrderIdx ] ] );
; 3026 :    // TraceLineS( szMsg, "" );
; 3027 :       nOrderIdx++;

	mov	ax, WORD PTR _nOrderIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nOrderIdx$[ebp], ax

; 3028 :       uTempLth = uLth - 1;

	movzx	ecx, WORD PTR _uLth$[ebp]
	sub	ecx, 1
	mov	WORD PTR _uTempLth$[ebp], cx

; 3029 :    }
; 3030 :    else

	jmp	SHORT $LN14@fnEncryptS
$LN26@fnEncryptS:

; 3031 :       uTempLth = uLth;

	mov	dx, WORD PTR _uLth$[ebp]
	mov	WORD PTR _uTempLth$[ebp], dx
$LN14@fnEncryptS:

; 3032 : 
; 3033 :    while ( uChar < uTempLth )

	movzx	eax, WORD PTR _uChar$[ebp]
	movzx	ecx, WORD PTR _uTempLth$[ebp]
	cmp	eax, ecx
	jge	$LN15@fnEncryptS
$LN16@fnEncryptS:

; 3034 :    {
; 3035 :       while ( EncryptB[ nOrderIdx ] > (uLth - 1) )

	movsx	edx, WORD PTR _nOrderIdx$[ebp]
	movzx	eax, BYTE PTR ?EncryptB@@3PAEA[edx]
	movzx	ecx, WORD PTR _uLth$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN17@fnEncryptS

; 3036 :          nOrderIdx++;

	mov	dx, WORD PTR _nOrderIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nOrderIdx$[ebp], dx
	jmp	SHORT $LN16@fnEncryptS
$LN17@fnEncryptS:

; 3037 : 
; 3038 :       uCrypt = pch[ uChar ];

	movzx	eax, WORD PTR _uChar$[ebp]
	mov	ecx, DWORD PTR _pch$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _uCrypt$[ebp], dl

; 3039 :       pchOut[ EncryptB[ nOrderIdx ] ] = uCrypt;

	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR ?EncryptB@@3PAEA[eax]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR _uCrypt$[ebp]
	mov	BYTE PTR [edx+ecx], al

; 3040 :    // zsprintf( szMsg, "UfEncryptStringUL Idx: %d   EncryptIdx: %d   Value: %2x",
; 3041 :    //           nOrderIdx, EncryptB[ nOrderIdx ], pchOut[ EncryptB[ nOrderIdx ] ] );
; 3042 :    // TraceLineS( szMsg, "" );
; 3043 : 
; 3044 :       uChar++;

	mov	cx, WORD PTR _uChar$[ebp]
	add	cx, 1
	mov	WORD PTR _uChar$[ebp], cx

; 3045 :       nOrderIdx++;

	mov	dx, WORD PTR _nOrderIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nOrderIdx$[ebp], dx

; 3046 :    }

	jmp	$LN14@fnEncryptS
$LN15@fnEncryptS:

; 3047 : 
; 3048 :    if ( zstrlen( pchOut ) != uLth )

	mov	eax, DWORD PTR _pchOut$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movzx	ecx, WORD PTR _uLth$[ebp]
	cmp	eax, ecx
	je	SHORT $LN29@fnEncryptS

; 3049 :    {
; 3050 :       SysMessageBox( 0, "Zeidon Internal Error",

	push	0
	push	OFFSET $SG15817
	push	OFFSET $SG15818
	push	0
	call	_SysMessageBox@16

; 3051 :                      "Null Error Encrypting String", 0 );
; 3052 :       return( zCALL_ERROR );

	mov	edx, -16				; fffffff0H
	mov	WORD PTR $T6[ebp], dx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??1ARACrypt@@UAE@XZ			; ARACrypt::~ARACrypt
	mov	ax, WORD PTR $T6[ebp]
	jmp	SHORT $LN30@fnEncryptS
$LN29@fnEncryptS:

; 3053 :    }
; 3054 : 
; 3055 : // zsprintf( szMsg, "UfEncryptStringUL Out: \"%s\"", pchOut );
; 3056 : // TraceLineS( szMsg, "" );
; 3057 : 
; 3058 : // UfDecryptStringUL( pch, pchOut, uLth );
; 3059 :    delete [] pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 3060 :    return( 0 );

	xor	edx, edx
	mov	WORD PTR $T5[ebp], dx
	lea	ecx, DWORD PTR _crypt$[ebp]
	call	??1ARACrypt@@UAE@XZ			; ARACrypt::~ARACrypt
	mov	ax, WORD PTR $T5[ebp]
$LN30@fnEncryptS:

; 3061 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?fnEncryptStringUL@@YAFPAD00GE@Z ENDP			; fnEncryptStringUL
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	call	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

	push	ebp
	mov	ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	pop	ebp
	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_GARACrypt@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GARACrypt@@UAEPAXI@Z PROC				; ARACrypt::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ARACrypt@@UAE@XZ			; ARACrypt::~ARACrypt
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN2@scalar
	push	117					; 00000075H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN2@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GARACrypt@@UAEPAXI@Z ENDP				; ARACrypt::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ARACrypt@@UAE@XZ PROC				; ARACrypt::~ARACrypt
; _this$ = ecx

; 2598 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ARACrypt@@6B@

; 2599 : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1ARACrypt@@UAE@XZ ENDP				; ARACrypt::~ARACrypt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_Out_C$ = -20						; size = 4
_Out_B$ = -16						; size = 4
_Counter$ = -12						; size = 4
_this$ = -8						; size = 4
_Crypto$ = -1						; size = 1
_cTarget$ = 8						; size = 4
?TransformChar@ARACrypt@@UAEXAAE@Z PROC			; ARACrypt::TransformChar
; _this$ = ecx

; 2695 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 2696 :    int               Counter  = 0;

	mov	DWORD PTR _Counter$[ebp], 0

; 2697 :    unsigned char     Crypto   = '\0';

	mov	BYTE PTR _Crypto$[ebp], 0

; 2698 :    unsigned long int Out_B = (m_LFSR_B & 0x00000001);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+73]
	and	ecx, 1
	mov	DWORD PTR _Out_B$[ebp], ecx

; 2699 :    unsigned long int Out_C = (m_LFSR_C & 0x00000001);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+77]
	and	eax, 1
	mov	DWORD PTR _Out_C$[ebp], eax

; 2700 : 
; 2701 :    // Cycle the LFSRs eight times to get eight
; 2702 :    // pseudo-random bits. Assemble these into
; 2703 :    // a single random character (Crypto).
; 2704 : 
; 2705 :    for ( Counter = 0; Counter < 8; Counter++ )

	mov	DWORD PTR _Counter$[ebp], 0
	jmp	SHORT $LN4@TransformC
$LN2@TransformC:
	mov	ecx, DWORD PTR _Counter$[ebp]
	add	ecx, 1
	mov	DWORD PTR _Counter$[ebp], ecx
$LN4@TransformC:
	cmp	DWORD PTR _Counter$[ebp], 8
	jge	$LN3@TransformC

; 2706 :    {
; 2707 :       if ( m_LFSR_A & 0x00000001 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+69]
	and	eax, 1
	je	SHORT $LN5@TransformC

; 2708 :       {
; 2709 :          // The least-significant bit of LFSR
; 2710 :          // A is "1". XOR LFSR A with its
; 2711 :          // feedback mask.
; 2712 : 
; 2713 :          m_LFSR_A = (((m_LFSR_A ^ m_Mask_A ) >> 1) | m_Rot1_A);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+69]
	xor	eax, DWORD PTR [edx+81]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+105]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+69], eax

; 2714 : 
; 2715 :          // Clock shift register B once.
; 2716 :          if ( m_LFSR_B & 0x00000001 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+73]
	and	ecx, 1
	je	SHORT $LN7@TransformC

; 2717 :          {
; 2718 :             // The LSB of LFSR B is "1". XOR
; 2719 :             // LFSR B with its feedback mask.
; 2720 : 
; 2721 :             m_LFSR_B = (((m_LFSR_B ^ m_Mask_B) >> 1) | m_Rot1_B);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+73]
	xor	ecx, DWORD PTR [eax+85]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	or	ecx, DWORD PTR [edx+109]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+73], ecx

; 2722 : 
; 2723 :             Out_B = 0x00000001;

	mov	DWORD PTR _Out_B$[ebp], 1

; 2724 :          }
; 2725 :          else

	jmp	SHORT $LN8@TransformC
$LN7@TransformC:

; 2726 :          {
; 2727 :             // The LSB of LFSR B is "0". Rotate
; 2728 :             // the LFSR contents once.
; 2729 : 
; 2730 :             m_LFSR_B = ((m_LFSR_B >> 1) & m_Rot0_B);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+73]
	shr	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+97]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+73], edx

; 2731 : 
; 2732 :             Out_B = 0x00000000;

	mov	DWORD PTR _Out_B$[ebp], 0
$LN8@TransformC:

; 2733 :          }
; 2734 :       }
; 2735 :       else

	jmp	SHORT $LN6@TransformC
$LN5@TransformC:

; 2736 :       {
; 2737 :          // The LSB of LFSR A is "0".
; 2738 :          // Rotate the LFSR contents once.
; 2739 : 
; 2740 :          m_LFSR_A = ((m_LFSR_A >> 1) & m_Rot0_A);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+69]
	shr	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+93]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+69], eax

; 2741 : 
; 2742 :          // Clock shift register C once.
; 2743 : 
; 2744 :          if ( m_LFSR_C & 0x00000001 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+77]
	and	ecx, 1
	je	SHORT $LN9@TransformC

; 2745 :          {
; 2746 :             // The LSB of LFSR C is "1".
; 2747 :             // XOR LFSR C with its feedback mask.
; 2748 : 
; 2749 :             m_LFSR_C = (((m_LFSR_C ^ m_Mask_C) >> 1) | m_Rot1_C);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+77]
	xor	ecx, DWORD PTR [eax+89]
	shr	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	or	ecx, DWORD PTR [edx+113]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+77], ecx

; 2750 :             Out_C = 0x00000001;

	mov	DWORD PTR _Out_C$[ebp], 1

; 2751 :          }
; 2752 :          else

	jmp	SHORT $LN6@TransformC
$LN9@TransformC:

; 2753 :          {
; 2754 :             // The LSB of LFSR C is "0". Rotate
; 2755 :             // the LFSR contents once.
; 2756 : 
; 2757 :             m_LFSR_C = ((m_LFSR_C >> 1) & m_Rot0_C);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+77]
	shr	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	and	edx, DWORD PTR [eax+101]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+77], edx

; 2758 : 
; 2759 :             Out_C = 0x00000000;

	mov	DWORD PTR _Out_C$[ebp], 0
$LN6@TransformC:

; 2760 :          }
; 2761 :       }
; 2762 : 
; 2763 :       // XOR the output from LFSRs B and C and
; 2764 :       // rotate it into the right bit of Crypto.
; 2765 : 
; 2766 :       // The following conversion warning is unecessary here as
; 2767 :       // 'loss of data' is a side effect and harmless.
; 2768 :       #pragma warning( disable : 4244 )
; 2769 : 
; 2770 :       Crypto = ((Crypto << 1) | (Out_B ^ Out_C));

	movzx	edx, BYTE PTR _Crypto$[ebp]
	shl	edx, 1
	mov	eax, DWORD PTR _Out_B$[ebp]
	xor	eax, DWORD PTR _Out_C$[ebp]
	or	edx, eax
	mov	BYTE PTR _Crypto$[ebp], dl

; 2771 : 
; 2772 :       #pragma warning( default : 4244 )
; 2773 :    }

	jmp	$LN2@TransformC
$LN3@TransformC:

; 2774 : 
; 2775 :    // XOR the resulting character with the
; 2776 :    // input character to encrypt/decrypt it.
; 2777 : 
; 2778 :    // The following conversion warning not necessary here either.
; 2779 :    // The 'loss of data', so to speak is a side effect and harmless.
; 2780 :    #pragma warning( disable : 4244 )
; 2781 : 
; 2782 :    cTarget = (cTarget ^ Crypto);

	mov	ecx, DWORD PTR _cTarget$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _Crypto$[ebp]
	xor	edx, eax
	mov	ecx, DWORD PTR _cTarget$[ebp]
	mov	BYTE PTR [ecx], dl

; 2783 : 
; 2784 :    if ( cTarget == NULL )           // No nulls allowed here. There is

	mov	edx, DWORD PTR _cTarget$[ebp]
	movzx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN1@TransformC

; 2785 :      cTarget = (cTarget ^ Crypto);  // no working std::string available.

	mov	ecx, DWORD PTR _cTarget$[ebp]
	movzx	edx, BYTE PTR [ecx]
	movzx	eax, BYTE PTR _Crypto$[ebp]
	xor	edx, eax
	mov	ecx, DWORD PTR _cTarget$[ebp]
	mov	BYTE PTR [ecx], dl
$LN1@TransformC:

; 2786 : 
; 2787 :    #pragma warning( default : 4244 )
; 2788 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?TransformChar@ARACrypt@@UAEXAAE@Z ENDP			; ARACrypt::TransformChar
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pchKey$ = 8						; size = 4
?GetKey@ARACrypt@@UAEXPAD@Z PROC			; ARACrypt::GetKey
; _this$ = ecx

; 2668 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 2669 :    strcpy( pchKey, m_szKey );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pchKey$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2670 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetKey@ARACrypt@@UAEXPAD@Z ENDP			; ARACrypt::GetKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
tv143 = -68						; size = 4
tv134 = -64						; size = 4
tv93 = -60						; size = 4
$T1 = -56						; size = 4
_nLth$ = -52						; size = 4
_nIdx$ = -48						; size = 4
_this$ = -44						; size = 4
_szSeed$ = -40						; size = 33
__$ArrayPad$ = -4					; size = 4
_cpcKey$ = 8						; size = 4
?SetKey@ARACrypt@@UAEXPBD@Z PROC			; ARACrypt::SetKey
; _this$ = ecx

; 2606 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 2607 :    char szSeed[ zMAXEL + 1 ];
; 2608 : 
; 2609 :    strcpy( m_szKey, cpcKey );

	mov	eax, DWORD PTR _cpcKey$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	_strcpy
	add	esp, 8

; 2610 : 
; 2611 :    if ( m_szKey[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _this$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+4]
	test	edx, edx
	jne	SHORT $LN8@SetKey

; 2612 :    {
; 2613 :       // Put some really outrageous characters in seed just in case.
; 2614 :       strcpy( szSeed, "\x43\xC8\x21\xD3\xF4\xB3\x10\x27\x09\xAA\x18\x56" );

	push	OFFSET $SG15711
	lea	eax, DWORD PTR _szSeed$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2615 : 
; 2616 :       //TO DO: Add Message to Event Log and/or window when there is one.
; 2617 : //    AfxMessageBox( "WARNING: Missing Pass Phrase. Default in effect!" );
; 2618 :    }
; 2619 :    else

	jmp	SHORT $LN9@SetKey
$LN8@SetKey:

; 2620 :    {
; 2621 :       strcpy( szSeed, m_szKey );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR _szSeed$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN9@SetKey:

; 2622 :    }
; 2623 : 
; 2624 :    // Make sure seed is at least 12 bytes long.
; 2625 : 
; 2626 :    int nIdx = 0;

	mov	DWORD PTR _nIdx$[ebp], 0

; 2627 :    int nLth = strlen( szSeed );

	lea	eax, DWORD PTR _szSeed$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 2628 : 
; 2629 :    for ( nIdx = 0; nLth < 12; nIdx++ )

	mov	DWORD PTR _nIdx$[ebp], 0
	jmp	SHORT $LN4@SetKey
$LN2@SetKey:
	mov	ecx, DWORD PTR _nIdx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nIdx$[ebp], ecx
$LN4@SetKey:
	cmp	DWORD PTR _nLth$[ebp], 12		; 0000000cH
	jge	SHORT $LN3@SetKey

; 2630 :    {
; 2631 :       szSeed[ nLth++ ] = szSeed[ nIdx ];

	mov	edx, DWORD PTR _nLth$[ebp]
	mov	eax, DWORD PTR _nIdx$[ebp]
	mov	cl, BYTE PTR _szSeed$[ebp+eax]
	mov	BYTE PTR _szSeed$[ebp+edx], cl
	mov	edx, DWORD PTR _nLth$[ebp]
	add	edx, 1
	mov	DWORD PTR _nLth$[ebp], edx

; 2632 :       szSeed[ nLth ] = 0;

	mov	eax, DWORD PTR _nLth$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 33			; 00000021H
	jae	SHORT $LN14@SetKey
	jmp	SHORT $LN15@SetKey
$LN14@SetKey:
	call	___report_rangecheckfailure
$LN15@SetKey:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szSeed$[ebp+ecx], 0

; 2633 :    }

	jmp	SHORT $LN2@SetKey
$LN3@SetKey:

; 2634 : 
; 2635 :    // LFSR A, B, and C get the first, second, and
; 2636 :    // third four bytes of the seed, respectively.
; 2637 : 
; 2638 :    for ( nIdx = 0; nIdx < 4; nIdx++ )

	mov	DWORD PTR _nIdx$[ebp], 0
	jmp	SHORT $LN7@SetKey
$LN5@SetKey:
	mov	edx, DWORD PTR _nIdx$[ebp]
	add	edx, 1
	mov	DWORD PTR _nIdx$[ebp], edx
$LN7@SetKey:
	cmp	DWORD PTR _nIdx$[ebp], 4
	jge	SHORT $LN6@SetKey

; 2639 :    {
; 2640 :       m_LFSR_A = ((m_LFSR_A <<= 8) |

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+69]
	shl	ecx, 8
	mov	DWORD PTR tv93[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR [edx+69], eax
	mov	ecx, DWORD PTR _nIdx$[ebp]
	movsx	edx, BYTE PTR _szSeed$[ebp+ecx]
	or	edx, DWORD PTR tv93[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+69], edx

; 2641 :                   ((unsigned long int) szSeed[ nIdx + 0 ]));
; 2642 : 
; 2643 :       m_LFSR_B = ((m_LFSR_B <<= 8) |

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+73]
	shl	edx, 8
	mov	DWORD PTR tv134[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR tv134[ebp]
	mov	DWORD PTR [eax+73], ecx
	mov	edx, DWORD PTR _nIdx$[ebp]
	movsx	eax, BYTE PTR _szSeed$[ebp+edx+4]
	or	eax, DWORD PTR tv134[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+73], eax

; 2644 :                   ((unsigned long int ) szSeed[ nIdx + 4 ]));
; 2645 : 
; 2646 :       m_LFSR_C = ((m_LFSR_C <<= 8) |

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+77]
	shl	eax, 8
	mov	DWORD PTR tv143[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv143[ebp]
	mov	DWORD PTR [ecx+77], edx
	mov	eax, DWORD PTR _nIdx$[ebp]
	movsx	ecx, BYTE PTR _szSeed$[ebp+eax+8]
	or	ecx, DWORD PTR tv143[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+77], ecx

; 2647 :                   ((unsigned long int) szSeed[ nIdx + 8 ]));
; 2648 :    }

	jmp	$LN5@SetKey
$LN6@SetKey:

; 2649 : 
; 2650 :    // If any LFSR contains 0x00000000, load a
; 2651 :    // non-zero default value instead. There is
; 2652 :    // no particular "good" value. The ones here
; 2653 :    // were selected to be distinctive during
; 2654 :    // testing and debugging.
; 2655 : 
; 2656 :    if ( 0x00000000 == m_LFSR_A )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+69], 0
	jne	SHORT $LN10@SetKey

; 2657 :       m_LFSR_A = 0x13579BDF;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+69], 324508639		; 13579bdfH
$LN10@SetKey:

; 2658 : 
; 2659 :    if ( 0x00000000 == m_LFSR_B )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+73], 0
	jne	SHORT $LN11@SetKey

; 2660 :       m_LFSR_B = 0x2468ACE0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+73], 610839776		; 2468ace0H
$LN11@SetKey:

; 2661 : 
; 2662 :    if ( 0x00000000 == m_LFSR_C )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+77], 0
	jne	SHORT $LN13@SetKey

; 2663 :       m_LFSR_C = 0xFDB97531;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+77], -38177487		; fdb97531H
$LN13@SetKey:

; 2664 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?SetKey@ARACrypt@@UAEXPBD@Z ENDP			; ARACrypt::SetKey
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_nLth$ = -16						; size = 4
_this$ = -12						; size = 4
_nPos$1 = -8						; size = 4
_cBuff$2 = -1						; size = 1
_pchTarget$ = 8						; size = 4
_cpcKey$ = 12						; size = 4
?TransformString@ARACrypt@@UAEXPADPBD@Z PROC		; ARACrypt::TransformString
; _this$ = ecx

; 2800 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 2801 :    // Reset the shift registers.
; 2802 : 
; 2803 :    if ( cpcKey && *cpcKey )

	cmp	DWORD PTR _cpcKey$[ebp], 0
	je	SHORT $LN5@TransformS
	mov	eax, DWORD PTR _cpcKey$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@TransformS

; 2804 :       SetKey( cpcKey );

	mov	edx, DWORD PTR _cpcKey$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
$LN5@TransformS:

; 2805 : 
; 2806 :    // Transform each character in the string.
; 2807 :    //
; 2808 :    // DEVELOPER'S NOTE
; 2809 :    // ==========================================
; 2810 :    // DO NOT TREAT THE OUTPUT STRING AS A NULL-
; 2811 :    // TERMINATED STRING.
; 2812 :    // ==========================================
; 2813 :    // The transformation process can create null
; 2814 :    // characters in the output string. Always
; 2815 :    // use the length( ) method to retrieve the full
; 2816 :    // string when it has been transformed.
; 2817 : 
; 2818 :    // bek NOTE: The above note does not apply to this
; 2819 :    // implementation of Warren Ward's method.
; 2820 :    // ARACrypt knows about nulls and transforms them
; 2821 :    // into XOR nulls so the entire result can be
; 2822 :    // treated as a 'normal' null terminated string.
; 2823 : 
; 2824 :    int nLth = strlen( pchTarget );

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 2825 : 
; 2826 :    for ( int nPos = 0; nPos < nLth; nPos++ )

	mov	DWORD PTR _nPos$1[ebp], 0
	jmp	SHORT $LN4@TransformS
$LN2@TransformS:
	mov	edx, DWORD PTR _nPos$1[ebp]
	add	edx, 1
	mov	DWORD PTR _nPos$1[ebp], edx
$LN4@TransformS:
	mov	eax, DWORD PTR _nPos$1[ebp]
	cmp	eax, DWORD PTR _nLth$[ebp]
	jge	SHORT $LN1@TransformS

; 2827 :    {
; 2828 :       // The following conversion warning not necessary here either.
; 2829 :       // The 'loss of data', so to speak is a side effect and harmless.
; 2830 :       #pragma warning( disable : 4244 )
; 2831 : 
; 2832 :       unsigned char cBuff = pchTarget[ nPos ];

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	add	ecx, DWORD PTR _nPos$1[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _cBuff$2[ebp], dl

; 2833 :       TransformChar( (unsigned char&) cBuff );

	lea	eax, DWORD PTR _cBuff$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 2834 :       pchTarget[ nPos ] = cBuff;

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	add	ecx, DWORD PTR _nPos$1[ebp]
	mov	dl, BYTE PTR _cBuff$2[ebp]
	mov	BYTE PTR [ecx], dl

; 2835 :    }

	jmp	SHORT $LN2@TransformS
$LN1@TransformS:

; 2836 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?TransformString@ARACrypt@@UAEXPADPBD@Z ENDP		; ARACrypt::TransformString
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ARACrypt@@QAE@XZ PROC				; ARACrypt::ARACrypt
; _this$ = ecx

; 2592 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ARACrypt@@6B@

; 2514 :           m_LFSR_A( 0x3B5169DF ),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+69], 995191263		; 3b5169dfH

; 2515 :           m_LFSR_B( 0xD2758CE3 ),

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+73], -764048157		; d2758ce3H

; 2516 :           m_LFSR_C( 0xF40B971A ),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+77], -200567014		; f40b971aH

; 2517 : 
; 2518 : 
; 2519 :    // Initialize the masks to magic numbers.
; 2520 :    // These values are primitive polynomials mod
; 2521 :    // 2, described in Applied Cryptography,
; 2522 :    // second edition, by Bruce Schneier (New York:
; 2523 :    // John Wiley and Sons, 1994). See Chapter 15:
; 2524 :    // Random Sequence Generators and Stream
; 2525 :    // Ciphers, particularly the discussion on
; 2526 :    // Linear Feedback Shift Registers.
; 2527 :    //
; 2528 :    // The primitive polynomials used here are:
; 2529 :    // Register A: ( 32, 7, 6, 2, 0 )
; 2530 :    // Register B: ( 31, 6, 0 )
; 2531 :    // Register C: ( 29, 2, 0 )
; 2532 :    //
; 2533 :    // The bits that must be set to "1" in the
; 2534 :    // XOR masks are:
; 2535 :    // Register A: ( 31, 6, 5, 1 )
; 2536 :    // Register B: ( 30, 5 )
; 2537 :    // Register C: ( 28, 1 )
; 2538 :    //
; 2539 :    // Developer's Note
; 2540 :    // DO NOT CHANGE THESE NUMBERS WITHOUT
; 2541 :    // REFERRING TO THE DISCUSSION IN SCHNEIER'S
; 2542 :    // BOOK. They are some of very few
; 2543 :    // near-32-bit values that will act as
; 2544 :    // maximal-length random generators.
; 2545 : 
; 2546 :           m_Mask_A( 0x80000062 ),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+81], -2147483550		; 80000062H

; 2547 :           m_Mask_B( 0x40000020 ),

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+85], 1073741856		; 40000020H

; 2548 :           m_Mask_C( 0x10000002 ),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+89], 268435458		; 10000002H

; 2549 : 
; 2550 : 
; 2551 :    // Set up LFSR "rotate" masks.
; 2552 :    // These masks limit the number of bits
; 2553 :    // used in the shift registers. Each one
; 2554 :    // provides the most-significant bit (MSB)
; 2555 :    // when performing a "rotate" operation. Here
; 2556 :    // are the shift register sizes and the byte
; 2557 :    // mask needed to place a "1" bit in the MSB
; 2558 :    // for Rotate-1, and a zero in the MSB for
; 2559 :    // Rotate-0. All the shift registers are stored
; 2560 :    // in an unsigned 32-bit integer, but these
; 2561 :    // masks effectively make the registers 32
; 2562 :    // bits (A), 31 bits (B), and 29 bits (C).
; 2563 :    //
; 2564 :    // Bit   |  3            2             1            0
; 2565 :    // Pos'n | 1098 7654  3210 9876  5432 1098  7654 3210
; 2566 :    // ===== | ==========================================
; 2567 :    // Value | 8421-8421  8421-8421  8421-8421  8421-8421
; 2568 :    // ===== | ==========================================
; 2569 :    //       |
; 2570 :    // A-Rot0 | 0111 1111  1111 1111  1111 1111  1111 1111
; 2571 :    // A-Rot1 | 1000 0000  0000 0000  0000 0000  0000 0000
; 2572 :    //        |
; 2573 :    // B-Rot0 | 0011 1111  1111 1111  1111 1111  1111 1111
; 2574 :    // B-Rot1 | 1100 0000  0000 0000  0000 0000  0000 0000
; 2575 :    //        |
; 2576 :    // C-Rot0 | 0000 1111  1111 1111  1111 1111  1111 1111
; 2577 :    // C-Rot1 | 1111 0000  0000 0000  0000 0000  0000 0000
; 2578 :    //
; 2579 :    //
; 2580 :    // Reg Size MSB Position   Rotate-0 Mask  Rotate-1 Mask
; 2581 :    // A  32    31       0x7FFFFFFF     0x80000000
; 2582 :    // B  31    30       0x3FFFFFFF     0xC0000000
; 2583 :    // C  29    28       0x0FFFFFFF     0xF0000000
; 2584 :    //
; 2585 : 
; 2586 :           m_Rot0_A( 0x7FFFFFFF ),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+93], 2147483647		; 7fffffffH

; 2587 :           m_Rot0_B( 0x3FFFFFFF ),

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+97], 1073741823		; 3fffffffH

; 2588 :           m_Rot0_C( 0x0FFFFFFF ),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+101], 268435455		; 0fffffffH

; 2589 :           m_Rot1_A( 0x80000000 ),

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+105], -2147483648	; 80000000H

; 2590 :           m_Rot1_B( 0xC0000000 ),

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+109], -1073741824	; c0000000H

; 2591 :           m_Rot1_C( 0xF0000000 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+113], -268435456		; f0000000H

; 2593 :    strcpy( m_szKey, "Don2Cam9Pas1Gig3Dks5Dgc8Kat2Mik3Jab1Mat2" );

	push	OFFSET $SG15684
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	call	_strcpy
	add	esp, 8

; 2594 : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ARACrypt@@QAE@XZ ENDP				; ARACrypt::ARACrypt
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_lViewCluster$ = 8					; size = 4
_nViewCount$ = 12					; size = 2
_pnViewErrorIdx$ = 16					; size = 4
_lControl$ = 20						; size = 4
?CommitMultipleOIs@@YGFJFPAFJ@Z PROC			; CommitMultipleOIs

; 3313 : {

	push	ebp
	mov	ebp, esp

; 3314 :    return( ::CommitMultipleOIs( (LPVIEWCLUSTER) lViewCluster,

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nViewCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lViewCluster$[ebp]
	push	eax
	call	_CommitMultipleOIs@16

; 3315 :                                 nViewCount, pnViewErrorIdx, lControl ) );
; 3316 : }

	pop	ebp
	ret	16					; 00000010H
?CommitMultipleOIs@@YGFJFPAFJ@Z ENDP			; CommitMultipleOIs
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??_0@YG?AVZDecimal@@V0@N@Z PROC				; operator/=

; 2484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2485 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2486 :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2487 :    zDec = zDec / zDecD;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2488 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2489 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??_0@YG?AVZDecimal@@V0@N@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??_0@YG?AVZDecimal@@V0@E@Z PROC				; operator/=

; 2475 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2476 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2477 :    zDecN = n;

	movzx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2478 :    zDec = zDec / zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2479 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2480 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@E@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??_0@YG?AVZDecimal@@V0@D@Z PROC				; operator/=

; 2466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2467 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2468 :    zDecN = n;

	movsx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2469 :    zDec = zDec / zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2470 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2471 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@D@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??_0@YG?AVZDecimal@@V0@I@Z PROC				; operator/=

; 2457 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2458 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2459 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@I@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2460 :    zDec = zDec / zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2461 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2462 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@I@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??_0@YG?AVZDecimal@@V0@H@Z PROC				; operator/=

; 2448 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2449 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2450 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2451 :    zDec = zDec / zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2452 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2453 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@H@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??_0@YGGGVZDecimal@@@Z PROC				; operator/=

; 2441 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2442 :    n = n / (zUSHORT) zDec;

	movzx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEGXZ			; ZDecimal::operator unsigned short
	movzx	ecx, ax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	WORD PTR _n$[ebp], ax

; 2443 :    return( n );

	mov	dx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], dx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2444 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??_0@YGGGVZDecimal@@@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??_0@YG?AVZDecimal@@V0@G@Z PROC				; operator/=

; 2432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2433 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2434 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2435 :    zDec = zDec / zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2436 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2437 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@G@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??_0@YGFFVZDecimal@@@Z PROC				; operator/=

; 2425 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2426 :    n = n / (zSHORT) zDec;

	movsx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEFXZ			; ZDecimal::operator short
	movsx	ecx, ax
	mov	eax, esi
	cdq
	idiv	ecx
	mov	WORD PTR _n$[ebp], ax

; 2427 :    return( n );

	mov	dx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], dx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2428 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??_0@YGFFVZDecimal@@@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??_0@YG?AVZDecimal@@V0@F@Z PROC				; operator/=

; 2416 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2417 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2418 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2419 :    zDec = zDec / zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2420 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2421 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@F@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??_0@YGKKVZDecimal@@@Z PROC				; operator/=

; 2409 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2410 :    l = l / (zULONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEKXZ			; ZDecimal::operator unsigned long
	mov	ecx, eax
	mov	eax, DWORD PTR _l$[ebp]
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _l$[ebp], eax

; 2411 :    return( l );

	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2412 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??_0@YGKKVZDecimal@@@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??_0@YG?AVZDecimal@@V0@K@Z PROC				; operator/=

; 2400 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2401 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2402 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2403 :    zDec = zDec / zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2404 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2405 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@K@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??_0@YGJAAJVZDecimal@@@Z PROC				; operator/=

; 2393 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2394 :    l = l / (zLONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEJXZ			; ZDecimal::operator long
	mov	ecx, eax
	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [ecx], eax

; 2395 :    return( l );

	mov	edx, DWORD PTR _l$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2396 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??_0@YGJAAJVZDecimal@@@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??_0@YG?AVZDecimal@@V0@J@Z PROC				; operator/=

; 2384 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2385 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2386 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2387 :    zDec = zDec / zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2388 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2389 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@V0@J@Z ENDP				; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -292						; size = 144
$T2 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec1$ = 12						; size = 4
_zDec2$ = 16						; size = 144
??_0@YG?AVZDecimal@@AAV0@V0@@Z PROC			; operator/=

; 2377 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2378 :    zDec1 = zDec1 / zDec2;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec2$[ebp]
	mov	edi, esp
	rep movsd
	mov	esi, DWORD PTR _zDec1$[ebp]
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _zDec1$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2379 :    return( zDec1 );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _zDec1$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2380 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??_0@YG?AVZDecimal@@AAV0@V0@@Z ENDP			; operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??X@YG?AVZDecimal@@V0@N@Z PROC				; operator*=

; 2364 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2365 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2366 :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2367 :    zDec = zDec * zDecD;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2368 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2369 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??X@YG?AVZDecimal@@V0@N@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??X@YG?AVZDecimal@@V0@E@Z PROC				; operator*=

; 2355 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2356 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2357 :    zDecN = n;

	movzx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2358 :    zDec = zDec * zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2359 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2360 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@E@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??X@YG?AVZDecimal@@V0@D@Z PROC				; operator*=

; 2346 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2347 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2348 :    zDecN = n;

	movsx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2349 :    zDec = zDec * zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2350 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2351 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@D@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??X@YG?AVZDecimal@@V0@I@Z PROC				; operator*=

; 2337 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2338 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2339 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@I@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2340 :    zDec = zDec * zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2341 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2342 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@I@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??X@YG?AVZDecimal@@V0@H@Z PROC				; operator*=

; 2328 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2329 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2330 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2331 :    zDec = zDec * zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2332 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2333 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@H@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??X@YGGGVZDecimal@@@Z PROC				; operator*=

; 2321 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2322 :    n = n * (zUSHORT) zDec;

	movzx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEGXZ			; ZDecimal::operator unsigned short
	movzx	eax, ax
	imul	esi, eax
	mov	WORD PTR _n$[ebp], si

; 2323 :    return( n );

	mov	cx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], cx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2324 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??X@YGGGVZDecimal@@@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??X@YG?AVZDecimal@@V0@G@Z PROC				; operator*=

; 2312 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2313 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2314 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2315 :    zDec = zDec * zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2316 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2317 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@G@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??X@YGFFVZDecimal@@@Z PROC				; operator*=

; 2305 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2306 :    n = n * (zSHORT) zDec;

	movsx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEFXZ			; ZDecimal::operator short
	cwde
	imul	esi, eax
	mov	WORD PTR _n$[ebp], si

; 2307 :    return( n );

	mov	cx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], cx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2308 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??X@YGFFVZDecimal@@@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??X@YG?AVZDecimal@@V0@F@Z PROC				; operator*=

; 2296 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2297 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2298 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2299 :    zDec = zDec * zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2300 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2301 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@F@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??X@YGKKVZDecimal@@@Z PROC				; operator*=

; 2289 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2290 :    l = l * (zULONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEKXZ			; ZDecimal::operator unsigned long
	imul	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _l$[ebp], eax

; 2291 :    return( l );

	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2292 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??X@YGKKVZDecimal@@@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??X@YG?AVZDecimal@@V0@K@Z PROC				; operator*=

; 2280 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2281 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2282 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2283 :    zDec = zDec * zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2284 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2285 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@K@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??X@YGJAAJVZDecimal@@@Z PROC				; operator*=

; 2273 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2274 :    l = l * (zLONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEJXZ			; ZDecimal::operator long
	mov	ecx, DWORD PTR _l$[ebp]
	imul	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [edx], eax

; 2275 :    return( l );

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2276 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??X@YGJAAJVZDecimal@@@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??X@YG?AVZDecimal@@V0@J@Z PROC				; operator*=

; 2264 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2265 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2266 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2267 :    zDec = zDec - zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2268 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2269 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@V0@J@Z ENDP				; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -292						; size = 144
$T2 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec1$ = 12						; size = 4
_zDec2$ = 16						; size = 144
??X@YG?AVZDecimal@@AAV0@V0@@Z PROC			; operator*=

; 2257 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2258 :    zDec1 = zDec1 * zDec2;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec2$[ebp]
	mov	edi, esp
	rep movsd
	mov	esi, DWORD PTR _zDec1$[ebp]
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _zDec1$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2259 :    return( zDec1 );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _zDec1$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2260 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??X@YG?AVZDecimal@@AAV0@V0@@Z ENDP			; operator*=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??Z@YG?AVZDecimal@@V0@N@Z PROC				; operator-=

; 2244 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2245 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2246 :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2247 :    zDec = zDec - zDecD;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2248 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2249 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??Z@YG?AVZDecimal@@V0@N@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??Z@YG?AVZDecimal@@V0@E@Z PROC				; operator-=

; 2235 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2236 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2237 :    zDecN = n;

	movzx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2238 :    zDec = zDec - zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2239 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2240 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@E@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??Z@YG?AVZDecimal@@V0@D@Z PROC				; operator-=

; 2226 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2227 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2228 :    zDecN = n;

	movsx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2229 :    zDec = zDec - zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2230 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2231 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@D@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??Z@YG?AVZDecimal@@V0@I@Z PROC				; operator-=

; 2217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2218 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2219 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@I@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2220 :    zDec = zDec - zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2221 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2222 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@I@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??Z@YG?AVZDecimal@@V0@H@Z PROC				; operator-=

; 2208 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2209 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2210 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2211 :    zDec = zDec - zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2212 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2213 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@H@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??Z@YGGGVZDecimal@@@Z PROC				; operator-=

; 2201 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2202 :    n = n - (zUSHORT) zDec;

	movzx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEGXZ			; ZDecimal::operator unsigned short
	movzx	eax, ax
	sub	esi, eax
	mov	WORD PTR _n$[ebp], si

; 2203 :    return( n );

	mov	cx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], cx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2204 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Z@YGGGVZDecimal@@@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??Z@YG?AVZDecimal@@V0@G@Z PROC				; operator-=

; 2192 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2193 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2194 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2195 :    zDec = zDec - zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2196 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2197 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@G@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??Z@YGFFVZDecimal@@@Z PROC				; operator-=

; 2185 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2186 :    n = n - (zSHORT) zDec;

	movsx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEFXZ			; ZDecimal::operator short
	cwde
	sub	esi, eax
	mov	WORD PTR _n$[ebp], si

; 2187 :    return( n );

	mov	cx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], cx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2188 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Z@YGFFVZDecimal@@@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??Z@YG?AVZDecimal@@V0@F@Z PROC				; operator-=

; 2176 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2177 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2178 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2179 :    zDec = zDec - zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2180 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2181 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@F@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??Z@YGKKVZDecimal@@@Z PROC				; operator-=

; 2169 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2170 :    l = l - (zULONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEKXZ			; ZDecimal::operator unsigned long
	mov	ecx, DWORD PTR _l$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _l$[ebp], ecx

; 2171 :    return( l );

	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2172 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Z@YGKKVZDecimal@@@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??Z@YG?AVZDecimal@@V0@K@Z PROC				; operator-=

; 2160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2161 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2162 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2163 :    zDec = zDec - zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2164 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2165 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@K@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??Z@YGJAAJVZDecimal@@@Z PROC				; operator-=

; 2153 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2154 :    l = l - (zLONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEJXZ			; ZDecimal::operator long
	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR [eax], edx

; 2155 :    return( l );

	mov	ecx, DWORD PTR _l$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR $T1[ebp], edx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2156 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Z@YGJAAJVZDecimal@@@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??Z@YG?AVZDecimal@@V0@J@Z PROC				; operator-=

; 2144 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2145 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2146 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2147 :    zDec = zDec - zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2148 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2149 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@V0@J@Z ENDP				; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -292						; size = 144
$T2 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec1$ = 12						; size = 4
_zDec2$ = 16						; size = 144
??Z@YG?AVZDecimal@@AAV0@V0@@Z PROC			; operator-=

; 2137 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2138 :    zDec1 = zDec1 - zDec2;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec2$[ebp]
	mov	edi, esp
	rep movsd
	mov	esi, DWORD PTR _zDec1$[ebp]
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _zDec1$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2139 :    return( zDec1 );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _zDec1$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2140 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Z@YG?AVZDecimal@@AAV0@V0@@Z ENDP			; operator-=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??Y@YG?AVZDecimal@@V0@N@Z PROC				; operator+=

; 2124 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2125 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2126 :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2127 :    zDec = zDec + zDecD;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2128 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2129 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??Y@YG?AVZDecimal@@V0@N@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??Y@YG?AVZDecimal@@V0@E@Z PROC				; operator+=

; 2115 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2116 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2117 :    zDecN = n;

	movzx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2118 :    zDec = zDec + zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2119 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2120 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@E@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??Y@YG?AVZDecimal@@V0@D@Z PROC				; operator+=

; 2106 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2107 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2108 :    zDecN = n;

	movsx	eax, BYTE PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2109 :    zDec = zDec + zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2110 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2111 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@D@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??Y@YG?AVZDecimal@@V0@I@Z PROC				; operator+=

; 2097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2098 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2099 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@I@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2100 :    zDec = zDec + zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2101 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2102 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@I@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??Y@YG?AVZDecimal@@V0@H@Z PROC				; operator+=

; 2088 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2089 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2090 :    zDecN = n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@H@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2091 :    zDec = zDec + zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2092 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2093 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@H@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??Y@YGGGVZDecimal@@@Z PROC				; operator+=

; 2081 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2082 :    n = n + (zUSHORT) zDec;

	movzx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEGXZ			; ZDecimal::operator unsigned short
	movzx	eax, ax
	add	esi, eax
	mov	WORD PTR _n$[ebp], si

; 2083 :    return( n );

	mov	cx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], cx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2084 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Y@YGGGVZDecimal@@@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??Y@YG?AVZDecimal@@V0@G@Z PROC				; operator+=

; 2072 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2073 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2074 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2075 :    zDec = zDec + zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2076 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2077 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@G@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 2
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??Y@YGFFVZDecimal@@@Z PROC				; operator+=

; 2065 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2066 :    n = n + (zSHORT) zDec;

	movsx	esi, WORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEFXZ			; ZDecimal::operator short
	cwde
	add	esi, eax
	mov	WORD PTR _n$[ebp], si

; 2067 :    return( n );

	mov	cx, WORD PTR _n$[ebp]
	mov	WORD PTR $T1[ebp], cx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	ax, WORD PTR $T1[ebp]

; 2068 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Y@YGFFVZDecimal@@@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??Y@YG?AVZDecimal@@V0@F@Z PROC				; operator+=

; 2056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2057 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2058 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2059 :    zDec = zDec + zDecN;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2060 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2061 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@F@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??Y@YGKKVZDecimal@@@Z PROC				; operator+=

; 2049 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2050 :    l = l + (zULONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEKXZ			; ZDecimal::operator unsigned long
	add	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR _l$[ebp], eax

; 2051 :    return( l );

	mov	eax, DWORD PTR _l$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2052 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Y@YGKKVZDecimal@@@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??Y@YG?AVZDecimal@@V0@K@Z PROC				; operator+=

; 2040 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2041 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2042 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2043 :    zDec = zDec + zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2044 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2045 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@K@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -4						; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??Y@YGJAAJVZDecimal@@@Z PROC				; operator+=

; 2033 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2034 :    l = l + (zLONG) zDec;

	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??BZDecimal@@QAEJXZ			; ZDecimal::operator long
	mov	ecx, DWORD PTR _l$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _l$[ebp]
	mov	DWORD PTR [edx], eax

; 2035 :    return( l );

	mov	eax, DWORD PTR _l$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T1[ebp], ecx
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR $T1[ebp]

; 2036 : }

	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??Y@YGJAAJVZDecimal@@@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -580						; size = 144
$T1 = -436						; size = 144
$T2 = -292						; size = 144
$T3 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??Y@YG?AVZDecimal@@V0@J@Z PROC				; operator+=

; 2024 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2025 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2026 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2027 :    zDec = zDec + zDecL;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2028 :    return( zDec );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2029 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@V0@J@Z ENDP				; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -292						; size = 144
$T2 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec1$ = 12						; size = 4
_zDec2$ = 16						; size = 144
??Y@YG?AVZDecimal@@AAV0@V0@@Z PROC			; operator+=

; 2017 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2018 :    zDec1 = zDec1 + zDec2;

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec2$[ebp]
	mov	edi, esp
	rep movsd
	mov	esi, DWORD PTR _zDec1$[ebp]
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	edi, esp
	rep movsd
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	mov	esi, eax
	mov	edi, esp
	rep movsd
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _zDec1$[ebp]
	call	??4ZDecimal@@QAE?AV0@V0@@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2019 :    return( zDec1 );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _zDec1$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2020 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??Y@YG?AVZDecimal@@AAV0@V0@@Z ENDP			; operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??9@YGDVZDecimal@@M@Z PROC				; operator!=

; 2005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 2006 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 2007 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2008 :    return( zDec != zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 2009 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@M@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??9@YGDMVZDecimal@@@Z PROC				; operator!=

; 1997 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1998 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1999 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 2000 :    return( zDecD != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 2001 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDMVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 8
??9@YGDVZDecimal@@N@Z PROC				; operator!=

; 1989 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1990 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1991 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1992 :    return( zDec != zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1993 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??9@YGDVZDecimal@@N@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 8
_zDec$ = 16						; size = 144
??9@YGDNVZDecimal@@@Z PROC				; operator!=

; 1981 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1982 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1983 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1984 :    return( zDecD != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1985 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??9@YGDNVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??9@YGDVZDecimal@@E@Z PROC				; operator!=

; 1973 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1974 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1975 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1976 :    return( zDec != zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1977 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@E@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??9@YGDEVZDecimal@@@Z PROC				; operator!=

; 1965 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1966 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1967 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1968 :    return( zDecN != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1969 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDEVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??9@YGDDVZDecimal@@@Z PROC				; operator!=

; 1957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1958 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1959 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1960 :    return( zDecN != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1961 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDDVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??9@YGDVZDecimal@@D@Z PROC				; operator!=

; 1949 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1950 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1951 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1952 :    return( zDec != zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1953 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@D@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??9@YGDIVZDecimal@@@Z PROC				; operator!=

; 1942 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1943 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1944 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1945 :    return( zDecN != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1946 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDIVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??9@YGDVZDecimal@@I@Z PROC				; operator!=

; 1934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1935 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1936 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1937 :    return( zDec != zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1938 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@I@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??9@YGDHVZDecimal@@@Z PROC				; operator!=

; 1926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1927 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1928 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1929 :    return( zDecN != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1930 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDHVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??9@YGDVZDecimal@@H@Z PROC				; operator!=

; 1918 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1919 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1920 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1921 :    return( zDec != zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1922 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@H@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??9@YGDVZDecimal@@G@Z PROC				; operator!=

; 1910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1911 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1912 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1913 :    return( zDec != zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1914 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@G@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??9@YGDGVZDecimal@@@Z PROC				; operator!=

; 1902 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1903 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1904 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1905 :    return( zDecN != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1906 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDGVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??9@YGDVZDecimal@@F@Z PROC				; operator!=

; 1894 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1895 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1896 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1897 :    return( zDec != zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1898 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@F@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??9@YGDFVZDecimal@@@Z PROC				; operator!=

; 1886 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1887 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1888 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1889 :    return( zDecN != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1890 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDFVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??9@YGDVZDecimal@@K@Z PROC				; operator!=

; 1878 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1879 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1880 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1881 :    return( zDec != zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1882 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@K@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??9@YGDKVZDecimal@@@Z PROC				; operator!=

; 1870 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1871 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1872 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1873 :    return( zDecL != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1874 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDKVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??9@YGDVZDecimal@@J@Z PROC				; operator!=

; 1862 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1863 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1864 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1865 :    return( zDec != zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1866 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDVZDecimal@@J@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??9@YGDJVZDecimal@@@Z PROC				; operator!=

; 1854 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1855 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1856 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1857 :    return( zDecL != zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??9@YGDVZDecimal@@0@Z			; operator!=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1858 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??9@YGDJVZDecimal@@@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??8@YGDVZDecimal@@M@Z PROC				; operator==

; 1842 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1843 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1844 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1845 :    return( zDec == zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1846 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@M@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??8@YGDMVZDecimal@@@Z PROC				; operator==

; 1834 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1835 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1836 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1837 :    return( zDecD == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1838 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDMVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 8
??8@YGDVZDecimal@@N@Z PROC				; operator==

; 1826 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1827 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1828 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1829 :    return( zDec == zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1830 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??8@YGDVZDecimal@@N@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 8
_zDec$ = 16						; size = 144
??8@YGDNVZDecimal@@@Z PROC				; operator==

; 1818 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1819 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1820 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1821 :    return( zDecD == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1822 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??8@YGDNVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??8@YGDVZDecimal@@E@Z PROC				; operator==

; 1810 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1811 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1812 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1813 :    return( zDec == zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1814 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@E@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??8@YGDEVZDecimal@@@Z PROC				; operator==

; 1802 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1803 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1804 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1805 :    return( zDecN == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1806 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDEVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??8@YGDDVZDecimal@@@Z PROC				; operator==

; 1794 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1795 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1796 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1797 :    return( zDecN == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1798 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDDVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??8@YGDVZDecimal@@D@Z PROC				; operator==

; 1786 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1787 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1788 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1789 :    return( zDec == zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1790 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@D@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??8@YGDIVZDecimal@@@Z PROC				; operator==

; 1778 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1779 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1780 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1781 :    return( zDecN == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1782 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDIVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??8@YGDVZDecimal@@I@Z PROC				; operator==

; 1770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1771 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1772 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1773 :    return( zDec == zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1774 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@I@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??8@YGDHVZDecimal@@@Z PROC				; operator==

; 1762 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1763 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1764 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1765 :    return( zDecN == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1766 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDHVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??8@YGDVZDecimal@@H@Z PROC				; operator==

; 1754 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1755 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1756 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1757 :    return( zDec == zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1758 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@H@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??8@YGDVZDecimal@@G@Z PROC				; operator==

; 1746 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1747 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1748 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1749 :    return( zDec == zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1750 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@G@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??8@YGDGVZDecimal@@@Z PROC				; operator==

; 1738 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1739 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1740 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1741 :    return( zDecN == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1742 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDGVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??8@YGDVZDecimal@@F@Z PROC				; operator==

; 1730 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1731 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1732 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1733 :    return( zDec == zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1734 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@F@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??8@YGDFVZDecimal@@@Z PROC				; operator==

; 1722 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1723 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1724 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1725 :    return( zDecN == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1726 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDFVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??8@YGDVZDecimal@@K@Z PROC				; operator==

; 1714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1715 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1716 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1717 :    return( zDec == zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1718 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@K@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??8@YGDKVZDecimal@@@Z PROC				; operator==

; 1706 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1707 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1708 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1709 :    return( zDecL == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1710 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDKVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??8@YGDVZDecimal@@J@Z PROC				; operator==

; 1698 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1699 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1700 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1701 :    return( zDec == zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1702 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDVZDecimal@@J@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??8@YGDJVZDecimal@@@Z PROC				; operator==

; 1690 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1691 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1692 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1693 :    return( zDecL == zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??8@YGDVZDecimal@@0@Z			; operator==
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1694 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??8@YGDJVZDecimal@@@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??M@YGDVZDecimal@@M@Z PROC				; operator<

; 1678 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1679 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1680 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1681 :    return( zDec < zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1682 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@M@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??M@YGDMVZDecimal@@@Z PROC				; operator<

; 1670 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1671 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1672 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1673 :    return( zDecD < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1674 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDMVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 8
??M@YGDVZDecimal@@N@Z PROC				; operator<

; 1662 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1663 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1664 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1665 :    return( zDec < zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1666 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??M@YGDVZDecimal@@N@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 8
_zDec$ = 16						; size = 144
??M@YGDNVZDecimal@@@Z PROC				; operator<

; 1654 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1655 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1656 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1657 :    return( zDecD < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1658 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??M@YGDNVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??M@YGDVZDecimal@@E@Z PROC				; operator<

; 1646 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1647 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1648 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1649 :    return( zDec < zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1650 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@E@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??M@YGDEVZDecimal@@@Z PROC				; operator<

; 1638 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1639 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1640 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1641 :    return( zDecN < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1642 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDEVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??M@YGDDVZDecimal@@@Z PROC				; operator<

; 1630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1631 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1632 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1633 :    return( zDecN < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1634 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDDVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??M@YGDVZDecimal@@D@Z PROC				; operator<

; 1622 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1623 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1624 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1625 :    return( zDec < zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1626 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@D@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??M@YGDIVZDecimal@@@Z PROC				; operator<

; 1614 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1615 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1616 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1617 :    return( zDecN < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1618 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDIVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??M@YGDVZDecimal@@I@Z PROC				; operator<

; 1606 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1607 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1608 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1609 :    return( zDec < zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1610 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@I@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??M@YGDHVZDecimal@@@Z PROC				; operator<

; 1598 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1599 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1600 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1601 :    return( zDecN < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1602 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDHVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??M@YGDVZDecimal@@H@Z PROC				; operator<

; 1590 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1591 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1592 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1593 :    return( zDec < zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1594 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@H@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??M@YGDVZDecimal@@G@Z PROC				; operator<

; 1582 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1583 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1584 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1585 :    return( zDec < zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1586 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@G@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??M@YGDGVZDecimal@@@Z PROC				; operator<

; 1574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1575 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1576 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1577 :    return( zDecN < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1578 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDGVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??M@YGDVZDecimal@@F@Z PROC				; operator<

; 1566 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1567 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1568 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1569 :    return( zDec < zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1570 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@F@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??M@YGDFVZDecimal@@@Z PROC				; operator<

; 1558 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1559 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1560 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1561 :    return( zDecN < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1562 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDFVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??M@YGDVZDecimal@@K@Z PROC				; operator<

; 1550 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1551 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1552 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1553 :    return( zDec < zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1554 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@K@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??M@YGDKVZDecimal@@@Z PROC				; operator<

; 1542 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1543 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1544 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1545 :    return( zDecL < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1546 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDKVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??M@YGDVZDecimal@@J@Z PROC				; operator<

; 1534 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1535 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1536 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1537 :    return( zDec < zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1538 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDVZDecimal@@J@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??M@YGDJVZDecimal@@@Z PROC				; operator<

; 1526 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1527 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1528 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1529 :    return( zDecL < zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??M@YGDVZDecimal@@0@Z			; operator<
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1530 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??M@YGDJVZDecimal@@@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??N@YGDVZDecimal@@M@Z PROC				; operator<=

; 1514 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1515 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1516 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1517 :    return( zDec <= zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1518 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@M@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??N@YGDMVZDecimal@@@Z PROC				; operator<=

; 1506 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1507 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1508 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1509 :    return( zDecD <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1510 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDMVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 8
??N@YGDVZDecimal@@N@Z PROC				; operator<=

; 1498 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1499 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1500 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1501 :    return( zDec <= zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1502 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??N@YGDVZDecimal@@N@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 8
_zDec$ = 16						; size = 144
??N@YGDNVZDecimal@@@Z PROC				; operator<=

; 1490 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1491 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1492 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1493 :    return( zDecD <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1494 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??N@YGDNVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??N@YGDVZDecimal@@E@Z PROC				; operator<=

; 1482 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1483 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1484 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1485 :    return( zDec <= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1486 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@E@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??N@YGDEVZDecimal@@@Z PROC				; operator<=

; 1474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1475 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1476 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1477 :    return( zDecN <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1478 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDEVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??N@YGDDVZDecimal@@@Z PROC				; operator<=

; 1466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1467 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1468 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1469 :    return( zDecN <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1470 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDDVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??N@YGDVZDecimal@@D@Z PROC				; operator<=

; 1458 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1459 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1460 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1461 :    return( zDec <= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1462 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@D@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??N@YGDIVZDecimal@@@Z PROC				; operator<=

; 1450 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1451 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1452 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1453 :    return( zDecN <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1454 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDIVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??N@YGDVZDecimal@@I@Z PROC				; operator<=

; 1442 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1443 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1444 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1445 :    return( zDec <= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1446 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@I@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??N@YGDHVZDecimal@@@Z PROC				; operator<=

; 1434 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1435 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1436 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1437 :    return( zDecN <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1438 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDHVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??N@YGDVZDecimal@@H@Z PROC				; operator<=

; 1426 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1427 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1428 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1429 :    return( zDec <= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1430 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@H@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??N@YGDVZDecimal@@G@Z PROC				; operator<=

; 1418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1419 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1420 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1421 :    return( zDec <= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1422 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@G@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??N@YGDGVZDecimal@@@Z PROC				; operator<=

; 1410 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1411 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1412 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1413 :    return( zDecN <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1414 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDGVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??N@YGDVZDecimal@@F@Z PROC				; operator<=

; 1402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1403 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1404 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1405 :    return( zDec <= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1406 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@F@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??N@YGDFVZDecimal@@@Z PROC				; operator<=

; 1394 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1395 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1396 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1397 :    return( zDecN <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1398 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDFVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??N@YGDVZDecimal@@K@Z PROC				; operator<=

; 1386 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1387 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1388 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1389 :    return( zDec <= zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1390 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@K@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??N@YGDKVZDecimal@@@Z PROC				; operator<=

; 1378 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1379 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1380 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1381 :    return( zDecL <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1382 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDKVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??N@YGDVZDecimal@@J@Z PROC				; operator<=

; 1370 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1371 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1372 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1373 :    return( zDec <= zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1374 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDVZDecimal@@J@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??N@YGDJVZDecimal@@@Z PROC				; operator<=

; 1362 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1363 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1364 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1365 :    return( zDecL <= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??N@YGDVZDecimal@@0@Z			; operator<=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1366 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??N@YGDJVZDecimal@@@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??O@YGDVZDecimal@@M@Z PROC				; operator>

; 1350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1351 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1352 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1353 :    return( zDec > zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1354 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@M@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??O@YGDMVZDecimal@@@Z PROC				; operator>

; 1342 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1343 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1344 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1345 :    return( zDecD > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1346 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDMVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 8
??O@YGDVZDecimal@@N@Z PROC				; operator>

; 1334 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1335 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1336 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1337 :    return( zDec > zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1338 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??O@YGDVZDecimal@@N@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 8
_zDec$ = 16						; size = 144
??O@YGDNVZDecimal@@@Z PROC				; operator>

; 1326 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1327 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1328 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1329 :    return( zDecD > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1330 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??O@YGDNVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??O@YGDVZDecimal@@E@Z PROC				; operator>

; 1318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1319 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1320 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1321 :    return( zDec > zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1322 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@E@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??O@YGDEVZDecimal@@@Z PROC				; operator>

; 1310 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1311 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1312 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1313 :    return( zDecN > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1314 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDEVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??O@YGDDVZDecimal@@@Z PROC				; operator>

; 1302 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1303 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1304 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1305 :    return( zDecN > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1306 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDDVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??O@YGDVZDecimal@@D@Z PROC				; operator>

; 1294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1295 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1296 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1297 :    return( zDec > zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1298 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@D@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??O@YGDIVZDecimal@@@Z PROC				; operator>

; 1286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1287 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1288 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1289 :    return( zDecN > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1290 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDIVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??O@YGDVZDecimal@@I@Z PROC				; operator>

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1279 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1280 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1281 :    return( zDec > zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1282 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@I@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??O@YGDHVZDecimal@@@Z PROC				; operator>

; 1270 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1271 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1272 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1273 :    return( zDecN > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1274 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDHVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??O@YGDVZDecimal@@H@Z PROC				; operator>

; 1262 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1263 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1264 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1265 :    return( zDec > zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1266 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@H@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??O@YGDVZDecimal@@G@Z PROC				; operator>

; 1254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1255 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1256 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1257 :    return( zDec > zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1258 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@G@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??O@YGDGVZDecimal@@@Z PROC				; operator>

; 1246 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1247 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1248 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1249 :    return( zDecN > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1250 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDGVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??O@YGDVZDecimal@@F@Z PROC				; operator>

; 1238 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1239 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1240 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1241 :    return( zDec > zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1242 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@F@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??O@YGDFVZDecimal@@@Z PROC				; operator>

; 1230 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1231 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1232 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1233 :    return( zDecN > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1234 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDFVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??O@YGDVZDecimal@@K@Z PROC				; operator>

; 1222 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1223 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1224 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1225 :    return( zDec > zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1226 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@K@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??O@YGDKVZDecimal@@@Z PROC				; operator>

; 1214 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1215 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1216 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1217 :    return( zDecL > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1218 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDKVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??O@YGDVZDecimal@@J@Z PROC				; operator>

; 1206 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1207 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1208 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1209 :    return( zDec > zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1210 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDVZDecimal@@J@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??O@YGDJVZDecimal@@@Z PROC				; operator>

; 1198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1199 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1200 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1201 :    return( zDecL > zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??O@YGDVZDecimal@@0@Z			; operator>
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1202 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??O@YGDJVZDecimal@@@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??P@YGDVZDecimal@@M@Z PROC				; operator>=

; 1186 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1187 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1188 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1189 :    return( zDec >= zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1190 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@M@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??P@YGDMVZDecimal@@@Z PROC				; operator>=

; 1178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1179 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1180 :    zDecD = (double) n;

	cvtss2sd xmm0, DWORD PTR _n$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1181 :    return( zDecD >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1182 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDMVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 8
??P@YGDVZDecimal@@N@Z PROC				; operator>=

; 1170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1171 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1172 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1173 :    return( zDec >= zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1174 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??P@YGDVZDecimal@@N@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecD$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 8
_zDec$ = 16						; size = 144
??P@YGDNVZDecimal@@@Z PROC				; operator>=

; 1162 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1163 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1164 :    zDecD = n;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _n$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1165 :    return( zDecD >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1166 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??P@YGDNVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??P@YGDVZDecimal@@E@Z PROC				; operator>=

; 1154 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1155 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1156 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1157 :    return( zDec >= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1158 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@E@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??P@YGDEVZDecimal@@@Z PROC				; operator>=

; 1146 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1147 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1148 :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1149 :    return( zDecN >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1150 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDEVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 1
_zDec$ = 12						; size = 144
??P@YGDDVZDecimal@@@Z PROC				; operator>=

; 1138 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1139 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1140 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1141 :    return( zDecN >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1142 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDDVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 1
??P@YGDVZDecimal@@D@Z PROC				; operator>=

; 1130 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1131 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1132 :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1133 :    return( zDec >= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1134 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@D@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??P@YGDIVZDecimal@@@Z PROC				; operator>=

; 1122 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1123 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1124 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1125 :    return( zDecN >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1126 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDIVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??P@YGDVZDecimal@@I@Z PROC				; operator>=

; 1114 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1115 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1116 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1117 :    return( zDec >= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1118 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@I@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 4
_zDec$ = 12						; size = 144
??P@YGDHVZDecimal@@@Z PROC				; operator>=

; 1106 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1107 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1108 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1109 :    return( zDecN >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1110 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDHVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 4
??P@YGDVZDecimal@@H@Z PROC				; operator>=

; 1098 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1099 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1100 :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1101 :    return( zDec >= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1102 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@H@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??P@YGDVZDecimal@@G@Z PROC				; operator>=

; 1090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1091 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1092 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1093 :    return( zDec >= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1094 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@G@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??P@YGDGVZDecimal@@@Z PROC				; operator>=

; 1082 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1083 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1084 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1085 :    return( zDecN >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1086 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDGVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_n$ = 152						; size = 2
??P@YGDVZDecimal@@F@Z PROC				; operator>=

; 1074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1075 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1076 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1077 :    return( zDec >= zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1078 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@F@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecN$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_n$ = 8							; size = 2
_zDec$ = 12						; size = 144
??P@YGDFVZDecimal@@@Z PROC				; operator>=

; 1066 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1067 :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1068 :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1069 :    return( zDecN >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1070 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDFVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??P@YGDVZDecimal@@K@Z PROC				; operator>=

; 1058 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1059 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1060 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1061 :    return( zDec >= zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1062 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@K@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??P@YGDKVZDecimal@@@Z PROC				; operator>=

; 1050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1051 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1052 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1053 :    return( zDecL >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1054 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDKVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
_l$ = 152						; size = 4
??P@YGDVZDecimal@@J@Z PROC				; operator>=

; 1042 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1043 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1044 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1045 :    return( zDec >= zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1046 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDVZDecimal@@J@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -293						; size = 1
$T2 = -292						; size = 144
_zDecL$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_l$ = 8							; size = 4
_zDec$ = 12						; size = 144
??P@YGDJVZDecimal@@@Z PROC				; operator>=

; 1034 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1035 :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1036 :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T2[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1037 :    return( zDecL >= zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	call	??P@YGDVZDecimal@@0@Z			; operator>=
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 1038 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??P@YGDJVZDecimal@@@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@MV0@@Z PROC				; operator/

; 1022 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1023 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1024 :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1025 :    return( zDecD / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1026 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@MV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 4
??K@YG?AVZDecimal@@V0@M@Z PROC				; operator/

; 1014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1015 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1016 :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1017 :    return( zDec / zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1018 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@M@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 8
_zDec$ = 20						; size = 144
??K@YG?AVZDecimal@@NV0@@Z PROC				; operator/

; 1006 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1007 :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1008 :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1009 :    return( zDecD / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1010 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??K@YG?AVZDecimal@@NV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??K@YG?AVZDecimal@@V0@N@Z PROC				; operator/

; 998  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 999  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 1000 :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 1001 :    return( zDec / zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1002 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??K@YG?AVZDecimal@@V0@N@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@EV0@@Z PROC				; operator/

; 990  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 991  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 992  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 993  :    return( zDecN / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 994  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@EV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??K@YG?AVZDecimal@@V0@E@Z PROC				; operator/

; 982  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 983  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 984  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 985  :    return( zDec / zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 986  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@E@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@DV0@@Z PROC				; operator/

; 974  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 975  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 976  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 977  :    return( zDecN / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 978  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@DV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??K@YG?AVZDecimal@@V0@D@Z PROC				; operator/

; 966  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 967  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 968  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 969  :    return( zDec / zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 970  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@D@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@IV0@@Z PROC				; operator/

; 958  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 959  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 960  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 961  :    return( zDecN / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 962  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@IV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??K@YG?AVZDecimal@@V0@I@Z PROC				; operator/

; 950  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 951  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 952  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 953  :    return( zDec / zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 954  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@I@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@HV0@@Z PROC				; operator/

; 942  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 943  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 944  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 945  :    return( zDecN / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 946  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@HV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??K@YG?AVZDecimal@@V0@H@Z PROC				; operator/

; 934  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 935  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 936  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 937  :    return( zDec / zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 938  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@H@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@GV0@@Z PROC				; operator/

; 926  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 927  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 928  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 929  :    return( zDecN / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 930  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@GV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??K@YG?AVZDecimal@@V0@G@Z PROC				; operator/

; 918  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 919  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 920  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 921  :    return( zDec / zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 922  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@G@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@FV0@@Z PROC				; operator/

; 910  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 911  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 912  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 913  :    return( zDecN / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@FV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??K@YG?AVZDecimal@@V0@F@Z PROC				; operator/

; 902  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 903  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 904  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 905  :    return( zDec / zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 906  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@F@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@KV0@@Z PROC				; operator/

; 894  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 895  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 896  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 897  :    return( zDecL / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 898  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@KV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??K@YG?AVZDecimal@@V0@K@Z PROC				; operator/

; 886  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 887  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 888  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 889  :    return( zDec / zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 890  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@K@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??K@YG?AVZDecimal@@JV0@@Z PROC				; operator/

; 878  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 879  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 880  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 881  :    return( zDecL / zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 882  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@JV0@@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??K@YG?AVZDecimal@@V0@J@Z PROC				; operator/

; 870  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 871  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 872  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 873  :    return( zDec / zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??K@YG?AVZDecimal@@V0@0@Z		; operator/
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 874  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??K@YG?AVZDecimal@@V0@J@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zTemp$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_zDec2$ = 156						; size = 144
??K@YG?AVZDecimal@@V0@0@Z PROC				; operator/

; 860  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 861  :    ZDecimal zTemp;

	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 862  : 
; 863  :    SysDivideDecimalByDecimal( &zTemp, &zDec, &zDec2 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	push	ecx
	lea	edx, DWORD PTR _zTemp$[ebp]
	push	edx
	call	_SysDivideDecimalByDecimal@12

; 864  : 
; 865  :    return( zTemp );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zTemp$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 866  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	292					; 00000124H
??K@YG?AVZDecimal@@V0@0@Z ENDP				; operator/
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@MV0@@Z PROC				; operator*

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 849  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 850  :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 851  :    return( zDecD * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 852  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@MV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 4
??D@YG?AVZDecimal@@V0@M@Z PROC				; operator*

; 840  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 841  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 842  :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 843  :    return( zDecD * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 844  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@M@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 8
_zDec$ = 20						; size = 144
??D@YG?AVZDecimal@@NV0@@Z PROC				; operator*

; 832  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 833  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 834  :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 835  :    return( zDecD * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 836  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??D@YG?AVZDecimal@@NV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??D@YG?AVZDecimal@@V0@N@Z PROC				; operator*

; 824  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 825  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 826  :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 827  :    return( zDecD * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 828  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??D@YG?AVZDecimal@@V0@N@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@EV0@@Z PROC				; operator*

; 816  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 817  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 818  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 819  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 820  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@EV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??D@YG?AVZDecimal@@V0@E@Z PROC				; operator*

; 808  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 809  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 810  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 811  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 812  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@E@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@DV0@@Z PROC				; operator*

; 800  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 801  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 802  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 803  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 804  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@DV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??D@YG?AVZDecimal@@V0@D@Z PROC				; operator*

; 792  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 793  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 794  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 795  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 796  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@D@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@IV0@@Z PROC				; operator*

; 784  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 785  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 786  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 787  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 788  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@IV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??D@YG?AVZDecimal@@V0@I@Z PROC				; operator*

; 776  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 777  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 778  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 779  :    return( zDec * zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 780  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@I@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@HV0@@Z PROC				; operator*

; 768  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 769  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 770  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 771  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 772  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@HV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??D@YG?AVZDecimal@@V0@H@Z PROC				; operator*

; 760  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 761  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 762  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 763  :    return( zDec * zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 764  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@H@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@GV0@@Z PROC				; operator*

; 752  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 753  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 754  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 755  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 756  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@GV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??D@YG?AVZDecimal@@V0@G@Z PROC				; operator*

; 744  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 745  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 746  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 747  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 748  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@G@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@FV0@@Z PROC				; operator*

; 736  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 737  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 738  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 739  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 740  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@FV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??D@YG?AVZDecimal@@V0@F@Z PROC				; operator*

; 728  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 729  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 730  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 731  :    return( zDecN * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 732  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@F@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@KV0@@Z PROC				; operator*

; 720  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 721  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 722  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 723  :    return( zDecL * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 724  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@KV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??D@YG?AVZDecimal@@V0@K@Z PROC				; operator*

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 713  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 714  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 715  :    return( zDecL * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 716  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@K@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??D@YG?AVZDecimal@@JV0@@Z PROC				; operator*

; 704  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 705  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 706  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 707  :    return( zDecL * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 708  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@JV0@@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??D@YG?AVZDecimal@@V0@J@Z PROC				; operator*

; 696  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 697  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 698  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 699  :    return( zDecL * zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??D@YG?AVZDecimal@@V0@0@Z		; operator*
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 700  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??D@YG?AVZDecimal@@V0@J@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zTemp$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_zDec2$ = 156						; size = 144
??D@YG?AVZDecimal@@V0@0@Z PROC				; operator*

; 687  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 688  :    ZDecimal zTemp;

	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 689  : 
; 690  :    SysMultiplyDecimalByDecimal( &zTemp, &zDec, &zDec2 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	push	ecx
	lea	edx, DWORD PTR _zTemp$[ebp]
	push	edx
	call	_SysMultiplyDecimalByDecimal@12

; 691  :    return( zTemp );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zTemp$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 692  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	292					; 00000124H
??D@YG?AVZDecimal@@V0@0@Z ENDP				; operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@MV0@@Z PROC				; operator-

; 675  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 676  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 677  :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 678  :    return( zDecD - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 679  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@MV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 4
??G@YG?AVZDecimal@@V0@M@Z PROC				; operator-

; 667  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 668  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 669  :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 670  :    return( zDec - zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 671  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@M@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 8
_zDec$ = 20						; size = 144
??G@YG?AVZDecimal@@NV0@@Z PROC				; operator-

; 659  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 660  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 661  :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 662  :    return( zDecD - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 663  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??G@YG?AVZDecimal@@NV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??G@YG?AVZDecimal@@V0@N@Z PROC				; operator-

; 651  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 652  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 653  :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 654  :    return( zDec - zDecD );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 655  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??G@YG?AVZDecimal@@V0@N@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@EV0@@Z PROC				; operator-

; 643  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 644  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 645  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 646  :    return( zDecN - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@EV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??G@YG?AVZDecimal@@V0@E@Z PROC				; operator-

; 635  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 636  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 637  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 638  :    return( zDec - zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 639  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@E@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@DV0@@Z PROC				; operator-

; 627  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 628  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 629  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 630  :    return( zDecN - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 631  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@DV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??G@YG?AVZDecimal@@V0@D@Z PROC				; operator-

; 619  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 620  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 621  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 622  :    return( zDec - zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 623  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@D@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@IV0@@Z PROC				; operator-

; 611  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 612  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 613  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 614  :    return( zDecN - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 615  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@IV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??G@YG?AVZDecimal@@V0@I@Z PROC				; operator-

; 603  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 604  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 605  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 606  :    return( zDec - zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 607  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@I@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@HV0@@Z PROC				; operator-

; 595  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 596  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 597  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 598  :    return( zDecN - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 599  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@HV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??G@YG?AVZDecimal@@V0@H@Z PROC				; operator-

; 587  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 588  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 589  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 590  :    return( zDec - zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 591  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@H@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@GV0@@Z PROC				; operator-

; 579  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 580  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 581  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 582  :    return( zDecN - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 583  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@GV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??G@YG?AVZDecimal@@V0@G@Z PROC				; operator-

; 571  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 572  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 573  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 574  :    return( zDec - zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 575  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@G@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@FV0@@Z PROC				; operator-

; 563  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 564  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 565  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 566  :    return( zDecN - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@FV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??G@YG?AVZDecimal@@V0@F@Z PROC				; operator-

; 555  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 556  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 557  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 558  :    return( zDec - zDecN );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 559  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@F@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@KV0@@Z PROC				; operator-

; 547  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 548  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 549  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 550  :    return( zDecL - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 551  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@KV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??G@YG?AVZDecimal@@V0@K@Z PROC				; operator-

; 539  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 540  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 541  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 542  :    return( zDec - zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 543  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@K@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??G@YG?AVZDecimal@@JV0@@Z PROC				; operator-

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 532  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 533  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 534  :    return( zDecL - zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 535  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@JV0@@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??G@YG?AVZDecimal@@V0@J@Z PROC				; operator-

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 524  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 525  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 526  :    return( zDec - zDecL );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??G@YG?AVZDecimal@@V0@0@Z		; operator-
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 527  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??G@YG?AVZDecimal@@V0@J@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zTemp$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_zDec2$ = 156						; size = 144
??G@YG?AVZDecimal@@V0@0@Z PROC				; operator-

; 514  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 515  :    ZDecimal zTemp;

	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 516  : 
; 517  :    SysSubtractDecimalFromDecimal( &zTemp, &zDec, &zDec2 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	push	ecx
	lea	edx, DWORD PTR _zTemp$[ebp]
	push	edx
	call	_SysSubtractDecimalFromDecimal@12

; 518  :    return( zTemp );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zTemp$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 519  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	292					; 00000124H
??G@YG?AVZDecimal@@V0@0@Z ENDP				; operator-
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 4
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@MV0@@Z PROC				; operator+

; 502  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 503  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 504  :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 505  :    return( zDecD + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 506  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@MV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 4
??H@YG?AVZDecimal@@V0@M@Z PROC				; operator+

; 494  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 495  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 496  :    zDecD = (double) d;

	cvtss2sd xmm0, DWORD PTR _d$[ebp]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 497  :    return( zDecD + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 498  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@M@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 8
_zDec$ = 20						; size = 144
??H@YG?AVZDecimal@@NV0@@Z PROC				; operator+

; 486  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 487  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 488  :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 489  :    return( zDecD + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 490  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??H@YG?AVZDecimal@@NV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecD$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_d$ = 156						; size = 8
??H@YG?AVZDecimal@@V0@N@Z PROC				; operator+

; 478  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 479  :    ZDecimal zDecD;

	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 480  :    zDecD = d;

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??4ZDecimal@@QAE?AV0@N@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 481  :    return( zDecD + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecD$[ebp]
	mov	edi, esp
	rep movsd
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecD$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 482  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
??H@YG?AVZDecimal@@V0@N@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@EV0@@Z PROC				; operator+

; 470  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 471  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 472  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 473  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 474  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@EV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??H@YG?AVZDecimal@@V0@E@Z PROC				; operator+

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 463  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 464  :    zDecN = (zSHORT) n;

	movzx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 465  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 466  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@E@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 1
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@DV0@@Z PROC				; operator+

; 454  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 455  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 456  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 457  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 458  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@DV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 1
??H@YG?AVZDecimal@@V0@D@Z PROC				; operator+

; 446  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 447  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 448  :    zDecN = (zSHORT) n;

	movsx	ax, BYTE PTR _n$[ebp]
	movzx	ecx, ax
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 449  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 450  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@D@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@IV0@@Z PROC				; operator+

; 438  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 439  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 440  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 441  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 442  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@IV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??H@YG?AVZDecimal@@V0@I@Z PROC				; operator+

; 430  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 431  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 432  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 433  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 434  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@I@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@HV0@@Z PROC				; operator+

; 422  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 423  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 424  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 425  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 426  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@HV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 4
??H@YG?AVZDecimal@@V0@H@Z PROC				; operator+

; 414  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 415  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 416  :    zDecN = (zLONG) n;

	mov	eax, DWORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 417  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 418  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@H@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@GV0@@Z PROC				; operator+

; 406  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 407  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 408  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 409  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 410  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@GV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??H@YG?AVZDecimal@@V0@G@Z PROC				; operator+

; 398  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 399  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 400  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@G@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 401  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 402  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@G@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@FV0@@Z PROC				; operator+

; 390  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 391  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 392  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 393  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 394  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@FV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecN$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_n$ = 156						; size = 2
??H@YG?AVZDecimal@@V0@F@Z PROC				; operator+

; 382  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 383  :    ZDecimal zDecN;

	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 384  :    zDecN = n;

	movzx	eax, WORD PTR _n$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??4ZDecimal@@QAE?AV0@F@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 385  :    return( zDecN + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecN$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecN$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 386  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@F@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@KV0@@Z PROC				; operator+

; 374  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 375  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 376  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 377  :    return( zDecL + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 378  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@KV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??H@YG?AVZDecimal@@V0@K@Z PROC				; operator+

; 366  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 367  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 368  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@K@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 369  :    return( zDecL + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 370  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@K@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
_zDec$ = 16						; size = 144
??H@YG?AVZDecimal@@JV0@@Z PROC				; operator+

; 358  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 359  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 360  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 361  :    return( zDecL + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 362  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@JV0@@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zDecL$ = -292						; size = 144
$T1 = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_l$ = 156						; size = 4
??H@YG?AVZDecimal@@V0@J@Z PROC				; operator+

; 350  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 351  :    ZDecimal zDecL;

	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 352  :    zDecL = l;

	mov	eax, DWORD PTR _l$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??4ZDecimal@@QAE?AV0@J@Z		; ZDecimal::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal

; 353  :    return( zDecL + zDec );

	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, esp
	rep movsd
	sub	esp, 144				; 00000090H
	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zDecL$[ebp]
	mov	edi, esp
	rep movsd
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??H@YG?AVZDecimal@@V0@0@Z		; operator+
	lea	ecx, DWORD PTR _zDecL$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 354  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	152					; 00000098H
??H@YG?AVZDecimal@@V0@J@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_zTemp$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
_zDec2$ = 156						; size = 144
??H@YG?AVZDecimal@@V0@0@Z PROC				; operator+

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 342  :    ZDecimal zTemp;

	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??0ZDecimal@@QAE@XZ			; ZDecimal::ZDecimal

; 343  : 
; 344  :    SysAddDecimalToDecimal( &zTemp, &zDec, &zDec2 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec$[ebp]
	push	ecx
	lea	edx, DWORD PTR _zTemp$[ebp]
	push	edx
	call	_SysAddDecimalToDecimal@12

; 345  :    return( zTemp );

	mov	ecx, 36					; 00000024H
	lea	esi, DWORD PTR _zTemp$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 346  : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	292					; 00000124H
??H@YG?AVZDecimal@@V0@0@Z ENDP				; operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -150						; size = 1
tv82 = -149						; size = 1
_zTemp$ = -148						; size = 144
__$ArrayPad$ = -4					; size = 4
_zDec$ = 8						; size = 144
??7@YGDVZDecimal@@@Z PROC				; operator!

; 329  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 330  :    ZDecimal zTemp = 0;

	push	0
	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??0ZDecimal@@QAE@H@Z			; ZDecimal::ZDecimal

; 331  : 
; 332  :    return( SysCompareDecimalToDecimal( &zTemp, &zDec ) == 0 );

	lea	eax, DWORD PTR _zDec$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zTemp$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	BYTE PTR tv82[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv82[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv82[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zTemp$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 333  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	144					; 00000090H
??7@YGDVZDecimal@@@Z ENDP				; operator!
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 1
tv79 = -1						; size = 1
_zDec1$ = 8						; size = 144
_zDec2$ = 152						; size = 144
??9@YGDVZDecimal@@0@Z PROC				; operator!=

; 323  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 324  :    return( SysCompareDecimalToDecimal( &zDec1, &zDec2 ) != 0 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec1$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@operator
	mov	BYTE PTR tv79[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv79[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv79[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDec1$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 325  : }

	mov	esp, ebp
	pop	ebp
	ret	288					; 00000120H
??9@YGDVZDecimal@@0@Z ENDP				; operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 1
tv79 = -1						; size = 1
_zDec1$ = 8						; size = 144
_zDec2$ = 152						; size = 144
??8@YGDVZDecimal@@0@Z PROC				; operator==

; 317  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 318  :    return( SysCompareDecimalToDecimal( &zDec1, &zDec2 ) == 0 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec1$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN3@operator
	mov	BYTE PTR tv79[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv79[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv79[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDec1$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 319  : }

	mov	esp, ebp
	pop	ebp
	ret	288					; 00000120H
??8@YGDVZDecimal@@0@Z ENDP				; operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 1
tv79 = -1						; size = 1
_zDec1$ = 8						; size = 144
_zDec2$ = 152						; size = 144
??O@YGDVZDecimal@@0@Z PROC				; operator>

; 311  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 312  :    return( SysCompareDecimalToDecimal( &zDec1, &zDec2 ) > 0 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec1$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jle	SHORT $LN3@operator
	mov	BYTE PTR tv79[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv79[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv79[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDec1$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 313  : }

	mov	esp, ebp
	pop	ebp
	ret	288					; 00000120H
??O@YGDVZDecimal@@0@Z ENDP				; operator>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 1
tv79 = -1						; size = 1
_zDec1$ = 8						; size = 144
_zDec2$ = 152						; size = 144
??P@YGDVZDecimal@@0@Z PROC				; operator>=

; 305  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 306  :    return( SysCompareDecimalToDecimal( &zDec1, &zDec2 ) >= 0 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec1$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jl	SHORT $LN3@operator
	mov	BYTE PTR tv79[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv79[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv79[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDec1$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 307  : }

	mov	esp, ebp
	pop	ebp
	ret	288					; 00000120H
??P@YGDVZDecimal@@0@Z ENDP				; operator>=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 1
tv79 = -1						; size = 1
_zDec1$ = 8						; size = 144
_zDec2$ = 152						; size = 144
??M@YGDVZDecimal@@0@Z PROC				; operator<

; 299  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 300  :    return( SysCompareDecimalToDecimal( &zDec1, &zDec2 ) < 0 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec1$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN3@operator
	mov	BYTE PTR tv79[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv79[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv79[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDec1$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 301  : }

	mov	esp, ebp
	pop	ebp
	ret	288					; 00000120H
??M@YGDVZDecimal@@0@Z ENDP				; operator<
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
$T1 = -2						; size = 1
tv79 = -1						; size = 1
_zDec1$ = 8						; size = 144
_zDec2$ = 152						; size = 144
??N@YGDVZDecimal@@0@Z PROC				; operator<=

; 293  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 294  :    return( SysCompareDecimalToDecimal( &zDec1, &zDec2 ) <= 0 );

	lea	eax, DWORD PTR _zDec2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zDec1$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	movsx	edx, ax
	test	edx, edx
	jg	SHORT $LN3@operator
	mov	BYTE PTR tv79[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	BYTE PTR tv79[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv79[ebp]
	mov	BYTE PTR $T1[ebp], al
	lea	ecx, DWORD PTR _zDec1$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	lea	ecx, DWORD PTR _zDec2$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	al, BYTE PTR $T1[ebp]

; 295  : }

	mov	esp, ebp
	pop	ebp
	ret	288					; 00000120H
??N@YGDVZDecimal@@0@Z ENDP				; operator<=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv72 = -1						; size = 1
?IsNull@ZDecimal@@QAEEXZ PROC				; ZDecimal::IsNull
; _this$ = ecx

; 287  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 288  :    return( SysCompareDecimalToNull( this ) == 0 );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN3@IsNull
	mov	BYTE PTR tv72[ebp], 1
	jmp	SHORT $LN4@IsNull
$LN3@IsNull:
	mov	BYTE PTR tv72[ebp], 0
$LN4@IsNull:
	mov	al, BYTE PTR tv72[ebp]

; 289  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?IsNull@ZDecimal@@QAEEXZ ENDP				; ZDecimal::IsNull
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BZDecimal@@QAEPADXZ PROC				; ZDecimal::operator char *
; _this$ = ecx

; 276  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  :    SysConvertDecimalToString( this, this->szValue, 10 );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysConvertDecimalToString@12

; 278  :    return( this->szValue );

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 40					; 00000028H

; 279  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BZDecimal@@QAEPADXZ ENDP				; ZDecimal::operator char *
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_l$ = -8						; size = 4
_this$ = -4						; size = 4
??BZDecimal@@QAEGXZ PROC				; ZDecimal::operator unsigned short
; _this$ = ecx

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 269  :    zLONG l;
; 270  : 
; 271  :    SysConvertDecimalToLong( this, &l );

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8

; 272  :    return( (zUSHORT) l );

	mov	ax, WORD PTR _l$[ebp]

; 273  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BZDecimal@@QAEGXZ ENDP				; ZDecimal::operator unsigned short
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_l$ = -8						; size = 4
_this$ = -4						; size = 4
??BZDecimal@@QAEFXZ PROC				; ZDecimal::operator short
; _this$ = ecx

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 261  :    zLONG l;
; 262  : 
; 263  :    SysConvertDecimalToLong( this, &l );

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8

; 264  :    return( (zSHORT) l );

	mov	ax, WORD PTR _l$[ebp]

; 265  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BZDecimal@@QAEFXZ ENDP				; ZDecimal::operator short
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_l$ = -8						; size = 4
_this$ = -4						; size = 4
??BZDecimal@@QAEKXZ PROC				; ZDecimal::operator unsigned long
; _this$ = ecx

; 252  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 253  :    zULONG l;
; 254  : 
; 255  :    SysConvertDecimalToLong( this, (zPLONG) &l );

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8

; 256  :    return( l );

	mov	eax, DWORD PTR _l$[ebp]

; 257  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BZDecimal@@QAEKXZ ENDP				; ZDecimal::operator unsigned long
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_l$ = -8						; size = 4
_this$ = -4						; size = 4
??BZDecimal@@QAEJXZ PROC				; ZDecimal::operator long
; _this$ = ecx

; 244  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 245  :    zLONG l;
; 246  : 
; 247  :    SysConvertDecimalToLong( this, &l );

	lea	eax, DWORD PTR _l$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8

; 248  :    return( l );

	mov	eax, DWORD PTR _l$[ebp]

; 249  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BZDecimal@@QAEJXZ ENDP				; ZDecimal::operator long
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_d$ = -12						; size = 8
_this$ = -4						; size = 4
??BZDecimal@@QAENXZ PROC				; ZDecimal::operator double
; _this$ = ecx

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 237  :    double d;
; 238  : 
; 239  :    SysConvertDecimalToDouble( this, &d );

	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysConvertDecimalToDouble@8

; 240  :    return( d );

	fld	QWORD PTR _d$[ebp]

; 241  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??BZDecimal@@QAENXZ ENDP				; ZDecimal::operator double
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@I@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 198  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 199  :    SysConvertLongToDecimal( (zLONG) i, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 200  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 201  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@I@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@H@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 191  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 192  :    SysConvertLongToDecimal( (zLONG) i, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 193  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 194  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@H@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_zPDEC$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@PAUDecimalStruct@@@Z PROC		; ZDecimal::operator=
; _this$ = ecx

; 149  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 150  :    SysAssignDecimalFromDecimal( this, zPDEC );

	mov	eax, DWORD PTR _zPDEC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysAssignDecimalFromDecimal@8

; 151  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 152  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@PAUDecimalStruct@@@Z ENDP		; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDEC$ = 12						; size = 40
??4ZDecimal@@QAE?AV0@UDecimalStruct@@@Z PROC		; ZDecimal::operator=
; _this$ = ecx

; 142  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 143  :    SysAssignDecimalFromDecimal( this, &zDEC );

	lea	eax, DWORD PTR _zDEC$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysAssignDecimalFromDecimal@8

; 144  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 145  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
??4ZDecimal@@QAE?AV0@UDecimalStruct@@@Z ENDP		; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pv$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@PAX@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 156  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 157  :    SysAssignDecimalFromDecimal( this, (zPDECIMAL) pv );

	mov	eax, DWORD PTR _pv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysAssignDecimalFromDecimal@8

; 158  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 159  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@PAX@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pszStr$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@PBD@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 226  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 227  :    SysConvertStringToDecimal( pszStr, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszStr$[ebp]
	push	ecx
	call	_SysConvertStringToDecimal@8

; 228  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 229  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@PBD@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pszStr$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@PAD@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 219  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 220  :    SysConvertStringToDecimal( pszStr, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszStr$[ebp]
	push	ecx
	call	_SysConvertStringToDecimal@8

; 221  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 222  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@PAD@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 8
??4ZDecimal@@QBE?AV0@N@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 212  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 213  :    SysConvertDoubleToDecimal( (double) d, (zPDECIMAL) this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_SysConvertDoubleToDecimal@12

; 214  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 215  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??4ZDecimal@@QBE?AV0@N@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_d$ = 12						; size = 8
??4ZDecimal@@QAE?AV0@N@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 205  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 206  :    SysConvertDoubleToDecimal( d, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_SysConvertDoubleToDecimal@12

; 207  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 208  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??4ZDecimal@@QAE?AV0@N@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
??4ZDecimal@@QAE?AV0@G@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 184  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 185  :    SysConvertLongToDecimal( (zLONG) n, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	movzx	ecx, WORD PTR _n$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 186  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 187  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@G@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 2
??4ZDecimal@@QAE?AV0@F@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 177  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 178  :    SysConvertLongToDecimal( (zLONG) n, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	movsx	ecx, WORD PTR _n$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 179  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 180  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@F@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@K@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 170  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 171  :    SysConvertLongToDecimal( (zLONG) l, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 172  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 173  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@K@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_l$ = 12						; size = 4
??4ZDecimal@@QAE?AV0@J@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 163  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 164  :    SysConvertLongToDecimal( l, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 165  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 166  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??4ZDecimal@@QAE?AV0@J@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_zDec$ = 12						; size = 144
??4ZDecimal@@QAE?AV0@V0@@Z PROC				; ZDecimal::operator=
; _this$ = ecx

; 135  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 136  :    SysAssignDecimalFromDecimal( this, &zDec );

	lea	eax, DWORD PTR _zDec$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_SysAssignDecimalFromDecimal@8

; 137  :    return( *this );

	mov	ecx, 36					; 00000024H
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	rep movsd
	lea	ecx, DWORD PTR _zDec$[ebp]
	call	??1ZDecimal@@QAE@XZ			; ZDecimal::~ZDecimal
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 138  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	148					; 00000094H
??4ZDecimal@@QAE?AV0@V0@@Z ENDP				; ZDecimal::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ZDecimal@@QAE@XZ PROC				; ZDecimal::~ZDecimal
; _this$ = ecx

; 126  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 127  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1ZDecimal@@QAE@XZ ENDP				; ZDecimal::~ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszStr$ = 8						; size = 4
??0ZDecimal@@QAE@PBD@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 86   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 87   :    SysConvertStringToDecimal( pszStr, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszStr$[ebp]
	push	ecx
	call	_SysConvertStringToDecimal@8

; 88   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@PBD@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_k$ = 8							; size = 4
??0ZDecimal@@QAE@I@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 121  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  :    SysConvertLongToDecimal( (zLONG) k, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 123  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@I@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_k$ = 8							; size = 4
??0ZDecimal@@QAE@H@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 116  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 117  :    SysConvertLongToDecimal( (zLONG) k, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 118  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@H@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_d$ = 8							; size = 8
??0ZDecimal@@QAE@N@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 111  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 112  :    SysConvertDoubleToDecimal( d, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_SysConvertDoubleToDecimal@12

; 113  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0ZDecimal@@QAE@N@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 2
??0ZDecimal@@QAE@G@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 106  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  :    SysConvertLongToDecimal( (zLONG) n, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	movzx	ecx, WORD PTR _n$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 108  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@G@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 2
??0ZDecimal@@QAE@F@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 101  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  :    SysConvertLongToDecimal( (zLONG) n, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	movsx	ecx, WORD PTR _n$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 103  : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@F@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
??0ZDecimal@@QAE@K@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 96   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 97   :    SysConvertLongToDecimal( (zULONG) l, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 98   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@K@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_l$ = 8							; size = 4
??0ZDecimal@@QAE@J@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 91   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   :    SysConvertLongToDecimal( l, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 93   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@J@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pszStr$ = 8						; size = 4
??0ZDecimal@@QAE@PAD@Z PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 81   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   :    SysConvertStringToDecimal( pszStr, this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszStr$[ebp]
	push	ecx
	call	_SysConvertStringToDecimal@8

; 83   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@PAD@Z ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pDEC$ = -8						; size = 4
_this$ = -4						; size = 4
_zDec$ = 8						; size = 4
??0ZDecimal@@QAE@PAUDecimalStruct@@@Z PROC		; ZDecimal::ZDecimal
; _this$ = ecx

; 74   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 75   :    zDECIMAL *pDEC = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pDEC$[ebp], eax

; 76   :    *pDEC = *zDec;

	mov	ecx, 10					; 0000000aH
	mov	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR _pDEC$[ebp]
	rep movsd

; 77   : // this->dDecValue = *zDec;
; 78   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0ZDecimal@@QAE@PAUDecimalStruct@@@Z ENDP		; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pDEC$ = -8						; size = 4
_this$ = -4						; size = 4
_zDec$ = 8						; size = 40
??0ZDecimal@@QAE@UDecimalStruct@@@Z PROC		; ZDecimal::ZDecimal
; _this$ = ecx

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 68   :    zDECIMAL *pDEC = this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR _pDEC$[ebp], eax

; 69   :    *pDEC = zDec;

	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _zDec$[ebp]
	mov	edi, DWORD PTR _pDEC$[ebp]
	rep movsd

; 70   : // this->dDecValue = zDec;
; 71   : }

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
??0ZDecimal@@QAE@UDecimalStruct@@@Z ENDP		; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ZDecimal@@QAE@XZ PROC				; ZDecimal::ZDecimal
; _this$ = ecx

; 62   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   :    SysAssignDecimalFromNull( this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	_SysAssignDecimalFromNull@4

; 64   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ZDecimal@@QAE@XZ ENDP				; ZDecimal::ZDecimal
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdResult$ = 8						; size = 4
_pdDec1$ = 12						; size = 4
_pdDec2$ = 16						; size = 4
_SysSubtractDecimalFromDecimal@12 PROC

; 3528 : {

	push	ebp
	mov	ebp, esp

; 3529 :    return( fnCallDecOper( pdResult, pdDec1, pdDec2, zDEC_CMD_SUBDEC ) );

	push	17					; 00000011H
	mov	eax, DWORD PTR _pdDec2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdDec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdResult$[ebp]
	push	edx
	call	_fnCallDecOper@16

; 3530 : }

	pop	ebp
	ret	12					; 0000000cH
_SysSubtractDecimalFromDecimal@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pd$ = 8						; size = 4
_nPrecision$ = 12					; size = 2
_SysRoundDecimal@8 PROC

; 3551 : {

	push	ebp
	mov	ebp, esp

; 3552 :    return( fnCallDecOper( pd, pd, &nPrecision, zDEC_CMD_ROUND ) );

	push	20					; 00000014H
	lea	eax, DWORD PTR _nPrecision$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pd$[ebp]
	push	edx
	call	_fnCallDecOper@16

; 3553 : }

	pop	ebp
	ret	8
_SysRoundDecimal@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdResult$ = 8						; size = 4
_pdDec1$ = 12						; size = 4
_pdDec2$ = 16						; size = 4
_SysMultiplyDecimalByDecimal@12 PROC

; 3536 : {

	push	ebp
	mov	ebp, esp

; 3537 :    return( fnCallDecOper( pdResult, pdDec1, pdDec2, zDEC_CMD_MULTDEC ) );

	push	18					; 00000012H
	mov	eax, DWORD PTR _pdDec2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdDec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdResult$[ebp]
	push	edx
	call	_fnCallDecOper@16

; 3538 : }

	pop	ebp
	ret	12					; 0000000cH
_SysMultiplyDecimalByDecimal@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdResult$ = 8						; size = 4
_pdDec1$ = 12						; size = 4
_pdDec2$ = 16						; size = 4
_SysDivideDecimalByDecimal@12 PROC

; 3544 : {

	push	ebp
	mov	ebp, esp

; 3545 :    return( fnCallDecOper( pdResult, pdDec1, pdDec2, zDEC_CMD_DIVDEC ) );

	push	19					; 00000013H
	mov	eax, DWORD PTR _pdDec2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdDec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdResult$[ebp]
	push	edx
	call	_fnCallDecOper@16

; 3546 : }

	pop	ebp
	ret	12					; 0000000cH
_SysDivideDecimalByDecimal@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pszString$ = 8						; size = 4
_pdDecimal$ = 12					; size = 4
_SysConvertStringToDecimal@8 PROC

; 3483 : {

	push	ebp
	mov	ebp, esp

; 3484 :    return( fnCallDecOper( pdDecimal, 0, (zPVOID) pszString,

	push	49					; 00000031H
	mov	eax, DWORD PTR _pszString$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pdDecimal$[ebp]
	push	ecx
	call	_fnCallDecOper@16

; 3485 :                           zDEC_CMD_STRINGTODEC ) );
; 3486 : }

	pop	ebp
	ret	8
_SysConvertStringToDecimal@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_lLong$ = 8						; size = 4
_pdDecimal$ = 12					; size = 4
_SysConvertLongToDecimal@8 PROC

; 3491 : {

	push	ebp
	mov	ebp, esp

; 3492 :    return( fnCallDecOper( pdDecimal, 0, &lLong, zDEC_CMD_LONGTODEC ) );

	push	51					; 00000033H
	lea	eax, DWORD PTR _lLong$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pdDecimal$[ebp]
	push	ecx
	call	_fnCallDecOper@16

; 3493 : }

	pop	ebp
	ret	8
_SysConvertLongToDecimal@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_dDouble$ = 8						; size = 8
_pdDecimal$ = 16					; size = 4
_SysConvertDoubleToDecimal@12 PROC

; 3512 : {

	push	ebp
	mov	ebp, esp

; 3513 :    return( fnCallDecOper( pdDecimal, 0, &dDouble, zDEC_CMD_DOUBLETODEC ) );

	push	53					; 00000035H
	lea	eax, DWORD PTR _dDouble$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pdDecimal$[ebp]
	push	ecx
	call	_fnCallDecOper@16

; 3514 : }

	pop	ebp
	ret	12					; 0000000cH
_SysConvertDoubleToDecimal@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdDecimal$ = 8						; size = 4
_pszString$ = 12					; size = 4
_nPrecision$ = 16					; size = 2
_SysConvertDecimalToString@12 PROC

; 3476 : {

	push	ebp
	mov	ebp, esp

; 3477 :    return( fnCallDecOper( pszString, pdDecimal, &nPrecision,

	push	48					; 00000030H
	lea	eax, DWORD PTR _nPrecision$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdDecimal$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszString$[ebp]
	push	edx
	call	_fnCallDecOper@16

; 3478 :                           zDEC_CMD_DECTOSTRING ) );
; 3479 : }

	pop	ebp
	ret	12					; 0000000cH
_SysConvertDecimalToString@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdDecimal$ = 8						; size = 4
_pdDouble$ = 12						; size = 4
_SysConvertDecimalToDouble@8 PROC

; 3505 : {

	push	ebp
	mov	ebp, esp

; 3506 :    return( fnCallDecOper( pdDouble, pdDecimal, 0, zDEC_CMD_DECTODOUBLE ) );

	push	52					; 00000034H
	push	0
	mov	eax, DWORD PTR _pdDecimal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdDouble$[ebp]
	push	ecx
	call	_fnCallDecOper@16

; 3507 : }

	pop	ebp
	ret	8
_SysConvertDecimalToDouble@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdSource$ = 8						; size = 4
_SysCompareDecimalToNull@4 PROC

; 3468 : {

	push	ebp
	mov	ebp, esp

; 3469 :    return( fnCallDecOper( 0, pdSource, 0, zDEC_CMD_COMPARENULL ) );

	push	4
	push	0
	mov	eax, DWORD PTR _pdSource$[ebp]
	push	eax
	push	0
	call	_fnCallDecOper@16

; 3470 : }

	pop	ebp
	ret	4
_SysCompareDecimalToNull@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdDecimal$ = 8						; size = 4
_plLong$ = 12						; size = 4
_SysConvertDecimalToLong@8 PROC

; 3498 : {

	push	ebp
	mov	ebp, esp

; 3499 :    return( fnCallDecOper( plLong, pdDecimal, 0, zDEC_CMD_DECTOLONG ) );

	push	50					; 00000032H
	push	0
	mov	eax, DWORD PTR _pdDecimal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plLong$[ebp]
	push	ecx
	call	_fnCallDecOper@16

; 3500 : }

	pop	ebp
	ret	8
_SysConvertDecimalToLong@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdTarget$ = 8						; size = 4
_dSource$ = 12						; size = 8
_SysCompareDecimalToDouble@12 PROC

; 3462 : {

	push	ebp
	mov	ebp, esp

; 3463 :    return( fnCallDecOper( 0, pdTarget, &dSource, zDEC_CMD_COMPAREDOUBLE ) );

	push	5
	lea	eax, DWORD PTR _dSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdTarget$[ebp]
	push	ecx
	push	0
	call	_fnCallDecOper@16

; 3464 : }

	pop	ebp
	ret	12					; 0000000cH
_SysCompareDecimalToDouble@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdTarget$ = 8						; size = 4
_pdSource$ = 12						; size = 4
_SysCompareDecimalToDecimal@8 PROC

; 3455 : {

	push	ebp
	mov	ebp, esp

; 3456 :    return( fnCallDecOper( 0, pdTarget, pdSource, zDEC_CMD_COMPAREDEC ) );

	push	2
	mov	eax, DWORD PTR _pdSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdTarget$[ebp]
	push	ecx
	push	0
	call	_fnCallDecOper@16

; 3457 : }

	pop	ebp
	ret	8
_SysCompareDecimalToDecimal@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pvReturn$ = 8						; size = 4
_pvDecimal$ = 12					; size = 4
_pvInfo$ = 16						; size = 4
_lControl$ = 20						; size = 4
_SysCallDecimalOperation@16 PROC

; 3435 : {

	push	ebp
	mov	ebp, esp

; 3436 :    return( fnCallDecOper( pvReturn, pvDecimal, pvInfo, lControl ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvDecimal$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturn$[ebp]
	push	eax
	call	_fnCallDecOper@16

; 3437 : }

	pop	ebp
	ret	16					; 00000010H
_SysCallDecimalOperation@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdTarget$ = 8						; size = 4
_SysAssignDecimalFromNull@4 PROC

; 3448 : {

	push	ebp
	mov	ebp, esp

; 3449 :    return( fnCallDecOper( pdTarget, 0, 0, zDEC_CMD_ASSIGNNULL ) );

	push	3
	push	0
	push	0
	mov	eax, DWORD PTR _pdTarget$[ebp]
	push	eax
	call	_fnCallDecOper@16

; 3450 : }

	pop	ebp
	ret	4
_SysAssignDecimalFromNull@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdTarget$ = 8						; size = 4
_pdSource$ = 12						; size = 4
_SysAssignDecimalFromDecimal@8 PROC

; 3442 : {

	push	ebp
	mov	ebp, esp

; 3443 :    return( fnCallDecOper( pdTarget, pdSource, 0, zDEC_CMD_ASSIGNDEC ) );

	push	1
	push	0
	mov	eax, DWORD PTR _pdSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdTarget$[ebp]
	push	ecx
	call	_fnCallDecOper@16

; 3444 : }

	pop	ebp
	ret	8
_SysAssignDecimalFromDecimal@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pdResult$ = 8						; size = 4
_pdDec1$ = 12						; size = 4
_pdDec2$ = 16						; size = 4
_SysAddDecimalToDecimal@12 PROC

; 3520 : {

	push	ebp
	mov	ebp, esp

; 3521 :    return( fnCallDecOper( pdResult, pdDec1, pdDec2, zDEC_CMD_ADDDEC ) );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pdDec2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdDec1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdResult$[ebp]
	push	edx
	call	_fnCallDecOper@16

; 3522 : }

	pop	ebp
	ret	12					; 0000000cH
_SysAddDecimalToDecimal@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_pchKey$ = 16						; size = 4
_uLth$ = 20						; size = 2
_UfDecryptStringUL@16 PROC

; 3253 : {

	push	ebp
	mov	ebp, esp

; 3254 :    return( fnDecryptStringUL( pchOut, pchIn, pchKey, uLth, TRUE ) );

	push	1
	movzx	eax, WORD PTR _uLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchIn$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchOut$[ebp]
	push	eax
	call	?fnDecryptStringUL@@YGFPAD00GE@Z	; fnDecryptStringUL

; 3255 : }

	pop	ebp
	ret	16					; 00000010H
_UfDecryptStringUL@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_pchKey$ = 16						; size = 4
_uLth$ = 20						; size = 2
_UfEncryptStringUL@16 PROC

; 3065 : {

	push	ebp
	mov	ebp, esp

; 3066 :    return( fnEncryptStringUL( pchOut, pchIn, pchKey, uLth, TRUE ) );

	push	1
	movzx	eax, WORD PTR _uLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchKey$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchIn$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchOut$[ebp]
	push	eax
	call	?fnEncryptStringUL@@YAFPAD00GE@Z	; fnEncryptStringUL
	add	esp, 20					; 00000014H

; 3067 : }

	pop	ebp
	ret	16					; 00000010H
_UfEncryptStringUL@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_nRC$ = -20						; size = 2
_uCurrLth$ = -16					; size = 2
_nInLth$ = -12						; size = 2
_nPos$ = -8						; size = 2
_ch$ = -1						; size = 1
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_pchKey$ = 16						; size = 4
_uLth$ = 20						; size = 2
_UfDecryptStringLong@16 PROC

; 3259 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3260 :    zCHAR   ch;
; 3261 :    zUSHORT uCurrLth;
; 3262 :    zSHORT  nInLth = zstrlen( pchIn );

	mov	eax, DWORD PTR _pchIn$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nInLth$[ebp], ax

; 3263 :    zSHORT  nPos = 0;

	xor	ecx, ecx
	mov	WORD PTR _nPos$[ebp], cx

; 3264 :    zSHORT  nRC;
; 3265 : 
; 3266 :    pchOut[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 3267 :    if ( nInLth > uLth )

	movsx	edx, WORD PTR _nInLth$[ebp]
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	edx, eax
	jle	SHORT $LN4@UfDecryptS

; 3268 :    {
; 3269 :       SysMessageBox( 0, "Zeidon Internal Error",

	push	0
	push	OFFSET $SG15914
	push	OFFSET $SG15915
	push	0
	call	_SysMessageBox@16

; 3270 :                      "Length Error Encrypting String", 0 );
; 3271 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@UfDecryptS
$LN4@UfDecryptS:

; 3272 :    }
; 3273 : 
; 3274 :    nRC = nInLth;

	mov	cx, WORD PTR _nInLth$[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN2@UfDecryptS:

; 3275 :    while ( nRC >= 0 && nInLth > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN3@UfDecryptS
	movsx	eax, WORD PTR _nInLth$[ebp]
	test	eax, eax
	jle	$LN3@UfDecryptS

; 3276 :    {
; 3277 :       // The maximum password length is zMAXEL.
; 3278 :       if ( nInLth > zMAXEL )

	movsx	ecx, WORD PTR _nInLth$[ebp]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN5@UfDecryptS

; 3279 :       {
; 3280 :          uCurrLth = zMAXEL;

	mov	edx, 32					; 00000020H
	mov	WORD PTR _uCurrLth$[ebp], dx

; 3281 :          ch = pchIn[ nPos + zMAXEL ];

	movsx	eax, WORD PTR _nPos$[ebp]
	mov	ecx, DWORD PTR _pchIn$[ebp]
	mov	dl, BYTE PTR [ecx+eax+32]
	mov	BYTE PTR _ch$[ebp], dl

; 3282 :          pchIn[ nPos + zMAXEL ] = 0;

	movsx	eax, WORD PTR _nPos$[ebp]
	mov	ecx, DWORD PTR _pchIn$[ebp]
	mov	BYTE PTR [ecx+eax+32], 0

; 3283 :       }
; 3284 :       else

	jmp	SHORT $LN6@UfDecryptS
$LN5@UfDecryptS:

; 3285 :       {
; 3286 :          if ( nPos == 0 ) // first time in

	movsx	edx, WORD PTR _nPos$[ebp]
	test	edx, edx
	jne	SHORT $LN7@UfDecryptS

; 3287 :             uCurrLth = uLth;

	mov	ax, WORD PTR _uLth$[ebp]
	mov	WORD PTR _uCurrLth$[ebp], ax

; 3288 :          else

	jmp	SHORT $LN8@UfDecryptS
$LN7@UfDecryptS:

; 3289 :             uCurrLth = nInLth;

	mov	cx, WORD PTR _nInLth$[ebp]
	mov	WORD PTR _uCurrLth$[ebp], cx
$LN8@UfDecryptS:

; 3290 : 
; 3291 :          ch = 0;

	mov	BYTE PTR _ch$[ebp], 0
$LN6@UfDecryptS:

; 3292 :       }
; 3293 : 
; 3294 :       nRC = fnDecryptStringUL( pchOut + nPos, pchIn + nPos, pchKey, uCurrLth, FALSE );

	push	0
	movzx	edx, WORD PTR _uCurrLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchKey$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nPos$[ebp]
	add	ecx, DWORD PTR _pchIn$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nPos$[ebp]
	add	edx, DWORD PTR _pchOut$[ebp]
	push	edx
	call	?fnDecryptStringUL@@YGFPAD00GE@Z	; fnDecryptStringUL
	mov	WORD PTR _nRC$[ebp], ax

; 3295 :       if ( ch )

	movsx	eax, BYTE PTR _ch$[ebp]
	test	eax, eax
	je	SHORT $LN9@UfDecryptS

; 3296 :          pchIn[ nPos + zMAXEL ] = ch;

	movsx	ecx, WORD PTR _nPos$[ebp]
	mov	edx, DWORD PTR _pchIn$[ebp]
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx+32], al
$LN9@UfDecryptS:

; 3297 : 
; 3298 :       nInLth -= zMAXEL;

	movsx	ecx, WORD PTR _nInLth$[ebp]
	sub	ecx, 32					; 00000020H
	mov	WORD PTR _nInLth$[ebp], cx

; 3299 :       nPos += zMAXEL;

	movsx	edx, WORD PTR _nPos$[ebp]
	add	edx, 32					; 00000020H
	mov	WORD PTR _nPos$[ebp], dx

; 3300 :    }

	jmp	$LN2@UfDecryptS
$LN3@UfDecryptS:

; 3301 : 
; 3302 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@UfDecryptS:

; 3303 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UfDecryptStringLong@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedeca.cpp
_TEXT	SEGMENT
_nRC$ = -20						; size = 2
_uCurrLth$ = -16					; size = 2
_nInLth$ = -12						; size = 2
_nPos$ = -8						; size = 2
_ch$ = -1						; size = 1
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_pchKey$ = 16						; size = 4
_uLth$ = 20						; size = 2
_UfEncryptStringLong@16 PROC

; 3092 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3093 :    zCHAR   ch;
; 3094 :    zUSHORT uCurrLth;
; 3095 :    zSHORT  nInLth = zstrlen( pchIn );

	mov	eax, DWORD PTR _pchIn$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nInLth$[ebp], ax

; 3096 :    zSHORT  nPos = 0;

	xor	ecx, ecx
	mov	WORD PTR _nPos$[ebp], cx

; 3097 :    zSHORT  nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 3098 : 
; 3099 :    pchOut[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 3100 :    if ( nInLth > uLth )

	movsx	eax, WORD PTR _nInLth$[ebp]
	movzx	ecx, WORD PTR _uLth$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN2@UfEncryptS

; 3101 :    {
; 3102 :       SysMessageBox( 0, "Zeidon Internal Error",

	push	0
	push	OFFSET $SG15841
	push	OFFSET $SG15842
	push	0
	call	_SysMessageBox@16

; 3103 :                      "Length Error Encrypting String", 0 );
; 3104 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@UfEncryptS
$LN2@UfEncryptS:

; 3105 :    }
; 3106 : 
; 3107 :    while ( nRC == 0 && nInLth > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN3@UfEncryptS
	movsx	eax, WORD PTR _nInLth$[ebp]
	test	eax, eax
	jle	$LN3@UfEncryptS

; 3108 :    {
; 3109 :       // The maximum password length is zMAXEL - 1.
; 3110 :       if ( nInLth > zMAXEL )

	movsx	ecx, WORD PTR _nInLth$[ebp]
	cmp	ecx, 32					; 00000020H
	jle	SHORT $LN5@UfEncryptS

; 3111 :       {
; 3112 :          uCurrLth = zMAXEL;

	mov	edx, 32					; 00000020H
	mov	WORD PTR _uCurrLth$[ebp], dx

; 3113 :          ch = pchIn[ nPos + zMAXEL ];

	movsx	eax, WORD PTR _nPos$[ebp]
	mov	ecx, DWORD PTR _pchIn$[ebp]
	mov	dl, BYTE PTR [ecx+eax+32]
	mov	BYTE PTR _ch$[ebp], dl

; 3114 :          pchIn[ nPos + zMAXEL ] = 0;

	movsx	eax, WORD PTR _nPos$[ebp]
	mov	ecx, DWORD PTR _pchIn$[ebp]
	mov	BYTE PTR [ecx+eax+32], 0

; 3115 :       }
; 3116 :       else

	jmp	SHORT $LN6@UfEncryptS
$LN5@UfEncryptS:

; 3117 :       {
; 3118 :          if ( nPos == 0 ) // first time in

	movsx	edx, WORD PTR _nPos$[ebp]
	test	edx, edx
	jne	SHORT $LN7@UfEncryptS

; 3119 :             uCurrLth = uLth;

	mov	ax, WORD PTR _uLth$[ebp]
	mov	WORD PTR _uCurrLth$[ebp], ax

; 3120 :          else

	jmp	SHORT $LN8@UfEncryptS
$LN7@UfEncryptS:

; 3121 :             uCurrLth = nInLth;

	mov	cx, WORD PTR _nInLth$[ebp]
	mov	WORD PTR _uCurrLth$[ebp], cx
$LN8@UfEncryptS:

; 3122 : 
; 3123 :          ch = 0;

	mov	BYTE PTR _ch$[ebp], 0
$LN6@UfEncryptS:

; 3124 :       }
; 3125 : 
; 3126 :       nRC = fnEncryptStringUL( pchOut + nPos, pchIn + nPos, pchKey, uCurrLth, FALSE );

	push	0
	movzx	edx, WORD PTR _uCurrLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchKey$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nPos$[ebp]
	add	ecx, DWORD PTR _pchIn$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nPos$[ebp]
	add	edx, DWORD PTR _pchOut$[ebp]
	push	edx
	call	?fnEncryptStringUL@@YAFPAD00GE@Z	; fnEncryptStringUL
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 3127 :       if ( ch )

	movsx	eax, BYTE PTR _ch$[ebp]
	test	eax, eax
	je	SHORT $LN9@UfEncryptS

; 3128 :          pchIn[ nPos + zMAXEL ] = ch;

	movsx	ecx, WORD PTR _nPos$[ebp]
	mov	edx, DWORD PTR _pchIn$[ebp]
	mov	al, BYTE PTR _ch$[ebp]
	mov	BYTE PTR [edx+ecx+32], al
$LN9@UfEncryptS:

; 3129 : 
; 3130 :       nInLth -= zMAXEL;

	movsx	ecx, WORD PTR _nInLth$[ebp]
	sub	ecx, 32					; 00000020H
	mov	WORD PTR _nInLth$[ebp], cx

; 3131 :       nPos += zMAXEL;

	movsx	edx, WORD PTR _nPos$[ebp]
	add	edx, 32					; 00000020H
	mov	WORD PTR _nPos$[ebp], dx

; 3132 :    }

	jmp	$LN2@UfEncryptS
$LN3@UfEncryptS:

; 3133 : 
; 3134 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@UfEncryptS:

; 3135 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UfEncryptStringLong@16 ENDP
_TEXT	ENDS
END
