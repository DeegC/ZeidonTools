; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEDMAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG13975 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG13415 DB	'Domain has an unnamed Context', 00H
	ORG $+2
$SG13416 DB	'Zeidon Error', 00H
	ORG $+3
$SG13660 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG13661 DB	'System Error', 00H
	ORG $+3
$SG13662 DB	'TZDMD101', 00H
	ORG $+3
$SG13663 DB	'Operation, ', 00H
$SG13664 DB	', not found for Domain: ', 00H
	ORG $+3
$SG13665 DB	'System Error', 00H
	ORG $+3
$SG13666 DB	'TZDMD101', 00H
	ORG $+7
$SG13885 DB	'(tblh) Entry type: %d   chType: %s   Context Name: %s   '
	DB	'Entity Name: %s   Attribute Name: %s', 00H
	ORG $+3
$SG13890 DB	'Operation ''%s'' does not handle an Entry Type of %ld fo'
	DB	'r domain ''%s''', 00H
$SG13891 DB	'System Error', 00H
	ORG $+3
$SG13892 DB	'TZDMD101', 00H
	ORG $+3
$SG13893 DB	'Operation, ', 00H
$SG13894 DB	', not found for Domain: ', 00H
	ORG $+3
$SG13895 DB	'System Error', 00H
	ORG $+3
$SG13896 DB	'TZDMD101', 00H
	ORG $+3
$SG13913 DB	'TZDME025 - Invalid table value: ', 00H
	ORG $+3
$SG13917 DB	'TZDME025 - Invalid table value: ', 00H
_DATA	ENDS
PUBLIC	_TableEntryForInternalValue@16
PUBLIC	_TableEntryIntToExt@20
PUBLIC	_TableEntryExtToInt@20
PUBLIC	_GetContext@12
PUBLIC	_GetDefaultContext@8
PUBLIC	_SfGetDefaultContextForDomain@12
PUBLIC	_fnGetTableEntryForDomain@32
PUBLIC	_Table_Handler@36
PUBLIC	_fnDomainProcessingRequired
PUBLIC	_fnGetContext
PUBLIC	_fnCallDomainOper@40
PUBLIC	_fnCallDomainOper2@36
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_IsDataNull
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_SysAssignDecimalFromNull@4:PROC
EXTRN	_SysConvertDecimalToLong@8:PROC
EXTRN	_SysCompareDecimalToNull@4:PROC
EXTRN	_SysConvertDecimalToString@12:PROC
EXTRN	_SysConvertLongToDecimal@8:PROC
EXTRN	_SendDomainError@28:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_StoreValueInRecord@20:PROC
EXTRN	_GetValueFromRecord@24:PROC
EXTRN	_TrueName@8:PROC
EXTRN	_SfGetApplicationForSubtask@8:PROC
EXTRN	_fnGetIntegerFromAttribute:PROC
EXTRN	_fnGetDecimalFromAttribute:PROC
EXTRN	_fnGetAddrForAttribute:PROC
EXTRN	_fnGetTaskDomain:PROC
EXTRN	_fnGetTextForTableEntry:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_szNullS:DWORD
EXTRN	_lNullInteger:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_pvData$ = 8						; size = 4
_chType$ = 12						; size = 1
_IsDataNull PROC

; 732  : {

	push	ebp
	mov	ebp, esp

; 733  :    // If the pvData input is null or points to a null char.
; 734  :    if ( pvData == 0 ||
; 735  :         (chType == zTYPE_STRING && *((zPCHAR) pvData) == 0) ||
; 736  :         (chType == zTYPE_INTEGER && *((zPLONG) pvData) == lNullInteger) ||

	cmp	DWORD PTR _pvData$[ebp], 0
	je	SHORT $LN3@IsDataNull
	movsx	eax, BYTE PTR _chType$[ebp]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN4@IsDataNull
	mov	ecx, DWORD PTR _pvData$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@IsDataNull
$LN4@IsDataNull:
	movsx	eax, BYTE PTR _chType$[ebp]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN5@IsDataNull
	mov	ecx, DWORD PTR _pvData$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	je	SHORT $LN3@IsDataNull
$LN5@IsDataNull:
	movsx	eax, BYTE PTR _chType$[ebp]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN2@IsDataNull
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_SysCompareDecimalToNull@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN2@IsDataNull
$LN3@IsDataNull:

; 737  :         (chType == zTYPE_DECIMAL &&
; 738  :          SysCompareDecimalToNull( (zPDECIMAL) pvData ) == 0) )
; 739  :    {
; 740  :       return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@IsDataNull
$LN2@IsDataNull:

; 741  :    }
; 742  : 
; 743  :    return( FALSE );

	xor	al, al
$LN1@IsDataNull:

; 744  : }

	pop	ebp
	ret	0
_IsDataNull ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_DomainData$ = -44					; size = 41
_lpTask$ = 8						; size = 4
_lpTaskDomain$ = 12					; size = 4
_lEntryType$ = 16					; size = 4
_lpView$ = 20						; size = 4
_lpViewEntity$ = 24					; size = 4
_lpViewAttribute$ = 28					; size = 4
_lpSrcView$ = 32					; size = 4
_lpSrcViewEntity$ = 36					; size = 4
_lpSrcViewAttribute$ = 40				; size = 4
_fnCallDomainOper2@36 PROC

; 128  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 129  :    zDomainOperData DomainData;
; 130  : 
; 131  :    zmemset( &DomainData, 0, sizeof( DomainData ) );

	push	41					; 00000029H
	push	0
	lea	eax, DWORD PTR _DomainData$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 132  : 
; 133  :    DomainData.zView              = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _DomainData$[ebp+13], ecx

; 134  :    DomainData.lpViewEntity       = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _DomainData$[ebp+17], edx

; 135  :    DomainData.lpViewAttribute    = lpViewAttribute;

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	DWORD PTR _DomainData$[ebp+21], eax

; 136  :    DomainData.zSrcView           = lpSrcView;

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	DWORD PTR _DomainData$[ebp+29], ecx

; 137  :    DomainData.lpSrcViewEntity    = lpSrcViewEntity;

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	DWORD PTR _DomainData$[ebp+33], edx

; 138  :    DomainData.lpSrcViewAttribute = lpSrcViewAttribute;

	mov	eax, DWORD PTR _lpSrcViewAttribute$[ebp]
	mov	DWORD PTR _DomainData$[ebp+37], eax

; 139  : 
; 140  :    // pfDomainOper is only set for DomainTypes:
; 141  :    // zDM_TYPE_EXPRESSION
; 142  :    // zDM_TYPE_ALGORITHM
; 143  :    // zDM_TYPE_TABLE
; 144  :    // and the domaintype need a Libraryname.
; 145  :    // Otherwise the Functionpointer is NULL
; 146  :    // 2000.01.19, RG
; 147  :    if ( *lpTaskDomain->pfDomainOper == 0 )

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	jne	SHORT $LN2@fnCallDoma

; 148  :       return( zDME_NOT_HANDLED );

	mov	eax, -10				; fffffff6H
	jmp	SHORT $LN1@fnCallDoma
$LN2@fnCallDoma:

; 149  : 
; 150  :    return( (zSHORT) (*lpTaskDomain->pfDomainOper)( lEntryType, &DomainData ) );

	lea	edx, DWORD PTR _DomainData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lEntryType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	call	edx
$LN1@fnCallDoma:

; 151  : }

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_fnCallDomainOper2@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_DomainData$ = -44					; size = 41
_lpTask$ = 8						; size = 4
_lpTaskDomain$ = 12					; size = 4
_lEntryType$ = 16					; size = 4
_chType$ = 20						; size = 1
_lpData$ = 24						; size = 4
_cpcContextName$ = 28					; size = 4
_lpView$ = 32						; size = 4
_lpViewEntity$ = 36					; size = 4
_lpViewAttribute$ = 40					; size = 4
_ulMaxStringLth$ = 44					; size = 4
_fnCallDomainOper@40 PROC

; 78   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 79   :    zDomainOperData DomainData;
; 80   : 
; 81   :    zmemset( &DomainData, 0, sizeof( DomainData ) );

	push	41					; 00000029H
	push	0
	lea	eax, DWORD PTR _DomainData$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 82   : 
; 83   :    DomainData.lID              = 0;

	mov	DWORD PTR _DomainData$[ebp], 0

; 84   :    DomainData.cType            = chType;

	mov	cl, BYTE PTR _chType$[ebp]
	mov	BYTE PTR _DomainData$[ebp+4], cl

; 85   :    DomainData.lpData           = lpData;

	mov	edx, DWORD PTR _lpData$[ebp]
	mov	DWORD PTR _DomainData$[ebp+5], edx

; 86   :    DomainData.pszContextName   = (zPCHAR) cpcContextName;

	mov	eax, DWORD PTR _cpcContextName$[ebp]
	mov	DWORD PTR _DomainData$[ebp+9], eax

; 87   :    DomainData.zView            = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _DomainData$[ebp+13], ecx

; 88   :    DomainData.lpViewEntity     = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _DomainData$[ebp+17], edx

; 89   :    DomainData.lpViewAttribute  = lpViewAttribute;

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	DWORD PTR _DomainData$[ebp+21], eax

; 90   :    DomainData.uMaxStringLength = ulMaxStringLth;

	mov	ecx, DWORD PTR _ulMaxStringLth$[ebp]
	mov	DWORD PTR _DomainData$[ebp+25], ecx

; 91   : 
; 92   :    // pfDomainOper is only set for DomainTypes:
; 93   :    // zDM_TYPE_EXPRESSION
; 94   :    // zDM_TYPE_ALGORITHM
; 95   :    // zDM_TYPE_TABLE
; 96   :    // and the domain type needs a Library name.
; 97   :    // Otherwise the Function pointer is NULL.
; 98   :    // 2000.01.19, RG
; 99   :    if ( *lpTaskDomain->pfDomainOper == 0 )

	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	cmp	DWORD PTR [edx+30], 0
	jne	SHORT $LN2@fnCallDoma

; 100  :       return( zDME_NOT_HANDLED );

	mov	eax, -10				; fffffff6H
	jmp	SHORT $LN1@fnCallDoma
$LN2@fnCallDoma:

; 101  : 
; 102  :    return( (zSHORT) (*lpTaskDomain->pfDomainOper)( lEntryType, &DomainData ) );

	lea	eax, DWORD PTR _DomainData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lEntryType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	mov	eax, DWORD PTR [edx+30]
	call	eax
$LN1@fnCallDoma:

; 103  : }

	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
_fnCallDomainOper@40 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_lpZKey$1 = -12						; size = 4
_lpName$2 = -8						; size = 4
_lpSrchContext$ = -4					; size = 4
_lpDomain$ = 8						; size = 4
_cpcContextName$ = 12					; size = 4
_fnGetContext PROC

; 168  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 169  :    zLPCONTEXT  lpSrchContext;
; 170  : 
; 171  :    lpSrchContext = zGETPTR( lpDomain->hFirstContext );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	mov	ecx, DWORD PTR [eax+47]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchContext$[ebp], eax

; 172  : 
; 173  :    // Check for presence of ZKey selection
; 174  :    if ( *cpcContextName == '\xff' )

	mov	edx, DWORD PTR _cpcContextName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, -1
	jne	SHORT $LN4@fnGetConte

; 175  :    {
; 176  :       LPZKEY lpZKey = (LPZKEY) cpcContextName;

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	mov	DWORD PTR _lpZKey$1[ebp], ecx
$LN2@fnGetConte:

; 177  : 
; 178  :       while ( lpSrchContext )

	cmp	DWORD PTR _lpSrchContext$[ebp], 0
	je	SHORT $LN3@fnGetConte

; 179  :       {
; 180  :          if ( lpSrchContext->lContextTok == lpZKey->lZKey )

	mov	edx, DWORD PTR _lpSrchContext$[ebp]
	mov	eax, DWORD PTR _lpZKey$1[ebp]
	mov	ecx, DWORD PTR [edx+39]
	cmp	ecx, DWORD PTR [eax+1]
	jne	SHORT $LN8@fnGetConte

; 181  :             break;

	jmp	SHORT $LN3@fnGetConte
$LN8@fnGetConte:

; 182  : 
; 183  :          lpSrchContext = zGETPTR( lpSrchContext->hNextContext );

	mov	edx, DWORD PTR _lpSrchContext$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchContext$[ebp], eax

; 184  :       }

	jmp	SHORT $LN2@fnGetConte
$LN3@fnGetConte:

; 185  :    }

	jmp	SHORT $LN7@fnGetConte
$LN4@fnGetConte:

; 186  :    else
; 187  :    {
; 188  :       while ( lpSrchContext )

	cmp	DWORD PTR _lpSrchContext$[ebp], 0
	je	SHORT $LN7@fnGetConte

; 189  :       {
; 190  :          zPCHAR lpName = lpSrchContext->szName;

	mov	ecx, DWORD PTR _lpSrchContext$[ebp]
	add	ecx, 6
	mov	DWORD PTR _lpName$2[ebp], ecx

; 191  : 
; 192  :          if ( lpName == 0 || lpName[ 0 ] == 0 )

	je	SHORT $LN11@fnGetConte
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpName$2[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN9@fnGetConte
$LN11@fnGetConte:

; 193  :          {
; 194  :             // "KZOEE356 - Domain has an unnamed Context"
; 195  :             fnSysMessageBox( 0, "Zeidon Error",

	push	0
	push	OFFSET $SG13415
	push	OFFSET $SG13416
	push	0
	call	_fnSysMessageBox@16

; 196  :                              "Domain has an unnamed Context", 0 );
; 197  :          // fnIssueCoreError( 0, lpView, 16, 356, 0, lpDomain->szName, 0 );
; 198  :          }

	jmp	SHORT $LN10@fnGetConte
$LN9@fnGetConte:

; 199  :          else
; 200  :          if ( zstrcmpi( lpName, cpcContextName ) == 0 )

	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpName$2[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@fnGetConte

; 201  :                break;

	jmp	SHORT $LN7@fnGetConte
$LN10@fnGetConte:

; 202  : 
; 203  :          lpSrchContext = zGETPTR( lpSrchContext->hNextContext );

	mov	edx, DWORD PTR _lpSrchContext$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchContext$[ebp], eax

; 204  :       }

	jmp	SHORT $LN4@fnGetConte
$LN7@fnGetConte:

; 205  :    }
; 206  : 
; 207  :    return( lpSrchContext );

	mov	eax, DWORD PTR _lpSrchContext$[ebp]

; 208  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetContext ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_lpTempDomain$ = -8					; size = 4
_lpTDTemp$ = -4						; size = 4
_lpReturnTaskDomain$ = 8				; size = 4
_lpView$ = 12						; size = 4
_lpCurrentTask$ = 16					; size = 4
_lpDomain$ = 20						; size = 4
_fnDomainProcessingRequired PROC

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 366  :    LPTASKDOMAIN   lpTDTemp;
; 367  :    LPDOMAIN       lpTempDomain;
; 368  : 
; 369  :    *lpReturnTaskDomain = fnGetTaskDomain( lpView, lpCurrentTask, lpDomain );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetTaskDomain
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpReturnTaskDomain$[ebp]
	mov	DWORD PTR [ecx], eax

; 370  :    lpTDTemp = *lpReturnTaskDomain;

	mov	edx, DWORD PTR _lpReturnTaskDomain$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpTDTemp$[ebp], eax

; 371  :    if ( lpTDTemp )

	cmp	DWORD PTR _lpTDTemp$[ebp], 0
	je	SHORT $LN2@fnDomainPr

; 372  :    {
; 373  :       lpTempDomain = zGETPTR( lpTDTemp->hDomain );

	mov	ecx, DWORD PTR _lpTDTemp$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempDomain$[ebp], eax

; 374  : 
; 375  :       if ( lpTDTemp->pfDomainOper ||
; 376  :            lpTempDomain->cDomainType == zDM_TYPE_TABLE ||

	mov	eax, DWORD PTR _lpTDTemp$[ebp]
	cmp	DWORD PTR [eax+30], 0
	jne	SHORT $LN4@fnDomainPr
	mov	ecx, DWORD PTR _lpTempDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+65]
	cmp	edx, 84					; 00000054H
	je	SHORT $LN4@fnDomainPr
	mov	eax, DWORD PTR _lpTempDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+65]
	cmp	ecx, 70					; 00000046H
	jne	SHORT $LN2@fnDomainPr
$LN4@fnDomainPr:

; 377  :            lpTempDomain->cDomainType == zDM_TYPE_FORMAT )
; 378  :       {
; 379  :          return( lpTempDomain->cDomainType );

	mov	edx, DWORD PTR _lpTempDomain$[ebp]
	mov	al, BYTE PTR [edx+65]
	jmp	SHORT $LN1@fnDomainPr
$LN2@fnDomainPr:

; 380  :       }
; 381  :    }
; 382  : 
; 383  :    return( 0 );

	xor	al, al
$LN1@fnDomainPr:

; 384  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDomainProcessingRequired ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_lZero$1 = -908						; size = 4
_uAttrLth$2 = -904					; size = 4
_nLth$3 = -900						; size = 4
_lIntValue$4 = -896					; size = 4
_lInternalValue$5 = -892				; size = 4
_lpViewEntityTemp$ = -888				; size = 4
tv541 = -884						; size = 4
tv471 = -880						; size = 4
_lpCurrentTask$ = -876					; size = 4
_lpTaskDomain$ = -872					; size = 4
tv974 = -868						; size = 4
_pchContext$6 = -864					; size = 4
$T7 = -860						; size = 4
tv952 = -856						; size = 4
_lpOrigTableEntry$8 = -852				; size = 4
tv838 = -848						; size = 4
tv837 = -844						; size = 4
tv744 = -840						; size = 4
tv690 = -836						; size = 4
tv619 = -832						; size = 4
tv618 = -828						; size = 4
$T9 = -824						; size = 4
tv542 = -820						; size = 4
_pvDataToStore$10 = -816				; size = 4
_pchContextName$11 = -812				; size = 4
tv514 = -808						; size = 4
tv511 = -804						; size = 4
tv411 = -800						; size = 4
tv193 = -796						; size = 4
tv190 = -792						; size = 4
_cAttrType$12 = -785					; size = 1
_lFlag$13 = -784					; size = 4
_pchAttribute$14 = -780					; size = 4
_pchAttribute$15 = -776					; size = 4
_lpContext$16 = -772					; size = 4
tv140 = -768						; size = 4
_lTempValue2$ = -764					; size = 4
_lpAttrValue$17 = -760					; size = 4
_lpSrchContext$18 = -756				; size = 4
_lplInteger$ = -752					; size = 4
_lpViewEntityCsr$ = -748				; size = 4
_lTempValue$ = -744					; size = 4
_lWork$ = -740						; size = 4
_lpInternalValue$ = -736				; size = 4
_bNull$19 = -729					; size = 1
_lpTableEntry$20 = -728					; size = 4
_c$21 = -721						; size = 1
_nSeverity$ = -720					; size = 2
_lpDomain$ = -716					; size = 4
_nRC$ = -712						; size = 2
_dTempValue$ = -708					; size = 40
_szWorkString2$ = -668					; size = 257
_szAttribValue$22 = -408				; size = 128
_szWorkString$ = -280					; size = 257
_szIntString$23 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_lEntryType$ = 8					; size = 4
_chType$ = 12						; size = 1
_pvData$ = 16						; size = 4
_cpcContextName$ = 20					; size = 4
_lpView$ = 24						; size = 4
_lpViewEntity$ = 28					; size = 4
_lpViewAttribute$ = 32					; size = 4
_ulMaxStringLth$ = 36					; size = 4
_pvTablePosition$ = 40					; size = 4
_Table_Handler@36 PROC

; 937  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 908				; 0000038cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 938  :    zCHAR             szWorkString[ 257 ];
; 939  :    zCHAR             szWorkString2[ 257 ];
; 940  :    zLONG             lWork = 0;

	mov	DWORD PTR _lWork$[ebp], 0

; 941  :    zPVOID            lpInternalValue;
; 942  :    zPLONG            lplInteger;
; 943  :    LPDOMAIN          lpDomain;
; 944  :    LPVIEWENTITY      lpViewEntityTemp;
; 945  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 946  :    LPTASKDOMAIN      lpTaskDomain;
; 947  :    LPTASK            lpCurrentTask;
; 948  :    zDECIMAL          dTempValue;
; 949  :    zLONG             lTempValue;
; 950  :    zLONG             lTempValue2;
; 951  :    zSHORT            nSeverity;
; 952  :    zSHORT            nRC = zCALL_ERROR;  // default to in error status ...

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 953  : 
; 954  :    if ( lEntryType < 1 || lEntryType > 10 )

	cmp	DWORD PTR _lEntryType$[ebp], 1
	jl	SHORT $LN27@Table_Hand
	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jle	SHORT $LN26@Table_Hand
$LN27@Table_Hand:

; 955  :    {
; 956  :       szWorkString[ 0 ] = chType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _chType$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], al

; 957  :       szWorkString[ 1 ] = 0;

	mov	DWORD PTR $T7[ebp], 1
	cmp	DWORD PTR $T7[ebp], 257			; 00000101H
	jae	SHORT $LN235@Table_Hand
	jmp	SHORT $LN236@Table_Hand
$LN235@Table_Hand:
	call	___report_rangecheckfailure
$LN236@Table_Hand:
	mov	ecx, DWORD PTR $T7[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 0

; 958  :       TraceLine( "(tblh) Entry type: %d   chType: %s   Context Name: %s   "

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lEntryType$[ebp]
	push	eax
	push	OFFSET $SG13885
	call	_TraceLine
	add	esp, 24					; 00000018H
$LN26@Table_Hand:

; 959  :                    "Entity Name: %s   Attribute Name: %s",
; 960  :                  lEntryType, szWorkString, cpcContextName,
; 961  :                  lpViewEntity->szName, lpViewAttribute->szName );
; 962  :    }
; 963  : 
; 964  :    lpDomain = zGETPTR( lpViewAttribute->hDomain );

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR [ecx+198]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 965  :    lpCurrentTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 966  : 
; 967  :    // If the table Domain has an operation, call the Domain Operation, instead
; 968  :    // of continuing processing here.
; 969  :    if ( lpDomain->szDomainOper[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+100]
	test	edx, edx
	je	$LN28@Table_Hand

; 970  :    {
; 971  :       lpTaskDomain = fnGetTaskDomain( lpView, lpCurrentTask, lpDomain );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetTaskDomain
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTaskDomain$[ebp], eax

; 972  :       if ( lpTaskDomain->pfDomainOper )

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	$LN29@Table_Hand

; 973  :       {
; 974  :          nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	mov	ecx, DWORD PTR _ulMaxStringLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvData$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _chType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lEntryType$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 975  :                                  lEntryType, chType, pvData,
; 976  :                                  cpcContextName, lpView,
; 977  :                                  lpViewEntity, lpViewAttribute,
; 978  :                                  ulMaxStringLth );
; 979  :          if ( nRC == zDME_NOT_HANDLED )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -10				; fffffff6H
	jne	SHORT $LN31@Table_Hand

; 980  :          {
; 981  :             zsprintf( szWorkString, "Operation '%s' does not handle an Entry "

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lEntryType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	push	OFFSET $SG13890
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 982  :                       "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 983  :                       lEntryType, lpDomain->szName );
; 984  :             MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	push	OFFSET $SG13891
	push	OFFSET $SG13892
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MessageSend@24
$LN31@Table_Hand:

; 985  :                          szWorkString, zMSGQ_DOMAIN_ERROR, 0 );
; 986  :          }
; 987  :       }

	jmp	$LN30@Table_Hand
$LN29@Table_Hand:

; 988  :       else
; 989  :       {
; 990  :          zstrcpy( szWorkString, "Operation, " );

	push	OFFSET $SG13893
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 991  :          zstrcat( szWorkString, lpDomain->szDomainOper );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 992  :          zstrcat( szWorkString, ", not found for Domain: " );

	push	OFFSET $SG13894
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 993  :          zstrcat( szWorkString, lpDomain->szName );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 6
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 994  :          MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	push	OFFSET $SG13895
	push	OFFSET $SG13896
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MessageSend@24

; 995  :                       szWorkString, zMSGQ_DOMAIN_ERROR, 0 );
; 996  :          nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
$LN30@Table_Hand:

; 997  :       }
; 998  : 
; 999  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN234@Table_Hand
$LN28@Table_Hand:

; 1000 :    }
; 1001 : 
; 1002 :    // Determine the function request.
; 1003 :    switch ( lEntryType )

	mov	eax, DWORD PTR _lEntryType$[ebp]
	mov	DWORD PTR tv140[ebp], eax
	mov	ecx, DWORD PTR tv140[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv140[ebp], ecx
	cmp	DWORD PTR tv140[ebp], 9
	ja	$LN231@Table_Hand
	mov	edx, DWORD PTR tv140[ebp]
	jmp	DWORD PTR $LN255@Table_Hand[edx*4]
$LN32@Table_Hand:

; 1004 :    {
; 1005 :       case zDME_VALIDATE_LPDATA:
; 1006 :       case zDME_SET_ATTRIBUTE:
; 1007 :          // If the pvData input is null or points to a null char, skip the
; 1008 :          // conversions, just null the attribute.
; 1009 :          if ( IsDataNull( pvData, chType ) )

	movzx	eax, BYTE PTR _chType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_IsDataNull
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	$LN33@Table_Hand

; 1010 :          {
; 1011 :             if ( lpViewAttribute->cType == zTYPE_INTEGER )

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	SHORT $LN34@Table_Hand

; 1012 :                lpInternalValue = (zPVOID) &lNullInteger;

	mov	DWORD PTR _lpInternalValue$[ebp], OFFSET _lNullInteger
	jmp	SHORT $LN35@Table_Hand
$LN34@Table_Hand:

; 1013 :             else
; 1014 :             {
; 1015 :                if ( lpViewAttribute->cType == zTYPE_DECIMAL )

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN36@Table_Hand

; 1016 :                {
; 1017 :                   SysAssignDecimalFromNull( &dTempValue );

	lea	ecx, DWORD PTR _dTempValue$[ebp]
	push	ecx
	call	_SysAssignDecimalFromNull@4

; 1018 :                   lpInternalValue = (zPVOID) &dTempValue;

	lea	edx, DWORD PTR _dTempValue$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], edx

; 1019 :                }

	jmp	SHORT $LN35@Table_Hand
$LN36@Table_Hand:

; 1020 :                else
; 1021 :                   lpInternalValue = (zPVOID) szNullS;

	mov	eax, DWORD PTR _szNullS
	mov	DWORD PTR _lpInternalValue$[ebp], eax
$LN35@Table_Hand:

; 1022 :             }
; 1023 : 
; 1024 :             if ( lEntryType == zDME_SET_ATTRIBUTE )

	cmp	DWORD PTR _lEntryType$[ebp], 1
	jne	SHORT $LN38@Table_Hand

; 1025 :                nRC = StoreValueInRecord( lpView, lpViewEntity,

	push	0
	mov	ecx, DWORD PTR _lpInternalValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_StoreValueInRecord@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN39@Table_Hand
$LN38@Table_Hand:

; 1026 :                                          lpViewAttribute,
; 1027 :                                          lpInternalValue, 0 );
; 1028 :             else
; 1029 :                nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN39@Table_Hand:

; 1030 : 
; 1031 :             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN234@Table_Hand
$LN33@Table_Hand:

; 1032 :          }
; 1033 : 
; 1034 :          switch ( chType )

	mov	al, BYTE PTR _chType$[ebp]
	mov	BYTE PTR tv190[ebp], al
	cmp	BYTE PTR tv190[ebp], 76			; 0000004cH
	jl	$LN80@Table_Hand
	cmp	BYTE PTR tv190[ebp], 77			; 0000004dH
	jle	$LN68@Table_Hand
	cmp	BYTE PTR tv190[ebp], 83			; 00000053H
	je	SHORT $LN40@Table_Hand
	jmp	$LN80@Table_Hand
$LN40@Table_Hand:

; 1035 :          {
; 1036 :             case zTYPE_STRING:
; 1037 :                switch ( lpViewAttribute->cType )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv193[ebp], dl
	cmp	BYTE PTR tv193[ebp], 76			; 0000004cH
	jl	$LN65@Table_Hand
	cmp	BYTE PTR tv193[ebp], 77			; 0000004dH
	jle	$LN51@Table_Hand
	cmp	BYTE PTR tv193[ebp], 83			; 00000053H
	je	SHORT $LN41@Table_Hand
	jmp	$LN65@Table_Hand
$LN41@Table_Hand:

; 1038 :                {
; 1039 :                   case zTYPE_STRING:
; 1040 :                      if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN44@Table_Hand
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	$LN42@Table_Hand
$LN44@Table_Hand:

; 1041 :                      {
; 1042 :                         if ( TableEntryForInternalValue( lpView, lpDomain, 0,
; 1043 :                                                          pvData ) == 0 )

	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_TableEntryForInternalValue@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN45@Table_Hand

; 1044 :                         {
; 1045 :                            lpInternalValue = pvData;

	mov	edx, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], edx

; 1046 :                            break;

	jmp	$LN6@Table_Hand
$LN45@Table_Hand:

; 1047 :                         }
; 1048 : 
; 1049 :                         if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN46@Table_Hand

; 1050 :                            nSeverity = -1;

	or	eax, -1
	mov	WORD PTR _nSeverity$[ebp], ax
	jmp	SHORT $LN47@Table_Hand
$LN46@Table_Hand:

; 1051 :                         else
; 1052 :                            nSeverity = 0;

	xor	ecx, ecx
	mov	WORD PTR _nSeverity$[ebp], cx
$LN47@Table_Hand:

; 1053 : 
; 1054 :                         // "TZDME025 - Invalid table value "
; 1055 :                         TraceLineS( "TZDME025 - Invalid table value: ",

	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	push	OFFSET $SG13913
	call	_TraceLineS@8

; 1056 :                                     (zPCHAR) pvData );
; 1057 :                         SendDomainError( lpView, lpDomain, nSeverity, 25, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	25					; 00000019H
	movzx	edx, WORD PTR _nSeverity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SendDomainError@28

; 1058 :                                          lpViewEntity->szName,
; 1059 :                                          lpViewAttribute->szName );
; 1060 : 
; 1061 :                         return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand

; 1062 :                      }

	jmp	$LN51@Table_Hand
$LN42@Table_Hand:

; 1063 :                      else
; 1064 :                      {
; 1065 :                         // convert from external to internal
; 1066 :                         nRC = TableEntryExtToInt( (zPVOID) szWorkString2, lpView,

	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1067 :                                                   lpDomain, cpcContextName,
; 1068 :                                                   (zPCHAR) pvData );
; 1069 :                         if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN48@Table_Hand

; 1070 :                         {
; 1071 :                            lpInternalValue = (zPVOID) szWorkString2;

	lea	edx, DWORD PTR _szWorkString2$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], edx

; 1072 :                            break;

	jmp	$LN6@Table_Hand
$LN48@Table_Hand:

; 1073 :                         }
; 1074 : 
; 1075 :                         if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN49@Table_Hand

; 1076 :                            nSeverity = -1;

	or	eax, -1
	mov	WORD PTR _nSeverity$[ebp], ax
	jmp	SHORT $LN50@Table_Hand
$LN49@Table_Hand:

; 1077 :                         else
; 1078 :                            nSeverity = 0;

	xor	ecx, ecx
	mov	WORD PTR _nSeverity$[ebp], cx
$LN50@Table_Hand:

; 1079 : 
; 1080 :                         // "TZDME025 - Invalid table value "
; 1081 :                         TraceLineS( "TZDME025 - Invalid table value: ",

	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	push	OFFSET $SG13917
	call	_TraceLineS@8

; 1082 :                                     (zPCHAR) pvData );
; 1083 :                         SendDomainError( lpView, lpDomain, nSeverity, 25, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	25					; 00000019H
	movzx	edx, WORD PTR _nSeverity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SendDomainError@28

; 1084 :                                          lpViewEntity->szName,
; 1085 :                                          lpViewAttribute->szName );
; 1086 : 
; 1087 :                         return( zCALL_ERROR ); // TableEntry not found, error

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN51@Table_Hand:

; 1088 :                      }
; 1089 : 
; 1090 :                   case zTYPE_INTEGER:
; 1091 :                   case zTYPE_DECIMAL:
; 1092 :                      if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN54@Table_Hand
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	$LN52@Table_Hand
$LN54@Table_Hand:

; 1093 :                      {
; 1094 :                         // The value coming in (pvData) is string.  Since the
; 1095 :                         // attribute type is integer or decimal, the table type
; 1096 :                         // is integer. (Internal table types are only stored as
; 1097 :                         // strings and integers.)
; 1098 :                         lWork = zatol( (zPCHAR) pvData );

	mov	eax, DWORD PTR _pvData$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lWork$[ebp], eax

; 1099 :                         if ( TableEntryForInternalValue( lpView, lpDomain,
; 1100 :                                                          lpDomain->szName,
; 1101 :                                                          (zPVOID) &lWork ) == 0 )

	lea	ecx, DWORD PTR _lWork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_TableEntryForInternalValue@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN55@Table_Hand

; 1102 :                         {
; 1103 :                            if ( lpViewAttribute->cType == zTYPE_DECIMAL )

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 77					; 0000004dH
	jne	SHORT $LN56@Table_Hand

; 1104 :                            {
; 1105 :                               SysConvertLongToDecimal( lWork, &dTempValue );

	lea	edx, DWORD PTR _dTempValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lWork$[ebp]
	push	eax
	call	_SysConvertLongToDecimal@8

; 1106 :                               lpInternalValue = (zPVOID) &dTempValue;

	lea	ecx, DWORD PTR _dTempValue$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], ecx

; 1107 :                            }

	jmp	SHORT $LN57@Table_Hand
$LN56@Table_Hand:

; 1108 :                            else
; 1109 :                               lpInternalValue = (zPVOID) &lWork;

	lea	edx, DWORD PTR _lWork$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], edx
$LN57@Table_Hand:

; 1110 : 
; 1111 :                            break;

	jmp	$LN6@Table_Hand
$LN55@Table_Hand:

; 1112 :                         }
; 1113 : 
; 1114 :                         if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN58@Table_Hand

; 1115 :                            nSeverity = -1;

	or	eax, -1
	mov	WORD PTR _nSeverity$[ebp], ax
	jmp	SHORT $LN59@Table_Hand
$LN58@Table_Hand:

; 1116 :                         else
; 1117 :                            nSeverity = 0;

	xor	ecx, ecx
	mov	WORD PTR _nSeverity$[ebp], cx
$LN59@Table_Hand:

; 1118 : 
; 1119 :                         // "TZDME025 - Invalid table value "
; 1120 :                         SendDomainError( lpView, lpDomain, nSeverity, 25, 0,

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	25					; 00000019H
	movzx	ecx, WORD PTR _nSeverity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28

; 1121 :                                          lpViewEntity->szName,
; 1122 :                                          lpViewAttribute->szName );
; 1123 :                         return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand

; 1124 :                      }

	jmp	$LN65@Table_Hand
$LN52@Table_Hand:

; 1125 :                      else
; 1126 :                      {
; 1127 :                         // convert from external to internal
; 1128 :                         nRC = TableEntryExtToInt( (zPVOID) &lWork, lpView,

	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lWork$[ebp]
	push	edx
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1129 :                                                   lpDomain, cpcContextName,
; 1130 :                                                   (zPCHAR) pvData );
; 1131 :                         if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN60@Table_Hand

; 1132 :                         {
; 1133 :                            if ( lpViewAttribute->cType == zTYPE_DECIMAL )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN61@Table_Hand

; 1134 :                            {
; 1135 :                               SysConvertLongToDecimal( lWork, &dTempValue );

	lea	eax, DWORD PTR _dTempValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lWork$[ebp]
	push	ecx
	call	_SysConvertLongToDecimal@8

; 1136 :                               lpInternalValue = (zPVOID) &dTempValue;

	lea	edx, DWORD PTR _dTempValue$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], edx

; 1137 :                            }

	jmp	SHORT $LN62@Table_Hand
$LN61@Table_Hand:

; 1138 :                            else
; 1139 :                               lpInternalValue = (zPVOID) &lWork;

	lea	eax, DWORD PTR _lWork$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], eax
$LN62@Table_Hand:

; 1140 : 
; 1141 :                            break;

	jmp	$LN6@Table_Hand
$LN60@Table_Hand:

; 1142 :                         }
; 1143 : 
; 1144 :                         if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN63@Table_Hand

; 1145 :                            nSeverity = -1;

	or	ecx, -1
	mov	WORD PTR _nSeverity$[ebp], cx
	jmp	SHORT $LN64@Table_Hand
$LN63@Table_Hand:

; 1146 :                         else
; 1147 :                            nSeverity = 0;

	xor	edx, edx
	mov	WORD PTR _nSeverity$[ebp], dx
$LN64@Table_Hand:

; 1148 : 
; 1149 :                         // "TZDME025 - Invalid table value "
; 1150 :                         SendDomainError( lpView, lpDomain, nSeverity, 25, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	25					; 00000019H
	movzx	edx, WORD PTR _nSeverity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SendDomainError@28

; 1151 :                                          lpViewEntity->szName,
; 1152 :                                          lpViewAttribute->szName );
; 1153 : 
; 1154 :                         return( zCALL_ERROR ); // TableEntry not found, error

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN65@Table_Hand:

; 1155 :                      }
; 1156 : 
; 1157 :                default:
; 1158 :                   if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN66@Table_Hand

; 1159 :                      nSeverity = -1;

	or	edx, -1
	mov	WORD PTR _nSeverity$[ebp], dx
	jmp	SHORT $LN67@Table_Hand
$LN66@Table_Hand:

; 1160 :                   else
; 1161 :                      nSeverity = 0;

	xor	eax, eax
	mov	WORD PTR _nSeverity$[ebp], ax
$LN67@Table_Hand:

; 1162 : 
; 1163 :                   // "TZDME003 - Attribute type invalid for this Domain "
; 1164 :                   SendDomainError( lpView, lpDomain, nSeverity, 3, 0,

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	3
	movzx	eax, WORD PTR _nSeverity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SendDomainError@28

; 1165 :                                    lpViewEntity->szName,
; 1166 :                                    lpViewAttribute->szName );
; 1167 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN6@Table_Hand:

; 1168 :                }
; 1169 : 
; 1170 :                break;

	jmp	$LN4@Table_Hand
$LN68@Table_Hand:

; 1171 : 
; 1172 :             case zTYPE_INTEGER:
; 1173 :             case zTYPE_DECIMAL:
; 1174 :                if ( lpViewAttribute->cType != zTYPE_INTEGER &&
; 1175 :                     lpViewAttribute->cType != zTYPE_DECIMAL &&

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	je	SHORT $LN69@Table_Hand
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	je	SHORT $LN69@Table_Hand
	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 83					; 00000053H
	je	SHORT $LN69@Table_Hand

; 1176 :                     lpViewAttribute->cType != zTYPE_STRING )
; 1177 :                {
; 1178 :                   // "TZDME003 - Attribute type invalid for this Domain "
; 1179 :                   SendDomainError( lpView, lpDomain, 0, 3, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	3
	push	0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28

; 1180 :                                    lpViewEntity->szName,
; 1181 :                                    lpViewAttribute->szName );
; 1182 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN69@Table_Hand:

; 1183 :                }
; 1184 : 
; 1185 :                if ( lpViewAttribute->cType == zTYPE_STRING )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 83					; 00000053H
	jne	$LN70@Table_Hand

; 1186 :                {
; 1187 :                   // Allow assignment of a number to string.
; 1188 :                   // We want the same behaviour,
; 1189 :                   //  as we get assigning a number to a normal string attribute.
; 1190 :                   // As the source is a number, there cannot be any context.
; 1191 : 
; 1192 :                   zCHAR szAttribValue[ 128 ] = { 0 };

	mov	BYTE PTR _szAttribValue$22[ebp], 0
	push	127					; 0000007fH
	push	0
	lea	eax, DWORD PTR _szAttribValue$22[ebp+1]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1193 : 
; 1194 :                   if ( chType == zTYPE_INTEGER )

	movsx	ecx, BYTE PTR _chType$[ebp]
	cmp	ecx, 76					; 0000004cH
	jne	SHORT $LN71@Table_Hand

; 1195 :                   {
; 1196 :                      // Convert integer coming in to a string
; 1197 :                      if ( *((zPLONG) pvData) != lNullInteger )

	mov	edx, DWORD PTR _pvData$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	je	SHORT $LN73@Table_Hand

; 1198 :                         zltoa( *((zPLONG) pvData), szAttribValue );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _szAttribValue$22[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN73@Table_Hand:

; 1199 :                   }

	jmp	SHORT $LN72@Table_Hand
$LN71@Table_Hand:

; 1200 :                   else
; 1201 :                   {
; 1202 :                      // Convert decimal coming in to a string
; 1203 :                      if ( SysCompareDecimalToNull( (zDECIMAL*) pvData ) != 0 )

	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_SysCompareDecimalToNull@4
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN72@Table_Hand

; 1204 :                         SysConvertDecimalToString( (zDECIMAL*) pvData,

	push	-1
	lea	eax, DWORD PTR _szAttribValue$22[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_SysConvertDecimalToString@12
$LN72@Table_Hand:

; 1205 :                                                    szAttribValue, -1 );
; 1206 :                   }
; 1207 : 
; 1208 :                   if ( TableEntryForInternalValue( lpView, lpDomain, 0,
; 1209 :                                                    szAttribValue ) == 0 )

	lea	edx, DWORD PTR _szAttribValue$22[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_TableEntryForInternalValue@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN75@Table_Hand

; 1210 :                   {
; 1211 :                      lpInternalValue = szAttribValue;

	lea	eax, DWORD PTR _szAttribValue$22[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], eax

; 1212 :                      break;

	jmp	$LN4@Table_Hand
$LN75@Table_Hand:

; 1213 :                   }
; 1214 : 
; 1215 :                   // "TZDME025 - Invalid table value "
; 1216 :                   SendDomainError( lpView, lpDomain, 0, 25, 0,

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	25					; 00000019H
	push	0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SendDomainError@28

; 1217 :                                    lpViewEntity->szName,
; 1218 :                                    lpViewAttribute->szName );
; 1219 : 
; 1220 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN70@Table_Hand:

; 1221 :                }
; 1222 : 
; 1223 :                // Decimal and integer values are treated the same in table lookup.
; 1224 :                if ( lpViewAttribute->cType == zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN76@Table_Hand

; 1225 :                   lTempValue = *((zPLONG) pvData);

	mov	ecx, DWORD PTR _pvData$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lTempValue$[ebp], edx
	jmp	SHORT $LN77@Table_Hand
$LN76@Table_Hand:

; 1226 :                else
; 1227 :                   SysConvertDecimalToLong( (zPDECIMAL) pvData, &lTempValue );

	lea	eax, DWORD PTR _lTempValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8
$LN77@Table_Hand:

; 1228 : 
; 1229 :                // We will always treat the setting of a table attribute value from
; 1230 :                // an integer or decimal as setting it from an internal value,
; 1231 :                // whether or not a Context Name is passed in.
; 1232 :                if ( TableEntryForInternalValue( lpView, lpDomain,
; 1233 :                                                 lpDomain->szName,
; 1234 :                                                 (zPVOID) &lTempValue ) == 0 )

	lea	edx, DWORD PTR _lTempValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_TableEntryForInternalValue@16
	cwde
	test	eax, eax
	jne	SHORT $LN78@Table_Hand

; 1235 :                {
; 1236 :                   lpInternalValue = pvData;

	mov	ecx, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpInternalValue$[ebp], ecx

; 1237 :                   break;

	jmp	SHORT $LN4@Table_Hand

; 1238 :                }

	jmp	SHORT $LN80@Table_Hand
$LN78@Table_Hand:

; 1239 :                else
; 1240 :                {
; 1241 :                   // "TZDME025 - Invalid table value "
; 1242 :                   SendDomainError( lpView, lpDomain, 0, 25, 0,

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	25					; 00000019H
	push	0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SendDomainError@28

; 1243 :                                    lpViewEntity->szName,
; 1244 :                                    lpViewAttribute->szName );
; 1245 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN80@Table_Hand:

; 1246 :                }
; 1247 : 
; 1248 :             default:
; 1249 :                // "TZDME001 - Invalid input data type "
; 1250 :                SendDomainError( lpView, lpDomain, 0, 1, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28

; 1251 :                                 lpViewEntity->szName,
; 1252 :                                 lpViewAttribute->szName );
; 1253 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN4@Table_Hand:

; 1254 :          }
; 1255 : 
; 1256 :          if ( lEntryType == zDME_SET_ATTRIBUTE )

	cmp	DWORD PTR _lEntryType$[ebp], 1
	jne	SHORT $LN81@Table_Hand

; 1257 :          {
; 1258 :             nRC = StoreValueInRecord( lpView, lpViewEntity,

	push	0
	mov	ecx, DWORD PTR _lpInternalValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_StoreValueInRecord@20
	mov	WORD PTR _nRC$[ebp], ax

; 1259 :                                       lpViewAttribute, lpInternalValue, 0 );
; 1260 :          }

	jmp	SHORT $LN82@Table_Hand
$LN81@Table_Hand:

; 1261 :          else
; 1262 :             nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN82@Table_Hand:

; 1263 : 
; 1264 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN234@Table_Hand
$LN83@Table_Hand:

; 1265 : 
; 1266 :       case zDME_GET_VARIABLE:
; 1267 :          // We have already validated the ViewEntity prior to invoking the
; 1268 :          // Domain function.  We are doing the call again so that we may
; 1269 :          // easily retrieve the lpViewEntityCsr.
; 1270 :          lpViewEntityTemp = fnValidViewEntity( &lpViewEntityCsr, lpView,

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntityTemp$[ebp], eax

; 1271 :                                                lpViewEntity->szName, 0 );
; 1272 :          if ( chType != zTYPE_STRING )

	movsx	eax, BYTE PTR _chType$[ebp]
	cmp	eax, 83					; 00000053H
	je	$LN84@Table_Hand

; 1273 :          {
; 1274 :             switch ( chType )

	mov	cl, BYTE PTR _chType$[ebp]
	mov	BYTE PTR tv411[ebp], cl
	cmp	BYTE PTR tv411[ebp], 76			; 0000004cH
	je	SHORT $LN85@Table_Hand
	cmp	BYTE PTR tv411[ebp], 77			; 0000004dH
	je	SHORT $LN86@Table_Hand
	cmp	BYTE PTR tv411[ebp], 80			; 00000050H
	je	SHORT $LN87@Table_Hand
	jmp	$LN92@Table_Hand
$LN85@Table_Hand:

; 1275 :             {
; 1276 :                case zTYPE_INTEGER:
; 1277 :                   nRC = fnGetIntegerFromAttribute( (zPLONG) pvData, lpView,

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 1278 :                                                    lpViewEntityCsr,
; 1279 :                                                    lpViewAttribute );
; 1280 :                   break;

	jmp	$LN8@Table_Hand
$LN86@Table_Hand:

; 1281 : 
; 1282 :                case zTYPE_DECIMAL:
; 1283 :                   nRC = fnGetDecimalFromAttribute( (zPDECIMAL) pvData, lpView,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvData$[ebp]
	push	eax
	call	_fnGetDecimalFromAttribute
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 1284 :                                                    lpViewEntityCsr,
; 1285 :                                                    lpViewAttribute );
; 1286 :                   break;

	jmp	$LN8@Table_Hand
$LN87@Table_Hand:

; 1287 : 
; 1288 :                case zTYPE_PIC:
; 1289 :                   // return the picture string for the given context
; 1290 :                   {
; 1291 :                      zLPCONTEXT  lpContext;
; 1292 : 
; 1293 :                      lpContext = fnGetContext( zGETPTR( lpViewAttribute->hDomain ),

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	eax, DWORD PTR [edx+198]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpContext$16[ebp], eax

; 1294 :                                                cpcContextName );
; 1295 :                      if ( lpContext )

	cmp	DWORD PTR _lpContext$16[ebp], 0
	je	SHORT $LN88@Table_Hand

; 1296 :                      {
; 1297 :                         if ( lpContext->hEditString &&

	mov	ecx, DWORD PTR _lpContext$16[ebp]
	cmp	DWORD PTR [ecx+59], 0
	je	SHORT $LN90@Table_Hand
	mov	edx, DWORD PTR _lpContext$16[ebp]
	mov	eax, DWORD PTR [edx+59]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN90@Table_Hand

; 1298 :                              *((zPCHAR) zGETPTR( lpContext->hEditString )) )
; 1299 :                         {
; 1300 :                            zstrcpy( (zPCHAR) pvData,

	mov	edx, DWORD PTR _lpContext$16[ebp]
	mov	eax, DWORD PTR [edx+59]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1301 :                                     zGETPTR( lpContext->hEditString ) );
; 1302 :                         }

	jmp	SHORT $LN91@Table_Hand
$LN90@Table_Hand:

; 1303 :                         else
; 1304 :                            *((zPCHAR) pvData) = '\x00';

	mov	edx, DWORD PTR _pvData$[ebp]
	mov	BYTE PTR [edx], 0
$LN91@Table_Hand:

; 1305 : 
; 1306 :                         nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1307 :                      }

	jmp	SHORT $LN89@Table_Hand
$LN88@Table_Hand:

; 1308 :                      else
; 1309 :                      {
; 1310 :                         // "TZDME008 - Could not find context for Domain "
; 1311 :                         SendDomainError( lpView, lpDomain, 0, 8, 0,

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	8
	push	0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SendDomainError@28

; 1312 :                                          lpViewEntity->szName,
; 1313 :                                          lpViewAttribute->szName );
; 1314 :                         nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN89@Table_Hand:

; 1315 :                      }
; 1316 :                   }
; 1317 : 
; 1318 :                   break;

	jmp	SHORT $LN8@Table_Hand
$LN92@Table_Hand:

; 1319 : 
; 1320 :                default:
; 1321 :                   // "TZDME001 - Invalid input data type "
; 1322 :                   SendDomainError( lpView, lpDomain, 0, 1, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28

; 1323 :                                    lpViewEntity->szName,
; 1324 :                                    lpViewAttribute->szName );
; 1325 : 
; 1326 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN8@Table_Hand:

; 1327 :             }
; 1328 : 
; 1329 :             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN234@Table_Hand
$LN84@Table_Hand:

; 1330 :          }
; 1331 : 
; 1332 :          nRC = fnGetAddrForAttribute( (zCOREMEM) &lpInternalValue, lpView,

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpInternalValue$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 1333 :                                       lpViewEntityCsr, 0, lpViewAttribute );
; 1334 : 
; 1335 :          switch ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	mov	DWORD PTR tv471[ebp], edx
	cmp	DWORD PTR tv471[ebp], -1
	je	SHORT $LN93@Table_Hand
	cmp	DWORD PTR tv471[ebp], 0
	je	SHORT $LN94@Table_Hand
	jmp	SHORT $LN95@Table_Hand
$LN93@Table_Hand:

; 1336 :          {
; 1337 :             case -1:
; 1338 :                // If the value of the attribute is a 'null' value,
; 1339 :                // set the output to null
; 1340 :                *((zPCHAR) pvData) = 0;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	BYTE PTR [eax], 0

; 1341 :                return( -1 );

	or	eax, -1
	jmp	$LN234@Table_Hand
$LN94@Table_Hand:

; 1342 : 
; 1343 :             case 0:
; 1344 :                break;

	jmp	SHORT $LN10@Table_Hand
$LN95@Table_Hand:

; 1345 : 
; 1346 :             default:
; 1347 :                // error message issued from fnGetAddrForAttribute...
; 1348 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN10@Table_Hand:

; 1349 :          }
; 1350 : 
; 1351 :          // Perform a table lookup and conversion to external string value
; 1352 :          if ( lpViewAttribute->cType == zTYPE_DECIMAL )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN96@Table_Hand

; 1353 :          {
; 1354 :             SysConvertDecimalToLong( (zPDECIMAL) lpInternalValue, &lTempValue );

	lea	eax, DWORD PTR _lTempValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInternalValue$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8

; 1355 :             nRC = TableEntryIntToExt( szWorkString2, lpView,

	lea	edx, DWORD PTR _lTempValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	call	_TableEntryIntToExt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1356 :                                       lpDomain,
; 1357 :                                       cpcContextName, (zPVOID) &lTempValue );
; 1358 :          }

	jmp	SHORT $LN97@Table_Hand
$LN96@Table_Hand:

; 1359 :          else
; 1360 :          {
; 1361 :             nRC = TableEntryIntToExt( szWorkString2, lpView,

	mov	ecx, DWORD PTR _lpInternalValue$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString2$[ebp]
	push	edx
	call	_TableEntryIntToExt@20
	mov	WORD PTR _nRC$[ebp], ax
$LN97@Table_Hand:

; 1362 :                                       lpDomain,
; 1363 :                                       cpcContextName, lpInternalValue );
; 1364 :          }
; 1365 : 
; 1366 :          if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN98@Table_Hand

; 1367 :          {
; 1368 :             zULONG nLth = zstrlen( szWorkString2 );

	lea	ecx, DWORD PTR _szWorkString2$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$3[ebp], eax

; 1369 : 
; 1370 :             if ( nLth <= ulMaxStringLth )

	mov	edx, DWORD PTR _nLth$3[ebp]
	cmp	edx, DWORD PTR _ulMaxStringLth$[ebp]
	ja	SHORT $LN99@Table_Hand

; 1371 :                zstrcpy( (zPCHAR) pvData, szWorkString2 );

	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN98@Table_Hand
$LN99@Table_Hand:

; 1372 :             else
; 1373 :                zstrncpy( (zPCHAR) pvData, szWorkString2, ulMaxStringLth );

	mov	edx, DWORD PTR _ulMaxStringLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH
$LN98@Table_Hand:

; 1374 :          }
; 1375 : 
; 1376 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN234@Table_Hand
$LN101@Table_Hand:

; 1377 : 
; 1378 :       case zDME_COMPARE_ATTRIBUTE:
; 1379 :       {
; 1380 :          // If the pvData input is null or points to a null char, skip the
; 1381 :          // conversions, just null the attribute.
; 1382 :          zBOOL bNull = IsDataNull( pvData, chType );

	movzx	edx, BYTE PTR _chType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvData$[ebp]
	push	eax
	call	_IsDataNull
	add	esp, 8
	mov	BYTE PTR _bNull$19[ebp], al

; 1383 : 
; 1384 :          // We have already validated the ViewEntity prior to invoking the
; 1385 :          // Domain function.  We are doing the call again so that we may
; 1386 :          // easily retrieve the lpViewEntityCsr.
; 1387 :          lpViewEntityTemp = fnValidViewEntity( &lpViewEntityCsr, lpView,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntityTemp$[ebp], eax

; 1388 :                                                lpViewEntity->szName, 0 );
; 1389 :          switch ( chType )

	mov	cl, BYTE PTR _chType$[ebp]
	mov	BYTE PTR tv511[ebp], cl
	cmp	BYTE PTR tv511[ebp], 76			; 0000004cH
	jl	$LN157@Table_Hand
	cmp	BYTE PTR tv511[ebp], 77			; 0000004dH
	jle	$LN143@Table_Hand
	cmp	BYTE PTR tv511[ebp], 83			; 00000053H
	je	SHORT $LN102@Table_Hand
	jmp	$LN157@Table_Hand
$LN102@Table_Hand:

; 1390 :          {
; 1391 :             case zTYPE_STRING:
; 1392 :                switch ( lpViewAttribute->cType )

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	al, BYTE PTR [edx+202]
	mov	BYTE PTR tv514[ebp], al
	cmp	BYTE PTR tv514[ebp], 76			; 0000004cH
	jl	$LN142@Table_Hand
	cmp	BYTE PTR tv514[ebp], 77			; 0000004dH
	jle	$LN121@Table_Hand
	cmp	BYTE PTR tv514[ebp], 83			; 00000053H
	je	SHORT $LN103@Table_Hand
	jmp	$LN142@Table_Hand
$LN103@Table_Hand:

; 1393 :                {
; 1394 :                   case zTYPE_STRING:
; 1395 :                      // String to string with no context, just compare the
; 1396 :                      // attribute to the variable.
; 1397 :                      if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN106@Table_Hand
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	$LN104@Table_Hand
$LN106@Table_Hand:

; 1398 :                      {
; 1399 :                         zPCHAR  pchAttribute;
; 1400 : 
; 1401 :                         if ( bNull )

	movzx	edx, BYTE PTR _bNull$19[ebp]
	test	edx, edx
	je	SHORT $LN107@Table_Hand

; 1402 :                            pvData = (zPVOID) "";

	mov	DWORD PTR _pvData$[ebp], OFFSET $SG13975
$LN107@Table_Hand:

; 1403 : 
; 1404 :                         fnGetAddrForAttribute( (zCOREMEM) &pchAttribute,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttribute$15[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 1405 :                                                lpView, lpViewEntityCsr, 0,
; 1406 :                                                lpViewAttribute );
; 1407 :                         if ( lpViewAttribute->bCaseSens )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN108@Table_Hand

; 1408 :                            nRC = zstrcmp( pchAttribute, (zPCHAR) pvData );

	mov	eax, DWORD PTR _pchAttribute$15[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pvData$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN239@Table_Hand
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttribute$15[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv542[ebp], eax
	jmp	SHORT $LN240@Table_Hand
$LN239@Table_Hand:
	mov	eax, DWORD PTR _pchAttribute$15[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pvData$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN237@Table_Hand
	mov	DWORD PTR tv541[ebp], 1
	jmp	SHORT $LN238@Table_Hand
$LN237@Table_Hand:
	mov	DWORD PTR tv541[ebp], -1
$LN238@Table_Hand:
	mov	ecx, DWORD PTR tv541[ebp]
	mov	DWORD PTR tv542[ebp], ecx
$LN240@Table_Hand:
	mov	dx, WORD PTR tv542[ebp]
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN109@Table_Hand
$LN108@Table_Hand:

; 1409 :                         else
; 1410 :                            nRC = zstrcmpi( pchAttribute, (zPCHAR) pvData );

	mov	eax, DWORD PTR _pvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttribute$15[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN109@Table_Hand:

; 1411 : 
; 1412 :                         if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN110@Table_Hand

; 1413 :                            nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN111@Table_Hand
$LN110@Table_Hand:

; 1414 :                         else
; 1415 :                         if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN111@Table_Hand

; 1416 :                            nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN111@Table_Hand:

; 1417 : 
; 1418 :                         return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN234@Table_Hand

; 1419 :                      }

	jmp	$LN121@Table_Hand
$LN104@Table_Hand:

; 1420 :                      else
; 1421 :                      {
; 1422 :                         // String to string with context, convert input
; 1423 :                         // pvData from external to internal, not found
; 1424 :                         // returns -1, else compare the attribute to the
; 1425 :                         // returned internal value.
; 1426 :                         nRC = TableEntryExtToInt( (zPVOID) szWorkString,

	mov	eax, DWORD PTR _pvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1427 :                                                   lpView, lpDomain,
; 1428 :                                                   cpcContextName,
; 1429 :                                                   (zPCHAR) pvData );
; 1430 :                         if ( nRC < 0 && bNull )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN113@Table_Hand
	movzx	eax, BYTE PTR _bNull$19[ebp]
	test	eax, eax
	je	SHORT $LN113@Table_Hand

; 1431 :                         {
; 1432 :                            szWorkString[ 0 ] = 0; // null is always acceptable

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T9[ebp], edx
	cmp	DWORD PTR $T9[ebp], 257			; 00000101H
	jae	SHORT $LN241@Table_Hand
	jmp	SHORT $LN242@Table_Hand
$LN241@Table_Hand:
	call	___report_rangecheckfailure
$LN242@Table_Hand:
	mov	eax, DWORD PTR $T9[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0

; 1433 :                            nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN113@Table_Hand:

; 1434 :                         }
; 1435 : 
; 1436 :                         if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN114@Table_Hand

; 1437 :                         {
; 1438 :                            zPCHAR   pchAttribute;
; 1439 : 
; 1440 :                            fnGetAddrForAttribute( (zCOREMEM) &pchAttribute,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttribute$14[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 1441 :                                                   lpView, lpViewEntityCsr, 0,
; 1442 :                                                   lpViewAttribute );
; 1443 :                            if ( lpViewAttribute->bCaseSens )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN116@Table_Hand

; 1444 :                               nRC = zstrcmp( pchAttribute, szWorkString );

	mov	eax, DWORD PTR _pchAttribute$14[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN245@Table_Hand
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttribute$14[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv619[ebp], eax
	jmp	SHORT $LN246@Table_Hand
$LN245@Table_Hand:
	mov	edx, DWORD PTR _pchAttribute$14[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN243@Table_Hand
	mov	DWORD PTR tv618[ebp], 1
	jmp	SHORT $LN244@Table_Hand
$LN243@Table_Hand:
	mov	DWORD PTR tv618[ebp], -1
$LN244@Table_Hand:
	mov	edx, DWORD PTR tv618[ebp]
	mov	DWORD PTR tv619[ebp], edx
$LN246@Table_Hand:
	mov	ax, WORD PTR tv619[ebp]
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN117@Table_Hand
$LN116@Table_Hand:

; 1445 :                            else
; 1446 :                               nRC = zstrcmpi( pchAttribute, szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttribute$14[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN117@Table_Hand:

; 1447 : 
; 1448 :                            if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN118@Table_Hand

; 1449 :                               nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN119@Table_Hand
$LN118@Table_Hand:

; 1450 :                            else
; 1451 :                            if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN119@Table_Hand

; 1452 :                               nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN119@Table_Hand:

; 1453 : 
; 1454 :                            return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN234@Table_Hand

; 1455 :                         }

	jmp	SHORT $LN121@Table_Hand
$LN114@Table_Hand:

; 1456 :                         else
; 1457 :                         {
; 1458 :                            // "TZDME025 - Invalid table value "
; 1459 :                            SendDomainError( lpView, lpDomain, 0, 25, 0,

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	25					; 00000019H
	push	0
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SendDomainError@28

; 1460 :                                             lpViewEntity->szName,
; 1461 :                                             lpViewAttribute->szName );
; 1462 :                            return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN121@Table_Hand:

; 1463 :                         }
; 1464 :                      }
; 1465 : 
; 1466 :                   case zTYPE_INTEGER:
; 1467 :                   case zTYPE_DECIMAL:
; 1468 :                      // If there is no ContextName passed, use the Domain
; 1469 :                      // name as ContextName.  In any event, use
; 1470 :                      // TableEntryExtToInt to determine if the external value
; 1471 :                      // passed is found under the correct Context.
; 1472 :                      //
; 1473 :                      // Note that in this case, we are NOT differentiating
; 1474 :                      // between < or >, but only between not equal and equal.
; 1475 : 
; 1476 :                      {
; 1477 :                         zPCHAR  pchContextName;
; 1478 : 
; 1479 :                         if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN124@Table_Hand
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN122@Table_Hand
$LN124@Table_Hand:

; 1480 :                            pchContextName = lpDomain->szName;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	mov	DWORD PTR _pchContextName$11[ebp], eax
	jmp	SHORT $LN123@Table_Hand
$LN122@Table_Hand:

; 1481 :                         else
; 1482 :                            pchContextName = (zPCHAR) cpcContextName;

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	mov	DWORD PTR _pchContextName$11[ebp], ecx
$LN123@Table_Hand:

; 1483 : 
; 1484 :                         if ( lpViewAttribute->cType == zTYPE_DECIMAL )

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	$LN125@Table_Hand

; 1485 :                         {
; 1486 :                            nRC = TableEntryExtToInt( (zPVOID) &dTempValue, lpView, lpDomain,

	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchContextName$11[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dTempValue$[ebp]
	push	edx
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1487 :                                                      pchContextName, (zPCHAR) pvData );
; 1488 :                            if ( nRC < 0 && bNull )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN127@Table_Hand
	movzx	ecx, BYTE PTR _bNull$19[ebp]
	test	ecx, ecx
	je	SHORT $LN127@Table_Hand

; 1489 :                               lWork = lNullInteger; // null is always acceptable

	mov	edx, DWORD PTR _lNullInteger
	mov	DWORD PTR _lWork$[ebp], edx
	jmp	SHORT $LN128@Table_Hand
$LN127@Table_Hand:

; 1490 :                            else
; 1491 :                            if ( *((zPLONG) &dTempValue) == lNullInteger )

	mov	eax, DWORD PTR _dTempValue$[ebp]
	cmp	eax, DWORD PTR _lNullInteger
	jne	SHORT $LN129@Table_Hand

; 1492 :                               lWork = lNullInteger;

	mov	ecx, DWORD PTR _lNullInteger
	mov	DWORD PTR _lWork$[ebp], ecx
	jmp	SHORT $LN128@Table_Hand
$LN129@Table_Hand:

; 1493 :                            else
; 1494 :                               SysConvertDecimalToLong( &dTempValue, &lWork );

	lea	edx, DWORD PTR _lWork$[ebp]
	push	edx
	lea	eax, DWORD PTR _dTempValue$[ebp]
	push	eax
	call	_SysConvertDecimalToLong@8
$LN128@Table_Hand:

; 1495 : 
; 1496 :                            nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 1497 :                         }

	jmp	SHORT $LN126@Table_Hand
$LN125@Table_Hand:

; 1498 :                         else
; 1499 :                         {
; 1500 :                            nRC = TableEntryExtToInt( (zPVOID) &lWork, lpView, lpDomain,

	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchContextName$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lWork$[ebp]
	push	eax
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1501 :                                                      pchContextName, (zPCHAR) pvData );
; 1502 :                            if ( nRC < 0 && bNull )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN126@Table_Hand
	movzx	edx, BYTE PTR _bNull$19[ebp]
	test	edx, edx
	je	SHORT $LN126@Table_Hand

; 1503 :                            {
; 1504 :                               lWork = lNullInteger; // null is always acceptable

	mov	eax, DWORD PTR _lNullInteger
	mov	DWORD PTR _lWork$[ebp], eax

; 1505 :                               nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN126@Table_Hand:

; 1506 :                            }
; 1507 :                         }
; 1508 : 
; 1509 :                         if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN132@Table_Hand

; 1510 :                         {
; 1511 :                            zLONG lZero = 0;

	mov	DWORD PTR _lZero$1[ebp], 0

; 1512 : 
; 1513 :                            fnGetAddrForAttribute( (zCOREMEM) &lplInteger, lpView,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lplInteger$[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 1514 :                                                   lpViewEntityCsr, 0, lpViewAttribute );
; 1515 : 
; 1516 :                            if ( lpViewAttribute->cType == zTYPE_DECIMAL )

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN134@Table_Hand

; 1517 :                            {
; 1518 :                               if ( SysCompareDecimalToNull( (zPDECIMAL) lplInteger ) == 0 )

	mov	eax, DWORD PTR _lplInteger$[ebp]
	push	eax
	call	_SysCompareDecimalToNull@4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN136@Table_Hand

; 1519 :                                  lTempValue = lNullInteger;

	mov	edx, DWORD PTR _lNullInteger
	mov	DWORD PTR _lTempValue$[ebp], edx
	jmp	SHORT $LN137@Table_Hand
$LN136@Table_Hand:

; 1520 :                               else
; 1521 :                                  SysConvertDecimalToLong( (zPDECIMAL) lplInteger,

	lea	eax, DWORD PTR _lTempValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lplInteger$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8
$LN137@Table_Hand:

; 1522 :                                                           &lTempValue );
; 1523 :                            }

	jmp	SHORT $LN135@Table_Hand
$LN134@Table_Hand:

; 1524 :                            else
; 1525 :                            {
; 1526 :                               lTempValue = *lplInteger;

	mov	edx, DWORD PTR _lplInteger$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lTempValue$[ebp], eax
$LN135@Table_Hand:

; 1527 :                            }
; 1528 : 
; 1529 :                            // for compatibility reasons:
; 1530 :                            //  NULL attribute compared to 0 matches
; 1531 :                            if ( lTempValue == lWork ||

	mov	ecx, DWORD PTR _lTempValue$[ebp]
	cmp	ecx, DWORD PTR _lWork$[ebp]
	je	SHORT $LN140@Table_Hand
	mov	edx, DWORD PTR _lTempValue$[ebp]
	cmp	edx, DWORD PTR _lNullInteger
	jne	SHORT $LN138@Table_Hand
	cmp	DWORD PTR _lWork$[ebp], 0
	jne	SHORT $LN138@Table_Hand
$LN140@Table_Hand:

; 1532 :                                 (lTempValue == lNullInteger && lWork == 0) )
; 1533 :                            {
; 1534 :                               return( 0 );

	xor	eax, eax
	jmp	$LN234@Table_Hand

; 1535 :                            }

	jmp	SHORT $LN139@Table_Hand
$LN138@Table_Hand:

; 1536 :                            else
; 1537 :                               return( lTempValue < lWork ? -1 : 1 );

	mov	eax, DWORD PTR _lTempValue$[ebp]
	cmp	eax, DWORD PTR _lWork$[ebp]
	jge	SHORT $LN247@Table_Hand
	mov	DWORD PTR tv690[ebp], -1
	jmp	SHORT $LN248@Table_Hand
$LN247@Table_Hand:
	mov	DWORD PTR tv690[ebp], 1
$LN248@Table_Hand:
	mov	ax, WORD PTR tv690[ebp]
	jmp	$LN234@Table_Hand
$LN139@Table_Hand:

; 1538 :                         }

	jmp	SHORT $LN142@Table_Hand
$LN132@Table_Hand:

; 1539 :                         else
; 1540 :                         {
; 1541 :                            if ( nRC == -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN141@Table_Hand

; 1542 :                            {
; 1543 :                               // "TZDME025 - Invalid table value "
; 1544 :                               SendDomainError( lpView, lpDomain, 0, 25, 0,

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	25					; 00000019H
	push	0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SendDomainError@28
$LN141@Table_Hand:

; 1545 :                                                lpViewEntity->szName,
; 1546 :                                                lpViewAttribute->szName );
; 1547 :                            }
; 1548 : 
; 1549 :                            return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN142@Table_Hand:

; 1550 :                         }
; 1551 :                      }
; 1552 : 
; 1553 :                   default:
; 1554 :                      // "TZDME001 - Invalid input data type "
; 1555 :                      SendDomainError( lpView, lpDomain, 0, 1, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28

; 1556 :                                       lpViewEntity->szName,
; 1557 :                                       lpViewAttribute->szName );
; 1558 :                      return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN143@Table_Hand:

; 1559 :                }
; 1560 : 
; 1561 :             case zTYPE_INTEGER:
; 1562 :             case zTYPE_DECIMAL:
; 1563 : 
; 1564 :                // When both the variable coming in and the target Domain are
; 1565 :                // integer/decimal, we will do an internal value compare and
; 1566 :                // forget the Context. In all cases we will convert the values
; 1567 :                // to integer before making the compare.
; 1568 : 
; 1569 :                if ( lpViewAttribute->cType == zTYPE_INTEGER ||

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	je	SHORT $LN146@Table_Hand
	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 77					; 0000004dH
	jne	$LN157@Table_Hand
$LN146@Table_Hand:

; 1570 :                     lpViewAttribute->cType == zTYPE_DECIMAL )
; 1571 :                {
; 1572 :                   if ( chType == zTYPE_DECIMAL )

	movsx	edx, BYTE PTR _chType$[ebp]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN147@Table_Hand

; 1573 :                      SysConvertDecimalToLong( (zPDECIMAL) pvData, &lTempValue );

	lea	eax, DWORD PTR _lTempValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8
	jmp	SHORT $LN148@Table_Hand
$LN147@Table_Hand:

; 1574 :                   else
; 1575 :                      lTempValue = (zLONG) *((zPLONG) pvData);

	mov	edx, DWORD PTR _pvData$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lTempValue$[ebp], eax
$LN148@Table_Hand:

; 1576 : 
; 1577 :                   fnGetAddrForAttribute( (zCOREMEM) &lplInteger, lpView,

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lplInteger$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 1578 :                                           lpViewEntityCsr, 0, lpViewAttribute );
; 1579 : 
; 1580 :                   if ( lpViewAttribute->cType == zTYPE_DECIMAL )

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN149@Table_Hand

; 1581 :                   {
; 1582 :                      if ( SysCompareDecimalToNull( (zPDECIMAL) lplInteger ) == 0 )

	mov	ecx, DWORD PTR _lplInteger$[ebp]
	push	ecx
	call	_SysCompareDecimalToNull@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN151@Table_Hand

; 1583 :                         lTempValue2 = 0;

	mov	DWORD PTR _lTempValue2$[ebp], 0
	jmp	SHORT $LN152@Table_Hand
$LN151@Table_Hand:

; 1584 :                      else
; 1585 :                      {
; 1586 :                         SysConvertDecimalToLong( (zPDECIMAL) lplInteger,

	lea	eax, DWORD PTR _lTempValue2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lplInteger$[ebp]
	push	ecx
	call	_SysConvertDecimalToLong@8
$LN152@Table_Hand:

; 1587 :                                                  &lTempValue2 );
; 1588 :                      }
; 1589 :                   }

	jmp	SHORT $LN150@Table_Hand
$LN149@Table_Hand:

; 1590 :                   else
; 1591 :                   {
; 1592 :                      if ( *lplInteger == lNullInteger )

	mov	edx, DWORD PTR _lplInteger$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lNullInteger
	jne	SHORT $LN153@Table_Hand

; 1593 :                         lTempValue2 = 0;

	mov	DWORD PTR _lTempValue2$[ebp], 0
	jmp	SHORT $LN150@Table_Hand
$LN153@Table_Hand:

; 1594 :                      else
; 1595 :                         lTempValue2 = (zLONG) *((zPLONG) lplInteger);

	mov	ecx, DWORD PTR _lplInteger$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lTempValue2$[ebp], edx
$LN150@Table_Hand:

; 1596 :                   }
; 1597 : 
; 1598 :                   // Now do the compare.
; 1599 :                   if ( lTempValue == lTempValue2 )

	mov	eax, DWORD PTR _lTempValue$[ebp]
	cmp	eax, DWORD PTR _lTempValue2$[ebp]
	jne	SHORT $LN155@Table_Hand

; 1600 :                      return( 0 );

	xor	eax, eax
	jmp	$LN234@Table_Hand
	jmp	SHORT $LN157@Table_Hand
$LN155@Table_Hand:

; 1601 :                   else
; 1602 :                      return( (lTempValue2 < lTempValue) ? -1 : 1 );

	mov	ecx, DWORD PTR _lTempValue2$[ebp]
	cmp	ecx, DWORD PTR _lTempValue$[ebp]
	jge	SHORT $LN249@Table_Hand
	mov	DWORD PTR tv744[ebp], -1
	jmp	SHORT $LN250@Table_Hand
$LN249@Table_Hand:
	mov	DWORD PTR tv744[ebp], 1
$LN250@Table_Hand:
	mov	ax, WORD PTR tv744[ebp]
	jmp	$LN234@Table_Hand
$LN157@Table_Hand:

; 1603 :                }
; 1604 :                else
; 1605 :                   ; // fall into default code, for error processing
; 1606 : 
; 1607 :             default:
; 1608 :                // "TZDME001 - Invalid input data type "
; 1609 :                SendDomainError( lpView, lpDomain, 0, 1, 0,

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SendDomainError@28

; 1610 :                                 lpViewEntity->szName,
; 1611 :                                 lpViewAttribute->szName );
; 1612 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN158@Table_Hand:

; 1613 :          }
; 1614 : 
; 1615 :          // FALL THROUGH!!!
; 1616 :          // FALL THROUGH!!!
; 1617 :          // FALL THROUGH!!!
; 1618 :       }
; 1619 : 
; 1620 :       case zDME_GET_FIRST_TBL_ENT_FOR_ATTR:
; 1621 :       case zDME_GET_NEXT_TBL_ENT_FOR_ATTR:
; 1622 :       {
; 1623 :          zLONG lFlag;
; 1624 : 
; 1625 :          if ( lpViewAttribute->bRequired )

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 4
	and	ecx, 1
	je	SHORT $LN159@Table_Hand

; 1626 :             lFlag = 1;

	mov	DWORD PTR _lFlag$13[ebp], 1
	jmp	SHORT $LN160@Table_Hand
$LN159@Table_Hand:

; 1627 :          else
; 1628 :             lFlag = 0;

	mov	DWORD PTR _lFlag$13[ebp], 0
$LN160@Table_Hand:

; 1629 : 
; 1630 :          if ( lEntryType == zDME_GET_NEXT_TBL_ENT_FOR_ATTR )

	cmp	DWORD PTR _lEntryType$[ebp], 5
	jne	SHORT $LN161@Table_Hand

; 1631 :            lFlag += 2;  // asking for next

	mov	edx, DWORD PTR _lFlag$13[ebp]
	add	edx, 2
	mov	DWORD PTR _lFlag$13[ebp], edx
$LN161@Table_Hand:

; 1632 : 
; 1633 :          nRC = fnGetTableEntryForDomain( lpView, lpViewEntity, lpViewAttribute,

	mov	eax, DWORD PTR _lFlag$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvTablePosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnGetTableEntryForDomain@32
	mov	WORD PTR _nRC$[ebp], ax

; 1634 :                                          lpDomain, cpcContextName,
; 1635 :                                          pvData, pvTablePosition, lFlag );
; 1636 :          if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN162@Table_Hand

; 1637 :          {
; 1638 :             // "TZDME008 - Could not find context for Domain "
; 1639 :             SendDomainError( lpView, lpDomain, 0, 8, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	8
	push	0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28
$LN162@Table_Hand:

; 1640 :                              lpViewEntity->szName,
; 1641 :                              lpViewAttribute->szName );
; 1642 :          }
; 1643 : 
; 1644 :          break;

	jmp	$LN2@Table_Hand
$LN163@Table_Hand:

; 1645 :       }
; 1646 : 
; 1647 :       case zDME_SET_ATTRIBUTE_VALUE_NEXT:
; 1648 :       case zDME_SET_ATTRIBUTE_VALUE_PREV:
; 1649 :       {
; 1650 :          zCHAR             c;
; 1651 :          zLPCONTEXT        lpSrchContext;
; 1652 :          LPTABLEENTRY      lpTableEntry;
; 1653 :          zPVOID            lpAttrValue;
; 1654 :          zCHAR             cAttrType;
; 1655 :          zULONG            uAttrLth;
; 1656 : 
; 1657 :          nRC = GetValueFromRecord( lpView, lpViewEntity, lpViewAttribute,

	lea	ecx, DWORD PTR _uAttrLth$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _cAttrType$12[ebp]
	push	edx
	lea	eax, DWORD PTR _lpAttrValue$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_GetValueFromRecord@24
	mov	WORD PTR _nRC$[ebp], ax

; 1658 :                                    (zCOREMEM) &lpAttrValue,
; 1659 :                                    &cAttrType, &uAttrLth );
; 1660 :          if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN164@Table_Hand

; 1661 :          {
; 1662 :             // error message issued by lower level routine...
; 1663 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN234@Table_Hand
$LN164@Table_Hand:

; 1664 :          }
; 1665 : 
; 1666 :          if ( lpAttrValue == 0 )

	cmp	DWORD PTR _lpAttrValue$17[ebp], 0
	jne	SHORT $LN165@Table_Hand

; 1667 :          {
; 1668 :             // Attribute value is null, it cannot be set to prev/next value
; 1669 :             nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 1670 :             break;

	jmp	$LN2@Table_Hand
$LN165@Table_Hand:

; 1671 :          }
; 1672 : 
; 1673 :          if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN168@Table_Hand
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN166@Table_Hand
$LN168@Table_Hand:

; 1674 :             GetDefaultContext( &lpSrchContext, lpDomain );

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSrchContext$18[ebp]
	push	edx
	call	_GetDefaultContext@8
	jmp	SHORT $LN167@Table_Hand
$LN166@Table_Hand:

; 1675 :          else
; 1676 :             lpSrchContext = fnGetContext( lpDomain, cpcContextName );

	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpSrchContext$18[ebp], eax
$LN167@Table_Hand:

; 1677 : 
; 1678 :          c = lpDomain->cType;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	al, BYTE PTR [edx+63]
	mov	BYTE PTR _c$21[ebp], al

; 1679 : 
; 1680 :          if ( lpSrchContext )

	cmp	DWORD PTR _lpSrchContext$18[ebp], 0
	je	$LN169@Table_Hand

; 1681 :          {
; 1682 :             // The context for this domain has been located. Scan the table
; 1683 :             // for the current value of the attribute.
; 1684 :             lpTableEntry = zGETPTR( lpSrchContext->hFirstTableEntry );

	mov	ecx, DWORD PTR _lpSrchContext$18[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax
$LN16@Table_Hand:

; 1685 :             while ( lpTableEntry )

	cmp	DWORD PTR _lpTableEntry$20[ebp], 0
	je	$LN17@Table_Hand

; 1686 :             {
; 1687 :                if ( c == zTYPE_INTEGER )

	movsx	eax, BYTE PTR _c$21[ebp]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN171@Table_Hand

; 1688 :                {
; 1689 :                   if ( lpTableEntry->unInternal.lInteger ==

	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	mov	edx, DWORD PTR _lpAttrValue$17[ebp]
	mov	eax, DWORD PTR [ecx+26]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN173@Table_Hand

; 1690 :                        *((zPLONG)lpAttrValue) )
; 1691 :                      break;

	jmp	$LN17@Table_Hand
$LN173@Table_Hand:

; 1692 :                }

	jmp	$LN172@Table_Hand
$LN171@Table_Hand:

; 1693 :                else
; 1694 :                {
; 1695 :                   if ( lpTableEntry->unInternal.hStringValue )

	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	$LN174@Table_Hand

; 1696 :                   {
; 1697 :                      if ( zstrcmp( zGETPTR( lpTableEntry->
; 1698 :                                                   unInternal.hStringValue ),
; 1699 :                                    (zPCHAR) lpAttrValue ) == 0 )

	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpAttrValue$17[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN253@Table_Hand
	mov	ecx, DWORD PTR _lpAttrValue$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv838[ebp], eax
	jmp	SHORT $LN254@Table_Hand
$LN253@Table_Hand:
	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	movsx	eax, BYTE PTR [eax]
	mov	ecx, DWORD PTR _lpAttrValue$17[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN251@Table_Hand
	mov	DWORD PTR tv837[ebp], 1
	jmp	SHORT $LN252@Table_Hand
$LN251@Table_Hand:
	mov	DWORD PTR tv837[ebp], -1
$LN252@Table_Hand:
	mov	eax, DWORD PTR tv837[ebp]
	mov	DWORD PTR tv838[ebp], eax
$LN254@Table_Hand:
	cmp	DWORD PTR tv838[ebp], 0
	jne	SHORT $LN176@Table_Hand

; 1700 :                      {
; 1701 :                         break;

	jmp	SHORT $LN17@Table_Hand
$LN176@Table_Hand:

; 1702 :                      }
; 1703 :                   }

	jmp	SHORT $LN172@Table_Hand
$LN174@Table_Hand:

; 1704 :                   else
; 1705 :                   {
; 1706 :                      if ( *((zPCHAR) lpAttrValue) == 0 )

	mov	ecx, DWORD PTR _lpAttrValue$17[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN172@Table_Hand

; 1707 :                         break;

	jmp	SHORT $LN17@Table_Hand
$LN172@Table_Hand:

; 1708 :                   }
; 1709 :                }
; 1710 : 
; 1711 :                lpTableEntry = zGETPTR( lpTableEntry->hNextTableEntry );

	mov	eax, DWORD PTR _lpTableEntry$20[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax

; 1712 :             }

	jmp	$LN16@Table_Hand
$LN17@Table_Hand:

; 1713 : 
; 1714 :             if ( lpTableEntry )

	cmp	DWORD PTR _lpTableEntry$20[ebp], 0
	je	$LN178@Table_Hand

; 1715 :             {
; 1716 :                zPVOID         pvDataToStore;
; 1717 :                LPTABLEENTRY   lpOrigTableEntry;
; 1718 : 
; 1719 :                // We have found the current table entry.  Now go up or down
; 1720 :                // depending on the input operation id. Also note that we
; 1721 :                // perform wrap around processing.
; 1722 : 
; 1723 :                lpOrigTableEntry = lpTableEntry; // used to prevent looping

	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	mov	DWORD PTR _lpOrigTableEntry$8[ebp], edx

; 1724 : 
; 1725 :                if ( lEntryType == zDME_SET_ATTRIBUTE_VALUE_NEXT )

	cmp	DWORD PTR _lEntryType$[ebp], 6
	jne	$LN180@Table_Hand

; 1726 :                {
; 1727 :                   lpTableEntry = zGETPTR( lpTableEntry->hNextTableEntry );

	mov	eax, DWORD PTR _lpTableEntry$20[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax

; 1728 :                   if ( lpTableEntry == 0 )

	cmp	DWORD PTR _lpTableEntry$20[ebp], 0
	jne	SHORT $LN182@Table_Hand

; 1729 :                      lpTableEntry = zGETPTR( lpSrchContext->hFirstTableEntry );

	mov	edx, DWORD PTR _lpSrchContext$18[ebp]
	mov	eax, DWORD PTR [edx+47]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax
$LN182@Table_Hand:

; 1730 : 
; 1731 :                   if ( lpViewAttribute->bRequired &&

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 4
	and	edx, 1
	je	$LN183@Table_Hand
	movsx	eax, BYTE PTR _c$21[ebp]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN185@Table_Hand
	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	mov	edx, DWORD PTR [ecx+26]
	cmp	edx, DWORD PTR _lNullInteger
	je	SHORT $LN18@Table_Hand
$LN185@Table_Hand:
	movsx	eax, BYTE PTR _c$21[ebp]
	cmp	eax, 83					; 00000053H
	jne	$LN183@Table_Hand
	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	$LN183@Table_Hand
$LN18@Table_Hand:

; 1732 :                        ((c == zTYPE_INTEGER &&
; 1733 :                          lpTableEntry->unInternal.lInteger == lNullInteger) ||
; 1734 :                         (c == zTYPE_STRING &&
; 1735 :                          lpTableEntry->unInternal.hStringValue == 0)) )
; 1736 :                   {
; 1737 :                      while ( TRUE )

	mov	edx, 1
	test	edx, edx
	je	$LN183@Table_Hand

; 1738 :                      {
; 1739 :                         if ( (c == zTYPE_INTEGER &&
; 1740 :                               lpTableEntry->unInternal.lInteger == lNullInteger) ||

	movsx	eax, BYTE PTR _c$21[ebp]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN189@Table_Hand
	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	mov	edx, DWORD PTR [ecx+26]
	cmp	edx, DWORD PTR _lNullInteger
	je	SHORT $LN188@Table_Hand
$LN189@Table_Hand:
	movsx	eax, BYTE PTR _c$21[ebp]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN186@Table_Hand
	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $LN186@Table_Hand
$LN188@Table_Hand:

; 1741 :                              (c == zTYPE_STRING &&
; 1742 :                               lpTableEntry->unInternal.hStringValue == 0) )
; 1743 :                         {
; 1744 :                            lpTableEntry =

	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax

; 1745 :                                     zGETPTR( lpTableEntry->hNextTableEntry );
; 1746 :                            if ( lpTableEntry == 0 )

	cmp	DWORD PTR _lpTableEntry$20[ebp], 0
	jne	SHORT $LN190@Table_Hand

; 1747 :                               lpTableEntry =

	mov	ecx, DWORD PTR _lpSrchContext$18[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax
$LN190@Table_Hand:

; 1748 :                                   zGETPTR( lpSrchContext->hFirstTableEntry );
; 1749 : 
; 1750 :                            if ( lpTableEntry == lpOrigTableEntry )

	mov	eax, DWORD PTR _lpTableEntry$20[ebp]
	cmp	eax, DWORD PTR _lpOrigTableEntry$8[ebp]
	jne	SHORT $LN191@Table_Hand

; 1751 :                               return( 1 ); // indicate cannot set value

	mov	eax, 1
	jmp	$LN234@Table_Hand
$LN191@Table_Hand:

; 1752 :                         }

	jmp	SHORT $LN187@Table_Hand
$LN186@Table_Hand:

; 1753 :                         else
; 1754 :                            break;

	jmp	SHORT $LN183@Table_Hand
$LN187@Table_Hand:

; 1755 :                      }

	jmp	$LN18@Table_Hand
$LN183@Table_Hand:

; 1756 :                   }
; 1757 :                }

	jmp	$LN181@Table_Hand
$LN180@Table_Hand:

; 1758 :                else
; 1759 :                {
; 1760 :                   // ( lEntryType == zDME_SET_ATTRIBUTE_VALUE_PREV )
; 1761 :                   lpTableEntry = zGETPTR( lpTableEntry->hPrevTableEntry );

	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax

; 1762 :                   if ( lpTableEntry == 0 )

	cmp	DWORD PTR _lpTableEntry$20[ebp], 0
	jne	SHORT $LN192@Table_Hand

; 1763 :                      lpTableEntry = zGETPTR( lpSrchContext->hLastTableEntry );

	mov	eax, DWORD PTR _lpSrchContext$18[ebp]
	mov	ecx, DWORD PTR [eax+51]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax
$LN192@Table_Hand:

; 1764 : 
; 1765 :                   if ( lpViewAttribute->bRequired &&

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 4
	and	eax, 1
	je	$LN181@Table_Hand
	movsx	ecx, BYTE PTR _c$21[ebp]
	cmp	ecx, 76					; 0000004cH
	jne	SHORT $LN195@Table_Hand
	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	mov	eax, DWORD PTR [edx+26]
	cmp	eax, DWORD PTR _lNullInteger
	je	SHORT $LN20@Table_Hand
$LN195@Table_Hand:
	movsx	ecx, BYTE PTR _c$21[ebp]
	cmp	ecx, 83					; 00000053H
	jne	$LN181@Table_Hand
	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	cmp	DWORD PTR [edx+26], 0
	jne	$LN181@Table_Hand
$LN20@Table_Hand:

; 1766 :                        ((c == zTYPE_INTEGER &&
; 1767 :                          lpTableEntry->unInternal.lInteger == lNullInteger) ||
; 1768 :                         (c == zTYPE_STRING &&
; 1769 :                          lpTableEntry->unInternal.hStringValue == 0)) )
; 1770 :                   {
; 1771 :                      while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$LN181@Table_Hand

; 1772 :                      {
; 1773 :                         if ( (c == zTYPE_INTEGER &&
; 1774 :                               lpTableEntry->unInternal.lInteger == lNullInteger) ||

	movsx	ecx, BYTE PTR _c$21[ebp]
	cmp	ecx, 76					; 0000004cH
	jne	SHORT $LN199@Table_Hand
	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	mov	eax, DWORD PTR [edx+26]
	cmp	eax, DWORD PTR _lNullInteger
	je	SHORT $LN198@Table_Hand
$LN199@Table_Hand:
	movsx	ecx, BYTE PTR _c$21[ebp]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN196@Table_Hand
	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	cmp	DWORD PTR [edx+26], 0
	jne	SHORT $LN196@Table_Hand
$LN198@Table_Hand:

; 1775 :                              (c == zTYPE_STRING &&
; 1776 :                               lpTableEntry->unInternal.hStringValue == 0) )
; 1777 :                         {
; 1778 :                            lpTableEntry =

	mov	eax, DWORD PTR _lpTableEntry$20[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax

; 1779 :                                  zGETPTR( lpTableEntry->hPrevTableEntry );
; 1780 :                            if ( lpTableEntry == 0 )

	cmp	DWORD PTR _lpTableEntry$20[ebp], 0
	jne	SHORT $LN200@Table_Hand

; 1781 :                               lpTableEntry =

	mov	edx, DWORD PTR _lpSrchContext$18[ebp]
	mov	eax, DWORD PTR [edx+51]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$20[ebp], eax
$LN200@Table_Hand:

; 1782 :                                  zGETPTR( lpSrchContext->hLastTableEntry );
; 1783 : 
; 1784 :                            if ( lpTableEntry == lpOrigTableEntry )

	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	cmp	ecx, DWORD PTR _lpOrigTableEntry$8[ebp]
	jne	SHORT $LN201@Table_Hand

; 1785 :                               return( 1 ); // indicate cannot set value

	mov	eax, 1
	jmp	$LN234@Table_Hand
$LN201@Table_Hand:

; 1786 :                         }

	jmp	SHORT $LN197@Table_Hand
$LN196@Table_Hand:

; 1787 :                         else
; 1788 :                            break;

	jmp	SHORT $LN181@Table_Hand
$LN197@Table_Hand:

; 1789 :                      }

	jmp	$LN20@Table_Hand
$LN181@Table_Hand:

; 1790 :                   }
; 1791 :                }
; 1792 : 
; 1793 :                if ( c == zTYPE_INTEGER )

	movsx	edx, BYTE PTR _c$21[ebp]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN202@Table_Hand

; 1794 :                {
; 1795 :                   pvDataToStore = (zPVOID)

	mov	eax, DWORD PTR _lpTableEntry$20[ebp]
	add	eax, 26					; 0000001aH
	mov	DWORD PTR _pvDataToStore$10[ebp], eax

; 1796 :                                   &(lpTableEntry->unInternal.lInteger);
; 1797 :                }

	jmp	SHORT $LN203@Table_Hand
$LN202@Table_Hand:

; 1798 :                else
; 1799 :                {
; 1800 :                   if ( lpTableEntry->unInternal.hStringValue )

	mov	ecx, DWORD PTR _lpTableEntry$20[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN204@Table_Hand

; 1801 :                      pvDataToStore = (zPVOID)

	mov	edx, DWORD PTR _lpTableEntry$20[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pvDataToStore$10[ebp], eax
	jmp	SHORT $LN203@Table_Hand
$LN204@Table_Hand:

; 1802 :                             zGETPTR( lpTableEntry->unInternal.hStringValue );
; 1803 :                   else
; 1804 :                      pvDataToStore = (zPVOID) szNullS;

	mov	ecx, DWORD PTR _szNullS
	mov	DWORD PTR _pvDataToStore$10[ebp], ecx
$LN203@Table_Hand:

; 1805 :                }
; 1806 : 
; 1807 :                nRC = StoreValueInRecord( lpView, lpViewEntity,

	push	0
	mov	edx, DWORD PTR _pvDataToStore$10[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreValueInRecord@20
	mov	WORD PTR _nRC$[ebp], ax

; 1808 :                                          lpViewAttribute,
; 1809 :                                          pvDataToStore, 0 );
; 1810 :             }

	jmp	SHORT $LN179@Table_Hand
$LN178@Table_Hand:

; 1811 :             else
; 1812 :             {
; 1813 :                // "TZDME025 - Invalid table value "
; 1814 :                SendDomainError( lpView, lpDomain, 0, 25, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	25					; 00000019H
	push	0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28

; 1815 :                                 lpViewEntity->szName,
; 1816 :                                 lpViewAttribute->szName );
; 1817 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN179@Table_Hand:

; 1818 :             }
; 1819 :          }

	jmp	SHORT $LN170@Table_Hand
$LN169@Table_Hand:

; 1820 :          else
; 1821 :          {
; 1822 :             // "TZDME008 - Could not find context for Domain "
; 1823 :             SendDomainError( lpView, lpDomain, 0, 8, 0,

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	8
	push	0
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SendDomainError@28

; 1824 :                              lpViewEntity->szName,
; 1825 :                              lpViewAttribute->szName );
; 1826 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN170@Table_Hand:

; 1827 :          }
; 1828 : 
; 1829 :          break;

	jmp	$LN2@Table_Hand
$LN206@Table_Hand:

; 1830 :       }
; 1831 : 
; 1832 :       case zDME_ADD_TO_ATTRIBUTE:
; 1833 :          break;

	jmp	$LN2@Table_Hand
$LN207@Table_Hand:

; 1834 : 
; 1835 :       case zDME_GET_COMPARE_VALUE:
; 1836 :          //  -1 - pvData invalid, that is not found in table...
; 1837 :          //   0 - pvData unchanged, okay to use as is.
; 1838 :          //   1 - pvData returned, string value
; 1839 :          //   2 - pvData returned, integer value
; 1840 :          switch ( chType )

	mov	cl, BYTE PTR _chType$[ebp]
	mov	BYTE PTR tv952[ebp], cl
	cmp	BYTE PTR tv952[ebp], 76			; 0000004cH
	je	SHORT $LN208@Table_Hand
	cmp	BYTE PTR tv952[ebp], 83			; 00000053H
	je	$LN214@Table_Hand
	jmp	$LN228@Table_Hand
$LN208@Table_Hand:

; 1841 :          {
; 1842 :             case zTYPE_INTEGER:
; 1843 :                // Integer type data accepted only if the attribute data
; 1844 :                // type is integer.  If not zCALL_ERROR returned.
; 1845 :                if ( lpViewAttribute->cType != zTYPE_INTEGER )

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN209@Table_Hand

; 1846 :                   break;

	jmp	$LN22@Table_Hand
$LN209@Table_Hand:

; 1847 : 
; 1848 :                // If both the variable and attribute are of type integer and
; 1849 :                // no context is specified, the variable is returned as is.
; 1850 :                if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN212@Table_Hand
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN210@Table_Hand
$LN212@Table_Hand:

; 1851 :                   nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN211@Table_Hand
$LN210@Table_Hand:

; 1852 :                else
; 1853 :                {
; 1854 :                // If both the variable and attribute are of type integer
; 1855 :                // and a context is specified, convert the integer to a
; 1856 :                // a string, then locate the resultant string as
; 1857 :                // as an external value for the specified context,
; 1858 :                // and return the corresponding internal value.
; 1859 :                   zCHAR szIntString[ 16 ];
; 1860 :                   zLONG lInternalValue;
; 1861 : 
; 1862 :                   // convert to string then look up using context
; 1863 :                   zltoa( *((zPLONG) pvData), szIntString );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _szIntString$23[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1864 :                   nRC = TableEntryExtToInt( (zPVOID) &lInternalValue,

	lea	eax, DWORD PTR _szIntString$23[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lInternalValue$5[ebp]
	push	ecx
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1865 :                                             lpView,
; 1866 :                                             lpDomain,
; 1867 :                                             cpcContextName,
; 1868 :                                             (zPCHAR) szIntString );
; 1869 :                   // If TableEntryExtToInt returns a not found (-1)
; 1870 :                   // just return that along to the caller of the
; 1871 :                   // Table_Handler. (zCALL_ERROR gets passed along too.)
; 1872 :                   if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN211@Table_Hand

; 1873 :                   {
; 1874 :                      nRC = 2;

	mov	eax, 2
	mov	WORD PTR _nRC$[ebp], ax

; 1875 :                      *((zPLONG) pvData) = lInternalValue;

	mov	ecx, DWORD PTR _pvData$[ebp]
	mov	edx, DWORD PTR _lInternalValue$5[ebp]
	mov	DWORD PTR [ecx], edx
$LN211@Table_Hand:

; 1876 :                   }
; 1877 :                }
; 1878 : 
; 1879 :                break;

	jmp	$LN22@Table_Hand
$LN214@Table_Hand:

; 1880 : 
; 1881 :             case zTYPE_STRING:
; 1882 :                switch ( lpViewAttribute->cType )

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv974[ebp], cl
	cmp	BYTE PTR tv974[ebp], 76			; 0000004cH
	je	SHORT $LN215@Table_Hand
	cmp	BYTE PTR tv974[ebp], 83			; 00000053H
	je	$LN220@Table_Hand
	jmp	$LN225@Table_Hand
$LN215@Table_Hand:

; 1883 :                {
; 1884 :                   case zTYPE_INTEGER:
; 1885 :                      {
; 1886 :                         zLONG    lIntValue;
; 1887 :                         zPCHAR   pchContext;
; 1888 : 
; 1889 :                         if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN218@Table_Hand
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN216@Table_Hand
$LN218@Table_Hand:

; 1890 :                            pchContext = lpDomain->szName;

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	mov	DWORD PTR _pchContext$6[ebp], eax
	jmp	SHORT $LN217@Table_Hand
$LN216@Table_Hand:

; 1891 :                         else
; 1892 :                            pchContext = (zPCHAR) cpcContextName;

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	mov	DWORD PTR _pchContext$6[ebp], ecx
$LN217@Table_Hand:

; 1893 : 
; 1894 :                         // If the variable is of type string and the
; 1895 :                         // attribute is of type integer, locate an external
; 1896 :                         // value, within the specified context (or default
; 1897 :                         // context if non specified), that matches the
; 1898 :                         // the variable and return the corresponding internal
; 1899 :                         // table value.
; 1900 :                         nRC = TableEntryExtToInt( (zPVOID) &lIntValue, lpView,

	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchContext$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lIntValue$4[ebp]
	push	eax
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1901 :                                                   lpDomain,
; 1902 :                                                   pchContext,
; 1903 :                                                   (zPCHAR) pvData );
; 1904 :                         // If TableEntryExtToInt returns a not found (-1)
; 1905 :                         // just return that along to the caller of the
; 1906 :                         // Table_Handler. (zCALL_ERROR gets passed along too.)
; 1907 :                         if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN219@Table_Hand

; 1908 :                         {
; 1909 :                            nRC = 2;

	mov	edx, 2
	mov	WORD PTR _nRC$[ebp], dx

; 1910 :                            *((zPLONG) pvData) = lIntValue;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	ecx, DWORD PTR _lIntValue$4[ebp]
	mov	DWORD PTR [eax], ecx
$LN219@Table_Hand:

; 1911 :                         }
; 1912 :                      }
; 1913 : 
; 1914 :                      break;

	jmp	$LN24@Table_Hand
$LN220@Table_Hand:

; 1915 : 
; 1916 :                   case zTYPE_STRING:
; 1917 :                      // If both the variable and attribute are of type string
; 1918 :                      // and no context is specified, return value as is.
; 1919 : 
; 1920 :                      /* DGC 1999.01.21 Used to be but don't know why:
; 1921 : 
; 1922 :                      if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 ||
; 1923 :                           zstrcmp( cpcContextName, lpDomain->szName ) == 0 )
; 1924 : 
; 1925 :                      I changed it because if the domain and context are the same
; 1926 :                      we shouldn't ignore it.
; 1927 :                      */
; 1928 :                      if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN223@Table_Hand
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN221@Table_Hand
$LN223@Table_Hand:

; 1929 :                         nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN222@Table_Hand
$LN221@Table_Hand:

; 1930 :                      else
; 1931 :                      {
; 1932 :                         // If both the variable and the attribute are of type
; 1933 :                         // string and a context different from the Domain is
; 1934 :                         // specified, locate the external table value, with
; 1935 :                         // specified context, and return the corresponding
; 1936 :                         // internal value.
; 1937 :                         nRC = TableEntryExtToInt( (zPVOID) szWorkString, lpView,

	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_TableEntryExtToInt@20
	mov	WORD PTR _nRC$[ebp], ax

; 1938 :                                                   lpDomain,
; 1939 :                                                   cpcContextName,
; 1940 :                                                   (zPCHAR) pvData );
; 1941 :                         // If TableEntryExtToInt returns a not found (-1)
; 1942 :                         // just return that along to the caller of the
; 1943 :                         // Table_Handler. (zCALL_ERROR gets passed along too.)
; 1944 :                         if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN222@Table_Hand

; 1945 :                         {
; 1946 :                            nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 1947 :                            zstrcpy( (zPCHAR) pvData, szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvData$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN222@Table_Hand:

; 1948 :                         }
; 1949 :                      }
; 1950 : 
; 1951 :                      break;

	jmp	SHORT $LN24@Table_Hand
$LN225@Table_Hand:

; 1952 : 
; 1953 :                   default:
; 1954 :                      if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN226@Table_Hand

; 1955 :                         nSeverity = -1;

	or	ecx, -1
	mov	WORD PTR _nSeverity$[ebp], cx
	jmp	SHORT $LN227@Table_Hand
$LN226@Table_Hand:

; 1956 :                      else
; 1957 :                         nSeverity = 0;

	xor	edx, edx
	mov	WORD PTR _nSeverity$[ebp], dx
$LN227@Table_Hand:

; 1958 : 
; 1959 :                      // "TZDME003 - Attribute type invalid for this Domain "
; 1960 :                      SendDomainError( lpView, lpDomain, nSeverity, 3, 0,

	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	3
	movzx	edx, WORD PTR _nSeverity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SendDomainError@28
$LN24@Table_Hand:

; 1961 :                                       lpViewEntity->szName,
; 1962 :                                       lpViewAttribute->szName );
; 1963 :                      break;
; 1964 :                }
; 1965 : 
; 1966 :                break;

	jmp	SHORT $LN22@Table_Hand
$LN228@Table_Hand:

; 1967 : 
; 1968 :             default:
; 1969 :                if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN229@Table_Hand

; 1970 :                   nSeverity = -1;

	or	edx, -1
	mov	WORD PTR _nSeverity$[ebp], dx
	jmp	SHORT $LN230@Table_Hand
$LN229@Table_Hand:

; 1971 :                else
; 1972 :                   nSeverity = 0;

	xor	eax, eax
	mov	WORD PTR _nSeverity$[ebp], ax
$LN230@Table_Hand:

; 1973 : 
; 1974 :                // "TZDME001 - Invalid input data type "
; 1975 :                SendDomainError( lpView, lpDomain, nSeverity, 1, 0,

	mov	ecx, DWORD PTR _lpViewAttribute$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	1
	movzx	eax, WORD PTR _nSeverity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SendDomainError@28
$LN22@Table_Hand:

; 1976 :                                 lpViewEntity->szName,
; 1977 :                                 lpViewAttribute->szName );
; 1978 :                break;
; 1979 :          }
; 1980 : 
; 1981 :          break;

	jmp	SHORT $LN2@Table_Hand
$LN231@Table_Hand:

; 1982 : 
; 1983 :       default:
; 1984 :          if ( lEntryType == zDME_VALIDATE_LPDATA )

	cmp	DWORD PTR _lEntryType$[ebp], 10		; 0000000aH
	jne	SHORT $LN232@Table_Hand

; 1985 :             nSeverity = -1;

	or	eax, -1
	mov	WORD PTR _nSeverity$[ebp], ax
	jmp	SHORT $LN233@Table_Hand
$LN232@Table_Hand:

; 1986 :          else
; 1987 :             nSeverity = 0;

	xor	ecx, ecx
	mov	WORD PTR _nSeverity$[ebp], cx
$LN233@Table_Hand:

; 1988 : 
; 1989 :          // "TZDME001 - Invalid input data type "
; 1990 :          SendDomainError( lpView, lpDomain, nSeverity, 1, 0,

	mov	edx, DWORD PTR _lpViewAttribute$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	1
	movzx	ecx, WORD PTR _nSeverity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SendDomainError@28

; 1991 :                           lpViewEntity->szName,
; 1992 :                           lpViewAttribute->szName );
; 1993 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN234@Table_Hand
$LN2@Table_Hand:

; 1994 :    }
; 1995 : 
; 1996 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN234@Table_Hand:

; 1997 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
	npad	2
$LN255@Table_Hand:
	DD	$LN32@Table_Hand
	DD	$LN83@Table_Hand
	DD	$LN101@Table_Hand
	DD	$LN158@Table_Hand
	DD	$LN158@Table_Hand
	DD	$LN163@Table_Hand
	DD	$LN163@Table_Hand
	DD	$LN206@Table_Hand
	DD	$LN207@Table_Hand
	DD	$LN32@Table_Hand
_Table_Handler@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
tv218 = -300						; size = 4
_pch$ = -296						; size = 4
_lpContext$1 = -292					; size = 4
_lEntryType$2 = -288					; size = 4
_lpCurrentTask$3 = -284					; size = 4
_lpTaskDomain$4 = -280					; size = 4
tv80 = -276						; size = 4
_lpSrchContext$ = -272					; size = 4
_nRC$ = -268						; size = 2
_lpTableEntry$ = -264					; size = 4
_szWorkString$5 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewAttribute$ = 16					; size = 4
_lpDomain$ = 20						; size = 4
_cpcContextName$ = 24					; size = 4
_pvData$ = 28						; size = 4
_pvTablePosition$ = 32					; size = 4
_lFlag$ = 36						; size = 4
_fnGetTableEntryForDomain@32 PROC

; 752  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 753  :    LPTABLEENTRY lpTableEntry;
; 754  :    zLPCONTEXT   lpSrchContext;
; 755  :    zPCHAR       pch;
; 756  :    zSHORT       nRC;
; 757  : 
; 758  :    // If the table Domain has an operation, call the Domain Operation, instead
; 759  :    // of continuing processing here.
; 760  :    if ( lpDomain->szDomainOper[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpDomain$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+100]
	test	eax, eax
	je	$LN4@fnGetTable

; 761  :    {
; 762  :       zCHAR        szWorkString[ 256 ];
; 763  :       LPTASK       lpCurrentTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$3[ebp], eax

; 764  :       LPTASKDOMAIN lpTaskDomain = fnGetTaskDomain( lpView, lpCurrentTask, lpDomain );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetTaskDomain
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTaskDomain$4[ebp], eax

; 765  :       if ( lpTaskDomain->pfDomainOper )

	mov	eax, DWORD PTR _lpTaskDomain$4[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	$LN5@fnGetTable

; 766  :       {
; 767  :          zLONG lEntryType = (lFlag & 2) ? zDME_GET_NEXT_TBL_ENT_FOR_ATTR :

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 2
	je	SHORT $LN27@fnGetTable
	mov	DWORD PTR tv80[ebp], 5
	jmp	SHORT $LN28@fnGetTable
$LN27@fnGetTable:
	mov	DWORD PTR tv80[ebp], 4
$LN28@fnGetTable:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _lEntryType$2[ebp], edx

; 768  :                                           zDME_GET_FIRST_TBL_ENT_FOR_ATTR;
; 769  :          nRC = fnCallDomainOper( lpCurrentTask, lpTaskDomain,

	push	256					; 00000100H
	mov	eax, DWORD PTR _lpViewAttribute$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	movzx	eax, BYTE PTR [edx+63]
	push	eax
	mov	ecx, DWORD PTR _lEntryType$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskDomain$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$3[ebp]
	push	eax
	call	_fnCallDomainOper@40
	mov	WORD PTR _nRC$[ebp], ax

; 770  :                                  lEntryType,
; 771  :                                  lpDomain->cType, pvData,
; 772  :                                  cpcContextName, lpView,
; 773  :                                  lpViewEntity, lpViewAttribute, 256 );
; 774  :          if ( nRC == zDME_NOT_HANDLED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -10				; fffffff6H
	jne	SHORT $LN7@fnGetTable

; 775  :          {
; 776  :             zsprintf( szWorkString, "Operation '%s' does not handle an Entry "

	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lEntryType$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	push	OFFSET $SG13660
	lea	edx, DWORD PTR _szWorkString$5[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 777  :                       "Type of %ld for domain '%s'", lpDomain->szDomainOper,
; 778  :                       lEntryType, lpDomain->szName );
; 779  :             MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	eax, DWORD PTR _szWorkString$5[ebp]
	push	eax
	push	OFFSET $SG13661
	push	OFFSET $SG13662
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MessageSend@24
$LN7@fnGetTable:

; 780  :                          szWorkString, zMSGQ_DOMAIN_ERROR, 0 );
; 781  :          }
; 782  :       }

	jmp	SHORT $LN6@fnGetTable
$LN5@fnGetTable:

; 783  :       else
; 784  :       {
; 785  :          zstrcpy( szWorkString, "Operation, " );

	push	OFFSET $SG13663
	lea	edx, DWORD PTR _szWorkString$5[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 786  :          zstrcat( szWorkString, lpDomain->szDomainOper );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	lea	ecx, DWORD PTR _szWorkString$5[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 787  :          zstrcat( szWorkString, ", not found for Domain: " );

	push	OFFSET $SG13664
	lea	edx, DWORD PTR _szWorkString$5[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 788  :          zstrcat( szWorkString, lpDomain->szName );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _szWorkString$5[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 789  :          MessageSend( lpView, "TZDMD101", "System Error",

	push	0
	push	200					; 000000c8H
	lea	edx, DWORD PTR _szWorkString$5[ebp]
	push	edx
	push	OFFSET $SG13665
	push	OFFSET $SG13666
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_MessageSend@24

; 790  :                       szWorkString, zMSGQ_DOMAIN_ERROR, 0 );
; 791  :          nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN6@fnGetTable:

; 792  :       }
; 793  : 
; 794  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnGetTable
$LN4@fnGetTable:

; 795  :    }
; 796  : 
; 797  :    if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN10@fnGetTable
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN8@fnGetTable
$LN10@fnGetTable:

; 798  :       GetDefaultContext( &lpSrchContext, lpDomain );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrchContext$[ebp]
	push	ecx
	call	_GetDefaultContext@8
	jmp	SHORT $LN9@fnGetTable
$LN8@fnGetTable:

; 799  :    else
; 800  :       lpSrchContext = fnGetContext( lpDomain, cpcContextName );

	mov	edx, DWORD PTR _cpcContextName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpSrchContext$[ebp], eax
$LN9@fnGetTable:

; 801  : 
; 802  :    if ( lFlag & 2 )  // next

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 2
	je	$LN11@fnGetTable

; 803  :    {
; 804  :       zLPCONTEXT   lpContext;
; 805  : 
; 806  :       lpTableEntry = *((LPTABLEENTRY zFAR *) pvTablePosition );

	mov	edx, DWORD PTR _pvTablePosition$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpTableEntry$[ebp], eax

; 807  :       lpTableEntry = zGETPTR( lpTableEntry->hNextTableEntry );

	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$[ebp], eax

; 808  :       if ( lpTableEntry == 0 )

	cmp	DWORD PTR _lpTableEntry$[ebp], 0
	jne	SHORT $LN13@fnGetTable

; 809  :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnGetTable
$LN13@fnGetTable:

; 810  : 
; 811  :       // Verify that the pvTablePosition is valid (i.e.  pointing to a
; 812  :       // TableEntry struct, context names match, pointing to the same domain).
; 813  :       lpContext = zGETPTR( lpTableEntry->hContext );

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpContext$1[ebp], eax

; 814  :       if ( lpTableEntry->nTableID != iTableEntry ||
; 815  :            lpContext != lpSrchContext ||

	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10031				; 0000272fH
	jne	SHORT $LN15@fnGetTable
	mov	ecx, DWORD PTR _lpContext$1[ebp]
	cmp	ecx, DWORD PTR _lpSrchContext$[ebp]
	jne	SHORT $LN15@fnGetTable
	mov	edx, DWORD PTR _lpContext$1[ebp]
	mov	eax, DWORD PTR [edx+43]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpDomain$[ebp]
	je	SHORT $LN14@fnGetTable
$LN15@fnGetTable:

; 816  :            zGETPTR( lpContext->hDomain ) != lpDomain )
; 817  :       {
; 818  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetTable
$LN14@fnGetTable:

; 819  :       }
; 820  :    }

	jmp	SHORT $LN12@fnGetTable
$LN11@fnGetTable:

; 821  :    else
; 822  :    {
; 823  :       if ( lpSrchContext == 0 )

	cmp	DWORD PTR _lpSrchContext$[ebp], 0
	jne	SHORT $LN16@fnGetTable

; 824  :       {
; 825  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetTable
$LN16@fnGetTable:

; 826  :       }
; 827  : 
; 828  :       // The context for this domain has been located. Save position
; 829  :       // of the table entry (for GetNextTableEntryForAttribute)
; 830  :       // in the pvTablePosition parameter.  Let the 'external'
; 831  :       // routine return the external value for the first table entry.
; 832  :       lpTableEntry = zGETPTR( lpSrchContext->hFirstTableEntry );

	mov	ecx, DWORD PTR _lpSrchContext$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$[ebp], eax
$LN12@fnGetTable:

; 833  :    }
; 834  : 
; 835  :    // 1/5/93 jap
; 836  :    // For attributes that are marked as required (may not be null),
; 837  :    // do not return any table entry whose internal value is null.
; 838  :    if ( lFlag & 1 )  // required

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 1
	je	SHORT $LN17@fnGetTable
$LN2@fnGetTable:

; 839  :    {
; 840  :       while ( lpTableEntry )

	cmp	DWORD PTR _lpTableEntry$[ebp], 0
	je	SHORT $LN17@fnGetTable

; 841  :       {
; 842  :          if ( (lpDomain->cType == zTYPE_INTEGER &&
; 843  :                lpTableEntry->unInternal.lInteger == lNullInteger) ||
; 844  :               (lpDomain->cType == zTYPE_DECIMAL &&
; 845  :                lpTableEntry->unInternal.lInteger == lNullInteger) ||

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+63]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN21@fnGetTable
	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	cmp	ecx, DWORD PTR _lNullInteger
	je	SHORT $LN20@fnGetTable
$LN21@fnGetTable:
	mov	edx, DWORD PTR _lpDomain$[ebp]
	movsx	eax, BYTE PTR [edx+63]
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN22@fnGetTable
	mov	ecx, DWORD PTR _lpTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	cmp	edx, DWORD PTR _lNullInteger
	je	SHORT $LN20@fnGetTable
$LN22@fnGetTable:
	mov	eax, DWORD PTR _lpDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+63]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN18@fnGetTable
	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	cmp	DWORD PTR [edx+26], 0
	jne	SHORT $LN18@fnGetTable
$LN20@fnGetTable:

; 846  :               (lpDomain->cType == zTYPE_STRING &&
; 847  :                lpTableEntry->unInternal.hStringValue == 0) )
; 848  :          {
; 849  :             lpTableEntry = zGETPTR( lpTableEntry->hNextTableEntry );

	mov	eax, DWORD PTR _lpTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTableEntry$[ebp], eax

; 850  :          }

	jmp	SHORT $LN19@fnGetTable
$LN18@fnGetTable:

; 851  :          else
; 852  :             break;

	jmp	SHORT $LN17@fnGetTable
$LN19@fnGetTable:

; 853  :       }

	jmp	SHORT $LN2@fnGetTable
$LN17@fnGetTable:

; 854  :    }
; 855  : 
; 856  :    // Return the external value in pvData.
; 857  :    if ( lpTableEntry )

	cmp	DWORD PTR _lpTableEntry$[ebp], 0
	je	SHORT $LN23@fnGetTable

; 858  :    {
; 859  :       pch = fnGetTextForTableEntry( lpTableEntry );

	mov	edx, DWORD PTR _lpTableEntry$[ebp]
	push	edx
	call	_fnGetTextForTableEntry
	add	esp, 4
	mov	DWORD PTR _pch$[ebp], eax

; 860  :       if ( pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN24@fnGetTable

; 861  :          zstrcpy( (zPCHAR) pvData, pch );

	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvData$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN23@fnGetTable
$LN24@fnGetTable:

; 862  :       else
; 863  :          *((zPCHAR) pvData ) = 0;

	mov	edx, DWORD PTR _pvData$[ebp]
	mov	BYTE PTR [edx], 0
$LN23@fnGetTable:

; 864  :    }
; 865  : 
; 866  :    // Return the table position in pvTablePosition.
; 867  :    zmemcpy( pvTablePosition, (zPVOID) &lpTableEntry, sizeof( zPVOID ) );

	push	4
	lea	eax, DWORD PTR _lpTableEntry$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvTablePosition$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 868  : 
; 869  :    nRC = *((LPTABLEENTRY zFAR *) pvTablePosition) ? 0 : -1 ; // -1 is end of table

	mov	edx, DWORD PTR _pvTablePosition$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN29@fnGetTable
	mov	DWORD PTR tv218[ebp], 0
	jmp	SHORT $LN30@fnGetTable
$LN29@fnGetTable:
	mov	DWORD PTR tv218[ebp], -1
$LN30@fnGetTable:
	mov	ax, WORD PTR tv218[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 870  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnGetTable:

; 871  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_fnGetTableEntryForDomain@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_lpApp$ = -24						; size = 4
_lpCurrentTask$ = -20					; size = 4
tv89 = -16						; size = 4
tv88 = -12						; size = 4
_lpDomain$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpReturnContext$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcDomainName$ = 16					; size = 4
_SfGetDefaultContextForDomain@12 PROC

; 314  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 315  :    LPTASK   lpCurrentTask;
; 316  :    LPAPP    lpApp;
; 317  :    LPDOMAIN lpDomain;
; 318  :    zSHORT   nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 319  : 
; 320  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 321  :    if ( (lpCurrentTask = fnOperationCall( iSfGetDefaultContextForDomain,
; 322  :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	23					; 00000017H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@SfGetDefau

; 323  :    {
; 324  :       *lpReturnContext = 0;

	mov	edx, DWORD PTR _lpReturnContext$[ebp]
	mov	DWORD PTR [edx], 0

; 325  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetDefau
$LN4@SfGetDefau:

; 326  :    }
; 327  : 
; 328  :    SfGetApplicationForSubtask( &lpApp, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_SfGetApplicationForSubtask@8

; 329  :    lpDomain = zGETPTR( lpApp->hFirstDomain );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+72]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax
$LN2@SfGetDefau:

; 330  :    while ( lpDomain )

	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	$LN3@SfGetDefau

; 331  :    {
; 332  :       if ( zstrcmp( lpDomain->szName, cpcDomainName ) == 0 )

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	eax, DWORD PTR _cpcDomainName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN9@SfGetDefau
	mov	edx, DWORD PTR _cpcDomainName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	add	eax, 6
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN10@SfGetDefau
$LN9@SfGetDefau:
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	mov	eax, DWORD PTR _cpcDomainName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN7@SfGetDefau
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN8@SfGetDefau
$LN7@SfGetDefau:
	mov	DWORD PTR tv88[ebp], -1
$LN8@SfGetDefau:
	mov	edx, DWORD PTR tv88[ebp]
	mov	DWORD PTR tv89[ebp], edx
$LN10@SfGetDefau:
	cmp	DWORD PTR tv89[ebp], 0
	jne	SHORT $LN5@SfGetDefau

; 333  :       {
; 334  :          nRC = GetDefaultContext( lpReturnContext, lpDomain );

	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpReturnContext$[ebp]
	push	ecx
	call	_GetDefaultContext@8
	mov	WORD PTR _nRC$[ebp], ax

; 335  :       // TraceLine( "SfGetDefaultContextForDomain Name: %s   Context: %s",
; 336  :       //            cpcDomainName, (*lpReturnContext)->szName );
; 337  :          break;

	jmp	SHORT $LN3@SfGetDefau
$LN5@SfGetDefau:

; 338  :       }
; 339  : 
; 340  :       lpDomain = zGETPTR( lpDomain->hNextDomain );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 341  :    }

	jmp	$LN2@SfGetDefau
$LN3@SfGetDefau:

; 342  : 
; 343  :    fnOperationReturn( iSfGetDefaultContextForDomain, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	23					; 00000017H
	call	_fnOperationReturn
	add	esp, 8

; 344  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfGetDefau:

; 345  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfGetDefaultContextForDomain@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_stZKeyTok$ = -12					; size = 6
tv76 = -4						; size = 4
_lpReturnContext$ = 8					; size = 4
_lpDomain$ = 12						; size = 4
_GetDefaultContext@8 PROC

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 267  :    ZKeyRecord stZKeyTok;
; 268  : 
; 269  :    // If no domain, return 0.
; 270  :    if ( lpDomain == 0 )

	cmp	DWORD PTR _lpDomain$[ebp], 0
	jne	SHORT $LN2@GetDefault

; 271  :    {
; 272  :       *lpReturnContext = (zLPCONTEXT) 0;

	mov	eax, DWORD PTR _lpReturnContext$[ebp]
	mov	DWORD PTR [eax], 0

; 273  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@GetDefault
$LN2@GetDefault:

; 274  :    }
; 275  : 
; 276  :    if ( lpDomain->lDefaultContextZKey )

	mov	ecx, DWORD PTR _lpDomain$[ebp]
	cmp	DWORD PTR [ecx+137], 0
	je	SHORT $LN3@GetDefault

; 277  :    {
; 278  :       stZKeyTok.ch1 = '\xff';

	mov	BYTE PTR _stZKeyTok$[ebp], -1

; 279  :       stZKeyTok.ch2 = '\x00';

	mov	BYTE PTR _stZKeyTok$[ebp+5], 0

; 280  :       stZKeyTok.lZKey = lpDomain->lDefaultContextZKey;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	eax, DWORD PTR [edx+137]
	mov	DWORD PTR _stZKeyTok$[ebp+1], eax

; 281  :       *lpReturnContext = fnGetContext( lpDomain, (zPCHAR) &stZKeyTok );

	lea	ecx, DWORD PTR _stZKeyTok$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	call	_fnGetContext
	add	esp, 8
	mov	ecx, DWORD PTR _lpReturnContext$[ebp]
	mov	DWORD PTR [ecx], eax

; 282  :    }

	jmp	SHORT $LN4@GetDefault
$LN3@GetDefault:

; 283  :    else
; 284  :       *lpReturnContext = fnGetContext( lpDomain, lpDomain->szName );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lpDomain$[ebp]
	push	eax
	call	_fnGetContext
	add	esp, 8
	mov	ecx, DWORD PTR _lpReturnContext$[ebp]
	mov	DWORD PTR [ecx], eax
$LN4@GetDefault:

; 285  : 
; 286  :    return( (*lpReturnContext) ? 1 : 0 );

	mov	edx, DWORD PTR _lpReturnContext$[ebp]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN6@GetDefault
	mov	DWORD PTR tv76[ebp], 1
	jmp	SHORT $LN7@GetDefault
$LN6@GetDefault:
	mov	DWORD PTR tv76[ebp], 0
$LN7@GetDefault:
	mov	ax, WORD PTR tv76[ebp]
$LN1@GetDefault:

; 287  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_GetDefaultContext@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
tv72 = -4						; size = 4
_lpReturnContext$ = 8					; size = 4
_lpDomain$ = 12						; size = 4
_cpcContextName$ = 16					; size = 4
_GetContext@12 PROC

; 232  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 233  :    // if no domain or no context name, return 0.
; 234  :    if ( lpDomain == 0 || cpcContextName == 0 || *cpcContextName == 0 )

	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	SHORT $LN3@GetContext
	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN3@GetContext
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@GetContext
$LN3@GetContext:

; 235  :    {
; 236  :       *lpReturnContext = (zLPCONTEXT) 0;

	mov	edx, DWORD PTR _lpReturnContext$[ebp]
	mov	DWORD PTR [edx], 0

; 237  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@GetContext
$LN2@GetContext:

; 238  :    }
; 239  : 
; 240  :    *lpReturnContext = fnGetContext( lpDomain, cpcContextName );

	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	push	ecx
	call	_fnGetContext
	add	esp, 8
	mov	edx, DWORD PTR _lpReturnContext$[ebp]
	mov	DWORD PTR [edx], eax

; 241  : 
; 242  :    return( (*lpReturnContext) ? 1 : 0 );

	mov	eax, DWORD PTR _lpReturnContext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@GetContext
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN6@GetContext
$LN5@GetContext:
	mov	DWORD PTR tv72[ebp], 0
$LN6@GetContext:
	mov	ax, WORD PTR tv72[ebp]
$LN1@GetContext:

; 243  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_GetContext@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_pch$1 = -24						; size = 4
_lpContext$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpSrchTableEntry$ = -12				; size = 4
_nRC$ = -8						; size = 2
_chType$ = -1						; size = 1
_lpReturnValue$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpDomain$ = 16						; size = 4
_cpcContext$ = 20					; size = 4
_cpcExternalValue$ = 24					; size = 4
_TableEntryExtToInt@20 PROC

; 642  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 643  :    LPTASK         lpCurrentTask;
; 644  :    zLPCONTEXT     lpContext;
; 645  :    LPTABLEENTRY   lpSrchTableEntry;
; 646  :    zCHAR          chType;
; 647  :    zSHORT         nRC;
; 648  : 
; 649  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 650  :    if ( (lpCurrentTask = fnOperationCall( iTableEntryExtToInt, lpView,
; 651  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	350					; 0000015eH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@TableEntry

; 652  :    {
; 653  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@TableEntry
$LN4@TableEntry:

; 654  :    }
; 655  : 
; 656  :    if ( cpcContext == 0 || cpcContext[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContext$[ebp], 0
	je	SHORT $LN7@TableEntry
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcContext$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN5@TableEntry
$LN7@TableEntry:

; 657  :       GetDefaultContext( &lpContext, lpDomain );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpContext$[ebp]
	push	eax
	call	_GetDefaultContext@8
	jmp	SHORT $LN6@TableEntry
$LN5@TableEntry:

; 658  :    else
; 659  :       lpContext = fnGetContext( lpDomain, cpcContext );

	mov	ecx, DWORD PTR _cpcContext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpContext$[ebp], eax
$LN6@TableEntry:

; 660  : 
; 661  :    if ( lpContext == 0 )

	cmp	DWORD PTR _lpContext$[ebp], 0
	jne	SHORT $LN8@TableEntry

; 662  :    {
; 663  :       // "KZOEE350 - Context Not Valid for Domain"
; 664  :       fnIssueCoreError( lpCurrentTask, lpView, 8, 350, 0, lpDomain->szName,

	push	1
	mov	eax, DWORD PTR _cpcContext$[ebp]
	push	eax
	call	_TrueName@8
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 6
	push	ecx
	push	0
	push	350					; 0000015eH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 665  :                         TrueName( cpcContext, zSHOW_ZKEY ) );
; 666  :       fnOperationReturn( iTableEntryExtToInt, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	350					; 0000015eH
	call	_fnOperationReturn
	add	esp, 8

; 667  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@TableEntry
$LN8@TableEntry:

; 668  :    }
; 669  : 
; 670  :    chType = lpDomain->cType;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	al, BYTE PTR [edx+63]
	mov	BYTE PTR _chType$[ebp], al

; 671  :    lpSrchTableEntry = zGETPTR( lpContext->hFirstTableEntry );

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchTableEntry$[ebp], eax
$LN2@TableEntry:

; 672  : 
; 673  :    while ( lpSrchTableEntry )

	cmp	DWORD PTR _lpSrchTableEntry$[ebp], 0
	je	SHORT $LN3@TableEntry

; 674  :    {
; 675  :       zPCHAR pch;
; 676  : 
; 677  :       pch = fnGetTextForTableEntry( lpSrchTableEntry );

	mov	eax, DWORD PTR _lpSrchTableEntry$[ebp]
	push	eax
	call	_fnGetTextForTableEntry
	add	esp, 4
	mov	DWORD PTR _pch$1[ebp], eax

; 678  :       if ( pch )

	cmp	DWORD PTR _pch$1[ebp], 0
	je	SHORT $LN9@TableEntry

; 679  :       {
; 680  :          if ( cpcExternalValue && cpcExternalValue[ 0 ] &&

	cmp	DWORD PTR _cpcExternalValue$[ebp], 0
	je	SHORT $LN11@TableEntry
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcExternalValue$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN11@TableEntry
	mov	edx, DWORD PTR _cpcExternalValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _pch$1[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@TableEntry

; 681  :               zstrcmpi( pch, cpcExternalValue ) == 0 )
; 682  :          {
; 683  :             break;

	jmp	SHORT $LN3@TableEntry
$LN11@TableEntry:

; 684  :          }
; 685  :       }

	jmp	SHORT $LN10@TableEntry
$LN9@TableEntry:

; 686  :       else
; 687  :       {
; 688  :          if ( cpcExternalValue == 0 || cpcExternalValue[ 0 ] == 0 )

	cmp	DWORD PTR _cpcExternalValue$[ebp], 0
	je	SHORT $LN13@TableEntry
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcExternalValue$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN10@TableEntry
$LN13@TableEntry:

; 689  :             break;

	jmp	SHORT $LN3@TableEntry
$LN10@TableEntry:

; 690  :       }
; 691  : 
; 692  :       lpSrchTableEntry = zGETPTR( lpSrchTableEntry->hNextTableEntry );

	mov	edx, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchTableEntry$[ebp], eax

; 693  :    }

	jmp	SHORT $LN2@TableEntry
$LN3@TableEntry:

; 694  : 
; 695  :    if ( lpSrchTableEntry )

	cmp	DWORD PTR _lpSrchTableEntry$[ebp], 0
	je	SHORT $LN14@TableEntry

; 696  :    {
; 697  :       if ( chType == zTYPE_INTEGER || chType == zTYPE_DECIMAL )

	movsx	ecx, BYTE PTR _chType$[ebp]
	cmp	ecx, 76					; 0000004cH
	je	SHORT $LN18@TableEntry
	movsx	edx, BYTE PTR _chType$[ebp]
	cmp	edx, 77					; 0000004dH
	jne	SHORT $LN16@TableEntry
$LN18@TableEntry:

; 698  :       {
; 699  :          // Integer or Decimal, internal table value to return is long
; 700  :          *((zPLONG) lpReturnValue) = lpSrchTableEntry->unInternal.lInteger;

	mov	eax, DWORD PTR _lpReturnValue$[ebp]
	mov	ecx, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	mov	DWORD PTR [eax], edx

; 701  :       }

	jmp	SHORT $LN17@TableEntry
$LN16@TableEntry:

; 702  :       else
; 703  :       {
; 704  :          // internal table value to return is string
; 705  :          if ( lpSrchTableEntry->unInternal.hStringValue )

	mov	eax, DWORD PTR _lpSrchTableEntry$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN19@TableEntry

; 706  :          {
; 707  :             zstrcpy( (zPCHAR) lpReturnValue,

	mov	ecx, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpReturnValue$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 708  :                      zGETPTR( lpSrchTableEntry->unInternal.hStringValue ) );
; 709  :          }

	jmp	SHORT $LN17@TableEntry
$LN19@TableEntry:

; 710  :          else
; 711  :             *((zPCHAR) lpReturnValue) = 0;

	mov	ecx, DWORD PTR _lpReturnValue$[ebp]
	mov	BYTE PTR [ecx], 0
$LN17@TableEntry:

; 712  :       }
; 713  : 
; 714  :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 715  :    }

	jmp	SHORT $LN15@TableEntry
$LN14@TableEntry:

; 716  :    else
; 717  :    {
; 718  :       if ( chType == zTYPE_INTEGER || chType == zTYPE_DECIMAL )

	movsx	eax, BYTE PTR _chType$[ebp]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN23@TableEntry
	movsx	ecx, BYTE PTR _chType$[ebp]
	cmp	ecx, 77					; 0000004dH
	jne	SHORT $LN21@TableEntry
$LN23@TableEntry:

; 719  :          *((zPLONG) lpReturnValue) = 0;

	mov	edx, DWORD PTR _lpReturnValue$[ebp]
	mov	DWORD PTR [edx], 0
	jmp	SHORT $LN22@TableEntry
$LN21@TableEntry:

; 720  :       else
; 721  :          *((zPCHAR) lpReturnValue) = 0;

	mov	eax, DWORD PTR _lpReturnValue$[ebp]
	mov	BYTE PTR [eax], 0
$LN22@TableEntry:

; 722  : 
; 723  :       nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN15@TableEntry:

; 724  :    }
; 725  : 
; 726  :    fnOperationReturn( iTableEntryExtToInt, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	350					; 0000015eH
	call	_fnOperationReturn
	add	esp, 8

; 727  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@TableEntry:

; 728  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TableEntryExtToInt@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_pch$1 = -24						; size = 4
_lpContext$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpSrchTableEntry$ = -12				; size = 4
_nRC$ = -8						; size = 2
_chType$ = -1						; size = 1
_pchReturnValue$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpDomain$ = 16						; size = 4
_cpcContext$ = 20					; size = 4
_lpInternalValue$ = 24					; size = 4
_TableEntryIntToExt@20 PROC

; 523  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 524  :    LPTASK         lpCurrentTask;
; 525  :    zLPCONTEXT     lpContext;
; 526  :    LPTABLEENTRY   lpSrchTableEntry;
; 527  :    zCHAR          chType;
; 528  :    zSHORT         nRC;
; 529  : 
; 530  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 531  :    if ( (lpCurrentTask = fnOperationCall( iTableEntryIntToExt, lpView,
; 532  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	351					; 0000015fH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@TableEntry

; 533  :    {
; 534  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@TableEntry
$LN4@TableEntry:

; 535  :    }
; 536  : 
; 537  :    if ( cpcContext == 0 || cpcContext[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContext$[ebp], 0
	je	SHORT $LN7@TableEntry
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcContext$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN5@TableEntry
$LN7@TableEntry:

; 538  :       GetDefaultContext( &lpContext, lpDomain );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpContext$[ebp]
	push	eax
	call	_GetDefaultContext@8
	jmp	SHORT $LN6@TableEntry
$LN5@TableEntry:

; 539  :    else
; 540  :       lpContext = fnGetContext( lpDomain, cpcContext );

	mov	ecx, DWORD PTR _cpcContext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpContext$[ebp], eax
$LN6@TableEntry:

; 541  : 
; 542  :    if ( lpContext == 0 )

	cmp	DWORD PTR _lpContext$[ebp], 0
	jne	SHORT $LN8@TableEntry

; 543  :    {
; 544  :       // "KZOEE350 - Context Not Valid for Domain"
; 545  :       fnIssueCoreError( lpCurrentTask, lpView, 8, 350, 0, lpDomain->szName,

	push	1
	mov	eax, DWORD PTR _cpcContext$[ebp]
	push	eax
	call	_TrueName@8
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 6
	push	ecx
	push	0
	push	350					; 0000015eH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 546  :                         TrueName( cpcContext, zSHOW_ZKEY ) );
; 547  :       fnOperationReturn( iTableEntryIntToExt, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	351					; 0000015fH
	call	_fnOperationReturn
	add	esp, 8

; 548  :       return( -1 );

	or	eax, -1
	jmp	$LN1@TableEntry
$LN8@TableEntry:

; 549  :    }
; 550  : 
; 551  :    chType = lpDomain->cType;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	al, BYTE PTR [edx+63]
	mov	BYTE PTR _chType$[ebp], al

; 552  :    lpSrchTableEntry = zGETPTR( lpContext->hFirstTableEntry );

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchTableEntry$[ebp], eax
$LN2@TableEntry:

; 553  : 
; 554  :    while ( lpSrchTableEntry )

	cmp	DWORD PTR _lpSrchTableEntry$[ebp], 0
	je	SHORT $LN3@TableEntry

; 555  :    {
; 556  :       if ( chType == zTYPE_INTEGER || chType == zTYPE_DECIMAL )

	movsx	eax, BYTE PTR _chType$[ebp]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN11@TableEntry
	movsx	ecx, BYTE PTR _chType$[ebp]
	cmp	ecx, 77					; 0000004dH
	jne	SHORT $LN9@TableEntry
$LN11@TableEntry:

; 557  :       {
; 558  :          if ( lpSrchTableEntry->unInternal.lInteger ==

	mov	edx, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	eax, DWORD PTR _lpInternalValue$[ebp]
	mov	ecx, DWORD PTR [edx+26]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN12@TableEntry

; 559  :                                                 *((zPLONG) lpInternalValue) )
; 560  :          {
; 561  :             break;

	jmp	SHORT $LN3@TableEntry
$LN12@TableEntry:

; 562  :          }
; 563  :       }

	jmp	SHORT $LN10@TableEntry
$LN9@TableEntry:

; 564  :       else
; 565  :       {
; 566  :          if ( ((lpInternalValue == 0 || *((zPCHAR) lpInternalValue) == 0) &&
; 567  :                lpSrchTableEntry->unInternal.hStringValue == 0) ||

	cmp	DWORD PTR _lpInternalValue$[ebp], 0
	je	SHORT $LN16@TableEntry
	mov	edx, DWORD PTR _lpInternalValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN15@TableEntry
$LN16@TableEntry:
	mov	ecx, DWORD PTR _lpSrchTableEntry$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN14@TableEntry
$LN15@TableEntry:
	mov	edx, DWORD PTR _lpSrchTableEntry$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN10@TableEntry
	mov	eax, DWORD PTR _lpInternalValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@TableEntry
$LN14@TableEntry:

; 568  :               (lpSrchTableEntry->unInternal.hStringValue != 0 &&
; 569  :                zstrcmpi( zGETPTR( lpSrchTableEntry->unInternal.hStringValue ),
; 570  :                          (zPCHAR) lpInternalValue ) == 0) )
; 571  :          {
; 572  :             break;

	jmp	SHORT $LN3@TableEntry
$LN10@TableEntry:

; 573  :          }
; 574  :       }
; 575  : 
; 576  :       lpSrchTableEntry = zGETPTR( lpSrchTableEntry->hNextTableEntry );

	mov	eax, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchTableEntry$[ebp], eax

; 577  :    }

	jmp	SHORT $LN2@TableEntry
$LN3@TableEntry:

; 578  : 
; 579  :    if ( lpSrchTableEntry )

	cmp	DWORD PTR _lpSrchTableEntry$[ebp], 0
	je	SHORT $LN17@TableEntry

; 580  :    {
; 581  :       zPCHAR pch;
; 582  : 
; 583  :       pch = fnGetTextForTableEntry( lpSrchTableEntry );

	mov	edx, DWORD PTR _lpSrchTableEntry$[ebp]
	push	edx
	call	_fnGetTextForTableEntry
	add	esp, 4
	mov	DWORD PTR _pch$1[ebp], eax

; 584  :       if ( pch )

	cmp	DWORD PTR _pch$1[ebp], 0
	je	SHORT $LN19@TableEntry

; 585  :          zstrcpy( pchReturnValue, pch );

	mov	eax, DWORD PTR _pch$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnValue$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN20@TableEntry
$LN19@TableEntry:

; 586  :       else
; 587  :          pchReturnValue[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchReturnValue$[ebp]
	mov	BYTE PTR [ecx+eax], 0
$LN20@TableEntry:

; 588  : 
; 589  :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 590  :    }

	jmp	SHORT $LN18@TableEntry
$LN17@TableEntry:

; 591  :    else
; 592  :    {
; 593  :       pchReturnValue[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnValue$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 594  :       nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
$LN18@TableEntry:

; 595  :    }
; 596  : 
; 597  :    fnOperationReturn( iTableEntryIntToExt, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	351					; 0000015fH
	call	_fnOperationReturn
	add	esp, 8

; 598  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@TableEntry:

; 599  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TableEntryIntToExt@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoedmaa.c
_TEXT	SEGMENT
_lpContext$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpSrchTableEntry$ = -12				; size = 4
_nRC$ = -8						; size = 2
_chType$ = -1						; size = 1
_lpView$ = 8						; size = 4
_lpDomain$ = 12						; size = 4
_cpcContextName$ = 16					; size = 4
_lpInputValue$ = 20					; size = 4
_TableEntryForInternalValue@16 PROC

; 420  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 421  :    LPTASK         lpCurrentTask;
; 422  :    zLPCONTEXT     lpContext;
; 423  :    LPTABLEENTRY   lpSrchTableEntry;
; 424  :    zCHAR          chType;
; 425  :    zSHORT         nRC;
; 426  : 
; 427  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 428  :    if ( (lpCurrentTask = fnOperationCall( iTableEntryForInternalValue,
; 429  :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	352					; 00000160H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@TableEntry

; 430  :    {
; 431  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@TableEntry
$LN4@TableEntry:

; 432  :    }
; 433  : 
; 434  :    if ( cpcContextName == 0 || cpcContextName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcContextName$[ebp], 0
	je	SHORT $LN7@TableEntry
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN5@TableEntry
$LN7@TableEntry:

; 435  :       GetDefaultContext( &lpContext, lpDomain );

	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpContext$[ebp]
	push	eax
	call	_GetDefaultContext@8
	jmp	SHORT $LN6@TableEntry
$LN5@TableEntry:

; 436  :    else
; 437  :       lpContext = fnGetContext( lpDomain, cpcContextName );

	mov	ecx, DWORD PTR _cpcContextName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDomain$[ebp]
	push	edx
	call	_fnGetContext
	add	esp, 8
	mov	DWORD PTR _lpContext$[ebp], eax
$LN6@TableEntry:

; 438  : 
; 439  :    if ( lpContext == 0 )

	cmp	DWORD PTR _lpContext$[ebp], 0
	jne	SHORT $LN8@TableEntry

; 440  :    {
; 441  :       // "KZOEE350 - Context Not Valid for Domain"
; 442  :       fnIssueCoreError( lpCurrentTask, lpView, 8, 350, 0, lpDomain->szName,

	push	1
	mov	eax, DWORD PTR _cpcContextName$[ebp]
	push	eax
	call	_TrueName@8
	push	eax
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	add	ecx, 6
	push	ecx
	push	0
	push	350					; 0000015eH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 443  :                         TrueName( cpcContextName, zSHOW_ZKEY ) );
; 444  :       fnOperationReturn( iTableEntryForInternalValue, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	352					; 00000160H
	call	_fnOperationReturn
	add	esp, 8

; 445  :       return( -1 );

	or	eax, -1
	jmp	$LN1@TableEntry
$LN8@TableEntry:

; 446  :    }
; 447  : 
; 448  :    chType = lpDomain->cType;

	mov	edx, DWORD PTR _lpDomain$[ebp]
	mov	al, BYTE PTR [edx+63]
	mov	BYTE PTR _chType$[ebp], al

; 449  :    lpSrchTableEntry = zGETPTR( lpContext->hFirstTableEntry );

	mov	ecx, DWORD PTR _lpContext$[ebp]
	mov	edx, DWORD PTR [ecx+47]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchTableEntry$[ebp], eax
$LN2@TableEntry:

; 450  : 
; 451  :    while ( lpSrchTableEntry )

	cmp	DWORD PTR _lpSrchTableEntry$[ebp], 0
	je	SHORT $LN3@TableEntry

; 452  :    {
; 453  :       if ( chType == zTYPE_INTEGER || chType == zTYPE_DECIMAL )

	movsx	eax, BYTE PTR _chType$[ebp]
	cmp	eax, 76					; 0000004cH
	je	SHORT $LN11@TableEntry
	movsx	ecx, BYTE PTR _chType$[ebp]
	cmp	ecx, 77					; 0000004dH
	jne	SHORT $LN9@TableEntry
$LN11@TableEntry:

; 454  :       {
; 455  :          if ( lpSrchTableEntry->unInternal.lInteger ==

	mov	edx, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	eax, DWORD PTR _lpInputValue$[ebp]
	mov	ecx, DWORD PTR [edx+26]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN12@TableEntry

; 456  :                                                   *((zPLONG) lpInputValue) )
; 457  :          {
; 458  :             break;

	jmp	SHORT $LN3@TableEntry
$LN12@TableEntry:

; 459  :          }
; 460  :       }

	jmp	SHORT $LN10@TableEntry
$LN9@TableEntry:

; 461  :       else
; 462  :       {
; 463  :          if ( ((lpInputValue == 0 || *((zPCHAR) lpInputValue) == 0) &&
; 464  :                lpSrchTableEntry->unInternal.hStringValue == 0) ||

	cmp	DWORD PTR _lpInputValue$[ebp], 0
	je	SHORT $LN16@TableEntry
	mov	edx, DWORD PTR _lpInputValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN15@TableEntry
$LN16@TableEntry:
	mov	ecx, DWORD PTR _lpSrchTableEntry$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN14@TableEntry
$LN15@TableEntry:
	mov	edx, DWORD PTR _lpSrchTableEntry$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN10@TableEntry
	mov	eax, DWORD PTR _lpInputValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@TableEntry
$LN14@TableEntry:

; 465  :               (lpSrchTableEntry->unInternal.hStringValue != 0 &&
; 466  :                zstrcmpi( zGETPTR( lpSrchTableEntry->unInternal.hStringValue ),
; 467  :                          (zPCHAR) lpInputValue ) == 0) )
; 468  :          {
; 469  :             break;

	jmp	SHORT $LN3@TableEntry
$LN10@TableEntry:

; 470  :          }
; 471  :       }
; 472  : 
; 473  :       lpSrchTableEntry = zGETPTR( lpSrchTableEntry->hNextTableEntry );

	mov	eax, DWORD PTR _lpSrchTableEntry$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchTableEntry$[ebp], eax

; 474  :    }

	jmp	SHORT $LN2@TableEntry
$LN3@TableEntry:

; 475  : 
; 476  :    if ( lpSrchTableEntry )

	cmp	DWORD PTR _lpSrchTableEntry$[ebp], 0
	je	SHORT $LN17@TableEntry

; 477  :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN18@TableEntry
$LN17@TableEntry:

; 478  :    else
; 479  :       nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
$LN18@TableEntry:

; 480  : 
; 481  :    fnOperationReturn( iTableEntryForInternalValue, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	352					; 00000160H
	call	_fnOperationReturn
	add	esp, 8

; 482  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@TableEntry:

; 483  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TableEntryForInternalValue@16 ENDP
_TEXT	ENDS
END
