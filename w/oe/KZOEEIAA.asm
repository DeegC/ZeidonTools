; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEEIAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG13721 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG14403 DB	'fnCreateEntity ERROR locating RecursViewEntity for lpVie'
	DB	'wSubobject: 0x%08x', 00H
	ORG $+1
$SG14482 DB	'KZOEE119 - Invalid View, View is Read Only for Entity: ', 00H
$SG14486 DB	'KZOEE253 - Entity cursor is NULL for Entity: ', 00H
	ORG $+2
$SG14490 DB	'KZOEE252 - Root of view has been deleted for Entity: ', 00H
	ORG $+2
$SG14497 DB	'KZOEE253 - Entity cursor is NULL for Entity: ', 00H
	ORG $+2
$SG14499 DB	'(DGC) View   Cursor   = ', 00H
	ORG $+3
$SG14500 DB	'(DGC) Entity Cursor   = ', 00H
	ORG $+3
$SG14501 DB	'(DGC) Entity Instance = ', 00H
	ORG $+3
$SG14502 DB	'Invalid Table ID for entity instance', 00H
	ORG $+3
$SG14503 DB	'DGC', 00H
$SG13484 DB	'Entity Creation not allowed', 00H
$SG14514 DB	'KZOEE253 - Entity cursor is NULL for Entity: ', 00H
	ORG $+2
$SG14515 DB	'KZOEE254 - Entity cursor is undefined for Entity: ', 00H
	ORG $+1
$SG13517 DB	'Entity Creation not allowed', 00H
$SG14519 DB	'KZOEE255 - Attempt to update a previous entity version f'
	DB	'or Entity: ', 00H
$SG13714 DB	'Entity Deletion not allowed', 00H
$SG14523 DB	'KZOEE264 - Invalid Operation for Hierarchical processing'
	DB	' for Entity: ', 00H
	ORG $+2
$SG13720 DB	'Can''t delete entity %s because of Restrict constraint o'
	DB	'n child entity %s', 00H
	ORG $+3
$SG13722 DB	'Entity Deletion not allowed - child is restricted', 00H
	ORG $+2
$SG13836 DB	'Entity Exclusion not allowed', 00H
	ORG $+3
$SG13916 DB	'Source Entity not includeble', 00H
	ORG $+3
$SG13918 DB	'The following LODs are out of sync and should be re-buil'
	DB	't', 00H
	ORG $+2
$SG13919 DB	'ERROR: ', 00H
$SG13920 DB	'Out-of-sync error. Target LOD = %s, date = %s', 00H
	ORG $+2
$SG13921 DB	'   ==> ', 00H
$SG13922 DB	'Out-of-sync error. Source LOD = %s, date = %s', 00H
	ORG $+2
$SG13923 DB	'   ==> ', 00H
$SG13924 DB	'SyncER/LOD', 00H
	ORG $+1
$SG13925 DB	'[Workstation]', 00H
	ORG $+2
$SG13927 DB	'LODs are potentially out of sync.  See trace for more.', 00H
	ORG $+1
$SG15064 DB	' dks 2007.04.23', 00H
$SG15065 DB	'RemoveAllTemporal skipping break:', 00H
	ORG $+2
$SG14232 DB	'Entity Instance key is NULL', 00H
$SG14233 DB	'Internal Zeidon Error', 00H
_DATA	ENDS
PUBLIC	_CheckExistenceOfEntity@8
PUBLIC	_CheckEntityInView@8
PUBLIC	_CreateEntity@12
PUBLIC	_GetEntityKey@8
PUBLIC	_LoadEntity@16
PUBLIC	_DeleteEntity@12
PUBLIC	_DropEntity@12
PUBLIC	_ExcludeEntity@12
PUBLIC	_CreateTemporalEntity@12
PUBLIC	_SetIncrementalUpdateFlags@12
PUBLIC	_GetIncrementalUpdateFlags@12
PUBLIC	_RelinkInstanceToInstance@16
PUBLIC	_CountEntitiesForView@8
PUBLIC	_CountEntitiesForViewUnderParent@12
PUBLIC	_fnEntityInstanceIsDead@4
PUBLIC	_fnSetEntityKey@12
PUBLIC	_fnCreateEntity@20
PUBLIC	_fnDeleteEntity
PUBLIC	_fnExcludeEntity
PUBLIC	_fnEstablishViewForInstance
PUBLIC	_fnValidateInsertPosition
PUBLIC	_fnValidateInstanceParameters
PUBLIC	_fnExcludeEntityInstance
PUBLIC	_fnSpawnCreateEntity
PUBLIC	_fnReclaimHiddenInstances@4
PUBLIC	_fnInstanceLinkedToInstance
PUBLIC	_fnInstanceVersioned
PUBLIC	_fnInstanceVersionRootMatch
PUBLIC	_fnHideLinkedChildren
PUBLIC	_fnHideExcludedDeletedInstances
PUBLIC	_fnInstanceKeysMatch
PUBLIC	_fnRelinkInstanceToInstance
PUBLIC	_fnGetEntityCnstrntOper
PUBLIC	_fnInvokeECEOperation
PUBLIC	_fnRemoveAllChildTemporalVsns
PUBLIC	_fnRemoveOtherOI_LinkedInstances
PUBLIC	_fnEntityInRecursivePath
PUBLIC	_fnFirstLevel2_ForViewEntity
PUBLIC	_fnStillPrevVersion
PUBLIC	_fnEntityContainsEntity@8
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnInitAttributes@8
PUBLIC	_fnSameRelationshipInstance
PUBLIC	_fnValidateInstanceAttributes
EXTRN	_memcmp:PROC
EXTRN	_strcmp:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_IssueOE_Error@28:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_DropView@4:PROC
EXTRN	_AcceptSubobject@8:PROC
EXTRN	_CancelSubobject@8:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorPrevEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorLastEntity@12:PROC
EXTRN	_SysGetProc@8:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysLoadLibrary@8:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_StoreStringInRecord@16:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnGetAttribFlagsPtr@8:PROC
EXTRN	_fnGetAttrAddrFromEntityInstance:PROC
EXTRN	_fnCreateAttributeRecord:PROC
EXTRN	_fnDeleteAttributeRecord:PROC
EXTRN	_fnSetUpdateIndicator:PROC
EXTRN	_fnSetEntityCursor:PROC
EXTRN	_fnValidateCursorParameters:PROC
EXTRN	_fnNullCursorForViewChildren:PROC
EXTRN	_fnResetCursorForViewChildren:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidViewCsr:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnAddEntityToDebugChange@4:PROC
EXTRN	_fnRemoveEntityFromDebugChange@4:PROC
EXTRN	_fnSetViewFromView:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	_fnSetViewToSubobject:PROC
EXTRN	_fnResetView:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_fnEntityNameFromCsr@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpAttrAddr$ = -16					; size = 4
_un$ = -12						; size = 4
_lpViewAttrib$ = -8					; size = 4
_nErrorCount$ = -4					; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_fnValidateInstanceAttributes PROC

; 4979 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4980 :    LPVIEWATTRIB   lpViewAttrib;
; 4981 :    zPVOID         lpAttrAddr;
; 4982 :    zULONG         un;
; 4983 :    zSHORT         nErrorCount = 0;

	xor	eax, eax
	mov	WORD PTR _nErrorCount$[ebp], ax

; 4984 : 
; 4985 :    // User shouldn't pass us a null pointer...
; 4986 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN5@fnValidate

; 4987 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN5@fnValidate:

; 4988 : 
; 4989 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnValidate
$LN2@fnValidate:

; 4991 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnValidate:

; 4990 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnValidate

; 4992 :    {
; 4993 :       // If the attribute is not required don't worry about it.
; 4994 :       // Don't worry about hidden attributes.
; 4995 :       // If the attribute is a genkey then we'll set it later so skip it.
; 4996 :       if ( lpViewAttrib->bRequired == FALSE ||
; 4997 :            lpViewAttrib->bHidden || lpViewAttrib->bGenkey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN7@fnValidate
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN7@fnValidate
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN6@fnValidate
$LN7@fnValidate:

; 4998 :       {
; 4999 :          continue;

	jmp	SHORT $LN2@fnValidate
$LN6@fnValidate:

; 5000 :       }
; 5001 : 
; 5002 :       // If the entity is a hanging entity then we only care about keys.
; 5003 :       if ( lpEntityInstance->u.nInd.bHangingEntity )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, 1
	je	SHORT $LN8@fnValidate

; 5004 :       {
; 5005 :          // Not a key?  Skip it.
; 5006 :          if ( lpViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN8@fnValidate

; 5007 :             continue;

	jmp	SHORT $LN2@fnValidate
$LN8@fnValidate:

; 5008 :       }
; 5009 : 
; 5010 :       // If the attribute is NULL then we have a problem.
; 5011 :       if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpAttrAddr, &un,
; 5012 :                                             lpEntityInstance,
; 5013 :                                             lpViewAttrib ) == -1 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _un$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpAttrAddr$[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $LN10@fnValidate

; 5014 :       {
; 5015 :          // "KZOEE248 - Required attribute is null"
; 5016 :          IssueOE_Error( lpView, 8, 248,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	400					; 00000190H
	push	248					; 000000f8H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_IssueOE_Error@28

; 5017 :                         zMSGQ_REQUIRED_DATA_ITEM_ERROR, 0,
; 5018 :                         lpViewEntity->szName,
; 5019 :                         lpViewAttrib->szName );
; 5020 : 
; 5021 :          // attribute is null...
; 5022 :          if ( nErrorCount != 32767 )

	movsx	edx, WORD PTR _nErrorCount$[ebp]
	cmp	edx, 32767				; 00007fffH
	je	SHORT $LN10@fnValidate

; 5023 :             nErrorCount++;

	mov	ax, WORD PTR _nErrorCount$[ebp]
	add	ax, 1
	mov	WORD PTR _nErrorCount$[ebp], ax
$LN10@fnValidate:

; 5024 :       }
; 5025 : 
; 5026 :    } // for...

	jmp	$LN2@fnValidate
$LN3@fnValidate:

; 5027 : 
; 5028 :    return( nErrorCount );

	mov	ax, WORD PTR _nErrorCount$[ebp]
$LN1@fnValidate:

; 5029 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidateInstanceAttributes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewEntity2$ = -8					; size = 4
_lpViewEntity1$ = -4					; size = 4
_lpEntityInstance1$ = 8					; size = 4
_lpEntityInstance2$ = 12				; size = 4
_fnSameRelationshipInstance PROC

; 1466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1467 :    LPVIEWENTITY lpViewEntity1;
; 1468 :    LPVIEWENTITY lpViewEntity2;
; 1469 : 
; 1470 :    if ( lpEntityInstance1 == lpEntityInstance2 )

	mov	eax, DWORD PTR _lpEntityInstance1$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance2$[ebp]
	jne	SHORT $LN2@fnSameRela

; 1471 :       return( 1 );  // Same relationship

	mov	eax, 1
	jmp	$LN1@fnSameRela
$LN2@fnSameRela:

; 1472 : 
; 1473 :    lpViewEntity1 = zGETPTR( lpEntityInstance1->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance1$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity1$[ebp], eax

; 1474 :    lpViewEntity2 = zGETPTR( lpEntityInstance2->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance2$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity2$[ebp], eax

; 1475 : 
; 1476 :    if ( lpViewEntity1->lERRelTok == lpViewEntity2->lERRelTok &&
; 1477 :         lpEntityInstance1->hParent && lpEntityInstance2->hParent )

	mov	edx, DWORD PTR _lpViewEntity1$[ebp]
	mov	eax, DWORD PTR _lpViewEntity2$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	jne	SHORT $LN3@fnSameRela
	mov	edx, DWORD PTR _lpEntityInstance1$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $LN3@fnSameRela
	mov	eax, DWORD PTR _lpEntityInstance2$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN3@fnSameRela

; 1478 :    {
; 1479 :       if ( fnInstanceKeysMatch( lpEntityInstance1, lpEntityInstance2 ) &&

	mov	ecx, DWORD PTR _lpEntityInstance2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance1$[ebp]
	push	edx
	call	_fnInstanceKeysMatch
	add	esp, 8
	cwde
	test	eax, eax
	je	SHORT $LN3@fnSameRela
	mov	ecx, DWORD PTR _lpEntityInstance2$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpEntityInstance1$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@fnSameRela

; 1480 :            fnInstanceKeysMatch( zGETPTR( lpEntityInstance1->hParent ),
; 1481 :                                 zGETPTR( lpEntityInstance2->hParent ) ) )
; 1482 :       {
; 1483 :          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnSameRela
$LN3@fnSameRela:

; 1484 :       }
; 1485 :    }
; 1486 : 
; 1487 :    return( 0 );  // Not the same relationship

	xor	eax, eax
$LN1@fnSameRela:

; 1488 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSameRelationshipInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewAttrib$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_fnInitAttributes@8 PROC

; 105  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 106  :    LPVIEWATTRIB lpViewAttrib;
; 107  : 
; 108  :    if ( lpViewEntity->bAttrInit == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 17					; 00000011H
	and	ecx, 1
	jne	SHORT $LN5@fnInitAttr

; 109  :       return;

	jmp	SHORT $LN1@fnInitAttr
$LN5@fnInitAttr:

; 110  : 
; 111  :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnInitAttr
$LN2@fnInitAttr:

; 113  :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnInitAttr:

; 112  :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN1@fnInitAttr

; 114  :    {
; 115  :       if ( lpViewAttrib->hInit )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+209], 0
	je	SHORT $LN6@fnInitAttr

; 116  :       {
; 117  :          StoreStringInRecord( lpView, lpViewEntity, lpViewAttrib,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+209]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_StoreStringInRecord@16
$LN6@fnInitAttr:

; 118  :                               zGETPTR( lpViewAttrib->hInit ) );
; 119  :       }
; 120  :    }

	jmp	SHORT $LN2@fnInitAttr
$LN1@fnInitAttr:

; 121  : 
; 122  : } // fnInitAttributes

	mov	esp, ebp
	pop	ebp
	ret	8
_fnInitAttributes@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -8					; size = 4
_lpLoopInstance$ = -4					; size = 4
_lpViewOI$ = 8						; size = 4
_fnCheckOIUpdated PROC

; 5502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5503 :    LPENTITYINSTANCE lpLoopInstance;
; 5504 :    LPVIEWENTITY lpViewEntity;
; 5505 : 
; 5506 :    lpViewOI->bUpdated = lpViewOI->bUpdatedFile = FALSE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 5507 : 
; 5508 :    // Loop through the entity instances.
; 5509 :    for ( lpLoopInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLoopInstance$[ebp], eax
	jmp	SHORT $LN4@fnCheckOIU
$LN2@fnCheckOIU:

; 5511 :          lpLoopInstance = zGETPTR( lpLoopInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpLoopInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLoopInstance$[ebp], eax
$LN4@fnCheckOIU:

; 5510 :          lpLoopInstance && lpViewOI->bUpdated == FALSE;

	cmp	DWORD PTR _lpLoopInstance$[ebp], 0
	je	$LN3@fnCheckOIU
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 4
	and	edx, 1
	jne	$LN3@fnCheckOIU

; 5512 :    {
; 5513 :       // Check to see if the entity instance has been changed somehow.  If it has
; 5514 :       // then we need to flag the OI as being updated.  We ignore instances
; 5515 :       // that have a previous version because we can't tell yet if the OI will
; 5516 :       // be updated because of the versioned instance.
; 5517 :       if ( lpLoopInstance->hPrevVsn == 0 &&
; 5518 :            !fnEntityInstanceIsDead( lpLoopInstance ) &&

	mov	eax, DWORD PTR _lpLoopInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	jne	$LN5@fnCheckOIU
	mov	ecx, DWORD PTR _lpLoopInstance$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	jne	$LN5@fnCheckOIU
	mov	eax, DWORD PTR _lpLoopInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN6@fnCheckOIU
	mov	edx, DWORD PTR _lpLoopInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	jne	SHORT $LN6@fnCheckOIU
	mov	ecx, DWORD PTR _lpLoopInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN6@fnCheckOIU
	mov	eax, DWORD PTR _lpLoopInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN6@fnCheckOIU
	mov	edx, DWORD PTR _lpLoopInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN5@fnCheckOIU
$LN6@fnCheckOIU:

; 5519 :            (lpLoopInstance->u.nInd.bCreated  ||
; 5520 :             lpLoopInstance->u.nInd.bUpdated  ||
; 5521 :             lpLoopInstance->u.nInd.bDeleted  ||
; 5522 :             lpLoopInstance->u.nInd.bIncluded ||
; 5523 :             lpLoopInstance->u.nInd.bExcluded) )
; 5524 :       {
; 5525 :          lpViewEntity = zGETPTR( lpLoopInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpLoopInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5526 : 
; 5527 :          if ( lpViewEntity->bDerived == FALSE &&
; 5528 :               lpViewEntity->bDerivedPath == FALSE &&

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	SHORT $LN7@fnCheckOIU
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	jne	SHORT $LN7@fnCheckOIU
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+191], 0
	je	SHORT $LN7@fnCheckOIU

; 5529 :               lpViewEntity->hFirstDataRecord != 0 )
; 5530 :          {
; 5531 :             // The entity is a "database" entity (not work).
; 5532 :             lpViewOI->bUpdated = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN7@fnCheckOIU:

; 5533 :          }
; 5534 : 
; 5535 :          lpViewOI->bUpdatedFile = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN5@fnCheckOIU:

; 5536 :       }
; 5537 :    }

	jmp	$LN2@fnCheckOIU
$LN3@fnCheckOIU:

; 5538 : 
; 5539 :    if ( lpViewOI->bUpdated )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN8@fnCheckOIU

; 5540 :       return( 3 );

	mov	eax, 3
	jmp	SHORT $LN1@fnCheckOIU
	jmp	SHORT $LN1@fnCheckOIU
$LN8@fnCheckOIU:

; 5541 :    else
; 5542 :    if ( lpViewOI->bUpdatedFile )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN10@fnCheckOIU

; 5543 :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnCheckOIU
	jmp	SHORT $LN1@fnCheckOIU
$LN10@fnCheckOIU:

; 5544 :    else
; 5545 :       return( 0 );

	xor	eax, eax
$LN1@fnCheckOIU:

; 5546 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCheckOIUpdated ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewAttrib2$ = -8					; size = 4
_lpViewAttrib1$ = -4					; size = 4
_lpVE1$ = 8						; size = 4
_lpVE2$ = 12						; size = 4
_fnEntityContainsEntity@8 PROC

; 5431 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5432 :    LPVIEWATTRIB lpViewAttrib2;
; 5433 :    LPVIEWATTRIB lpViewAttrib1;
; 5434 : 
; 5435 :    // They had better be the same ER entity.
; 5436 :    if ( lpVE1->lEREntTok != lpVE2->lEREntTok )

	mov	eax, DWORD PTR _lpVE1$[ebp]
	mov	ecx, DWORD PTR _lpVE2$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN8@fnEntityCo

; 5437 :       return( FALSE );

	xor	al, al
	jmp	$LN1@fnEntityCo
$LN8@fnEntityCo:

; 5438 : 
; 5439 :    if ( lpVE2 == lpVE1 )

	mov	eax, DWORD PTR _lpVE2$[ebp]
	cmp	eax, DWORD PTR _lpVE1$[ebp]
	jne	SHORT $LN9@fnEntityCo

; 5440 :       return( TRUE );

	mov	al, 1
	jmp	$LN1@fnEntityCo
$LN9@fnEntityCo:

; 5441 : 
; 5442 :    if ( lpVE2->bFullPersist && lpVE1->bFullPersist )

	mov	ecx, DWORD PTR _lpVE2$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 22					; 00000016H
	and	edx, 1
	je	SHORT $LN10@fnEntityCo
	mov	eax, DWORD PTR _lpVE1$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 22					; 00000016H
	and	ecx, 1
	je	SHORT $LN10@fnEntityCo

; 5443 :       return( TRUE );

	mov	al, 1
	jmp	$LN1@fnEntityCo
$LN10@fnEntityCo:

; 5444 : 
; 5445 :    // OK...the two enties are not the same AND one of the entities is
; 5446 :    // not fully persistent.  Look for hidden attributes.
; 5447 :    for ( lpViewAttrib2 = zGETPTR( lpVE2->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpVE2$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib2$[ebp], eax
	jmp	SHORT $LN4@fnEntityCo
$LN2@fnEntityCo:

; 5449 :          lpViewAttrib2 = zGETPTR( lpViewAttrib2->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib2$[ebp], eax
$LN4@fnEntityCo:

; 5448 :          lpViewAttrib2;

	cmp	DWORD PTR _lpViewAttrib2$[ebp], 0
	je	$LN3@fnEntityCo

; 5450 :    {
; 5451 :       // We don't care if the 'source' attribute is hidden.
; 5452 :       if ( lpViewAttrib2->bHidden &&
; 5453 :            lpViewAttrib2->bKey == FALSE &&

	mov	eax, DWORD PTR _lpViewAttrib2$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN11@fnEntityCo
	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN11@fnEntityCo
	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 2
	and	edx, 1
	jne	SHORT $LN11@fnEntityCo

; 5454 :            lpViewAttrib2->bForeignKey == FALSE )
; 5455 :       {
; 5456 :          continue;

	jmp	SHORT $LN2@fnEntityCo
$LN11@fnEntityCo:

; 5457 :       }
; 5458 : 
; 5459 :       // See if there is a matching attribute in the cache entity.
; 5460 :       for ( lpViewAttrib1 = zGETPTR( lpVE1->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpVE1$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib1$[ebp], eax
	jmp	SHORT $LN7@fnEntityCo
$LN5@fnEntityCo:

; 5462 :             lpViewAttrib1 = zGETPTR( lpViewAttrib1->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib1$[ebp], eax
$LN7@fnEntityCo:

; 5461 :             lpViewAttrib1;

	cmp	DWORD PTR _lpViewAttrib1$[ebp], 0
	je	SHORT $LN6@fnEntityCo

; 5463 :       {
; 5464 :          if ( lpViewAttrib1->lERAttTok == lpViewAttrib2->lERAttTok )

	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	mov	eax, DWORD PTR [ecx+177]
	cmp	eax, DWORD PTR [edx+177]
	jne	SHORT $LN12@fnEntityCo

; 5465 :             break;

	jmp	SHORT $LN6@fnEntityCo
$LN12@fnEntityCo:

; 5466 :       }

	jmp	SHORT $LN5@fnEntityCo
$LN6@fnEntityCo:

; 5467 : 
; 5468 :       // If we didn't find a matching attribute or if the attribute we
; 5469 :       // found is hidden then set compare to FALSE.
; 5470 :       if ( lpViewAttrib1 == 0 ||

	cmp	DWORD PTR _lpViewAttrib1$[ebp], 0
	je	SHORT $LN14@fnEntityCo
	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN13@fnEntityCo
	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN13@fnEntityCo
	mov	edx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 2
	and	eax, 1
	jne	SHORT $LN13@fnEntityCo
$LN14@fnEntityCo:

; 5471 :            (lpViewAttrib1->bHidden && lpViewAttrib1->bKey == FALSE &&
; 5472 :             lpViewAttrib1->bForeignKey == FALSE) )
; 5473 :       {
; 5474 :          // We found a non-hidden attribute in lpVE2 that is not part of
; 5475 :          // lpVE1 so return FALSE.
; 5476 :          return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@fnEntityCo
$LN13@fnEntityCo:

; 5477 :       }
; 5478 : 
; 5479 :    } // for ( lpViewAttrib2 )...

	jmp	$LN2@fnEntityCo
$LN3@fnEntityCo:

; 5480 : 
; 5481 :    return( TRUE );

	mov	al, 1
$LN1@fnEntityCo:

; 5482 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnEntityContainsEntity@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpLinked$ = -4						; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnStillPrevVersion PROC

; 5392 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5393 :    LPENTITYINSTANCE lpLinked;
; 5394 : 
; 5395 :    if ( lpEntityInstance->hNextVsn )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	SHORT $LN4@fnStillPre

; 5396 :       return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@fnStillPre
$LN4@fnStillPre:

; 5397 : 
; 5398 :    lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$LN2@fnStillPre:

; 5399 :    while ( lpLinked && lpLinked != lpEntityInstance )

	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $LN3@fnStillPre
	mov	eax, DWORD PTR _lpLinked$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN3@fnStillPre

; 5400 :    {
; 5401 :       if ( lpLinked->hNextVsn )

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	cmp	DWORD PTR [ecx+34], 0
	je	SHORT $LN5@fnStillPre

; 5402 :          return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@fnStillPre
$LN5@fnStillPre:

; 5403 : 
; 5404 :       lpLinked = zGETPTR( lpLinked->hNextLinked );

	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax

; 5405 :    }

	jmp	SHORT $LN2@fnStillPre
$LN3@fnStillPre:

; 5406 : 
; 5407 :    lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -257				; fffffeffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 5408 :    return( 0 );

	xor	al, al
$LN1@fnStillPre:

; 5409 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnStillPrevVersion ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpWkViewEntity$ = -4					; size = 4
_lpStartEntityInstance$ = 8				; size = 4
_lpViewEntity$ = 12					; size = 4
_fnFirstLevel2_ForViewEntity PROC

; 5345 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5346 :    LPVIEWENTITY lpWkViewEntity;
; 5347 : 
; 5348 :    if ( lpViewEntity->nLevel < 2 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	ecx, 2
	jge	SHORT $LN2@fnFirstLev

; 5349 :       return( lpStartEntityInstance );

	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	jmp	$LN1@fnFirstLev
$LN2@fnFirstLev:

; 5350 : 
; 5351 :    while ( lpViewEntity->nLevel > 2 )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	eax, 2
	jle	SHORT $LN4@fnFirstLev

; 5352 :       lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN2@fnFirstLev
$LN4@fnFirstLev:

; 5353 : 
; 5354 :    while ( lpStartEntityInstance && lpStartEntityInstance->nLevel == 1 )

	cmp	DWORD PTR _lpStartEntityInstance$[ebp], 0
	je	SHORT $LN8@fnFirstLev
	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	ecx, 1
	jne	SHORT $LN8@fnFirstLev

; 5355 :       lpStartEntityInstance = zGETPTR( lpStartEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnFirstLev
$LN8@fnFirstLev:

; 5356 : 
; 5357 :    for ( ; ; )
; 5358 :    {
; 5359 :       if ( lpStartEntityInstance == 0 )

	cmp	DWORD PTR _lpStartEntityInstance$[ebp], 0
	jne	SHORT $LN10@fnFirstLev

; 5360 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnFirstLev
$LN10@fnFirstLev:

; 5361 : 
; 5362 :       lpWkViewEntity = zGETPTR( lpStartEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax

; 5363 :       if ( lpWkViewEntity->nHierNbr < lpViewEntity->nHierNbr )

	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	cmp	ecx, eax
	jge	SHORT $LN11@fnFirstLev

; 5364 :       {
; 5365 :          if ( lpStartEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN13@fnFirstLev

; 5366 :             lpStartEntityInstance = zGETPTR( lpStartEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartEntityInstance$[ebp], eax
	jmp	SHORT $LN14@fnFirstLev
$LN13@fnFirstLev:

; 5367 :          else
; 5368 :             lpStartEntityInstance = zGETPTR( lpStartEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartEntityInstance$[ebp], eax
$LN14@fnFirstLev:

; 5369 :       }

	jmp	SHORT $LN12@fnFirstLev
$LN11@fnFirstLev:

; 5370 :       else
; 5371 :       if ( lpWkViewEntity->nHierNbr > lpViewEntity->nHierNbr )

	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	cmp	ecx, eax
	jle	SHORT $LN15@fnFirstLev

; 5372 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnFirstLev
	jmp	SHORT $LN12@fnFirstLev
$LN15@fnFirstLev:

; 5373 :       else
; 5374 :          return( lpStartEntityInstance );

	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	jmp	SHORT $LN1@fnFirstLev
$LN12@fnFirstLev:

; 5375 :         }

	jmp	$LN8@fnFirstLev
$LN1@fnFirstLev:

; 5376 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnFirstLevel2_ForViewEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpWkViewEntity$ = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_fnEntityInRecursivePath PROC

; 5293 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5294 :    LPVIEWENTITY lpWkViewEntity;
; 5295 : 
; 5296 :    if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN2@fnEntityIn

; 5297 :       return( 1 );

	mov	al, 1
	jmp	$LN1@fnEntityIn
$LN2@fnEntityIn:

; 5298 : 
; 5299 :    while ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$LN3@fnEntityIn
$LN4@fnEntityIn:

; 5300 :    {
; 5301 :       while ( lpViewEntity && lpViewEntity->bRecursivePar == FALSE )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN5@fnEntityIn
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 29					; 0000001dH
	and	eax, 1
	jne	SHORT $LN5@fnEntityIn

; 5302 :          lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN4@fnEntityIn
$LN5@fnEntityIn:

; 5303 : 
; 5304 :       if ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN9@fnEntityIn

; 5305 :       {
; 5306 :          lpWkViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
$LN6@fnEntityIn:

; 5307 : 
; 5308 :          while ( lpWkViewEntity &&

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	SHORT $LN7@fnEntityIn
	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jle	SHORT $LN7@fnEntityIn

; 5309 :                  lpWkViewEntity->nLevel > lpViewEntity->nLevel )
; 5310 :          {
; 5311 :             if ( lpWkViewEntity->bRecursive &&

	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN10@fnEntityIn
	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $LN10@fnEntityIn

; 5312 :                  lpWkViewEntity->lEREntTok == lpViewEntity->lEREntTok )
; 5313 :             {
; 5314 :                return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@fnEntityIn
$LN10@fnEntityIn:

; 5315 :             }
; 5316 : 
; 5317 :             lpWkViewEntity = zGETPTR( lpWkViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax

; 5318 :          }

	jmp	SHORT $LN6@fnEntityIn
$LN7@fnEntityIn:

; 5319 : 
; 5320 :          lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN9@fnEntityIn:

; 5321 :       }
; 5322 :    }

	jmp	$LN2@fnEntityIn
$LN3@fnEntityIn:

; 5323 : 
; 5324 :    return( 0 );

	xor	al, al
$LN1@fnEntityIn:

; 5325 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnEntityInRecursivePath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lTgtERRelTok$ = -32					; size = 4
_hSrcViewOI$ = -28					; size = 4
_hTgtViewOI$ = -24					; size = 4
_lpWkViewEntity$ = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpWk2$ = -12						; size = 4
_lpWk1$ = -8						; size = 4
_lpWk3$ = -4						; size = 4
_lpTgtEntityInstance$ = 8				; size = 4
_lpSrcEntityInstance$ = 12				; size = 4
_fnRemoveOtherOI_LinkedInstances PROC

; 5162 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5163 :    zLONG            lTgtERRelTok;
; 5164 :    LPVIEWOI         hSrcViewOI;
; 5165 :    LPVIEWOI         hTgtViewOI;
; 5166 :    LPVIEWENTITY     lpViewEntity;
; 5167 :    LPVIEWENTITY     lpWkViewEntity;
; 5168 :    LPENTITYINSTANCE lpWk1;
; 5169 :    LPENTITYINSTANCE lpWk2;
; 5170 :    LPENTITYINSTANCE lpWk3;
; 5171 : 
; 5172 :    lpViewEntity = zGETPTR( lpTgtEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5173 :    lTgtERRelTok = lpViewEntity->lERRelTok;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+199]
	mov	DWORD PTR _lTgtERRelTok$[ebp], eax

; 5174 :    hSrcViewOI   = lpSrcEntityInstance->hViewOI;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR _hSrcViewOI$[ebp], edx

; 5175 :    hTgtViewOI   = lpTgtEntityInstance->hViewOI;

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hTgtViewOI$[ebp], ecx

; 5176 : 
; 5177 :    // First, see if there are any entity instances linked to this
; 5178 :    // instance which are in a different ViewOI, if not so, then return.
; 5179 :    lpWk1 = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk1$[ebp], eax

; 5180 :    if ( lpWk1 )

	cmp	DWORD PTR _lpWk1$[ebp], 0
	je	SHORT $LN2@fnRemoveOt

; 5181 :       lpWkViewEntity = zGETPTR( lpWk1->hViewEntity );

	mov	ecx, DWORD PTR _lpWk1$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
$LN2@fnRemoveOt:

; 5182 :    while ( lpWk1 && lpWk1 != lpTgtEntityInstance &&

	cmp	DWORD PTR _lpWk1$[ebp], 0
	je	SHORT $LN3@fnRemoveOt
	mov	eax, DWORD PTR _lpWk1$[ebp]
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	je	SHORT $LN3@fnRemoveOt
	mov	ecx, DWORD PTR _lpWk1$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hTgtViewOI$[ebp]
	je	SHORT $LN19@fnRemoveOt
	mov	eax, DWORD PTR _lpWk1$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hSrcViewOI$[ebp]
	je	SHORT $LN19@fnRemoveOt
	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	eax, DWORD PTR _lTgtERRelTok$[ebp]
	cmp	eax, DWORD PTR [edx+199]
	jne	SHORT $LN3@fnRemoveOt
$LN19@fnRemoveOt:

; 5183 :            ( lpWk1->hViewOI == hTgtViewOI ||
; 5184 :              lpWk1->hViewOI == hSrcViewOI ||
; 5185 :              lTgtERRelTok == lpWkViewEntity->lERRelTok) )
; 5186 :    {
; 5187 :       lpWk1 = zGETPTR( lpWk1->hNextLinked );

	mov	ecx, DWORD PTR _lpWk1$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk1$[ebp], eax

; 5188 :       lpWkViewEntity = zGETPTR( lpWk1->hViewEntity );

	mov	eax, DWORD PTR _lpWk1$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax

; 5189 :    }

	jmp	SHORT $LN2@fnRemoveOt
$LN3@fnRemoveOt:

; 5190 : 
; 5191 :    if ( lpWk1 == 0 || lpWk1 == lpTgtEntityInstance )

	cmp	DWORD PTR _lpWk1$[ebp], 0
	je	SHORT $LN21@fnRemoveOt
	mov	edx, DWORD PTR _lpWk1$[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	SHORT $LN20@fnRemoveOt
$LN21@fnRemoveOt:

; 5192 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnRemoveOt
$LN20@fnRemoveOt:

; 5193 : 
; 5194 :    // lpWk1 now points to the first Entity instance found which is
; 5195 :    // not part of the same object instance as the entity instance
; 5196 :    // passed, remove it from the link chain.
; 5197 :    lpWk2 = lpTgtEntityInstance;

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR _lpWk2$[ebp], eax
$LN4@fnRemoveOt:

; 5198 :    while ( zGETPTR( lpWk2->hNextLinked ) != lpWk1 )

	mov	ecx, DWORD PTR _lpWk2$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWk1$[ebp]
	je	SHORT $LN5@fnRemoveOt

; 5199 :    {
; 5200 :       lpWk2 = zGETPTR( lpWk2->hNextLinked );

	mov	eax, DWORD PTR _lpWk2$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk2$[ebp], eax

; 5201 :    }

	jmp	SHORT $LN4@fnRemoveOt
$LN5@fnRemoveOt:

; 5202 : 
; 5203 :    if ( zGETPTR( lpWk1->hNextLinked ) == lpWk2 )

	mov	edx, DWORD PTR _lpWk1$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWk2$[ebp]
	jne	SHORT $LN22@fnRemoveOt

; 5204 :       lpWk2->hNextLinked = 0;

	mov	ecx, DWORD PTR _lpWk2$[ebp]
	mov	DWORD PTR [ecx+42], 0
	jmp	SHORT $LN23@fnRemoveOt
$LN22@fnRemoveOt:

; 5205 :    else
; 5206 :       lpWk2->hNextLinked = lpWk1->hNextLinked;

	mov	edx, DWORD PTR _lpWk2$[ebp]
	mov	eax, DWORD PTR _lpWk1$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$LN23@fnRemoveOt:

; 5207 : 
; 5208 :    lpWk1->hNextLinked = 0;

	mov	edx, DWORD PTR _lpWk1$[ebp]
	mov	DWORD PTR [edx+42], 0
$LN8@fnRemoveOt:

; 5209 : 
; 5210 :    // Now see if we can find any more instances not in the link chain
; 5211 :    for ( ; ; )
; 5212 :    {
; 5213 :       if ( lpTgtEntityInstance->hNextLinked == 0 )

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	SHORT $LN24@fnRemoveOt

; 5214 :          break;

	jmp	$LN7@fnRemoveOt
$LN24@fnRemoveOt:

; 5215 : 
; 5216 :       lpWk2 = lpTgtEntityInstance;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR _lpWk2$[ebp], ecx

; 5217 :       lpWk3 = zGETPTR( lpWk2->hNextLinked );

	mov	edx, DWORD PTR _lpWk2$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk3$[ebp], eax

; 5218 :       lpViewEntity = zGETPTR( lpWk3->hViewEntity );

	mov	ecx, DWORD PTR _lpWk3$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN9@fnRemoveOt:

; 5219 :       while ( lpWk3 != lpTgtEntityInstance &&

	mov	eax, DWORD PTR _lpWk3$[ebp]
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	je	SHORT $LN10@fnRemoveOt
	mov	ecx, DWORD PTR _lpWk3$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hTgtViewOI$[ebp]
	je	SHORT $LN25@fnRemoveOt
	mov	eax, DWORD PTR _lpWk3$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hSrcViewOI$[ebp]
	je	SHORT $LN25@fnRemoveOt
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR _lTgtERRelTok$[ebp]
	cmp	eax, DWORD PTR [edx+199]
	jne	SHORT $LN10@fnRemoveOt
$LN25@fnRemoveOt:

; 5220 :               ( lpWk3->hViewOI == hTgtViewOI ||
; 5221 :                 lpWk3->hViewOI == hSrcViewOI ||
; 5222 :                 lTgtERRelTok == lpViewEntity->lERRelTok) )
; 5223 :       {
; 5224 :          lpWk2 = lpWk3;

	mov	ecx, DWORD PTR _lpWk3$[ebp]
	mov	DWORD PTR _lpWk2$[ebp], ecx

; 5225 :          lpWk3 = zGETPTR( lpWk3->hNextLinked );

	mov	edx, DWORD PTR _lpWk3$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk3$[ebp], eax

; 5226 :          lpViewEntity = zGETPTR( lpWk3->hViewEntity );

	mov	ecx, DWORD PTR _lpWk3$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5227 :       }

	jmp	SHORT $LN9@fnRemoveOt
$LN10@fnRemoveOt:

; 5228 : 
; 5229 :       // If lpWk3 is in another object instance, remove it from the other
; 5230 :       // instance and link it up to lpWk1. lpWk2 is currently chained
; 5231 :       // to lpWk3 in order to make unchaining easier.
; 5232 :       if ( lpWk3 != lpTgtEntityInstance )

	mov	eax, DWORD PTR _lpWk3$[ebp]
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	je	SHORT $LN26@fnRemoveOt

; 5233 :       {
; 5234 :          if ( lpWk3->hNextLinked == zGETHNDL( lpWk2 ) )

	mov	ecx, DWORD PTR _lpWk2$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpWk3$[ebp]
	cmp	DWORD PTR [edx+42], eax
	jne	SHORT $LN28@fnRemoveOt

; 5235 :             lpWk2->hNextLinked = 0;

	mov	eax, DWORD PTR _lpWk2$[ebp]
	mov	DWORD PTR [eax+42], 0
	jmp	SHORT $LN29@fnRemoveOt
$LN28@fnRemoveOt:

; 5236 :          else
; 5237 :             lpWk2->hNextLinked = lpWk3->hNextLinked;

	mov	ecx, DWORD PTR _lpWk2$[ebp]
	mov	edx, DWORD PTR _lpWk3$[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax
$LN29@fnRemoveOt:

; 5238 : 
; 5239 :          if ( lpWk1->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpWk1$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN30@fnRemoveOt

; 5240 :             lpWk3->hNextLinked = zGETHNDL( lpWk1 );

	mov	edx, DWORD PTR _lpWk1$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWk3$[ebp]
	mov	DWORD PTR [ecx+42], eax
	jmp	SHORT $LN31@fnRemoveOt
$LN30@fnRemoveOt:

; 5241 :          else
; 5242 :             lpWk3->hNextLinked = lpWk1->hNextLinked;

	mov	edx, DWORD PTR _lpWk3$[ebp]
	mov	eax, DWORD PTR _lpWk1$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$LN31@fnRemoveOt:

; 5243 : 
; 5244 :          lpWk1->hNextLinked = zGETHNDL( lpWk3 );

	mov	edx, DWORD PTR _lpWk3$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWk1$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 5245 :       }

	jmp	SHORT $LN27@fnRemoveOt
$LN26@fnRemoveOt:

; 5246 :       else
; 5247 :          break;

	jmp	SHORT $LN7@fnRemoveOt
$LN27@fnRemoveOt:

; 5248 :    }

	jmp	$LN8@fnRemoveOt
$LN7@fnRemoveOt:

; 5249 : 
; 5250 :    // Finally, zero all the record pointers from lpTgtEntityInstance and
; 5251 :    // its linked instances
; 5252 :    lpWk2 = lpTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR _lpWk2$[ebp], edx
$LN13@fnRemoveOt:

; 5253 :    do
; 5254 :    {
; 5255 :       lpWk3 = lpWk2;

	mov	eax, DWORD PTR _lpWk2$[ebp]
	mov	DWORD PTR _lpWk3$[ebp], eax
$LN14@fnRemoveOt:

; 5256 :       while ( lpWk3->hPrevVsn )

	mov	ecx, DWORD PTR _lpWk3$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN16@fnRemoveOt

; 5257 :          lpWk3 = zGETPTR( lpWk3->hPrevVsn );

	mov	edx, DWORD PTR _lpWk3$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk3$[ebp], eax
	jmp	SHORT $LN14@fnRemoveOt
$LN16@fnRemoveOt:

; 5258 : 
; 5259 :       while ( lpWk3 )

	cmp	DWORD PTR _lpWk3$[ebp], 0
	je	SHORT $LN17@fnRemoveOt

; 5260 :       {
; 5261 :          if ( lpWk3->hPersistRecord == lpWk1->hPersistRecord )

	mov	ecx, DWORD PTR _lpWk3$[ebp]
	mov	edx, DWORD PTR _lpWk1$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	cmp	eax, DWORD PTR [edx+60]
	jne	SHORT $LN32@fnRemoveOt

; 5262 :             lpWk3->hPersistRecord = 0;

	mov	ecx, DWORD PTR _lpWk3$[ebp]
	mov	DWORD PTR [ecx+60], 0
$LN32@fnRemoveOt:

; 5263 : 
; 5264 :          lpWk3 = zGETPTR( lpWk3->hNextVsn );

	mov	edx, DWORD PTR _lpWk3$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk3$[ebp], eax

; 5265 :       }

	jmp	SHORT $LN16@fnRemoveOt
$LN17@fnRemoveOt:

; 5266 : 
; 5267 :       lpWk2 = zGETPTR( lpWk2->hNextLinked );

	mov	ecx, DWORD PTR _lpWk2$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk2$[ebp], eax

; 5268 : 
; 5269 :    }  while ( lpWk2 && lpWk2 != lpTgtEntityInstance );

	cmp	DWORD PTR _lpWk2$[ebp], 0
	je	SHORT $LN12@fnRemoveOt
	mov	eax, DWORD PTR _lpWk2$[ebp]
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	SHORT $LN13@fnRemoveOt
$LN12@fnRemoveOt:

; 5270 : 
; 5271 :    return( 0 );

	xor	eax, eax
$LN1@fnRemoveOt:

; 5272 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnRemoveOtherOI_LinkedInstances ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpTask$1 = -44						; size = 4
_lpViewCsr$ = -40					; size = 4
_lpViewEntityCsr$ = -36					; size = 4
_lpPrevVsn$2 = -32					; size = 4
_lpNextHier$3 = -28					; size = 4
_lpViewOI$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_vWork$ = -16						; size = 4
_lpWorkInstance$ = -12					; size = 4
_nLvl$ = -8						; size = 2
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_bAccept$ = 16						; size = 1
_fnRemoveAllChildTemporalVsns PROC

; 5050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 5051 :    LPVIEWENTITY     lpViewEntity;
; 5052 :    LPVIEWCSR        lpViewCsr;
; 5053 :    LPVIEWOI         lpViewOI;
; 5054 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 5055 :    LPENTITYINSTANCE lpWorkInstance;
; 5056 :    zVIEW            vWork;
; 5057 :    zSHORT           nLvl;
; 5058 :    zSHORT           nRC;
; 5059 : 
; 5060 :    vWork = 0;

	mov	DWORD PTR _vWork$[ebp], 0

; 5061 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5062 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5063 :    if ( lpEntityInstance == 0 || lpViewOI->nVersionedInstances == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN7@fnRemoveAl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	jne	SHORT $LN6@fnRemoveAl
$LN7@fnRemoveAl:

; 5064 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnRemoveAl
$LN6@fnRemoveAl:

; 5065 : 
; 5066 :    lpWorkInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpWorkInstance$[ebp], eax

; 5067 :    nLvl = lpWorkInstance->nLevel;

	mov	ecx, DWORD PTR _lpWorkInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nLvl$[ebp], dx
$LN2@fnRemoveAl:

; 5068 :    while ( lpWorkInstance->hNextHier )

	mov	eax, DWORD PTR _lpWorkInstance$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $LN4@fnRemoveAl

; 5069 :    {
; 5070 :       LPENTITYINSTANCE lpNextHier = zGETPTR( lpWorkInstance->hNextHier );

	mov	ecx, DWORD PTR _lpWorkInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$3[ebp], eax

; 5071 : 
; 5072 :       if ( lpNextHier->nLevel <= nLvl )

	mov	eax, DWORD PTR _lpNextHier$3[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nLvl$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN8@fnRemoveAl

; 5073 :          break;

	jmp	SHORT $LN4@fnRemoveAl
$LN8@fnRemoveAl:

; 5074 : 
; 5075 :       lpWorkInstance = lpNextHier;

	mov	eax, DWORD PTR _lpNextHier$3[ebp]
	mov	DWORD PTR _lpWorkInstance$[ebp], eax

; 5076 :    }

	jmp	SHORT $LN2@fnRemoveAl
$LN4@fnRemoveAl:

; 5077 : 
; 5078 :    // Now that we have found the last descendent of the entity instance,
; 5079 :    // go through and find all versions to accept or cancel.
; 5080 :    while ( lpWorkInstance != lpEntityInstance )

	mov	ecx, DWORD PTR _lpWorkInstance$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	$LN5@fnRemoveAl

; 5081 :    {
; 5082 :       if ( lpWorkInstance->u.nInd.bTemporal || lpWorkInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	jne	SHORT $LN10@fnRemoveAl
	mov	ecx, DWORD PTR _lpWorkInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	$LN9@fnRemoveAl
$LN10@fnRemoveAl:

; 5083 :       {
; 5084 :          LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpWorkInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$2[ebp], eax

; 5085 : 
; 5086 :          if ( lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot == FALSE )

	cmp	DWORD PTR _lpPrevVsn$2[ebp], 0
	je	SHORT $LN11@fnRemoveAl
	mov	ecx, DWORD PTR _lpPrevVsn$2[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	jne	SHORT $LN11@fnRemoveAl

; 5087 :          {
; 5088 :             LPTASK lpTask;
; 5089 : 
; 5090 :             // Remove was requested ... why not do it???
; 5091 :             TraceLineS( "RemoveAllTemporal skipping break:", " dks 2007.04.23" );  // dks  2007.04.23

	push	OFFSET $SG15064
	push	OFFSET $SG15065
	call	_TraceLineS@8

; 5092 :             lpViewEntity = zGETPTR( lpWorkInstance->hViewEntity );

	mov	eax, DWORD PTR _lpWorkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5093 :             nRC = fnValidateInstanceParameters( &lpTask,

	push	-32768					; ffff8000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	104					; 00000068H
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	mov	WORD PTR _nRC$[ebp], ax

; 5094 :                                                 &lpViewEntity,
; 5095 :                                                 &lpViewEntityCsr,
; 5096 :                                                 iCancelSubobject,
; 5097 :                                                 lpView,
; 5098 :                                                 lpViewEntity->szName,
; 5099 :                                                 (zSHORT) 0x8000 ); // test (no error message)
; 5100 :             if ( nRC != zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	je	SHORT $LN12@fnRemoveAl

; 5101 :                fnOperationReturn( iCancelSubobject, lpTask );

	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	push	104					; 00000068H
	call	_fnOperationReturn
	add	esp, 8
$LN12@fnRemoveAl:

; 5102 : 
; 5103 :             if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN11@fnRemoveAl

; 5104 :                break;

	jmp	$LN5@fnRemoveAl
$LN11@fnRemoveAl:

; 5105 :          }
; 5106 : 
; 5107 :          if ( vWork == 0 )

	cmp	DWORD PTR _vWork$[ebp], 0
	jne	SHORT $LN14@fnRemoveAl

; 5108 :             CreateViewFromViewForTask( &vWork, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vWork$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12
$LN14@fnRemoveAl:

; 5109 : 
; 5110 :          lpViewEntityCsr = fnEstablishViewForInstance( vWork, 0, lpWorkInstance );

	mov	eax, DWORD PTR _lpWorkInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vWork$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 5111 :          lpViewEntity = zGETPTR( lpWorkInstance->hViewEntity );

	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5112 :          if ( bAccept )

	movzx	ecx, BYTE PTR _bAccept$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@fnRemoveAl

; 5113 :             nRC = AcceptSubobject( vWork, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _vWork$[ebp]
	push	eax
	call	_AcceptSubobject@8
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN16@fnRemoveAl
$LN15@fnRemoveAl:

; 5114 :          else
; 5115 :             nRC = CancelSubobject( vWork, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _vWork$[ebp]
	push	edx
	call	_CancelSubobject@8
	mov	WORD PTR _nRC$[ebp], ax
$LN16@fnRemoveAl:

; 5116 : 
; 5117 :          if ( nRC < zCURSOR_UNDEFINED || lpViewOI->nVersionedInstances == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	jl	SHORT $LN18@fnRemoveAl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	jne	SHORT $LN17@fnRemoveAl
$LN18@fnRemoveAl:

; 5118 :          {
; 5119 :             DropView( vWork );

	mov	eax, DWORD PTR _vWork$[ebp]
	push	eax
	call	_DropView@4

; 5120 : 
; 5121 :             if ( lpViewOI->nVersionedInstances == 0 )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	jne	SHORT $LN19@fnRemoveAl

; 5122 :                return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnRemoveAl
	jmp	SHORT $LN17@fnRemoveAl
$LN19@fnRemoveAl:

; 5123 :             else
; 5124 :                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnRemoveAl
$LN17@fnRemoveAl:

; 5125 :          }
; 5126 : 
; 5127 :          // Get the instance pointer from the cursor after the accept or
; 5128 :          // cancel call.
; 5129 :          lpWorkInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance$[ebp], eax
$LN9@fnRemoveAl:

; 5130 :       }
; 5131 : 
; 5132 :       lpWorkInstance = zGETPTR( lpWorkInstance->hPrevHier );

	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance$[ebp], eax

; 5133 :    }

	jmp	$LN4@fnRemoveAl
$LN5@fnRemoveAl:

; 5134 : 
; 5135 :    if ( vWork )

	cmp	DWORD PTR _vWork$[ebp], 0
	je	SHORT $LN21@fnRemoveAl

; 5136 :       DropView( vWork );

	mov	ecx, DWORD PTR _vWork$[ebp]
	push	ecx
	call	_DropView@4
$LN21@fnRemoveAl:

; 5137 : 
; 5138 :    return( 0 );

	xor	eax, eax
$LN1@fnRemoveAl:

; 5139 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnRemoveAllChildTemporalVsns ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpCurrentTask$ = 16					; size = 4
_nEvent$ = 20						; size = 2
_nState$ = 24						; size = 2
_fnInvokeECEOperation PROC

; 4947 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4948 :    zPECEOPER   pfn;
; 4949 : 
; 4950 :    pfn = fnGetEntityCnstrntOper( lpView, lpViewEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetEntityCnstrntOper
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _pfn$[ebp], eax

; 4951 :    if ( pfn )

	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $LN2@fnInvokeEC

; 4952 :    {
; 4953 :       return( (*pfn)( lpView, lpViewEntity->szName,

	movzx	eax, WORD PTR _nState$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nEvent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _pfn$[ebp]
	jmp	SHORT $LN1@fnInvokeEC
$LN2@fnInvokeEC:

; 4954 :                       nEvent, nState ) );
; 4955 :    }
; 4956 : 
; 4957 :    return( 0 );

	xor	eax, eax
$LN1@fnInvokeEC:

; 4958 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInvokeECEOperation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpLastTaskOperation$1 = -36				; size = 4
_lpViewOD$ = -32					; size = 4
_hLibrary$ = -28					; size = 4
_lProcessID$ = -24					; size = 4
_hCurrentTask$ = -20					; size = 4
_pchOperLibName$ = -16					; size = 4
_hTaskOperation$ = -12					; size = 4
_lpTaskOperation$ = -8					; size = 4
_bMutexLocked$2 = -1					; size = 1
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpCurrentTask$ = 16					; size = 4
_fnGetEntityCnstrntOper PROC

; 4834 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 4835 :    LPTASK      hCurrentTask = zGETHNDL( lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hCurrentTask$[ebp], eax

; 4836 :    LPVIEWOD    lpViewOD;
; 4837 :    zPCHAR      pchOperLibName;
; 4838 :    LPLIBRARY   hLibrary;
; 4839 :    zPVOID      hTaskOperation;
; 4840 :    LPTASKOPER  lpTaskOperation;
; 4841 :    zLONG       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 4842 : 
; 4843 :    // No Object Constraint operation pointer, return 0 ==> not found.
; 4844 :    if ( lpViewEntity->szECEOpername[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+146]
	test	ecx, ecx
	jne	SHORT $LN5@fnGetEntit

; 4845 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetEntit
$LN5@fnGetEntit:

; 4846 : 
; 4847 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4848 : 
; 4849 :    for ( lpTaskOperation = zGETPTR( lpViewEntity->hFirstTaskOperation );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+183]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
	jmp	SHORT $LN4@fnGetEntit
$LN2@fnGetEntit:

; 4851 :          lpTaskOperation = zGETPTR( lpTaskOperation->hNextTaskOperationForOEA ) )

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
$LN4@fnGetEntit:

; 4850 :          lpTaskOperation;

	cmp	DWORD PTR _lpTaskOperation$[ebp], 0
	je	SHORT $LN3@fnGetEntit

; 4852 :    {
; 4853 :       if ( lpTaskOperation->hTask == hCurrentTask &&

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+14]
	cmp	eax, DWORD PTR _hCurrentTask$[ebp]
	jne	SHORT $LN6@fnGetEntit
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN6@fnGetEntit

; 4854 :            lpTaskOperation->lProcessID == lProcessID )
; 4855 :       {
; 4856 :          return( (zPECEOPER) lpTaskOperation->pfnTaskOper );

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [eax+30]
	jmp	$LN1@fnGetEntit
$LN6@fnGetEntit:

; 4857 :       }
; 4858 :    }

	jmp	SHORT $LN2@fnGetEntit
$LN3@fnGetEntit:

; 4859 : 
; 4860 :    // No task object oper exists yet, create one if possible.
; 4861 :    pchOperLibName = lpViewOD->szOperLibname;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 142				; 0000008eH
	mov	DWORD PTR _pchOperLibName$[ebp], ecx

; 4862 :    if ( pchOperLibName == 0 || pchOperLibName[ 0 ] == 0 )

	je	SHORT $LN8@fnGetEntit
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchOperLibName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN7@fnGetEntit
$LN8@fnGetEntit:

; 4863 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetEntit
$LN7@fnGetEntit:

; 4864 : 
; 4865 :    hLibrary = SysLoadLibrary( lpView, pchOperLibName );

	mov	eax, DWORD PTR _pchOperLibName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 4866 : 
; 4867 :    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$LN9@fnGetEntit

; 4868 :    {
; 4869 :       zBOOL bMutexLocked;
; 4870 : 
; 4871 :       hTaskOperation = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10034					; 00002732H
	push	0
	push	1
	push	38					; 00000026H
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskOperation$[ebp], eax

; 4872 :                                          sizeof( TaskOperationRecord ), 1, 0,
; 4873 :                                          iTaskOperation );
; 4874 :       if ( hTaskOperation == 0 )

	cmp	DWORD PTR _hTaskOperation$[ebp], 0
	jne	SHORT $LN11@fnGetEntit

; 4875 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetEntit
$LN11@fnGetEntit:

; 4876 : 
; 4877 :       lpTaskOperation              = zGETPTR( hTaskOperation );

	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax

; 4878 :       lpTaskOperation->hViewEntity = zGETHNDL( lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+22], eax

; 4879 :       lpTaskOperation->hTask       = hCurrentTask;

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR _hCurrentTask$[ebp]
	mov	DWORD PTR [edx+14], eax

; 4880 :       lpTaskOperation->lProcessID  = lProcessID;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [ecx+34], edx

; 4881 : 
; 4882 :       // Set pointers for TaskOperation chain off of Task structure
; 4883 :       // Note: this is a single linked list
; 4884 :       if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hCurrentTask$[ebp]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN12@fnGetEntit

; 4885 :       {
; 4886 :          bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$2[ebp], 1

; 4887 :          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 4888 :       }

	jmp	SHORT $LN13@fnGetEntit
$LN12@fnGetEntit:

; 4889 :       else
; 4890 :          bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$2[ebp], 0
$LN13@fnGetEntit:

; 4891 : 
; 4892 :       lpTaskOperation->hNextTaskOperationForTask =

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+130]
	mov	DWORD PTR [edx+2], ecx

; 4893 :                                           lpCurrentTask->hFirstTaskOperation;
; 4894 :       lpCurrentTask->hFirstTaskOperation = hTaskOperation;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+130], eax

; 4895 : 
; 4896 :       if ( bMutexLocked )

	movzx	ecx, BYTE PTR _bMutexLocked$2[ebp]
	test	ecx, ecx
	je	SHORT $LN14@fnGetEntit

; 4897 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN14@fnGetEntit:

; 4898 : 
; 4899 :       lpTaskOperation->pfnTaskOper = SysGetProc( hLibrary,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 146				; 00000092H
	push	edx
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 4900 :                                                  lpViewEntity->szECEOpername );
; 4901 : 
; 4902 :       // Set pointers for TaskOperation chain off of ViewEntity structure
; 4903 :       // Note: this is a double linked list
; 4904 :       if ( lpViewEntity->hLastTaskOperation )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+187], 0
	je	SHORT $LN15@fnGetEntit

; 4905 :       {
; 4906 :          LPTASKOPER lpLastTaskOperation;
; 4907 : 
; 4908 :          lpLastTaskOperation = zGETPTR( lpViewEntity->hLastTaskOperation );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+187]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastTaskOperation$1[ebp], eax

; 4909 :          lpLastTaskOperation->hNextTaskOperationForOEA = hTaskOperation;

	mov	edx, DWORD PTR _lpLastTaskOperation$1[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+6], eax

; 4910 :          lpTaskOperation->hPrevTaskOperationForOEA =

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+187]
	mov	DWORD PTR [ecx+10], eax

; 4911 :                                             lpViewEntity->hLastTaskOperation;
; 4912 :          lpViewEntity->hLastTaskOperation = hTaskOperation;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [ecx+187], edx

; 4913 :       }

	jmp	SHORT $LN16@fnGetEntit
$LN15@fnGetEntit:

; 4914 :       else
; 4915 :       {
; 4916 :          lpViewEntity->hFirstTaskOperation = hTaskOperation;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [eax+183], ecx

; 4917 :          lpViewEntity->hLastTaskOperation  = hTaskOperation;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+187], eax
$LN16@fnGetEntit:

; 4918 :       }
; 4919 :    }

	jmp	SHORT $LN10@fnGetEntit
$LN9@fnGetEntit:

; 4920 :    else
; 4921 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetEntit
$LN10@fnGetEntit:

; 4922 : 
; 4923 :    return( (zPECEOPER) lpTaskOperation->pfnTaskOper );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [ecx+30]
$LN1@fnGetEntit:

; 4924 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetEntityCnstrntOper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_hOldRecord$ = -40					; size = 4
_lpTgtViewEntity$ = -36					; size = 4
_lpSrcViewEntity$ = -32					; size = 4
_hNewRecord$1 = -28					; size = 4
_lpWorkEI$2 = -24					; size = 4
_lpWorkEI$3 = -20					; size = 4
_lpVsnEntityInstance$ = -16				; size = 4
_lpWrkEntityInstance$ = -12				; size = 4
_nRC$ = -8						; size = 2
_bCreated$ = -3						; size = 1
_bUpdated$ = -2						; size = 1
_bPrevVersion$ = -1					; size = 1
_lpTgtEntityInstance$ = 8				; size = 4
_lpSrcEntityInstance$ = 12				; size = 4
_fnRelinkInstanceToInstance PROC

; 4631 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 4632 :    LPVIEWENTITY     lpTgtViewEntity;
; 4633 :    LPENTITYINSTANCE lpWrkEntityInstance;
; 4634 :    LPENTITYINSTANCE lpVsnEntityInstance;
; 4635 :    zPVOID           hOldRecord;
; 4636 :    zBOOL            bCreated, bUpdated, bPrevVersion;
; 4637 :    zSHORT           nRC;
; 4638 : 
; 4639 : #ifdef DEBUG
; 4640 :    LPVIEWENTITY lpSrcViewEntity = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$[ebp], eax

; 4641 : #endif
; 4642 : 
; 4643 :    // Get the target view entity.
; 4644 :    lpTgtViewEntity = zGETPTR( lpTgtEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewEntity$[ebp], eax

; 4645 : 
; 4646 :    // Make sure that the source and target are not already linked.
; 4647 :    if ( lpSrcEntityInstance == lpTgtEntityInstance )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	SHORT $LN18@fnRelinkIn

; 4648 :       nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	$LN19@fnRelinkIn
$LN18@fnRelinkIn:

; 4649 :    else
; 4650 :    {
; 4651 :       nRC = 0;   // default return code to 0

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 4652 :       bUpdated = lpSrcEntityInstance->u.nInd.bUpdated;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	mov	BYTE PTR _bUpdated$[ebp], dl

; 4653 :       bCreated = lpSrcEntityInstance->u.nInd.bCreated;

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	mov	BYTE PTR _bCreated$[ebp], cl

; 4654 :       bPrevVersion = FALSE;

	mov	BYTE PTR _bPrevVersion$[ebp], 0

; 4655 :       if ( lpSrcEntityInstance->u.nInd.bPrevVersion ||

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 8
	and	eax, 1
	jne	SHORT $LN21@fnRelinkIn
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 8
	and	edx, 1
	je	SHORT $LN20@fnRelinkIn
$LN21@fnRelinkIn:

; 4656 :            lpTgtEntityInstance->u.nInd.bPrevVersion )
; 4657 :       {
; 4658 :          bPrevVersion = TRUE;

	mov	BYTE PTR _bPrevVersion$[ebp], 1

; 4659 :          if ( lpSrcEntityInstance->u.nInd.bPrevVersion == FALSE )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 8
	and	ecx, 1
	jne	SHORT $LN20@fnRelinkIn

; 4660 :          {
; 4661 :             lpSrcEntityInstance->u.nInd.bPrevVersion = TRUE;

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 4662 :             lpWrkEntityInstance = zGETPTR( lpSrcEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN2@fnRelinkIn:

; 4663 :             while ( lpWrkEntityInstance &&

	cmp	DWORD PTR _lpWrkEntityInstance$[ebp], 0
	je	SHORT $LN20@fnRelinkIn
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	je	SHORT $LN20@fnRelinkIn

; 4664 :                     lpWrkEntityInstance != lpSrcEntityInstance )
; 4665 :             {
; 4666 :                lpWrkEntityInstance->u.nInd.bPrevVersion = TRUE;

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 4667 :                lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax

; 4668 :             }

	jmp	SHORT $LN2@fnRelinkIn
$LN20@fnRelinkIn:

; 4669 :          }
; 4670 :       }
; 4671 : 
; 4672 :       lpWrkEntityInstance = zGETPTR( lpSrcEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN4@fnRelinkIn:

; 4673 :       while ( lpWrkEntityInstance &&

	cmp	DWORD PTR _lpWrkEntityInstance$[ebp], 0
	je	SHORT $LN19@fnRelinkIn
	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	je	SHORT $LN19@fnRelinkIn

; 4674 :               lpWrkEntityInstance != lpSrcEntityInstance )
; 4675 :       {
; 4676 :          if ( lpWrkEntityInstance == lpTgtEntityInstance )

	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	SHORT $LN23@fnRelinkIn

; 4677 :          {
; 4678 :             nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 4679 :             break;

	jmp	SHORT $LN19@fnRelinkIn
$LN23@fnRelinkIn:

; 4680 :          }
; 4681 : 
; 4682 :          lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax

; 4683 :       }

	jmp	SHORT $LN4@fnRelinkIn
$LN19@fnRelinkIn:

; 4684 :    }
; 4685 : 
; 4686 :    // if the return code is 0, then all edits have passed and the
; 4687 :    // source and target entity instances are not currently linked,
; 4688 :    // link them now
; 4689 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN24@fnRelinkIn

; 4690 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnRelinkIn
$LN24@fnRelinkIn:

; 4691 : 
; 4692 :    // Link the two instances together
; 4693 :    if ( lpSrcEntityInstance->hNextLinked == 0 )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	$LN25@fnRelinkIn

; 4694 :    {
; 4695 :       if ( lpTgtEntityInstance->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN27@fnRelinkIn

; 4696 :          lpSrcEntityInstance->hNextLinked = zGETHNDL( lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
	jmp	$LN28@fnRelinkIn
$LN27@fnRelinkIn:

; 4697 :       else
; 4698 :       {
; 4699 :          // Chain forward past target entity instance on target chain
; 4700 :          lpWrkEntityInstance = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN8@fnRelinkIn:

; 4701 :          for ( ; ; )
; 4702 :          {
; 4703 :             // Set the record pointer for other instances in target
; 4704 :             // link chain to point to the source record.
; 4705 :             lpWrkEntityInstance->hPersistRecord = lpSrcEntityInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 4706 :             lpWrkEntityInstance->u.nInd.bUpdated = bUpdated;

	movzx	ecx, BYTE PTR _bUpdated$[ebp]
	and	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -5					; fffffffbH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 4707 :             lpWrkEntityInstance->u.nInd.bCreated = bCreated;

	movzx	edx, BYTE PTR _bCreated$[ebp]
	and	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	or	ecx, edx
	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 4708 :             lpWrkEntityInstance->u.nInd.bPrevVersion = bPrevVersion;

	movzx	eax, BYTE PTR _bPrevVersion$[ebp]
	and	eax, 1
	shl	eax, 8
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -257				; fffffeffH
	or	edx, eax
	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 4709 : 
; 4710 :             if ( zGETPTR( lpWrkEntityInstance->hNextLinked ) ==

	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	SHORT $LN29@fnRelinkIn

; 4711 :                                                    lpTgtEntityInstance )
; 4712 :             {
; 4713 :                break;

	jmp	SHORT $LN7@fnRelinkIn
$LN29@fnRelinkIn:

; 4714 :             }
; 4715 : 
; 4716 :             lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax

; 4717 :          }

	jmp	$LN8@fnRelinkIn
$LN7@fnRelinkIn:

; 4718 : 
; 4719 :          lpSrcEntityInstance->hNextLinked = lpTgtEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$LN28@fnRelinkIn:

; 4720 :       }
; 4721 : 
; 4722 :       lpTgtEntityInstance->hNextLinked = zGETHNDL( lpSrcEntityInstance );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 4723 :    }

	jmp	$LN26@fnRelinkIn
$LN25@fnRelinkIn:

; 4724 :    else
; 4725 :    {
; 4726 :       if ( lpTgtEntityInstance->hNextLinked == 0 )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	jne	SHORT $LN30@fnRelinkIn

; 4727 :       {
; 4728 :          lpTgtEntityInstance->hNextLinked = lpSrcEntityInstance->hNextLinked;

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR [eax+42], edx

; 4729 :          lpSrcEntityInstance->hNextLinked = zGETHNDL( lpTgtEntityInstance );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 4730 :       }

	jmp	$LN26@fnRelinkIn
$LN30@fnRelinkIn:

; 4731 :       else
; 4732 :       {
; 4733 :          // Both entity instances are on two different link chains,
; 4734 :          // break the two chains and combine into one larger chain
; 4735 :          lpWrkEntityInstance = zGETPTR( lpSrcEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN9@fnRelinkIn:

; 4736 :          while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN10@fnRelinkIn

; 4737 :          {
; 4738 :             LPENTITYINSTANCE lpWorkEI;
; 4739 : 
; 4740 :             lpWorkEI = zGETPTR( lpWrkEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkEI$3[ebp], eax

; 4741 : 
; 4742 :             if ( lpWorkEI == lpSrcEntityInstance )

	mov	ecx, DWORD PTR _lpWorkEI$3[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	jne	SHORT $LN32@fnRelinkIn

; 4743 :                break;

	jmp	SHORT $LN10@fnRelinkIn
$LN32@fnRelinkIn:

; 4744 : 
; 4745 :             lpWrkEntityInstance = lpWorkEI;

	mov	edx, DWORD PTR _lpWorkEI$3[ebp]
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], edx

; 4746 :          }

	jmp	SHORT $LN9@fnRelinkIn
$LN10@fnRelinkIn:

; 4747 : 
; 4748 :          lpWrkEntityInstance->hNextLinked = zGETHNDL( lpTgtEntityInstance );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 4749 : 
; 4750 :          // Chain forward past target entity instance on target chain
; 4751 :          lpWrkEntityInstance = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN13@fnRelinkIn:

; 4752 :          for ( ; ; )
; 4753 :          {
; 4754 :             LPENTITYINSTANCE lpWorkEI;
; 4755 : 
; 4756 :             // Set the record pointer for other instances in target
; 4757 :             // link chain to point to the source record
; 4758 :             lpWrkEntityInstance->hPersistRecord = lpSrcEntityInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 4759 :             lpWrkEntityInstance->u.nInd.bUpdated = bUpdated;

	movzx	ecx, BYTE PTR _bUpdated$[ebp]
	and	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -5					; fffffffbH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 4760 :             lpWrkEntityInstance->u.nInd.bCreated = bCreated;

	movzx	edx, BYTE PTR _bCreated$[ebp]
	and	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -3					; fffffffdH
	or	ecx, edx
	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 4761 :             lpWrkEntityInstance->u.nInd.bPrevVersion = bPrevVersion;

	movzx	eax, BYTE PTR _bPrevVersion$[ebp]
	and	eax, 1
	shl	eax, 8
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -257				; fffffeffH
	or	edx, eax
	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 4762 : 
; 4763 :             lpWorkEI = zGETPTR( lpWrkEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkEI$2[ebp], eax

; 4764 : 
; 4765 :             if ( lpWorkEI == lpTgtEntityInstance )

	mov	eax, DWORD PTR _lpWorkEI$2[ebp]
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	SHORT $LN33@fnRelinkIn

; 4766 :                break;

	jmp	SHORT $LN12@fnRelinkIn
$LN33@fnRelinkIn:

; 4767 : 
; 4768 :             lpWrkEntityInstance = lpWorkEI;

	mov	ecx, DWORD PTR _lpWorkEI$2[ebp]
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], ecx

; 4769 :          }

	jmp	$LN13@fnRelinkIn
$LN12@fnRelinkIn:

; 4770 : 
; 4771 :          // Now that we have found the last instance in the target
; 4772 :          // link chain, chain it forward to the source instance.
; 4773 :          lpWrkEntityInstance->hNextLinked = zGETHNDL( lpSrcEntityInstance );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$LN26@fnRelinkIn:

; 4774 :       }
; 4775 :    }
; 4776 : 
; 4777 : #ifdef DEBUG
; 4778 :    lpSrcViewEntity = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$[ebp], eax

; 4779 : #endif
; 4780 : 
; 4781 :    // The two instances are linked together, now free up the data
; 4782 :    // record for the target entity instance and set the record
; 4783 :    // pointer from the source entity instance.
; 4784 :    hOldRecord = lpTgtEntityInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR _hOldRecord$[ebp], edx

; 4785 :    fnDeleteAttributeRecord( lpTgtViewEntity, lpTgtEntityInstance, TRUE );

	push	1
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 4786 :    lpTgtEntityInstance->hPersistRecord = lpSrcEntityInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 4787 :    lpTgtEntityInstance->u.nInd.bUpdated = bUpdated;

	movzx	edx, BYTE PTR _bUpdated$[ebp]
	and	edx, 1
	shl	edx, 2
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	or	ecx, edx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 4788 :    lpTgtEntityInstance->u.nInd.bCreated = bCreated;

	movzx	eax, BYTE PTR _bCreated$[ebp]
	and	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	or	edx, eax
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 4789 :    lpTgtEntityInstance->u.nInd.bPrevVersion = bPrevVersion;

	movzx	ecx, BYTE PTR _bPrevVersion$[ebp]
	and	ecx, 1
	shl	ecx, 8
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -257				; fffffeffH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 4790 : 
; 4791 :    // Now that the old record has been deleted, propogate the link
; 4792 :    // record across all versions of the target instance.
; 4793 :    if ( lpTgtEntityInstance->hNextVsn )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN34@fnRelinkIn

; 4794 :    {
; 4795 :       zPVOID hNewRecord;
; 4796 : 
; 4797 :       hNewRecord = lpTgtEntityInstance->hPersistRecord;

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR _hNewRecord$1[ebp], ecx

; 4798 : 
; 4799 :       lpVsnEntityInstance = zGETPTR( lpTgtEntityInstance->hNextVsn );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVsnEntityInstance$[ebp], eax
$LN14@fnRelinkIn:

; 4800 :       while ( lpVsnEntityInstance )

	cmp	DWORD PTR _lpVsnEntityInstance$[ebp], 0
	je	SHORT $LN34@fnRelinkIn

; 4801 :       {
; 4802 :          if ( lpVsnEntityInstance->hPersistRecord == hOldRecord )

	mov	ecx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	cmp	edx, DWORD PTR _hOldRecord$[ebp]
	jne	SHORT $LN35@fnRelinkIn

; 4803 :          {
; 4804 :             lpVsnEntityInstance->hPersistRecord = hNewRecord;

	mov	eax, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	ecx, DWORD PTR _hNewRecord$1[ebp]
	mov	DWORD PTR [eax+60], ecx

; 4805 :             lpWrkEntityInstance = zGETPTR( lpVsnEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN16@fnRelinkIn:

; 4806 : 
; 4807 :             while ( lpWrkEntityInstance &&

	cmp	DWORD PTR _lpWrkEntityInstance$[ebp], 0
	je	SHORT $LN35@fnRelinkIn
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpVsnEntityInstance$[ebp]
	je	SHORT $LN35@fnRelinkIn

; 4808 :                     lpWrkEntityInstance != lpVsnEntityInstance )
; 4809 :             {
; 4810 :                lpVsnEntityInstance->hPersistRecord = hNewRecord;

	mov	edx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	eax, DWORD PTR _hNewRecord$1[ebp]
	mov	DWORD PTR [edx+60], eax

; 4811 :                lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax

; 4812 :             }

	jmp	SHORT $LN16@fnRelinkIn
$LN35@fnRelinkIn:

; 4813 :          }
; 4814 : 
; 4815 :          lpVsnEntityInstance = zGETPTR( lpVsnEntityInstance->hNextVsn );

	mov	eax, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVsnEntityInstance$[ebp], eax

; 4816 :       }

	jmp	SHORT $LN14@fnRelinkIn
$LN34@fnRelinkIn:

; 4817 :    }
; 4818 : 
; 4819 :    return( nRC );  // return to caller

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnRelinkIn:

; 4820 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnRelinkInstanceToInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
tv91 = -48						; size = 4
_lpViewEntity$ = -44					; size = 4
tv156 = -40						; size = 4
tv155 = -36						; size = 4
_ulOffset$ = -32					; size = 4
_lpTgtRecord$ = -28					; size = 4
_lpSrcRecord$ = -24					; size = 4
_lpExternalP$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpSrcData$ = -12					; size = 4
_lpTgtData$ = -8					; size = 4
_bKeyFound$ = -1					; size = 1
_lpTgtEntityInstance$ = 8				; size = 4
_lpSrcEntityInstance$ = 12				; size = 4
_fnInstanceKeysMatch PROC

; 4544 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 4545 :    zBOOL        bKeyFound;
; 4546 :    zULONG       ulOffset;
; 4547 :    LPVIEWENTITY lpViewEntity;
; 4548 :    LPVIEWATTRIB lpViewAttrib;
; 4549 :    zPCHAR       lpSrcRecord;
; 4550 :    zPCHAR       lpTgtRecord;
; 4551 :    zPCHAR       lpSrcData;
; 4552 :    zPCHAR       lpTgtData;
; 4553 :    zCOREMEM     lpExternalP;
; 4554 : 
; 4555 :    bKeyFound = 0;

	mov	BYTE PTR _bKeyFound$[ebp], 0

; 4556 :    lpTgtRecord = (zPCHAR) zGETPTR( lpTgtEntityInstance->hPersistRecord );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtRecord$[ebp], eax

; 4557 :    lpSrcRecord = (zPCHAR) zGETPTR( lpSrcEntityInstance->hPersistRecord );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcRecord$[ebp], eax

; 4558 :    if ( lpSrcRecord && lpTgtRecord )

	cmp	DWORD PTR _lpSrcRecord$[ebp], 0
	je	$LN6@fnInstance
	cmp	DWORD PTR _lpTgtRecord$[ebp], 0
	je	$LN6@fnInstance

; 4559 :    {
; 4560 :       lpViewEntity = zGETPTR( lpTgtEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4561 :       lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN2@fnInstance:

; 4562 :       while ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN6@fnInstance

; 4563 :       {
; 4564 :          if ( lpViewAttrib->bKey && lpViewAttrib->bPersist )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	je	$LN7@fnInstance
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	je	$LN7@fnInstance

; 4565 :          {
; 4566 :             bKeyFound = TRUE;

	mov	BYTE PTR _bKeyFound$[ebp], 1

; 4567 :             ulOffset = lpViewAttrib->ulRecordOffset;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _ulOffset$[ebp], ecx

; 4568 :             lpSrcData = lpSrcRecord + ulOffset;

	mov	edx, DWORD PTR _lpSrcRecord$[ebp]
	add	edx, DWORD PTR _ulOffset$[ebp]
	mov	DWORD PTR _lpSrcData$[ebp], edx

; 4569 :             lpTgtData = lpTgtRecord + ulOffset;

	mov	eax, DWORD PTR _lpTgtRecord$[ebp]
	add	eax, DWORD PTR _ulOffset$[ebp]
	mov	DWORD PTR _lpTgtData$[ebp], eax

; 4570 :             switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv91[ebp], dl
	cmp	BYTE PTR tv91[ebp], 83			; 00000053H
	je	SHORT $LN8@fnInstance
	jmp	$LN12@fnInstance
$LN8@fnInstance:

; 4571 :             {
; 4572 :                case 'S':
; 4573 :                   if ( lpSrcData[ 0 ] == (zCHAR) '\xff' &&

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSrcData$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, -1
	jne	SHORT $LN9@fnInstance
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTgtData$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	jne	SHORT $LN9@fnInstance

; 4574 :                        lpTgtData[ 0 ] == (zCHAR) '\xff' )
; 4575 :                   {
; 4576 :                      lpExternalP = (zCOREMEM) (lpSrcData + 1);

	mov	edx, DWORD PTR _lpSrcData$[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$[ebp], edx

; 4577 :                      lpSrcData   = zGETPTR( *lpExternalP );

	mov	eax, DWORD PTR _lpExternalP$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcData$[ebp], eax

; 4578 :                      lpExternalP = (zCOREMEM) (lpTgtData + 1);

	mov	edx, DWORD PTR _lpTgtData$[ebp]
	add	edx, 1
	mov	DWORD PTR _lpExternalP$[ebp], edx

; 4579 :                      lpTgtData   = zGETPTR( *lpExternalP );

	mov	eax, DWORD PTR _lpExternalP$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtData$[ebp], eax
$LN9@fnInstance:

; 4580 :                   }
; 4581 : 
; 4582 :                   if ( lpSrcData[ 0 ] != lpTgtData[ 0 ] ||

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpSrcData$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _lpTgtData$[ebp]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	edx, ecx
	jne	SHORT $LN11@fnInstance
	mov	edx, DWORD PTR _lpSrcData$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _lpTgtData$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN18@fnInstance
	mov	eax, DWORD PTR _lpTgtData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcData$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv156[ebp], eax
	jmp	SHORT $LN19@fnInstance
$LN18@fnInstance:
	mov	edx, DWORD PTR _lpSrcData$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _lpTgtData$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN16@fnInstance
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN17@fnInstance
$LN16@fnInstance:
	mov	DWORD PTR tv155[ebp], -1
$LN17@fnInstance:
	mov	eax, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv156[ebp], eax
$LN19@fnInstance:
	cmp	DWORD PTR tv156[ebp], 0
	je	SHORT $LN10@fnInstance
$LN11@fnInstance:

; 4583 :                        zstrcmp( lpSrcData, lpTgtData ) != 0 )
; 4584 :                   {
; 4585 :                      return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnInstance
$LN10@fnInstance:

; 4586 :                   }
; 4587 : 
; 4588 :                   break;

	jmp	SHORT $LN7@fnInstance
$LN12@fnInstance:

; 4589 : 
; 4590 :                default:
; 4591 :                   if ( zmemcmp( lpSrcData, lpTgtData,
; 4592 :                                 lpViewAttrib->ulLth ) != 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+203]
	push	edx
	mov	eax, DWORD PTR _lpTgtData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcData$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN7@fnInstance

; 4593 :                   {
; 4594 :                      return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnInstance
$LN7@fnInstance:

; 4595 :                   }
; 4596 :             }
; 4597 :          }
; 4598 : 
; 4599 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 4600 :       }

	jmp	$LN2@fnInstance
$LN6@fnInstance:

; 4601 :    }
; 4602 : 
; 4603 :    // If we get here and a key was found, then the records match ...
; 4604 :    // return success.
; 4605 :    if ( bKeyFound )

	movzx	ecx, BYTE PTR _bKeyFound$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@fnInstance

; 4606 :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnInstance
$LN14@fnInstance:

; 4607 : 
; 4608 :    // If a key was not found or a record does not exist, then they can't
; 4609 :    // match ... return failure.
; 4610 :    return( 0 );  // default is no match

	xor	eax, eax
$LN1@fnInstance:

; 4611 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInstanceKeysMatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_nLevel$ = -8						; size = 2
_nHidden$ = -4						; size = 2
_lpStartEntityInstance$ = 8				; size = 4
_bMarkExcluded$ = 12					; size = 2
_fnHideExcludedDeletedInstances PROC

; 3809 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3810 :    zSHORT            nHidden;
; 3811 :    zSHORT            nLevel;
; 3812 : 
; 3813 :    nHidden = 0;

	xor	eax, eax
	mov	WORD PTR _nHidden$[ebp], ax

; 3814 :    nLevel = lpStartEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nLevel$[ebp], dx
$LN4@fnHideExcl:

; 3815 : 
; 3816 :    do
; 3817 :    {
; 3818 :       if ( lpStartEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN5@fnHideExcl

; 3819 :       {
; 3820 :          lpStartEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 3821 :          nHidden++;

	mov	dx, WORD PTR _nHidden$[ebp]
	add	dx, 1
	mov	WORD PTR _nHidden$[ebp], dx

; 3822 : 
; 3823 :          // Call the recursive function to mark any linked instances
; 3824 :          // as hidden which were deleted or excluded by the calling
; 3825 :          // operation
; 3826 :          if ( (lpStartEntityInstance->u.nInd.bDeleted ||
; 3827 :                lpStartEntityInstance->u.nInd.bExcluded) &&

	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN7@fnHideExcl
	mov	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN6@fnHideExcl
$LN7@fnHideExcl:
	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN6@fnHideExcl

; 3828 :               lpStartEntityInstance->hNextLinked )
; 3829 :          {
; 3830 :             nHidden += fnHideLinkedChildren( lpStartEntityInstance,

	movzx	edx, WORD PTR _bMarkExcluded$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	push	eax
	call	_fnHideLinkedChildren
	add	esp, 8
	movsx	ecx, ax
	movsx	edx, WORD PTR _nHidden$[ebp]
	add	edx, ecx
	mov	WORD PTR _nHidden$[ebp], dx
$LN6@fnHideExcl:

; 3831 :                                              bMarkExcluded );
; 3832 :          }
; 3833 : 
; 3834 :          if ( bMarkExcluded == FALSE )

	movsx	eax, WORD PTR _bMarkExcluded$[ebp]
	test	eax, eax
	jne	SHORT $LN5@fnHideExcl

; 3835 :             lpStartEntityInstance->u.nInd.bExcluded = FALSE;

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN5@fnHideExcl:

; 3836 :       }
; 3837 : 
; 3838 :       lpStartEntityInstance = zGETPTR( lpStartEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartEntityInstance$[ebp], eax

; 3839 : 
; 3840 :    }  while ( lpStartEntityInstance &&

	cmp	DWORD PTR _lpStartEntityInstance$[ebp], 0
	je	SHORT $LN3@fnHideExcl
	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jg	$LN4@fnHideExcl
$LN3@fnHideExcl:

; 3841 :               lpStartEntityInstance->nLevel > nLevel );
; 3842 : 
; 3843 :    return( nHidden );

	mov	ax, WORD PTR _nHidden$[ebp]

; 3844 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnHideExcludedDeletedInstances ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpNextHier$ = -16					; size = 4
_lpLinked$ = -12					; size = 4
_nLevel$ = -8						; size = 2
_nHidden$ = -4						; size = 2
_lpStartEntityInstance$ = 8				; size = 4
_bMarkExcluded$ = 12					; size = 2
_fnHideLinkedChildren PROC

; 3740 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3741 :    zSHORT            nHidden;
; 3742 :    zSHORT            nLevel;
; 3743 :    LPENTITYINSTANCE  lpLinked;
; 3744 :    LPENTITYINSTANCE  lpNextHier;
; 3745 : 
; 3746 :    nHidden  = 0;

	xor	eax, eax
	mov	WORD PTR _nHidden$[ebp], ax

; 3747 :    nLevel   = lpStartEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nLevel$[ebp], dx

; 3748 :    lpLinked = zGETPTR( lpStartEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$LN2@fnHideLink:

; 3749 : 
; 3750 :    // For every linked instance to the starting instance passed,
; 3751 :    // mark it and all its children as hidden IF they are not already hidden
; 3752 :    // and they are marked either for delete or exclude. Recursively call
; 3753 :    // ourself for every child of a linked instance marked for delete which
; 3754 :    // is itself also marked for delete.
; 3755 :    while ( lpLinked && lpLinked != lpStartEntityInstance )

	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	$LN3@fnHideLink
	mov	edx, DWORD PTR _lpLinked$[ebp]
	cmp	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	je	$LN3@fnHideLink

; 3756 :    {
; 3757 :       if ( lpLinked->u.nInd.bHidden == FALSE &&

	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	$LN6@fnHideLink
	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN7@fnHideLink
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	je	$LN6@fnHideLink
$LN7@fnHideLink:

; 3758 :            (lpLinked->u.nInd.bExcluded || lpLinked->u.nInd.bDeleted) )
; 3759 :       {
; 3760 :          lpLinked->u.nInd.bHidden = TRUE;

	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 1024				; 00000400H
	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 3761 :          if ( bMarkExcluded == FALSE )

	movsx	eax, WORD PTR _bMarkExcluded$[ebp]
	test	eax, eax
	jne	SHORT $LN8@fnHideLink

; 3762 :             lpLinked->u.nInd.bExcluded = FALSE;

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN8@fnHideLink:

; 3763 : 
; 3764 :          nHidden++;

	mov	cx, WORD PTR _nHidden$[ebp]
	add	cx, 1
	mov	WORD PTR _nHidden$[ebp], cx

; 3765 :          lpNextHier = zGETPTR( lpLinked->hNextHier );

	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$[ebp], eax
$LN4@fnHideLink:

; 3766 :          while ( lpNextHier && lpNextHier->nLevel > lpLinked->nLevel )

	cmp	DWORD PTR _lpNextHier$[ebp], 0
	je	$LN6@fnHideLink
	mov	ecx, DWORD PTR _lpNextHier$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpLinked$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jle	$LN6@fnHideLink

; 3767 :          {
; 3768 :             if ( lpNextHier->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpNextHier$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN9@fnHideLink

; 3769 :             {
; 3770 :                if ( lpNextHier->hNextLinked &&

	mov	ecx, DWORD PTR _lpNextHier$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN10@fnHideLink
	mov	edx, DWORD PTR _lpNextHier$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN11@fnHideLink
	mov	ecx, DWORD PTR _lpNextHier$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	je	SHORT $LN10@fnHideLink
$LN11@fnHideLink:

; 3771 :                     (lpNextHier->u.nInd.bExcluded ||
; 3772 :                      lpNextHier->u.nInd.bDeleted) )
; 3773 :                {
; 3774 :                   nHidden += fnHideLinkedChildren( lpNextHier,

	movzx	eax, WORD PTR _bMarkExcluded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNextHier$[ebp]
	push	ecx
	call	_fnHideLinkedChildren
	add	esp, 8
	movsx	edx, ax
	movsx	eax, WORD PTR _nHidden$[ebp]
	add	eax, edx
	mov	WORD PTR _nHidden$[ebp], ax
$LN10@fnHideLink:

; 3775 :                                                    bMarkExcluded );
; 3776 :                }
; 3777 : 
; 3778 :                lpNextHier->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpNextHier$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpNextHier$[ebp]
	mov	DWORD PTR [eax+6], edx

; 3779 :                nHidden++;

	mov	cx, WORD PTR _nHidden$[ebp]
	add	cx, 1
	mov	WORD PTR _nHidden$[ebp], cx
$LN9@fnHideLink:

; 3780 :             }
; 3781 : 
; 3782 :             lpNextHier = zGETPTR( lpNextHier->hNextHier );

	mov	edx, DWORD PTR _lpNextHier$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$[ebp], eax

; 3783 :          }

	jmp	$LN4@fnHideLink
$LN6@fnHideLink:

; 3784 :       }
; 3785 : 
; 3786 :       lpLinked = zGETPTR( lpLinked->hNextLinked );

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax

; 3787 :    }

	jmp	$LN2@fnHideLink
$LN3@fnHideLink:

; 3788 : 
; 3789 :    // Return number of instances hidden
; 3790 :    return( nHidden );

	mov	ax, WORD PTR _nHidden$[ebp]

; 3791 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnHideLinkedChildren ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpPrevVsn$1 = -16					; size = 4
_lpPrevVsn$2 = -12					; size = 4
_lpViewOI$ = -8						; size = 4
tv130 = -4						; size = 4
_lpTgtEntityInstance$ = 8				; size = 4
_lpSrcEntityInstance$ = 12				; size = 4
_fnInstanceVersionRootMatch PROC

; 4484 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4485 :    LPVIEWOI lpViewOI = zGETPTR( lpSrcEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4486 : 
; 4487 :    // If no temporal entities or subobject versions exist for either
; 4488 :    // viewoi, then the answer is same version.
; 4489 :    if ( lpViewOI->nVersionedInstances == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	jne	SHORT $LN2@fnInstance

; 4490 :       return( 1 );

	mov	al, 1
	jmp	$LN1@fnInstance
$LN2@fnInstance:

; 4491 : 
; 4492 :    // Determine the source root version for the source entity instance.
; 4493 :    while ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN3@fnInstance

; 4494 :    {
; 4495 :       if ( lpSrcEntityInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN7@fnInstance

; 4496 :       {
; 4497 :          LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpSrcEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$2[ebp], eax

; 4498 : 
; 4499 :          if ( lpPrevVsn->u.nInd.bPrevVsnRoot )

	mov	ecx, DWORD PTR _lpPrevVsn$2[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	je	SHORT $LN7@fnInstance

; 4500 :             break;

	jmp	SHORT $LN3@fnInstance
$LN7@fnInstance:

; 4501 :       }
; 4502 : 
; 4503 :       lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hParent );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 4504 :    }

	jmp	SHORT $LN2@fnInstance
$LN3@fnInstance:

; 4505 : 
; 4506 :    if ( lpSrcEntityInstance == 0 )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	jne	SHORT $LN4@fnInstance

; 4507 :       return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@fnInstance
$LN4@fnInstance:

; 4508 : 
; 4509 :    // Determine the source root version for the target entity instance.
; 4510 :    while ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN5@fnInstance

; 4511 :    {
; 4512 :       if ( lpTgtEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN10@fnInstance

; 4513 :       {
; 4514 :          LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpTgtEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$1[ebp], eax

; 4515 : 
; 4516 :          if ( lpPrevVsn->u.nInd.bPrevVsnRoot )

	mov	edx, DWORD PTR _lpPrevVsn$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN10@fnInstance

; 4517 :             break;

	jmp	SHORT $LN5@fnInstance
$LN10@fnInstance:

; 4518 :       }
; 4519 : 
; 4520 :       lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 4521 :    }

	jmp	SHORT $LN4@fnInstance
$LN5@fnInstance:

; 4522 : 
; 4523 :    // Return the comparison of the source and target version root.
; 4524 :    return( lpSrcEntityInstance == lpTgtEntityInstance );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	SHORT $LN13@fnInstance
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN14@fnInstance
$LN13@fnInstance:
	mov	DWORD PTR tv130[ebp], 0
$LN14@fnInstance:
	mov	al, BYTE PTR tv130[ebp]
$LN1@fnInstance:

; 4525 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInstanceVersionRootMatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -4						; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnInstanceVersioned PROC

; 4440 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4441 :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4442 : 
; 4443 :    // If the ViewOI has no versioned instances, return 0.
; 4444 :    if ( lpViewOI->nVersionedInstances == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	jne	SHORT $LN2@fnInstance

; 4445 :       return( 0 );

	xor	al, al
	jmp	SHORT $LN1@fnInstance
$LN2@fnInstance:

; 4446 : 
; 4447 :    // We look for either a temporal entity or a versioned instance up the
; 4448 :    // parent chain to see if the instance is versioned.
; 4449 :    while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN3@fnInstance

; 4450 :    {
; 4451 :       if ( lpEntityInstance->u.nInd.bTemporal || lpEntityInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN6@fnInstance
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN5@fnInstance
$LN6@fnInstance:

; 4452 :          return( 1 ); // the instance is versioned

	mov	al, 1
	jmp	SHORT $LN1@fnInstance
$LN5@fnInstance:

; 4453 : 
; 4454 :       lpEntityInstance = zGETPTR( lpEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 4455 :    }

	jmp	SHORT $LN2@fnInstance
$LN3@fnInstance:

; 4456 : 
; 4457 :    return( 0 ); // instance is not part of a newer version

	xor	al, al
$LN1@fnInstance:

; 4458 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInstanceVersioned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpWrkInstance$ = -4					; size = 4
_lpSrcInstance$ = 8					; size = 4
_lpTgtInstance$ = 12					; size = 4
_fnInstanceLinkedToInstance PROC

; 4403 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4404 :    LPENTITYINSTANCE lpWrkInstance;
; 4405 : 
; 4406 :    if ( lpSrcInstance == 0 || lpTgtInstance == 0 ||
; 4407 :         lpSrcInstance->hNextLinked == 0 || lpTgtInstance->hNextLinked == 0 )

	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	SHORT $LN5@fnInstance
	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	SHORT $LN5@fnInstance
	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	SHORT $LN5@fnInstance
	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN4@fnInstance
$LN5@fnInstance:

; 4408 :    {
; 4409 :       return( 0 );

	xor	al, al
	jmp	SHORT $LN1@fnInstance
$LN4@fnInstance:

; 4410 :    }
; 4411 : 
; 4412 :    lpWrkInstance = zGETPTR( lpSrcInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSrcInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN2@fnInstance:

; 4413 :    while ( lpWrkInstance != lpTgtInstance && lpWrkInstance != lpSrcInstance )

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	ecx, DWORD PTR _lpTgtInstance$[ebp]
	je	SHORT $LN3@fnInstance
	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	edx, DWORD PTR _lpSrcInstance$[ebp]
	je	SHORT $LN3@fnInstance

; 4414 :    {
; 4415 :       lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 4416 :    }

	jmp	SHORT $LN2@fnInstance
$LN3@fnInstance:

; 4417 : 
; 4418 :    if ( lpWrkInstance == lpTgtInstance )

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	edx, DWORD PTR _lpTgtInstance$[ebp]
	jne	SHORT $LN6@fnInstance

; 4419 :       return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@fnInstance
	jmp	SHORT $LN1@fnInstance
$LN6@fnInstance:

; 4420 :    else
; 4421 :       return( 0 );

	xor	al, al
$LN1@fnInstance:

; 4422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInstanceLinkedToInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_hNextHier$1 = -60					; size = 4
tv69 = -56						; size = 4
_lpPrevHier$2 = -52					; size = 4
_lpSearchLink$3 = -48					; size = 4
_lpViewEntityRP$ = -44					; size = 4
_lpViewCsr$ = -40					; size = 4
_lpWork$4 = -36						; size = 4
_lpViewEntityCsr$ = -32					; size = 4
_lpViewEntity$ = -28					; size = 4
_hEntityInstance$ = -24					; size = 4
_lpEntityInstance$ = -20				; size = 4
_nLevel$5 = -16						; size = 2
_nHierLvl1$ = -12					; size = 2
_nHierLvl2$ = -8					; size = 2
_bGetNext$ = -1						; size = 1
_lpViewOI$ = 8						; size = 4
_fnReclaimHiddenInstances@4 PROC

; 4248 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 4249 :    LPENTITYINSTANCE lpEntityInstance;
; 4250 :    LPENTITYINSTANCE hEntityInstance;
; 4251 :    LPVIEWCSR        lpViewCsr;
; 4252 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 4253 :    LPVIEWENTITY     lpViewEntity, lpViewEntityRP;
; 4254 :    zSHORT           nHierLvl1, nHierLvl2;
; 4255 :    zBOOL            bGetNext;
; 4256 : 
; 4257 :    hEntityInstance = lpViewOI->hRootEntityInstance;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR _hEntityInstance$[ebp], ecx

; 4258 :    if ( hEntityInstance == 0 )

	cmp	DWORD PTR _hEntityInstance$[ebp], 0
	jne	SHORT $LN15@fnReclaimH

; 4259 :       return;

	jmp	$LN1@fnReclaimH
$LN15@fnReclaimH:

; 4260 : 
; 4261 :    // Loop through each of the entity instances.  We use bGetNext to control
; 4262 :    // whether we get the next entity.  If bGetNext is FALSE then it's already
; 4263 :    // been done in the body of the loop.
; 4264 :    for ( ;

	jmp	SHORT $LN4@fnReclaimH
$LN2@fnReclaimH:

; 4266 :          hEntityInstance = bGetNext ? lpEntityInstance->hNextHier : hEntityInstance )

	movzx	edx, BYTE PTR _bGetNext$[ebp]
	test	edx, edx
	je	SHORT $LN34@fnReclaimH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR tv69[ebp], ecx
	jmp	SHORT $LN35@fnReclaimH
$LN34@fnReclaimH:
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR tv69[ebp], edx
$LN35@fnReclaimH:
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR _hEntityInstance$[ebp], eax
$LN4@fnReclaimH:

; 4265 :          hEntityInstance;

	cmp	DWORD PTR _hEntityInstance$[ebp], 0
	je	$LN3@fnReclaimH

; 4267 :    {
; 4268 :       LPENTITYINSTANCE lpPrevHier;
; 4269 :       LPENTITYINSTANCE hNextHier;
; 4270 :       LPENTITYINSTANCE lpWork;
; 4271 :       zSHORT           nLevel;
; 4272 : 
; 4273 :       lpEntityInstance = zGETPTR( hEntityInstance );

	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 4274 :       bGetNext = TRUE;

	mov	BYTE PTR _bGetNext$[ebp], 1

; 4275 : 
; 4276 :       // We only try to reclaim dead entity instances.
; 4277 :       if ( !fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnEntityInstanceIsDead@4
	cwde
	test	eax, eax
	jne	SHORT $LN16@fnReclaimH

; 4278 :          continue;

	jmp	SHORT $LN2@fnReclaimH
$LN16@fnReclaimH:

; 4279 : 
; 4280 :       // First see if instance is referenced by a cursor
; 4281 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4282 :       nHierLvl2 = 0;

	xor	eax, eax
	mov	WORD PTR _nHierLvl2$[ebp], ax

; 4283 :       if ( lpViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN17@fnReclaimH

; 4284 :       {
; 4285 :          nHierLvl2 = lpViewEntity->nHierNbr - 1;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	mov	WORD PTR _nHierLvl2$[ebp], cx

; 4286 :          lpViewEntityRP = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityRP$[ebp], eax
$LN5@fnReclaimH:

; 4287 :          while ( lpViewEntityRP->lEREntTok != lpViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpViewEntityRP$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $LN6@fnReclaimH

; 4288 :             lpViewEntityRP = zGETPTR( lpViewEntityRP->hParent );

	mov	ecx, DWORD PTR _lpViewEntityRP$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityRP$[ebp], eax
	jmp	SHORT $LN5@fnReclaimH
$LN6@fnReclaimH:

; 4289 : 
; 4290 :          nHierLvl1 = lpViewEntityRP->nHierNbr - 1;

	mov	eax, DWORD PTR _lpViewEntityRP$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	mov	WORD PTR _nHierLvl1$[ebp], cx

; 4291 :       }

	jmp	SHORT $LN18@fnReclaimH
$LN17@fnReclaimH:

; 4292 :       else
; 4293 :          nHierLvl1 = lpViewEntity->nHierNbr - 1;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	mov	WORD PTR _nHierLvl1$[ebp], ax
$LN18@fnReclaimH:

; 4294 : 
; 4295 :       // Now go through the view cursors and see if any is referencing
; 4296 :       // the entity instance in question.
; 4297 :       for ( lpViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $LN9@fnReclaimH
$LN7@fnReclaimH:

; 4299 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr ) )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$LN9@fnReclaimH:

; 4298 :             lpViewCsr;

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	je	SHORT $LN8@fnReclaimH

; 4300 :       {
; 4301 :          lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );  // blew on this line 2006.06.30 dks

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4302 :          lpViewEntityCsr += nHierLvl1;

	movsx	ecx, WORD PTR _nHierLvl1$[ebp]
	imul	edx, ecx, 30
	add	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 4303 :          if ( lpViewEntityCsr->hEntityInstance == hEntityInstance )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	cmp	ecx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $LN19@fnReclaimH

; 4304 :             break;

	jmp	SHORT $LN8@fnReclaimH
$LN19@fnReclaimH:

; 4305 : 
; 4306 :          if ( nHierLvl2 )

	movsx	edx, WORD PTR _nHierLvl2$[ebp]
	test	edx, edx
	je	SHORT $LN20@fnReclaimH

; 4307 :          {
; 4308 :             lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4309 :             lpViewEntityCsr += nHierLvl2;

	movsx	edx, WORD PTR _nHierLvl2$[ebp]
	imul	eax, edx, 30
	add	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4310 :             if ( lpViewEntityCsr->hEntityInstance == hEntityInstance )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	cmp	edx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $LN20@fnReclaimH

; 4311 :                break;

	jmp	SHORT $LN8@fnReclaimH
$LN20@fnReclaimH:

; 4312 :          }
; 4313 :       }

	jmp	SHORT $LN7@fnReclaimH
$LN8@fnReclaimH:

; 4314 : 
; 4315 :       // If no cursor was found, delete the entity instance and
; 4316 :       // all of its subordinates.
; 4317 :       if ( lpViewCsr )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	je	SHORT $LN22@fnReclaimH

; 4318 :          continue;     // Continue with next entity instance.

	jmp	$LN2@fnReclaimH
$LN22@fnReclaimH:

; 4319 : 
; 4320 :       nLevel = lpEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nLevel$5[ebp], cx

; 4321 :       lpPrevHier = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$2[ebp], eax

; 4322 :       if ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN23@fnReclaimH

; 4323 :       {
; 4324 :          lpWork = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWork$4[ebp], eax

; 4325 :          lpWork->hPrevTwin = lpEntityInstance->hPrevTwin;

	mov	ecx, DWORD PTR _lpWork$4[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	mov	DWORD PTR [ecx+26], eax
$LN23@fnReclaimH:

; 4326 :       }
; 4327 : 
; 4328 :       if ( lpEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN24@fnReclaimH

; 4329 :       {
; 4330 :          lpWork = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWork$4[ebp], eax

; 4331 :          lpWork->hNextTwin = lpEntityInstance->hNextTwin;

	mov	ecx, DWORD PTR _lpWork$4[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	mov	DWORD PTR [ecx+22], eax
$LN24@fnReclaimH:

; 4332 :       }
; 4333 : 
; 4334 :       // Indicate that we'll end up with the next entity instance.
; 4335 :       bGetNext = FALSE;

	mov	BYTE PTR _bGetNext$[ebp], 0

; 4336 : 
; 4337 :       // Check to see if we are removing the root entity instance.
; 4338 :       if ( lpViewOI->hRootEntityInstance == hEntityInstance )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	cmp	edx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $LN12@fnReclaimH

; 4339 :          lpViewOI->hRootEntityInstance = lpEntityInstance->hNextTwin;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	mov	DWORD PTR [eax+26], edx
$LN12@fnReclaimH:

; 4340 : 
; 4341 :       // Clear this entity instance and all of its children.
; 4342 :       do
; 4343 :       {
; 4344 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4345 :          hNextHier    = lpEntityInstance->hNextHier;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hNextHier$1[ebp], eax

; 4346 :          if ( lpEntityInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN26@fnReclaimH

; 4347 :          {
; 4348 :             lpWork = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWork$4[ebp], eax

; 4349 :             if ( lpWork->hNextLinked == hEntityInstance )

	mov	ecx, DWORD PTR _lpWork$4[ebp]
	mov	edx, DWORD PTR [ecx+42]
	cmp	edx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $LN28@fnReclaimH

; 4350 :                lpWork->hNextLinked = 0;

	mov	eax, DWORD PTR _lpWork$4[ebp]
	mov	DWORD PTR [eax+42], 0
	jmp	SHORT $LN29@fnReclaimH
$LN28@fnReclaimH:

; 4351 :             else
; 4352 :             {
; 4353 :                LPENTITYINSTANCE lpSearchLink;
; 4354 : 
; 4355 :                lpSearchLink = lpWork;

	mov	ecx, DWORD PTR _lpWork$4[ebp]
	mov	DWORD PTR _lpSearchLink$3[ebp], ecx
$LN13@fnReclaimH:

; 4356 :                while ( lpSearchLink->hNextLinked != hEntityInstance )

	mov	edx, DWORD PTR _lpSearchLink$3[ebp]
	mov	eax, DWORD PTR [edx+42]
	cmp	eax, DWORD PTR _hEntityInstance$[ebp]
	je	SHORT $LN14@fnReclaimH

; 4357 :                   lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	ecx, DWORD PTR _lpSearchLink$3[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$3[ebp], eax
	jmp	SHORT $LN13@fnReclaimH
$LN14@fnReclaimH:

; 4358 : 
; 4359 :                lpSearchLink->hNextLinked = lpEntityInstance->hNextLinked;

	mov	eax, DWORD PTR _lpSearchLink$3[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR [eax+42], edx
$LN29@fnReclaimH:

; 4360 :             }
; 4361 :          }

	jmp	SHORT $LN27@fnReclaimH
$LN26@fnReclaimH:

; 4362 :          else
; 4363 :             fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, TRUE );

	push	1
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH
$LN27@fnReclaimH:

; 4364 : 
; 4365 :          fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, FALSE );

	push	0
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 4366 :          fnRemoveEntityFromDebugChange( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnRemoveEntityFromDebugChange@4

; 4367 :          fnFreeDataspace( lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 4368 : 
; 4369 :          // Get next instance.
; 4370 :          hEntityInstance  = hNextHier;

	mov	eax, DWORD PTR _hNextHier$1[ebp]
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 4371 :          lpEntityInstance = zGETPTR( hEntityInstance );

	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 4372 : 
; 4373 :       }  while ( lpEntityInstance && lpEntityInstance->nLevel > nLevel );

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN11@fnReclaimH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$5[ebp]
	cmp	eax, ecx
	jg	$LN12@fnReclaimH
$LN11@fnReclaimH:

; 4374 : 
; 4375 :       if ( lpPrevHier )

	cmp	DWORD PTR _lpPrevHier$2[ebp], 0
	je	SHORT $LN31@fnReclaimH

; 4376 :          lpPrevHier->hNextHier = hEntityInstance;

	mov	edx, DWORD PTR _lpPrevHier$2[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+14], eax
$LN31@fnReclaimH:

; 4377 : 
; 4378 :       if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN32@fnReclaimH

; 4379 :          lpEntityInstance->hPrevHier = zGETHNDL( lpPrevHier );

	mov	ecx, DWORD PTR _lpPrevHier$2[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax
$LN32@fnReclaimH:

; 4380 : 
; 4381 :    } // for each lpEntityInstance...

	jmp	$LN2@fnReclaimH
$LN3@fnReclaimH:

; 4382 : 
; 4383 :    // We're all done, clear the hidden count.
; 4384 :    lpViewOI->nHiddenCount = 0;    // clear hidden count

	xor	eax, eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [ecx+24], ax
$LN1@fnReclaimH:

; 4385 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnReclaimHiddenInstances@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpWorkInstance$1 = -76					; size = 4
_lpTask$2 = -72						; size = 4
_lpPrevTwin$3 = -68					; size = 4
_lpNextTwin$4 = -64					; size = 4
_lpLinkedFirstViewCsr$5 = -60				; size = 4
_lpLinkedOI$6 = -56					; size = 4
_lpRecursViewEntity$7 = -52				; size = 4
_lpParentInstance$ = -48				; size = 4
_lpViewEntity$ = -44					; size = 4
_lpSpawnView$8 = -40					; size = 4
_lpSearchViewEntityCsr$9 = -36				; size = 4
_lpSpawnedInstance$10 = -32				; size = 4
_lpWorkViewEntityCsr$11 = -28				; size = 4
_lpSearchViewEntity$12 = -24				; size = 4
_lpParentViewEntity$13 = -20				; size = 4
_lpLinkedInstance$ = -16				; size = 4
_lpLinkedTwin$14 = -12					; size = 4
_nSpawnPosition$15 = -8					; size = 2
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_fnSpawnCreateEntity PROC

; 3984 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 3985 :    LPENTITYINSTANCE lpParentInstance;
; 3986 :    LPENTITYINSTANCE lpLinkedInstance;
; 3987 :    LPVIEWENTITY     lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 3988 :    zSHORT           nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 3989 : 
; 3990 :    // START OF CREATE ENTITY SPAWNING CODE
; 3991 :    // Now that the entity has been created, see if we need to call
; 3992 :    // fnCreateEntity to spawn the create of this same entity under a
; 3993 :    // different parent in the same view object. To do this, we check all
; 3994 :    // linked instances of the parent entity type from the same object
; 3995 :    // instance and see if that linked instance has a definition level
; 3996 :    // non-derived child entity type representing the current entity type.
; 3997 :    // If we find a spawn condition, we create a new view for spawning,
; 3998 :    // create the spawned instance in the appropriate position and
; 3999 :    // link it to the newly created instance.
; 4000 :    if ( lpEntityInstance->hParent == 0 || lpViewEntity->bDerived )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN22@fnSpawnCre
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	je	SHORT $LN21@fnSpawnCre
$LN22@fnSpawnCre:

; 4001 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnSpawnCre
$LN21@fnSpawnCre:

; 4002 : 
; 4003 :    lpParentInstance = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentInstance$[ebp], eax

; 4004 :    for ( lpLinkedInstance = zGETPTR( lpParentInstance->hNextLinked );

	mov	edx, DWORD PTR _lpParentInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedInstance$[ebp], eax
	jmp	SHORT $LN4@fnSpawnCre
$LN2@fnSpawnCre:

; 4006 :          lpLinkedInstance = zGETPTR( lpLinkedInstance->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedInstance$[ebp], eax
$LN4@fnSpawnCre:

; 4005 :          nRC == 0 && lpLinkedInstance && lpLinkedInstance != lpParentInstance;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN3@fnSpawnCre
	cmp	DWORD PTR _lpLinkedInstance$[ebp], 0
	je	$LN3@fnSpawnCre
	mov	ecx, DWORD PTR _lpLinkedInstance$[ebp]
	cmp	ecx, DWORD PTR _lpParentInstance$[ebp]
	je	$LN3@fnSpawnCre

; 4007 :    {
; 4008 :       LPVIEWENTITY lpParentViewEntity;
; 4009 :       LPVIEWENTITY lpRecursViewEntity;
; 4010 :       LPVIEWENTITY lpSearchViewEntity;
; 4011 : 
; 4012 :       if ( lpLinkedInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN23@fnSpawnCre

; 4013 :          continue;

	jmp	SHORT $LN2@fnSpawnCre
$LN23@fnSpawnCre:

; 4014 : 
; 4015 :       // If we find a linked parent in ANY object instance, go through the
; 4016 :       // child entity types of the linked parent and see if one exists which
; 4017 :       // matches the current entity type.
; 4018 :       lpParentViewEntity = zGETPTR( lpLinkedInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$13[ebp], eax

; 4019 :       lpRecursViewEntity = lpParentViewEntity;

	mov	eax, DWORD PTR _lpParentViewEntity$13[ebp]
	mov	DWORD PTR _lpRecursViewEntity$7[ebp], eax

; 4020 :       if ( lpParentViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpParentViewEntity$13[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN24@fnSpawnCre
$LN7@fnSpawnCre:

; 4021 :       {
; 4022 :          do
; 4023 :          {
; 4024 :             lpParentViewEntity = zGETPTR( lpParentViewEntity->hParent );

	mov	eax, DWORD PTR _lpParentViewEntity$13[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$13[ebp], eax

; 4025 :          }  while ( lpParentViewEntity->lEREntTok !=

	mov	edx, DWORD PTR _lpParentViewEntity$13[ebp]
	mov	eax, DWORD PTR _lpRecursViewEntity$7[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $LN7@fnSpawnCre
$LN24@fnSpawnCre:

; 4026 :                                               lpRecursViewEntity->lEREntTok );
; 4027 :       }
; 4028 : 
; 4029 :       for ( lpSearchViewEntity = zGETPTR( lpParentViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpParentViewEntity$13[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$12[ebp], eax
	jmp	SHORT $LN10@fnSpawnCre
$LN8@fnSpawnCre:

; 4031 :                lpSearchViewEntity->nLevel > lpParentViewEntity->nLevel;
; 4032 :             lpSearchViewEntity = zGETPTR( lpSearchViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpSearchViewEntity$12[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$12[ebp], eax
$LN10@fnSpawnCre:

; 4030 :             lpSearchViewEntity &&

	cmp	DWORD PTR _lpSearchViewEntity$12[ebp], 0
	je	$LN9@fnSpawnCre
	mov	eax, DWORD PTR _lpSearchViewEntity$12[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpParentViewEntity$13[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jle	$LN9@fnSpawnCre

; 4033 :       {
; 4034 :          zVIEW            lpSpawnView;
; 4035 :          LPVIEWOI         lpLinkedOI;
; 4036 :          LPVIEWCSR        lpLinkedFirstViewCsr;
; 4037 :          zSHORT           nSpawnPosition;
; 4038 :          LPVIEWENTITYCSR  lpSearchViewEntityCsr;
; 4039 :          LPVIEWENTITYCSR  lpWorkViewEntityCsr;
; 4040 :          LPENTITYINSTANCE lpLinkedTwin;
; 4041 :          LPENTITYINSTANCE lpSpawnedInstance;
; 4042 : 
; 4043 :          if ( zGETPTR( lpSearchViewEntity->hParent ) != lpParentViewEntity )

	mov	ecx, DWORD PTR _lpSearchViewEntity$12[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpParentViewEntity$13[ebp]
	je	SHORT $LN25@fnSpawnCre

; 4044 :             continue;

	jmp	SHORT $LN8@fnSpawnCre
$LN25@fnSpawnCre:

; 4045 : 
; 4046 :          if ( lpSearchViewEntity->bDerived )

	mov	eax, DWORD PTR _lpSearchViewEntity$12[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	je	SHORT $LN26@fnSpawnCre

; 4047 :             continue;

	jmp	SHORT $LN8@fnSpawnCre
$LN26@fnSpawnCre:

; 4048 : 
; 4049 :          if ( lpSearchViewEntity->lERRelTok != lpViewEntity->lERRelTok )

	mov	edx, DWORD PTR _lpSearchViewEntity$12[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	je	SHORT $LN27@fnSpawnCre

; 4050 :             continue;

	jmp	SHORT $LN8@fnSpawnCre
$LN27@fnSpawnCre:

; 4051 : 
; 4052 :          if ( lpSearchViewEntity->bRelLink1 != lpViewEntity->bRelLink1 )

	mov	edx, DWORD PTR _lpSearchViewEntity$12[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 28					; 0000001cH
	and	edx, 1
	cmp	eax, edx
	je	SHORT $LN28@fnSpawnCre

; 4053 :             continue;

	jmp	$LN8@fnSpawnCre
$LN28@fnSpawnCre:

; 4054 : 
; 4055 :          if ( !fnInstanceVersionRootMatch( lpParentInstance, lpLinkedInstance ) )

	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpParentInstance$[ebp]
	push	ecx
	call	_fnInstanceVersionRootMatch
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN29@fnSpawnCre

; 4056 :             continue;

	jmp	$LN8@fnSpawnCre
$LN29@fnSpawnCre:

; 4057 : 
; 4058 :          lpLinkedOI = zGETPTR( lpLinkedInstance->hViewOI );

	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedOI$6[ebp], eax

; 4059 :          lpLinkedFirstViewCsr = zGETPTR( lpLinkedOI->hFirstViewCsr );

	mov	edx, DWORD PTR _lpLinkedOI$6[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedFirstViewCsr$5[ebp], eax

; 4060 : 
; 4061 :          // We've found a spawn condition, create a spawn view and do the spawn.
; 4062 :          nRC = CreateViewFromViewForTask( &lpSpawnView,

	push	0
	mov	ecx, DWORD PTR _lpLinkedFirstViewCsr$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	lea	eax, DWORD PTR _lpSpawnView$8[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax

; 4063 :                                           zGETPTR( lpLinkedFirstViewCsr->hView ), 0 );
; 4064 :          if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@fnSpawnCre

; 4065 :             continue;

	jmp	$LN8@fnSpawnCre
$LN30@fnSpawnCre:

; 4066 : 
; 4067 :          // Establish target cursors up the parent chain.
; 4068 :          lpSearchViewEntityCsr =

	mov	edx, DWORD PTR _lpLinkedInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpSpawnView$8[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpSearchViewEntityCsr$9[ebp], eax

; 4069 :                fnEstablishViewForInstance( lpSpawnView, 0, lpLinkedInstance );
; 4070 :          if ( lpParentViewEntity != lpRecursViewEntity )

	mov	ecx, DWORD PTR _lpParentViewEntity$13[ebp]
	cmp	ecx, DWORD PTR _lpRecursViewEntity$7[ebp]
	je	SHORT $LN31@fnSpawnCre

; 4071 :          {
; 4072 :             fnSetViewToSubobject( lpSpawnView,

	mov	edx, DWORD PTR _lpSearchViewEntityCsr$9[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRecursViewEntity$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSpawnView$8[ebp]
	push	ecx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
$LN11@fnSpawnCre:

; 4073 :                                   lpRecursViewEntity,
; 4074 :                                   lpSearchViewEntityCsr );
; 4075 :             while ( zGETPTR( lpSearchViewEntityCsr->hViewEntity ) != lpParentViewEntity )

	mov	edx, DWORD PTR _lpSearchViewEntityCsr$9[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpParentViewEntity$13[ebp]
	je	SHORT $LN31@fnSpawnCre

; 4076 :             {
; 4077 :                lpSearchViewEntityCsr = zGETPTR( lpSearchViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$9[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntityCsr$9[ebp], eax

; 4078 :             }

	jmp	SHORT $LN11@fnSpawnCre
$LN31@fnSpawnCre:

; 4079 :          }
; 4080 : 
; 4081 :          // Now that the cursors are established up the parent chain, create a
; 4082 :          // cursor for the twin of the current instance under the linked parent.
; 4083 :          // First, find the view cursor for the target of the spawned create.
; 4084 :          lpWorkViewEntityCsr = zGETPTR( lpSearchViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$9[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$11[ebp], eax
$LN13@fnSpawnCre:

; 4085 :          while ( zGETPTR( lpWorkViewEntityCsr->hViewEntity ) !=

	mov	edx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSearchViewEntity$12[ebp]
	je	SHORT $LN14@fnSpawnCre

; 4086 :                                                          lpSearchViewEntity )
; 4087 :          {
; 4088 :             lpWorkViewEntityCsr = zGETPTR( lpWorkViewEntityCsr->hNextHier );

	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$11[ebp], eax

; 4089 :          }

	jmp	SHORT $LN13@fnSpawnCre
$LN14@fnSpawnCre:

; 4090 : 
; 4091 :          nSpawnPosition = zPOS_AFTER;

	mov	eax, 3
	mov	WORD PTR _nSpawnPosition$15[ebp], ax

; 4092 :          if ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	$LN32@fnSpawnCre

; 4093 :          {
; 4094 :             LPENTITYINSTANCE lpNextTwin;
; 4095 : 
; 4096 :             lpNextTwin   = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTwin$4[ebp], eax

; 4097 :             lpLinkedTwin = zGETPTR( lpNextTwin->hNextLinked );

	mov	ecx, DWORD PTR _lpNextTwin$4[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedTwin$14[ebp], eax
$LN15@fnSpawnCre:

; 4098 :             while ( lpLinkedTwin )

	cmp	DWORD PTR _lpLinkedTwin$14[ebp], 0
	je	SHORT $LN16@fnSpawnCre

; 4099 :             {
; 4100 :                if ( zGETPTR( lpLinkedTwin->hParent ) == lpLinkedInstance )

	mov	eax, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpLinkedInstance$[ebp]
	jne	SHORT $LN34@fnSpawnCre

; 4101 :                   break;

	jmp	SHORT $LN16@fnSpawnCre
$LN34@fnSpawnCre:

; 4102 : 
; 4103 :                if ( lpLinkedTwin->hNextLinked == lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+42]
	cmp	ecx, DWORD PTR [eax+22]
	jne	SHORT $LN35@fnSpawnCre

; 4104 :                {
; 4105 :                   lpLinkedTwin = 0;

	mov	DWORD PTR _lpLinkedTwin$14[ebp], 0

; 4106 :                   break;

	jmp	SHORT $LN16@fnSpawnCre
$LN35@fnSpawnCre:

; 4107 :                }
; 4108 : 
; 4109 :                lpLinkedTwin = zGETPTR( lpLinkedTwin->hNextLinked );

	mov	edx, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedTwin$14[ebp], eax

; 4110 :             }

	jmp	SHORT $LN15@fnSpawnCre
$LN16@fnSpawnCre:

; 4111 : 
; 4112 :             if ( lpLinkedTwin )

	cmp	DWORD PTR _lpLinkedTwin$14[ebp], 0
	je	SHORT $LN36@fnSpawnCre

; 4113 :             {
; 4114 :                lpWorkViewEntityCsr->hEntityInstance = zGETHNDL( lpLinkedTwin );

	mov	ecx, DWORD PTR _lpLinkedTwin$14[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	mov	DWORD PTR [edx+26], eax

; 4115 :             // if ( lpWorkViewEntityCsr->hEntityInstance == UNSET_CSR )
; 4116 :             //    SysMessageBox( 0, "fnSpawnCreateEntity", "UNSET_CSR", -1 );
; 4117 : 
; 4118 :                nSpawnPosition = zPOS_BEFORE;

	mov	eax, 4
	mov	WORD PTR _nSpawnPosition$15[ebp], ax
$LN36@fnSpawnCre:

; 4119 :             }
; 4120 :          }

	jmp	$LN33@fnSpawnCre
$LN32@fnSpawnCre:

; 4121 :          else
; 4122 :          if ( lpEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN33@fnSpawnCre

; 4123 :          {
; 4124 :             LPENTITYINSTANCE lpPrevTwin;
; 4125 : 
; 4126 :             lpPrevTwin   = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTwin$3[ebp], eax

; 4127 :             lpLinkedTwin = zGETPTR( lpPrevTwin->hNextLinked );

	mov	ecx, DWORD PTR _lpPrevTwin$3[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedTwin$14[ebp], eax
$LN17@fnSpawnCre:

; 4128 :             while ( lpLinkedTwin )

	cmp	DWORD PTR _lpLinkedTwin$14[ebp], 0
	je	SHORT $LN18@fnSpawnCre

; 4129 :             {
; 4130 :                if ( zGETPTR( lpLinkedTwin->hParent ) == lpLinkedInstance )

	mov	eax, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpLinkedInstance$[ebp]
	jne	SHORT $LN38@fnSpawnCre

; 4131 :                   break;

	jmp	SHORT $LN18@fnSpawnCre
$LN38@fnSpawnCre:

; 4132 : 
; 4133 :                if ( lpLinkedTwin->hNextLinked == lpEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+42]
	cmp	ecx, DWORD PTR [eax+26]
	jne	SHORT $LN39@fnSpawnCre

; 4134 :                {
; 4135 :                   lpLinkedTwin = 0;

	mov	DWORD PTR _lpLinkedTwin$14[ebp], 0

; 4136 :                   break;

	jmp	SHORT $LN18@fnSpawnCre
$LN39@fnSpawnCre:

; 4137 :                }
; 4138 : 
; 4139 :                lpLinkedTwin = zGETPTR( lpLinkedTwin->hNextLinked );

	mov	edx, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedTwin$14[ebp], eax

; 4140 :             }

	jmp	SHORT $LN17@fnSpawnCre
$LN18@fnSpawnCre:

; 4141 : 
; 4142 :             if ( lpLinkedTwin )

	cmp	DWORD PTR _lpLinkedTwin$14[ebp], 0
	je	SHORT $LN33@fnSpawnCre

; 4143 :             {
; 4144 :                lpWorkViewEntityCsr->hEntityInstance = zGETHNDL( lpLinkedTwin );

	mov	ecx, DWORD PTR _lpLinkedTwin$14[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	mov	DWORD PTR [edx+26], eax
$LN33@fnSpawnCre:

; 4145 :             // if ( lpWorkViewEntityCsr->hEntityInstance == UNSET_CSR )
; 4146 :             //    SysMessageBox( 0, "fnSpawnCreateEntity2", "UNSET_CSR", -1 );
; 4147 :             }
; 4148 :          }
; 4149 : 
; 4150 :          // For now, we do not support creation spawning in recursive levels of
; 4151 :          // the object instance.  So if the level does not match, issue an error
; 4152 :          // and get out.  NOTE, this should not happen if fnEstablishViewForInstance
; 4153 :          // is called above.  It removes the recursive spawning restriction!!
; 4154 :          if ( lpSearchViewEntityCsr->nLevel != lpLinkedInstance->nLevel )

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$9[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpLinkedInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	je	SHORT $LN41@fnSpawnCre

; 4155 :          {
; 4156 :             LPTASK lpTask = zGETPTR( lpSpawnView->hTask );

	mov	ecx, DWORD PTR _lpSpawnView$8[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 4157 :             // "KZOEE139 - Error establishing cursor for "
; 4158 :             // "CreateEntity spawn"
; 4159 :             fnIssueCoreError( lpTask, lpView, 8, 139, 0,

	push	0
	mov	eax, DWORD PTR _lpSearchViewEntity$12[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	139					; 0000008bH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4160 :                               lpSearchViewEntity->szName, 0 );
; 4161 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 4162 :          }

	jmp	$LN42@fnSpawnCre
$LN41@fnSpawnCre:

; 4163 :          else
; 4164 :          {
; 4165 :             // We've established the cursors in the spawn view for spawning
; 4166 :             // the create, now call fnCreateEntity to spawn the create.
; 4167 :             nRC = fnCreateEntity( lpSpawnView,

	push	0
	movzx	ecx, WORD PTR _nSpawnPosition$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpSpawnView$8[ebp]
	push	edx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 4168 :                                   zGETPTR( lpWorkViewEntityCsr->hViewEntity ),
; 4169 :                                   lpWorkViewEntityCsr, nSpawnPosition, 0 );
; 4170 :             if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN43@fnSpawnCre

; 4171 :             {
; 4172 :                LPENTITYINSTANCE lpWorkInstance;
; 4173 : 
; 4174 :                lpSpawnedInstance = zGETPTR( lpWorkViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSpawnedInstance$10[ebp], eax

; 4175 :                lpSpawnedInstance->u.nInd.bCreated = TRUE;

	mov	eax, DWORD PTR _lpSpawnedInstance$10[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _lpSpawnedInstance$10[ebp]
	mov	DWORD PTR [edx+6], ecx

; 4176 :                lpSpawnedInstance->hNextLinked = zGETHNDL( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSpawnedInstance$10[ebp]
	mov	DWORD PTR [ecx+42], eax

; 4177 :                if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN44@fnSpawnCre

; 4178 :                {
; 4179 :                   lpLinkedTwin = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedTwin$14[ebp], eax
$LN19@fnSpawnCre:

; 4180 :                   while ( zGETPTR( lpLinkedTwin->hNextLinked ) != lpEntityInstance )

	mov	edx, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN20@fnSpawnCre

; 4181 :                   {
; 4182 :                      lpLinkedTwin = zGETPTR( lpLinkedTwin->hNextLinked );

	mov	ecx, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedTwin$14[ebp], eax

; 4183 :                   }

	jmp	SHORT $LN19@fnSpawnCre
$LN20@fnSpawnCre:

; 4184 : 
; 4185 :                   lpLinkedTwin->hNextLinked = zGETHNDL( lpSpawnedInstance );

	mov	eax, DWORD PTR _lpSpawnedInstance$10[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpLinkedTwin$14[ebp]
	mov	DWORD PTR [ecx+42], eax

; 4186 :                }

	jmp	SHORT $LN45@fnSpawnCre
$LN44@fnSpawnCre:

; 4187 :                else
; 4188 :                   lpEntityInstance->hNextLinked = zGETHNDL( lpSpawnedInstance );

	mov	edx, DWORD PTR _lpSpawnedInstance$10[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$LN45@fnSpawnCre:

; 4189 : 
; 4190 :                // Set the record pointer in the spawned instance.
; 4191 :                lpWorkInstance = zGETPTR( lpSpawnedInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSpawnedInstance$10[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance$1[ebp], eax

; 4192 :                lpSpawnedInstance->hPersistRecord = lpWorkInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpSpawnedInstance$10[ebp]
	mov	edx, DWORD PTR _lpWorkInstance$1[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax
$LN43@fnSpawnCre:

; 4193 :             }
; 4194 : 
; 4195 :             DropView( lpSpawnView );

	mov	ecx, DWORD PTR _lpSpawnView$8[ebp]
	push	ecx
	call	_DropView@4
$LN42@fnSpawnCre:

; 4196 :          }
; 4197 : 
; 4198 :       } // for ( lpSearchViewEntity )...

	jmp	$LN8@fnSpawnCre
$LN9@fnSpawnCre:

; 4199 : 
; 4200 :    }  // for ( lpLinkedInstance )...

	jmp	$LN2@fnSpawnCre
$LN3@fnSpawnCre:

; 4201 : 
; 4202 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSpawnCre:

; 4203 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSpawnCreateEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpParent$1 = -36					; size = 4
_lpViewEntity$ = -32					; size = 4
_lpLinkedViewEntity$2 = -28				; size = 4
_lpLinkedParent$ = -24					; size = 4
_lpWrkViewEntity$ = -20					; size = 4
_hLinkedParent$3 = -16					; size = 4
_lpWrkInstance$ = -12					; size = 4
_lpLinkedInstance$ = -8					; size = 4
_bInvertedFound$ = -1					; size = 1
_lpEntityInstance$ = 8					; size = 4
_fnExcludeEntityInstance PROC

; 3864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3865 :    zBOOL             bInvertedFound;
; 3866 :    LPVIEWENTITY      lpViewEntity;
; 3867 :    LPVIEWENTITY      lpWrkViewEntity;
; 3868 :    LPENTITYINSTANCE  lpLinkedInstance;
; 3869 :    LPENTITYINSTANCE  lpLinkedParent;
; 3870 :    LPENTITYINSTANCE  lpWrkInstance;
; 3871 : 
; 3872 : 
; 3873 :    // Init inversion flag
; 3874 :    bInvertedFound = 0;

	mov	BYTE PTR _bInvertedFound$[ebp], 0

; 3875 : 
; 3876 :    // Get entity instance at which to start the exclude and mark the
; 3877 :    // Entity instance as excluded. Then go through and mark the entity
; 3878 :    // instance and all of its subordinates as hidden
; 3879 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 3880 : 
; 3881 :    if ( lpEntityInstance->hParent == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	jne	SHORT $LN10@fnExcludeE

; 3882 :       return( bInvertedFound );

	mov	al, BYTE PTR _bInvertedFound$[ebp]
	jmp	$LN1@fnExcludeE
$LN10@fnExcludeE:

; 3883 : 
; 3884 :    lpEntityInstance->u.nInd.bExcluded = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 3885 : 
; 3886 :    // Now that the simple exclusion is done, go through all linked
; 3887 :    // instances and mark all linked instances as excluded which represent
; 3888 :    // the same relationship to the same parent.
; 3889 :    lpLinkedInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedInstance$[ebp], eax

; 3890 :    if ( lpLinkedInstance == 0 )

	cmp	DWORD PTR _lpLinkedInstance$[ebp], 0
	jne	SHORT $LN2@fnExcludeE

; 3891 :       return( bInvertedFound );

	mov	al, BYTE PTR _bInvertedFound$[ebp]
	jmp	$LN1@fnExcludeE
$LN2@fnExcludeE:

; 3892 : 
; 3893 :    while ( lpLinkedInstance != lpEntityInstance )

	mov	edx, DWORD PTR _lpLinkedInstance$[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	je	$LN3@fnExcludeE

; 3894 :    {
; 3895 :       LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpLinkedInstance->hViewEntity );

	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$2[ebp], eax

; 3896 : 
; 3897 :       // We have a linked instance, for each instance see if the
; 3898 :       // corresponding view entity represents the same relationship
; 3899 :       // to the same parent instance OR has an inversion of the
; 3900 :       // same relationship to the same parent instance.
; 3901 :       // First, see if the instance is marked as deleted from
; 3902 :       // a delete entity call
; 3903 :       if ( lpLinkedViewEntity->lERRelTok == lpViewEntity->lERRelTok &&

	mov	edx, DWORD PTR _lpLinkedViewEntity$2[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	jne	SHORT $LN12@fnExcludeE
	mov	edx, DWORD PTR _lpLinkedInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $LN12@fnExcludeE

; 3904 :            lpLinkedInstance->hParent )
; 3905 :       {
; 3906 :          LPENTITYINSTANCE hLinkedParent;
; 3907 : 
; 3908 :          // The linked instance represents the same relationship ...
; 3909 :          // see if its parent is a linked instance to the current parent.
; 3910 :          lpLinkedParent = zGETPTR( lpLinkedInstance->hParent );

	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedParent$[ebp], eax

; 3911 :          hLinkedParent  = lpLinkedParent->hNextLinked;

	mov	edx, DWORD PTR _lpLinkedParent$[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR _hLinkedParent$3[ebp], eax

; 3912 : 
; 3913 :          if ( hLinkedParent )

	cmp	DWORD PTR _hLinkedParent$3[ebp], 0
	je	SHORT $LN13@fnExcludeE
$LN4@fnExcludeE:

; 3914 :          {
; 3915 :             while ( hLinkedParent != lpEntityInstance->hParent &&

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _hLinkedParent$3[ebp]
	cmp	edx, DWORD PTR [ecx+30]
	je	SHORT $LN13@fnExcludeE
	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	mov	ecx, DWORD PTR _hLinkedParent$3[ebp]
	cmp	ecx, DWORD PTR [eax+30]
	je	SHORT $LN13@fnExcludeE

; 3916 :                     hLinkedParent != lpLinkedInstance->hParent )
; 3917 :             {
; 3918 :                lpLinkedParent = zGETPTR( hLinkedParent );

	mov	edx, DWORD PTR _hLinkedParent$3[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedParent$[ebp], eax

; 3919 :                hLinkedParent  = lpLinkedParent->hNextLinked;

	mov	eax, DWORD PTR _lpLinkedParent$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR _hLinkedParent$3[ebp], ecx

; 3920 :             }

	jmp	SHORT $LN4@fnExcludeE
$LN13@fnExcludeE:

; 3921 :          }
; 3922 : 
; 3923 :          if ( hLinkedParent == lpEntityInstance->hParent )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _hLinkedParent$3[ebp]
	cmp	eax, DWORD PTR [edx+30]
	jne	SHORT $LN12@fnExcludeE

; 3924 :             lpLinkedInstance->u.nInd.bExcluded = TRUE;

	mov	ecx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN12@fnExcludeE:

; 3925 :       }
; 3926 : 
; 3927 :       // See if the structure is inverted for a linked instance
; 3928 :       lpWrkViewEntity = zGETPTR( lpLinkedViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpLinkedViewEntity$2[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity$[ebp], eax
$LN6@fnExcludeE:

; 3929 :       while ( lpWrkViewEntity &&

	cmp	DWORD PTR _lpWrkViewEntity$[ebp], 0
	je	$LN7@fnExcludeE
	mov	eax, DWORD PTR _lpWrkViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpLinkedViewEntity$2[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jle	$LN7@fnExcludeE

; 3930 :               lpWrkViewEntity->nLevel > lpLinkedViewEntity->nLevel )
; 3931 :       {
; 3932 :          LPENTITYINSTANCE lpParent;
; 3933 : 
; 3934 :          if ( lpWrkViewEntity->hParent == lpLinkedInstance->hViewEntity &&

	mov	ecx, DWORD PTR _lpWrkViewEntity$[ebp]
	mov	edx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	eax, DWORD PTR [ecx+10]
	cmp	eax, DWORD PTR [edx+2]
	jne	SHORT $LN15@fnExcludeE
	mov	ecx, DWORD PTR _lpWrkViewEntity$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+199]
	cmp	eax, DWORD PTR [edx+199]
	jne	SHORT $LN15@fnExcludeE

; 3935 :               lpWrkViewEntity->lERRelTok == lpViewEntity->lERRelTok )
; 3936 :          {
; 3937 :             // We've found an inverted structure in the linked entity
; 3938 :             // instance, now go and mark the child entity instance
; 3939 :             // which is linked to the source entity instances parent
; 3940 :             // as excluded.
; 3941 :             lpParent      = zGETPTR( lpEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$1[ebp], eax

; 3942 :             lpWrkInstance = zGETPTR( lpParent->hNextLinked );

	mov	eax, DWORD PTR _lpParent$1[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN8@fnExcludeE:

; 3943 :             while (  lpWrkInstance && lpWrkInstance != lpParent )

	cmp	DWORD PTR _lpWrkInstance$[ebp], 0
	je	SHORT $LN15@fnExcludeE
	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	edx, DWORD PTR _lpParent$1[ebp]
	je	SHORT $LN15@fnExcludeE

; 3944 :             {
; 3945 :                if ( zGETPTR( lpWrkInstance->hParent ) == lpLinkedInstance )

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpLinkedInstance$[ebp]
	jne	SHORT $LN16@fnExcludeE

; 3946 :                {
; 3947 :                   lpWrkInstance->u.nInd.bExcluded = TRUE;

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 3948 :                   bInvertedFound = TRUE;

	mov	BYTE PTR _bInvertedFound$[ebp], 1
$LN16@fnExcludeE:

; 3949 :                }
; 3950 : 
; 3951 :                lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 3952 :             }

	jmp	SHORT $LN8@fnExcludeE
$LN15@fnExcludeE:

; 3953 :          }
; 3954 : 
; 3955 :          lpWrkViewEntity = zGETPTR( lpWrkViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpWrkViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity$[ebp], eax

; 3956 :       }

	jmp	$LN6@fnExcludeE
$LN7@fnExcludeE:

; 3957 : 
; 3958 :       lpLinkedInstance = zGETPTR( lpLinkedInstance->hNextLinked );

	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedInstance$[ebp], eax

; 3959 : 
; 3960 :    } // while...

	jmp	$LN2@fnExcludeE
$LN3@fnExcludeE:

; 3961 : 
; 3962 :    // Whew, I think we've done it, return to caller.
; 3963 :    return( bInvertedFound );

	mov	al, BYTE PTR _bInvertedFound$[ebp]
$LN1@fnExcludeE:

; 3964 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnExcludeEntityInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpTask$1 = -72						; size = 4
_lpTask$2 = -68						; size = 4
_lpTask$3 = -64						; size = 4
_lpTask$4 = -60						; size = 4
_lpTask$5 = -56						; size = 4
_lpRootViewEntityCsr$ = -52				; size = 4
_lpTask$6 = -48						; size = 4
_lpViewOI$ = -44					; size = 4
_lpTask$7 = -40						; size = 4
_lpTask$8 = -36						; size = 4
_lpParent$9 = -32					; size = 4
_lpRootViewEntityInstance$ = -28			; size = 4
_lpViewCsr$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_nID$10 = -4						; size = 2
_plpReturnTask$ = 8					; size = 4
_ppvReturnViewEntity$ = 12				; size = 4
_ppvReturnViewEntityCsr$ = 16				; size = 4
_iOperationID$ = 20					; size = 2
_lpView$ = 24						; size = 4
_cpcEntityName$ = 28					; size = 4
_nFlags$ = 32						; size = 2
_fnValidateInstanceParameters PROC

; 3447 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 3448 :    LPTASK            lpCurrentTask;
; 3449 :    LPVIEWOI          lpViewOI;
; 3450 :    LPVIEWCSR         lpViewCsr;
; 3451 :    LPVIEWENTITY      lpViewEntity;
; 3452 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 3453 :    LPVIEWENTITYCSR   lpRootViewEntityCsr;
; 3454 :    LPENTITYINSTANCE  lpRootViewEntityInstance;
; 3455 :    LPENTITYINSTANCE  lpEntityInstance;
; 3456 : 
; 3457 :    if ( nFlags & 2 )

	movsx	eax, WORD PTR _nFlags$[ebp]
	and	eax, 2
	je	SHORT $LN8@fnValidate

; 3458 :    {
; 3459 :       lpCurrentTask = *plpReturnTask;

	mov	ecx, DWORD PTR _plpReturnTask$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpCurrentTask$[ebp], edx

; 3460 : 
; 3461 :       // Validate that the view passed is valid.
; 3462 :       if ( fnValidViewCsr( lpCurrentTask, lpView ) == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN10@fnValidate

; 3463 :       {
; 3464 :          fnOperationReturn( iOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _iOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8

; 3465 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN10@fnValidate:

; 3466 :       }
; 3467 :    }

	jmp	SHORT $LN9@fnValidate
$LN8@fnValidate:

; 3468 :    else
; 3469 :    {
; 3470 :       // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 3471 :       if ( (lpCurrentTask = fnOperationCall( iOperationID, lpView,
; 3472 :                                              zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	movzx	eax, WORD PTR _iOperationID$[ebp]
	push	eax
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN11@fnValidate

; 3473 :       {
; 3474 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN11@fnValidate:

; 3475 :       }
; 3476 : 
; 3477 :       *plpReturnTask = lpCurrentTask;

	mov	ecx, DWORD PTR _plpReturnTask$[ebp]
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [ecx], edx
$LN9@fnValidate:

; 3478 :    }
; 3479 : 
; 3480 :    // Get the view Object Instance for the view
; 3481 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3482 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 3483 : 
; 3484 :    // Validate that the entity exists
; 3485 :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView,
; 3486 :                                            cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN12@fnValidate

; 3487 :    {
; 3488 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8

; 3489 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN12@fnValidate:

; 3490 :    }
; 3491 : 
; 3492 :    // Set View Entity and View Entity Cursor for caller.
; 3493 :    *ppvReturnViewEntity    = lpViewEntity;

	mov	eax, DWORD PTR _ppvReturnViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax], ecx

; 3494 :    *ppvReturnViewEntityCsr = lpViewEntityCsr;

	mov	edx, DWORD PTR _ppvReturnViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx], eax

; 3495 : 
; 3496 :    // If intent is update, fail the call
; 3497 :    if ( lpView->bReadOnly && (nFlags & 1) &&

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 6
	and	edx, 1
	je	$LN13@fnValidate
	movsx	eax, WORD PTR _nFlags$[ebp]
	and	eax, 1
	je	$LN13@fnValidate
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	SHORT $LN13@fnValidate

; 3498 :         lpViewEntity->bDerivedPath == FALSE )
; 3499 :    {
; 3500 :       // Special case, we will allow exclusion and inclusion of a root in a
; 3501 :       // read only view since the incremental update behavior of
; 3502 :       // excluding and including at the root level is null.
; 3503 :       if ( lpViewEntity->hParent ||

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN15@fnValidate
	movsx	ecx, WORD PTR _iOperationID$[ebp]
	cmp	ecx, 105				; 00000069H
	je	SHORT $LN13@fnValidate
	movsx	edx, WORD PTR _iOperationID$[ebp]
	cmp	edx, 107				; 0000006bH
	je	SHORT $LN13@fnValidate
$LN15@fnValidate:

; 3504 :            (iOperationID != iIncludeSubobjectFromSubobject &&
; 3505 :             iOperationID != iExcludeEntity) )
; 3506 :       {
; 3507 :          if ( (nFlags & 0x8000) == 0 )

	movsx	eax, WORD PTR _nFlags$[ebp]
	and	eax, 32768				; 00008000H
	jne	SHORT $LN16@fnValidate

; 3508 :          {
; 3509 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$7[ebp], eax

; 3510 :             // "KZOEE119 - Invalid View, View is Read Only"
; 3511 :             fnIssueCoreError( lpTask, lpView, 8, 119, 0, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	0
	push	119					; 00000077H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$7[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3512 :          }

	jmp	SHORT $LN17@fnValidate
$LN16@fnValidate:

; 3513 :          else
; 3514 :          {
; 3515 :             TraceLineS( "KZOEE119 - Invalid View, View is Read Only for Entity: ",

	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	OFFSET $SG14482
	call	_TraceLineS@8
$LN17@fnValidate:

; 3516 :                         cpcEntityName );
; 3517 :          }
; 3518 : 
; 3519 :          fnOperationReturn( iOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8

; 3520 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN13@fnValidate:

; 3521 :       }
; 3522 :    }
; 3523 : 
; 3524 :    lpRootViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$[ebp], eax

; 3525 :    // if Object instance is empty, issue an error
; 3526 :    if ( lpViewOI->hRootEntityInstance == 0 &&
; 3527 :         iOperationID != iCountEntitiesForView &&

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+26], 0
	jne	SHORT $LN18@fnValidate
	movsx	eax, WORD PTR _iOperationID$[ebp]
	cmp	eax, 123				; 0000007bH
	je	SHORT $LN18@fnValidate
	movsx	ecx, WORD PTR _iOperationID$[ebp]
	cmp	ecx, 121				; 00000079H
	je	SHORT $LN18@fnValidate

; 3528 :         iOperationID != iRelinkAllSubobjectsForOI )
; 3529 :    {
; 3530 :       if ( (nFlags & 0x8000) == 0 )

	movsx	edx, WORD PTR _nFlags$[ebp]
	and	edx, 32768				; 00008000H
	jne	SHORT $LN19@fnValidate

; 3531 :       {
; 3532 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$6[ebp], eax

; 3533 :          //  "KZOEE253 - Entity cursor is NULL"
; 3534 :          fnIssueCoreError( lpTask, lpView, 8, 253, 0,

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	253					; 000000fdH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$6[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3535 :                            lpViewEntity->szName, 0 );
; 3536 :       }

	jmp	SHORT $LN20@fnValidate
$LN19@fnValidate:

; 3537 :       else
; 3538 :       {
; 3539 :          TraceLineS( "KZOEE253 - Entity cursor is NULL for Entity: ",

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG14486
	call	_TraceLineS@8
$LN20@fnValidate:

; 3540 :                      lpViewEntity->szName );
; 3541 :       }
; 3542 : 
; 3543 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _iOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8

; 3544 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN18@fnValidate:

; 3545 :    }
; 3546 : 
; 3547 :    // If the root entity of the Object instance has been deleted,
; 3548 :    // issue an error.
; 3549 :    lpRootViewEntityInstance = zGETPTR( lpRootViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpRootViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityInstance$[ebp], eax

; 3550 :    if ( lpRootViewEntityInstance &&

	cmp	DWORD PTR _lpRootViewEntityInstance$[ebp], 0
	je	SHORT $LN21@fnValidate
	mov	ecx, DWORD PTR _lpRootViewEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN21@fnValidate

; 3551 :         lpRootViewEntityInstance->u.nInd.bHidden )
; 3552 :    {
; 3553 :       if ( (nFlags & 0x8000) == 0 )

	movsx	eax, WORD PTR _nFlags$[ebp]
	and	eax, 32768				; 00008000H
	jne	SHORT $LN22@fnValidate

; 3554 :       {
; 3555 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$5[ebp], eax

; 3556 :          //  "KZOEE252 - Root of view has been deleted"
; 3557 :          fnIssueCoreError( lpTask, lpView, 8, 252, 0,

	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	252					; 000000fcH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$5[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3558 :                            fnEntityNameFromCsr( lpViewEntityCsr ), 0 );
; 3559 :       }

	jmp	SHORT $LN23@fnValidate
$LN22@fnValidate:

; 3560 :       else
; 3561 :       {
; 3562 :          TraceLineS( "KZOEE252 - Root of view has been deleted for Entity: ",

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	OFFSET $SG14490
	call	_TraceLineS@8
$LN23@fnValidate:

; 3563 :                      fnEntityNameFromCsr( lpViewEntityCsr ) );
; 3564 :       }
; 3565 : 
; 3566 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8

; 3567 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN21@fnValidate:

; 3568 :    }
; 3569 : 
; 3570 :    // If this is a relink all call, skip entity instance stuff.
; 3571 :    if ( iOperationID == iRelinkAllSubobjectsForOI )

	movsx	eax, WORD PTR _iOperationID$[ebp]
	cmp	eax, 121				; 00000079H
	jne	SHORT $LN24@fnValidate

; 3572 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnValidate
$LN24@fnValidate:

; 3573 : 
; 3574 :    // Get Entity Instance pointer.
; 3575 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 3576 : 
; 3577 :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN25@fnValidate

; 3578 :       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN25@fnValidate:

; 3579 : 
; 3580 :    // If this is a count of the entities, exit now.
; 3581 :    if ( iOperationID == iCountEntitiesForView )

	movsx	ecx, WORD PTR _iOperationID$[ebp]
	cmp	ecx, 123				; 0000007bH
	jne	SHORT $LN26@fnValidate

; 3582 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnValidate
$LN26@fnValidate:

; 3583 : 
; 3584 :    // Now make sure a cursor exists for the view entity
; 3585 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN27@fnValidate

; 3586 :    {
; 3587 :       if ( (nFlags & 0x8000) == 0 )

	movsx	edx, WORD PTR _nFlags$[ebp]
	and	edx, 32768				; 00008000H
	jne	SHORT $LN28@fnValidate

; 3588 :       {
; 3589 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$4[ebp], eax

; 3590 :          //  "KZOEE253 - Entity cursor is NULL"
; 3591 :          fnIssueCoreError( lpTask, lpView, 8, 253, 0,

	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	253					; 000000fdH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$4[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3592 :                            fnEntityNameFromCsr( lpViewEntityCsr ), 0 );
; 3593 :       }

	jmp	SHORT $LN29@fnValidate
$LN28@fnValidate:

; 3594 :       else
; 3595 :       {
; 3596 :          TraceLineS( "KZOEE253 - Entity cursor is NULL for Entity: ",

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	OFFSET $SG14497
	call	_TraceLineS@8
$LN29@fnValidate:

; 3597 :                      fnEntityNameFromCsr( lpViewEntityCsr ) );
; 3598 :       }
; 3599 : 
; 3600 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _iOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8

; 3601 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN27@fnValidate:

; 3602 :    }
; 3603 : 
; 3604 :    if ( lpEntityInstance->nTableID != iEntityInstance )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10024				; 00002728H
	je	SHORT $LN30@fnValidate

; 3605 :    {
; 3606 :       TraceLineX( "(DGC) View   Cursor   = ", (zLONG) lpViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	push	OFFSET $SG14499
	call	_TraceLineX@8

; 3607 :       TraceLineX( "(DGC) Entity Cursor   = ", (zLONG) lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	push	OFFSET $SG14500
	call	_TraceLineX@8

; 3608 :       TraceLineX( "(DGC) Entity Instance = ", (zLONG) lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	OFFSET $SG14501
	call	_TraceLineX@8

; 3609 :       SysMessageBox( lpView, "DGC", "Invalid Table ID for entity instance", 1 );

	push	1
	push	OFFSET $SG14502
	push	OFFSET $SG14503
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 3610 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	movzx	eax, WORD PTR _iOperationID$[ebp]
	push	eax
	call	_fnOperationReturn
	add	esp, 8

; 3611 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN30@fnValidate:

; 3612 :    }
; 3613 : 
; 3614 :    if ( lpEntityInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	$LN31@fnValidate

; 3615 :    {
; 3616 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 3617 :       zSHORT nID;
; 3618 : 
; 3619 :       nID = 254;   // initialize error to: Entity cursor is undefined

	mov	edx, 254				; 000000feH
	mov	WORD PTR _nID$10[ebp], dx
$LN2@fnValidate:

; 3620 : 
; 3621 :       // The error in question is undefined UNLESS ALL of the
; 3622 :       // entity instances of the highest hidden parent are also hidden.
; 3623 :       while ( lpEntityInstance->hParent )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN4@fnValidate

; 3624 :       {
; 3625 :          LPENTITYINSTANCE lpParent = zGETPTR( lpEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$9[ebp], eax

; 3626 : 
; 3627 :          if ( lpParent->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpParent$9[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN33@fnValidate

; 3628 :             break;

	jmp	SHORT $LN4@fnValidate
$LN33@fnValidate:

; 3629 : 
; 3630 :          lpEntityInstance = lpParent;

	mov	edx, DWORD PTR _lpParent$9[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx

; 3631 :       }

	jmp	SHORT $LN2@fnValidate
$LN4@fnValidate:

; 3632 : 
; 3633 :       while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN6@fnValidate

; 3634 :          lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnValidate
$LN6@fnValidate:

; 3635 : 
; 3636 :       while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN7@fnValidate

; 3637 :       {
; 3638 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN34@fnValidate

; 3639 :             break;

	jmp	SHORT $LN7@fnValidate
$LN34@fnValidate:

; 3640 : 
; 3641 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 3642 :       }

	jmp	SHORT $LN6@fnValidate
$LN7@fnValidate:

; 3643 : 
; 3644 :       // If no potentially visible entity instances were found, issue
; 3645 :       // the entity instance is NULL error.
; 3646 :       if ( (nFlags & 0x8000) == 0 )

	movsx	ecx, WORD PTR _nFlags$[ebp]
	and	ecx, 32768				; 00008000H
	jne	SHORT $LN35@fnValidate

; 3647 :       {
; 3648 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8[ebp], eax

; 3649 :          if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN37@fnValidate

; 3650 :          {
; 3651 :             //  "KZOEE253 - Entity cursor is NULL"
; 3652 :             fnIssueCoreError( lpTask, lpView, 8, 253, 0,

	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	253					; 000000fdH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$8[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3653 :                               fnEntityNameFromCsr( lpViewEntityCsr ), 0 );
; 3654 :          }

	jmp	SHORT $LN38@fnValidate
$LN37@fnValidate:

; 3655 :          else
; 3656 :          {
; 3657 :             //  "KZOEE254 - Entity cursor is undefined"
; 3658 :             fnIssueCoreError( lpTask, lpView, 8, 254, 0,

	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	254					; 000000feH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$8[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN38@fnValidate:

; 3659 :                               fnEntityNameFromCsr( lpViewEntityCsr ), 0 );
; 3660 :          }
; 3661 :       }

	jmp	SHORT $LN36@fnValidate
$LN35@fnValidate:

; 3662 :       else
; 3663 :       {
; 3664 :          if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN39@fnValidate

; 3665 :          {
; 3666 :             TraceLineS( "KZOEE253 - Entity cursor is NULL for Entity: ",

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	OFFSET $SG14514
	call	_TraceLineS@8

; 3667 :                         fnEntityNameFromCsr( lpViewEntityCsr ) );
; 3668 :          }

	jmp	SHORT $LN36@fnValidate
$LN39@fnValidate:

; 3669 :          else
; 3670 :          {
; 3671 :             TraceLineS( "KZOEE254 - Entity cursor is undefined for Entity: ",

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	OFFSET $SG14515
	call	_TraceLineS@8
$LN36@fnValidate:

; 3672 :                         fnEntityNameFromCsr( lpViewEntityCsr ) );
; 3673 :          }
; 3674 :       }
; 3675 : 
; 3676 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _iOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8

; 3677 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate

; 3678 :    }

	jmp	$LN32@fnValidate
$LN31@fnValidate:

; 3679 :    else
; 3680 :    if ( lpEntityInstance->u.nInd.bPrevVersion && lpEntityInstance->hNextVsn )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 8
	and	eax, 1
	je	SHORT $LN32@fnValidate
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+34], 0
	je	SHORT $LN32@fnValidate

; 3681 :    {
; 3682 :       if ( (nFlags & 0x8000) == 0 )

	movsx	edx, WORD PTR _nFlags$[ebp]
	and	edx, 32768				; 00008000H
	jne	SHORT $LN42@fnValidate

; 3683 :       {
; 3684 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 3685 :          //  "KZOEE255 - Attempt to update a previous entity version"
; 3686 :          fnIssueCoreError( lpTask, lpView, 8, 255, 0,

	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	255					; 000000ffH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$3[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3687 :                            fnEntityNameFromCsr( lpViewEntityCsr ), 0 );
; 3688 :       }

	jmp	SHORT $LN43@fnValidate
$LN42@fnValidate:

; 3689 :       else
; 3690 :       {
; 3691 :          TraceLineS( "KZOEE255 - Attempt to update a previous entity version for Entity: ",

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	OFFSET $SG14519
	call	_TraceLineS@8
$LN43@fnValidate:

; 3692 :                      fnEntityNameFromCsr( lpViewEntityCsr ) );
; 3693 :       }
; 3694 : 
; 3695 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _iOperationID$[ebp]
	push	ecx
	call	_fnOperationReturn
	add	esp, 8

; 3696 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnValidate
$LN32@fnValidate:

; 3697 :    }
; 3698 : 
; 3699 :    // Next make sure we are not processing hierarchically.
; 3700 :    if ( lpViewCsr->hHierRootEntityInstance )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN44@fnValidate

; 3701 :    {
; 3702 :       if ( (nFlags & 0x8000) == 0 )

	movsx	eax, WORD PTR _nFlags$[ebp]
	and	eax, 32768				; 00008000H
	jne	SHORT $LN45@fnValidate

; 3703 :       {
; 3704 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 3705 :          // "KZOEE264 - Invalid Operation for Hierarchical processing"
; 3706 :          fnIssueCoreError( lpTask, lpView, 8, 264, 0,

	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	264					; 00000108H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3707 :                            fnEntityNameFromCsr( lpViewEntityCsr ), 0 );
; 3708 :       }

	jmp	SHORT $LN46@fnValidate
$LN45@fnValidate:

; 3709 :       else
; 3710 :       {
; 3711 :          TraceLineS( "KZOEE264 - Invalid Operation for Hierarchical processing for Entity: ",

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEntityNameFromCsr@4
	push	eax
	push	OFFSET $SG14523
	call	_TraceLineS@8
$LN46@fnValidate:

; 3712 :                      fnEntityNameFromCsr( lpViewEntityCsr ) );
; 3713 :       }
; 3714 : 
; 3715 :       fnOperationReturn( iOperationID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOperationID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8

; 3716 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnValidate
$LN44@fnValidate:

; 3717 :    }
; 3718 : 
; 3719 :    // Everything is AOK, return.
; 3720 :    return( 0 );

	xor	eax, eax
$LN1@fnValidate:

; 3721 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidateInstanceParameters ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpTask$1 = -100					; size = 4
_lpTask$2 = -96						; size = 4
_lpTask$3 = -92						; size = 4
_lpRootViewEntity$4 = -88				; size = 4
_lpTask$5 = -84						; size = 4
_lpTask$6 = -80						; size = 4
_lpViewOI$ = -76					; size = 4
_lpTask$7 = -72						; size = 4
_lpTask$8 = -68						; size = 4
_lpParentViewEntity$9 = -64				; size = 4
_lpTask$10 = -60					; size = 4
_lpTask$11 = -56					; size = 4
_lpRootViewEntityCsr$ = -52				; size = 4
tv74 = -48						; size = 4
_lpLinkedParentViewEntity$12 = -44			; size = 4
_lpViewCsr$ = -40					; size = 4
_lpWrkInstance$13 = -36					; size = 4
_lpSearchViewEntity$14 = -32				; size = 4
_lpParent$15 = -28					; size = 4
_lpTwinEntityInstance$ = -24				; size = 4
_lpParentViewEntityCsr$ = -20				; size = 4
_lpLinkedEntityInstance$16 = -16			; size = 4
_lpViewRootEntityInstance$ = -12			; size = 4
_lpViewEntity$ = -8					; size = 4
_lpParentEntityInstance$ = -4				; size = 4
_pnNewRoot$ = 8						; size = 4
_iOperationID$ = 12					; size = 2
_lpView$ = 16						; size = 4
_lpViewEntityCsr$ = 20					; size = 4
_nPosition$ = 24					; size = 2
_fnValidateInsertPosition PROC

; 2625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 100				; 00000064H

; 2626 :    LPVIEWOI          lpViewOI;
; 2627 :    LPVIEWCSR         lpViewCsr;
; 2628 :    LPVIEWENTITY      lpViewEntity;
; 2629 :    LPVIEWENTITYCSR   lpParentViewEntityCsr;
; 2630 :    LPVIEWENTITYCSR   lpRootViewEntityCsr;
; 2631 :    LPENTITYINSTANCE  lpViewRootEntityInstance;
; 2632 :    LPENTITYINSTANCE  lpTwinEntityInstance;
; 2633 :    LPENTITYINSTANCE  lpParentEntityInstance;
; 2634 : 
; 2635 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2636 :    lpViewCsr    = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2637 :    lpViewOI     = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2638 : 
; 2639 :    // Validate the position parameter
; 2640 :    switch ( nPosition )

	movsx	eax, WORD PTR _nPosition$[ebp]
	mov	DWORD PTR tv74[ebp], eax
	cmp	DWORD PTR tv74[ebp], 0
	jle	SHORT $LN15@fnValidate
	cmp	DWORD PTR tv74[ebp], 4
	jle	SHORT $LN14@fnValidate
	jmp	SHORT $LN15@fnValidate
$LN14@fnValidate:

; 2641 :    {
; 2642 :       case zPOS_BEFORE: // 4
; 2643 :       case zPOS_AFTER:  // 3
; 2644 :       case zPOS_FIRST:  // 1
; 2645 :       case zPOS_LAST:   // 2
; 2646 :          break;

	jmp	SHORT $LN2@fnValidate
$LN15@fnValidate:

; 2647 : 
; 2648 :       default:
; 2649 :       {
; 2650 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$11[ebp], eax

; 2651 :          //  "KZOEE120 - Invalid position parameter"
; 2652 :          fnIssueCoreError( lpTask, lpView, 8, 120, (zLONG) nPosition,

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	movsx	ecx, WORD PTR _nPosition$[ebp]
	push	ecx
	push	120					; 00000078H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$11[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2653 :                            lpViewEntity->szName, 0 );
; 2654 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN2@fnValidate:

; 2655 :       }
; 2656 :    }
; 2657 : 
; 2658 :    //
; 2659 :    //  Insert errors:  See comment for function above
; 2660 :    //
; 2661 : 
; 2662 :    *pnNewRoot = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _pnNewRoot$[ebp]
	mov	WORD PTR [edx], cx

; 2663 :    lpRootViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$[ebp], eax

; 2664 :    lpViewRootEntityInstance = zGETPTR( lpRootViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpRootViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewRootEntityInstance$[ebp], eax

; 2665 : 
; 2666 :    if ( lpViewRootEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpViewRootEntityInstance$[ebp], 1
	jne	SHORT $LN16@fnValidate

; 2667 :       lpViewRootEntityInstance = fnEstablishCursorForView( lpRootViewEntityCsr );

	mov	ecx, DWORD PTR _lpRootViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpViewRootEntityInstance$[ebp], eax
$LN16@fnValidate:

; 2668 : 
; 2669 :    if ( lpViewRootEntityInstance == 0 )

	cmp	DWORD PTR _lpViewRootEntityInstance$[ebp], 0
	jne	SHORT $LN17@fnValidate

; 2670 :       lpViewRootEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewRootEntityInstance$[ebp], eax
$LN17@fnValidate:

; 2671 : 
; 2672 :    // Gig, PATCH Attempt 1/8/93, go to parent of view root if it exists
; 2673 :    if ( lpViewRootEntityInstance && lpViewRootEntityInstance->hParent )

	cmp	DWORD PTR _lpViewRootEntityInstance$[ebp], 0
	je	SHORT $LN18@fnValidate
	mov	ecx, DWORD PTR _lpViewRootEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN18@fnValidate

; 2674 :       lpViewRootEntityInstance = zGETPTR( lpViewRootEntityInstance->hParent );

	mov	edx, DWORD PTR _lpViewRootEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewRootEntityInstance$[ebp], eax
$LN18@fnValidate:

; 2675 :    // Gig, PATCH Attempt 1/8/93, go to parent of view root if it exists
; 2676 : 
; 2677 :    if   ( lpViewRootEntityInstance &&
; 2678 :           lpViewRootEntityInstance->u.nInd.bHidden &&

	cmp	DWORD PTR _lpViewRootEntityInstance$[ebp], 0
	je	SHORT $LN19@fnValidate
	mov	ecx, DWORD PTR _lpViewRootEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN19@fnValidate
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	ecx, 1
	jle	SHORT $LN19@fnValidate

; 2679 :           lpViewEntity->nLevel > 1 )
; 2680 :    {
; 2681 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$10[ebp], eax

; 2682 :       //  "KZOEE252 - Root of view has been deleted"
; 2683 :       fnIssueCoreError( lpTask, lpView, 8, 252, 0,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	252					; 000000fcH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$10[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2684 :                         lpViewEntity->szName, 0 );
; 2685 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN19@fnValidate:

; 2686 :    }
; 2687 : 
; 2688 :    // If the cursor for the current entity instance needs to be
; 2689 :    // established, establish it now.
; 2690 :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN20@fnValidate

; 2691 :    {
; 2692 :       fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN20@fnValidate:

; 2693 :    }
; 2694 : 
; 2695 :    lpParentEntityInstance = 0;

	mov	DWORD PTR _lpParentEntityInstance$[ebp], 0

; 2696 :    lpTwinEntityInstance   = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTwinEntityInstance$[ebp], eax

; 2697 : 
; 2698 :    // If the view entity has no parent OR the view cursor for the
; 2699 :    // entity is > 1 (recursive at the root level) look for a
; 2700 :    // parent entity instance.
; 2701 :    if ( lpViewEntity->hParent || lpViewEntityCsr->nLevel > 1 )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	SHORT $LN23@fnValidate
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	cmp	ecx, 1
	jle	$LN21@fnValidate
$LN23@fnValidate:

; 2702 :    {
; 2703 :       lpParentViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$[ebp], eax

; 2704 : 
; 2705 :       // If null, we are at a subobject entity.
; 2706 :       if ( lpParentViewEntityCsr == 0 )

	cmp	DWORD PTR _lpParentViewEntityCsr$[ebp], 0
	jne	SHORT $LN24@fnValidate

; 2707 :          lpParentEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntityInstance$[ebp], eax
	jmp	SHORT $LN25@fnValidate
$LN24@fnValidate:

; 2708 :       else
; 2709 :       {
; 2710 :          if ( lpParentViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	eax, DWORD PTR _lpParentViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	jne	SHORT $LN26@fnValidate

; 2711 :             fnEstablishCursorForView( lpParentViewEntityCsr );

	mov	ecx, DWORD PTR _lpParentViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN26@fnValidate:

; 2712 : 
; 2713 :          lpParentEntityInstance = zGETPTR( lpParentViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpParentViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntityInstance$[ebp], eax

; 2714 : 
; 2715 :          // PATCH 7/1/93 Gig, We do not allow creation of entities which have
; 2716 :          // a parent unless the parent exists!!
; 2717 :          if ( lpParentEntityInstance == 0 )

	cmp	DWORD PTR _lpParentEntityInstance$[ebp], 0
	jne	SHORT $LN25@fnValidate

; 2718 :          {
; 2719 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8[ebp], eax

; 2720 :             LPVIEWENTITY lpParentViewEntity = zGETPTR( lpParentViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpParentViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$9[ebp], eax

; 2721 : 
; 2722 :             //  "KZOEE122 - Attempt to create an Entity without a parent"
; 2723 :             fnIssueCoreError( lpTask, lpView, 8, 122, 0,

	mov	edx, DWORD PTR _lpParentViewEntity$9[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	122					; 0000007aH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2724 :                               lpViewEntity->szName,
; 2725 :                               lpParentViewEntity->szName );
; 2726 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN25@fnValidate:

; 2727 :          }
; 2728 :       }
; 2729 : 
; 2730 :       // If the current parent cursor is on a previous version, issue
; 2731 :       // an error.
; 2732 :       if ( lpParentEntityInstance )

	cmp	DWORD PTR _lpParentEntityInstance$[ebp], 0
	je	SHORT $LN28@fnValidate

; 2733 :       {
; 2734 :          if ( lpParentEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN28@fnValidate

; 2735 :          {
; 2736 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$7[ebp], eax

; 2737 :             //  "KZOEE254 - Entity cursor is undefined"
; 2738 :             fnIssueCoreError( lpTask, lpView, 8, 254, 0,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	254					; 000000feH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$7[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2739 :                               lpViewEntity->szName, 0 );
; 2740 :             return( zCALL_ERROR );   // Cursor undefined

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN28@fnValidate:

; 2741 :          }
; 2742 :       }
; 2743 :    }

	jmp	SHORT $LN22@fnValidate
$LN21@fnValidate:

; 2744 :    else
; 2745 :    {
; 2746 :       lpParentViewEntityCsr  = 0;

	mov	DWORD PTR _lpParentViewEntityCsr$[ebp], 0

; 2747 :       lpParentEntityInstance = 0;

	mov	DWORD PTR _lpParentEntityInstance$[ebp], 0
$LN22@fnValidate:

; 2748 :    }
; 2749 : 
; 2750 :    // If a twin exists, make sure it is not the root of the complete
; 2751 :    // object instance and that the cursor is undefined because it is
; 2752 :    // pointing to a deleted entity or a previous version.
; 2753 :    if ( lpTwinEntityInstance ) // if a twin exists

	cmp	DWORD PTR _lpTwinEntityInstance$[ebp], 0
	je	$LN30@fnValidate

; 2754 :    {
; 2755 :       if ( lpTwinEntityInstance == lpViewRootEntityInstance &&

	mov	ecx, DWORD PTR _lpTwinEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpViewRootEntityInstance$[ebp]
	jne	$LN32@fnValidate
	mov	edx, DWORD PTR _lpTwinEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	eax, 1
	jne	$LN32@fnValidate

; 2756 :            lpTwinEntityInstance->nLevel == 1 )
; 2757 :       {
; 2758 :          if ( lpViewOI->bMultipleRootLevels == FALSE )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, 1
	jne	$LN32@fnValidate

; 2759 :          {
; 2760 :             if ( lpTwinEntityInstance->u.nInd.bHidden &&

	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	$LN34@fnValidate
	mov	edx, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN34@fnValidate

; 2761 :                  lpTwinEntityInstance->u.nInd.bCreated )
; 2762 :             {
; 2763 :                LPENTITYINSTANCE  lpWrkInstance;
; 2764 : 
; 2765 :                lpWrkInstance = zGETPTR( lpTwinEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$13[ebp], eax
$LN4@fnValidate:

; 2766 :                while ( lpWrkInstance && lpWrkInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpWrkInstance$13[ebp], 0
	je	SHORT $LN5@fnValidate
	mov	eax, DWORD PTR _lpWrkInstance$13[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN5@fnValidate

; 2767 :                   lpWrkInstance = zGETPTR( lpWrkInstance->hNextTwin );

	mov	edx, DWORD PTR _lpWrkInstance$13[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$13[ebp], eax
	jmp	SHORT $LN4@fnValidate
$LN5@fnValidate:

; 2768 : 
; 2769 :                if ( lpWrkInstance )

	cmp	DWORD PTR _lpWrkInstance$13[ebp], 0
	je	SHORT $LN36@fnValidate

; 2770 :                {
; 2771 :                   LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$6[ebp], eax

; 2772 :                   //  "KZOEE121 - Attempt to insert twin to root of Instance"
; 2773 :                   fnIssueCoreError( lpTask, lpView, 8, 121, 0,

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	121					; 00000079H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$6[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2774 :                                     lpViewEntity->szName, 0 );
; 2775 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN36@fnValidate:

; 2776 :                }
; 2777 :             }

	jmp	SHORT $LN32@fnValidate
$LN34@fnValidate:

; 2778 :             else
; 2779 :             {
; 2780 :                LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$5[ebp], eax

; 2781 :                //  "KZOEE121 - Attempt to insert twin to root of Instance"
; 2782 :                fnIssueCoreError( lpTask, lpView, 8, 121, 0,

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	121					; 00000079H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$5[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2783 :                                  lpViewEntity->szName, 0 );
; 2784 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN32@fnValidate:

; 2785 :             }
; 2786 :          }
; 2787 :       }
; 2788 :    }

	jmp	SHORT $LN31@fnValidate
$LN30@fnValidate:

; 2789 :    else   // No twin exists, see if entity has a parent
; 2790 :    if ( lpParentEntityInstance == 0 )  // Parent entity instance exists?

	cmp	DWORD PTR _lpParentEntityInstance$[ebp], 0
	jne	SHORT $LN31@fnValidate

; 2791 :    {
; 2792 :       // No parent Entity Instance, make sure this can be a root.
; 2793 :       if ( lpViewRootEntityInstance )  // Another entity instance exists

	cmp	DWORD PTR _lpViewRootEntityInstance$[ebp], 0
	je	SHORT $LN31@fnValidate

; 2794 :       {
; 2795 :          LPVIEWENTITY lpRootViewEntity;
; 2796 : 
; 2797 :          lpRootViewEntity = zGETPTR( lpViewRootEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpViewRootEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntity$4[ebp], eax

; 2798 : 
; 2799 :          // If a root exists and entity has neither a twin nor a
; 2800 :          // parent cursor, then the new entity is disjoint unless the
; 2801 :          // entity is the parent of the current root cursor.
; 2802 :          if ( zGETPTR( lpRootViewEntity->hParent ) != lpViewEntity )

	mov	ecx, DWORD PTR _lpRootViewEntity$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN39@fnValidate

; 2803 :          {
; 2804 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 2805 :             //  "KZOEE122 - Attempt to create an Entity without a parent"
; 2806 :             fnIssueCoreError( lpTask, lpView, 8, 122, 0,

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	122					; 0000007aH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$3[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2807 :                               lpViewEntity->szName, 0 );
; 2808 :             return( zCALL_ERROR );  // Entity is disjoint

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN39@fnValidate:

; 2809 :          }
; 2810 : 
; 2811 :          // Otherwise, the entity is a new root, set indicator
; 2812 :          *pnNewRoot = TRUE;

	mov	edx, 1
	mov	eax, DWORD PTR _pnNewRoot$[ebp]
	mov	WORD PTR [eax], dx
$LN31@fnValidate:

; 2813 :       }
; 2814 :    }
; 2815 : 
; 2816 :    // For every linked parent entity instance, make sure the
; 2817 :    // corresponding view object does not have this target entity
; 2818 :    // as either a child or direct parent to the linked parent found.
; 2819 :    if ( iOperationID != iIncludeSubobjectFromSubobject &&
; 2820 :         iOperationID != iCreateTemporalEntity &&

	movsx	ecx, WORD PTR _iOperationID$[ebp]
	cmp	ecx, 105				; 00000069H
	je	$LN40@fnValidate
	movsx	edx, WORD PTR _iOperationID$[ebp]
	cmp	edx, 115				; 00000073H
	je	$LN40@fnValidate
	movsx	eax, WORD PTR _iOperationID$[ebp]
	cmp	eax, 101				; 00000065H
	je	$LN40@fnValidate

; 2821 :         iOperationID != iCreateEntity )
; 2822 :    {
; 2823 :       LPVIEWENTITY      lpSearchViewEntity;
; 2824 :       LPVIEWENTITY      lpLinkedParentViewEntity;
; 2825 :       LPENTITYINSTANCE  lpLinkedEntityInstance;
; 2826 : 
; 2827 :       if ( lpParentEntityInstance )

	cmp	DWORD PTR _lpParentEntityInstance$[ebp], 0
	je	SHORT $LN41@fnValidate
$LN6@fnValidate:

; 2828 :       {
; 2829 :          while ( lpParentEntityInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpParentEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN41@fnValidate

; 2830 :             lpParentEntityInstance = zGETPTR( lpParentEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntityInstance$[ebp], eax
	jmp	SHORT $LN6@fnValidate
$LN41@fnValidate:

; 2831 :       }
; 2832 : 
; 2833 :       if ( lpParentEntityInstance && lpParentEntityInstance->hNextLinked )

	cmp	DWORD PTR _lpParentEntityInstance$[ebp], 0
	je	$LN40@fnValidate
	mov	ecx, DWORD PTR _lpParentEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	$LN40@fnValidate

; 2834 :       {
; 2835 :          lpLinkedEntityInstance = lpParentEntityInstance;

	mov	edx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	DWORD PTR _lpLinkedEntityInstance$16[ebp], edx
$LN8@fnValidate:

; 2836 :          while ( lpLinkedEntityInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpLinkedEntityInstance$16[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN9@fnValidate

; 2837 :             lpLinkedEntityInstance = zGETPTR( lpLinkedEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpLinkedEntityInstance$16[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedEntityInstance$16[ebp], eax
	jmp	SHORT $LN8@fnValidate
$LN9@fnValidate:

; 2838 : 
; 2839 :          lpLinkedEntityInstance = zGETPTR( lpLinkedEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpLinkedEntityInstance$16[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedEntityInstance$16[ebp], eax
$LN10@fnValidate:

; 2840 :          while ( lpLinkedEntityInstance != lpParentEntityInstance )

	mov	edx, DWORD PTR _lpLinkedEntityInstance$16[ebp]
	cmp	edx, DWORD PTR _lpParentEntityInstance$[ebp]
	je	$LN40@fnValidate

; 2841 :          {
; 2842 :             if ( lpLinkedEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpLinkedEntityInstance$16[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	$LN43@fnValidate

; 2843 :             {
; 2844 :                LPVIEWENTITY lpParent;
; 2845 : 
; 2846 :                lpLinkedParentViewEntity = zGETPTR( lpLinkedEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpLinkedEntityInstance$16[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedParentViewEntity$12[ebp], eax

; 2847 :                lpParent = zGETPTR( lpLinkedParentViewEntity->hParent );

	mov	ecx, DWORD PTR _lpLinkedParentViewEntity$12[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$15[ebp], eax

; 2848 : 
; 2849 :                // Check the linked parent view entity does not have
; 2850 :                // target entity as the parent
; 2851 :                if ( lpLinkedParentViewEntity->lERRelTok ==
; 2852 :                                              lpViewEntity->lERRelTok &&
; 2853 :                      lpParent &&

	mov	eax, DWORD PTR _lpLinkedParentViewEntity$12[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $LN44@fnValidate
	cmp	DWORD PTR _lpParent$15[ebp], 0
	je	SHORT $LN44@fnValidate
	mov	eax, DWORD PTR _lpParent$15[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $LN44@fnValidate

; 2854 :                      lpParent->lEREntTok == lpViewEntity->lERRelTok )
; 2855 :                {
; 2856 :                   LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 2857 :                   // "KZOEE124 - Entity parent is included in another path "
; 2858 :                   // "           containing same entity type"
; 2859 :                   lpParent = zGETPTR( lpParentEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$15[ebp], eax

; 2860 :                   fnIssueCoreError( lpTask, lpView, 8, 124, 0,

	mov	ecx, DWORD PTR _lpParent$15[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	124					; 0000007cH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2861 :                                     lpViewEntity->szName,
; 2862 :                                     lpParent->szName );
; 2863 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidate
$LN44@fnValidate:

; 2864 :                }
; 2865 : 
; 2866 :                lpSearchViewEntity = zGETPTR( lpLinkedParentViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpLinkedParentViewEntity$12[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$14[ebp], eax
$LN12@fnValidate:

; 2867 : 
; 2868 :                while ( lpSearchViewEntity &&

	cmp	DWORD PTR _lpSearchViewEntity$14[ebp], 0
	je	$LN43@fnValidate
	mov	ecx, DWORD PTR _lpSearchViewEntity$14[ebp]
	movsx	edx, WORD PTR [ecx+215]
	mov	eax, DWORD PTR _lpLinkedParentViewEntity$12[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	edx, ecx
	jle	$LN43@fnValidate

; 2869 :                        lpSearchViewEntity->nLevel >
; 2870 :                                           lpLinkedParentViewEntity->nLevel )
; 2871 :                {
; 2872 :                   if ( lpSearchViewEntity->lEREntTok ==
; 2873 :                                                    lpViewEntity->lEREntTok &&

	mov	edx, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $LN45@fnValidate
	mov	edx, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	jne	SHORT $LN45@fnValidate

; 2874 :                         lpSearchViewEntity->lERRelTok ==
; 2875 :                                                    lpViewEntity->lERRelTok )
; 2876 :                   {
; 2877 :                      LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 2878 :                      // "KZOEE124 - Entity parent is included in another path "
; 2879 :                      // "           containing same entity type"
; 2880 :                      lpParent = zGETPTR( lpParentEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$15[ebp], eax

; 2881 :                      fnIssueCoreError( lpTask, lpView, 8, 124, 0,

	mov	eax, DWORD PTR _lpParent$15[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	124					; 0000007cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2882 :                                        lpViewEntity->szName,
; 2883 :                                        lpParent->szName );
; 2884 :                      return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnValidate
$LN45@fnValidate:

; 2885 :                   }
; 2886 : 
; 2887 :                   lpSearchViewEntity = zGETPTR( lpSearchViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$14[ebp], eax

; 2888 :                }

	jmp	$LN12@fnValidate
$LN43@fnValidate:

; 2889 :             }
; 2890 : 
; 2891 :             lpLinkedEntityInstance = zGETPTR( lpLinkedEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpLinkedEntityInstance$16[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedEntityInstance$16[ebp], eax

; 2892 :          }

	jmp	$LN10@fnValidate
$LN40@fnValidate:

; 2893 :       }
; 2894 :    }
; 2895 : 
; 2896 :    return( nPosition ); // return the nPosition value

	mov	ax, WORD PTR _nPosition$[ebp]
$LN1@fnValidate:

; 2897 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidateInsertPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpWorkInstance2$ = -40					; size = 4
_lpViewCsr$ = -36					; size = 4
_lpWorkViewEntity$1 = -32				; size = 4
_lpRecursiveParent$ = -28				; size = 4
_lpFirstViewEntityCsr$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpRecursiveCsr$ = -16					; size = 4
_lpWorkInstance1$ = -12					; size = 4
_lpWorkCsr$ = -8					; size = 4
_bReset$ = -1						; size = 1
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_fnEstablishViewForInstance PROC

; 2451 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 2452 :    LPVIEWCSR        lpViewCsr;
; 2453 :    LPVIEWENTITY     lpViewEntity;
; 2454 :    LPVIEWENTITYCSR  lpFirstViewEntityCsr;
; 2455 :    LPVIEWENTITYCSR  lpWorkCsr;
; 2456 :    LPVIEWENTITYCSR  lpRecursiveParent;
; 2457 :    LPVIEWENTITYCSR  lpRecursiveCsr;
; 2458 :    LPENTITYINSTANCE lpWorkInstance1;
; 2459 :    LPENTITYINSTANCE lpWorkInstance2;
; 2460 :    zBOOL            bReset = FALSE;  // initialize bReset

	mov	BYTE PTR _bReset$[ebp], 0

; 2461 : 
; 2462 :    lpViewEntity         = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2463 :    lpViewCsr            = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2464 :    lpFirstViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewEntityCsr$[ebp], eax

; 2465 : 
; 2466 :    // If no entity cursor passed, establish one.
; 2467 :    lpRecursiveParent = 0;

	mov	DWORD PTR _lpRecursiveParent$[ebp], 0

; 2468 :    if ( lpViewEntityCsr == 0 )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	jne	SHORT $LN11@fnEstablis

; 2469 :    {
; 2470 :       fnResetView( lpView, 1 );

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnResetView
	add	esp, 8

; 2471 :       bReset = TRUE;

	mov	BYTE PTR _bReset$[ebp], 1

; 2472 :       lpViewEntityCsr = lpFirstViewEntityCsr;

	mov	ecx, DWORD PTR _lpFirstViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx

; 2473 :       lpViewEntityCsr += (lpViewEntity->nHierNbr - 1); // + (# * sizeof( EntityCsr Structure ))

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx

; 2474 :    }

	jmp	SHORT $LN12@fnEstablis
$LN11@fnEstablis:

; 2475 :    else
; 2476 :    if ( lpViewEntity != zGETPTR( lpViewEntityCsr->hViewEntity ) )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntity$[ebp], eax
	je	SHORT $LN12@fnEstablis

; 2477 :    {
; 2478 :       // The view entity of the instance does not match the view entity of
; 2479 :       // the csr, this means that the view entity of the cursor MUST be
; 2480 :       // a recursive parent cursor for the entity instance in question.
; 2481 :       lpRecursiveParent = lpViewEntityCsr;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpRecursiveParent$[ebp], ecx

; 2482 :       lpViewEntityCsr   = lpFirstViewEntityCsr;

	mov	edx, DWORD PTR _lpFirstViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 2483 :       lpViewEntityCsr += (lpViewEntity->nHierNbr - 1);

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	imul	edx, ecx, 30
	add	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx
$LN12@fnEstablis:

; 2484 :    }
; 2485 : 
; 2486 :    // First, take care of the leveling problem.
; 2487 :    if ( lpViewEntityCsr->nLevel != lpEntityInstance->nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	je	$LN14@fnEstablis

; 2488 :    {
; 2489 :       if ( bReset == FALSE )

	movzx	ecx, BYTE PTR _bReset$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@fnEstablis

; 2490 :       {
; 2491 :          fnResetView( lpView, 1 );

	push	1
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetView
	add	esp, 8

; 2492 :          bReset = TRUE;

	mov	BYTE PTR _bReset$[ebp], 1
$LN2@fnEstablis:

; 2493 :       }
; 2494 : 
; 2495 :       while ( lpViewEntityCsr->nLevel < lpEntityInstance->nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jge	$LN14@fnEstablis

; 2496 :       {
; 2497 :          // Until we get a cursor whose level matches the target instance
; 2498 :          // we want to establish, we continually find the highest level
; 2499 :          // recursive child which is greater than the current entity csr
; 2500 :          // level and set subobject views down to that child.
; 2501 :          lpWorkInstance1 = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpWorkInstance1$[ebp], ecx
$LN6@fnEstablis:

; 2502 :          for ( ; ; )
; 2503 :          {
; 2504 :             LPVIEWENTITY lpWorkViewEntity = zGETPTR( lpWorkInstance1->hViewEntity );

	mov	edx, DWORD PTR _lpWorkInstance1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntity$1[ebp], eax

; 2505 : 
; 2506 :             if ( lpWorkViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpWorkViewEntity$1[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN16@fnEstablis

; 2507 :             {
; 2508 :                // Now find the cursor matching recursive child lpWorkInstance1
; 2509 :                lpRecursiveCsr = lpFirstViewEntityCsr;

	mov	eax, DWORD PTR _lpFirstViewEntityCsr$[ebp]
	mov	DWORD PTR _lpRecursiveCsr$[ebp], eax

; 2510 :                lpRecursiveCsr += (lpWorkViewEntity->nHierNbr - 1);

	mov	ecx, DWORD PTR _lpWorkViewEntity$1[ebp]
	movsx	edx, WORD PTR [ecx+217]
	sub	edx, 1
	imul	eax, edx, 30
	add	eax, DWORD PTR _lpRecursiveCsr$[ebp]
	mov	DWORD PTR _lpRecursiveCsr$[ebp], eax

; 2511 : 
; 2512 :                // If we get a level match on the cursor, then accept the entity
; 2513 :                // at the cursor, otherwise keep looking.
; 2514 :                if ( lpRecursiveCsr->nLevel == lpWorkInstance1->nLevel )

	mov	ecx, DWORD PTR _lpRecursiveCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpWorkInstance1$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jne	SHORT $LN16@fnEstablis

; 2515 :                   break;

	jmp	SHORT $LN5@fnEstablis
$LN16@fnEstablis:

; 2516 :             }
; 2517 : 
; 2518 :             lpWorkInstance1 = zGETPTR( lpWorkInstance1->hParent );

	mov	edx, DWORD PTR _lpWorkInstance1$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance1$[ebp], eax

; 2519 :          }

	jmp	SHORT $LN6@fnEstablis
$LN5@fnEstablis:

; 2520 : 
; 2521 :          lpWorkCsr = lpRecursiveCsr;

	mov	ecx, DWORD PTR _lpRecursiveCsr$[ebp]
	mov	DWORD PTR _lpWorkCsr$[ebp], ecx

; 2522 :          lpWorkInstance2 = lpWorkInstance1;

	mov	edx, DWORD PTR _lpWorkInstance1$[ebp]
	mov	DWORD PTR _lpWorkInstance2$[ebp], edx
$LN7@fnEstablis:

; 2523 : 
; 2524 :          // Establish the cursors for the recursive child up to the
; 2525 :          // recursive parent.
; 2526 :          while ( lpWorkCsr &&

	cmp	DWORD PTR _lpWorkCsr$[ebp], 0
	je	SHORT $LN8@fnEstablis
	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpWorkInstance1$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jne	SHORT $LN8@fnEstablis

; 2527 :                  lpWorkCsr->nLevel == lpWorkInstance1->nLevel )
; 2528 :          {
; 2529 :             lpWorkCsr->hEntityInstance = zGETHNDL( lpWorkInstance1 );

	mov	ecx, DWORD PTR _lpWorkInstance1$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 2530 :          // if ( lpWorkCsr->hEntityInstance == UNSET_CSR )
; 2531 :          //    SysMessageBox( 0, "fnEstablishViewForInstance", "UNSET_CSR", -1 );
; 2532 : 
; 2533 :             lpWorkCsr = zGETPTR( lpWorkCsr->hParent );

	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 2534 :             lpWorkInstance1 = zGETPTR( lpWorkInstance1->hParent );

	mov	edx, DWORD PTR _lpWorkInstance1$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance1$[ebp], eax

; 2535 :          }

	jmp	SHORT $LN7@fnEstablis
$LN8@fnEstablis:

; 2536 : 
; 2537 :          // Now we set the view to the subobject in question and
; 2538 :          // continue until the target entity comes into view.
; 2539 :          fnSetViewToSubobject( lpView,

	mov	ecx, DWORD PTR _lpRecursiveCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWorkInstance2$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH

; 2540 :                                zGETPTR( lpWorkInstance2->hViewEntity ),
; 2541 :                                lpRecursiveCsr );
; 2542 :       }

	jmp	$LN2@fnEstablis
$LN14@fnEstablis:

; 2543 :    }
; 2544 : 
; 2545 :    // Now that we are done, establish any necessary cursors up the
; 2546 :    // parent chain.
; 2547 :    lpWorkCsr = lpViewEntityCsr;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpWorkCsr$[ebp], edx
$LN9@fnEstablis:

; 2548 :    while ( lpWorkCsr &&

	cmp	DWORD PTR _lpWorkCsr$[ebp], 0
	je	SHORT $LN10@fnEstablis
	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jne	SHORT $LN10@fnEstablis

; 2549 :            lpWorkCsr->nLevel == lpEntityInstance->nLevel )
; 2550 :    {
; 2551 :       lpWorkCsr->hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 2552 :    // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 2553 :    //    SysMessageBox( 0, "fnEstablishViewForInstance2", "UNSET_CSR", -1 );
; 2554 : 
; 2555 :       lpEntityInstance = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2556 :       lpWorkCsr = zGETPTR( lpWorkCsr->hParent );

	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 2557 :    }

	jmp	SHORT $LN9@fnEstablis
$LN10@fnEstablis:

; 2558 : 
; 2559 :    // If the ViewEntityCsr passed was the recursive parent cursor for the
; 2560 :    // instance being positioned on, do a SetViewToSubobject to position the
; 2561 :    // instance in the recursive parent cursor and reset the lpViewEntityCsr
; 2562 :    // back to the recursive parent.
; 2563 :    if ( lpRecursiveParent )

	cmp	DWORD PTR _lpRecursiveParent$[ebp], 0
	je	SHORT $LN18@fnEstablis

; 2564 :    {
; 2565 :       fnSetViewToSubobject( lpView, zGETPTR( lpViewEntityCsr->hViewEntity ),

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH

; 2566 :                             lpViewEntityCsr );
; 2567 :       lpViewEntityCsr = lpRecursiveParent;

	mov	edx, DWORD PTR _lpRecursiveParent$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 2568 :    }

	jmp	SHORT $LN19@fnEstablis
$LN18@fnEstablis:

; 2569 :    else
; 2570 :    {
; 2571 :       if ( bReset == FALSE )

	movzx	eax, BYTE PTR _bReset$[ebp]
	test	eax, eax
	jne	SHORT $LN19@fnEstablis

; 2572 :          fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN19@fnEstablis:

; 2573 :    }
; 2574 : 
; 2575 :    // Return success.
; 2576 :    return( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]

; 2577 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnEstablishViewForInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -28					; size = 4
_lpViewOI$ = -24					; size = 4
tv137 = -20						; size = 4
_lpEntityInstance$ = -16				; size = 4
_nHiddenCount$ = -12					; size = 2
_nRC$ = -8						; size = 2
_bInvertedFound$ = -1					; size = 1
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_nReposition$ = 20					; size = 2
_bMarkExcluded$ = 24					; size = 2
_fnExcludeEntity PROC

; 1773 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1774 :    LPVIEWCSR         lpViewCsr;
; 1775 :    LPVIEWOI          lpViewOI;
; 1776 :    LPENTITYINSTANCE  lpEntityInstance;
; 1777 :    zBOOL             bInvertedFound;
; 1778 :    zSHORT            nHiddenCount;
; 1779 :    zSHORT            nRC;
; 1780 : 
; 1781 : 
; 1782 :    // Exclude the entity instance by calling fnExcludeEntityInstance
; 1783 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1784 :    bInvertedFound = fnExcludeEntityInstance( lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnExcludeEntityInstance
	add	esp, 4
	mov	BYTE PTR _bInvertedFound$[ebp], al

; 1785 : 
; 1786 :    // Now that the Exclude process is complete for the instance,
; 1787 :    // call fnHideDeletedExcludedInstances for the excluded instances Parent
; 1788 :    // This is done in the case of an include because linked instances of
; 1789 :    // this entity instances parents may have been as a result of structure
; 1790 :    // inversion.
; 1791 :    nHiddenCount = 0;

	xor	eax, eax
	mov	WORD PTR _nHiddenCount$[ebp], ax

; 1792 :    if ( bInvertedFound )

	movzx	ecx, BYTE PTR _bInvertedFound$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@fnExcludeE

; 1793 :       nHiddenCount = fnHideLinkedChildren( zGETPTR( lpEntityInstance->

	movzx	edx, WORD PTR _bMarkExcluded$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnHideLinkedChildren
	add	esp, 8
	mov	WORD PTR _nHiddenCount$[ebp], ax
$LN4@fnExcludeE:

; 1794 :                                                                   hParent ),
; 1795 :                                            bMarkExcluded );
; 1796 :    nHiddenCount += fnHideExcludedDeletedInstances( lpEntityInstance,

	movzx	edx, WORD PTR _bMarkExcluded$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnHideExcludedDeletedInstances
	add	esp, 8
	movsx	ecx, ax
	movsx	edx, WORD PTR _nHiddenCount$[ebp]
	add	edx, ecx
	mov	WORD PTR _nHiddenCount$[ebp], dx

; 1797 :                                                    bMarkExcluded );
; 1798 : 
; 1799 :    // Update the hidden count in the View OI
; 1800 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1801 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1802 :    lpViewOI->nHiddenCount += nHiddenCount;

	movsx	ecx, WORD PTR _nHiddenCount$[ebp]
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+24]
	add	eax, ecx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [ecx+24], ax

; 1803 :    if ( bMarkExcluded )

	movsx	edx, WORD PTR _bMarkExcluded$[ebp]
	test	edx, edx
	je	SHORT $LN5@fnExcludeE

; 1804 : // >>> RAD54278-1 BEGIN
; 1805 :       fnSetUpdateIndicator( lpViewOI, lpEntityInstance, 0, TRUE, FALSE, FALSE );

	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$LN5@fnExcludeE:

; 1806 : // >>> RAD54278-1 END
; 1807 : 
; 1808 :    // Now see if the user requested the cursor to be repositioned
; 1809 :    switch ( nReposition )

	movsx	edx, WORD PTR _nReposition$[ebp]
	mov	DWORD PTR tv137[ebp], edx
	mov	eax, DWORD PTR tv137[ebp]
	sub	eax, 1
	mov	DWORD PTR tv137[ebp], eax
	cmp	DWORD PTR tv137[ebp], 3
	ja	SHORT $LN10@fnExcludeE
	mov	ecx, DWORD PTR tv137[ebp]
	jmp	DWORD PTR $LN12@fnExcludeE[ecx*4]
$LN6@fnExcludeE:

; 1810 :    {
; 1811 :       case zREPOS_FIRST:
; 1812 :          nRC = SetCursorFirstEntity( lpView, lpViewEntity->szName, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1813 :          break;

	jmp	SHORT $LN2@fnExcludeE
$LN7@fnExcludeE:

; 1814 : 
; 1815 :       case zREPOS_LAST:
; 1816 :          nRC = SetCursorLastEntity( lpView, lpViewEntity->szName, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetCursorLastEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1817 :          break;

	jmp	SHORT $LN2@fnExcludeE
$LN8@fnExcludeE:

; 1818 : 
; 1819 :       case zREPOS_NEXT:
; 1820 :          nRC = SetCursorNextEntity( lpView, lpViewEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1821 :          break;

	jmp	SHORT $LN2@fnExcludeE
$LN9@fnExcludeE:

; 1822 : 
; 1823 :       case zREPOS_PREV:
; 1824 :          nRC = SetCursorPrevEntity( lpView, lpViewEntity->szName, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1825 :          break;

	jmp	SHORT $LN2@fnExcludeE
$LN10@fnExcludeE:

; 1826 : 
; 1827 :       default:
; 1828 :          nRC = zCURSOR_UNDEFINED;

	mov	ecx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], cx
$LN2@fnExcludeE:

; 1829 :    }
; 1830 : 
; 1831 :    // Whew, I think we've done it, return to caller.
; 1832 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 1833 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN12@fnExcludeE:
	DD	$LN6@fnExcludeE
	DD	$LN7@fnExcludeE
	DD	$LN8@fnExcludeE
	DD	$LN9@fnExcludeE
_fnExcludeEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -48					; size = 4
_lpTempViewEntity$1 = -44				; size = 4
tv210 = -40						; size = 4
_lpViewOI$ = -36					; size = 4
_lpStartEntityInstance$ = -32				; size = 4
_lpLinkedInstance$ = -28				; size = 4
_lpWorkInstance$ = -24					; size = 4
_lpEntityInstance$ = -20				; size = 4
_nHiddenCount$ = -16					; size = 2
_nRC$ = -12						; size = 2
_nStartLevel$ = -8					; size = 2
_nLevel$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_nReposition$ = 20					; size = 2
_lpCurrentTask$ = 24					; size = 4
_fnDeleteEntity PROC

; 1504 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 1505 :    LPVIEWCSR         lpViewCsr;
; 1506 :    LPVIEWOI          lpViewOI;
; 1507 :    LPENTITYINSTANCE  lpStartEntityInstance;
; 1508 :    LPENTITYINSTANCE  lpEntityInstance;
; 1509 :    LPENTITYINSTANCE  lpLinkedInstance;
; 1510 :    LPENTITYINSTANCE  lpWorkInstance;
; 1511 :    zSHORT            nStartLevel;
; 1512 :    zSHORT            nLevel;
; 1513 :    zSHORT            nHiddenCount;
; 1514 :    zSHORT            nRC;
; 1515 : 
; 1516 :    // Get entity instance at which to start the delete.
; 1517 :    lpStartEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartEntityInstance$[ebp], eax

; 1518 :    lpEntityInstance = lpStartEntityInstance;

	mov	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx

; 1519 :    nStartLevel = lpEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nStartLevel$[ebp], cx

; 1520 : 
; 1521 :    // First, exclude the entity instance, then go through and mark
; 1522 :    // all those as deleted whose delete rules support delete.
; 1523 :    lpLinkedInstance = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLinkedInstance$[ebp], edx
$LN4@fnDeleteEn:

; 1524 :    for ( ; ; )
; 1525 :    {
; 1526 :       LPVIEWENTITY lpTempViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntity$1[ebp], eax

; 1527 : 
; 1528 :       // If the instance in question is already hidden, skip it
; 1529 :       // and all of its descendents since it may have been excluded or
; 1530 :       // moved BEFORE the Delete was issued.
; 1531 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN14@fnDeleteEn

; 1532 :       {
; 1533 :          nLevel = lpEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nLevel$[ebp], dx

; 1534 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN5@fnDeleteEn:

; 1535 :          while ( lpEntityInstance &&

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN6@fnDeleteEn
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN6@fnDeleteEn

; 1536 :                  lpEntityInstance->nLevel > nLevel )
; 1537 :          {
; 1538 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1539 :          }

	jmp	SHORT $LN5@fnDeleteEn
$LN6@fnDeleteEn:

; 1540 :       }

	jmp	$LN15@fnDeleteEn
$LN14@fnDeleteEn:

; 1541 :       else
; 1542 :       if ( lpTempViewEntity->bPDelete == FALSE &&

	mov	ecx, DWORD PTR _lpTempViewEntity$1[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 7
	and	edx, 1
	jne	$LN16@fnDeleteEn
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN16@fnDeleteEn

; 1543 :            lpEntityInstance->nLevel > nStartLevel )
; 1544 :       {
; 1545 :          // If we get an entity instance which cannot be deleted,
; 1546 :          // skip it and all its descendents since they were
; 1547 :          // already excluded in the beginning of this operation.
; 1548 :          nLevel = lpEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nLevel$[ebp], cx

; 1549 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN18@fnDeleteEn

; 1550 :             fnExcludeEntityInstance( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnExcludeEntityInstance
	add	esp, 4
$LN18@fnDeleteEn:

; 1551 : 
; 1552 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnDeleteEn:

; 1553 :          while ( lpEntityInstance &&

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN8@fnDeleteEn
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	edx, eax
	jle	SHORT $LN8@fnDeleteEn

; 1554 :                  lpEntityInstance->nLevel > nLevel )
; 1555 :          {
; 1556 :             lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 1557 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1558 :          }

	jmp	SHORT $LN7@fnDeleteEn
$LN8@fnDeleteEn:

; 1559 :       }

	jmp	$LN15@fnDeleteEn
$LN16@fnDeleteEn:

; 1560 :       else
; 1561 :       {
; 1562 :          // Mark all linked instances to this instance as deleted.
; 1563 :          lpWorkInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpWorkInstance$[ebp], eax
$LN11@fnDeleteEn:

; 1564 :          for ( ; ; )
; 1565 :          {
; 1566 :             if ( lpWorkInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpWorkInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN19@fnDeleteEn

; 1567 :                lpWorkInstance->u.nInd.bDeleted = TRUE;

	mov	eax, DWORD PTR _lpWorkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 8
	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN19@fnDeleteEn:

; 1568 : 
; 1569 :             lpWorkInstance = zGETPTR( lpWorkInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWorkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance$[ebp], eax

; 1570 :             if ( lpWorkInstance == 0 || lpWorkInstance == lpEntityInstance )

	cmp	DWORD PTR _lpWorkInstance$[ebp], 0
	je	SHORT $LN21@fnDeleteEn
	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	jne	SHORT $LN20@fnDeleteEn
$LN21@fnDeleteEn:

; 1571 :                break;

	jmp	SHORT $LN10@fnDeleteEn
$LN20@fnDeleteEn:

; 1572 : 
; 1573 : #if 1
; 1574 :             // BEGIN - 9/30/93 - Bug in TZTENVRO Deletes
; 1575 :             // We are on a linked instance of a target delete, if the
; 1576 :             // instance in question is part of the same ViewOI and
; 1577 :             // represents a different relationship type or an instance
; 1578 :             // of the same relationship to a different parent, mark the
; 1579 :             // instance as Excluded.
; 1580 :             if ( lpWorkInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpWorkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN22@fnDeleteEn

; 1581 :             {
; 1582 :                if ( lpWorkInstance->hViewOI == lpEntityInstance->hViewOI &&

	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	jne	SHORT $LN22@fnDeleteEn
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkInstance$[ebp]
	push	eax
	call	_fnSameRelationshipInstance
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN22@fnDeleteEn

; 1583 :                     !fnSameRelationshipInstance( lpWorkInstance,
; 1584 :                                                  lpEntityInstance ) )
; 1585 :                {
; 1586 :                   lpWorkInstance->u.nInd.bExcluded = TRUE;

	mov	edx, DWORD PTR _lpWorkInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpWorkInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN22@fnDeleteEn:

; 1587 :                }
; 1588 :             }
; 1589 :             // END - 9/30/93
; 1590 : #endif
; 1591 :          }

	jmp	$LN11@fnDeleteEn
$LN10@fnDeleteEn:

; 1592 : 
; 1593 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN15@fnDeleteEn:

; 1594 :       }
; 1595 : 
; 1596 :       // Issue the delete process for all linked instances to the initial
; 1597 :       // starting instance.
; 1598 :       if ( lpEntityInstance == 0 || lpEntityInstance->nLevel <= nStartLevel )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN25@fnDeleteEn
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jg	SHORT $LN24@fnDeleteEn
$LN25@fnDeleteEn:

; 1599 :       {
; 1600 :          lpLinkedInstance = zGETPTR( lpLinkedInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedInstance$[ebp], eax

; 1601 :          if ( lpLinkedInstance == 0 ||

	cmp	DWORD PTR _lpLinkedInstance$[ebp], 0
	je	SHORT $LN28@fnDeleteEn
	mov	eax, DWORD PTR _lpLinkedInstance$[ebp]
	cmp	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	jne	SHORT $LN26@fnDeleteEn
$LN28@fnDeleteEn:

; 1602 :               lpLinkedInstance == lpStartEntityInstance )
; 1603 :          {
; 1604 :             break;

	jmp	SHORT $LN3@fnDeleteEn

; 1605 :          }

	jmp	SHORT $LN24@fnDeleteEn
$LN26@fnDeleteEn:

; 1606 :          else
; 1607 :          {
; 1608 :             lpEntityInstance = lpLinkedInstance;

	mov	ecx, DWORD PTR _lpLinkedInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx

; 1609 :             nStartLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nStartLevel$[ebp], ax
$LN24@fnDeleteEn:

; 1610 :          }
; 1611 :       }
; 1612 :    }

	jmp	$LN4@fnDeleteEn
$LN3@fnDeleteEn:

; 1613 : 
; 1614 :    // After marking all necessary instances as deleted, call
; 1615 :    // fnHideExcludedDeletedInstances to hide ALL appropriate instances
; 1616 :    // from view.
; 1617 :    nHiddenCount = fnHideExcludedDeletedInstances( lpStartEntityInstance, 1 );

	push	1
	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	push	ecx
	call	_fnHideExcludedDeletedInstances
	add	esp, 8
	mov	WORD PTR _nHiddenCount$[ebp], ax

; 1618 : 
; 1619 :    // Update the hidden count in the View OI.
; 1620 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1621 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1622 :    lpViewOI->nHiddenCount += nHiddenCount;

	movsx	eax, WORD PTR _nHiddenCount$[ebp]
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	add	edx, eax
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [eax+24], dx

; 1623 : 
; 1624 : // >>> RAD54278-1 BEGIN
; 1625 :    fnSetUpdateIndicator( lpViewOI, lpStartEntityInstance,

	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H

; 1626 :                          0, TRUE, FALSE, FALSE );
; 1627 : // >>> RAD54278-1 END
; 1628 : 
; 1629 :    // Now see if the user requested the cursor to be repositioned.
; 1630 :    switch ( nReposition )

	movsx	eax, WORD PTR _nReposition$[ebp]
	mov	DWORD PTR tv210[ebp], eax
	cmp	DWORD PTR tv210[ebp], 0
	jle	SHORT $LN30@fnDeleteEn
	cmp	DWORD PTR tv210[ebp], 4
	jle	SHORT $LN29@fnDeleteEn
	jmp	SHORT $LN30@fnDeleteEn
$LN29@fnDeleteEn:

; 1631 :    {
; 1632 :       case zREPOS_FIRST:
; 1633 :       case zREPOS_LAST:
; 1634 :       case zREPOS_NEXT:
; 1635 :       case zREPOS_PREV:
; 1636 :          nRC = fnSetEntityCursor( lpView, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	movsx	edx, WORD PTR _nReposition$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 1637 :                                   0, (zLONG) nReposition,
; 1638 :                                   0, 0, 0, 0, 0, 0,
; 1639 :                                   lpCurrentTask );
; 1640 :          break;

	jmp	SHORT $LN12@fnDeleteEn
$LN30@fnDeleteEn:

; 1641 : 
; 1642 :       default:
; 1643 :          nRC = zCURSOR_UNDEFINED;

	mov	eax, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], ax
$LN12@fnDeleteEn:

; 1644 :    }
; 1645 : 
; 1646 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 1647 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDeleteEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpWorkInstance$1 = -124				; size = 4
_lpWorkInstance$2 = -120				; size = 4
_lpWorkInstance$3 = -116				; size = 4
_lpAllocTask$ = -112					; size = 4
_lpParentViewEntityCsr$4 = -108				; size = 4
_lpNextHier$5 = -104					; size = 4
tv172 = -100						; size = 4
_lpViewOI$ = -96					; size = 4
_lpWorkViewEnt$6 = -92					; size = 4
_lpParentEntityInstance$ = -88				; size = 4
_lpNextTwin$7 = -84					; size = 4
_lpSearchViewEntity$8 = -80				; size = 4
_lpNextHier$9 = -76					; size = 4
_lpLastChild$10 = -72					; size = 4
_lpRootEntityInstance$ = -68				; size = 4
_lpViewCsr$ = -64					; size = 4
_lpSearchCsr$11 = -60					; size = 4
_lpPrevTwin$12 = -56					; size = 4
_lpNextHier$13 = -52					; size = 4
_lpSearchViewCsr$ = -48					; size = 4
_lpViewSubobject$ = -44					; size = 4
_lpSearchEntityInstance$14 = -40			; size = 4
_lpSearchViewEntityCsr$15 = -36				; size = 4
_hEntityInstance$ = -32					; size = 4
_lpTwinEntityInstance$ = -28				; size = 4
_lpEntityInstance$ = -24				; size = 4
_nParentHierNbr$16 = -20				; size = 2
_nLevel$17 = -16					; size = 2
_nHierNbr$18 = -12					; size = 2
_nRelativeCsr$19 = -8					; size = 2
_nRelativeRecursCsr$20 = -4				; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_nPosition$ = 20					; size = 2
_bNewRoot$ = 24						; size = 2
_fnCreateEntity@20 PROC

; 2999 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH

; 3000 :    LPTASK            lpAllocTask;
; 3001 :    LPVIEWOI          lpViewOI;
; 3002 :    LPVIEWCSR         lpViewCsr;
; 3003 :    LPVIEWCSR         lpSearchViewCsr;
; 3004 :    LPVIEWSUBOBJECT   lpViewSubobject = 0;

	mov	DWORD PTR _lpViewSubobject$[ebp], 0

; 3005 :    zPVOID            hEntityInstance = 0;

	mov	DWORD PTR _hEntityInstance$[ebp], 0

; 3006 :    LPENTITYINSTANCE  lpEntityInstance;
; 3007 :    LPENTITYINSTANCE  lpRootEntityInstance;
; 3008 :    LPENTITYINSTANCE  lpParentEntityInstance;
; 3009 :    LPENTITYINSTANCE  lpTwinEntityInstance;
; 3010 : 
; 3011 :    lpViewCsr   = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3012 :    lpViewOI    = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 3013 :    lpAllocTask = zGETPTR( lpViewOI->hTask );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 3014 : 
; 3015 :    // Get twin to current entity.
; 3016 :    lpParentEntityInstance = 0;

	mov	DWORD PTR _lpParentEntityInstance$[ebp], 0

; 3017 :    if ( lpViewEntityCsr->nLevel > 1 ) // parent exists at definition level

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	cmp	ecx, 1
	jle	SHORT $LN20@fnCreateEn

; 3018 :    {
; 3019 :       LPVIEWENTITYCSR lpParentViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$4[ebp], eax

; 3020 : 
; 3021 :       // If there is no parent entity cursor, then this entity is to be the new root
; 3022 :       // of a subobject view, the parent in this case is the parent of the view.
; 3023 :       if ( lpParentViewEntityCsr )

	cmp	DWORD PTR _lpParentViewEntityCsr$4[ebp], 0
	je	SHORT $LN21@fnCreateEn

; 3024 :       {
; 3025 :          lpParentEntityInstance = zGETPTR( lpParentViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpParentViewEntityCsr$4[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntityInstance$[ebp], eax

; 3026 :       // if ( zGETHNDL( lpParentEntityInstance ) == UNSET_CSR )
; 3027 :       //    SysMessageBox( 0, "fnCreateEntity", "UNSET_CSR", -1 );
; 3028 :       }

	jmp	SHORT $LN20@fnCreateEn
$LN21@fnCreateEn:

; 3029 :       else
; 3030 :       {
; 3031 :          lpParentEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntityInstance$[ebp], eax
$LN20@fnCreateEn:

; 3032 :       // if ( zGETHNDL( lpParentEntityInstance ) == UNSET_CSR )
; 3033 :       //    SysMessageBox( 0, "fnCreateEntity", "UNSET_CSR", -1 );
; 3034 :       }
; 3035 :    }
; 3036 : 
; 3037 :    // Everything's OK for creating an entity instance, create it now.
; 3038 :    hEntityInstance = fnAllocDataspace( lpAllocTask->hFirstDataHeader,

	push	10024					; 00002728H
	push	0
	push	1
	push	68					; 00000044H
	mov	edx, DWORD PTR _lpAllocTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 3039 :                                        sizeof( EntityInstanceRecord ),
; 3040 :                                        1, 0, iEntityInstance );
; 3041 : 
; 3042 :    if ( hEntityInstance == 0 )

	cmp	DWORD PTR _hEntityInstance$[ebp], 0
	jne	SHORT $LN23@fnCreateEn

; 3043 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateEn
$LN23@fnCreateEn:

; 3044 : 
; 3045 :    lpEntityInstance = zGETPTR( hEntityInstance );

	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 3046 :    fnSetEntityKey( lpAllocTask, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	push	eax
	call	_fnSetEntityKey@12

; 3047 : 
; 3048 :    // Set values in entity instance record.
; 3049 :    lpEntityInstance->hViewOI = lpViewCsr->hViewOI;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR [ecx+10], eax

; 3050 : 
; 3051 :    // Set the view entity associated with the Entity, in the case of a
; 3052 :    // recursive subobject, the view entity pointed to by the cursor may not
; 3053 :    // in fact be the view entity we are creating, in this case we must get
; 3054 :    // the view entity from the subobject entry chained to this entry.
; 3055 :    lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 3056 :    if ( lpViewSubobject && lpViewSubobject->hRecursViewEntity &&

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	je	SHORT $LN24@fnCreateEn
	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN24@fnCreateEn
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jne	SHORT $LN24@fnCreateEn

; 3057 :         lpViewEntityCsr == zGETPTR( lpViewSubobject->hRootCsr ) )
; 3058 :    {
; 3059 :       lpEntityInstance->hViewEntity = lpViewSubobject->hRecursViewEntity;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+2], edx

; 3060 :    }

	jmp	SHORT $LN25@fnCreateEn
$LN24@fnCreateEn:

; 3061 :    else
; 3062 :    {
; 3063 :       lpEntityInstance->hViewEntity = zGETHNDL( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 3064 :       lpViewSubobject = 0;

	mov	DWORD PTR _lpViewSubobject$[ebp], 0
$LN25@fnCreateEn:

; 3065 :    }
; 3066 : 
; 3067 :    lpEntityInstance->nLevel = lpViewEntityCsr->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	cx, WORD PTR [eax+22]
	mov	WORD PTR [edx+58], cx

; 3068 : 
; 3069 :    // Get root of instance chain.
; 3070 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 3071 : 
; 3072 :    // The following check is made in CreateEntity, but is done again here so
; 3073 :    // calls from ActivateOI work after having to go down a subobject level.
; 3074 :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN26@fnCreateEn

; 3075 :       fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN26@fnCreateEn:

; 3076 : 
; 3077 :    // Get twin to current entity.
; 3078 :    lpTwinEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTwinEntityInstance$[ebp], eax

; 3079 : 
; 3080 :    // Set parent, twin, and hierarchical pointers.
; 3081 :    // If we are creating a new root, simply set hierarchical pointers.
; 3082 :    if ( bNewRoot || lpRootEntityInstance == 0 )

	movsx	edx, WORD PTR _bNewRoot$[ebp]
	test	edx, edx
	jne	SHORT $LN29@fnCreateEn
	cmp	DWORD PTR _lpRootEntityInstance$[ebp], 0
	jne	SHORT $LN27@fnCreateEn
$LN29@fnCreateEn:

; 3083 :    {
; 3084 :       if ( lpRootEntityInstance )

	cmp	DWORD PTR _lpRootEntityInstance$[ebp], 0
	je	SHORT $LN30@fnCreateEn

; 3085 :       {
; 3086 :          lpEntityInstance->hNextHier = zGETHNDL( lpRootEntityInstance );

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 3087 :          lpRootEntityInstance->hPrevHier = hEntityInstance;

	mov	edx, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax
$LN30@fnCreateEn:

; 3088 :       }
; 3089 : 
; 3090 :       lpViewOI->hRootEntityInstance = hEntityInstance;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [ecx+26], edx

; 3091 :    }

	jmp	$LN28@fnCreateEn
$LN27@fnCreateEn:

; 3092 :    else
; 3093 :    {
; 3094 :       LPENTITYINSTANCE  lpNextTwin;
; 3095 :       LPENTITYINSTANCE  lpPrevTwin;
; 3096 : 
; 3097 :       lpEntityInstance->hParent = zGETHNDL( lpParentEntityInstance );

	mov	eax, DWORD PTR _lpParentEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 3098 :    // if ( lpEntityInstance->hParent == UNSET_CSR )
; 3099 :    //    SysMessageBox( 0, "fnCreateEntity", "UNSET_CSR", -1 );
; 3100 : 
; 3101 :       switch ( nPosition )

	movsx	edx, WORD PTR _nPosition$[ebp]
	mov	DWORD PTR tv172[ebp], edx
	mov	eax, DWORD PTR tv172[ebp]
	sub	eax, 1
	mov	DWORD PTR tv172[ebp], eax
	cmp	DWORD PTR tv172[ebp], 3
	ja	$LN2@fnCreateEn
	mov	ecx, DWORD PTR tv172[ebp]
	jmp	DWORD PTR $LN78@fnCreateEn[ecx*4]
$LN31@fnCreateEn:

; 3102 :       {
; 3103 :          case zPOS_AFTER: // 3
; 3104 :             if ( lpTwinEntityInstance )

	cmp	DWORD PTR _lpTwinEntityInstance$[ebp], 0
	je	SHORT $LN32@fnCreateEn

; 3105 :             {
; 3106 :                lpEntityInstance->hPrevTwin = zGETHNDL( lpTwinEntityInstance );

	mov	edx, DWORD PTR _lpTwinEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 3107 :                lpEntityInstance->hNextTwin = lpTwinEntityInstance->hNextTwin;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR [edx+22], ecx

; 3108 :                if ( lpTwinEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpTwinEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN33@fnCreateEn

; 3109 :                {
; 3110 :                   LPENTITYINSTANCE lpWorkInstance = zGETPTR( lpTwinEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance$3[ebp], eax

; 3111 : 
; 3112 :                   lpWorkInstance->hPrevTwin = hEntityInstance;

	mov	edx, DWORD PTR _lpWorkInstance$3[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+26], eax
$LN33@fnCreateEn:

; 3113 :                }
; 3114 : 
; 3115 :                lpTwinEntityInstance->hNextTwin = hEntityInstance;

	mov	ecx, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [ecx+22], edx
$LN32@fnCreateEn:

; 3116 :             }
; 3117 : 
; 3118 :             break;

	jmp	$LN2@fnCreateEn
$LN34@fnCreateEn:

; 3119 : 
; 3120 :          case zPOS_BEFORE: // 4
; 3121 :             if ( lpTwinEntityInstance )

	cmp	DWORD PTR _lpTwinEntityInstance$[ebp], 0
	je	SHORT $LN35@fnCreateEn

; 3122 :             {
; 3123 :                lpEntityInstance->hNextTwin = zGETHNDL( lpTwinEntityInstance );

	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+22], eax

; 3124 :                lpEntityInstance->hPrevTwin = lpTwinEntityInstance->hPrevTwin;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 3125 :                if ( lpTwinEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpTwinEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN36@fnCreateEn

; 3126 :                {
; 3127 :                   LPENTITYINSTANCE lpWorkInstance = zGETPTR( lpTwinEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance$2[ebp], eax

; 3128 : 
; 3129 :                   lpWorkInstance->hNextTwin = hEntityInstance;

	mov	edx, DWORD PTR _lpWorkInstance$2[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+22], eax
$LN36@fnCreateEn:

; 3130 :                }
; 3131 : 
; 3132 :                lpTwinEntityInstance->hPrevTwin = hEntityInstance;

	mov	ecx, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [ecx+26], edx
$LN35@fnCreateEn:

; 3133 :             }
; 3134 : 
; 3135 :             break;

	jmp	SHORT $LN2@fnCreateEn
$LN37@fnCreateEn:

; 3136 : 
; 3137 :          case zPOS_FIRST: // 1
; 3138 :             if ( lpTwinEntityInstance )

	cmp	DWORD PTR _lpTwinEntityInstance$[ebp], 0
	je	SHORT $LN38@fnCreateEn
$LN4@fnCreateEn:

; 3139 :             {
; 3140 :                while ( lpTwinEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN5@fnCreateEn

; 3141 :                   lpTwinEntityInstance = zGETPTR( lpTwinEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTwinEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnCreateEn
$LN5@fnCreateEn:

; 3142 : 
; 3143 :                lpEntityInstance->hNextTwin = zGETHNDL( lpTwinEntityInstance );

	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+22], eax

; 3144 :                lpTwinEntityInstance->hPrevTwin = hEntityInstance;

	mov	edx, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+26], eax
$LN38@fnCreateEn:

; 3145 : 
; 3146 :             }
; 3147 : 
; 3148 :             break;

	jmp	SHORT $LN2@fnCreateEn
$LN39@fnCreateEn:

; 3149 : 
; 3150 :          case zPOS_LAST: // 2
; 3151 :             if ( lpTwinEntityInstance )

	cmp	DWORD PTR _lpTwinEntityInstance$[ebp], 0
	je	SHORT $LN2@fnCreateEn
$LN6@fnCreateEn:

; 3152 :             {
; 3153 :                while ( lpTwinEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpTwinEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN7@fnCreateEn

; 3154 :                   lpTwinEntityInstance = zGETPTR( lpTwinEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTwinEntityInstance$[ebp], eax
	jmp	SHORT $LN6@fnCreateEn
$LN7@fnCreateEn:

; 3155 : 
; 3156 :                lpEntityInstance->hPrevTwin = zGETHNDL( lpTwinEntityInstance );

	mov	ecx, DWORD PTR _lpTwinEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+26], eax

; 3157 :                lpTwinEntityInstance->hNextTwin = hEntityInstance;

	mov	eax, DWORD PTR _lpTwinEntityInstance$[ebp]
	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [eax+22], ecx
$LN2@fnCreateEn:

; 3158 :             }
; 3159 : 
; 3160 :             break;
; 3161 :       }
; 3162 : 
; 3163 :       lpNextTwin = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTwin$7[ebp], eax

; 3164 : 
; 3165 :       // Set hierarchical pointers, if there is a next twin, then this
; 3166 :       // is ideal because setting the hierarchical cursor means simply
; 3167 :       // chaining this cursor to the next twin.
; 3168 :       if ( lpNextTwin )  // if there is a next twin

	cmp	DWORD PTR _lpNextTwin$7[ebp], 0
	je	SHORT $LN41@fnCreateEn

; 3169 :       {
; 3170 :          lpEntityInstance->hNextHier = zGETHNDL( lpNextTwin );

	mov	ecx, DWORD PTR _lpNextTwin$7[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+14], eax

; 3171 :          lpEntityInstance->hPrevHier = lpNextTwin->hPrevHier;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpNextTwin$7[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR [eax+18], edx

; 3172 :          if ( lpEntityInstance->hPrevHier )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN43@fnCreateEn

; 3173 :          {
; 3174 :             LPENTITYINSTANCE lpWorkInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkInstance$1[ebp], eax

; 3175 : 
; 3176 :             lpWorkInstance->hNextHier = hEntityInstance;

	mov	eax, DWORD PTR _lpWorkInstance$1[ebp]
	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [eax+14], ecx
$LN43@fnCreateEn:

; 3177 :          }
; 3178 : 
; 3179 :          lpNextTwin->hPrevHier = hEntityInstance;

	mov	edx, DWORD PTR _lpNextTwin$7[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax

; 3180 :          if ( lpNextTwin == lpRootEntityInstance )

	mov	ecx, DWORD PTR _lpNextTwin$7[ebp]
	cmp	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	jne	SHORT $LN44@fnCreateEn

; 3181 :          {
; 3182 :             lpViewOI->hRootEntityInstance = hEntityInstance;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+26], eax

; 3183 :             lpRootEntityInstance = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpRootEntityInstance$[ebp], ecx
$LN44@fnCreateEn:

; 3184 :          }
; 3185 :       }

	jmp	$LN28@fnCreateEn
$LN41@fnCreateEn:

; 3186 :       else
; 3187 :       {
; 3188 :          // Otherwise, use the previous twin as the previous
; 3189 :          // hierarchical if the twin has no next hierarchical OR the
; 3190 :          // next hierarchical for the twin is not a child of the
; 3191 :          // twin.
; 3192 :          lpPrevTwin = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTwin$12[ebp], eax

; 3193 :          if ( lpPrevTwin )

	cmp	DWORD PTR _lpPrevTwin$12[ebp], 0
	je	$LN45@fnCreateEn

; 3194 :          {
; 3195 :             LPENTITYINSTANCE lpNextHier = zGETPTR( lpPrevTwin->hNextHier );

	mov	ecx, DWORD PTR _lpPrevTwin$12[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$5[ebp], eax

; 3196 : 
; 3197 :             if ( lpNextHier == 0 ||

	cmp	DWORD PTR _lpNextHier$5[ebp], 0
	je	SHORT $LN49@fnCreateEn
	mov	eax, DWORD PTR _lpNextHier$5[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jg	SHORT $LN47@fnCreateEn
$LN49@fnCreateEn:

; 3198 :                  lpNextHier->nLevel <= lpEntityInstance->nLevel )
; 3199 :             {
; 3200 :                lpEntityInstance->hPrevHier = zGETHNDL( lpPrevTwin );

	mov	ecx, DWORD PTR _lpPrevTwin$12[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax

; 3201 :                if ( lpPrevTwin->hNextHier )

	mov	eax, DWORD PTR _lpPrevTwin$12[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $LN50@fnCreateEn

; 3202 :                {
; 3203 :                   lpEntityInstance->hNextHier = lpPrevTwin->hNextHier;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lpPrevTwin$12[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+14], eax

; 3204 :                   lpNextHier->hPrevHier = hEntityInstance;

	mov	ecx, DWORD PTR _lpNextHier$5[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [ecx+18], edx
$LN50@fnCreateEn:

; 3205 :                }
; 3206 : 
; 3207 :                lpPrevTwin->hNextHier = hEntityInstance;

	mov	eax, DWORD PTR _lpPrevTwin$12[ebp]
	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [eax+14], ecx

; 3208 :             }

	jmp	$LN48@fnCreateEn
$LN47@fnCreateEn:

; 3209 :             else
; 3210 :             {
; 3211 :                LPENTITYINSTANCE lpLastChild;
; 3212 :                LPENTITYINSTANCE lpNextHier;
; 3213 : 
; 3214 :                lpLastChild = zGETPTR( lpPrevTwin->hNextHier );

	mov	edx, DWORD PTR _lpPrevTwin$12[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastChild$10[ebp], eax

; 3215 :                lpNextHier  = zGETPTR( lpLastChild->hNextHier );

	mov	ecx, DWORD PTR _lpLastChild$10[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$9[ebp], eax
$LN8@fnCreateEn:

; 3216 : 
; 3217 :                while ( lpNextHier &&

	cmp	DWORD PTR _lpNextHier$9[ebp], 0
	je	SHORT $LN9@fnCreateEn
	mov	eax, DWORD PTR _lpNextHier$9[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jle	SHORT $LN9@fnCreateEn

; 3218 :                        lpNextHier->nLevel > lpEntityInstance->nLevel )
; 3219 :                {
; 3220 :                   lpLastChild = lpNextHier;

	mov	ecx, DWORD PTR _lpNextHier$9[ebp]
	mov	DWORD PTR _lpLastChild$10[ebp], ecx

; 3221 :                   lpNextHier  = zGETPTR( lpLastChild->hNextHier );

	mov	edx, DWORD PTR _lpLastChild$10[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$9[ebp], eax

; 3222 :                }

	jmp	SHORT $LN8@fnCreateEn
$LN9@fnCreateEn:

; 3223 : 
; 3224 :                lpEntityInstance->hPrevHier = zGETHNDL( lpLastChild );

	mov	ecx, DWORD PTR _lpLastChild$10[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax

; 3225 :                lpEntityInstance->hNextHier = lpLastChild->hNextHier;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpLastChild$10[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR [eax+14], edx

; 3226 :                lpLastChild->hNextHier = hEntityInstance;

	mov	eax, DWORD PTR _lpLastChild$10[ebp]
	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [eax+14], ecx

; 3227 : 
; 3228 :                if ( lpEntityInstance->hNextHier )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+14], 0
	je	SHORT $LN48@fnCreateEn

; 3229 :                {
; 3230 :                   lpNextHier = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$9[ebp], eax

; 3231 :                   lpNextHier->hPrevHier = hEntityInstance;

	mov	edx, DWORD PTR _lpNextHier$9[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax
$LN48@fnCreateEn:

; 3232 :                }
; 3233 :             }
; 3234 :          }

	jmp	$LN28@fnCreateEn
$LN45@fnCreateEn:

; 3235 :          else
; 3236 :          {
; 3237 :             LPVIEWENTITY     lpWorkViewEnt;
; 3238 :             LPVIEWENTITYCSR  lpSearchCsr;
; 3239 :             LPENTITYINSTANCE lpSearchEntityInstance;
; 3240 :             LPENTITYINSTANCE lpNextHier;
; 3241 :             zSHORT           nParentHierNbr;
; 3242 :             zSHORT           nHierNbr;
; 3243 :             zSHORT           nLevel;
; 3244 : 
; 3245 :             // Here we take the first established cursor which is
; 3246 :             // hierarchically before the current entity instance
; 3247 :             // (knowing that it may in fact be the parent cursor itself)
; 3248 :             // and work forward from that entity instance in order to
; 3249 :             // find our correct hierarchical position
; 3250 : 
; 3251 :             lpSearchCsr = zGETPTR( lpViewEntityCsr->hPrevHier );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchCsr$11[ebp], eax
$LN10@fnCreateEn:

; 3252 :             while ( lpSearchCsr &&

	cmp	DWORD PTR _lpSearchCsr$11[ebp], 0
	je	SHORT $LN11@fnCreateEn
	mov	eax, DWORD PTR _lpSearchCsr$11[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN52@fnCreateEn
	mov	ecx, DWORD PTR _lpSearchCsr$11[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN11@fnCreateEn
$LN52@fnCreateEn:

; 3253 :                     (lpSearchCsr->hEntityInstance == 0 ||
; 3254 :                      lpSearchCsr->hEntityInstance == UNSET_CSR) )
; 3255 :             {
; 3256 :                lpSearchCsr = zGETPTR( lpSearchCsr->hPrevHier );

	mov	edx, DWORD PTR _lpSearchCsr$11[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchCsr$11[ebp], eax

; 3257 :             }

	jmp	SHORT $LN10@fnCreateEn
$LN11@fnCreateEn:

; 3258 : 
; 3259 :             // If no cursor was found, then we must have hit the root of a
; 3260 :             // Subobject view, so use the parent root cursor for the view.
; 3261 :             if ( lpSearchCsr )

	cmp	DWORD PTR _lpSearchCsr$11[ebp], 0
	je	SHORT $LN53@fnCreateEn

; 3262 :                lpSearchEntityInstance = zGETPTR( lpSearchCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpSearchCsr$11[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$14[ebp], eax
	jmp	SHORT $LN54@fnCreateEn
$LN53@fnCreateEn:

; 3263 :             else
; 3264 :                lpSearchEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$14[ebp], eax
$LN54@fnCreateEn:

; 3265 : 
; 3266 :             if ( lpSearchEntityInstance->nLevel >= lpEntityInstance->nLevel )

	mov	edx, DWORD PTR _lpSearchEntityInstance$14[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jl	SHORT $LN55@fnCreateEn
$LN12@fnCreateEn:

; 3267 :             {
; 3268 :                while ( lpSearchEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpSearchEntityInstance$14[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN55@fnCreateEn

; 3269 :                   lpSearchEntityInstance = zGETPTR( lpSearchEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$14[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntityInstance$14[ebp], eax
	jmp	SHORT $LN12@fnCreateEn
$LN55@fnCreateEn:

; 3270 :             }
; 3271 : 
; 3272 :             // Now to set hierarchical cursor using a forward entity
; 3273 :             // instance search.
; 3274 :             lpNextHier     = zGETPTR( lpSearchEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSearchEntityInstance$14[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$13[ebp], eax

; 3275 :             nLevel         = lpViewEntityCsr->nLevel;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ax, WORD PTR [edx+22]
	mov	WORD PTR _nLevel$17[ebp], ax

; 3276 :             lpWorkViewEnt  = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEnt$6[ebp], eax

; 3277 :             nHierNbr       = lpWorkViewEnt->nHierNbr;

	mov	eax, DWORD PTR _lpWorkViewEnt$6[ebp]
	mov	cx, WORD PTR [eax+217]
	mov	WORD PTR _nHierNbr$18[ebp], cx

; 3278 : 
; 3279 :             // Found a condition (whacked account.vml) in which lpParentEntityInstance is null.  Don't
; 3280 :             // know why, but by protecting the following code, seems to be OK.  dks 2010.02.24
; 3281 :             if ( lpParentEntityInstance )

	cmp	DWORD PTR _lpParentEntityInstance$[ebp], 0
	je	SHORT $LN14@fnCreateEn

; 3282 :             {
; 3283 :                lpWorkViewEnt  = zGETPTR( lpParentEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEnt$6[ebp], eax

; 3284 :                nParentHierNbr = lpWorkViewEnt->nHierNbr;

	mov	ecx, DWORD PTR _lpWorkViewEnt$6[ebp]
	mov	dx, WORD PTR [ecx+217]
	mov	WORD PTR _nParentHierNbr$16[ebp], dx
$LN14@fnCreateEn:

; 3285 :             }
; 3286 :          // else
; 3287 :          //    nParentHierNbr = nHierNbr - 1;
; 3288 : 
; 3289 :             while ( lpNextHier )

	cmp	DWORD PTR _lpNextHier$13[ebp], 0
	je	SHORT $LN15@fnCreateEn

; 3290 :             {
; 3291 :                lpWorkViewEnt = zGETPTR( lpNextHier->hViewEntity );

	mov	eax, DWORD PTR _lpNextHier$13[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEnt$6[ebp], eax

; 3292 : 
; 3293 :                if ( lpNextHier->nLevel > lpViewEntityCsr->nLevel ||

	mov	edx, DWORD PTR _lpNextHier$13[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jg	SHORT $LN59@fnCreateEn
	mov	eax, DWORD PTR _lpNextHier$13[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	cmp	ecx, eax
	jne	SHORT $LN57@fnCreateEn
	mov	ecx, DWORD PTR _lpWorkViewEnt$6[ebp]
	movsx	edx, WORD PTR [ecx+217]
	movsx	eax, WORD PTR _nHierNbr$18[ebp]
	cmp	edx, eax
	jge	SHORT $LN57@fnCreateEn
$LN59@fnCreateEn:

; 3294 :                     (lpNextHier->nLevel == lpViewEntityCsr->nLevel &&
; 3295 :                      lpWorkViewEnt->nHierNbr < nHierNbr) )
; 3296 :                {
; 3297 :                   lpSearchEntityInstance = lpNextHier;

	mov	ecx, DWORD PTR _lpNextHier$13[ebp]
	mov	DWORD PTR _lpSearchEntityInstance$14[ebp], ecx

; 3298 :                   lpNextHier             = zGETPTR( lpNextHier->hNextHier );

	mov	edx, DWORD PTR _lpNextHier$13[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$13[ebp], eax

; 3299 :                }

	jmp	SHORT $LN58@fnCreateEn
$LN57@fnCreateEn:

; 3300 :                else
; 3301 :                   break;

	jmp	SHORT $LN15@fnCreateEn
$LN58@fnCreateEn:

; 3302 :             }

	jmp	SHORT $LN14@fnCreateEn
$LN15@fnCreateEn:

; 3303 : 
; 3304 :             lpEntityInstance->hPrevHier = zGETHNDL( lpSearchEntityInstance );

	mov	ecx, DWORD PTR _lpSearchEntityInstance$14[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax

; 3305 :             lpEntityInstance->hNextHier = lpSearchEntityInstance->hNextHier;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpSearchEntityInstance$14[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR [eax+14], edx

; 3306 :             lpSearchEntityInstance->hNextHier = hEntityInstance;

	mov	eax, DWORD PTR _lpSearchEntityInstance$14[ebp]
	mov	ecx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [eax+14], ecx

; 3307 :             lpNextHier = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$13[ebp], eax

; 3308 :             if ( lpEntityInstance->hNextHier )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+14], 0
	je	SHORT $LN28@fnCreateEn

; 3309 :                lpNextHier->hPrevHier = hEntityInstance;

	mov	edx, DWORD PTR _lpNextHier$13[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+18], eax
$LN28@fnCreateEn:

; 3310 : 
; 3311 :          }    // END else for previouse twin not end of inst chain
; 3312 :       }       // END else for new entity has no next twin
; 3313 :    }          // END else for this entity is not a new root
; 3314 : 
; 3315 :    // Finally, set the cursor for the entity and null the child cursors.
; 3316 :    lpViewEntityCsr->hEntityInstance = hEntityInstance;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [ecx+26], edx

; 3317 : // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 3318 : //    SysMessageBox( 0, "fnCreateEntity", "UNSET_CSR", -1 );
; 3319 : 
; 3320 :    if ( lpTwinEntityInstance )

	cmp	DWORD PTR _lpTwinEntityInstance$[ebp], 0
	je	SHORT $LN61@fnCreateEn

; 3321 :       fnNullCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnNullCursorForViewChildren
	add	esp, 4
$LN61@fnCreateEn:

; 3322 : 
; 3323 :    // Now that the entity had been created, update any other views
; 3324 :    // which have a cursor position on the new entity instance's
; 3325 :    // parent. If the entity is a new root, set the instance pointer
; 3326 :    // in all views, otherwise, if the entity cursor for the other
; 3327 :    // views is NULL, invalidate the pointer to force resetting in case
; 3328 :    // the newly created entity belongs in that cursor (we skip the
; 3329 :    // overhead of determining that fact now).
; 3330 :    lpSearchViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewCsr$[ebp], eax

; 3331 :    if ( lpSearchViewCsr == lpViewCsr )

	mov	eax, DWORD PTR _lpSearchViewCsr$[ebp]
	cmp	eax, DWORD PTR _lpViewCsr$[ebp]
	jne	SHORT $LN62@fnCreateEn

; 3332 :       lpSearchViewCsr = zGETPTR( lpSearchViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpSearchViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewCsr$[ebp], eax
$LN62@fnCreateEn:

; 3333 : 
; 3334 :    if ( lpSearchViewCsr )

	cmp	DWORD PTR _lpSearchViewCsr$[ebp], 0
	je	$LN63@fnCreateEn

; 3335 :    {
; 3336 :       LPVIEWENTITYCSR  lpSearchViewEntityCsr;
; 3337 :       LPVIEWENTITY     lpSearchViewEntity;
; 3338 :       zSHORT           nRelativeCsr;
; 3339 :       zSHORT           nRelativeRecursCsr;
; 3340 : 
; 3341 :       nRelativeCsr = lpViewEntity->nHierNbr - 1;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	mov	WORD PTR _nRelativeCsr$19[ebp], cx

; 3342 :       nRelativeRecursCsr = 0;

	xor	edx, edx
	mov	WORD PTR _nRelativeRecursCsr$20[ebp], dx

; 3343 : 
; 3344 :       // If there are other view cursors to this object instance, see if
; 3345 :       // the entity in question is a recursive entity type, this will
; 3346 :       // be true if either the ViewSubobject is set from above OR the
; 3347 :       // view entity for the current entity cursor is marked as recursive.
; 3348 :       // If so, then set nRelativeRecursCsr to the second entity cursor in
; 3349 :       // the subobject which may represent the entity in question.
; 3350 :       if ( lpViewSubobject )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	je	SHORT $LN64@fnCreateEn

; 3351 :       {
; 3352 :          if ( lpViewSubobject->hRecursViewEntity )

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN66@fnCreateEn

; 3353 :          {
; 3354 :             lpSearchViewEntity = zGETPTR( lpViewSubobject->hRecursViewEntity );

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$8[ebp], eax

; 3355 :             nRelativeRecursCsr = lpSearchViewEntity->nHierNbr - 1;

	mov	eax, DWORD PTR _lpSearchViewEntity$8[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	mov	WORD PTR _nRelativeRecursCsr$20[ebp], cx

; 3356 :          }

	jmp	SHORT $LN67@fnCreateEn
$LN66@fnCreateEn:

; 3357 :          else
; 3358 :          {
; 3359 :             TraceLine( "fnCreateEntity ERROR locating RecursViewEntity for lpViewSubobject: 0x%08x",

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	push	edx
	push	OFFSET $SG14403
	call	_TraceLine
	add	esp, 8
$LN67@fnCreateEn:

; 3360 :                        lpViewSubobject );
; 3361 :          }
; 3362 :       }

	jmp	SHORT $LN18@fnCreateEn
$LN64@fnCreateEn:

; 3363 :       else
; 3364 :       if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN18@fnCreateEn

; 3365 :       {
; 3366 :          nRelativeRecursCsr = nRelativeCsr;

	mov	dx, WORD PTR _nRelativeCsr$19[ebp]
	mov	WORD PTR _nRelativeRecursCsr$20[ebp], dx

; 3367 :          lpSearchViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$8[ebp], eax
$LN16@fnCreateEn:

; 3368 :          while ( lpSearchViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	edx, DWORD PTR _lpSearchViewEntity$8[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $LN17@fnCreateEn

; 3369 :             lpSearchViewEntity = zGETPTR( lpSearchViewEntity->hParent );

	mov	edx, DWORD PTR _lpSearchViewEntity$8[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$8[ebp], eax
	jmp	SHORT $LN16@fnCreateEn
$LN17@fnCreateEn:

; 3370 : 
; 3371 :          nRelativeCsr = lpSearchViewEntity->nHierNbr - 1;

	mov	ecx, DWORD PTR _lpSearchViewEntity$8[ebp]
	movsx	edx, WORD PTR [ecx+217]
	sub	edx, 1
	mov	WORD PTR _nRelativeCsr$19[ebp], dx
$LN18@fnCreateEn:

; 3372 :       }
; 3373 : 
; 3374 :       while ( lpSearchViewCsr )

	cmp	DWORD PTR _lpSearchViewCsr$[ebp], 0
	je	$LN63@fnCreateEn

; 3375 :       {
; 3376 :          if ( lpSearchViewCsr != lpViewCsr )

	mov	eax, DWORD PTR _lpSearchViewCsr$[ebp]
	cmp	eax, DWORD PTR _lpViewCsr$[ebp]
	je	$LN69@fnCreateEn

; 3377 :          {
; 3378 :             lpSearchViewEntityCsr =

	mov	ecx, DWORD PTR _lpSearchViewCsr$[ebp]
	add	ecx, 46					; 0000002eH
	mov	DWORD PTR _lpSearchViewEntityCsr$15[ebp], ecx

; 3379 :                            (LPVIEWENTITYCSR) (lpSearchViewCsr + 1);
; 3380 :             lpSearchViewEntityCsr += nRelativeCsr;

	movsx	edx, WORD PTR _nRelativeCsr$19[ebp]
	imul	eax, edx, 30
	add	eax, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	mov	DWORD PTR _lpSearchViewEntityCsr$15[ebp], eax

; 3381 :             if ( bNewRoot || lpRootEntityInstance == 0 )

	movsx	ecx, WORD PTR _bNewRoot$[ebp]
	test	ecx, ecx
	jne	SHORT $LN72@fnCreateEn
	cmp	DWORD PTR _lpRootEntityInstance$[ebp], 0
	jne	SHORT $LN70@fnCreateEn
$LN72@fnCreateEn:

; 3382 :             {
; 3383 :                lpSearchViewEntityCsr->hEntityInstance = hEntityInstance;

	mov	edx, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	mov	eax, DWORD PTR _hEntityInstance$[ebp]
	mov	DWORD PTR [edx+26], eax

; 3384 :             // if ( lpSearchViewEntityCsr->hEntityInstance == UNSET_CSR )
; 3385 :             //    SysMessageBox( 0, "fnCreateEntity2", "UNSET_CSR", -1 );
; 3386 :             }

	jmp	SHORT $LN69@fnCreateEn
$LN70@fnCreateEn:

; 3387 :             else
; 3388 :             {
; 3389 :                if ( lpSearchViewEntityCsr->nLevel == lpViewEntityCsr->nLevel &&

	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	cmp	edx, ecx
	jne	SHORT $LN73@fnCreateEn
	mov	edx, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	cmp	DWORD PTR [edx+26], 0
	jne	SHORT $LN73@fnCreateEn

; 3390 :                     lpSearchViewEntityCsr->hEntityInstance == 0 )
; 3391 :                {
; 3392 :                   lpSearchViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	mov	DWORD PTR [eax+26], 1

; 3393 :                // if ( lpSearchViewEntityCsr->hEntityInstance == UNSET_CSR )  // happens too much
; 3394 :                //    SysMessageBox( 0, "fnCreateEntity3", "UNSET_CSR", -1 );
; 3395 :                }

	jmp	SHORT $LN69@fnCreateEn
$LN73@fnCreateEn:

; 3396 :                else
; 3397 :                if ( nRelativeRecursCsr )

	movsx	ecx, WORD PTR _nRelativeRecursCsr$20[ebp]
	test	ecx, ecx
	je	SHORT $LN69@fnCreateEn

; 3398 :                {
; 3399 :                   lpSearchViewEntityCsr = (LPVIEWENTITYCSR) (lpSearchViewCsr + 1);

	mov	edx, DWORD PTR _lpSearchViewCsr$[ebp]
	add	edx, 46					; 0000002eH
	mov	DWORD PTR _lpSearchViewEntityCsr$15[ebp], edx

; 3400 :                   lpSearchViewEntityCsr += nRelativeRecursCsr;

	movsx	eax, WORD PTR _nRelativeRecursCsr$20[ebp]
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	mov	DWORD PTR _lpSearchViewEntityCsr$15[ebp], ecx

; 3401 :                   if ( lpSearchViewEntityCsr->nLevel == lpViewEntityCsr->nLevel &&

	mov	edx, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jne	SHORT $LN69@fnCreateEn
	mov	eax, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN69@fnCreateEn

; 3402 :                        lpSearchViewEntityCsr->hEntityInstance == 0 )
; 3403 :                   {
; 3404 :                      lpSearchViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$15[ebp]
	mov	DWORD PTR [ecx+26], 1
$LN69@fnCreateEn:

; 3405 :                   // if ( lpSearchViewEntityCsr->hEntityInstance == UNSET_CSR )  // happens too much
; 3406 :                   //    SysMessageBox( 0, "fnCreateEntity4", "UNSET_CSR", -1 );
; 3407 :                   }
; 3408 :                }
; 3409 :             }
; 3410 :          }
; 3411 : 
; 3412 :          lpSearchViewCsr = zGETPTR( lpSearchViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpSearchViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewCsr$[ebp], eax

; 3413 :       }

	jmp	$LN18@fnCreateEn
$LN63@fnCreateEn:

; 3414 :    }
; 3415 : 
; 3416 :    fnAddEntityToDebugChange( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnAddEntityToDebugChange@4

; 3417 : 
; 3418 :    return( 0 );  // entity instance created successfully

	xor	eax, eax
$LN1@fnCreateEn:

; 3419 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN78@fnCreateEn:
	DD	$LN37@fnCreateEn
	DD	$LN39@fnCreateEn
	DD	$LN31@fnCreateEn
	DD	$LN34@fnCreateEn
_fnCreateEntity@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
tv69 = -4						; size = 4
_lpTask$ = 8						; size = 4
_lpOwningTask$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_fnSetEntityKey@12 PROC

; 2915 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2916 :    // lpOwningTask is not required, so set it.
; 2917 :    if ( lpOwningTask == 0 )

	cmp	DWORD PTR _lpOwningTask$[ebp], 0
	jne	SHORT $LN2@fnSetEntit

; 2918 :       lpOwningTask = lpTask;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$LN2@fnSetEntit:

; 2919 : 
; 2920 : // if ( lpOwningTask->lTaskID == AnchorBlock->lMainTaskID )
; 2921 : // if ( zGETHNDL( lpOwningTask ) == zGETHNDL( AnchorBlock) )
; 2922 :       zLOCK_MUTEX( zMUTEX_ENTITYKEY );

	push	11					; 0000000bH
	call	_fnSysLockCoreMutex@4

; 2923 : 
; 2924 :    lpEntityInstance->ulKey = ++(lpOwningTask->ulCurrentEntityKey);

	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	mov	edx, DWORD PTR [ecx+154]
	add	edx, 1
	mov	DWORD PTR tv69[ebp], edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR [eax+154], ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR [edx+50], eax

; 2925 : 
; 2926 : // if ( lpOwningTask->lTaskID == AnchorBlock->lMainTaskID )
; 2927 : // if ( zGETHNDL( lpOwningTask ) == zGETHNDL( AnchorBlock) )
; 2928 :       zUNLOCK_MUTEX( zMUTEX_ENTITYKEY );

	push	11					; 0000000bH
	call	_fnSysUnlockCoreMutex@4

; 2929 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSetEntityKey@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpEntityInstance$ = 8					; size = 4
_fnEntityInstanceIsDead@4 PROC

; 4209 : {

	push	ebp
	mov	ebp, esp

; 4210 :    // If the instance isn't hidden it can't be dead.
; 4211 :    if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN2@fnEntityIn

; 4212 :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnEntityIn
$LN2@fnEntityIn:

; 4213 : 
; 4214 :    // Instances with previous versions aren't dead.
; 4215 :    if ( lpEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN3@fnEntityIn

; 4216 :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnEntityIn
$LN3@fnEntityIn:

; 4217 : 
; 4218 :    if ( lpEntityInstance->u.nInd.bCreated == FALSE &&
; 4219 :         lpEntityInstance->u.nInd.bIncluded == FALSE &&

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN4@fnEntityIn
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	jne	SHORT $LN4@fnEntityIn
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN5@fnEntityIn
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN4@fnEntityIn
$LN5@fnEntityIn:

; 4220 :         (lpEntityInstance->u.nInd.bExcluded ||
; 4221 :          lpEntityInstance->u.nInd.bDeleted) )
; 4222 :    {
; 4223 :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@fnEntityIn
$LN4@fnEntityIn:

; 4224 :    }
; 4225 : 
; 4226 :    // If we get here then instance is dead.
; 4227 :    return( TRUE );

	mov	eax, 1
$LN1@fnEntityIn:

; 4228 : }

	pop	ebp
	ret	4
_fnEntityInstanceIsDead@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -36				; size = 4
_lCount$ = -32						; size = 4
_lpViewEntity$ = -28					; size = 4
_lpViewEntityCsr$ = -24					; size = 4
_lpCurrentTask$ = -20					; size = 4
_lpScopingViewEntityCsr$ = -16				; size = 4
_lpEntityInstance$ = -12				; size = 4
_nLevel$ = -8						; size = 2
_nStopLevel$ = -4					; size = 2
_zView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcScopingEntityName$ = 16				; size = 4
_CountEntitiesForViewUnderParent@12 PROC

; 1151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1152 :    LPTASK            lpCurrentTask;
; 1153 :    LPVIEWENTITY      lpViewEntity;
; 1154 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1155 :    LPVIEWENTITY      lpScopingViewEntity;
; 1156 :    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 1157 :    LPENTITYINSTANCE  lpEntityInstance;
; 1158 :    zLONG             lCount = 0;

	mov	DWORD PTR _lCount$[ebp], 0

; 1159 :    zSHORT            nStopLevel;
; 1160 :    zSHORT            nLevel;
; 1161 : 
; 1162 :    if ( cpcScopingEntityName == 0 || cpcScopingEntityName[ 0 ] == 0 )

	cmp	DWORD PTR _cpcScopingEntityName$[ebp], 0
	je	SHORT $LN7@CountEntit
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcScopingEntityName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN6@CountEntit
$LN7@CountEntit:

; 1163 :    {
; 1164 :       // No scoping entity is really just like...
; 1165 :       return( CountEntitiesForView( zView, cpcEntityName ) );

	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	call	_CountEntitiesForView@8
	jmp	$LN1@CountEntit
$LN6@CountEntit:

; 1166 :    }
; 1167 : 
; 1168 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcScopingEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	push	131					; 00000083H
	lea	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpScopingViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN8@CountEntit

; 1169 :                                       &lpScopingViewEntity,
; 1170 :                                       &lpScopingViewEntityCsr,
; 1171 :                                       iCountEntitiesForViewUnderParent,
; 1172 :                                       zView,
; 1173 :                                       cpcScopingEntityName, 0 ) )
; 1174 :    {
; 1175 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CountEntit
$LN8@CountEntit:

; 1176 :    }
; 1177 : 
; 1178 :    // If no current entity instance for scoping entity return zero.
; 1179 :    if ( lpScopingViewEntityCsr->hEntityInstance == 0 ||

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN10@CountEntit
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN9@CountEntit
$LN10@CountEntit:

; 1180 :         lpScopingViewEntityCsr->hEntityInstance == UNSET_CSR )
; 1181 :    {
; 1182 :       fnOperationReturn( iCountEntitiesForViewUnderParent, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	131					; 00000083H
	call	_fnOperationReturn
	add	esp, 8

; 1183 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@CountEntit
$LN9@CountEntit:

; 1184 :    }
; 1185 : 
; 1186 :    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1187 :    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN11@CountEntit

; 1188 :    {
; 1189 :       fnOperationReturn( iCountEntitiesForViewUnderParent, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	131					; 00000083H
	call	_fnOperationReturn
	add	esp, 8

; 1190 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CountEntit
$LN11@CountEntit:

; 1191 :    }
; 1192 : 
; 1193 :    if ( lpViewEntityCsr->hEntityInstance == 0 ||

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN14@CountEntit
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	$LN12@CountEntit
$LN14@CountEntit:

; 1194 :         lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 1195 :    {
; 1196 :       // We need to find the first entity instance with a view entity
; 1197 :       // matching lpViewEntity.
; 1198 :       lpEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1199 :       nStopLevel       = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nStopLevel$[ebp], ax

; 1200 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN2@CountEntit:

; 1201 : 
; 1202 :       while ( lpEntityInstance &&
; 1203 :               zGETPTR( lpEntityInstance->hViewEntity ) != lpViewEntity &&

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN3@CountEntit
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN3@CountEntit
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nStopLevel$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN3@CountEntit

; 1204 :               lpEntityInstance->nLevel > nStopLevel )
; 1205 :       {
; 1206 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1207 :       }

	jmp	SHORT $LN2@CountEntit
$LN3@CountEntit:

; 1208 : 
; 1209 :       // If following condition is true then we never found a matching entity.
; 1210 :       if ( lpEntityInstance == 0 || lpEntityInstance->nLevel <= nStopLevel )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN16@CountEntit
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStopLevel$[ebp]
	cmp	edx, eax
	jg	SHORT $LN15@CountEntit
$LN16@CountEntit:

; 1211 :       {
; 1212 :          fnOperationReturn( iCountEntitiesForViewUnderParent, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	131					; 00000083H
	call	_fnOperationReturn
	add	esp, 8

; 1213 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CountEntit
$LN15@CountEntit:

; 1214 :       }
; 1215 : 
; 1216 :       nLevel           = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$[ebp], ax

; 1217 :       lpEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1218 :    }

	jmp	SHORT $LN13@CountEntit
$LN12@CountEntit:

; 1219 :    else
; 1220 :    {
; 1221 : 
; 1222 :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1223 :       nLevel           = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$[ebp], ax
$LN13@CountEntit:

; 1224 :    }
; 1225 : 
; 1226 :    lpEntityInstance = zGETPTR( lpScopingViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1227 :    nStopLevel       = lpEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nStopLevel$[ebp], cx
$LN4@CountEntit:

; 1228 : 
; 1229 :    while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN5@CountEntit

; 1230 :    {
; 1231 :       if ( lpEntityInstance->u.nInd.bHidden == FALSE &&
; 1232 :            lpEntityInstance->nLevel == nLevel &&

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN17@CountEntit
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	edx, eax
	jne	SHORT $LN17@CountEntit
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	jne	SHORT $LN17@CountEntit

; 1233 :            zGETPTR( lpEntityInstance->hViewEntity ) == lpViewEntity )
; 1234 :       {
; 1235 :          lCount++;

	mov	eax, DWORD PTR _lCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lCount$[ebp], eax
$LN17@CountEntit:

; 1236 :       }
; 1237 : 
; 1238 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1239 : 
; 1240 :       if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN18@CountEntit

; 1241 :          break;

	jmp	SHORT $LN5@CountEntit
$LN18@CountEntit:

; 1242 : 
; 1243 :       if ( lpEntityInstance->nLevel <= nStopLevel )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStopLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN19@CountEntit

; 1244 :          break;

	jmp	SHORT $LN5@CountEntit
$LN19@CountEntit:

; 1245 :    }

	jmp	SHORT $LN4@CountEntit
$LN5@CountEntit:

; 1246 : 
; 1247 :    fnOperationReturn( iCountEntitiesForViewUnderParent, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	131					; 00000083H
	call	_fnOperationReturn
	add	esp, 8

; 1248 :    return( lCount );

	mov	eax, DWORD PTR _lCount$[ebp]
$LN1@CountEntit:

; 1249 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CountEntitiesForViewUnderParent@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lCount$ = -12						; size = 4
_lpCurrentTask$ = -8					; size = 4
_lpEntityInstance$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_CountEntitiesForView@8 PROC

; 892  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 893  :    LPTASK            lpCurrentTask;
; 894  :    LPVIEWENTITY      lpViewEntity;
; 895  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 896  :    LPENTITYINSTANCE  lpEntityInstance;
; 897  :    zLONG             lCount = 0;

	mov	DWORD PTR _lCount$[ebp], 0

; 898  : 
; 899  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 900  :    if ( (lpCurrentTask = fnOperationCall( iCountEntitiesForView, lpView,
; 901  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	123					; 0000007bH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN6@CountEntit

; 902  :    {
; 903  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CountEntit
$LN6@CountEntit:

; 904  :    }
; 905  : 
; 906  :    // Validate that the entity exists
; 907  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 908  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN7@CountEntit

; 909  :    {
; 910  :       fnOperationReturn( iCountEntitiesForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	123					; 0000007bH
	call	_fnOperationReturn
	add	esp, 8

; 911  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CountEntit
$LN7@CountEntit:

; 912  :    }
; 913  : 
; 914  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 915  :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN8@CountEntit

; 916  :       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN8@CountEntit:

; 917  : 
; 918  :    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN9@CountEntit
$LN2@CountEntit:

; 919  :    {
; 920  :       // go to first instance
; 921  :       while ( lpEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN4@CountEntit

; 922  :          lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN2@CountEntit
$LN4@CountEntit:

; 923  : 
; 924  :       // scan the twin pointers and count all the unhidden instances
; 925  :       while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN9@CountEntit

; 926  :       {
; 927  :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN10@CountEntit

; 928  :             lCount++;

	mov	ecx, DWORD PTR _lCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lCount$[ebp], ecx
$LN10@CountEntit:

; 929  : 
; 930  :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 931  :       }

	jmp	SHORT $LN4@CountEntit
$LN9@CountEntit:

; 932  :    }
; 933  : 
; 934  :    fnOperationReturn( iCountEntitiesForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	123					; 0000007bH
	call	_fnOperationReturn
	add	esp, 8

; 935  :    return( lCount );

	mov	eax, DWORD PTR _lCount$[ebp]
$LN1@CountEntit:

; 936  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CountEntitiesForView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpTgtOwningTask$ = -272				; size = 4
_lpSrcOwningTask$ = -268				; size = 4
_lpTgtViewEntityCsr$ = -264				; size = 4
_lpSrcViewEntityCsr$ = -260				; size = 4
_lpTgtEntityInstance$ = -256				; size = 4
_lpSrcEntityInstance$ = -252				; size = 4
tv177 = -248						; size = 4
tv176 = -244						; size = 4
_lpTgtViewEntity$ = -240				; size = 4
_lpViewOI$ = -236					; size = 4
_lpViewCsr$ = -232					; size = 4
_nRC$ = -228						; size = 2
_szYN$ = -224						; size = 2
_lpSrcViewEntity$ = -220				; size = 4
_lpSrcViewOD$ = -216					; size = 4
_lpTgtViewOD$ = -212					; size = 4
_lpCurrentTask$ = -208					; size = 4
_szMsg$1 = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_zTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_zSrcView$ = 16						; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_RelinkInstanceToInstance@16 PROC

; 1867 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1868 :    LPTASK           lpCurrentTask;
; 1869 :    LPTASK           lpSrcOwningTask;
; 1870 :    LPTASK           lpTgtOwningTask;
; 1871 :    LPVIEWOD         lpSrcViewOD;
; 1872 :    LPVIEWOD         lpTgtViewOD;
; 1873 :    LPVIEWCSR        lpViewCsr;
; 1874 :    LPVIEWOI         lpViewOI;
; 1875 :    LPVIEWENTITY     lpSrcViewEntity;
; 1876 :    LPVIEWENTITYCSR  lpSrcViewEntityCsr;
; 1877 :    LPVIEWENTITY     lpTgtViewEntity;
; 1878 :    LPVIEWENTITYCSR  lpTgtViewEntityCsr;
; 1879 :    LPENTITYINSTANCE lpSrcEntityInstance;
; 1880 :    LPENTITYINSTANCE lpTgtEntityInstance;
; 1881 :    zCHAR            szYN[ 2 ];
; 1882 :    zSHORT           nRC;
; 1883 : 
; 1884 :    // Validate parameters
; 1885 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _zSrcView$[ebp]
	push	ecx
	push	116					; 00000074H
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@RelinkInst

; 1886 :                                       &lpSrcViewEntity,
; 1887 :                                       &lpSrcViewEntityCsr,
; 1888 :                                       iRelinkInstanceToInstance,
; 1889 :                                       zSrcView,
; 1890 :                                       cpcSrcEntityName, 0 ) )
; 1891 :    {
; 1892 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkInst
$LN2@RelinkInst:

; 1893 :    }
; 1894 : 
; 1895 :    // Validate parameters
; 1896 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	2
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _zTgtView$[ebp]
	push	ecx
	push	116					; 00000074H
	lea	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@RelinkInst

; 1897 :                                       &lpTgtViewEntity,
; 1898 :                                       &lpTgtViewEntityCsr,
; 1899 :                                       iRelinkInstanceToInstance,
; 1900 :                                       zTgtView,
; 1901 :                                       cpcTgtEntityName,
; 1902 :                                       2 ) )  // we already called once
; 1903 :    {
; 1904 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkInst
$LN3@RelinkInst:

; 1905 :    }
; 1906 : 
; 1907 :    // Make sure the target and source entity instances are the same
; 1908 :    // E/R Entity
; 1909 :    if ( lpSrcViewEntity->lEREntTok != lpTgtViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN4@RelinkInst

; 1910 :    {
; 1911 :       // "KZOEE125 - Target and Source Entities are not the same E/R Entity"
; 1912 :       fnIssueCoreError( lpCurrentTask, zSrcView, 8, 123, 0,

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	123					; 0000007bH
	push	8
	mov	edx, DWORD PTR _zSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1913 :                         lpTgtViewEntity->szName,
; 1914 :                         lpSrcViewEntity->szName );
; 1915 : 
; 1916 :       fnOperationReturn( iRelinkInstanceToInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	116					; 00000074H
	call	_fnOperationReturn
	add	esp, 8

; 1917 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkInst
$LN4@RelinkInst:

; 1918 :    }
; 1919 : 
; 1920 :    // Make sure entity can be included
; 1921 :    if ( lpSrcViewEntity->bInclSrc == FALSE )

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 5
	and	eax, 1
	jne	SHORT $LN5@RelinkInst

; 1922 :    {
; 1923 :       // "KZOEE106 - Rules violation"
; 1924 :       fnIssueCoreError( lpCurrentTask, zSrcView, 8, 106, 0,

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG13916
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _zSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1925 :                         "Source Entity not includeble",
; 1926 :                         lpSrcViewEntity->szName );
; 1927 :       fnOperationReturn( iRelinkInstanceToInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	116					; 00000074H
	call	_fnOperationReturn
	add	esp, 8

; 1928 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkInst
$LN5@RelinkInst:

; 1929 :    }
; 1930 : 
; 1931 :    // Make sure that the LODs are in sync.  They are out of sync if the LODs
; 1932 :    // were built with different dates for the ER.  We won't bother performing
; 1933 :    // the check if either LOD doesn't have the ER date.  This allows old LODs
; 1934 :    // to work.
; 1935 :    lpSrcViewOD = zGETPTR( zSrcView->hViewOD );

	mov	edx, DWORD PTR _zSrcView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOD$[ebp], eax

; 1936 :    lpTgtViewOD = zGETPTR( zTgtView->hViewOD );

	mov	ecx, DWORD PTR _zTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOD$[ebp], eax

; 1937 :    if ( lpSrcViewOD->szER_Date[ 0 ] && lpTgtViewOD->szER_Date[ 0 ] &&

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+248]
	test	eax, eax
	je	$LN6@RelinkInst
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+248]
	test	ecx, ecx
	je	$LN6@RelinkInst
	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+248]
	cmp	eax, edx
	jne	SHORT $LN12@RelinkInst
	mov	eax, DWORD PTR _lpTgtViewOD$[ebp]
	add	eax, 248				; 000000f8H
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN13@RelinkInst
$LN12@RelinkInst:
	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+248]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN10@RelinkInst
	mov	DWORD PTR tv176[ebp], 1
	jmp	SHORT $LN11@RelinkInst
$LN10@RelinkInst:
	mov	DWORD PTR tv176[ebp], -1
$LN11@RelinkInst:
	mov	eax, DWORD PTR tv176[ebp]
	mov	DWORD PTR tv177[ebp], eax
$LN13@RelinkInst:
	cmp	DWORD PTR tv177[ebp], 0
	je	$LN6@RelinkInst

; 1938 :         zstrcmp( lpSrcViewOD->szER_Date, lpTgtViewOD->szER_Date ) != 0 )
; 1939 :    {
; 1940 :       zCHAR szMsg[ 200 ];
; 1941 : 
; 1942 :       TraceLineS( "ERROR: ", "The following LODs are out of sync and should be re-built" );

	push	OFFSET $SG13918
	push	OFFSET $SG13919
	call	_TraceLineS@8

; 1943 : 
; 1944 :       zsprintf( szMsg, "Out-of-sync error. Target LOD = %s, date = %s",

	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG13920
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1945 :                 lpTgtViewOD->szName, lpTgtViewOD->szER_Date );
; 1946 :       TraceLineS( "   ==> ", szMsg );

	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	push	OFFSET $SG13921
	call	_TraceLineS@8

; 1947 : 
; 1948 :       zsprintf( szMsg, "Out-of-sync error. Source LOD = %s, date = %s",

	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	eax, DWORD PTR _lpSrcViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG13922
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1949 :                 lpSrcViewOD->szName, lpSrcViewOD->szER_Date );
; 1950 :       TraceLineS( "   ==> ", szMsg );

	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	push	OFFSET $SG13923
	call	_TraceLineS@8

; 1951 : 
; 1952 :       SysReadZeidonIni( -1, "[Workstation]", "SyncER/LOD", szYN );

	lea	eax, DWORD PTR _szYN$[ebp]
	push	eax
	push	OFFSET $SG13924
	push	OFFSET $SG13925
	push	-1
	call	_SysReadZeidonIni@16

; 1953 :       if ( szYN[ 0 ] != 'N' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szYN$[ebp+edx]
	cmp	eax, 78					; 0000004eH
	je	SHORT $LN6@RelinkInst

; 1954 :       {
; 1955 :          // "KZOEE106 - Rules violation"
; 1956 :          fnIssueCoreError( lpCurrentTask, zSrcView, 8, 106, 0,

	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG13927
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _zSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1957 :                            "LODs are potentially out of sync.  See trace for more.",
; 1958 :                            lpTgtViewOD->szName );
; 1959 : 
; 1960 :          fnOperationReturn( iRelinkInstanceToInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	116					; 00000074H
	call	_fnOperationReturn
	add	esp, 8

; 1961 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkInst
$LN6@RelinkInst:

; 1962 :       }
; 1963 :    }
; 1964 : 
; 1965 :    // Get the source and target task.
; 1966 :    lpViewCsr       = zGETPTR( zSrcView->hViewCsr );

	mov	edx, DWORD PTR _zSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1967 :    lpViewOI        = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1968 :    lpSrcOwningTask = zGETPTR( lpViewOI->hTask );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcOwningTask$[ebp], eax

; 1969 :    lpViewCsr       = zGETPTR( zTgtView->hViewCsr );

	mov	edx, DWORD PTR _zTgtView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1970 :    lpViewOI        = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1971 :    lpTgtOwningTask = zGETPTR( lpViewOI->hTask );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtOwningTask$[ebp], eax

; 1972 : 
; 1973 : #if 0
; 1974 :    if ( lpSrcOwningTask != lpTgtOwningTask )
; 1975 :    {
; 1976 :       if ( lpSrcOwningTask != zGETPTR( AnchorBlock->hMainTask ) )
; 1977 :       {
; 1978 :          // "KZOEE131 - Attempt to include Subobject from another "
; 1979 :          // "           Application Task"
; 1980 :          fnIssueCoreError( zSrcView, lpView, 8, 131, 0, 0, 0 );
; 1981 :          fnOperationReturn( iRelinkInstanceToInstance, lpCurrentTask );
; 1982 :          return( zCALL_ERROR );
; 1983 :       }
; 1984 : 
; 1985 :       // lpViewOI is still set to the Tgt view OI.
; 1986 :       lpViewOI->hAllocTask = zGETHNDL( lpSrcOwningTask );
; 1987 :    }
; 1988 : #endif
; 1989 : 
; 1990 :    // Get the source and target instances
; 1991 :    lpSrcEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 1992 :    lpTgtEntityInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 1993 :    if ( !fnInstanceKeysMatch( lpTgtEntityInstance, lpSrcEntityInstance ) )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN8@RelinkInst

; 1994 :    {
; 1995 :       // "KZOEE117 - Entity Instance Keys do not match"
; 1996 :       fnIssueCoreError( lpCurrentTask, zSrcView, 8, 117, 0,

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	117					; 00000075H
	push	8
	mov	edx, DWORD PTR _zSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1997 :                         lpSrcViewEntity->szName,
; 1998 :                         lpTgtViewEntity->szName );
; 1999 :       fnOperationReturn( iRelinkInstanceToInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	116					; 00000074H
	call	_fnOperationReturn
	add	esp, 8

; 2000 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@RelinkInst
$LN8@RelinkInst:

; 2001 :    }
; 2002 : 
; 2003 :    nRC = fnRelinkInstanceToInstance( lpTgtEntityInstance,

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	call	_fnRelinkInstanceToInstance
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2004 :                                      lpSrcEntityInstance );
; 2005 : 
; 2006 : 
; 2007 :    // Return to caller
; 2008 :    fnOperationReturn( iRelinkInstanceToInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	116					; 00000074H
	call	_fnOperationReturn
	add	esp, 8

; 2009 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@RelinkInst:

; 2010 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_RelinkInstanceToInstance@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -24					; size = 4
_lpViewEntityCsr$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
tv89 = -12						; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nOption$ = 16						; size = 2
_GetIncrementalUpdateFlags@12 PROC

; 2354 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2355 :    LPTASK           lpCurrentTask;
; 2356 :    LPVIEWENTITY     lpViewEntity;
; 2357 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 2358 :    LPENTITYINSTANCE lpEntityInstance;
; 2359 :    zSHORT           nRC;
; 2360 : 
; 2361 :    // If task not active or disabled, return zCALL_ERROR.
; 2362 :    if ( (lpCurrentTask = fnOperationCall( iGetIncrementalUpdateFlags,
; 2363 :                                           lpView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	120					; 00000078H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@GetIncreme

; 2364 :    {
; 2365 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetIncreme
$LN4@GetIncreme:

; 2366 :    }
; 2367 : 
; 2368 :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 2369 :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN5@GetIncreme

; 2370 :    {
; 2371 :       fnOperationReturn( iGetIncrementalUpdateFlags, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	120					; 00000078H
	call	_fnOperationReturn
	add	esp, 8

; 2372 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetIncreme
$LN5@GetIncreme:

; 2373 :    }
; 2374 : 
; 2375 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2376 :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN6@GetIncreme

; 2377 :    {
; 2378 :       fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4

; 2379 :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN6@GetIncreme:

; 2380 :    }
; 2381 : 
; 2382 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN7@GetIncreme

; 2383 :    {
; 2384 :       fnOperationReturn( iGetIncrementalUpdateFlags, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	120					; 00000078H
	call	_fnOperationReturn
	add	esp, 8

; 2385 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@GetIncreme
$LN7@GetIncreme:

; 2386 :    }
; 2387 : 
; 2388 :    // Cast the flag to zUSHORT for IBM/AIX.
; 2389 :    switch ( (zUSHORT) nOption )

	movzx	edx, WORD PTR _nOption$[ebp]
	mov	DWORD PTR tv89[ebp], edx
	cmp	DWORD PTR tv89[ebp], 2048		; 00000800H
	jg	SHORT $LN16@GetIncreme
	cmp	DWORD PTR tv89[ebp], 2048		; 00000800H
	je	SHORT $LN11@GetIncreme
	cmp	DWORD PTR tv89[ebp], 2
	je	SHORT $LN8@GetIncreme
	cmp	DWORD PTR tv89[ebp], 8
	je	SHORT $LN9@GetIncreme
	cmp	DWORD PTR tv89[ebp], 32			; 00000020H
	je	SHORT $LN10@GetIncreme
	jmp	SHORT $LN14@GetIncreme
$LN16@GetIncreme:
	cmp	DWORD PTR tv89[ebp], 16384		; 00004000H
	je	SHORT $LN12@GetIncreme
	cmp	DWORD PTR tv89[ebp], 32768		; 00008000H
	je	SHORT $LN13@GetIncreme
	jmp	SHORT $LN14@GetIncreme
$LN8@GetIncreme:

; 2390 :    {
; 2391 :       case zSET_INCR_CREATED:
; 2392 :          nRC = lpEntityInstance->u.nInd.bCreated;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 2393 :          break;

	jmp	$LN2@GetIncreme
$LN9@GetIncreme:

; 2394 : 
; 2395 :       case zSET_INCR_UPDATED:
; 2396 :          nRC = lpEntityInstance->u.nInd.bUpdated;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 2397 :          break;

	jmp	SHORT $LN2@GetIncreme
$LN10@GetIncreme:

; 2398 : 
; 2399 :       case zSET_INCR_INCLUDED:
; 2400 :          nRC = lpEntityInstance->u.nInd.bIncluded;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 2401 :          break;

	jmp	SHORT $LN2@GetIncreme
$LN11@GetIncreme:

; 2402 : 
; 2403 :       case zSET_INCR_HANGING_ENTITY:
; 2404 :          nRC = lpEntityInstance->u.nInd.bHangingEntity;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 2405 :          break;

	jmp	SHORT $LN2@GetIncreme
$LN12@GetIncreme:

; 2406 : 
; 2407 :       case zSET_INCR_TEMPORAL_ENTITY:
; 2408 :          nRC = lpEntityInstance->u.nInd.bTemporal;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 2409 :          break;

	jmp	SHORT $LN2@GetIncreme
$LN13@GetIncreme:

; 2410 : 
; 2411 :       case zSET_INCR_DELETED:
; 2412 :          nRC = lpEntityInstance->u.nInd.bDeleted;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 2413 :          break;

	jmp	SHORT $LN2@GetIncreme
$LN14@GetIncreme:

; 2414 : 
; 2415 :       default:
; 2416 :          //  "KZOEE120 - Invalid position parameter"
; 2417 :          fnIssueCoreError( lpCurrentTask, lpView, 16, 302, (zLONG) nOption, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nOption$[ebp]
	push	eax
	push	302					; 0000012eH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2418 :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN2@GetIncreme:

; 2419 :          break;
; 2420 :    }
; 2421 : 
; 2422 :    fnOperationReturn( iGetIncrementalUpdateFlags, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	120					; 00000078H
	call	_fnOperationReturn
	add	esp, 8

; 2423 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetIncreme:

; 2424 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_GetIncrementalUpdateFlags@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -92					; size = 4
tv209 = -88						; size = 4
tv202 = -84						; size = 4
tv195 = -80						; size = 4
tv190 = -76						; size = 4
tv183 = -72						; size = 4
tv178 = -68						; size = 4
tv165 = -64						; size = 4
tv160 = -60						; size = 4
tv153 = -56						; size = 4
tv95 = -52						; size = 4
_lpAttribFlags$1 = -48					; size = 4
_lpRootEntityInstance$ = -44				; size = 4
_lpViewEntityCsr$ = -40					; size = 4
_lpViewAttrib$2 = -36					; size = 4
_lpViewEntity$ = -32					; size = 4
_lpTempViewEntity$3 = -28				; size = 4
_lpCurrentTask$ = -24					; size = 4
_lpViewOI$ = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_bPersist$ = -11					; size = 1
_bAttrNotUpdated$ = -10					; size = 1
_bNotIncluded$ = -9					; size = 1
_bIncluded$ = -8					; size = 1
_bNotUpdated$ = -7					; size = 1
_bUpdated$ = -6						; size = 1
_bCreated$ = -5						; size = 1
_bWorkEntity$4 = -4					; size = 1
_bMustCheckOIUpdated$ = -3				; size = 1
_bAttrUpdated$ = -2					; size = 1
_bSingleEntity$ = -1					; size = 1
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nOption$ = 16						; size = 2
_SetIncrementalUpdateFlags@12 PROC

; 2081 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH

; 2082 :    zBOOL            bCreated;
; 2083 :    zBOOL            bPersist;
; 2084 :    zBOOL            bUpdated;
; 2085 :    zBOOL            bNotUpdated;
; 2086 :    zBOOL            bIncluded;
; 2087 :    zBOOL            bNotIncluded;
; 2088 :    zBOOL            bSingleEntity;
; 2089 :    zBOOL            bAttrUpdated;
; 2090 :    zBOOL            bAttrNotUpdated;
; 2091 :    LPTASK           lpCurrentTask;
; 2092 :    LPVIEWCSR        lpViewCsr;
; 2093 :    LPVIEWOI         lpViewOI;
; 2094 :    LPVIEWENTITY     lpViewEntity;
; 2095 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 2096 :    LPENTITYINSTANCE lpRootEntityInstance;
; 2097 :    LPENTITYINSTANCE lpEntityInstance;
; 2098 :    zBOOL            bMustCheckOIUpdated = FALSE;

	mov	BYTE PTR _bMustCheckOIUpdated$[ebp], 0

; 2099 : 
; 2100 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2101 :    if ( (lpCurrentTask = fnOperationCall( iSetIncrementalUpdateFlags, lpView,
; 2102 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	119					; 00000077H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN8@SetIncreme

; 2103 :    {
; 2104 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetIncreme
$LN8@SetIncreme:

; 2105 :    }
; 2106 : 
; 2107 :    if ( nOption == 0 )

	movsx	ecx, WORD PTR _nOption$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@SetIncreme

; 2108 :    {
; 2109 :       fnOperationReturn( iSetIncrementalUpdateFlags, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	119					; 00000077H
	call	_fnOperationReturn
	add	esp, 8

; 2110 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SetIncreme
$LN9@SetIncreme:

; 2111 :    }
; 2112 : 
; 2113 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2114 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2115 : 
; 2116 :    if ( cpcEntityName && cpcEntityName[ 0 ] )

	cmp	DWORD PTR _cpcEntityName$[ebp], 0
	je	$LN10@SetIncreme
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	$LN10@SetIncreme

; 2117 :    {
; 2118 :       if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 2119 :                                               lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN12@SetIncreme

; 2120 :       {
; 2121 :          fnOperationReturn( iSetIncrementalUpdateFlags, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	119					; 00000077H
	call	_fnOperationReturn
	add	esp, 8

; 2122 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetIncreme
$LN12@SetIncreme:

; 2123 :       }
; 2124 : 
; 2125 :       bSingleEntity = ((nOption & zSET_INCR_CURSORPOS) != 0);

	movsx	eax, WORD PTR _nOption$[ebp]
	and	eax, 128				; 00000080H
	je	SHORT $LN46@SetIncreme
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN47@SetIncreme
$LN46@SetIncreme:
	mov	DWORD PTR tv95[ebp], 0
$LN47@SetIncreme:
	mov	cl, BYTE PTR tv95[ebp]
	mov	BYTE PTR _bSingleEntity$[ebp], cl

; 2126 :       if ( bSingleEntity )

	movzx	edx, BYTE PTR _bSingleEntity$[ebp]
	test	edx, edx
	je	SHORT $LN13@SetIncreme

; 2127 :       {
; 2128 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2129 :          if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN14@SetIncreme

; 2130 :          {
; 2131 :             fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4

; 2132 :             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN14@SetIncreme:

; 2133 :          }
; 2134 : 
; 2135 :          if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN13@SetIncreme

; 2136 :          {
; 2137 :             fnOperationReturn( iSetIncrementalUpdateFlags, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	119					; 00000077H
	call	_fnOperationReturn
	add	esp, 8

; 2138 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@SetIncreme
$LN13@SetIncreme:

; 2139 :          }
; 2140 :       }
; 2141 :    }

	jmp	SHORT $LN11@SetIncreme
$LN10@SetIncreme:

; 2142 :    else
; 2143 :    {
; 2144 :       bSingleEntity = FALSE;

	mov	BYTE PTR _bSingleEntity$[ebp], 0

; 2145 :       lpViewEntity = 0;

	mov	DWORD PTR _lpViewEntity$[ebp], 0
$LN11@SetIncreme:

; 2146 :    }
; 2147 : 
; 2148 :    // Get the root of the object instance
; 2149 :    if ( bSingleEntity )

	movzx	eax, BYTE PTR _bSingleEntity$[ebp]
	test	eax, eax
	je	SHORT $LN16@SetIncreme

; 2150 :       lpRootEntityInstance = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpRootEntityInstance$[ebp], ecx
	jmp	SHORT $LN17@SetIncreme
$LN16@SetIncreme:

; 2151 :    else
; 2152 :       lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax
$LN17@SetIncreme:

; 2153 : 
; 2154 :    if ( lpRootEntityInstance == 0 )

	cmp	DWORD PTR _lpRootEntityInstance$[ebp], 0
	jne	SHORT $LN18@SetIncreme

; 2155 :    {
; 2156 :       fnOperationReturn( iSetIncrementalUpdateFlags, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	119					; 00000077H
	call	_fnOperationReturn
	add	esp, 8

; 2157 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SetIncreme
$LN18@SetIncreme:

; 2158 :    }
; 2159 : 
; 2160 :    bCreated  = ((nOption & zSET_INCR_CREATED ) != 0);

	movsx	edx, WORD PTR _nOption$[ebp]
	and	edx, 2
	je	SHORT $LN48@SetIncreme
	mov	DWORD PTR tv153[ebp], 1
	jmp	SHORT $LN49@SetIncreme
$LN48@SetIncreme:
	mov	DWORD PTR tv153[ebp], 0
$LN49@SetIncreme:
	mov	al, BYTE PTR tv153[ebp]
	mov	BYTE PTR _bCreated$[ebp], al

; 2161 :    if ( bCreated == FALSE )

	movzx	ecx, BYTE PTR _bCreated$[ebp]
	test	ecx, ecx
	jne	$LN19@SetIncreme

; 2162 :    {
; 2163 :       bPersist = ((nOption & zSET_INCR_PERSISTENT) != 0);

	movsx	edx, WORD PTR _nOption$[ebp]
	and	edx, 4
	je	SHORT $LN50@SetIncreme
	mov	DWORD PTR tv160[ebp], 1
	jmp	SHORT $LN51@SetIncreme
$LN50@SetIncreme:
	mov	DWORD PTR tv160[ebp], 0
$LN51@SetIncreme:
	mov	al, BYTE PTR tv160[ebp]
	mov	BYTE PTR _bPersist$[ebp], al

; 2164 :       bUpdated = ((nOption & zSET_INCR_UPDATED) != 0);

	movsx	ecx, WORD PTR _nOption$[ebp]
	and	ecx, 8
	je	SHORT $LN52@SetIncreme
	mov	DWORD PTR tv165[ebp], 1
	jmp	SHORT $LN53@SetIncreme
$LN52@SetIncreme:
	mov	DWORD PTR tv165[ebp], 0
$LN53@SetIncreme:
	mov	dl, BYTE PTR tv165[ebp]
	mov	BYTE PTR _bUpdated$[ebp], dl

; 2165 :       if ( bUpdated )

	movzx	eax, BYTE PTR _bUpdated$[ebp]
	test	eax, eax
	je	SHORT $LN20@SetIncreme

; 2166 :       {
; 2167 :          lpViewOI->bUpdated = lpViewOI->bUpdatedFile = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2168 :          bNotUpdated = 0;

	mov	BYTE PTR _bNotUpdated$[ebp], 0

; 2169 :       }

	jmp	SHORT $LN19@SetIncreme
$LN20@SetIncreme:

; 2170 :       else
; 2171 :       {
; 2172 :          bNotUpdated = ((nOption & zSET_INCR_NOT_UPDATED) != 0);

	movsx	ecx, WORD PTR _nOption$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN54@SetIncreme
	mov	DWORD PTR tv178[ebp], 1
	jmp	SHORT $LN55@SetIncreme
$LN54@SetIncreme:
	mov	DWORD PTR tv178[ebp], 0
$LN55@SetIncreme:
	mov	dl, BYTE PTR tv178[ebp]
	mov	BYTE PTR _bNotUpdated$[ebp], dl
$LN19@SetIncreme:

; 2173 :       }
; 2174 :    }
; 2175 : 
; 2176 :    bIncluded = ((nOption & zSET_INCR_INCLUDED) != 0);

	movsx	eax, WORD PTR _nOption$[ebp]
	and	eax, 32					; 00000020H
	je	SHORT $LN56@SetIncreme
	mov	DWORD PTR tv183[ebp], 1
	jmp	SHORT $LN57@SetIncreme
$LN56@SetIncreme:
	mov	DWORD PTR tv183[ebp], 0
$LN57@SetIncreme:
	mov	cl, BYTE PTR tv183[ebp]
	mov	BYTE PTR _bIncluded$[ebp], cl

; 2177 :    if ( bIncluded == FALSE )

	movzx	edx, BYTE PTR _bIncluded$[ebp]
	test	edx, edx
	jne	SHORT $LN22@SetIncreme

; 2178 :       bNotIncluded = ((nOption & zSET_INCR_NOT_INCLUDED) != 0);

	movsx	eax, WORD PTR _nOption$[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN58@SetIncreme
	mov	DWORD PTR tv190[ebp], 1
	jmp	SHORT $LN59@SetIncreme
$LN58@SetIncreme:
	mov	DWORD PTR tv190[ebp], 0
$LN59@SetIncreme:
	mov	cl, BYTE PTR tv190[ebp]
	mov	BYTE PTR _bNotIncluded$[ebp], cl
	jmp	SHORT $LN23@SetIncreme
$LN22@SetIncreme:

; 2179 :    else
; 2180 :       bNotIncluded = 0;

	mov	BYTE PTR _bNotIncluded$[ebp], 0
$LN23@SetIncreme:

; 2181 : 
; 2182 :    bAttrUpdated = ((nOption & zSET_INCR_ATTR_UPDATED) != 0);

	movsx	edx, WORD PTR _nOption$[ebp]
	and	edx, 4096				; 00001000H
	je	SHORT $LN60@SetIncreme
	mov	DWORD PTR tv195[ebp], 1
	jmp	SHORT $LN61@SetIncreme
$LN60@SetIncreme:
	mov	DWORD PTR tv195[ebp], 0
$LN61@SetIncreme:
	mov	al, BYTE PTR tv195[ebp]
	mov	BYTE PTR _bAttrUpdated$[ebp], al

; 2183 :    if ( bAttrUpdated == FALSE )

	movzx	ecx, BYTE PTR _bAttrUpdated$[ebp]
	test	ecx, ecx
	jne	SHORT $LN24@SetIncreme

; 2184 :       bAttrNotUpdated = ((nOption & zSET_INCR_ATTR_NOT_UPDATED) != 0);

	movsx	edx, WORD PTR _nOption$[ebp]
	and	edx, 8192				; 00002000H
	je	SHORT $LN62@SetIncreme
	mov	DWORD PTR tv202[ebp], 1
	jmp	SHORT $LN63@SetIncreme
$LN62@SetIncreme:
	mov	DWORD PTR tv202[ebp], 0
$LN63@SetIncreme:
	mov	al, BYTE PTR tv202[ebp]
	mov	BYTE PTR _bAttrNotUpdated$[ebp], al
$LN24@SetIncreme:

; 2185 : 
; 2186 :    // Loop through the entity instances.
; 2187 :    for ( lpEntityInstance = lpRootEntityInstance;

	mov	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN4@SetIncreme
$LN2@SetIncreme:

; 2189 :          lpEntityInstance = bSingleEntity ? 0 :

	movzx	edx, BYTE PTR _bSingleEntity$[ebp]
	test	edx, edx
	je	SHORT $LN64@SetIncreme
	mov	DWORD PTR tv209[ebp], 0
	jmp	SHORT $LN65@SetIncreme
$LN64@SetIncreme:
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv209[ebp], eax
$LN65@SetIncreme:
	mov	edx, DWORD PTR tv209[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
$LN4@SetIncreme:

; 2188 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@SetIncreme

; 2190 :                             zGETPTR( lpEntityInstance->hNextHier ) )
; 2191 :    {
; 2192 :       LPVIEWENTITY lpTempViewEntity;
; 2193 :       LPVIEWATTRIB lpViewAttrib;
; 2194 :       zBOOL        bWorkEntity; // indicate entity is work or derived
; 2195 : 
; 2196 :       lpTempViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntity$3[ebp], eax

; 2197 : 
; 2198 :       // If lpViewEntity is not null, then we only want to change the flags
; 2199 :       // for EI's that match that view entity.
; 2200 :       if ( lpViewEntity && lpTempViewEntity != lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN25@SetIncreme
	mov	edx, DWORD PTR _lpTempViewEntity$3[ebp]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN25@SetIncreme

; 2201 :          continue;  // They don't match so continue with next EI.

	jmp	SHORT $LN2@SetIncreme
$LN25@SetIncreme:

; 2202 : 
; 2203 :       bWorkEntity = FALSE;

	mov	BYTE PTR _bWorkEntity$4[ebp], 0

; 2204 :       if ( lpTempViewEntity->bDerived || lpTempViewEntity->bDerivedPath ||

	mov	eax, DWORD PTR _lpTempViewEntity$3[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	SHORT $LN27@SetIncreme
	mov	edx, DWORD PTR _lpTempViewEntity$3[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	jne	SHORT $LN27@SetIncreme
	mov	ecx, DWORD PTR _lpTempViewEntity$3[ebp]
	cmp	DWORD PTR [ecx+191], 0
	jne	SHORT $LN26@SetIncreme
$LN27@SetIncreme:

; 2205 :            lpTempViewEntity->hFirstDataRecord == 0 )
; 2206 :       {
; 2207 :          bWorkEntity = TRUE;

	mov	BYTE PTR _bWorkEntity$4[ebp], 1
$LN26@SetIncreme:

; 2208 :       }
; 2209 : 
; 2210 :       if ( bCreated )

	movzx	edx, BYTE PTR _bCreated$[ebp]
	test	edx, edx
	je	SHORT $LN28@SetIncreme

; 2211 :       {
; 2212 :          lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 2213 :          lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 2214 :          lpViewOI->bUpdatedFile = TRUE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 2215 :          if ( bWorkEntity == FALSE )

	movzx	eax, BYTE PTR _bWorkEntity$4[ebp]
	test	eax, eax
	jne	SHORT $LN30@SetIncreme

; 2216 :             lpViewOI->bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN30@SetIncreme:

; 2217 :       }

	jmp	SHORT $LN29@SetIncreme
$LN28@SetIncreme:

; 2218 :       else
; 2219 :       {
; 2220 :          if ( bPersist )

	movzx	ecx, BYTE PTR _bPersist$[ebp]
	test	ecx, ecx
	je	SHORT $LN31@SetIncreme

; 2221 :          {
; 2222 :             lpEntityInstance->u.nInd.bCreated = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2223 :             bMustCheckOIUpdated = TRUE;

	mov	BYTE PTR _bMustCheckOIUpdated$[ebp], 1
$LN31@SetIncreme:

; 2224 :          }
; 2225 : 
; 2226 :          if ( bUpdated )

	movzx	edx, BYTE PTR _bUpdated$[ebp]
	test	edx, edx
	je	SHORT $LN32@SetIncreme

; 2227 :          {
; 2228 :             lpEntityInstance->u.nInd.bUpdated = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 4
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 2229 :          }

	jmp	SHORT $LN29@SetIncreme
$LN32@SetIncreme:

; 2230 :          else
; 2231 :          if ( bNotUpdated )

	movzx	eax, BYTE PTR _bNotUpdated$[ebp]
	test	eax, eax
	je	SHORT $LN29@SetIncreme

; 2232 :          {
; 2233 :             lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 2234 :             bMustCheckOIUpdated = TRUE;

	mov	BYTE PTR _bMustCheckOIUpdated$[ebp], 1
$LN29@SetIncreme:

; 2235 : 
; 2236 :             /*
; 2237 :             HH, 2002.05.02
; 2238 :             This code was commented out for following reasons:
; 2239 :             - it is obviously wrong, the "created" flag is not turned on,
; 2240 :               but it is turned off.
; 2241 :             - to "correct" it would mean, that turn "updated" off for a
; 2242 :               deleted entity means to "undelete" it.
; 2243 : 
; 2244 :             If we would want that behaviour, then we should correct and
; 2245 :             re-activate the code. However, this is a runtime change which
; 2246 :             can influence existing applications.
; 2247 : 
; 2248 :             Removing the code is not a runtime change, because of the bug it
; 2249 :             did not have any significant effect.
; 2250 : 
; 2251 :             // We don't want the entities to be flagged as updated.  If
; 2252 :             // the current entity is flagged as deleted then we will turn
; 2253 :             // on the "created" flag so the EI is considered "dead".
; 2254 :             if ( lpEntityInstance->u.nInd.bDeleted )
; 2255 :             {
; 2256 :                lpEntityInstance->u.nInd.bCreated = FALSE; // wrong, = TRUE is correct
; 2257 :             }
; 2258 :             */
; 2259 :          }
; 2260 :       }
; 2261 : 
; 2262 :       if ( bIncluded && lpEntityInstance->hParent )

	movzx	ecx, BYTE PTR _bIncluded$[ebp]
	test	ecx, ecx
	je	SHORT $LN35@SetIncreme
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $LN35@SetIncreme

; 2263 :          lpEntityInstance->u.nInd.bIncluded = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	jmp	SHORT $LN36@SetIncreme
$LN35@SetIncreme:

; 2264 :       else
; 2265 :       if ( bNotIncluded )

	movzx	eax, BYTE PTR _bNotIncluded$[ebp]
	test	eax, eax
	je	SHORT $LN36@SetIncreme

; 2266 :          lpEntityInstance->u.nInd.bIncluded = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN36@SetIncreme:

; 2267 : 
; 2268 :       // Now check to see if we need to update the attributes.
; 2269 :       if ( bAttrUpdated == FALSE && bAttrNotUpdated == FALSE )

	movzx	ecx, BYTE PTR _bAttrUpdated$[ebp]
	test	ecx, ecx
	jne	SHORT $LN38@SetIncreme
	movzx	edx, BYTE PTR _bAttrNotUpdated$[ebp]
	test	edx, edx
	jne	SHORT $LN38@SetIncreme

; 2270 :          continue; // Nope--continue with the next EI.

	jmp	$LN2@SetIncreme
$LN38@SetIncreme:

; 2271 : 
; 2272 :       // Set attribute flags.
; 2273 :       for ( lpViewAttrib = zGETPTR( lpTempViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpTempViewEntity$3[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$2[ebp], eax
	jmp	SHORT $LN7@SetIncreme
$LN5@SetIncreme:

; 2275 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$2[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$2[ebp], eax
$LN7@SetIncreme:

; 2274 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$2[ebp], 0
	je	SHORT $LN6@SetIncreme

; 2276 :       {
; 2277 :          LPATTRIBFLAGS lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance,

	mov	ecx, DWORD PTR _lpViewAttrib$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$1[ebp], eax

; 2278 :                                                             lpViewAttrib );
; 2279 : 
; 2280 :          // Set the update flag for the entity.  Since we KNOW that either
; 2281 :          // bAttrUpdated flag or bAttrNotUpdated flag is TRUE, and since they
; 2282 :          // can't both be TRUE, we can just set the update flag for the
; 2283 :          // attribute to bAttrUpdated.
; 2284 :          if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$1[ebp], 0
	je	SHORT $LN39@SetIncreme

; 2285 :             lpAttribFlags->u.bFlags.bUpdated = bAttrUpdated;

	movzx	eax, BYTE PTR _bAttrUpdated$[ebp]
	and	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _lpAttribFlags$1[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -3					; fffffffdH
	or	edx, eax
	mov	eax, DWORD PTR _lpAttribFlags$1[ebp]
	mov	DWORD PTR [eax], edx
$LN39@SetIncreme:

; 2286 :       }

	jmp	SHORT $LN5@SetIncreme
$LN6@SetIncreme:

; 2287 : 
; 2288 :       if ( bAttrUpdated && lpEntityInstance->u.nInd.bUpdated == FALSE )

	movzx	ecx, BYTE PTR _bAttrUpdated$[ebp]
	test	ecx, ecx
	je	SHORT $LN40@SetIncreme
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	jne	SHORT $LN40@SetIncreme

; 2289 :       {
; 2290 :          lpEntityInstance->u.nInd.bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 2291 :          lpViewOI->bUpdatedFile = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 2292 :          if ( bWorkEntity == FALSE )

	movzx	ecx, BYTE PTR _bWorkEntity$4[ebp]
	test	ecx, ecx
	jne	SHORT $LN42@SetIncreme

; 2293 :             lpViewOI->bUpdated = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN42@SetIncreme:

; 2294 :       }

	jmp	SHORT $LN41@SetIncreme
$LN40@SetIncreme:

; 2295 :       else
; 2296 :       if ( bAttrNotUpdated && lpEntityInstance->u.nInd.bUpdated )

	movzx	edx, BYTE PTR _bAttrNotUpdated$[ebp]
	test	edx, edx
	je	SHORT $LN41@SetIncreme
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN41@SetIncreme

; 2297 :       {
; 2298 :          lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2299 :          bMustCheckOIUpdated = TRUE;

	mov	BYTE PTR _bMustCheckOIUpdated$[ebp], 1
$LN41@SetIncreme:

; 2300 :       }
; 2301 :    }

	jmp	$LN2@SetIncreme
$LN3@SetIncreme:

; 2302 : 
; 2303 :    // if an update flag was removed, we have to re-check the
; 2304 :    //  OI update flags from scratch
; 2305 :    if ( bMustCheckOIUpdated )

	movzx	edx, BYTE PTR _bMustCheckOIUpdated$[ebp]
	test	edx, edx
	je	SHORT $LN44@SetIncreme

; 2306 :       fnCheckOIUpdated( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnCheckOIUpdated
	add	esp, 4
$LN44@SetIncreme:

; 2307 : 
; 2308 :    // Everything has been set, return
; 2309 :    fnOperationReturn( iSetIncrementalUpdateFlags, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	119					; 00000077H
	call	_fnOperationReturn
	add	esp, 8

; 2310 :    return( 0 );

	xor	eax, eax
$LN1@SetIncreme:

; 2311 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SetIncrementalUpdateFlags@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewCsr$1 = -48					; size = 4
_lpViewOI$2 = -44					; size = 4
_lpWorkViewEntityCsr$3 = -40				; size = 4
_lpViewEntityCsr$ = -36					; size = 4
_lpEntityInstance$4 = -32				; size = 4
_lpWorkView$5 = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpCurrentTask$ = -20					; size = 4
_nPositionOK$ = -16					; size = 2
_bNewRoot$ = -12					; size = 2
_n$6 = -8						; size = 2
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nPosition$ = 16					; size = 2
_CreateTemporalEntity@12 PROC

; 428  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 429  :    LPTASK          lpCurrentTask;
; 430  :    LPVIEWENTITY    lpViewEntity;
; 431  :    LPVIEWENTITYCSR lpViewEntityCsr;
; 432  :    zSHORT          nPositionOK;  // 0=after, 1=before
; 433  :    // int          nExtraRecordFlags;
; 434  :    zSHORT          bNewRoot;
; 435  :    zSHORT          nRC;
; 436  : 
; 437  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 438  :    if ( (lpCurrentTask = fnOperationCall( iCreateTemporalEntity, lpView,
; 439  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	115					; 00000073H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@CreateTemp

; 440  :    {
; 441  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN2@CreateTemp:

; 442  :    }
; 443  : 
; 444  :    // Validate that the entity exists.
; 445  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 446  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@CreateTemp

; 447  :    {
; 448  :       fnOperationReturn( iCreateTemporalEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	115					; 00000073H
	call	_fnOperationReturn
	add	esp, 8

; 449  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN3@CreateTemp:

; 450  :    }
; 451  : 
; 452  :    // If the view is read only, issue an error.
; 453  :    if ( lpView->bReadOnly )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN4@CreateTemp

; 454  :    {
; 455  :       // "KZOEE119 - Invalid View, View is Read Only"
; 456  :       fnIssueCoreError( lpCurrentTask, lpView, 8, 119, 0, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	push	0
	push	119					; 00000077H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 457  :       fnOperationReturn( iCreateTemporalEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	115					; 00000073H
	call	_fnOperationReturn
	add	esp, 8

; 458  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN4@CreateTemp:

; 459  :    }
; 460  : 
; 461  :    // Make sure entity can be created.
; 462  :    if ( lpViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	jne	SHORT $LN5@CreateTemp

; 463  :    {
; 464  :       // "KZOEE106 - Rules violation"
; 465  :       fnIssueCoreError( lpCurrentTask, lpView, 8, 106, 0,

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG13484
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 466  :                         "Entity Creation not allowed",
; 467  :                         lpViewEntity->szName );
; 468  :       fnOperationReturn( iCreateTemporalEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	115					; 00000073H
	call	_fnOperationReturn
	add	esp, 8

; 469  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN5@CreateTemp:

; 470  :    }
; 471  : 
; 472  :    // Validate that an insert of this entity in this instance at
; 473  :    // the specified position is valid.
; 474  :    nPositionOK = fnValidateInsertPosition( &bNewRoot,

	movzx	edx, WORD PTR _nPosition$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	115					; 00000073H
	lea	edx, DWORD PTR _bNewRoot$[ebp]
	push	edx
	call	_fnValidateInsertPosition
	add	esp, 20					; 00000014H
	mov	WORD PTR _nPositionOK$[ebp], ax

; 475  :                                            iCreateTemporalEntity,
; 476  :                                            lpView,
; 477  :                                            lpViewEntityCsr,
; 478  :                                            nPosition );
; 479  :    if ( nPositionOK < 0 )

	movsx	eax, WORD PTR _nPositionOK$[ebp]
	test	eax, eax
	jge	SHORT $LN6@CreateTemp

; 480  :    {
; 481  :       fnOperationReturn( iCreateTemporalEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	115					; 00000073H
	call	_fnOperationReturn
	add	esp, 8

; 482  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN6@CreateTemp:

; 483  :    }
; 484  : 
; 485  : #ifdef __ACTIVATE_CONSTRAINTS__
; 486  :    // If there is a create constraint active for this entity we need to
; 487  :    // use a work view, just in case the constraint handler objects and
; 488  :    // we have to set everything back to the way it was.
; 489  :    if ( lpViewEntity->bCreateConstraint )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 1
	and	eax, 1
	je	$LN7@CreateTemp

; 490  :    {
; 491  :       zVIEW             lpWorkView;
; 492  :       LPVIEWENTITYCSR   lpWorkViewEntityCsr;
; 493  :       zSHORT            n;
; 494  : 
; 495  :       CreateViewFromViewForTask( &lpWorkView, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpWorkView$5[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 496  : 
; 497  :       // Reset the View entity csr for work view.
; 498  :       fnValidViewEntity( &lpWorkViewEntityCsr, lpWorkView, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkView$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpWorkViewEntityCsr$3[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 499  : 
; 500  :       // Call fnCreateTemporalEntity to create the entity.
; 501  :       nRC = fnCreateEntity( lpWorkView, lpViewEntity,

	movzx	eax, WORD PTR _bNewRoot$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWorkViewEntityCsr$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkView$5[ebp]
	push	ecx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 502  :                             lpWorkViewEntityCsr,
; 503  :                             nPosition, bNewRoot );
; 504  :       if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN9@CreateTemp

; 505  :       {
; 506  :          fnDropView( lpWorkView );

	mov	eax, DWORD PTR _lpWorkView$5[ebp]
	push	eax
	call	_fnDropView@4

; 507  :          fnOperationReturn( iCreateTemporalEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	115					; 00000073H
	call	_fnOperationReturn
	add	esp, 8

; 508  :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@CreateTemp
$LN9@CreateTemp:

; 509  :       }
; 510  : 
; 511  :       // If the view entity has any initialization attributes, initialize
; 512  :       // them now.
; 513  :       fnInitAttributes( lpWorkView, lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkView$5[ebp]
	push	eax
	call	_fnInitAttributes@8

; 514  : 
; 515  :       n = fnInvokeECEOperation( lpWorkView, lpViewEntity,

	push	0
	push	3
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkView$5[ebp]
	push	eax
	call	_fnInvokeECEOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _n$6[ebp], ax

; 516  :                                 lpCurrentTask, zECE_CREATE, 0 );
; 517  :       if ( n )

	movsx	ecx, WORD PTR _n$6[ebp]
	test	ecx, ecx
	je	SHORT $LN10@CreateTemp

; 518  :       {
; 519  :          fnDeleteEntity( lpWorkView, lpViewEntity, lpWorkViewEntityCsr,

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpWorkViewEntityCsr$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWorkView$5[ebp]
	push	edx
	call	_fnDeleteEntity
	add	esp, 20					; 00000014H

; 520  :                          zREPOS_NONE, lpCurrentTask );
; 521  :          fnDropView( lpWorkView );

	mov	eax, DWORD PTR _lpWorkView$5[ebp]
	push	eax
	call	_fnDropView@4

; 522  :          fnOperationReturn( iCreateTemporalEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	115					; 00000073H
	call	_fnOperationReturn
	add	esp, 8

; 523  :          return( n );

	mov	ax, WORD PTR _n$6[ebp]
	jmp	$LN1@CreateTemp

; 524  :       }

	jmp	SHORT $LN11@CreateTemp
$LN10@CreateTemp:

; 525  :       else
; 526  :       {
; 527  :          // Save cursors from the work view to the original.
; 528  :          fnSetViewFromView( lpView, lpWorkView);

	mov	edx, DWORD PTR _lpWorkView$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetViewFromView
	add	esp, 8

; 529  : 
; 530  :          // Drop work view.
; 531  :          fnDropView( lpWorkView );

	mov	ecx, DWORD PTR _lpWorkView$5[ebp]
	push	ecx
	call	_fnDropView@4
$LN11@CreateTemp:

; 532  :       }
; 533  :    }

	jmp	SHORT $LN8@CreateTemp
$LN7@CreateTemp:

; 534  :    else
; 535  : #endif
; 536  : 
; 537  :    {
; 538  :       // Call fnCreateEntity to create the entity.
; 539  :       nRC = fnCreateEntity( lpView, lpViewEntity, lpViewEntityCsr,

	movzx	edx, WORD PTR _bNewRoot$[ebp]
	push	edx
	movzx	eax, WORD PTR _nPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 540  :                            nPosition, bNewRoot );
; 541  :       // If the view entity has any initialization attributes, initialize
; 542  :       // them now.
; 543  :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN8@CreateTemp

; 544  :          fnInitAttributes( lpView, lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInitAttributes@8
$LN8@CreateTemp:

; 545  :    }
; 546  : 
; 547  :    // If the entity instance has been successfully created, mark the
; 548  :    // Entity instance as owning the entity record and check the
; 549  :    // instances parent to see if any other linked instances require
; 550  :    // spawning this entity type. If so, issue a warning message for
; 551  :    // now since the overhead in establishing a view for spawning
; 552  :    // entity creations may not be worth the effort and performance
; 553  :    // lost when compared to the benefit gained. Unfortunately, this
; 554  :    // check is done after the entity has been created (i.e. the horses
; 555  :    // are already out of the barn).
; 556  :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN13@CreateTemp

; 557  :    {
; 558  :       LPENTITYINSTANCE  lpEntityInstance;
; 559  :       LPVIEWCSR         lpViewCsr;
; 560  :       LPVIEWOI          lpViewOI;
; 561  : 
; 562  :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$4[ebp], eax

; 563  :       lpEntityInstance->u.nInd.bCreated  = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 2
	mov	eax, DWORD PTR _lpEntityInstance$4[ebp]
	mov	DWORD PTR [eax+6], edx

; 564  :       lpEntityInstance->u.nInd.bTemporal = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 2048				; 00000800H
	mov	eax, DWORD PTR _lpEntityInstance$4[ebp]
	mov	DWORD PTR [eax+6], edx

; 565  :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 566  :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$2[ebp], eax

; 567  :       lpViewOI->nVersionedInstances++;

	mov	edx, DWORD PTR _lpViewOI$2[ebp]
	mov	ax, WORD PTR [edx+22]
	add	ax, 1
	mov	ecx, DWORD PTR _lpViewOI$2[ebp]
	mov	WORD PTR [ecx+22], ax
$LN13@CreateTemp:

; 568  :    }
; 569  : 
; 570  :    // return success, we've managed to create an entity
; 571  :    fnOperationReturn( iCreateTemporalEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	115					; 00000073H
	call	_fnOperationReturn
	add	esp, 8

; 572  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CreateTemp:

; 573  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CreateTemporalEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -36					; size = 4
_lpViewOI$ = -32					; size = 4
_lpViewEntityCsr$ = -28					; size = 4
_lpPrevVsn$ = -24					; size = 4
_lpEntityInstance$ = -20				; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntity$ = -12					; size = 4
_n$1 = -8						; size = 2
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nReposition$ = 16					; size = 2
_ExcludeEntity@12 PROC

; 1680 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1681 :    LPTASK            lpCurrentTask;
; 1682 :    LPVIEWCSR         lpViewCsr;
; 1683 :    LPVIEWOI          lpViewOI;
; 1684 :    LPVIEWENTITY      lpViewEntity;
; 1685 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1686 :    LPENTITYINSTANCE  lpPrevVsn;
; 1687 :    LPENTITYINSTANCE  lpEntityInstance;
; 1688 :    zSHORT            nRC;
; 1689 : 
; 1690 :    // Validate that the source view entity exists and has a cursor value
; 1691 :    // for copying.  We call fnValidateInstanceParameters for the source
; 1692 :    // since it requires the same editing as an attribute retrieval
; 1693 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	1
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	107					; 0000006bH
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@ExcludeEnt

; 1694 :                                       &lpViewEntity,
; 1695 :                                       &lpViewEntityCsr,
; 1696 :                                       iExcludeEntity,
; 1697 :                                       lpView,
; 1698 :                                       cpcEntityName, 1 ) )
; 1699 :    {
; 1700 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ExcludeEnt
$LN2@ExcludeEnt:

; 1701 :    }
; 1702 : 
; 1703 :    // Make sure entity can be excluded
; 1704 :    if ( lpViewEntity->hParent && lpViewEntity->bExclude == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN3@ExcludeEnt
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN3@ExcludeEnt

; 1705 :    {
; 1706 :       // "KZOEE106 - Rules violation"
; 1707 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 106, 0,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG13836
	push	0
	push	106					; 0000006aH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1708 :                         "Entity Exclusion not allowed",
; 1709 :                         lpViewEntity->szName );
; 1710 :       fnOperationReturn( iExcludeEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	107					; 0000006bH
	call	_fnOperationReturn
	add	esp, 8

; 1711 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ExcludeEnt
$LN3@ExcludeEnt:

; 1712 :    }
; 1713 : 
; 1714 : #ifdef __ACTIVATE_CONSTRAINTS__
; 1715 :    // If there is an Entity Constraint for exclude, see if it has
; 1716 :    // any objections about continuing.
; 1717 :    if ( lpViewEntity->bExcludeConstraint )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN4@ExcludeEnt

; 1718 :    {
; 1719 :       zSHORT   n;
; 1720 : 
; 1721 :       n = fnInvokeECEOperation( lpView, lpViewEntity, lpCurrentTask,

	push	0
	push	5
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeECEOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _n$1[ebp], ax

; 1722 :                                 zECE_EXCLUDE, 0 );
; 1723 :       // If constraint handler doesn't like something, get out.
; 1724 :       if ( n )

	movsx	eax, WORD PTR _n$1[ebp]
	test	eax, eax
	je	SHORT $LN4@ExcludeEnt

; 1725 :       {
; 1726 :          fnOperationReturn( iExcludeEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	107					; 0000006bH
	call	_fnOperationReturn
	add	esp, 8

; 1727 :          return( n );

	mov	ax, WORD PTR _n$1[ebp]
	jmp	$LN1@ExcludeEnt
$LN4@ExcludeEnt:

; 1728 :       }
; 1729 :    }
; 1730 : #endif
; 1731 : 
; 1732 :    // Get the entity instance to be excluded
; 1733 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1734 :    fnRemoveAllChildTemporalVsns( lpView, lpEntityInstance, 0 );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnRemoveAllChildTemporalVsns
	add	esp, 12					; 0000000cH

; 1735 : 
; 1736 :    // If the entity instance is a temporal entity or the root of
; 1737 :    // a versioned Subobject, issue a cancel subobject prior to the
; 1738 :    // call to exclude entity
; 1739 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1740 :    lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 1741 :    if ( lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot )

	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	je	SHORT $LN6@ExcludeEnt
	mov	eax, DWORD PTR _lpPrevVsn$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 9
	and	ecx, 1
	je	SHORT $LN6@ExcludeEnt

; 1742 :       nRC = CancelSubobject( lpView, cpcEntityName );

	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_CancelSubobject@8
	mov	WORD PTR _nRC$[ebp], ax
$LN6@ExcludeEnt:

; 1743 : 
; 1744 :    // Call fnExcludeEntity
; 1745 :    nRC = fnExcludeEntity( lpView, lpViewEntity, lpViewEntityCsr,

	push	1
	movzx	ecx, WORD PTR _nReposition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnExcludeEntity
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 1746 :                           nReposition, 1 );
; 1747 : #ifdef __RECLAIM__
; 1748 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1749 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1750 :    if ( nRC != zCURSOR_UNDEFINED && lpViewOI->nHiddenCount > __RECLAIM_LIMIT__ )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN7@ExcludeEnt
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	cmp	edx, 20					; 00000014H
	jle	SHORT $LN7@ExcludeEnt

; 1751 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$LN7@ExcludeEnt:

; 1752 : #endif
; 1753 : 
; 1754 :    // Whew, I think we've done it, return to caller
; 1755 :    fnOperationReturn( iExcludeEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	107					; 0000006bH
	call	_fnOperationReturn
	add	esp, 8

; 1756 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ExcludeEnt:

; 1757 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_ExcludeEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -52					; size = 4
_lpViewCsr$ = -48					; size = 4
_lpCurrentTask$ = -44					; size = 4
_lpViewEntityCsr$ = -40					; size = 4
_lpPrevVsn$ = -36					; size = 4
_lpViewOI$ = -32					; size = 4
tv211 = -28						; size = 4
tv142 = -24						; size = 4
_lpPrevLinked$1 = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_nLvl$ = -12						; size = 2
_nRC$ = -8						; size = 2
_bTemporal$ = -1					; size = 1
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nReposition$ = 16					; size = 2
_DropEntity@12 PROC

; 968  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 969  :    LPTASK            lpCurrentTask;
; 970  :    LPVIEWOI          lpViewOI;
; 971  :    LPVIEWCSR         lpViewCsr;
; 972  :    LPVIEWENTITY      lpViewEntity;
; 973  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 974  :    LPENTITYINSTANCE  lpEntityInstance;
; 975  :    LPENTITYINSTANCE  lpPrevVsn;
; 976  :    zBOOL             bTemporal;
; 977  :    zSHORT            nRC, nLvl;
; 978  : 
; 979  :    // Validate that the source view entity exists and has a cursor
; 980  :    // value for copying, we call fnValidateInstanceParameters for the
; 981  :    // source since it requires the same editing as an attribute retrieval
; 982  :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	1
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	126					; 0000007eH
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@DropEntity

; 983  :                                       &lpViewEntity,
; 984  :                                       &lpViewEntityCsr,
; 985  :                                       iDropEntity,
; 986  :                                       lpView,
; 987  :                                       cpcEntityName, 1 ) )
; 988  :    {
; 989  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DropEntity
$LN12@DropEntity:

; 990  :    }
; 991  : 
; 992  :    // Get the entity instance to be deleted
; 993  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 994  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 995  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 996  : 
; 997  :    fnRemoveAllChildTemporalVsns( lpView, lpEntityInstance, 0 );

	push	0
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnRemoveAllChildTemporalVsns
	add	esp, 12					; 0000000cH

; 998  : 
; 999  :    // If the entity instance is a temporal entity or the root of
; 1000 :    // a versioned Subobject, issue a cancel subobject prior to marking
; 1001 :    // the previous version as hidden
; 1002 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 1003 :    lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 1004 :    if ( lpEntityInstance->u.nInd.bTemporal ||

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	jne	SHORT $LN14@DropEntity
	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	je	$LN13@DropEntity
	mov	ecx, DWORD PTR _lpPrevVsn$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	je	$LN13@DropEntity
$LN14@DropEntity:

; 1005 :         (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 1006 :    {
; 1007 :       // Set temporal entity indicator
; 1008 :       bTemporal = lpEntityInstance->u.nInd.bTemporal;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	mov	BYTE PTR _bTemporal$[ebp], cl

; 1009 :       nRC = CancelSubobject( lpView, cpcEntityName );

	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_CancelSubobject@8
	mov	WORD PTR _nRC$[ebp], ax

; 1010 : 
; 1011 :       // if the entity instance was temporal, then the cancel deleted the
; 1012 :       // temporal instance, issue the repositioning requested and return.
; 1013 :       if ( bTemporal )

	movzx	ecx, BYTE PTR _bTemporal$[ebp]
	test	ecx, ecx
	je	$LN15@DropEntity

; 1014 :       {
; 1015 :          // Now see if the user requested the cursor to be repositioned
; 1016 :          if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN16@DropEntity

; 1017 :          switch ( nReposition )

	movsx	eax, WORD PTR _nReposition$[ebp]
	mov	DWORD PTR tv142[ebp], eax
	mov	ecx, DWORD PTR tv142[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv142[ebp], ecx
	cmp	DWORD PTR tv142[ebp], 3
	ja	SHORT $LN21@DropEntity
	mov	edx, DWORD PTR tv142[ebp]
	jmp	DWORD PTR $LN34@DropEntity[edx*4]
$LN17@DropEntity:

; 1018 :          {
; 1019 :             case zREPOS_FIRST:
; 1020 :                nRC = SetCursorFirstEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1021 :                break;

	jmp	SHORT $LN16@DropEntity
$LN18@DropEntity:

; 1022 : 
; 1023 :             case zREPOS_LAST:
; 1024 :                nRC = SetCursorLastEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetCursorLastEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1025 :                break;

	jmp	SHORT $LN16@DropEntity
$LN19@DropEntity:

; 1026 : 
; 1027 :             case zREPOS_NEXT:
; 1028 :                nRC = SetCursorNextEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1029 :                break;

	jmp	SHORT $LN16@DropEntity
$LN20@DropEntity:

; 1030 : 
; 1031 :             case zREPOS_PREV:
; 1032 :                nRC = SetCursorPrevEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1033 :                break;

	jmp	SHORT $LN16@DropEntity
$LN21@DropEntity:

; 1034 : 
; 1035 :             default:
; 1036 :                nRC = zCURSOR_UNDEFINED;

	mov	edx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], dx
$LN16@DropEntity:

; 1037 :          }
; 1038 : 
; 1039 :          // We think we're done, tell the caller everything is AOK!
; 1040 :          fnOperationReturn( iDropEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	126					; 0000007eH
	call	_fnOperationReturn
	add	esp, 8

; 1041 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@DropEntity
$LN15@DropEntity:

; 1042 :       }
; 1043 : 
; 1044 :       // Get the entity instance to be dropped after the cancel
; 1045 :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN13@DropEntity:

; 1046 :    }
; 1047 : 
; 1048 :    nRC = 0; // Count the instance marked as hidden

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1049 :    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN22@DropEntity

; 1050 :    {
; 1051 :       nLvl = lpEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nLvl$[ebp], dx
$LN6@DropEntity:

; 1052 :       do
; 1053 :       {
; 1054 :          lpEntityInstance->u.nInd.bCreated =

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 1024				; 00000400H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1055 :             lpEntityInstance->u.nInd.bHidden = TRUE;
; 1056 : 
; 1057 :          // If the entity is linked to other entities, remove it from the link
; 1058 :          // chain.
; 1059 :          if ( lpEntityInstance->hNextLinked )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	SHORT $LN23@DropEntity

; 1060 :          {
; 1061 :             LPENTITYINSTANCE lpPrevLinked;
; 1062 : 
; 1063 :             // Find the EI that points to the current EI.
; 1064 :             for ( lpPrevLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevLinked$1[ebp], eax
	jmp	SHORT $LN9@DropEntity
$LN7@DropEntity:

; 1066 :                   lpPrevLinked = zGETPTR( lpPrevLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpPrevLinked$1[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevLinked$1[ebp], eax
$LN9@DropEntity:

; 1065 :                   zGETPTR( lpPrevLinked->hNextLinked ) != lpEntityInstance;

	mov	edx, DWORD PTR _lpPrevLinked$1[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN8@DropEntity

; 1067 :             {
; 1068 :                // Nothing needs to be done here.
; 1069 :             }

	jmp	SHORT $LN7@DropEntity
$LN8@DropEntity:

; 1070 : 
; 1071 :             // Remove lpEntityInstance from the link chain.
; 1072 :             if ( zGETPTR( lpEntityInstance->hNextLinked ) == lpPrevLinked )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpPrevLinked$1[ebp]
	jne	SHORT $LN24@DropEntity

; 1073 :                lpPrevLinked->hNextLinked = 0;

	mov	eax, DWORD PTR _lpPrevLinked$1[ebp]
	mov	DWORD PTR [eax+42], 0
	jmp	SHORT $LN25@DropEntity
$LN24@DropEntity:

; 1074 :             else
; 1075 :                lpPrevLinked->hNextLinked = lpEntityInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpPrevLinked$1[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax
$LN25@DropEntity:

; 1076 : 
; 1077 :             // NULL out the hRecord pointer so that when the EI is eventually
; 1078 :             // freed we won't free the attribute data.
; 1079 :             // Note that we can do this because
; 1080 :             // a dropped entity instance doesn't change the database so we
; 1081 :             // don't need to keep seperate copies of the attributes.
; 1082 :             lpEntityInstance->hPersistRecord = 0;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 1083 :             lpEntityInstance->hNextLinked = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+42], 0
$LN23@DropEntity:

; 1084 :          }
; 1085 : 
; 1086 :          nRC++;

	mov	ax, WORD PTR _nRC$[ebp]
	add	ax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 1087 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1088 :       }  while ( lpEntityInstance && lpEntityInstance->nLevel > nLvl );

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN5@DropEntity
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nLvl$[ebp]
	cmp	ecx, edx
	jg	$LN6@DropEntity
$LN5@DropEntity:

; 1089 : 
; 1090 :       lpViewOI->nHiddenCount += nRC;

	movsx	eax, WORD PTR _nRC$[ebp]
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	add	edx, eax
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [eax+24], dx

; 1091 :       nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN22@DropEntity:

; 1092 :    }
; 1093 : 
; 1094 :    switch ( nReposition )

	movsx	edx, WORD PTR _nReposition$[ebp]
	mov	DWORD PTR tv211[ebp], edx
	mov	eax, DWORD PTR tv211[ebp]
	sub	eax, 1
	mov	DWORD PTR tv211[ebp], eax
	cmp	DWORD PTR tv211[ebp], 3
	ja	SHORT $LN31@DropEntity
	mov	ecx, DWORD PTR tv211[ebp]
	jmp	DWORD PTR $LN35@DropEntity[ecx*4]
$LN27@DropEntity:

; 1095 :    {
; 1096 :       case zREPOS_FIRST:
; 1097 :          nRC = SetCursorFirstEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1098 :          break;

	jmp	SHORT $LN10@DropEntity
$LN28@DropEntity:

; 1099 : 
; 1100 :       case zREPOS_LAST:
; 1101 :          nRC = SetCursorLastEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetCursorLastEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1102 :          break;

	jmp	SHORT $LN10@DropEntity
$LN29@DropEntity:

; 1103 : 
; 1104 :       case zREPOS_NEXT:
; 1105 :          nRC = SetCursorNextEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1106 :          break;

	jmp	SHORT $LN10@DropEntity
$LN30@DropEntity:

; 1107 : 
; 1108 :       case zREPOS_PREV:
; 1109 :          nRC = SetCursorPrevEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1110 :          break;

	jmp	SHORT $LN10@DropEntity
$LN31@DropEntity:

; 1111 : 
; 1112 :       default:
; 1113 :          nRC = zCURSOR_UNDEFINED;

	mov	ecx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], cx
$LN10@DropEntity:

; 1114 :    }
; 1115 : 
; 1116 : #ifdef __RECLAIM__
; 1117 :    if ( nRC != zCURSOR_UNDEFINED && lpViewOI->nHiddenCount > __RECLAIM_LIMIT__ )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN32@DropEntity
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	cmp	ecx, 20					; 00000014H
	jle	SHORT $LN32@DropEntity

; 1118 :       fnReclaimHiddenInstances( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnReclaimHiddenInstances@4
$LN32@DropEntity:

; 1119 : #endif
; 1120 : 
; 1121 :    // We think we're done, tell the caller everything is AOK!
; 1122 :    fnOperationReturn( iDropEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	126					; 0000007eH
	call	_fnOperationReturn
	add	esp, 8

; 1123 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DropEntity:

; 1124 : 
; 1125 : } // DropEntity

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN34@DropEntity:
	DD	$LN17@DropEntity
	DD	$LN18@DropEntity
	DD	$LN19@DropEntity
	DD	$LN20@DropEntity
$LN35@DropEntity:
	DD	$LN27@DropEntity
	DD	$LN28@DropEntity
	DD	$LN29@DropEntity
	DD	$LN30@DropEntity
_DropEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -256					; size = 4
_lpViewOI$ = -252					; size = 4
_lpViewEntityCsr$ = -248				; size = 4
_lpPrevVsn$ = -244					; size = 4
tv215 = -240						; size = 4
_lpChildViewEntity$1 = -236				; size = 4
_lpEntityInstance$ = -232				; size = 4
_lpChild$2 = -228					; size = 4
_n$3 = -224						; size = 2
_bTemporal$ = -217					; size = 1
_lpCurrentTask$ = -216					; size = 4
_lpViewEntity$ = -212					; size = 4
_nRC$ = -208						; size = 2
_szMsg$4 = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nReposition$ = 16					; size = 2
_DeleteEntity@12 PROC

; 1280 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 256				; 00000100H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1281 :    LPTASK            lpCurrentTask;
; 1282 :    LPVIEWCSR         lpViewCsr;
; 1283 :    LPVIEWOI          lpViewOI;
; 1284 :    LPVIEWENTITY      lpViewEntity;
; 1285 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1286 :    LPENTITYINSTANCE  lpEntityInstance;
; 1287 :    LPENTITYINSTANCE  lpPrevVsn;
; 1288 :    zBOOL             bTemporal;
; 1289 :    zSHORT            nRC;
; 1290 : 
; 1291 :    // Validate that the source view entity exists and has a cursor
; 1292 :    // value for copying, we call fnValidateInstanceParameters for the
; 1293 :    // source since it requires the same editing as an attribute retrieval
; 1294 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	1
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	106					; 0000006aH
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN7@DeleteEnti

; 1295 :                                       &lpViewEntity,
; 1296 :                                       &lpViewEntityCsr,
; 1297 :                                       iDeleteEntity,
; 1298 :                                       lpView,
; 1299 :                                       cpcEntityName, 1 ) )
; 1300 :    {
; 1301 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DeleteEnti
$LN7@DeleteEnti:

; 1302 :    }
; 1303 : 
; 1304 :    // Make sure entity can be deleted
; 1305 :    if ( lpViewEntity->bDelete == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN8@DeleteEnti

; 1306 :    {
; 1307 :       // "KZOEE106 - Rules violation"
; 1308 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 106, 0,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13714
	push	0
	push	106					; 0000006aH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1309 :                         "Entity Deletion not allowed",
; 1310 :                         lpViewEntity->szName );
; 1311 :       fnOperationReturn( iDeleteEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	106					; 0000006aH
	call	_fnOperationReturn
	add	esp, 8

; 1312 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DeleteEnti
$LN8@DeleteEnti:

; 1313 :    }
; 1314 : 
; 1315 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1316 : 
; 1317 :    // Make sure that none of the child entities have restrictions on their
; 1318 :    // parents being deleted.  If bCheckRestrict is TRUE, then at least one
; 1319 :    // child entity has the bPRestrict flag set.
; 1320 :    if ( lpViewEntity->bCheckRestrict )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 9
	and	eax, 1
	je	$LN9@DeleteEnti

; 1321 :    {
; 1322 :       LPENTITYINSTANCE lpChild;
; 1323 : 
; 1324 :       // Loop through each of the child entity instances of lpEntityInstance.
; 1325 :       // When the level of the lpChild entity instance is no longer greater
; 1326 :       // than the level of the current entity instance it is not a child.
; 1327 :       for ( lpChild = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChild$2[ebp], eax
	jmp	SHORT $LN4@DeleteEnti
$LN2@DeleteEnti:

; 1329 :             lpChild = zGETPTR( lpChild->hNextHier ) )

	mov	eax, DWORD PTR _lpChild$2[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChild$2[ebp], eax
$LN4@DeleteEnti:

; 1328 :             lpChild;

	cmp	DWORD PTR _lpChild$2[ebp], 0
	je	$LN9@DeleteEnti

; 1330 :       {
; 1331 :          LPVIEWENTITY lpChildViewEntity = zGETPTR( lpChild->hViewEntity );

	mov	edx, DWORD PTR _lpChild$2[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildViewEntity$1[ebp], eax

; 1332 : 
; 1333 :          if ( lpChildViewEntity->nLevel <= lpViewEntity->nLevel )

	mov	ecx, DWORD PTR _lpChildViewEntity$1[ebp]
	movsx	edx, WORD PTR [ecx+215]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	edx, ecx
	jg	SHORT $LN10@DeleteEnti

; 1334 :             break;

	jmp	$LN9@DeleteEnti
$LN10@DeleteEnti:

; 1335 : 
; 1336 :          // We check the entity levels because we only want child entities that
; 1337 :          // are direct children of lpViewEntity.
; 1338 :          if ( lpChildViewEntity->nLevel != lpViewEntity->nLevel + 1 )

	mov	edx, DWORD PTR _lpChildViewEntity$1[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	add	edx, 1
	cmp	eax, edx
	je	SHORT $LN11@DeleteEnti

; 1339 :             continue;

	jmp	SHORT $LN2@DeleteEnti
$LN11@DeleteEnti:

; 1340 : 
; 1341 :          // Don't bother checking a hidden child.
; 1342 :          if ( lpChild->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpChild$2[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN12@DeleteEnti

; 1343 :             continue;

	jmp	$LN2@DeleteEnti
$LN12@DeleteEnti:

; 1344 : 
; 1345 :          // If the bPRestrict flag is set, then we can't delete the entity.
; 1346 :          if ( lpChildViewEntity->bPRestrict )

	mov	edx, DWORD PTR _lpChildViewEntity$1[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 8
	and	eax, 1
	je	SHORT $LN13@DeleteEnti

; 1347 :          {
; 1348 :             zCHAR szMsg[ 200 ];
; 1349 : 
; 1350 :             zsprintf( szMsg, "Can't delete entity %s because of Restrict "

	mov	ecx, DWORD PTR _lpChildViewEntity$1[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13720
	lea	eax, DWORD PTR _szMsg$4[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 1351 :                      "constraint on child entity %s",
; 1352 :                       lpViewEntity->szName,
; 1353 :                      lpChildViewEntity->szName );
; 1354 :             TraceLineS( szMsg, "" );

	push	OFFSET $SG13721
	lea	ecx, DWORD PTR _szMsg$4[ebp]
	push	ecx
	call	_TraceLineS@8

; 1355 : 
; 1356 :             // "KZOEE106 - Rules violation"
; 1357 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 106, 0,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13722
	push	0
	push	106					; 0000006aH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1358 :                               "Entity Deletion not allowed"
; 1359 :                               " - child is restricted",
; 1360 :                               lpViewEntity->szName );
; 1361 :             fnOperationReturn( iDeleteEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	106					; 0000006aH
	call	_fnOperationReturn
	add	esp, 8

; 1362 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DeleteEnti
$LN13@DeleteEnti:

; 1363 :          }
; 1364 :       }

	jmp	$LN2@DeleteEnti
$LN9@DeleteEnti:

; 1365 : 
; 1366 :    } // if ( lpViewEntity->bCheckRestrict )...
; 1367 : 
; 1368 : #ifdef __ACTIVATE_CONSTRAINTS__
; 1369 :    // If there is an Entity Constraint for delete, see if it has
; 1370 :    // any objections about continuing.
; 1371 :    if ( lpViewEntity->bDeleteConstraint )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN14@DeleteEnti

; 1372 :    {
; 1373 :       zSHORT   n;
; 1374 : 
; 1375 :       n = fnInvokeECEOperation( lpView, lpViewEntity, lpCurrentTask,

	push	0
	push	4
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnInvokeECEOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _n$3[ebp], ax

; 1376 :                                 zECE_DELETE, 0 );
; 1377 :       // If constraint handler doesn't like something, get out.
; 1378 :       if ( n )

	movsx	edx, WORD PTR _n$3[ebp]
	test	edx, edx
	je	SHORT $LN14@DeleteEnti

; 1379 :       {
; 1380 :          fnOperationReturn( iDeleteEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	106					; 0000006aH
	call	_fnOperationReturn
	add	esp, 8

; 1381 :          return( n );

	mov	ax, WORD PTR _n$3[ebp]
	jmp	$LN1@DeleteEnti
$LN14@DeleteEnti:

; 1382 :       }
; 1383 :    }
; 1384 : #endif
; 1385 : 
; 1386 :    // Get the entity instance to be deleted.
; 1387 :    fnRemoveAllChildTemporalVsns( lpView, lpEntityInstance, 0 );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnRemoveAllChildTemporalVsns
	add	esp, 12					; 0000000cH

; 1388 : 
; 1389 :    // If the entity instance is a temporal entity or the root of
; 1390 :    // a versioned Subobject, issue a cancel subobject prior to the
; 1391 :    // call to delete entity.
; 1392 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1393 :    lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 1394 :    if ( lpEntityInstance->u.nInd.bTemporal ||

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN17@DeleteEnti
	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	je	$LN16@DeleteEnti
	mov	edx, DWORD PTR _lpPrevVsn$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	$LN16@DeleteEnti
$LN17@DeleteEnti:

; 1395 :         (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 1396 :    {
; 1397 :       // Set temporal entity indicator.
; 1398 :       bTemporal = lpEntityInstance->u.nInd.bTemporal;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	mov	BYTE PTR _bTemporal$[ebp], dl

; 1399 :       nRC = CancelSubobject( lpView, cpcEntityName );

	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_CancelSubobject@8
	mov	WORD PTR _nRC$[ebp], ax

; 1400 : 
; 1401 :       // If the entity instance was temporal, then the cancel deleted the
; 1402 :       // temporal instance, issue the repositioning requested and return.
; 1403 :       if ( bTemporal )

	movzx	edx, BYTE PTR _bTemporal$[ebp]
	test	edx, edx
	je	$LN16@DeleteEnti

; 1404 :       {
; 1405 :          // Now see if the user requested the cursor to be repositioned.
; 1406 :          if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN19@DeleteEnti

; 1407 :          switch ( nReposition )

	movsx	ecx, WORD PTR _nReposition$[ebp]
	mov	DWORD PTR tv215[ebp], ecx
	mov	edx, DWORD PTR tv215[ebp]
	sub	edx, 1
	mov	DWORD PTR tv215[ebp], edx
	cmp	DWORD PTR tv215[ebp], 3
	ja	SHORT $LN24@DeleteEnti
	mov	eax, DWORD PTR tv215[ebp]
	jmp	DWORD PTR $LN28@DeleteEnti[eax*4]
$LN20@DeleteEnti:

; 1408 :          {
; 1409 :             case zREPOS_FIRST:
; 1410 :                nRC = SetCursorFirstEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1411 :                break;

	jmp	SHORT $LN19@DeleteEnti
$LN21@DeleteEnti:

; 1412 : 
; 1413 :             case zREPOS_LAST:
; 1414 :                nRC = SetCursorLastEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SetCursorLastEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1415 :                break;

	jmp	SHORT $LN19@DeleteEnti
$LN22@DeleteEnti:

; 1416 : 
; 1417 :             case zREPOS_NEXT:
; 1418 :                nRC = SetCursorNextEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1419 :                break;

	jmp	SHORT $LN19@DeleteEnti
$LN23@DeleteEnti:

; 1420 : 
; 1421 :             case zREPOS_PREV:
; 1422 :                nRC = SetCursorPrevEntity( lpView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1423 :                break;

	jmp	SHORT $LN19@DeleteEnti
$LN24@DeleteEnti:

; 1424 : 
; 1425 :             default:
; 1426 :                nRC = zCURSOR_UNDEFINED;

	mov	eax, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], ax
$LN19@DeleteEnti:

; 1427 :          }
; 1428 : 
; 1429 :          // We think we're done, tell the caller everything is AOK!
; 1430 :          fnOperationReturn( iDeleteEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	106					; 0000006aH
	call	_fnOperationReturn
	add	esp, 8

; 1431 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@DeleteEnti
$LN16@DeleteEnti:

; 1432 :       }
; 1433 :    }
; 1434 : 
; 1435 :    // Call fnDeleteEntity if all is well so far.
; 1436 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN25@DeleteEnti

; 1437 :    {
; 1438 :       // Call fnDeleteEntity.
; 1439 :       nRC = fnDeleteEntity( lpView, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nReposition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDeleteEntity
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN25@DeleteEnti:

; 1440 :                             nReposition, lpCurrentTask );
; 1441 :    }
; 1442 : 
; 1443 : #ifdef __RECLAIM__
; 1444 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1445 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1446 :    if ( nRC != zCURSOR_UNDEFINED && lpViewOI->nHiddenCount > __RECLAIM_LIMIT__ )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN26@DeleteEnti
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	cmp	edx, 20					; 00000014H
	jle	SHORT $LN26@DeleteEnti

; 1447 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$LN26@DeleteEnti:

; 1448 : #endif
; 1449 : 
; 1450 :    // We think we're done, tell the caller everything is AOK!
; 1451 :    fnOperationReturn( iDeleteEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	106					; 0000006aH
	call	_fnOperationReturn
	add	esp, 8

; 1452 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DeleteEnti:

; 1453 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	2
$LN28@DeleteEnti:
	DD	$LN20@DeleteEnti
	DD	$LN21@DeleteEnti
	DD	$LN22@DeleteEnti
	DD	$LN23@DeleteEnti
_DeleteEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpEntityInstance$1 = -28				; size = 4
_lpViewEntity$ = -24					; size = 4
_lpViewEntityCsr$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_nRC$ = -12						; size = 2
_bNewRoot$ = -8						; size = 2
_nPositionOK$ = -4					; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nPosition$ = 16					; size = 2
_plpRecord$ = 20					; size = 4
_LoadEntity@16 PROC

; 811  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 812  :    LPTASK          lpCurrentTask;
; 813  :    LPVIEWENTITY    lpViewEntity;
; 814  :    LPVIEWENTITYCSR lpViewEntityCsr;
; 815  :    zSHORT          nPositionOK;  // 0=after, 1=before
; 816  :    // int          nExtraRecordFlags;
; 817  :    zSHORT          bNewRoot;
; 818  :    zSHORT          nRC;
; 819  : 
; 820  :    if ( plpRecord )

	cmp	DWORD PTR _plpRecord$[ebp], 0
	je	SHORT $LN2@LoadEntity

; 821  :       *plpRecord = 0;

	mov	eax, DWORD PTR _plpRecord$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@LoadEntity:

; 822  : 
; 823  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 824  :    if ( (lpCurrentTask = fnOperationCall( iLoadEntity, lpView,
; 825  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	117					; 00000075H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN3@LoadEntity

; 826  :    {
; 827  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@LoadEntity
$LN3@LoadEntity:

; 828  :    }
; 829  : 
; 830  :    // Validate that the entity exists
; 831  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 832  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN4@LoadEntity

; 833  :    {
; 834  :       fnOperationReturn( iLoadEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	117					; 00000075H
	call	_fnOperationReturn
	add	esp, 8

; 835  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@LoadEntity
$LN4@LoadEntity:

; 836  :    }
; 837  : 
; 838  :    // Validate that an insert of this entity in this instance at
; 839  :    // the specified position is valid.
; 840  :    nPositionOK = fnValidateInsertPosition( &bNewRoot,

	movzx	eax, WORD PTR _nPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	117					; 00000075H
	lea	eax, DWORD PTR _bNewRoot$[ebp]
	push	eax
	call	_fnValidateInsertPosition
	add	esp, 20					; 00000014H
	mov	WORD PTR _nPositionOK$[ebp], ax

; 841  :                                            iLoadEntity,
; 842  :                                            lpView,
; 843  :                                            lpViewEntityCsr,
; 844  :                                            nPosition );
; 845  :    if ( nPositionOK < 0 )

	movsx	ecx, WORD PTR _nPositionOK$[ebp]
	test	ecx, ecx
	jge	SHORT $LN5@LoadEntity

; 846  :    {
; 847  :       fnOperationReturn( iLoadEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	117					; 00000075H
	call	_fnOperationReturn
	add	esp, 8

; 848  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@LoadEntity
$LN5@LoadEntity:

; 849  :    }
; 850  : 
; 851  :    // call fnCreateEntity to create the entity
; 852  :    nRC = fnCreateEntity( lpView, lpViewEntity, lpViewEntityCsr,

	movzx	eax, WORD PTR _bNewRoot$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 853  :                          nPosition, bNewRoot );
; 854  : 
; 855  :    if ( plpRecord )

	cmp	DWORD PTR _plpRecord$[ebp], 0
	je	SHORT $LN6@LoadEntity

; 856  :    {
; 857  :       LPENTITYINSTANCE lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$1[ebp], eax

; 858  : 
; 859  :       *plpRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	ecx, DWORD PTR _lpEntityInstance$1[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _plpRecord$[ebp]
	mov	DWORD PTR [ecx], eax

; 860  :       if ( *plpRecord == 0 )

	mov	edx, DWORD PTR _plpRecord$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN6@LoadEntity

; 861  :       {
; 862  :          fnCreateAttributeRecord( lpCurrentTask,

	mov	eax, DWORD PTR _lpEntityInstance$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH

; 863  :                                   lpViewEntity, lpEntityInstance );
; 864  :          *plpRecord = (zPCHAR) zGETPTR( lpEntityInstance->hPersistRecord );

	mov	eax, DWORD PTR _lpEntityInstance$1[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _plpRecord$[ebp]
	mov	DWORD PTR [edx], eax
$LN6@LoadEntity:

; 865  :       }
; 866  :    }
; 867  : 
; 868  :    // Return success ... we've managed to create an entity.
; 869  :    fnOperationReturn( iLoadEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	117					; 00000075H
	call	_fnOperationReturn
	add	esp, 8

; 870  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@LoadEntity:

; 871  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_LoadEntity@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_lpEntityInstance$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_GetEntityKey@8 PROC

; 2947 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2948 :    LPTASK            lpCurrentTask;
; 2949 :    LPVIEWENTITY      lpViewEntity;
; 2950 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2951 :    LPENTITYINSTANCE  lpEntityInstance;
; 2952 : 
; 2953 :    // Validate parameters
; 2954 :    if ( fnValidateCursorParameters( &lpCurrentTask,
; 2955 :                                     &lpViewEntity,
; 2956 :                                     0,
; 2957 :                                     &lpViewEntityCsr,
; 2958 :                                     0,
; 2959 :                                     iGetEntityKey,
; 2960 :                                     lpView,
; 2961 :                                     cpcEntityName,
; 2962 :                                     0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	108					; 0000006cH
	push	0
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@GetEntityK

; 2963 :    {
; 2964 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@GetEntityK
$LN2@GetEntityK:

; 2965 :    }
; 2966 : 
; 2967 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2968 : 
; 2969 : #ifdef DEBUG
; 2970 :    if ( lpEntityInstance->ulKey == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+50], 0
	jne	SHORT $LN3@GetEntityK

; 2971 :       SysMessageBox( lpView, "Internal Zeidon Error",

	push	1
	push	OFFSET $SG14232
	push	OFFSET $SG14233
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16
$LN3@GetEntityK:

; 2972 :                      "Entity Instance key is NULL", 1 );
; 2973 : #endif
; 2974 : 
; 2975 :    fnOperationReturn( iGetEntityKey, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	108					; 0000006cH
	call	_fnOperationReturn
	add	esp, 8

; 2976 :    return( lpEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
$LN1@GetEntityK:

; 2977 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_GetEntityKey@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpEntityInstance$1 = -44				; size = 4
_lpViewEntityCsr$ = -40					; size = 4
_lpWorkViewEntityCsr$2 = -36				; size = 4
_lpEntityInstance$3 = -32				; size = 4
_lpWorkView$4 = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpCurrentTask$ = -20					; size = 4
_nPositionOK$ = -16					; size = 2
_bNewRoot$ = -12					; size = 2
_n$5 = -8						; size = 2
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_nPosition$ = 16					; size = 2
_CreateEntity@12 PROC

; 598  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 599  :    LPTASK            lpCurrentTask;
; 600  :    LPVIEWENTITY      lpViewEntity;
; 601  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 602  :    zSHORT            nPositionOK;  // 0=after, 1=before
; 603  : // int               nExtraRecordFlags;
; 604  :    zSHORT            bNewRoot;
; 605  :    zSHORT            nRC;
; 606  : 
; 607  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 608  :    if ( (lpCurrentTask = fnOperationCall( iCreateEntity, lpView,
; 609  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	101					; 00000065H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@CreateEnti

; 610  :    {
; 611  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateEnti
$LN2@CreateEnti:

; 612  :    }
; 613  : 
; 614  :    // Validate that the entity exists.
; 615  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 616  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@CreateEnti

; 617  :    {
; 618  :       fnOperationReturn( iCreateEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	101					; 00000065H
	call	_fnOperationReturn
	add	esp, 8

; 619  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateEnti
$LN3@CreateEnti:

; 620  :    }
; 621  : 
; 622  :    // If the view is read only, issue an error.
; 623  :    if ( lpView->bReadOnly && lpViewEntity->bDerivedPath == FALSE )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN4@CreateEnti
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	SHORT $LN4@CreateEnti

; 624  :    {
; 625  :       // "KZOEE119 - Invalid View, View is Read Only"
; 626  :       fnIssueCoreError( lpCurrentTask, lpView, 8, 119, 0, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	0
	push	119					; 00000077H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 627  :       fnOperationReturn( iCreateEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	101					; 00000065H
	call	_fnOperationReturn
	add	esp, 8

; 628  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateEnti
$LN4@CreateEnti:

; 629  :    }
; 630  : 
; 631  :    // Make sure entity can be created.
; 632  :    if ( lpViewEntity->bCreate == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	and	edx, 1
	jne	SHORT $LN5@CreateEnti

; 633  :    {
; 634  :       // "KZOEE106 - Rules violation"
; 635  :       fnIssueCoreError( lpCurrentTask, lpView, 8, 106, 0,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG13517
	push	0
	push	106					; 0000006aH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 636  :                         "Entity Creation not allowed",
; 637  :                         lpViewEntity->szName );
; 638  :       fnOperationReturn( iCreateEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	101					; 00000065H
	call	_fnOperationReturn
	add	esp, 8

; 639  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateEnti
$LN5@CreateEnti:

; 640  :    }
; 641  : 
; 642  : #if 0
; 643  :    // Debugging code ... dks 2007.05.24
; 644  :    if ( lpViewEntityCsr->nLevel > 1 ) // parent exists at definition level
; 645  :    {
; 646  :       LPVIEWENTITYCSR lpParentViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );
; 647  :       LPENTITYINSTANCE lpParentEntityInstance;
; 648  : 
; 649  :       // If there is no parent entity cursor, then this entity is to be the new root
; 650  :       // of a subobject view, the parent in this case is the parent of the view.
; 651  :       if ( lpParentViewEntityCsr )
; 652  :       {
; 653  :          lpParentEntityInstance = zGETPTR( lpParentViewEntityCsr->hEntityInstance );
; 654  :       // if ( lpParentEntityInstance == UNSET_CSR )
; 655  :       //    SysMessageBox( 0, "CreateEntity", "UNSET_CSR", -1 );
; 656  :       }
; 657  :       else
; 658  :       {
; 659  :          LPVIEWCSR lpViewCsr = zGETPTR( lpViewEntityCsr->hViewCsr );
; 660  :          lpParentEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );
; 661  :       // if ( lpParentEntityInstance == UNSET_CSR )
; 662  :       //    SysMessageBox( 0, "CreateEntity", "UNSET_CSR", -1 );
; 663  :       }
; 664  :    }
; 665  : #endif
; 666  : 
; 667  :    // Validate that an insert of this entity in this instance at the specified
; 668  :    // position is valid.
; 669  :    nPositionOK = fnValidateInsertPosition( &bNewRoot, iCreateEntity, lpView,

	movzx	ecx, WORD PTR _nPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	101					; 00000065H
	lea	ecx, DWORD PTR _bNewRoot$[ebp]
	push	ecx
	call	_fnValidateInsertPosition
	add	esp, 20					; 00000014H
	mov	WORD PTR _nPositionOK$[ebp], ax

; 670  :                                            lpViewEntityCsr, nPosition );
; 671  :    if ( nPositionOK < 0 )

	movsx	edx, WORD PTR _nPositionOK$[ebp]
	test	edx, edx
	jge	SHORT $LN6@CreateEnti

; 672  :    {
; 673  :       fnOperationReturn( iCreateEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	101					; 00000065H
	call	_fnOperationReturn
	add	esp, 8

; 674  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateEnti
$LN6@CreateEnti:

; 675  :    }
; 676  : 
; 677  : #ifdef __ACTIVATE_CONSTRAINTS__
; 678  :    // If there is a create constraint active for this entity we need to
; 679  :    // use a work view, just in case the constraint handler objects and
; 680  :    // we have to set everything back to the way it was.
; 681  :    if ( lpViewEntity->bCreateConstraint )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	shr	edx, 1
	and	edx, 1
	je	$LN7@CreateEnti

; 682  :    {
; 683  :       zVIEW             lpWorkView;
; 684  :       LPVIEWENTITYCSR   lpWorkViewEntityCsr;
; 685  :       zSHORT            n;
; 686  :       LPENTITYINSTANCE  lpEntityInstance;
; 687  : 
; 688  :       CreateViewFromViewForTask( &lpWorkView, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpWorkView$4[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 689  : 
; 690  :       // Reset the View entity csr for work view.
; 691  :       fnValidViewEntity( &lpWorkViewEntityCsr, lpWorkView, cpcEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkView$4[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpWorkViewEntityCsr$2[ebp]
	push	ecx
	call	_fnValidViewEntity@16

; 692  : 
; 693  :       // Call fnCreateEntity to create the entity.
; 694  :       nRC = fnCreateEntity( lpWorkView, lpViewEntity,

	movzx	edx, WORD PTR _bNewRoot$[ebp]
	push	edx
	movzx	eax, WORD PTR _nPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkView$4[ebp]
	push	eax
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 695  :                             lpWorkViewEntityCsr,
; 696  :                             nPosition, bNewRoot );
; 697  :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@CreateEnti

; 698  :       {
; 699  :          fnDropView( lpWorkView );

	mov	edx, DWORD PTR _lpWorkView$4[ebp]
	push	edx
	call	_fnDropView@4

; 700  :          fnOperationReturn( iCreateEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	101					; 00000065H
	call	_fnOperationReturn
	add	esp, 8

; 701  :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@CreateEnti
$LN9@CreateEnti:

; 702  :       }
; 703  : 
; 704  :       // If the view entity has any initialization attributes, initialize
; 705  :       // them now.
; 706  :       fnInitAttributes( lpWorkView, lpViewEntity );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWorkView$4[ebp]
	push	edx
	call	_fnInitAttributes@8

; 707  : 
; 708  :       // Set bCreated flag so constraint operation can modify keys if
; 709  :       // wanted.  It will be turned on again later but that's OK.
; 710  :       lpEntityInstance = zGETPTR( lpWorkViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpWorkViewEntityCsr$2[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$1[ebp], eax

; 711  :       lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2
	mov	ecx, DWORD PTR _lpEntityInstance$1[ebp]
	mov	DWORD PTR [ecx+6], eax

; 712  : 
; 713  :       n = fnInvokeECEOperation( lpWorkView, lpViewEntity,

	push	0
	push	3
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkView$4[ebp]
	push	ecx
	call	_fnInvokeECEOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _n$5[ebp], ax

; 714  :                                 lpCurrentTask, zECE_CREATE, 0 );
; 715  :       if ( n )

	movsx	edx, WORD PTR _n$5[ebp]
	test	edx, edx
	je	SHORT $LN10@CreateEnti

; 716  :       {
; 717  :          fnDeleteEntity( lpWorkView, lpViewEntity, lpWorkViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkView$4[ebp]
	push	eax
	call	_fnDeleteEntity
	add	esp, 20					; 00000014H

; 718  :                          zREPOS_NONE, lpCurrentTask );
; 719  :          fnDropView( lpWorkView );

	mov	ecx, DWORD PTR _lpWorkView$4[ebp]
	push	ecx
	call	_fnDropView@4

; 720  :          fnOperationReturn( iCreateEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	101					; 00000065H
	call	_fnOperationReturn
	add	esp, 8

; 721  :          return( n );

	mov	ax, WORD PTR _n$5[ebp]
	jmp	$LN1@CreateEnti

; 722  :       }

	jmp	SHORT $LN11@CreateEnti
$LN10@CreateEnti:

; 723  :       else
; 724  :       {
; 725  :          // Save cursors from the work view to the original.
; 726  :          fnSetViewFromView( lpView, lpWorkView );

	mov	eax, DWORD PTR _lpWorkView$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetViewFromView
	add	esp, 8

; 727  : 
; 728  :          // Drop work view.
; 729  :          fnDropView( lpWorkView );

	mov	edx, DWORD PTR _lpWorkView$4[ebp]
	push	edx
	call	_fnDropView@4
$LN11@CreateEnti:

; 730  :       }
; 731  :    }

	jmp	SHORT $LN8@CreateEnti
$LN7@CreateEnti:

; 732  :    else
; 733  : #endif
; 734  :    {
; 735  :       // Call fnCreateEntity to create the entity.
; 736  :       nRC = fnCreateEntity( lpView, lpViewEntity, lpViewEntityCsr,

	movzx	eax, WORD PTR _bNewRoot$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 737  :                             nPosition, bNewRoot );
; 738  : 
; 739  :       // If the view entity has any initialization attributes, initialize them now.
; 740  :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN8@CreateEnti

; 741  :          fnInitAttributes( lpView, lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnInitAttributes@8
$LN8@CreateEnti:

; 742  :    }
; 743  : 
; 744  :    // If the entity instance has been successfully created, mark the
; 745  :    // Entity instance as owning the entity record and check the
; 746  :    // instance's parent to see if any other linked instances require
; 747  :    // spawning this entity type.  If so, issue a warning message for
; 748  :    // now since the overhead in establishing a view for spawning
; 749  :    // entity creations may not be worth the effort and performance
; 750  :    // lost when compared to the benefit gained.  Unfortunately, this
; 751  :    // check is done after the entity has been created (i.e. the horse
; 752  :    // is already out of the barn).
; 753  :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN13@CreateEnti

; 754  :    {
; 755  :       LPENTITYINSTANCE  lpEntityInstance;
; 756  : 
; 757  :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$3[ebp], eax

; 758  :       lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$3[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2
	mov	ecx, DWORD PTR _lpEntityInstance$3[ebp]
	mov	DWORD PTR [ecx+6], eax

; 759  : 
; 760  : #if 0  // We have a case where the hParent is UNSET_CSR (1), but
; 761  :        // lpViewEntityCsr->hParent is 0 and not sure what to do about it.  // dks 2007.05.16
; 762  :       if ( lpEntityInstance->hParent == UNSET_CSR )
; 763  :       {
; 764  :          LPVIEWENTITYCSR   lpParentViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent )
; 765  :          LPENTITYINSTANCE  lpEntityInstance;
; 766  : 
; 767  :          SysMessageBox( 0, "Establishing Cursor", "Prior to SpawnCreateEntity", -1 );
; 768  :          fnEstablishCursorForView( lpViewEntityCsr );
; 769  :       }
; 770  : #endif
; 771  : 
; 772  :       // Spawn the entity create if necessary.
; 773  :       fnSpawnCreateEntity( lpView, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSpawnCreateEntity
	add	esp, 8

; 774  : 
; 775  : // >>> RAD54278-1 BEGIN
; 776  :       fnSetUpdateIndicator( 0, lpEntityInstance, 0, TRUE, FALSE, FALSE );

	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$3[ebp]
	push	ecx
	push	0
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$LN13@CreateEnti:

; 777  : // >>> RAD54278-1 END
; 778  :    }
; 779  : 
; 780  :    // Return success, we've managed to create an entity.
; 781  :    fnOperationReturn( iCreateEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	101					; 00000065H
	call	_fnOperationReturn
	add	esp, 8

; 782  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CreateEnti:

; 783  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CreateEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lInputTok$1 = -48					; size = 4
tv195 = -44						; size = 4
tv194 = -40						; size = 4
_lpViewOD$ = -36					; size = 4
tv159 = -32						; size = 4
tv158 = -28						; size = 4
_lpSearchViewEntityCsr$2 = -24				; size = 4
_lpViewCsr$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpViewEntity$ = -8					; size = 4
_nStartLevel$ = -4					; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_CheckEntityInView@8 PROC

; 294  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 295  :    LPTASK            lpCurrentTask;
; 296  :    LPVIEWCSR         lpViewCsr;
; 297  :    LPVIEWOD          lpViewOD;
; 298  :    LPVIEWENTITY      lpViewEntity;
; 299  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 300  :    zSHORT            nStartLevel;
; 301  : 
; 302  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 303  :    if ( (lpCurrentTask = fnOperationCall( iCheckEntityInView, lpView,
; 304  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	132					; 00000084H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN11@CheckEntit

; 305  :    {
; 306  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CheckEntit
$LN11@CheckEntit:

; 307  :    }
; 308  : 
; 309  :    // Get the view csr for the view.
; 310  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 311  : 
; 312  :    // Get the view object definition for the view
; 313  :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 314  : 
; 315  :    // Validate that the entity exists.
; 316  :    lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 317  :    lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 318  : 
; 319  :    // If the root cursor is not the first cursor, skip ViewEntities
; 320  :    // until we get to the entity matching the root cursor.
; 321  :    if ( lpViewEntityCsr != zGETPTR( lpViewCsr->hFirstOD_EntityCsr ) )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], eax
	je	SHORT $LN12@CheckEntit

; 322  :    {
; 323  :       LPVIEWENTITYCSR lpSearchViewEntityCsr;
; 324  : 
; 325  :       lpSearchViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntityCsr$2[ebp], eax
$LN2@CheckEntit:

; 326  :       while ( lpSearchViewEntityCsr != lpViewEntityCsr )

	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$2[ebp]
	cmp	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	je	SHORT $LN12@CheckEntit

; 327  :       {
; 328  :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 329  :          lpSearchViewEntityCsr++;

	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$2[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpSearchViewEntityCsr$2[ebp], ecx

; 330  :       }

	jmp	SHORT $LN2@CheckEntit
$LN12@CheckEntit:

; 331  :    }
; 332  : 
; 333  :    nStartLevel = lpViewEntityCsr->nLevel;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ax, WORD PTR [edx+22]
	mov	WORD PTR _nStartLevel$[ebp], ax

; 334  : 
; 335  :    if ( cpcEntityName[ 0 ] == '\xff' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, -1
	jne	SHORT $LN6@CheckEntit

; 336  :    {
; 337  :       zLONG lInputTok;
; 338  : 
; 339  :       lInputTok = *((zPLONG) (cpcEntityName + 1));

	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	DWORD PTR _lInputTok$1[ebp], eax
$LN4@CheckEntit:

; 340  :       while ( lpViewEntityCsr && lpViewEntity->lEREntTok != lInputTok )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN5@CheckEntit
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+195]
	cmp	edx, DWORD PTR _lInputTok$1[ebp]
	je	SHORT $LN5@CheckEntit

; 341  :       {
; 342  :          if ( lpViewEntityCsr->nLevel < nStartLevel )  // dks 2006.05.08 10B diff

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN15@CheckEntit

; 343  :          {
; 344  :             lpViewEntityCsr = 0;

	mov	DWORD PTR _lpViewEntityCsr$[ebp], 0

; 345  :             break;

	jmp	SHORT $LN5@CheckEntit
$LN15@CheckEntit:

; 346  :          }
; 347  : 
; 348  :          lpViewEntity    = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 349  :          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 350  :       }

	jmp	SHORT $LN4@CheckEntit
$LN5@CheckEntit:

; 351  :    }

	jmp	$LN14@CheckEntit
$LN6@CheckEntit:

; 352  :    else
; 353  :    {
; 354  :       while ( lpViewEntityCsr &&

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	$LN14@CheckEntit
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN22@CheckEntit
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv159[ebp], eax
	jmp	SHORT $LN23@CheckEntit
$LN22@CheckEntit:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN20@CheckEntit
	mov	DWORD PTR tv158[ebp], 1
	jmp	SHORT $LN21@CheckEntit
$LN20@CheckEntit:
	mov	DWORD PTR tv158[ebp], -1
$LN21@CheckEntit:
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR tv159[ebp], edx
$LN23@CheckEntit:
	cmp	DWORD PTR tv159[ebp], 0
	je	SHORT $LN14@CheckEntit

; 355  :               zstrcmp( lpViewEntity->szName, cpcEntityName ) != 0 )
; 356  :       {
; 357  :          if ( lpViewEntityCsr->nLevel < nStartLevel )  // dks 2006.05.08 10B diff

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN16@CheckEntit

; 358  :          {
; 359  :             lpViewEntityCsr = 0;

	mov	DWORD PTR _lpViewEntityCsr$[ebp], 0

; 360  :             break;

	jmp	SHORT $LN14@CheckEntit
$LN16@CheckEntit:

; 361  :          }
; 362  : 
; 363  :          lpViewEntity    = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 364  :          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 365  :       }

	jmp	$LN6@CheckEntit
$LN14@CheckEntit:

; 366  :    }
; 367  : 
; 368  :    // If entity found return OK.
; 369  :    if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN17@CheckEntit

; 370  :    {
; 371  :       fnOperationReturn( iCheckEntityInView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	132					; 00000084H
	call	_fnOperationReturn
	add	esp, 8

; 372  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@CheckEntit
$LN17@CheckEntit:

; 373  :    }
; 374  : 
; 375  :    // Now make sure that the entity is valid for the view.
; 376  :    for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN10@CheckEntit
$LN8@CheckEntit:

; 378  :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN10@CheckEntit:

; 377  :          lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN9@CheckEntit

; 379  :    {
; 380  :       if ( zstrcmp( lpViewEntity->szName, cpcEntityName ) == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN26@CheckEntit
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv195[ebp], eax
	jmp	SHORT $LN27@CheckEntit
$LN26@CheckEntit:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN24@CheckEntit
	mov	DWORD PTR tv194[ebp], 1
	jmp	SHORT $LN25@CheckEntit
$LN24@CheckEntit:
	mov	DWORD PTR tv194[ebp], -1
$LN25@CheckEntit:
	mov	ecx, DWORD PTR tv194[ebp]
	mov	DWORD PTR tv195[ebp], ecx
$LN27@CheckEntit:
	cmp	DWORD PTR tv195[ebp], 0
	jne	SHORT $LN18@CheckEntit

; 381  :       {
; 382  :          fnOperationReturn( iCheckEntityInView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	132					; 00000084H
	call	_fnOperationReturn
	add	esp, 8

; 383  :          return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@CheckEntit
$LN18@CheckEntit:

; 384  :       }
; 385  :    }

	jmp	$LN8@CheckEntit
$LN9@CheckEntit:

; 386  : 
; 387  : #if 0  // we don't want an error ... we're just asking the question
; 388  : 
; 389  :    // Note, the name may not be invalid, it may simply be out of view
; 390  :    // because of a call to SetViewToSubobject
; 391  :    //  "KZOEE103 - Invalid Entity name for View"
; 392  :    TraceLine( "Invalid Entity name: %s   for View (0x%08x)   OD: %s",
; 393  :               cpcEntityName, lpView, lpViewOD->szName );
; 394  :    fnIssueCoreError( lpCurrentTask, lpView, 8, 103, 0,
; 395  :                      lpViewOD->szName,
; 396  :                      TrueName( cpcEntityName, zSHOW_ZKEY ) );
; 397  : #endif
; 398  : 
; 399  :    fnOperationReturn( iCheckEntityInView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	132					; 00000084H
	call	_fnOperationReturn
	add	esp, 8

; 400  :    return( -2 );

	mov	eax, -2					; fffffffeH
$LN1@CheckEntit:

; 401  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CheckEntityInView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -32					; size = 4
_lpViewEntity$ = -28					; size = 4
_lpViewCsr$ = -24					; size = 4
_lpCurrentTask$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpEntityInstance$ = -12				; size = 4
_lpScanEntityInstance$ = -8				; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_CheckExistenceOfEntity@8 PROC

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 144  :    LPVIEWOI          lpViewOI;
; 145  :    LPVIEWCSR         lpViewCsr;
; 146  :    LPVIEWENTITY      lpViewEntity;
; 147  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 148  :    LPENTITYINSTANCE  lpEntityInstance;
; 149  :    LPENTITYINSTANCE  lpScanEntityInstance;
; 150  :    LPTASK            lpCurrentTask;
; 151  :    zSHORT            nRC;
; 152  : 
; 153  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 154  :    if ( (lpCurrentTask = fnOperationCall( iCheckExistenceOfEntity, lpView,
; 155  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	100					; 00000064H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN6@CheckExist

; 156  :    {
; 157  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CheckExist
$LN6@CheckExist:

; 158  :    }
; 159  : 
; 160  :    // Set lpViewCsr
; 161  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 162  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 163  : 
; 164  :    // Validate that the entity exists.
; 165  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 166  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN7@CheckExist

; 167  :    {
; 168  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CheckExist
$LN7@CheckExist:

; 169  :    }
; 170  : 
; 171  :    nRC = zCURSOR_NULL;  // default RC to -3 (NULL Instance)

	mov	edx, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], dx

; 172  : 
; 173  :    // If object instance is not empty, check for entity.
; 174  :    if ( lpViewOI->hRootEntityInstance )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	$LN8@CheckExist

; 175  :    {
; 176  :       if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN9@CheckExist

; 177  :          fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN9@CheckExist:

; 178  : 
; 179  :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 180  : 
; 181  :       // if the cursor needs to be established, do it now
; 182  :       if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN8@CheckExist

; 183  :       {
; 184  :          if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	$LN11@CheckExist

; 185  :          {
; 186  :             // The EntityInstance is hidden, we start off assuming
; 187  :             // that all twins are hidden, scan 'forward' for
; 188  :             // any twin occurrence that is not hidden, if none are
; 189  :             // found then scan 'backward' for any twin occurrence
; 190  :             // that is not hidden.  If an occurrence is found that
; 191  :             // is not hidden, the return code is set to indicate
; 192  :             // that the cursor is undefined.
; 193  : 
; 194  :             // default indicates that there are no entity instances
; 195  :             nRC = zCURSOR_NULL;

	mov	ecx, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], cx

; 196  :             lpScanEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEntityInstance$[ebp], eax
$LN2@CheckExist:

; 197  :             while ( lpScanEntityInstance )

	cmp	DWORD PTR _lpScanEntityInstance$[ebp], 0
	je	SHORT $LN3@CheckExist

; 198  :             {
; 199  :                if ( lpScanEntityInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpScanEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN13@CheckExist

; 200  :                {
; 201  :                   nRC = zCURSOR_UNDEFINED;

	mov	eax, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], ax

; 202  :                   break;

	jmp	SHORT $LN3@CheckExist
$LN13@CheckExist:

; 203  :                }
; 204  : 
; 205  :                lpScanEntityInstance = zGETPTR( lpScanEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpScanEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEntityInstance$[ebp], eax

; 206  :             }

	jmp	SHORT $LN2@CheckExist
$LN3@CheckExist:

; 207  : 
; 208  :             if ( nRC == zCURSOR_NULL )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	jne	SHORT $LN14@CheckExist

; 209  :             {
; 210  :                lpScanEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEntityInstance$[ebp], eax
$LN4@CheckExist:

; 211  :                while ( lpScanEntityInstance )

	cmp	DWORD PTR _lpScanEntityInstance$[ebp], 0
	je	SHORT $LN14@CheckExist

; 212  :                {
; 213  :                   if ( lpScanEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpScanEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN15@CheckExist

; 214  :                   {
; 215  :                      nRC = zCURSOR_UNDEFINED;

	mov	edx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], dx

; 216  :                      break;

	jmp	SHORT $LN14@CheckExist
$LN15@CheckExist:

; 217  :                   }
; 218  : 
; 219  :                   lpScanEntityInstance = zGETPTR( lpScanEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpScanEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEntityInstance$[ebp], eax

; 220  :                }

	jmp	SHORT $LN4@CheckExist
$LN14@CheckExist:

; 221  :             }
; 222  :          }

	jmp	SHORT $LN8@CheckExist
$LN11@CheckExist:

; 223  :          else
; 224  :             nRC = zCURSOR_SET;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN8@CheckExist:

; 225  :       }
; 226  : 
; 227  : // DGC 4-29-2002
; 228  : // Made a change requested by Doug, Phil, and TB.  A cursor is returned NULL
; 229  : // even if the parent cursors are NULL.  We used to return UNDEFINED if a
; 230  : // parent was NULL but that made a certain situation ambiguous.
; 231  : #if 0
; 232  :       // The instance appears to be NULL, However it may be null under
; 233  :       // a deleted parent somewhere. Find the supposed parent to the
; 234  :       // entity and make sure the parent is not deleted!!!
; 235  :       if ( lpEntityInstance == 0 )
; 236  :       {
; 237  :          for ( ; ; )
; 238  :          {
; 239  :             while ( lpViewEntityCsr && lpViewEntityCsr->hEntityInstance == 0 )
; 240  :                lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );
; 241  : 
; 242  :             if ( lpViewEntityCsr == 0 ||
; 243  :                  lpViewEntityCsr->hEntityInstance != UNSET_CSR )
; 244  :             {
; 245  :                break;
; 246  :             }
; 247  : 
; 248  :             fnEstablishCursorForView( lpViewEntityCsr );
; 249  :          }
; 250  : 
; 251  :          if ( lpViewEntityCsr )
; 252  :             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );
; 253  :          else
; 254  :             lpEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );
; 255  : 
; 256  :          if ( lpEntityInstance && lpEntityInstance->u.nInd.bHidden )
; 257  :          {
; 258  : #if 0  // Gig, 10/26/92 ?? Should this be an error ???
; 259  :             //  "KZOEE254 - Entity cursor is undefined"
; 260  :             fnIssueCoreError( lpTask, lpView, 8, 254, 0,
; 261  :                               lpViewEntity->szName, 0 );
; 262  :             nRC = zCALL_ERROR;
; 263  : #else
; 264  :             nRC = zCURSOR_UNDEFINED;
; 265  : #endif
; 266  :          }
; 267  :       }
; 268  : #endif
; 269  :    }
; 270  : 
; 271  :    fnOperationReturn( iCheckExistenceOfEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	100					; 00000064H
	call	_fnOperationReturn
	add	esp, 8

; 272  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CheckExist:

; 273  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CheckExistenceOfEntity@8 ENDP
_TEXT	ENDS
END
