; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEERAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG13458 DB	01H DUP (?)
$SG13459 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG13372 DB	'TZDME001', 00H
	ORG $+3
$SG13373 DB	'Invalid Input Data Type.', 00H
	ORG $+3
$SG13375 DB	'TZDME002', 00H
	ORG $+3
$SG13376 DB	'Text String exceeds attribute length.', 00H
	ORG $+2
$SG13378 DB	'TZDME003', 00H
	ORG $+3
$SG13379 DB	'Attribute Type invalid for this Domain.', 00H
$SG13381 DB	'TZDME004', 00H
	ORG $+3
$SG13382 DB	'Invalid Domain Entry Type.', 00H
	ORG $+1
$SG13384 DB	'TZDME005', 00H
	ORG $+3
$SG13385 DB	'Table_Handler invalid for this Domain.', 00H
	ORG $+1
$SG13387 DB	'TZDME006', 00H
	ORG $+3
$SG13388 DB	'Integer overflow.', 00H
	ORG $+2
$SG13390 DB	'TZDME007', 00H
	ORG $+3
$SG13391 DB	'Integer underflow.', 00H
	ORG $+1
$SG13393 DB	'TZDME008', 00H
	ORG $+3
$SG13394 DB	'Could not find context for Domain.', 00H
	ORG $+1
$SG13396 DB	'TZDME009', 00H
	ORG $+3
$SG13397 DB	'Context edit string is invalid for Domain.', 00H
	ORG $+1
$SG13399 DB	'TZDME010', 00H
	ORG $+3
$SG13400 DB	'DateTime input string invalid.', 00H
	ORG $+1
$SG13402 DB	'TZDME011', 00H
	ORG $+3
$SG13403 DB	'Error storing value in record.', 00H
	ORG $+1
$SG13405 DB	'TZDME012', 00H
	ORG $+3
$SG13406 DB	'Context Required when Type is INTEGER. ', 00H
$SG13408 DB	'TZDME013', 00H
	ORG $+3
$SG13409 DB	'Context/cType Combination is invalid.', 00H
	ORG $+2
$SG13411 DB	'TZDME014', 00H
	ORG $+3
$SG13412 DB	'Context is for retrieval only.', 00H
	ORG $+1
$SG13414 DB	'TZDME015', 00H
	ORG $+3
$SG13415 DB	'Context only used for arithmetic operations.', 00H
	ORG $+3
$SG13417 DB	'TZDME016', 00H
	ORG $+3
$SG13418 DB	'Input invalid for context.', 00H
	ORG $+1
$SG13420 DB	'TZDME017', 00H
	ORG $+3
$SG13421 DB	'Context Required when Type is DECIMAL.', 00H
	ORG $+1
$SG13423 DB	'TZDME018', 00H
	ORG $+3
$SG13424 DB	'Context edit string is null.', 00H
	ORG $+3
$SG13426 DB	'TZDME019', 00H
	ORG $+3
$SG13427 DB	'International number formatting is not available.', 00H
	ORG $+2
$SG13429 DB	'TZDME020', 00H
	ORG $+3
$SG13430 DB	'Invalid decimal string.', 00H
$SG13432 DB	'TZDME021', 00H
	ORG $+3
$SG13433 DB	'Return area not large enough for formatted string.', 00H
	ORG $+1
$SG13435 DB	'TZDME022', 00H
	ORG $+3
$SG13436 DB	'Only AlphaNumeric chars are allowed.', 00H
	ORG $+3
$SG13438 DB	'TZDME023', 00H
	ORG $+3
$SG13439 DB	'Value is out of valid range.', 00H
	ORG $+3
$SG13441 DB	'TZDME024', 00H
	ORG $+3
$SG13442 DB	'Invalid integer string.', 00H
$SG13444 DB	'TZDME025', 00H
	ORG $+3
$SG13445 DB	'Invalid table value.', 00H
	ORG $+3
$SG13447 DB	'Unknown Error Message ', 00H
	ORG $+1
$SG13449 DB	'DomainMessage', 00H
	ORG $+2
$SG13450 DB	'[Debug]', 00H
$SG13455 DB	0aH, 0aH, ' Debug Info 1:', 09H, 00H
	ORG $+2
$SG13457 DB	0aH, ' Debug Info 2:', 09H, 00H
	ORG $+3
$SG13460 DB	'Domain Name Unknown', 00H
$SG13461 DB	'DomainError: %s - %s   Type: %c   for Domain: %s  Info: '
	DB	'%s.%s', 00H
	ORG $+2
$SG13478 DB	'IssueError: ', 00H
	ORG $+3
$SG13505 DB	'No message', 00H
	ORG $+1
$SG13506 DB	'(er) - recursive error ', 00H
$SG13547 DB	'Unknown Error Message (', 00H
$SG13548 DB	') ', 00H
	ORG $+1
$SG13551 DB	',', 0aH, 0aH, ' ', 00H
	ORG $+3
$SG13553 DB	',', 0aH, 00H
	ORG $+1
$SG13554 DB	'IssueOE_Error : ', 00H
	ORG $+3
$SG13556 DB	',', 0aH, 0aH, 'View Object: ', 00H
	ORG $+3
$SG13559 DB	')', 00H
	ORG $+2
$SG13560 DB	',', 0aH, 'Operation: ', 00H
	ORG $+2
$SG13562 DB	', ', 00H
	ORG $+1
$SG13564 DB	') ', 00H
	ORG $+1
$SG13565 DB	'IssueOE_Error:  %s  Severity: %d', 00H
_DATA	ENDS
PUBLIC	_IssueError@16
PUBLIC	_IssueOE_Error@28
PUBLIC	_SendDomainError@28
PUBLIC	_fnIssueCoreError
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_MiValidView@4:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysGetBaseMessage@12:PROC
EXTRN	_SysGetOperationMessage@12:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_szlApplicationLogicError:DWORD
EXTRN	_szlOE_SystemError:DWORD
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeraa.c
_TEXT	SEGMENT
_lpFirstSubtask$1 = -8					; size = 4
_nRC$2 = -4						; size = 2
_lpTask$ = 8						; size = 4
_lpView$ = 12						; size = 4
_nSeverity$ = 16					; size = 2
_nID$ = 20						; size = 2
_lLong$ = 24						; size = 4
_cpcMessage1$ = 28					; size = 4
_cpcMessage2$ = 32					; size = 4
_fnIssueCoreError PROC

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 310  :    if ( lpTask->nRecurse )

	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+56]
	test	ecx, ecx
	je	SHORT $LN2@fnIssueCor

; 311  :    {
; 312  :       if ( cpcMessage2 == 0 || *cpcMessage2 == 0 )

	cmp	DWORD PTR _cpcMessage2$[ebp], 0
	je	SHORT $LN5@fnIssueCor
	mov	edx, DWORD PTR _cpcMessage2$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN4@fnIssueCor
$LN5@fnIssueCor:

; 313  :       {
; 314  :          if ( cpcMessage1 == 0 || *cpcMessage1 == 0 )

	cmp	DWORD PTR _cpcMessage1$[ebp], 0
	je	SHORT $LN8@fnIssueCor
	mov	ecx, DWORD PTR _cpcMessage1$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN6@fnIssueCor
$LN8@fnIssueCor:

; 315  :             cpcMessage2 = "No message";

	mov	DWORD PTR _cpcMessage2$[ebp], OFFSET $SG13505
	jmp	SHORT $LN4@fnIssueCor
$LN6@fnIssueCor:

; 316  :          else
; 317  :             cpcMessage2 = cpcMessage1;

	mov	eax, DWORD PTR _cpcMessage1$[ebp]
	mov	DWORD PTR _cpcMessage2$[ebp], eax
$LN4@fnIssueCor:

; 318  :       }
; 319  : 
; 320  :       TraceLineS( "(er) - recursive error ", cpcMessage2 );

	mov	ecx, DWORD PTR _cpcMessage2$[ebp]
	push	ecx
	push	OFFSET $SG13506
	call	_TraceLineS@8

; 321  :    // SysMessageBox( "(er) - recursive error ", cpcMessage2, 1 );
; 322  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnIssueCor

; 323  :    }

	jmp	$LN1@fnIssueCor
$LN2@fnIssueCor:

; 324  :    else
; 325  :    {
; 326  :       LPSUBTASK lpFirstSubtask = zGETPTR( lpTask->hFirstSubtask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSubtask$1[ebp], eax

; 327  :       zSHORT    nRC;
; 328  : 
; 329  :       if ( MiValidView( lpView ) == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MiValidView@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN9@fnIssueCor

; 330  :          lpView = zGETPTR( lpFirstSubtask->hSubtaskView );

	mov	eax, DWORD PTR _lpFirstSubtask$1[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax
$LN9@fnIssueCor:

; 331  : 
; 332  :       lpTask->nRecurse++;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	ax, WORD PTR [edx+56]
	add	ax, 1
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [ecx+56], ax

; 333  : 
; 334  :       nRC = IssueOE_Error( lpView, nSeverity, nID,

	mov	edx, DWORD PTR _cpcMessage2$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMessage1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lLong$[ebp]
	push	ecx
	push	1000					; 000003e8H
	movzx	edx, WORD PTR _nID$[ebp]
	push	edx
	movzx	eax, WORD PTR _nSeverity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_IssueOE_Error@28
	mov	WORD PTR _nRC$2[ebp], ax

; 335  :                            zMSGQ_SYSTEM_ERROR,
; 336  :                            lLong, cpcMessage1, cpcMessage2 );
; 337  :       lpTask->nRecurse--;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	ax, WORD PTR [edx+56]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [ecx+56], ax

; 338  :       return( nRC );

	mov	ax, WORD PTR _nRC$2[ebp]
$LN1@fnIssueCor:

; 339  :    }
; 340  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnIssueCoreError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeraa.c
_TEXT	SEGMENT
_pchTitle$ = -576					; size = 4
_lMsgType$ = -572					; size = 4
tv276 = -568						; size = 4
tv271 = -564						; size = 4
tv267 = -560						; size = 4
tv264 = -556						; size = 4
tv68 = -552						; size = 4
_nEntityAttrFlag$ = -548				; size = 2
_szMsg$ = -544						; size = 512
_sz$1 = -32						; size = 10
_szMsgID$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_zView$ = 8						; size = 4
_lpDomain$ = 12						; size = 4
_nSeverity$ = 16					; size = 2
_lMessageID$ = 20					; size = 4
_lInfo$ = 24						; size = 4
_cpcInfo1$ = 28						; size = 4
_cpcInfo2$ = 32						; size = 4
_SendDomainError@28 PROC

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 576				; 00000240H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 59   :    zPCHAR      pchTitle;
; 60   :    zLONG       lMsgType;
; 61   :    zCHAR       szMsg[ 512 ];
; 62   :    zCHAR       szMsgID[ 16 ];
; 63   :    zSHORT      nEntityAttrFlag = 1;

	mov	eax, 1
	mov	WORD PTR _nEntityAttrFlag$[ebp], ax

; 64   : 
; 65   :    pchTitle = szlApplicationLogicError;

	mov	ecx, DWORD PTR _szlApplicationLogicError
	mov	DWORD PTR _pchTitle$[ebp], ecx

; 66   :    if ( nSeverity >= 0 && nSeverity < 16 )

	movsx	edx, WORD PTR _nSeverity$[ebp]
	test	edx, edx
	jl	SHORT $LN4@SendDomain
	movsx	eax, WORD PTR _nSeverity$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN4@SendDomain

; 67   :       lMsgType = zMSGQ_DOMAIN_ERROR;

	mov	DWORD PTR _lMsgType$[ebp], 200		; 000000c8H
	jmp	SHORT $LN5@SendDomain
$LN4@SendDomain:

; 68   :    else
; 69   :       lMsgType = zMSGQ_SYSTEM_ERROR;

	mov	DWORD PTR _lMsgType$[ebp], 1000		; 000003e8H
$LN5@SendDomain:

; 70   : 
; 71   :    switch ( lMessageID )

	mov	ecx, DWORD PTR _lMessageID$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 1
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 24			; 00000018H
	ja	$LN31@SendDomain
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN49@SendDomain[eax*4]
$LN6@SendDomain:

; 72   :    {
; 73   :       case 1:
; 74   :          zstrcpy( szMsgID, "TZDME001" );

	push	OFFSET $SG13372
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 75   :          zstrcpy( szMsg, "Invalid Input Data Type." );

	push	OFFSET $SG13373
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 76   :          nEntityAttrFlag = 0;

	xor	eax, eax
	mov	WORD PTR _nEntityAttrFlag$[ebp], ax

; 77   :          break;

	jmp	$LN2@SendDomain
$LN7@SendDomain:

; 78   : 
; 79   :       case 2:
; 80   :          zstrcpy( szMsgID, "TZDME002" );

	push	OFFSET $SG13375
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 81   :          zstrcpy( szMsg, "Text String exceeds attribute length." );

	push	OFFSET $SG13376
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 82   :          break;

	jmp	$LN2@SendDomain
$LN8@SendDomain:

; 83   : 
; 84   :       case 3:
; 85   :          zstrcpy( szMsgID, "TZDME003" );

	push	OFFSET $SG13378
	lea	eax, DWORD PTR _szMsgID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 86   :          zstrcpy( szMsg, "Attribute Type invalid for this Domain." );

	push	OFFSET $SG13379
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 87   :          break;

	jmp	$LN2@SendDomain
$LN9@SendDomain:

; 88   : 
; 89   :       case 4:
; 90   :          zstrcpy( szMsgID, "TZDME004" );

	push	OFFSET $SG13381
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 91   :          zstrcpy( szMsg, "Invalid Domain Entry Type." );

	push	OFFSET $SG13382
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 92   :          break;

	jmp	$LN2@SendDomain
$LN10@SendDomain:

; 93   : 
; 94   :       case 5:
; 95   :          zstrcpy( szMsgID, "TZDME005" );

	push	OFFSET $SG13384
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 96   :          zstrcpy( szMsg, "Table_Handler invalid for this Domain." );

	push	OFFSET $SG13385
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 97   :          break;

	jmp	$LN2@SendDomain
$LN11@SendDomain:

; 98   : 
; 99   :       case 6:
; 100  :          zstrcpy( szMsgID, "TZDME006" );

	push	OFFSET $SG13387
	lea	eax, DWORD PTR _szMsgID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 101  :          zstrcpy( szMsg, "Integer overflow." );

	push	OFFSET $SG13388
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 102  :          break;

	jmp	$LN2@SendDomain
$LN12@SendDomain:

; 103  : 
; 104  :       case 7:
; 105  :          zstrcpy( szMsgID, "TZDME007" );

	push	OFFSET $SG13390
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 106  :          zstrcpy( szMsg, "Integer underflow." );

	push	OFFSET $SG13391
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 107  :          break;

	jmp	$LN2@SendDomain
$LN13@SendDomain:

; 108  : 
; 109  :       case 8:
; 110  :          zstrcpy( szMsgID, "TZDME008" );

	push	OFFSET $SG13393
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 111  :          zstrcpy( szMsg, "Could not find context for Domain." );

	push	OFFSET $SG13394
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 112  :          break;

	jmp	$LN2@SendDomain
$LN14@SendDomain:

; 113  : 
; 114  :       case 9:
; 115  :          zstrcpy( szMsgID, "TZDME009" );

	push	OFFSET $SG13396
	lea	eax, DWORD PTR _szMsgID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 116  :          zstrcpy( szMsg, "Context edit string is invalid for Domain." );

	push	OFFSET $SG13397
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 117  :          break;

	jmp	$LN2@SendDomain
$LN15@SendDomain:

; 118  : 
; 119  :       case 10:
; 120  :          zstrcpy( szMsgID, "TZDME010" );

	push	OFFSET $SG13399
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 121  :          zstrcpy( szMsg, "DateTime input string invalid." );

	push	OFFSET $SG13400
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 122  :          nEntityAttrFlag = 0;

	xor	ecx, ecx
	mov	WORD PTR _nEntityAttrFlag$[ebp], cx

; 123  :          break;

	jmp	$LN2@SendDomain
$LN16@SendDomain:

; 124  : 
; 125  :       case 11:
; 126  :          zstrcpy( szMsgID, "TZDME011" );

	push	OFFSET $SG13402
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 127  :          zstrcpy( szMsg, "Error storing value in record." );

	push	OFFSET $SG13403
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 128  :          break;

	jmp	$LN2@SendDomain
$LN17@SendDomain:

; 129  : 
; 130  :       case 12:
; 131  :          zstrcpy( szMsgID, "TZDME012" );

	push	OFFSET $SG13405
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 132  :          zstrcpy( szMsg, "Context Required when Type is INTEGER. " );

	push	OFFSET $SG13406
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 133  :          break;

	jmp	$LN2@SendDomain
$LN18@SendDomain:

; 134  : 
; 135  :       case 13:
; 136  :          zstrcpy( szMsgID, "TZDME013" );

	push	OFFSET $SG13408
	lea	eax, DWORD PTR _szMsgID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 137  :          zstrcpy( szMsg, "Context/cType Combination is invalid." );

	push	OFFSET $SG13409
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 138  :          break;

	jmp	$LN2@SendDomain
$LN19@SendDomain:

; 139  : 
; 140  :       case 14:
; 141  :          zstrcpy( szMsgID, "TZDME014" );

	push	OFFSET $SG13411
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 142  :          zstrcpy( szMsg, "Context is for retrieval only." );

	push	OFFSET $SG13412
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 143  :          break;

	jmp	$LN2@SendDomain
$LN20@SendDomain:

; 144  : 
; 145  :       case 15:
; 146  :          zstrcpy( szMsgID, "TZDME015" );

	push	OFFSET $SG13414
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 147  :          zstrcpy( szMsg, "Context only used for arithmetic operations." );

	push	OFFSET $SG13415
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 148  :          break;

	jmp	$LN2@SendDomain
$LN21@SendDomain:

; 149  : 
; 150  :       case 16:
; 151  :          zstrcpy( szMsgID, "TZDME016" );

	push	OFFSET $SG13417
	lea	eax, DWORD PTR _szMsgID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 152  :          zstrcpy( szMsg, "Input invalid for context." );

	push	OFFSET $SG13418
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 153  :          break;

	jmp	$LN2@SendDomain
$LN22@SendDomain:

; 154  : 
; 155  :       case 17:
; 156  :          zstrcpy( szMsgID, "TZDME017" );

	push	OFFSET $SG13420
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 157  :          zstrcpy( szMsg, "Context Required when Type is DECIMAL." );

	push	OFFSET $SG13421
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 158  :          break;

	jmp	$LN2@SendDomain
$LN23@SendDomain:

; 159  : 
; 160  :       case 18:
; 161  :          zstrcpy( szMsgID, "TZDME018" );

	push	OFFSET $SG13423
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 162  :          zstrcpy( szMsg, "Context edit string is null." );

	push	OFFSET $SG13424
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 163  :          break;

	jmp	$LN2@SendDomain
$LN24@SendDomain:

; 164  : 
; 165  :       case 19:
; 166  :          zstrcpy( szMsgID, "TZDME019" );

	push	OFFSET $SG13426
	lea	eax, DWORD PTR _szMsgID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 167  :          zstrcpy( szMsg, "International number formatting is not available." );

	push	OFFSET $SG13427
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 168  :          break;

	jmp	$LN2@SendDomain
$LN25@SendDomain:

; 169  : 
; 170  :       case 20:
; 171  :          zstrcpy( szMsgID, "TZDME020" );

	push	OFFSET $SG13429
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 172  :          zstrcpy( szMsg, "Invalid decimal string." );

	push	OFFSET $SG13430
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 173  :          nEntityAttrFlag = 0;

	xor	ecx, ecx
	mov	WORD PTR _nEntityAttrFlag$[ebp], cx

; 174  :          break;

	jmp	$LN2@SendDomain
$LN26@SendDomain:

; 175  : 
; 176  :       case 21:
; 177  :          zstrcpy( szMsgID, "TZDME021" );

	push	OFFSET $SG13432
	lea	edx, DWORD PTR _szMsgID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 178  :          zstrcpy( szMsg, "Return area not large enough for formatted string." );

	push	OFFSET $SG13433
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 179  :          break;

	jmp	$LN2@SendDomain
$LN27@SendDomain:

; 180  : 
; 181  :       case 22:
; 182  :          zstrcpy( szMsgID, "TZDME022" );

	push	OFFSET $SG13435
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 183  :          zstrcpy( szMsg, "Only AlphaNumeric chars are allowed." );

	push	OFFSET $SG13436
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 184  :          nEntityAttrFlag = 0;

	xor	eax, eax
	mov	WORD PTR _nEntityAttrFlag$[ebp], ax

; 185  :          break;

	jmp	$LN2@SendDomain
$LN28@SendDomain:

; 186  : 
; 187  :       case 23:
; 188  :          zstrcpy( szMsgID, "TZDME023" );

	push	OFFSET $SG13438
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 189  :          zstrcpy( szMsg, "Value is out of valid range." );

	push	OFFSET $SG13439
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 190  :          nEntityAttrFlag = 0;

	xor	eax, eax
	mov	WORD PTR _nEntityAttrFlag$[ebp], ax

; 191  :          break;

	jmp	SHORT $LN2@SendDomain
$LN29@SendDomain:

; 192  : 
; 193  :       case 24:
; 194  :          zstrcpy( szMsgID, "TZDME024" );

	push	OFFSET $SG13441
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 195  :          zstrcpy( szMsg, "Invalid integer string." );

	push	OFFSET $SG13442
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 196  :          nEntityAttrFlag = 0;

	xor	eax, eax
	mov	WORD PTR _nEntityAttrFlag$[ebp], ax

; 197  :          break;

	jmp	SHORT $LN2@SendDomain
$LN30@SendDomain:

; 198  : 
; 199  :       case 25:
; 200  :          zstrcpy( szMsgID, "TZDME025" );

	push	OFFSET $SG13444
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 201  :          zstrcpy( szMsg, "Invalid table value." );

	push	OFFSET $SG13445
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 202  :          nEntityAttrFlag = 0;

	xor	eax, eax
	mov	WORD PTR _nEntityAttrFlag$[ebp], ax

; 203  :          break;

	jmp	SHORT $LN2@SendDomain
$LN31@SendDomain:

; 204  : 
; 205  :       default:
; 206  :          zstrcpy( szMsg, "Unknown Error Message " );

	push	OFFSET $SG13447
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN2@SendDomain:

; 207  :    }
; 208  : 
; 209  :    // If flag is off then check Zeidon INI file to see if we should turn it
; 210  :    // on anyway.
; 211  :    if ( nEntityAttrFlag == 0 )

	movsx	edx, WORD PTR _nEntityAttrFlag$[ebp]
	test	edx, edx
	jne	SHORT $LN32@SendDomain

; 212  :    {
; 213  :       zCHAR sz[ 10 ];
; 214  : 
; 215  :       SysReadZeidonIni( -1, "[Debug]", "DomainMessage", sz );

	lea	eax, DWORD PTR _sz$1[ebp]
	push	eax
	push	OFFSET $SG13449
	push	OFFSET $SG13450
	push	-1
	call	_SysReadZeidonIni@16

; 216  :       if ( sz[ 0 ] == 'Y' || sz[ 0 ] == 'y' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$1[ebp+edx]
	cmp	eax, 89					; 00000059H
	je	SHORT $LN34@SendDomain
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$1[ebp+edx]
	cmp	eax, 121				; 00000079H
	jne	SHORT $LN32@SendDomain
$LN34@SendDomain:

; 217  :          nEntityAttrFlag = 1;

	mov	ecx, 1
	mov	WORD PTR _nEntityAttrFlag$[ebp], cx
$LN32@SendDomain:

; 218  :    }
; 219  : 
; 220  :    if ( nEntityAttrFlag == 1 )

	movsx	edx, WORD PTR _nEntityAttrFlag$[ebp]
	cmp	edx, 1
	jne	SHORT $LN35@SendDomain

; 221  :    {
; 222  :       // If the message created was for a programming error (not an expected
; 223  :       // end-user message), then add the Entity and Attribute.  This information
; 224  :       // only appears when there is no LAND.MSG ... otherwise the german text
; 225  :       // overwrites everything!
; 226  :       if ( cpcInfo1 )

	cmp	DWORD PTR _cpcInfo1$[ebp], 0
	je	SHORT $LN36@SendDomain

; 227  :       {
; 228  :          zstrcat( szMsg, "\n\n Debug Info 1:\t" );

	push	OFFSET $SG13455
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 229  :          zstrcat( szMsg, cpcInfo1 );

	mov	ecx, DWORD PTR _cpcInfo1$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN36@SendDomain:

; 230  :       }
; 231  : 
; 232  :       if ( cpcInfo2 )

	cmp	DWORD PTR _cpcInfo2$[ebp], 0
	je	SHORT $LN35@SendDomain

; 233  :       {
; 234  :          zstrcat( szMsg, "\n Debug Info 2:\t" );

	push	OFFSET $SG13457
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 235  :          zstrcat( szMsg, cpcInfo2 );

	mov	ecx, DWORD PTR _cpcInfo2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN35@SendDomain:

; 236  :       }
; 237  :    }
; 238  : 
; 239  :    TraceLine( "DomainError: %s - %s   Type: %c   for Domain: %s  Info: %s.%s",

	cmp	DWORD PTR _cpcInfo2$[ebp], 0
	je	SHORT $LN41@SendDomain
	mov	eax, DWORD PTR _cpcInfo2$[ebp]
	mov	DWORD PTR tv264[ebp], eax
	jmp	SHORT $LN42@SendDomain
$LN41@SendDomain:
	mov	DWORD PTR tv264[ebp], OFFSET $SG13458
$LN42@SendDomain:
	cmp	DWORD PTR _cpcInfo1$[ebp], 0
	je	SHORT $LN43@SendDomain
	mov	ecx, DWORD PTR _cpcInfo1$[ebp]
	mov	DWORD PTR tv267[ebp], ecx
	jmp	SHORT $LN44@SendDomain
$LN43@SendDomain:
	mov	DWORD PTR tv267[ebp], OFFSET $SG13459
$LN44@SendDomain:
	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	SHORT $LN45@SendDomain
	mov	edx, DWORD PTR _lpDomain$[ebp]
	add	edx, 6
	mov	DWORD PTR tv271[ebp], edx
	jmp	SHORT $LN46@SendDomain
$LN45@SendDomain:
	mov	DWORD PTR tv271[ebp], OFFSET $SG13460
$LN46@SendDomain:
	cmp	DWORD PTR _lpDomain$[ebp], 0
	je	SHORT $LN47@SendDomain
	mov	eax, DWORD PTR _lpDomain$[ebp]
	movsx	ecx, BYTE PTR [eax+65]
	mov	DWORD PTR tv276[ebp], ecx
	jmp	SHORT $LN48@SendDomain
$LN47@SendDomain:
	mov	DWORD PTR tv276[ebp], 63		; 0000003fH
$LN48@SendDomain:
	mov	edx, DWORD PTR tv264[ebp]
	push	edx
	mov	eax, DWORD PTR tv267[ebp]
	push	eax
	mov	ecx, DWORD PTR tv271[ebp]
	push	ecx
	mov	edx, DWORD PTR tv276[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsgID$[ebp]
	push	ecx
	push	OFFSET $SG13461
	call	_TraceLine
	add	esp, 28					; 0000001cH

; 240  :               szMsgID, szMsg, lpDomain ? lpDomain->cDomainType : '?',
; 241  :               lpDomain ? lpDomain->szName : "Domain Name Unknown",
; 242  :               cpcInfo1 ? cpcInfo1 : "", cpcInfo2 ? cpcInfo2 : "" );
; 243  :    if ( nSeverity == -1 ) // domain validation only ... no error message!

	movsx	edx, WORD PTR _nSeverity$[ebp]
	cmp	edx, -1
	jne	SHORT $LN38@SendDomain

; 244  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SendDomain
	jmp	SHORT $LN1@SendDomain
$LN38@SendDomain:

; 245  :    else
; 246  :       return( MessageSend( zView, szMsgID, pchTitle, szMsg, lMsgType, 0 ) );

	push	0
	mov	eax, DWORD PTR _lMsgType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTitle$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMsgID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	call	_MessageSend@24
$LN1@SendDomain:

; 247  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN49@SendDomain:
	DD	$LN6@SendDomain
	DD	$LN7@SendDomain
	DD	$LN8@SendDomain
	DD	$LN9@SendDomain
	DD	$LN10@SendDomain
	DD	$LN11@SendDomain
	DD	$LN12@SendDomain
	DD	$LN13@SendDomain
	DD	$LN14@SendDomain
	DD	$LN15@SendDomain
	DD	$LN16@SendDomain
	DD	$LN17@SendDomain
	DD	$LN18@SendDomain
	DD	$LN19@SendDomain
	DD	$LN20@SendDomain
	DD	$LN21@SendDomain
	DD	$LN22@SendDomain
	DD	$LN23@SendDomain
	DD	$LN24@SendDomain
	DD	$LN25@SendDomain
	DD	$LN26@SendDomain
	DD	$LN27@SendDomain
	DD	$LN28@SendDomain
	DD	$LN29@SendDomain
	DD	$LN30@SendDomain
_SendDomainError@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeraa.c
_TEXT	SEGMENT
_pchTitle$ = -600					; size = 4
_lpFirstSubtask$1 = -596				; size = 4
$T2 = -592						; size = 4
$T3 = -588						; size = 4
$T4 = -584						; size = 4
_lpViewOD$ = -580					; size = 4
_zView$ = -576						; size = 4
_k$5 = -572						; size = 2
_lpTask$ = -568						; size = 4
_szCoreMessage$ = -564					; size = 512
_cpcMsgId$ = -52					; size = 16
_szOperationName$6 = -36				; size = 32
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_nSeverity$ = 12					; size = 2
_nID$ = 16						; size = 2
_lMsgType$ = 20						; size = 4
_lLong$ = 24						; size = 4
_cpcMessage1$ = 28					; size = 4
_cpcMessage2$ = 32					; size = 4
_IssueOE_Error@28 PROC

; 362  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 600				; 00000258H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 363  :    LPTASK      lpTask;
; 364  :    zCHAR       szCoreMessage[ 512 ];
; 365  :    zCHAR       cpcMsgId[ 16 ];
; 366  :    zVIEW       zView;
; 367  :    zPCHAR      pchTitle;
; 368  :    LPVIEWOD    lpViewOD;
; 369  : 
; 370  : // SysMessageBox( 0, "IssueOE_Error", cpcMessage1, -1 ); call MessageBox directly
; 371  : 
; 372  :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN5@IssueOE_Er

; 373  :    {
; 374  :       lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 375  : 
; 376  :       // If the view is valid we'll pass it along, otherwise we will
; 377  :       // pass the first SubtaskView for the task.
; 378  :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN7@IssueOE_Er

; 379  :          zView = lpView;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _zView$[ebp], edx
	jmp	SHORT $LN8@IssueOE_Er
$LN7@IssueOE_Er:

; 380  :       else
; 381  :       {
; 382  :          LPSUBTASK lpFirstSubtask = zGETPTR( lpTask->hFirstSubtask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSubtask$1[ebp], eax

; 383  :          zView = zGETPTR( lpFirstSubtask->hSubtaskView );

	mov	edx, DWORD PTR _lpFirstSubtask$1[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _zView$[ebp], eax
$LN8@IssueOE_Er:

; 384  :       }
; 385  : 
; 386  :       lpViewOD = zGETPTR( zView->hViewOD );

	mov	ecx, DWORD PTR _zView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 387  :    }

	jmp	SHORT $LN6@IssueOE_Er
$LN5@IssueOE_Er:

; 388  :    else
; 389  :    {
; 390  :       lpTask = 0;

	mov	DWORD PTR _lpTask$[ebp], 0

; 391  :       zView = 0;

	mov	DWORD PTR _zView$[ebp], 0

; 392  :       lpViewOD = 0;

	mov	DWORD PTR _lpViewOD$[ebp], 0
$LN6@IssueOE_Er:

; 393  :    }
; 394  : 
; 395  :    szCoreMessage[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 512			; 00000200H
	jae	SHORT $LN22@IssueOE_Er
	jmp	SHORT $LN23@IssueOE_Er
$LN22@IssueOE_Er:
	call	___report_rangecheckfailure
$LN23@IssueOE_Er:
	mov	edx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szCoreMessage$[ebp+edx], 0

; 396  :    SysGetBaseMessage( szCoreMessage, nID, 256 );

	push	256					; 00000100H
	movsx	eax, WORD PTR _nID$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_SysGetBaseMessage@12

; 397  :    if ( szCoreMessage[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szCoreMessage$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN9@IssueOE_Er

; 398  :    {
; 399  :       zstrcpy( szCoreMessage, "Unknown Error Message (" );

	push	OFFSET $SG13547
	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 400  :       zltoa( nID, &szCoreMessage[ 490 ] );

	push	10					; 0000000aH
	mov	eax, 1
	imul	ecx, eax, 490
	lea	edx, DWORD PTR _szCoreMessage$[ebp+ecx]
	push	edx
	movsx	eax, WORD PTR _nID$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 401  :       zstrcat( szCoreMessage, &szCoreMessage[ 490 ] );

	mov	ecx, 1
	imul	edx, ecx, 490
	lea	eax, DWORD PTR _szCoreMessage$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 402  :       zstrcat( szCoreMessage, ") " );

	push	OFFSET $SG13548
	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN9@IssueOE_Er:

; 403  :    }
; 404  : 
; 405  :    if ( lLong )

	cmp	DWORD PTR _lLong$[ebp], 0
	je	SHORT $LN10@IssueOE_Er

; 406  :    {
; 407  :       zltoa( lLong, &szCoreMessage[ 490 ] );

	push	10					; 0000000aH
	mov	eax, 1
	imul	ecx, eax, 490
	lea	edx, DWORD PTR _szCoreMessage$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lLong$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 408  :       zstrcat( szCoreMessage, &szCoreMessage[ 490 ] );

	mov	ecx, 1
	imul	edx, ecx, 490
	lea	eax, DWORD PTR _szCoreMessage$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN10@IssueOE_Er:

; 409  :    }
; 410  : 
; 411  :    if ( cpcMessage1 )  // if any additional information

	cmp	DWORD PTR _cpcMessage1$[ebp], 0
	je	SHORT $LN11@IssueOE_Er

; 412  :    {
; 413  :       zstrcat( szCoreMessage, ",\n\n " );

	push	OFFSET $SG13551
	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 414  :       zstrcat( szCoreMessage, cpcMessage1 );

	mov	eax, DWORD PTR _cpcMessage1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 415  :       if ( cpcMessage2 )

	cmp	DWORD PTR _cpcMessage2$[ebp], 0
	je	SHORT $LN11@IssueOE_Er

; 416  :       {
; 417  :          zstrcat( szCoreMessage, ",\n" );

	push	OFFSET $SG13553
	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 418  :          zstrcat( szCoreMessage, cpcMessage2 );

	mov	eax, DWORD PTR _cpcMessage2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN11@IssueOE_Er:

; 419  :       }
; 420  :    }
; 421  : 
; 422  :    TraceLineS( "IssueOE_Error : ", szCoreMessage );

	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	push	OFFSET $SG13554
	call	_TraceLineS@8

; 423  : 
; 424  :    // See if we can determine the view object resulting in the error.
; 425  :    // But don't do it for EE071 or EE101 as it implies erroneous information.
; 426  :    if ( lpView && lpViewOD && nID != 71 && nID != 101 )  // dks 2006.04.27

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN13@IssueOE_Er
	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN13@IssueOE_Er
	movsx	eax, WORD PTR _nID$[ebp]
	cmp	eax, 71					; 00000047H
	je	SHORT $LN13@IssueOE_Er
	movsx	ecx, WORD PTR _nID$[ebp]
	cmp	ecx, 101				; 00000065H
	je	SHORT $LN13@IssueOE_Er

; 427  :    {
; 428  :        zstrcat( szCoreMessage, ",\n\nView Object: " );

	push	OFFSET $SG13556
	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 429  :        zstrcat( szCoreMessage, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN13@IssueOE_Er:

; 430  :    }
; 431  : 
; 432  :    // See if we can determine the operation.
; 433  :    if ( lpTask && lpTask->bAudit && lpTask->nOperIdx > -1 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN14@IssueOE_Er
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, 1
	je	$LN14@IssueOE_Er
	mov	ecx, DWORD PTR _lpTask$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, -1
	jle	$LN14@IssueOE_Er

; 434  :    {
; 435  :       zCHAR szOperationName[ 32 ];
; 436  : 
; 437  :       szOperationName[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 32			; 00000020H
	jae	SHORT $LN24@IssueOE_Er
	jmp	SHORT $LN25@IssueOE_Er
$LN24@IssueOE_Er:
	call	___report_rangecheckfailure
$LN25@IssueOE_Er:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szOperationName$6[ebp+edx], 0

; 438  :       SysGetOperationMessage( szOperationName,

	push	31					; 0000001fH
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+60]
	push	eax
	lea	ecx, DWORD PTR _szOperationName$6[ebp]
	push	ecx
	call	_SysGetOperationMessage@12

; 439  :                            // lpTask->nOper[ 0 ], 31 );
; 440  :                               lpTask->nOper[ lpTask->nOperIdx ], 31 );
; 441  :       if ( szOperationName[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szOperationName$6[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN15@IssueOE_Er

; 442  :       {
; 443  :          szOperationName[ 0 ] = '(';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szOperationName$6[ebp+eax], 40 ; 00000028H

; 444  :       // zltoa( lpTask->nOper[ 0 ], &szOperationName[ 1 ] );
; 445  :          zltoa( lpTask->nOper[ lpTask->nOperIdx ], &szOperationName[ 1 ] );

	push	10					; 0000000aH
	mov	ecx, 1
	shl	ecx, 0
	lea	edx, DWORD PTR _szOperationName$6[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, WORD PTR [edx+ecx*2+60]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 446  :          zstrcat( szOperationName, ")" );

	push	OFFSET $SG13559
	lea	ecx, DWORD PTR _szOperationName$6[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN15@IssueOE_Er:

; 447  :       }
; 448  : 
; 449  :       zstrcat( szCoreMessage, ",\nOperation: " );

	push	OFFSET $SG13560
	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 450  :       zstrcat( szCoreMessage, szOperationName );

	lea	eax, DWORD PTR _szOperationName$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 451  :       if ( lpTask->nOperIdx > 0 )

	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, WORD PTR [edx+58]
	test	eax, eax
	jle	$LN14@IssueOE_Er

; 452  :       {
; 453  :          zSHORT k;
; 454  :          for ( k = lpTask->nOperIdx - 1; k > -1 ; k-- )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	sub	edx, 1
	mov	WORD PTR _k$5[ebp], dx
	jmp	SHORT $LN4@IssueOE_Er
$LN2@IssueOE_Er:
	mov	ax, WORD PTR _k$5[ebp]
	sub	ax, 1
	mov	WORD PTR _k$5[ebp], ax
$LN4@IssueOE_Er:
	movsx	ecx, WORD PTR _k$5[ebp]
	cmp	ecx, -1
	jle	$LN14@IssueOE_Er

; 455  :          {
; 456  :             zstrcat( szCoreMessage, ", " );

	push	OFFSET $SG13562
	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 457  :             szOperationName[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 32			; 00000020H
	jae	SHORT $LN26@IssueOE_Er
	jmp	SHORT $LN27@IssueOE_Er
$LN26@IssueOE_Er:
	call	___report_rangecheckfailure
$LN27@IssueOE_Er:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szOperationName$6[ebp+edx], 0

; 458  :             SysGetOperationMessage( szOperationName, lpTask->nOper[ k ], 31 );

	push	31					; 0000001fH
	movsx	eax, WORD PTR _k$5[ebp]
	mov	ecx, DWORD PTR _lpTask$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+60]
	push	edx
	lea	eax, DWORD PTR _szOperationName$6[ebp]
	push	eax
	call	_SysGetOperationMessage@12

; 459  :             if ( szOperationName[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szOperationName$6[ebp+edx]
	test	eax, eax
	jne	SHORT $LN17@IssueOE_Er

; 460  :             {
; 461  :                szOperationName[ 0 ] = '(';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szOperationName$6[ebp+edx], 40 ; 00000028H

; 462  :                zltoa( lpTask->nOper[ k ], &szOperationName[ 1 ] );

	push	10					; 0000000aH
	mov	eax, 1
	shl	eax, 0
	lea	ecx, DWORD PTR _szOperationName$6[ebp+eax]
	push	ecx
	movsx	edx, WORD PTR _k$5[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+60]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 463  :                zstrcat( szOperationName, ") " );

	push	OFFSET $SG13564
	lea	edx, DWORD PTR _szOperationName$6[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN17@IssueOE_Er:

; 464  :             }
; 465  : 
; 466  :             zstrcat( szCoreMessage, szOperationName );

	lea	eax, DWORD PTR _szOperationName$6[ebp]
	push	eax
	lea	ecx, DWORD PTR _szCoreMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 467  :          }

	jmp	$LN2@IssueOE_Er
$LN14@IssueOE_Er:

; 468  :       }
; 469  :    }
; 470  : 
; 471  :    TraceLine( "IssueOE_Error:  %s  Severity: %d", szCoreMessage, nSeverity );

	movsx	edx, WORD PTR _nSeverity$[ebp]
	push	edx
	lea	eax, DWORD PTR _szCoreMessage$[ebp]
	push	eax
	push	OFFSET $SG13565
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 472  : 
; 473  :    if ( nSeverity > 16 )

	movsx	ecx, WORD PTR _nSeverity$[ebp]
	cmp	ecx, 16					; 00000010H
	jle	SHORT $LN18@IssueOE_Er

; 474  :       return( IssueError( zView, nSeverity, nID, szCoreMessage ) );

	lea	edx, DWORD PTR _szCoreMessage$[ebp]
	push	edx
	movzx	eax, WORD PTR _nID$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nSeverity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	call	_IssueError@16
	jmp	SHORT $LN21@IssueOE_Er
$LN18@IssueOE_Er:

; 475  : 
; 476  : #ifndef __DO_MSGOBJ__
; 477  :    if ( lpTask == 0 )
; 478  :       return( IssueError( zView, nSeverity, nID, szCoreMessage ) );
; 479  : #endif
; 480  : 
; 481  :    if ( nSeverity == 16 )

	movsx	eax, WORD PTR _nSeverity$[ebp]
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN19@IssueOE_Er

; 482  :       pchTitle = szlOE_SystemError;

	mov	ecx, DWORD PTR _szlOE_SystemError
	mov	DWORD PTR _pchTitle$[ebp], ecx
	jmp	SHORT $LN20@IssueOE_Er
$LN19@IssueOE_Er:

; 483  :    else
; 484  :       pchTitle = szlApplicationLogicError;

	mov	edx, DWORD PTR _szlApplicationLogicError
	mov	DWORD PTR _pchTitle$[ebp], edx
$LN20@IssueOE_Er:

; 485  : 
; 486  :    zltoa( nID, cpcMsgId ); // convert message id to a string

	push	10					; 0000000aH
	lea	eax, DWORD PTR _cpcMsgId$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nID$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 487  :    return( MessageSend( zView, cpcMsgId,

	push	0
	movsx	edx, WORD PTR _nSeverity$[ebp]
	add	edx, DWORD PTR _lMsgType$[ebp]
	push	edx
	lea	eax, DWORD PTR _szCoreMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlApplicationLogicError
	push	ecx
	lea	edx, DWORD PTR _cpcMsgId$[ebp]
	push	edx
	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	call	_MessageSend@24
$LN21@IssueOE_Er:

; 488  :                         szlApplicationLogicError,
; 489  :                         szCoreMessage,
; 490  :                         lMsgType + nSeverity, 0 ) );
; 491  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_IssueOE_Error@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeeraa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
_szTitle$ = -4						; size = 4
_lpView$ = 8						; size = 4
_nSeverity$ = 12					; size = 2
_nID$ = 16						; size = 2
_cpcMessage$ = 20					; size = 4
_IssueError@16 PROC

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 275  :    LPTASK    lpTask;
; 276  :    zPCHAR    szTitle;
; 277  : 
; 278  :    if ( nSeverity < 16 )

	movsx	eax, WORD PTR _nSeverity$[ebp]
	cmp	eax, 16					; 00000010H
	jge	SHORT $LN2@IssueError

; 279  :       szTitle = szlApplicationLogicError;

	mov	ecx, DWORD PTR _szlApplicationLogicError
	mov	DWORD PTR _szTitle$[ebp], ecx
	jmp	SHORT $LN3@IssueError
$LN2@IssueError:

; 280  :    else
; 281  :       szTitle = szlOE_SystemError;

	mov	edx, DWORD PTR _szlOE_SystemError
	mov	DWORD PTR _szTitle$[ebp], edx
$LN3@IssueError:

; 282  : 
; 283  :    // NOTE, there is no guarantee that lpView is set OR valid.
; 284  :    lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 285  : 
; 286  :    // Log the error with the subtask
; 287  :    // TEMP For now, we just spit all errors out to the window!!! TEMP
; 288  :    TraceLineS( "IssueError: ", cpcMessage );

	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	push	OFFSET $SG13478
	call	_TraceLineS@8

; 289  :    SysMessageBox( lpView, szTitle, cpcMessage, 1 );         // TEMP

	push	1
	mov	eax, DWORD PTR _cpcMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 290  : 
; 291  :    return( 0 );   // Error creating error object

	xor	eax, eax

; 292  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_IssueError@16 ENDP
_TEXT	ENDS
END
