; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEMIAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG13801 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG13568 DB	'.', 00H
	ORG $+2
$SG13733 DB	'ON', 00H
	ORG $+1
$SG13734 DB	'OFF', 00H
$SG13785 DB	'On', 00H
	ORG $+1
$SG13735 DB	'MiGetSetViewTaskAppFlags setting KeepAlive for Applicati'
	DB	'on: %s to %s', 00H
	ORG $+3
$SG13786 DB	'Off', 00H
$SG13787 DB	'Trace dataspace ', 00H
	ORG $+3
$SG13792 DB	'(mi) List OE Memory ###### BEGIN ###### Task: 0x%08x', 00H
	ORG $+3
$SG13793 DB	'???', 00H
$SG13794 DB	'  Memory [%x] for Task 0x%08x   App: %s   Size: %d   Sta'
	DB	'tus: ', 00H
	ORG $+2
$SG13797 DB	'Shutdown', 00H
	ORG $+3
$SG13798 DB	'Active', 00H
	ORG $+1
$SG13800 DB	'   [%lx] size: %ld; fs ceiling: %ld; total fs: %ld ==> %'
	DB	's', 00H
	ORG $+2
$SG13802 DB	'(mi) List OE Memory ###### END ###### - total = ', 00H
_DATA	ENDS
PUBLIC	_MiGetDateTimeForOI@8
PUBLIC	_MiGetERTokenForEntity@8
PUBLIC	_MiGetParentEntityNameForView@12
PUBLIC	_MiGetInstanceID_ForView@4
PUBLIC	_MiGetKeyFromInstance@16
PUBLIC	_MiGetObjectNameForView@8
PUBLIC	_MiGetTemporalStateOfEntity@8
PUBLIC	_MiGetUpdateForView@4
PUBLIC	_MiSetInstanceUpdateFlag@8
PUBLIC	_MiHasPersistentChanges@4
PUBLIC	_MiGetOI_ReleaseForView@8
PUBLIC	_MiSetOI_ReleaseForView@8
PUBLIC	_MiCompareOI_ToRelease@8
PUBLIC	_MiGetActivateFlags@4
PUBLIC	_MiGetSetViewTaskAppFlags@16
PUBLIC	_MiValidView@4
PUBLIC	_MiGetTypeForViewEntityAttr@12
PUBLIC	_MiGetUpdateForViewEntityAttr@16
PUBLIC	_MiGetCardinalityForEntity@16
PUBLIC	_MiListOE_Memory@8
PUBLIC	_MiEntityVersioned@8
PUBLIC	_MiGetViewEntityForView@8
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_SysValidAddress@12:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnGetStringFromAttribute:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_fnEntityInstanceIsDead@4:PROC
EXTRN	_fnInstanceVersioned:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnStartBrowseOfTaskList@8:PROC
EXTRN	_fnEndBrowseOfTaskList@4:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnValidViewAttrib:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_g_bTraceDataspace:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -12					; size = 4
_lpViewEntity$ = -8					; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_MiGetViewEntityForView@8 PROC

; 814  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 815  :    LPTASK           lpCurrentTask;
; 816  :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 817  :    LPVIEWENTITY     lpViewEntity;
; 818  : 
; 819  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 820  :    if ( (lpCurrentTask = fnOperationCall( iMiGetViewEntityForView, lpView,
; 821  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	458					; 000001caH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetViewE

; 822  :    {
; 823  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@MiGetViewE
$LN2@MiGetViewE:

; 824  :    }
; 825  : 
; 826  :    if ( cpcEntityName == 0 )

	cmp	DWORD PTR _cpcEntityName$[ebp], 0
	jne	SHORT $LN3@MiGetViewE

; 827  :    {
; 828  :       fnOperationReturn( iMiGetViewEntityForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	458					; 000001caH
	call	_fnOperationReturn
	add	esp, 8

; 829  :       return( (LPVIEWENTITY) zGETPTR( lpView->hViewOD ) );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $LN1@MiGetViewE
$LN3@MiGetViewE:

; 830  :    }
; 831  : 
; 832  :    // Validate that the entity exists.
; 833  :    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 834  : 
; 835  :    fnOperationReturn( iMiGetViewEntityForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	458					; 000001caH
	call	_fnOperationReturn
	add	esp, 8

; 836  :    return( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
$LN1@MiGetViewE:

; 837  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiGetViewEntityForView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpEntityInstance$ = -20				; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpViewEntity$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_MiEntityVersioned@8 PROC

; 1405 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1406 :    LPTASK            lpCurrentTask;
; 1407 :    LPVIEWENTITY      lpViewEntity;
; 1408 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1409 :    LPENTITYINSTANCE  lpEntityInstance;
; 1410 :    zSHORT            nRC;
; 1411 : 
; 1412 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 1413 :    if ( (lpCurrentTask = fnOperationCall( iMiEntityVersioned, lpView,
; 1414 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	469					; 000001d5H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiEntityVe

; 1415 :    {
; 1416 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiEntityVe
$LN2@MiEntityVe:

; 1417 :    }
; 1418 : 
; 1419 :    // Validate that the entity exists
; 1420 :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 1421 :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@MiEntityVe

; 1422 :    {
; 1423 :       fnOperationReturn( iMiEntityVersioned, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	469					; 000001d5H
	call	_fnOperationReturn
	add	esp, 8

; 1424 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiEntityVe
$LN3@MiEntityVe:

; 1425 :    }
; 1426 : 
; 1427 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1428 : 
; 1429 :    nRC = fnInstanceVersioned( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnInstanceVersioned
	add	esp, 4
	movzx	dx, al
	mov	WORD PTR _nRC$[ebp], dx

; 1430 : 
; 1431 :    fnOperationReturn( iMiEntityVersioned, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	469					; 000001d5H
	call	_fnOperationReturn
	add	esp, 8

; 1432 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@MiEntityVe:

; 1433 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiEntityVersioned@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
$T1 = -844						; size = 4
_lpPrevFreespace$ = -840				; size = 4
$T2 = -836						; size = 4
tv140 = -832						; size = 4
_lpApp$ = -828						; size = 4
tv72 = -824						; size = 4
tv68 = -820						; size = 4
_ulFreeBytes$ = -816					; size = 4
_ulTotalAlloc$ = -812					; size = 4
_hDataHeader$ = -808					; size = 4
_lpDataHeader$ = -804					; size = 4
_lpNextFreespace$ = -800				; size = 4
_hTask$ = -796						; size = 4
_lpTask$ = -792						; size = 4
_k$ = -788						; size = 2
_by$ = -781						; size = 1
_szMsg$ = -780						; size = 513
_szPageTable$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_nLevel$ = 12						; size = 2
_MiListOE_Memory@8 PROC

; 1278 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 844				; 0000034cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1279 :    zCHAR        szPageTable[ zSHR_MAX_PAGES + 1 ];
; 1280 :    zCHAR        szMsg[ 256 + zSHR_MAX_PAGES + 1 ];
; 1281 :    zULONG       ulFreeBytes;
; 1282 :    zULONG       ulTotalAlloc = 0;

	mov	DWORD PTR _ulTotalAlloc$[ebp], 0

; 1283 :    LPTASK       hTask = 0;

	mov	DWORD PTR _hTask$[ebp], 0

; 1284 :    LPTASK       lpTask;
; 1285 :    LPAPP        lpApp;
; 1286 :    LPDATAHEADER hDataHeader;
; 1287 :    LPDATAHEADER lpDataHeader;
; 1288 :    LPFREESPACE  lpPrevFreespace;
; 1289 :    LPFREESPACE  lpNextFreespace;
; 1290 :    zBYTE        by;
; 1291 :    zSHORT       k;
; 1292 : 
; 1293 :    if ( nLevel == -1 )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, -1
	jne	SHORT $LN11@MiListOE_M

; 1294 :    {
; 1295 :       g_bTraceDataspace = !g_bTraceDataspace;

	movzx	ecx, BYTE PTR _g_bTraceDataspace
	test	ecx, ecx
	jne	SHORT $LN20@MiListOE_M
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN21@MiListOE_M
$LN20@MiListOE_M:
	mov	DWORD PTR tv68[ebp], 0
$LN21@MiListOE_M:
	mov	dl, BYTE PTR tv68[ebp]
	mov	BYTE PTR _g_bTraceDataspace, dl

; 1296 :       TraceLineS( "Trace dataspace ", g_bTraceDataspace ? "On" : "Off" );

	movzx	eax, BYTE PTR _g_bTraceDataspace
	test	eax, eax
	je	SHORT $LN22@MiListOE_M
	mov	DWORD PTR tv72[ebp], OFFSET $SG13785
	jmp	SHORT $LN23@MiListOE_M
$LN22@MiListOE_M:
	mov	DWORD PTR tv72[ebp], OFFSET $SG13786
$LN23@MiListOE_M:
	mov	ecx, DWORD PTR tv72[ebp]
	push	ecx
	push	OFFSET $SG13787
	call	_TraceLineS@8
$LN11@MiListOE_M:

; 1297 :    }
; 1298 : 
; 1299 :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN12@MiListOE_M

; 1300 :       hTask = lpView->hTask;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hTask$[ebp], eax
$LN12@MiListOE_M:

; 1301 : 
; 1302 :    if ( hTask == 0 && AnchorBlock)

	cmp	DWORD PTR _hTask$[ebp], 0
	jne	SHORT $LN13@MiListOE_M
	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN13@MiListOE_M

; 1303 :       hTask = AnchorBlock->hFirstTask;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	mov	DWORD PTR _hTask$[ebp], edx
$LN13@MiListOE_M:

; 1304 : 
; 1305 :    if ( hTask == 0 || (lpTask = zGETPTR( hTask )) == 0 )

	cmp	DWORD PTR _hTask$[ebp], 0
	je	SHORT $LN15@MiListOE_M
	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN14@MiListOE_M
$LN15@MiListOE_M:

; 1306 :       return( 0 );

	xor	eax, eax
	jmp	$LN19@MiListOE_M
$LN14@MiListOE_M:

; 1307 : 
; 1308 :    TraceLine( "(mi) List OE Memory ###### BEGIN ###### Task: 0x%08x", hTask );

	mov	ecx, DWORD PTR _hTask$[ebp]
	push	ecx
	push	OFFSET $SG13792
	call	_TraceLine
	add	esp, 8

; 1309 : 
; 1310 :    zLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysLockCoreMutex@4

; 1311 :    fnStartBrowseOfTaskList( lpTask, FALSE );

	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnStartBrowseOfTaskList@8

; 1312 : 
; 1313 :    // Make sure the task is a valid task
; 1314 :    for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN4@MiListOE_M
$LN2@MiListOE_M:

; 1316 :          lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN4@MiListOE_M:

; 1315 :          lpTask;

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN3@MiListOE_M

; 1317 :    {
; 1318 :       hTask = zGETHNDL( lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hTask$[ebp], eax

; 1319 :       by = (zBYTE) ((zULONG) hTask >> 24);

	mov	edx, DWORD PTR _hTask$[ebp]
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _by$[ebp], dl

; 1320 :       lpApp = zGETPTR( lpTask->hApp );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 1321 :       zsprintf( szMsg, "  Memory [%x] for Task 0x%08x   App: %s   Size: %d   Status: ",

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN24@MiListOE_M
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	mov	DWORD PTR tv140[ebp], edx
	jmp	SHORT $LN25@MiListOE_M
$LN24@MiListOE_M:
	mov	DWORD PTR tv140[ebp], OFFSET $SG13793
$LN25@MiListOE_M:
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+162]
	push	ecx
	mov	edx, DWORD PTR tv140[ebp]
	push	edx
	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	movzx	ecx, BYTE PTR _by$[ebp]
	push	ecx
	push	OFFSET $SG13794
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 1322 :                 (zLONG) by, hTask, lpApp ? lpApp->szName : "???", lpTask->ulTrackTaskMemory );
; 1323 :       if ( lpTask->bShutdown )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN16@MiListOE_M

; 1324 :       {
; 1325 :          TraceLineS( szMsg, "Shutdown" );

	push	OFFSET $SG13797
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_TraceLineS@8

; 1326 :          continue;

	jmp	$LN2@MiListOE_M

; 1327 :       }

	jmp	SHORT $LN17@MiListOE_M
$LN16@MiListOE_M:

; 1328 :       else
; 1329 :          TraceLineS( szMsg, "Active" );

	push	OFFSET $SG13798
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_TraceLineS@8
$LN17@MiListOE_M:

; 1330 : 
; 1331 :       k = sizeof( zCHAR ) * zSHR_MAX_PAGES;

	mov	ecx, 256				; 00000100H
	mov	WORD PTR _k$[ebp], cx

; 1332 :       zmemset( szPageTable, '.', k );

	movsx	edx, WORD PTR _k$[ebp]
	push	edx
	push	46					; 0000002eH
	lea	eax, DWORD PTR _szPageTable$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1333 :       szPageTable[ sizeof( zCHAR ) * zSHR_MAX_PAGES ] = 0;

	mov	ecx, 1
	shl	ecx, 8
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 257			; 00000101H
	jae	SHORT $LN26@MiListOE_M
	jmp	SHORT $LN27@MiListOE_M
$LN26@MiListOE_M:
	call	___report_rangecheckfailure
$LN27@MiListOE_M:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szPageTable$[ebp+edx], 0

; 1334 :       hDataHeader = lpTask->hFirstDataHeader;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	mov	DWORD PTR _hDataHeader$[ebp], ecx
$LN5@MiListOE_M:

; 1335 :       while ( hDataHeader )

	cmp	DWORD PTR _hDataHeader$[ebp], 0
	je	$LN6@MiListOE_M

; 1336 :       {
; 1337 :          by = (zBYTE) ((zULONG) hDataHeader >> 24);

	mov	edx, DWORD PTR _hDataHeader$[ebp]
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _by$[ebp], dl

; 1338 :          szPageTable[ by ] = 'Y';

	movzx	eax, BYTE PTR _by$[ebp]
	mov	BYTE PTR _szPageTable$[ebp+eax], 89	; 00000059H

; 1339 : 
; 1340 :          lpDataHeader = zGETPTR( hDataHeader );

	mov	ecx, DWORD PTR _hDataHeader$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$[ebp], eax

; 1341 :          ulTotalAlloc += lpDataHeader->ulUseableSize;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR _ulTotalAlloc$[ebp]
	add	eax, DWORD PTR [edx+10]
	mov	DWORD PTR _ulTotalAlloc$[ebp], eax

; 1342 : 
; 1343 : #if 1 //def WE_NEED_A_MUTEX_JUST_FOR_THIS???
; 1344 :          lpPrevFreespace = &lpDataHeader->Freespace;

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	add	ecx, 46					; 0000002eH
	mov	DWORD PTR _lpPrevFreespace$[ebp], ecx

; 1345 :          lpNextFreespace = zGETPTR( lpPrevFreespace->hNextFreespace );

	mov	edx, DWORD PTR _lpPrevFreespace$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextFreespace$[ebp], eax

; 1346 : 
; 1347 :          // If lpNextFreespace is null, set it to lpPrevFreespace (the zero-
; 1348 :          // length Freespace link in the table header).
; 1349 :          if ( lpNextFreespace == 0 )

	cmp	DWORD PTR _lpNextFreespace$[ebp], 0
	jne	SHORT $LN18@MiListOE_M

; 1350 :             lpNextFreespace = lpPrevFreespace;

	mov	ecx, DWORD PTR _lpPrevFreespace$[ebp]
	mov	DWORD PTR _lpNextFreespace$[ebp], ecx
$LN18@MiListOE_M:

; 1351 : 
; 1352 :          // lpNextFreespace points to the first free chunk of space
; 1353 :          ulFreeBytes = 0;

	mov	DWORD PTR _ulFreeBytes$[ebp], 0
$LN7@MiListOE_M:

; 1354 :          while ( lpNextFreespace )

	cmp	DWORD PTR _lpNextFreespace$[ebp], 0
	je	SHORT $LN8@MiListOE_M

; 1355 :          {
; 1356 :             ulFreeBytes += lpNextFreespace->ulFreeLth;

	mov	edx, DWORD PTR _lpNextFreespace$[ebp]
	mov	eax, DWORD PTR _ulFreeBytes$[ebp]
	add	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _ulFreeBytes$[ebp], eax

; 1357 : 
; 1358 :             // Move on to next free chunk of space
; 1359 :             lpNextFreespace = zGETPTR( lpNextFreespace->hNextFreespace );

	mov	ecx, DWORD PTR _lpNextFreespace$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextFreespace$[ebp], eax

; 1360 :          }

	jmp	SHORT $LN7@MiListOE_M
$LN8@MiListOE_M:

; 1361 : 
; 1362 :          k = sizeof( zCHAR ) * zSHR_MAX_PAGES - 1;

	mov	eax, 255				; 000000ffH
	mov	WORD PTR _k$[ebp], ax
$LN9@MiListOE_M:

; 1363 :          while ( szPageTable[ k ] == '.' )

	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, BYTE PTR _szPageTable$[ebp+ecx]
	cmp	edx, 46					; 0000002eH
	jne	SHORT $LN10@MiListOE_M

; 1364 :             szPageTable[ k-- ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	mov	cx, WORD PTR _k$[ebp]
	sub	cx, 1
	mov	WORD PTR _k$[ebp], cx
	cmp	DWORD PTR $T1[ebp], 257			; 00000101H
	jae	SHORT $LN28@MiListOE_M
	jmp	SHORT $LN29@MiListOE_M
$LN28@MiListOE_M:
	call	___report_rangecheckfailure
$LN29@MiListOE_M:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szPageTable$[ebp+edx], 0
	jmp	SHORT $LN9@MiListOE_M
$LN10@MiListOE_M:

; 1365 : 
; 1366 :          zsprintf( szMsg, "   [%lx] size: %ld; fs ceiling: %ld; total fs: %ld ==> %s",

	lea	eax, DWORD PTR _szPageTable$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulFreeBytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	push	eax
	push	OFFSET $SG13800
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 28					; 0000001cH

; 1367 :                    (zLONG) lpDataHeader, lpDataHeader->ulUseableSize,
; 1368 :                    lpDataHeader->ulMaxEmptyBlockSize, ulFreeBytes, szPageTable );
; 1369 : #else
; 1370 :          zsprintf( szMsg, "   [%lx] size: %ld; fs ceiling: %ld ==> %s",
; 1371 :                    (zLONG) lpDataHeader, lpDataHeader->lNumberOfEntries,
; 1372 :                    lpDataHeader->ulMaxEmptyBlockSize, szPageTable );
; 1373 : #endif
; 1374 :          TraceLineS( szMsg, "" );

	push	OFFSET $SG13801
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_TraceLineS@8

; 1375 : 
; 1376 :          hDataHeader = lpDataHeader->hNextDataHeader;

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	mov	DWORD PTR _hDataHeader$[ebp], ecx

; 1377 :       }

	jmp	$LN5@MiListOE_M
$LN6@MiListOE_M:

; 1378 :    }

	jmp	$LN2@MiListOE_M
$LN3@MiListOE_M:

; 1379 : 
; 1380 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 1381 :    zUNLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysUnlockCoreMutex@4

; 1382 : 
; 1383 :    TraceLineI( "(mi) List OE Memory ###### END ###### - total = ",

	mov	edx, DWORD PTR _ulTotalAlloc$[ebp]
	push	edx
	push	OFFSET $SG13802
	call	_TraceLineI@8

; 1384 :                ulTotalAlloc );
; 1385 :    return( ulTotalAlloc );

	mov	eax, DWORD PTR _ulTotalAlloc$[ebp]
$LN19@MiListOE_M:

; 1386 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_MiListOE_Memory@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntity$ = -8					; size = 4
_nRC$ = -4						; size = 2
_puCardMin$ = 8						; size = 4
_puCardMax$ = 12					; size = 4
_lpView$ = 16						; size = 4
_cpcEntityName$ = 20					; size = 4
_MiGetCardinalityForEntity@16 PROC

; 1040 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1041 :    LPTASK            lpCurrentTask;
; 1042 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1043 :    LPVIEWENTITY      lpViewEntity;
; 1044 :    zSHORT            nRC;
; 1045 : 
; 1046 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 1047 :    if ( (lpCurrentTask = fnOperationCall( iMiGetCardinalityForEntity, lpView,
; 1048 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	459					; 000001cbH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetCardi

; 1049 :    {
; 1050 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetCardi
$LN2@MiGetCardi:

; 1051 :    }
; 1052 : 
; 1053 :    // Validate that the entity exists
; 1054 :    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1055 :    if ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN3@MiGetCardi

; 1056 :    {
; 1057 :       *puCardMin = lpViewEntity->uCardMin;

	mov	ecx, DWORD PTR _puCardMin$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	ax, WORD PTR [edx+219]
	mov	WORD PTR [ecx], ax

; 1058 :       *puCardMax = lpViewEntity->uCardMax;

	mov	ecx, DWORD PTR _puCardMax$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	ax, WORD PTR [edx+221]
	mov	WORD PTR [ecx], ax

; 1059 :       nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 1060 :    }

	jmp	SHORT $LN4@MiGetCardi
$LN3@MiGetCardi:

; 1061 :    else
; 1062 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN4@MiGetCardi:

; 1063 : 
; 1064 :    fnOperationReturn( iMiGetCardinalityForEntity, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	459					; 000001cbH
	call	_fnOperationReturn
	add	esp, 8

; 1065 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@MiGetCardi:

; 1066 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MiGetCardinalityForEntity@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_lpViewEntity$ = -12					; size = 4
_lpViewAttrib$ = -8					; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttributeName$ = 16					; size = 4
_nOption$ = 20						; size = 2
_MiGetUpdateForViewEntityAttr@16 PROC

; 379  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 380  :    LPTASK            lpCurrentTask;
; 381  :    LPVIEWENTITY      lpViewEntity;
; 382  :    LPVIEWATTRIB      lpViewAttrib;
; 383  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 384  :    LPENTITYINSTANCE  lpEntityInstance;
; 385  : 
; 386  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 387  :    if ( (lpCurrentTask = fnOperationCall( iMiGetUpdateForViewEntityAttr,
; 388  :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	453					; 000001c5H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetUpdat

; 389  :    {
; 390  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetUpdat
$LN2@MiGetUpdat:

; 391  :    }
; 392  : 
; 393  :    // Validate that the entity exists.
; 394  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 395  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@MiGetUpdat

; 396  :    {
; 397  :       fnOperationReturn( iMiGetUpdateForViewEntityAttr, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	453					; 000001c5H
	call	_fnOperationReturn
	add	esp, 8

; 398  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetUpdat
$LN3@MiGetUpdat:

; 399  :    }
; 400  : 
; 401  :    // Validate that the Attrib exists.
; 402  :    lpViewAttrib = 0;

	mov	DWORD PTR _lpViewAttrib$[ebp], 0

; 403  :    if ( cpcAttributeName && cpcAttributeName[ 0 ] &&

	cmp	DWORD PTR _cpcAttributeName$[ebp], 0
	je	SHORT $LN4@MiGetUpdat
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcAttributeName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN4@MiGetUpdat
	push	0
	mov	eax, DWORD PTR _cpcAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN4@MiGetUpdat

; 404  :         (lpViewAttrib = fnValidViewAttrib( lpView, lpViewEntity,
; 405  :                                            cpcAttributeName, 0 )) == 0 )
; 406  :    {
; 407  :       fnOperationReturn( iMiGetUpdateForViewEntityAttr, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	453					; 000001c5H
	call	_fnOperationReturn
	add	esp, 8

; 408  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetUpdat
$LN4@MiGetUpdat:

; 409  :    }
; 410  : 
; 411  :    if ( nOption & zUPD_INCLUDE )

	movsx	ecx, WORD PTR _nOption$[ebp]
	and	ecx, 1
	je	SHORT $LN5@MiGetUpdat

; 412  :    {
; 413  :       fnOperationReturn( iMiGetUpdateForViewEntityAttr, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	453					; 000001c5H
	call	_fnOperationReturn
	add	esp, 8

; 414  :       if ( lpView->bReadOnly || lpViewEntity->bInclude == FALSE )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $LN8@MiGetUpdat
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN6@MiGetUpdat
$LN8@MiGetUpdat:

; 415  :          return( 0 );

	xor	eax, eax
	jmp	$LN1@MiGetUpdat
	jmp	SHORT $LN5@MiGetUpdat
$LN6@MiGetUpdat:

; 416  :       else
; 417  :          return( 1 );

	mov	eax, 1
	jmp	$LN1@MiGetUpdat
$LN5@MiGetUpdat:

; 418  :    }
; 419  : 
; 420  :    if ( lpView->bReadOnly || lpViewEntity->bUpdate == FALSE )

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 6
	and	edx, 1
	jne	SHORT $LN10@MiGetUpdat
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 2
	and	ecx, 1
	jne	SHORT $LN9@MiGetUpdat
$LN10@MiGetUpdat:

; 421  :    {
; 422  :       fnOperationReturn( iMiGetUpdateForViewEntityAttr, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	453					; 000001c5H
	call	_fnOperationReturn
	add	esp, 8

; 423  :       if ( (nOption & zUPD_NONPERSIST) != 0 && lpViewAttrib && lpViewAttrib->bPersist == FALSE )

	movsx	eax, WORD PTR _nOption$[ebp]
	and	eax, 2
	je	SHORT $LN11@MiGetUpdat
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN11@MiGetUpdat
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN11@MiGetUpdat

; 424  :          return( 1 );

	mov	eax, 1
	jmp	$LN1@MiGetUpdat
	jmp	SHORT $LN9@MiGetUpdat
$LN11@MiGetUpdat:

; 425  :       else
; 426  :          return( 0 );

	xor	eax, eax
	jmp	$LN1@MiGetUpdat
$LN9@MiGetUpdat:

; 427  :    }
; 428  : 
; 429  :    if ( lpViewAttrib == 0 || lpViewAttrib->bKey == FALSE )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN14@MiGetUpdat
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN13@MiGetUpdat
$LN14@MiGetUpdat:

; 430  :    {
; 431  :       fnOperationReturn( iMiGetUpdateForViewEntityAttr, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	453					; 000001c5H
	call	_fnOperationReturn
	add	esp, 8

; 432  :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@MiGetUpdat
$LN13@MiGetUpdat:

; 433  :    }
; 434  : 
; 435  :    // If we get here then the attribute is a key.  If the cursor is
; 436  :    // not established, get a cursor position on an entity instance.
; 437  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 438  :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN15@MiGetUpdat

; 439  :       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN15@MiGetUpdat:

; 440  : 
; 441  :    // If there is an entity instance and it has not been created, then
; 442  :    // we will say that the attribute cannot be updated because the
; 443  :    // attribute is a key and keys cannot be changed once they have
; 444  :    // been stored to a database, otherwise, we will return that the
; 445  :    // attribute can be updated.
; 446  :    fnOperationReturn( iMiGetUpdateForViewEntityAttr, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	453					; 000001c5H
	call	_fnOperationReturn
	add	esp, 8

; 447  :    if ( lpEntityInstance && lpEntityInstance->u.nInd.bCreated == FALSE )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN16@MiGetUpdat
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN16@MiGetUpdat

; 448  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@MiGetUpdat
	jmp	SHORT $LN1@MiGetUpdat
$LN16@MiGetUpdat:

; 449  :    else
; 450  :       return( 1 );

	mov	eax, 1
$LN1@MiGetUpdat:

; 451  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MiGetUpdateForViewEntityAttr@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewOD$ = -32					; size = 4
_lpCurrentTask$ = -28					; size = 4
tv145 = -24						; size = 4
tv144 = -20						; size = 4
tv93 = -16						; size = 4
tv92 = -12						; size = 4
_lpViewEntity$ = -8					; size = 4
_lpViewAttrib$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcAttribName$ = 16					; size = 4
_MiGetTypeForViewEntityAttr@12 PROC

; 309  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 310  :    LPTASK        lpCurrentTask;
; 311  :    LPVIEWOD      lpViewOD;
; 312  :    LPVIEWENTITY  lpViewEntity;
; 313  :    LPVIEWATTRIB  lpViewAttrib = 0;

	mov	DWORD PTR _lpViewAttrib$[ebp], 0

; 314  : 
; 315  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 316  :    if ( (lpCurrentTask = fnOperationCall( iMiGetTypeForViewEntityAttr,
; 317  :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	467					; 000001d3H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN7@MiGetTypeF

; 318  :    {
; 319  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetTypeF
$LN7@MiGetTypeF:

; 320  :    }
; 321  : 
; 322  :    // Get the view object definition for the view.
; 323  :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 324  : 
; 325  :    // Now make sure that the entity is valid for the view.
; 326  :    for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN4@MiGetTypeF
$LN2@MiGetTypeF:

; 328  :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN4@MiGetTypeF:

; 327  :          lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$LN3@MiGetTypeF

; 329  :    {
; 330  :       if ( zstrcmp( lpViewEntity->szName, cpcEntityName ) == 0 )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN15@MiGetTypeF
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN16@MiGetTypeF
$LN15@MiGetTypeF:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN13@MiGetTypeF
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN14@MiGetTypeF
$LN13@MiGetTypeF:
	mov	DWORD PTR tv92[ebp], -1
$LN14@MiGetTypeF:
	mov	edx, DWORD PTR tv92[ebp]
	mov	DWORD PTR tv93[ebp], edx
$LN16@MiGetTypeF:
	cmp	DWORD PTR tv93[ebp], 0
	jne	$LN8@MiGetTypeF

; 331  :       {
; 332  :          // Get first attribute for entity.
; 333  :          lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN5@MiGetTypeF:

; 334  : 
; 335  :          // Look for the attribute.
; 336  :          while ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN6@MiGetTypeF

; 337  :          {
; 338  :             if ( zstrcmp( lpViewAttrib->szName, cpcAttribName ) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcAttribName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN19@MiGetTypeF
	mov	eax, DWORD PTR _cpcAttribName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv145[ebp], eax
	jmp	SHORT $LN20@MiGetTypeF
$LN19@MiGetTypeF:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcAttribName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN17@MiGetTypeF
	mov	DWORD PTR tv144[ebp], 1
	jmp	SHORT $LN18@MiGetTypeF
$LN17@MiGetTypeF:
	mov	DWORD PTR tv144[ebp], -1
$LN18@MiGetTypeF:
	mov	eax, DWORD PTR tv144[ebp]
	mov	DWORD PTR tv145[ebp], eax
$LN20@MiGetTypeF:
	cmp	DWORD PTR tv145[ebp], 0
	jne	SHORT $LN9@MiGetTypeF

; 339  :             {
; 340  :                break;

	jmp	SHORT $LN6@MiGetTypeF
$LN9@MiGetTypeF:

; 341  :             }
; 342  : 
; 343  :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 344  :          }

	jmp	SHORT $LN5@MiGetTypeF
$LN6@MiGetTypeF:

; 345  : 
; 346  :          break;  // we found the entity

	jmp	SHORT $LN3@MiGetTypeF
$LN8@MiGetTypeF:

; 347  :       }
; 348  :    }

	jmp	$LN2@MiGetTypeF
$LN3@MiGetTypeF:

; 349  : 
; 350  :    fnOperationReturn( iMiGetTypeForViewEntityAttr, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	467					; 000001d3H
	call	_fnOperationReturn
	add	esp, 8

; 351  :    if ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN10@MiGetTypeF

; 352  :       return( lpViewAttrib->cType );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ax, BYTE PTR [ecx+202]
	jmp	SHORT $LN1@MiGetTypeF
	jmp	SHORT $LN1@MiGetTypeF
$LN10@MiGetTypeF:

; 353  :    else
; 354  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@MiGetTypeF:

; 355  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_MiGetTypeForViewEntityAttr@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_MiValidView@4 PROC

; 1172 : {

	push	ebp
	mov	ebp, esp

; 1173 :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN2@MiValidVie

; 1174 :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@MiValidVie
$LN2@MiValidVie:

; 1175 : 
; 1176 :    if ( SysValidAddress( (zPVOID) lpView,

	push	1
	push	38					; 00000026H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysValidAddress@12
	test	eax, eax
	je	SHORT $LN3@MiValidVie

; 1177 :                          (zLONG) sizeof( ViewRecord ), 1 ) )
; 1178 :    {
; 1179 :       if ( lpView->nTableID == iView )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	edx, 10021				; 00002725H
	jne	SHORT $LN3@MiValidVie

; 1180 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@MiValidVie
$LN3@MiValidVie:

; 1181 :    }
; 1182 : 
; 1183 :    return( FALSE );

	xor	eax, eax
$LN1@MiValidVie:

; 1184 : }

	pop	ebp
	ret	4
_MiValidView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lRC$ = -24						; size = 4
tv89 = -20						; size = 4
tv84 = -16						; size = 4
_lpTask$ = -12						; size = 4
_lpApp$ = -8						; size = 4
_bSetTo$1 = -1						; size = 1
_lpView$ = 8						; size = 4
_lOption$ = 12						; size = 4
_pchTaskInfo$ = 16					; size = 4
_lFlag$ = 20						; size = 4
_MiGetSetViewTaskAppFlags@16 PROC

; 1210 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1211 :    LPTASK     lpTask;
; 1212 :    LPAPP      lpApp = 0;

	mov	DWORD PTR _lpApp$[ebp], 0

; 1213 :    zLONG      lRC = 0;

	mov	DWORD PTR _lRC$[ebp], 0

; 1214 : 
; 1215 :    // If task not active or disabled, return 0.
; 1216 :    if ( (lpTask = fnOperationCall( iMiGetSetViewTaskAppFlags,
; 1217 :                                    lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	468					; 000001d4H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@MiGetSetVi

; 1218 :    {
; 1219 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@MiGetSetVi
$LN2@MiGetSetVi:

; 1220 :    }
; 1221 : 
; 1222 :    if ( lOption & 0x00000001 ) // Application KeepAlive

	mov	ecx, DWORD PTR _lOption$[ebp]
	and	ecx, 1
	je	SHORT $LN3@MiGetSetVi

; 1223 :    {
; 1224 :    // lRC /= lRC;
; 1225 :       lpApp = zGETPTR( lpTask->hApp );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 1226 :       if ( lpApp && lpApp->bKeepAlive )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN3@MiGetSetVi
	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1905]
	and	edx, 1
	je	SHORT $LN3@MiGetSetVi

; 1227 :          lRC = 1;

	mov	DWORD PTR _lRC$[ebp], 1
$LN3@MiGetSetVi:

; 1228 :    }
; 1229 : 
; 1230 :    if ( lFlag & 0x00000001 ) // set flag

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 1
	je	$LN5@MiGetSetVi

; 1231 :    {
; 1232 :       if ( lOption & 0x00000001 ) // Application KeepAlive

	mov	ecx, DWORD PTR _lOption$[ebp]
	and	ecx, 1
	je	SHORT $LN7@MiGetSetVi

; 1233 :       {
; 1234 :          zBOOL bSetTo = (lFlag & 0x00000002) ? 1 : 0;

	mov	edx, DWORD PTR _lFlag$[ebp]
	and	edx, 2
	je	SHORT $LN12@MiGetSetVi
	mov	DWORD PTR tv84[ebp], 1
	jmp	SHORT $LN13@MiGetSetVi
$LN12@MiGetSetVi:
	mov	DWORD PTR tv84[ebp], 0
$LN13@MiGetSetVi:
	mov	al, BYTE PTR tv84[ebp]
	mov	BYTE PTR _bSetTo$1[ebp], al

; 1235 : 
; 1236 :          if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN7@MiGetSetVi

; 1237 :          {
; 1238 :             TraceLine( "MiGetSetViewTaskAppFlags setting KeepAlive for Application: %s to %s",

	movzx	ecx, BYTE PTR _bSetTo$1[ebp]
	cmp	ecx, 1
	jne	SHORT $LN14@MiGetSetVi
	mov	DWORD PTR tv89[ebp], OFFSET $SG13733
	jmp	SHORT $LN15@MiGetSetVi
$LN14@MiGetSetVi:
	mov	DWORD PTR tv89[ebp], OFFSET $SG13734
$LN15@MiGetSetVi:
	mov	edx, DWORD PTR tv89[ebp]
	push	edx
	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	push	OFFSET $SG13735
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 1239 :                        lpApp->szName, bSetTo == TRUE ? "ON" : "OFF" );
; 1240 :             lpApp->bKeepAlive = bSetTo;

	movzx	ecx, BYTE PTR _bSetTo$1[ebp]
	and	ecx, 1
	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+1905]
	and	eax, -2					; fffffffeH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR [ecx+1905], eax
$LN7@MiGetSetVi:

; 1241 :          }
; 1242 :       }
; 1243 : 
; 1244 :       if ( lOption & 0x00000002 ) // Task Title

	mov	edx, DWORD PTR _lOption$[ebp]
	and	edx, 2
	je	SHORT $LN9@MiGetSetVi

; 1245 :       {
; 1246 :          zstrncpy( lpTask->szTaskTitle, pchTaskInfo, 127 );

	push	127					; 0000007fH
	mov	eax, DWORD PTR _pchTaskInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 311				; 00000137H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 1247 :          lpTask->szTaskTitle[ 127 ] = 0;

	mov	edx, 1
	imul	eax, edx, 127
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	BYTE PTR [ecx+eax+311], 0
$LN9@MiGetSetVi:

; 1248 :       }
; 1249 :    }

	jmp	SHORT $LN6@MiGetSetVi
$LN5@MiGetSetVi:

; 1250 :    else
; 1251 :    if ( lOption & 0x00000002 ) // Task Title

	mov	edx, DWORD PTR _lOption$[ebp]
	and	edx, 2
	je	SHORT $LN6@MiGetSetVi

; 1252 :    {
; 1253 :       zstrcpy( pchTaskInfo, lpTask->szTaskTitle );

	mov	eax, DWORD PTR _lpTask$[ebp]
	add	eax, 311				; 00000137H
	push	eax
	mov	ecx, DWORD PTR _pchTaskInfo$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN6@MiGetSetVi:

; 1254 :    }
; 1255 : 
; 1256 :    fnOperationReturn( iMiGetSetViewTaskAppFlags, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	468					; 000001d4H
	call	_fnOperationReturn
	add	esp, 8

; 1257 :    return( lRC );

	mov	eax, DWORD PTR _lRC$[ebp]
$LN1@MiGetSetVi:

; 1258 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MiGetSetViewTaskAppFlags@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -12					; size = 4
_lpViewCsr$ = -8					; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_MiGetActivateFlags@4 PROC

; 1151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1152 :    LPTASK            lpCurrentTask;
; 1153 :    LPVIEWCSR         lpViewCsr;
; 1154 :    LPVIEWOI          lpViewOI;
; 1155 : 
; 1156 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 1157 :    if ( (lpCurrentTask = fnOperationCall( iMiGetActivateFlags, lpView,
; 1158 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	464					; 000001d0H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetActiv

; 1159 :    {
; 1160 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetActiv
$LN2@MiGetActiv:

; 1161 :    }
; 1162 : 
; 1163 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1164 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1165 : 
; 1166 :    fnOperationReturn( iMiGetActivateFlags, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	464					; 000001d0H
	call	_fnOperationReturn
	add	esp, 8

; 1167 :    return( lpViewOI->lActivateControl );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [eax+48]
$LN1@MiGetActiv:

; 1168 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_MiGetActivateFlags@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -40					; size = 4
_lpViewCsr$ = -36					; size = 4
_lpCurrentTask$ = -32					; size = 4
tv136 = -28						; size = 4
tv135 = -24						; size = 4
_pchTemp$ = -20						; size = 4
_pchCmpr$ = -16						; size = 4
_pchOI$ = -12						; size = 4
_nReleaseOI$ = -8					; size = 2
_nReleaseCmpr$ = -4					; size = 2
_lpView$ = 8						; size = 4
_pchCompareRelease$ = 12				; size = 4
_MiCompareOI_ToRelease@8 PROC

; 951  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 952  :    LPTASK            lpCurrentTask;
; 953  :    LPVIEWCSR         lpViewCsr;
; 954  :    LPVIEWOI          lpViewOI;
; 955  :    zSHORT            nReleaseOI;
; 956  :    zSHORT            nReleaseCmpr;
; 957  :    zPCHAR            pchOI;
; 958  :    zPCHAR            pchCmpr;
; 959  :    zPCHAR            pchTemp;
; 960  : 
; 961  :    // If task not active or disabled, or view csr invalid, return 0.
; 962  :    if ( (lpCurrentTask = fnOperationCall( iMiCompareOI_ReleaseToRelease,
; 963  :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	463					; 000001cfH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiCompareO

; 964  :    {
; 965  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@MiCompareO
$LN2@MiCompareO:

; 966  :    }
; 967  : 
; 968  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 969  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 970  : 
; 971  :    pchOI   = lpViewOI->szRelease;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	add	edx, 56					; 00000038H
	mov	DWORD PTR _pchOI$[ebp], edx

; 972  :    pchCmpr = pchCompareRelease;

	mov	eax, DWORD PTR _pchCompareRelease$[ebp]
	mov	DWORD PTR _pchCmpr$[ebp], eax

; 973  : 
; 974  :    // if the number of digits preceding the '.' is larger in one release
; 975  :    // value than the other, that release value is larger
; 976  :    pchTemp = zstrchr( pchOI, '.' );

	push	46					; 0000002eH
	mov	ecx, DWORD PTR _pchOI$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchTemp$[ebp], eax

; 977  :    if ( pchTemp )

	cmp	DWORD PTR _pchTemp$[ebp], 0
	je	SHORT $LN3@MiCompareO

; 978  :       nReleaseOI = pchTemp - pchOI;

	mov	edx, DWORD PTR _pchTemp$[ebp]
	sub	edx, DWORD PTR _pchOI$[ebp]
	mov	WORD PTR _nReleaseOI$[ebp], dx
	jmp	SHORT $LN4@MiCompareO
$LN3@MiCompareO:

; 979  :    else
; 980  :       nReleaseOI = 0;

	xor	eax, eax
	mov	WORD PTR _nReleaseOI$[ebp], ax
$LN4@MiCompareO:

; 981  : 
; 982  :    pchTemp = zstrchr( pchCmpr, '.' );

	push	46					; 0000002eH
	mov	ecx, DWORD PTR _pchCmpr$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchTemp$[ebp], eax

; 983  :    if ( pchTemp )

	cmp	DWORD PTR _pchTemp$[ebp], 0
	je	SHORT $LN5@MiCompareO

; 984  :       nReleaseCmpr = pchTemp - pchCmpr;

	mov	edx, DWORD PTR _pchTemp$[ebp]
	sub	edx, DWORD PTR _pchCmpr$[ebp]
	mov	WORD PTR _nReleaseCmpr$[ebp], dx
	jmp	SHORT $LN6@MiCompareO
$LN5@MiCompareO:

; 985  :    else
; 986  :       nReleaseCmpr = 0;

	xor	eax, eax
	mov	WORD PTR _nReleaseCmpr$[ebp], ax
$LN6@MiCompareO:

; 987  : 
; 988  :    if ( nReleaseOI == nReleaseCmpr )

	movsx	ecx, WORD PTR _nReleaseOI$[ebp]
	movsx	edx, WORD PTR _nReleaseCmpr$[ebp]
	cmp	ecx, edx
	jne	$LN7@MiCompareO

; 989  :    {
; 990  :       if ( pchOI && pchCmpr )

	cmp	DWORD PTR _pchOI$[ebp], 0
	je	SHORT $LN9@MiCompareO
	cmp	DWORD PTR _pchCmpr$[ebp], 0
	je	SHORT $LN9@MiCompareO

; 991  :       {
; 992  :          nReleaseCmpr = zstrcmp( pchOI, pchCmpr );

	mov	eax, DWORD PTR _pchOI$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pchCmpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN23@MiCompareO
	mov	ecx, DWORD PTR _pchCmpr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchOI$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN24@MiCompareO
$LN23@MiCompareO:
	mov	eax, DWORD PTR _pchOI$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pchCmpr$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN21@MiCompareO
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN22@MiCompareO
$LN21@MiCompareO:
	mov	DWORD PTR tv135[ebp], -1
$LN22@MiCompareO:
	mov	ecx, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv136[ebp], ecx
$LN24@MiCompareO:
	mov	dx, WORD PTR tv136[ebp]
	mov	WORD PTR _nReleaseCmpr$[ebp], dx

; 993  :          if ( nReleaseCmpr < 0 )

	movsx	eax, WORD PTR _nReleaseCmpr$[ebp]
	test	eax, eax
	jge	SHORT $LN11@MiCompareO

; 994  :             nReleaseCmpr = -1;

	or	ecx, -1
	mov	WORD PTR _nReleaseCmpr$[ebp], cx
	jmp	SHORT $LN12@MiCompareO
$LN11@MiCompareO:

; 995  :          else
; 996  :          if ( nReleaseCmpr > 0 )

	movsx	edx, WORD PTR _nReleaseCmpr$[ebp]
	test	edx, edx
	jle	SHORT $LN12@MiCompareO

; 997  :             nReleaseCmpr = 1;

	mov	eax, 1
	mov	WORD PTR _nReleaseCmpr$[ebp], ax
$LN12@MiCompareO:

; 998  :       }

	jmp	SHORT $LN10@MiCompareO
$LN9@MiCompareO:

; 999  :       else
; 1000 :       if ( pchOI )

	cmp	DWORD PTR _pchOI$[ebp], 0
	je	SHORT $LN14@MiCompareO

; 1001 :          nReleaseCmpr = 1;

	mov	ecx, 1
	mov	WORD PTR _nReleaseCmpr$[ebp], cx
	jmp	SHORT $LN10@MiCompareO
$LN14@MiCompareO:

; 1002 :       else
; 1003 :       if ( pchCmpr )

	cmp	DWORD PTR _pchCmpr$[ebp], 0
	je	SHORT $LN16@MiCompareO

; 1004 :          nReleaseCmpr = -1;

	or	edx, -1
	mov	WORD PTR _nReleaseCmpr$[ebp], dx
	jmp	SHORT $LN10@MiCompareO
$LN16@MiCompareO:

; 1005 :       else
; 1006 :          nReleaseCmpr = 0;

	xor	eax, eax
	mov	WORD PTR _nReleaseCmpr$[ebp], ax
$LN10@MiCompareO:

; 1007 :    }

	jmp	SHORT $LN8@MiCompareO
$LN7@MiCompareO:

; 1008 :    else
; 1009 :    if ( nReleaseOI > nReleaseCmpr )

	movsx	ecx, WORD PTR _nReleaseOI$[ebp]
	movsx	edx, WORD PTR _nReleaseCmpr$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN18@MiCompareO

; 1010 :       nReleaseCmpr = 1;

	mov	eax, 1
	mov	WORD PTR _nReleaseCmpr$[ebp], ax
	jmp	SHORT $LN8@MiCompareO
$LN18@MiCompareO:

; 1011 :    else
; 1012 :       nReleaseCmpr = -1;

	or	ecx, -1
	mov	WORD PTR _nReleaseCmpr$[ebp], cx
$LN8@MiCompareO:

; 1013 : 
; 1014 :    fnOperationReturn( iMiCompareOI_ReleaseToRelease, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	463					; 000001cfH
	call	_fnOperationReturn
	add	esp, 8

; 1015 :    return( nReleaseCmpr );

	mov	ax, WORD PTR _nReleaseCmpr$[ebp]
$LN1@MiCompareO:

; 1016 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiCompareOI_ToRelease@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_lpViewOI$ = -4						; size = 4
_lpView$ = 8						; size = 4
_cpcNewRelease$ = 12					; size = 4
_MiSetOI_ReleaseForView@8 PROC

; 902  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 903  :    LPTASK     lpCurrentTask;
; 904  :    LPVIEWCSR  lpViewCsr;
; 905  :    LPVIEWOI   lpViewOI;
; 906  : 
; 907  :    // If task not active or disabled, or view csr invalid, return 0.
; 908  :    if ( (lpCurrentTask = fnOperationCall( iMiSetOI_ReleaseForView, lpView,
; 909  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	462					; 000001ceH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiSetOI_Re

; 910  :    {
; 911  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@MiSetOI_Re
$LN2@MiSetOI_Re:

; 912  :    }
; 913  : 
; 914  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 915  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 916  :    zstrncpy( lpViewOI->szRelease, cpcNewRelease, 8 );

	push	8
	mov	edx, DWORD PTR _cpcNewRelease$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 917  :    lpViewOI->szRelease[ 8 ] = 0;

	mov	ecx, 1
	shl	ecx, 3
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	BYTE PTR [edx+ecx+56], 0

; 918  : 
; 919  :    fnOperationReturn( iMiSetOI_ReleaseForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	462					; 000001ceH
	call	_fnOperationReturn
	add	esp, 8

; 920  :    return( 1 );

	mov	eax, 1
$LN1@MiSetOI_Re:

; 921  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiSetOI_ReleaseForView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -12					; size = 4
_lpViewCsr$ = -8					; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_pchReturnRelease$ = 12					; size = 4
_MiGetOI_ReleaseForView@8 PROC

; 859  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 860  :    LPTASK     lpCurrentTask;
; 861  :    LPVIEWCSR  lpViewCsr;
; 862  :    LPVIEWOI   lpViewOI;
; 863  : 
; 864  :    *pchReturnRelease = 0;   // ensure no junk in return value

	mov	eax, DWORD PTR _pchReturnRelease$[ebp]
	mov	BYTE PTR [eax], 0

; 865  : 
; 866  :    // If task not active or disabled, or view csr invalid, return 0.
; 867  :    if ( (lpCurrentTask = fnOperationCall( iMiGetOI_ReleaseForView, lpView,
; 868  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	461					; 000001cdH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetOI_Re

; 869  :    {
; 870  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@MiGetOI_Re
$LN2@MiGetOI_Re:

; 871  :    }
; 872  : 
; 873  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 874  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 875  :    zstrcpy( pchReturnRelease, lpViewOI->szRelease );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	mov	ecx, DWORD PTR _pchReturnRelease$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 876  :    fnOperationReturn( iMiGetOI_ReleaseForView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	461					; 000001cdH
	call	_fnOperationReturn
	add	esp, 8

; 877  :    return( 1 );

	mov	eax, 1
$LN1@MiGetOI_Re:

; 878  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiGetOI_ReleaseForView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -24					; size = 4
_lpViewCsr$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewEntity$1 = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_MiHasPersistentChanges@4 PROC

; 1084 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1085 :    LPTASK            lpCurrentTask;
; 1086 :    LPVIEWCSR         lpViewCsr;
; 1087 :    LPVIEWOI          lpViewOI;
; 1088 :    LPENTITYINSTANCE  lpEntityInstance;
; 1089 :    zSHORT            nRC = FALSE;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1090 : 
; 1091 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 1092 :    if ( (lpCurrentTask = fnOperationCall( iMiHasPersistentChanges, lpView,
; 1093 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	465					; 000001d1H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN5@MiHasPersi

; 1094 :    {
; 1095 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiHasPersi
$LN5@MiHasPersi:

; 1096 :    }
; 1097 : 
; 1098 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1099 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1100 : 
; 1101 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN4@MiHasPersi
$LN2@MiHasPersi:

; 1103 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@MiHasPersi:

; 1102 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@MiHasPersi

; 1104 :    {
; 1105 :       LPVIEWENTITY lpViewEntity;
; 1106 : 
; 1107 :       // First check and make sure there are changes to the EI.
; 1108 :       if ( lpEntityInstance->u.nInd.bCreated == FALSE  &&
; 1109 :            lpEntityInstance->u.nInd.bDeleted == FALSE  &&
; 1110 :            lpEntityInstance->u.nInd.bIncluded == FALSE &&
; 1111 :            lpEntityInstance->u.nInd.bExcluded == FALSE &&
; 1112 :            lpEntityInstance->u.nInd.bUpdated == FALSE  &&

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN6@MiHasPersi
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN6@MiHasPersi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	jne	SHORT $LN6@MiHasPersi
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN6@MiHasPersi
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 2
	and	ecx, 1
	jne	SHORT $LN6@MiHasPersi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN6@MiHasPersi

; 1113 :            lpEntityInstance->u.nInd.bDeleted == FALSE )
; 1114 :       {
; 1115 :          continue;

	jmp	SHORT $LN2@MiHasPersi
$LN6@MiHasPersi:

; 1116 :       }
; 1117 : 
; 1118 :       if ( fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN7@MiHasPersi

; 1119 :          continue;

	jmp	$LN2@MiHasPersi
$LN7@MiHasPersi:

; 1120 : 
; 1121 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 1122 :       if ( lpViewEntity->bDerived ||
; 1123 :            lpViewEntity->bDerivedPath ||

	mov	edx, DWORD PTR _lpViewEntity$1[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	jne	SHORT $LN9@MiHasPersi
	mov	ecx, DWORD PTR _lpViewEntity$1[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	SHORT $LN9@MiHasPersi
	mov	eax, DWORD PTR _lpViewEntity$1[ebp]
	mov	ecx, DWORD PTR [eax+239]
	and	ecx, 1
	je	SHORT $LN8@MiHasPersi
$LN9@MiHasPersi:

; 1124 :            lpViewEntity->bHasDB_Oper ) // added Phil/Doug 2005.10.17
; 1125 :       {
; 1126 :          continue;

	jmp	$LN2@MiHasPersi
$LN8@MiHasPersi:

; 1127 :       }
; 1128 : 
; 1129 :       nRC = TRUE;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 1130 :       break;

	jmp	SHORT $LN3@MiHasPersi

; 1131 :    }

	jmp	$LN2@MiHasPersi
$LN3@MiHasPersi:

; 1132 : 
; 1133 :    fnOperationReturn( iMiHasPersistentChanges, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	465					; 000001d1H
	call	_fnOperationReturn
	add	esp, 8

; 1134 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@MiHasPersi:

; 1135 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_MiHasPersistentChanges@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -28					; size = 4
_lpCurrentTask$ = -24					; size = 4
tv94 = -20						; size = 4
tv89 = -16						; size = 4
tv83 = -12						; size = 4
_lpViewOI$ = -8						; size = 4
_bUpdated$ = -1						; size = 1
_lpView$ = 8						; size = 4
_lFlag$ = 12						; size = 4
_MiSetInstanceUpdateFlag@8 PROC

; 260  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 261  :    LPTASK     lpCurrentTask;
; 262  :    LPVIEWCSR  lpViewCsr;
; 263  :    LPVIEWOI   lpViewOI;
; 264  :    zBOOL      bUpdated = FALSE;

	mov	BYTE PTR _bUpdated$[ebp], 0

; 265  : 
; 266  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 267  :    if ( (lpCurrentTask = fnOperationCall( iMiSetInstanceUpdateFlag, lpView,
; 268  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	466					; 000001d2H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiSetInsta

; 269  :    {
; 270  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiSetInsta
$LN2@MiSetInsta:

; 271  :    }
; 272  : 
; 273  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 274  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 275  : 
; 276  :    bUpdated = lpViewOI->bUpdated || lpViewOI->bUpdatedFile;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN4@MiSetInsta
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN4@MiSetInsta
	mov	DWORD PTR tv83[ebp], 0
	jmp	SHORT $LN5@MiSetInsta
$LN4@MiSetInsta:
	mov	DWORD PTR tv83[ebp], 1
$LN5@MiSetInsta:
	mov	al, BYTE PTR tv83[ebp]
	mov	BYTE PTR _bUpdated$[ebp], al

; 277  :    lpViewOI->bUpdatedFile = lpViewOI->bUpdated = (lFlag & 0x00000001) ? TRUE : FALSE;

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 1
	je	SHORT $LN6@MiSetInsta
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN7@MiSetInsta
$LN6@MiSetInsta:
	mov	DWORD PTR tv89[ebp], 0
$LN7@MiSetInsta:
	mov	edx, DWORD PTR tv89[ebp]
	and	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	or	ecx, edx
	mov	DWORD PTR tv94[ebp], ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR tv94[ebp]
	mov	DWORD PTR [edx+36], eax
	mov	ecx, DWORD PTR tv94[ebp]
	shr	ecx, 4
	and	ecx, 1
	and	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -33				; ffffffdfH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 278  : 
; 279  :    fnOperationReturn( iMiSetInstanceUpdateFlag, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	466					; 000001d2H
	call	_fnOperationReturn
	add	esp, 8

; 280  :    return( bUpdated );

	movzx	eax, BYTE PTR _bUpdated$[ebp]
$LN1@MiSetInsta:

; 281  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiSetInstanceUpdateFlag@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_MiGetUpdateForView@4 PROC

; 223  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 224  :    LPTASK     lpCurrentTask;
; 225  : 
; 226  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 227  :    if ( (lpCurrentTask = fnOperationCall( iMiGetUpdateForView, lpView,
; 228  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	452					; 000001c4H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetUpdat

; 229  :    {
; 230  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetUpdat
$LN2@MiGetUpdat:

; 231  :    }
; 232  : 
; 233  :    fnOperationReturn( iMiGetUpdateForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	452					; 000001c4H
	call	_fnOperationReturn
	add	esp, 8

; 234  :    if ( lpView->bReadOnly )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN3@MiGetUpdat

; 235  :       return( 0 );       // NOT Updateable

	xor	eax, eax
	jmp	SHORT $LN1@MiGetUpdat
	jmp	SHORT $LN1@MiGetUpdat
$LN3@MiGetUpdat:

; 236  :    else
; 237  :       return( 1 );       // Updateable

	mov	eax, 1
$LN1@MiGetUpdat:

; 238  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_MiGetUpdateForView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpPrevVsn$1 = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_MiGetTemporalStateOfEntity@8 PROC

; 475  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 476  :    LPTASK            lpCurrentTask;
; 477  :    LPVIEWENTITY      lpViewEntity;
; 478  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 479  :    LPENTITYINSTANCE  lpEntityInstance;
; 480  :    zSHORT            nRC;
; 481  : 
; 482  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 483  :    if ( (lpCurrentTask = fnOperationCall( iMiGetTemporalStateOfEntity, lpView,
; 484  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	454					; 000001c6H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN5@MiGetTempo

; 485  :    {
; 486  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetTempo
$LN5@MiGetTempo:

; 487  :    }
; 488  : 
; 489  :    // Validate that the entity exists
; 490  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 491  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN6@MiGetTempo

; 492  :    {
; 493  :       fnOperationReturn( iMiGetTemporalStateOfEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	454					; 000001c6H
	call	_fnOperationReturn
	add	esp, 8

; 494  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetTempo
$LN6@MiGetTempo:

; 495  :    }
; 496  : 
; 497  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 498  : 
; 499  :    // Establish cursor if necessary.
; 500  :    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN7@MiGetTempo

; 501  :       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@MiGetTempo:

; 502  : 
; 503  :    //
; 504  :    // 1. Check Cursor for null or undefined.
; 505  :    //
; 506  :    if ( lpEntityInstance == 0L )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN8@MiGetTempo

; 507  :       nRC = zCURSOR_NULL;

	mov	edx, -3					; fffffffdH
	mov	WORD PTR _nRC$[ebp], dx
	jmp	$LN9@MiGetTempo
$LN8@MiGetTempo:

; 508  :    else
; 509  :    if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN10@MiGetTempo

; 510  :       nRC = zCURSOR_UNDEFINED;

	mov	edx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], dx
	jmp	$LN9@MiGetTempo
$LN10@MiGetTempo:

; 511  :    else
; 512  :    {
; 513  :    //
; 514  :    // 2. Check the EntityInstance for being marked as temporal.
; 515  :    //
; 516  :       if ( lpEntityInstance->u.nInd.bTemporal )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN12@MiGetTempo

; 517  :          // Indicate Entity instance is a Temporal Entity.
; 518  :          nRC = zTES_TEMPORAL;

	mov	edx, 2
	mov	WORD PTR _nRC$[ebp], dx
	jmp	$LN9@MiGetTempo
$LN12@MiGetTempo:

; 519  :       else
; 520  :    //
; 521  :    // 3. Does Instance have a previous version
; 522  :    //
; 523  :       if ( lpEntityInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN14@MiGetTempo

; 524  :       {
; 525  :          LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$1[ebp], eax

; 526  : 
; 527  :          if ( lpPrevVsn->u.nInd.bPrevVsnRoot )

	mov	eax, DWORD PTR _lpPrevVsn$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 9
	and	ecx, 1
	je	SHORT $LN16@MiGetTempo

; 528  :          {
; 529  :             // Indicate Entity instance is a Temporal Subobject Root.
; 530  :             nRC = zTES_SUBOBJECT_ROOT;

	mov	edx, 3
	mov	WORD PTR _nRC$[ebp], dx

; 531  :          }

	jmp	SHORT $LN17@MiGetTempo
$LN16@MiGetTempo:

; 532  :          else
; 533  :          {
; 534  :             // Indicate Entity instance is a child of a Temporal
; 535  :             // Subobject Root.
; 536  :             nRC = zTES_SUBOBJECT_CHILD;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN17@MiGetTempo:

; 537  :          }
; 538  :       }

	jmp	SHORT $LN9@MiGetTempo
$LN14@MiGetTempo:

; 539  :       else
; 540  :       {
; 541  :    //
; 542  :    // 4. Is any parent Instance marked as a previous version
; 543  :    //
; 544  :          // Default to entity with no Temporal instances.
; 545  :          nRC = zTES_NONE;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 546  : 
; 547  :          // Go up the parent chain looking for an instance marked as
; 548  :          // a previous version.
; 549  :          for ( lpEntityInstance = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN4@MiGetTempo
$LN2@MiGetTempo:

; 551  :                lpEntityInstance = zGETPTR( lpEntityInstance->hParent ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@MiGetTempo:

; 550  :                lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN9@MiGetTempo

; 552  :          {
; 553  :             if ( lpEntityInstance->u.nInd.bPrevVersion || lpEntityInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 8
	and	ecx, 1
	jne	SHORT $LN19@MiGetTempo
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN18@MiGetTempo
$LN19@MiGetTempo:

; 554  :             {
; 555  :                // Indicate entity instance is child of Temporal
; 556  :                // Subobject Root.
; 557  :                nRC = zTES_SUBOBJECT_CHILD;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 558  :                break;

	jmp	SHORT $LN9@MiGetTempo
$LN18@MiGetTempo:

; 559  :             }
; 560  :          }

	jmp	SHORT $LN2@MiGetTempo
$LN9@MiGetTempo:

; 561  :       }
; 562  :    }
; 563  : 
; 564  :    fnOperationReturn( iMiGetTemporalStateOfEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	454					; 000001c6H
	call	_fnOperationReturn
	add	esp, 8

; 565  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@MiGetTempo:

; 566  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiGetTemporalStateOfEntity@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewOD$ = -8						; size = 4
_lpCurrentTask$ = -4					; size = 4
_pchReturnName$ = 8					; size = 4
_lpView$ = 12						; size = 4
_MiGetObjectNameForView@8 PROC

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 771  :    LPTASK     lpCurrentTask;
; 772  :    LPVIEWOD   lpViewOD;
; 773  : 
; 774  :    pchReturnName[ 0 ] = 0;  // init return name

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 775  : 
; 776  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 777  :    if ( (lpCurrentTask = fnOperationCall( iMiGetObjectNameForView, lpView,
; 778  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	460					; 000001ccH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetObjec

; 779  :    {
; 780  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetObjec
$LN2@MiGetObjec:

; 781  :    }
; 782  : 
; 783  :    if ( lpView->hViewOD == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	jne	SHORT $LN3@MiGetObjec

; 784  :    {
; 785  :       *pchReturnName = 0;

	mov	edx, DWORD PTR _pchReturnName$[ebp]
	mov	BYTE PTR [edx], 0

; 786  :       fnOperationReturn( iMiGetObjectNameForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	460					; 000001ccH
	call	_fnOperationReturn
	add	esp, 8

; 787  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@MiGetObjec
$LN3@MiGetObjec:

; 788  :    }
; 789  : 
; 790  :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 791  :    zstrcpy( pchReturnName, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 792  : 
; 793  :    fnOperationReturn( iMiGetObjectNameForView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	460					; 000001ccH
	call	_fnOperationReturn
	add	esp, 8

; 794  :    return( 0 );

	xor	eax, eax
$LN1@MiGetObjec:

; 795  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiGetObjectNameForView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpViewAttrib$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_pch$ = -12						; size = 4
_nRC$1 = -8						; size = 2
_nBytesLeft$ = -4					; size = 2
_pchReturnString$ = 8					; size = 4
_nLth$ = 12						; size = 2
_lpView$ = 16						; size = 4
_cpcEntityName$ = 20					; size = 4
_MiGetKeyFromInstance@16 PROC

; 675  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 676  :    LPTASK           lpCurrentTask;
; 677  :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 678  :    LPVIEWENTITY     lpViewEntity;
; 679  :    LPVIEWATTRIB     lpViewAttrib;
; 680  :    zPCHAR           pch;
; 681  :    zSHORT           nBytesLeft;
; 682  : 
; 683  :    pchReturnString[ 0 ] = 0;   // init return string

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 684  : 
; 685  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 686  :    if ( (lpCurrentTask = fnOperationCall( iMiGetKeyFromInstance, lpView,
; 687  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	457					; 000001c9H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN7@MiGetKeyFr

; 688  :    {
; 689  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetKeyFr
$LN7@MiGetKeyFr:

; 690  :    }
; 691  : 
; 692  :    // Validate that the entity exists
; 693  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 694  :                                            lpView,
; 695  :                                            cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN8@MiGetKeyFr

; 696  :    {
; 697  :       fnOperationReturn( iMiGetKeyFromInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	457					; 000001c9H
	call	_fnOperationReturn
	add	esp, 8

; 698  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetKeyFr
$LN8@MiGetKeyFr:

; 699  :    }
; 700  : 
; 701  :    pch = pchReturnString; // set pointer

	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	DWORD PTR _pch$[ebp], edx

; 702  :    nBytesLeft = nLth;

	mov	ax, WORD PTR _nLth$[ebp]
	mov	WORD PTR _nBytesLeft$[ebp], ax

; 703  :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@MiGetKeyFr
$LN2@MiGetKeyFr:

; 705  :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@MiGetKeyFr:

; 704  :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@MiGetKeyFr

; 706  :    {
; 707  :       zSHORT   nRC;
; 708  : 
; 709  :       if ( lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN9@MiGetKeyFr

; 710  :          continue;

	jmp	SHORT $LN2@MiGetKeyFr
$LN9@MiGetKeyFr:

; 711  : 
; 712  :       if ( nBytesLeft < nLth )

	movsx	ecx, WORD PTR _nBytesLeft$[ebp]
	movsx	edx, WORD PTR _nLth$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN10@MiGetKeyFr

; 713  :       {
; 714  :          zstrcat( pch, "." );

	push	OFFSET $SG13568
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 715  :          pch++;

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx

; 716  :          nBytesLeft--;

	mov	dx, WORD PTR _nBytesLeft$[ebp]
	sub	dx, 1
	mov	WORD PTR _nBytesLeft$[ebp], dx
$LN10@MiGetKeyFr:

; 717  :       }
; 718  : 
; 719  :       if ( nBytesLeft < 1 )

	movsx	eax, WORD PTR _nBytesLeft$[ebp]
	cmp	eax, 1
	jge	SHORT $LN11@MiGetKeyFr

; 720  :       {
; 721  :          // we ran out of buffer space...
; 722  :          // "KZOEE301 - Return buffer not large enough to
; 723  :          //  contain concatenated keys"
; 724  :          fnIssueCoreError( lpCurrentTask, lpView, 8, 301, nLth,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	movsx	edx, WORD PTR _nLth$[ebp]
	push	edx
	push	301					; 0000012dH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 725  :                            lpViewEntity->szName, 0 );
; 726  :          fnOperationReturn( iMiGetKeyFromInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	457					; 000001c9H
	call	_fnOperationReturn
	add	esp, 8

; 727  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetKeyFr
$LN11@MiGetKeyFr:

; 728  :       }
; 729  : 
; 730  :       nRC = fnGetStringFromAttribute( pch, nBytesLeft,

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	movsx	eax, WORD PTR _nBytesLeft$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$1[ebp], ax

; 731  :                                       lpView, lpViewEntityCsr,
; 732  :                                       lpViewAttrib, 0 );
; 733  : 
; 734  :       // -1 return means attribute was null.
; 735  :       // zCALL_ERROR for blobs...
; 736  :       if ( nRC )

	movsx	edx, WORD PTR _nRC$1[ebp]
	test	edx, edx
	je	SHORT $LN5@MiGetKeyFr

; 737  :       {
; 738  :          fnOperationReturn( iMiGetKeyFromInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	457					; 000001c9H
	call	_fnOperationReturn
	add	esp, 8

; 739  :          return( nRC );

	mov	ax, WORD PTR _nRC$1[ebp]
	jmp	SHORT $LN1@MiGetKeyFr
$LN5@MiGetKeyFr:

; 740  :       }
; 741  : 
; 742  :       while ( *pch && nBytesLeft )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN6@MiGetKeyFr
	movsx	eax, WORD PTR _nBytesLeft$[ebp]
	test	eax, eax
	je	SHORT $LN6@MiGetKeyFr

; 743  :       {
; 744  :          pch++;

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx

; 745  :          nBytesLeft--;

	mov	dx, WORD PTR _nBytesLeft$[ebp]
	sub	dx, 1
	mov	WORD PTR _nBytesLeft$[ebp], dx

; 746  :       }

	jmp	SHORT $LN5@MiGetKeyFr
$LN6@MiGetKeyFr:

; 747  : 
; 748  :    } // for...

	jmp	$LN2@MiGetKeyFr
$LN3@MiGetKeyFr:

; 749  : 
; 750  :    fnOperationReturn( iMiGetKeyFromInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	457					; 000001c9H
	call	_fnOperationReturn
	add	esp, 8

; 751  :    return( nLth - nBytesLeft );

	movsx	eax, WORD PTR _nLth$[ebp]
	movsx	ecx, WORD PTR _nBytesLeft$[ebp]
	sub	eax, ecx
$LN1@MiGetKeyFr:

; 752  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MiGetKeyFromInstance@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -12					; size = 4
_lRC$ = -8						; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_MiGetInstanceID_ForView@4 PROC

; 184  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 185  :    LPTASK      lpCurrentTask;
; 186  :    LPVIEWCSR   lpViewCsr;
; 187  :    zLONG       lRC;
; 188  : 
; 189  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 190  :    if ( (lpCurrentTask = fnOperationCall( iMiGetInstanceID_ForView, lpView,
; 191  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	451					; 000001c3H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetInsta

; 192  :    {
; 193  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetInsta
$LN2@MiGetInsta:

; 194  :    }
; 195  : 
; 196  :    lRC = zCALL_ERROR;

	mov	DWORD PTR _lRC$[ebp], -16		; fffffff0H

; 197  :    if ( lpView->hViewCsr )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN3@MiGetInsta

; 198  :    {
; 199  :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 200  :       lRC = (zLONG) lpViewCsr->hViewOI;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR _lRC$[ebp], edx
$LN3@MiGetInsta:

; 201  :    }
; 202  : 
; 203  :    fnOperationReturn( iMiGetInstanceID_ForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	451					; 000001c3H
	call	_fnOperationReturn
	add	esp, 8

; 204  :    return( lRC );

	mov	eax, DWORD PTR _lRC$[ebp]
$LN1@MiGetInsta:

; 205  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_MiGetInstanceID_ForView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpParent$1 = -44					; size = 4
_lpRecursViewEntity$2 = -40				; size = 4
_lpParent$3 = -36					; size = 4
_lpParentViewEntity$4 = -32				; size = 4
_lpParent$5 = -28					; size = 4
_lpViewSubobject$6 = -24				; size = 4
_lpViewCsr$ = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pchReturnString$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_MiGetParentEntityNameForView@12 PROC

; 76   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 77   :    LPTASK           lpCurrentTask;
; 78   :    LPVIEWCSR        lpViewCsr;
; 79   :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 80   :    LPVIEWENTITY     lpViewEntity;
; 81   :    zSHORT           nRC;
; 82   : 
; 83   :    // First initialize return string to null.
; 84   :    pchReturnString[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 85   : 
; 86   :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 87   :    if ( (lpCurrentTask = fnOperationCall( iMiGetParentEntityNameForView,
; 88   :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	450					; 000001c2H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetParen

; 89   :    {
; 90   :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetParen
$LN2@MiGetParen:

; 91   :    }
; 92   : 
; 93   :    // Set lpViewCsr
; 94   :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 95   : 
; 96   :    // Start off assuming we'll get a hit
; 97   :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 98   : 
; 99   :    // Validate that the entity exists
; 100  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 101  :                                            lpView, cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@MiGetParen

; 102  :    {
; 103  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MiGetParen
$LN3@MiGetParen:

; 104  :    }
; 105  : 
; 106  :    // If view entity csr at level 1 (root), parent is null.
; 107  : 
; 108  :    if ( lpViewEntityCsr->nLevel == 1 )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	edx, 1
	jne	SHORT $LN4@MiGetParen

; 109  :       ;  // done...

	jmp	$LN5@MiGetParen
$LN4@MiGetParen:

; 110  :    else
; 111  : 
; 112  :    // If view entity csr has a parent pass back its name.
; 113  :    if ( lpViewEntityCsr->hParent )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN6@MiGetParen

; 114  :    {
; 115  :       LPVIEWENTITYCSR lpParent;
; 116  :       LPVIEWENTITY    lpParentViewEntity;
; 117  : 
; 118  :       lpParent           = zGETPTR( lpViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$5[ebp], eax

; 119  :       lpParentViewEntity = zGETPTR( lpParent->hViewEntity );

	mov	eax, DWORD PTR _lpParent$5[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$4[ebp], eax

; 120  : 
; 121  :       zstrcpy( pchReturnString, lpParentViewEntity->szName );

	mov	edx, DWORD PTR _lpParentViewEntity$4[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 122  :    }

	jmp	$LN5@MiGetParen
$LN6@MiGetParen:

; 123  :    else
; 124  : 
; 125  :    // if view entity csr level matches view entity level,
; 126  :    // return the view entity parent name
; 127  :    if ( lpViewEntityCsr->nLevel == lpViewEntity->nLevel )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	edx, ecx
	jne	SHORT $LN8@MiGetParen

; 128  :    {
; 129  :       LPVIEWENTITY lpParent;
; 130  : 
; 131  :       lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$3[ebp], eax

; 132  :       zstrcpy( pchReturnString, lpParent->szName );

	mov	ecx, DWORD PTR _lpParent$3[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 133  :    }

	jmp	$LN5@MiGetParen
$LN8@MiGetParen:

; 134  :    else
; 135  : 
; 136  :    // Look for the recursive child in the subobject view
; 137  :    if ( lpViewCsr->hFirstViewSubobject )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN10@MiGetParen

; 138  :    {
; 139  :       LPVIEWSUBOBJECT   lpViewSubobject;
; 140  :       LPVIEWENTITY      lpRecursViewEntity;
; 141  :       LPVIEWENTITY      lpParent;
; 142  : 
; 143  :       lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$6[ebp], eax

; 144  :       if ( lpViewSubobject->hRecursViewEntity )

	mov	eax, DWORD PTR _lpViewSubobject$6[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN12@MiGetParen

; 145  :       {
; 146  :          lpRecursViewEntity = zGETPTR( lpViewSubobject->hRecursViewEntity );

	mov	ecx, DWORD PTR _lpViewSubobject$6[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursViewEntity$2[ebp], eax

; 147  :          lpParent           = zGETPTR( lpRecursViewEntity->hParent );

	mov	eax, DWORD PTR _lpRecursViewEntity$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$1[ebp], eax

; 148  :          zstrcpy( pchReturnString, lpParent->szName );

	mov	edx, DWORD PTR _lpParent$1[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 149  :       }

	jmp	SHORT $LN13@MiGetParen
$LN12@MiGetParen:

; 150  :       else
; 151  :       {
; 152  :          // "KZOEE300 - Problems finding a parent "
; 153  :          fnIssueCoreError( lpCurrentTask, lpView, 16, 300, 0, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	push	0
	push	300					; 0000012cH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 154  :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN13@MiGetParen:

; 155  :       }
; 156  :    }

	jmp	SHORT $LN5@MiGetParen
$LN10@MiGetParen:

; 157  :    else
; 158  :    {
; 159  :       // "KZOEE300 - Problems finding a parent "
; 160  :       fnIssueCoreError( lpCurrentTask, lpView, 16, 300, 0, cpcEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	push	0
	push	300					; 0000012cH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 161  :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN5@MiGetParen:

; 162  :    }
; 163  : 
; 164  :    fnOperationReturn( iMiGetParentEntityNameForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	450					; 000001c2H
	call	_fnOperationReturn
	add	esp, 8

; 165  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@MiGetParen:

; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_MiGetParentEntityNameForView@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -12					; size = 4
_lpViewEntity$ = -8					; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_MiGetERTokenForEntity@8 PROC

; 629  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 630  :    LPTASK           lpCurrentTask;
; 631  :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 632  :    LPVIEWENTITY     lpViewEntity;
; 633  : 
; 634  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 635  :    if ( (lpCurrentTask = fnOperationCall( iMiGetERTokenForEntity, lpView,
; 636  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	456					; 000001c8H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetERTok

; 637  :    {
; 638  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetERTok
$LN2@MiGetERTok:

; 639  :    }
; 640  : 
; 641  :    // Validate that the entity exists
; 642  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 643  :                                            lpView,
; 644  :                                            cpcEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@MiGetERTok

; 645  :    {
; 646  :       fnOperationReturn( iMiGetERTokenForEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	456					; 000001c8H
	call	_fnOperationReturn
	add	esp, 8

; 647  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetERTok
$LN3@MiGetERTok:

; 648  :    }
; 649  : 
; 650  :    fnOperationReturn( iMiGetERTokenForEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	456					; 000001c8H
	call	_fnOperationReturn
	add	esp, 8

; 651  :    return( lpViewEntity->lEREntTok );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [eax+195]
$LN1@MiGetERTok:

; 652  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiGetERTokenForEntity@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -12					; size = 4
_lpViewCsr$ = -8					; size = 4
_lpCurrentTask$ = -4					; size = 4
_pchDateTime$ = 8					; size = 4
_lpView$ = 12						; size = 4
_MiGetDateTimeForOI@8 PROC

; 585  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 586  :    LPTASK     lpCurrentTask;
; 587  :    LPVIEWCSR  lpViewCsr;
; 588  :    LPVIEWOI   lpViewOI;
; 589  : 
; 590  :    // First set return area to zeros
; 591  :    zmemset( pchDateTime, 0, sizeof( DateTimeRecord ) );

	push	6
	push	0
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 592  : 
; 593  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 594  :    if ( (lpCurrentTask = fnOperationCall( iMiGetDateTimeForOI, lpView,
; 595  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	455					; 000001c7H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MiGetDateT

; 596  :    {
; 597  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@MiGetDateT
$LN2@MiGetDateT:

; 598  :    }
; 599  : 
; 600  :    // Set lpViewCsr
; 601  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 602  :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 603  : 
; 604  :    // copy the DateTime of when the OI was created, into the return area.
; 605  :    zmemcpy( pchDateTime, (zPCHAR) &(lpViewOI->DateTime),

	push	6
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 30					; 0000001eH
	push	eax
	mov	ecx, DWORD PTR _pchDateTime$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 606  :             sizeof( DateTimeRecord ) );
; 607  : 
; 608  :    fnOperationReturn( iMiGetDateTimeForOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	455					; 000001c7H
	call	_fnOperationReturn
	add	esp, 8

; 609  :    return( 0 );

	xor	eax, eax
$LN1@MiGetDateT:

; 610  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_MiGetDateTimeForOI@8 ENDP
_TEXT	ENDS
END
