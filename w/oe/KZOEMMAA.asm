; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEMMAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_g_bTraceDataspace:BYTE
_DATA	ENDS
_BSS	SEGMENT
$SG13423 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG13389 DB	'Memory Management Error! Wrong Dataspace Table ID: ', 00H
$SG13391 DB	'Memory Management: Inconsistent size of memory blocks', 00H
	ORG $+2
$SG13392 DB	'Zeidon Error', 00H
	ORG $+3
$SG13424 DB	'Running in Server Mode and using local memory', 00H
	ORG $+2
$SG13426 DB	'Data Header Number:    ', 00H
$SG13427 DB	'  Total Size         = ', 00H
$SG13428 DB	'  Used Size          = ', 00H
$SG13429 DB	'  Max free Blocksize = ', 00H
$SG13430 DB	'  Used Blocks        = ', 00H
$SG13431 DB	'  Free Blocks        = ', 00H
$SG13436 DB	'Zero FreeLth', 00H
	ORG $+3
$SG13437 DB	'TraceDataHeader', 00H
$SG13504 DB	'(mm) Invalid fnAllocDataspace request ', 00H
	ORG $+1
$SG13510 DB	'Inconsistent Freespace Count', 00H
	ORG $+3
$SG13511 DB	'Memory Management Error: ', 00H
	ORG $+2
$SG13523 DB	'(mm) fnAllocDataspace (%d) allocation over threshold for'
	DB	' task: 0x%08x ======> %d', 00H
	ORG $+7
$SG13525 DB	'(mm) fnAllocDataspace (%d) allocation over ceiling for t'
	DB	'ask: 0x%08x ======> %d', 00H
	ORG $+1
$SG13529 DB	'(mm) fnAllocDataspace for AnchorBlock unsuccessful', 00H
	ORG $+1
$SG13532 DB	'(mm) fnAllocDataspace unsuccessful for size: ', 00H
	ORG $+6
$SG13558 DB	'FreeDataspace: Memory to free already freed (ID: %d) 0x%'
	DB	'08x   ++ 0x%08x', 00H
$SG13559 DB	'Memory to free already freed.', 00H
	ORG $+2
$SG13560 DB	'Zeidon Error', 00H
	ORG $+3
$SG13564 DB	'Memory Management Error! Wrong Dataheader Table ID: ', 00H
	ORG $+3
$SG13567 DB	'Memory Management! Used memory size becomes negative: ', 00H
	ORG $+1
$SG13582 DB	'Freespace request invalid', 00H
	ORG $+2
$SG13583 DB	'Zeidon Error', 00H
	ORG $+3
$SG13585 DB	'Data header request invalid', 00H
$SG13586 DB	'Zeidon Error', 00H
	ORG $+3
$SG13614 DB	'Allocating new space for Task (0x%08x) [0x%08x] size = %'
	DB	'd', 00H
_DATA	ENDS
PUBLIC	_TraceDataHeader@8
PUBLIC	_fnAllocDataspace
PUBLIC	_fnGetDataspaceLength
PUBLIC	_fnStoreStringInDataspace
PUBLIC	_fnInitializeDataspace
PUBLIC	_fnFreeDataspace
PUBLIC	_fnChainFreespaces
PUBLIC	_fnListDataspaceLeak@12
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnAllocSharedMemory@16:PROC
EXTRN	_fnFreeSharedMemory@8:PROC
EXTRN	_fnSysCreateHandle@8:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_g_bServerMode:BYTE
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
_lpAnchorBlock$ = 8					; size = 4
_hTask$ = 12						; size = 4
_nFlag$ = 16						; size = 2
_fnListDataspaceLeak@12 PROC

; 435  : {

	push	ebp
	mov	ebp, esp

; 436  : }

	pop	ebp
	ret	12					; 0000000cH
_fnListDataspaceLeak@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
_lpFreespace$ = -32					; size = 4
_pvEndOfBuffer$ = -28					; size = 4
_ulCntFreeSpaces$ = -24					; size = 4
_ulFree$ = -20						; size = 4
_ulUsed$ = -16						; size = 4
tv75 = -12						; size = 4
_lpNextSpace$ = -8					; size = 4
_lpSpace$ = -4						; size = 4
_lpDataHeader$ = 8					; size = 4
_fnChainFreespaces PROC

; 142  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 143  :    LPFREESPACE  lpFreespace; // last element of freespace chain
; 144  :    LPFREESPACE  lpSpace;     // actual space
; 145  :    LPFREESPACE  lpNextSpace; // next space
; 146  :    zPVOID       pvEndOfBuffer;
; 147  :    zULONG       ulCntFreeSpaces = 0;

	mov	DWORD PTR _ulCntFreeSpaces$[ebp], 0

; 148  :    zULONG       ulFree = 0;

	mov	DWORD PTR _ulFree$[ebp], 0

; 149  :    zULONG       ulUsed = 0;

	mov	DWORD PTR _ulUsed$[ebp], 0

; 150  : 
; 151  :    zLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysLockCoreMutex@4

; 152  : 
; 153  :    lpSpace = (LPFREESPACE)((zPCHAR) lpDataHeader + sizeof( DataHeaderRecord ));

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _lpSpace$[ebp], eax

; 154  :    pvEndOfBuffer = (zPCHAR) lpDataHeader + sizeof( DataHeaderRecord ) +

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	lea	ecx, DWORD PTR [eax+edx+64]
	mov	DWORD PTR _pvEndOfBuffer$[ebp], ecx

; 155  :                                                  lpDataHeader->ulUseableSize;
; 156  :    lpFreespace = &lpDataHeader->Freespace;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	add	edx, 46					; 0000002eH
	mov	DWORD PTR _lpFreespace$[ebp], edx
$LN2@fnChainFre:

; 157  :    while ( (void *) lpSpace < pvEndOfBuffer )

	mov	eax, DWORD PTR _lpSpace$[ebp]
	cmp	eax, DWORD PTR _pvEndOfBuffer$[ebp]
	jae	$LN3@fnChainFre

; 158  :    {
; 159  :       lpNextSpace = (LPFREESPACE) ((zPCHAR) lpSpace + lpSpace->ulFreeLth);

	mov	ecx, DWORD PTR _lpSpace$[ebp]
	mov	edx, DWORD PTR _lpSpace$[ebp]
	add	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _lpNextSpace$[ebp], edx

; 160  :       switch ( lpSpace->nTableID )

	mov	eax, DWORD PTR _lpSpace$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 10026		; 0000272aH
	je	$LN10@fnChainFre
	cmp	DWORD PTR tv75[ebp], 10027		; 0000272bH
	je	SHORT $LN6@fnChainFre
	cmp	DWORD PTR tv75[ebp], 10051		; 00002743H
	je	$LN10@fnChainFre
	jmp	$LN11@fnChainFre
$LN6@fnChainFre:

; 161  :       {
; 162  :          case iFreespace:
; 163  :          {
; 164  :             if ( ((void *) lpNextSpace < pvEndOfBuffer) &&

	mov	edx, DWORD PTR _lpNextSpace$[ebp]
	cmp	edx, DWORD PTR _pvEndOfBuffer$[ebp]
	jae	SHORT $LN7@fnChainFre
	mov	eax, DWORD PTR _lpNextSpace$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10027				; 0000272bH
	jne	SHORT $LN7@fnChainFre

; 165  :                  (lpNextSpace->nTableID == iFreespace) )
; 166  :             {
; 167  :                // Next memory space is also a freespace, so join both.
; 168  :                lpSpace->ulFreeLth += lpNextSpace->ulFreeLth;

	mov	edx, DWORD PTR _lpSpace$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	ecx, DWORD PTR _lpNextSpace$[ebp]
	add	eax, DWORD PTR [ecx+6]
	mov	edx, DWORD PTR _lpSpace$[ebp]
	mov	DWORD PTR [edx+6], eax

; 169  :             }

	jmp	SHORT $LN8@fnChainFre
$LN7@fnChainFre:

; 170  :             else
; 171  :             {
; 172  :                // Next space is used so chain the space into the list.
; 173  :                if ( lpSpace->ulFreeLth > lpDataHeader->ulMaxEmptyBlockSize )

	mov	eax, DWORD PTR _lpSpace$[ebp]
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [eax+6]
	cmp	edx, DWORD PTR [ecx+26]
	jbe	SHORT $LN9@fnChainFre

; 174  :                   lpDataHeader->ulMaxEmptyBlockSize = lpSpace->ulFreeLth;

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR _lpSpace$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+26], edx
$LN9@fnChainFre:

; 175  : 
; 176  :                ulCntFreeSpaces++;

	mov	eax, DWORD PTR _ulCntFreeSpaces$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulCntFreeSpaces$[ebp], eax

; 177  : 
; 178  :                // Chain the space into the freespace list.
; 179  :                lpSpace->hNextFreespace = 0;

	mov	ecx, DWORD PTR _lpSpace$[ebp]
	mov	DWORD PTR [ecx+14], 0

; 180  :                ulFree += lpSpace->ulFreeLth;

	mov	edx, DWORD PTR _lpSpace$[ebp]
	mov	eax, DWORD PTR _ulFree$[ebp]
	add	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _ulFree$[ebp], eax

; 181  :                lpFreespace->hNextFreespace = lpSpace->hFreespace;

	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	edx, DWORD PTR _lpSpace$[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR [ecx+14], eax

; 182  :                lpFreespace = lpSpace;

	mov	ecx, DWORD PTR _lpSpace$[ebp]
	mov	DWORD PTR _lpFreespace$[ebp], ecx

; 183  :                lpSpace = lpNextSpace;

	mov	edx, DWORD PTR _lpNextSpace$[ebp]
	mov	DWORD PTR _lpSpace$[ebp], edx
$LN8@fnChainFre:

; 184  :             }
; 185  : 
; 186  :             break;

	jmp	SHORT $LN4@fnChainFre
$LN10@fnChainFre:

; 187  :          }
; 188  : 
; 189  :          case iUsedFreespace:
; 190  :          case iUsedFreespace1:
; 191  :          {
; 192  :             ulUsed += lpSpace->ulFreeLth;

	mov	eax, DWORD PTR _lpSpace$[ebp]
	mov	ecx, DWORD PTR _ulUsed$[ebp]
	add	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR _ulUsed$[ebp], ecx

; 193  :             lpSpace = lpNextSpace;

	mov	edx, DWORD PTR _lpNextSpace$[ebp]
	mov	DWORD PTR _lpSpace$[ebp], edx

; 194  :             break;

	jmp	SHORT $LN4@fnChainFre
$LN11@fnChainFre:

; 195  :          }
; 196  : 
; 197  :          default:
; 198  :          {
; 199  :          // SysMessageBox( "Zeidon Error", "Memory Management: "
; 200  :          //                "Wrong Dataspace Table ID", 0 );
; 201  :             TraceLineI( "Memory Management Error! Wrong Dataspace Table ID: ",

	mov	eax, DWORD PTR _lpSpace$[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET $SG13389
	call	_TraceLineI@8

; 202  :                         lpSpace->nTableID );
; 203  :             return( lpSpace );

	mov	eax, DWORD PTR _lpSpace$[ebp]
	jmp	SHORT $LN1@fnChainFre
$LN4@fnChainFre:

; 204  :          }
; 205  :       }
; 206  :    }

	jmp	$LN2@fnChainFre
$LN3@fnChainFre:

; 207  : 
; 208  :    if ( (ulUsed + ulFree) != lpDataHeader->ulUseableSize )

	mov	edx, DWORD PTR _ulUsed$[ebp]
	add	edx, DWORD PTR _ulFree$[ebp]
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	cmp	edx, DWORD PTR [eax+10]
	je	SHORT $LN12@fnChainFre

; 209  :    {
; 210  :       TraceDataHeader( lpDataHeader, TRUE );

	push	1
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	push	ecx
	call	_TraceDataHeader@8

; 211  :       SysMessageBox( 0, "Zeidon Error", "Memory Management: "

	push	0
	push	OFFSET $SG13391
	push	OFFSET $SG13392
	push	0
	call	_SysMessageBox@16

; 212  :                      "Inconsistent size of memory blocks", 0 );
; 213  :       zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4

; 214  :       return( lpDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	jmp	SHORT $LN1@fnChainFre
$LN12@fnChainFre:

; 215  :    }
; 216  : 
; 217  :    lpDataHeader->ulCntFreeSpaces = ulCntFreeSpaces;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR _ulCntFreeSpaces$[ebp]
	mov	DWORD PTR [edx+22], eax

; 218  : 
; 219  :    // Now all freed memory is chained into the list.
; 220  :    lpDataHeader->ulFreedMemSize = 0;

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [ecx+30], 0

; 221  : 
; 222  :    zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4

; 223  :    return( 0 );

	xor	eax, eax
$LN1@fnChainFre:

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnChainFreespaces ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
_ulSize$ = -48						; size = 4
_lpNextDataHeader$1 = -44				; size = 4
_lpLong$ = -40						; size = 4
_lpnAddress$2 = -36					; size = 4
_hDataHandle$3 = -32					; size = 4
_hTmp$ = -28						; size = 4
_lpPrevDataHeader$4 = -24				; size = 4
_lpFreespace1$5 = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpFreespace$ = -12					; size = 4
_lpDataHeader$ = -8					; size = 4
_nPrevTableID$ = -4					; size = 2
_Address$ = 8						; size = 4
_fnFreeDataspace PROC

; 815  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 816  :    LPTASK        lpCurrentTask;
; 817  :    zSHORT        nPrevTableID;
; 818  :    zULONG        ulSize;
; 819  : // zULONG        ulFreeSize;  // the size of the freed space might be
; 820  :                               // joined with another freespace
; 821  :    zPLONG        lpLong;
; 822  :    LPDATAHEADER  lpDataHeader;
; 823  :    LPFREESPACE   lpFreespace;
; 824  :    zPVOID        hTmp;
; 825  : // LPFREESPACE   lpSearchFreespace;
; 826  : // LPFREESPACE   lpSearchPrevFreespace;
; 827  : // zPCHAR        lpSearch;
; 828  : 
; 829  :    if ( Address == 0 )

	cmp	DWORD PTR _Address$[ebp], 0
	jne	SHORT $LN2@fnFreeData

; 830  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnFreeData
$LN2@fnFreeData:

; 831  : 
; 832  : // if ( AnchorBlock->nStatus == 101 ) // DGC debugging hack.
; 833  : //    return( 0 );
; 834  : 
; 835  : #if 0
; 836  :    if ( g_bServerMode )
; 837  :    {
; 838  :       SysFree( Address );
; 839  :       return( 0 );
; 840  :    }
; 841  : #endif
; 842  : 
; 843  :    lpFreespace = (LPFREESPACE) Address;

	mov	eax, DWORD PTR _Address$[ebp]
	mov	DWORD PTR _lpFreespace$[ebp], eax

; 844  :    lpFreespace--;  // point to the FreespaceStruct in front of the memory

	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	sub	ecx, 18					; 00000012H
	mov	DWORD PTR _lpFreespace$[ebp], ecx

; 845  : 
; 846  :    // If it is an invalid request, return Address.
; 847  :    if ( lpFreespace->nTableID != iUsedFreespace &&

	mov	edx, DWORD PTR _lpFreespace$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10026				; 0000272aH
	je	SHORT $LN3@fnFreeData
	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	edx, 10051				; 00002743H
	je	SHORT $LN3@fnFreeData

; 848  :         lpFreespace->nTableID != iUsedFreespace1 )
; 849  :    {
; 850  :       LPFREESPACE lpFreespace1 = lpFreespace;

	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	DWORD PTR _lpFreespace1$5[ebp], eax

; 851  : 
; 852  :       lpFreespace1++;

	mov	ecx, DWORD PTR _lpFreespace1$5[ebp]
	add	ecx, 18					; 00000012H
	mov	DWORD PTR _lpFreespace1$5[ebp], ecx

; 853  : 
; 854  : #ifdef ALLOC_FREE_TRACE
; 855  :       if ( AnchorBlock )
; 856  :       {
; 857  :          LPANCHOR lpAnchorBlock = AnchorBlock;  // zGETPTR( g_hAnchorBlock );
; 858  :          if ( lpAnchorBlock->bTraceMem )
; 859  :          {
; 860  :             zPVOID lHandle = (zPVOID) zGETHNDL( Address );
; 861  :             zLONG lHash = fnHashPointerRemove( lpAnchorBlock, lHandle, PrimeTable[ 4 ] );
; 862  : 
; 863  :             if ( lHash >= 0 )
; 864  :                TraceLine( "(mm) FreeDataspace located: 0x%08x for task: 0x%08x freed %d bytes at Id: %d",
; 865  :                           lpAnchorBlock->pvMemId[ lHash ], lpAnchorBlock->pvMemTask[ lHash ],
; 866  :                           lpAnchorBlock->lMemSize[ lHash ], lHash );
; 867  :             else
; 868  :                TraceLine( "(mm) FreeDataspace not found: 0x%08x", lHandle );
; 869  :          }
; 870  :       }
; 871  : #endif
; 872  : 
; 873  :       TraceLine( "FreeDataspace: Memory to free already freed (ID: %d) 0x%08x   ++ 0x%08x",

	mov	edx, DWORD PTR _lpFreespace1$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFreespace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	movsx	edx, WORD PTR [ecx]
	push	edx
	push	OFFSET $SG13558
	call	_TraceLine
	add	esp, 16					; 00000010H

; 874  :                  lpFreespace->nTableID, lpFreespace, lpFreespace1 );
; 875  :       fnSysMessageBox( 0, "Zeidon Error", "Memory to free already freed.", 0 );

	push	0
	push	OFFSET $SG13559
	push	OFFSET $SG13560
	push	0
	call	_fnSysMessageBox@16

; 876  :    // fnIssueCoreError( 0, lpView, 16, 14, (zLONG) lpFreespace->nPrevTableID, 0, 0 );
; 877  :       return( Address );

	mov	eax, DWORD PTR _Address$[ebp]
	jmp	$LN1@fnFreeData
$LN3@fnFreeData:

; 878  :    }
; 879  : 
; 880  :    // TODO: We only need to lock the mutex when freeing memory from the
; 881  :    // system task.  However, the current state doesn't allow us to determine
; 882  :    // what the task is from the freespace struct.  We need to make a change
; 883  :    // that allows us to find the task and then check to see if the task is
; 884  :    // the system task before locking the mutex.
; 885  :    zLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysLockCoreMutex@4

; 886  : 
; 887  : #ifdef ALLOC_FREE_TRACE
; 888  :    if ( AnchorBlock )
; 889  :    {
; 890  :       LPANCHOR lpAnchorBlock = AnchorBlock;  // zGETPTR( g_hAnchorBlock );
; 891  :       if ( lpAnchorBlock->bTraceMem )
; 892  :       {
; 893  :          zPVOID lHandle = (zPVOID) zGETHNDL( Address );
; 894  :          zLONG lHash = fnHashPointerRemove( lpAnchorBlock, lHandle, PrimeTable[ 4 ] );
; 895  : 
; 896  :          if ( lHash >= 0 )
; 897  :          {
; 898  : #if 1
; 899  :             if ( lpAnchorBlock->lMemSize[ lHash ] < 0 )
; 900  :             {
; 901  :                lpAnchorBlock->lMemSize[ lHash ] *= -1;
; 902  :                TraceLine( "(mm) FreeDataspace: 0x%08x for task: 0x%08x freed (previous leak) %d bytes at Id: %d",
; 903  :                           lpAnchorBlock->pvMemId[ lHash ], lpAnchorBlock->pvMemTask[ lHash ],
; 904  :                           lpAnchorBlock->lMemSize[ lHash ], lHash );
; 905  :             }
; 906  :             else
; 907  :             if ( lpAnchorBlock->lMemSize[ lHash ] == 1428 )
; 908  :             {
; 909  :                TraceLine( "(mm) FreeDataspace: 0x%08x for task: 0x%08x freed %d bytes at Id: %d",
; 910  :                           lpAnchorBlock->pvMemId[ lHash ], lpAnchorBlock->pvMemTask[ lHash ],
; 911  :                           lpAnchorBlock->lMemSize[ lHash ], lHash );
; 912  :             }
; 913  : #else
; 914  :             TraceLine( "(mm) FreeDataspace: 0x%08x for task: 0x%08x freed %d bytes at Id: %d",
; 915  :                        lpAnchorBlock->pvMemId[ lHash ], lpAnchorBlock->pvMemTask[ lHash ],
; 916  :                        lpAnchorBlock->lMemSize[ lHash ], lHash );
; 917  : #endif
; 918  :             if ( lHash >= PrimeTable[ 4 ] && lHash <= lpAnchorBlock->lMemMax )
; 919  :             {
; 920  :                zLONG lLth = (lpAnchorBlock->lMemMax - lHash) * sizeof( zLONG );
; 921  :                if ( lLth )
; 922  :                {
; 923  :                   zmemcpy( lpAnchorBlock->pvMemId + lHash, lpAnchorBlock->pvMemId + lHash + 1, lLth );
; 924  :                   zmemcpy( lpAnchorBlock->lMemSize + lHash, lpAnchorBlock->lMemSize + lHash + 1, lLth );
; 925  :                   zmemcpy( lpAnchorBlock->pvMemTask + lHash, lpAnchorBlock->pvMemTask + lHash + 1, lLth );
; 926  :                }
; 927  : 
; 928  :                lpAnchorBlock->pvMemId[ lpAnchorBlock->lMemMax ] = 0;
; 929  :                lpAnchorBlock->lMemMax--;
; 930  :             }
; 931  :             else
; 932  :             if ( lHash >= 0 )
; 933  :                lpAnchorBlock->pvMemId[ lHash ] = 0;
; 934  :          }
; 935  :          else
; 936  :             TraceLine( "(mm) FreeDataspace cannot find 0x%08x", lHandle );
; 937  :       }
; 938  :    }
; 939  : #endif
; 940  : 
; 941  :    // The "next freespace pointer" in a used memory chunk points back to
; 942  :    // the data header.
; 943  :    // Retrieve Dataspace Header from alloc prefix
; 944  :    lpDataHeader = (LPDATAHEADER) zGETPTR( lpFreespace->hNextFreespace );

	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$[ebp], eax

; 945  :    lpCurrentTask = zGETPTR( lpDataHeader->hTask );

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 946  : 
; 947  :    // If the current task is in the process being deleted we don't need to
; 948  :    // worry about keeping track of the deallocations.  DeleteTask will delete
; 949  :    // the memory pages (i.e. DataHeaders) all at once.
; 950  :    if ( lpCurrentTask && lpCurrentTask->bShutdown )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN4@fnFreeData
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN4@fnFreeData

; 951  :    {
; 952  :       zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4

; 953  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnFreeData
$LN4@fnFreeData:

; 954  :    }
; 955  : 
; 956  :    // ### Emergency fix 24.4.1998,HH
; 957  :    // ### lpDataHeader = 0 in Frank Holzenthal's case.
; 958  :    // ### We assume that the address has been freed already.
; 959  :    // ### So, we just return (better than crash).
; 960  :    if ( lpDataHeader == 0 )

	cmp	DWORD PTR _lpDataHeader$[ebp], 0
	jne	SHORT $LN5@fnFreeData

; 961  :    {
; 962  :       zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4

; 963  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnFreeData
$LN5@fnFreeData:

; 964  :    }
; 965  : 
; 966  :    // ###
; 967  :    if ( lpDataHeader->nTableID != iDataHeader )

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10002				; 00002712H
	je	SHORT $LN6@fnFreeData

; 968  :    {
; 969  :       TraceLineI( "Memory Management Error! Wrong Dataheader Table ID: ",

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	movsx	eax, WORD PTR [edx]
	push	eax
	push	OFFSET $SG13564
	call	_TraceLineI@8
$LN6@fnFreeData:

; 970  :                   lpDataHeader->nTableID );
; 971  :       // fnIssueCoreError( 0, lpView, 16, 15, 0, 0, 0 );
; 972  :       // return( Address );
; 973  :    }
; 974  : 
; 975  :    // Why should we only lock the mutex when the "MainTask" is doing a free??
; 976  :    // We have to lock always to prevent one thread from changing the chains when
; 977  :    // a second one is doing a alloc or a free too.
; 978  :    /*if ( lpDataHeader->ulTaskID == AnchorBlock->lMainTaskID )  // TODO: only for main task because
; 979  :    {                                                            // otherwise the only one to change
; 980  :       zLOCK_MUTEX( zMUTEX_MEMORY );                             // the chain is the task itself,
; 981  :    }*/                                                          // which is single-threaded
; 982  : 
; 983  :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN7@fnFreeData

; 984  :       lpCurrentTask->ulTrackTaskMemory -= lpFreespace->ulFreeLth;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR _lpFreespace$[ebp]
	mov	eax, DWORD PTR [ecx+162]
	sub	eax, DWORD PTR [edx+6]
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [ecx+162], eax
$LN7@fnFreeData:

; 985  : 
; 986  : // if ( lpFreespace->nUsedTableID == 10100 )
; 987  : //    TraceLine( "FreeDataspace: (ID: %d %d) 0x%08x for Task: 0x%08x",
; 988  : //               lpFreespace->nTableID, lpFreespace->nUsedTableID, lpFreespace, lpCurrentTask );
; 989  : 
; 990  : // TraceLine( "fnFreeDataspace freeing (%d) Freespace: 0x%08x",
; 991  : //            lpFreespace->ulDebugID, lpFreespace );
; 992  : 
; 993  :    // Get size of area to be freed.
; 994  :    ulSize = lpFreespace->ulFreeLth;

	mov	edx, DWORD PTR _lpFreespace$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _ulSize$[ebp], eax

; 995  : 
; 996  :    // Retain the previous table ID which is the first short in the structure.
; 997  :    {
; 998  :       zPSHORT lpnAddress;
; 999  : 
; 1000 :       lpnAddress   = (zPSHORT) Address;

	mov	ecx, DWORD PTR _Address$[ebp]
	mov	DWORD PTR _lpnAddress$2[ebp], ecx

; 1001 :       nPrevTableID = *lpnAddress;

	mov	edx, DWORD PTR _lpnAddress$2[ebp]
	mov	ax, WORD PTR [edx]
	mov	WORD PTR _nPrevTableID$[ebp], ax

; 1002 :    }
; 1003 : 
; 1004 :    // Clear out first few bytes of area in case an internal table was stored
; 1005 :    // there (so the table id is cleared).
; 1006 :    // Minimum size of an allocated block is 4 Bytes!
; 1007 :    lpLong = (zPLONG) Address;

	mov	ecx, DWORD PTR _Address$[ebp]
	mov	DWORD PTR _lpLong$[ebp], ecx

; 1008 :    *lpLong = 0;

	mov	edx, DWORD PTR _lpLong$[ebp]
	mov	DWORD PTR [edx], 0

; 1009 : 
; 1010 :    // Set user-data to all 0.
; 1011 : // zmemset( Address, 0,
; 1012 : //          (unsigned int) (ulSize - (sizeof( FreespaceRecord ))) );
; 1013 : 
; 1014 :    // Reset nTableID to Freespace
; 1015 :    lpFreespace->nTableID     = iFreespace;

	mov	eax, 10027				; 0000272bH
	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	WORD PTR [ecx], ax

; 1016 :    lpFreespace->nUsedTableID = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	WORD PTR [eax+4], dx

; 1017 :    lpFreespace->nPrevTableID = nPrevTableID;

	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	dx, WORD PTR _nPrevTableID$[ebp]
	mov	WORD PTR [ecx+2], dx

; 1018 : 
; 1019 :    // Change the freespace handle to point to the current freespace structure
; 1020 :    // (it used to point to the useable space AFTER the freespace structure).
; 1021 :    hTmp = lpFreespace->hFreespace;

	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hTmp$[ebp], ecx

; 1022 :    lpFreespace->hFreespace = fnSysCreateHandle( lpDataHeader, lpFreespace );

	mov	edx, DWORD PTR _lpFreespace$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	push	eax
	call	_fnSysCreateHandle@8
	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 1023 : 
; 1024 :    // Bump down used entries
; 1025 :    lpDataHeader->ulCntUsedEntries--;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+14]
	sub	eax, 1
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 1026 :    lpDataHeader->ulUsedSpace -= lpFreespace->ulFreeLth;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	ecx, DWORD PTR [edx+18]
	sub	ecx, DWORD PTR [eax+6]
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [edx+18], ecx

; 1027 :    lpDataHeader->ulFreedMemSize += lpFreespace->ulFreeLth;

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	mov	edx, DWORD PTR _lpFreespace$[ebp]
	add	ecx, DWORD PTR [edx+6]
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [eax+30], ecx

; 1028 :    if (lpDataHeader->ulUsedSpace & 0x80000000)

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	and	edx, -2147483648			; 80000000H
	je	SHORT $LN8@fnFreeData

; 1029 :    {
; 1030 :       TraceLineI( "Memory Management! Used memory size becomes negative: ",

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	push	OFFSET $SG13567
	call	_TraceLineI@8
$LN8@fnFreeData:

; 1031 :                   lpDataHeader->ulUsedSpace );
; 1032 :    }
; 1033 : 
; 1034 :    // We have now freed up an entry!  If the entry count is 0 and this is
; 1035 :    // not the first dataspace for the task, return the space to the system.
; 1036 :    if ( lpDataHeader->ulCntUsedEntries == 0 && lpDataHeader->hPrevDataHeader )

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	cmp	DWORD PTR [edx+14], 0
	jne	$LN9@fnFreeData
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	SHORT $LN9@fnFreeData

; 1037 :    {
; 1038 :       zLONG        hDataHandle;
; 1039 :       LPDATAHEADER lpPrevDataHeader;
; 1040 : 
; 1041 :       hDataHandle = lpDataHeader->hDataHandle;

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _hDataHandle$3[ebp], edx

; 1042 :    // TraceLineI( "Free Block:          ", ((unsigned long) hDataHandle >> 24));
; 1043 : 
; 1044 :       // Chain Previous Dataspace to next Dataspace
; 1045 :       lpPrevDataHeader = zGETPTR( lpDataHeader->hPrevDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevDataHeader$4[ebp], eax

; 1046 :       hDataHandle = lpPrevDataHeader->lNextDataHandle;

	mov	edx, DWORD PTR _lpPrevDataHeader$4[ebp]
	mov	eax, DWORD PTR [edx+34]
	mov	DWORD PTR _hDataHandle$3[ebp], eax

; 1047 :       lpPrevDataHeader->lNextDataHandle = lpDataHeader->lNextDataHandle;

	mov	ecx, DWORD PTR _lpPrevDataHeader$4[ebp]
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+34]
	mov	DWORD PTR [ecx+34], eax

; 1048 :       lpPrevDataHeader->hNextDataHeader = lpDataHeader->hNextDataHeader;

	mov	ecx, DWORD PTR _lpPrevDataHeader$4[ebp]
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+38]
	mov	DWORD PTR [ecx+38], eax

; 1049 :       if ( lpDataHeader->hNextDataHeader )

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN10@fnFreeData

; 1050 :       {
; 1051 :          LPDATAHEADER lpNextDataHeader;
; 1052 : 
; 1053 :          lpNextDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextDataHeader$1[ebp], eax

; 1054 :          lpNextDataHeader->hPrevDataHeader = lpDataHeader->hPrevDataHeader;

	mov	ecx, DWORD PTR _lpNextDataHeader$1[ebp]
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax
$LN10@fnFreeData:

; 1055 :       }
; 1056 : 
; 1057 :       fnFreeSharedMemory( lpCurrentTask, hDataHandle );

	mov	ecx, DWORD PTR _hDataHandle$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnFreeSharedMemory@8

; 1058 : 
; 1059 :       zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4

; 1060 : 
; 1061 :       return( 0 );  // return 0 address for space freed

	xor	eax, eax
	jmp	SHORT $LN1@fnFreeData
$LN9@fnFreeData:

; 1062 :    }
; 1063 : 
; 1064 :    hTmp = 0;

	mov	DWORD PTR _hTmp$[ebp], 0

; 1065 :    if ( lpDataHeader->ulFreedMemSize >

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [eax+10]
	xor	edx, edx
	mov	ecx, 20					; 00000014H
	div	ecx
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	cmp	DWORD PTR [edx+30], eax
	jbe	SHORT $LN11@fnFreeData

; 1066 :         lpDataHeader->ulUseableSize / GARBAGE_COLLECT_FACTOR )
; 1067 :    {
; 1068 :       // Now clean up all Freed Memory chunks that are not yet chained
; 1069 :       // into the freespace chain.
; 1070 :       hTmp = fnChainFreespaces( lpDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	push	eax
	call	_fnChainFreespaces
	add	esp, 4
	mov	DWORD PTR _hTmp$[ebp], eax
$LN11@fnFreeData:

; 1071 :    }
; 1072 : 
; 1073 :    zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4

; 1074 : 
; 1075 :    return( hTmp );  // return null for space freed

	mov	eax, DWORD PTR _hTmp$[ebp]
$LN1@fnFreeData:

; 1076 : 
; 1077 : } // end of:  fnFreeDataspace

	mov	esp, ebp
	pop	ebp
	ret	0
_fnFreeDataspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
_ulHandle$ = -16					; size = 4
_ulTotalSize$ = -12					; size = 4
_lpFreespace$ = -8					; size = 4
_lpDataHeader$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_Address$ = 12						; size = 4
_nTableID$ = 16						; size = 2
_cpcTitle$ = 20						; size = 4
_ulBytes$ = 24						; size = 4
_cpcShareName$ = 28					; size = 4
_fnInitializeDataspace PROC

; 1169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1170 :    zULONG       ulHandle = 0;

	mov	DWORD PTR _ulHandle$[ebp], 0

; 1171 :    LPDATAHEADER lpDataHeader;
; 1172 :    LPFREESPACE  lpFreespace;
; 1173 :    zULONG       ulTotalSize;
; 1174 : 
; 1175 : #if 0
; 1176 :    // If we're running in server mode then we will be allocating local memory,
; 1177 :    // so there's nothing to do.
; 1178 :    if ( g_bServerMode )
; 1179 :    {
; 1180 :       *Address = SysMalloc( ulBytes );
; 1181 :       return( (zLONG) *Address );
; 1182 :    }
; 1183 : #endif
; 1184 : 
; 1185 :    ulTotalSize = ulBytes + sizeof( DataHeaderRecord );

	mov	eax, DWORD PTR _ulBytes$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _ulTotalSize$[ebp], eax

; 1186 :    if ( ulTotalSize % zALIGN_MEM_SIZE )

	mov	eax, DWORD PTR _ulTotalSize$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	je	SHORT $LN2@fnInitiali

; 1187 :       ulTotalSize += zALIGN_MEM_SIZE - ulTotalSize % zALIGN_MEM_SIZE;

	mov	eax, DWORD PTR _ulTotalSize$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	add	eax, DWORD PTR _ulTotalSize$[ebp]
	mov	DWORD PTR _ulTotalSize$[ebp], eax
$LN2@fnInitiali:

; 1188 : 
; 1189 :    // Allocate space for shared memory + data header.
; 1190 :    ulHandle = fnAllocSharedMemory( (zCOREMEM) Address, lpCurrentTask,

	mov	ecx, DWORD PTR _cpcShareName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulTotalSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Address$[ebp]
	push	ecx
	call	_fnAllocSharedMemory@16
	mov	DWORD PTR _ulHandle$[ebp], eax

; 1191 :                                    ulTotalSize, cpcShareName );
; 1192 :    if ( *Address == 0 )

	mov	edx, DWORD PTR _Address$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN3@fnInitiali

; 1193 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnInitiali
$LN3@fnInitiali:

; 1194 : 
; 1195 :    // Initialize Header To Table.
; 1196 :    lpDataHeader = (LPDATAHEADER) *Address;

	mov	eax, DWORD PTR _Address$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpDataHeader$[ebp], ecx

; 1197 : 
; 1198 :    // Clear header to 000000000...
; 1199 :    zmemset( lpDataHeader, 0, sizeof( DataHeaderRecord ) );

	push	64					; 00000040H
	push	0
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1200 : 
; 1201 :    lpDataHeader->nTableID            = iDataHeader;

	mov	eax, 10002				; 00002712H
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	WORD PTR [ecx], ax

; 1202 :    lpDataHeader->ulMaxEmptyBlockSize = ulBytes;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR _ulBytes$[ebp]
	mov	DWORD PTR [edx+26], eax

; 1203 :    lpDataHeader->hTask               = zGETHNDL( lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [edx+2], eax

; 1204 :    lpDataHeader->hDataHandle         = ulHandle;

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR _ulHandle$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 1205 :    lpDataHeader->ulUseableSize       = ulBytes; // + sizeof( DataHeaderRecord );

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR _ulBytes$[ebp]
	mov	DWORD PTR [edx+10], eax

; 1206 : 
; 1207 :    if ( g_bTraceDataspace )

	movzx	ecx, BYTE PTR _g_bTraceDataspace
	test	ecx, ecx
	je	SHORT $LN4@fnInitiali

; 1208 :    {
; 1209 :       TraceLine( "Allocating new space for Task (0x%08x) [0x%08x] size = %d",

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	push	OFFSET $SG13614
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN4@fnInitiali:

; 1210 :                  lpDataHeader->hTask, lpDataHeader, lpDataHeader->ulUseableSize );
; 1211 :    }
; 1212 : 
; 1213 :    // Initialize Table.
; 1214 :    lpFreespace = (LPFREESPACE) (lpDataHeader + 1);

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	add	ecx, 64					; 00000040H
	mov	DWORD PTR _lpFreespace$[ebp], ecx

; 1215 :    lpFreespace->hFreespace = fnSysCreateHandle( lpDataHeader, lpFreespace );

	mov	edx, DWORD PTR _lpFreespace$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	push	eax
	call	_fnSysCreateHandle@8
	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 1216 : 
; 1217 :    // Initialize the root freespace record contained in header record.
; 1218 : // lpDataHeader->Freespace.nTableID      = nTableID;
; 1219 :    lpDataHeader->Freespace.nTableID      = iFreespace;

	mov	edx, 10027				; 0000272bH
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	WORD PTR [eax+46], dx

; 1220 :    lpDataHeader->Freespace.nPrevTableID  = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	WORD PTR [edx+48], cx

; 1221 :    lpDataHeader->Freespace.ulFreeLth     = 0;  // this doesn't own any space

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [eax+52], 0

; 1222 :    lpDataHeader->ulCntFreeSpaces         = 1;  // there is one big initial freespace

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [ecx+22], 1

; 1223 :    lpDataHeader->Freespace.hNextFreespace = (LPFREESPACE) lpFreespace->hFreespace;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR [edx+60], ecx

; 1224 : 
; 1225 : // lpFreespace->nTableID       = nTableID;
; 1226 :    lpFreespace->nTableID       = iFreespace;

	mov	edx, 10027				; 0000272bH
	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	WORD PTR [eax], dx

; 1227 :    lpFreespace->nPrevTableID   = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _lpFreespace$[ebp]
	mov	WORD PTR [edx+2], cx

; 1228 :    lpFreespace->ulFreeLth      = ulBytes;

	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	ecx, DWORD PTR _ulBytes$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 1229 :    lpFreespace->hNextFreespace = 0;

	mov	edx, DWORD PTR _lpFreespace$[ebp]
	mov	DWORD PTR [edx+14], 0

; 1230 : 
; 1231 :    return( ulHandle );   // return the handle to the new dataspace.

	mov	eax, DWORD PTR _ulHandle$[ebp]
$LN1@fnInitiali:

; 1232 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInitializeDataspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
_lpReturnName$ = -12					; size = 4
_ulLth$1 = -8						; size = 4
_hDataspace$ = -4					; size = 4
_lpDataHeader$ = 8					; size = 4
_cpcName$ = 12						; size = 4
_fnStoreStringInDataspace PROC

; 95   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 96   :    zPCHAR lpReturnName;
; 97   :    zPVOID hDataspace = 0;

	mov	DWORD PTR _hDataspace$[ebp], 0

; 98   : 
; 99   :    if ( cpcName && cpcName[ 0 ] )

	cmp	DWORD PTR _cpcName$[ebp], 0
	je	SHORT $LN2@fnStoreStr
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN2@fnStoreStr

; 100  :    {
; 101  :       zULONG ulLth = zstrlen( cpcName ) + 1;

	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _ulLth$1[ebp], eax

; 102  :       hDataspace = fnAllocDataspace( lpDataHeader, ulLth, 0, 0, iString );

	push	10103					; 00002777H
	push	0
	push	0
	mov	edx, DWORD PTR _ulLth$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hDataspace$[ebp], eax

; 103  :       if ( hDataspace )

	cmp	DWORD PTR _hDataspace$[ebp], 0
	je	SHORT $LN2@fnStoreStr

; 104  :       {
; 105  :          lpReturnName = zGETPTR( hDataspace );

	mov	ecx, DWORD PTR _hDataspace$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpReturnName$[ebp], eax

; 106  :          zstrcpy( lpReturnName, cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpReturnName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN2@fnStoreStr:

; 107  :       }
; 108  :    }
; 109  : 
; 110  :    return( (zPCHAR) hDataspace );

	mov	eax, DWORD PTR _hDataspace$[ebp]

; 111  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnStoreStringInDataspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
_lpDataHeader$ = -8					; size = 4
_lpFreespace$ = -4					; size = 4
_Address$ = 8						; size = 4
_fnGetDataspaceLength PROC

; 1096 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1097 :    LPDATAHEADER  lpDataHeader;
; 1098 :    LPFREESPACE   lpFreespace;
; 1099 : 
; 1100 :    if ( Address == 0 )

	cmp	DWORD PTR _Address$[ebp], 0
	jne	SHORT $LN2@fnGetDatas

; 1101 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetDatas
$LN2@fnGetDatas:

; 1102 : 
; 1103 : #if 0
; 1104 :    if ( g_bServerMode )
; 1105 :       return( SysMemSize( Address ) );
; 1106 : #endif
; 1107 : 
; 1108 :    lpFreespace = (LPFREESPACE) Address;

	mov	eax, DWORD PTR _Address$[ebp]
	mov	DWORD PTR _lpFreespace$[ebp], eax

; 1109 :    lpFreespace--;

	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	sub	ecx, 18					; 00000012H
	mov	DWORD PTR _lpFreespace$[ebp], ecx

; 1110 : 
; 1111 :    // If it is an invalid request, return 0.
; 1112 :    if ( lpFreespace->nTableID != iUsedFreespace &&

	mov	edx, DWORD PTR _lpFreespace$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10026				; 0000272aH
	je	SHORT $LN3@fnGetDatas
	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	edx, 10051				; 00002743H
	je	SHORT $LN3@fnGetDatas

; 1113 :         lpFreespace->nTableID != iUsedFreespace1 )
; 1114 :    {
; 1115 :       fnSysMessageBox( 0, "Zeidon Error",

	push	0
	push	OFFSET $SG13582
	push	OFFSET $SG13583
	push	0
	call	_fnSysMessageBox@16

; 1116 :                        "Freespace request invalid", 0 );
; 1117 :    // fnIssueCoreError( 0, lpView, 16, 14, (zLONG) lpFreespace->nPrevTableID, 0, 0 );
; 1118 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetDatas
$LN3@fnGetDatas:

; 1119 :    }
; 1120 : 
; 1121 :    // Retrieve Dataspace Header from alloc prefix
; 1122 :    lpDataHeader = (LPDATAHEADER) zGETPTR( lpFreespace->hNextFreespace );

	mov	eax, DWORD PTR _lpFreespace$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$[ebp], eax

; 1123 :    if ( lpDataHeader->nTableID != iDataHeader )

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10002				; 00002712H
	je	SHORT $LN4@fnGetDatas

; 1124 :    {
; 1125 :       fnSysMessageBox( 0, "Zeidon Error",

	push	0
	push	OFFSET $SG13585
	push	OFFSET $SG13586
	push	0
	call	_fnSysMessageBox@16

; 1126 :                        "Data header request invalid", 0 );
; 1127 :    // fnIssueCoreError( 0, lpView, 16, 15, 0, 0, 0 );
; 1128 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetDatas
$LN4@fnGetDatas:

; 1129 :    }
; 1130 : 
; 1131 :    // Get size of area
; 1132 :    return( lpFreespace->ulFreeLth - sizeof( FreespaceRecord ) );

	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	eax, DWORD PTR [ecx+6]
	sub	eax, 18					; 00000012H
$LN1@fnGetDatas:

; 1133 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetDataspaceLength ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
_pTmp$1 = -64						; size = 4
_hDataHeader$ = -60					; size = 4
_hReturnPtr$ = -56					; size = 4
_ulAllocBytes$ = -52					; size = 4
_hNewDataHeader$2 = -48					; size = 4
_lpFirstDataHeader$ = -44				; size = 4
_lpPrevFreespace$ = -40					; size = 4
_lpNewDataHeader$3 = -36				; size = 4
_lpCurrentTask$ = -32					; size = 4
_lpReturnPtr$ = -28					; size = 4
_lpNewDataspace$ = -24					; size = 4
_ulSize$ = -20						; size = 4
_lpNextFreespace$ = -16					; size = 4
_lpDataHeader$ = -12					; size = 4
_nAllocCnt$ = -8					; size = 2
_bMutexLocked$ = -1					; size = 1
_hFirstDataHeader$ = 8					; size = 4
_ulReqSize$ = 12					; size = 4
_nInitialize$ = 16					; size = 2
_chInitByte$ = 20					; size = 1
_nTableID$ = 24						; size = 2
_fnAllocDataspace PROC

; 465  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 466  :    LPDATAHEADER  lpFirstDataHeader;
; 467  :    LPDATAHEADER  lpDataHeader;
; 468  :    LPFREESPACE   lpPrevFreespace;
; 469  :    LPFREESPACE   lpNextFreespace;
; 470  :    LPFREESPACE   lpNewDataspace;
; 471  :    LPTASK        lpCurrentTask;
; 472  :    zPCHAR        lpReturnPtr = 0;

	mov	DWORD PTR _lpReturnPtr$[ebp], 0

; 473  :    zPVOID        hReturnPtr;
; 474  :    zPVOID        hDataHeader;
; 475  :    zULONG        ulSize;
; 476  :    zULONG        ulAllocBytes;
; 477  :    zBOOL         bMutexLocked;
; 478  :    zSHORT        nAllocCnt;
; 479  : 
; 480  : #if 0 // debugging only
; 481  :    LPTASK lpMainTask = zGETPTR( AnchorBlock->hMainTask );
; 482  :    if ( (lpMainTask && hFirstDataHeader == lpMainTask->hFirstDataHeader) ||
; 483  :         hFirstDataHeader == AnchorBlock->hMainFirstDataHeader ||
; 484  :         hFirstDataHeader == (LPDATAHEADER) g_hAnchorBlock )
; 485  :    {
; 486  :       ulSize = 1;
; 487  :    }
; 488  :    else
; 489  :       ulSize = 0;
; 490  : #endif
; 491  : 
; 492  :    // Minimum allocation unit is MIN_MEM_BLOCKSIZE.
; 493  :    if ( ulReqSize < MIN_MEM_BLOCKSIZE )

	cmp	DWORD PTR _ulReqSize$[ebp], 16		; 00000010H
	jae	SHORT $LN7@fnAllocDat

; 494  :       ulReqSize = MIN_MEM_BLOCKSIZE;

	mov	DWORD PTR _ulReqSize$[ebp], 16		; 00000010H
$LN7@fnAllocDat:

; 495  : 
; 496  :    // Ensure that the requested space is on the required byte boundary.
; 497  :    // So we assure that a minimum of at least 4 Bytes is allocated.
; 498  :    if ( ulReqSize % zALIGN_MEM_SIZE )

	mov	eax, DWORD PTR _ulReqSize$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	je	SHORT $LN8@fnAllocDat

; 499  :       ulReqSize += zALIGN_MEM_SIZE - (ulReqSize % zALIGN_MEM_SIZE);

	mov	eax, DWORD PTR _ulReqSize$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	mov	eax, 4
	sub	eax, edx
	add	eax, DWORD PTR _ulReqSize$[ebp]
	mov	DWORD PTR _ulReqSize$[ebp], eax
$LN8@fnAllocDat:

; 500  : 
; 501  : #if 0
; 502  :    // If we're running in ServerMode, then we can allocate local memory.
; 503  :    if ( g_bServerMode )
; 504  :    {
; 505  :       lpReturnPtr = SysMalloc( ulReqSize );
; 506  :       if ( lpReturnPtr )
; 507  :       {
; 508  :          if ( nInitialize && chInitByte )
; 509  :             zmemset( lpReturnPtr, chInitByte, (unsigned int) ulReqSize );
; 510  : 
; 511  :          if ( nTableID && nTableID < iAttributeRecord )
; 512  :             memcpy( lpReturnPtr, &nTableID, sizeof( nTableID ) );
; 513  :       }
; 514  : 
; 515  :       return( lpReturnPtr );
; 516  :    }
; 517  : #endif
; 518  : 
; 519  :    // A quick hack to test things.  We're chaining everything off of the main
; 520  :    // system task.  dks 2006.05.07  change from 10B
; 521  : // if ( hFirstDataHeader != (LPDATAHEADER) g_hAnchorBlock )
; 522  : //    hFirstDataHeader = AnchorBlock->hMainFirstDataHeader;
; 523  : 
; 524  :    hDataHeader = hFirstDataHeader;

	mov	ecx, DWORD PTR _hFirstDataHeader$[ebp]
	mov	DWORD PTR _hDataHeader$[ebp], ecx

; 525  :    lpDataHeader = zGETPTR( hFirstDataHeader );

	mov	edx, DWORD PTR _hFirstDataHeader$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$[ebp], eax

; 526  : 
; 527  :    // If this is not a valid alloc request, return "no good".
; 528  :    if ( lpDataHeader == 0 || ulReqSize <= 0 )

	cmp	DWORD PTR _lpDataHeader$[ebp], 0
	je	SHORT $LN10@fnAllocDat
	cmp	DWORD PTR _ulReqSize$[ebp], 0
	ja	SHORT $LN9@fnAllocDat
$LN10@fnAllocDat:

; 529  :    {
; 530  :       TraceLineI( "(mm) Invalid fnAllocDataspace request ", ulReqSize );

	mov	eax, DWORD PTR _ulReqSize$[ebp]
	push	eax
	push	OFFSET $SG13504
	call	_TraceLineI@8

; 531  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnAllocDat
$LN9@fnAllocDat:

; 532  :    }
; 533  : 
; 534  :    lpFirstDataHeader = lpDataHeader;

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR _lpFirstDataHeader$[ebp], ecx

; 535  :    lpCurrentTask = zGETPTR( lpFirstDataHeader->hTask );

	mov	edx, DWORD PTR _lpFirstDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 536  : 
; 537  :    // Add the size of the prefix to the size of the new chunk returned.
; 538  :    ulSize = ulReqSize + sizeof( FreespaceRecord );

	mov	ecx, DWORD PTR _ulReqSize$[ebp]
	add	ecx, 18					; 00000012H
	mov	DWORD PTR _ulSize$[ebp], ecx

; 539  :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN11@fnAllocDat

; 540  :       lpCurrentTask->ulTrackTaskMemory += ulSize;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+162]
	add	eax, DWORD PTR _ulSize$[ebp]
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [ecx+162], eax
$LN11@fnAllocDat:

; 541  : 
; 542  :    // Ensure that the total space is on the required byte boundary.
; 543  :    // The next two lines are commented out, because the FreespaceStruct
; 544  :    // has to be on the boundary anyway.
; 545  : // if ( ulSize % zALIGN_MEM_SIZE )
; 546  : //    ulSize += zALIGN_MEM_SIZE - (ulSize % zALIGN_MEM_SIZE);
; 547  : 
; 548  : // if ( ulSize == 62 || ulSize == 66 )
; 549  : //    TraceLineI( "AllocDataspace size: ", ulSize );
; 550  : 
; 551  :    // Single thread memory allocation/deallocation for memory allocated out of the
; 552  :    // AnchorBlock memory segment or for memory allocated for the system task.
; 553  :    if ( lpFirstDataHeader->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpFirstDataHeader$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+2]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN12@fnAllocDat

; 554  :    {
; 555  :       bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 556  :       zLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysLockCoreMutex@4

; 557  :    }

	jmp	SHORT $LN13@fnAllocDat
$LN12@fnAllocDat:

; 558  :    else
; 559  :       bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0
$LN13@fnAllocDat:

; 560  : 
; 561  :    // Logic completely changed because it was totally confusing (us).
; 562  :    nAllocCnt = 1;

	mov	edx, 1
	mov	WORD PTR _nAllocCnt$[ebp], dx
$LN4@fnAllocDat:

; 563  :    do  // search in each shared data block
; 564  :    {
; 565  :       if ( lpDataHeader->ulCntFreeSpaces > 0 &&

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	cmp	DWORD PTR [eax+22], 0
	jbe	$LN14@fnAllocDat
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	cmp	edx, DWORD PTR _ulSize$[ebp]
	jbe	$LN14@fnAllocDat

; 566  :            lpDataHeader->ulMaxEmptyBlockSize > ulSize )
; 567  :       {
; 568  :          // It looks like there is enough space in this memory block.
; 569  :          lpPrevFreespace = &lpDataHeader->Freespace;

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	add	eax, 46					; 0000002eH
	mov	DWORD PTR _lpPrevFreespace$[ebp], eax

; 570  :          lpNextFreespace = zGETPTR( lpPrevFreespace->hNextFreespace );

	mov	ecx, DWORD PTR _lpPrevFreespace$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextFreespace$[ebp], eax

; 571  :          if ( lpNextFreespace == 0 )

	cmp	DWORD PTR _lpNextFreespace$[ebp], 0
	jne	SHORT $LN5@fnAllocDat

; 572  :          {
; 573  :             // Must not occur, because then ulCntFreeSpaces should be 0.
; 574  :          // SysMessageBox( "Zeidon Error", "Memory Management: "
; 575  :          //                "Inconsistent Freespace Count", 0 );
; 576  :             TraceLineS( "Memory Management Error: ",

	push	OFFSET $SG13510
	push	OFFSET $SG13511
	call	_TraceLineS@8

; 577  :                         "Inconsistent Freespace Count" );
; 578  : 
; 579  :             TraceDataHeader( lpDataHeader, FALSE ); // trace this header

	push	0
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	push	eax
	call	_TraceDataHeader@8

; 580  :          // fnChainFreespaces( lpDataHeader );
; 581  :          // TraceDataHeader( lpDataHeader, FALSE ); // trace this header again after chaining
; 582  :             continue;  // try it again, now the freespace count should be consistent again

	jmp	$LN2@fnAllocDat
$LN5@fnAllocDat:

; 583  : 
; 584  :          // if ( bMutexLocked )
; 585  :          //    zUNLOCK_MUTEX( zMUTEX_MEMORY );
; 586  : 
; 587  :          // return( 0 );
; 588  :          }
; 589  : 
; 590  :          while ( lpNextFreespace )

	cmp	DWORD PTR _lpNextFreespace$[ebp], 0
	je	$LN14@fnAllocDat

; 591  :          {
; 592  :             // If a big enough freespace area is found, use it.
; 593  :             if ( lpNextFreespace->ulFreeLth >= ulSize )

	mov	ecx, DWORD PTR _lpNextFreespace$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	cmp	edx, DWORD PTR _ulSize$[ebp]
	jb	$LN16@fnAllocDat

; 594  :             {
; 595  :                // If there isn't enough room at the end of the found space to
; 596  :                // create a new freespace entry, return the whole available chunk.
; 597  :                if ( lpNextFreespace->ulFreeLth <

	mov	eax, DWORD PTR _ulSize$[ebp]
	add	eax, 34					; 00000022H
	mov	ecx, DWORD PTR _lpNextFreespace$[ebp]
	cmp	DWORD PTR [ecx+6], eax
	jae	SHORT $LN17@fnAllocDat

; 598  :                     (ulSize + sizeof( FreespaceRecord ) + MIN_MEM_BLOCKSIZE) )
; 599  :                {
; 600  :                   ulSize = lpNextFreespace->ulFreeLth;

	mov	edx, DWORD PTR _lpNextFreespace$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _ulSize$[ebp], eax

; 601  : 
; 602  :                   // Chain last pointer ahead to next pointer.
; 603  :                   lpPrevFreespace->hNextFreespace = lpNextFreespace->hNextFreespace;

	mov	ecx, DWORD PTR _lpPrevFreespace$[ebp]
	mov	edx, DWORD PTR _lpNextFreespace$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+14], eax

; 604  :                   lpDataHeader->ulCntFreeSpaces--;

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	sub	edx, 1
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [eax+22], edx

; 605  :                }

	jmp	SHORT $LN18@fnAllocDat
$LN17@fnAllocDat:

; 606  :                else
; 607  :                {
; 608  :                   // Create a new Freespace chunk after the space being allocated and
; 609  :                   // point the previous dataspace chunk to the newly created chunk.
; 610  :                   lpNewDataspace = (LPFREESPACE) ((zPCHAR) lpNextFreespace + ulSize);

	mov	ecx, DWORD PTR _lpNextFreespace$[ebp]
	add	ecx, DWORD PTR _ulSize$[ebp]
	mov	DWORD PTR _lpNewDataspace$[ebp], ecx

; 611  :                   lpNewDataspace->hNextFreespace = lpNextFreespace->hNextFreespace;

	mov	edx, DWORD PTR _lpNewDataspace$[ebp]
	mov	eax, DWORD PTR _lpNextFreespace$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+14], ecx

; 612  :                   lpNewDataspace->nTableID = lpNextFreespace->nTableID;

	mov	edx, DWORD PTR _lpNewDataspace$[ebp]
	mov	eax, DWORD PTR _lpNextFreespace$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx

; 613  :                   lpNewDataspace->nPrevTableID = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpNewDataspace$[ebp]
	mov	WORD PTR [eax+2], dx

; 614  : #ifdef ALLOC_FREE_TRACE
; 615  :                   lpNewDataspace->ulDebugID = ++(AnchorBlock->ulAllocCnt);  // pre-increment intended
; 616  : #endif
; 617  :                   lpNewDataspace->ulFreeLth = lpNextFreespace->ulFreeLth - ulSize;

	mov	ecx, DWORD PTR _lpNextFreespace$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	sub	edx, DWORD PTR _ulSize$[ebp]
	mov	eax, DWORD PTR _lpNewDataspace$[ebp]
	mov	DWORD PTR [eax+6], edx

; 618  :                   lpNewDataspace->hFreespace = fnSysCreateHandle( lpDataHeader, lpNewDataspace );

	mov	ecx, DWORD PTR _lpNewDataspace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	push	edx
	call	_fnSysCreateHandle@8
	mov	ecx, DWORD PTR _lpNewDataspace$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 619  :                   lpPrevFreespace->hNextFreespace = lpNewDataspace->hFreespace;

	mov	edx, DWORD PTR _lpPrevFreespace$[ebp]
	mov	eax, DWORD PTR _lpNewDataspace$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR [edx+14], ecx
$LN18@fnAllocDat:

; 620  :                // TraceLine( "fnAllocFreespace allocated (%d) Freespace: 0x%08x",
; 621  :                //            lpNewDataspace->ulDebugID, lpNewDataspace );
; 622  :                }
; 623  : 
; 624  :                lpReturnPtr = (zPCHAR) lpNextFreespace;

	mov	edx, DWORD PTR _lpNextFreespace$[ebp]
	mov	DWORD PTR _lpReturnPtr$[ebp], edx

; 625  :                lpReturnPtr += sizeof( FreespaceRecord );

	mov	eax, DWORD PTR _lpReturnPtr$[ebp]
	add	eax, 18					; 00000012H
	mov	DWORD PTR _lpReturnPtr$[ebp], eax

; 626  :                hReturnPtr = fnSysCreateHandle( lpDataHeader, lpReturnPtr );

	mov	ecx, DWORD PTR _lpReturnPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	push	edx
	call	_fnSysCreateHandle@8
	mov	DWORD PTR _hReturnPtr$[ebp], eax

; 627  : 
; 628  :                // Point to the FreespaceStruct in front of the memory.
; 629  :                lpNewDataspace = (LPFREESPACE) lpReturnPtr - 1;

	mov	eax, DWORD PTR _lpReturnPtr$[ebp]
	sub	eax, 18					; 00000012H
	mov	DWORD PTR _lpNewDataspace$[ebp], eax

; 630  : 
; 631  :                // Now initialize the FreespaceStruct in front of the memory.
; 632  : 
; 633  :                // Set the "next freespace pointer" in this used memory chunk
; 634  :                // to point back to the data header.
; 635  :                lpNextFreespace->hNextFreespace = (LPFREESPACE) hDataHeader;

	mov	ecx, DWORD PTR _lpNextFreespace$[ebp]
	mov	edx, DWORD PTR _hDataHeader$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 636  : 
; 637  :                // For some reason ??? hFreespace of a used memory space must
; 638  :                // point to the beginning of the user memory area.
; 639  :                lpNextFreespace->hFreespace   = hReturnPtr;

	mov	eax, DWORD PTR _lpNextFreespace$[ebp]
	mov	ecx, DWORD PTR _hReturnPtr$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 640  :                lpNextFreespace->nTableID     = iUsedFreespace;

	mov	edx, 10026				; 0000272aH
	mov	eax, DWORD PTR _lpNextFreespace$[ebp]
	mov	WORD PTR [eax], dx

; 641  :                lpNextFreespace->nUsedTableID = nTableID;

	mov	ecx, DWORD PTR _lpNextFreespace$[ebp]
	mov	dx, WORD PTR _nTableID$[ebp]
	mov	WORD PTR [ecx+4], dx

; 642  :                lpNextFreespace->ulFreeLth    = ulSize;

	mov	eax, DWORD PTR _lpNextFreespace$[ebp]
	mov	ecx, DWORD PTR _ulSize$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 643  : 
; 644  :                lpDataHeader->ulCntUsedEntries++;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+14]
	add	eax, 1
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 645  :                lpDataHeader->ulUsedSpace += ulSize;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+18]
	add	eax, DWORD PTR _ulSize$[ebp]
	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [ecx+18], eax

; 646  : 
; 647  :                // Memory found so return the handle of the found memory space.
; 648  :                if ( lpReturnPtr )

	cmp	DWORD PTR _lpReturnPtr$[ebp], 0
	je	SHORT $LN19@fnAllocDat

; 649  :                {
; 650  :                   // Turn lpReturnPtr into a handle.
; 651  :                   if ( nInitialize )

	movsx	edx, WORD PTR _nInitialize$[ebp]
	test	edx, edx
	je	SHORT $LN20@fnAllocDat

; 652  :                      zmemset( lpReturnPtr, chInitByte, ulReqSize );

	mov	eax, DWORD PTR _ulReqSize$[ebp]
	push	eax
	movsx	ecx, BYTE PTR _chInitByte$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpReturnPtr$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN20@fnAllocDat:

; 653  : 
; 654  :                   if ( nTableID && nTableID < iAttributeRecord )

	movsx	eax, WORD PTR _nTableID$[ebp]
	test	eax, eax
	je	SHORT $LN19@fnAllocDat
	movsx	ecx, WORD PTR _nTableID$[ebp]
	cmp	ecx, 10100				; 00002774H
	jge	SHORT $LN19@fnAllocDat

; 655  :                      memcpy( lpReturnPtr, &nTableID, sizeof( nTableID ) );

	push	2
	lea	edx, DWORD PTR _nTableID$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpReturnPtr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN19@fnAllocDat:

; 656  :                }
; 657  : 
; 658  : #ifdef ALLOC_FREE_TRACE
; 659  :                if ( AnchorBlock && nTableID != iAnchor )
; 660  :                {
; 661  :                   LPANCHOR lpAnchorBlock = AnchorBlock; // zGETPTR( g_hAnchorBlock );
; 662  :                   if ( lpAnchorBlock->bTraceMem )
; 663  :                   {
; 664  :                      zSHORT k;
; 665  :                      zLONG lHash = fnHashPointerAdd( lpAnchorBlock, (zPVOID) hReturnPtr, PrimeTable[ 4 ] );
; 666  :                      if ( lHash >= 0 )
; 667  :                      {
; 668  :                         lpAnchorBlock->pvMemId[ lHash ] = (zPVOID) hReturnPtr;
; 669  :                         lpAnchorBlock->lMemSize[ lHash ] = (zLONG) ulReqSize;
; 670  :                         lpAnchorBlock->pvMemTask[ lHash ] = zGETHNDL( lpCurrentTask );
; 671  : #if 1
; 672  :                         lBomb /= lBomb;
; 673  :                         lBomb++;
; 674  :                         for ( k = 0; SizeTable[ k ]; k++ )
; 675  :                         {
; 676  :                            if ( ulReqSize == SizeTable[ k ] && (AddressTable[ k ] == 0 || hReturnPtr == AddressTable[ k ]) )
; 677  :                            {
; 678  :                               TraceLine( "(mm) AllocDataspace: 0x%08x for task: 0x%08x allocated %d bytes at Id: %d",
; 679  :                                          lpAnchorBlock->pvMemId[ lHash ], lpAnchorBlock->pvMemTask[ lHash ],
; 680  :                                          lpAnchorBlock->lMemSize[ lHash ], lHash );
; 681  :                            }
; 682  :                         }
; 683  : #endif
; 684  :                      }
; 685  :                      else
; 686  :                         TraceLine( "(mm) AllocDataspace cannot Add: 0x%08x", hReturnPtr );
; 687  :                   }
; 688  :                }
; 689  : #endif
; 690  : 
; 691  :                if ( bMutexLocked )

	movzx	ecx, BYTE PTR _bMutexLocked$[ebp]
	test	ecx, ecx
	je	SHORT $LN22@fnAllocDat

; 692  :                   zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4
$LN22@fnAllocDat:

; 693  : 
; 694  :             // if ( lpNextFreespace->nUsedTableID == 10100 )
; 695  :             //    TraceLine( "AllocDataspace: (ID: %d %d) 0x%08x for Task: 0x%08x",
; 696  :             //               lpNextFreespace->nTableID, lpNextFreespace->nUsedTableID, lpNextFreespace, lpCurrentTask );
; 697  : 
; 698  :                return( hReturnPtr );

	mov	eax, DWORD PTR _hReturnPtr$[ebp]
	jmp	$LN1@fnAllocDat
$LN16@fnAllocDat:

; 699  :             }
; 700  : 
; 701  :             // Move on to next free chunk of space.
; 702  :             lpPrevFreespace = lpNextFreespace;

	mov	edx, DWORD PTR _lpNextFreespace$[ebp]
	mov	DWORD PTR _lpPrevFreespace$[ebp], edx

; 703  :             lpNextFreespace = zGETPTR( lpNextFreespace->hNextFreespace );

	mov	eax, DWORD PTR _lpNextFreespace$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextFreespace$[ebp], eax

; 704  : 
; 705  :          }  // while ( lpNextFreespace )

	jmp	$LN5@fnAllocDat
$LN14@fnAllocDat:

; 706  :       }
; 707  : 
; 708  :       // In this block there was no freespace that was big enough, so set the
; 709  :       // lMaxEmptyBlockSize at least 1 smaller than the desired size and try
; 710  :       // the next block.
; 711  :       if ( lpDataHeader->ulMaxEmptyBlockSize >= ulSize )

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+26]
	cmp	eax, DWORD PTR _ulSize$[ebp]
	jb	SHORT $LN23@fnAllocDat

; 712  :          lpDataHeader->ulMaxEmptyBlockSize = ulSize - 1;

	mov	ecx, DWORD PTR _ulSize$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	DWORD PTR [edx+26], ecx
$LN23@fnAllocDat:

; 713  : 
; 714  :       // Go to the next block, or if it was the last one create a new block.
; 715  :       if ( lpDataHeader->hNextDataHeader )

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN24@fnAllocDat

; 716  :       {
; 717  :          nAllocCnt++;

	mov	cx, WORD PTR _nAllocCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nAllocCnt$[ebp], cx

; 718  :          lpDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$[ebp], eax

; 719  :       }

	jmp	$LN25@fnAllocDat
$LN24@fnAllocDat:

; 720  :       else
; 721  :       {
; 722  :          // We need a new shared memory block so create one and chain it in.
; 723  :          LPDATAHEADER hNewDataHeader;
; 724  :          LPDATAHEADER lpNewDataHeader;
; 725  :          void         *pTmp;
; 726  : 
; 727  :       // if ( AnchorBlock->nMemoryCeiling ||
; 728  :       //      AnchorBlock->nMemoryTraceThreshold )
; 729  :       // {
; 730  :       //    TraceLine( "(mm) fnAllocDataspace (%d) allocation for task: 0x%08x ======> Threshold: %d   Ceiling: %d",
; 731  :       //               nAllocCnt, lpFirstDataHeader->hTask,
; 732  :       //               AnchorBlock->nMemoryTraceThreshold, AnchorBlock->nMemoryCeiling );
; 733  :       // }
; 734  : 
; 735  :          if ( AnchorBlock->nMemoryTraceThreshold &&

	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, WORD PTR [ecx+134]
	test	edx, edx
	je	SHORT $LN26@fnAllocDat
	movsx	eax, WORD PTR _nAllocCnt$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, WORD PTR [ecx+134]
	cmp	eax, edx
	jle	SHORT $LN26@fnAllocDat

; 736  :               nAllocCnt > AnchorBlock->nMemoryTraceThreshold )
; 737  :          {
; 738  :             TraceLine( "(mm) fnAllocDataspace (%d) allocation over threshold for task: 0x%08x ======> %d",

	mov	eax, DWORD PTR _AnchorBlock
	movsx	ecx, WORD PTR [eax+134]
	push	ecx
	movsx	edx, WORD PTR _nAllocCnt$[ebp]
	push	edx
	push	OFFSET $SG13523
	call	_TraceLine
	add	esp, 12					; 0000000cH
$LN26@fnAllocDat:

; 739  :                        nAllocCnt, AnchorBlock->nMemoryTraceThreshold );
; 740  :          }
; 741  : 
; 742  :          if ( AnchorBlock->nMemoryCeiling &&

	mov	eax, DWORD PTR _AnchorBlock
	movsx	ecx, WORD PTR [eax+136]
	test	ecx, ecx
	je	SHORT $LN27@fnAllocDat
	movsx	edx, WORD PTR _nAllocCnt$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	movsx	ecx, WORD PTR [eax+136]
	cmp	edx, ecx
	jle	SHORT $LN27@fnAllocDat

; 743  :               nAllocCnt > AnchorBlock->nMemoryCeiling )
; 744  :          {
; 745  :             TraceLine( "(mm) fnAllocDataspace (%d) allocation over ceiling for task: 0x%08x ======> %d",

	mov	edx, DWORD PTR _AnchorBlock
	movsx	eax, WORD PTR [edx+136]
	push	eax
	mov	ecx, DWORD PTR _lpFirstDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	movsx	eax, WORD PTR _nAllocCnt$[ebp]
	push	eax
	push	OFFSET $SG13525
	call	_TraceLine
	add	esp, 16					; 00000010H

; 746  :                        nAllocCnt, lpFirstDataHeader->hTask,
; 747  :                        AnchorBlock->nMemoryCeiling );
; 748  :             lpCurrentTask->bLoadAllocLimit = TRUE;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	or	edx, 16384				; 00004000H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [eax+443], edx
$LN27@fnAllocDat:

; 749  :          }
; 750  : 
; 751  :          ulAllocBytes = AnchorBlock->lTaskAllocSize;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+86]
	mov	DWORD PTR _ulAllocBytes$[ebp], edx

; 752  : 
; 753  :          if ( ulSize > ulAllocBytes )

	mov	eax, DWORD PTR _ulSize$[ebp]
	cmp	eax, DWORD PTR _ulAllocBytes$[ebp]
	jbe	SHORT $LN28@fnAllocDat

; 754  :             ulAllocBytes = ulSize + sizeof( FreespaceRecord );

	mov	ecx, DWORD PTR _ulSize$[ebp]
	add	ecx, 18					; 00000012H
	mov	DWORD PTR _ulAllocBytes$[ebp], ecx
$LN28@fnAllocDat:

; 755  : 
; 756  :          hNewDataHeader = (LPDATAHEADER) fnInitializeDataspace( lpCurrentTask,

	push	0
	mov	edx, DWORD PTR _ulAllocBytes$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	movzx	ecx, WORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _pTmp$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnInitializeDataspace
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hNewDataHeader$2[ebp], eax

; 757  :                                                                 (zCOREMEM) &pTmp,
; 758  :                                                                 lpDataHeader->nTableID,
; 759  :                                                                 0, ulAllocBytes, 0 );
; 760  :          if ( hNewDataHeader )

	cmp	DWORD PTR _hNewDataHeader$2[ebp], 0
	je	SHORT $LN29@fnAllocDat

; 761  :          {
; 762  :             lpNewDataHeader = zGETPTR( hNewDataHeader );

	mov	ecx, DWORD PTR _hNewDataHeader$2[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewDataHeader$3[ebp], eax

; 763  : 
; 764  :             // Chain next DataHeader to this DataHeader.
; 765  :             // I really don't know why the handle to the next Dataheader is
; 766  :             // stored in two variables???? (us)
; 767  :             lpNewDataHeader->lNextDataHandle = lpDataHeader->lNextDataHandle;

	mov	edx, DWORD PTR _lpNewDataHeader$3[ebp]
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	mov	DWORD PTR [edx+34], ecx

; 768  :             lpNewDataHeader->hNextDataHeader = lpDataHeader->hNextDataHeader;

	mov	edx, DWORD PTR _lpNewDataHeader$3[ebp]
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	mov	DWORD PTR [edx+38], ecx

; 769  :             lpNewDataHeader->hPrevDataHeader = (LPDATAHEADER) lpDataHeader->hDataHandle;

	mov	edx, DWORD PTR _lpNewDataHeader$3[ebp]
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+42], ecx

; 770  :             lpNewDataHeader->hTask           = lpFirstDataHeader->hTask;

	mov	edx, DWORD PTR _lpNewDataHeader$3[ebp]
	mov	eax, DWORD PTR _lpFirstDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx

; 771  :             lpDataHeader->lNextDataHandle    = (zLONG) hNewDataHeader;

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR _hNewDataHeader$2[ebp]
	mov	DWORD PTR [edx+34], eax

; 772  :             lpDataHeader->hNextDataHeader    = hNewDataHeader;

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR _hNewDataHeader$2[ebp]
	mov	DWORD PTR [ecx+38], edx

; 773  :             lpDataHeader = lpNewDataHeader;

	mov	eax, DWORD PTR _lpNewDataHeader$3[ebp]
	mov	DWORD PTR _lpDataHeader$[ebp], eax

; 774  :          }

	jmp	SHORT $LN25@fnAllocDat
$LN29@fnAllocDat:

; 775  :          else
; 776  :          {
; 777  :             TraceLineX( "(mm) fnAllocDataspace for AnchorBlock unsuccessful",

	mov	ecx, DWORD PTR _AnchorBlock
	push	ecx
	push	OFFSET $SG13529
	call	_TraceLineX@8

; 778  :                         (zLONG) AnchorBlock );
; 779  :             if ( bMutexLocked )

	movzx	edx, BYTE PTR _bMutexLocked$[ebp]
	test	edx, edx
	je	SHORT $LN31@fnAllocDat

; 780  :                zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4
$LN31@fnAllocDat:

; 781  : 
; 782  :             return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnAllocDat
$LN25@fnAllocDat:

; 783  :          }
; 784  :       }
; 785  : 
; 786  :       hDataHeader = (zPVOID) lpDataHeader->hDataHandle;

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR _hDataHeader$[ebp], ecx
$LN2@fnAllocDat:

; 787  : 
; 788  :    } while ( lpDataHeader );

	cmp	DWORD PTR _lpDataHeader$[ebp], 0
	jne	$LN4@fnAllocDat

; 789  : 
; 790  :    if ( bMutexLocked )

	movzx	edx, BYTE PTR _bMutexLocked$[ebp]
	test	edx, edx
	je	SHORT $LN32@fnAllocDat

; 791  :       zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4
$LN32@fnAllocDat:

; 792  : 
; 793  :    TraceLineX( "(mm) fnAllocDataspace unsuccessful for size: ", ulReqSize );

	mov	eax, DWORD PTR _ulReqSize$[ebp]
	push	eax
	push	OFFSET $SG13532
	call	_TraceLineX@8

; 794  :    return( 0 );

	xor	eax, eax
$LN1@fnAllocDat:

; 795  : 
; 796  : } // end of:  fnAllocDataspace

	mov	esp, ebp
	pop	ebp
	ret	0
_fnAllocDataspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemmaa.c
_TEXT	SEGMENT
tv135 = -24						; size = 4
_ulUsed$ = -20						; size = 4
_ulFree$ = -16						; size = 4
_ulCntFreeSpaces$ = -12					; size = 4
_pvEndOfBuffer$ = -8					; size = 4
_lpSpace$ = -4						; size = 4
_lpDataHeader$ = 8					; size = 4
_bAll$ = 12						; size = 1
_TraceDataHeader@8 PROC

; 229  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 230  :    LPFREESPACE  lpSpace;     // actual space
; 231  :    zPVOID       pvEndOfBuffer;
; 232  :    zULONG       ulCntFreeSpaces = 0;

	mov	DWORD PTR _ulCntFreeSpaces$[ebp], 0

; 233  :    zULONG       ulFree = 0;

	mov	DWORD PTR _ulFree$[ebp], 0

; 234  :    zULONG       ulUsed = 0;

	mov	DWORD PTR _ulUsed$[ebp], 0

; 235  : 
; 236  :    if ( g_bServerMode )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $LN10@TraceDataH

; 237  :    {
; 238  :       TraceLineS( "Running in Server Mode and using local memory", "" );

	push	OFFSET $SG13423
	push	OFFSET $SG13424
	call	_TraceLineS@8

; 239  :       return;

	jmp	$LN1@TraceDataH
$LN10@TraceDataH:

; 240  :    }
; 241  : 
; 242  :    if ( bAll )  // if bAll is set, position to the very first DataHeader

	movzx	ecx, BYTE PTR _bAll$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@TraceDataH
$LN2@TraceDataH:

; 243  :    {
; 244  :       while ( lpDataHeader->hPrevDataHeader )

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN4@TraceDataH

; 245  :          lpDataHeader = zGETPTR( lpDataHeader->hPrevDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$[ebp], eax
	jmp	SHORT $LN2@TraceDataH
$LN4@TraceDataH:

; 246  :    }
; 247  : 
; 248  :    // Trace out specified DataHeader(s).
; 249  :    while ( lpDataHeader )

	cmp	DWORD PTR _lpDataHeader$[ebp], 0
	je	$LN1@TraceDataH

; 250  :    {
; 251  :       fnChainFreespaces( lpDataHeader );  // recover freespace

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	push	edx
	call	_fnChainFreespaces
	add	esp, 4

; 252  : 
; 253  :       TraceLineI( "Data Header Number:    ",

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 24					; 00000018H
	push	ecx
	push	OFFSET $SG13426
	call	_TraceLineI@8

; 254  :                   (unsigned long) lpDataHeader->hDataHandle >> 24 );
; 255  :       TraceLineI( "  Total Size         = ", lpDataHeader->ulUseableSize );

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	push	OFFSET $SG13427
	call	_TraceLineI@8

; 256  :       TraceLineI( "  Used Size          = ", lpDataHeader->ulUsedSpace );

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	push	OFFSET $SG13428
	call	_TraceLineI@8

; 257  :       TraceLineI( "  Max free Blocksize = ", lpDataHeader->ulMaxEmptyBlockSize );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	push	OFFSET $SG13429
	call	_TraceLineI@8

; 258  :       TraceLineI( "  Used Blocks        = ", lpDataHeader->ulCntUsedEntries );

	mov	edx, DWORD PTR _lpDataHeader$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET $SG13430
	call	_TraceLineI@8

; 259  :       TraceLineI( "  Free Blocks        = ", lpDataHeader->ulCntFreeSpaces );

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	push	OFFSET $SG13431
	call	_TraceLineI@8

; 260  : 
; 261  :       // Trace out the freespace here.
; 262  :       lpSpace = (LPFREESPACE) ((zPCHAR) lpDataHeader + sizeof( DataHeaderRecord ));

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	add	eax, 64					; 00000040H
	mov	DWORD PTR _lpSpace$[ebp], eax

; 263  :       pvEndOfBuffer = (zPCHAR) lpDataHeader + sizeof( DataHeaderRecord ) +

	mov	ecx, DWORD PTR _lpDataHeader$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	lea	ecx, DWORD PTR [eax+edx+64]
	mov	DWORD PTR _pvEndOfBuffer$[ebp], ecx
$LN6@TraceDataH:

; 264  :                                                  lpDataHeader->ulUseableSize;
; 265  :       while ( (void *) lpSpace < pvEndOfBuffer )

	mov	edx, DWORD PTR _lpSpace$[ebp]
	cmp	edx, DWORD PTR _pvEndOfBuffer$[ebp]
	jae	SHORT $LN7@TraceDataH

; 266  :       {
; 267  :          switch ( lpSpace->nTableID )

	mov	eax, DWORD PTR _lpSpace$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	DWORD PTR tv135[ebp], ecx

; 268  :          {
; 269  :             case iFreespace:
; 270  :             {
; 271  :             // TraceLine( "Freespace (%d) 0x%08x  =================  Length: %d   Next: 0x%08x",
; 272  :             //            lpSpace->ulDebugID, lpSpace, lpSpace->ulFreeLth, ((zULONG) lpSpace) + lpSpace->ulFreeLth );
; 273  :                break;
; 274  :             }
; 275  : 
; 276  :             case iUsedFreespace:
; 277  :             case iUsedFreespace1:
; 278  :             {
; 279  :             // zCHAR  szMessage[ 256 ];
; 280  : 
; 281  :             // zsprintf( szMessage, "Used Freespace (%d) 0x%08x   Length: %d ***   Next: 0x%08x",
; 282  :             //           lpSpace->ulDebugID, lpSpace, lpSpace->ulFreeLth, ((zULONG) lpSpace) + lpSpace->ulFreeLth );
; 283  :             // TraceBuffer( szMessage, lpSpace, lpSpace->ulFreeLth );
; 284  :                break;
; 285  :             }
; 286  : 
; 287  :             default:
; 288  :             {
; 289  :             // zCHAR  szMessage[ 256 ];
; 290  : 
; 291  :             // SysMessageBox( "Zeidon Error", "Memory Management: "
; 292  :             //                "Wrong Dataspace Table ID", 0 );
; 293  :             // TraceLine( "Memory Management Error! Wrong Dataspace (%d) Table ID: %d",
; 294  :             //             lpSpace->ulDebugID, lpSpace->nTableID );
; 295  :                break;
; 296  :             }
; 297  :          }
; 298  : 
; 299  :          if ( lpSpace->ulFreeLth == 0 )

	mov	edx, DWORD PTR _lpSpace$[ebp]
	cmp	DWORD PTR [edx+6], 0
	jne	SHORT $LN15@TraceDataH

; 300  :          {
; 301  :             SysMessageBox( 0, "TraceDataHeader", "Zero FreeLth", -1 );

	push	-1
	push	OFFSET $SG13436
	push	OFFSET $SG13437
	push	0
	call	_SysMessageBox@16

; 302  :             break;

	jmp	SHORT $LN7@TraceDataH
$LN15@TraceDataH:

; 303  :          }
; 304  : 
; 305  :          lpSpace = (LPFREESPACE) ((zPCHAR) lpSpace + lpSpace->ulFreeLth);

	mov	eax, DWORD PTR _lpSpace$[ebp]
	mov	ecx, DWORD PTR _lpSpace$[ebp]
	add	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR _lpSpace$[ebp], ecx

; 306  :       }

	jmp	SHORT $LN6@TraceDataH
$LN7@TraceDataH:

; 307  : 
; 308  :       if ( bAll == FALSE )

	movzx	edx, BYTE PTR _bAll$[ebp]
	test	edx, edx
	jne	SHORT $LN16@TraceDataH

; 309  :          break;

	jmp	SHORT $LN1@TraceDataH
$LN16@TraceDataH:

; 310  : 
; 311  :       lpDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$[ebp], eax

; 312  :    }

	jmp	$LN4@TraceDataH
$LN1@TraceDataH:

; 313  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_TraceDataHeader@8 ENDP
_TEXT	ENDS
END
