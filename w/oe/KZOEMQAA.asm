; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEMQAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG13421 DB	'KZMSGQOO', 00H
	ORG $+3
$SG13427 DB	'QMsg', 00H
	ORG $+3
$SG13456 DB	'MessageSend Task Error: %s  %s  %s  %d', 00H
	ORG $+1
$SG13460 DB	'MessageSend Interface Inactive: %s  %s  %s  %d', 00H
	ORG $+1
$SG13463 DB	'Message Interface Inactive: %s %s %s %d', 00H
$SG13466 DB	'MessageSend Recursive Error: %s  %s  %s  %d', 00H
$SG13467 DB	'MessageSend Interface Active: %s  %s  %s  %d', 00H
	ORG $+3
$SG13468 DB	'WebUserErrorMessages', 00H
	ORG $+3
$SG13469 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG13480 DB	'MessagePrompt Trying to pop up a Web message box: %s for'
	DB	' WebSubtask: 0x%08x', 00H
$SG13482 DB	'ZeidonWeb', 00H
	ORG $+2
$SG13483 DB	'Client', 00H
	ORG $+1
$SG13484 DB	'QMsg', 00H
	ORG $+3
$SG13485 DB	'QMsg', 00H
	ORG $+3
$SG13486 DB	'Title', 00H
	ORG $+2
$SG13487 DB	'QMsg', 00H
	ORG $+3
$SG13488 DB	'Text', 00H
	ORG $+3
$SG13489 DB	'QMsg', 00H
	ORG $+3
$SG13490 DB	'View', 00H
	ORG $+3
$SG13491 DB	'QMsg', 00H
	ORG $+3
$SG13524 DB	'MessagePrompt Task Error: %s  %s  %s', 00H
	ORG $+3
$SG13528 DB	'Interface Inactive', 00H
	ORG $+1
$SG13531 DB	'MessagePrompt Recursive Error: %s  %s  %s', 00H
	ORG $+2
$SG13535 DB	'KZMSGQOO', 00H
	ORG $+3
$SG13539 DB	'MessagePrompt Trying to pop up a Web message box: ', 00H
	ORG $+1
$SG13541 DB	'ZeidonWeb', 00H
	ORG $+2
$SG13542 DB	'Client', 00H
	ORG $+1
$SG13543 DB	'QMsg', 00H
	ORG $+3
$SG13544 DB	'QMsg', 00H
	ORG $+3
$SG13545 DB	'Title', 00H
	ORG $+2
$SG13546 DB	'QMsg', 00H
	ORG $+3
$SG13547 DB	'Text', 00H
	ORG $+3
$SG13548 DB	'QMsg', 00H
	ORG $+3
$SG13549 DB	'View', 00H
	ORG $+3
$SG13550 DB	'QMsg', 00H
	ORG $+3
$SG13552 DB	'Type', 00H
	ORG $+3
$SG13553 DB	'QMsg', 00H
	ORG $+3
$SG13576 DB	'MessagePromptForInput Task Error: %s  %s  %s', 00H
	ORG $+3
$SG13580 DB	'Interface Inactive', 00H
	ORG $+1
$SG13583 DB	'MessagePromptForInput Recursive Error: %s  %s  %s', 00H
	ORG $+2
$SG13599 DB	'MessagePresent Task Error: %d', 00H
	ORG $+2
$SG13603 DB	'Interface Inactive', 00H
	ORG $+1
$SG13606 DB	'MessagePresent Recursive Error: %d', 00H
	ORG $+1
$SG13682 DB	'TaskAppRecord', 00H
	ORG $+2
$SG13683 DB	'fnFindMQInterface', 00H
	ORG $+2
$SG13687 DB	'MQInterfaceRecord', 00H
	ORG $+2
$SG13688 DB	'fnFindMQInterface', 00H
	ORG $+2
$SG13695 DB	'Cannot load Message Object: ', 00H
	ORG $+3
$SG13696 DB	'System Error', 00H
_DATA	ENDS
PUBLIC	_MessageSend@24
PUBLIC	_MessagePrompt@32
PUBLIC	_MessagePromptForInput@28
PUBLIC	_MessagePresent@12
PUBLIC	_fnGetMsgQ@12
PUBLIC	_fnFindTaskApp
PUBLIC	_fnFindMQInterface
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_IssueError@16:PROC
EXTRN	_ActivateEmptyObjectInstance@16:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CheckExistenceOfEntity@8:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_SetCursorFirstEntityByInteger@20:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_SetAttributeFromVariable@32:PROC
EXTRN	_SysFreeLibrary@8:PROC
EXTRN	_SysGetProc@8:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysLoadLibraryWithErrFlag@12:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SfLockView@4:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_szlMessageObject:DWORD
EXTRN	_szlId:DWORD
EXTRN	_szl__MSGQ:DWORD
EXTRN	_szlTask:DWORD
EXTRN	_g_pchMQI:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemqaa.c
_TEXT	SEGMENT
_lpMQInterface$ = -12					; size = 4
_lpTaskApp$ = -8					; size = 4
_lpApp$ = -4						; size = 4
_vSubtask$ = 8						; size = 4
_lpTask$ = 12						; size = 4
_fnFindMQInterface PROC

; 697  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 698  :    LPAPP          lpApp;
; 699  :    LPTASKAPP      lpTaskApp;
; 700  :    LPMQINTERFACE  lpMQInterface;
; 701  : 
; 702  :    // DGC 12/2/96 Use Core function.
; 703  :    fnGetApplicationForSubtask( &lpApp, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8

; 704  : 
; 705  :    // If a task is coming up, then it may not yet be tied to an
; 706  :    // application, in this case get out fast.
; 707  :    if ( lpApp == 0 )

	cmp	DWORD PTR _lpApp$[ebp], 0
	jne	SHORT $LN2@fnFindMQIn

; 708  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnFindMQIn
$LN2@fnFindMQIn:

; 709  : 
; 710  :    // Find the appropriate TaskAppRecord.
; 711  :    lpTaskApp = fnFindTaskApp( vSubtask, lpTask, lpApp );

	mov	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_fnFindTaskApp
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTaskApp$[ebp], eax

; 712  : 
; 713  :    if ( lpTaskApp == 0 )

	cmp	DWORD PTR _lpTaskApp$[ebp], 0
	jne	SHORT $LN3@fnFindMQIn

; 714  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnFindMQIn
	jmp	SHORT $LN4@fnFindMQIn
$LN3@fnFindMQIn:

; 715  :    else
; 716  :    {
; 717  :       // TaskAppRecord for the application was found on the chain.
; 718  :       lpMQInterface = zGETPTR( lpTaskApp->hMQInterface );

	mov	edx, DWORD PTR _lpTaskApp$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMQInterface$[ebp], eax
$LN4@fnFindMQIn:

; 719  :    }
; 720  : 
; 721  :    return( lpMQInterface );

	mov	eax, DWORD PTR _lpMQInterface$[ebp]
$LN1@fnFindMQIn:

; 722  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnFindMQInterface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemqaa.c
_TEXT	SEGMENT
_lpTask$1 = -576					; size = 4
_lpTask$2 = -572					; size = 4
_lpTask$3 = -568					; size = 4
_lpMQInterface$4 = -564					; size = 4
tv207 = -560						; size = 4
tv206 = -556						; size = 4
_hTaskApp$ = -552					; size = 4
_hMQInterface$5 = -548					; size = 4
_lpLibrary$6 = -544					; size = 4
_hLibrary$7 = -540					; size = 4
_lProcessID$ = -536					; size = 4
_lpViewOD$8 = -532					; size = 4
_k$9 = -528						; size = 2
_bMutexLocked$10 = -522					; size = 1
_bCorrectProcess$ = -521				; size = 1
_lpTaskApp$ = -520					; size = 4
_szMsg$11 = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_vSubtask$ = 8						; size = 4
_lpTask$ = 12						; size = 4
_lpApp$ = 16						; size = 4
_fnFindTaskApp PROC

; 740  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 576				; 00000240H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 741  :    LPTASKAPP   lpTaskApp;
; 742  :    zPVOID      hTaskApp;
; 743  :    zBOOL       bCorrectProcess = TRUE;

	mov	BYTE PTR _bCorrectProcess$[ebp], 1

; 744  :    zLONG lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 745  : 
; 746  :    // Scan the TaskApp chain for the matching application.
; 747  :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN11@fnFindTask

; 748  :    {
; 749  :       for ( lpTaskApp = zGETPTR( lpTask->hFirstTaskApp );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+102]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskApp$[ebp], eax
	jmp	SHORT $LN4@fnFindTask
$LN2@fnFindTask:

; 751  :             lpTaskApp = zGETPTR( lpTaskApp->hNextTaskApp ) )

	mov	edx, DWORD PTR _lpTaskApp$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskApp$[ebp], eax
$LN4@fnFindTask:

; 750  :             lpTaskApp;

	cmp	DWORD PTR _lpTaskApp$[ebp], 0
	je	SHORT $LN3@fnFindTask

; 752  :       {
; 753  :          if ( lpTaskApp->lProcessID == lProcessID &&

	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN13@fnFindTask
	mov	eax, DWORD PTR _lpTaskApp$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpApp$[ebp]
	jne	SHORT $LN13@fnFindTask

; 754  :               zGETPTR( lpTaskApp->hApp ) == lpApp )
; 755  :          {
; 756  :             // Ensure it is for the correct process.
; 757  :             LPLIBRARY lpLibrary = zGETPTR( lpTaskApp->hLibrary );

	mov	edx, DWORD PTR _lpTaskApp$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$6[ebp], eax

; 758  : 
; 759  :             if ( lpLibrary && lpLibrary->lProcessID != lProcessID )

	cmp	DWORD PTR _lpLibrary$6[ebp], 0
	je	SHORT $LN14@fnFindTask
	mov	ecx, DWORD PTR _lpLibrary$6[ebp]
	mov	edx, DWORD PTR [ecx+271]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN14@fnFindTask

; 760  :                bCorrectProcess = FALSE;

	mov	BYTE PTR _bCorrectProcess$[ebp], 0
$LN14@fnFindTask:

; 761  : 
; 762  :             break;

	jmp	SHORT $LN3@fnFindTask
$LN13@fnFindTask:

; 763  :          }
; 764  :       }

	jmp	$LN2@fnFindTask
$LN3@fnFindTask:

; 765  :    }

	jmp	SHORT $LN12@fnFindTask
$LN11@fnFindTask:

; 766  :    else
; 767  :       lpTaskApp = 0;

	mov	DWORD PTR _lpTaskApp$[ebp], 0
$LN12@fnFindTask:

; 768  : 
; 769  :    if ( lpTaskApp == 0 || bCorrectProcess == FALSE )

	cmp	DWORD PTR _lpTaskApp$[ebp], 0
	je	SHORT $LN16@fnFindTask
	movzx	eax, BYTE PTR _bCorrectProcess$[ebp]
	test	eax, eax
	jne	$LN15@fnFindTask
$LN16@fnFindTask:

; 770  :    {
; 771  :       LPVIEWOD       lpViewOD;
; 772  :       LPMQINTERFACE  lpMQInterface;
; 773  :       zPVOID         hMQInterface;
; 774  :       LPLIBRARY      hLibrary;
; 775  : 
; 776  :       // If the application was not found on the TaskApp chain, create
; 777  :       // a new TaskAppRecord for this application and put it on the chain.
; 778  :       if ( lpTaskApp == 0 ) // need to allocate Task/Interface object

	cmp	DWORD PTR _lpTaskApp$[ebp], 0
	jne	SHORT $LN17@fnFindTask

; 779  :       {
; 780  :          hTaskApp = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10037					; 00002735H
	push	0
	push	1
	push	26					; 0000001aH
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskApp$[ebp], eax

; 781  :                                       sizeof( TaskAppRecord ),
; 782  :                                       1, 0, iTaskApp );
; 783  :          lpTaskApp = zGETPTR( hTaskApp );

	mov	eax, DWORD PTR _hTaskApp$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskApp$[ebp], eax

; 784  :          lpTaskApp->lProcessID = lProcessID;

	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	edx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [ecx+14], edx
$LN17@fnFindTask:

; 785  :       }
; 786  : 
; 787  :       if ( lpTaskApp == 0 )

	cmp	DWORD PTR _lpTaskApp$[ebp], 0
	jne	SHORT $LN18@fnFindTask

; 788  :       {
; 789  :          LPTASK lpTask = zGETPTR( vSubtask->hTask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 790  :          // "KZOEE012 - Error allocating memory"
; 791  :          fnIssueCoreError( lpTask, vSubtask, 20, 12, 0,

	push	OFFSET $SG13682
	push	OFFSET $SG13683
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$3[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 792  :                            "fnFindMQInterface", "TaskAppRecord" );
; 793  :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnFindTask
$LN18@fnFindTask:

; 794  :       }
; 795  : 
; 796  :       if ( bCorrectProcess ) // true if we allocated Task/Interface object

	movzx	ecx, BYTE PTR _bCorrectProcess$[ebp]
	test	ecx, ecx
	je	$LN19@fnFindTask

; 797  :       {
; 798  :          zBOOL bMutexLocked;
; 799  : 
; 800  :          lpTaskApp->hTask = zGETHNDL( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 801  :          lpTaskApp->hApp  = zGETHNDL( lpApp );

	mov	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 802  : 
; 803  :          // Alloc space for the MessageQueue processing entry points.
; 804  :          hMQInterface = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10047					; 0000273fH
	push	0
	push	1
	push	22					; 00000016H
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hMQInterface$5[ebp], eax

; 805  :                                           sizeof( MQInterfaceRecord ), 1, 0,
; 806  :                                           iMQInterface );
; 807  :          lpMQInterface = zGETPTR( hMQInterface );

	mov	ecx, DWORD PTR _hMQInterface$5[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMQInterface$4[ebp], eax

; 808  :          if ( lpMQInterface == 0 )

	cmp	DWORD PTR _lpMQInterface$4[ebp], 0
	jne	SHORT $LN21@fnFindTask

; 809  :          {
; 810  :             LPTASK lpTask = zGETPTR( vSubtask->hTask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 811  :             // "KZOEE012 - Error allocating memory"
; 812  :             fnIssueCoreError( lpTask, vSubtask, 20, 12, 0, "fnFindMQInterface",

	push	OFFSET $SG13687
	push	OFFSET $SG13688
	push	0
	push	12					; 0000000cH
	push	20					; 00000014H
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 813  :                               "MQInterfaceRecord" );
; 814  :             fnFreeDataspace( lpTaskApp );

	mov	eax, DWORD PTR _lpTaskApp$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 815  :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnFindTask
$LN21@fnFindTask:

; 816  :          }
; 817  : 
; 818  :          // Save list of entry points.
; 819  :          lpTaskApp->hMQInterface = hMQInterface;

	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	edx, DWORD PTR _hMQInterface$5[ebp]
	mov	DWORD PTR [ecx+22], edx

; 820  : 
; 821  :          // Chain the TaskAppRecord off the Task record (single Link List).
; 822  :          if ( lpTaskApp->hTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _lpTaskApp$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN22@fnFindTask

; 823  :          {
; 824  :             bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$10[ebp], 1

; 825  :             zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 826  :          }

	jmp	SHORT $LN23@fnFindTask
$LN22@fnFindTask:

; 827  :          else
; 828  :             bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$10[ebp], 0
$LN23@fnFindTask:

; 829  : 
; 830  :          lpTaskApp->hNextTaskApp = lpTask->hFirstTaskApp;

	mov	eax, DWORD PTR _lpTaskApp$[ebp]
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+102]
	mov	DWORD PTR [eax+2], edx

; 831  :          lpTask->hFirstTaskApp = hTaskApp;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _hTaskApp$[ebp]
	mov	DWORD PTR [eax+102], ecx

; 832  : 
; 833  :          if ( bMutexLocked )

	movzx	edx, BYTE PTR _bMutexLocked$10[ebp]
	test	edx, edx
	je	SHORT $LN24@fnFindTask

; 834  :             zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN24@fnFindTask:

; 835  :       }

	jmp	SHORT $LN20@fnFindTask
$LN19@fnFindTask:

; 836  :       else
; 837  :       {
; 838  :          SysFreeLibrary( vSubtask, lpTaskApp->hLibrary );

	mov	eax, DWORD PTR _lpTaskApp$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysFreeLibrary@8
$LN20@fnFindTask:

; 839  :       }
; 840  : 
; 841  :       // Find the Message object so that we can get the dll name for
; 842  :       // message queue object processing.
; 843  :       for ( lpViewOD = zGETPTR( lpApp->hFirstViewOD );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$8[ebp], eax
	jmp	SHORT $LN7@fnFindTask
$LN5@fnFindTask:

; 845  :             lpViewOD = zGETPTR( lpViewOD->hNextViewOD ) )

	mov	edx, DWORD PTR _lpViewOD$8[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$8[ebp], eax
$LN7@fnFindTask:

; 844  :             lpViewOD;

	cmp	DWORD PTR _lpViewOD$8[ebp], 0
	je	$LN6@fnFindTask

; 846  :       {
; 847  :          if ( zstrcmp( lpViewOD->szName, szlMessageObject ) == 0 )

	mov	ecx, DWORD PTR _lpViewOD$8[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _szlMessageObject
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN33@fnFindTask
	mov	edx, DWORD PTR _szlMessageObject
	push	edx
	mov	eax, DWORD PTR _lpViewOD$8[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN34@fnFindTask
$LN33@fnFindTask:
	mov	ecx, DWORD PTR _lpViewOD$8[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _szlMessageObject
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN31@fnFindTask
	mov	DWORD PTR tv206[ebp], 1
	jmp	SHORT $LN32@fnFindTask
$LN31@fnFindTask:
	mov	DWORD PTR tv206[ebp], -1
$LN32@fnFindTask:
	mov	edx, DWORD PTR tv206[ebp]
	mov	DWORD PTR tv207[ebp], edx
$LN34@fnFindTask:
	cmp	DWORD PTR tv207[ebp], 0
	jne	SHORT $LN25@fnFindTask

; 848  :             break;

	jmp	SHORT $LN6@fnFindTask
$LN25@fnFindTask:

; 849  :       }

	jmp	$LN5@fnFindTask
$LN6@fnFindTask:

; 850  : 
; 851  :       if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$8[ebp], 0
	jne	SHORT $LN26@fnFindTask

; 852  :       {
; 853  :          zCHAR szMsg[ 512 ];
; 854  : 
; 855  :       // LPTASK lpTask = zGETPTR( vSubtask->hTask );
; 856  : 
; 857  :          // "KZOEE330 - Message Object Definition not loaded for Application"
; 858  :       // fnIssueCoreError( lpTask, lpView, 20, 330, 0, lpApp->hName, 0 );
; 859  : 
; 860  :          // Don't use the fnIssueCoreError above because will just cause
; 861  :          // a recursive call if the message object can't be found.
; 862  :          zstrcpy( szMsg, "Cannot load Message Object: " );

	push	OFFSET $SG13695
	lea	eax, DWORD PTR _szMsg$11[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 863  :          zstrcat( szMsg, szlMessageObject );

	mov	ecx, DWORD PTR _szlMessageObject
	push	ecx
	lea	edx, DWORD PTR _szMsg$11[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 864  :          SysMessageBox( vSubtask, "System Error", szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$11[ebp]
	push	eax
	push	OFFSET $SG13696
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 865  :       }

	jmp	$LN15@fnFindTask
$LN26@fnFindTask:

; 866  :       else
; 867  :       {
; 868  :          hLibrary = SysLoadLibraryWithErrFlag( vSubtask,

	push	0
	mov	edx, DWORD PTR _lpViewOD$8[ebp]
	add	edx, 142				; 0000008eH
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysLoadLibraryWithErrFlag@12
	mov	DWORD PTR _hLibrary$7[ebp], eax

; 869  :                                                lpViewOD->szOperLibname, 0 );
; 870  : 
; 871  :          // If we have a library, get all the Message Queueing Interfaces
; 872  :          // that we know about.
; 873  :          if ( hLibrary )

	cmp	DWORD PTR _hLibrary$7[ebp], 0
	je	SHORT $LN28@fnFindTask

; 874  :          {
; 875  :             zSHORT  k;
; 876  : 
; 877  :             lpTaskApp->hLibrary = hLibrary;

	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	edx, DWORD PTR _hLibrary$7[ebp]
	mov	DWORD PTR [ecx+18], edx

; 878  :             for ( k = 0; k < MAX_CORE_MQ_INT; k++ )

	xor	eax, eax
	mov	WORD PTR _k$9[ebp], ax
	jmp	SHORT $LN10@fnFindTask
$LN8@fnFindTask:
	mov	cx, WORD PTR _k$9[ebp]
	add	cx, 1
	mov	WORD PTR _k$9[ebp], cx
$LN10@fnFindTask:
	movsx	edx, WORD PTR _k$9[ebp]
	cmp	edx, 4
	jge	SHORT $LN9@fnFindTask

; 879  :                lpMQInterface->pfnMQ[ k ] = SysGetProc( hLibrary, g_pchMQI[ k ] );

	movsx	eax, WORD PTR _k$9[ebp]
	mov	ecx, DWORD PTR _g_pchMQI[eax*4]
	push	ecx
	mov	edx, DWORD PTR _hLibrary$7[ebp]
	push	edx
	call	_SysGetProc@8
	movsx	ecx, WORD PTR _k$9[ebp]
	mov	edx, DWORD PTR _lpMQInterface$4[ebp]
	mov	DWORD PTR [edx+ecx*4+6], eax
	jmp	SHORT $LN8@fnFindTask
$LN9@fnFindTask:

; 880  :          }

	jmp	SHORT $LN15@fnFindTask
$LN28@fnFindTask:

; 881  :          else
; 882  :          {
; 883  :             LPTASK lpTask = zGETPTR( vSubtask->hTask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 884  :             // "KZOEE067 - Could not initialize the Core-MQ interface "
; 885  :             fnIssueCoreError( lpTask, vSubtask, 20, 67, 3L,

	push	0
	mov	edx, DWORD PTR _lpViewOD$8[ebp]
	add	edx, 142				; 0000008eH
	push	edx
	push	3
	push	67					; 00000043H
	push	20					; 00000014H
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN15@fnFindTask:

; 886  :                               lpViewOD->szOperLibname, 0 );
; 887  :          }
; 888  :       }
; 889  :    }
; 890  : 
; 891  :    return( lpTaskApp );

	mov	eax, DWORD PTR _lpTaskApp$[ebp]
$LN1@fnFindTask:

; 892  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnFindTaskApp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemqaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_vMsgQ$ = -4						; size = 4
_vSubtask$ = 8						; size = 4
_lpTask$ = 12						; size = 4
_lFlag$ = 16						; size = 2
_fnGetMsgQ@12 PROC

; 82   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 83   :    LPTASK lpCurrentTask;
; 84   :    zVIEW  vMsgQ;
; 85   : 
; 86   :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN2@fnGetMsgQ

; 87   :       lpCurrentTask = (LPTASK) lpTask;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	jmp	SHORT $LN3@fnGetMsgQ
$LN2@fnGetMsgQ:

; 88   :    else
; 89   :       lpCurrentTask = zGETPTR( vSubtask->hTask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
$LN3@fnGetMsgQ:

; 90   : 
; 91   :    GetViewByName( &vMsgQ, szl__MSGQ, vSubtask, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szl__MSGQ
	push	ecx
	lea	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_GetViewByName@16

; 92   :    if ( vMsgQ == 0 )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	jne	SHORT $LN4@fnGetMsgQ

; 93   :    {
; 94   :       if ( lpCurrentTask->vWebSubtask )

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN4@fnGetMsgQ

; 95   :       {
; 96   :          if ( ActivateEmptyObjectInstance( &vMsgQ, "KZMSGQOO",
; 97   :                                            lpCurrentTask->vWebSubtask,
; 98   :                                            zMULTIPLE ) >= 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	push	OFFSET $SG13421
	lea	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_ActivateEmptyObjectInstance@16
	movsx	ecx, ax
	test	ecx, ecx
	jl	SHORT $LN4@fnGetMsgQ

; 99   :          {
; 100  :             SetNameForView( vMsgQ, szl__MSGQ,

	push	2
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _szl__MSGQ
	push	ecx
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetNameForView@16
$LN4@fnGetMsgQ:

; 101  :                             lpCurrentTask->vWebSubtask, zLEVEL_TASK );
; 102  :          }
; 103  :       }
; 104  :    }
; 105  : 
; 106  :    if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	SHORT $LN7@fnGetMsgQ

; 107  :    {
; 108  :       CreateViewFromViewForTask( &vMsgQ, vMsgQ, 0 );

	push	0
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 109  : 
; 110  :       // We're gonna pop up a message box.  It's possible that the driver
; 111  :       // will try to clean up any non-named, non-locked views.  Prevent
; 112  :       // the temp view from being cleaned up by locking it.
; 113  :       SfLockView( vMsgQ );

	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SfLockView@4

; 114  :       if ( lFlag & 0x00000001 )  // determine if there are QMsg records

	movsx	eax, WORD PTR _lFlag$[ebp]
	and	eax, 1
	je	SHORT $LN7@fnGetMsgQ

; 115  :       {
; 116  :          if ( lpCurrentTask->vWebSubtask )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN7@fnGetMsgQ

; 117  :          {
; 118  :             if ( SetCursorFirstEntityByInteger( vMsgQ, szlTask, szlId,
; 119  :                                                 (zLONG) lpCurrentTask->vWebSubtask,
; 120  :                                                 0 ) != 0 ||

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _szlId
	push	ecx
	mov	edx, DWORD PTR _szlTask
	push	edx
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetCursorFirstEntityByInteger@20
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN11@fnGetMsgQ
	push	OFFSET $SG13427
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_CheckExistenceOfEntity@8
	cwde
	test	eax, eax
	je	SHORT $LN7@fnGetMsgQ
$LN11@fnGetMsgQ:

; 121  :                  CheckExistenceOfEntity( vMsgQ, "QMsg" ) != 0 )
; 122  :             {
; 123  :                DropView( vMsgQ );

	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_DropView@4

; 124  :                vMsgQ = 0;  // there are no QMsg records for this task

	mov	DWORD PTR _vMsgQ$[ebp], 0
$LN7@fnGetMsgQ:

; 125  :             }
; 126  :          }
; 127  :       }
; 128  :    }
; 129  : 
; 130  :    return( vMsgQ );

	mov	eax, DWORD PTR _vMsgQ$[ebp]

; 131  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnGetMsgQ@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemqaa.c
_TEXT	SEGMENT
_pfn$1 = -16						; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpMQInterface$ = -8					; size = 4
_nRC$ = -4						; size = 2
_vSubtask$ = 8						; size = 4
_lEventType$ = 12					; size = 4
_vMsgQ$ = 16						; size = 4
_MessagePresent@12 PROC

; 621  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 622  :    LPTASK         lpCurrentTask;
; 623  :    LPMQINTERFACE  lpMQInterface;
; 624  : // zPLONG         lplTaskID;
; 625  :    zSHORT         nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 626  : 
; 627  :    lpCurrentTask = fnOperationCall( iMessagePresent, vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	363					; 0000016bH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 628  :    if ( lpCurrentTask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MessagePre

; 629  :    {
; 630  :       TraceLine( "MessagePresent Task Error: %d", lEventType );

	mov	edx, DWORD PTR _lEventType$[ebp]
	push	edx
	push	OFFSET $SG13599
	call	_TraceLine
	add	esp, 8
$LN2@MessagePre:

; 631  :    }
; 632  : 
; 633  : // lplTaskID = &lpCurrentTask->lTaskID;
; 634  : 
; 635  : #ifdef __DO_MSGOBJ__
; 636  : // if ( fnValidView( lpCurrentTask, vSubtask ) == 0 )
; 637  : // {
; 638  : //    fnOperationReturn( iMessagePresent, lpCurrentTask );
; 639  : //    return( nRC );
; 640  : // }
; 641  : 
; 642  :    lpMQInterface = fnFindMQInterface( vSubtask, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_fnFindMQInterface
	add	esp, 8
	mov	DWORD PTR _lpMQInterface$[ebp], eax

; 643  : 
; 644  :    if ( lpMQInterface == 0 || lpMQInterface->pfnMQ[ 3 ] == 0 )

	cmp	DWORD PTR _lpMQInterface$[ebp], 0
	je	SHORT $LN5@MessagePre
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	cmp	DWORD PTR [ecx+eax+6], 0
	jne	SHORT $LN3@MessagePre
$LN5@MessagePre:

; 645  :    {
; 646  :       SysMessageBox( vSubtask, g_pchMQI[ 3 ], "Interface Inactive", 1 );

	push	1
	push	OFFSET $SG13603
	mov	edx, 4
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _g_pchMQI[eax]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 647  :    }

	jmp	$LN4@MessagePre
$LN3@MessagePre:

; 648  :    else
; 649  :    if ( lpMQInterface->bRecursiveCall )

	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	and	ecx, 1
	je	SHORT $LN6@MessagePre

; 650  :    {
; 651  :       TraceLine( "MessagePresent Recursive Error: %d", lEventType );

	mov	edx, DWORD PTR _lEventType$[ebp]
	push	edx
	push	OFFSET $SG13606
	call	_TraceLine
	add	esp, 8

; 652  :    // SysMessageBox( vSubtask, g_pchMQI[ 0 ],
; 653  :    //                "Recursive error on MessagePresent", 1 );
; 654  :    }

	jmp	SHORT $LN4@MessagePre
$LN6@MessagePre:

; 655  :    else
; 656  :    {
; 657  :       lpMQInterface->bRecursiveCall = TRUE;

	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	or	ecx, 1
	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [edx+2], ecx

; 658  : 
; 659  :       if ( vMsgQ == 0 )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	jne	SHORT $LN8@MessagePre

; 660  :          GetViewByName( &vMsgQ, szl__MSGQ, vSubtask, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szl__MSGQ
	push	ecx
	lea	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_GetViewByName@16
$LN8@MessagePre:

; 661  : 
; 662  :       if ( vMsgQ ) // **HH**

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	SHORT $LN9@MessagePre

; 663  :       {
; 664  :          MQ_MessagePresent pfn;
; 665  : 
; 666  :       // TraceLineS( "MessagePresent Trying to pop up a message box", "" );
; 667  :          pfn = (MQ_MessagePresent) lpMQInterface->pfnMQ[ 3 ];

	mov	eax, 4
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	mov	eax, DWORD PTR [edx+ecx+6]
	mov	DWORD PTR _pfn$1[ebp], eax

; 668  :          CreateViewFromViewForTask( &vMsgQ, vMsgQ, 0 );

	push	0
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 669  :          nRC = (*pfn)( vMsgQ, vSubtask, lEventType );

	mov	eax, DWORD PTR _lEventType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	DWORD PTR _pfn$1[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 670  :          DropView( vMsgQ );

	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_DropView@4
$LN9@MessagePre:

; 671  :       }
; 672  : 
; 673  :       lpMQInterface->bRecursiveCall = FALSE;

	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [eax+2], edx
$LN4@MessagePre:

; 674  :    }
; 675  : #endif
; 676  : 
; 677  :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN10@MessagePre

; 678  :       fnOperationReturn( iMessagePresent, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	363					; 0000016bH
	call	_fnOperationReturn
	add	esp, 8
$LN10@MessagePre:

; 679  : 
; 680  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 681  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_MessagePresent@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemqaa.c
_TEXT	SEGMENT
_pfn$1 = -20						; size = 4
_lpCurrentTask$ = -16					; size = 4
_vMsgQ$ = -12						; size = 4
_lpMQInterface$ = -8					; size = 4
_nRC$ = -4						; size = 2
_vSubtask$ = 8						; size = 4
_cpcMsgId$ = 12						; size = 4
_cpcTitle$ = 16						; size = 4
_cpcMsgText$ = 20					; size = 4
_bBeep$ = 24						; size = 2
_pchReturnBuffer$ = 28					; size = 4
_usBufferLth$ = 32					; size = 2
_MessagePromptForInput@28 PROC

; 529  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 530  :    LPTASK         lpCurrentTask;
; 531  :    LPMQINTERFACE  lpMQInterface;
; 532  : // zPLONG         lplTaskID;
; 533  :    zVIEW          vMsgQ;
; 534  :    zSHORT         nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 535  : 
; 536  :    lpCurrentTask = fnOperationCall( iMessagePromptForInput, vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	362					; 0000016aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 537  :    if ( lpCurrentTask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MessagePro

; 538  :    {
; 539  :       TraceLine( "MessagePromptForInput Task Error: %s  %s  %s",

	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	push	OFFSET $SG13576
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN2@MessagePro:

; 540  :                  cpcMsgId, cpcTitle, cpcMsgText );
; 541  :    }
; 542  : 
; 543  : // lplTaskID = &lpCurrentTask->lTaskID;
; 544  : 
; 545  : #ifdef __DO_MSGOBJ__
; 546  : // if ( fnValidView( lpCurrentTask, vSubtask ) == 0 )
; 547  : // {
; 548  : //    fnOperationReturn( iMessagePromptForInput, lpCurrentTask );
; 549  : //    return( nRC );
; 550  : // }
; 551  : 
; 552  :    lpMQInterface = fnFindMQInterface( vSubtask, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_fnFindMQInterface
	add	esp, 8
	mov	DWORD PTR _lpMQInterface$[ebp], eax

; 553  : 
; 554  :    if ( lpMQInterface == 0 || lpMQInterface->pfnMQ[ 2 ] == 0 )

	cmp	DWORD PTR _lpMQInterface$[ebp], 0
	je	SHORT $LN5@MessagePro
	mov	ecx, 4
	shl	ecx, 1
	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	cmp	DWORD PTR [edx+ecx+6], 0
	jne	SHORT $LN3@MessagePro
$LN5@MessagePro:

; 555  :    {
; 556  :       SysMessageBox( vSubtask, g_pchMQI[ 2 ], "Interface Inactive", 1 );

	push	1
	push	OFFSET $SG13580
	mov	eax, 4
	shl	eax, 1
	mov	ecx, DWORD PTR _g_pchMQI[eax]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 557  :       SysMessageBox( vSubtask, cpcTitle, cpcMsgText, 1 );

	push	1
	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 558  :    }

	jmp	$LN4@MessagePro
$LN3@MessagePro:

; 559  :    else
; 560  :    if ( lpMQInterface->bRecursiveCall )

	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	and	ecx, 1
	je	SHORT $LN6@MessagePro

; 561  :    {
; 562  :       TraceLine( "MessagePromptForInput Recursive Error: %s  %s  %s",

	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	push	OFFSET $SG13583
	call	_TraceLine
	add	esp, 16					; 00000010H

; 563  :                  cpcMsgId, cpcTitle, cpcMsgText );
; 564  :    // SysMessageBox( vSubtask, g_pchMQI[ 0 ], "Recursive error", 1 );
; 565  :    // SysMessageBox( vSubtask, cpcTitle, cpcMsgText, 1 );
; 566  :    }

	jmp	$LN4@MessagePro
$LN6@MessagePro:

; 567  :    else
; 568  :    {
; 569  :       lpMQInterface->bRecursiveCall = TRUE;

	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	mov	eax, DWORD PTR [edx+2]
	or	eax, 1
	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 570  : 
; 571  :       GetViewByName( &vMsgQ, szl__MSGQ, vSubtask, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _szl__MSGQ
	push	eax
	lea	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_GetViewByName@16

; 572  :       if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	SHORT $LN8@MessagePro

; 573  :       {
; 574  :          MQ_MessagePromptForInput pfn;
; 575  : 
; 576  :       // TraceLineS( "MessagePromptForInput Trying to pop up a message box: ",
; 577  :       //             cpcMsgText );
; 578  :          pfn = lpMQInterface->pfnMQ[ 2 ];

	mov	edx, 4
	shl	edx, 1
	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	ecx, DWORD PTR [eax+edx+6]
	mov	DWORD PTR _pfn$1[ebp], ecx

; 579  :          CreateViewFromViewForTask( &vMsgQ, vMsgQ, 0 );

	push	0
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	lea	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 580  :          nRC = (*pfn)( vMsgQ, vSubtask, cpcMsgId, cpcTitle,

	movzx	ecx, WORD PTR _usBufferLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnBuffer$[ebp]
	push	edx
	movzx	eax, WORD PTR _bBeep$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgText$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTitle$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMsgId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	DWORD PTR _pfn$1[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 581  :                        cpcMsgText, bBeep, pchReturnBuffer, usBufferLth );
; 582  :          DropView( vMsgQ );

	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_DropView@4
$LN8@MessagePro:

; 583  :       }
; 584  : 
; 585  :       lpMQInterface->bRecursiveCall = FALSE;

	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [eax+2], edx
$LN4@MessagePro:

; 586  :    }
; 587  : #endif
; 588  : 
; 589  :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN9@MessagePro

; 590  :       fnOperationReturn( iMessagePromptForInput, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	362					; 0000016aH
	call	_fnOperationReturn
	add	esp, 8
$LN9@MessagePro:

; 591  : 
; 592  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 593  : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_MessagePromptForInput@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemqaa.c
_TEXT	SEGMENT
_pfn$1 = -20						; size = 4
_lpMQInterface$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_vMsgQ$ = -8						; size = 4
_nRC$ = -4						; size = 2
_vSubtask$ = 8						; size = 4
_cpcMsgId$ = 12						; size = 4
_cpcTitle$ = 16						; size = 4
_cpcMsgText$ = 20					; size = 4
_bBeep$ = 24						; size = 2
_nButtons$ = 28						; size = 2
_nDefaultButton$ = 32					; size = 2
_nIcon$ = 36						; size = 2
_MessagePrompt@32 PROC

; 383  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 384  :    LPTASK         lpCurrentTask;
; 385  :    LPMQINTERFACE  lpMQInterface;
; 386  : // zPLONG         lplTaskID;
; 387  :    zVIEW          vMsgQ;
; 388  :    zSHORT         nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 389  : 
; 390  :    lpCurrentTask = fnOperationCall( iMessagePrompt, vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	361					; 00000169H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 391  :    if ( lpCurrentTask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MessagePro

; 392  :    {
; 393  :       TraceLine( "MessagePrompt Task Error: %s  %s  %s",

	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	push	OFFSET $SG13524
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN2@MessagePro:

; 394  :                  cpcMsgId, cpcTitle, cpcMsgText );
; 395  :    }
; 396  : 
; 397  : // lplTaskID = &lpCurrentTask->lTaskID;
; 398  : 
; 399  : #ifdef __DO_MSGOBJ__
; 400  : // if ( fnValidView( lpCurrentTask, vSubtask ) == 0 )
; 401  : // {
; 402  : //    fnOperationReturn( iMessagePrompt, lpCurrentTask );
; 403  : //    return( nRC );
; 404  : // }
; 405  : 
; 406  :    lpMQInterface = fnFindMQInterface( vSubtask, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_fnFindMQInterface
	add	esp, 8
	mov	DWORD PTR _lpMQInterface$[ebp], eax

; 407  : 
; 408  :    if ( lpMQInterface == 0 || lpMQInterface->pfnMQ[ 1 ] == 0 )

	cmp	DWORD PTR _lpMQInterface$[ebp], 0
	je	SHORT $LN5@MessagePro
	mov	ecx, 4
	shl	ecx, 0
	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	cmp	DWORD PTR [edx+ecx+6], 0
	jne	SHORT $LN3@MessagePro
$LN5@MessagePro:

; 409  :    {
; 410  :       SysMessageBox( vSubtask, g_pchMQI[ 1 ], "Interface Inactive", 1 );

	push	1
	push	OFFSET $SG13528
	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _g_pchMQI[eax]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 411  :       SysMessageBox( vSubtask, cpcTitle, cpcMsgText, 1 );

	push	1
	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 412  :    }

	jmp	$LN4@MessagePro
$LN3@MessagePro:

; 413  :    else
; 414  :    if ( lpMQInterface->bRecursiveCall )

	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	and	ecx, 1
	je	SHORT $LN6@MessagePro

; 415  :    {
; 416  :       TraceLine( "MessagePrompt Recursive Error: %s  %s  %s",

	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	push	OFFSET $SG13531
	call	_TraceLine
	add	esp, 16					; 00000010H

; 417  :                  cpcMsgId, cpcTitle, cpcMsgText );
; 418  :    // SysMessageBox( vSubtask, g_pchMQI[ 0 ], "Recursive error", 1 );
; 419  :    // SysMessageBox( vSubtask, cpcTitle, cpcMsgText, 1 );
; 420  :    }

	jmp	$LN4@MessagePro
$LN6@MessagePro:

; 421  :    else
; 422  :    {
; 423  :       lpMQInterface->bRecursiveCall = TRUE;

	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	mov	eax, DWORD PTR [edx+2]
	or	eax, 1
	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 424  : 
; 425  :       GetViewByName( &vMsgQ, szl__MSGQ, vSubtask, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _szl__MSGQ
	push	eax
	lea	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_GetViewByName@16

; 426  :       if ( vMsgQ == 0 )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	jne	SHORT $LN8@MessagePro

; 427  :       {
; 428  :          if ( lpCurrentTask->vWebSubtask )

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN8@MessagePro

; 429  :          {
; 430  :             if ( ActivateEmptyObjectInstance( &vMsgQ, "KZMSGQOO",
; 431  :                                               lpCurrentTask->vWebSubtask,
; 432  :                                               zMULTIPLE ) >= 0 )

	push	256					; 00000100H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	push	OFFSET $SG13535
	lea	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_ActivateEmptyObjectInstance@16
	cwde
	test	eax, eax
	jl	SHORT $LN8@MessagePro

; 433  :             {
; 434  :                SetNameForView( vMsgQ, szl__MSGQ,

	push	2
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _szl__MSGQ
	push	eax
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetNameForView@16
$LN8@MessagePro:

; 435  :                                lpCurrentTask->vWebSubtask, zLEVEL_TASK );
; 436  :             }
; 437  :          }
; 438  :       }
; 439  : 
; 440  :       if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	$LN11@MessagePro

; 441  :       {
; 442  :          CreateViewFromViewForTask( &vMsgQ, vMsgQ, 0 );

	push	0
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	lea	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 443  : 
; 444  :          // We're gonna pop up a message box.  It's possible that the driver
; 445  :          // will try to clean up any non-named, non-locked views.  Prevent
; 446  :          // the temp view from being cleaned up by locking it.
; 447  :          SfLockView( vMsgQ );

	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SfLockView@4

; 448  :          if ( lpCurrentTask->vWebSubtask )

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	$LN12@MessagePro

; 449  :          {
; 450  :             TraceLineS( "MessagePrompt Trying to pop up a Web message box: ",

	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	push	OFFSET $SG13539
	call	_TraceLineS@8

; 451  :                         cpcMsgText );
; 452  :             if ( SetCursorFirstEntityByInteger( vMsgQ, szlTask, szlId,
; 453  :                                                 (zLONG) lpCurrentTask->vWebSubtask,
; 454  :                                                 0 ) != 0 )

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _szlId
	push	eax
	mov	ecx, DWORD PTR _szlTask
	push	ecx
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetCursorFirstEntityByInteger@20
	cwde
	test	eax, eax
	je	SHORT $LN14@MessagePro

; 455  :             {
; 456  :                CreateEntity( vMsgQ, szlTask, zPOS_LAST );

	push	2
	mov	ecx, DWORD PTR _szlTask
	push	ecx
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_CreateEntity@12

; 457  :                SetAttributeFromVariable( vMsgQ, szlTask, szlId,

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	mov	ecx, DWORD PTR _szlId
	push	ecx
	mov	edx, DWORD PTR _szlTask
	push	edx
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromVariable@32

; 458  :                                          &lpCurrentTask->vWebSubtask,
; 459  :                                          zTYPE_INTEGER,
; 460  :                                          0, 0, 0 );
; 461  :                SetAttributeFromVariable( vMsgQ, szlTask, "Client",

	push	0
	push	0
	push	0
	push	83					; 00000053H
	push	OFFSET $SG13541
	push	OFFSET $SG13542
	mov	ecx, DWORD PTR _szlTask
	push	ecx
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetAttributeFromVariable@32
$LN14@MessagePro:

; 462  :                                          "ZeidonWeb", zTYPE_STRING, 0, 0, 0 );
; 463  :             }
; 464  : 
; 465  :             CreateEntity( vMsgQ, "QMsg", zPOS_LAST );

	push	2
	push	OFFSET $SG13543
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_CreateEntity@12

; 466  :             SetAttributeFromString( vMsgQ, "QMsg", szlId, cpcMsgId );

	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlId
	push	edx
	push	OFFSET $SG13544
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 467  :             SetAttributeFromString( vMsgQ, "QMsg", "Title", cpcTitle );

	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	push	OFFSET $SG13545
	push	OFFSET $SG13546
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 468  :             SetAttributeFromString( vMsgQ, "QMsg", "Text", cpcMsgText );

	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	push	OFFSET $SG13547
	push	OFFSET $SG13548
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 469  :             SetAttributeFromInteger( vMsgQ, "QMsg", "View", (zLONG) vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET $SG13549
	push	OFFSET $SG13550
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 470  :             if ( nButtons == 4 ) // zBUTTONS_OKCANCEL

	movsx	ecx, WORD PTR _nButtons$[ebp]
	cmp	ecx, 4
	jne	SHORT $LN15@MessagePro

; 471  :                SetAttributeFromInteger( vMsgQ, "QMsg", "Type", -1 );  // prompt

	push	-1
	push	OFFSET $SG13552
	push	OFFSET $SG13553
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16
$LN15@MessagePro:

; 472  :          }

	jmp	SHORT $LN13@MessagePro
$LN12@MessagePro:

; 473  :          else
; 474  :          {
; 475  :             MQ_MessagePrompt pfn = lpMQInterface->pfnMQ[ 1 ];

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	edx, DWORD PTR [ecx+eax+6]
	mov	DWORD PTR _pfn$1[ebp], edx

; 476  :          // TraceLineS( "MessagePrompt Trying to pop up a message box: ",
; 477  :          //             cpcMsgText );
; 478  :             nRC = (*pfn)( vMsgQ, vSubtask, cpcMsgId, cpcTitle,

	movzx	eax, WORD PTR _nIcon$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nDefaultButton$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nButtons$[ebp]
	push	edx
	movzx	eax, WORD PTR _bBeep$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgText$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTitle$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMsgId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	DWORD PTR _pfn$1[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN13@MessagePro:

; 479  :                           cpcMsgText, bBeep, nButtons,
; 480  :                           nDefaultButton, nIcon );
; 481  :          }
; 482  : 
; 483  :          DropView( vMsgQ );

	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_DropView@4
$LN11@MessagePro:

; 484  :       }
; 485  : 
; 486  :       lpMQInterface->bRecursiveCall = FALSE;

	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [eax+2], edx
$LN4@MessagePro:

; 487  :    }
; 488  : 
; 489  : #endif
; 490  : 
; 491  :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN16@MessagePro

; 492  :       fnOperationReturn( iMessagePrompt, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	361					; 00000169H
	call	_fnOperationReturn
	add	esp, 8
$LN16@MessagePro:

; 493  : 
; 494  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 495  : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_MessagePrompt@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoemqaa.c
_TEXT	SEGMENT
_pfn$1 = -552						; size = 4
_pfn$2 = -548						; size = 4
_lpMQInterface$ = -544					; size = 4
_lpCurrentTask$ = -540					; size = 4
_nRC$ = -536						; size = 2
_vMsgQ$ = -532						; size = 4
_szMsg$3 = -528						; size = 512
_sz$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_vSubtask$ = 8						; size = 4
_cpcMsgId$ = 12						; size = 4
_cpcTitle$ = 16						; size = 4
_cpcMsgText$ = 20					; size = 4
_lMsgType$ = 24						; size = 4
_bBeep$ = 28						; size = 2
_MessageSend@24 PROC

; 165  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 166  :    LPTASK         lpCurrentTask;
; 167  :    LPMQINTERFACE  lpMQInterface;
; 168  :    zVIEW          vMsgQ;
; 169  : // zPLONG         lplTaskID;
; 170  :    zSHORT         nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 171  :    zCHAR          sz[ 10 ];
; 172  : 
; 173  :    lpCurrentTask = fnOperationCall( iMessageSend, vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	360					; 00000168H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 174  :    if ( lpCurrentTask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@MessageSen

; 175  :    {
; 176  :       TraceLine( "MessageSend Task Error: %s  %s  %s  %d",

	mov	edx, DWORD PTR _lMsgType$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMsgId$[ebp]
	push	edx
	push	OFFSET $SG13456
	call	_TraceLine
	add	esp, 20					; 00000014H
$LN2@MessageSen:

; 177  :                  cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 178  :    }
; 179  : 
; 180  : // lplTaskID = &lpCurrentTask->lTaskID;
; 181  : 
; 182  : #ifdef __DO_MSGOBJ__
; 183  : // if ( fnValidView( lpCurrentTask, vSubtask ) == 0 )
; 184  : // {
; 185  : //    fnOperationReturn( iMessageSend, lpCurrentTask );
; 186  : //    return( nRC );
; 187  : // }
; 188  : 
; 189  :    lpMQInterface = fnFindMQInterface( vSubtask, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_fnFindMQInterface
	add	esp, 8
	mov	DWORD PTR _lpMQInterface$[ebp], eax

; 190  : 
; 191  :    if ( lpMQInterface == 0 || lpMQInterface->pfnMQ[ 0 ] == 0 )

	cmp	DWORD PTR _lpMQInterface$[ebp], 0
	je	SHORT $LN5@MessageSen
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	cmp	DWORD PTR [ecx+eax+6], 0
	jne	SHORT $LN3@MessageSen
$LN5@MessageSen:

; 192  :    {
; 193  :       TraceLine( "MessageSend Interface Inactive: %s  %s  %s  %d",

	mov	edx, DWORD PTR _lMsgType$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMsgId$[ebp]
	push	edx
	push	OFFSET $SG13460
	call	_TraceLine
	add	esp, 20					; 00000014H

; 194  :                  cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 195  :       if ( lpCurrentTask == 0 || lpCurrentTask->vWebSubtask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN7@MessageSen
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN6@MessageSen
$LN7@MessageSen:

; 196  :       {
; 197  :          zCHAR szMsg[ 512 ];
; 198  : 
; 199  :          zsprintf( szMsg, "Message Interface Inactive: %s %s %s %d",

	mov	ecx, DWORD PTR _lMsgType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	push	OFFSET $SG13463
	lea	edx, DWORD PTR _szMsg$3[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 200  :                    cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 201  :          SysMessageBox( vSubtask, g_pchMQI[ 0 ], szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$3[ebp]
	push	eax
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _g_pchMQI[edx]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysMessageBox@16
$LN6@MessageSen:

; 202  :       }
; 203  :    }

	jmp	$LN4@MessageSen
$LN3@MessageSen:

; 204  :    else
; 205  :    if ( lpMQInterface->bRecursiveCall )

	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	mov	eax, DWORD PTR [edx+2]
	and	eax, 1
	je	SHORT $LN8@MessageSen

; 206  :    {
; 207  :       TraceLine( "MessageSend Recursive Error: %s  %s  %s  %d",

	mov	ecx, DWORD PTR _lMsgType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	push	OFFSET $SG13466
	call	_TraceLine
	add	esp, 20					; 00000014H

; 208  :                  cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 209  :    // SysMessageBox( vSubtask, g_pchMQI[ 0 ], "Recursive error", 1 );
; 210  :    // SysMessageBox( vSubtask, cpcTitle, cpcMsgText, 1 );
; 211  :    }

	jmp	$LN4@MessageSen
$LN8@MessageSen:

; 212  :    else
; 213  :    {
; 214  :       TraceLine( "MessageSend Interface Active: %s  %s  %s  %d",

	mov	edx, DWORD PTR _lMsgType$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMsgId$[ebp]
	push	edx
	push	OFFSET $SG13467
	call	_TraceLine
	add	esp, 20					; 00000014H

; 215  :                  cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 216  :       lpMQInterface->bRecursiveCall = TRUE;

	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	or	ecx, 1
	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [edx+2], ecx

; 217  :       vMsgQ = fnGetMsgQ( vSubtask, lpCurrentTask, 0 );

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_fnGetMsgQ@12
	mov	DWORD PTR _vMsgQ$[ebp], eax

; 218  : 
; 219  :       // If the zeidon.ini requests that all messages be sent to the User, but
; 220  :       // there is not a valid message object, we will simply exit, because we
; 221  :       // cannot get a message back to the User.
; 222  :       SysReadZeidonIni( -1, "[ObjectEngine]", "WebUserErrorMessages", sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET $SG13468
	push	OFFSET $SG13469
	push	-1
	call	_SysReadZeidonIni@16

; 223  :       if ( (sz[ 0 ] == 'Y' || sz[ 0 ] == 'y') && vMsgQ == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sz$[ebp+ecx]
	cmp	edx, 89					; 00000059H
	je	SHORT $LN12@MessageSen
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sz$[ebp+ecx]
	cmp	edx, 121				; 00000079H
	jne	SHORT $LN10@MessageSen
$LN12@MessageSen:
	cmp	DWORD PTR _vMsgQ$[ebp], 0
	jne	SHORT $LN10@MessageSen

; 224  :          nRC = -16;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	$LN11@MessageSen
$LN10@MessageSen:

; 225  :       else
; 226  :       {
; 227  :          // When running on the Web, messages will be sent back to the End User if:
; 228  :          // 1. The error message type is Domain, Constraint Error or Constraint Warning. (These
; 229  :          //    messages should always be returned to the End User.)
; 230  :          // 2. The zeidon.ini variable, WebUserErrorMessages, is set to Y. (This allows us to have
; 231  :          //    messages pop up when debugging but to be sent back to the User in production).
; 232  :          if ( lpCurrentTask->vWebSubtask )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	$LN13@MessageSen

; 233  :          {
; 234  :             if ( sz[ 0 ] == 'Y' || sz[ 0 ] == 'y' ||
; 235  :                  lMsgType == zMSGQ_DOMAIN_ERROR ||
; 236  :                  lMsgType == zMSGQ_OBJECT_CONSTRAINT_ERROR ||
; 237  :                  lMsgType == zMSGQ_OBJECT_CONSTRAINT_WARNING ||

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _sz$[ebp+eax]
	cmp	ecx, 89					; 00000059H
	je	SHORT $LN17@MessageSen
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _sz$[ebp+eax]
	cmp	ecx, 121				; 00000079H
	je	SHORT $LN17@MessageSen
	cmp	DWORD PTR _lMsgType$[ebp], 200		; 000000c8H
	je	SHORT $LN17@MessageSen
	cmp	DWORD PTR _lMsgType$[ebp], 300		; 0000012cH
	je	SHORT $LN17@MessageSen
	cmp	DWORD PTR _lMsgType$[ebp], 100		; 00000064H
	je	SHORT $LN17@MessageSen
	cmp	DWORD PTR _lMsgType$[ebp], 400		; 00000190H
	jne	$LN15@MessageSen
$LN17@MessageSen:

; 238  :                  lMsgType == zMSGQ_REQUIRED_DATA_ITEM_ERROR )
; 239  :             {
; 240  :                if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	$LN18@MessageSen

; 241  :                {
; 242  :                   TraceLine( "MessagePrompt Trying to pop up a Web message box: %s for WebSubtask: 0x%08x",

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgText$[ebp]
	push	ecx
	push	OFFSET $SG13480
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 243  :                              cpcMsgText, lpCurrentTask->vWebSubtask );
; 244  :                   if ( SetCursorFirstEntityByInteger( vMsgQ, szlTask, szlId,
; 245  :                                                       (zLONG) lpCurrentTask->vWebSubtask,
; 246  :                                                       0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _szlId
	push	ecx
	mov	edx, DWORD PTR _szlTask
	push	edx
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetCursorFirstEntityByInteger@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN20@MessageSen

; 247  :                   {
; 248  :                   // TraceLine( "MessageSend Creating Task Entity: %s  %s  %s  %d",
; 249  :                   //            cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 250  :                      CreateEntity( vMsgQ, szlTask, zPOS_LAST );

	push	2
	mov	edx, DWORD PTR _szlTask
	push	edx
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_CreateEntity@12

; 251  :                   // TraceLine( "MessageSend Created Task Entity: %s  %s  %s  %d",
; 252  :                   //            cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 253  :                      SetAttributeFromVariable( vMsgQ, szlTask, szlId,

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	edx, DWORD PTR _szlId
	push	edx
	mov	eax, DWORD PTR _szlTask
	push	eax
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetAttributeFromVariable@32

; 254  :                                                &lpCurrentTask->vWebSubtask,
; 255  :                                                zTYPE_INTEGER,
; 256  :                                                0, 0, 0 );
; 257  :                      SetAttributeFromVariable( vMsgQ, szlTask, "Client",

	push	0
	push	0
	push	0
	push	83					; 00000053H
	push	OFFSET $SG13482
	push	OFFSET $SG13483
	mov	edx, DWORD PTR _szlTask
	push	edx
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromVariable@32
$LN20@MessageSen:

; 258  :                                                "ZeidonWeb", zTYPE_STRING, 0, 0, 0 );
; 259  :                   }
; 260  : 
; 261  :                // TraceLine( "MessageSend Creating QMsg Entity: %s  %s  %s  %d",
; 262  :                //            cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 263  :                   CreateEntity( vMsgQ, "QMsg", zPOS_LAST );

	push	2
	push	OFFSET $SG13484
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_CreateEntity@12

; 264  :                // TraceLine( "MessageSend Created QMsg Entity: %s  %s  %s  %d",
; 265  :                //            cpcMsgId, cpcTitle, cpcMsgText, lMsgType );
; 266  :                   SetAttributeFromString( vMsgQ, "QMsg", szlId, cpcMsgId );

	mov	edx, DWORD PTR _cpcMsgId$[ebp]
	push	edx
	mov	eax, DWORD PTR _szlId
	push	eax
	push	OFFSET $SG13485
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 267  :                   SetAttributeFromString( vMsgQ, "QMsg", "Title", cpcTitle );

	mov	edx, DWORD PTR _cpcTitle$[ebp]
	push	edx
	push	OFFSET $SG13486
	push	OFFSET $SG13487
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 268  :                   SetAttributeFromString( vMsgQ, "QMsg", "Text", cpcMsgText );

	mov	ecx, DWORD PTR _cpcMsgText$[ebp]
	push	ecx
	push	OFFSET $SG13488
	push	OFFSET $SG13489
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 269  :                   SetAttributeFromInteger( vMsgQ, "QMsg", "View", (zLONG) vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG13490
	push	OFFSET $SG13491
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16

; 270  :                }

	jmp	SHORT $LN19@MessageSen
$LN18@MessageSen:

; 271  :                else
; 272  :                {
; 273  :                   // We are in the Web without a valid view (problem "Invalid View" error), so simply return with error code.
; 274  :                   nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx
$LN19@MessageSen:

; 275  :                }
; 276  :             }

	jmp	SHORT $LN16@MessageSen
$LN15@MessageSen:

; 277  :             else
; 278  :             {
; 279  :                if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	SHORT $LN21@MessageSen

; 280  :                {
; 281  :                   MQ_MessageSend pfn = (MQ_MessageSend) lpMQInterface->pfnMQ[ 0 ];

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpMQInterface$[ebp]
	mov	eax, DWORD PTR [edx+ecx+6]
	mov	DWORD PTR _pfn$2[ebp], eax

; 282  :                // TraceLineS( "MessagePrompt Trying to pop up a message box: ",
; 283  :                //             cpcMsgText );
; 284  :                   nRC = (*pfn)( vMsgQ, vSubtask, cpcMsgId, cpcTitle,

	movzx	ecx, WORD PTR _bBeep$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lMsgType$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMsgId$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	DWORD PTR _pfn$2[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 285  :                                 cpcMsgText, lMsgType, bBeep );
; 286  :                   DropView( vMsgQ );

	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_DropView@4

; 287  :                }

	jmp	SHORT $LN16@MessageSen
$LN21@MessageSen:

; 288  :                else
; 289  :                   IssueError( vSubtask, 0, 0, cpcMsgText );

	mov	eax, DWORD PTR _cpcMsgText$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_IssueError@16
$LN16@MessageSen:

; 290  :             }
; 291  :          }

	jmp	SHORT $LN11@MessageSen
$LN13@MessageSen:

; 292  :          else
; 293  :          {
; 294  :             if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	SHORT $LN23@MessageSen

; 295  :             {
; 296  :                MQ_MessageSend pfn = (MQ_MessageSend) lpMQInterface->pfnMQ[ 0 ];

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	edx, DWORD PTR [ecx+eax+6]
	mov	DWORD PTR _pfn$1[ebp], edx

; 297  :             // TraceLineS( "MessagePrompt Trying to pop up a message box: ",
; 298  :             //             cpcMsgText );
; 299  :                nRC = (*pfn)( vMsgQ, vSubtask, cpcMsgId, cpcTitle,

	movzx	eax, WORD PTR _bBeep$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lMsgType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsgId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	DWORD PTR _pfn$1[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 300  :                           cpcMsgText, lMsgType, bBeep );
; 301  :                DropView( vMsgQ );

	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_DropView@4

; 302  :             }

	jmp	SHORT $LN11@MessageSen
$LN23@MessageSen:

; 303  :             else
; 304  :                IssueError( vSubtask, 0, 0, cpcMsgText );

	mov	edx, DWORD PTR _cpcMsgText$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_IssueError@16
$LN11@MessageSen:

; 305  :          }
; 306  :       }
; 307  : 
; 308  :       lpMQInterface->bRecursiveCall = FALSE;

	mov	ecx, DWORD PTR _lpMQInterface$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpMQInterface$[ebp]
	mov	DWORD PTR [eax+2], edx
$LN4@MessageSen:

; 309  :    }
; 310  : 
; 311  : #endif
; 312  : 
; 313  :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN25@MessageSen

; 314  :       fnOperationReturn( iMessageSend, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	360					; 00000168H
	call	_fnOperationReturn
	add	esp, 8
$LN25@MessageSen:

; 315  : 
; 316  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 317  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_MessageSend@24 ENDP
_TEXT	ENDS
END
