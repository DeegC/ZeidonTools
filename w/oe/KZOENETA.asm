; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOENETA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_chNetSendCompressed
PUBLIC	_szlApplA
PUBLIC	_szlAddress
PUBLIC	__szlApplication
PUBLIC	_szlArgument
PUBLIC	_szlDataServer
PUBLIC	_szlDefaultServer
PUBLIC	_szlLOD
PUBLIC	_szlNetworkError
PUBLIC	_szlOverrideLOD
PUBLIC	_szlOverrideLOD_Server
PUBLIC	_szlOverrideOper
PUBLIC	_szlOverrideOperServer
PUBLIC	_szlFalse
PUBLIC	_szlTrue
PUBLIC	_szlTranDataServer
PUBLIC	_szlTransformation
PUBLIC	_szlTranUserGroup
PUBLIC	_szlUserGroup
_BSS	SEGMENT
$SG15376 DB	01H DUP (?)
$SG15379 DB	01H DUP (?)
_g_chNetSendCompressed DB 01H DUP (?)
$SG14363 DB	01H DUP (?)
$SG15405 DB	01H DUP (?)
$SG15410 DB	01H DUP (?)
$SG15413 DB	01H DUP (?)
$SG15442 DB	01H DUP (?)
$SG15444 DB	01H DUP (?)
$SG15447 DB	01H DUP (?)
$SG14426 DB	01H DUP (?)
$SG14428 DB	01H DUP (?)
$SG15454 DB	01H DUP (?)
$SG14430 DB	01H DUP (?)
$SG14432 DB	01H DUP (?)
$SG15459 DB	01H DUP (?)
$SG15463 DB	01H DUP (?)
$SG15471 DB	01H DUP (?)
$SG15474 DB	01H DUP (?)
$SG15477 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_jbEmergencyExit:DWORD:010H
_DATA	ENDS
_BSS	SEGMENT
$SG15483 DB	01H DUP (?)
$SG15626 DB	01H DUP (?)
$SG15628 DB	01H DUP (?)
$SG15631 DB	01H DUP (?)
$SG15634 DB	01H DUP (?)
$SG15639 DB	01H DUP (?)
$SG15645 DB	01H DUP (?)
$SG15659 DB	01H DUP (?)
$SG15662 DB	01H DUP (?)
$SG15667 DB	01H DUP (?)
$SG15679 DB	01H DUP (?)
$SG15682 DB	01H DUP (?)
$SG15688 DB	01H DUP (?)
$SG15691 DB	01H DUP (?)
$SG15737 DB	01H DUP (?)
$SG15740 DB	01H DUP (?)
$SG15743 DB	01H DUP (?)
$SG15750 DB	01H DUP (?)
$SG15754 DB	01H DUP (?)
$SG15761 DB	01H DUP (?)
$SG15766 DB	01H DUP (?)
$SG15769 DB	01H DUP (?)
$SG15774 DB	01H DUP (?)
$SG14783 DB	01H DUP (?)
$SG14802 DB	01H DUP (?)
$SG14819 DB	01H DUP (?)
$SG14823 DB	01H DUP (?)
$SG15850 DB	01H DUP (?)
$SG15852 DB	01H DUP (?)
$SG14829 DB	01H DUP (?)
$SG15855 DB	01H DUP (?)
$SG14832 DB	01H DUP (?)
$SG13808 DB	01H DUP (?)
$SG15860 DB	01H DUP (?)
$SG14836 DB	01H DUP (?)
$SG14839 DB	01H DUP (?)
$SG15870 DB	01H DUP (?)
$SG14848 DB	01H DUP (?)
$SG14850 DB	01H DUP (?)
$SG13828 DB	01H DUP (?)
$SG14853 DB	01H DUP (?)
$SG13831 DB	01H DUP (?)
$SG14856 DB	01H DUP (?)
$SG15892 DB	01H DUP (?)
$SG15907 DB	01H DUP (?)
$SG15914 DB	01H DUP (?)
$SG15924 DB	01H DUP (?)
$SG13886 DB	01H DUP (?)
$SG13891 DB	01H DUP (?)
$SG15942 DB	01H DUP (?)
$SG15945 DB	01H DUP (?)
$SG15954 DB	01H DUP (?)
$SG13921 DB	01H DUP (?)
$SG13926 DB	01H DUP (?)
$SG15980 DB	01H DUP (?)
$SG15996 DB	01H DUP (?)
$SG16018 DB	01H DUP (?)
$SG16037 DB	01H DUP (?)
$SG16040 DB	01H DUP (?)
$SG16042 DB	01H DUP (?)
$SG16044 DB	01H DUP (?)
$SG14030 DB	01H DUP (?)
$SG14043 DB	01H DUP (?)
$SG14048 DB	01H DUP (?)
$SG14052 DB	01H DUP (?)
$SG14054 DB	01H DUP (?)
$SG14068 DB	01H DUP (?)
$SG14072 DB	01H DUP (?)
$SG14075 DB	01H DUP (?)
$SG14078 DB	01H DUP (?)
$SG15126 DB	01H DUP (?)
$SG15133 DB	01H DUP (?)
$SG15152 DB	01H DUP (?)
$SG15156 DB	01H DUP (?)
$SG15159 DB	01H DUP (?)
$SG15162 DB	01H DUP (?)
$SG15166 DB	01H DUP (?)
$SG15195 DB	01H DUP (?)
$SG15254 DB	01H DUP (?)
$SG15261 DB	01H DUP (?)
$SG15311 DB	01H DUP (?)
$SG15315 DB	01H DUP (?)
$SG15325 DB	01H DUP (?)
$SG15330 DB	01H DUP (?)
$SG14314 DB	01H DUP (?)
$SG14319 DB	01H DUP (?)
$SG15348 DB	01H DUP (?)
$SG14324 DB	01H DUP (?)
$SG15353 DB	01H DUP (?)
$SG15355 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG14336 DB	'Trace', 00H
	ORG $+2
$SG14338 DB	'Request OI From File', 00H
	ORG $+3
$SG14340 DB	'Request OI', 00H
	ORG $+1
$SG14342 DB	'Commit OI to File', 00H
	ORG $+2
$SG14344 DB	'Commit OI', 00H
	ORG $+2
$SG14346 DB	'Send File', 00H
	ORG $+2
$SG14348 DB	'Call Operation', 00H
	ORG $+1
$SG14350 DB	'BAD_MESSAGE', 00H
$SG14351 DB	'(kzoeneta) ** Message Type == ', 00H
	ORG $+1
$SG15377 DB	'(kzoeneta) ** Error sending zPACKET_SENDLTH', 00H
$SG15380 DB	'(kzoeneta) ** Error sending data line', 00H
	ORG $+2
$SG14361 DB	'(kzoeneta) ** Bad message = ', 00H
	ORG $+3
$SG14364 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG14366 DB	'(kzoeneta) ** Leaving NetProcessMessage( ) network: %s  '
	DB	'RC: %d', 00H
	ORG $+1
$SG15398 DB	'NetSendCompressed', 00H
	ORG $+2
$SG15399 DB	'[Zeidon]', 00H
	ORG $+3
$SG15403 DB	'NETACT', 00H
	ORG $+1
$SG15406 DB	'(kzoeneta) ** Sending END packet.', 00H
	ORG $+2
$SG15411 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG15414 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG14409 DB	'QualAttrib', 00H
	ORG $+1
$SG14410 DB	'SubQualAttrib', 00H
	ORG $+2
$SG14416 DB	'IS', 00H
	ORG $+1
$SG14417 DB	'Oper', 00H
	ORG $+3
$SG14418 DB	'SourceViewName', 00H
	ORG $+1
$SG15443 DB	'(kzoeneta) ** Received Activate OI message.', 00H
$SG15445 DB	'(kzoeneta) ** Retrieving Activate info.', 00H
$SG14421 DB	'SourceViewID', 00H
	ORG $+3
$SG14422 DB	'SourceEntityName', 00H
	ORG $+3
$SG14423 DB	'EntityName', 00H
	ORG $+1
$SG15448 DB	'(kzoeneta) ** Couldn''t retrieve Act info', 00H
	ORG $+3
$SG14424 DB	'(', 00H
	ORG $+2
$SG14425 DB	'Oper', 00H
	ORG $+3
$SG15450 DB	'(kzoeneta) ** User Name: %s  App Name: %s  Object Def: %'
	DB	's', 00H
	ORG $+2
$SG14427 DB	'SourceViewName', 00H
	ORG $+1
$SG15452 DB	'(kzoeneta) ** Invalid App name = ', 00H
	ORG $+2
$SG14429 DB	'SourceViewID', 00H
	ORG $+3
$SG15455 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG14431 DB	'SourceEntityName', 00H
	ORG $+3
$SG15457 DB	'(kzoeneta) ** Invalid OD name = ', 00H
	ORG $+3
$SG14433 DB	'EntityName', 00H
	ORG $+1
$SG15460 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG14437 DB	'AND', 00H
$SG14438 DB	'Oper', 00H
	ORG $+3
$SG14439 DB	'EntityName', 00H
	ORG $+1
$SG15464 DB	'(kzoeneta) ** Receiving Qual OI.', 00H
	ORG $+3
$SG14440 DB	'AttributeName', 00H
	ORG $+2
_szlApplA DB	'ApplA', 00H
	ORG $+2
$SG14441 DB	'=', 00H
	ORG $+2
_szlAddress DB	'Address', 00H
$SG15466 DB	'KZDBHQUA', 00H
	ORG $+3
$SG14442 DB	'Oper', 00H
	ORG $+3
__szlApplication DB 'Application', 00H
$SG14443 DB	'Value', 00H
	ORG $+2
_szlArgument DB	'Argument', 00H
	ORG $+3
$SG14444 DB	')', 00H
	ORG $+2
_szlDataServer DB 'DataServer', 00H
	ORG $+1
$SG14445 DB	'Oper', 00H
	ORG $+3
_szlDefaultServer DB 'DefaultServer', 00H
	ORG $+2
_szlLOD	DB	'LOD', 00H
_szlNetworkError DB 'Zeidon Network Error', 00H
	ORG $+3
$SG15472 DB	'(kzoeneta) ** Not able to indicate empty OI!', 00H
	ORG $+3
_szlOverrideLOD DB 'OverrideLOD', 00H
_szlOverrideLOD_Server DB 'OverrideLOD_Server', 00H
	ORG $+1
_szlOverrideOper DB 'OverrideOper', 00H
	ORG $+3
$SG15475 DB	'(kzoeneta) ** Not able to ACK request of OI!', 00H
	ORG $+3
_szlOverrideOperServer DB 'OverrideOperServer', 00H
	ORG $+1
_szlFalse DB	'F', 00H
	ORG $+2
_szlTrue DB	'T', 00H
	ORG $+2
$SG15478 DB	'(kzoeneta) ** Sending Activated OI.', 00H
_szlTranDataServer DB 'TranDataServer', 00H
	ORG $+1
_szlTransformation DB 'Transformation', 00H
	ORG $+1
_szlTranUserGroup DB 'TranUserGroup', 00H
	ORG $+2
$SG15481 DB	'(kzoeneta) ** Sending RC packet. RC = ', 00H
	ORG $+1
_szlUserGroup DB 'UserGroup', 00H
	ORG $+2
$SG15484 DB	'(kzoeneta) ** Not able send Return code!', 00H
	ORG $+3
$SG14467 DB	'(kzoeneta) ** Starting activate for network: %s   OD Nam'
	DB	'e: %s', 00H
	ORG $+2
$SG15496 DB	'fnProcessActivateOI_FromFile( ) is deprecated', 00H
	ORG $+2
$SG15497 DB	'(kzoeneta) ** ', 00H
	ORG $+1
$SG15546 DB	'Link buffer doesn''t start with a ''(''', 00H
	ORG $+3
$SG15549 DB	'Link buffer: expecting hex digit.', 00H
	ORG $+2
$SG15551 DB	'Link buffer: expecting '':'' after OI tag.', 00H
	ORG $+3
$SG15553 DB	'Link buffer: Could find OI matching Tag.', 00H
	ORG $+3
$SG15555 DB	'Link buffer: expecting hex digit(2).', 00H
	ORG $+3
$SG15557 DB	'Link buffer: expecting '')/'' after Hier Num.', 00H
$SG15559 DB	'Link buffer: Could find EI matching Hier Count.', 00H
$SG15562 DB	'Link buffer: Link EIs don''t have matching tokens.', 00H
	ORG $+2
$SG13569 DB	'Cannot find network ''%s''', 00H
	ORG $+3
$SG14601 DB	'%x:%lx', 00H
	ORG $+1
$SG14602 DB	'%x:%lx', 00H
	ORG $+1
$SG15627 DB	'(kzoeneta) ** Received Commit OI message.', 00H
	ORG $+2
$SG15629 DB	'(kzoeneta) ** Retrieving Commit packet.', 00H
$SG15632 DB	'(kzoeneta) ** Couldn''t retrieve Commit info', 00H
$SG15635 DB	'(kzoeneta) ** Couldn''t retrieve the object names.', 00H
	ORG $+2
$SG15637 DB	'(kzoeneta) ** Invalid App name = ', 00H
	ORG $+2
$SG15640 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG13597 DB	'zServerDirInit', 00H
	ORG $+1
$SG15646 DB	'(kzoeneta) ** Couldn''t retrieve the link buffer.', 00H
	ORG $+3
$SG13598 DB	'zServerDirClose', 00H
$SG13599 DB	'zServerDirGetAddr', 00H
	ORG $+2
$SG15648 DB	'(kzoeneta) ** Link Buffer = ', 00H
	ORG $+3
$SG15650 DB	'(kzoeneta) ** App Name: %s  Object Def: %s  User Name: %'
	DB	's', 00H
	ORG $+2
$SG13602 DB	'Can''t find Server Directory functions in ''%s''. See tr'
	DB	'ace for more.', 00H
	ORG $+1
$SG13603 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG15652 DB	'(kzoeneta) ** View Count: %s  OD Name Lth: %d', 00H
	ORG $+2
$SG15653 DB	'(kzoeneta) ** OD Names: ', 00H
	ORG $+3
$SG15657 DB	'(kzoeneta) ** Invalid OD name = ', 00H
	ORG $+3
$SG15660 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG15663 DB	'(kzoeneta) ** Receiving OIs to commit.', 00H
	ORG $+1
$SG15668 DB	'(kzoeneta) ** Not able to retrieve OIs for commit!', 00H
	ORG $+1
$SG15675 DB	'(kzoeneta) ** Sending committed OI #', 00H
	ORG $+3
$SG13628 DB	'[%s]', 00H
	ORG $+3
$SG13629 DB	'ApplServer', 00H
	ORG $+1
$SG15680 DB	'(kzoeneta) ** Not able to ACK request of OI!', 00H
	ORG $+3
$SG15683 DB	'(kzoeneta) ** Not able to ACK request of OI!', 00H
	ORG $+3
$SG15686 DB	'(kzoeneta) ** Sending RC packet.  RC = ', 00H
$SG15689 DB	'(kzoeneta) ** Not able send Return code!', 00H
	ORG $+3
$SG15692 DB	'(kzoeneta) ** Not able send Error Idx code!', 00H
$SG14670 DB	'(merge) Tags don''t match! Old entity = ', 00H
$SG14671 DB	'(merge) Tags don''t match! New entity = ', 00H
$SG14672 DB	'(merge) lpOld       = ', 00H
	ORG $+1
$SG14673 DB	'(merge) lpNew->lTag = ', 00H
	ORG $+1
$SG14678 DB	'(merge) Extra New entity! = ', 00H
	ORG $+3
$SG14679 DB	'(merge) lpNew->lTag = ', 00H
	ORG $+1
$SG15704 DB	'fnProcessCommitOI_ToFile( ) is Deprecated', 00H
	ORG $+2
$SG15705 DB	'(kzoeneta) ** ', 00H
	ORG $+1
$SG13661 DB	'(kzoeneta) ** Opening a connection. Current connections '
	DB	'= ', 00H
	ORG $+1
$SG13664 DB	'(kzoeneta) ** Open connection failed, hostaddress=', 00H
	ORG $+1
$SG13686 DB	'Couldn''t find lpNetConn!', 00H
	ORG $+3
$SG15738 DB	'(kzoeneta) ** Received Send File message.', 00H
	ORG $+2
$SG15741 DB	'(kzoeneta) ** Couldn''t retrieve send file info', 00H
	ORG $+1
$SG15744 DB	'(kzoeneta) ** Couldn''t retrieve file name.', 00H
	ORG $+1
$SG15746 DB	'(kzoeneta) ** App Name: %s  File Name: %s', 00H
	ORG $+2
$SG15748 DB	'(kzoeneta) ** Invalid App name = ', 00H
	ORG $+2
$SG15751 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG15755 DB	'(kzoeneta) ** Receiving file.', 00H
	ORG $+2
$SG15762 DB	'(kzoeneta) ** Couldn''t retrieve send file line', 00H
	ORG $+1
$SG15767 DB	'(kzoeneta) ** Error writing line to file.', 00H
	ORG $+2
$SG15770 DB	'(kzoeneta) ** Error writing line to file.', 00H
	ORG $+2
$SG15772 DB	'(kzoeneta) ** Sending # of lines.  Lines = ', 00H
$SG15775 DB	'(kzoeneta) ** Not able send line count!', 00H
$SG13761 DB	'__MSGQ', 00H
	ORG $+1
$SG13764 DB	'KZMSGQOO', 00H
	ORG $+3
$SG13765 DB	'Cannot load Message Object: ', 00H
	ORG $+3
$SG13766 DB	'KZMSGQOO', 00H
	ORG $+3
$SG13767 DB	'System Error', 00H
	ORG $+3
$SG13768 DB	'__MSGQ', 00H
	ORG $+1
$SG13769 DB	'Task', 00H
	ORG $+3
$SG13770 DB	'Id', 00H
	ORG $+1
$SG13771 DB	'Task', 00H
	ORG $+3
$SG13772 DB	'Client', 00H
	ORG $+1
$SG13773 DB	'Task', 00H
	ORG $+3
$SG14803 DB	'(kzoeneta) ** Sending Commit OI packet', 00H
	ORG $+1
$SG14807 DB	'1b', 00H
	ORG $+1
$SG14809 DB	'(kzoeneta) ** Appl Name: %s  User Name: %s ', 00H
$SG14811 DB	'(kzoeneta) ** View Count: %s  OD Name Lth: %d', 00H
	ORG $+2
$SG14812 DB	'(kzoeneta) ** OD Names: ', 00H
	ORG $+3
$SG14813 DB	'(kzoeneta) ** LB Lth: ', 00H
	ORG $+1
$SG13795 DB	'QMsg', 00H
	ORG $+3
$SG14820 DB	'(kzoeneta) ** Sending OIs to commit', 00H
$SG13796 DB	'DBH_Error', 00H
	ORG $+2
$SG13797 DB	'QMsg', 00H
	ORG $+3
$SG13798 DB	'QMsg', 00H
	ORG $+3
$SG13799 DB	'QMsg', 00H
	ORG $+3
$SG14824 DB	'(kzoeneta) ** Error sending OI for Commit!', 00H
	ORG $+1
$SG13801 DB	'DBH_Error', 00H
	ORG $+2
$SG13802 DB	'DBH_Error', 00H
	ORG $+2
$SG15851 DB	'(kzoeneta) ** Received Transformation message.', 00H
	ORG $+1
$SG13803 DB	'DBH_Error', 00H
	ORG $+2
$SG15853 DB	'(kzoeneta) ** Retrieving the Argument OI.', 00H
	ORG $+2
$SG14830 DB	'(kzoeneta) ** Waiting for returned OI', 00H
	ORG $+2
$SG15856 DB	'(kzoeneta) ** Couldn''t retrieve app name.', 00H
	ORG $+2
$SG14833 DB	'(kzoeneta) ** Error receiving OI ACK!', 00H
	ORG $+2
$SG13809 DB	'(kzoeneta) ** Unable to send message object!', 00H
	ORG $+3
$SG15859 DB	'kztranwo', 00H
	ORG $+3
$SG15861 DB	'(kzoeneta) ** Not able to retrieve Arg List!', 00H
	ORG $+3
$SG14837 DB	'(kzoeneta) ** Received RC - error in Commit', 00H
$SG15862 DB	'T', 00H
	ORG $+2
$SG15863 DB	'OperationType', 00H
	ORG $+2
$SG15864 DB	'Operation', 00H
	ORG $+2
$SG14840 DB	'(kzoeneta) ** Error receiving OI ACK!', 00H
	ORG $+2
$SG15866 DB	'ObjectName', 00H
	ORG $+1
$SG15867 DB	'Operation', 00H
	ORG $+2
$SG13821 DB	'KZTRACEO', 00H
	ORG $+3
$SG15871 DB	'(kzoeneta) ** Error sending zPACKET_END', 00H
$SG13824 DB	'DateTime', 00H
	ORG $+3
$SG15873 DB	'l', 00H
	ORG $+2
$SG14849 DB	'(kzoeneta) ** Error receiving OI after commit!', 00H
	ORG $+1
$SG13825 DB	'TraceEnd', 00H
	ORG $+3
$SG15874 DB	'DataType', 00H
	ORG $+3
$SG13826 DB	'Trace', 00H
	ORG $+2
$SG14851 DB	'(kzoeneta) ** Received bytes but no ACK!', 00H
	ORG $+3
$SG15876 DB	'Value', 00H
	ORG $+2
$SG13829 DB	'(kzoeneta) ** Unable to send Trace Object Flag', 00H
	ORG $+1
$SG15878 DB	'V', 00H
	ORG $+2
$SG14854 DB	'(kzoeneta) ** Error receiving OI ACK!', 00H
	ORG $+2
$SG15879 DB	'DataType', 00H
	ORG $+3
$SG15880 DB	'ApplicationName', 00H
$SG13832 DB	'(kzoeneta) ** Unable to send Trace object!', 00H
	ORG $+1
$SG14857 DB	'(kzoeneta) ** No return code for Commit!', 00H
	ORG $+3
$SG15882 DB	'Y', 00H
	ORG $+2
$SG15883 DB	'SubtaskView', 00H
$SG14859 DB	'(kzoeneta) ** RC from commit = ', 00H
$SG15885 DB	'N', 00H
	ORG $+2
$SG15886 DB	'SendArgument', 00H
	ORG $+3
$SG15889 DB	'ObjectName', 00H
	ORG $+1
$SG15893 DB	'(kzoeneta) ** Not able to retrieve Arg List!', 00H
	ORG $+3
$SG15894 DB	'UserName', 00H
	ORG $+3
$SG15895 DB	'Operation', 00H
	ORG $+2
$SG15896 DB	'Password', 00H
	ORG $+3
$SG15897 DB	'Operation', 00H
	ORG $+2
$SG15898 DB	'OperName', 00H
	ORG $+3
$SG15899 DB	'Operation', 00H
	ORG $+2
$SG15902 DB	'DLL_Name', 00H
	ORG $+3
$SG15903 DB	'Operation', 00H
	ORG $+2
$SG15908 DB	'(kzoeneta) ** Error sending zPACKET_ERROR', 00H
	ORG $+2
$SG15909 DB	'(kzoeneta) ** Global operation library = ', 00H
	ORG $+2
$SG15910 DB	'Can''t find global oper lib.', 00H
$SG13862 DB	'DBH_Error', 00H
	ORG $+2
$SG15911 DB	'_zCall_%s', 00H
	ORG $+2
$SG13863 DB	'DBH_Error', 00H
	ORG $+2
$SG13864 DB	'DBH_Error', 00H
	ORG $+2
$SG15915 DB	'(kzoeneta) ** Error sending zPACKET_ERROR', 00H
	ORG $+2
$SG15916 DB	'(kzoeneta) ** Global operation = ', 00H
	ORG $+2
$SG15917 DB	'Can''t find _zCall... func.', 00H
	ORG $+1
$SG15919 DB	'V', 00H
	ORG $+2
$SG15920 DB	'DataType', 00H
	ORG $+3
$SG15922 DB	'Y', 00H
	ORG $+2
$SG15923 DB	'ReturnArgument', 00H
	ORG $+1
$SG15925 DB	'Value', 00H
	ORG $+2
$SG15926 DB	'Y', 00H
	ORG $+2
$SG15927 DB	'ReturnArgument', 00H
	ORG $+1
$SG15931 DB	'ObjectName', 00H
	ORG $+1
$SG15933 DB	'E', 00H
	ORG $+2
$SG15934 DB	'ViewReturned', 00H
	ORG $+3
$SG15935 DB	'Y', 00H
	ORG $+2
$SG13887 DB	'(kzoeneta) ** Couldn''t retrieve Message flag.', 00H
	ORG $+2
$SG15936 DB	'ViewReturned', 00H
	ORG $+3
$SG15937 DB	'ReturnValue', 00H
$SG15938 DB	'Operation', 00H
	ORG $+2
$SG13890 DB	'kzmsgqoo', 00H
	ORG $+3
$SG15940 DB	'(kzoeneta) ** Sending RC packet.  RC = ', 00H
$SG13892 DB	'(kzoeneta) ** Couldn''t retrieve Message object.', 00H
$SG13894 DB	'DBH_Error', 00H
	ORG $+2
$SG15943 DB	'(kzoeneta) ** Not able send Return code!', 00H
	ORG $+3
$SG13896 DB	'DBH_Error', 00H
	ORG $+2
$SG13897 DB	'DBH_Error', 00H
	ORG $+2
$SG15946 DB	'(kzoeneta) ** Not able send vArgs back to client!', 00H
	ORG $+2
$SG13898 DB	'DBH_Error', 00H
	ORG $+2
$SG13899 DB	'DBH_Error', 00H
	ORG $+2
$SG15948 DB	'V', 00H
	ORG $+2
$SG13900 DB	'DBH_Error', 00H
	ORG $+2
$SG15949 DB	'DataType', 00H
	ORG $+3
$SG15950 DB	'Y', 00H
	ORG $+2
$SG13902 DB	'DBH_Error', 00H
	ORG $+2
$SG15951 DB	'ViewReturned', 00H
	ORG $+3
$SG13903 DB	'DBH_Error', 00H
	ORG $+2
$SG15955 DB	'(kzoeneta) ** Not able send view argument back to client'
	DB	'!', 00H
	ORG $+2
$SG13922 DB	'(kzoeneta) ** Couldn''t retrieve Trace flag.', 00H
$SG13925 DB	'KZTRACEO', 00H
	ORG $+3
$SG13927 DB	'(kzoeneta) ** Couldn''t retrieve Trace object.', 00H
	ORG $+2
$SG13928 DB	'Trace', 00H
	ORG $+2
$SG13929 DB	'Line', 00H
	ORG $+3
$SG13931 DB	'TraceStart', 00H
	ORG $+1
$SG13932 DB	'Trace', 00H
	ORG $+2
$SG15981 DB	'(kzoeneta) ** Couldn''t retrieve Trace Switch Message', 00H
	ORG $+3
$SG13933 DB	'(kzoeneta) ** Start Server Trace: ', 00H
	ORG $+1
$SG13934 DB	'Line', 00H
	ORG $+3
$SG15983 DB	'(kzoeneta) ** Received Trace Switch message.', 00H
	ORG $+3
$SG13935 DB	'Line', 00H
	ORG $+3
$SG13937 DB	'(kzoeneta) ** Line: ', 00H
	ORG $+3
$SG13938 DB	'Trace', 00H
	ORG $+2
$SG13939 DB	'Line', 00H
	ORG $+3
$SG13940 DB	'TraceEnd', 00H
	ORG $+3
$SG13941 DB	'Trace', 00H
	ORG $+2
$SG13942 DB	'(kzoeneta) ** End Server Trace: ', 00H
	ORG $+3
$SG15997 DB	'(kzoeneta) ** Couldn''t retrieve Timestamp Message', 00H
	ORG $+2
$SG15999 DB	'(kzoeneta) ** Received Timestamp message.', 00H
	ORG $+2
$SG16019 DB	'(kzoeneta) ** Trying to startup networks', 00H
	ORG $+3
$SG16020 DB	'Network%d', 00H
	ORG $+2
$SG16021 DB	'[Network]', 00H
	ORG $+2
$SG16023 DB	'[%s]', 00H
	ORG $+3
$SG16024 DB	'Startup', 00H
$SG16026 DB	'(kzoeneta) ** Startup = ', 00H
	ORG $+3
$SG13980 DB	'%2.2hd', 00H
	ORG $+1
$SG16029 DB	'ExecName', 00H
	ORG $+3
$SG13981 DB	'%2.2hd', 00H
	ORG $+1
$SG13982 DB	'%2.2hd', 00H
	ORG $+1
$SG16033 DB	'TraceLevel', 00H
	ORG $+1
$SG16038 DB	'(kzoeneta) *MainTask* Starting Listen', 00H
	ORG $+2
$SG16041 DB	'(kzoeneta) ** Error calling NetListen', 00H
	ORG $+2
$SG16043 DB	'(kzoeneta) ** Error calling NetStartup!! ', 00H
	ORG $+2
$SG16045 DB	'(kzoeneta) ** Startup networks successful', 00H
	ORG $+2
$SG15033 DB	'kztranwo', 00H
	ORG $+3
$SG15035 DB	'Operation', 00H
	ORG $+2
$SG15036 DB	'ApplicationName', 00H
$SG15037 DB	'Operation', 00H
	ORG $+2
$SG15038 DB	'OperName', 00H
	ORG $+3
$SG15039 DB	'Operation', 00H
	ORG $+2
$SG15042 DB	'T', 00H
	ORG $+2
$SG15043 DB	'OperationType', 00H
	ORG $+2
$SG15044 DB	'Operation', 00H
	ORG $+2
$SG15045 DB	'ObjectName', 00H
	ORG $+1
$SG15046 DB	'Operation', 00H
	ORG $+2
$SG15047 DB	'G', 00H
	ORG $+2
$SG15048 DB	'OperationType', 00H
	ORG $+2
$SG15049 DB	'Operation', 00H
	ORG $+2
$SG15051 DB	'DLL_Name', 00H
	ORG $+3
$SG15052 DB	'Operation', 00H
	ORG $+2
$SG15053 DB	'ReturnType', 00H
	ORG $+1
$SG15054 DB	'Operation', 00H
	ORG $+2
$SG14031 DB	'(kzoeneta) ** Sending RequestOI packet', 00H
	ORG $+1
$SG15057 DB	'Y', 00H
	ORG $+2
$SG15058 DB	'ReturnArgument', 00H
	ORG $+1
$SG15059 DB	'PointerValue', 00H
	ORG $+3
$SG14035 DB	'1b', 00H
	ORG $+1
$SG15061 DB	'Y', 00H
	ORG $+2
$SG15062 DB	'SendArgument', 00H
	ORG $+3
$SG15063 DB	'DataType', 00H
	ORG $+3
$SG15066 DB	'Value', 00H
	ORG $+2
$SG14044 DB	'(kzoeneta) ** Sending qualification OI', 00H
	ORG $+1
$SG14061 DB	'Application not defined on Server', 00H
	ORG $+2
$SG14039 DB	'(kzoeneta) ** Sending Activate Packet ... ApplName: %s  '
	DB	'Object Def: %s  User Name: %s', 00H
	ORG $+2
$SG15071 DB	'Value', 00H
	ORG $+2
$SG15072 DB	'Value', 00H
	ORG $+2
$SG14049 DB	'(kzoeneta) ** Error receiving OI ACK!', 00H
	ORG $+2
$SG15077 DB	'Value', 00H
	ORG $+2
$SG14053 DB	'(kzoeneta) ** Received Act ACK - proceeding with Act', 00H
	ORG $+3
$SG15078 DB	'Value', 00H
	ORG $+2
$SG14055 DB	'(kzoeneta) ** Receiving activated OI.', 00H
	ORG $+2
$SG14058 DB	'(kzoeneta) ** Network error #', 00H
	ORG $+2
$SG15083 DB	'Value', 00H
	ORG $+2
$SG15084 DB	'Value', 00H
	ORG $+2
$SG14064 DB	'*Out Of Memory*', 00H
$SG15089 DB	'Value', 00H
	ORG $+2
$SG14065 DB	'Server Transaction Crash ', 00H
	ORG $+2
$SG15090 DB	'Value', 00H
	ORG $+2
$SG14069 DB	'(kzoeneta) ** Received RC - error in Commit', 00H
$SG14073 DB	'(kzoeneta) ** Received unknown Packet!', 00H
	ORG $+1
$SG15100 DB	'N', 00H
	ORG $+2
$SG14076 DB	'(kzoeneta) ** Error receiving OI ACK!', 00H
	ORG $+2
$SG15101 DB	'SendArgument', 00H
	ORG $+3
$SG15103 DB	'ObjectName', 00H
	ORG $+1
$SG14079 DB	'(kzoeneta) ** No return code for Commit!', 00H
	ORG $+3
$SG15104 DB	'Y', 00H
	ORG $+2
$SG15105 DB	'SendArgument', 00H
	ORG $+3
$SG14081 DB	'(kzoeneta) ** RC from activate = ', 00H
	ORG $+2
$SG15108 DB	'N', 00H
	ORG $+2
$SG15109 DB	'SendArgument', 00H
	ORG $+3
$SG15112 DB	'Y', 00H
	ORG $+2
$SG15113 DB	'SubtaskView', 00H
$SG15114 DB	'ApplicationName', 00H
$SG15115 DB	'N', 00H
	ORG $+2
$SG15116 DB	'SendArgument', 00H
	ORG $+3
$SG15119 DB	'ApplicationName', 00H
$SG15120 DB	'PointerValue', 00H
	ORG $+3
$SG15121 DB	'Y', 00H
	ORG $+2
$SG15122 DB	'SendArgument', 00H
	ORG $+3
$SG15123 DB	'ObjectName', 00H
	ORG $+1
$SG15127 DB	'(kzoeneta) ** Sending Transformation Call', 00H
	ORG $+2
$SG15134 DB	'(kzoeneta) ** Error sending Arg OI!', 00H
$SG15135 DB	'V', 00H
	ORG $+2
$SG15136 DB	'DataType', 00H
	ORG $+3
$SG15137 DB	'V', 00H
	ORG $+2
$SG15138 DB	'DataType', 00H
	ORG $+3
$SG15140 DB	'Y', 00H
	ORG $+2
$SG15141 DB	'SubtaskView', 00H
$SG15143 DB	'N', 00H
	ORG $+2
$SG15144 DB	'SendArgument', 00H
	ORG $+3
$SG15147 DB	'Y', 00H
	ORG $+2
$SG15148 DB	'ReturnArgument', 00H
	ORG $+1
$SG15149 DB	'PointerValue', 00H
	ORG $+3
$SG15150 DB	'PointerValue', 00H
	ORG $+3
$SG15153 DB	'(kzoeneta) ** Error sending argument OI!', 00H
	ORG $+3
$SG15157 DB	'(kzoeneta) ** Waiting for ACK', 00H
	ORG $+2
$SG15160 DB	'(kzoeneta) ** Error receiving OI ACK!', 00H
	ORG $+2
$SG15163 DB	'(kzoeneta) ** No return code for NetCallOperation!', 00H
	ORG $+1
$SG15165 DB	'kztranwo', 00H
	ORG $+3
$SG15167 DB	'(kzoeneta) ** Not able to retrieve Arg List!', 00H
	ORG $+3
$SG15169 DB	'ReturnValue', 00H
$SG15170 DB	'Operation', 00H
	ORG $+2
$SG15172 DB	'ReturnValue', 00H
$SG15173 DB	'Operation', 00H
	ORG $+2
$SG14150 DB	'DefaultNetwork', 00H
	ORG $+1
$SG15175 DB	'ReturnValue', 00H
$SG14151 DB	'[Zeidon]', 00H
	ORG $+3
$SG15176 DB	'Operation', 00H
	ORG $+2
$SG14153 DB	'No default network for NetStartup', 00H
	ORG $+2
$SG15178 DB	'ReturnValue', 00H
$SG14154 DB	'DefaultNetworkExec', 00H
	ORG $+1
$SG15179 DB	'Operation', 00H
	ORG $+2
$SG14155 DB	'[Zeidon]', 00H
	ORG $+3
$SG15181 DB	'V', 00H
	ORG $+2
$SG15182 DB	'DataType', 00H
	ORG $+3
$SG15184 DB	'Y', 00H
	ORG $+2
$SG15185 DB	'SubtaskView', 00H
$SG14161 DB	'Can''t find library ''%s''', 00H
$SG15186 DB	'PointerValue', 00H
	ORG $+3
$SG14162 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG15187 DB	'ObjectName', 00H
	ORG $+1
$SG14163 DB	'zNetStart', 00H
	ORG $+2
$SG15189 DB	'E', 00H
	ORG $+2
$SG14165 DB	'Can''t find operation zNetStart in library ''%s''', 00H
	ORG $+1
$SG15190 DB	'ViewReturned', 00H
	ORG $+3
$SG14166 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14167 DB	'zNetClose', 00H
	ORG $+2
$SG15192 DB	'Y', 00H
	ORG $+2
$SG15193 DB	'ViewReturned', 00H
	ORG $+3
$SG14169 DB	'Can''t find operation zNetClose in library ''%s''', 00H
	ORG $+1
$SG14170 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14171 DB	'zNetListen', 00H
	ORG $+1
$SG15196 DB	'(kzoeneta) ** Not able to retrieve new view!', 00H
	ORG $+3
$SG14173 DB	'Can''t find operation zNetListen in library ''%s''', 00H
$SG15198 DB	'(kzoeneta) ** RC from transaction = ', 00H
	ORG $+3
$SG14174 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14175 DB	'zNetStopListen', 00H
	ORG $+1
$SG14177 DB	'Can''t find operation zNetStopListen in library ''%s''', 00H
$SG14178 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14179 DB	'zNetOpenConnection', 00H
	ORG $+1
$SG14181 DB	'Can''t find operation zNetOpenConnection in library ''%s'
	DB	'''', 00H
$SG14182 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14183 DB	'zNetCloseConnection', 00H
$SG14185 DB	'Can''t find operation zNetCloseConnection in library ''%'
	DB	's''', 00H
	ORG $+3
$SG14186 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14187 DB	'zNetSend', 00H
	ORG $+3
$SG14189 DB	'Can''t find operation zNetSend in library ''%s''', 00H
	ORG $+2
$SG14190 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14191 DB	'zNetReceive', 00H
$SG14193 DB	'Cannot find operation zNetReceive in library ''%s''', 00H
	ORG $+2
$SG14194 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14195 DB	'zNetGetHostAddress', 00H
	ORG $+1
$SG14197 DB	'Cannot find operation zNetGetLocalHostAddress in library'
	DB	' ''%s''', 00H
	ORG $+2
$SG14198 DB	'Zeidon Network Error', 00H
	ORG $+3
$SG14199 DB	'(kzoeneta) ** Starting network ', 00H
$SG14202 DB	'Out of memory for network', 00H
	ORG $+2
$SG14203 DB	'[%s]', 00H
	ORG $+3
$SG14204 DB	'TraceLevel', 00H
	ORG $+1
$SG15229 DB	'(kzoeneta) ** Setting Net trace level to ', 00H
	ORG $+2
$SG14205 DB	'ServerCoreTraceLevel', 00H
	ORG $+3
$SG14206 DB	'ServerNetTraceLevel', 00H
$SG14207 DB	'ServerDBHTraceLevel', 00H
$SG14209 DB	'(kzoeneta) ** Local host address = ', 00H
$SG14210 DB	'ServerDirApp', 00H
	ORG $+3
$SG14212 DB	'zSimpDir', 00H
	ORG $+3
$SG15250 DB	'*default*', 00H
	ORG $+2
$SG15251 DB	'(kzoeneta) ** Network status: no network running for ', 00H
	ORG $+2
$SG15253 DB	'(kzoeneta) ** Network status for network: ', 00H
	ORG $+1
$SG15255 DB	'(kzoeneta)         ** Network running', 00H
	ORG $+2
$SG15258 DB	'(kzoeneta)         ** Connections running: ', 00H
$SG15262 DB	'(kzoeneta)         ** Network listening', 00H
$SG14241 DB	'(kzoeneta) ** NetClose for Network: ', 00H
	ORG $+3
$SG14247 DB	'(kzoeneta) ** Closing network ', 00H
	ORG $+1
$SG14266 DB	'(kzoeneta) ** Starting NetListen for network ', 00H
	ORG $+2
$SG14268 DB	'(kzoeneta) ** Network already listening!', 00H
	ORG $+3
$SG14270 DB	'(kzoeneta) ** Starting listen for network ', 00H
	ORG $+1
$SG15301 DB	'(kzoeneta) ** Read Data error = ', 00H
	ORG $+3
$SG15303 DB	'Invalid Entity name = %s', 00H
	ORG $+3
$SG15305 DB	'Invalid Entity level = %s', 00H
	ORG $+2
$SG14282 DB	'(kzoeneta) ** Stopping listen for network ', 00H
	ORG $+1
$SG15307 DB	'Maximum number of entities in stream exceeded', 00H
	ORG $+2
$SG14284 DB	'(kzoeneta) ** Network not listening!', 00H
	ORG $+3
$SG15309 DB	'Invalid Attr name for Entity = %s', 00H
	ORG $+2
$SG15312 DB	'(kzoeneta) ** Error receiving SENDLTH!', 00H
	ORG $+1
$SG15316 DB	'(kzoeneta) ** Received OI END message', 00H
	ORG $+2
$SG15318 DB	'Error transmitting OI -- some lines lost.', 00H
	ORG $+2
$SG15320 DB	'(kzoeneta) ** Received Packet ERROR code = ', 00H
$SG15326 DB	'(kzoeneta) ** Invalid packet type--expecting SENDLTH!', 00H
	ORG $+2
$SG15328 DB	'(kzoeneta) ** Received SENDLTH packet. Lth = ', 00H
	ORG $+2
$SG15331 DB	'(kzoeneta) ** Error receiving data', 00H
	ORG $+1
$SG14309 DB	'(kzoeneta) ** Inside NetProcessMessage( ) network: ', 00H
$SG14312 DB	'(kzoeneta) ** Received message for network ', 00H
$SG14311 DB	'(kzoeneta) ** Cannot find network NetProcessMessage( ) n'
	DB	'etwork: ', 00H
	ORG $+3
$SG14315 DB	'(kzoeneta) ** Error receiving message!', 00H
	ORG $+1
$SG14320 DB	'(kzoeneta) ** Error receiving Trace Switches', 00H
	ORG $+3
$SG15349 DB	'(kzoeneta) ** Initiating receive of OI', 00H
	ORG $+1
$SG14325 DB	'(kzoeneta) ** Error ... removing connection from network'
	DB	'!', 00H
	ORG $+2
$SG14326 DB	'KZTRACEO', 00H
	ORG $+3
$SG14328 DB	'KZTRACEO', 00H
	ORG $+3
$SG15354 DB	'(kzoeneta) ** Receive OI OK.  Sending ack.', 00H
	ORG $+1
$SG14331 DB	'Trace', 00H
	ORG $+2
$SG15356 DB	'(kzoeneta) ** Error receiving OI.  Sending error packet.'
	DB	00H
	ORG $+3
$SG14332 DB	'nLine', 00H
	ORG $+2
$SG14333 DB	'Trace', 00H
	ORG $+2
$SG14334 DB	'DateTime', 00H
	ORG $+3
$SG14335 DB	'TraceStart', 00H
_DATA	ENDS
PUBLIC	_NetStartup@12
PUBLIC	_NetClose@8
PUBLIC	_NetListen@8
PUBLIC	_NetStopListen@8
PUBLIC	_NetGetLocalHostAddress@12
PUBLIC	_NetActivateOI@28
PUBLIC	_NetCommitOI@28
PUBLIC	_NetActivateOI_FromFile@28
PUBLIC	_NetCommitOI_ToFile@20
PUBLIC	_NetSendFile@28
PUBLIC	_NetCallOperation
PUBLIC	_NetProcessMessage@12
PUBLIC	_NetGetTraceLevel@8
PUBLIC	_NetSetTraceLevel@12
PUBLIC	_NetStatus@8
PUBLIC	_SfStartNetworks@8
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnProcessActivateOI@12
PUBLIC	_fnProcessCommitOI@12
PUBLIC	_fnProcessActivateOI_FromFile@8
PUBLIC	_fnProcessCommitOI_ToFile@8
PUBLIC	_fnProcessOperation@12
PUBLIC	_fnProcessSendFile@12
PUBLIC	_fnProcessTraceSwitches@12
PUBLIC	_fnProcessTimestamp@12
PUBLIC	_fnSendOI@16
PUBLIC	_fnSendOI_Data@20
PUBLIC	_fnReceiveOI@24
PUBLIC	_fnReadDataFromNet@20
PUBLIC	_TestMsgObjDef
PUBLIC	_fnSendHeaderPacket@16
PUBLIC	_fnFindNetwork@12
PUBLIC	_fnRetrieveAppName@8
PUBLIC	_LoadNetworkOperations
PUBLIC	_fnGetApplAddress@24
PUBLIC	_fnAddConnectionToNetwork@32
PUBLIC	_fnRemoveConnectionFromNetwork@12
PUBLIC	_fnFlushBuffer@8
PUBLIC	_fnSendDataPacket@16
PUBLIC	_fnReceiveDataPacket@16
PUBLIC	_fnCreateMsgObj@4
PUBLIC	_fnSendMessageObject@12
PUBLIC	_fnSendTraceObj@12
PUBLIC	_fnSendMsgAndTraceObj@12
PUBLIC	_fnRetrieveMessageObject@12
PUBLIC	_fnRetrieveTraceObj@12
PUBLIC	_fnRetrieveMsgAndTraceObj@12
PUBLIC	_fnEmptyOI@4
PUBLIC	_fnSendTraceSwitches@12
PUBLIC	_fnSendTimestamp@12
PUBLIC	_fnNetActivateOI@32
PUBLIC	_fnConvertIS_Clause@4
PUBLIC	_fnFindEntityInstanceByHierCount@8
PUBLIC	_fnSetLinkBuffer@20
PUBLIC	_fnMergeViews@8
PUBLIC	_fnRelinkOIs@16
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__strtoul:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_TraceBuffer@12:PROC
EXTRN	_ActivateEmptyObjectInstance@16:PROC
EXTRN	_ActivateObjectInstance@20:PROC
EXTRN	_ActivateOI_FromOI_ForTask@16:PROC
EXTRN	_CommitMultipleOIs@16:PROC
EXTRN	_DropObjectInstance@4:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CheckExistenceOfEntity@8:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_DeleteEntity@12:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_SetCursorNextEntityByString@20:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_GetIntegerFromAttribute@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_GetDecimalFromAttribute@16:PROC
EXTRN	_SetAttributeFromDecimal@52:PROC
EXTRN	_GetBlobFromAttribute@20:PROC
EXTRN	_SetAttributeFromBlob@20:PROC
EXTRN	_SetAttributeFromAttribute@24:PROC
EXTRN	_CompareAttributeToString@16:PROC
EXTRN	_SetMatchingAttributesByName@20:PROC
EXTRN	_SetAttributeFromVariable@32:PROC
EXTRN	_CountEntitiesForView@8:PROC
EXTRN	_MessagePresent@12:PROC
EXTRN	_SysAllocMemory@20:PROC
EXTRN	_SysAppendcDirSep@4:PROC
EXTRN	_SysCloseFile@12:PROC
EXTRN	_SysFreeLibrary@8:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysGetDateTime@4:PROC
EXTRN	_SysGetLocalDirectory@4:PROC
EXTRN	_SysGetProc@8:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysGetTaskFromView@4:PROC
EXTRN	_SysGetUserID@12:PROC
EXTRN	_SysLoadLibrary@8:PROC
EXTRN	_SysLoadLibraryWithErrFlag@12:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysOpenFile@12:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysWriteFile@16:PROC
EXTRN	_SysWriteLine@12:PROC
EXTRN	_GetAddrForAttribute@16:PROC
EXTRN	_SfActivateSysEmptyOI@16:PROC
EXTRN	_SfWriteOI_ToStream@20:PROC
EXTRN	_SfActivateOI_FromStream@24:PROC
EXTRN	_ActivateViewObject@12:PROC
EXTRN	_SfCreateSubtask@12:PROC
EXTRN	_SfGetApplicationForSubtask@8:PROC
EXTRN	_SfLockView@4:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnGetAttribFlagsPtr@8:PROC
EXTRN	_fnGetAttrAddrFromEntityInstance:PROC
EXTRN	_fnStoreValueInEntityInstance:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnEntityInstanceIsDead@4:PROC
EXTRN	_fnEstablishViewForInstance:PROC
EXTRN	_fnReclaimHiddenInstances@4:PROC
EXTRN	_fnRelinkInstanceToInstance:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnCleanupInstance:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnDropSubtask:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidView:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__isalnum:PROC
EXTRN	__imp__toupper:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	__setjmp3:PROC
EXTRN	_memset:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_cDirSep:BYTE
EXTRN	_szl__MSGQ:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpLastViewEntity$1 = -56				; size = 4
_lpViewEntity$2 = -52					; size = 4
tv188 = -48						; size = 4
tv162 = -44						; size = 4
_plpViewCsr$ = -40					; size = 4
_hBuffer$ = -36						; size = 4
_plpViewOI$ = -32					; size = 4
_pchBuffer$ = -28					; size = 4
_lpLastEI$ = -24					; size = 4
_lHierCount$ = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_pch$ = -12						; size = 4
_nOI_Idx$3 = -8						; size = 2
_k$ = -4						; size = 2
_lpTask$ = 8						; size = 4
_lpViewCluster$ = 12					; size = 4
_nViewCount$ = 16					; size = 2
_pchLinkBuffer$ = 20					; size = 4
_fnRelinkOIs@16 PROC

; 5756 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 5757 :    zLONG             lHierCount;
; 5758 :    zLONG             hBuffer = 0;

	mov	DWORD PTR _hBuffer$[ebp], 0

; 5759 :    LPENTITYINSTANCE  lpEntityInstance;
; 5760 :    LPENTITYINSTANCE  lpLastEI;
; 5761 :    LPVIEWCSR         *plpViewCsr;
; 5762 :    LPVIEWOI          *plpViewOI;
; 5763 :    zPCHAR            pchBuffer;
; 5764 :    zPCHAR            pch;
; 5765 :    zSHORT            k;
; 5766 : 
; 5767 :    // First allocate enough space to save some pointers.
; 5768 :    hBuffer = SysAllocMemory( &pchBuffer, nViewCount * sizeof( LPVIEWOI ) * 2,

	push	0
	push	32768					; 00008000H
	push	0
	movsx	eax, WORD PTR _nViewCount$[ebp]
	shl	eax, 2
	shl	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hBuffer$[ebp], eax

; 5769 :                              0, zCOREMEM_ALLOC, 0 );
; 5770 :    if ( hBuffer == 0 )

	cmp	DWORD PTR _hBuffer$[ebp], 0
	jne	SHORT $LN10@fnRelinkOI

; 5771 :       return;

	jmp	$LN1@fnRelinkOI
$LN10@fnRelinkOI:

; 5772 : 
; 5773 :    zmemset( pchBuffer, 0, nViewCount * sizeof( LPVIEWOI ) * 2 );

	movsx	edx, WORD PTR _nViewCount$[ebp]
	shl	edx, 2
	shl	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5774 : 
; 5775 :    plpViewCsr = (LPVIEWCSR *) pchBuffer;

	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _plpViewCsr$[ebp], ecx

; 5776 :    plpViewOI  = (LPVIEWOI *) (pchBuffer + sizeof( LPVIEWCSR ) * nViewCount);

	movsx	edx, WORD PTR _nViewCount$[ebp]
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _plpViewOI$[ebp], ecx

; 5777 : 
; 5778 :    // First thing is to set the hier # for all the entity instances.
; 5779 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@fnRelinkOI
$LN2@fnRelinkOI:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@fnRelinkOI:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN3@fnRelinkOI

; 5780 :    {
; 5781 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN11@fnRelinkOI

; 5782 :          continue;

	jmp	SHORT $LN2@fnRelinkOI
$LN11@fnRelinkOI:

; 5783 : 
; 5784 :       // Get ViewCsrs/ViewOIs for all the views.
; 5785 :       plpViewCsr[ k ] = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _plpViewCsr$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 5786 :       plpViewOI[ k ]  = zGETPTR( plpViewCsr[ k ]->hViewOI );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _plpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _plpViewOI$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 5787 : 
; 5788 :       lHierCount = 0;

	mov	DWORD PTR _lHierCount$[ebp], 0

; 5789 :       for ( lpEntityInstance = zGETPTR( plpViewOI[ k ]->hRootEntityInstance );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _plpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN7@fnRelinkOI
$LN5@fnRelinkOI:

; 5791 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnRelinkOI:

; 5790 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN6@fnRelinkOI

; 5792 :       {
; 5793 :          if ( fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN12@fnRelinkOI

; 5794 :             continue;

	jmp	SHORT $LN5@fnRelinkOI
$LN12@fnRelinkOI:

; 5795 : 
; 5796 :          lpEntityInstance->lHierCount = lHierCount++;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lHierCount$[ebp]
	mov	DWORD PTR [edx+54], eax
	mov	ecx, DWORD PTR _lHierCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lHierCount$[ebp], ecx

; 5797 :       }

	jmp	SHORT $LN5@fnRelinkOI
$LN6@fnRelinkOI:

; 5798 :    }

	jmp	$LN2@fnRelinkOI
$LN3@fnRelinkOI:

; 5799 : 
; 5800 :    // Now go through the link buffer.  The first char had better be a '('.
; 5801 :    // (OI-idx:EI-hier#/OI-idx:EI-her#/...)(...)...
; 5802 :    pch = pchLinkBuffer;

	mov	edx, DWORD PTR _pchLinkBuffer$[ebp]
	mov	DWORD PTR _pch$[ebp], edx

; 5803 :    if ( *pch++ != '(' )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv162[ebp], ecx
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
	cmp	DWORD PTR tv162[ebp], 40		; 00000028H
	je	SHORT $LN13@fnRelinkOI

; 5804 :    {
; 5805 :       fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15546
	push	OFFSET _szlNetworkError
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 5806 :                        "Link buffer doesn't start with a '('", 1 );
; 5807 :       goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN13@fnRelinkOI:

; 5808 :    }
; 5809 : 
; 5810 :    lpLastEI = 0;

	mov	DWORD PTR _lpLastEI$[ebp], 0
$LN8@fnRelinkOI:

; 5811 : 
; 5812 :    // Loop through the link buffer and try to link up EIs.
; 5813 :    while ( *pch )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$EndOfFunction$25

; 5814 :    {
; 5815 :       zSHORT nOI_Idx;
; 5816 : 
; 5817 :       // Skip opening paren if it's there -- they're harmless.
; 5818 :       if ( *pch == '(' )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 40					; 00000028H
	jne	SHORT $LN14@fnRelinkOI

; 5819 :          pch++;

	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$LN14@fnRelinkOI:

; 5820 : 
; 5821 :       if ( !zisalnum( *pch ) )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN15@fnRelinkOI

; 5822 :       {
; 5823 :          fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15549
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 5824 :                           "Link buffer: expecting hex digit.", 1 );
; 5825 :          goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN15@fnRelinkOI:

; 5826 :       }
; 5827 : 
; 5828 :       // Get the OI idx;  pch then contains the char that stopped the scan.
; 5829 :       nOI_Idx = (zSHORT) zstrtol( pch, &pch, 16 );

	push	16					; 00000010H
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nOI_Idx$3[ebp], ax

; 5830 : 
; 5831 :       // The next char had better be a ':'!
; 5832 :       if ( *pch++ != ':' )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
	cmp	DWORD PTR tv188[ebp], 58		; 0000003aH
	je	SHORT $LN16@fnRelinkOI

; 5833 :       {
; 5834 :          fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15551
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 5835 :                           "Link buffer: expecting ':' after OI tag.", 1 );
; 5836 :          goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN16@fnRelinkOI:

; 5837 :       }
; 5838 : 
; 5839 :       if ( nOI_Idx == nViewCount )

	movsx	eax, WORD PTR _nOI_Idx$3[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN17@fnRelinkOI

; 5840 :       {
; 5841 :          fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15553
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 5842 :                           "Link buffer: Could find OI matching Tag.", 1 );
; 5843 :          goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN17@fnRelinkOI:

; 5844 :       }
; 5845 : 
; 5846 :       if ( !zisalnum( *pch ) )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@fnRelinkOI

; 5847 :       {
; 5848 :          fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15555
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 5849 :                           "Link buffer: expecting hex digit(2).", 1 );
; 5850 :          goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN18@fnRelinkOI:

; 5851 :       }
; 5852 : 
; 5853 :       // Get the hier number.
; 5854 :       lHierCount = zstrtol( pch, &pch, 16 );

	push	16					; 00000010H
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtol
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lHierCount$[ebp], eax

; 5855 : 
; 5856 :       // The next char had better be a ')' or a '/'!
; 5857 :       if ( *pch != ')' && *pch != '/' )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 41					; 00000029H
	je	SHORT $LN19@fnRelinkOI
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 47					; 0000002fH
	je	SHORT $LN19@fnRelinkOI

; 5858 :       {
; 5859 :          fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15557
	push	OFFSET _szlNetworkError
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 5860 :                           "Link buffer: expecting ')/' after Hier Num.", 1 );
; 5861 :          goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN19@fnRelinkOI:

; 5862 :       }
; 5863 : 
; 5864 :       // Find the entity instance that matches lHierCount.
; 5865 :       lpEntityInstance = zGETPTR( plpViewOI[ nOI_Idx ]->hRootEntityInstance );

	movsx	ecx, WORD PTR _nOI_Idx$3[ebp]
	mov	edx, DWORD PTR _plpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5866 :       lpEntityInstance = fnFindEntityInstanceByHierCount( lpEntityInstance,

	mov	edx, DWORD PTR _lHierCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnFindEntityInstanceByHierCount@8
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5867 :                                                           lHierCount );
; 5868 :       if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN20@fnRelinkOI

; 5869 :       {
; 5870 :          fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15559
	push	OFFSET _szlNetworkError
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 5871 :                           "Link buffer: Could find EI matching Hier Count.", 1 );
; 5872 :          goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN20@fnRelinkOI:

; 5873 :       }
; 5874 : 
; 5875 :       if ( lpLastEI )

	cmp	DWORD PTR _lpLastEI$[ebp], 0
	je	SHORT $LN21@fnRelinkOI

; 5876 :       {
; 5877 : 
; 5878 : #ifdef DEBUG
; 5879 :          LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 5880 :          LPVIEWENTITY lpLastViewEntity = zGETPTR( lpLastEI->hViewEntity );

	mov	ecx, DWORD PTR _lpLastEI$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastViewEntity$1[ebp], eax

; 5881 : 
; 5882 :          if ( lpViewEntity->lEREntTok != lpLastViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpViewEntity$2[ebp]
	mov	ecx, DWORD PTR _lpLastViewEntity$1[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN22@fnRelinkOI

; 5883 :          {
; 5884 :             fnSysMessageBox( lpTask, szlNetworkError,

	push	1
	push	OFFSET $SG15562
	push	OFFSET _szlNetworkError
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 5885 :                              "Link buffer: Link EIs don't have matching tokens.", 1 );
; 5886 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$25
$LN22@fnRelinkOI:

; 5887 :          }
; 5888 : 
; 5889 : #endif
; 5890 :          fnRelinkInstanceToInstance( lpLastEI, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLastEI$[ebp]
	push	edx
	call	_fnRelinkInstanceToInstance
	add	esp, 8
$LN21@fnRelinkOI:

; 5891 : 
; 5892 :       } // if ( lpLastEI )...
; 5893 : 
; 5894 :       // Set lpLastEI so that the next EI we read can be linked to
; 5895 :       // it.
; 5896 :       lpLastEI = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLastEI$[ebp], eax

; 5897 : 
; 5898 :       // If pch point to a close paren then we just linked the last EI in the
; 5899 :       // current EI list.  Set lpLastEI to 0 to indicate that the
; 5900 :       // next EI we read is the first in a linked chain.
; 5901 :       if ( *pch == ')' )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 41					; 00000029H
	jne	SHORT $LN23@fnRelinkOI

; 5902 :          lpLastEI = 0;

	mov	DWORD PTR _lpLastEI$[ebp], 0
$LN23@fnRelinkOI:

; 5903 : 
; 5904 :       pch++;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax

; 5905 : 
; 5906 :    } // while ( *pch )...

	jmp	$LN8@fnRelinkOI
$EndOfFunction$25:

; 5907 : 
; 5908 : EndOfFunction:
; 5909 : 
; 5910 :    SysFreeMemory( hBuffer );

	mov	ecx, DWORD PTR _hBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4
$LN1@fnRelinkOI:

; 5911 : 
; 5912 : } // fnRelinkOIs

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnRelinkOIs@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpViewOD$ = -68					; size = 4
_lpViewEntity$1 = -64					; size = 4
_lpNewAttribFlags$2 = -60				; size = 4
_lpOldAttribFlags$3 = -56				; size = 4
_lpValue$4 = -52					; size = 4
_uLth$5 = -48						; size = 4
_lpNewViewCsr$ = -44					; size = 4
_lpOldViewCsr$ = -40					; size = 4
tv220 = -36						; size = 4
_lpOldViewOI$ = -32					; size = 4
_lpNewViewOI$ = -28					; size = 4
tv90 = -24						; size = 4
_lpViewAttrib$6 = -20					; size = 4
_lpViewEntity$7 = -16					; size = 4
_lpNew$ = -12						; size = 4
_lpOld$ = -8						; size = 4
_bGetNextOld$ = -1					; size = 1
_vNew$ = 8						; size = 4
_vOld$ = 12						; size = 4
_fnMergeViews@8 PROC

; 3051 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 3052 :    LPVIEWCSR         lpOldViewCsr = zGETPTR( vOld->hViewCsr );

	mov	eax, DWORD PTR _vOld$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldViewCsr$[ebp], eax

; 3053 :    LPVIEWOI          lpOldViewOI  = zGETPTR( lpOldViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpOldViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldViewOI$[ebp], eax

; 3054 :    LPVIEWCSR         lpNewViewCsr = zGETPTR( vNew->hViewCsr );

	mov	ecx, DWORD PTR _vNew$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewCsr$[ebp], eax

; 3055 :    LPVIEWOI          lpNewViewOI  = zGETPTR( lpNewViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewOI$[ebp], eax

; 3056 :    LPENTITYINSTANCE  lpNew;
; 3057 :    LPENTITYINSTANCE  lpOld;
; 3058 :    zBOOL             bGetNextOld;
; 3059 : 
; 3060 : #ifdef DEBUG
; 3061 :    LPVIEWOD          lpViewOD = zGETPTR( vNew->hViewOD );

	mov	edx, DWORD PTR _vNew$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3062 : #endif
; 3063 : 
; 3064 :    // Loop through each entity instance and merge data from new to old.
; 3065 : 
; 3066 :    // Loop through all the old instances and try to merge the new instances.
; 3067 :    lpNew = zGETPTR( lpNewViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpNewViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNew$[ebp], eax

; 3068 :    for ( lpOld = zGETPTR( lpOldViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpOldViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOld$[ebp], eax
	jmp	SHORT $LN4@fnMergeVie
$LN2@fnMergeVie:

; 3070 :          lpOld = (bGetNextOld ? zGETPTR( lpOld->hNextHier ) : lpOld) )

	movzx	edx, BYTE PTR _bGetNextOld$[ebp]
	test	edx, edx
	je	SHORT $LN25@fnMergeVie
	mov	eax, DWORD PTR _lpOld$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN26@fnMergeVie
$LN25@fnMergeVie:
	mov	edx, DWORD PTR _lpOld$[ebp]
	mov	DWORD PTR tv90[ebp], edx
$LN26@fnMergeVie:
	mov	eax, DWORD PTR tv90[ebp]
	mov	DWORD PTR _lpOld$[ebp], eax
$LN4@fnMergeVie:

; 3069 :          lpOld;

	cmp	DWORD PTR _lpOld$[ebp], 0
	je	$LN3@fnMergeVie

; 3071 :    {
; 3072 :       LPVIEWENTITY lpViewEntity;
; 3073 :       LPVIEWATTRIB lpViewAttrib;
; 3074 : 
; 3075 :       // We'll assume here that the next iteration of the 'for' loop should
; 3076 :       // get the next lpOld.
; 3077 :       bGetNextOld = TRUE;

	mov	BYTE PTR _bGetNextOld$[ebp], 1
$LN5@fnMergeVie:

; 3078 : 
; 3079 :       // Skip old entity instances if they are "dead".  If they are dead then
; 3080 :       // they were not sent to the server so they won't show up in the new OI.
; 3081 :       while ( lpOld && fnEntityInstanceIsDead( lpOld ) )

	cmp	DWORD PTR _lpOld$[ebp], 0
	je	SHORT $LN6@fnMergeVie
	mov	ecx, DWORD PTR _lpOld$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN6@fnMergeVie

; 3082 :          lpOld = zGETPTR( lpOld->hNextHier );

	mov	eax, DWORD PTR _lpOld$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOld$[ebp], eax
	jmp	SHORT $LN5@fnMergeVie
$LN6@fnMergeVie:

; 3083 : 
; 3084 :       if ( lpOld == 0 )

	cmp	DWORD PTR _lpOld$[ebp], 0
	jne	SHORT $LN15@fnMergeVie

; 3085 :          break;

	jmp	$LN3@fnMergeVie
$LN15@fnMergeVie:

; 3086 : 
; 3087 :       // Compare the tag of the new instance with the pointer of the old
; 3088 :       // instance.  If they are not the same then something happened:
; 3089 :       // o  A commit object operation on the server created or deleted an
; 3090 :       //    entity.
; 3091 :       if ( (zLONG) lpOld != lpNew->lTag )

	mov	edx, DWORD PTR _lpNew$[ebp]
	mov	eax, DWORD PTR _lpOld$[ebp]
	cmp	eax, DWORD PTR [edx+46]
	je	SHORT $LN16@fnMergeVie

; 3092 :       {
; 3093 :          zLONG lSomethingNeedsToBeDoneHere;
; 3094 : 
; 3095 :          // We'll worry about handling server commit operations that create/
; 3096 :          // delete entities later.  For now we'll just assume that lpOld
; 3097 :          // wasn't sent to the server...so skip it.
; 3098 : 
; 3099 :          // NOTE: We can determine if the lpNew entity was created on the
; 3100 :          // server by checking the value of lpNew->lTag.  If it is 0 then
; 3101 :          // the entity was created on the server.
; 3102 : 
; 3103 :          lpViewEntity = zGETPTR( lpOld->hViewEntity );

	mov	ecx, DWORD PTR _lpOld$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$7[ebp], eax

; 3104 :          TraceLineS( "(merge) Tags don't match! Old entity = ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$7[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG14670
	call	_TraceLineS@8

; 3105 :          lpViewEntity = zGETPTR( lpNew->hViewEntity );

	mov	ecx, DWORD PTR _lpNew$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$7[ebp], eax

; 3106 :          TraceLineS( "(merge) Tags don't match! New entity = ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$7[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG14671
	call	_TraceLineS@8

; 3107 :          TraceLineX( "(merge) lpOld       = ", (zLONG) lpOld );

	mov	ecx, DWORD PTR _lpOld$[ebp]
	push	ecx
	push	OFFSET $SG14672
	call	_TraceLineX@8

; 3108 :          TraceLineX( "(merge) lpNew->lTag = ", lpNew->lTag );

	mov	edx, DWORD PTR _lpNew$[ebp]
	mov	eax, DWORD PTR [edx+46]
	push	eax
	push	OFFSET $SG14673
	call	_TraceLineX@8

; 3109 : 
; 3110 :          continue;

	jmp	$LN2@fnMergeVie
$LN16@fnMergeVie:

; 3111 :       }
; 3112 : 
; 3113 :       // If we get here then the tag for the new entity matches the pointer
; 3114 :       // for the old entity.  They must be the same instance.
; 3115 :       lpViewEntity = zGETPTR( lpOld->hViewEntity );

	mov	ecx, DWORD PTR _lpOld$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$7[ebp], eax

; 3116 :       if ( lpViewEntity->bDerived == FALSE &&
; 3117 :            lpViewEntity->bDerivedPath == FALSE &&

	mov	eax, DWORD PTR _lpViewEntity$7[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	$LN17@fnMergeVie
	mov	edx, DWORD PTR _lpViewEntity$7[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	jne	$LN17@fnMergeVie
	mov	ecx, DWORD PTR _lpViewEntity$7[ebp]
	mov	edx, DWORD PTR [ecx+239]
	and	edx, 1
	jne	$LN17@fnMergeVie

; 3118 :            lpViewEntity->bHasDB_Oper == FALSE ) // added Phil/Doug 2005.10.17
; 3119 :       {
; 3120 :          // Copy each of the attribute values.
; 3121 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$7[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$6[ebp], eax
	jmp	SHORT $LN9@fnMergeVie
$LN7@fnMergeVie:

; 3123 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$6[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$6[ebp], eax
$LN9@fnMergeVie:

; 3122 :                lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$6[ebp], 0
	je	SHORT $LN17@fnMergeVie

; 3124 :          {
; 3125 :             zPVOID        lpValue;
; 3126 :             zULONG        uLth;
; 3127 :             LPATTRIBFLAGS lpOldAttribFlags;
; 3128 :             LPATTRIBFLAGS lpNewAttribFlags;
; 3129 : 
; 3130 :             if ( lpViewAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$6[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN18@fnMergeVie

; 3131 :                continue;

	jmp	SHORT $LN7@fnMergeVie
$LN18@fnMergeVie:

; 3132 : 
; 3133 :             fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpValue, &uLth,

	mov	eax, DWORD PTR _lpViewAttrib$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNew$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$5[ebp]
	push	edx
	lea	eax, DWORD PTR _lpValue$4[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 3134 :                                              lpNew, lpViewAttrib );
; 3135 :             fnStoreValueInEntityInstance( lpOld, lpViewEntity, lpViewAttrib,

	mov	ecx, DWORD PTR _uLth$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValue$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOld$[ebp]
	push	edx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H

; 3136 :                                           lpValue, uLth );
; 3137 : 
; 3138 :             lpNewAttribFlags = fnGetAttribFlagsPtr( lpNew, lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNew$[ebp]
	push	ecx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpNewAttribFlags$2[ebp], eax

; 3139 :             lpOldAttribFlags = fnGetAttribFlagsPtr( lpOld, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOld$[ebp]
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpOldAttribFlags$3[ebp], eax

; 3140 :             lpOldAttribFlags->u.uFlags = lpNewAttribFlags->u.uFlags;

	mov	ecx, DWORD PTR _lpOldAttribFlags$3[ebp]
	mov	edx, DWORD PTR _lpNewAttribFlags$2[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx], eax

; 3141 : 
; 3142 :          } // for...

	jmp	$LN7@fnMergeVie
$LN17@fnMergeVie:

; 3143 :       }
; 3144 : 
; 3145 :       lpOld->u.nIndicators = lpNew->u.nIndicators;

	mov	ecx, DWORD PTR _lpOld$[ebp]
	mov	edx, DWORD PTR _lpNew$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+6], eax

; 3146 : 
; 3147 :       lpNew = zGETPTR( lpNew->hNextHier );

	mov	ecx, DWORD PTR _lpNew$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNew$[ebp], eax

; 3148 :       if ( lpNew == 0 )

	cmp	DWORD PTR _lpNew$[ebp], 0
	jne	SHORT $LN19@fnMergeVie

; 3149 :          break;

	jmp	SHORT $LN3@fnMergeVie
$LN19@fnMergeVie:

; 3150 : 
; 3151 :    } // for ( lpOld )...

	jmp	$LN2@fnMergeVie
$LN3@fnMergeVie:

; 3152 : 
; 3153 :    if ( lpNew )

	cmp	DWORD PTR _lpNew$[ebp], 0
	je	SHORT $LN20@fnMergeVie

; 3154 :    {
; 3155 :       zLONG        lSomethingNeedsToBeDoneHereToo;
; 3156 :       LPVIEWENTITY lpViewEntity;
; 3157 : 
; 3158 :       // If we get here then we've gone through all the old entities but we
; 3159 :       // still have new entities left.  This means that some entities were
; 3160 :       // created on the server.  We should merge them in.
; 3161 :       lpViewEntity = zGETPTR( lpNew->hViewEntity );

	mov	eax, DWORD PTR _lpNew$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 3162 :       TraceLineS( "(merge) Extra New entity! = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$1[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG14678
	call	_TraceLineS@8

; 3163 :       TraceLineX( "(merge) lpNew->lTag = ", lpNew->lTag );

	mov	eax, DWORD PTR _lpNew$[ebp]
	mov	ecx, DWORD PTR [eax+46]
	push	ecx
	push	OFFSET $SG14679
	call	_TraceLineX@8
$LN20@fnMergeVie:

; 3164 :    }
; 3165 : 
; 3166 :    // Now loop through again but just copy the EI flags.
; 3167 : 
; 3168 :    lpNew = zGETPTR( lpNewViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpNewViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNew$[ebp], eax

; 3169 :    for ( lpOld = zGETPTR( lpOldViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpOldViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOld$[ebp], eax
	jmp	SHORT $LN12@fnMergeVie
$LN10@fnMergeVie:

; 3171 :          lpOld = ( bGetNextOld ? zGETPTR( lpOld->hNextHier ) : lpOld ) )

	movzx	eax, BYTE PTR _bGetNextOld$[ebp]
	test	eax, eax
	je	SHORT $LN27@fnMergeVie
	mov	ecx, DWORD PTR _lpOld$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv220[ebp], eax
	jmp	SHORT $LN28@fnMergeVie
$LN27@fnMergeVie:
	mov	eax, DWORD PTR _lpOld$[ebp]
	mov	DWORD PTR tv220[ebp], eax
$LN28@fnMergeVie:
	mov	ecx, DWORD PTR tv220[ebp]
	mov	DWORD PTR _lpOld$[ebp], ecx
$LN12@fnMergeVie:

; 3170 :          lpOld;

	cmp	DWORD PTR _lpOld$[ebp], 0
	je	SHORT $LN11@fnMergeVie

; 3172 :    {
; 3173 :       // We'll assume here that the next iteration of the 'for' loop should
; 3174 :       // get the next lpOld.
; 3175 :       bGetNextOld = TRUE;

	mov	BYTE PTR _bGetNextOld$[ebp], 1
$LN13@fnMergeVie:

; 3176 : 
; 3177 :       while ( lpOld && fnEntityInstanceIsDead( lpOld ) )

	cmp	DWORD PTR _lpOld$[ebp], 0
	je	SHORT $LN14@fnMergeVie
	mov	edx, DWORD PTR _lpOld$[ebp]
	push	edx
	call	_fnEntityInstanceIsDead@4
	cwde
	test	eax, eax
	je	SHORT $LN14@fnMergeVie

; 3178 :          lpOld = zGETPTR( lpOld->hNextHier );

	mov	ecx, DWORD PTR _lpOld$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOld$[ebp], eax
	jmp	SHORT $LN13@fnMergeVie
$LN14@fnMergeVie:

; 3179 : 
; 3180 :       if ( lpOld == 0 )

	cmp	DWORD PTR _lpOld$[ebp], 0
	jne	SHORT $LN21@fnMergeVie

; 3181 :          break;

	jmp	SHORT $LN11@fnMergeVie
$LN21@fnMergeVie:

; 3182 : 
; 3183 :       // Compare the tag of the new instance with the pointer of the old
; 3184 :       // instance.  If they are not the same then one of two things happened:
; 3185 :       // o  For some reason lpOld wasn't sent to the server--maybe it's
; 3186 :       //    dead.
; 3187 :       // o  A commit object operation on the server created or deleted an
; 3188 :       //    entity.
; 3189 :       if ( (zLONG) lpOld != lpNew->lTag )

	mov	eax, DWORD PTR _lpNew$[ebp]
	mov	ecx, DWORD PTR _lpOld$[ebp]
	cmp	ecx, DWORD PTR [eax+46]
	je	SHORT $LN22@fnMergeVie

; 3190 :          continue;

	jmp	SHORT $LN10@fnMergeVie
$LN22@fnMergeVie:

; 3191 : 
; 3192 :       // If we get here then the tag for the new entity matches the pointer
; 3193 :       // for the old entity.  They must be the same instance.
; 3194 : 
; 3195 :       lpOld->u.nIndicators = lpNew->u.nIndicators;

	mov	edx, DWORD PTR _lpOld$[ebp]
	mov	eax, DWORD PTR _lpNew$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+6], ecx

; 3196 : 
; 3197 :       lpNew = zGETPTR( lpNew->hNextHier );

	mov	edx, DWORD PTR _lpNew$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNew$[ebp], eax

; 3198 :       if ( lpNew == 0 )

	cmp	DWORD PTR _lpNew$[ebp], 0
	jne	SHORT $LN23@fnMergeVie

; 3199 :          break;

	jmp	SHORT $LN11@fnMergeVie
$LN23@fnMergeVie:

; 3200 : 
; 3201 :    } // for ( lpOld )...

	jmp	$LN10@fnMergeVie
$LN11@fnMergeVie:

; 3202 : 
; 3203 :    return( 0 );

	xor	eax, eax

; 3204 : 
; 3205 : } // fnMergeViews

	mov	esp, ebp
	pop	ebp
	ret	8
_fnMergeViews@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pchSave$1 = -468					; size = 4
_lpTempViewCsr$2 = -464					; size = 4
_lpTempViewCsr$3 = -460					; size = 4
_lpViewOI$ = -456					; size = 4
_lHierCount$ = -452					; size = 4
_pchLinkBuffer$ = -448					; size = 4
_lpViewCsr$ = -444					; size = 4
_lpLinked$4 = -440					; size = 4
_lpLinked$5 = -436					; size = 4
_j$6 = -432						; size = 2
_nLinkInfo$7 = -428					; size = 2
_lpEntityInstance$ = -424				; size = 4
_j$8 = -420						; size = 2
_bInterlinking$ = -413					; size = 1
_pchBufferEnd$ = -412					; size = 4
_k$ = -408						; size = 2
_cOI_Linked$ = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpViewArray$ = 12					; size = 4
_nViewCount$ = 16					; size = 2
_ppchLinkBuffer$ = 20					; size = 4
_plLinkBufferLth$ = 24					; size = 4
_fnSetLinkBuffer@20 PROC

; 2796 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 468				; 000001d4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2797 :    zPCHAR           pchLinkBuffer;
; 2798 :    zSHORT           k;
; 2799 :    zPCHAR           pchBufferEnd;
; 2800 :    zLONG            lHierCount;
; 2801 :    zBOOL            bInterlinking = FALSE;

	mov	BYTE PTR _bInterlinking$[ebp], 0

; 2802 :    LPENTITYINSTANCE lpEntityInstance;
; 2803 :    LPVIEWOI         lpViewOI;
; 2804 :    LPVIEWCSR        lpViewCsr;
; 2805 :    zCHAR            cOI_Linked[ 400 ];  // We can handle 400 OIs.
; 2806 : 
; 2807 :    *ppchLinkBuffer  = 0;

	mov	eax, DWORD PTR _ppchLinkBuffer$[ebp]
	mov	DWORD PTR [eax], 0

; 2808 :    *plLinkBufferLth = 0;

	mov	ecx, DWORD PTR _plLinkBufferLth$[ebp]
	mov	DWORD PTR [ecx], 0

; 2809 : 
; 2810 :    // If we have only 1 view there can't be any interlinking...
; 2811 :    if ( nViewCount <= 1 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	edx, 1
	jg	SHORT $LN26@fnSetLinkB

; 2812 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSetLinkB
$LN26@fnSetLinkB:

; 2813 : 
; 2814 :    // First set the hier count for all the EIs.  Also check to make sure that
; 2815 :    // there is interlinking between OIs.
; 2816 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@fnSetLinkB
$LN2@fnSetLinkB:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@fnSetLinkB:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$LN3@fnSetLinkB

; 2817 :    {
; 2818 :       if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN27@fnSetLinkB

; 2819 :          continue;

	jmp	SHORT $LN2@fnSetLinkB
$LN27@fnSetLinkB:

; 2820 : 
; 2821 :       lHierCount = 0;

	mov	DWORD PTR _lHierCount$[ebp], 0

; 2822 :       lpViewCsr  = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2823 :       lpViewOI   = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2824 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN7@fnSetLinkB
$LN5@fnSetLinkB:

; 2826 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnSetLinkB:

; 2825 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN6@fnSetLinkB

; 2827 :       {
; 2828 :          LPENTITYINSTANCE lpLinked;
; 2829 : 
; 2830 :          if ( fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN28@fnSetLinkB

; 2831 :             continue;

	jmp	SHORT $LN5@fnSetLinkB
$LN28@fnSetLinkB:

; 2832 : 
; 2833 :          lpEntityInstance->lHierCount = lHierCount++;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lHierCount$[ebp]
	mov	DWORD PTR [eax+54], ecx
	mov	edx, DWORD PTR _lHierCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _lHierCount$[ebp], edx

; 2834 : 
; 2835 :          // Check to see if the current EI is linked with an EI in one of the
; 2836 :          // other OIs.  If bInterlinking is TRUE then we already know that
; 2837 :          // there is interlinking between the OIs so skip it.  (We still need
; 2838 :          // to loop through the entity instances to set their hier #)
; 2839 :          if ( bInterlinking || lpEntityInstance->hNextLinked == 0 )

	movzx	eax, BYTE PTR _bInterlinking$[ebp]
	test	eax, eax
	jne	SHORT $LN30@fnSetLinkB
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN29@fnSetLinkB
$LN30@fnSetLinkB:

; 2840 :             continue;

	jmp	SHORT $LN5@fnSetLinkB
$LN29@fnSetLinkB:

; 2841 : 
; 2842 :          // Loop through each of the linked instances and see if there is
; 2843 :          // any interlinking.  Stop looping if we find that there is
; 2844 :          // interlinking.
; 2845 :          for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$4[ebp], eax
	jmp	SHORT $LN10@fnSetLinkB
$LN8@fnSetLinkB:

; 2847 :                lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLinked$4[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$4[ebp], eax
$LN10@fnSetLinkB:

; 2846 :                lpLinked != lpEntityInstance && bInterlinking == FALSE;

	mov	eax, DWORD PTR _lpLinked$4[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	$LN9@fnSetLinkB
	movzx	ecx, BYTE PTR _bInterlinking$[ebp]
	test	ecx, ecx
	jne	$LN9@fnSetLinkB

; 2848 :          {
; 2849 :             zSHORT j;
; 2850 : 
; 2851 :             // Don't look at EI's that are part of the same OI.
; 2852 :             if ( lpLinked->hViewOI == lpViewCsr->hViewOI )

	mov	edx, DWORD PTR _lpLinked$4[ebp]
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	jne	SHORT $LN31@fnSetLinkB

; 2853 :                continue;

	jmp	SHORT $LN8@fnSetLinkB
$LN31@fnSetLinkB:

; 2854 : 
; 2855 :             // See if the linked instance belongs to another OI.
; 2856 :             for ( j = 0; j < nViewCount; j++ )

	xor	edx, edx
	mov	WORD PTR _j$6[ebp], dx
	jmp	SHORT $LN13@fnSetLinkB
$LN11@fnSetLinkB:
	mov	ax, WORD PTR _j$6[ebp]
	add	ax, 1
	mov	WORD PTR _j$6[ebp], ax
$LN13@fnSetLinkB:
	movsx	ecx, WORD PTR _j$6[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN12@fnSetLinkB

; 2857 :             {
; 2858 :                LPVIEWCSR lpTempViewCsr;
; 2859 : 
; 2860 :                if ( lpViewArray[ j ] == 0 )

	movsx	eax, WORD PTR _j$6[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN32@fnSetLinkB

; 2861 :                   continue;

	jmp	SHORT $LN11@fnSetLinkB
$LN32@fnSetLinkB:

; 2862 : 
; 2863 :                lpTempViewCsr = zGETPTR( lpViewArray[ j ]->hViewCsr );

	movsx	edx, WORD PTR _j$6[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewCsr$3[ebp], eax

; 2864 :                if ( lpTempViewCsr->hViewOI == lpLinked->hViewOI )

	mov	eax, DWORD PTR _lpTempViewCsr$3[ebp]
	mov	ecx, DWORD PTR _lpLinked$4[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $LN33@fnSetLinkB

; 2865 :                {
; 2866 :                   // We have a match--set flag and get out.
; 2867 :                   bInterlinking = TRUE;

	mov	BYTE PTR _bInterlinking$[ebp], 1

; 2868 :                   break;

	jmp	SHORT $LN12@fnSetLinkB
$LN33@fnSetLinkB:

; 2869 :                }
; 2870 : 
; 2871 :             } // for ( j...)...

	jmp	SHORT $LN11@fnSetLinkB
$LN12@fnSetLinkB:

; 2872 : 
; 2873 :          } // for ( lpLinked...)...

	jmp	$LN8@fnSetLinkB
$LN9@fnSetLinkB:

; 2874 : 
; 2875 :       } // for ( lpEntityInstance...)...

	jmp	$LN5@fnSetLinkB
$LN6@fnSetLinkB:

; 2876 : 
; 2877 :    } // for ( k...)...

	jmp	$LN2@fnSetLinkB
$LN3@fnSetLinkB:

; 2878 : 
; 2879 :    // If there is no interlinking between the OIs then there's nothing more
; 2880 :    // to do.
; 2881 :    if ( bInterlinking == FALSE )

	movzx	eax, BYTE PTR _bInterlinking$[ebp]
	test	eax, eax
	jne	SHORT $LN34@fnSetLinkB

; 2882 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSetLinkB
$LN34@fnSetLinkB:

; 2883 : 
; 2884 :    // We now know that there is interlinking between the OIs.  Create the
; 2885 :    // buffer and set it so we can re-link the instances later.
; 2886 : 
; 2887 :    pchLinkBuffer = (zPCHAR) fnAllocDataspace( lpTask->hFirstDataHeader,

	push	0
	push	0
	push	0
	push	30000					; 00007530H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchLinkBuffer$[ebp], eax

; 2888 :                                               LINK_BUFFER_SIZE, FALSE, 0, 0 );
; 2889 :    if ( pchLinkBuffer == 0 )

	cmp	DWORD PTR _pchLinkBuffer$[ebp], 0
	jne	SHORT $LN35@fnSetLinkB

; 2890 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetLinkB
$LN35@fnSetLinkB:

; 2891 : 
; 2892 :    pchLinkBuffer   = zGETPTR( pchLinkBuffer );

	mov	eax, DWORD PTR _pchLinkBuffer$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchLinkBuffer$[ebp], eax

; 2893 :    *ppchLinkBuffer = pchBufferEnd = pchLinkBuffer;

	mov	ecx, DWORD PTR _pchLinkBuffer$[ebp]
	mov	DWORD PTR _pchBufferEnd$[ebp], ecx
	mov	edx, DWORD PTR _ppchLinkBuffer$[ebp]
	mov	eax, DWORD PTR _pchBufferEnd$[ebp]
	mov	DWORD PTR [edx], eax

; 2894 : 
; 2895 :    // Loop through all the EI's again.  This time we'll start adding link info.
; 2896 :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN16@fnSetLinkB
$LN14@fnSetLinkB:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN16@fnSetLinkB:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN15@fnSetLinkB

; 2897 :    {
; 2898 :       if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN36@fnSetLinkB

; 2899 :          continue;

	jmp	SHORT $LN14@fnSetLinkB
$LN36@fnSetLinkB:

; 2900 : 
; 2901 :       lpViewCsr  = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2902 :       lpViewOI   = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2903 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN19@fnSetLinkB
$LN17@fnSetLinkB:

; 2905 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN19@fnSetLinkB:

; 2904 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN18@fnSetLinkB

; 2906 :       {
; 2907 :          zSHORT           nLinkInfo;
; 2908 :          zPCHAR           pchSave;
; 2909 :          LPENTITYINSTANCE lpLinked;
; 2910 : 
; 2911 :          // Don't bother with an entity that isn't linked.
; 2912 :          if ( lpEntityInstance->hNextLinked == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	jne	SHORT $LN37@fnSetLinkB

; 2913 :             continue;

	jmp	SHORT $LN17@fnSetLinkB
$LN37@fnSetLinkB:

; 2914 : 
; 2915 :          // Don't bother with a dead entity.
; 2916 :          if ( fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN38@fnSetLinkB

; 2917 :             continue;

	jmp	SHORT $LN17@fnSetLinkB
$LN38@fnSetLinkB:

; 2918 : 
; 2919 :          // Assume that we don't have to create link information for the
; 2920 :          // current EI.  nLinkInfo can be:
; 2921 :          //   0 - Means that no interlinks have been found.
; 2922 :          //   1 - Interlink has been found--add info to link buffer.
; 2923 :          //   2 - A link has been found but it belongs to an OI that we've
; 2924 :          //       already searched.  This means that info has already been
; 2925 :          //       added to the link buffer for the current EI.
; 2926 :          // pchSave saves the current position of pchBufferEnd in case we have
; 2927 :          // to go back to it.
; 2928 :          nLinkInfo = 0;

	xor	edx, edx
	mov	WORD PTR _nLinkInfo$7[ebp], dx

; 2929 :          pchSave   = pchBufferEnd;

	mov	eax, DWORD PTR _pchBufferEnd$[ebp]
	mov	DWORD PTR _pchSave$1[ebp], eax

; 2930 : 
; 2931 :          // Set table to all 0's to indicate that for this linked-list chain
; 2932 :          // we haven't linked any OIs yet.
; 2933 :          zmemset( cOI_Linked, 0, sizeof( cOI_Linked ) );

	push	400					; 00000190H
	push	0
	lea	ecx, DWORD PTR _cOI_Linked$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2934 : 
; 2935 :          // Loop through each of the linked instances and see if there is
; 2936 :          // any interlinking.  Stop looping if we find that there is
; 2937 :          // interlinking.
; 2938 :          for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$5[ebp], eax
	jmp	SHORT $LN22@fnSetLinkB
$LN20@fnSetLinkB:

; 2940 :                lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLinked$5[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$5[ebp], eax
$LN22@fnSetLinkB:

; 2939 :                lpLinked != lpEntityInstance;

	mov	eax, DWORD PTR _lpLinked$5[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	$LN21@fnSetLinkB

; 2941 :          {
; 2942 :             zSHORT j;
; 2943 : 
; 2944 :             // Don't look at EI's that are part of the same OI.
; 2945 :             if ( lpLinked->hViewOI == lpViewCsr->hViewOI )

	mov	ecx, DWORD PTR _lpLinked$5[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [ecx+10]
	cmp	eax, DWORD PTR [edx+10]
	jne	SHORT $LN39@fnSetLinkB

; 2946 :                continue;

	jmp	SHORT $LN20@fnSetLinkB
$LN39@fnSetLinkB:

; 2947 : 
; 2948 :             // See if the linked instance belongs to another OI.
; 2949 :             for ( j = 0; j < nViewCount; j++ )

	xor	ecx, ecx
	mov	WORD PTR _j$8[ebp], cx
	jmp	SHORT $LN25@fnSetLinkB
$LN23@fnSetLinkB:
	mov	dx, WORD PTR _j$8[ebp]
	add	dx, 1
	mov	WORD PTR _j$8[ebp], dx
$LN25@fnSetLinkB:
	movsx	eax, WORD PTR _j$8[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN24@fnSetLinkB

; 2950 :             {
; 2951 :                LPVIEWCSR lpTempViewCsr;
; 2952 : 
; 2953 :                if ( lpViewArray[ j ] == 0 )

	movsx	edx, WORD PTR _j$8[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN40@fnSetLinkB

; 2954 :                   continue;

	jmp	SHORT $LN23@fnSetLinkB
$LN40@fnSetLinkB:

; 2955 : 
; 2956 :                // If lpLinked is not part of the OI specified by
; 2957 :                // lpViewArray[ j ] then skip it.
; 2958 :                lpTempViewCsr = zGETPTR( lpViewArray[ j ]->hViewCsr );

	movsx	ecx, WORD PTR _j$8[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewCsr$2[ebp], eax

; 2959 :                if ( lpTempViewCsr->hViewOI != lpLinked->hViewOI )

	mov	edx, DWORD PTR _lpTempViewCsr$2[ebp]
	mov	eax, DWORD PTR _lpLinked$5[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	je	SHORT $LN41@fnSetLinkB

; 2960 :                   continue;

	jmp	SHORT $LN23@fnSetLinkB
$LN41@fnSetLinkB:

; 2961 : 
; 2962 :                // At this point 'k' is the index pointing to the lpView for
; 2963 :                // lpEntityInstance and 'j' is the index pointing to the lpView
; 2964 :                // that lpLinked is part of.
; 2965 :                if ( j < k )

	movsx	edx, WORD PTR _j$8[ebp]
	movsx	eax, WORD PTR _k$[ebp]
	cmp	edx, eax
	jge	SHORT $LN42@fnSetLinkB

; 2966 :                {
; 2967 :                   // We've found an interlink but lpLinked belongs to an
; 2968 :                   // OI that we've already searched.  This means that we've
; 2969 :                   // already added info to the link buffer and doesn't need
; 2970 :                   // to be done for the current set of linked instances.
; 2971 :                   nLinkInfo = 2;

	mov	ecx, 2
	mov	WORD PTR _nLinkInfo$7[ebp], cx

; 2972 :                   break;

	jmp	$LN24@fnSetLinkB
$LN42@fnSetLinkB:

; 2973 :                }
; 2974 : 
; 2975 :                // Check to see if we've already found a linked EI in this
; 2976 :                // view.  We only need to find 1 since all the linked EIs in
; 2977 :                // the OI are already linked together.
; 2978 :                if ( cOI_Linked[ j ] == TRUE )

	movsx	edx, WORD PTR _j$8[ebp]
	movsx	eax, BYTE PTR _cOI_Linked$[ebp+edx]
	cmp	eax, 1
	jne	SHORT $LN43@fnSetLinkB

; 2979 :                   break;

	jmp	$LN24@fnSetLinkB
$LN43@fnSetLinkB:

; 2980 : 
; 2981 :                // Set flag to indicate we've linked this OI.
; 2982 :                cOI_Linked[ j ] = TRUE;

	movsx	ecx, WORD PTR _j$8[ebp]
	mov	BYTE PTR _cOI_Linked$[ebp+ecx], 1

; 2983 : 
; 2984 :                // If this is the first EI that we've found add a paren to
; 2985 :                // start things and then add lpEntityInstance.
; 2986 :                if ( nLinkInfo == 0 )

	movsx	edx, WORD PTR _nLinkInfo$7[ebp]
	test	edx, edx
	jne	SHORT $LN44@fnSetLinkB

; 2987 :                {
; 2988 :                   *pchBufferEnd++ = '(';

	mov	eax, DWORD PTR _pchBufferEnd$[ebp]
	mov	BYTE PTR [eax], 40			; 00000028H
	mov	ecx, DWORD PTR _pchBufferEnd$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchBufferEnd$[ebp], ecx

; 2989 :                   zsprintf( pchBufferEnd, "%x:%lx", k,

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+54]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	push	ecx
	push	OFFSET $SG14601
	mov	edx, DWORD PTR _pchBufferEnd$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2990 :                             lpEntityInstance->lHierCount );
; 2991 :                   pchBufferEnd += zstrlen( pchBufferEnd );

	mov	eax, DWORD PTR _pchBufferEnd$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchBufferEnd$[ebp]
	mov	DWORD PTR _pchBufferEnd$[ebp], eax
$LN44@fnSetLinkB:

; 2992 :                }
; 2993 : 
; 2994 :                // Add a slash to seperate EI data.
; 2995 :                *pchBufferEnd++ = '/';

	mov	ecx, DWORD PTR _pchBufferEnd$[ebp]
	mov	BYTE PTR [ecx], 47			; 0000002fH
	mov	edx, DWORD PTR _pchBufferEnd$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchBufferEnd$[ebp], edx

; 2996 : 
; 2997 :                // Set flag to indicate that we've found interlinking and
; 2998 :                // that we're adding it to the buffer.
; 2999 :                nLinkInfo = 1;

	mov	eax, 1
	mov	WORD PTR _nLinkInfo$7[ebp], ax

; 3000 : 
; 3001 :                //
; 3002 :                zsprintf( pchBufferEnd, "%x:%lx", j, lpLinked->lHierCount );

	mov	ecx, DWORD PTR _lpLinked$5[ebp]
	mov	edx, DWORD PTR [ecx+54]
	push	edx
	movsx	eax, WORD PTR _j$8[ebp]
	push	eax
	push	OFFSET $SG14602
	mov	ecx, DWORD PTR _pchBufferEnd$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3003 :                pchBufferEnd += zstrlen( pchBufferEnd );

	mov	edx, DWORD PTR _pchBufferEnd$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchBufferEnd$[ebp]
	mov	DWORD PTR _pchBufferEnd$[ebp], eax

; 3004 : 
; 3005 :             } // for ( j...)...

	jmp	$LN23@fnSetLinkB
$LN24@fnSetLinkB:

; 3006 : 
; 3007 :             if ( nLinkInfo == 2 )

	movsx	eax, WORD PTR _nLinkInfo$7[ebp]
	cmp	eax, 2
	jne	SHORT $LN45@fnSetLinkB

; 3008 :                break;

	jmp	SHORT $LN21@fnSetLinkB
$LN45@fnSetLinkB:

; 3009 : 
; 3010 :          } // for ( lpLinked...)...

	jmp	$LN20@fnSetLinkB
$LN21@fnSetLinkB:

; 3011 : 
; 3012 :          // If nLinkInfo is 2 then we don't need to add information to the
; 3013 :          // link buffer for the current entity so reset pchBufferEnd.
; 3014 :          if ( nLinkInfo == 2 )

	movsx	ecx, WORD PTR _nLinkInfo$7[ebp]
	cmp	ecx, 2
	jne	SHORT $LN46@fnSetLinkB

; 3015 :             pchBufferEnd = pchSave;

	mov	edx, DWORD PTR _pchSave$1[ebp]
	mov	DWORD PTR _pchBufferEnd$[ebp], edx
	jmp	SHORT $LN47@fnSetLinkB
$LN46@fnSetLinkB:

; 3016 :          else
; 3017 :          if ( nLinkInfo == 1 )

	movsx	eax, WORD PTR _nLinkInfo$7[ebp]
	cmp	eax, 1
	jne	SHORT $LN47@fnSetLinkB

; 3018 :             *pchBufferEnd++ = ')';

	mov	ecx, DWORD PTR _pchBufferEnd$[ebp]
	mov	BYTE PTR [ecx], 41			; 00000029H
	mov	edx, DWORD PTR _pchBufferEnd$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchBufferEnd$[ebp], edx
$LN47@fnSetLinkB:

; 3019 : 
; 3020 :       } // for ( lpEntityInstance...)...

	jmp	$LN17@fnSetLinkB
$LN18@fnSetLinkB:

; 3021 : 
; 3022 :    } // for ( k...)...

	jmp	$LN14@fnSetLinkB
$LN15@fnSetLinkB:

; 3023 : 
; 3024 :    *pchBufferEnd++ = 0;

	mov	eax, DWORD PTR _pchBufferEnd$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pchBufferEnd$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchBufferEnd$[ebp], ecx

; 3025 : 
; 3026 :    *plLinkBufferLth = (zLONG) (pchBufferEnd - pchLinkBuffer);

	mov	edx, DWORD PTR _pchBufferEnd$[ebp]
	sub	edx, DWORD PTR _pchLinkBuffer$[ebp]
	mov	eax, DWORD PTR _plLinkBufferLth$[ebp]
	mov	DWORD PTR [eax], edx

; 3027 : // TraceBuffer( "(kzoeneta) ** LinkBuffer = ", pchLinkBuffer,
; 3028 : //              (zSHORT) *plLinkBufferLth );
; 3029 : 
; 3030 :    return( 0 );

	xor	eax, eax
$LN1@fnSetLinkB:

; 3031 : 
; 3032 : } // fnSetLinkBuffer

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnSetLinkBuffer@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNextTwin$ = -8					; size = 4
_nLevel$1 = -4						; size = 2
_lpEntityInstance$ = 8					; size = 4
_lHierCount$ = 12					; size = 4
_fnFindEntityInstanceByHierCount@8 PROC

; 2728 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
$LN2@fnFindEnti:

; 2729 :    LPENTITYINSTANCE lpNextTwin;
; 2730 : 
; 2731 :    while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@fnFindEnti

; 2732 :    {
; 2733 :       // If the EI is dead then skip it and it's children.
; 2734 :       if ( fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN9@fnFindEnti

; 2735 :       {
; 2736 :          if ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN10@fnFindEnti

; 2737 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN11@fnFindEnti
$LN10@fnFindEnti:

; 2738 :          else
; 2739 :          {
; 2740 :             zSHORT nLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$1[ebp], ax

; 2741 : 
; 2742 :             for ( lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN6@fnFindEnti
$LN4@fnFindEnti:

; 2744 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN6@fnFindEnti:

; 2743 :                   lpEntityInstance && lpEntityInstance->nLevel > nLevel;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN11@fnFindEnti
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$1[ebp]
	cmp	eax, ecx
	jle	SHORT $LN11@fnFindEnti

; 2745 :             {
; 2746 :                // Nothing needs to be done here.
; 2747 :             }

	jmp	SHORT $LN4@fnFindEnti
$LN11@fnFindEnti:

; 2748 :          }
; 2749 : 
; 2750 :          continue;

	jmp	SHORT $LN2@fnFindEnti
$LN9@fnFindEnti:

; 2751 :       }
; 2752 : 
; 2753 :       if ( lpEntityInstance->lHierCount == lHierCount )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+54]
	cmp	eax, DWORD PTR _lHierCount$[ebp]
	jne	SHORT $LN12@fnFindEnti

; 2754 :          return( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	jmp	SHORT $LN1@fnFindEnti
$LN12@fnFindEnti:

; 2755 : 
; 2756 :       // Try a shortcut...see if the next twin (if there is one) has a hier
; 2757 :       // count < the one we're looking for.
; 2758 :       lpNextTwin = zGETPTR( lpEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTwin$[ebp], eax

; 2759 : 
; 2760 :       // Just in case the next twin stuff doesn't work out we'll set
; 2761 :       // lpEntityInstance to point to the next EI hierarchically.
; 2762 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnFindEnti:

; 2763 : 
; 2764 :       while ( lpNextTwin )

	cmp	DWORD PTR _lpNextTwin$[ebp], 0
	je	SHORT $LN8@fnFindEnti

; 2765 :       {
; 2766 :          if ( lpNextTwin->lHierCount <= lHierCount &&

	mov	edx, DWORD PTR _lpNextTwin$[ebp]
	mov	eax, DWORD PTR [edx+54]
	cmp	eax, DWORD PTR _lHierCount$[ebp]
	jg	SHORT $LN13@fnFindEnti
	mov	ecx, DWORD PTR _lpNextTwin$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN13@fnFindEnti

; 2767 :               !fnEntityInstanceIsDead( lpNextTwin ) )
; 2768 :          {
; 2769 :             lpEntityInstance = lpNextTwin;

	mov	eax, DWORD PTR _lpNextTwin$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN13@fnFindEnti:

; 2770 :          }
; 2771 : 
; 2772 :          lpNextTwin = zGETPTR( lpNextTwin->hNextTwin );

	mov	ecx, DWORD PTR _lpNextTwin$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTwin$[ebp], eax

; 2773 :       }

	jmp	SHORT $LN7@fnFindEnti
$LN8@fnFindEnti:

; 2774 :    }

	jmp	$LN2@fnFindEnti
$LN3@fnFindEnti:

; 2775 : 
; 2776 :    return( 0 );  // If we get here then we didn't find it.

	xor	eax, eax
$LN1@fnFindEnti:

; 2777 : 
; 2778 : } // fnFindEntityInstanceByHierCount

	mov	esp, ebp
	pop	ebp
	ret	8
_fnFindEntityInstanceByHierCount@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpTempViewEntityCsr$1 = -180				; size = 4
_lpSrcViewEntity$2 = -176				; size = 4
_lpSubQualViewEntityCsr$ = -172				; size = 4
_lpSubQualViewEntity$ = -168				; size = 4
_lpQualViewEntityCsr$ = -164				; size = 4
_lpQualViewEntity$ = -160				; size = 4
_lpViewOI$ = -156					; size = 4
_lpViewCsr$ = -152					; size = 4
_lpOrigQual$ = -148					; size = 4
_lpViewEntityCsr$3 = -144				; size = 4
_lpSrcView$4 = -140					; size = 4
_lpViewEntity$5 = -136					; size = 4
_lpEntityInstance$ = -132				; size = 4
_lpViewAttrib$6 = -128					; size = 4
_bFirstTime$7 = -121					; size = 1
_pchEntityName$8 = -120					; size = 4
_lpNewQual$ = -116					; size = 4
_szTargetEntity$9 = -112				; size = 33
_szSourceEntity$10 = -76				; size = 33
_szSrcViewName$11 = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_plpQualView$ = 8					; size = 4
_fnConvertIS_Clause@4 PROC

; 2267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 180				; 000000b4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2268 :    zVIEW             lpOrigQual = *plpQualView;

	mov	eax, DWORD PTR _plpQualView$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpOrigQual$[ebp], ecx

; 2269 :    zVIEW             lpNewQual = 0;

	mov	DWORD PTR _lpNewQual$[ebp], 0

; 2270 :    LPVIEWCSR         lpViewCsr;
; 2271 :    LPVIEWOI          lpViewOI;
; 2272 :    LPENTITYINSTANCE  lpEntityInstance;
; 2273 :    LPVIEWENTITY      lpQualViewEntity;
; 2274 :    LPVIEWENTITYCSR   lpQualViewEntityCsr;
; 2275 :    LPVIEWENTITY      lpSubQualViewEntity;
; 2276 :    LPVIEWENTITYCSR   lpSubQualViewEntityCsr;
; 2277 : 
; 2278 :    ActivateOI_FromOI_ForTask( &lpNewQual, lpOrigQual, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _lpOrigQual$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	call	_ActivateOI_FromOI_ForTask@16

; 2279 :    *plpQualView = lpNewQual;

	mov	ecx, DWORD PTR _plpQualView$[ebp]
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	mov	DWORD PTR [ecx], edx

; 2280 : 
; 2281 :    lpViewCsr = zGETPTR( lpNewQual->hViewCsr );

	mov	eax, DWORD PTR _lpNewQual$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2282 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2283 : 
; 2284 :    lpQualViewEntity    = fnValidViewEntity( &lpQualViewEntityCsr, lpNewQual,

	push	0
	push	OFFSET $SG14409
	mov	ecx, DWORD PTR _lpNewQual$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpQualViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpQualViewEntity$[ebp], eax

; 2285 :                                             "QualAttrib", 0 );
; 2286 :    lpSubQualViewEntity = fnValidViewEntity( &lpSubQualViewEntityCsr, lpNewQual,

	push	0
	push	OFFSET $SG14410
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSubQualViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpSubQualViewEntity$[ebp], eax

; 2287 :                                             "SubQualAttrib", 0 );
; 2288 : 
; 2289 :    // Loop through each of the entities in the and look for QualAttribs and
; 2290 :    // SubQualAttribs.
; 2291 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnConvertI
$LN2@fnConvertI:

; 2293 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnConvertI:

; 2292 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@fnConvertI

; 2294 :    {
; 2295 :       LPVIEWENTITY    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$5[ebp], eax

; 2296 :       LPVIEWENTITY    lpSrcViewEntity;
; 2297 :       LPVIEWATTRIB    lpViewAttrib;
; 2298 :       LPVIEWENTITYCSR lpViewEntityCsr;
; 2299 :       LPVIEWENTITYCSR lpTempViewEntityCsr;
; 2300 :       zVIEW           lpSrcView;
; 2301 :       zCHAR           szSrcViewName[ zZEIDON_NAME_LTH + 1 ];
; 2302 :       zCHAR           szTargetEntity[ zZEIDON_NAME_LTH + 1 ];
; 2303 :       zCHAR           szSourceEntity[ zZEIDON_NAME_LTH + 1 ];
; 2304 :       zPCHAR          pchEntityName;
; 2305 :       zBOOL           bFirstTime;
; 2306 : 
; 2307 :       // Find if the current EI is a QualAttrib or a SubQualAttrib.
; 2308 :       if ( lpViewEntity == lpQualViewEntity )

	mov	edx, DWORD PTR _lpViewEntity$5[ebp]
	cmp	edx, DWORD PTR _lpQualViewEntity$[ebp]
	jne	SHORT $LN8@fnConvertI

; 2309 :          lpViewEntityCsr = lpQualViewEntityCsr;

	mov	eax, DWORD PTR _lpQualViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$3[ebp], eax
	jmp	SHORT $LN9@fnConvertI
$LN8@fnConvertI:

; 2310 :       else
; 2311 :       if ( lpViewEntity == lpSubQualViewEntity )

	mov	ecx, DWORD PTR _lpViewEntity$5[ebp]
	cmp	ecx, DWORD PTR _lpSubQualViewEntity$[ebp]
	jne	SHORT $LN10@fnConvertI

; 2312 :          lpViewEntityCsr = lpSubQualViewEntityCsr;

	mov	edx, DWORD PTR _lpSubQualViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$3[ebp], edx
	jmp	SHORT $LN9@fnConvertI
$LN10@fnConvertI:

; 2313 :       else
; 2314 :          continue;      // Skip non-QualAttrib entities.

	jmp	SHORT $LN2@fnConvertI
$LN9@fnConvertI:

; 2315 : 
; 2316 :       fnEstablishViewForInstance( lpNewQual, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 2317 :                                   lpEntityInstance );
; 2318 : 
; 2319 :       pchEntityName = lpViewEntity->szName;

	mov	eax, DWORD PTR _lpViewEntity$5[ebp]
	add	eax, 14					; 0000000eH
	mov	DWORD PTR _pchEntityName$8[ebp], eax

; 2320 : 
; 2321 :       // Skip over entities where the Oper is not "IS".
; 2322 :       if ( CompareAttributeToString( lpNewQual, pchEntityName,
; 2323 :                                      "Oper", "IS" ) != 0 )

	push	OFFSET $SG14416
	push	OFFSET $SG14417
	mov	ecx, DWORD PTR _pchEntityName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	je	SHORT $LN12@fnConvertI

; 2324 :       {
; 2325 :          continue;

	jmp	$LN2@fnConvertI
$LN12@fnConvertI:

; 2326 :       }
; 2327 : 
; 2328 :       // Get the source view.entity and the target entity.
; 2329 :       GetStringFromAttribute( szSrcViewName, lpNewQual, pchEntityName,

	push	OFFSET $SG14418
	mov	ecx, DWORD PTR _pchEntityName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	lea	eax, DWORD PTR _szSrcViewName$11[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 2330 :                               "SourceViewName" );
; 2331 :       if ( szSrcViewName && szSrcViewName[ 0 ] )

	lea	ecx, DWORD PTR _szSrcViewName$11[ebp]
	test	ecx, ecx
	je	SHORT $LN13@fnConvertI
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szSrcViewName$11[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN13@fnConvertI

; 2332 :          GetViewByName( &lpSrcView, szSrcViewName, lpOrigQual, zLEVEL_TASK );

	push	2
	mov	edx, DWORD PTR _lpOrigQual$[ebp]
	push	edx
	lea	eax, DWORD PTR _szSrcViewName$11[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcView$4[ebp]
	push	ecx
	call	_GetViewByName@16
	jmp	SHORT $LN14@fnConvertI
$LN13@fnConvertI:

; 2333 :       else
; 2334 :          GetIntegerFromAttribute( (zPLONG) &lpSrcView, lpNewQual,

	push	OFFSET $SG14421
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcView$4[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16
$LN14@fnConvertI:

; 2335 :                                   pchEntityName, "SourceViewID" );
; 2336 :       GetStringFromAttribute( szSourceEntity, lpNewQual, pchEntityName,

	push	OFFSET $SG14422
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szSourceEntity$10[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 2337 :                               "SourceEntityName" );
; 2338 :       GetStringFromAttribute( szTargetEntity, lpNewQual, pchEntityName,

	push	OFFSET $SG14423
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTargetEntity$9[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 2339 :                               "EntityName" );
; 2340 : 
; 2341 :       // Now change the "IS" to "(key1 = value1 & key2 = value2...)"
; 2342 : 
; 2343 :       // Replace the "IS" with open paren.
; 2344 :       SetAttributeFromString( lpNewQual, pchEntityName, "Oper", "(" );

	push	OFFSET $SG14424
	push	OFFSET $SG14425
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 2345 :       SetAttributeFromString( lpNewQual, pchEntityName, "SourceViewName", "" );

	push	OFFSET $SG14426
	push	OFFSET $SG14427
	mov	ecx, DWORD PTR _pchEntityName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 2346 :       SetAttributeFromString( lpNewQual, pchEntityName, "SourceViewID", "" );

	push	OFFSET $SG14428
	push	OFFSET $SG14429
	mov	eax, DWORD PTR _pchEntityName$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewQual$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 2347 :       SetAttributeFromString( lpNewQual, pchEntityName, "SourceEntityName", "" );

	push	OFFSET $SG14430
	push	OFFSET $SG14431
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 2348 :       SetAttributeFromString( lpNewQual, pchEntityName, "EntityName", "" );

	push	OFFSET $SG14432
	push	OFFSET $SG14433
	mov	ecx, DWORD PTR _pchEntityName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 2349 : 
; 2350 :       // Add a QualAttrib for each key.
; 2351 :       lpSrcViewEntity = fnValidViewEntity( &lpTempViewEntityCsr,

	push	0
	lea	eax, DWORD PTR _szSourceEntity$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTempViewEntityCsr$1[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpSrcViewEntity$2[ebp], eax

; 2352 :                                            lpSrcView, szSourceEntity, 0 );
; 2353 :       bFirstTime = TRUE;

	mov	BYTE PTR _bFirstTime$7[ebp], 1

; 2354 :       for ( lpViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpSrcViewEntity$2[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$6[ebp], eax
	jmp	SHORT $LN7@fnConvertI
$LN5@fnConvertI:

; 2356 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$6[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$6[ebp], eax
$LN7@fnConvertI:

; 2355 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$6[ebp], 0
	je	$LN6@fnConvertI

; 2357 :       {
; 2358 :          if ( lpViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpViewAttrib$6[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN15@fnConvertI

; 2359 :             continue;

	jmp	SHORT $LN5@fnConvertI
$LN15@fnConvertI:

; 2360 : 
; 2361 :          if ( bFirstTime )

	movzx	eax, BYTE PTR _bFirstTime$7[ebp]
	test	eax, eax
	je	SHORT $LN16@fnConvertI

; 2362 :             bFirstTime = FALSE;

	mov	BYTE PTR _bFirstTime$7[ebp], 0
	jmp	SHORT $LN17@fnConvertI
$LN16@fnConvertI:

; 2363 :          else
; 2364 :          {
; 2365 :             // Create the "AND" oper.
; 2366 :             CreateEntity( lpNewQual, pchEntityName, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _pchEntityName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	call	_CreateEntity@12

; 2367 :             SetAttributeFromString( lpNewQual, pchEntityName, "Oper", "AND" );

	push	OFFSET $SG14437
	push	OFFSET $SG14438
	mov	eax, DWORD PTR _pchEntityName$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewQual$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN17@fnConvertI:

; 2368 :          }
; 2369 : 
; 2370 :          // Create the key compare.
; 2371 :          CreateEntity( lpNewQual, pchEntityName, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	call	_CreateEntity@12

; 2372 :          SetAttributeFromString( lpNewQual, pchEntityName, "EntityName",

	lea	ecx, DWORD PTR _szTargetEntity$9[ebp]
	push	ecx
	push	OFFSET $SG14439
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 2373 :                                  szTargetEntity );
; 2374 :          SetAttributeFromString( lpNewQual, pchEntityName, "AttributeName",

	mov	ecx, DWORD PTR _lpViewAttrib$6[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14440
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 2375 :                                  lpViewAttrib->szName );
; 2376 :          SetAttributeFromString( lpNewQual, pchEntityName, "Oper", "=" );

	push	OFFSET $SG14441
	push	OFFSET $SG14442
	mov	ecx, DWORD PTR _pchEntityName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 2377 :          SetAttributeFromAttribute( lpNewQual, pchEntityName, "Value",

	mov	eax, DWORD PTR _lpViewAttrib$6[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szSourceEntity$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$4[ebp]
	push	edx
	push	OFFSET $SG14443
	mov	eax, DWORD PTR _pchEntityName$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewQual$[ebp]
	push	ecx
	call	_SetAttributeFromAttribute@24

; 2378 :                                     lpSrcView, szSourceEntity,
; 2379 :                                     lpViewAttrib->szName );
; 2380 :       } // for ( lpViewAttrib )...

	jmp	$LN5@fnConvertI
$LN6@fnConvertI:

; 2381 : 
; 2382 :       // Create the closing paren.
; 2383 :       CreateEntity( lpNewQual, pchEntityName, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _pchEntityName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewQual$[ebp]
	push	eax
	call	_CreateEntity@12

; 2384 :       SetAttributeFromString( lpNewQual, pchEntityName, "Oper", ")" );

	push	OFFSET $SG14444
	push	OFFSET $SG14445
	mov	ecx, DWORD PTR _pchEntityName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 2385 : 
; 2386 :       // We've just created a number of QualAttribs that we know don't contain
; 2387 :       // the "IS" oper so set lpEntityInstance to skip over the new entities.
; 2388 :       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$3[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2389 : 
; 2390 :    } // for ( lpEntityInstance )...

	jmp	$LN2@fnConvertI
$LN3@fnConvertI:

; 2391 : 
; 2392 :    return( 0 );

	xor	eax, eax

; 2393 : 
; 2394 : } // fnConvertIS_Clause

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnConvertIS_Clause@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_ActivateInfo$ = -232					; size = 24
tv234 = -208						; size = 4
_lPacketData$ = -204					; size = 4
_pvConn$ = -200						; size = 4
_cPacketType$ = -193					; size = 1
_nRC$ = -192						; size = 2
_ActPacket$ = -188					; size = 147
_szAppName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpNetwork$ = 12					; size = 4
_pchAddress$ = 16					; size = 4
_pvReturnView$ = 20					; size = 4
_pchObjName$ = 24					; size = 4
_vSubtask$ = 28						; size = 4
_vQual$ = 32						; size = 4
_lControl$ = 36						; size = 4
_fnNetActivateOI@32 PROC

; 1161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1162 :    zCHAR   cPacketType;
; 1163 :    zLONG   lPacketData;
; 1164 :    zPVOID  pvConn = 0;

	mov	DWORD PTR _pvConn$[ebp], 0

; 1165 :    zCHAR   szAppName[ zZEIDON_NAME_LTH + 1 ];
; 1166 :    zSHORT  nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 1167 : 
; 1168 :    zActivatePacket       ActPacket = { 0 };

	mov	BYTE PTR _ActPacket$[ebp], 0
	push	146					; 00000092H
	push	0
	lea	ecx, DWORD PTR _ActPacket$[ebp+1]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 1169 :    ServDirActivateRecord ActivateInfo = { 0 };

	mov	DWORD PTR _ActivateInfo$[ebp], 0
	xor	edx, edx
	mov	DWORD PTR _ActivateInfo$[ebp+4], edx
	mov	DWORD PTR _ActivateInfo$[ebp+8], edx
	mov	DWORD PTR _ActivateInfo$[ebp+12], edx
	mov	DWORD PTR _ActivateInfo$[ebp+16], edx
	mov	DWORD PTR _ActivateInfo$[ebp+20], edx

; 1170 : 
; 1171 :    fnRetrieveAppName( vSubtask, szAppName );

	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_fnRetrieveAppName@8

; 1172 : 
; 1173 :    // Set up info for activate request.
; 1174 :    ActivateInfo.pszNetworkName         = lpNetwork->szNetworkName;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _ActivateInfo$[ebp], edx

; 1175 :    ActivateInfo.vSubtask               = vSubtask;

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	DWORD PTR _ActivateInfo$[ebp+12], eax

; 1176 :    ActivateInfo.lControl               = lControl;

	mov	ecx, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR _ActivateInfo$[ebp+8], ecx

; 1177 :    ActivateInfo.pszViewOD_Name         = pchObjName;

	mov	edx, DWORD PTR _pchObjName$[ebp]
	mov	DWORD PTR _ActivateInfo$[ebp+16], edx

; 1178 :    ActivateInfo.vQualView              = vQual;

	mov	eax, DWORD PTR _vQual$[ebp]
	mov	DWORD PTR _ActivateInfo$[ebp+20], eax

; 1179 :    ActivateInfo.pszUserSuppliedAddress = pchAddress;

	mov	ecx, DWORD PTR _pchAddress$[ebp]
	mov	DWORD PTR _ActivateInfo$[ebp+4], ecx

; 1180 : 
; 1181 :    // Open connection.
; 1182 :    if ( fnAddConnectionToNetwork( lpTask, lpNetwork, pchAddress,
; 1183 :                                   &pvConn, TRUE, zAPPLREQ_ACTIVATE,
; 1184 :                                   &ActivateInfo, vSubtask ) < 0 )

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	lea	eax, DWORD PTR _ActivateInfo$[ebp]
	push	eax
	push	1
	push	1
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnAddConnectionToNetwork@32
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN4@fnNetActiv

; 1185 :    {
; 1186 :       return( zNETWORK_ERROR );

	mov	eax, -6					; fffffffaH
	jmp	$LN1@fnNetActiv
$LN4@fnNetActiv:

; 1187 :    }
; 1188 : 
; 1189 :    if ( lpNetwork->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	cmp	ecx, 1
	jle	SHORT $LN5@fnNetActiv

; 1190 :       TraceLineS( "(kzoeneta) ** Sending RequestOI packet", "" );

	push	OFFSET $SG14030
	push	OFFSET $SG14031
	call	_TraceLineS@8
$LN5@fnNetActiv:

; 1191 : 
; 1192 :    *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 1193 : 
; 1194 :    //=======================================================================
; 1195 :    // Transmitting data.
; 1196 :    //
; 1197 :    // Until further notice, the following code only SENDS data over the
; 1198 :    // network.
; 1199 :    //=======================================================================
; 1200 : 
; 1201 :    // First send the header for the server driver and then the regular
; 1202 :    // packet for the function structure.
; 1203 :    if ( fnSendHeaderPacket( lpNetwork, &pvConn,
; 1204 :                             zPACKET_REQUESTOI, szAppName ) != 0 )

	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	push	82					; 00000052H
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendHeaderPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN6@fnNetActiv

; 1205 :    {
; 1206 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN6@fnNetActiv:

; 1207 :    }
; 1208 : 
; 1209 :    if ( fnSendTraceSwitches( lpNetwork, &pvConn, lpTask) != 0 )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendTraceSwitches@12
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN7@fnNetActiv

; 1210 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN7@fnNetActiv:

; 1211 : 
; 1212 :    if ( fnSendDataPacket( lpNetwork, &pvConn, zPACKET_REQUESTOI, 0 ) != 0 )

	push	0
	push	82					; 00000052H
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN8@fnNetActiv

; 1213 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN8@fnNetActiv:

; 1214 : 
; 1215 :    // Set up the activate information.  We initialize the structure to 0's so
; 1216 :    // that the network stack can better compress the data.
; 1217 :    zmemset( &ActPacket, 0, sizeof( zActivatePacket ) );

	push	147					; 00000093H
	push	0
	lea	edx, DWORD PTR _ActPacket$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1218 :    zstrcpy( ActPacket.szVersion, zCURRENT_PROTOCOL_VERSION );

	push	OFFSET $SG14035
	lea	eax, DWORD PTR _ActPacket$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1219 :    zltox( lControl, ActPacket.szControl );

	push	16					; 00000010H
	lea	ecx, DWORD PTR _ActPacket$[ebp+35]
	push	ecx
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1220 :    zstrcpy( ActPacket.szObjectDef, pchObjName );

	mov	eax, DWORD PTR _pchObjName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ActPacket$[ebp+3]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1221 :    if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $LN9@fnNetActiv

; 1222 :       ActPacket.cUseQualification = 'Y';

	mov	BYTE PTR _ActPacket$[ebp+44], 89	; 00000059H
	jmp	SHORT $LN10@fnNetActiv
$LN9@fnNetActiv:

; 1223 :    else
; 1224 :       ActPacket.cUseQualification = 'N';

	mov	BYTE PTR _ActPacket$[ebp+44], 78	; 0000004eH
$LN10@fnNetActiv:

; 1225 : 
; 1226 :    zstrcpy( ActPacket.szAppName, szAppName );

	lea	edx, DWORD PTR _szAppName$[ebp]
	push	edx
	lea	eax, DWORD PTR _ActPacket$[ebp+45]
	push	eax
	call	_strcpy
	add	esp, 8

; 1227 :    SysGetUserID( vSubtask, ActPacket.szUserName, ActPacket.szPassword );

	lea	ecx, DWORD PTR _ActPacket$[ebp+111]
	push	ecx
	lea	edx, DWORD PTR _ActPacket$[ebp+78]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysGetUserID@12

; 1228 : 
; 1229 :    if ( lpNetwork->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	cmp	edx, 1
	jle	SHORT $LN11@fnNetActiv

; 1230 :    {
; 1231 :       TraceLine( "(kzoeneta) ** Sending Activate Packet ... ApplName: %s  "

	lea	eax, DWORD PTR _ActPacket$[ebp+78]
	push	eax
	lea	ecx, DWORD PTR _ActPacket$[ebp+3]
	push	ecx
	lea	edx, DWORD PTR _ActPacket$[ebp+45]
	push	edx
	push	OFFSET $SG14039
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN11@fnNetActiv:

; 1232 :                    "Object Def: %s  User Name: %s",
; 1233 :                  ActPacket.szAppName, ActPacket.szObjectDef,
; 1234 :                  ActPacket.szUserName );
; 1235 :    }
; 1236 : 
; 1237 :    // Send server activate info.
; 1238 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 1239 :                                 &ActPacket, sizeof( zActivatePacket ),
; 1240 :                                 zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	147					; 00000093H
	lea	eax, DWORD PTR _ActPacket$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+170]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@fnNetActiv

; 1241 :    {
; 1242 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN12@fnNetActiv:

; 1243 :    }
; 1244 : 
; 1245 :    // If we have a qualification object, then send it.
; 1246 :    if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $LN13@fnNetActiv

; 1247 :    {
; 1248 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN14@fnNetActiv

; 1249 :          TraceLineS( "(kzoeneta) ** Sending qualification OI", "" );

	push	OFFSET $SG14043
	push	OFFSET $SG14044
	call	_TraceLineS@8
$LN14@fnNetActiv:

; 1250 : 
; 1251 :       if ( fnSendOI( &pvConn, lpNetwork, vQual, 0 ) == zCALL_ERROR )

	push	0
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	call	_fnSendOI@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN13@fnNetActiv

; 1252 :          goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN13@fnNetActiv:

; 1253 :    }
; 1254 : 
; 1255 :    // Tell network handler to flush the send buffer.
; 1256 :    if ( fnFlushBuffer( lpNetwork, &pvConn ) != 0 )

	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnFlushBuffer@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN16@fnNetActiv

; 1257 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN16@fnNetActiv:

; 1258 : 
; 1259 :    //=======================================================================
; 1260 :    // Receiving data.
; 1261 :    //
; 1262 :    // From here until we close the connection we will only RECEIVE data over
; 1263 :    // the network.
; 1264 :    //=======================================================================
; 1265 : 
; 1266 :    // Wait for Ack.
; 1267 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lPacketData ) != 0 )

	lea	eax, DWORD PTR _lPacketData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cPacketType$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnReceiveDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN17@fnNetActiv

; 1268 :    {
; 1269 :       TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );

	push	OFFSET $SG14048
	push	OFFSET $SG14049
	call	_TraceLineS@8

; 1270 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN17@fnNetActiv:

; 1271 :    }
; 1272 : 
; 1273 :    switch ( cPacketType )

	movsx	edx, BYTE PTR _cPacketType$[ebp]
	mov	DWORD PTR tv234[ebp], edx
	mov	eax, DWORD PTR tv234[ebp]
	sub	eax, 35					; 00000023H
	mov	DWORD PTR tv234[ebp], eax
	cmp	DWORD PTR tv234[ebp], 66		; 00000042H
	ja	$LN29@fnNetActiv
	mov	ecx, DWORD PTR tv234[ebp]
	movzx	edx, BYTE PTR $LN35@fnNetActiv[ecx]
	jmp	DWORD PTR $LN36@fnNetActiv[edx*4]
$LN18@fnNetActiv:

; 1274 :    {
; 1275 :       case zPACKET_ACK:
; 1276 :          // We got an ACK, so continue OK.
; 1277 :          if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN19@fnNetActiv

; 1278 :          {
; 1279 :             TraceLineS( "(kzoeneta) ** Received Act ACK - proceeding with Act", "" );

	push	OFFSET $SG14052
	push	OFFSET $SG14053
	call	_TraceLineS@8

; 1280 :             TraceLineS( "(kzoeneta) ** Receiving activated OI.", "" );

	push	OFFSET $SG14054
	push	OFFSET $SG14055
	call	_TraceLineS@8
$LN19@fnNetActiv:

; 1281 :          }
; 1282 : 
; 1283 :          nRC = fnReceiveOI( &pvConn, lpNetwork, pvReturnView,

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchObjName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	call	_fnReceiveOI@24
	mov	WORD PTR _nRC$[ebp], ax

; 1284 :                             vSubtask, pchObjName, lControl );
; 1285 :          break;

	jmp	$LN2@fnNetActiv
$LN20@fnNetActiv:

; 1286 : 
; 1287 :       case zPACKET_EMPTYOI:
; 1288 :          // This means that the server didn't find anything to activate and
; 1289 :          // is returning an empty OI.  Instead of actually returning it from
; 1290 :          // the server (and wasting time on the network), we'll just activate
; 1291 :          // it here.
; 1292 :          ActivateEmptyObjectInstance( pvReturnView, pchObjName,

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchObjName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	push	edx
	call	_ActivateEmptyObjectInstance@16

; 1293 :                                       vSubtask, lControl );
; 1294 :          break;

	jmp	$LN2@fnNetActiv
$LN21@fnNetActiv:

; 1295 : 
; 1296 :       case zPACKET_ERROR:
; 1297 :          TraceLineI( "(kzoeneta) ** Network error #", lPacketData );

	mov	eax, DWORD PTR _lPacketData$[ebp]
	push	eax
	push	OFFSET $SG14058
	call	_TraceLineI@8

; 1298 :          if ( lPacketData == zNETERR_INVALIDAPP )

	cmp	DWORD PTR _lPacketData$[ebp], 1
	jne	SHORT $LN22@fnNetActiv

; 1299 :          {
; 1300 :             fnSysMessageBox( lpTask, "Application not defined on Server",

	push	0
	lea	ecx, DWORD PTR _ActPacket$[ebp+45]
	push	ecx
	push	OFFSET $SG14061
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 1301 :                              ActPacket.szAppName, 0 );
; 1302 :          }

	jmp	SHORT $LN23@fnNetActiv
$LN22@fnNetActiv:

; 1303 :          else
; 1304 :          if ( lPacketData == zNETERR_OUTOFMEMORY )

	cmp	DWORD PTR _lPacketData$[ebp], 3
	jne	SHORT $LN24@fnNetActiv

; 1305 :          {
; 1306 :             fnSysMessageBox( lpTask, "Server Transaction Crash ",

	push	1
	push	OFFSET $SG14064
	push	OFFSET $SG14065
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 1307 :                              "*Out Of Memory*", 1 );
; 1308 :          }

	jmp	SHORT $LN23@fnNetActiv
$LN24@fnNetActiv:

; 1309 :          else
; 1310 :             fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, vSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnRetrieveMsgAndTraceObj@12
$LN23@fnNetActiv:

; 1311 : 
; 1312 :          goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN26@fnNetActiv:

; 1313 : 
; 1314 :       case zPACKET_RC:
; 1315 :          // If we received the RC packet, then there was an error activating
; 1316 :          // the OI on the server.  Get the return code and go to the end of
; 1317 :          // the function.
; 1318 :          if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN27@fnNetActiv

; 1319 :             TraceLineS( "(kzoeneta) ** Received RC - error in Commit", "" );

	push	OFFSET $SG14068
	push	OFFSET $SG14069
	call	_TraceLineS@8
$LN27@fnNetActiv:

; 1320 : 
; 1321 :          if ( fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, vSubtask ) < 0 )

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnRetrieveMsgAndTraceObj@12
	cwde
	test	eax, eax
	jge	SHORT $LN28@fnNetActiv

; 1322 :             goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN28@fnNetActiv:

; 1323 : 
; 1324 :          nRC = (zSHORT) lPacketData;

	mov	cx, WORD PTR _lPacketData$[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 1325 :          goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN29@fnNetActiv:

; 1326 : 
; 1327 :       default:
; 1328 :          TraceLineS( "(kzoeneta) ** Received unknown Packet!", "" );

	push	OFFSET $SG14072
	push	OFFSET $SG14073
	call	_TraceLineS@8

; 1329 :          goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN2@fnNetActiv:

; 1330 :    }
; 1331 : 
; 1332 :    // Get return code.
; 1333 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lPacketData ) != 0 )

	lea	edx, DWORD PTR _lPacketData$[ebp]
	push	edx
	lea	eax, DWORD PTR _cPacketType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnReceiveDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN30@fnNetActiv

; 1334 :    {
; 1335 :       TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );

	push	OFFSET $SG14075
	push	OFFSET $SG14076
	call	_TraceLineS@8

; 1336 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 1337 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$37
$LN30@fnNetActiv:

; 1338 :    }
; 1339 : 
; 1340 :    if ( cPacketType != zPACKET_RC )

	movsx	edx, BYTE PTR _cPacketType$[ebp]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN31@fnNetActiv

; 1341 :    {
; 1342 :       TraceLineS( "(kzoeneta) ** No return code for Commit!", "" );

	push	OFFSET $SG14078
	push	OFFSET $SG14079
	call	_TraceLineS@8

; 1343 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 1344 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$37
$LN31@fnNetActiv:

; 1345 :    }
; 1346 : 
; 1347 :    nRC = (zSHORT) lPacketData;

	mov	cx, WORD PTR _lPacketData$[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 1348 : 
; 1349 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN32@fnNetActiv

; 1350 :    {
; 1351 :       TraceLineI( "(kzoeneta) ** RC from activate = ", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG14081
	call	_TraceLineI@8
$LN32@fnNetActiv:

; 1352 :    }
; 1353 : 
; 1354 :    if ( fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, vSubtask ) < 0 )

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnRetrieveMsgAndTraceObj@12
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $EndOfFunction$37

; 1355 :    {
; 1356 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$37:

; 1357 :       goto EndOfFunction;
; 1358 :    }
; 1359 : 
; 1360 : EndOfFunction:
; 1361 :    fnRemoveConnectionFromNetwork( lpNetwork, &pvConn, TRUE );

	push	1
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnRemoveConnectionFromNetwork@12

; 1362 : 
; 1363 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnNetActiv:

; 1364 : 
; 1365 : } // fnNetActivateOI

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	2
$LN36@fnNetActiv:
	DD	$LN26@fnNetActiv
	DD	$LN21@fnNetActiv
	DD	$LN18@fnNetActiv
	DD	$LN20@fnNetActiv
	DD	$LN29@fnNetActiv
$LN35@fnNetActiv:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnNetActivateOI@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_szTimestamp$ = -24					; size = 19
__$ArrayPad$ = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_lpTask$ = 16						; size = 4
_fnSendTimestamp@12 PROC

; 1131 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1132 :    zCHAR  szTimestamp[ L_TIMESTAMP_MSG + 1 ];
; 1133 : 
; 1134 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_TIMESTAMP,
; 1135 :                           L_TIMESTAMP_MSG  ) != 0 )

	push	18					; 00000012H
	push	84					; 00000054H
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendDataPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@fnSendTime

; 1136 :    {
; 1137 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendTime
$LN2@fnSendTime:

; 1138 :    }
; 1139 : 
; 1140 :    // Send server the timestamp message.
; 1141 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,
; 1142 :                                 szTimestamp, L_TRACE_SWITCH_MSG,
; 1143 :                                 zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	6
	lea	eax, DWORD PTR _szTimestamp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+170]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@fnSendTime

; 1144 :    {
; 1145 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendTime
$LN3@fnSendTime:

; 1146 :    }
; 1147 : 
; 1148 :    return( 0 );

	xor	eax, eax
$LN1@fnSendTime:

; 1149 : 
; 1150 : } // fnSendTimestamp

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSendTimestamp@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_szTraceSwitch$ = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_lpTask$ = 16						; size = 4
_fnSendTraceSwitches@12 PROC

; 1101 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1102 :    zCHAR  szTraceSwitch[ L_TRACE_SWITCH_MSG + 1 ];
; 1103 : 
; 1104 :    zsprintf( szTraceSwitch, "%2.2hd", lpNetwork->nServerCoreTraceLevel );

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+142]
	push	ecx
	push	OFFSET $SG13980
	lea	edx, DWORD PTR _szTraceSwitch$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1105 : // zsprintf( szTraceSwitch + 2, "%2.2hd", lpTask->nDBHandlerTraceLevel );
; 1106 :    zsprintf( szTraceSwitch + 2, "%2.2hd", lpNetwork->nServerDBHTraceLevel );

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+146]
	push	ecx
	push	OFFSET $SG13981
	lea	edx, DWORD PTR _szTraceSwitch$[ebp+2]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1107 :    zsprintf( szTraceSwitch + 4, "%2.2hd", lpNetwork->nServerNetTraceLevel );

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+144]
	push	ecx
	push	OFFSET $SG13982
	lea	edx, DWORD PTR _szTraceSwitch$[ebp+4]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1108 : 
; 1109 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_TRACESWITCH,
; 1110 :                           L_TRACE_SWITCH_MSG  ) != 0 )

	push	6
	push	43					; 0000002bH
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendDataPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@fnSendTrac

; 1111 :    {
; 1112 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendTrac
$LN2@fnSendTrac:

; 1113 :    }
; 1114 : 
; 1115 :    // Send server the trace switch message.
; 1116 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,
; 1117 :                                 szTraceSwitch, L_TRACE_SWITCH_MSG,
; 1118 :                                 zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	6
	lea	eax, DWORD PTR _szTraceSwitch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+170]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@fnSendTrac

; 1119 :    {
; 1120 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendTrac
$LN3@fnSendTrac:

; 1121 :    }
; 1122 : 
; 1123 :    return( 0 );

	xor	eax, eax
$LN1@fnSendTrac:

; 1124 : 
; 1125 : } // fnSendTraceSwitches

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSendTraceSwitches@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpViewOI$ = -12					; size = 4
_lpViewCsr$ = -8					; size = 4
_lpEntityInstance$ = -4					; size = 4
_lpView$ = 8						; size = 4
_fnEmptyOI@4 PROC

; 1059 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1060 :    LPVIEWCSR         lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1061 :    LPVIEWOI          lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1062 :    LPENTITYINSTANCE  lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1063 : 
; 1064 :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN4@fnEmptyOI

; 1065 :       return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@fnEmptyOI
$LN4@fnEmptyOI:

; 1066 : 
; 1067 :    if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN2@fnEmptyOI

; 1068 :       return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@fnEmptyOI
$LN2@fnEmptyOI:

; 1069 : 
; 1070 :    while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN3@fnEmptyOI

; 1071 :    {
; 1072 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1073 :       if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN6@fnEmptyOI

; 1074 :          break;

	jmp	SHORT $LN3@fnEmptyOI
$LN6@fnEmptyOI:

; 1075 :    }

	jmp	SHORT $LN2@fnEmptyOI
$LN3@fnEmptyOI:

; 1076 : 
; 1077 :    if ( lpEntityInstance->u.nInd.bHidden &&

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN7@fnEmptyOI
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN8@fnEmptyOI
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN7@fnEmptyOI
$LN8@fnEmptyOI:

; 1078 :         (lpEntityInstance->u.nInd.bCreated ||
; 1079 :          lpEntityInstance->u.nInd.bDeleted == FALSE) )
; 1080 : 
; 1081 :    {
; 1082 :       return( TRUE );

	mov	al, 1
	jmp	SHORT $LN1@fnEmptyOI
$LN7@fnEmptyOI:

; 1083 :    }
; 1084 : 
; 1085 :    return( FALSE );

	xor	al, al
$LN1@fnEmptyOI:

; 1086 : 
; 1087 : } // fnEmptyOI

	mov	esp, ebp
	pop	ebp
	ret	4
_fnEmptyOI@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
tv76 = -12						; size = 4
_nRC2$ = -8						; size = 2
_nRC1$ = -4						; size = 2
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_vSubtask$ = 16						; size = 4
_fnRetrieveMsgAndTraceObj@12 PROC

; 1049 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1050 :    zSHORT nRC1, nRC2;
; 1051 :    nRC1 = fnRetrieveMessageObject( lpNetwork, ppvConn, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnRetrieveMessageObject@12
	mov	WORD PTR _nRC1$[ebp], ax

; 1052 :    nRC2 = fnRetrieveTraceObj( lpNetwork, ppvConn, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnRetrieveTraceObj@12
	mov	WORD PTR _nRC2$[ebp], ax

; 1053 :    return( nRC1 == 0 ? nRC2 : nRC1 );

	movsx	eax, WORD PTR _nRC1$[ebp]
	test	eax, eax
	jne	SHORT $LN3@fnRetrieve
	movsx	ecx, WORD PTR _nRC2$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	jmp	SHORT $LN4@fnRetrieve
$LN3@fnRetrieve:
	movsx	edx, WORD PTR _nRC1$[ebp]
	mov	DWORD PTR tv76[ebp], edx
$LN4@fnRetrieve:
	mov	ax, WORD PTR tv76[ebp]

; 1054 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnRetrieveMsgAndTraceObj@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pchFlag$ = -308					; size = 4
$T1 = -304						; size = 4
_vTrace$ = -300						; size = 4
_nRC$ = -296						; size = 2
_cLine$2 = -292						; size = 255
_cDTime$3 = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_vSubtask$ = 16						; size = 4
_fnRetrieveTraceObj@12 PROC

; 994  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 308				; 00000134H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 995  :    zPCHAR pchFlag;
; 996  :    zVIEW  vTrace;
; 997  :    zSHORT nRC;
; 998  : 
; 999  :    // Retrieve the 1-byte flag indicating whether a trace object was sent.
; 1000 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 1001 :                                    &pchFlag, 1, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	1
	lea	eax, DWORD PTR _pchFlag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN4@fnRetrieve

; 1002 :    {
; 1003 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Trace flag.", "" );

	push	OFFSET $SG13921
	push	OFFSET $SG13922
	call	_TraceLineS@8

; 1004 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN9@fnRetrieve
$LN4@fnRetrieve:

; 1005 :    }
; 1006 : 
; 1007 :    // If the flag indicates that a message object was sent, then retrieve it.
; 1008 :    if ( pchFlag[ 0 ] == szlTrue[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchFlag$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	ecx, BYTE PTR _szlTrue[edx]
	cmp	eax, ecx
	jne	$LN5@fnRetrieve

; 1009 :    {
; 1010 :       if ( fnReceiveOI( ppvConn, lpNetwork, &vTrace, vSubtask, "KZTRACEO",
; 1011 :                         zSINGLE | zACTIVATE_SYSTEM ) == zCALL_ERROR )

	push	536870912				; 20000000H
	push	OFFSET $SG13925
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTrace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	call	_fnReceiveOI@24
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN6@fnRetrieve

; 1012 :       {
; 1013 :          TraceLineS( "(kzoeneta) ** Couldn't retrieve Trace object.", "" );

	push	OFFSET $SG13926
	push	OFFSET $SG13927
	call	_TraceLineS@8

; 1014 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN9@fnRetrieve
$LN6@fnRetrieve:

; 1015 :       }
; 1016 : 
; 1017 :       nRC = SetCursorFirstEntity ( vTrace, "Line", "Trace" );

	push	OFFSET $SG13928
	push	OFFSET $SG13929
	mov	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1018 :       if ( nRC == zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN7@fnRetrieve

; 1019 :       {
; 1020 :          zCHAR cDTime[ 32 ];
; 1021 :          GetStringFromAttribute( cDTime, vTrace,"Trace", "TraceStart" );

	push	OFFSET $SG13931
	push	OFFSET $SG13932
	mov	eax, DWORD PTR _vTrace$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cDTime$3[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1022 :          TraceLineS( "(kzoeneta) ** Start Server Trace: ", cDTime );

	lea	edx, DWORD PTR _cDTime$3[ebp]
	push	edx
	push	OFFSET $SG13933
	call	_TraceLineS@8
$LN2@fnRetrieve:

; 1023 :          while ( nRC == zCURSOR_SET )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN3@fnRetrieve

; 1024 :          {
; 1025 :            zCHAR cLine[ 255 ];
; 1026 :            cLine[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 255			; 000000ffH
	jae	SHORT $LN10@fnRetrieve
	jmp	SHORT $LN11@fnRetrieve
$LN10@fnRetrieve:
	call	___report_rangecheckfailure
$LN11@fnRetrieve:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _cLine$2[ebp+eax], 0

; 1027 :            GetStringFromAttribute( cLine, vTrace, "Line", "Line" );

	push	OFFSET $SG13934
	push	OFFSET $SG13935
	mov	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cLine$2[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 1028 :            if ( cLine[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _cLine$2[ebp+ecx]
	test	edx, edx
	je	SHORT $LN8@fnRetrieve

; 1029 :               TraceLineS( "(kzoeneta) ** Line: ", cLine );

	lea	eax, DWORD PTR _cLine$2[ebp]
	push	eax
	push	OFFSET $SG13937
	call	_TraceLineS@8
$LN8@fnRetrieve:

; 1030 : 
; 1031 :            nRC = SetCursorNextEntity( vTrace, "Line", "Trace" );

	push	OFFSET $SG13938
	push	OFFSET $SG13939
	mov	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 1032 :          } // while

	jmp	$LN2@fnRetrieve
$LN3@fnRetrieve:

; 1033 : 
; 1034 :          GetStringFromAttribute( cDTime, vTrace,"Trace", "TraceEnd" );

	push	OFFSET $SG13940
	push	OFFSET $SG13941
	mov	edx, DWORD PTR _vTrace$[ebp]
	push	edx
	lea	eax, DWORD PTR _cDTime$3[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 1035 :          TraceLineS( "(kzoeneta) ** End Server Trace: ", cDTime );

	lea	ecx, DWORD PTR _cDTime$3[ebp]
	push	ecx
	push	OFFSET $SG13942
	call	_TraceLineS@8
$LN7@fnRetrieve:

; 1036 :       }
; 1037 : 
; 1038 :       DropObjectInstance( vTrace );

	mov	edx, DWORD PTR _vTrace$[ebp]
	push	edx
	call	_DropObjectInstance@4
$LN5@fnRetrieve:

; 1039 :    }
; 1040 : 
; 1041 :    return( 0 );

	xor	eax, eax
$LN9@fnRetrieve:

; 1042 : 
; 1043 : } // fnRetrieveTraceObj

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnRetrieveTraceObj@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pchFlag$ = -28						; size = 4
_vLocalMsg$ = -24					; size = 4
_lc$1 = -20						; size = 4
_vMessage$ = -16					; size = 4
_vCopy$2 = -12						; size = 4
_nRC$ = -8						; size = 2
_nc$3 = -4						; size = 2
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_vSubtask$ = 16						; size = 4
_fnRetrieveMessageObject@12 PROC

; 919  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 920  :    zPCHAR pchFlag;
; 921  :    zVIEW  vMessage, vLocalMsg;
; 922  :    zSHORT nRC;
; 923  : 
; 924  :    // Retrieve the 1-byte flag indicating whether a message object was sent.
; 925  :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 926  :                                    &pchFlag, 1, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	1
	lea	eax, DWORD PTR _pchFlag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN6@fnRetrieve

; 927  :    {
; 928  :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Message flag.", "" );

	push	OFFSET $SG13886
	push	OFFSET $SG13887
	call	_TraceLineS@8

; 929  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnRetrieve
$LN6@fnRetrieve:

; 930  :    }
; 931  : 
; 932  :    // If the flag indicates that a message object was sent, then retrieve it.
; 933  :    if ( pchFlag[ 0 ] == szlTrue[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchFlag$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	ecx, BYTE PTR _szlTrue[edx]
	cmp	eax, ecx
	jne	$LN7@fnRetrieve

; 934  :    {
; 935  :       zVIEW vCopy = 0;

	mov	DWORD PTR _vCopy$2[ebp], 0

; 936  : 
; 937  :       if ( fnReceiveOI( ppvConn, lpNetwork, &vMessage, vSubtask, "kzmsgqoo",
; 938  :                         zSINGLE ) == zCALL_ERROR )

	push	0
	push	OFFSET $SG13890
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	call	_fnReceiveOI@24
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN8@fnRetrieve

; 939  :       {
; 940  :          TraceLineS( "(kzoeneta) ** Couldn't retrieve Message object.", "" );

	push	OFFSET $SG13891
	push	OFFSET $SG13892
	call	_TraceLineS@8

; 941  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnRetrieve
$LN8@fnRetrieve:

; 942  :       }
; 943  : 
; 944  :       nRC = MessagePresent( vSubtask, 0, vMessage );

	mov	ecx, DWORD PTR _vMessage$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_MessagePresent@12
	mov	WORD PTR _nRC$[ebp], ax

; 945  : 
; 946  :       // Copy the DBH_Error entities to the local message Object.
; 947  :       vLocalMsg = fnCreateMsgObj( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_fnCreateMsgObj@4
	mov	DWORD PTR _vLocalMsg$[ebp], eax

; 948  :       if ( TestMsgObjDef( vLocalMsg ) != 0 &&

	mov	ecx, DWORD PTR _vLocalMsg$[ebp]
	push	ecx
	call	_TestMsgObjDef
	add	esp, 4
	movsx	edx, ax
	test	edx, edx
	je	$LN9@fnRetrieve
	push	0
	mov	eax, DWORD PTR _vLocalMsg$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vCopy$2[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12
	movsx	edx, ax
	test	edx, edx
	jl	$LN9@fnRetrieve

; 949  :            CreateViewFromViewForTask( &vCopy, vLocalMsg, 0 ) >= 0 )
; 950  :       {
; 951  :          zSHORT nc;
; 952  :          zLONG  lc;
; 953  : 
; 954  :          // Copy over all the DBH_Error entities.
; 955  :          nc = SetCursorFirstEntity( vMessage, "DBH_Error", 0 );

	push	0
	push	OFFSET $SG13894
	mov	eax, DWORD PTR _vMessage$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nc$3[ebp], ax
$LN2@fnRetrieve:

; 956  :          while ( nc >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nc$3[ebp]
	test	ecx, ecx
	jl	SHORT $LN3@fnRetrieve

; 957  :          {
; 958  :             if ( CreateEntity( vCopy, "DBH_Error", zPOS_LAST ) < 0 )

	push	2
	push	OFFSET $SG13896
	mov	edx, DWORD PTR _vCopy$2[ebp]
	push	edx
	call	_CreateEntity@12
	cwde
	test	eax, eax
	jge	SHORT $LN10@fnRetrieve

; 959  :                break;

	jmp	SHORT $LN3@fnRetrieve
$LN10@fnRetrieve:

; 960  : 
; 961  :             SetMatchingAttributesByName( vCopy, "DBH_Error",

	push	3
	push	OFFSET $SG13897
	mov	ecx, DWORD PTR _vMessage$[ebp]
	push	ecx
	push	OFFSET $SG13898
	mov	edx, DWORD PTR _vCopy$2[ebp]
	push	edx
	call	_SetMatchingAttributesByName@20

; 962  :                                          vMessage, "DBH_Error", zSET_ALL );
; 963  :             nc = SetCursorNextEntity( vMessage, "DBH_Error", 0 );

	push	0
	push	OFFSET $SG13899
	mov	eax, DWORD PTR _vMessage$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nc$3[ebp], ax

; 964  :          }

	jmp	SHORT $LN2@fnRetrieve
$LN3@fnRetrieve:

; 965  : 
; 966  :          // Make sure that there are not more than 100 DBH_Error's.
; 967  :          lc = CountEntitiesForView( vCopy, "DBH_Error") - 100;

	push	OFFSET $SG13900
	mov	ecx, DWORD PTR _vCopy$2[ebp]
	push	ecx
	call	_CountEntitiesForView@8
	sub	eax, 100				; 00000064H
	mov	DWORD PTR _lc$1[ebp], eax

; 968  :          if ( lc > 0 )

	cmp	DWORD PTR _lc$1[ebp], 0
	jle	SHORT $LN11@fnRetrieve

; 969  :          {
; 970  :             SetCursorFirstEntity( vCopy, "DBH_Error", 0 );

	push	0
	push	OFFSET $SG13902
	mov	edx, DWORD PTR _vCopy$2[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
$LN4@fnRetrieve:

; 971  : 
; 972  :             while ( lc > 0 )

	cmp	DWORD PTR _lc$1[ebp], 0
	jle	SHORT $LN11@fnRetrieve

; 973  :             {
; 974  :                DeleteEntity( vCopy, "DBH_Error", zREPOS_FIRST );

	push	1
	push	OFFSET $SG13903
	mov	eax, DWORD PTR _vCopy$2[ebp]
	push	eax
	call	_DeleteEntity@12

; 975  :                lc--;

	mov	ecx, DWORD PTR _lc$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _lc$1[ebp], ecx

; 976  :             }

	jmp	SHORT $LN4@fnRetrieve
$LN11@fnRetrieve:

; 977  :          }
; 978  : 
; 979  :          DropView( vCopy );

	mov	edx, DWORD PTR _vCopy$2[ebp]
	push	edx
	call	_DropView@4
$LN9@fnRetrieve:

; 980  :       }
; 981  : 
; 982  :       DropObjectInstance( vMessage );

	mov	eax, DWORD PTR _vMessage$[ebp]
	push	eax
	call	_DropObjectInstance@4

; 983  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnRetrieve
$LN7@fnRetrieve:

; 984  :    }
; 985  : 
; 986  :    return( 0 );

	xor	eax, eax
$LN1@fnRetrieve:

; 987  : 
; 988  : } // fnRetrieveMessageObject

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnRetrieveMessageObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
tv76 = -12						; size = 4
_nRC2$ = -8						; size = 2
_nRC1$ = -4						; size = 2
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_vSubtask$ = 16						; size = 4
_fnSendMsgAndTraceObj@12 PROC

; 882  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 883  :   zSHORT nRC1, nRC2;
; 884  :   nRC1 = fnSendMessageObject( lpNetwork, ppvConn, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendMessageObject@12
	mov	WORD PTR _nRC1$[ebp], ax

; 885  :   nRC2 = fnSendTraceObj( lpNetwork, ppvConn, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendTraceObj@12
	mov	WORD PTR _nRC2$[ebp], ax

; 886  :   return( nRC1 == 0 ? nRC2 : nRC1 );

	movsx	eax, WORD PTR _nRC1$[ebp]
	test	eax, eax
	jne	SHORT $LN3@fnSendMsgA
	movsx	ecx, WORD PTR _nRC2$[ebp]
	mov	DWORD PTR tv76[ebp], ecx
	jmp	SHORT $LN4@fnSendMsgA
$LN3@fnSendMsgA:
	movsx	edx, WORD PTR _nRC1$[ebp]
	mov	DWORD PTR tv76[ebp], edx
$LN4@fnSendMsgA:
	mov	ax, WORD PTR tv76[ebp]

; 887  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSendMsgAndTraceObj@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_vTrace$ = -28						; size = 4
_szDateTime$1 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_vSubtask$ = 16						; size = 4
_fnSendTraceObj@12 PROC

; 837  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 838  :    zVIEW  vTrace = 0;

	mov	DWORD PTR _vTrace$[ebp], 0

; 839  : 
; 840  :    GetViewByName( &vTrace, "KZTRACEO", vSubtask, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG13821
	lea	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	call	_GetViewByName@16

; 841  : 
; 842  :    if ( vTrace )

	cmp	DWORD PTR _vTrace$[ebp], 0
	je	$LN2@fnSendTrac

; 843  :    {
; 844  :       zCHAR szDateTime[ 18 ];
; 845  : 
; 846  :       SysGetDateTime( szDateTime );  // DateTime yyyymmddhhmmssttt

	lea	edx, DWORD PTR _szDateTime$1[ebp]
	push	edx
	call	_SysGetDateTime@4

; 847  :       SetAttributeFromVariable( vTrace, "Trace", "TraceEnd",

	push	0
	push	OFFSET $SG13824
	push	17					; 00000011H
	push	83					; 00000053H
	lea	eax, DWORD PTR _szDateTime$1[ebp]
	push	eax
	push	OFFSET $SG13825
	push	OFFSET $SG13826
	mov	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	call	_SetAttributeFromVariable@32

; 848  :                                 szDateTime, zTYPE_STRING, 17, "DateTime", 0 );
; 849  : 
; 850  :       // Send flag to indicate we are sending a Trace object.
; 851  :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,
; 852  :                                    szlTrue, 1, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	1
	push	OFFSET _szlTrue
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+170]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN4@fnSendTrac

; 853  :       {
; 854  :          TraceLineS( "(kzoeneta) ** Unable to send Trace Object Flag", "" );

	push	OFFSET $SG13828
	push	OFFSET $SG13829
	call	_TraceLineS@8

; 855  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendTrac
$LN4@fnSendTrac:

; 856  :       }
; 857  : 
; 858  :       if ( fnSendOI( ppvConn, lpNetwork, vTrace, 0 ) == zCALL_ERROR )

	push	0
	mov	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	call	_fnSendOI@16
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN5@fnSendTrac

; 859  :       {
; 860  :          TraceLineS( "(kzoeneta) ** Unable to send Trace object!", "" );

	push	OFFSET $SG13831
	push	OFFSET $SG13832
	call	_TraceLineS@8

; 861  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendTrac
$LN5@fnSendTrac:

; 862  :       }
; 863  :    }

	jmp	SHORT $LN3@fnSendTrac
$LN2@fnSendTrac:

; 864  :    else
; 865  :    {
; 866  :       // Send flag to indicate that there is no Trace object.
; 867  :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,
; 868  :                                    szlFalse, 1, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	1
	push	OFFSET _szlFalse
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+170]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN3@fnSendTrac

; 869  :       {
; 870  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendTrac
$LN3@fnSendTrac:

; 871  :       }
; 872  :    }
; 873  : 
; 874  :    return( 0 );

	xor	eax, eax
$LN1@fnSendTrac:

; 875  : 
; 876  : } // fnSendTraceObj

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSendTraceObj@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_vMessage$ = -16					; size = 4
_vMsgQ$ = -12						; size = 4
_nNewMsgObj$1 = -8					; size = 2
_nRC$ = -4						; size = 2
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_vSubtask$ = 16						; size = 4
_fnSendMessageObject@12 PROC

; 756  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 757  :    zVIEW  vMessage = 0;

	mov	DWORD PTR _vMessage$[ebp], 0

; 758  :    zVIEW  vMsgQ;
; 759  :    zSHORT nRC;
; 760  : 
; 761  :    GetViewByName( &vMsgQ, szl__MSGQ, vSubtask, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szl__MSGQ
	push	ecx
	lea	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_GetViewByName@16

; 762  :    if ( vMsgQ )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	je	$LN8@fnSendMess

; 763  :    {
; 764  :       // The message object contains the messages for all tasks that belong
; 765  :       // to the same application.  Since we only want to send the messages
; 766  :       // for the current task, we will create a temp message object to send
; 767  :       // to the client with just the messages for the current task.  We only
; 768  :       // care about it if messages (or DBH error messages) exist.
; 769  : 
; 770  :       zSHORT nNewMsgObj = TestMsgObjDef( vMsgQ );

	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_TestMsgObjDef
	add	esp, 4
	mov	WORD PTR _nNewMsgObj$1[ebp], ax

; 771  : 
; 772  :       if ( CheckExistenceOfEntity( vMsgQ, "QMsg" ) == zCURSOR_SET ||

	push	OFFSET $SG13795
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN10@fnSendMess
	movsx	eax, WORD PTR _nNewMsgObj$1[ebp]
	test	eax, eax
	je	$LN8@fnSendMess
	push	OFFSET $SG13796
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_CheckExistenceOfEntity@8
	movsx	edx, ax
	test	edx, edx
	jne	$LN8@fnSendMess
$LN10@fnSendMess:

; 773  :            (nNewMsgObj &&
; 774  :             CheckExistenceOfEntity( vMsgQ, "DBH_Error" ) == zCURSOR_SET) )
; 775  :       {
; 776  :          ActivateOI_FromOI_ForTask( &vMessage, vMsgQ, 0, zSINGLE );

	push	0
	push	0
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vMessage$[ebp]
	push	ecx
	call	_ActivateOI_FromOI_ForTask@16

; 777  : 
; 778  :          // Now that we have the messages in a temp OI, delete the messages out
; 779  :          // of the original OI.
; 780  :          for ( nRC = SetCursorFirstEntity( vMsgQ, "QMsg", 0 );

	push	0
	push	OFFSET $SG13797
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnSendMess
$LN2@fnSendMess:

; 782  :                nRC = SetCursorNextEntity( vMsgQ, "QMsg", 0 ) )

	push	0
	push	OFFSET $SG13798
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnSendMess:

; 781  :                nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $LN3@fnSendMess

; 783  :          {
; 784  :             DeleteEntity( vMsgQ, "QMsg", zREPOS_NONE );

	push	0
	push	OFFSET $SG13799
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_DeleteEntity@12

; 785  :          }

	jmp	SHORT $LN2@fnSendMess
$LN3@fnSendMess:

; 786  : 
; 787  :          if ( nNewMsgObj )

	movsx	eax, WORD PTR _nNewMsgObj$1[ebp]
	test	eax, eax
	je	SHORT $LN8@fnSendMess

; 788  :          {
; 789  :             for ( nRC = SetCursorFirstEntity( vMsgQ, "DBH_Error", 0 );

	push	0
	push	OFFSET $SG13801
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN7@fnSendMess
$LN5@fnSendMess:

; 791  :                   nRC = SetCursorNextEntity( vMsgQ, "DBH_Error", 0 ) )

	push	0
	push	OFFSET $SG13802
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN7@fnSendMess:

; 790  :                   nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $LN8@fnSendMess

; 792  :             {
; 793  :                DeleteEntity( vMsgQ, "DBH_Error", zREPOS_NONE );

	push	0
	push	OFFSET $SG13803
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_DeleteEntity@12

; 794  :             }

	jmp	SHORT $LN5@fnSendMess
$LN8@fnSendMess:

; 795  :          }
; 796  :       }
; 797  :    }
; 798  : 
; 799  :    if ( vMessage )

	cmp	DWORD PTR _vMessage$[ebp], 0
	je	SHORT $LN12@fnSendMess

; 800  :    {
; 801  :       // Send flag to indicate we are sending a message object.
; 802  :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,
; 803  :                                    szlTrue, 1, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	1
	push	OFFSET _szlTrue
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+170]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN14@fnSendMess

; 804  :       {
; 805  :          fnDropView( vMessage );

	mov	ecx, DWORD PTR _vMessage$[ebp]
	push	ecx
	call	_fnDropView@4

; 806  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendMess
$LN14@fnSendMess:

; 807  :       }
; 808  : 
; 809  :       if ( fnSendOI( ppvConn, lpNetwork, vMessage, 0 ) == zCALL_ERROR )

	push	0
	mov	edx, DWORD PTR _vMessage$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	call	_fnSendOI@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN15@fnSendMess

; 810  :       {
; 811  :          TraceLineS( "(kzoeneta) ** Unable to send message object!", "" );

	push	OFFSET $SG13808
	push	OFFSET $SG13809
	call	_TraceLineS@8

; 812  :          fnDropView( vMessage );

	mov	eax, DWORD PTR _vMessage$[ebp]
	push	eax
	call	_fnDropView@4

; 813  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendMess
$LN15@fnSendMess:

; 814  :       }
; 815  : 
; 816  :       // Since we don't need it anymore, drop the temp message OI.
; 817  :       DropObjectInstance( vMessage );

	mov	ecx, DWORD PTR _vMessage$[ebp]
	push	ecx
	call	_DropObjectInstance@4

; 818  :    }

	jmp	SHORT $LN13@fnSendMess
$LN12@fnSendMess:

; 819  :    else
; 820  :    {
; 821  :       // Send flag to indicate that there is no message object.
; 822  :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,
; 823  :                                    szlFalse, 1, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	1
	push	OFFSET _szlFalse
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+170]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN13@fnSendMess

; 824  :       {
; 825  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendMess
$LN13@fnSendMess:

; 826  :       }
; 827  :    }
; 828  : 
; 829  :    return( 0 );

	xor	eax, eax
$LN1@fnSendMess:

; 830  : 
; 831  : } // fnSendMessageObject

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSendMessageObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpApp$1 = -528						; size = 4
_lTask$ = -524						; size = 4
_vMsgQ$ = -520						; size = 4
_szMsg$2 = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_vSubtask$ = 8						; size = 4
_fnCreateMsgObj@4 PROC

; 720  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 721  :    zVIEW  vMsgQ;
; 722  :    zLONG  lTask;
; 723  : 
; 724  :    GetViewByName( &vMsgQ, "__MSGQ", vSubtask, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG13761
	lea	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_GetViewByName@16

; 725  :    if ( vMsgQ == 0 )

	cmp	DWORD PTR _vMsgQ$[ebp], 0
	jne	$LN2@fnCreateMs

; 726  :    {
; 727  :       LPAPP lpApp;
; 728  : 
; 729  :       if ( ActivateEmptyObjectInstance( &vMsgQ, "KZMSGQOO", vSubtask,
; 730  :                                         zMULTIPLE ) < 0 )

	push	256					; 00000100H
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET $SG13764
	lea	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_ActivateEmptyObjectInstance@16
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN3@fnCreateMs

; 731  :       {
; 732  :          zCHAR szMsg[ 512 ];
; 733  : 
; 734  :          zstrcpy( szMsg, "Cannot load Message Object: " );

	push	OFFSET $SG13765
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 735  :          zstrcat( szMsg, "KZMSGQOO" );

	push	OFFSET $SG13766
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 736  :          SysMessageBox( vSubtask, "System Error", szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$2[ebp]
	push	ecx
	push	OFFSET $SG13767
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 737  :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCreateMs
$LN3@fnCreateMs:

; 738  :       }
; 739  : 
; 740  :       SetNameForView( vMsgQ, "__MSGQ", vSubtask, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG13768
	mov	ecx, DWORD PTR _vMsgQ$[ebp]
	push	ecx
	call	_SetNameForView@16

; 741  :       CreateEntity( vMsgQ, "Task", zPOS_FIRST );

	push	1
	push	OFFSET $SG13769
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_CreateEntity@12

; 742  :       lTask = SysGetTaskFromView( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysGetTaskFromView@4
	mov	DWORD PTR _lTask$[ebp], eax

; 743  :       SetAttributeFromInteger( vMsgQ, "Task", "Id", lTask );

	mov	ecx, DWORD PTR _lTask$[ebp]
	push	ecx
	push	OFFSET $SG13770
	push	OFFSET $SG13771
	mov	edx, DWORD PTR _vMsgQ$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16

; 744  : 
; 745  :       fnGetApplicationForSubtask( &lpApp, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$1[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8

; 746  :       SetAttributeFromString( vMsgQ, "Task", "Client", lpApp->szName );

	mov	edx, DWORD PTR _lpApp$1[ebp]
	add	edx, 6
	push	edx
	push	OFFSET $SG13772
	push	OFFSET $SG13773
	mov	eax, DWORD PTR _vMsgQ$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN2@fnCreateMs:

; 747  :    }
; 748  : 
; 749  :    return( vMsgQ );

	mov	eax, DWORD PTR _vMsgQ$[ebp]
$LN1@fnCreateMs:

; 750  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnCreateMsgObj@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pDummy$ = -8						; size = 4
_lpPacket$1 = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_pcPacketType$ = 16					; size = 4
_plPacketData$ = 20					; size = 4
_fnReceiveDataPacket@16 PROC

; 641  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
$LN2@fnReceiveD:

; 642  :    zPVOID   pDummy;
; 643  : 
; 644  :    // Keep looping until we receive a valid packet.
; 645  :    while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$LN1@fnReceiveD

; 646  :    {
; 647  :       if ( lpNetwork->lpfnRecvPacket )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [ecx+202], 0
	je	SHORT $LN4@fnReceiveD

; 648  :       {
; 649  :          // If the network handler supplied us a ReceivePacket routine
; 650  :          // then use it.
; 651  :          if ( (*lpNetwork->lpfnRecvPacket)( &lpNetwork->pNetworkHandle,
; 652  :                                             ppvConn, pcPacketType,
; 653  :                                             plPacketData ) != 0 )

	mov	edx, DWORD PTR _plPacketData$[ebp]
	push	edx
	mov	eax, DWORD PTR _pcPacketType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+202]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN6@fnReceiveD

; 654  :          {
; 655  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnReceiveD
$LN6@fnReceiveD:

; 656  :          }
; 657  :       }

	jmp	SHORT $LN5@fnReceiveD
$LN4@fnReceiveD:

; 658  :       else
; 659  :       {
; 660  :          LPSTRPACKET lpPacket;
; 661  : 
; 662  :          if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle,
; 663  :                                          ppvConn, &lpPacket, zSTRPACKETLTH,
; 664  :                                          zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	10					; 0000000aH
	lea	eax, DWORD PTR _lpPacket$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN7@fnReceiveD

; 665  :          {
; 666  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnReceiveD
$LN7@fnReceiveD:

; 667  :          }
; 668  : 
; 669  :          *pcPacketType = lpPacket->cPacketType;

	mov	eax, DWORD PTR _pcPacketType$[ebp]
	mov	ecx, DWORD PTR _lpPacket$1[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 670  :          *plPacketData = zxtol( lpPacket->szPacketData );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _lpPacket$1[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _plPacketData$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@fnReceiveD:

; 671  :       }
; 672  : 
; 673  :       // If we've retrieved any packet type other than zPACKET_HEADER then
; 674  :       // return.  If we've received a header packet, then we want to skip it
; 675  :       // (the header is for some server application).
; 676  :       if ( *pcPacketType != zPACKET_HEADER )

	mov	edx, DWORD PTR _pcPacketType$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 72					; 00000048H
	je	SHORT $LN8@fnReceiveD

; 677  :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnReceiveD
$LN8@fnReceiveD:

; 678  : 
; 679  :       // Suck up the bytes that make up the header.
; 680  :       if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 681  :                                       &pDummy, *plPacketData,
; 682  :                                       zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	mov	ecx, DWORD PTR _plPacketData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	lea	eax, DWORD PTR _pDummy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN9@fnReceiveD

; 683  :       {
; 684  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnReceiveD
$LN9@fnReceiveD:

; 685  :       }
; 686  : 
; 687  :    } // for (;;)...

	jmp	$LN2@fnReceiveD
$LN1@fnReceiveD:

; 688  : 
; 689  : } // fnReceiveDataPacket

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnReceiveDataPacket@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_nRC$ = -20						; size = 2
_Packet$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_cPacketType$ = 16					; size = 1
_lPacketData$ = 20					; size = 4
_fnSendDataPacket@16 PROC

; 599  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 600  :    zSHORT nRC;
; 601  : 
; 602  :    if ( lpNetwork->lpfnSendPacket )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [eax+198], 0
	je	SHORT $LN2@fnSendData

; 603  :    {
; 604  :       // If the network handler supplied us a SendPacket routine then use it.
; 605  :       nRC = (*lpNetwork->lpfnSendPacket)( &lpNetwork->pNetworkHandle,

	mov	ecx, DWORD PTR _lPacketData$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _cPacketType$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+198]
	call	eax
	mov	WORD PTR _nRC$[ebp], ax

; 606  :                                           ppvConn, cPacketType, lPacketData );
; 607  :    }

	jmp	$LN3@fnSendData
$LN2@fnSendData:

; 608  :    else
; 609  :    {
; 610  :       zDataStrPacket Packet;
; 611  : 
; 612  :       zmemset( &Packet, 0, zSTRPACKETLTH );

	push	10					; 0000000aH
	push	0
	lea	ecx, DWORD PTR _Packet$1[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 613  :       Packet.cPacketType = cPacketType;

	mov	dl, BYTE PTR _cPacketType$[ebp]
	mov	BYTE PTR _Packet$1[ebp], dl

; 614  : 
; 615  :       if ( lPacketData < 0 )

	cmp	DWORD PTR _lPacketData$[ebp], 0
	jge	SHORT $LN4@fnSendData

; 616  :       {
; 617  :          // Convert negative integer to positive and prepend '-' sign.
; 618  :          Packet.szPacketData[ 0 ] = '-';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _Packet$1[ebp+ecx+1], 45	; 0000002dH

; 619  :          lPacketData = -lPacketData;

	mov	edx, DWORD PTR _lPacketData$[ebp]
	neg	edx
	mov	DWORD PTR _lPacketData$[ebp], edx

; 620  :          zltox( lPacketData, &Packet.szPacketData[ 1 ] );

	push	16					; 00000010H
	mov	eax, 1
	shl	eax, 0
	lea	ecx, DWORD PTR _Packet$1[ebp+eax+1]
	push	ecx
	mov	edx, DWORD PTR _lPacketData$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 621  :       }

	jmp	SHORT $LN5@fnSendData
$LN4@fnSendData:

; 622  :       else
; 623  :          zltox( lPacketData, Packet.szPacketData );

	push	16					; 00000010H
	lea	eax, DWORD PTR _Packet$1[ebp+1]
	push	eax
	mov	ecx, DWORD PTR _lPacketData$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN5@fnSendData:

; 624  : 
; 625  :       nRC = (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,

	push	83					; 00000053H
	push	10					; 0000000aH
	lea	edx, DWORD PTR _Packet$1[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+170]
	call	eax
	mov	WORD PTR _nRC$[ebp], ax
$LN3@fnSendData:

; 626  :                                     &Packet, zSTRPACKETLTH, zTYPE_STRING );
; 627  :    }
; 628  : 
; 629  :    if ( cPacketType == zPACKET_ERROR )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN6@fnSendData

; 630  :       fnFlushBuffer( lpNetwork, ppvConn );

	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnFlushBuffer@8
$LN6@fnSendData:

; 631  : 
; 632  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 633  : 
; 634  : } // fnSendDataPacket

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSendDataPacket@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_fnFlushBuffer@8 PROC

; 585  : {

	push	ebp
	mov	ebp, esp

; 586  :    if ( lpNetwork->lpfnBufferEnd )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [eax+186], 0
	je	SHORT $LN2@fnFlushBuf

; 587  :       return(*lpNetwork->lpfnBufferEnd)( &lpNetwork->pNetworkHandle, ppvConn );

	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+186]
	call	ecx
	jmp	SHORT $LN1@fnFlushBuf
	jmp	SHORT $LN1@fnFlushBuf
$LN2@fnFlushBuf:

; 588  :    else
; 589  :       return(*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,

	push	66					; 00000042H
	push	0
	push	0
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+170]
	call	edx
$LN1@fnFlushBuf:

; 590  :                                      0, 0, zTYPE_BLOB );
; 591  : } // fnFlushBuffer

	pop	ebp
	ret	8
_fnFlushBuffer@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpPrevNetConn$ = -12					; size = 4
_lpNetConn$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_bCallClose$ = 16					; size = 1
_fnRemoveConnectionFromNetwork@12 PROC

; 531  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 532  :    LPNETCONN lpNetConn;
; 533  :    LPNETCONN lpPrevNetConn;
; 534  :    zSHORT    nRC;
; 535  : 
; 536  :    zLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysLockCoreMutex@4

; 537  : 
; 538  :    lpPrevNetConn = 0;

	mov	DWORD PTR _lpPrevNetConn$[ebp], 0

; 539  :    for ( lpNetConn = zGETPTR( lpNetwork->hFirstNetConn );

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+150]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetConn$[ebp], eax
	jmp	SHORT $LN4@fnRemoveCo
$LN2@fnRemoveCo:

; 541  :          lpNetConn = zGETPTR( lpNetConn->hNextNetConn ) )

	mov	edx, DWORD PTR _lpNetConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetConn$[ebp], eax
$LN4@fnRemoveCo:

; 540  :          lpNetConn && lpNetConn->pvConn != ppvConn;

	cmp	DWORD PTR _lpNetConn$[ebp], 0
	je	SHORT $LN3@fnRemoveCo
	mov	ecx, DWORD PTR _lpNetConn$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _ppvConn$[ebp]
	je	SHORT $LN3@fnRemoveCo

; 542  :    {
; 543  :       lpPrevNetConn = lpNetConn;

	mov	eax, DWORD PTR _lpNetConn$[ebp]
	mov	DWORD PTR _lpPrevNetConn$[ebp], eax

; 544  :    }

	jmp	SHORT $LN2@fnRemoveCo
$LN3@fnRemoveCo:

; 545  : 
; 546  :    if ( lpNetConn == 0 )

	cmp	DWORD PTR _lpNetConn$[ebp], 0
	jne	SHORT $LN5@fnRemoveCo

; 547  :    {
; 548  :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 549  :       lpNetConn = zGETPTR( lpNetwork->hFirstNetConn );

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+150]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetConn$[ebp], eax

; 550  :       SysMessageBox( 0, szlNetworkError, "Couldn't find lpNetConn!", -1 );

	push	-1
	push	OFFSET $SG13686
	push	OFFSET _szlNetworkError
	push	0
	call	_SysMessageBox@16

; 551  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnRemoveCo
$LN5@fnRemoveCo:

; 552  :    }
; 553  : 
; 554  :    if ( lpPrevNetConn == 0 )

	cmp	DWORD PTR _lpPrevNetConn$[ebp], 0
	jne	SHORT $LN6@fnRemoveCo

; 555  :       lpNetwork->hFirstNetConn = lpNetConn->hNextNetConn;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR _lpNetConn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+150], edx
	jmp	SHORT $LN7@fnRemoveCo
$LN6@fnRemoveCo:

; 556  :    else
; 557  :       lpPrevNetConn->hNextNetConn = lpNetConn->hNextNetConn;

	mov	eax, DWORD PTR _lpPrevNetConn$[ebp]
	mov	ecx, DWORD PTR _lpNetConn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
$LN7@fnRemoveCo:

; 558  : 
; 559  :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 560  :    if ( bCallClose )

	movzx	ecx, BYTE PTR _bCallClose$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@fnRemoveCo

; 561  :    {
; 562  :       if ( (*lpNetwork->lpfnCloseConn)( (zPPVOID) &lpNetwork->pNetworkHandle,
; 563  :                                         (zPPVOID) ppvConn ) != 0 )

	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+182]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN8@fnRemoveCo

; 564  :       {
; 565  :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN8@fnRemoveCo:

; 566  :       }
; 567  :    }
; 568  : 
; 569  :    fnFreeDataspace( lpNetConn );

	mov	edx, DWORD PTR _lpNetConn$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 570  :    lpNetwork->nConnCount--;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	cx, WORD PTR [eax+148]
	sub	cx, 1
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	WORD PTR [edx+148], cx

; 571  : 
; 572  :    zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 573  : 
; 574  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnRemoveCo:

; 575  : 
; 576  : } // fnRemoveConnectionFromNetwork

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnRemoveConnectionFromNetwork@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_hNetConn$ = -272					; size = 4
_lpNetConn$ = -268					; size = 4
_nRC$1 = -264						; size = 2
_szServer$2 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpNetwork$ = 12					; size = 4
_pchServerAddress$ = 16					; size = 4
_ppvConn$ = 20						; size = 4
_bCallOpen$ = 24					; size = 1
_lRequest$ = 28						; size = 4
_pvRequestInfo$ = 32					; size = 4
_vSubtask$ = 36						; size = 4
_fnAddConnectionToNetwork@32 PROC

; 463  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 464  :    LPNETCONN lpNetConn;
; 465  :    zPVOID    hNetConn;
; 466  : 
; 467  :    zLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysLockCoreMutex@4

; 468  : 
; 469  :    // Do we need to call the network handler to open a connection?
; 470  :    if ( bCallOpen )

	movzx	eax, BYTE PTR _bCallOpen$[ebp]
	test	eax, eax
	je	$LN5@fnAddConne

; 471  :    {
; 472  :       zCHAR  szServer[ 256 ];
; 473  :       zSHORT nRC;
; 474  : 
; 475  :       if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN4@fnAddConne

; 476  :          TraceLineI( "(kzoeneta) ** Opening a connection. Current connections = ",

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+148]
	push	ecx
	push	OFFSET $SG13661
	call	_TraceLineI@8
$LN4@fnAddConne:

; 477  :                      lpNetwork->nConnCount );
; 478  : 
; 479  :       // Try to open connections and keep trying until we get an open conn or
; 480  :       // an error.
; 481  :       do
; 482  :       {
; 483  :          // Get address of data server.
; 484  :          nRC = fnGetApplAddress( lpTask, lpNetwork, lRequest, pvRequestInfo,

	mov	edx, DWORD PTR _pchServerAddress$[ebp]
	push	edx
	lea	eax, DWORD PTR _szServer$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvRequestInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lRequest$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnGetApplAddress@24
	mov	WORD PTR _nRC$1[ebp], ax

; 485  :                                  szServer, pchServerAddress );
; 486  :          if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$1[ebp]
	test	edx, edx
	jge	SHORT $LN7@fnAddConne

; 487  :             return( zNETWORK_ERROR );

	mov	eax, -6					; fffffffaH
	jmp	$LN1@fnAddConne
$LN7@fnAddConne:

; 488  : 
; 489  :          // Try to open the connection.  Return codes:
; 490  :          //    0 - Connection opened.
; 491  :          //   -1 - Connection failed (timed out).
; 492  :          //   zCALL_ERROR - unrecoverable error.
; 493  :          nRC = (*lpNetwork->lpfnOpenConn)( (zPPVOID) &lpNetwork->pNetworkHandle,

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szServer$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+178]
	call	edx
	mov	WORD PTR _nRC$1[ebp], ax

; 494  :                                            (zPPVOID) ppvConn, szServer, vSubtask );
; 495  :          if ( nRC )

	movsx	eax, WORD PTR _nRC$1[ebp]
	test	eax, eax
	je	SHORT $LN2@fnAddConne

; 496  :          {
; 497  :             TraceLineS( "(kzoeneta) ** Open connection failed, hostaddress=",

	mov	ecx, DWORD PTR _pchServerAddress$[ebp]
	push	ecx
	push	OFFSET $SG13664
	call	_TraceLineS@8

; 498  :                         pchServerAddress );
; 499  : 
; 500  :             if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$1[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN9@fnAddConne

; 501  :                return( zNETWORK_ERROR );

	mov	eax, -6					; fffffffaH
	jmp	$LN1@fnAddConne
$LN9@fnAddConne:

; 502  : 
; 503  :             // We will try to open the connection again.  Turn on a flag to
; 504  :             // tell the appl server logic that we are trying again.
; 505  :             lRequest |= zAPPLREQ_RETRY;

	mov	eax, DWORD PTR _lRequest$[ebp]
	or	eax, 65536				; 00010000H
	mov	DWORD PTR _lRequest$[ebp], eax
$LN2@fnAddConne:

; 506  :          }
; 507  : 
; 508  :       } while ( nRC );

	movsx	ecx, WORD PTR _nRC$1[ebp]
	test	ecx, ecx
	jne	$LN4@fnAddConne
$LN5@fnAddConne:

; 509  : 
; 510  :    } // if ( bCallOpen )...
; 511  : 
; 512  :    hNetConn = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	0
	push	0
	push	1
	push	216					; 000000d8H
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNetConn$[ebp], eax

; 513  :                                 sizeof( NetConnectionRecord ), TRUE, 0, 0 );
; 514  :    lpNetConn = zGETPTR( hNetConn );

	mov	ecx, DWORD PTR _hNetConn$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetConn$[ebp], eax

; 515  :    lpNetConn->pvConn = ppvConn;

	mov	edx, DWORD PTR _lpNetConn$[ebp]
	mov	eax, DWORD PTR _ppvConn$[ebp]
	mov	DWORD PTR [edx], eax

; 516  : 
; 517  :    lpNetConn->hNextNetConn = lpNetwork->hFirstNetConn;

	mov	ecx, DWORD PTR _lpNetConn$[ebp]
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+150]
	mov	DWORD PTR [ecx+4], eax

; 518  :    lpNetwork->nConnCount++;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	dx, WORD PTR [ecx+148]
	add	dx, 1
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	WORD PTR [eax+148], dx

; 519  :    lpNetwork->hFirstNetConn = hNetConn;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR _hNetConn$[ebp]
	mov	DWORD PTR [ecx+150], edx

; 520  : 
; 521  :    zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 522  : 
; 523  :    return( 0 );

	xor	eax, eax
$LN1@fnAddConne:

; 524  : 
; 525  : } // fnAddConnectionToNetwork

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_fnAddConnectionToNetwork@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lProcessID$1 = -4108					; size = 4
_lpLibrary$2 = -4104					; size = 4
_szGroup$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpNetwork$ = 12					; size = 4
_lType$ = 16						; size = 4
_pvData$ = 20						; size = 4
_pchReturnAddress$ = 24					; size = 4
_pchUserAddress$ = 28					; size = 4
_fnGetApplAddress@24 PROC

; 410  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4108				; 0000100cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 411  :    zCHAR szGroup[ 4096 ];
; 412  : 
; 413  :    // If we have a server directory function, use it.
; 414  :    if ( lpNetwork->lpfnServDirGetAddr )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [eax+218], 0
	je	SHORT $LN2@fnGetApplA

; 415  :    {
; 416  :       zLONG lProcessID = SysGetProcessID( 0 ); // we didn't do this in 10B

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$1[ebp], eax

; 417  :       LPLIBRARY lpLibrary = zGETPTR( lpNetwork->hServDirLib );

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+206]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$2[ebp], eax

; 418  :       if ( lpLibrary == 0 || lProcessID != lpLibrary->lProcessID )

	cmp	DWORD PTR _lpLibrary$2[ebp], 0
	je	SHORT $LN4@fnGetApplA
	mov	eax, DWORD PTR _lpLibrary$2[ebp]
	mov	ecx, DWORD PTR _lProcessID$1[ebp]
	cmp	ecx, DWORD PTR [eax+271]
	je	SHORT $LN2@fnGetApplA
$LN4@fnGetApplA:

; 419  :          LoadNetworkOperations( lpTask, lpNetwork );

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_LoadNetworkOperations
	add	esp, 8
$LN2@fnGetApplA:

; 420  :    }
; 421  : 
; 422  :    if ( lpNetwork->lpfnServDirGetAddr )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [ecx+218], 0
	je	SHORT $LN5@fnGetApplA

; 423  :    {
; 424  :       return( (*lpNetwork->lpfnServDirGetAddr)( lpTask,

	mov	edx, DWORD PTR _pvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _pchReturnAddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+218]
	call	edx
	jmp	SHORT $LN1@fnGetApplA
$LN5@fnGetApplA:

; 425  :                                                 pchReturnAddress,
; 426  :                                                 &lpNetwork->pvServDirData,
; 427  :                                                 lType, pvData ) );
; 428  :    }
; 429  : 
; 430  :    // Default is to allow only one attempt.
; 431  :    if ( lType & zAPPLREQ_RETRY )

	mov	eax, DWORD PTR _lType$[ebp]
	and	eax, 65536				; 00010000H
	je	SHORT $LN6@fnGetApplA

; 432  :       return( zNETWORK_ERROR );

	mov	eax, -6					; fffffffaH
	jmp	SHORT $LN1@fnGetApplA
$LN6@fnGetApplA:

; 433  : 
; 434  :    // If the user supplied an address, then just use that.
; 435  :    if ( pchUserAddress && pchUserAddress[ 0 ] )

	cmp	DWORD PTR _pchUserAddress$[ebp], 0
	je	SHORT $LN7@fnGetApplA
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchUserAddress$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN7@fnGetApplA

; 436  :    {
; 437  :       zstrcpy( pchReturnAddress, pchUserAddress );

	mov	edx, DWORD PTR _pchUserAddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnAddress$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 438  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetApplA
$LN7@fnGetApplA:

; 439  :    }
; 440  : 
; 441  :    // The default is to read the server address from the INI file
; 442  :    // using the network name.
; 443  :    zsprintf( szGroup, "[%s]", lpNetwork->szNetworkName );

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET $SG13628
	lea	edx, DWORD PTR _szGroup$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 444  :    SysReadZeidonIni( -1, szGroup, "ApplServer", pchReturnAddress );

	mov	eax, DWORD PTR _pchReturnAddress$[ebp]
	push	eax
	push	OFFSET $SG13629
	lea	ecx, DWORD PTR _szGroup$[ebp]
	push	ecx
	push	-1
	call	_SysReadZeidonIni@16

; 445  : 
; 446  :    return( 0 );

	xor	eax, eax
$LN1@fnGetApplA:

; 447  : 
; 448  : } // fnGetApplAddress

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnGetApplAddress@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpSystemTask$ = -216					; size = 4
_vTask$ = -212						; size = 4
_hLibrary$ = -208					; size = 4
_szMsg$1 = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpNetwork$ = 12					; size = 4
_LoadNetworkOperations PROC

; 365  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 366  :    LPLIBRARY hLibrary;
; 367  :    LPTASK    lpSystemTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemTask$[ebp], eax

; 368  : // zVIEW     vTask = zGETPTR( lpSystemTask->hFirstView );
; 369  :    zVIEW     vTask = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$[ebp], eax

; 370  : 
; 371  :    if ( vTask == 0 )

	cmp	DWORD PTR _vTask$[ebp], 0
	jne	SHORT $LN2@LoadNetwor

; 372  :       vTask = zGETPTR( lpSystemTask->hFirstView );

	mov	ecx, DWORD PTR _lpSystemTask$[ebp]
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$[ebp], eax
$LN2@LoadNetwor:

; 373  : 
; 374  :    hLibrary = SysLoadLibraryWithErrFlag( vTask, lpNetwork->szFileName, FALSE );

	push	0
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 222				; 000000deH
	push	eax
	mov	ecx, DWORD PTR _vTask$[ebp]
	push	ecx
	call	_SysLoadLibraryWithErrFlag@12
	mov	DWORD PTR _hLibrary$[ebp], eax

; 375  :    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$LN3@LoadNetwor

; 376  :    {
; 377  :       lpNetwork->hServDirLib = hLibrary;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+206], eax

; 378  :       lpNetwork->lpfnServDirInit = (zLPFN_SERVDIRINIT)

	push	OFFSET $SG13597
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	_SysGetProc@8
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [edx+210], eax

; 379  :                                 SysGetProc( hLibrary, "zServerDirInit" );
; 380  :       lpNetwork->lpfnServDirClose = (zLPFN_SERVDIRCLOSE)

	push	OFFSET $SG13598
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [ecx+214], eax

; 381  :                                 SysGetProc( hLibrary, "zServerDirClose" );
; 382  :       lpNetwork->lpfnServDirGetAddr = (zLPFN_SERVDIRADDR)

	push	OFFSET $SG13599
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [ecx+218], eax

; 383  :                                 SysGetProc( hLibrary, "zServerDirGetAddr" );
; 384  : 
; 385  :       if ( lpNetwork->lpfnServDirInit    == 0 ||
; 386  :            lpNetwork->lpfnServDirClose   == 0 ||

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [edx+210], 0
	je	SHORT $LN5@LoadNetwor
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [eax+214], 0
	je	SHORT $LN5@LoadNetwor
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [ecx+218], 0
	jne	SHORT $LN3@LoadNetwor
$LN5@LoadNetwor:

; 387  :            lpNetwork->lpfnServDirGetAddr == 0 )
; 388  :       {
; 389  :          zCHAR szMsg[ 200 ];
; 390  : 
; 391  :          zsprintf( szMsg, "Can't find Server Directory functions in '%s'. "

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 222				; 000000deH
	push	edx
	push	OFFSET $SG13602
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 392  :                    "See trace for more.", lpNetwork->szFileName );
; 393  :          fnSysMessageBox( lpTask, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	push	OFFSET $SG13603
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 394  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@LoadNetwor
$LN3@LoadNetwor:

; 395  :       }
; 396  :    }
; 397  : 
; 398  :    return( 0 );

	xor	eax, eax
$LN1@LoadNetwor:

; 399  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_LoadNetworkOperations ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpApp$ = -4						; size = 4
_vSubtask$ = 8						; size = 4
_pchAppName$ = 12					; size = 4
_fnRetrieveAppName@8 PROC

; 353  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 354  :    LPAPP lpApp;
; 355  : 
; 356  :    fnGetApplicationForSubtask( &lpApp, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8

; 357  :    if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN2@fnRetrieve

; 358  :       zstrcpy( pchAppName, lpApp->szName );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN1@fnRetrieve
$LN2@fnRetrieve:

; 359  :    else
; 360  :       pchAppName[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAppName$[ebp]
	mov	BYTE PTR [eax+edx], 0
$LN1@fnRetrieve:

; 361  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnRetrieveAppName@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lProcessID$ = -220					; size = 4
tv90 = -216						; size = 4
tv89 = -212						; size = 4
_lpNetwork$ = -208					; size = 4
_szMsg$1 = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_pchNetworkName$ = 12					; size = 4
_bShowError$ = 16					; size = 1
_fnFindNetwork@12 PROC

; 313  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 314  :    LPNETWORK lpNetwork;
; 315  : 
; 316  :    zLONG  lProcessID   = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 317  : 
; 318  :    zLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysLockCoreMutex@4

; 319  : 
; 320  :    // Find the network pointer that matches the network name.
; 321  :    for ( lpNetwork = zGETPTR( AnchorBlock->hFirstNetwork );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+122]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetwork$[ebp], eax
	jmp	SHORT $LN4@fnFindNetw
$LN2@fnFindNetw:

; 323  :          lpNetwork = zGETPTR( lpNetwork->hNextNetwork ) )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetwork$[ebp], eax
$LN4@fnFindNetw:

; 322  :          lpNetwork;

	cmp	DWORD PTR _lpNetwork$[ebp], 0
	je	$LN3@fnFindNetw

; 324  :    {
; 325  :       if ( lpNetwork->lProcessID != lProcessID )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN5@fnFindNetw

; 326  :          continue;

	jmp	SHORT $LN2@fnFindNetw
$LN5@fnFindNetw:

; 327  : 
; 328  :       if ( zstrcmp( lpNetwork->szNetworkName, pchNetworkName ) != 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN11@fnFindNetw
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN12@fnFindNetw
$LN11@fnFindNetw:
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, BYTE PTR [eax+20]
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN9@fnFindNetw
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN10@fnFindNetw
$LN9@fnFindNetw:
	mov	DWORD PTR tv89[ebp], -1
$LN10@fnFindNetw:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR tv90[ebp], ecx
$LN12@fnFindNetw:
	cmp	DWORD PTR tv90[ebp], 0
	je	SHORT $LN6@fnFindNetw

; 329  :          continue;

	jmp	$LN2@fnFindNetw
$LN6@fnFindNetw:

; 330  : 
; 331  :       // If we get here we found the network we are looking for.
; 332  :       break;

	jmp	SHORT $LN3@fnFindNetw

; 333  :    }

	jmp	$LN2@fnFindNetw
$LN3@fnFindNetw:

; 334  : 
; 335  :    zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 336  : 
; 337  :    if ( lpNetwork == 0 && bShowError )

	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN7@fnFindNetw
	movzx	edx, BYTE PTR _bShowError$[ebp]
	test	edx, edx
	je	SHORT $LN7@fnFindNetw

; 338  :    {
; 339  :       zCHAR szMsg[ 200 ];
; 340  : 
; 341  :       zsprintf( szMsg, "Cannot find network '%s'", pchNetworkName );

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	push	OFFSET $SG13569
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 342  :       fnSysMessageBox( lpTask, szlNetworkError, szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	push	OFFSET _szlNetworkError
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16
$LN7@fnFindNetw:

; 343  :    }
; 344  : 
; 345  :    return( lpNetwork );

	mov	eax, DWORD PTR _lpNetwork$[ebp]

; 346  : 
; 347  : } // fnFindNetwork

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnFindNetwork@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_nLth$ = -60						; size = 2
_szHeaderStr$ = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_cPacketType$ = 16					; size = 1
_szAppName$ = 20					; size = 4
_fnSendHeaderPacket@16 PROC

; 696  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 697  :    zCHAR         szHeaderStr[ 50 ];
; 698  :    zSHORT        nLth;
; 699  : 
; 700  :    szHeaderStr[ 0 ] = cPacketType;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _cPacketType$[ebp]
	mov	BYTE PTR _szHeaderStr$[ebp+ecx], dl

; 701  :    zstrcpy( &szHeaderStr[ 1 ], szAppName );

	mov	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	lea	edx, DWORD PTR _szHeaderStr$[ebp+ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 702  :    nLth = zstrlen( szHeaderStr ) + 1;

	lea	eax, DWORD PTR _szHeaderStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	WORD PTR _nLth$[ebp], ax

; 703  : 
; 704  :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_HEADER, nLth ) != 0 )

	movsx	ecx, WORD PTR _nLth$[ebp]
	push	ecx
	push	72					; 00000048H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN2@fnSendHead

; 705  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendHead
$LN2@fnSendHead:

; 706  : 
; 707  :    // Send server the header string.
; 708  :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, ppvConn,
; 709  :                                 szHeaderStr, nLth, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	movsx	edx, WORD PTR _nLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _szHeaderStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+170]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@fnSendHead

; 710  :    {
; 711  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendHead
$LN3@fnSendHead:

; 712  :    }
; 713  : 
; 714  :    return( 0 );

	xor	eax, eax
$LN1@fnSendHead:

; 715  : 
; 716  : } // fnSendHeaderPacket

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSendHeaderPacket@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpViewOD$ = -16					; size = 4
tv88 = -12						; size = 4
tv87 = -8						; size = 4
_lpViewEntity$ = -4					; size = 4
_vMsg$ = 8						; size = 4
_TestMsgObjDef PROC

; 897  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 898  :    LPVIEWOD lpViewOD;
; 899  :    LPVIEWENTITY lpViewEntity;
; 900  : 
; 901  :    // Does the Object definition contain the entity "DBH_Error"?
; 902  :    lpViewOD = zGETPTR( vMsg->hViewOD );

	mov	eax, DWORD PTR _vMsg$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 903  :    for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN4@TestMsgObj
$LN2@TestMsgObj:

; 905  :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN4@TestMsgObj:

; 904  :          lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN3@TestMsgObj

; 906  :    {
; 907  :       // Is the entity the DBH_Error?
; 908  :       if ( zstrcmp( lpViewEntity->szName, "DBH_Error" ) == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	movsx	edx, BYTE PTR $SG13862
	cmp	ecx, edx
	jne	SHORT $LN9@TestMsgObj
	push	OFFSET $SG13863
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv88[ebp], eax
	jmp	SHORT $LN10@TestMsgObj
$LN9@TestMsgObj:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	movsx	eax, BYTE PTR $SG13864
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN7@TestMsgObj
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN8@TestMsgObj
$LN7@TestMsgObj:
	mov	DWORD PTR tv87[ebp], -1
$LN8@TestMsgObj:
	mov	ecx, DWORD PTR tv87[ebp]
	mov	DWORD PTR tv88[ebp], ecx
$LN10@TestMsgObj:
	cmp	DWORD PTR tv88[ebp], 0
	jne	SHORT $LN5@TestMsgObj

; 909  :          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@TestMsgObj
$LN5@TestMsgObj:

; 910  :    }

	jmp	SHORT $LN2@TestMsgObj
$LN3@TestMsgObj:

; 911  : 
; 912  :    return( 0 );

	xor	eax, eax
$LN1@TestMsgObj:

; 913  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_TestMsgObjDef ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpTask$1 = -536					; size = 4
_ppvConn$ = -532					; size = 4
_pchExtraData$2 = -528					; size = 4
_lPacketData$ = -524					; size = 4
tv72 = -520						; size = 4
_lpAct$ = -516						; size = 4
_lpNetwork$ = -512					; size = 4
_cDataType$ = -506					; size = 1
_cPacketType$ = -505					; size = 1
_szMsg$3 = -504						; size = 500
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_pvData$ = 12						; size = 4
_ppchReturnBuffer$ = 16					; size = 4
_uLth$ = 20						; size = 4
_nErrorNum$ = 24					; size = 2
_fnReadDataFromNet@20 PROC

; 5077 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5078 :    LPACTIVATE  lpAct = (LPACTIVATE) pvData;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpAct$[ebp], eax

; 5079 :    LPNETWORK   lpNetwork = lpAct->lpNetwork;

	mov	ecx, DWORD PTR _lpAct$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpNetwork$[ebp], edx

; 5080 :    zPVOID      *ppvConn = lpAct->ppvConn;

	mov	eax, DWORD PTR _lpAct$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _ppvConn$[ebp], ecx

; 5081 :    zCHAR       cDataType;
; 5082 :    zCHAR       cPacketType;
; 5083 :    zLONG       lPacketData;
; 5084 : 
; 5085 :    // If nErrorNum is not 0, then flash the error message and get out.
; 5086 :    if ( nErrorNum )

	movsx	edx, WORD PTR _nErrorNum$[ebp]
	test	edx, edx
	je	$LN4@fnReadData

; 5087 :    {
; 5088 :       zCHAR szMsg[ 500 ];
; 5089 : 
; 5090 :       zPCHAR pchExtraData = (zPCHAR) ppchReturnBuffer;

	mov	eax, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR _pchExtraData$2[ebp], eax

; 5091 : 
; 5092 :       TraceLineI( "(kzoeneta) ** Read Data error = ", nErrorNum );

	movsx	ecx, WORD PTR _nErrorNum$[ebp]
	push	ecx
	push	OFFSET $SG15301
	call	_TraceLineI@8

; 5093 :       switch ( nErrorNum )

	movsx	edx, WORD PTR _nErrorNum$[ebp]
	mov	DWORD PTR tv72[ebp], edx
	mov	eax, DWORD PTR tv72[ebp]
	sub	eax, 74					; 0000004aH
	mov	DWORD PTR tv72[ebp], eax
	cmp	DWORD PTR tv72[ebp], 30			; 0000001eH
	ja	SHORT $LN2@fnReadData
	mov	ecx, DWORD PTR tv72[ebp]
	movzx	edx, BYTE PTR $LN21@fnReadData[ecx]
	jmp	DWORD PTR $LN22@fnReadData[edx*4]
$LN5@fnReadData:

; 5094 :       {
; 5095 :          case 74:
; 5096 :             // "KZOEE074 - Invalid Entity name on line "
; 5097 :             zsprintf( szMsg, "Invalid Entity name = %s", pchExtraData );

	mov	eax, DWORD PTR _pchExtraData$2[ebp]
	push	eax
	push	OFFSET $SG15303
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 5098 :             break;

	jmp	SHORT $LN2@fnReadData
$LN6@fnReadData:

; 5099 : 
; 5100 :          case 75:
; 5101 :             // "KZOEE075 - Invalid Entity level on line "
; 5102 :             zsprintf( szMsg, "Invalid Entity level = %s", pchExtraData );

	mov	edx, DWORD PTR _pchExtraData$2[ebp]
	push	edx
	push	OFFSET $SG15305
	lea	eax, DWORD PTR _szMsg$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 5103 :             break;

	jmp	SHORT $LN2@fnReadData
$LN7@fnReadData:

; 5104 : 
; 5105 :          case 90:
; 5106 :             // "KZOEE090 - Maximum number of entites in portable file exceeded"
; 5107 :             zstrcpy( szMsg, "Maximum number of entities in stream exceeded" );

	push	OFFSET $SG15307
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5108 :             break;

	jmp	SHORT $LN2@fnReadData
$LN8@fnReadData:

; 5109 : 
; 5110 :          case 104:
; 5111 :             // "KZOEE104 - Invalid Attribute name for Entity"
; 5112 :             zsprintf( szMsg, "Invalid Attr name for Entity = %s",

	mov	edx, DWORD PTR _pchExtraData$2[ebp]
	push	edx
	push	OFFSET $SG15309
	lea	eax, DWORD PTR _szMsg$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN2@fnReadData:

; 5113 :                       pchExtraData );
; 5114 :             break;
; 5115 : 
; 5116 :       } // switch ( nErrorNum )
; 5117 : 
; 5118 :       SysMessageBox( lpView, szlNetworkError, szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 5119 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnReadData
$LN4@fnReadData:

; 5120 : 
; 5121 :    } // if ( nErrorNum )...
; 5122 : 
; 5123 :    // The first few bytes should be the Zeidon network packet indicating the
; 5124 :    // length of the incoming line or that there is no more incoming data.
; 5125 :    if ( fnReceiveDataPacket( lpNetwork, ppvConn, &cPacketType, &lPacketData ) != 0 )

	lea	eax, DWORD PTR _lPacketData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cPacketType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnReceiveDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN9@fnReadData

; 5126 :    {
; 5127 :       TraceLineS( "(kzoeneta) ** Error receiving SENDLTH!", "" );

	push	OFFSET $SG15311
	push	OFFSET $SG15312
	call	_TraceLineS@8

; 5128 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnReadData
$LN9@fnReadData:

; 5129 :    }
; 5130 : 
; 5131 :    if ( cPacketType == zPACKET_END )

	movsx	edx, BYTE PTR _cPacketType$[ebp]
	cmp	edx, 69					; 00000045H
	jne	SHORT $LN10@fnReadData

; 5132 :    {
; 5133 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN11@fnReadData

; 5134 :          TraceLineS( "(kzoeneta) ** Received OI END message", "" );

	push	OFFSET $SG15315
	push	OFFSET $SG15316
	call	_TraceLineS@8
$LN11@fnReadData:

; 5135 : 
; 5136 :       if ( lPacketData != lpAct->lLineCount )

	mov	edx, DWORD PTR _lpAct$[ebp]
	mov	eax, DWORD PTR _lPacketData$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN12@fnReadData

; 5137 :       {
; 5138 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 5139 :          // "KZOEE400 - Error transmitting lines. "
; 5140 :          fnIssueCoreError( lpTask, lpView, 16, 400, 0,

	push	0
	push	OFFSET $SG15318
	push	0
	push	400					; 00000190H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5141 :                            "Error transmitting OI -- some lines lost.", 0 );
; 5142 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnReadData
$LN12@fnReadData:

; 5143 :       }
; 5144 : 
; 5145 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnReadData
$LN10@fnReadData:

; 5146 :    }
; 5147 : 
; 5148 :    if ( cPacketType == zPACKET_ERROR )

	movsx	edx, BYTE PTR _cPacketType$[ebp]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN13@fnReadData

; 5149 :    {
; 5150 :       TraceLineI( "(kzoeneta) ** Received Packet ERROR code = ", lPacketData );

	mov	eax, DWORD PTR _lPacketData$[ebp]
	push	eax
	push	OFFSET $SG15320
	call	_TraceLineI@8

; 5151 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnReadData
$LN13@fnReadData:

; 5152 :    }
; 5153 : 
; 5154 :    if ( cPacketType == zPACKET_SENDLTHS )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN14@fnReadData

; 5155 :       cDataType = zTYPE_STRING;

	mov	BYTE PTR _cDataType$[ebp], 83		; 00000053H
	jmp	SHORT $LN15@fnReadData
$LN14@fnReadData:

; 5156 :    else
; 5157 :    if ( cPacketType == zPACKET_SENDLTHB )

	movsx	edx, BYTE PTR _cPacketType$[ebp]
	cmp	edx, 66					; 00000042H
	jne	SHORT $LN16@fnReadData

; 5158 :       cDataType = zTYPE_BLOB;

	mov	BYTE PTR _cDataType$[ebp], 66		; 00000042H
	jmp	SHORT $LN15@fnReadData
$LN16@fnReadData:

; 5159 :    else
; 5160 :    {
; 5161 :       TraceLineS( "(kzoeneta) ** Invalid packet type--expecting SENDLTH!", "" );

	push	OFFSET $SG15325
	push	OFFSET $SG15326
	call	_TraceLineS@8

; 5162 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnReadData
$LN15@fnReadData:

; 5163 :    }
; 5164 : 
; 5165 :    if ( lpNetwork->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	cmp	ecx, 1
	jle	SHORT $LN18@fnReadData

; 5166 :    {
; 5167 :       TraceLineI( "(kzoeneta) ** Received SENDLTH packet. Lth = ", lPacketData );

	mov	edx, DWORD PTR _lPacketData$[ebp]
	push	edx
	push	OFFSET $SG15328
	call	_TraceLineI@8
$LN18@fnReadData:

; 5168 :    }
; 5169 : 
; 5170 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle,
; 5171 :                                    ppvConn, ppchReturnBuffer,
; 5172 :                                    lPacketData, cDataType ) != 0 )

	movzx	eax, BYTE PTR _cDataType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lPacketData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+174]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN19@fnReadData

; 5173 :    {
; 5174 :       TraceLineS( "(kzoeneta) ** Error receiving data", "" );

	push	OFFSET $SG15330
	push	OFFSET $SG15331
	call	_TraceLineS@8

; 5175 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnReadData
$LN19@fnReadData:

; 5176 :    }
; 5177 : 
; 5178 :    lpAct->lLineCount++;

	mov	edx, DWORD PTR _lpAct$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _lpAct$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 5179 : 
; 5180 :    return( 1 );

	mov	eax, 1
$LN1@fnReadData:

; 5181 : 
; 5182 : } // fnReadDataFromNet

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	3
$LN22@fnReadData:
	DD	$LN5@fnReadData
	DD	$LN6@fnReadData
	DD	$LN7@fnReadData
	DD	$LN8@fnReadData
	DD	$LN2@fnReadData
$LN21@fnReadData:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnReadDataFromNet@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_ar$ = -16						; size = 12
_nRC$ = -4						; size = 2
_ppvConn$ = 8						; size = 4
_lpNetwork$ = 12					; size = 4
_pvOI$ = 16						; size = 4
_vSubtask$ = 20						; size = 4
_pchObjectDef$ = 24					; size = 4
_lControl$ = 28						; size = 4
_fnReceiveOI@24 PROC

; 5194 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5195 :    ActivateRecord ar;
; 5196 :    zSHORT      nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 5197 : 
; 5198 :    ar.lpNetwork  = lpNetwork;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR _ar$[ebp], ecx

; 5199 :    ar.ppvConn    = ppvConn;

	mov	edx, DWORD PTR _ppvConn$[ebp]
	mov	DWORD PTR _ar$[ebp+4], edx

; 5200 :    ar.lLineCount = 0;

	mov	DWORD PTR _ar$[ebp+8], 0

; 5201 : 
; 5202 :    if ( lpNetwork->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	cmp	ecx, 1
	jle	SHORT $LN2@fnReceiveO

; 5203 :    {
; 5204 :       TraceLineS( "(kzoeneta) ** Initiating receive of OI", "" );

	push	OFFSET $SG15348
	push	OFFSET $SG15349
	call	_TraceLineS@8
$LN2@fnReceiveO:

; 5205 :    }
; 5206 : 
; 5207 :    lControl |= zACTIVATE_NOCONSTRAINTS;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 16777216				; 01000000H
	mov	DWORD PTR _lControl$[ebp], edx

; 5208 : 
; 5209 :    nRC = SfActivateOI_FromStream( pvOI, pchObjectDef, vSubtask,

	lea	eax, DWORD PTR _ar$[ebp]
	push	eax
	push	OFFSET _fnReadDataFromNet@20
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchObjectDef$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvOI$[ebp]
	push	ecx
	call	_SfActivateOI_FromStream@24
	mov	WORD PTR _nRC$[ebp], ax

; 5210 :                                   lControl, fnReadDataFromNet, &ar );
; 5211 :    if ( nRC != zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	je	SHORT $LN3@fnReceiveO

; 5212 :    {
; 5213 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN5@fnReceiveO

; 5214 :       {
; 5215 :          TraceLineS( "(kzoeneta) ** Receive OI OK.  Sending ack.", "" );

	push	OFFSET $SG15353
	push	OFFSET $SG15354
	call	_TraceLineS@8
$LN5@fnReceiveO:

; 5216 :       }
; 5217 :    }

	jmp	SHORT $LN4@fnReceiveO
$LN3@fnReceiveO:

; 5218 :    else
; 5219 :    {
; 5220 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 5221 :       TraceLineS( "(kzoeneta) ** Error receiving OI.  Sending error packet.", "" );

	push	OFFSET $SG15355
	push	OFFSET $SG15356
	call	_TraceLineS@8
$LN4@fnReceiveO:

; 5222 :    }
; 5223 : 
; 5224 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 5225 : 
; 5226 : } // fnReceiveOI

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnReceiveOI@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = -12					; size = 4
_lpAct$ = -8						; size = 4
_cPacketType$ = -1					; size = 1
_lpTaskView$ = 8					; size = 4
_lpvData$ = 12						; size = 4
_pchBuffer$ = 16					; size = 4
_uLth$ = 20						; size = 4
_cDataType$ = 24					; size = 1
_fnSendOI_Data@20 PROC

; 5241 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5242 :    zCHAR       cPacketType;
; 5243 :    LPACTIVATE  lpAct = (LPACTIVATE) lpvData;

	mov	eax, DWORD PTR _lpvData$[ebp]
	mov	DWORD PTR _lpAct$[ebp], eax

; 5244 :    LPNETWORK   lpNetwork = lpAct->lpNetwork;

	mov	ecx, DWORD PTR _lpAct$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpNetwork$[ebp], edx

; 5245 : 
; 5246 :    if ( uLth == 0 )

	cmp	DWORD PTR _uLth$[ebp], 0
	jne	SHORT $LN2@fnSendOI_D

; 5247 :       uLth = zstrlen( pchBuffer ) + 1;

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _uLth$[ebp], eax
$LN2@fnSendOI_D:

; 5248 : 
; 5249 :    if ( cDataType == zTYPE_STRING )

	movsx	ecx, BYTE PTR _cDataType$[ebp]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN3@fnSendOI_D

; 5250 :       cPacketType = zPACKET_SENDLTHS;

	mov	BYTE PTR _cPacketType$[ebp], 83		; 00000053H
	jmp	SHORT $LN4@fnSendOI_D
$LN3@fnSendOI_D:

; 5251 :    else
; 5252 :       cPacketType = zPACKET_SENDLTHB;

	mov	BYTE PTR _cPacketType$[ebp], 66		; 00000042H
$LN4@fnSendOI_D:

; 5253 : 
; 5254 :    // Send the length packet.
; 5255 :    if ( fnSendDataPacket( lpNetwork, lpAct->ppvConn, cPacketType, uLth ) != 0 )

	mov	edx, DWORD PTR _uLth$[ebp]
	push	edx
	movzx	eax, BYTE PTR _cPacketType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAct$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN5@fnSendOI_D

; 5256 :    {
; 5257 :       TraceLineS( "(kzoeneta) ** Error sending zPACKET_SENDLTH", "" );

	push	OFFSET $SG15376
	push	OFFSET $SG15377
	call	_TraceLineS@8

; 5258 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendOI_D
$LN5@fnSendOI_D:

; 5259 :    }
; 5260 : 
; 5261 :    // Send the actual data.
; 5262 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, lpAct->ppvConn,
; 5263 :                                 pchBuffer, uLth, cDataType ) != 0 )

	movzx	edx, BYTE PTR _cDataType$[ebp]
	push	edx
	mov	eax, DWORD PTR _uLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAct$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+170]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN6@fnSendOI_D

; 5264 :    {
; 5265 :       TraceLineS( "(kzoeneta) ** Error sending data line", "" );

	push	OFFSET $SG15379
	push	OFFSET $SG15380
	call	_TraceLineS@8

; 5266 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendOI_D
$LN6@fnSendOI_D:

; 5267 :    }
; 5268 : 
; 5269 :    lpAct->lLineCount++;

	mov	edx, DWORD PTR _lpAct$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _lpAct$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 5270 : 
; 5271 :    return( 0 );

	xor	eax, eax
$LN1@fnSendOI_D:

; 5272 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnSendOI_Data@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_ar$ = -40						; size = 12
_lpViewOD$1 = -28					; size = 4
tv76 = -24						; size = 4
_nRC$ = -20						; size = 2
_szCompressed$2 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_ppvConn$ = 8						; size = 4
_lpNetwork$ = 12					; size = 4
_vOI$ = 16						; size = 4
_lControl$ = 20						; size = 4
_fnSendOI@16 PROC

; 5284 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5285 :    zSHORT         nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 5286 :    ActivateRecord ar;
; 5287 : 
; 5288 :    ar.lpNetwork  = lpNetwork;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR _ar$[ebp], ecx

; 5289 :    ar.ppvConn    = ppvConn;

	mov	edx, DWORD PTR _ppvConn$[ebp]
	mov	DWORD PTR _ar$[ebp+4], edx

; 5290 :    ar.lLineCount = 0;

	mov	DWORD PTR _ar$[ebp+8], 0

; 5291 : 
; 5292 :    if ( g_chNetSendCompressed == 0 )

	movsx	eax, BYTE PTR _g_chNetSendCompressed
	test	eax, eax
	jne	SHORT $LN2@fnSendOI

; 5293 :    {
; 5294 :       zCHAR szCompressed[ 10 ];
; 5295 : 
; 5296 :       SysReadZeidonIni( -1, "[Zeidon]", "NetSendCompressed", szCompressed );

	lea	ecx, DWORD PTR _szCompressed$2[ebp]
	push	ecx
	push	OFFSET $SG15398
	push	OFFSET $SG15399
	push	-1
	call	_SysReadZeidonIni@16

; 5297 :       g_chNetSendCompressed = ztoupper( szCompressed[ 0 ] ) == 'N' ? 'N' : 'Y';

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szCompressed$2[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 78					; 0000004eH
	jne	SHORT $LN12@fnSendOI
	mov	DWORD PTR tv76[ebp], 78			; 0000004eH
	jmp	SHORT $LN13@fnSendOI
$LN12@fnSendOI:
	mov	DWORD PTR tv76[ebp], 89			; 00000059H
$LN13@fnSendOI:
	mov	dl, BYTE PTR tv76[ebp]
	mov	BYTE PTR _g_chNetSendCompressed, dl
$LN2@fnSendOI:

; 5298 :    }
; 5299 : 
; 5300 :    if ( g_chNetSendCompressed != 'N' )

	movsx	eax, BYTE PTR _g_chNetSendCompressed
	cmp	eax, 78					; 0000004eH
	je	SHORT $LN3@fnSendOI

; 5301 :       lControl |= zCOMPRESSED;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 131072				; 00020000H
	mov	DWORD PTR _lControl$[ebp], ecx
	jmp	SHORT $LN4@fnSendOI
$LN3@fnSendOI:

; 5302 :    else
; 5303 :    {
; 5304 :       LPVIEWOD lpViewOD = zGETPTR( vOI->hViewOD );

	mov	edx, DWORD PTR _vOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 5305 :       if ( lpViewOD->bNetCompress )

	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 12					; 0000000cH
	and	edx, 1
	je	SHORT $LN4@fnSendOI

; 5306 :          lControl |= zCOMPRESSED;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 131072				; 00020000H
	mov	DWORD PTR _lControl$[ebp], eax
$LN4@fnSendOI:

; 5307 :    }
; 5308 : 
; 5309 :    nRC = SfWriteOI_ToStream( vOI, "NETACT", lControl,

	lea	ecx, DWORD PTR _ar$[ebp]
	push	ecx
	push	OFFSET _fnSendOI_Data@20
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	push	OFFSET $SG15403
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_SfWriteOI_ToStream@20
	mov	WORD PTR _nRC$[ebp], ax

; 5310 :                              fnSendOI_Data, (zPVOID) &ar );
; 5311 : 
; 5312 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN6@fnSendOI

; 5313 :    {
; 5314 :       TraceLineS( "(kzoeneta) ** Sending END packet.", "" );

	push	OFFSET $SG15405
	push	OFFSET $SG15406
	call	_TraceLineS@8
$LN6@fnSendOI:

; 5315 :    }
; 5316 : 
; 5317 :    // Send a message to say we're done sending the OI
; 5318 :    if ( nRC != zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	je	SHORT $LN7@fnSendOI

; 5319 :    {
; 5320 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_END,
; 5321 :                              ar.lLineCount ) != 0 )

	mov	ecx, DWORD PTR _ar$[ebp+8]
	push	ecx
	push	69					; 00000045H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN9@fnSendOI

; 5322 :       {
; 5323 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15410
	push	OFFSET $SG15411
	call	_TraceLineS@8

; 5324 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendOI
$LN9@fnSendOI:

; 5325 :       }
; 5326 :    }

	jmp	SHORT $LN8@fnSendOI
$LN7@fnSendOI:

; 5327 :    else
; 5328 :    {
; 5329 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 5330 :                              zNETERR_SENDOI ) != 0 )

	push	6
	push	42					; 0000002aH
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN8@fnSendOI

; 5331 :       {
; 5332 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15413
	push	OFFSET $SG15414
	call	_TraceLineS@8

; 5333 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSendOI
$LN8@fnSendOI:

; 5334 :       }
; 5335 :    }
; 5336 : 
; 5337 :    return( 0 );

	xor	eax, eax
$LN1@fnSendOI:

; 5338 : 
; 5339 : } // fnSendOI

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSendOI@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pch$ = -4						; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_lpTask$ = 16						; size = 4
_fnProcessTimestamp@12 PROC

; 7140 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7141 :    zPCHAR pch;
; 7142 : 
; 7143 :    // Retrieve the timestamp message.
; 7144 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 7145 :                                    &pch, L_TIMESTAMP_MSG,
; 7146 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	18					; 00000012H
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@fnProcessT

; 7147 :    {
; 7148 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Timestamp Message", "" );

	push	OFFSET $SG15996
	push	OFFSET $SG15997
	call	_TraceLineS@8

; 7149 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnProcessT
$LN2@fnProcessT:

; 7150 :    }
; 7151 : 
; 7152 :    // Set task timestamp from Server timestamp.
; 7153 :    zmemcpy( lpTask->szTimeStamp, pch, L_TIMESTAMP_MSG );

	push	18					; 00000012H
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 174				; 000000aeH
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7154 :    lpTask->szTimeStamp[ L_TIMESTAMP_MSG ] = 0;

	mov	edx, 1
	imul	eax, edx, 18
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	BYTE PTR [ecx+eax+174], 0

; 7155 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN3@fnProcessT

; 7156 :       TraceLineS( "(kzoeneta) ** Received Timestamp message.", lpTask->szTimeStamp );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 174				; 000000aeH
	push	ecx
	push	OFFSET $SG15999
	call	_TraceLineS@8
$LN3@fnProcessT:

; 7157 : 
; 7158 :    return( 0 );

	xor	eax, eax
$LN1@fnProcessT:

; 7159 : 
; 7160 : } // fnProcessTimestamp

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnProcessTimestamp@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pch$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_k$ = -16						; size = 2
_szTraceSwitch$ = -12					; size = 7
__$ArrayPad$ = -4					; size = 4
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_lpTask$ = 16						; size = 4
_fnProcessTraceSwitches@12 PROC

; 7097 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7098 :    zCHAR szTraceSwitch[ L_TRACE_SWITCH_MSG + 1 ];
; 7099 :    zPCHAR pch;
; 7100 :    zSHORT k;
; 7101 : 
; 7102 :    // Retrieve the trace switch message.
; 7103 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 7104 :                                    &pch, L_TRACE_SWITCH_MSG,
; 7105 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	6
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@fnProcessT

; 7106 :    {
; 7107 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Trace Switch Message", "" );

	push	OFFSET $SG15980
	push	OFFSET $SG15981
	call	_TraceLineS@8

; 7108 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN7@fnProcessT
$LN2@fnProcessT:

; 7109 :    }
; 7110 : 
; 7111 :    zmemcpy( &szTraceSwitch, pch, L_TRACE_SWITCH_MSG );

	push	6
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTraceSwitch$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 7112 :    szTraceSwitch[ L_TRACE_SWITCH_MSG ] = 0;

	mov	edx, 1
	imul	eax, edx, 6
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 7
	jae	SHORT $LN8@fnProcessT
	jmp	SHORT $LN9@fnProcessT
$LN8@fnProcessT:
	call	___report_rangecheckfailure
$LN9@fnProcessT:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szTraceSwitch$[ebp+ecx], 0

; 7113 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN3@fnProcessT

; 7114 :       TraceLineS( "(kzoeneta) ** Received Trace Switch message.", szTraceSwitch );

	lea	ecx, DWORD PTR _szTraceSwitch$[ebp]
	push	ecx
	push	OFFSET $SG15983
	call	_TraceLineS@8
$LN3@fnProcessT:

; 7115 : 
; 7116 :    // server network tracelevel
; 7117 :    k = (zSHORT) zatol( szTraceSwitch + 4 );

	lea	edx, DWORD PTR _szTraceSwitch$[ebp+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7118 :    if ( k > lpNetwork->nTraceLevel )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	cmp	eax, edx
	jle	SHORT $LN4@fnProcessT

; 7119 :       lpNetwork->nTraceLevel = k;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax+140], cx
$LN4@fnProcessT:

; 7120 : 
; 7121 :    // server DBHandler tracelevel
; 7122 :    szTraceSwitch[ 4 ] = 0;

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 7
	jae	SHORT $LN10@fnProcessT
	jmp	SHORT $LN11@fnProcessT
$LN10@fnProcessT:
	call	___report_rangecheckfailure
$LN11@fnProcessT:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szTraceSwitch$[ebp+eax], 0

; 7123 :    k = (zSHORT) zatol( szTraceSwitch + 2 );

	lea	ecx, DWORD PTR _szTraceSwitch$[ebp+2]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7124 :    if ( k > lpTask->nDBHandlerTraceLevel )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+92]
	cmp	edx, ecx
	jle	SHORT $LN5@fnProcessT

; 7125 :       lpTask->nDBHandlerTraceLevel = k;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx+92], ax
$LN5@fnProcessT:

; 7126 : 
; 7127 :    // server core tracelevel
; 7128 :    szTraceSwitch[ 2 ] = 0;

	mov	ecx, 1
	shl	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 7
	jae	SHORT $LN12@fnProcessT
	jmp	SHORT $LN13@fnProcessT
$LN12@fnProcessT:
	call	___report_rangecheckfailure
$LN13@fnProcessT:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szTraceSwitch$[ebp+edx], 0

; 7129 :    k = (zSHORT) zatol( szTraceSwitch );

	lea	eax, DWORD PTR _szTraceSwitch$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7130 :    if ( k > 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	test	ecx, ecx
	jle	SHORT $LN6@fnProcessT

; 7131 :       lpTask->bTrace = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax
$LN6@fnProcessT:

; 7132 : 
; 7133 :    return( 0 );

	xor	eax, eax
$LN7@fnProcessT:

; 7134 : 
; 7135 : } // fnProcessTraceSwitches

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnProcessTraceSwitches@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpSendFile$ = -352					; size = 4
_lpDropSubtask$1 = -348					; size = 4
_pchLine$2 = -344					; size = 4
_pch$ = -340						; size = 4
_nFileNameLth$ = -336					; size = 2
_cPacketType$3 = -329					; size = 1
_lPacketData$4 = -328					; size = 4
_f$ = -324						; size = 4
_vSubtask$ = -320					; size = 4
_iLineCount$ = -316					; size = 2
_cDataType$ = -309					; size = 1
_nRC$ = -308						; size = 2
_sf$ = -304						; size = 37
_szFileName$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpNetwork$ = 12					; size = 4
_ppvConn$ = 16						; size = 4
_fnProcessSendFile@12 PROC

; 6488 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6489 :    zVIEW  vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 6490 :    zPCHAR pch;
; 6491 :    zSHORT nFileNameLth;
; 6492 :    zLONG  f = -1;

	mov	DWORD PTR _f$[ebp], -1

; 6493 :    zCHAR  szFileName[ zMAX_FILENAME_LTH + 1 ];
; 6494 :    zCHAR  cDataType;
; 6495 :    SendFileRecord sf;
; 6496 :    LPSENDFILE     lpSendFile;
; 6497 :    zSHORT iLineCount;
; 6498 :    zSHORT nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 6499 : 
; 6500 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN4@fnProcessS

; 6501 :       TraceLineS( "(kzoeneta) ** Received Send File message.", "" );

	push	OFFSET $SG15737
	push	OFFSET $SG15738
	call	_TraceLineS@8
$LN4@fnProcessS:

; 6502 : 
; 6503 :    //=======================================================================
; 6504 :    // Receiving data.
; 6505 :    //
; 6506 :    // Until noted below, we will only RECEIVE data over the network.
; 6507 :    //=======================================================================
; 6508 : 
; 6509 :    // First thing to do is retrieve the commit info.
; 6510 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6511 :                                    &lpSendFile, sizeof( sf ),
; 6512 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	37					; 00000025H
	lea	eax, DWORD PTR _lpSendFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN5@fnProcessS

; 6513 :    {
; 6514 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve send file info", "" );

	push	OFFSET $SG15740
	push	OFFSET $SG15741
	call	_TraceLineS@8

; 6515 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 6516 :       goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN5@fnProcessS:

; 6517 :    }
; 6518 : 
; 6519 :    // Store the info locally -- as soon as we perform the next network IO
; 6520 :    // operation we aren't assured that lpCommitPacket points to valid data.
; 6521 :    zmemcpy( &sf, lpSendFile, sizeof( sf ) );

	push	37					; 00000025H
	mov	ecx, DWORD PTR _lpSendFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6522 : 
; 6523 :    // Retrieve the file name.
; 6524 :    nFileNameLth = (zSHORT) zxtol( sf.szFileNameLth );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _sf$[ebp+33]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nFileNameLth$[ebp], ax

; 6525 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6526 :                                    &pch, nFileNameLth,
; 6527 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	movsx	ecx, WORD PTR _nFileNameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+174]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN6@fnProcessS

; 6528 :    {
; 6529 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve file name.", "" );

	push	OFFSET $SG15743
	push	OFFSET $SG15744
	call	_TraceLineS@8

; 6530 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6531 :       goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN6@fnProcessS:

; 6532 :    }
; 6533 : 
; 6534 :    // Store the filename to a more static location.
; 6535 :    zstrcpy( szFileName, pch );

	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6536 :    SysAppendcDirSep( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 6537 :    zstrcat( szFileName, &pch[ zstrlen( pch ) + 1 ] );

	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pch$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 6538 : 
; 6539 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN7@fnProcessS

; 6540 :    {
; 6541 :       TraceLine( "(kzoeneta) ** App Name: %s  File Name: %s",

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sf$[ebp]
	push	ecx
	push	OFFSET $SG15746
	call	_TraceLine
	add	esp, 12					; 0000000cH
$LN7@fnProcessS:

; 6542 :                  sf.szAppName, szFileName );
; 6543 :    }
; 6544 : 
; 6545 :    // Try to create a subtask view using the application name passed.
; 6546 :    if ( SfCreateSubtask( &vSubtask, lpTaskView, sf.szAppName ) == zCALL_ERROR )

	lea	edx, DWORD PTR _sf$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SfCreateSubtask@12
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN8@fnProcessS

; 6547 :    {
; 6548 :       TraceLineS( "(kzoeneta) ** Invalid App name = ", sf.szAppName );

	lea	eax, DWORD PTR _sf$[ebp]
	push	eax
	push	OFFSET $SG15748
	call	_TraceLineS@8

; 6549 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6550 :                              zNETERR_INVALIDAPP ) != 0 )

	push	1
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN9@fnProcessS

; 6551 :       {
; 6552 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15750
	push	OFFSET $SG15751
	call	_TraceLineS@8
$LN9@fnProcessS:

; 6553 :       }
; 6554 : 
; 6555 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 6556 :       goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN8@fnProcessS:

; 6557 :    }
; 6558 : 
; 6559 :    fnCreateMsgObj( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_fnCreateMsgObj@4

; 6560 : 
; 6561 :    f = SysOpenFile( vSubtask, szFileName, COREFILE_WRITE );

	push	64					; 00000040H
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _f$[ebp], eax

; 6562 :    if ( f == -1 )

	cmp	DWORD PTR _f$[ebp], -1
	jne	SHORT $LN10@fnProcessS

; 6563 :    {
; 6564 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6565 :       goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN10@fnProcessS:

; 6566 :    }
; 6567 : 
; 6568 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN11@fnProcessS

; 6569 :       TraceLineS( "(kzoeneta) ** Receiving file.", "" );

	push	OFFSET $SG15754
	push	OFFSET $SG15755
	call	_TraceLineS@8
$LN11@fnProcessS:

; 6570 : 
; 6571 :    if ( sf.bBinaryFile == 'Y' )

	movsx	edx, BYTE PTR _sf$[ebp+36]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN12@fnProcessS

; 6572 :    {
; 6573 :       cDataType = zTYPE_BLOB;

	mov	BYTE PTR _cDataType$[ebp], 66		; 00000042H

; 6574 :    }

	jmp	SHORT $LN13@fnProcessS
$LN12@fnProcessS:

; 6575 :    else
; 6576 :       cDataType = zTYPE_STRING;

	mov	BYTE PTR _cDataType$[ebp], 83		; 00000053H
$LN13@fnProcessS:

; 6577 : 
; 6578 :    iLineCount = 0;

	xor	eax, eax
	mov	WORD PTR _iLineCount$[ebp], ax
$LN2@fnProcessS:

; 6579 :    while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@fnProcessS

; 6580 :    {
; 6581 :       zCHAR   cPacketType;
; 6582 :       zULONG  lPacketData;
; 6583 :       zPCHAR  pchLine;
; 6584 : 
; 6585 :       if ( fnReceiveDataPacket( lpNetwork, ppvConn, &cPacketType,
; 6586 :                                 (zPLONG) &lPacketData ) != 0 )

	lea	edx, DWORD PTR _lPacketData$4[ebp]
	push	edx
	lea	eax, DWORD PTR _cPacketType$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnReceiveDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN14@fnProcessS

; 6587 :       {
; 6588 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 6589 :          goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN14@fnProcessS:

; 6590 :       }
; 6591 : 
; 6592 :       // lPacketData is the length of the line.  If it is 0, then we're at the
; 6593 :       // end of the file.
; 6594 :       if ( lPacketData == 0 )

	cmp	DWORD PTR _lPacketData$4[ebp], 0
	jne	SHORT $LN15@fnProcessS

; 6595 :          break;

	jmp	$LN3@fnProcessS
$LN15@fnProcessS:

; 6596 : 
; 6597 :       iLineCount++;

	mov	dx, WORD PTR _iLineCount$[ebp]
	add	dx, 1
	mov	WORD PTR _iLineCount$[ebp], dx

; 6598 : 
; 6599 :       if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6600 :                                       &pchLine, lPacketData,
; 6601 :                                       cDataType ) != 0 )

	movzx	eax, BYTE PTR _cDataType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lPacketData$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$2[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+174]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN16@fnProcessS

; 6602 :       {
; 6603 :          TraceLineS( "(kzoeneta) ** Couldn't retrieve send file line", "" );

	push	OFFSET $SG15761
	push	OFFSET $SG15762
	call	_TraceLineS@8

; 6604 :          nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6605 :          goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN16@fnProcessS:

; 6606 :       }
; 6607 : 
; 6608 :       if ( sf.bBinaryFile == 'Y' )

	movsx	eax, BYTE PTR _sf$[ebp+36]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN17@fnProcessS

; 6609 :       {
; 6610 :          if ( SysWriteFile( vSubtask, f, (zCPCHAR) pchLine,
; 6611 :                             lPacketData ) < lPacketData )

	mov	ecx, DWORD PTR _lPacketData$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchLine$2[ebp]
	push	edx
	mov	eax, DWORD PTR _f$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysWriteFile@16
	cmp	eax, DWORD PTR _lPacketData$4[ebp]
	jae	SHORT $LN19@fnProcessS

; 6612 :          {
; 6613 :             TraceLineS( "(kzoeneta) ** Error writing line to file.", "" );

	push	OFFSET $SG15766
	push	OFFSET $SG15767
	call	_TraceLineS@8

; 6614 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6615 :             goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN19@fnProcessS:

; 6616 :          }
; 6617 :       }

	jmp	SHORT $LN18@fnProcessS
$LN17@fnProcessS:

; 6618 :       else
; 6619 :       {
; 6620 :          if ( SysWriteLine( vSubtask, f, (zCPCHAR) pchLine ) < 0 )

	mov	eax, DWORD PTR _pchLine$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysWriteLine@12
	test	eax, eax
	jge	SHORT $LN18@fnProcessS

; 6621 :          {
; 6622 :             TraceLineS( "(kzoeneta) ** Error writing line to file.", "" );

	push	OFFSET $SG15769
	push	OFFSET $SG15770
	call	_TraceLineS@8

; 6623 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 6624 :             goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN18@fnProcessS:

; 6625 :          }
; 6626 :       }
; 6627 : 
; 6628 :    } // while ( TRUE )...

	jmp	$LN2@fnProcessS
$LN3@fnProcessS:

; 6629 : 
; 6630 :    //=======================================================================
; 6631 :    // Transmitting data.
; 6632 :    //
; 6633 :    // Until we close the connection, the following code only SENDS data over
; 6634 :    // the network.
; 6635 :    //=======================================================================
; 6636 : 
; 6637 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN21@fnProcessS

; 6638 :    {
; 6639 :       TraceLineI( "(kzoeneta) ** Sending # of lines.  Lines = ", iLineCount );

	movsx	eax, WORD PTR _iLineCount$[ebp]
	push	eax
	push	OFFSET $SG15772
	call	_TraceLineI@8
$LN21@fnProcessS:

; 6640 :    }
; 6641 : 
; 6642 :    // Send number of lines received.
; 6643 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_RC, iLineCount ) != 0 )

	movsx	ecx, WORD PTR _iLineCount$[ebp]
	push	ecx
	push	35					; 00000023H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN22@fnProcessS

; 6644 :    {
; 6645 :       TraceLineS( "(kzoeneta) ** Not able send line count!", "" );

	push	OFFSET $SG15774
	push	OFFSET $SG15775
	call	_TraceLineS@8

; 6646 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6647 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$28
$LN22@fnProcessS:

; 6648 :    }
; 6649 : 
; 6650 :    if ( fnSendMsgAndTraceObj( lpNetwork, ppvConn, vSubtask ) == zCALL_ERROR )

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendMsgAndTraceObj@12
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN23@fnProcessS

; 6651 :    {
; 6652 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 6653 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$28
$LN23@fnProcessS:

; 6654 :    }
; 6655 : 
; 6656 :    if ( fnFlushBuffer( lpNetwork, ppvConn ) != 0 )

	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnFlushBuffer@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN24@fnProcessS

; 6657 :    {
; 6658 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6659 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$28
$LN24@fnProcessS:

; 6660 :    }
; 6661 : 
; 6662 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$28:

; 6663 : 
; 6664 : EndOfFunction:
; 6665 :    if ( f != -1 )

	cmp	DWORD PTR _f$[ebp], -1
	je	SHORT $LN25@fnProcessS

; 6666 :       SysCloseFile( vSubtask, f, 0 );

	push	0
	mov	ecx, DWORD PTR _f$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysCloseFile@12
$LN25@fnProcessS:

; 6667 : 
; 6668 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN26@fnProcessS

; 6669 :       DROPSUBTASK( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropSubtask$1[ebp], eax
	push	0
	mov	edx, DWORD PTR _lpDropSubtask$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDropSubtask$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH
$LN26@fnProcessS:

; 6670 : 
; 6671 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 6672 : 
; 6673 : } // fnProcesssSendFile

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnProcessSendFile@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pchPassword$ = -932					; size = 4
_pchUserName$ = -928					; size = 4
_lpTask$ = -924						; size = 4
_lpViewOI$1 = -920					; size = 4
_lpViewCsr$2 = -916					; size = 4
_lpWkViewOD$3 = -912					; size = 4
_pchOperName$ = -908					; size = 4
_pchAppName$ = -904					; size = 4
_lpDropSubtask$4 = -900					; size = 4
tv149 = -896						; size = 4
_lpDropSubtask$5 = -892					; size = 4
_lpDropSubtask$6 = -888					; size = 4
_pfnOper$ = -884					; size = 4
_lpApp$ = -880						; size = 4
_lpViewOD$ = -876					; size = 4
_lRC$ = -872						; size = 4
_vViewSubtask$7 = -868					; size = 4
_pchObjectName$ = -864					; size = 4
_hLibrary$ = -860					; size = 4
_pchDLL_Name$ = -856					; size = 4
_pchApplName$8 = -852					; size = 4
_nReturnCode$ = -848					; size = 2
_bTransformation$ = -842				; size = 1
_bFlushNeeded$ = -841					; size = 1
_nViewCount$ = -840					; size = 2
_vSubtask$ = -836					; size = 4
_nRC$ = -832						; size = 2
_vArgs$ = -828						; size = 4
_k$ = -824						; size = 2
_pvViewList$ = -820					; size = 160
_vViewList$ = -660					; size = 160
_szClientAddress$9 = -500				; size = 200
_szName$ = -300						; size = 257
_szAppName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpNetwork$ = 12					; size = 4
_ppvConn$ = 16						; size = 4
_fnProcessOperation@12 PROC

; 6682 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 932				; 000003a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6683 :    LPTASK    lpTask;
; 6684 :    zBOOL     bFlushNeeded = FALSE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 0

; 6685 :    zBOOL     bTransformation;
; 6686 :    zLONG     lRC;
; 6687 :    zVIEW     vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 6688 :    zVIEW     vArgs = 0;

	mov	DWORD PTR _vArgs$[ebp], 0

; 6689 :    zCHAR     szAppName[ zAPPL_NAME_LTH ];
; 6690 :    zPCHAR    pchAppName;
; 6691 :    zPCHAR    pchObjectName;
; 6692 :    zPCHAR    pchUserName;
; 6693 :    zPCHAR    pchPassword;
; 6694 :    zPCHAR    pchOperName;
; 6695 :    zPCHAR    pchDLL_Name;
; 6696 :    zVIEW     vViewList[ 40 ];        // Max 40 views passed to transformation.
; 6697 :    zPVIEW    pvViewList[ 40 ];
; 6698 :    zSHORT    nViewCount = -1;

	or	eax, -1
	mov	WORD PTR _nViewCount$[ebp], ax

; 6699 :    zCHAR     szName[ zMAX_FILENAME_LTH + 1 ];
; 6700 :    LPAPP     lpApp;
; 6701 :    LPVIEWOD  lpViewOD;
; 6702 :    LPLIBRARY hLibrary;
; 6703 :    LPFN_CALLOPER pfnOper;
; 6704 :    zSHORT    nReturnCode = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], cx

; 6705 :    zSHORT    nRC;
; 6706 :    zSHORT    k;
; 6707 : 
; 6708 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN20@fnProcessO

; 6709 :    {
; 6710 :       TraceLineS( "(kzoeneta) ** Received Transformation message.", "" );

	push	OFFSET $SG15850
	push	OFFSET $SG15851
	call	_TraceLineS@8

; 6711 :       TraceLineS( "(kzoeneta) ** Retrieving the Argument OI.", "" );

	push	OFFSET $SG15852
	push	OFFSET $SG15853
	call	_TraceLineS@8
$LN20@fnProcessO:

; 6712 :    }
; 6713 : 
; 6714 :    zmemset( vViewList, 0, sizeof( vViewList ) );

	push	160					; 000000a0H
	push	0
	lea	ecx, DWORD PTR _vViewList$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 6715 : 
; 6716 :    //=======================================================================
; 6717 :    // Receiving data.
; 6718 :    //
; 6719 :    // Until noted below, we will only RECEIVE data over the network.
; 6720 :    //=======================================================================
; 6721 :    // First retrieve the app name.
; 6722 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6723 :                                    &pchAppName, zAPPL_NAME_LTH,
; 6724 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	33					; 00000021H
	lea	edx, DWORD PTR _pchAppName$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+174]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN21@fnProcessO

; 6725 :    {
; 6726 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve app name.", "" );

	push	OFFSET $SG15855
	push	OFFSET $SG15856
	call	_TraceLineS@8

; 6727 :       goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN21@fnProcessO:

; 6728 :    }
; 6729 : 
; 6730 :    zstrcpy( szAppName, pchAppName );

	mov	edx, DWORD PTR _pchAppName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 6731 : 
; 6732 :    if ( SfCreateSubtask( &vSubtask, lpTaskView, szAppName ) == zCALL_ERROR )

	lea	ecx, DWORD PTR _szAppName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SfCreateSubtask@12
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN22@fnProcessO

; 6733 :       goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN22@fnProcessO:

; 6734 : 
; 6735 :    lpTask = fnOperationCall( iNetCallOperation, vSubtask, 0 );

	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	513					; 00000201H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax

; 6736 :    fnCreateMsgObj( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_fnCreateMsgObj@4

; 6737 : 
; 6738 :    if ( fnReceiveOI( ppvConn, lpNetwork, &vArgs, vSubtask, "kztranwo",
; 6739 :                      zSINGLE | zACTIVATE_SYSTEM ) == zCALL_ERROR )

	push	536870912				; 20000000H
	push	OFFSET $SG15859
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	call	_fnReceiveOI@24
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN23@fnProcessO

; 6740 :    {
; 6741 :       TraceLineS( "(kzoeneta) ** Not able to retrieve Arg List!", "" );

	push	OFFSET $SG15860
	push	OFFSET $SG15861
	call	_TraceLineS@8

; 6742 :       goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN23@fnProcessO:

; 6743 :    }
; 6744 : 
; 6745 :    bTransformation = (CompareAttributeToString( vArgs, "Operation",

	push	OFFSET $SG15862
	push	OFFSET $SG15863
	push	OFFSET $SG15864
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN63@fnProcessO
	mov	DWORD PTR tv149[ebp], 1
	jmp	SHORT $LN64@fnProcessO
$LN63@fnProcessO:
	mov	DWORD PTR tv149[ebp], 0
$LN64@fnProcessO:
	mov	dl, BYTE PTR tv149[ebp]
	mov	BYTE PTR _bTransformation$[ebp], dl

; 6746 :                                                 "OperationType",
; 6747 :                                                 zTYPE_TRAN ) == 0);
; 6748 : 
; 6749 :    // Make sure it's a valid object.
; 6750 :    if ( bTransformation )

	movzx	eax, BYTE PTR _bTransformation$[ebp]
	test	eax, eax
	je	SHORT $LN24@fnProcessO

; 6751 :    {
; 6752 :       GetAddrForAttribute( &pchObjectName, vArgs, "Operation", "ObjectName" );

	push	OFFSET $SG15866
	push	OFFSET $SG15867
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchObjectName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 6753 :       lpViewOD = ActivateViewObject( vSubtask, pchObjectName, FALSE );

	push	0
	mov	eax, DWORD PTR _pchObjectName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6754 :       if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN24@fnProcessO

; 6755 :       {
; 6756 :          if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6757 :                                 zNETERR_INVALIDOD ) != 0 )

	push	2
	push	42					; 0000002aH
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN26@fnProcessO

; 6758 :          {
; 6759 :             TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15870
	push	OFFSET $SG15871
	call	_TraceLineS@8
$LN26@fnProcessO:

; 6760 :          }
; 6761 : 
; 6762 :          bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 6763 :          goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN24@fnProcessO:

; 6764 :       }
; 6765 :    }
; 6766 : 
; 6767 :    // Loop through each of the arguments looking for views.  If one is found
; 6768 :    // check to see if it was sent to us.  If so, retrieve it.
; 6769 :    for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 );

	push	0
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnProcessO
$LN2@fnProcessO:

; 6771 :          nRC = SetCursorNextEntity( vArgs, szlArgument, 0 ) )

	push	0
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnProcessO:

; 6770 :          nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN3@fnProcessO

; 6772 :    {
; 6773 :       zPCHAR pchApplName;
; 6774 :       zVIEW  vViewSubtask;
; 6775 : 
; 6776 :       // If the DataType is 'l', then this argument represents the client's
; 6777 :       // address ('l' for local).  To keep people from cheating, we will
; 6778 :       // retrieve the client address directly from the network.
; 6779 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 6780 :                                      "DataType", "l" ) == 0 )

	push	OFFSET $SG15873
	push	OFFSET $SG15874
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN27@fnProcessO

; 6781 :       {
; 6782 :          zCHAR szClientAddress[ 200 ];
; 6783 : 
; 6784 :          // Call network handler to get address of the remote node.
; 6785 :          if ( (*lpNetwork->lpfnGetAddress)( vSubtask,
; 6786 :                                             &lpNetwork->pNetworkHandle,
; 6787 :                                             ppvConn, 'R',
; 6788 :                                             szClientAddress ) != 0 )

	lea	ecx, DWORD PTR _szClientAddress$9[ebp]
	push	ecx
	push	82					; 00000052H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+190]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN28@fnProcessO

; 6789 :          {
; 6790 :             goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN28@fnProcessO:

; 6791 :          }
; 6792 : 
; 6793 :          SetAttributeFromString( vArgs, szlArgument, "Value", szClientAddress );

	lea	edx, DWORD PTR _szClientAddress$9[ebp]
	push	edx
	push	OFFSET $SG15876
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 6794 :          continue;

	jmp	$LN2@fnProcessO
$LN27@fnProcessO:

; 6795 :       }
; 6796 : 
; 6797 :       // If the argument is not a view, then don't worry about it.
; 6798 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 6799 :                                      "DataType", "V" ) != 0 )

	push	OFFSET $SG15878
	push	OFFSET $SG15879
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN29@fnProcessO

; 6800 :       {
; 6801 :          continue;

	jmp	$LN2@fnProcessO
$LN29@fnProcessO:

; 6802 :       }
; 6803 : 
; 6804 :       nViewCount++;

	mov	ax, WORD PTR _nViewCount$[ebp]
	add	ax, 1
	mov	WORD PTR _nViewCount$[ebp], ax

; 6805 :       vViewList[ nViewCount ] = 0;

	movsx	ecx, WORD PTR _nViewCount$[ebp]
	mov	DWORD PTR _vViewList$[ebp+ecx*4], 0

; 6806 : 
; 6807 :       GetAddrForAttribute( &pchApplName, vArgs, szlArgument,

	push	OFFSET $SG15880
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchApplName$8[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 6808 :                            "ApplicationName" );
; 6809 : 
; 6810 :       // If SubtaskView is 'Y', then the view is a subtask view so nothing
; 6811 :       // was sent but we do need to set up a subtask view.
; 6812 :       if ( CompareAttributeToString( vArgs, szlArgument, "SubtaskView",
; 6813 :                                      "Y" ) == 0 )

	push	OFFSET $SG15882
	push	OFFSET $SG15883
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN30@fnProcessO

; 6814 :       {
; 6815 :          // ** Not Sure Which VIEW to use -----------------------\/
; 6816 :          SfCreateSubtask( &vViewList[ nViewCount ], lpTaskView, pchApplName );

	mov	eax, DWORD PTR _pchApplName$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nViewCount$[ebp]
	lea	eax, DWORD PTR _vViewList$[ebp+edx*4]
	push	eax
	call	_SfCreateSubtask@12

; 6817 :          continue;

	jmp	$LN2@fnProcessO
$LN30@fnProcessO:

; 6818 :       }
; 6819 : 
; 6820 :       // If the client didn't send the argument, then continue.  The view
; 6821 :       // in vViewList has already been set to 0.
; 6822 :       if ( CompareAttributeToString( vArgs, szlArgument, "SendArgument",
; 6823 :                                      "N" ) == 0 )

	push	OFFSET $SG15885
	push	OFFSET $SG15886
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN31@fnProcessO

; 6824 :       {
; 6825 :          continue;

	jmp	$LN2@fnProcessO
$LN31@fnProcessO:

; 6826 :       }
; 6827 : 
; 6828 :       // If application name was supplied then the current view argument is
; 6829 :       // for an object def from another application.  Create a temporary
; 6830 :       // subtask view for that application.
; 6831 :       if ( pchApplName && *pchApplName )

	cmp	DWORD PTR _pchApplName$8[ebp], 0
	je	SHORT $LN32@fnProcessO
	mov	eax, DWORD PTR _pchApplName$8[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN32@fnProcessO

; 6832 :          SfCreateSubtask( &vViewSubtask, vSubtask, pchApplName );

	mov	edx, DWORD PTR _pchApplName$8[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vViewSubtask$7[ebp]
	push	ecx
	call	_SfCreateSubtask@12
	jmp	SHORT $LN33@fnProcessO
$LN32@fnProcessO:

; 6833 :       else
; 6834 :          vViewSubtask = vSubtask;  // Use "global" subtask.

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	DWORD PTR _vViewSubtask$7[ebp], edx
$LN33@fnProcessO:

; 6835 : 
; 6836 :       // Try retrieving the view from the network.
; 6837 :       GetAddrForAttribute( &pchObjectName, vArgs, szlArgument, "ObjectName" );

	push	OFFSET $SG15889
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchObjectName$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 6838 :       nRC = fnReceiveOI( ppvConn, lpNetwork, &vViewList[ nViewCount ],

	push	0
	mov	edx, DWORD PTR _pchObjectName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vViewSubtask$7[ebp]
	push	eax
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	lea	edx, DWORD PTR _vViewList$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	call	_fnReceiveOI@24
	mov	WORD PTR _nRC$[ebp], ax

; 6839 :                          vViewSubtask, pchObjectName, zSINGLE );
; 6840 : 
; 6841 :       // If we created a temp subtask drop it.
; 6842 :       if ( pchApplName && *pchApplName )

	cmp	DWORD PTR _pchApplName$8[ebp], 0
	je	SHORT $LN34@fnProcessO
	mov	edx, DWORD PTR _pchApplName$8[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN34@fnProcessO

; 6843 :          DROPSUBTASK( vViewSubtask );

	mov	ecx, DWORD PTR _vViewSubtask$7[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropSubtask$4[ebp], eax
	push	0
	mov	eax, DWORD PTR _lpDropSubtask$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDropSubtask$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH
$LN34@fnProcessO:

; 6844 : 
; 6845 :       // Check return code from fnReceiveOI.
; 6846 :       if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN35@fnProcessO

; 6847 :       {
; 6848 :          TraceLineS( "(kzoeneta) ** Not able to retrieve Arg List!", "" );

	push	OFFSET $SG15892
	push	OFFSET $SG15893
	call	_TraceLineS@8

; 6849 :          goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN35@fnProcessO:

; 6850 :       }
; 6851 : 
; 6852 :    } // for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 )...

	jmp	$LN2@fnProcessO
$LN3@fnProcessO:

; 6853 : 
; 6854 :    //=======================================================================
; 6855 :    // Transmitting data.
; 6856 :    //
; 6857 :    // Until we close the connection, the following code only SENDS data over
; 6858 :    // the network.
; 6859 :    //=======================================================================
; 6860 : 
; 6861 :    bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 6862 : 
; 6863 :    GetAddrForAttribute( &pchUserName, vArgs, "Operation", "UserName" );

	push	OFFSET $SG15894
	push	OFFSET $SG15895
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchUserName$[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 6864 :    GetAddrForAttribute( &pchPassword, vArgs, "Operation", "Password" );

	push	OFFSET $SG15896
	push	OFFSET $SG15897
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchPassword$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 6865 :    GetAddrForAttribute( &pchOperName, vArgs, "Operation", "OperName" );

	push	OFFSET $SG15898
	push	OFFSET $SG15899
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchOperName$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 6866 : 
; 6867 :    SfGetApplicationForSubtask( &lpApp, vSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_SfGetApplicationForSubtask@8

; 6868 : 
; 6869 :    // Set up the view pointer list.
; 6870 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN7@fnProcessO
$LN5@fnProcessO:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN7@fnProcessO:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN6@fnProcessO

; 6871 :       pvViewList[ k ] = &vViewList[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _vViewList$[ebp+ecx*4]
	movsx	eax, WORD PTR _k$[ebp]
	mov	DWORD PTR _pvViewList$[ebp+eax*4], edx
	jmp	SHORT $LN5@fnProcessO
$LN6@fnProcessO:

; 6872 : 
; 6873 :    pvViewList[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	DWORD PTR _pvViewList$[ebp+ecx*4], 0

; 6874 :    zstrcpy( szName, lpApp->szLibraryDir );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 90					; 0000005aH
	push	edx
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 6875 :    SysAppendcDirSep( szName );

	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 6876 : 
; 6877 :    if ( bTransformation )

	movzx	edx, BYTE PTR _bTransformation$[ebp]
	test	edx, edx
	je	SHORT $LN36@fnProcessO

; 6878 :    {
; 6879 :       SfGetApplicationForSubtask( &lpApp, vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_SfGetApplicationForSubtask@8

; 6880 : 
; 6881 :       zstrcpy( szName, lpApp->szLibraryDir );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 90					; 0000005aH
	push	edx
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 6882 :       SysAppendcDirSep( szName );

	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 6883 :       pchDLL_Name = lpViewOD->szOperLibname;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 142				; 0000008eH
	mov	DWORD PTR _pchDLL_Name$[ebp], edx

; 6884 :       zstrcat( szName, lpViewOD->szOperLibname );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 142				; 0000008eH
	push	eax
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 6885 :    }

	jmp	SHORT $LN37@fnProcessO
$LN36@fnProcessO:

; 6886 :    else
; 6887 :    {
; 6888 :       // Call the global operation.
; 6889 :       GetAddrForAttribute( &pchDLL_Name, vArgs, "Operation", "DLL_Name" );

	push	OFFSET $SG15902
	push	OFFSET $SG15903
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchDLL_Name$[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 6890 :       if ( pchDLL_Name && *pchDLL_Name )

	cmp	DWORD PTR _pchDLL_Name$[ebp], 0
	je	SHORT $LN37@fnProcessO
	mov	ecx, DWORD PTR _pchDLL_Name$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN37@fnProcessO

; 6891 :       {
; 6892 :          zstrcat( szName, pchDLL_Name );

	mov	eax, DWORD PTR _pchDLL_Name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN37@fnProcessO:

; 6893 :       }
; 6894 :    }
; 6895 : 
; 6896 :    hLibrary = SysLoadLibrary( vSubtask, szName );

	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 6897 :    if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $LN39@fnProcessO

; 6898 :    {
; 6899 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6900 :                              zNETERR_NOEXECUTABLE ) != 0 )

	push	8
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN40@fnProcessO

; 6901 :       {
; 6902 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_ERROR", "" );

	push	OFFSET $SG15907
	push	OFFSET $SG15908
	call	_TraceLineS@8
$LN40@fnProcessO:

; 6903 :       }
; 6904 : 
; 6905 :       TraceLineS( "(kzoeneta) ** Global operation library = ", szName );

	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET $SG15909
	call	_TraceLineS@8

; 6906 :       SysMessageBox( vSubtask, szlNetworkError,

	push	1
	push	OFFSET $SG15910
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 6907 :                      "Can't find global oper lib.", 1 );
; 6908 :       goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN39@fnProcessO:

; 6909 :    }
; 6910 : 
; 6911 :    zsprintf( szName, "_zCall_%s", pchOperName );

	mov	eax, DWORD PTR _pchOperName$[ebp]
	push	eax
	push	OFFSET $SG15911
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 6912 :    pfnOper = (LPFN_CALLOPER) SysGetProc( hLibrary, szName );

	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pfnOper$[ebp], eax

; 6913 :    if ( pfnOper == 0 )

	cmp	DWORD PTR _pfnOper$[ebp], 0
	jne	SHORT $LN41@fnProcessO

; 6914 :    {
; 6915 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6916 :                              zNETERR_NOOPER ) != 0 )

	push	9
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN42@fnProcessO

; 6917 :       {
; 6918 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_ERROR", "" );

	push	OFFSET $SG15914
	push	OFFSET $SG15915
	call	_TraceLineS@8
$LN42@fnProcessO:

; 6919 :       }
; 6920 : 
; 6921 :       TraceLineS( "(kzoeneta) ** Global operation = ", szName );

	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	push	OFFSET $SG15916
	call	_TraceLineS@8

; 6922 :       SysMessageBox( vSubtask, szlNetworkError,

	push	1
	push	OFFSET $SG15917
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 6923 :                      "Can't find _zCall... func.", 1 );
; 6924 :       SysFreeLibrary( vSubtask, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysFreeLibrary@8

; 6925 :       goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN41@fnProcessO:

; 6926 :    }
; 6927 : 
; 6928 :    // Set up the view pointer list.
; 6929 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN10@fnProcessO
$LN8@fnProcessO:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN10@fnProcessO:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN9@fnProcessO

; 6930 :       pvViewList[ k ] = &vViewList[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _vViewList$[ebp+eax*4]
	movsx	edx, WORD PTR _k$[ebp]
	mov	DWORD PTR _pvViewList$[ebp+edx*4], ecx
	jmp	SHORT $LN8@fnProcessO
$LN9@fnProcessO:

; 6931 : 
; 6932 :    pvViewList[ k ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	DWORD PTR _pvViewList$[ebp+eax*4], 0

; 6933 : 
; 6934 :    // Ok, boys, this is it--call the transformation shell.
; 6935 :    lRC = (*pfnOper)( vArgs, pvViewList );

	lea	ecx, DWORD PTR _pvViewList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	DWORD PTR _pfnOper$[ebp]
	mov	DWORD PTR _lRC$[ebp], eax

; 6936 : 
; 6937 :    SysFreeLibrary( vSubtask, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SysFreeLibrary@8

; 6938 : 
; 6939 :    // Loop through each of the arguments looking for views that need to be
; 6940 :    // returned.  Later on we'll send the arg list object back to the client.
; 6941 :    // To save transmission time we'll null out the values of arguments that
; 6942 :    // we don't have to send back.
; 6943 :    k = -1;

	or	edx, -1
	mov	WORD PTR _k$[ebp], dx

; 6944 :    for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 );

	push	0
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN13@fnProcessO
$LN11@fnProcessO:

; 6946 :          nRC = SetCursorNextEntity( vArgs, szlArgument, 0 ) )

	push	0
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN13@fnProcessO:

; 6945 :          nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN12@fnProcessO

; 6947 :    {
; 6948 :       LPVIEWOD  lpWkViewOD;
; 6949 :       LPVIEWCSR lpViewCsr;
; 6950 :       LPVIEWOI  lpViewOI;
; 6951 : 
; 6952 :       // If the argument is not a view, then don't worry about it.
; 6953 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 6954 :                                      "DataType", "V" ) != 0 )

	push	OFFSET $SG15919
	push	OFFSET $SG15920
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN43@fnProcessO

; 6955 :       {
; 6956 :          // If we aren't sending the argument back then set it to null.
; 6957 :          if ( CompareAttributeToString( vArgs, szlArgument,
; 6958 :                                         "ReturnArgument", "Y" ) != 0 )

	push	OFFSET $SG15922
	push	OFFSET $SG15923
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	je	SHORT $LN44@fnProcessO

; 6959 :          {
; 6960 :             SetAttributeFromString( vArgs, szlArgument, "Value", "" );

	push	OFFSET $SG15924
	push	OFFSET $SG15925
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN44@fnProcessO:

; 6961 :          }
; 6962 : 
; 6963 :          continue;

	jmp	$LN11@fnProcessO
$LN43@fnProcessO:

; 6964 :       }
; 6965 : 
; 6966 :       k++; // Keep track of number of views.

	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 6967 : 
; 6968 :       // If the view is not flagged as a returned view, forget it.
; 6969 :       nRC = CompareAttributeToString( vArgs, szlArgument,

	push	OFFSET $SG15926
	push	OFFSET $SG15927
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	mov	WORD PTR _nRC$[ebp], ax

; 6970 :                                       "ReturnArgument", "Y" );
; 6971 :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN45@fnProcessO

; 6972 :          continue;

	jmp	$LN11@fnProcessO
$LN45@fnProcessO:

; 6973 : 
; 6974 :       // Don't bother sending back the view if it is null.
; 6975 :       if ( vViewList[ k ] == 0 || vViewList[ k ]->hViewCsr == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	DWORD PTR _vViewList$[ebp+edx*4], 0
	je	SHORT $LN47@fnProcessO
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vViewList$[ebp+eax*4]
	cmp	DWORD PTR [ecx+10], 0
	jne	SHORT $LN46@fnProcessO
$LN47@fnProcessO:

; 6976 :          continue;

	jmp	$LN11@fnProcessO
$LN46@fnProcessO:

; 6977 : 
; 6978 :       lpWkViewOD = zGETPTR( vViewList[ k ]->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vViewList$[ebp+edx*4]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewOD$3[ebp], eax

; 6979 :       SetAttributeFromString( vArgs, szlArgument, "ObjectName",

	mov	edx, DWORD PTR _lpWkViewOD$3[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG15931
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 6980 :                               lpWkViewOD->szName );
; 6981 : 
; 6982 :       lpViewCsr = zGETPTR( vViewList[ k ]->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vViewList$[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 6983 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$2[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$1[ebp], eax

; 6984 : 
; 6985 :       // If there is no root entity instance, then the OI is empty.
; 6986 :       if ( lpViewOI->hRootEntityInstance == 0 )

	mov	eax, DWORD PTR _lpViewOI$1[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN48@fnProcessO

; 6987 :       {
; 6988 :          SetAttributeFromString( vArgs, szlArgument, "ViewReturned", "E" );

	push	OFFSET $SG15933
	push	OFFSET $SG15934
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 6989 :          continue;

	jmp	$LN11@fnProcessO
$LN48@fnProcessO:

; 6990 :       }
; 6991 : 
; 6992 :       // Set flag to indicate we are returning the view.
; 6993 :       SetAttributeFromString( vArgs, szlArgument, "ViewReturned", "Y" );

	push	OFFSET $SG15935
	push	OFFSET $SG15936
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 6994 : 
; 6995 :    } // for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 )...

	jmp	$LN11@fnProcessO
$LN12@fnProcessO:

; 6996 : 
; 6997 :    // Send return code.
; 6998 :    GetIntegerFromAttribute( &lRC, vArgs, "Operation", "ReturnValue" );

	push	OFFSET $SG15937
	push	OFFSET $SG15938
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lRC$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 6999 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN49@fnProcessO

; 7000 :       TraceLineI( "(kzoeneta) ** Sending RC packet.  RC = ", lRC );

	mov	ecx, DWORD PTR _lRC$[ebp]
	push	ecx
	push	OFFSET $SG15940
	call	_TraceLineI@8
$LN49@fnProcessO:

; 7001 : 
; 7002 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_RC, lRC ) != 0 )

	mov	edx, DWORD PTR _lRC$[ebp]
	push	edx
	push	35					; 00000023H
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendDataPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN50@fnProcessO

; 7003 :    {
; 7004 :       TraceLineS( "(kzoeneta) ** Not able send Return code!", "" );

	push	OFFSET $SG15942
	push	OFFSET $SG15943
	call	_TraceLineS@8

; 7005 :       goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN50@fnProcessO:

; 7006 :    }
; 7007 : 
; 7008 :    // Send the vArgs view back to the client.
; 7009 :    if ( fnSendOI( ppvConn, lpNetwork, vArgs, 0 ) == zCALL_ERROR )

	push	0
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	call	_fnSendOI@16
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN51@fnProcessO

; 7010 :    {
; 7011 :       TraceLineS( "(kzoeneta) ** Not able send vArgs back to client!", "" );

	push	OFFSET $SG15945
	push	OFFSET $SG15946
	call	_TraceLineS@8

; 7012 :       goto EndOfFunction;

	jmp	$EndOfFunction$65
$LN51@fnProcessO:

; 7013 :    }
; 7014 : 
; 7015 :    // Loop through each of the arguments looking for views we need to send
; 7016 :    // back to the client.
; 7017 :    k = -1;

	or	ecx, -1
	mov	WORD PTR _k$[ebp], cx

; 7018 :    for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 );

	push	0
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN16@fnProcessO
$LN14@fnProcessO:

; 7020 :          nRC = SetCursorNextEntity( vArgs, szlArgument, 0 ) )

	push	0
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN16@fnProcessO:

; 7019 :          nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN15@fnProcessO

; 7021 :    {
; 7022 :       // If the argument is not a view, then don't worry about it.
; 7023 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 7024 :                                      "DataType", "V" ) != 0 )

	push	OFFSET $SG15948
	push	OFFSET $SG15949
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	je	SHORT $LN52@fnProcessO

; 7025 :          continue;

	jmp	SHORT $LN14@fnProcessO
$LN52@fnProcessO:

; 7026 : 
; 7027 :       k++;

	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx

; 7028 : 
; 7029 :       // Don't worry about the view if we're not sending it back.
; 7030 :       nRC = CompareAttributeToString( vArgs, szlArgument, "ViewReturned", "Y" );

	push	OFFSET $SG15950
	push	OFFSET $SG15951
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	mov	WORD PTR _nRC$[ebp], ax

; 7031 :       if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN53@fnProcessO

; 7032 :          continue;

	jmp	$LN14@fnProcessO
$LN53@fnProcessO:

; 7033 : 
; 7034 : #ifdef DGC
; 7035 :       if ( lpNetwork->nTraceLevel > 0 )
; 7036 :       {
; 7037 :          zCHAR szTempFileName[ zMAX_FILENAME_LTH + 1 ];
; 7038 : 
; 7039 :          SysGetEnvVar( szTempFileName, "TEMP", zMAX_FILENAME_LTH + 1 );
; 7040 :          SysAppendcDirSep( szTempFileName );
; 7041 :          zstrcat( szTempFileName, "tranoi.por" );
; 7042 :          CommitOI_ToFile( vViewList[ k ], szTempFileName,
; 7043 :                           zINCREMENTAL | zSAVE_CURSORS );
; 7044 :       }
; 7045 : #endif
; 7046 : 
; 7047 :       // Send the vArgs view back to the client.
; 7048 :       if ( fnSendOI( ppvConn, lpNetwork, vViewList[ k ],
; 7049 :                      zINCREMENTAL | zSAVE_CURSORS ) == zCALL_ERROR )

	push	327680					; 00050000H
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vViewList$[ebp+ecx*4]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	call	_fnSendOI@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN54@fnProcessO

; 7050 :       {
; 7051 :          TraceLineS( "(kzoeneta) ** Not able send view argument back to client!", "" );

	push	OFFSET $SG15954
	push	OFFSET $SG15955
	call	_TraceLineS@8

; 7052 :          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$65
$LN54@fnProcessO:

; 7053 :       }
; 7054 : 
; 7055 :    } // for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 )...

	jmp	$LN14@fnProcessO
$LN15@fnProcessO:

; 7056 : 
; 7057 :    // If we get here then everything's fine...
; 7058 :    nReturnCode = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnCode$[ebp], ax
$EndOfFunction$65:

; 7059 : 
; 7060 : EndOfFunction:
; 7061 :    if ( vSubtask &&

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN55@fnProcessO
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendMsgAndTraceObj@12
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN55@fnProcessO

; 7062 :         fnSendMsgAndTraceObj( lpNetwork, ppvConn, vSubtask ) == zCALL_ERROR )
; 7063 :    {
; 7064 :       nReturnCode = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], dx
$LN55@fnProcessO:

; 7065 :    }
; 7066 : 
; 7067 :    if ( bFlushNeeded && fnFlushBuffer( lpNetwork, ppvConn ) != 0 )

	movzx	eax, BYTE PTR _bFlushNeeded$[ebp]
	test	eax, eax
	je	SHORT $LN56@fnProcessO
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnFlushBuffer@8
	cwde
	test	eax, eax
	je	SHORT $LN56@fnProcessO

; 7068 :       nReturnCode = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN56@fnProcessO:

; 7069 : 
; 7070 :    for ( k = 0; k <= nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN19@fnProcessO
$LN17@fnProcessO:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN19@fnProcessO:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jg	$LN18@fnProcessO

; 7071 :    {
; 7072 :       if ( vViewList[ k ] )

	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR _vViewList$[ebp+eax*4], 0
	je	SHORT $LN57@fnProcessO

; 7073 :       {
; 7074 :          if ( vViewList[ k ]->hSubtask )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vViewList$[ebp+ecx*4]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN58@fnProcessO

; 7075 :          {
; 7076 :             DROPSUBTASK( vViewList[ k ] );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vViewList$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropSubtask$6[ebp], eax
	push	0
	mov	eax, DWORD PTR _lpDropSubtask$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDropSubtask$6[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH

; 7077 :          }

	jmp	SHORT $LN57@fnProcessO
$LN58@fnProcessO:

; 7078 :          else
; 7079 :             fnDropView( vViewList[ k ] );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vViewList$[ebp+eax*4]
	push	ecx
	call	_fnDropView@4
$LN57@fnProcessO:

; 7080 :       }
; 7081 :    }

	jmp	$LN17@fnProcessO
$LN18@fnProcessO:

; 7082 : 
; 7083 :    if ( vArgs )

	cmp	DWORD PTR _vArgs$[ebp], 0
	je	SHORT $LN60@fnProcessO

; 7084 :       fnDropView( vArgs );

	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_fnDropView@4
$LN60@fnProcessO:

; 7085 : 
; 7086 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN61@fnProcessO

; 7087 :       DROPSUBTASK( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropSubtask$5[ebp], eax
	push	0
	mov	edx, DWORD PTR _lpDropSubtask$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDropSubtask$5[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH
$LN61@fnProcessO:

; 7088 : 
; 7089 :    fnOperationReturn( iNetCallOperation, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	513					; 00000201H
	call	_fnOperationReturn
	add	esp, 8

; 7090 :    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]

; 7091 : 
; 7092 : } // fnProcesssOperation

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnProcessOperation@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_fnProcessCommitOI_ToFile@8 PROC

; 6283 : {

	push	ebp
	mov	ebp, esp

; 6284 :    TraceLineS( "(kzoeneta) ** ", "fnProcessCommitOI_ToFile( ) is Deprecated" );

	push	OFFSET $SG15704
	push	OFFSET $SG15705
	call	_TraceLineS@8

; 6285 :    return( 0 );

	xor	eax, eax

; 6286 : 
; 6287 : #if 0
; 6288 :    zSHORT nRC = 0;
; 6289 :    zBOOL  bFlushNeeded = FALSE;
; 6290 :    zVIEW  vSubtask = 0;
; 6291 :    zVIEW  vOI = 0;
; 6292 :    zPCHAR pch;
; 6293 :    zSHORT nFileNameLth;
; 6294 :    zBOOL  bSystem;
; 6295 :    zLONG  lControl;
; 6296 :    zCHAR  szFileName[ zMAX_FILENAME_LTH + 1 ];
; 6297 :    zCommitPacket  CommitPacket;
; 6298 :    LPCOMMITPACKET lpCommitPacket;
; 6299 : 
; 6300 :    if ( lpNetwork->nTraceLevel > 0 )
; 6301 :    {
; 6302 :       TraceLineS( "(kzoeneta) ** Received Commit OI message.", "" );
; 6303 :       TraceLineS( "(kzoeneta) ** Retrieving Commit packet.", "" );
; 6304 :    }
; 6305 : 
; 6306 :    //=======================================================================
; 6307 :    // Receiving data.
; 6308 :    //
; 6309 :    // Until noted below, we will only RECEIVE data over the network.
; 6310 :    //=======================================================================
; 6311 : 
; 6312 :    // First thing to do is retrieve the commit info.
; 6313 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6314 :                                    &lpCommitPacket, sizeof( zCommitPacket ),
; 6315 :                                    zTYPE_STRING ) != 0 )
; 6316 :    {
; 6317 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Commit info", "" );
; 6318 :       nRC = zCALL_ERROR;
; 6319 :       goto EndOfFunction;
; 6320 :    }
; 6321 : 
; 6322 :    // Store the info locally -- as soon as we perform the next network IO
; 6323 :    // operation we aren't assured that lpCommitPacket points to valid data.
; 6324 :    zmemcpy( &CommitPacket, lpCommitPacket, sizeof( zCommitPacket ) );
; 6325 :    lControl = zxtol( CommitPacket.szControl );
; 6326 : 
; 6327 :    // Retrieve the file name.
; 6328 :    nFileNameLth = (zSHORT) zxtol( CommitPacket.szFileNameLth );
; 6329 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6330 :                                    &pch, nFileNameLth,
; 6331 :                                    zTYPE_STRING ) != 0 )
; 6332 :    {
; 6333 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve file name.", "" );
; 6334 :       nRC = zCALL_ERROR;
; 6335 :       goto EndOfFunction;
; 6336 :    }
; 6337 : 
; 6338 :    zstrcpy( szFileName, pch );
; 6339 : 
; 6340 : #if 0
; 6341 :    /* this code doesn't work unless client changed, HH, 08.11.1996
; 6342 :    */
; 6343 :    zstrcpy( szFileName, vSubtask->hSubtask->hApp->hObjectDir );
; 6344 :    SysAppendcDirSep( szFileName );
; 6345 :    zstrcat( szFileName, pch );
; 6346 : #endif
; 6347 : 
; 6348 :    if ( lpNetwork->nTraceLevel > 0 )
; 6349 :    {
; 6350 :       TraceLine( "(kzoeneta) ** User Name: %s  App Name: %s  "
; 6351 :                    "Object Def: %s  File Name: %s",
; 6352 :                  CommitPacket.szUserName, CommitPacket.szAppName,
; 6353 :                  CommitPacket.szObjectDef, pch );
; 6354 :    }
; 6355 : 
; 6356 :    // Try to create a subtask view using the application name passed.
; 6357 :    if ( CREATESUBTASK( &vSubtask, CommitPacket.szAppName ) == zCALL_ERROR )
; 6358 :    {
; 6359 :       TraceLineS( "(kzoeneta) ** Invalid App name = ", CommitPacket.szAppName );
; 6360 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6361 :                              zNETERR_INVALIDAPP ) != 0 )
; 6362 :       {
; 6363 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );
; 6364 :       }
; 6365 : 
; 6366 :       nRC = zCALL_ERROR;
; 6367 :       bFlushNeeded = TRUE;
; 6368 :       goto EndOfFunction;
; 6369 :    }
; 6370 : 
; 6371 :    fnCreateMsgObj( vSubtask );
; 6372 : 
; 6373 :    if ( lpNetwork->nTraceLevel > 0 )
; 6374 :       TraceLineS( "(kzoeneta) ** Full name  = ", szFileName );
; 6375 : 
; 6376 :    // Make sure request is for valid OD.
; 6377 :    if ( lControl & zACTIVATE_SYSTEM )
; 6378 :       bSystem = TRUE;
; 6379 :    else
; 6380 :       bSystem = FALSE;
; 6381 :    if ( ActivateViewObject( vSubtask, CommitPacket.szObjectDef, bSystem ) == 0 )
; 6382 :    {
; 6383 :       TraceLineS( "(kzoeneta) ** Invalid OD name = ", CommitPacket.szObjectDef );
; 6384 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6385 :                              zNETERR_INVALIDOD ) != 0 )
; 6386 :       {
; 6387 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );
; 6388 :       }
; 6389 : 
; 6390 :       nRC = zCALL_ERROR;
; 6391 :       bFlushNeeded = TRUE;
; 6392 :       goto EndOfFunction;
; 6393 :    }
; 6394 : 
; 6395 :    if ( lpNetwork->nTraceLevel > 0 )
; 6396 :    {
; 6397 :       TraceLineS( "(kzoeneta) ** Receiving OI to commit.", "" );
; 6398 :    }
; 6399 : 
; 6400 :    // Retrieve the OI we need to commit.  Add the zACTIVATE_SYSTEM flag if it
; 6401 :    // is specified in lControl.
; 6402 :    nRC = fnReceiveOI( ppvConn, lpNetwork, &vOI, vSubtask,
; 6403 :                       CommitPacket.szObjectDef,
; 6404 :                       zMULTIPLE | ( lControl & zACTIVATE_SYSTEM ) );
; 6405 :    if ( nRC == zCALL_ERROR )
; 6406 :    {
; 6407 :       TraceLineS( "(kzoeneta) ** Not able to retrieve OI for commit!", "" );
; 6408 :       nRC = zCALL_ERROR;
; 6409 :       goto EndOfFunction;
; 6410 :    }
; 6411 : 
; 6412 :    //=======================================================================
; 6413 :    // Transmitting data.
; 6414 :    //
; 6415 :    // Until we close the connection, the following code only SENDS data over
; 6416 :    // the network.
; 6417 :    //=======================================================================
; 6418 : 
; 6419 :    bFlushNeeded = TRUE;
; 6420 : 
; 6421 :    if ( fnCheckForClientAuthority( ppvConn, lpNetwork,
; 6422 :                                    CommitPacket.szAppName,
; 6423 :                                    CommitPacket.szUserName,
; 6424 :                                    CommitPacket.szPassword,
; 6425 :                                    CommitPacket.szObjectDef,
; 6426 :                                    zLADTYPE_LOD_COMMIT_FILE ) < 0 )
; 6427 :    {
; 6428 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6429 :                               zNETERR_NOAUTHORITY ) != 0 )
; 6430 :       {
; 6431 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_ERROR", "" );
; 6432 :       }
; 6433 : 
; 6434 :       nRC = zCALL_ERROR;
; 6435 :       goto EndOfFunction;
; 6436 :    }
; 6437 : 
; 6438 :    SetNameForView( vOI, "__NetCommitWIP", 0, zLEVEL_TASK );
; 6439 : 
; 6440 :    // For right now we will assume that we commit files to the Bin dir
; 6441 :    // of the application.
; 6442 : 
; 6443 :    // Commit the OI but force the activate to occur locally.
; 6444 :    nRC = CommitOI_ToFile( vOI, szFileName, lControl | zACTIVATE_LOCAL );
; 6445 : 
; 6446 :    if ( lpNetwork->nTraceLevel > 0 )
; 6447 :       TraceLineI( "(kzoeneta) ** Sending RC packet.  RC = ", nRC );
; 6448 : 
; 6449 :    // Send return code.
; 6450 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_RC, nRC ) != 0 )
; 6451 :    {
; 6452 :       TraceLineS( "(kzoeneta) ** Not able send Return code!", "" );
; 6453 :       nRC = zCALL_ERROR;
; 6454 :       goto EndOfFunction;
; 6455 :    }
; 6456 : 
; 6457 :    nRC = 0;
; 6458 : 
; 6459 : EndOfFunction:
; 6460 :    if ( vSubtask &&
; 6461 :         fnSendMsgAndTraceObj( lpNetwork, ppvConn, vSubtask ) == zCALL_ERROR )
; 6462 :    {
; 6463 :       nRC = zCALL_ERROR;
; 6464 :    }
; 6465 : 
; 6466 :    if ( bFlushNeeded && fnFlushBuffer( lpNetwork, ppvConn ) != 0 )
; 6467 :    {
; 6468 :       nRC = zCALL_ERROR;
; 6469 :    }
; 6470 : 
; 6471 :    if ( vOI )
; 6472 :       fnDropView( vOI );
; 6473 : 
; 6474 :    if ( vSubtask )
; 6475 :       DROPSUBTASK( vSubtask );
; 6476 : 
; 6477 :    return( nRC );
; 6478 : #endif
; 6479 : 
; 6480 : } // fnProcesssCommitOI_ToFile

	pop	ebp
	ret	8
_fnProcessCommitOI_ToFile@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = 8						; size = 4
_ppvConn$ = 12						; size = 4
_fnProcessActivateOI_FromFile@8 PROC

; 5561 : {

	push	ebp
	mov	ebp, esp

; 5562 :    TraceLineS( "(kzoeneta) ** ", "fnProcessActivateOI_FromFile( ) is deprecated" );

	push	OFFSET $SG15496
	push	OFFSET $SG15497
	call	_TraceLineS@8

; 5563 :    return( 0 );

	xor	eax, eax

; 5564 : 
; 5565 : #if 0
; 5566 :    zSHORT nRC;
; 5567 :    zBOOL  bFlushNeeded = FALSE;
; 5568 :    zVIEW  vSubtask = 0;
; 5569 :    zVIEW  vOI = 0;
; 5570 :    zLONG  lControl;
; 5571 :    zCHAR  szFileName[ zMAX_FILENAME_LTH + 1 ];
; 5572 :    zPCHAR pch;
; 5573 :    zSHORT nFileNameLth;
; 5574 :    zActivatePacket ActPacket;
; 5575 :    LPACTPACKET     lpActPacket;
; 5576 : 
; 5577 :    if ( lpNetwork->nTraceLevel > 0 )
; 5578 :    {
; 5579 :       TraceLineS( "(kzoeneta) ** Received Activate OI From File message.", "" );
; 5580 :       TraceLineS( "(kzoeneta) ** Retrieving Activate info.", "" );
; 5581 :    }
; 5582 : 
; 5583 :    //=======================================================================
; 5584 :    // Receiving data.
; 5585 :    //
; 5586 :    // Until noted below, we will only RECEIVE data over the network.
; 5587 :    //=======================================================================
; 5588 : 
; 5589 :    // First thing to do is retrieve the activate info.
; 5590 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 5591 :                                    &lpActPacket, sizeof( zActivatePacket ),
; 5592 :                                    zTYPE_STRING ) != 0 )
; 5593 :    {
; 5594 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Act info", "" );
; 5595 :       nRC = zCALL_ERROR;
; 5596 :       goto EndOfFunction;
; 5597 :    }
; 5598 : 
; 5599 :    // Store the info locally -- as soon as we perform the next network IO
; 5600 :    // operation we aren't assured that lpActPacket points to valid data.
; 5601 :    zmemcpy( &ActPacket, lpActPacket, sizeof( zActivatePacket ) );
; 5602 :    lControl = zxtol( ActPacket.szControl );
; 5603 : 
; 5604 :    // Retrieve the file name.  Use a dummy pointer to get the file name and
; 5605 :    // then copy it into the allocated buffer.
; 5606 :    nFileNameLth = (zSHORT) zxtol( ActPacket.szFileNameLth );
; 5607 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 5608 :                                    &pch, nFileNameLth, zTYPE_STRING ) != 0 )
; 5609 :    {
; 5610 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve file name.", "" );
; 5611 :       nRC = zCALL_ERROR;
; 5612 :       goto EndOfFunction;
; 5613 :    }
; 5614 : 
; 5615 :    zstrcpy( szFileName, pch );
; 5616 : 
; 5617 :    if ( lpNetwork->nTraceLevel > 0 )
; 5618 :    {
; 5619 :       TraceLine( "(kzoeneta) ** User Name: %s  App Name: %s  "
; 5620 :                    "Object Def: %s  File Name: %s",
; 5621 :                  ActPacket.szUserName, ActPacket.szAppName,
; 5622 :                  ActPacket.szObjectDef, szFileName );
; 5623 :    }
; 5624 : 
; 5625 :    //=======================================================================
; 5626 :    // Transmitting data.
; 5627 :    //
; 5628 :    // Until we close the connection, the following code only SENDS data over
; 5629 :    // the network.
; 5630 :    //=======================================================================
; 5631 : 
; 5632 :    bFlushNeeded = TRUE;
; 5633 : 
; 5634 :    // Try to create a subtask view using the application name passed.
; 5635 :    if ( CREATESUBTASK( &vSubtask, ActPacket.szAppName ) == zCALL_ERROR )
; 5636 :    {
; 5637 :       TraceLineS( "(kzoeneta) ** Invalid App name = ", ActPacket.szAppName );
; 5638 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 5639 :                              zNETERR_INVALIDAPP ) != 0 )
; 5640 :       {
; 5641 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );
; 5642 :       }
; 5643 : 
; 5644 :       nRC = zCALL_ERROR;
; 5645 :       goto EndOfFunction;
; 5646 :    }
; 5647 : 
; 5648 :    fnCreateMsgObj( vSubtask );
; 5649 : 
; 5650 :    // Make sure request is for valid OD.
; 5651 :    if ( ActivateViewObject( vSubtask, ActPacket.szObjectDef, FALSE ) == 0 )
; 5652 :    {
; 5653 :       TraceLineS( "(kzoeneta) ** Invalid OD name = ", ActPacket.szObjectDef );
; 5654 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 5655 :                              zNETERR_INVALIDOD ) != 0 )
; 5656 :       {
; 5657 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );
; 5658 :       }
; 5659 : 
; 5660 :       nRC = zCALL_ERROR;
; 5661 :       goto EndOfFunction;
; 5662 :    }
; 5663 : 
; 5664 :    if ( fnCheckForClientAuthority( ppvConn, lpNetwork, ActPacket.szAppName,
; 5665 :                                    ActPacket.szUserName, ActPacket.szPassword,
; 5666 :                                    ActPacket.szObjectDef,
; 5667 :                                    zLADTYPE_LOD_ACTIVATE_FILE ) < 0 )
; 5668 :    {
; 5669 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 5670 :                               zNETERR_NOAUTHORITY ) != 0 )
; 5671 :       {
; 5672 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_ERROR", "" );
; 5673 :       }
; 5674 : 
; 5675 :       nRC = zCALL_ERROR;
; 5676 :       goto EndOfFunction;
; 5677 :    }
; 5678 : 
; 5679 :    // For right now we will assume that activated files are in the Bin dir
; 5680 :    // of the application.
; 5681 : 
; 5682 :    // Activate the OI.
; 5683 :    nRC = ActivateOI_FromFile( &vOI, ActPacket.szObjectDef, vSubtask,
; 5684 :                               szFileName, lControl );
; 5685 : 
; 5686 :    if ( vOI )
; 5687 :    {
; 5688 :       // Send Ack to signal we got this far.
; 5689 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ACK, 0 ) != 0 )
; 5690 :       {
; 5691 :          TraceLineS( "(kzoeneta) ** Not able to ACK request of OI!", "" );
; 5692 :          nRC = zCALL_ERROR;
; 5693 :          goto EndOfFunction;
; 5694 :       }
; 5695 : 
; 5696 :       if ( lpNetwork->nTraceLevel > 0 )
; 5697 :          TraceLineS( "(kzoeneta) ** Sending Activated OI.", "" );
; 5698 : 
; 5699 :       if ( fnSendOI( ppvConn, lpNetwork, vOI,
; 5700 :                      zINCREMENTAL | zSAVE_CURSORS ) == zCALL_ERROR )
; 5701 :       {
; 5702 :          nRC = zCALL_ERROR;
; 5703 :          goto EndOfFunction;
; 5704 :       }
; 5705 :    }
; 5706 : 
; 5707 :    if ( lpNetwork->nTraceLevel > 0 )
; 5708 :    {
; 5709 :       TraceLineI( "(kzoeneta) ** Sending RC packet. RC = ", nRC );
; 5710 :    }
; 5711 : 
; 5712 :    // Send return code.
; 5713 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_RC, nRC ) != 0 )
; 5714 :    {
; 5715 :       TraceLineS( "(kzoeneta) ** Not able send Return code!", "" );
; 5716 :       nRC = zCALL_ERROR;
; 5717 :       goto EndOfFunction;
; 5718 :    }
; 5719 : 
; 5720 :    nRC = 0;
; 5721 : 
; 5722 : EndOfFunction:
; 5723 :    if ( vSubtask &&
; 5724 :         fnSendMsgAndTraceObj( lpNetwork, ppvConn, vSubtask ) == zCALL_ERROR )
; 5725 :    {
; 5726 :       nRC = zCALL_ERROR;
; 5727 :    }
; 5728 : 
; 5729 :    if ( bFlushNeeded && fnFlushBuffer( lpNetwork, ppvConn ) != 0 )
; 5730 :    {
; 5731 :       nRC = zCALL_ERROR;
; 5732 :    }
; 5733 : 
; 5734 :    if ( vOI )
; 5735 :       fnDropView( vOI );
; 5736 : 
; 5737 :    if ( vSubtask )
; 5738 :       DROPSUBTASK( vSubtask );
; 5739 : 
; 5740 :    return( nRC );
; 5741 : #endif
; 5742 : 
; 5743 : } // fnProcesssActivateOI_FromFile

	pop	ebp
	ret	8
_fnProcessActivateOI_FromFile@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lLth$1 = -1060						; size = 4
tv284 = -1056						; size = 4
tv249 = -1052						; size = 4
_lpCommitPacket$ = -1048				; size = 4
_lpDropSubtask$2 = -1044				; size = 4
$T3 = -1040						; size = 4
_lpViewCsr$ = -1036					; size = 4
_nViewErrorIdx$ = -1032					; size = 2
_lpTask$ = -1028					; size = 4
_lCommitControl$ = -1024				; size = 4
_lLinkBufferLth$ = -1020				; size = 4
_pch2$4 = -1016						; size = 4
_lpViewOI$ = -1012					; size = 4
_pchLinkBuffer$ = -1008					; size = 4
_vSubtask$ = -1004					; size = 4
_pchOD_Names$ = -1000					; size = 4
_nOD_NameLth$ = -996					; size = 2
_pch$ = -992						; size = 4
_nViewCount$ = -988					; size = 2
_bFlushNeeded$ = -981					; size = 1
_nRC$ = -980						; size = 2
_k$ = -976						; size = 2
_CommitPacket$ = -972					; size = 158
_lpViewCluster$ = -812					; size = 800
_szLth$5 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpNetwork$ = 12					; size = 4
_ppvConn$ = 16						; size = 4
_fnProcessCommitOI@12 PROC

; 5922 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1060				; 00000424H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5923 :    LPTASK            lpTask;
; 5924 :    zVIEW             vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 5925 :    ViewClusterRecord lpViewCluster[ 100 ] = { 0 };

	mov	DWORD PTR _lpViewCluster$[ebp], 0
	push	796					; 0000031cH
	push	0
	lea	eax, DWORD PTR _lpViewCluster$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 5926 :    LPVIEWCSR         lpViewCsr;
; 5927 :    LPVIEWOI          lpViewOI;
; 5928 :    zCommitPacket     CommitPacket;
; 5929 :    LPCOMMITPACKET    lpCommitPacket;
; 5930 :    zPCHAR            pchOD_Names = 0;

	mov	DWORD PTR _pchOD_Names$[ebp], 0

; 5931 :    zPCHAR            pch;
; 5932 :    zPCHAR            pchLinkBuffer = 0;

	mov	DWORD PTR _pchLinkBuffer$[ebp], 0

; 5933 :    zLONG             lLinkBufferLth;
; 5934 :    zLONG             lCommitControl = 0;

	mov	DWORD PTR _lCommitControl$[ebp], 0

; 5935 :    zBOOL             bFlushNeeded = FALSE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 0

; 5936 :    zSHORT            nOD_NameLth;
; 5937 :    zSHORT            nViewErrorIdx;
; 5938 :    zSHORT            nViewCount = 0;

	xor	ecx, ecx
	mov	WORD PTR _nViewCount$[ebp], cx

; 5939 :    zSHORT            k;
; 5940 :    zSHORT            nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 5941 : 
; 5942 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN18@fnProcessC

; 5943 :    {
; 5944 :       TraceLineS( "(kzoeneta) ** Received Commit OI message.", "" );

	push	OFFSET $SG15626
	push	OFFSET $SG15627
	call	_TraceLineS@8

; 5945 :       TraceLineS( "(kzoeneta) ** Retrieving Commit packet.", "" );

	push	OFFSET $SG15628
	push	OFFSET $SG15629
	call	_TraceLineS@8
$LN18@fnProcessC:

; 5946 :    }
; 5947 : 
; 5948 :    //=======================================================================
; 5949 :    // Receiving data.
; 5950 :    //
; 5951 :    // Until noted below, we will only RECEIVE data over the network.
; 5952 :    //=======================================================================
; 5953 : 
; 5954 :    // First thing to do is retrieve the commit info.
; 5955 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 5956 :                                    &lpCommitPacket, sizeof( zCommitPacket ),
; 5957 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	158					; 0000009eH
	lea	edx, DWORD PTR _lpCommitPacket$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+174]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN19@fnProcessC

; 5958 :    {
; 5959 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Commit info", "" );

	push	OFFSET $SG15631
	push	OFFSET $SG15632
	call	_TraceLineS@8

; 5960 :       goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN19@fnProcessC:

; 5961 :    }
; 5962 : 
; 5963 :    // Store the info locally -- as soon as we perform the next network IO
; 5964 :    // operation we aren't assured that lpCommitPacket points to valid data.
; 5965 :    zmemcpy( &CommitPacket, lpCommitPacket, sizeof( zCommitPacket ) );

	push	158					; 0000009eH
	mov	edx, DWORD PTR _lpCommitPacket$[ebp]
	push	edx
	lea	eax, DWORD PTR _CommitPacket$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5966 : 
; 5967 :    nViewCount     = (zSHORT) zxtol( CommitPacket.szViewCount );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _CommitPacket$[ebp+143]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nViewCount$[ebp], ax

; 5968 :    nOD_NameLth    = (zSHORT) zxtol( CommitPacket.szObjectNameLth );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _CommitPacket$[ebp+146]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nOD_NameLth$[ebp], ax

; 5969 :    lLinkBufferLth = zxtol( CommitPacket.szLinkBufferLth );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _CommitPacket$[ebp+154]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLinkBufferLth$[ebp], eax

; 5970 :    lCommitControl = zxtol( CommitPacket.szControl );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _CommitPacket$[ebp+68]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lCommitControl$[ebp], eax

; 5971 : 
; 5972 :    // Get the list of object names.
; 5973 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 5974 :                                    &pch, nOD_NameLth, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	movsx	edx, WORD PTR _nOD_NameLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN20@fnProcessC

; 5975 :    {
; 5976 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve the object names.", "" );

	push	OFFSET $SG15634
	push	OFFSET $SG15635
	call	_TraceLineS@8

; 5977 :       goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN20@fnProcessC:

; 5978 :    }
; 5979 : 
; 5980 :    // Try to create a subtask view using the application name passed.
; 5981 :    if ( SfCreateSubtask( &vSubtask, lpTaskView, CommitPacket.szAppName ) == zCALL_ERROR )

	lea	eax, DWORD PTR _CommitPacket$[ebp+35]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SfCreateSubtask@12
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN21@fnProcessC

; 5982 :    {
; 5983 :       TraceLineS( "(kzoeneta) ** Invalid App name = ", CommitPacket.szAppName );

	lea	ecx, DWORD PTR _CommitPacket$[ebp+35]
	push	ecx
	push	OFFSET $SG15637
	call	_TraceLineS@8

; 5984 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 5985 :                              zNETERR_INVALIDAPP ) != 0 )

	push	1
	push	42					; 0000002aH
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN22@fnProcessC

; 5986 :       {
; 5987 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15639
	push	OFFSET $SG15640
	call	_TraceLineS@8
$LN22@fnProcessC:

; 5988 :       }
; 5989 : 
; 5990 :       bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 5991 :       goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN21@fnProcessC:

; 5992 :    }
; 5993 : 
; 5994 :    lpTask = fnOperationCall( iNetCommitOI, vSubtask, 0 );

	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	501					; 000001f5H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax

; 5995 :    pchOD_Names = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	0
	push	0
	push	1
	movsx	eax, WORD PTR _nOD_NameLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchOD_Names$[ebp], eax

; 5996 :                                    nOD_NameLth, TRUE, 0, 0 );
; 5997 :    if ( pchOD_Names == 0 )

	cmp	DWORD PTR _pchOD_Names$[ebp], 0
	jne	SHORT $LN23@fnProcessC

; 5998 :       goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN23@fnProcessC:

; 5999 : 
; 6000 :    pchOD_Names = zGETPTR( pchOD_Names );

	mov	eax, DWORD PTR _pchOD_Names$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchOD_Names$[ebp], eax

; 6001 :    zmemcpy( pchOD_Names, pch, nOD_NameLth );

	movsx	ecx, WORD PTR _nOD_NameLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchOD_Names$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6002 : 
; 6003 :    if ( lLinkBufferLth > 0 )

	cmp	DWORD PTR _lLinkBufferLth$[ebp], 0
	jle	$LN24@fnProcessC

; 6004 :    {
; 6005 :       pchLinkBuffer = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _lLinkBufferLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchLinkBuffer$[ebp], eax

; 6006 :                                         lLinkBufferLth, TRUE, 0, 0 );
; 6007 :       if ( pchLinkBuffer == 0 )

	cmp	DWORD PTR _pchLinkBuffer$[ebp], 0
	jne	SHORT $LN25@fnProcessC

; 6008 :          goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN25@fnProcessC:

; 6009 : 
; 6010 :       pchLinkBuffer = zGETPTR( pchLinkBuffer );

	mov	ecx, DWORD PTR _pchLinkBuffer$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchLinkBuffer$[ebp], eax

; 6011 : 
; 6012 :       if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6013 :                                       &pch, lLinkBufferLth,
; 6014 :                                       zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	mov	edx, DWORD PTR _lLinkBufferLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN26@fnProcessC

; 6015 :       {
; 6016 :          TraceLineS( "(kzoeneta) ** Couldn't retrieve the link buffer.", "" );

	push	OFFSET $SG15645
	push	OFFSET $SG15646
	call	_TraceLineS@8

; 6017 :          goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN26@fnProcessC:

; 6018 :       }
; 6019 : 
; 6020 :       zmemcpy( pchLinkBuffer, pch, (zSHORT) lLinkBufferLth );

	movsx	eax, WORD PTR _lLinkBufferLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchLinkBuffer$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6021 : 
; 6022 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN24@fnProcessC

; 6023 :          TraceBuffer( "(kzoeneta) ** Link Buffer = ", pch, (zSHORT) lLinkBufferLth );

	movsx	edx, WORD PTR _lLinkBufferLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET $SG15648
	call	_TraceBuffer@12
$LN24@fnProcessC:

; 6024 :    }
; 6025 : 
; 6026 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN28@fnProcessC

; 6027 :    {
; 6028 :       TraceLine( "(kzoeneta) ** App Name: %s  Object Def: %s  User Name: %s",

	lea	eax, DWORD PTR _CommitPacket$[ebp+77]
	push	eax
	lea	ecx, DWORD PTR _CommitPacket$[ebp+3]
	push	ecx
	lea	edx, DWORD PTR _CommitPacket$[ebp+35]
	push	edx
	push	OFFSET $SG15650
	call	_TraceLine
	add	esp, 16					; 00000010H

; 6029 :                  CommitPacket.szAppName, CommitPacket.szObjectDef,
; 6030 :                  CommitPacket.szUserName );
; 6031 :       if ( nViewCount > 1 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	eax, 1
	jle	SHORT $LN28@fnProcessC

; 6032 :       {
; 6033 :          TraceLine( "(kzoeneta) ** View Count: %s  OD Name Lth: %d",

	movsx	ecx, WORD PTR _nOD_NameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _CommitPacket$[ebp+143]
	push	edx
	push	OFFSET $SG15652
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 6034 :                     CommitPacket.szViewCount, nOD_NameLth );
; 6035 :          TraceBuffer( "(kzoeneta) ** OD Names: ",

	movsx	eax, WORD PTR _nOD_NameLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchOD_Names$[ebp]
	push	ecx
	push	OFFSET $SG15653
	call	_TraceBuffer@12
$LN28@fnProcessC:

; 6036 :                       pchOD_Names, nOD_NameLth );
; 6037 :       }
; 6038 :    }
; 6039 : 
; 6040 :    fnCreateMsgObj( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_fnCreateMsgObj@4

; 6041 : 
; 6042 :    // Make sure request is for valid ODs.
; 6043 :    for ( k = 0, pch = pchOD_Names; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	mov	ecx, DWORD PTR _pchOD_Names$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $LN4@fnProcessC
$LN2@fnProcessC:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN4@fnProcessC:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN3@fnProcessC

; 6044 :    {
; 6045 :       if ( k > 0 )

	movsx	edx, WORD PTR _k$[ebp]
	test	edx, edx
	jle	SHORT $LN30@fnProcessC
$LN5@fnProcessC:

; 6046 :       {
; 6047 :          // Skip to the beginning of the next name.
; 6048 :          while ( *pch++ )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv249[ebp], ecx
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
	cmp	DWORD PTR tv249[ebp], 0
	je	SHORT $LN30@fnProcessC

; 6049 :             ;

	jmp	SHORT $LN5@fnProcessC
$LN30@fnProcessC:

; 6050 :       }
; 6051 : 
; 6052 :       // If *pch is 0 then there is no OD name.  If there is no OD name then
; 6053 :       // this particular view is skipped.
; 6054 :       if ( pch[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN31@fnProcessC

; 6055 :          continue;

	jmp	SHORT $LN2@fnProcessC
$LN31@fnProcessC:

; 6056 : 
; 6057 :       if ( ActivateViewObject( vSubtask, pch, FALSE ) == 0 )

	push	0
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $LN32@fnProcessC

; 6058 :       {
; 6059 :          TraceLineS( "(kzoeneta) ** Invalid OD name = ", pch );

	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	push	OFFSET $SG15657
	call	_TraceLineS@8

; 6060 :          if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 6061 :                                 zNETERR_INVALIDOD ) != 0 )

	push	2
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN33@fnProcessC

; 6062 :          {
; 6063 :             TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15659
	push	OFFSET $SG15660
	call	_TraceLineS@8
$LN33@fnProcessC:

; 6064 :          }
; 6065 : 
; 6066 :          bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 6067 :          goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN32@fnProcessC:

; 6068 :       }
; 6069 :    }

	jmp	$LN2@fnProcessC
$LN3@fnProcessC:

; 6070 : 
; 6071 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN34@fnProcessC

; 6072 :       TraceLineS( "(kzoeneta) ** Receiving OIs to commit.", "" );

	push	OFFSET $SG15662
	push	OFFSET $SG15663
	call	_TraceLineS@8
$LN34@fnProcessC:

; 6073 : 
; 6074 :    // Retrieve the OIs we need to commit.
; 6075 :    for ( k = 0, pch = pchOD_Names; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	mov	ecx, DWORD PTR _pchOD_Names$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $LN9@fnProcessC
$LN7@fnProcessC:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN9@fnProcessC:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN8@fnProcessC

; 6076 :    {
; 6077 :       zCHAR  szLth[ 5 ];
; 6078 :       zPCHAR pch2;
; 6079 :       zLONG  lLth;
; 6080 : 
; 6081 :       if ( k > 0 )

	movsx	edx, WORD PTR _k$[ebp]
	test	edx, edx
	jle	SHORT $LN35@fnProcessC
$LN10@fnProcessC:

; 6082 :       {
; 6083 :          // Skip to the beginning of the next name.
; 6084 :          while ( *pch++ )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv284[ebp], ecx
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
	cmp	DWORD PTR tv284[ebp], 0
	je	SHORT $LN35@fnProcessC

; 6085 :             ;

	jmp	SHORT $LN10@fnProcessC
$LN35@fnProcessC:

; 6086 :       }
; 6087 : 
; 6088 :       // If *pch is 0 then there is no OD name.  If there is no OD name then
; 6089 :       // this particular view is skipped.
; 6090 :       if ( pch[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN36@fnProcessC

; 6091 :          continue;

	jmp	SHORT $LN7@fnProcessC
$LN36@fnProcessC:

; 6092 : 
; 6093 :       // Retrieve the OI.
; 6094 :       if ( fnReceiveOI( ppvConn, lpNetwork, &lpViewCluster[ k ].vOI, vSubtask,
; 6095 :                         pch, zMULTIPLE ) == zCALL_ERROR )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _lpViewCluster$[ebp+eax*8]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	call	_fnReceiveOI@24
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN37@fnProcessC

; 6096 :       {
; 6097 :          TraceLineS( "(kzoeneta) ** Not able to retrieve OIs for commit!", "" );

	push	OFFSET $SG15667
	push	OFFSET $SG15668
	call	_TraceLineS@8

; 6098 :          goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN37@fnProcessC:

; 6099 :       }
; 6100 : 
; 6101 :       // Get the *length* of the control value for the view.
; 6102 :       if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6103 :                                       &pch2, 2, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	2
	lea	edx, DWORD PTR _pch2$4[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+174]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN38@fnProcessC

; 6104 :       {
; 6105 :          goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN38@fnProcessC:

; 6106 :       }
; 6107 : 
; 6108 :       szLth[ 0 ] = *pch2++;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pch2$4[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _szLth$5[ebp+eax], dl
	mov	eax, DWORD PTR _pch2$4[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$4[ebp], eax

; 6109 :       szLth[ 1 ] = *pch2;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pch2$4[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szLth$5[ebp+ecx], al

; 6110 :       szLth[ 2 ] = 0;

	mov	ecx, 1
	shl	ecx, 1
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 5
	jae	SHORT $LN59@fnProcessC
	jmp	SHORT $LN60@fnProcessC
$LN59@fnProcessC:
	call	___report_rangecheckfailure
$LN60@fnProcessC:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szLth$5[ebp+edx], 0

; 6111 :       lLth = zxtol( szLth );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _szLth$5[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLth$1[ebp], eax

; 6112 : 
; 6113 :       // Get the *length* of the control value for the view.
; 6114 :       if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 6115 :                                       &pch2, lLth, zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	mov	ecx, DWORD PTR _lLth$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch2$4[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+174]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN39@fnProcessC

; 6116 :       {
; 6117 :          goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN39@fnProcessC:

; 6118 :       }
; 6119 : 
; 6120 :       lpViewCluster[ k ].lControl = zxtol( pch2 );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pch2$4[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	movsx	ecx, WORD PTR _k$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp+ecx*8+4], eax

; 6121 : 
; 6122 :       // Turn on the flag to commit the OI on the current pc.
; 6123 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp+edx*8]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6124 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6125 :       lpViewOI->lActivateControl |= zACTIVATE_LOCAL;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	or	edx, 1073741824				; 40000000H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+48], edx

; 6126 :    }

	jmp	$LN7@fnProcessC
$LN8@fnProcessC:

; 6127 : 
; 6128 : #ifdef DGC
; 6129 :    if ( lpNetwork->nTraceLevel > 0 )
; 6130 :    {
; 6131 :       zCHAR szTempFileName[ zMAX_FILENAME_LTH + 1 ];
; 6132 : 
; 6133 :       SysGetEnvVar( szTempFileName, "TEMP", zMAX_FILENAME_LTH + 1 );
; 6134 :       SysAppendcDirSep( szTempFileName );
; 6135 :       zstrcat( szTempFileName, "commitoi.por" );
; 6136 :       CommitOI_ToFile( vOI, szTempFileName, zINCREMENTAL );
; 6137 :    }
; 6138 : #endif
; 6139 : 
; 6140 :    //=======================================================================
; 6141 :    // Transmitting data.
; 6142 :    //
; 6143 :    // Until we close the connection, the following code only SENDS data over
; 6144 :    // the network.
; 6145 :    //=======================================================================
; 6146 : 
; 6147 :    bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 6148 : 
; 6149 :    // For now we won't execute constraints on the server.
; 6150 :    lCommitControl |= zCOMMIT_NOCONSTRAINTS;

	mov	ecx, DWORD PTR _lCommitControl$[ebp]
	or	ecx, 16777216				; 01000000H
	mov	DWORD PTR _lCommitControl$[ebp], ecx

; 6151 : 
; 6152 :    // If we received any link information we must now do relinking.
; 6153 :    if ( lLinkBufferLth > 0 )

	cmp	DWORD PTR _lLinkBufferLth$[ebp], 0
	jle	SHORT $LN40@fnProcessC

; 6154 :       fnRelinkOIs( lpTask, lpViewCluster, nViewCount, pchLinkBuffer );

	mov	edx, DWORD PTR _pchLinkBuffer$[ebp]
	push	edx
	movzx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnRelinkOIs@16
$LN40@fnProcessC:

; 6155 : 
; 6156 :    // Tell commit that we don't want to clean up the OI and to leave the
; 6157 :    // entity flags.
; 6158 :    lCommitControl |= zCOMMIT_NOCLEANUP;

	mov	eax, DWORD PTR _lCommitControl$[ebp]
	or	eax, 256				; 00000100H
	mov	DWORD PTR _lCommitControl$[ebp], eax

; 6159 : 
; 6160 :    // Commit the OI but tell Core not to clean up the deleted/excluded
; 6161 :    // instances.  We do this so that when we send the OI back to the client,
; 6162 :    // it can merge the committed OI with the original OI.
; 6163 :    nRC = CommitMultipleOIs( lpViewCluster, nViewCount,

	mov	ecx, DWORD PTR _lCommitControl$[ebp]
	push	ecx
	lea	edx, DWORD PTR _nViewErrorIdx$[ebp]
	push	edx
	movzx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 6164 :                             &nViewErrorIdx, lCommitControl );
; 6165 : 
; 6166 :    // Turn off the flag to commit the OI on the current pc.
; 6167 :    lpViewOI->lActivateControl &= ~zACTIVATE_LOCAL;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -1073741825			; bfffffffH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 6168 : 
; 6169 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN41@fnProcessC

; 6170 :    {
; 6171 :       for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN14@fnProcessC
$LN12@fnProcessC:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN14@fnProcessC:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$LN41@fnProcessC

; 6172 :       {
; 6173 :          if ( lpViewCluster[ k ].vOI == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	DWORD PTR _lpViewCluster$[ebp+ecx*8], 0
	jne	SHORT $LN42@fnProcessC

; 6174 :             continue;

	jmp	SHORT $LN12@fnProcessC
$LN42@fnProcessC:

; 6175 : 
; 6176 :          if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN43@fnProcessC

; 6177 :             TraceLineI( "(kzoeneta) ** Sending committed OI #", k );

	movsx	ecx, WORD PTR _k$[ebp]
	push	ecx
	push	OFFSET $SG15675
	call	_TraceLineI@8
$LN43@fnProcessC:

; 6178 : 
; 6179 :          if ( fnEmptyOI( lpViewCluster[ k ].vOI ) )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp+edx*8]
	push	eax
	call	_fnEmptyOI@4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN44@fnProcessC

; 6180 :          {
; 6181 :             if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_EMPTYOI, 0 ) != 0 )

	push	0
	push	101					; 00000065H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN46@fnProcessC

; 6182 :             {
; 6183 :                TraceLineS( "(kzoeneta) ** Not able to ACK request of OI!", "" );

	push	OFFSET $SG15679
	push	OFFSET $SG15680
	call	_TraceLineS@8

; 6184 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6185 :                goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN46@fnProcessC:

; 6186 :             }
; 6187 :          }

	jmp	SHORT $LN45@fnProcessC
$LN44@fnProcessC:

; 6188 :          else
; 6189 :          {
; 6190 :             // Send Ack to signal we got this far.
; 6191 :             if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ACK, 0 ) != 0 )

	push	0
	push	75					; 0000004bH
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendDataPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN47@fnProcessC

; 6192 :             {
; 6193 :                TraceLineS( "(kzoeneta) ** Not able to ACK request of OI!", "" );

	push	OFFSET $SG15682
	push	OFFSET $SG15683
	call	_TraceLineS@8

; 6194 :                nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 6195 :                goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN47@fnProcessC:

; 6196 :             }
; 6197 : 
; 6198 :             if ( fnSendOI( ppvConn, lpNetwork, lpViewCluster[ k ].vOI,
; 6199 :                            zINCREMENTAL ) == zCALL_ERROR )

	push	65536					; 00010000H
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp+ecx*8]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	call	_fnSendOI@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN45@fnProcessC

; 6200 :             {
; 6201 :                nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 6202 :                goto EndOfFunction;

	jmp	$EndOfFunction$61
$LN45@fnProcessC:

; 6203 :             }
; 6204 :          }
; 6205 :       } // for...

	jmp	$LN12@fnProcessC
$LN41@fnProcessC:

; 6206 :    }
; 6207 : 
; 6208 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN49@fnProcessC

; 6209 :       TraceLineI( "(kzoeneta) ** Sending RC packet.  RC = ", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG15686
	call	_TraceLineI@8
$LN49@fnProcessC:

; 6210 : 
; 6211 :    // Send return code.
; 6212 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_RC, nRC ) != 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	35					; 00000023H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN50@fnProcessC

; 6213 :    {
; 6214 :       TraceLineS( "(kzoeneta) ** Not able send Return code!", "" );

	push	OFFSET $SG15688
	push	OFFSET $SG15689
	call	_TraceLineS@8

; 6215 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6216 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$61
$LN50@fnProcessC:

; 6217 :    }
; 6218 : 
; 6219 :    // If we got an error then send the error idx.
; 6220 :    if ( nRC < 0 &&

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN51@fnProcessC
	movsx	ecx, WORD PTR _nViewErrorIdx$[ebp]
	push	ecx
	push	35					; 00000023H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN51@fnProcessC

; 6221 :         fnSendDataPacket( lpNetwork, ppvConn, zPACKET_RC, nViewErrorIdx ) != 0 )
; 6222 :    {
; 6223 :       TraceLineS( "(kzoeneta) ** Not able send Error Idx code!", "" );

	push	OFFSET $SG15691
	push	OFFSET $SG15692
	call	_TraceLineS@8

; 6224 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 6225 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$61
$LN51@fnProcessC:

; 6226 :    }
; 6227 : 
; 6228 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$61:

; 6229 : 
; 6230 : EndOfFunction:
; 6231 :    if ( vSubtask &&

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN52@fnProcessC
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendMsgAndTraceObj@12
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN52@fnProcessC

; 6232 :         fnSendMsgAndTraceObj( lpNetwork, ppvConn, vSubtask ) == zCALL_ERROR )
; 6233 :    {
; 6234 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN52@fnProcessC:

; 6235 :    }
; 6236 : 
; 6237 :    if ( bFlushNeeded && fnFlushBuffer( lpNetwork, ppvConn ) != 0 )

	movzx	eax, BYTE PTR _bFlushNeeded$[ebp]
	test	eax, eax
	je	SHORT $LN53@fnProcessC
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnFlushBuffer@8
	cwde
	test	eax, eax
	je	SHORT $LN53@fnProcessC

; 6238 :    {
; 6239 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN53@fnProcessC:

; 6240 :    }
; 6241 : 
; 6242 :    if ( pchOD_Names )

	cmp	DWORD PTR _pchOD_Names$[ebp], 0
	je	SHORT $LN54@fnProcessC

; 6243 :       fnFreeDataspace( pchOD_Names );

	mov	edx, DWORD PTR _pchOD_Names$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$LN54@fnProcessC:

; 6244 : 
; 6245 :    if ( pchLinkBuffer )

	cmp	DWORD PTR _pchLinkBuffer$[ebp], 0
	je	SHORT $LN55@fnProcessC

; 6246 :       fnFreeDataspace( pchLinkBuffer );

	mov	eax, DWORD PTR _pchLinkBuffer$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN55@fnProcessC:

; 6247 : 
; 6248 :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN17@fnProcessC
$LN15@fnProcessC:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN17@fnProcessC:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN16@fnProcessC

; 6249 :    {
; 6250 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	DWORD PTR _lpViewCluster$[ebp+edx*8], 0
	jne	SHORT $LN56@fnProcessC

; 6251 :          continue;

	jmp	SHORT $LN15@fnProcessC
$LN56@fnProcessC:

; 6252 : 
; 6253 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp+eax*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6254 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6255 : 
; 6256 :       // It's possible that we've activated the OI with pessimistic locking.
; 6257 :       // This means that there are records in the DB to lock out the OI.  But
; 6258 :       // Core automatically deletes those records when the OI is dropped.  This
; 6259 :       // is not good because the client that requested this OI obviously wants
; 6260 :       // the locks left in place.  To keep the locks we'll turn off the flag
; 6261 :       // that says the OI has pessimistic locking.  This will keep Core from
; 6262 :       // deleting the locks when we drop the view.
; 6263 :       lpViewOI->bIsLocked = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -129				; ffffff7fH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 6264 : 
; 6265 :       fnDropView( lpViewCluster[ k ].vOI );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp+edx*8]
	push	eax
	call	_fnDropView@4

; 6266 :    }

	jmp	$LN15@fnProcessC
$LN16@fnProcessC:

; 6267 : 
; 6268 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN57@fnProcessC

; 6269 :       DROPSUBTASK( vSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropSubtask$2[ebp], eax
	push	0
	mov	eax, DWORD PTR _lpDropSubtask$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDropSubtask$2[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH
$LN57@fnProcessC:

; 6270 : 
; 6271 :    fnOperationReturn( iNetCommitOI, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	501					; 000001f5H
	call	_fnOperationReturn
	add	esp, 8

; 6272 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN58@fnProcessC:

; 6273 : 
; 6274 : } // fnProcesssCommitOI

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnProcessCommitOI@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpViewCsr$1 = -196					; size = 4
_lpActPacket$ = -192					; size = 4
_lpDropSubtask$2 = -188					; size = 4
_lpViewOI$3 = -184					; size = 4
_lpTask$ = -180						; size = 4
_vQual$ = -176						; size = 4
_lControl$ = -172					; size = 4
_vOI$ = -168						; size = 4
_vSubtask$ = -164					; size = 4
_bFlushNeeded$ = -157					; size = 1
_nRC$ = -156						; size = 2
_ActPacket$ = -152					; size = 147
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpNetwork$ = 12					; size = 4
_ppvConn$ = 16						; size = 4
_fnProcessActivateOI@12 PROC

; 5349 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5350 :    LPTASK         lpTask = 0;

	mov	DWORD PTR _lpTask$[ebp], 0

; 5351 :    zVIEW          vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 5352 :    zVIEW          vQual = 0;

	mov	DWORD PTR _vQual$[ebp], 0

; 5353 :    zVIEW          vOI = 0;

	mov	DWORD PTR _vOI$[ebp], 0

; 5354 :    zLONG          lControl;
; 5355 :    zBOOL          bFlushNeeded = FALSE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 0

; 5356 :    zActivatePacket ActPacket;
; 5357 :    LPACTPACKET    lpActPacket;
; 5358 :    zSHORT         nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 5359 : 
; 5360 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN2@fnProcessA

; 5361 :    {
; 5362 :       TraceLineS( "(kzoeneta) ** Received Activate OI message.", "" );

	push	OFFSET $SG15442
	push	OFFSET $SG15443
	call	_TraceLineS@8

; 5363 :       TraceLineS( "(kzoeneta) ** Retrieving Activate info.", "" );

	push	OFFSET $SG15444
	push	OFFSET $SG15445
	call	_TraceLineS@8
$LN2@fnProcessA:

; 5364 :    }
; 5365 : 
; 5366 :    //=======================================================================
; 5367 :    // Receiving data.
; 5368 :    //
; 5369 :    // Until noted below, we will only RECEIVE data over the network.
; 5370 :    //=======================================================================
; 5371 : 
; 5372 :    // First thing to do is retrieve the activate info.
; 5373 :    if ( (*lpNetwork->lpfnReceive)( &lpNetwork->pNetworkHandle, ppvConn,
; 5374 :                                    &lpActPacket, sizeof( zActivatePacket ),
; 5375 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	147					; 00000093H
	lea	eax, DWORD PTR _lpActPacket$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+174]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@fnProcessA

; 5376 :    {
; 5377 :       TraceLineS( "(kzoeneta) ** Couldn't retrieve Act info", "" );

	push	OFFSET $SG15447
	push	OFFSET $SG15448
	call	_TraceLineS@8

; 5378 :       goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN3@fnProcessA:

; 5379 :    }
; 5380 : 
; 5381 :    // Store the info locally -- as soon as we perform the next network IO
; 5382 :    // operation we aren't assured that lpActPacket points to valid data.
; 5383 :    zmemcpy( &ActPacket, lpActPacket, sizeof( zActivatePacket ) );

	push	147					; 00000093H
	mov	eax, DWORD PTR _lpActPacket$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ActPacket$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5384 :    lControl = zxtol( ActPacket.szControl );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _ActPacket$[ebp+35]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lControl$[ebp], eax

; 5385 : 
; 5386 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN4@fnProcessA

; 5387 :    {
; 5388 :       TraceLine( "(kzoeneta) ** User Name: %s  App Name: %s  Object Def: %s",

	lea	edx, DWORD PTR _ActPacket$[ebp+3]
	push	edx
	lea	eax, DWORD PTR _ActPacket$[ebp+45]
	push	eax
	lea	ecx, DWORD PTR _ActPacket$[ebp+78]
	push	ecx
	push	OFFSET $SG15450
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN4@fnProcessA:

; 5389 :                  ActPacket.szUserName, ActPacket.szAppName,
; 5390 :                  ActPacket.szObjectDef );
; 5391 :    }
; 5392 : 
; 5393 :    // Try to create a subtask view using the application name passed.
; 5394 :    if ( SfCreateSubtask( &vSubtask, lpTaskView, ActPacket.szAppName ) == zCALL_ERROR )

	lea	edx, DWORD PTR _ActPacket$[ebp+45]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_SfCreateSubtask@12
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN5@fnProcessA

; 5395 :    {
; 5396 :       TraceLineS( "(kzoeneta) ** Invalid App name = ", ActPacket.szAppName );

	lea	eax, DWORD PTR _ActPacket$[ebp+45]
	push	eax
	push	OFFSET $SG15452
	call	_TraceLineS@8

; 5397 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 5398 :                              zNETERR_INVALIDAPP ) != 0 )

	push	1
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN6@fnProcessA

; 5399 :       {
; 5400 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15454
	push	OFFSET $SG15455
	call	_TraceLineS@8
$LN6@fnProcessA:

; 5401 :       }
; 5402 : 
; 5403 :       bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 5404 :       goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN5@fnProcessA:

; 5405 :    }
; 5406 : 
; 5407 :    lpTask = fnOperationCall( iNetActivateOI, vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	500					; 000001f4H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax

; 5408 :    fnCreateMsgObj( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_fnCreateMsgObj@4

; 5409 : 
; 5410 :    // Make sure request is for valid OD.
; 5411 :    if ( ActivateViewObject( vSubtask, ActPacket.szObjectDef, FALSE ) == 0 )

	push	0
	lea	eax, DWORD PTR _ActPacket$[ebp+3]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $LN7@fnProcessA

; 5412 :    {
; 5413 :       TraceLineS( "(kzoeneta) ** Invalid OD name = ", ActPacket.szObjectDef );

	lea	edx, DWORD PTR _ActPacket$[ebp+3]
	push	edx
	push	OFFSET $SG15457
	call	_TraceLineS@8

; 5414 :       if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 5415 :                              zNETERR_INVALIDOD ) != 0 )

	push	2
	push	42					; 0000002aH
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendDataPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN8@fnProcessA

; 5416 :       {
; 5417 :          TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG15459
	push	OFFSET $SG15460
	call	_TraceLineS@8
$LN8@fnProcessA:

; 5418 :       }
; 5419 : 
; 5420 :       bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 5421 :       goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN7@fnProcessA:

; 5422 :    }
; 5423 : 
; 5424 :    if ( ActPacket.cUseQualification == 'Y' )

	movsx	eax, BYTE PTR _ActPacket$[ebp+44]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN9@fnProcessA

; 5425 :    {
; 5426 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN10@fnProcessA

; 5427 :       {
; 5428 :          TraceLineS( "(kzoeneta) ** Receiving Qual OI.", "" );

	push	OFFSET $SG15463
	push	OFFSET $SG15464
	call	_TraceLineS@8
$LN10@fnProcessA:

; 5429 :       }
; 5430 : 
; 5431 :       if ( fnReceiveOI( ppvConn, lpNetwork, &vQual, vSubtask, "KZDBHQUA",
; 5432 :                         zMULTIPLE | zACTIVATE_SYSTEM ) == zCALL_ERROR )

	push	536871168				; 20000100H
	push	OFFSET $SG15466
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	call	_fnReceiveOI@24
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN9@fnProcessA

; 5433 :       {
; 5434 :          goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN9@fnProcessA:

; 5435 :       }
; 5436 :    }
; 5437 : 
; 5438 :    //=======================================================================
; 5439 :    // Transmitting data.
; 5440 :    //
; 5441 :    // Until we close the connection, the following code only SENDS data over
; 5442 :    // the network.
; 5443 :    //=======================================================================
; 5444 : 
; 5445 :    bFlushNeeded = TRUE;

	mov	BYTE PTR _bFlushNeeded$[ebp], 1

; 5446 : 
; 5447 :    // For now we don't want to execute activate constraints on the server.
; 5448 :    lControl |= zACTIVATE_NOCONSTRAINTS;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 16777216				; 01000000H
	mov	DWORD PTR _lControl$[ebp], edx

; 5449 : 
; 5450 :    // Force activate to be local.
; 5451 :    lControl |= zACTIVATE_LOCAL;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 1073741824				; 40000000H
	mov	DWORD PTR _lControl$[ebp], eax

; 5452 : 
; 5453 :    // Activate the OI but force the activate to occur locally.
; 5454 :    nRC = ActivateObjectInstance( &vOI, ActPacket.szObjectDef, vSubtask, vQual,

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ActPacket$[ebp+3]
	push	ecx
	lea	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _nRC$[ebp], ax

; 5455 :                                  lControl );
; 5456 : 
; 5457 :    if ( vOI )

	cmp	DWORD PTR _vOI$[ebp], 0
	je	$LN12@fnProcessA

; 5458 :    {
; 5459 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN13@fnProcessA

; 5460 :       {
; 5461 :          // If we have an object instance (vOI is not 0) but the return code was
; 5462 :          // less than 0, there was nothing on the DB to activate so the OI is
; 5463 :          // empty.  Instead of sending an empty OI across the network we'll
; 5464 :          // just send an indication that we have an empty OI and we'll let the
; 5465 :          // client activate an empty OI on it's side.
; 5466 :          if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_EMPTYOI, 0 ) != 0 )

	push	0
	push	101					; 00000065H
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN15@fnProcessA

; 5467 :          {
; 5468 :             TraceLineS( "(kzoeneta) ** Not able to indicate empty OI!", "" );

	push	OFFSET $SG15471
	push	OFFSET $SG15472
	call	_TraceLineS@8

; 5469 :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 5470 :             goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN15@fnProcessA:

; 5471 :          }
; 5472 :       }

	jmp	$LN12@fnProcessA
$LN13@fnProcessA:

; 5473 :       else
; 5474 :       {
; 5475 :          // Send Ack to signal we got this far.
; 5476 :          if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ACK, 0 ) != 0 )

	push	0
	push	75					; 0000004bH
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN16@fnProcessA

; 5477 :          {
; 5478 :             TraceLineS( "(kzoeneta) ** Not able to ACK request of OI!", "" );

	push	OFFSET $SG15474
	push	OFFSET $SG15475
	call	_TraceLineS@8

; 5479 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 5480 :             goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN16@fnProcessA:

; 5481 :          }
; 5482 : 
; 5483 :          if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN17@fnProcessA

; 5484 :          {
; 5485 :             TraceLineS( "(kzoeneta) ** Sending Activated OI.", "" );

	push	OFFSET $SG15477
	push	OFFSET $SG15478
	call	_TraceLineS@8
$LN17@fnProcessA:

; 5486 :          }
; 5487 : 
; 5488 :          // Now send the oi.
; 5489 :          if ( fnSendOI( ppvConn, lpNetwork, vOI, zINCREMENTAL ) == zCALL_ERROR )

	push	65536					; 00010000H
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	call	_fnSendOI@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN12@fnProcessA

; 5490 :          {
; 5491 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 5492 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$28
$LN12@fnProcessA:

; 5493 :          }
; 5494 :       }
; 5495 :    }
; 5496 : 
; 5497 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN19@fnProcessA

; 5498 :       TraceLineI( "(kzoeneta) ** Sending RC packet. RC = ", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG15481
	call	_TraceLineI@8
$LN19@fnProcessA:

; 5499 : 
; 5500 :    // Send return code.
; 5501 :    if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_RC, nRC ) != 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	35					; 00000023H
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN20@fnProcessA

; 5502 :    {
; 5503 :       TraceLineS( "(kzoeneta) ** Not able send Return code!", "" );

	push	OFFSET $SG15483
	push	OFFSET $SG15484
	call	_TraceLineS@8

; 5504 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 5505 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$28
$LN20@fnProcessA:

; 5506 :    }
; 5507 : 
; 5508 :    // If we get here then everything's OK and we already sent the return code
; 5509 :    // back to the client so let's set it to 0.
; 5510 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$28:

; 5511 : 
; 5512 : EndOfFunction:
; 5513 :    if ( vSubtask &&

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN21@fnProcessA
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendMsgAndTraceObj@12
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN21@fnProcessA

; 5514 :         fnSendMsgAndTraceObj( lpNetwork, ppvConn, vSubtask ) == zCALL_ERROR )
; 5515 :    {
; 5516 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN21@fnProcessA:

; 5517 :    }
; 5518 : 
; 5519 :    if ( bFlushNeeded && fnFlushBuffer( lpNetwork, ppvConn ) != 0 )

	movzx	eax, BYTE PTR _bFlushNeeded$[ebp]
	test	eax, eax
	je	SHORT $LN22@fnProcessA
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnFlushBuffer@8
	cwde
	test	eax, eax
	je	SHORT $LN22@fnProcessA

; 5520 :    {
; 5521 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN22@fnProcessA:

; 5522 :    }
; 5523 : 
; 5524 :    if ( vOI )

	cmp	DWORD PTR _vOI$[ebp], 0
	je	SHORT $LN23@fnProcessA

; 5525 :    {
; 5526 :       LPVIEWCSR lpViewCsr = zGETPTR( vOI->hViewCsr );

	mov	edx, DWORD PTR _vOI$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 5527 :       LPVIEWOI  lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$3[ebp], eax

; 5528 : 
; 5529 :       // It's possible that we've activated the OI with pessimistic locking.
; 5530 :       // This means that there are records in the DB to lock out the OI.  But
; 5531 :       // Core automatically deletes those records when the OI is dropped.  This
; 5532 :       // is not good because the client that requested this OI obviously wants
; 5533 :       // the locks left in place.  To keep the locks we'll turn off the flag
; 5534 :       // that says the OI has pessimistic locking.  This will keep Core from
; 5535 :       // deleting the locks when we drop the view.
; 5536 :       lpViewOI->bIsLocked = 0;

	mov	eax, DWORD PTR _lpViewOI$3[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _lpViewOI$3[ebp]
	mov	DWORD PTR [edx+36], ecx

; 5537 : 
; 5538 :       fnDropView( vOI );

	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_fnDropView@4
$LN23@fnProcessA:

; 5539 :    }
; 5540 : 
; 5541 :    if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $LN24@fnProcessA

; 5542 :       fnDropView( vQual );

	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnDropView@4
$LN24@fnProcessA:

; 5543 : 
; 5544 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN25@fnProcessA

; 5545 :       DROPSUBTASK( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropSubtask$2[ebp], eax
	push	0
	mov	ecx, DWORD PTR _lpDropSubtask$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDropSubtask$2[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH
$LN25@fnProcessA:

; 5546 : 
; 5547 :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN26@fnProcessA

; 5548 :       fnOperationReturn( iNetActivateOI, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	500					; 000001f4H
	call	_fnOperationReturn
	add	esp, 8
$LN26@fnProcessA:

; 5549 : 
; 5550 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 5551 : 
; 5552 : } // fnProcessActivateOI

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnProcessActivateOI@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
$T1 = -340						; size = 4
$T2 = -336						; size = 4
$T3 = -332						; size = 4
_k$ = -328						; size = 4
_szGroupName$ = -324					; size = 61
_szExecName$ = -260					; size = 61
_szStartup$ = -196					; size = 61
_szNetName$ = -132					; size = 61
_szValue$ = -68						; size = 61
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lControl$ = 12						; size = 4
_SfStartNetworks@8 PROC

; 7184 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 340				; 00000154H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7185 :    zCHAR  szValue[ 61 ];
; 7186 :    zCHAR  szStartup[ 61 ];
; 7187 :    zCHAR  szNetName[ 61 ];
; 7188 :    zCHAR  szGroupName[ 61 ];
; 7189 :    zCHAR  szExecName[ 61 ];
; 7190 :    int   k;
; 7191 : 
; 7192 :    // If user has specified a startup network, then start it up.
; 7193 :    TraceLineS( "(kzoeneta) ** Trying to startup networks", "" );

	push	OFFSET $SG16018
	push	OFFSET $SG16019
	call	_TraceLineS@8

; 7194 : 
; 7195 :    szValue[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 61			; 0000003dH
	jae	SHORT $LN17@SfStartNet
	jmp	SHORT $LN18@SfStartNet
$LN17@SfStartNet:
	call	___report_rangecheckfailure
$LN18@SfStartNet:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szValue$[ebp+edx], 0

; 7196 :    szNetName[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 61			; 0000003dH
	jae	SHORT $LN19@SfStartNet
	jmp	SHORT $LN20@SfStartNet
$LN19@SfStartNet:
	call	___report_rangecheckfailure
$LN20@SfStartNet:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szNetName$[ebp+edx], 0

; 7197 : 
; 7198 :    // Try starting all the networks.  They will be listed in the [network]
; 7199 :    // group as:
; 7200 :    //    [Network]
; 7201 :    //    Network1=zWinSock
; 7202 :    //    Network2=zNetBuei
; 7203 :    //    etc...
; 7204 :    for ( k = 1; TRUE; k++ )

	mov	DWORD PTR _k$[ebp], 1
	jmp	SHORT $LN4@SfStartNet
$LN2@SfStartNet:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@SfStartNet:
	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@SfStartNet

; 7205 :    {
; 7206 :       zsprintf( szNetName, "Network%d", k );

	mov	edx, DWORD PTR _k$[ebp]
	push	edx
	push	OFFSET $SG16020
	lea	eax, DWORD PTR _szNetName$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7207 :    // TraceLineS( "(kzoeneta) ** Looking for Net = ", szNetName );
; 7208 : 
; 7209 :       szValue[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 61			; 0000003dH
	jae	SHORT $LN21@SfStartNet
	jmp	SHORT $LN22@SfStartNet
$LN21@SfStartNet:
	call	___report_rangecheckfailure
$LN22@SfStartNet:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szValue$[ebp+eax], 0

; 7210 :       SysReadZeidonIni( -1, "[Network]", szNetName, szValue );

	lea	ecx, DWORD PTR _szValue$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szNetName$[ebp]
	push	edx
	push	OFFSET $SG16021
	push	-1
	call	_SysReadZeidonIni@16

; 7211 :       if ( szValue[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szValue$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN5@SfStartNet

; 7212 :          break;               // No network# item so break loop.

	jmp	$LN3@SfStartNet
$LN5@SfStartNet:

; 7213 : 
; 7214 :       zstrcpy( szNetName, szValue );

	lea	eax, DWORD PTR _szValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szNetName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7215 :       zsprintf( szGroupName, "[%s]", szValue );

	lea	edx, DWORD PTR _szValue$[ebp]
	push	edx
	push	OFFSET $SG16023
	lea	eax, DWORD PTR _szGroupName$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7216 :       SysReadZeidonIni( -1, szGroupName, "Startup", szStartup );

	lea	ecx, DWORD PTR _szStartup$[ebp]
	push	ecx
	push	OFFSET $SG16024
	lea	edx, DWORD PTR _szGroupName$[ebp]
	push	edx
	push	-1
	call	_SysReadZeidonIni@16

; 7217 :       if ( szValue[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szValue$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN6@SfStartNet

; 7218 :          continue;

	jmp	$LN2@SfStartNet
$LN6@SfStartNet:

; 7219 : 
; 7220 :       TraceLineS( "(kzoeneta) ** Startup = ", szStartup );

	lea	eax, DWORD PTR _szStartup$[ebp]
	push	eax
	push	OFFSET $SG16026
	call	_TraceLineS@8

; 7221 : 
; 7222 :       // If Startup is NO, 0, or FALSE don't start it.
; 7223 :       if ( ztoupper( szStartup[ 0 ] ) == 'N' || szStartup[ 0 ] == '0' ||

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szStartup$[ebp+edx]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 78					; 0000004eH
	je	SHORT $LN8@SfStartNet
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szStartup$[ebp+edx]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN8@SfStartNet
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szStartup$[ebp+edx]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 70					; 00000046H
	jne	SHORT $LN7@SfStartNet
$LN8@SfStartNet:

; 7224 :            ztoupper( szStartup[ 0 ] ) == 'F' )
; 7225 :       {
; 7226 :          continue;

	jmp	$LN2@SfStartNet
$LN7@SfStartNet:

; 7227 :       }
; 7228 : 
; 7229 :       SysReadZeidonIni( -1, szGroupName, "ExecName", szExecName );

	lea	ecx, DWORD PTR _szExecName$[ebp]
	push	ecx
	push	OFFSET $SG16029
	lea	edx, DWORD PTR _szGroupName$[ebp]
	push	edx
	push	-1
	call	_SysReadZeidonIni@16

; 7230 :       if ( szExecName[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szExecName$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN9@SfStartNet

; 7231 :          zstrcpy( szExecName, szNetName );

	lea	eax, DWORD PTR _szNetName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szExecName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN9@SfStartNet:

; 7232 : 
; 7233 :       // If network is started see if we need to do a listen.
; 7234 :       if ( NetStartup( lpView, szNetName, szExecName ) != zCALL_ERROR )

	lea	edx, DWORD PTR _szExecName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szNetName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_NetStartup@12
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	je	$LN10@SfStartNet

; 7235 :       {
; 7236 :          SysReadZeidonIni( -1, szGroupName, "TraceLevel", szValue );

	lea	eax, DWORD PTR _szValue$[ebp]
	push	eax
	push	OFFSET $SG16033
	lea	ecx, DWORD PTR _szGroupName$[ebp]
	push	ecx
	push	-1
	call	_SysReadZeidonIni@16

; 7237 :          if ( szValue[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szValue$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN12@SfStartNet

; 7238 :             NetSetTraceLevel( lpView, szNetName, (zSHORT) zatol( szValue ) );

	lea	edx, DWORD PTR _szValue$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _szNetName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_NetSetTraceLevel@12
$LN12@SfStartNet:

; 7239 : 
; 7240 :          // TODO: CHANGE THIS
; 7241 :          // (BC) Not sure why this is Here, Listen is called in NetStartup
; 7242 :          //        so no need for it here
; 7243 : 
; 7244 :          // We only automatically start a listen for the main task.
; 7245 :          if ( ztoupper( szStartup[ 0 ] ) == 'L' &&

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szStartup$[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN13@SfStartNet
	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+106], 0
	je	SHORT $LN14@SfStartNet
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [eax+106]
	cmp	edx, DWORD PTR [ecx+14]
	jne	SHORT $LN13@SfStartNet
$LN14@SfStartNet:

; 7246 :               (AnchorBlock->hMainTask == 0 ||
; 7247 :                AnchorBlock->hMainTask == lpView->hTask) )
; 7248 :          {
; 7249 :             TraceLineS( "(kzoeneta) *MainTask* Starting Listen", "" );

	push	OFFSET $SG16037
	push	OFFSET $SG16038
	call	_TraceLineS@8

; 7250 :             if ( NetListen( lpView, szNetName ) == zCALL_ERROR )

	lea	eax, DWORD PTR _szNetName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_NetListen@8
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN13@SfStartNet

; 7251 :             {
; 7252 :                TraceLineS( "(kzoeneta) ** Error calling NetListen", "" );

	push	OFFSET $SG16040
	push	OFFSET $SG16041
	call	_TraceLineS@8

; 7253 :                NetClose( lpView, szNetName );

	lea	eax, DWORD PTR _szNetName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_NetClose@8

; 7254 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN16@SfStartNet
$LN13@SfStartNet:

; 7255 :             }
; 7256 :          }/**/
; 7257 :       }

	jmp	SHORT $LN11@SfStartNet
$LN10@SfStartNet:

; 7258 :      else
; 7259 :         TraceLineS( "(kzoeneta) ** Error calling NetStartup!! ", "" );

	push	OFFSET $SG16042
	push	OFFSET $SG16043
	call	_TraceLineS@8
$LN11@SfStartNet:

; 7260 : 
; 7261 : 
; 7262 :    } // for k...

	jmp	$LN2@SfStartNet
$LN3@SfStartNet:

; 7263 : 
; 7264 :    TraceLineS( "(kzoeneta) ** Startup networks successful", "" );

	push	OFFSET $SG16044
	push	OFFSET $SG16045
	call	_TraceLineS@8

; 7265 : 
; 7266 :    return( 0 );

	xor	eax, eax
$LN16@SfStartNet:

; 7267 : 
; 7268 : } // SfStartNetworks

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_SfStartNetworks@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpTask$ = -12						; size = 4
_lpNetwork$ = -8					; size = 4
_nStatus$ = -4						; size = 2
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_NetStatus@8 PROC

; 4957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4958 :    LPTASK         lpTask;
; 4959 :    LPNETWORK      lpNetwork;
; 4960 :    zSHORT         nStatus;
; 4961 : 
; 4962 :    // If task not active or disabled, return zCALL_ERROR.
; 4963 :    if ( (lpTask = fnOperationCall( iNetStatus, lpTaskView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	508					; 000001fcH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetStatus

; 4964 :    {
; 4965 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStatus
$LN2@NetStatus:

; 4966 :    }
; 4967 : 
; 4968 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, FALSE )) == 0 )

	push	0
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN3@NetStatus

; 4969 :    {
; 4970 :       if ( pchNetworkName == 0 )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	jne	SHORT $LN4@NetStatus

; 4971 :          pchNetworkName = DEFAULT_NETWORK;

	mov	DWORD PTR _pchNetworkName$[ebp], OFFSET $SG15250
$LN4@NetStatus:

; 4972 : 
; 4973 :       TraceLineS( "(kzoeneta) ** Network status: no network running for ",

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	push	OFFSET $SG15251
	call	_TraceLineS@8

; 4974 :                   pchNetworkName );
; 4975 :       fnOperationReturn( iNetStatus, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	508					; 000001fcH
	call	_fnOperationReturn
	add	esp, 8

; 4976 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@NetStatus
$LN3@NetStatus:

; 4977 :    }
; 4978 : 
; 4979 :    nStatus = zNETSTAT_STARTED;

	mov	edx, 1
	mov	WORD PTR _nStatus$[ebp], dx

; 4980 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN5@NetStatus

; 4981 :    {
; 4982 :       TraceLineS( "(kzoeneta) ** Network status for network: ",

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET $SG15253
	call	_TraceLineS@8

; 4983 :                   lpNetwork->szNetworkName );
; 4984 :       TraceLineS( "(kzoeneta)         ** Network running", "" );

	push	OFFSET $SG15254
	push	OFFSET $SG15255
	call	_TraceLineS@8
$LN5@NetStatus:

; 4985 :    }
; 4986 : 
; 4987 :    if ( lpNetwork->nConnCount > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+148]
	test	ecx, ecx
	jle	SHORT $LN6@NetStatus

; 4988 :    {
; 4989 :       nStatus |= zNETSTAT_OPENCONNECTION;

	movsx	edx, WORD PTR _nStatus$[ebp]
	or	edx, 2
	mov	WORD PTR _nStatus$[ebp], dx

; 4990 : 
; 4991 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN6@NetStatus

; 4992 :       {
; 4993 :          TraceLineI( "(kzoeneta)         ** Connections running: ",

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+148]
	push	eax
	push	OFFSET $SG15258
	call	_TraceLineI@8
$LN6@NetStatus:

; 4994 :                      lpNetwork->nConnCount );
; 4995 :       }
; 4996 :    }
; 4997 : 
; 4998 :    if ( lpNetwork->bListen )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+154]
	and	edx, 1
	je	SHORT $LN8@NetStatus

; 4999 :    {
; 5000 :       nStatus |= zNETSTAT_LISTEN;

	movsx	eax, WORD PTR _nStatus$[ebp]
	or	eax, 4
	mov	WORD PTR _nStatus$[ebp], ax

; 5001 : 
; 5002 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN8@NetStatus

; 5003 :       {
; 5004 :          TraceLineS( "(kzoeneta)         ** Network listening", "" );

	push	OFFSET $SG15261
	push	OFFSET $SG15262
	call	_TraceLineS@8
$LN8@NetStatus:

; 5005 :       }
; 5006 :    }
; 5007 : 
; 5008 :    fnOperationReturn( iNetStatus, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	508					; 000001fcH
	call	_fnOperationReturn
	add	esp, 8

; 5009 :    return( nStatus );

	mov	ax, WORD PTR _nStatus$[ebp]
$LN1@NetStatus:

; 5010 : 
; 5011 : } // NetStatus

	mov	esp, ebp
	pop	ebp
	ret	8
_NetStatus@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = -8					; size = 4
_lpTask$ = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_nTraceLevel$ = 16					; size = 2
_NetSetTraceLevel@12 PROC

; 4862 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4863 :    LPTASK         lpTask;
; 4864 :    LPNETWORK      lpNetwork;
; 4865 : 
; 4866 :    // If task not active or disabled, return zCALL_ERROR.
; 4867 :    if ( (lpTask = fnOperationCall( iNetSetTraceLevel, lpTaskView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	506					; 000001faH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetSetTrac

; 4868 :    {
; 4869 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetSetTrac
$LN2@NetSetTrac:

; 4870 :    }
; 4871 : 
; 4872 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN3@NetSetTrac

; 4873 :    {
; 4874 :       fnOperationReturn( iNetSetTraceLevel, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	506					; 000001faH
	call	_fnOperationReturn
	add	esp, 8

; 4875 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetSetTrac
$LN3@NetSetTrac:

; 4876 :    }
; 4877 : 
; 4878 :    lpNetwork->nTraceLevel = nTraceLevel;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	dx, WORD PTR _nTraceLevel$[ebp]
	mov	WORD PTR [ecx+140], dx

; 4879 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN4@NetSetTrac

; 4880 :    {
; 4881 :       TraceLineI( "(kzoeneta) ** Setting Net trace level to ", nTraceLevel );

	movsx	edx, WORD PTR _nTraceLevel$[ebp]
	push	edx
	push	OFFSET $SG15229
	call	_TraceLineI@8
$LN4@NetSetTrac:

; 4882 :    }
; 4883 : 
; 4884 :    fnOperationReturn( iNetSetTraceLevel, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	506					; 000001faH
	call	_fnOperationReturn
	add	esp, 8

; 4885 :    return( 0 );

	xor	eax, eax
$LN1@NetSetTrac:

; 4886 : 
; 4887 : } // NetSetTraceLevel

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_NetSetTraceLevel@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = -8					; size = 4
_lpTask$ = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_NetGetTraceLevel@8 PROC

; 4911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4912 :    LPTASK         lpTask;
; 4913 :    LPNETWORK      lpNetwork;
; 4914 : 
; 4915 :    // If task not active or disabled, return zCALL_ERROR.
; 4916 :    if ( (lpTask = fnOperationCall( iNetGetTraceLevel, lpTaskView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	503					; 000001f7H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetGetTrac

; 4917 :    {
; 4918 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetGetTrac
$LN2@NetGetTrac:

; 4919 :    }
; 4920 : 
; 4921 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN3@NetGetTrac

; 4922 :    {
; 4923 :       fnOperationReturn( iNetGetTraceLevel, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	503					; 000001f7H
	call	_fnOperationReturn
	add	esp, 8

; 4924 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetGetTrac
$LN3@NetGetTrac:

; 4925 :    }
; 4926 : 
; 4927 :    fnOperationReturn( iNetGetTraceLevel, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	503					; 000001f7H
	call	_fnOperationReturn
	add	esp, 8

; 4928 :    return( lpNetwork->nTraceLevel );

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	ax, WORD PTR [edx+140]
$LN1@NetGetTrac:

; 4929 : 
; 4930 : } // NetGetTraceLevel

	mov	esp, ebp
	pop	ebp
	ret	8
_NetGetTraceLevel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lPacketData$ = -60					; size = 4
tv211 = -56						; size = 4
tv202 = -52						; size = 4
_pchTemp$ = -48						; size = 4
_vTrace$ = -44						; size = 4
_lpTask$ = -40						; size = 4
_lpNetwork$ = -36					; size = 4
_cPacketType$ = -29					; size = 1
_nRC$ = -28						; size = 2
_szDateTime$1 = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_ppvConn$ = 16						; size = 4
_NetProcessMessage@12 PROC

; 2050 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2051 :    zCHAR       *pchTemp;
; 2052 :    LPTASK      lpTask;
; 2053 :    zCHAR       cPacketType;
; 2054 :    zLONG       lPacketData;
; 2055 :    LPNETWORK   lpNetwork;
; 2056 :    zVIEW       vTrace = 0;

	mov	DWORD PTR _vTrace$[ebp], 0

; 2057 :    zSHORT      nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2058 : 
; 2059 :    // If task not active or disabled, return zCALL_ERROR.
; 2060 :    if ( (lpTask = fnOperationCall( iNetProcessMessage, lpTaskView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	push	505					; 000001f9H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN8@NetProcess

; 2061 :    {
; 2062 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetProcess
$LN8@NetProcess:

; 2063 :    }
; 2064 : 
; 2065 :    TraceLineS( "(kzoeneta) ** Inside NetProcessMessage( ) network: ", pchNetworkName );

	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	push	OFFSET $SG14309
	call	_TraceLineS@8

; 2066 : 
; 2067 :    // Set flag indicating that the current task is a server for a client
; 2068 :    // request.
; 2069 :    lpTask->bServer = TRUE;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 2070 : 
; 2071 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN9@NetProcess

; 2072 :    {
; 2073 :       TraceLineS( "(kzoeneta) ** Cannot find network NetProcessMessage( ) network: ", pchNetworkName );

	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	push	OFFSET $SG14311
	call	_TraceLineS@8

; 2074 :       fnOperationReturn( iNetProcessMessage, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	505					; 000001f9H
	call	_fnOperationReturn
	add	esp, 8

; 2075 :       lpTask->bServer = FALSE;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 2076 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetProcess
$LN9@NetProcess:

; 2077 :    }
; 2078 : 
; 2079 :    // A connection should have been created and passed to us via ppvConn so
; 2080 :    // we'll just add it to our connection list.
; 2081 :    fnAddConnectionToNetwork( lpTask, lpNetwork, 0, ppvConn,

	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnAddConnectionToNetwork@32

; 2082 :                              FALSE, 0, 0, lpTaskView );
; 2083 : 
; 2084 : // if ( lpNetwork->nTraceLevel > 0 )
; 2085 :       TraceLineS( "(kzoeneta) ** Received message for network ",

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET $SG14312
	call	_TraceLineS@8
$LN2@NetProcess:

; 2086 :                   lpNetwork->szNetworkName );
; 2087 : 
; 2088 :    // This seems to continue looping if the data packet if a TRACESWITCH or TIMESTAMP. Not really sure
; 2089 :    // when that would be used.
; 2090 :    while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$LN3@NetProcess

; 2091 :    {
; 2092 :       if ( fnReceiveDataPacket( lpNetwork, ppvConn, &cPacketType,
; 2093 :                                 &lPacketData ) != 0 )

	lea	ecx, DWORD PTR _lPacketData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cPacketType$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnReceiveDataPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN10@NetProcess

; 2094 :       {
; 2095 :          TraceLineS( "(kzoeneta) ** Error receiving message!", "" );

	push	OFFSET $SG14314
	push	OFFSET $SG14315
	call	_TraceLineS@8

; 2096 :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN10@NetProcess:

; 2097 :       }
; 2098 : 
; 2099 :       if ( cPacketType == zPACKET_TRACESWITCH )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	cmp	ecx, 43					; 0000002bH
	jne	SHORT $LN11@NetProcess

; 2100 :       {
; 2101 :          if ( fnProcessTraceSwitches( lpNetwork, ppvConn, lpTask ) != 0 )

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnProcessTraceSwitches@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN13@NetProcess

; 2102 :          {
; 2103 :             TraceLineS( "(kzoeneta) ** Error receiving Trace Switches", "" );

	push	OFFSET $SG14319
	push	OFFSET $SG14320
	call	_TraceLineS@8

; 2104 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN13@NetProcess:

; 2105 :          }
; 2106 :       }

	jmp	SHORT $LN12@NetProcess
$LN11@NetProcess:

; 2107 :       else
; 2108 :       if ( cPacketType == zPACKET_TIMESTAMP )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	cmp	ecx, 84					; 00000054H
	jne	SHORT $LN14@NetProcess

; 2109 :       {
; 2110 :          fnProcessTimestamp( lpNetwork, ppvConn, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnProcessTimestamp@12

; 2111 :       }

	jmp	SHORT $LN12@NetProcess
$LN14@NetProcess:

; 2112 :       else
; 2113 :          break;

	jmp	SHORT $LN3@NetProcess
$LN12@NetProcess:

; 2114 :    }

	jmp	$LN2@NetProcess
$LN3@NetProcess:

; 2115 : 
; 2116 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN16@NetProcess

; 2117 :    {
; 2118 :       TraceLineS( "(kzoeneta) ** Error ... removing connection from network!", "" );

	push	OFFSET $SG14324
	push	OFFSET $SG14325
	call	_TraceLineS@8

; 2119 :       fnRemoveConnectionFromNetwork( lpNetwork, ppvConn, FALSE );

	push	0
	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnRemoveConnectionFromNetwork@12

; 2120 :       fnOperationReturn( iNetProcessMessage, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	505					; 000001f9H
	call	_fnOperationReturn
	add	esp, 8

; 2121 :       lpTask->bServer = FALSE;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ecx, -65				; ffffffbfH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 2122 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetProcess
$LN16@NetProcess:

; 2123 :    }
; 2124 : 
; 2125 :    // Create Trace Object
; 2126 :    nRC = SfActivateSysEmptyOI( &vTrace, "KZTRACEO", lpTaskView, zSINGLE );

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	OFFSET $SG14326
	lea	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16
	mov	WORD PTR _nRC$[ebp], ax

; 2127 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN17@NetProcess

; 2128 :       nRC = SetNameForView( vTrace, "KZTRACEO", lpTaskView, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	OFFSET $SG14328
	mov	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	call	_SetNameForView@16
	mov	WORD PTR _nRC$[ebp], ax
$LN17@NetProcess:

; 2129 : 
; 2130 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN18@NetProcess

; 2131 :       nRC = SfLockView( vTrace );

	mov	eax, DWORD PTR _vTrace$[ebp]
	push	eax
	call	_SfLockView@4
	mov	WORD PTR _nRC$[ebp], ax
$LN18@NetProcess:

; 2132 : 
; 2133 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN19@NetProcess

; 2134 :    {
; 2135 :       zCHAR szDateTime[ 18 ];
; 2136 : 
; 2137 :       nRC = CreateEntity( vTrace, "Trace", zPOS_AFTER );

	push	3
	push	OFFSET $SG14331
	mov	edx, DWORD PTR _vTrace$[ebp]
	push	edx
	call	_CreateEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 2138 :       SetAttributeFromInteger( vTrace, "Trace", "nLine", 0 );

	push	0
	push	OFFSET $SG14332
	push	OFFSET $SG14333
	mov	eax, DWORD PTR _vTrace$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 2139 :       SysGetDateTime( szDateTime );  // DateTime yyyymmddhhmmssttt

	lea	ecx, DWORD PTR _szDateTime$1[ebp]
	push	ecx
	call	_SysGetDateTime@4

; 2140 :       SetAttributeFromVariable( vTrace, "Trace", "TraceStart",

	push	0
	push	OFFSET $SG14334
	push	17					; 00000011H
	push	83					; 00000053H
	lea	edx, DWORD PTR _szDateTime$1[ebp]
	push	edx
	push	OFFSET $SG14335
	push	OFFSET $SG14336
	mov	eax, DWORD PTR _vTrace$[ebp]
	push	eax
	call	_SetAttributeFromVariable@32
$LN19@NetProcess:

; 2141 :                                 szDateTime, zTYPE_STRING, 17, "DateTime", 0 );
; 2142 :    }
; 2143 : 
; 2144 :    switch ( cPacketType )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	mov	DWORD PTR tv202[ebp], ecx
	mov	edx, DWORD PTR tv202[ebp]
	sub	edx, 67					; 00000043H
	mov	DWORD PTR tv202[ebp], edx
	cmp	DWORD PTR tv202[ebp], 48		; 00000030H
	ja	SHORT $LN26@NetProcess
	mov	eax, DWORD PTR tv202[ebp]
	movzx	ecx, BYTE PTR $LN39@NetProcess[eax]
	jmp	DWORD PTR $LN41@NetProcess[ecx*4]
$LN20@NetProcess:

; 2145 :    {
; 2146 :       case zPACKET_REQUESTOIFROMFILE:
; 2147 :          pchTemp = "Request OI From File";

	mov	DWORD PTR _pchTemp$[ebp], OFFSET $SG14338

; 2148 :          break;

	jmp	SHORT $LN4@NetProcess
$LN21@NetProcess:

; 2149 : 
; 2150 :       case zPACKET_REQUESTOI:
; 2151 :          pchTemp = "Request OI";

	mov	DWORD PTR _pchTemp$[ebp], OFFSET $SG14340

; 2152 :          break;

	jmp	SHORT $LN4@NetProcess
$LN22@NetProcess:

; 2153 : 
; 2154 :       case zPACKET_COMMITOITOFILE:
; 2155 :          pchTemp = "Commit OI to File";

	mov	DWORD PTR _pchTemp$[ebp], OFFSET $SG14342

; 2156 :          break;

	jmp	SHORT $LN4@NetProcess
$LN23@NetProcess:

; 2157 : 
; 2158 :       case zPACKET_COMMITOI:
; 2159 :          pchTemp = "Commit OI";

	mov	DWORD PTR _pchTemp$[ebp], OFFSET $SG14344

; 2160 :          break;

	jmp	SHORT $LN4@NetProcess
$LN24@NetProcess:

; 2161 : 
; 2162 :       case zPACKET_SENDFILE:
; 2163 :          pchTemp = "Send File";

	mov	DWORD PTR _pchTemp$[ebp], OFFSET $SG14346

; 2164 :          break;

	jmp	SHORT $LN4@NetProcess
$LN25@NetProcess:

; 2165 : 
; 2166 :       case zPACKET_CALLOPERATION:
; 2167 :          pchTemp = "Call Operation";

	mov	DWORD PTR _pchTemp$[ebp], OFFSET $SG14348

; 2168 :          break;

	jmp	SHORT $LN4@NetProcess
$LN26@NetProcess:

; 2169 : 
; 2170 :       default:
; 2171 :          pchTemp = "BAD_MESSAGE";

	mov	DWORD PTR _pchTemp$[ebp], OFFSET $SG14350
$LN4@NetProcess:

; 2172 :          break;
; 2173 :    }
; 2174 : 
; 2175 :    TraceLineS( "(kzoeneta) ** Message Type == ", pchTemp );

	mov	edx, DWORD PTR _pchTemp$[ebp]
	push	edx
	push	OFFSET $SG14351
	call	_TraceLineS@8

; 2176 : 
; 2177 :    if ( setjmp( jbEmergencyExit ) == 0 )

	push	0
	push	OFFSET _jbEmergencyExit
	call	__setjmp3
	add	esp, 8
	test	eax, eax
	jne	$LN27@NetProcess

; 2178 :    {
; 2179 :       // Check to see if the client requested an OI.
; 2180 :       switch ( cPacketType )

	movsx	eax, BYTE PTR _cPacketType$[ebp]
	mov	DWORD PTR tv211[ebp], eax
	mov	ecx, DWORD PTR tv211[ebp]
	sub	ecx, 67					; 00000043H
	mov	DWORD PTR tv211[ebp], ecx
	cmp	DWORD PTR tv211[ebp], 48		; 00000030H
	ja	$LN35@NetProcess
	mov	edx, DWORD PTR tv211[ebp]
	movzx	eax, BYTE PTR $LN40@NetProcess[edx]
	jmp	DWORD PTR $LN42@NetProcess[eax*4]
$LN29@NetProcess:

; 2181 :       {
; 2182 :          case zPACKET_REQUESTOIFROMFILE:
; 2183 :             nRC = fnProcessActivateOI_FromFile( lpNetwork, ppvConn );

	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnProcessActivateOI_FromFile@8
	mov	WORD PTR _nRC$[ebp], ax

; 2184 :             break;

	jmp	$LN6@NetProcess
$LN30@NetProcess:

; 2185 : 
; 2186 :          case zPACKET_REQUESTOI:
; 2187 :             nRC = fnProcessActivateOI( lpTaskView, lpNetwork, ppvConn );

	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_fnProcessActivateOI@12
	mov	WORD PTR _nRC$[ebp], ax

; 2188 :             break;

	jmp	$LN6@NetProcess
$LN31@NetProcess:

; 2189 : 
; 2190 :          case zPACKET_COMMITOITOFILE:
; 2191 :             nRC = fnProcessCommitOI_ToFile( lpNetwork, ppvConn );

	mov	eax, DWORD PTR _ppvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnProcessCommitOI_ToFile@8
	mov	WORD PTR _nRC$[ebp], ax

; 2192 :             break;

	jmp	$LN6@NetProcess
$LN32@NetProcess:

; 2193 : 
; 2194 :          case zPACKET_COMMITOI:
; 2195 :             nRC = fnProcessCommitOI( lpTaskView, lpNetwork, ppvConn );

	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnProcessCommitOI@12
	mov	WORD PTR _nRC$[ebp], ax

; 2196 :             break;

	jmp	SHORT $LN6@NetProcess
$LN33@NetProcess:

; 2197 : 
; 2198 :          case zPACKET_SENDFILE:
; 2199 :             nRC = fnProcessSendFile( lpTaskView, lpNetwork, ppvConn );

	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnProcessSendFile@12
	mov	WORD PTR _nRC$[ebp], ax

; 2200 :             break;

	jmp	SHORT $LN6@NetProcess
$LN34@NetProcess:

; 2201 : 
; 2202 :          case zPACKET_CALLOPERATION:
; 2203 :             nRC = fnProcessOperation( lpTaskView, lpNetwork, ppvConn );

	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnProcessOperation@12
	mov	WORD PTR _nRC$[ebp], ax

; 2204 :             break;

	jmp	SHORT $LN6@NetProcess
$LN35@NetProcess:

; 2205 : 
; 2206 :          default:
; 2207 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 2208 :             TraceLineI( "(kzoeneta) ** Bad message = ", cPacketType );

	movsx	eax, BYTE PTR _cPacketType$[ebp]
	push	eax
	push	OFFSET $SG14361
	call	_TraceLineI@8

; 2209 :             if ( fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,
; 2210 :                                    zNETERR_BADMESSAGE ) != 0 )

	push	5
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN6@NetProcess

; 2211 :             {
; 2212 :                TraceLineS( "(kzoeneta) ** Error sending zPACKET_END", "" );

	push	OFFSET $SG14363
	push	OFFSET $SG14364
	call	_TraceLineS@8
$LN6@NetProcess:

; 2213 :             }
; 2214 : 
; 2215 :             break;
; 2216 :       }
; 2217 :    }

	jmp	SHORT $LN28@NetProcess
$LN27@NetProcess:

; 2218 :    else
; 2219 :    {
; 2220 :       // We get here on a return from longjmp.
; 2221 :       // At that point, the system is highly instable (Out Of Memory).
; 2222 :       fnSendDataPacket( lpNetwork, ppvConn, zPACKET_ERROR,

	push	3
	push	42					; 0000002aH
	mov	ecx, DWORD PTR _ppvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16

; 2223 :                         zNETERR_OUTOFMEMORY );
; 2224 :       nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax
$LN28@NetProcess:

; 2225 :    }
; 2226 : 
; 2227 :    // Delete Trace Object
; 2228 :    if ( vTrace )

	cmp	DWORD PTR _vTrace$[ebp], 0
	je	SHORT $LN37@NetProcess

; 2229 :       DropObjectInstance( vTrace );

	mov	ecx, DWORD PTR _vTrace$[ebp]
	push	ecx
	call	_DropObjectInstance@4
$LN37@NetProcess:

; 2230 : 
; 2231 :    // The connection should be closed as soon as we return soooo...
; 2232 :    fnRemoveConnectionFromNetwork( lpNetwork, ppvConn, FALSE );

	push	0
	mov	edx, DWORD PTR _ppvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnRemoveConnectionFromNetwork@12

; 2233 : 
; 2234 :    fnOperationReturn( iNetProcessMessage, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	505					; 000001f9H
	call	_fnOperationReturn
	add	esp, 8

; 2235 :    lpTask->bServer = FALSE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -65				; ffffffbfH
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 2236 :    TraceLine( "(kzoeneta) ** Leaving NetProcessMessage( ) network: %s  RC: %d",

	movsx	edx, WORD PTR _nRC$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	push	OFFSET $SG14366
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 2237 :               pchNetworkName, nRC );
; 2238 : 
; 2239 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@NetProcess:

; 2240 : 
; 2241 : } // NetProcessMessage

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN41@NetProcess:
	DD	$LN23@NetProcess
	DD	$LN20@NetProcess
	DD	$LN25@NetProcess
	DD	$LN21@NetProcess
	DD	$LN22@NetProcess
	DD	$LN24@NetProcess
	DD	$LN26@NetProcess
$LN39@NetProcess:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	npad	3
$LN42@NetProcess:
	DD	$LN32@NetProcess
	DD	$LN29@NetProcess
	DD	$LN34@NetProcess
	DD	$LN30@NetProcess
	DD	$LN31@NetProcess
	DD	$LN33@NetProcess
	DD	$LN35@NetProcess
$LN40@NetProcess:
	DB	0
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
_NetProcessMessage@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lRC$ = -544						; size = 4
_OperInfo$ = -540					; size = 20
_lpViewOD$1 = -520					; size = 4
_l$2 = -516						; size = 4
_pch$3 = -512						; size = 4
_lpSubtask$4 = -508					; size = 4
_l$5 = -504						; size = 4
_pv$6 = -500						; size = 4
_lpViewOD$7 = -496					; size = 4
_lpApp$8 = -492						; size = 4
tv193 = -488						; size = 4
_pl$9 = -484						; size = 4
_pc$10 = -480						; size = 4
$T11 = -476						; size = 4
$T12 = -472						; size = 4
_pvView$13 = -468					; size = 4
_pchObjName$14 = -464					; size = 4
_vSendView$15 = -460					; size = 4
tv395 = -456						; size = 4
tv394 = -452						; size = 4
_ps$16 = -448						; size = 4
_pd$17 = -444						; size = 4
_pv$18 = -440						; size = 4
_n$19 = -436						; size = 2
tv597 = -432						; size = 4
tv194 = -428						; size = 4
_szDataType$20 = -424					; size = 2
_v$21 = -420						; size = 4
_pvoid$22 = -416					; size = 4
_szReturnType$ = -412					; size = 2
_cPacketType$ = -406					; size = 1
_c$23 = -405						; size = 1
_lpTask$ = -404						; size = 4
_nReturnCode$ = -400					; size = 2
_pvConn$ = -396						; size = 4
_nRC$ = -392						; size = 2
_lpNetwork$ = -388					; size = 4
_vaList$ = -384						; size = 4
_bPointer$24 = -377					; size = 1
_vArgs$ = -376						; size = 4
_d$25 = -372						; size = 40
_szServer$ = -332					; size = 256
_szTempAppName$26 = -76					; size = 33
_szAppName$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_pchNetworkName$ = 8					; size = 4
_pchAddress$ = 12					; size = 4
_vSubtask$ = 16						; size = 4
_bTransformation$ = 20					; size = 1
_pchInfo$ = 24						; size = 4
_pchOperName$ = 28					; size = 4
_pvReturn$ = 32						; size = 4
_pchArgList$ = 36					; size = 4
_NetCallOperation PROC

; 4037 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 4038 :    LPNETWORK     lpNetwork;
; 4039 :    zPVOID        pvConn = 0;

	mov	DWORD PTR _pvConn$[ebp], 0

; 4040 :    LPTASK        lpTask;
; 4041 :    zCHAR         szReturnType[ 2 ];
; 4042 :    zVIEW         vArgs = 0;

	mov	DWORD PTR _vArgs$[ebp], 0

; 4043 :    va_list       vaList;
; 4044 :    zCHAR         cPacketType;
; 4045 :    zCHAR         szAppName[ zZEIDON_NAME_LTH + 1 ];
; 4046 :    zCHAR         szServer[ 256 ];
; 4047 :    ServDirOperRecord OperInfo;
; 4048 :    zLONG         lRC;
; 4049 :    zSHORT        nReturnCode = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], ax

; 4050 :    zSHORT        nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 4051 : 
; 4052 :    // If task not active or disabled, return zCALL_ERROR.
; 4053 :    if ( (lpTask = fnOperationCall( iNetCallOperation, vSubtask, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	513					; 00000201H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN14@NetCallOpe

; 4054 :    {
; 4055 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN87@NetCallOpe
$LN14@NetCallOpe:

; 4056 :    }
; 4057 : 
; 4058 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN15@NetCallOpe

; 4059 :    {
; 4060 :       fnOperationReturn( iNetCallOperation, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	513					; 00000201H
	call	_fnOperationReturn
	add	esp, 8

; 4061 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN87@NetCallOpe
$LN15@NetCallOpe:

; 4062 :    }
; 4063 : 
; 4064 :    //
; 4065 :    // Try creating the argument object from the argument list.
; 4066 :    //
; 4067 : 
; 4068 :    SfActivateSysEmptyOI( &vArgs, "kztranwo", vSubtask, zSINGLE );

	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG15033
	lea	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 4069 :    if ( vArgs == 0 )

	cmp	DWORD PTR _vArgs$[ebp], 0
	jne	SHORT $LN16@NetCallOpe

; 4070 :    {
; 4071 :       fnOperationReturn( iNetCallOperation, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	513					; 00000201H
	call	_fnOperationReturn
	add	esp, 8

; 4072 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN87@NetCallOpe
$LN16@NetCallOpe:

; 4073 :    }
; 4074 : 
; 4075 :    fnRetrieveAppName( vSubtask, szAppName );

	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_fnRetrieveAppName@8

; 4076 : 
; 4077 :    CreateEntity( vArgs, "Operation", zPOS_AFTER );

	push	3
	push	OFFSET $SG15035
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_CreateEntity@12

; 4078 :    SetAttributeFromString( vArgs, "Operation", "ApplicationName", szAppName );

	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	push	OFFSET $SG15036
	push	OFFSET $SG15037
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4079 :    SetAttributeFromString( vArgs, "Operation", "OperName", pchOperName );

	mov	edx, DWORD PTR _pchOperName$[ebp]
	push	edx
	push	OFFSET $SG15038
	push	OFFSET $SG15039
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4080 :    if ( bTransformation )

	movzx	ecx, BYTE PTR _bTransformation$[ebp]
	test	ecx, ecx
	je	SHORT $LN17@NetCallOpe

; 4081 :    {
; 4082 :       SetAttributeFromString( vArgs, "Operation", "OperationType", zTYPE_TRAN );

	push	OFFSET $SG15042
	push	OFFSET $SG15043
	push	OFFSET $SG15044
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4083 :       SetAttributeFromString( vArgs, "Operation", "ObjectName", pchInfo );

	mov	eax, DWORD PTR _pchInfo$[ebp]
	push	eax
	push	OFFSET $SG15045
	push	OFFSET $SG15046
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4084 :    }

	jmp	SHORT $LN18@NetCallOpe
$LN17@NetCallOpe:

; 4085 :    else
; 4086 :    {
; 4087 :       SetAttributeFromString( vArgs, "Operation", "OperationType", zTYPE_GOPER );

	push	OFFSET $SG15047
	push	OFFSET $SG15048
	push	OFFSET $SG15049
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4088 :       if ( pchInfo && *pchInfo )

	cmp	DWORD PTR _pchInfo$[ebp], 0
	je	SHORT $LN18@NetCallOpe
	mov	eax, DWORD PTR _pchInfo$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN18@NetCallOpe

; 4089 :          SetAttributeFromString( vArgs, "Operation", "DLL_Name", pchInfo );

	mov	edx, DWORD PTR _pchInfo$[ebp]
	push	edx
	push	OFFSET $SG15051
	push	OFFSET $SG15052
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN18@NetCallOpe:

; 4090 :    }
; 4091 : 
; 4092 :    // First value in the arg list is the return type.
; 4093 :    szReturnType[ 0 ] = *pchArgList++;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchArgList$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szReturnType$[ebp+edx], cl
	mov	edx, DWORD PTR _pchArgList$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchArgList$[ebp], edx

; 4094 :    szReturnType[ 1 ] = 0;

	mov	DWORD PTR $T12[ebp], 1
	cmp	DWORD PTR $T12[ebp], 2
	jae	SHORT $LN88@NetCallOpe
	jmp	SHORT $LN89@NetCallOpe
$LN88@NetCallOpe:
	call	___report_rangecheckfailure
$LN89@NetCallOpe:
	mov	eax, DWORD PTR $T12[ebp]
	mov	BYTE PTR _szReturnType$[ebp+eax], 0

; 4095 :    SetAttributeFromString( vArgs, "Operation", "ReturnType", szReturnType );

	lea	ecx, DWORD PTR _szReturnType$[ebp]
	push	ecx
	push	OFFSET $SG15053
	push	OFFSET $SG15054
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4096 : 
; 4097 :    // Loop through each of the arguments and add them to vArg.
; 4098 :    va_start( vaList, pchArgList );

	lea	eax, DWORD PTR _pchArgList$[ebp+4]
	mov	DWORD PTR _vaList$[ebp], eax
$LN2@NetCallOpe:

; 4099 :    while ( *pchArgList )

	mov	ecx, DWORD PTR _pchArgList$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN3@NetCallOpe

; 4100 :    {
; 4101 :       zCHAR  szDataType[ 2 ];
; 4102 :       zPVOID pvoid;
; 4103 :       zBOOL  bPointer;
; 4104 : 
; 4105 :       CreateEntity( vArgs, szlArgument, zPOS_AFTER );

	push	3
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_CreateEntity@12

; 4106 : 
; 4107 :       if ( *pchArgList == 'p' )

	mov	ecx, DWORD PTR _pchArgList$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 112				; 00000070H
	jne	$LN20@NetCallOpe

; 4108 :       {
; 4109 :          bPointer = TRUE;

	mov	BYTE PTR _bPointer$24[ebp], 1

; 4110 :          pchArgList++;

	mov	eax, DWORD PTR _pchArgList$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchArgList$[ebp], eax

; 4111 :          SetAttributeFromString( vArgs, szlArgument, "ReturnArgument", "Y" );

	push	OFFSET $SG15057
	push	OFFSET $SG15058
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4112 :          pvoid = va_arg( vaList, zPVOID );

	mov	edx, DWORD PTR _vaList$[ebp]
	add	edx, 4
	mov	DWORD PTR _vaList$[ebp], edx
	mov	eax, DWORD PTR _vaList$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR _pvoid$22[ebp], ecx

; 4113 :          SetAttributeFromBlob( vArgs, szlArgument, "PointerValue",

	push	4
	lea	edx, DWORD PTR _pvoid$22[ebp]
	push	edx
	push	OFFSET $SG15059
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromBlob@20

; 4114 :                                &pvoid, sizeof( pvoid ) );
; 4115 :          if ( pvoid )

	cmp	DWORD PTR _pvoid$22[ebp], 0
	je	SHORT $LN22@NetCallOpe

; 4116 :             SetAttributeFromString( vArgs, szlArgument, "SendArgument", "Y" );

	push	OFFSET $SG15061
	push	OFFSET $SG15062
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN22@NetCallOpe:

; 4117 :       }

	jmp	SHORT $LN21@NetCallOpe
$LN20@NetCallOpe:

; 4118 :       else
; 4119 :          bPointer = FALSE;

	mov	BYTE PTR _bPointer$24[ebp], 0
$LN21@NetCallOpe:

; 4120 : 
; 4121 :       szDataType[ 0 ] = *pchArgList;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchArgList$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _szDataType$20[ebp+eax], dl

; 4122 :       szDataType[ 1 ] = 0;

	mov	DWORD PTR $T11[ebp], 1
	cmp	DWORD PTR $T11[ebp], 2
	jae	SHORT $LN90@NetCallOpe
	jmp	SHORT $LN91@NetCallOpe
$LN90@NetCallOpe:
	call	___report_rangecheckfailure
$LN91@NetCallOpe:
	mov	eax, DWORD PTR $T11[ebp]
	mov	BYTE PTR _szDataType$20[ebp+eax], 0

; 4123 :       SetAttributeFromString( vArgs, szlArgument, "DataType", szDataType );

	lea	ecx, DWORD PTR _szDataType$20[ebp]
	push	ecx
	push	OFFSET $SG15063
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4124 : 
; 4125 :       switch ( *pchArgList++ )

	mov	eax, DWORD PTR _pchArgList$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv193[ebp], ecx
	mov	edx, DWORD PTR _pchArgList$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchArgList$[ebp], edx
	mov	eax, DWORD PTR tv193[ebp]
	mov	DWORD PTR tv194[ebp], eax
	mov	ecx, DWORD PTR tv194[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR tv194[ebp], ecx
	cmp	DWORD PTR tv194[ebp], 13		; 0000000dH
	ja	$LN4@NetCallOpe
	mov	edx, DWORD PTR tv194[ebp]
	movzx	eax, BYTE PTR $LN96@NetCallOpe[edx]
	jmp	DWORD PTR $LN97@NetCallOpe[eax*4]

; 4126 :       {
; 4127 :          case 'l':      // Local address
; 4128 :             // The argument to the transformation is the local address, but to
; 4129 :             // keep anyone from cheating we don't send the address.  We'll set
; 4130 :             // the argument type to 'l' and let the server retrieve the local
; 4131 :             // address via the network.
; 4132 :             break;

	jmp	$LN4@NetCallOpe
$LN24@NetCallOpe:

; 4133 : 
; 4134 :          case 'S':      // String
; 4135 :          {
; 4136 :             zPCHAR pch = va_arg( vaList, zPCHAR );

	mov	ecx, DWORD PTR _vaList$[ebp]
	add	ecx, 4
	mov	DWORD PTR _vaList$[ebp], ecx
	mov	edx, DWORD PTR _vaList$[ebp]
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR _pch$3[ebp], eax

; 4137 :             SetAttributeFromString( vArgs, szlArgument, "Value", pch );

	mov	ecx, DWORD PTR _pch$3[ebp]
	push	ecx
	push	OFFSET $SG15066
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4138 :             break;

	jmp	$LN4@NetCallOpe
$LN25@NetCallOpe:

; 4139 :          }
; 4140 : 
; 4141 :          case 'Y':      // Byte
; 4142 :             if ( bPointer )

	movzx	eax, BYTE PTR _bPointer$24[ebp]
	test	eax, eax
	je	SHORT $LN26@NetCallOpe

; 4143 :             {
; 4144 :                zPCHAR pc = (zPCHAR) pvoid;

	mov	ecx, DWORD PTR _pvoid$22[ebp]
	mov	DWORD PTR _pc$10[ebp], ecx

; 4145 :                if ( pc )

	cmp	DWORD PTR _pc$10[ebp], 0
	je	SHORT $LN28@NetCallOpe

; 4146 :                   SetAttributeFromInteger( vArgs, szlArgument, "Value", *pc );

	mov	edx, DWORD PTR _pc$10[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	push	OFFSET $SG15071
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16
$LN28@NetCallOpe:

; 4147 :             }

	jmp	SHORT $LN27@NetCallOpe
$LN26@NetCallOpe:

; 4148 :             else
; 4149 :             {
; 4150 :                zCHAR c = (zCHAR) va_arg( vaList, VA_ARG_CHAR );

	mov	edx, DWORD PTR _vaList$[ebp]
	add	edx, 4
	mov	DWORD PTR _vaList$[ebp], edx
	mov	eax, DWORD PTR _vaList$[ebp]
	mov	cl, BYTE PTR [eax-4]
	mov	BYTE PTR _c$23[ebp], cl

; 4151 :                SetAttributeFromInteger( vArgs, szlArgument, "Value", c );

	movsx	edx, BYTE PTR _c$23[ebp]
	push	edx
	push	OFFSET $SG15072
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16
$LN27@NetCallOpe:

; 4152 :             }
; 4153 : 
; 4154 :             break;

	jmp	$LN4@NetCallOpe
$LN29@NetCallOpe:

; 4155 : 
; 4156 :          case 'L':      // Long integer
; 4157 :             if ( bPointer )

	movzx	ecx, BYTE PTR _bPointer$24[ebp]
	test	ecx, ecx
	je	SHORT $LN30@NetCallOpe

; 4158 :             {
; 4159 :                zPLONG pl = (zPLONG) pvoid;

	mov	edx, DWORD PTR _pvoid$22[ebp]
	mov	DWORD PTR _pl$9[ebp], edx

; 4160 :                if ( pl )

	cmp	DWORD PTR _pl$9[ebp], 0
	je	SHORT $LN32@NetCallOpe

; 4161 :                   SetAttributeFromInteger( vArgs, szlArgument, "Value", *pl );

	mov	eax, DWORD PTR _pl$9[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET $SG15077
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16
$LN32@NetCallOpe:

; 4162 :             }

	jmp	SHORT $LN31@NetCallOpe
$LN30@NetCallOpe:

; 4163 :             else
; 4164 :             {
; 4165 :                zLONG l = va_arg( vaList, zLONG );

	mov	eax, DWORD PTR _vaList$[ebp]
	add	eax, 4
	mov	DWORD PTR _vaList$[ebp], eax
	mov	ecx, DWORD PTR _vaList$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	mov	DWORD PTR _l$2[ebp], edx

; 4166 :                SetAttributeFromInteger( vArgs, szlArgument, "Value", l );

	mov	eax, DWORD PTR _l$2[ebp]
	push	eax
	push	OFFSET $SG15078
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16
$LN31@NetCallOpe:

; 4167 :             }
; 4168 : 
; 4169 :             break;

	jmp	$LN4@NetCallOpe
$LN33@NetCallOpe:

; 4170 : 
; 4171 :          case zTYPE_DECIMAL:      // Decimal
; 4172 :          case 'R':      // ??? Real ???
; 4173 :             if ( bPointer )

	movzx	edx, BYTE PTR _bPointer$24[ebp]
	test	edx, edx
	je	SHORT $LN34@NetCallOpe

; 4174 :             {
; 4175 :                zPDECIMAL pd = (zPDECIMAL) pvoid;

	mov	eax, DWORD PTR _pvoid$22[ebp]
	mov	DWORD PTR _pd$17[ebp], eax

; 4176 : 
; 4177 :                if ( pd )

	cmp	DWORD PTR _pd$17[ebp], 0
	je	SHORT $LN36@NetCallOpe

; 4178 :                   SetAttributeFromDecimal( vArgs, szlArgument, "Value", *pd );

	mov	esi, DWORD PTR _pd$17[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	push	OFFSET $SG15083
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromDecimal@52
$LN36@NetCallOpe:

; 4179 :             }

	jmp	SHORT $LN35@NetCallOpe
$LN34@NetCallOpe:

; 4180 :             else
; 4181 :             {
; 4182 :                zDECIMAL d;
; 4183 : 
; 4184 :                d = va_arg( vaList, zDECIMAL );

	mov	edx, DWORD PTR _vaList$[ebp]
	add	edx, 40					; 00000028H
	mov	DWORD PTR _vaList$[ebp], edx
	mov	esi, DWORD PTR _vaList$[ebp]
	sub	esi, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	lea	edi, DWORD PTR _d$25[ebp]
	rep movsd

; 4185 :                SetAttributeFromDecimal( vArgs, szlArgument, "Value", d );

	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _d$25[ebp]
	mov	edi, esp
	rep movsd
	push	OFFSET $SG15084
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromDecimal@52
$LN35@NetCallOpe:

; 4186 :             }
; 4187 : 
; 4188 :             break;

	jmp	$LN4@NetCallOpe
$LN37@NetCallOpe:

; 4189 : 
; 4190 :          case 'N':      // Short integer
; 4191 :             if ( bPointer )

	movzx	ecx, BYTE PTR _bPointer$24[ebp]
	test	ecx, ecx
	je	SHORT $LN38@NetCallOpe

; 4192 :             {
; 4193 :                zPSHORT ps = (zPSHORT) pvoid;

	mov	edx, DWORD PTR _pvoid$22[ebp]
	mov	DWORD PTR _ps$16[ebp], edx

; 4194 : 
; 4195 :                if ( ps )

	cmp	DWORD PTR _ps$16[ebp], 0
	je	SHORT $LN40@NetCallOpe

; 4196 :                   SetAttributeFromInteger( vArgs, szlArgument, "Value",

	mov	eax, DWORD PTR _ps$16[ebp]
	movsx	ecx, WORD PTR [eax]
	push	ecx
	push	OFFSET $SG15089
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16
$LN40@NetCallOpe:

; 4197 :                                            (zLONG) *ps );
; 4198 :             }

	jmp	SHORT $LN39@NetCallOpe
$LN38@NetCallOpe:

; 4199 :             else
; 4200 :             {
; 4201 :                zSHORT n = (zSHORT) va_arg( vaList, VA_ARG_SHORT );

	mov	eax, DWORD PTR _vaList$[ebp]
	add	eax, 4
	mov	DWORD PTR _vaList$[ebp], eax
	mov	ecx, DWORD PTR _vaList$[ebp]
	mov	dx, WORD PTR [ecx-4]
	mov	WORD PTR _n$19[ebp], dx

; 4202 : 
; 4203 :                SetAttributeFromInteger( vArgs, szlArgument, "Value", n );

	movsx	eax, WORD PTR _n$19[ebp]
	push	eax
	push	OFFSET $SG15090
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromInteger@16
$LN39@NetCallOpe:

; 4204 :             }
; 4205 : 
; 4206 :             break;

	jmp	$LN4@NetCallOpe

; 4207 : 
; 4208 :          case 'F':      // Float
; 4209 :             break;

	jmp	$LN4@NetCallOpe

; 4210 : 
; 4211 :          case 'D':      // Date
; 4212 :             break;

	jmp	$LN4@NetCallOpe

; 4213 : 
; 4214 :          case 'H':      // Time
; 4215 :             break;

	jmp	$LN4@NetCallOpe

; 4216 : 
; 4217 :          case 'B':      // Blob
; 4218 :             break;

	jmp	$LN4@NetCallOpe
$LN45@NetCallOpe:

; 4219 : 
; 4220 :          case 'V':      // View
; 4221 :             if ( bPointer )

	movzx	edx, BYTE PTR _bPointer$24[ebp]
	test	edx, edx
	je	$LN46@NetCallOpe

; 4222 :             {
; 4223 :                zPVIEW   pv = (zPVIEW) pvoid;

	mov	eax, DWORD PTR _pvoid$22[ebp]
	mov	DWORD PTR _pv$18[ebp], eax

; 4224 :                LPVIEWOD lpViewOD;
; 4225 : 
; 4226 :                // If the view is empty, then set flag to indicate we are NOT
; 4227 :                // sending the OI.
; 4228 :                if ( *pv == 0 )

	mov	ecx, DWORD PTR _pv$18[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN48@NetCallOpe

; 4229 :                   SetAttributeFromString( vArgs, szlArgument, "SendArgument", "N" );

	push	OFFSET $SG15100
	push	OFFSET $SG15101
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16
	jmp	SHORT $LN49@NetCallOpe
$LN48@NetCallOpe:

; 4230 :                else
; 4231 :                {
; 4232 :                   // Make sure the view is valid.
; 4233 :                   if ( fnValidView( lpTask, *pv ) == 0 )

	mov	eax, DWORD PTR _pv$18[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN50@NetCallOpe

; 4234 :                      goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN50@NetCallOpe:

; 4235 : 
; 4236 :                   lpViewOD = zGETPTR( (*pv)->hViewOD );

	mov	ecx, DWORD PTR _pv$18[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 4237 :                   SetAttributeFromString( vArgs, szlArgument, "ObjectName",

	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG15103
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4238 :                                           lpViewOD->szName );
; 4239 :                   SetAttributeFromString( vArgs, szlArgument, "SendArgument", "Y" );

	push	OFFSET $SG15104
	push	OFFSET $SG15105
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN49@NetCallOpe:

; 4240 :                }
; 4241 :             }

	jmp	$LN4@NetCallOpe
$LN46@NetCallOpe:

; 4242 :             else
; 4243 :             {
; 4244 :                zVIEW v = va_arg( vaList, zVIEW );

	mov	ecx, DWORD PTR _vaList$[ebp]
	add	ecx, 4
	mov	DWORD PTR _vaList$[ebp], ecx
	mov	edx, DWORD PTR _vaList$[ebp]
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR _v$21[ebp], eax

; 4245 : 
; 4246 :                if ( v == 0 )

	cmp	DWORD PTR _v$21[ebp], 0
	jne	SHORT $LN51@NetCallOpe

; 4247 :                {
; 4248 :                   SetAttributeFromString( vArgs, szlArgument, "SendArgument", "N" );

	push	OFFSET $SG15108
	push	OFFSET $SG15109
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4249 :                }

	jmp	$LN4@NetCallOpe
$LN51@NetCallOpe:

; 4250 :                else
; 4251 :                // Check to see if view is a subtask view.
; 4252 :                if ( v->hSubtask )

	mov	edx, DWORD PTR _v$21[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	$LN53@NetCallOpe

; 4253 :                {
; 4254 :                   LPSUBTASK lpSubtask = zGETPTR( v->hSubtask );

	mov	eax, DWORD PTR _v$21[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$4[ebp], eax

; 4255 :                   LPAPP     lpApp     = zGETPTR( lpSubtask->hApp );

	mov	edx, DWORD PTR _lpSubtask$4[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$8[ebp], eax

; 4256 : 
; 4257 :                   // We've got a subtask view--there is no OI to send but there
; 4258 :                   // is an application name.
; 4259 :                   SetAttributeFromString( vArgs, szlArgument,

	push	OFFSET $SG15112
	push	OFFSET $SG15113
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4260 :                                           "SubtaskView", "Y" );
; 4261 :                   SetAttributeFromString( vArgs, szlArgument,

	mov	edx, DWORD PTR _lpApp$8[ebp]
	add	edx, 6
	push	edx
	push	OFFSET $SG15114
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 4262 :                                           "ApplicationName", lpApp->szName );
; 4263 :                   SetAttributeFromString( vArgs, szlArgument,

	push	OFFSET $SG15115
	push	OFFSET $SG15116
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 4264 :                                           "SendArgument", "N" );
; 4265 :                }

	jmp	$LN4@NetCallOpe
$LN53@NetCallOpe:

; 4266 :                else
; 4267 :                {
; 4268 :                   zCHAR    szTempAppName[ zAPPL_NAME_LTH ];
; 4269 :                   LPVIEWOD lpViewOD;
; 4270 : 
; 4271 :                   if ( fnValidView( lpTask, v ) == 0 )

	mov	edx, DWORD PTR _v$21[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN55@NetCallOpe

; 4272 :                   {
; 4273 :                      va_end( vaList );

	mov	DWORD PTR _vaList$[ebp], 0

; 4274 :                      goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN55@NetCallOpe:

; 4275 :                   }
; 4276 : 
; 4277 :                   lpViewOD = zGETPTR( v->hViewOD );

	mov	edx, DWORD PTR _v$21[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$7[ebp], eax

; 4278 : 
; 4279 :                   // Check to see if the app name for the view matches the
; 4280 :                   // "global" app name for this transformation.  If it doesn't
; 4281 :                   // then we need to set the application name for the view.
; 4282 :                   fnRetrieveAppName( v, szTempAppName );

	lea	ecx, DWORD PTR _szTempAppName$26[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$21[ebp]
	push	edx
	call	_fnRetrieveAppName@8

; 4283 :                   if ( zstrcmp( szTempAppName, szAppName ) != 0 )

	movsx	eax, BYTE PTR _szTempAppName$26[ebp]
	movsx	ecx, BYTE PTR _szAppName$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN94@NetCallOpe
	lea	edx, DWORD PTR _szAppName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTempAppName$26[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv395[ebp], eax
	jmp	SHORT $LN95@NetCallOpe
$LN94@NetCallOpe:
	movsx	ecx, BYTE PTR _szTempAppName$26[ebp]
	movsx	edx, BYTE PTR _szAppName$[ebp]
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN92@NetCallOpe
	mov	DWORD PTR tv394[ebp], 1
	jmp	SHORT $LN93@NetCallOpe
$LN92@NetCallOpe:
	mov	DWORD PTR tv394[ebp], -1
$LN93@NetCallOpe:
	mov	eax, DWORD PTR tv394[ebp]
	mov	DWORD PTR tv395[ebp], eax
$LN95@NetCallOpe:
	cmp	DWORD PTR tv395[ebp], 0
	je	SHORT $LN56@NetCallOpe

; 4284 :                   {
; 4285 :                      SetAttributeFromString( vArgs, szlArgument,

	lea	ecx, DWORD PTR _szTempAppName$26[ebp]
	push	ecx
	push	OFFSET $SG15119
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$LN56@NetCallOpe:

; 4286 :                                              "ApplicationName",
; 4287 :                                              szTempAppName );
; 4288 :                   }
; 4289 : 
; 4290 :                   SetAttributeFromBlob( vArgs, szlArgument, "PointerValue",

	push	4
	lea	eax, DWORD PTR _v$21[ebp]
	push	eax
	push	OFFSET $SG15120
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromBlob@20

; 4291 :                                         &v, sizeof( v ) );
; 4292 :                   SetAttributeFromString( vArgs, szlArgument, "SendArgument", "Y" );

	push	OFFSET $SG15121
	push	OFFSET $SG15122
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 4293 :                   SetAttributeFromString( vArgs, szlArgument, "ObjectName",

	mov	eax, DWORD PTR _lpViewOD$7[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG15123
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN4@NetCallOpe:

; 4294 :                                           lpViewOD->szName );
; 4295 :                }
; 4296 :             }
; 4297 : 
; 4298 :             break;
; 4299 : 
; 4300 :       } // switch ( *pchArgList++ )...
; 4301 : 
; 4302 :    } // while ( *pchArgList )...

	jmp	$LN2@NetCallOpe
$LN3@NetCallOpe:

; 4303 : 
; 4304 :    va_end( vaList );

	mov	DWORD PTR _vaList$[ebp], 0

; 4305 : 
; 4306 :    // Set up info for activate request.
; 4307 :    OperInfo.pszNetworkName         = lpNetwork->szNetworkName;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR _OperInfo$[ebp], edx

; 4308 :    OperInfo.vSubtask               = vSubtask;

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	DWORD PTR _OperInfo$[ebp+12], eax

; 4309 :    OperInfo.lControl               = 0;

	mov	DWORD PTR _OperInfo$[ebp+8], 0

; 4310 :    OperInfo.pszUserSuppliedAddress = pchAddress;

	mov	ecx, DWORD PTR _pchAddress$[ebp]
	mov	DWORD PTR _OperInfo$[ebp+4], ecx

; 4311 :    OperInfo.pszOperName            = pchOperName;

	mov	edx, DWORD PTR _pchOperName$[ebp]
	mov	DWORD PTR _OperInfo$[ebp+16], edx

; 4312 : 
; 4313 :    // Open connection.
; 4314 :    if ( fnAddConnectionToNetwork( lpTask, lpNetwork, szServer,
; 4315 :                                   &pvConn, TRUE, zAPPLREQ_OPER,
; 4316 :                                   &OperInfo, vSubtask ) < 0 )

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _OperInfo$[ebp]
	push	ecx
	push	4
	push	1
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	lea	eax, DWORD PTR _szServer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnAddConnectionToNetwork@32
	cwde
	test	eax, eax
	jge	SHORT $LN57@NetCallOpe

; 4317 :    {
; 4318 :       nReturnCode = zNETWORK_ERROR;

	mov	ecx, -6					; fffffffaH
	mov	WORD PTR _nReturnCode$[ebp], cx

; 4319 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN57@NetCallOpe:

; 4320 :    }
; 4321 : 
; 4322 :    if ( lpNetwork->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	cmp	eax, 1
	jle	SHORT $LN58@NetCallOpe

; 4323 :       TraceLineS( "(kzoeneta) ** Sending Transformation Call", "" );

	push	OFFSET $SG15126
	push	OFFSET $SG15127
	call	_TraceLineS@8
$LN58@NetCallOpe:

; 4324 : 
; 4325 :    //=======================================================================
; 4326 :    // Transmitting data.
; 4327 :    //
; 4328 :    // Until further notice, the following code only SENDS data over the
; 4329 :    // network.
; 4330 :    //=======================================================================
; 4331 :    // First send the header for the server driver and then the regular
; 4332 :    // packet for the function structure.
; 4333 :    if ( fnSendHeaderPacket( lpNetwork, &pvConn, zPACKET_CALLOPERATION,
; 4334 :                             szAppName ) != 0 )

	lea	ecx, DWORD PTR _szAppName$[ebp]
	push	ecx
	push	79					; 0000004fH
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnSendHeaderPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN59@NetCallOpe

; 4335 :    {
; 4336 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN59@NetCallOpe:

; 4337 :    }
; 4338 : 
; 4339 :    if ( fnSendTraceSwitches( lpNetwork, &pvConn, lpTask) != 0 )

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendTraceSwitches@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN60@NetCallOpe

; 4340 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN60@NetCallOpe:

; 4341 : 
; 4342 :    if ( fnSendDataPacket( lpNetwork, &pvConn, zPACKET_CALLOPERATION, 0 ) != 0 )

	push	0
	push	79					; 0000004fH
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendDataPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN61@NetCallOpe

; 4343 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN61@NetCallOpe:

; 4344 : 
; 4345 :    // Send the app name.
; 4346 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 4347 :                                 szAppName, zAPPL_NAME_LTH,
; 4348 :                                 zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	33					; 00000021H
	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+170]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN62@NetCallOpe

; 4349 :    {
; 4350 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN62@NetCallOpe:

; 4351 :    }
; 4352 : 
; 4353 :    // Send the Argument list OI to the server to be committed.
; 4354 :    if ( fnSendOI( &pvConn, lpNetwork, vArgs, 0 ) == zCALL_ERROR )

	push	0
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	call	_fnSendOI@16
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN63@NetCallOpe

; 4355 :    {
; 4356 :       TraceLineS( "(kzoeneta) ** Error sending Arg OI!", "" );

	push	OFFSET $SG15133
	push	OFFSET $SG15134
	call	_TraceLineS@8

; 4357 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN63@NetCallOpe:

; 4358 :    }
; 4359 : 
; 4360 :    // Loop through each of the arguments looking for views.  If one is found
; 4361 :    // send it to the server.
; 4362 :    for ( nRC = SetCursorFirstEntityByString( vArgs, szlArgument, "DataType",

	push	0
	push	OFFSET $SG15135
	push	OFFSET $SG15136
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN8@NetCallOpe
$LN6@NetCallOpe:

; 4365 :          nRC = SetCursorNextEntityByString( vArgs, szlArgument, "DataType",

	push	0
	push	OFFSET $SG15137
	push	OFFSET $SG15138
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetCursorNextEntityByString@20
	mov	WORD PTR _nRC$[ebp], ax
$LN8@NetCallOpe:

; 4363 :                                              "V", 0 );
; 4364 :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN7@NetCallOpe

; 4366 :                                             "V", 0 ) )
; 4367 :    {
; 4368 :       zVIEW  vSendView;
; 4369 : 
; 4370 :       // If view is a Subtask View then we don't need to send anything.
; 4371 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 4372 :                                      "SubtaskView", "Y" ) == 0 )

	push	OFFSET $SG15140
	push	OFFSET $SG15141
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN64@NetCallOpe

; 4373 :       {
; 4374 :          continue;

	jmp	SHORT $LN6@NetCallOpe
$LN64@NetCallOpe:

; 4375 :       }
; 4376 : 
; 4377 :       // If we're not sending the view, skip it.
; 4378 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 4379 :                                      "SendArgument", "N" ) == 0 )

	push	OFFSET $SG15143
	push	OFFSET $SG15144
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN65@NetCallOpe

; 4380 :       {
; 4381 :          continue;

	jmp	SHORT $LN6@NetCallOpe
$LN65@NetCallOpe:

; 4382 :       }
; 4383 : 
; 4384 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 4385 :                                      "ReturnArgument", "Y" ) == 0 )

	push	OFFSET $SG15147
	push	OFFSET $SG15148
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN66@NetCallOpe

; 4386 :       {
; 4387 :          zPVIEW pv;
; 4388 : 
; 4389 :          GetBlobFromAttribute( &pv, 0, vArgs, szlArgument, "PointerValue" );

	push	OFFSET $SG15149
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _pv$6[ebp]
	push	edx
	call	_GetBlobFromAttribute@20

; 4390 :          vSendView = *pv;

	mov	eax, DWORD PTR _pv$6[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vSendView$15[ebp], ecx

; 4391 :       }

	jmp	SHORT $LN67@NetCallOpe
$LN66@NetCallOpe:

; 4392 :       else
; 4393 :          GetBlobFromAttribute( &vSendView, 0, vArgs,

	push	OFFSET $SG15150
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _vSendView$15[ebp]
	push	eax
	call	_GetBlobFromAttribute@20
$LN67@NetCallOpe:

; 4394 :                                szlArgument, "PointerValue" );
; 4395 : 
; 4396 :       // We need to send the view to the server...
; 4397 :       if ( fnSendOI( &pvConn, lpNetwork, vSendView,
; 4398 :                      zINCREMENTAL | zSAVE_CURSORS ) == zCALL_ERROR )

	push	327680					; 00050000H
	mov	ecx, DWORD PTR _vSendView$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	call	_fnSendOI@16
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN68@NetCallOpe

; 4399 :       {
; 4400 :          TraceLineS( "(kzoeneta) ** Error sending argument OI!", "" );

	push	OFFSET $SG15152
	push	OFFSET $SG15153
	call	_TraceLineS@8

; 4401 :          goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN68@NetCallOpe:

; 4402 :       }
; 4403 : 
; 4404 :    } // for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 )...

	jmp	$LN6@NetCallOpe
$LN7@NetCallOpe:

; 4405 : 
; 4406 :    // Tell network handler to flush the send buffer.
; 4407 :    if ( fnFlushBuffer( lpNetwork, &pvConn ) != 0 )

	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnFlushBuffer@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN69@NetCallOpe

; 4408 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN69@NetCallOpe:

; 4409 : 
; 4410 :    // We don't need it anymore so...
; 4411 :    fnDropView( vArgs );

	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_fnDropView@4

; 4412 :    vArgs = 0;

	mov	DWORD PTR _vArgs$[ebp], 0

; 4413 : 
; 4414 :    //=======================================================================
; 4415 :    // Receiving data.
; 4416 :    //
; 4417 :    // From here until we close the connection we will only RECEIVE data over
; 4418 :    // the network.
; 4419 :    //=======================================================================
; 4420 : 
; 4421 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN70@NetCallOpe

; 4422 :       TraceLineS( "(kzoeneta) ** Waiting for ACK", "" );

	push	OFFSET $SG15156
	push	OFFSET $SG15157
	call	_TraceLineS@8
$LN70@NetCallOpe:

; 4423 : 
; 4424 :    // Wait for return code.
; 4425 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lRC ) != 0 )

	lea	edx, DWORD PTR _lRC$[ebp]
	push	edx
	lea	eax, DWORD PTR _cPacketType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnReceiveDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN71@NetCallOpe

; 4426 :    {
; 4427 :       TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );

	push	OFFSET $SG15159
	push	OFFSET $SG15160
	call	_TraceLineS@8

; 4428 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN71@NetCallOpe:

; 4429 :    }
; 4430 : 
; 4431 :    if ( cPacketType != zPACKET_RC )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	cmp	ecx, 35					; 00000023H
	je	SHORT $LN72@NetCallOpe

; 4432 :    {
; 4433 :       TraceLineS( "(kzoeneta) ** No return code for NetCallOperation!", "" );

	push	OFFSET $SG15162
	push	OFFSET $SG15163
	call	_TraceLineS@8

; 4434 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN72@NetCallOpe:

; 4435 :    }
; 4436 : 
; 4437 :    if ( fnReceiveOI( &pvConn, lpNetwork, &vArgs, vSubtask, "kztranwo",
; 4438 :                      zSINGLE | zACTIVATE_SYSTEM ) == zCALL_ERROR )

	push	536870912				; 20000000H
	push	OFFSET $SG15165
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	call	_fnReceiveOI@24
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN73@NetCallOpe

; 4439 :    {
; 4440 :       TraceLineS( "(kzoeneta) ** Not able to retrieve Arg List!", "" );

	push	OFFSET $SG15166
	push	OFFSET $SG15167
	call	_TraceLineS@8

; 4441 :       goto EndOfFunction;

	jmp	$EndOfFunction$99
$LN73@NetCallOpe:

; 4442 :    }
; 4443 : 
; 4444 :    // Set the return value.
; 4445 :    switch ( szReturnType[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szReturnType$[ebp+edx]
	mov	DWORD PTR tv597[ebp], eax
	mov	ecx, DWORD PTR tv597[ebp]
	sub	ecx, 76					; 0000004cH
	mov	DWORD PTR tv597[ebp], ecx
	cmp	DWORD PTR tv597[ebp], 8
	ja	$LN9@NetCallOpe
	mov	edx, DWORD PTR tv597[ebp]
	jmp	DWORD PTR $LN98@NetCallOpe[edx*4]
$LN74@NetCallOpe:

; 4446 :    {
; 4447 :       case zTYPE_INTEGER:
; 4448 :          GetIntegerFromAttribute( (zPLONG) pvReturn,

	push	OFFSET $SG15169
	push	OFFSET $SG15170
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	push	ecx
	call	_GetIntegerFromAttribute@16

; 4449 :                                   vArgs, "Operation", "ReturnValue" );
; 4450 :          break;

	jmp	SHORT $LN9@NetCallOpe
$LN75@NetCallOpe:

; 4451 : 
; 4452 :       case 'N':  // Short integer.
; 4453 :       {
; 4454 :          zLONG l;
; 4455 : 
; 4456 :          GetIntegerFromAttribute( &l, vArgs, "Operation", "ReturnValue" );

	push	OFFSET $SG15172
	push	OFFSET $SG15173
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$5[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 4457 :          *((zPSHORT) pvReturn) = (zSHORT) l;

	mov	ecx, DWORD PTR _pvReturn$[ebp]
	mov	dx, WORD PTR _l$5[ebp]
	mov	WORD PTR [ecx], dx

; 4458 :          break;

	jmp	SHORT $LN9@NetCallOpe
$LN76@NetCallOpe:

; 4459 :       }
; 4460 : 
; 4461 :       case zTYPE_DATETIME:  // Date/time returned as a string.
; 4462 :       case zTYPE_STRING:
; 4463 :          GetStringFromAttribute( (zPCHAR) pvReturn,

	push	OFFSET $SG15175
	push	OFFSET $SG15176
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 4464 :                                  vArgs, "Operation", "ReturnValue" );
; 4465 :          break;

	jmp	SHORT $LN9@NetCallOpe
$LN77@NetCallOpe:

; 4466 : 
; 4467 :       case 'R':
; 4468 :       case zTYPE_DECIMAL:
; 4469 :          GetDecimalFromAttribute( (zPDECIMAL) pvReturn,

	push	OFFSET $SG15178
	push	OFFSET $SG15179
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturn$[ebp]
	push	eax
	call	_GetDecimalFromAttribute@16
$LN9@NetCallOpe:

; 4470 :                                   vArgs, "Operation", "ReturnValue" );
; 4471 :          break;
; 4472 :    }
; 4473 : 
; 4474 :    for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 );

	push	0
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN13@NetCallOpe
$LN11@NetCallOpe:

; 4476 :          nRC = SetCursorNextEntity( vArgs, szlArgument, 0 ) )

	push	0
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN13@NetCallOpe:

; 4475 :          nRC >= zCURSOR_SET;

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN12@NetCallOpe

; 4477 :    {
; 4478 :       zPVIEW pvView;
; 4479 :       zPCHAR pchObjName;
; 4480 : 
; 4481 :       // If the argument is not a view, then don't worry about it.
; 4482 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 4483 :                                      "DataType", "V" ) != 0 )

	push	OFFSET $SG15181
	push	OFFSET $SG15182
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_CompareAttributeToString@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN78@NetCallOpe

; 4484 :       {
; 4485 :          continue;

	jmp	SHORT $LN11@NetCallOpe
$LN78@NetCallOpe:

; 4486 :       }
; 4487 : 
; 4488 :       // If view is a Subtask View then we don't need to retrieve anything.
; 4489 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 4490 :                                      "SubtaskView", "Y" ) == 0 )

	push	OFFSET $SG15184
	push	OFFSET $SG15185
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN79@NetCallOpe

; 4491 :       {
; 4492 :          continue;

	jmp	SHORT $LN11@NetCallOpe
$LN79@NetCallOpe:

; 4493 :       }
; 4494 : 
; 4495 :       GetBlobFromAttribute( &pvView, 0, vArgs, szlArgument, "PointerValue" );

	push	OFFSET $SG15186
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _pvView$13[ebp]
	push	eax
	call	_GetBlobFromAttribute@20

; 4496 :       GetAddrForAttribute( &pchObjName, vArgs, szlArgument, "ObjectName" );

	push	OFFSET $SG15187
	push	OFFSET _szlArgument
	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchObjName$14[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 4497 : 
; 4498 :       // If the view is flagged as empty, then activate an empty OI.
; 4499 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 4500 :                                      "ViewReturned", "E" ) == 0 )

	push	OFFSET $SG15189
	push	OFFSET $SG15190
	push	OFFSET _szlArgument
	mov	eax, DWORD PTR _vArgs$[ebp]
	push	eax
	call	_CompareAttributeToString@16
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN80@NetCallOpe

; 4501 :       {
; 4502 : 
; 4503 :          ActivateEmptyObjectInstance( pvView, pchObjName, vSubtask, zMULTIPLE );

	push	256					; 00000100H
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchObjName$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvView$13[ebp]
	push	ecx
	call	_ActivateEmptyObjectInstance@16

; 4504 :          continue;

	jmp	$LN11@NetCallOpe
$LN80@NetCallOpe:

; 4505 :       }
; 4506 : 
; 4507 :       // If the view is flagged as being returned, retrieve it.
; 4508 :       if ( CompareAttributeToString( vArgs, szlArgument,
; 4509 :                                      "ViewReturned", "Y" ) == 0 )

	push	OFFSET $SG15192
	push	OFFSET $SG15193
	push	OFFSET _szlArgument
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_CompareAttributeToString@16
	cwde
	test	eax, eax
	jne	SHORT $LN81@NetCallOpe

; 4510 :       {
; 4511 :          if ( fnReceiveOI( &pvConn, lpNetwork, pvView, vSubtask,
; 4512 :                            pchObjName, zMULTIPLE ) == zCALL_ERROR )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _pchObjName$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvView$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	call	_fnReceiveOI@24
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN81@NetCallOpe

; 4513 :          {
; 4514 :             TraceLineS( "(kzoeneta) ** Not able to retrieve new view!", "" );

	push	OFFSET $SG15195
	push	OFFSET $SG15196
	call	_TraceLineS@8

; 4515 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$99
$LN81@NetCallOpe:

; 4516 :          }
; 4517 :       }
; 4518 : 
; 4519 :    } // for ( nRC = SetCursorFirstEntity( vArgs, szlArgument, 0 )...

	jmp	$LN11@NetCallOpe
$LN12@NetCallOpe:

; 4520 : 
; 4521 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN83@NetCallOpe

; 4522 :       TraceLineI( "(kzoeneta) ** RC from transaction = ", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG15198
	call	_TraceLineI@8
$LN83@NetCallOpe:

; 4523 : 
; 4524 :    if ( fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, vSubtask ) < 0 )

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnRetrieveMsgAndTraceObj@12
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN84@NetCallOpe

; 4525 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$99
$LN84@NetCallOpe:

; 4526 : 
; 4527 :    // If we got here, then everything's OK.
; 4528 :    nReturnCode = 0;

	xor	edx, edx
	mov	WORD PTR _nReturnCode$[ebp], dx
$EndOfFunction$99:

; 4529 : 
; 4530 : EndOfFunction:
; 4531 :    if ( pvConn && fnRemoveConnectionFromNetwork( lpNetwork, &pvConn,

	cmp	DWORD PTR _pvConn$[ebp], 0
	je	SHORT $LN85@NetCallOpe
	push	1
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnRemoveConnectionFromNetwork@12
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN85@NetCallOpe

; 4532 :                                                  TRUE ) == zCALL_ERROR )
; 4533 :    {
; 4534 :       nReturnCode = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturnCode$[ebp], ax
$LN85@NetCallOpe:

; 4535 :    }
; 4536 : 
; 4537 :    if ( vArgs )

	cmp	DWORD PTR _vArgs$[ebp], 0
	je	SHORT $LN86@NetCallOpe

; 4538 :       fnDropView( vArgs );

	mov	ecx, DWORD PTR _vArgs$[ebp]
	push	ecx
	call	_fnDropView@4
$LN86@NetCallOpe:

; 4539 : 
; 4540 :    fnOperationReturn( iNetCallOperation, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	513					; 00000201H
	call	_fnOperationReturn
	add	esp, 8

; 4541 :    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
$LN87@NetCallOpe:

; 4542 : 
; 4543 : } // NetCallOperation

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN97@NetCallOpe:
	DD	$LN29@NetCallOpe
	DD	$LN33@NetCallOpe
	DD	$LN37@NetCallOpe
	DD	$LN24@NetCallOpe
	DD	$LN45@NetCallOpe
	DD	$LN25@NetCallOpe
	DD	$LN4@NetCallOpe
$LN96@NetCallOpe:
	DB	0
	DB	1
	DB	2
	DB	6
	DB	6
	DB	6
	DB	1
	DB	3
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	5
	npad	2
$LN98@NetCallOpe:
	DD	$LN74@NetCallOpe
	DD	$LN77@NetCallOpe
	DD	$LN75@NetCallOpe
	DD	$LN9@NetCallOpe
	DD	$LN9@NetCallOpe
	DD	$LN9@NetCallOpe
	DD	$LN77@NetCallOpe
	DD	$LN76@NetCallOpe
	DD	$LN76@NetCallOpe
_NetCallOperation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pchNetworkName$ = 8					; size = 4
_pchAddress$ = 12					; size = 4
_pchLocalFileName$ = 16					; size = 4
_pchServerDirectory$ = 20				; size = 4
_pchServerFileName$ = 24				; size = 4
_bBinaryFile$ = 28					; size = 1
_vSubtask$ = 32						; size = 4
_NetSendFile@28 PROC

; 4582 : {

	push	ebp
	mov	ebp, esp

; 4583 :    return( 0 );

	xor	eax, eax

; 4584 : 
; 4585 : // 2001.06.28
; 4586 : // DGC Not supported at the moment (security risk).
; 4587 : #if 0
; 4588 :    zSHORT      nRC = zCALL_ERROR;
; 4589 :    zULONG      usBytesRead;
; 4590 :    zSHORT      iLineCount;
; 4591 :    zSHORT      nFileNameLth;
; 4592 :    zLONG       hFile = -1;
; 4593 :    LPNETWORK   lpNetwork;
; 4594 :    zPVOID      pvConn = 0;
; 4595 :    zPCHAR      pchLine = 0;
; 4596 :    zPCHAR      pchBuffer = 0;
; 4597 :    zBOOL       bConnOpen = FALSE;
; 4598 :    zCHAR       cDataType;
; 4599 :    zCHAR       cPacketType;
; 4600 :    zLONG       lPacketData;
; 4601 :    LPTASK      lpTask;
; 4602 :    SendFileRecord sf;
; 4603 :    LAD_InfoRecord LAD_Info;
; 4604 : 
; 4605 :    zmemset( &LAD_Info, 0, sizeof( LAD_Info ) );
; 4606 : 
; 4607 :    // If task not active or disabled, return zCALL_ERROR.
; 4608 :    if ( (lpTask = fnOperationCall( iNetSendFile ... )) == 0 )
; 4609 :    {
; 4610 :       return( zCALL_ERROR );
; 4611 :    }
; 4612 : 
; 4613 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )
; 4614 :       goto EndOfFunction;
; 4615 : 
; 4616 :    fnRetrieveAppName( vSubtask, sf.szAppName );
; 4617 :    nFileNameLth = zstrlen( pchServerFileName ) +
; 4618 :                            zstrlen( pchServerDirectory ) + 2;
; 4619 :    zltox( nFileNameLth, sf.szFileNameLth );
; 4620 : 
; 4621 :    // Try opening the file.
; 4622 :    hFile = SysOpenFile( vSubtask, pchLocalFileName, COREFILE_READ );
; 4623 :    if ( hFile == -1 )
; 4624 :    {
; 4625 :       TraceLineS( "(kzoeneta) ** Can't open file ", pchLocalFileName );
; 4626 :       SysMessageBox( szlNetworkError, "Can't open file for NetSendFile", 1 );
; 4627 :       goto EndOfFunction;
; 4628 :    }
; 4629 : 
; 4630 :    LAD_Info.lpTask     = lpTask;
; 4631 :    LAD_Info.lpNetwork  = lpNetwork;
; 4632 :    LAD_Info.vSubtask   = vSubtask;
; 4633 :    LAD_Info.nObjType   = zLADTYPE_SEND_FILE;
; 4634 :    SysGetUserID( vSubtask, LAD_Info.szUserName, LAD_Info.szPassword );
; 4635 : 
; 4636 :    if ( fnGetApplAddress( &LAD_Info, pchAddress ) == zCALL_ERROR )
; 4637 :    {
; 4638 :       fnOperationReturn( iNetSendFile, lpTask );
; 4639 :       return( zCALL_ERROR );
; 4640 :    }
; 4641 : 
; 4642 :    // Open connection.
; 4643 :    if ( fnAddConnectionToNetwork( &LAD_Info, &pvConn,
; 4644 :                                   TRUE, vSubtask ) == zCALL_ERROR )
; 4645 :    {
; 4646 :       goto EndOfFunction;
; 4647 :    }
; 4648 : 
; 4649 :    bConnOpen = TRUE;
; 4650 : 
; 4651 :    if ( lpNetwork->nTraceLevel > 1 )
; 4652 :       TraceLineS( "(kzoeneta) ** Sending file ", pchLocalFileName );
; 4653 : 
; 4654 :    // If we're sending a binary file then we need to set up a buffer.
; 4655 :    if ( bBinaryFile )
; 4656 :    {
; 4657 :       pchLine = (zPCHAR) fnAllocDataspace( lpTask->hFirstDataHeader,
; 4658 :                                            zSENDFILE_BUFFER, TRUE, 0, 0 );
; 4659 :       pchLine = (zPCHAR) zGETPTR( pchLine );
; 4660 :       if ( pchLine == 0 )
; 4661 :          goto EndOfFunction;
; 4662 : 
; 4663 :       sf.bBinaryFile = 'Y';
; 4664 :       cPacketType = zPACKET_SENDLTHB;
; 4665 :       cDataType   = zTYPE_BLOB;
; 4666 :    }
; 4667 :    else
; 4668 :    {
; 4669 :       sf.bBinaryFile = 'N';
; 4670 :       cPacketType = zPACKET_SENDLTHS;
; 4671 :       cDataType   = zTYPE_STRING;
; 4672 :    }
; 4673 : 
; 4674 :    //=======================================================================
; 4675 :    // Transmitting data.
; 4676 :    //
; 4677 :    // Until further notice, the following code only SENDS data over the
; 4678 :    // network.
; 4679 :    //
; 4680 :    //=======================================================================
; 4681 : 
; 4682 :    // First send the header for the server driver and then the regular
; 4683 :    // packet for the function structure.
; 4684 :    if ( fnSendHeaderPacket( lpNetwork, &pvConn, zPACKET_SENDFILE,
; 4685 :                             sf.szAppName ) != 0 )
; 4686 :    {
; 4687 :       goto EndOfFunction;
; 4688 :    }
; 4689 : 
; 4690 :    if ( fnSendTraceSwitches( lpNetwork, &pvConn, lpTask) != 0)
; 4691 :       goto EndOfFunction;
; 4692 : 
; 4693 :    if ( fnSendDataPacket( lpNetwork, &pvConn, zPACKET_SENDFILE, 0 ) != 0 )
; 4694 :       goto EndOfFunction;
; 4695 : 
; 4696 :    // Send the file information.
; 4697 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 4698 :                                 (zPCHAR) &sf, sizeof( sf ),
; 4699 :                                 zTYPE_STRING ) != 0 )
; 4700 :    {
; 4701 :       goto EndOfFunction;
; 4702 :    }
; 4703 : 
; 4704 :    // Send the directory/filename.
; 4705 :    pchBuffer = (zPCHAR) fnAllocDataspace( lpTask->hFirstDataHeader,
; 4706 :                                           nFileNameLth, TRUE, 0, 0 );
; 4707 :    pchBuffer = (zPCHAR) zGETPTR( pchBuffer );
; 4708 :    zstrcpy( pchBuffer, pchServerDirectory );
; 4709 :    zstrcpy( &pchBuffer[ zstrlen( pchBuffer ) + 1 ], pchServerFileName );
; 4710 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 4711 :                                 pchBuffer, nFileNameLth,
; 4712 :                                 zTYPE_STRING ) != 0 )
; 4713 :    {
; 4714 :       goto EndOfFunction;
; 4715 :    }
; 4716 : 
; 4717 :    // Now send each line of the file.
; 4718 :    iLineCount = 0;
; 4719 :    while ( TRUE )
; 4720 :    {
; 4721 :       if ( bBinaryFile )
; 4722 :       {
; 4723 :          usBytesRead = SysReadFile( vSubtask, hFile,
; 4724 :                                     pchLine, zSENDFILE_BUFFER );
; 4725 :          if ( usBytesRead == 0 )
; 4726 :             break;
; 4727 :       }
; 4728 :       else
; 4729 :       {
; 4730 :          if ( SysReadLine( vSubtask, (zCOREMEM) &pchLine, hFile ) != 1 )
; 4731 :             break;
; 4732 : 
; 4733 :          usBytesRead = zstrlen( pchLine ) + 1;
; 4734 :       }
; 4735 : 
; 4736 :       iLineCount++;
; 4737 : 
; 4738 :       // Send the length of the line.
; 4739 :       if ( fnSendDataPacket( lpNetwork, &pvConn, cPacketType,
; 4740 :                              usBytesRead ) != 0 )
; 4741 :          goto EndOfFunction;
; 4742 : 
; 4743 :       // Send the line.
; 4744 :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 4745 :                                    pchLine, usBytesRead, cDataType ) != 0 )
; 4746 :       {
; 4747 :          // Send 0 "length" to indicate we are done.
; 4748 :          fnSendDataPacket( lpNetwork, &pvConn, cPacketType, 0 );
; 4749 :          goto EndOfFunction;
; 4750 :       }
; 4751 : 
; 4752 :       // If we're reading a binary file then check to see if we are at the
; 4753 :       // end of the file.
; 4754 :       if ( bBinaryFile )
; 4755 :       {
; 4756 :          if ( usBytesRead < zSENDFILE_BUFFER )
; 4757 :             break;
; 4758 :       }
; 4759 : 
; 4760 :    } // for (;;)...
; 4761 : 
; 4762 :    // Send 0 "length" to indicate we are done.
; 4763 :    if ( fnSendDataPacket( lpNetwork, &pvConn, cPacketType, 0 ) != 0 )
; 4764 :       goto EndOfFunction;
; 4765 : 
; 4766 :    // Tell network handler to flush the send buffer.
; 4767 :    if ( fnFlushBuffer( lpNetwork, &pvConn ) != 0 )
; 4768 :       goto EndOfFunction;
; 4769 : 
; 4770 :    //=======================================================================
; 4771 :    // Receiving data.
; 4772 :    //
; 4773 :    // From here until we close the connection we will only RECEIVE data over
; 4774 :    // the network.
; 4775 :    //=======================================================================
; 4776 : 
; 4777 :    // Now wait for ack.
; 4778 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType,
; 4779 :                              &lPacketData ) != 0 )
; 4780 :       goto EndOfFunction;
; 4781 : 
; 4782 :    if ( cPacketType != zPACKET_RC )
; 4783 :    {
; 4784 :       TraceLineI( "(kzoeneta) ** Network error #", lPacketData );
; 4785 :       if ( lPacketData == zNETERR_OUTOFMEMORY )
; 4786 :       {
; 4787 :          SysMessageBox( "Server Transaction Crash ",
; 4788 :                         "*Out Of Memory*", 1 );
; 4789 :       }
; 4790 :    }
; 4791 :    else
; 4792 :    if ( lPacketData != iLineCount )
; 4793 :       TraceLineS( "(kzoeneta) ** Lines don't match up!", "" );
; 4794 :    else
; 4795 :       // If we get here then everything's OK.
; 4796 :       nRC = 0;
; 4797 : 
; 4798 :    if ( fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, vSubtask ) < 0 )
; 4799 :    {
; 4800 :       nRC = zCALL_ERROR;
; 4801 :       goto EndOfFunction;
; 4802 :    }
; 4803 : 
; 4804 : EndOfFunction:
; 4805 :    if ( nRC == zCALL_ERROR )
; 4806 :    {
; 4807 :       zCHAR szMsg[ zMAX_FILENAME_LTH + 40 ];
; 4808 : 
; 4809 :       zsprintf( szMsg, "Error sending file '%s' to server.", pchLocalFileName );
; 4810 :       SysMessageBox( szlNetworkError, szMsg, 1 );
; 4811 :    }
; 4812 : 
; 4813 :    if ( bConnOpen && fnRemoveConnectionFromNetwork( lpNetwork, &pvConn,
; 4814 :                                                     TRUE ) == zCALL_ERROR )
; 4815 :    {
; 4816 :       nRC = zCALL_ERROR;
; 4817 :    }
; 4818 : 
; 4819 :    if ( pchBuffer )
; 4820 :       fnFreeDataspace( pchBuffer );
; 4821 : 
; 4822 :    if ( hFile != -1 )
; 4823 :       SysCloseFile( vSubtask, hFile, 0 );
; 4824 : 
; 4825 :    if ( pchLine && bBinaryFile )
; 4826 :       fnFreeDataspace( pchLine );
; 4827 : 
; 4828 :    fnOperationReturn( iNetSendFile, lpTask );
; 4829 :    return( nRC );
; 4830 : #endif
; 4831 : 
; 4832 : } // NetSendFile

	pop	ebp
	ret	28					; 0000001cH
_NetSendFile@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pchNetworkName$ = 8					; size = 4
_pchAddress$ = 12					; size = 4
_lpView$ = 16						; size = 4
_pchFileName$ = 20					; size = 4
_lControl$ = 24						; size = 4
_NetCommitOI_ToFile@20 PROC

; 3798 : {

	push	ebp
	mov	ebp, esp

; 3799 :    return( 0 );

	xor	eax, eax

; 3800 : 
; 3801 : // 2001.06.28
; 3802 : // DGC Not supported at the moment (security risk).
; 3803 : #if 0
; 3804 :    zSHORT        nRC = zCALL_ERROR;
; 3805 :    zCHAR         cPacketType;
; 3806 :    zLONG         lPacketData;
; 3807 :    LPNETWORK     lpNetwork;
; 3808 :    zPVOID        pvConn = 0;
; 3809 :    zCommitPacket CommitPacket;
; 3810 :    LPTASK        lpTask;
; 3811 :    LPVIEWOD      lpViewOD;
; 3812 :    LAD_InfoRecord LAD_Info;
; 3813 : 
; 3814 :    zmemset( &LAD_Info, 0, sizeof( LAD_Info ) );
; 3815 : 
; 3816 :    // If task not active or disabled, return zCALL_ERROR.
; 3817 :    if ( (lpTask = fnOperationCall( iNetCommitOI_ToFile ... )) == 0 )
; 3818 :       return( zCALL_ERROR );
; 3819 : 
; 3820 :    if ( fnValidView( lpTask, lpView ) == 0 )
; 3821 :    {
; 3822 :       fnOperationReturn( iNetCommitOI_ToFile, lpTask );
; 3823 :       return( zCALL_ERROR );
; 3824 :    }
; 3825 : 
; 3826 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )
; 3827 :    {
; 3828 :       fnOperationReturn( iNetCommitOI_ToFile, lpTask );
; 3829 :       return( zCALL_ERROR );
; 3830 :    }
; 3831 : 
; 3832 :    lpViewOD = zGETPTR( lpView->hViewOD );
; 3833 : 
; 3834 :    LAD_Info.lpTask     = lpTask;
; 3835 :    LAD_Info.lpNetwork  = lpNetwork;
; 3836 :    LAD_Info.nObjType   = zLADTYPE_LOD_COMMIT_FILE;
; 3837 :    LAD_Info.pchObjName = lpViewOD->szName;
; 3838 :    fnRetrieveAppName( lpView, LAD_Info.szAppName );
; 3839 :    SysGetUserID( lpView, LAD_Info.szUserName, LAD_Info.szPassword );
; 3840 : 
; 3841 :    if ( fnGetApplAddress( &LAD_Info, pchAddress ) == zCALL_ERROR )
; 3842 :    {
; 3843 :       fnOperationReturn( iNetCommitOI_ToFile, lpTask );
; 3844 :       return( zCALL_ERROR );
; 3845 :    }
; 3846 : 
; 3847 :    // Open connection.
; 3848 :    if ( fnAddConnectionToNetwork( &LAD_Info, &pvConn,
; 3849 :                                   TRUE, lpView ) == zCALL_ERROR )
; 3850 :    {
; 3851 :       fnOperationReturn( iNetCommitOI_ToFile, lpTask );
; 3852 :       return( zCALL_ERROR );
; 3853 :    }
; 3854 : 
; 3855 :    if ( lpNetwork->nTraceLevel > 1 )
; 3856 :       TraceLineS( "(kzoeneta) ** Sending Commit OI packet", "" );
; 3857 : 
; 3858 :    //=======================================================================
; 3859 :    // Transmitting data.
; 3860 :    //
; 3861 :    // Until further notice, the following code only SENDS data over the
; 3862 :    // network.
; 3863 :    //=======================================================================
; 3864 : 
; 3865 :    // First send the header for the server driver and then the regular
; 3866 :    // packet for the function structure.
; 3867 :    if ( fnSendHeaderPacket( lpNetwork, &pvConn, zPACKET_COMMITOITOFILE,
; 3868 :                             LAD_Info.szAppName ) != 0 )
; 3869 :    {
; 3870 :       goto EndOfFunction;
; 3871 :    }
; 3872 : 
; 3873 :    if ( fnSendTraceSwitches( lpNetwork, &pvConn, lpTask) != 0)
; 3874 :       goto EndOfFunction;
; 3875 : 
; 3876 :    if ( fnSendDataPacket( lpNetwork, &pvConn, zPACKET_COMMITOITOFILE, 0 ) != 0 )
; 3877 :       goto EndOfFunction;
; 3878 : 
; 3879 :    // Set up the commit information.  We initialize the structure to 0's so
; 3880 :    // that the network stack can better compress the data.
; 3881 :    zmemset( &CommitPacket, 0, sizeof( zCommitPacket ) );
; 3882 :    zstrcpy( CommitPacket.szVersion, zCURRENT_PROTOCOL_VERSION );
; 3883 :    zstrcpy( CommitPacket.szObjectDef, lpViewOD->szName );
; 3884 :    zltox( lControl, CommitPacket.szControl );
; 3885 :    zltox( (zLONG) zstrlen( pchFileName ) + 1, CommitPacket.szFileNameLth );
; 3886 :    zstrcpy( CommitPacket.szAppName, LAD_Info.szAppName );
; 3887 :    SysGetUserID( lpView, CommitPacket.szUserName, CommitPacket.szPassword );
; 3888 : 
; 3889 :    if ( lpNetwork->nTraceLevel > 0 )
; 3890 :    {
; 3891 :       TraceLineS( "(kzoeneta) ** Appl Name: %s  Object Def: %s  "
; 3892 :                     "User Name: %s  File Name: %s",
; 3893 :                   CommitPacket.szAppName, CommitPacket.szObjectDef,
; 3894 :                   CommitPacket.szUserName, pchFileName );
; 3895 :    }
; 3896 : 
; 3897 :    // Send server commit info.
; 3898 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 3899 :                                 &CommitPacket, sizeof( zCommitPacket ),
; 3900 :                                 zTYPE_STRING ) != 0 )
; 3901 :    {
; 3902 :       goto EndOfFunction;
; 3903 :    }
; 3904 : 
; 3905 :    // Send server file name.
; 3906 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 3907 :                                 pchFileName, zstrlen( pchFileName ) + 1,
; 3908 :                                 zTYPE_STRING ) != 0 )
; 3909 :    {
; 3910 :       goto EndOfFunction;
; 3911 :    }
; 3912 : 
; 3913 :    if ( lpNetwork->nTraceLevel > 0 )
; 3914 :       TraceLineS( "(kzoeneta) ** Sending OI to commit file", "" );
; 3915 : 
; 3916 :    // Send the OI to the server to be committed.
; 3917 :    if ( fnSendOI( &pvConn, lpNetwork, lpView, zINCREMENTAL ) == zCALL_ERROR )
; 3918 :    {
; 3919 :       TraceLineS( "(kzoeneta) ** Error sending OI for Commit!", "" );
; 3920 :       goto EndOfFunction;
; 3921 :    }
; 3922 : 
; 3923 :    // Tell network handler to flush the send buffer.
; 3924 :    if ( fnFlushBuffer( lpNetwork, &pvConn ) != 0 )
; 3925 :       goto EndOfFunction;
; 3926 : 
; 3927 :    //=======================================================================
; 3928 :    // Receiving data.
; 3929 :    //
; 3930 :    // From here until we close the connection we will only RECEIVE data over
; 3931 :    // the network.
; 3932 :    //=======================================================================
; 3933 : 
; 3934 :    if ( lpNetwork->nTraceLevel > 0 )
; 3935 :       TraceLineS( "(kzoeneta) ** Waiting for ACK", "" );
; 3936 : 
; 3937 :    // Wait for return code.
; 3938 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lPacketData ) != 0 )
; 3939 :    {
; 3940 :       TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );
; 3941 :       goto EndOfFunction;
; 3942 :    }
; 3943 : 
; 3944 :    if ( cPacketType != zPACKET_RC )
; 3945 :    {
; 3946 :       TraceLineS( "(kzoeneta) ** No return code for CommitOI_ToFile!", "" );
; 3947 :       goto EndOfFunction;
; 3948 :    }
; 3949 : 
; 3950 :    nRC = (zSHORT) lPacketData;
; 3951 : 
; 3952 :    if ( lpNetwork->nTraceLevel > 0 )
; 3953 :       TraceLineI( "(kzoeneta) ** RC from commit OI to file = ", nRC );
; 3954 : 
; 3955 :    if ( fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, lpView ) < 0 )
; 3956 :    {
; 3957 :       nRC = zCALL_ERROR;
; 3958 :       goto EndOfFunction;
; 3959 :    }
; 3960 : 
; 3961 : EndOfFunction:
; 3962 :    if ( fnRemoveConnectionFromNetwork( lpNetwork, &pvConn,
; 3963 :                                        TRUE ) == zCALL_ERROR )
; 3964 :    {
; 3965 :       nRC = zCALL_ERROR;
; 3966 :    }
; 3967 : 
; 3968 :    fnOperationReturn( iNetCommitOI_ToFile, lpTask );
; 3969 :    return( nRC );
; 3970 : #endif
; 3971 : 
; 3972 : } // NetCommitOI_ToFile

	pop	ebp
	ret	20					; 00000014H
_NetCommitOI_ToFile@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_pchNetworkName$ = 8					; size = 4
_pchAddress$ = 12					; size = 4
_pvReturnView$ = 16					; size = 4
_pchViewOD_Name$ = 20					; size = 4
_vSubtask$ = 24						; size = 4
_pchFileName$ = 28					; size = 4
_lControl$ = 32						; size = 4
_NetActivateOI_FromFile@28 PROC

; 2516 : {

	push	ebp
	mov	ebp, esp

; 2517 :    return( 0 );

	xor	eax, eax

; 2518 : 
; 2519 : // 2001.06.28
; 2520 : // DGC Not supported at the moment (security risk).
; 2521 : #if 0
; 2522 :    LPTASK          lpTask;
; 2523 :    LAD_InfoRecord  LAD_Info;
; 2524 :    zCHAR           cPacketType;
; 2525 :    zLONG           lPacketData;
; 2526 :    LPNETWORK       lpNetwork;
; 2527 :    zPVOID          pvConn = 0;
; 2528 :    zActivatePacket ActPacket;
; 2529 :    zSHORT          nRC = zCALL_ERROR;
; 2530 : 
; 2531 :    zmemset( &LAD_Info, 0, sizeof( LAD_Info ) );
; 2532 : 
; 2533 :    // If task not active or disabled, return zCALL_ERROR.
; 2534 :    if ( (lpTask = fnOperationCall( iNetActivateOI_FromFile ... )) == 0 )
; 2535 :    {
; 2536 :       return( zCALL_ERROR );
; 2537 :    }
; 2538 : 
; 2539 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )
; 2540 :    {
; 2541 :       fnOperationReturn( iNetActivateOI_FromFile, lpTask );
; 2542 :       return( zCALL_ERROR );
; 2543 :    }
; 2544 : 
; 2545 :    if ( lpNetwork->nTraceLevel > 0 )
; 2546 :    {
; 2547 :       TraceLine( "(kzoeneta) ** Starting activate for network: %s  OD Name: %s",
; 2548 :                  lpNetwork->szNetworkName, pchViewOD_Name );
; 2549 :    }
; 2550 : 
; 2551 :    LAD_Info.lpTask     = lpTask;
; 2552 :    LAD_Info.lpNetwork  = lpNetwork;
; 2553 :    LAD_Info.vSubtask   = vSubtask;
; 2554 :    LAD_Info.nObjType   = zLADTYPE_LOD_ACTIVATE_FILE;
; 2555 :    LAD_Info.pchObjName = pchViewOD_Name;
; 2556 :    SysGetUserID( vSubtask, LAD_Info.szUserName, LAD_Info.szPassword );
; 2557 :    fnRetrieveAppName( vSubtask, LAD_Info.szAppName );
; 2558 : 
; 2559 :    if ( fnGetApplAddress( &LAD_Info, pchAddress ) == zCALL_ERROR )
; 2560 :    {
; 2561 :       fnOperationReturn( iNetActivateOI_FromFile, lpTask );
; 2562 :       return( zCALL_ERROR );
; 2563 :    }
; 2564 : 
; 2565 :    // Open connection.
; 2566 :    if ( fnAddConnectionToNetwork( &LAD_Info, &pvConn, TRUE, vSubtask ) < 0 )
; 2567 :    {
; 2568 :       fnOperationReturn( iNetActivateOI_FromFile, lpTask );
; 2569 :       return( zNETWORK_ERROR );
; 2570 :    }
; 2571 : 
; 2572 :    if ( lpNetwork->nTraceLevel > 1 )
; 2573 :       TraceLineS( "(kzoeneta) ** Sending RequestOI packet", "" );
; 2574 : 
; 2575 :    //=======================================================================
; 2576 :    // Transmitting data.
; 2577 :    //
; 2578 :    // Until further notice, the following code only SENDS data over the
; 2579 :    // network.
; 2580 :    //=======================================================================
; 2581 : 
; 2582 :    // First send the header for the server driver and then the regular
; 2583 :    // packet for the function structure.
; 2584 :    if ( fnSendHeaderPacket( lpNetwork, &pvConn, zPACKET_REQUESTOIFROMFILE,
; 2585 :                             LAD_Info.szAppName ) != 0 )
; 2586 :       goto EndOfFunction;
; 2587 : 
; 2588 :    if ( fnSendTraceSwitches( lpNetwork, &pvConn, lpTask) != 0)
; 2589 :       goto EndOfFunction;
; 2590 : 
; 2591 :    if ( fnSendDataPacket( lpNetwork, &pvConn,
; 2592 :                           zPACKET_REQUESTOIFROMFILE, 0 ) != 0 )
; 2593 :       goto EndOfFunction;
; 2594 : 
; 2595 :    // Set up the activate information.  We initialize the structure to 0's so
; 2596 :    // that the network stack can better compress the data.
; 2597 :    zmemset( &ActPacket, 0, sizeof( zActivatePacket ) );
; 2598 :    zstrcpy( ActPacket.szVersion, zCURRENT_PROTOCOL_VERSION );
; 2599 :    zltox( lControl, ActPacket.szControl );
; 2600 :    zstrcpy( ActPacket.szObjectDef, pchViewOD_Name );
; 2601 :    ActPacket.cUseQualification = 'N';
; 2602 :    zltox( (zLONG) zstrlen( pchFileName ) + 1, ActPacket.szFileNameLth );
; 2603 : 
; 2604 :    zstrcpy( ActPacket.szAppName, LAD_Info.szAppName );
; 2605 :    SysGetUserID( vSubtask, ActPacket.szUserName, ActPacket.szPassword );
; 2606 : 
; 2607 :    if ( lpNetwork->nTraceLevel > 1 )
; 2608 :    {
; 2609 :       TraceLine( "(kzoeneta) ** Sending Activate File Packet Appl Name: %s  ",
; 2610 :                    "Object Def: %s  User Name: %s  FileName: %s",
; 2611 :                  ActPacket.szAppName, ActPacket.szObjectDef,
; 2612 :                  ActPacket.szUserName, pchFileName );
; 2613 :    }
; 2614 : 
; 2615 :    // Send server activate info.
; 2616 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle,
; 2617 :                                 &pvConn, &ActPacket, sizeof( zActivatePacket ),
; 2618 :                                 zTYPE_STRING ) != 0 )
; 2619 :       goto EndOfFunction;
; 2620 : 
; 2621 :    // Send file name.
; 2622 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 2623 :                                 pchFileName,
; 2624 :                                 zstrlen( pchFileName ) + 1,
; 2625 :                                 zTYPE_STRING ) != 0 )
; 2626 :    {
; 2627 :       goto EndOfFunction;
; 2628 :    }
; 2629 : 
; 2630 :    // Tell network handler to flush the send buffer.
; 2631 :    if ( fnFlushBuffer( lpNetwork, &pvConn ) != 0 )
; 2632 :       goto EndOfFunction;
; 2633 : 
; 2634 :    //=======================================================================
; 2635 :    // Receiving data.
; 2636 :    //
; 2637 :    // From here until we close the connection we will only RECEIVE data over
; 2638 :    // the network.
; 2639 :    //=======================================================================
; 2640 : 
; 2641 :    // Wait for Ack.
; 2642 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lPacketData ) != 0 )
; 2643 :    {
; 2644 :       TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );
; 2645 :       goto EndOfFunction;
; 2646 :    }
; 2647 : 
; 2648 :    if ( cPacketType == zPACKET_ERROR )
; 2649 :    {
; 2650 : 
; 2651 :       TraceLineI( "(kzoeneta) ** Network error #", lPacketData );
; 2652 :       if ( lPacketData == zNETERR_OUTOFMEMORY )
; 2653 :       {
; 2654 :          SysMessageBox( "Server Transaction Crash ",
; 2655 :                         "*Out Of Memory*", 1 );
; 2656 :       }
; 2657 :       goto EndOfFunction;
; 2658 :    }
; 2659 :    else
; 2660 :    if ( cPacketType == zPACKET_RC )
; 2661 :    {
; 2662 :       // If we received the RC packet, then there was an error activating
; 2663 :       // the OI on the server.  Get the return code and go to the end of the
; 2664 :       // function.
; 2665 :       if ( lpNetwork->nTraceLevel > 0 )
; 2666 :          TraceLineS( "(kzoeneta) ** Received RC - error in Commit", "" );
; 2667 : 
; 2668 :       nRC = (zSHORT) lPacketData;
; 2669 :       goto EndOfFunction;
; 2670 :    }
; 2671 :    else
; 2672 :    if ( cPacketType != zPACKET_ACK )
; 2673 :    {
; 2674 :       TraceLineS( "(kzoeneta) ** Received bytes but no ACK!", "" );
; 2675 :       goto EndOfFunction;
; 2676 :    }
; 2677 : 
; 2678 :    if ( lpNetwork->nTraceLevel > 0 )
; 2679 :    {
; 2680 :       TraceLineS( "(kzoeneta) ** Received Act ACK - proceeding with Act ... "
; 2681 :                   "Receiving activated OI." );
; 2682 :    }
; 2683 : 
; 2684 :    fnReceiveOI( &pvConn, lpNetwork, pvReturnView, vSubtask,
; 2685 :                 pchViewOD_Name, zMULTIPLE );
; 2686 : 
; 2687 :    // Get return code.
; 2688 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lPacketData ) != 0 )
; 2689 :    {
; 2690 :       TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );
; 2691 :       goto EndOfFunction;
; 2692 :    }
; 2693 : 
; 2694 :    if ( cPacketType != zPACKET_RC )
; 2695 :    {
; 2696 :       TraceLineS( "(kzoeneta) ** No return code for Commit!", "" );
; 2697 :       goto EndOfFunction;
; 2698 :    }
; 2699 : 
; 2700 :    nRC = (zSHORT) lPacketData;
; 2701 : 
; 2702 :    if ( lpNetwork->nTraceLevel > 0 )
; 2703 :       TraceLineI( "(kzoeneta) ** RC from activate = ", nRC );
; 2704 : 
; 2705 :    if ( fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, vSubtask ) < 0 )
; 2706 :    {
; 2707 :       nRC = zCALL_ERROR;
; 2708 :       goto EndOfFunction;
; 2709 :    }
; 2710 : 
; 2711 : EndOfFunction:
; 2712 : 
; 2713 :    if ( fnRemoveConnectionFromNetwork( lpNetwork, &pvConn,
; 2714 :                                        TRUE ) == zCALL_ERROR )
; 2715 :    {
; 2716 :       nRC = zCALL_ERROR;
; 2717 :    }
; 2718 : 
; 2719 :    fnOperationReturn( iNetActivateOI_FromFile, lpTask );
; 2720 :    return( nRC );
; 2721 : #endif
; 2722 : 
; 2723 : } // NetActivateOI_FromFile

	pop	ebp
	ret	28					; 0000001cH
_NetActivateOI_FromFile@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpReferenceViewOD$ = -608				; size = 4
_CommitInfo$ = -604					; size = 16
_lpNewViewOI$1 = -588					; size = 4
_lpViewOI$2 = -584					; size = 4
_lpDropSubtask$3 = -580					; size = 4
_lLth$4 = -576						; size = 4
_lpViewCsr$ = -572					; size = 4
_lpViewCsr$5 = -568					; size = 4
_lLinkBufferLth$ = -564					; size = 4
_pchLinkBuffer$ = -560					; size = 4
_vSubtask$ = -556					; size = 4
_lpViewOD$ = -552					; size = 4
_lPacketData$ = -548					; size = 4
_lpTaskView$ = -544					; size = 4
_lpViewOI$6 = -540					; size = 4
_vReferenceView$ = -536					; size = 4
_lpTask$ = -532						; size = 4
_pchObjectNameBuffer$ = -528				; size = 4
_lpViewOI$7 = -524					; size = 4
_nObjectNameLth$ = -520					; size = 2
_bChanged$8 = -513					; size = 1
_lpNewViewArray$ = -512					; size = 4
_pch$ = -508						; size = 4
_lpEntityInstance$9 = -504				; size = 4
_bConnectionMade$ = -497				; size = 1
_pvConn$ = -496						; size = 4
_nRC$ = -492						; size = 2
_cPacketType$ = -485					; size = 1
_lpNetwork$ = -484					; size = 4
_k$ = -480						; size = 2
_CommitPacket$ = -476					; size = 158
_szServer$ = -316					; size = 256
_szAppName$ = -60					; size = 33
_szLth$10 = -24						; size = 5
_szControl$11 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_pchNetworkName$ = 8					; size = 4
_pchAddress$ = 12					; size = 4
_lpViewCluster$ = 16					; size = 4
_lpViewArray$ = 20					; size = 4
_nViewCount$ = 24					; size = 2
_pnViewErrorIdx$ = 28					; size = 4
_lControl$ = 32						; size = 4
_NetCommitOI@28 PROC

; 3248 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 608				; 00000260H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 3249 :    zSHORT        nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 3250 :    zSHORT        k;
; 3251 :    zVIEW         vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 3252 :    zCHAR         cPacketType;
; 3253 :    zLONG         lPacketData;
; 3254 :    LPNETWORK     lpNetwork;
; 3255 :    zPVOID        pvConn = 0;

	mov	DWORD PTR _pvConn$[ebp], 0

; 3256 :    LPVIEWOD      lpReferenceViewOD;
; 3257 :    LPVIEWOD      lpViewOD;
; 3258 :    LPVIEWCSR     lpViewCsr;
; 3259 :    zCommitPacket CommitPacket;
; 3260 :    LPTASK        lpTask;
; 3261 :    zVIEW         vReferenceView = 0;

	mov	DWORD PTR _vReferenceView$[ebp], 0

; 3262 :    zVIEW         lpTaskView = 0;

	mov	DWORD PTR _lpTaskView$[ebp], 0

; 3263 :    zPCHAR        pchObjectNameBuffer = 0;

	mov	DWORD PTR _pchObjectNameBuffer$[ebp], 0

; 3264 :    zPCHAR        pch;
; 3265 :    zSHORT        nObjectNameLth;
; 3266 :    zBOOL         bConnectionMade = FALSE;

	mov	BYTE PTR _bConnectionMade$[ebp], 0

; 3267 :    zPVIEW        lpNewViewArray = 0;

	mov	DWORD PTR _lpNewViewArray$[ebp], 0

; 3268 :    zPCHAR        pchLinkBuffer = 0;

	mov	DWORD PTR _pchLinkBuffer$[ebp], 0

; 3269 :    zLONG         lLinkBufferLth;
; 3270 :    zCHAR         szServer[ 256 ] = "";

	mov	cl, BYTE PTR $SG14783
	mov	BYTE PTR _szServer$[ebp], cl
	push	255					; 000000ffH
	push	0
	lea	edx, DWORD PTR _szServer$[ebp+1]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 3271 :    zCHAR         szAppName[ zZEIDON_NAME_LTH + 1 ];
; 3272 :    ServDirCommitRecord CommitInfo;
; 3273 : 
; 3274 :    // Find a view that can be used as the task view.
; 3275 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@NetCommitO
$LN2@NetCommitO:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@NetCommitO:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN3@NetCommitO

; 3276 :    {
; 3277 :       if ( lpViewArray[ k ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN23@NetCommitO

; 3278 :       {
; 3279 :          lpTaskView = lpViewArray[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _lpTaskView$[ebp], edx

; 3280 :          break;

	jmp	SHORT $LN3@NetCommitO
$LN23@NetCommitO:

; 3281 :       }
; 3282 :    }

	jmp	SHORT $LN2@NetCommitO
$LN3@NetCommitO:

; 3283 : 
; 3284 :    // No views to commit? Just return.
; 3285 :    if ( lpTaskView == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	jne	SHORT $LN24@NetCommitO

; 3286 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@NetCommitO
$LN24@NetCommitO:

; 3287 : 
; 3288 :    // If task not active or disabled, return zCALL_ERROR.
; 3289 :    if ( (lpTask = fnOperationCall( iNetCommitOI, lpTaskView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	501					; 000001f5H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN25@NetCommitO

; 3290 :    {
; 3291 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetCommitO
$LN25@NetCommitO:

; 3292 :    }
; 3293 : 
; 3294 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN26@NetCommitO

; 3295 :    {
; 3296 :       fnOperationReturn( iNetCommitOI, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	501					; 000001f5H
	call	_fnOperationReturn
	add	esp, 8

; 3297 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetCommitO
$LN26@NetCommitO:

; 3298 :    }
; 3299 : 
; 3300 :    // Create a buffer to store object names.  We'll arbitrarily allocate
; 3301 :    // 32000 bytes.
; 3302 :    pchObjectNameBuffer = (zPCHAR) fnAllocDataspace( lpTask->hFirstDataHeader,

	push	0
	push	0
	push	1
	push	32000					; 00007d00H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchObjectNameBuffer$[ebp], eax

; 3303 :                                                     32000, TRUE, 0, 0 );
; 3304 :    pchObjectNameBuffer = zGETPTR( pchObjectNameBuffer );

	mov	eax, DWORD PTR _pchObjectNameBuffer$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchObjectNameBuffer$[ebp], eax

; 3305 :    pch = pchObjectNameBuffer;

	mov	ecx, DWORD PTR _pchObjectNameBuffer$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx

; 3306 : 
; 3307 :    // The reference view is just the last valid view in the array.
; 3308 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN7@NetCommitO
$LN5@NetCommitO:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN7@NetCommitO:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN6@NetCommitO

; 3309 :    {
; 3310 :       LPENTITYINSTANCE lpEntityInstance;
; 3311 :       LPVIEWOI         lpViewOI;
; 3312 :       zBOOL            bChanged;
; 3313 : 
; 3314 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN27@NetCommitO

; 3315 :       {
; 3316 :          // Store a 0 for the object name.
; 3317 :          if ( nViewCount > 1 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	edx, 1
	jle	SHORT $LN28@NetCommitO

; 3318 :             *pch++ = 0;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN28@NetCommitO:

; 3319 : 
; 3320 :          continue;

	jmp	SHORT $LN5@NetCommitO
$LN27@NetCommitO:

; 3321 :       }
; 3322 : 
; 3323 :       lpViewOD  = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3324 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3325 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$7[ebp], eax

; 3326 : 
; 3327 :       // If OI hasn't been updated then forget about it UNLESS...
; 3328 :       // there is pessimistic locking.  Then we need to continue so that any
; 3329 :       // pessimistic locks are dropped.
; 3330 :       if ( (lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING) == 0 )

	mov	eax, DWORD PTR _lpViewOI$7[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 67108864				; 04000000H
	jne	$LN29@NetCommitO

; 3331 :       {
; 3332 :          bChanged  = FALSE;

	mov	BYTE PTR _bChanged$8[ebp], 0

; 3333 :          if ( lpViewOI->bUpdated )

	mov	edx, DWORD PTR _lpViewOI$7[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 4
	and	eax, 1
	je	$LN30@NetCommitO

; 3334 :          {
; 3335 :             // Make sure that the OI really is changed.
; 3336 :             for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$7[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$9[ebp], eax
	jmp	SHORT $LN10@NetCommitO
$LN8@NetCommitO:

; 3338 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$9[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$9[ebp], eax
$LN10@NetCommitO:

; 3337 :                   lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$9[ebp], 0
	je	$LN30@NetCommitO

; 3339 :             {
; 3340 :                // If the entity is created AND deleted then the OI really
; 3341 :                // hasn't changed.
; 3342 :                if ( lpEntityInstance->u.nInd.bCreated  &&

	mov	edx, DWORD PTR _lpEntityInstance$9[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN31@NetCommitO
	mov	ecx, DWORD PTR _lpEntityInstance$9[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	je	SHORT $LN31@NetCommitO

; 3343 :                     lpEntityInstance->u.nInd.bDeleted )
; 3344 :                {
; 3345 :                   continue;

	jmp	SHORT $LN8@NetCommitO
$LN31@NetCommitO:

; 3346 :                }
; 3347 : 
; 3348 :                // If the entity is included AND excluded then the OI really
; 3349 :                // hasn't changed.
; 3350 :                if ( lpEntityInstance->u.nInd.bIncluded &&

	mov	eax, DWORD PTR _lpEntityInstance$9[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN32@NetCommitO
	mov	edx, DWORD PTR _lpEntityInstance$9[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN32@NetCommitO

; 3351 :                     lpEntityInstance->u.nInd.bExcluded )
; 3352 :                {
; 3353 :                   continue;

	jmp	SHORT $LN8@NetCommitO
$LN32@NetCommitO:

; 3354 :                }
; 3355 : 
; 3356 :                if ( lpEntityInstance->u.nInd.bUpdated  ||
; 3357 :                     lpEntityInstance->u.nInd.bCreated  ||
; 3358 :                     lpEntityInstance->u.nInd.bDeleted  ||
; 3359 :                     lpEntityInstance->u.nInd.bIncluded ||

	mov	ecx, DWORD PTR _lpEntityInstance$9[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	jne	SHORT $LN34@NetCommitO
	mov	eax, DWORD PTR _lpEntityInstance$9[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN34@NetCommitO
	mov	edx, DWORD PTR _lpEntityInstance$9[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN34@NetCommitO
	mov	ecx, DWORD PTR _lpEntityInstance$9[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN34@NetCommitO
	mov	eax, DWORD PTR _lpEntityInstance$9[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	je	SHORT $LN33@NetCommitO
$LN34@NetCommitO:

; 3360 :                     lpEntityInstance->u.nInd.bExcluded )
; 3361 :                {
; 3362 :                   bChanged = TRUE;

	mov	BYTE PTR _bChanged$8[ebp], 1

; 3363 :                   break;

	jmp	SHORT $LN30@NetCommitO
$LN33@NetCommitO:

; 3364 :                }
; 3365 :             } // for...

	jmp	$LN8@NetCommitO
$LN30@NetCommitO:

; 3366 :          } // if ( lpViewOI->bUpdated )...
; 3367 : 
; 3368 :          if ( bChanged == FALSE )

	movzx	edx, BYTE PTR _bChanged$8[ebp]
	test	edx, edx
	jne	SHORT $LN29@NetCommitO

; 3369 :          {
; 3370 :             // View isn't really changed so forget it.
; 3371 :             lpViewArray[ k ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [ecx+eax*4], 0

; 3372 : 
; 3373 :             // Store a 0 for the object name.
; 3374 :             if ( nViewCount > 1 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	edx, 1
	jle	SHORT $LN36@NetCommitO

; 3375 :                *pch++ = 0;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN36@NetCommitO:

; 3376 : 
; 3377 :             // Get rid of entity instances that are dead--instances that
; 3378 :             // have been created AND deleted, etc.
; 3379 :             fnReclaimHiddenInstances( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$7[ebp]
	push	edx
	call	_fnReclaimHiddenInstances@4

; 3380 : 
; 3381 :             lpViewOI->bUpdated = lpViewOI->bUpdatedFile = FALSE;

	mov	eax, DWORD PTR _lpViewOI$7[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpViewOI$7[ebp]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _lpViewOI$7[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpViewOI$7[ebp]
	mov	DWORD PTR [edx+36], ecx

; 3382 : 
; 3383 :             continue;

	jmp	$LN5@NetCommitO
$LN29@NetCommitO:

; 3384 :          }
; 3385 :       }
; 3386 : 
; 3387 :       if ( vReferenceView == 0 )

	cmp	DWORD PTR _vReferenceView$[ebp], 0
	jne	SHORT $LN37@NetCommitO

; 3388 :       {
; 3389 :          vReferenceView    = lpViewArray[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _vReferenceView$[ebp], edx

; 3390 :          lpReferenceViewOD = lpViewOD;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR _lpReferenceViewOD$[ebp], eax
$LN37@NetCommitO:

; 3391 :       }
; 3392 : 
; 3393 :       // Store the object name.
; 3394 :       pch = zstrcpyp( pch, lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	mov	esi, eax
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	esi, eax
	mov	DWORD PTR _pch$[ebp], esi

; 3395 :       pch++;  // Skip past null terminator.

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx

; 3396 : 
; 3397 :       // Get rid of entity instances that are dead--instances that
; 3398 :       // have been created AND deleted, etc.
; 3399 :       fnReclaimHiddenInstances( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$7[ebp]
	push	edx
	call	_fnReclaimHiddenInstances@4

; 3400 :    }

	jmp	$LN5@NetCommitO
$LN6@NetCommitO:

; 3401 : 
; 3402 :    // If vReferenceView is 0 then we didn't find any OIs that have changes so
; 3403 :    // we can forget about committing anything.
; 3404 :    if ( vReferenceView == 0 )

	cmp	DWORD PTR _vReferenceView$[ebp], 0
	jne	SHORT $LN38@NetCommitO

; 3405 :    {
; 3406 :       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 3407 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN38@NetCommitO:

; 3408 :    }
; 3409 : 
; 3410 :    fnRetrieveAppName( vReferenceView, szAppName );

	lea	ecx, DWORD PTR _szAppName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vReferenceView$[ebp]
	push	edx
	call	_fnRetrieveAppName@8

; 3411 :    SfCreateSubtask( &vSubtask, vReferenceView, szAppName );

	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vReferenceView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SfCreateSubtask@12

; 3412 : 
; 3413 :    // Set up info for commit request.
; 3414 :    CommitInfo.pszNetworkName         = lpNetwork->szNetworkName;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR _CommitInfo$[ebp], eax

; 3415 :    CommitInfo.vOI                    = vReferenceView;

	mov	ecx, DWORD PTR _vReferenceView$[ebp]
	mov	DWORD PTR _CommitInfo$[ebp+12], ecx

; 3416 :    CommitInfo.lControl               = lControl;

	mov	edx, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR _CommitInfo$[ebp+8], edx

; 3417 :    CommitInfo.pszUserSuppliedAddress = pchAddress;

	mov	eax, DWORD PTR _pchAddress$[ebp]
	mov	DWORD PTR _CommitInfo$[ebp+4], eax

; 3418 : 
; 3419 :    // Open connection.
; 3420 :    if ( fnAddConnectionToNetwork( lpTask, lpNetwork, szServer,
; 3421 :                                   &pvConn, TRUE, zAPPLREQ_COMMIT,
; 3422 :                                   &CommitInfo, lpTaskView ) < 0 )

	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _CommitInfo$[ebp]
	push	edx
	push	2
	push	1
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szServer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnAddConnectionToNetwork@32
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN39@NetCommitO

; 3423 :    {
; 3424 :       nRC = zNETWORK_ERROR;

	mov	edx, -6					; fffffffaH
	mov	WORD PTR _nRC$[ebp], dx

; 3425 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN39@NetCommitO:

; 3426 :    }
; 3427 : 
; 3428 :    bConnectionMade = TRUE;

	mov	BYTE PTR _bConnectionMade$[ebp], 1

; 3429 : 
; 3430 :    if ( lpNetwork->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	cmp	ecx, 1
	jle	SHORT $LN40@NetCommitO

; 3431 :       TraceLineS( "(kzoeneta) ** Sending Commit OI packet", "" );

	push	OFFSET $SG14802
	push	OFFSET $SG14803
	call	_TraceLineS@8
$LN40@NetCommitO:

; 3432 : 
; 3433 :    //=======================================================================
; 3434 :    // Transmitting data.
; 3435 :    //
; 3436 :    // Until further notice, the following code only SENDS data over the
; 3437 :    // network.
; 3438 :    //=======================================================================
; 3439 : 
; 3440 :    // First send the header for the server driver and then the regular
; 3441 :    // packet for the function structure.
; 3442 :    if ( fnSendHeaderPacket( lpNetwork, &pvConn, zPACKET_COMMITOI,
; 3443 :                             szAppName ) != 0 )

	lea	edx, DWORD PTR _szAppName$[ebp]
	push	edx
	push	67					; 00000043H
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnSendHeaderPacket@16
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN41@NetCommitO

; 3444 :    {
; 3445 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN41@NetCommitO:

; 3446 :    }
; 3447 : 
; 3448 :    if ( fnSendTraceSwitches( lpNetwork, &pvConn, lpTask ) != 0 )

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendTraceSwitches@12
	cwde
	test	eax, eax
	je	SHORT $LN42@NetCommitO

; 3449 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN42@NetCommitO:

; 3450 : 
; 3451 :    if ( fnSendDataPacket( lpNetwork, &pvConn, zPACKET_COMMITOI, 0 ) != 0 )

	push	0
	push	67					; 00000043H
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnSendDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN43@NetCommitO

; 3452 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN43@NetCommitO:

; 3453 : 
; 3454 :    // Set up the commit information.  We initialize the structure to 0's so
; 3455 :    // that the network stack can better compress the data.
; 3456 :    zmemset( &CommitPacket, 0, sizeof( zCommitPacket ) );

	push	158					; 0000009eH
	push	0
	lea	ecx, DWORD PTR _CommitPacket$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3457 :    zstrcpy( CommitPacket.szVersion, zCURRENT_PROTOCOL_VERSION );

	push	OFFSET $SG14807
	lea	edx, DWORD PTR _CommitPacket$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3458 :    zstrcpy( CommitPacket.szAppName, szAppName );

	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _CommitPacket$[ebp+35]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3459 :    SysGetUserID( lpTaskView, CommitPacket.szUserName, CommitPacket.szPassword );

	lea	edx, DWORD PTR _CommitPacket$[ebp+110]
	push	edx
	lea	eax, DWORD PTR _CommitPacket$[ebp+77]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysGetUserID@12

; 3460 :    zltox( nViewCount, CommitPacket.szViewCount );

	push	16					; 00000010H
	lea	edx, DWORD PTR _CommitPacket$[ebp+143]
	push	edx
	movsx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3461 :    zltox( lControl, CommitPacket.szControl );

	push	16					; 00000010H
	lea	ecx, DWORD PTR _CommitPacket$[ebp+68]
	push	ecx
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3462 : 
; 3463 :    nObjectNameLth = (zSHORT) (pch - pchObjectNameBuffer);

	mov	eax, DWORD PTR _pch$[ebp]
	sub	eax, DWORD PTR _pchObjectNameBuffer$[ebp]
	mov	WORD PTR _nObjectNameLth$[ebp], ax

; 3464 :    zltox( (zLONG) nObjectNameLth, CommitPacket.szObjectNameLth );

	push	16					; 00000010H
	lea	ecx, DWORD PTR _CommitPacket$[ebp+146]
	push	ecx
	movsx	edx, WORD PTR _nObjectNameLth$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3465 : 
; 3466 :    // Set up the link buffer.  This buffer contains a list of all entity
; 3467 :    // instances that are linked with each other in lpViewArray.
; 3468 :    fnSetLinkBuffer( lpTask, lpViewArray, nViewCount,

	lea	eax, DWORD PTR _lLinkBufferLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLinkBuffer$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nViewCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSetLinkBuffer@20

; 3469 :                     &pchLinkBuffer, &lLinkBufferLth );
; 3470 : 
; 3471 :    zltox( lLinkBufferLth, CommitPacket.szLinkBufferLth );

	push	16					; 00000010H
	lea	edx, DWORD PTR _CommitPacket$[ebp+154]
	push	edx
	mov	eax, DWORD PTR _lLinkBufferLth$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3472 : 
; 3473 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN44@NetCommitO

; 3474 :    {
; 3475 :       TraceLine( "(kzoeneta) ** Appl Name: %s  User Name: %s ",

	lea	eax, DWORD PTR _CommitPacket$[ebp+77]
	push	eax
	lea	ecx, DWORD PTR _CommitPacket$[ebp+35]
	push	ecx
	push	OFFSET $SG14809
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 3476 :                  CommitPacket.szAppName, CommitPacket.szUserName );
; 3477 :       if ( nViewCount > 1 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	edx, 1
	jle	SHORT $LN45@NetCommitO

; 3478 :       {
; 3479 :          TraceLine( "(kzoeneta) ** View Count: %s  OD Name Lth: %d",

	movsx	eax, WORD PTR _nObjectNameLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _CommitPacket$[ebp+143]
	push	ecx
	push	OFFSET $SG14811
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 3480 :                     CommitPacket.szViewCount, nObjectNameLth );
; 3481 :          TraceBuffer( "(kzoeneta) ** OD Names: ",

	movsx	edx, WORD PTR _nObjectNameLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchObjectNameBuffer$[ebp]
	push	eax
	push	OFFSET $SG14812
	call	_TraceBuffer@12
$LN45@NetCommitO:

; 3482 :                       pchObjectNameBuffer, nObjectNameLth );
; 3483 :       }
; 3484 : 
; 3485 :       TraceLineS( "(kzoeneta) ** LB Lth: ", CommitPacket.szLinkBufferLth );

	lea	ecx, DWORD PTR _CommitPacket$[ebp+154]
	push	ecx
	push	OFFSET $SG14813
	call	_TraceLineS@8
$LN44@NetCommitO:

; 3486 :    }
; 3487 : 
; 3488 :    // Send server commit info.
; 3489 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 3490 :                                 &CommitPacket, sizeof( zCommitPacket ),
; 3491 :                                 zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	158					; 0000009eH
	lea	edx, DWORD PTR _CommitPacket$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+170]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN46@NetCommitO

; 3492 :    {
; 3493 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN46@NetCommitO:

; 3494 :    }
; 3495 : 
; 3496 :    // Send the object names.
; 3497 :    if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 3498 :                                 pchObjectNameBuffer, nObjectNameLth,
; 3499 :                                 zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	movsx	edx, WORD PTR _nObjectNameLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchObjectNameBuffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+170]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN47@NetCommitO

; 3500 :    {
; 3501 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN47@NetCommitO:

; 3502 :    }
; 3503 : 
; 3504 :    // Send the link buffer info if we have any.
; 3505 :    if ( lLinkBufferLth > 0 )

	cmp	DWORD PTR _lLinkBufferLth$[ebp], 0
	jle	SHORT $LN48@NetCommitO

; 3506 :    {
; 3507 :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 3508 :                                    pchLinkBuffer, lLinkBufferLth,
; 3509 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	mov	eax, DWORD PTR _lLinkBufferLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchLinkBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+170]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN48@NetCommitO

; 3510 :       {
; 3511 :          goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN48@NetCommitO:

; 3512 :       }
; 3513 :    }
; 3514 : 
; 3515 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN50@NetCommitO

; 3516 :       TraceLineS( "(kzoeneta) ** Sending OIs to commit", "" );

	push	OFFSET $SG14819
	push	OFFSET $SG14820
	call	_TraceLineS@8
$LN50@NetCommitO:

; 3517 : 
; 3518 :    // Send the OIs to the server to be committed.  Send entity tags so we can
; 3519 :    // compare/merge later.
; 3520 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN13@NetCommitO
$LN11@NetCommitO:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN13@NetCommitO:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$LN12@NetCommitO

; 3521 :    {
; 3522 :       zCHAR szControl[ 10 ];
; 3523 :       zCHAR szLth[ 5 ];
; 3524 :       zLONG lLth;
; 3525 : 
; 3526 :       if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN51@NetCommitO

; 3527 :          continue;

	jmp	SHORT $LN11@NetCommitO
$LN51@NetCommitO:

; 3528 : 
; 3529 :       if ( fnSendOI( &pvConn, lpNetwork, lpViewArray[ k ],
; 3530 :                      zINCREMENTAL | zENTITY_TAGS ) == zCALL_ERROR )

	push	589824					; 00090000H
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	call	_fnSendOI@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN52@NetCommitO

; 3531 :       {
; 3532 :          TraceLineS( "(kzoeneta) ** Error sending OI for Commit!", "" );

	push	OFFSET $SG14823
	push	OFFSET $SG14824
	call	_TraceLineS@8

; 3533 :          goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN52@NetCommitO:

; 3534 :       }
; 3535 : 
; 3536 :       // Send the control value for the view.  We'll store the length of the
; 3537 :       // string containing the control value in the first 2 bytes.  We'll assume
; 3538 :       // that the length can be sent as a 2-digit hex value.
; 3539 :       zltox( lpViewCluster[ k ].lControl, &szControl[ 2 ] );

	push	16					; 00000010H
	mov	eax, 1
	shl	eax, 1
	lea	ecx, DWORD PTR _szControl$11[ebp+eax]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3540 :       lLth = zstrlen( &szControl[ 2 ] ) + 1;

	mov	edx, 1
	shl	edx, 1
	lea	eax, DWORD PTR _szControl$11[ebp+edx]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _lLth$4[ebp], eax

; 3541 :       zltox( lLth, szLth );

	push	16					; 00000010H
	lea	ecx, DWORD PTR _szLth$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _lLth$4[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3542 :       szControl[ 0 ] = szLth[ 0 ];  // Copy lth to first two bytes.

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szLth$10[ebp+ecx]
	mov	BYTE PTR _szControl$11[ebp+eax], cl

; 3543 :       szControl[ 1 ] = szLth[ 1 ];

	mov	edx, 1
	shl	edx, 0
	mov	eax, 1
	shl	eax, 0
	mov	cl, BYTE PTR _szLth$10[ebp+edx]
	mov	BYTE PTR _szControl$11[ebp+eax], cl

; 3544 :       // First, send the length, then the data.
; 3545 :       //  The strings must be written and read synchronously.
; 3546 :       //  According to network handler interface, you cannot write
; 3547 :       //  length + data information in one message and retrieve it
; 3548 :       //  in two messages.
; 3549 :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 3550 :                                    szControl, 2,
; 3551 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	push	2
	lea	edx, DWORD PTR _szControl$11[ebp]
	push	edx
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+170]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN53@NetCommitO

; 3552 :       {
; 3553 :          goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN53@NetCommitO:

; 3554 :       }
; 3555 : 
; 3556 :       if ( (*lpNetwork->lpfnSend)( &lpNetwork->pNetworkHandle, &pvConn,
; 3557 :                                    szControl + 2, lLth,
; 3558 :                                    zTYPE_STRING ) != 0 )

	push	83					; 00000053H
	mov	edx, DWORD PTR _lLth$4[ebp]
	push	edx
	lea	eax, DWORD PTR _szControl$11[ebp+2]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+170]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN54@NetCommitO

; 3559 :       {
; 3560 :          goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN54@NetCommitO:

; 3561 :       }
; 3562 :    }

	jmp	$LN11@NetCommitO
$LN12@NetCommitO:

; 3563 : 
; 3564 :    // Tell network handler to flush the send buffer.
; 3565 :    if ( fnFlushBuffer( lpNetwork, &pvConn ) != 0 )

	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnFlushBuffer@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN55@NetCommitO

; 3566 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN55@NetCommitO:

; 3567 : 
; 3568 :    //=======================================================================
; 3569 :    // Receiving data.
; 3570 :    //
; 3571 :    // From here until we close the connection we will only RECEIVE data over
; 3572 :    // the network.
; 3573 :    //=======================================================================
; 3574 : 
; 3575 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN56@NetCommitO

; 3576 :       TraceLineS( "(kzoeneta) ** Waiting for returned OI", "" );

	push	OFFSET $SG14829
	push	OFFSET $SG14830
	call	_TraceLineS@8
$LN56@NetCommitO:

; 3577 : 
; 3578 :    // Wait for Ack.
; 3579 :    if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lPacketData ) != 0 )

	lea	edx, DWORD PTR _lPacketData$[ebp]
	push	edx
	lea	eax, DWORD PTR _cPacketType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnReceiveDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN57@NetCommitO

; 3580 :    {
; 3581 :       TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );

	push	OFFSET $SG14832
	push	OFFSET $SG14833
	call	_TraceLineS@8

; 3582 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN57@NetCommitO:

; 3583 :    }
; 3584 : 
; 3585 :    if ( cPacketType == zPACKET_RC )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	cmp	ecx, 35					; 00000023H
	jne	$LN58@NetCommitO

; 3586 :    {
; 3587 :       // If we received the RC packet, then there was an error committing
; 3588 :       // the OIs on the server.  Get the return code and go to the end of the
; 3589 :       // function.
; 3590 :       if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN59@NetCommitO

; 3591 :          TraceLineS( "(kzoeneta) ** Received RC - error in Commit", "" );

	push	OFFSET $SG14836
	push	OFFSET $SG14837
	call	_TraceLineS@8
$LN59@NetCommitO:

; 3592 : 
; 3593 :       nRC = (zSHORT) lPacketData;

	mov	cx, WORD PTR _lPacketData$[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 3594 : 
; 3595 :       // Get the index that indicates what view wasn't committed.
; 3596 :       if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType, &lPacketData ) != 0 )

	lea	edx, DWORD PTR _lPacketData$[ebp]
	push	edx
	lea	eax, DWORD PTR _cPacketType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnReceiveDataPacket@16
	cwde
	test	eax, eax
	je	SHORT $LN60@NetCommitO

; 3597 :       {
; 3598 :          TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );

	push	OFFSET $SG14839
	push	OFFSET $SG14840
	call	_TraceLineS@8

; 3599 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 3600 :          goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN60@NetCommitO:

; 3601 :       }
; 3602 : 
; 3603 :       if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN61@NetCommitO

; 3604 :          *pnViewErrorIdx = (zSHORT) lPacketData;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _lPacketData$[ebp]
	mov	WORD PTR [edx], ax
$LN61@NetCommitO:

; 3605 : 
; 3606 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN58@NetCommitO:

; 3607 :    }
; 3608 : 
; 3609 :    // Allocate an array for the incoming views.
; 3610 :    lpNewViewArray = (zPVIEW) fnAllocDataspace( lpTask->hFirstDataHeader,

	push	0
	push	0
	push	1
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _lpNewViewArray$[ebp], eax

; 3611 :                                                sizeof( zVIEW ) * (zULONG) nViewCount,
; 3612 :                                                TRUE, 0, 0 );
; 3613 :    lpNewViewArray = zGETPTR( lpNewViewArray );

	mov	ecx, DWORD PTR _lpNewViewArray$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewArray$[ebp], eax

; 3614 : 
; 3615 :    // Retrieve all the views.
; 3616 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN16@NetCommitO
$LN14@NetCommitO:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN16@NetCommitO:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN15@NetCommitO

; 3617 :    {
; 3618 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN62@NetCommitO

; 3619 :          continue;

	jmp	SHORT $LN14@NetCommitO
$LN62@NetCommitO:

; 3620 : 
; 3621 :       lpViewOD = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3622 : 
; 3623 :       if ( cPacketType == zPACKET_EMPTYOI )

	movsx	eax, BYTE PTR _cPacketType$[ebp]
	cmp	eax, 101				; 00000065H
	jne	SHORT $LN63@NetCommitO

; 3624 :       {
; 3625 :          // Nothing needs to be done here.
; 3626 :          // The server committed the OI but the root must have been deleted
; 3627 :          // because the resulting OI is empty.  Since we don't want to send an
; 3628 :          // empty OI back we'll just skip it.
; 3629 :       }

	jmp	SHORT $LN64@NetCommitO
$LN63@NetCommitO:

; 3630 :       else
; 3631 :       if ( cPacketType == zPACKET_ACK )

	movsx	ecx, BYTE PTR _cPacketType$[ebp]
	cmp	ecx, 75					; 0000004bH
	jne	SHORT $LN65@NetCommitO

; 3632 :       {
; 3633 :          // The server committed the OI and now must send back the resulting OI.
; 3634 :          if ( fnReceiveOI( &pvConn, lpNetwork, &lpNewViewArray[ k ],
; 3635 :                            lpViewArray[ k ], lpViewOD->szName,
; 3636 :                            zMULTIPLE ) == zCALL_ERROR )

	push	256					; 00000100H
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpNewViewArray$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	call	_fnReceiveOI@24
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN67@NetCommitO

; 3637 :          {
; 3638 :             TraceLineS( "(kzoeneta) ** Error receiving OI after commit!", "" );

	push	OFFSET $SG14848
	push	OFFSET $SG14849
	call	_TraceLineS@8

; 3639 :             goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN67@NetCommitO:

; 3640 :          }
; 3641 :       }

	jmp	SHORT $LN64@NetCommitO
$LN65@NetCommitO:

; 3642 :       else
; 3643 :       {
; 3644 :          TraceLineS( "(kzoeneta) ** Received bytes but no ACK!", "" );

	push	OFFSET $SG14850
	push	OFFSET $SG14851
	call	_TraceLineS@8

; 3645 :          goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN64@NetCommitO:

; 3646 :       }
; 3647 : 
; 3648 :       // Get the next packet.
; 3649 :       if ( fnReceiveDataPacket( lpNetwork, &pvConn, &cPacketType,
; 3650 :                                 &lPacketData ) != 0 )

	lea	eax, DWORD PTR _lPacketData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _cPacketType$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvConn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnReceiveDataPacket@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN68@NetCommitO

; 3651 :       {
; 3652 :          TraceLineS( "(kzoeneta) ** Error receiving OI ACK!", "" );

	push	OFFSET $SG14853
	push	OFFSET $SG14854
	call	_TraceLineS@8

; 3653 :          goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN68@NetCommitO:

; 3654 :       }
; 3655 : 
; 3656 :    } // for ( k...)...

	jmp	$LN14@NetCommitO
$LN15@NetCommitO:

; 3657 : 
; 3658 :    if ( cPacketType != zPACKET_RC )

	movsx	edx, BYTE PTR _cPacketType$[ebp]
	cmp	edx, 35					; 00000023H
	je	SHORT $LN69@NetCommitO

; 3659 :    {
; 3660 :       TraceLineS( "(kzoeneta) ** No return code for Commit!", "" );

	push	OFFSET $SG14856
	push	OFFSET $SG14857
	call	_TraceLineS@8

; 3661 :       goto EndOfFunction;

	jmp	$EndOfFunction$81
$LN69@NetCommitO:

; 3662 :    }
; 3663 : 
; 3664 :    nRC = (zSHORT) lPacketData;

	mov	ax, WORD PTR _lPacketData$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3665 : 
; 3666 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN70@NetCommitO

; 3667 :       TraceLineI( "(kzoeneta) ** RC from commit = ", nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	push	OFFSET $SG14859
	call	_TraceLineI@8
$LN70@NetCommitO:

; 3668 : 
; 3669 :    //=======================================================================
; 3670 :    // We have sent the user's OIs (lpViewArray) to the server and they've been
; 3671 :    // committed and sent back to us (as lpNewViewArray).  We must now merge the
; 3672 :    // changes from new to lpView.  We can't just drop lpView because that will
; 3673 :    // invalidate all other views to the OI referenced by lpView.  In addition,
; 3674 :    // all the names for lpView will be dropped.  Lastly, it will not "update"
; 3675 :    // any linked instances.
; 3676 :    //
; 3677 :    // If we merge the changes from vNew to lpView, then all the views to
; 3678 :    // the OI will still be valid, the view names will be preserved, and the
; 3679 :    // linked instances will also be "updated".
; 3680 :    //=======================================================================
; 3681 : 
; 3682 :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN19@NetCommitO
$LN17@NetCommitO:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN19@NetCommitO:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$EndOfFunction$81

; 3683 :    {
; 3684 :       LPVIEWCSR lpViewCsr;
; 3685 :       LPVIEWOI  lpViewOI;
; 3686 :       LPVIEWOI  lpNewViewOI;
; 3687 : 
; 3688 :       if ( lpNewViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpNewViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN71@NetCommitO

; 3689 :          continue;

	jmp	SHORT $LN17@NetCommitO
$LN71@NetCommitO:

; 3690 : 
; 3691 :       if ( fnMergeViews( lpNewViewArray[ k ],
; 3692 :                          lpViewArray[ k ] ) == zCALL_ERROR )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpNewViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_fnMergeViews@8
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN72@NetCommitO

; 3693 :       {
; 3694 :          nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 3695 :          continue;

	jmp	SHORT $LN17@NetCommitO
$LN72@NetCommitO:

; 3696 :       }
; 3697 : 
; 3698 :       // Call operation to clean up the OI. This will also drop
; 3699 :       // all the deleted/excluded entity instances.
; 3700 :       fnCleanupInstance( lpViewArray[ k ], 1 );

	push	1
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnCleanupInstance
	add	esp, 8

; 3701 : 
; 3702 :       // Turn off the update flags.
; 3703 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$5[ebp], eax

; 3704 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$5[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$6[ebp], eax

; 3705 :       lpViewOI->bUpdated = lpViewOI->bUpdatedFile = FALSE;

	mov	eax, DWORD PTR _lpViewOI$6[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpViewOI$6[ebp]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _lpViewOI$6[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpViewOI$6[ebp]
	mov	DWORD PTR [edx+36], ecx

; 3706 : 
; 3707 :       lpViewCsr   = zGETPTR( lpNewViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpNewViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$5[ebp], eax

; 3708 :       lpNewViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$5[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewOI$1[ebp], eax

; 3709 :       lpViewOI->bIsLocked = lpNewViewOI->bIsLocked;

	mov	eax, DWORD PTR _lpNewViewOI$1[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 7
	and	ecx, 1
	and	ecx, 1
	shl	ecx, 7
	mov	edx, DWORD PTR _lpViewOI$6[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -129				; ffffff7fH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpViewOI$6[ebp]
	mov	DWORD PTR [ecx+36], eax

; 3710 : 
; 3711 :    } // for k...

	jmp	$LN17@NetCommitO
$EndOfFunction$81:

; 3712 : 
; 3713 : EndOfFunction:
; 3714 :    if ( vSubtask && bConnectionMade &&

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN73@NetCommitO
	movzx	edx, BYTE PTR _bConnectionMade$[ebp]
	test	edx, edx
	je	SHORT $LN73@NetCommitO
	mov	eax, DWORD PTR _vReferenceView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvConn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_fnRetrieveMsgAndTraceObj@12
	cwde
	test	eax, eax
	jge	SHORT $LN73@NetCommitO

; 3715 :         fnRetrieveMsgAndTraceObj( lpNetwork, &pvConn, vReferenceView ) < 0 )
; 3716 :    {
; 3717 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN73@NetCommitO:

; 3718 :    }
; 3719 : 
; 3720 :    if ( bConnectionMade &&

	movzx	edx, BYTE PTR _bConnectionMade$[ebp]
	test	edx, edx
	je	SHORT $LN74@NetCommitO
	push	1
	lea	eax, DWORD PTR _pvConn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnRemoveConnectionFromNetwork@12
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN74@NetCommitO

; 3721 :         fnRemoveConnectionFromNetwork( lpNetwork, &pvConn,
; 3722 :                                        TRUE ) == zCALL_ERROR )
; 3723 :    {
; 3724 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN74@NetCommitO:

; 3725 :    }
; 3726 : 
; 3727 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN75@NetCommitO

; 3728 :       DROPSUBTASK( vSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropSubtask$3[ebp], eax
	push	0
	mov	eax, DWORD PTR _lpDropSubtask$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDropSubtask$3[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH
$LN75@NetCommitO:

; 3729 : 
; 3730 :    if ( pchObjectNameBuffer )

	cmp	DWORD PTR _pchObjectNameBuffer$[ebp], 0
	je	SHORT $LN76@NetCommitO

; 3731 :       fnFreeDataspace( pchObjectNameBuffer );

	mov	eax, DWORD PTR _pchObjectNameBuffer$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN76@NetCommitO:

; 3732 : 
; 3733 :    if ( pchLinkBuffer )

	cmp	DWORD PTR _pchLinkBuffer$[ebp], 0
	je	SHORT $LN77@NetCommitO

; 3734 :       fnFreeDataspace( pchLinkBuffer );

	mov	ecx, DWORD PTR _pchLinkBuffer$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
$LN77@NetCommitO:

; 3735 : 
; 3736 :    if ( lpNewViewArray )

	cmp	DWORD PTR _lpNewViewArray$[ebp], 0
	je	$LN78@NetCommitO

; 3737 :    {
; 3738 :       for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN22@NetCommitO
$LN20@NetCommitO:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN22@NetCommitO:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN21@NetCommitO

; 3739 :       {
; 3740 :          LPVIEWOI lpViewOI;
; 3741 : 
; 3742 :          if ( lpNewViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpNewViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN79@NetCommitO

; 3743 :             continue;

	jmp	SHORT $LN20@NetCommitO
$LN79@NetCommitO:

; 3744 : 
; 3745 :          lpViewCsr = zGETPTR( lpNewViewArray[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpNewViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3746 :          lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$2[ebp], eax

; 3747 : 
; 3748 :          // To keep any possible pessimistic locks from being dropped let's
; 3749 :          // turn off the bIsLocked flag.  Note that this only happens if the
; 3750 :          // user indicated that locks are to be left in place after the commit.
; 3751 :          lpViewOI->bIsLocked = 0;

	mov	edx, DWORD PTR _lpViewOI$2[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -129				; ffffff7fH
	mov	ecx, DWORD PTR _lpViewOI$2[ebp]
	mov	DWORD PTR [ecx+36], eax

; 3752 : 
; 3753 :          fnDropView( lpNewViewArray[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpNewViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_fnDropView@4

; 3754 :       }

	jmp	$LN20@NetCommitO
$LN21@NetCommitO:

; 3755 : 
; 3756 :       fnFreeDataspace( lpNewViewArray );

	mov	edx, DWORD PTR _lpNewViewArray$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$LN78@NetCommitO:

; 3757 :    }
; 3758 : 
; 3759 :    fnOperationReturn( iNetCommitOI, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	501					; 000001f5H
	call	_fnOperationReturn
	add	esp, 8

; 3760 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@NetCommitO:

; 3761 : 
; 3762 : } // NetCommitOI

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_NetCommitOI@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = -12					; size = 4
_lpTask$ = -8						; size = 4
_nRC$ = -4						; size = 2
_pchNetworkName$ = 8					; size = 4
_pchAddress$ = 12					; size = 4
_pvReturnView$ = 16					; size = 4
_pchViewOD_Name$ = 20					; size = 4
_vSubtask$ = 24						; size = 4
_lpQualView$ = 28					; size = 4
_lControl$ = 32						; size = 4
_NetActivateOI@28 PROC

; 2432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2433 :    LPTASK         lpTask;
; 2434 :    LPNETWORK      lpNetwork;
; 2435 :    zSHORT         nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2436 : 
; 2437 :    // If task not active or disabled, return zCALL_ERROR.
; 2438 :    if ( (lpTask = fnOperationCall( iNetActivateOI, vSubtask, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	500					; 000001f4H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetActivat

; 2439 :    {
; 2440 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetActivat
$LN2@NetActivat:

; 2441 :    }
; 2442 : 
; 2443 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN3@NetActivat

; 2444 :    {
; 2445 :       fnOperationReturn( iNetActivateOI, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	500					; 000001f4H
	call	_fnOperationReturn
	add	esp, 8

; 2446 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetActivat
$LN3@NetActivat:

; 2447 :    }
; 2448 : 
; 2449 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN4@NetActivat

; 2450 :    {
; 2451 :       TraceLine( "(kzoeneta) ** Starting activate for network: %s   OD Name: %s",

	mov	ecx, DWORD PTR _pchViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET $SG14467
	call	_TraceLine
	add	esp, 12					; 0000000cH
$LN4@NetActivat:

; 2452 :                  lpNetwork->szNetworkName, pchViewOD_Name );
; 2453 :    }
; 2454 : 
; 2455 :    // Check to see if the qualification object uses the "IS" clause.  If it
; 2456 :    // does we need to change the "IS" clause into it's seperate key
; 2457 :    // components.
; 2458 :    if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $LN5@NetActivat

; 2459 :    {
; 2460 :       if ( fnConvertIS_Clause( &lpQualView ) == zCALL_ERROR )

	lea	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_fnConvertIS_Clause@4
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN5@NetActivat

; 2461 :       {
; 2462 :          fnOperationReturn( iNetActivateOI, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	500					; 000001f4H
	call	_fnOperationReturn
	add	esp, 8

; 2463 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetActivat
$LN5@NetActivat:

; 2464 :       }
; 2465 :    }
; 2466 : 
; 2467 :    nRC = fnNetActivateOI( lpTask, lpNetwork, pchAddress, pvReturnView,

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAddress$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnNetActivateOI@32
	mov	WORD PTR _nRC$[ebp], ax

; 2468 :                           pchViewOD_Name, vSubtask, lpQualView, lControl );
; 2469 : 
; 2470 :    // fnConvertIS_Clause( ) created a new qualification object so we must
; 2471 :    // drop it.
; 2472 :    if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $LN7@NetActivat

; 2473 :       fnDropView( lpQualView );

	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_fnDropView@4
$LN7@NetActivat:

; 2474 : 
; 2475 :    fnOperationReturn( iNetActivateOI, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	500					; 000001f4H
	call	_fnOperationReturn
	add	esp, 8

; 2476 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@NetActivat:

; 2477 : 
; 2478 : } // NetActivateOI

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_NetActivateOI@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpNetwork$ = -8					; size = 4
_lpTask$ = -4						; size = 4
_lpView$ = 8						; size = 4
_pchNetworkName$ = 12					; size = 4
_pchHostAddress$ = 16					; size = 4
_NetGetLocalHostAddress@12 PROC

; 5036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5037 :    LPTASK         lpTask;
; 5038 :    LPNETWORK      lpNetwork;
; 5039 : 
; 5040 :    // If task not active or disabled, return zCALL_ERROR.
; 5041 :    if ( (lpTask = fnOperationCall( iNetGetLocalHostAddress, lpView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	514					; 00000202H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetGetLoca

; 5042 :    {
; 5043 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetGetLoca
$LN2@NetGetLoca:

; 5044 :    }
; 5045 : 
; 5046 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN3@NetGetLoca

; 5047 :    {
; 5048 :       fnOperationReturn( iNetStatus, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	508					; 000001fcH
	call	_fnOperationReturn
	add	esp, 8

; 5049 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@NetGetLoca
$LN3@NetGetLoca:

; 5050 :    }
; 5051 : 
; 5052 :    if ( (*lpNetwork->lpfnGetAddress)( lpView, &lpNetwork->pNetworkHandle,
; 5053 :                                       0, 'L', pchHostAddress ) != 0 )

	mov	ecx, DWORD PTR _pchHostAddress$[ebp]
	push	ecx
	push	76					; 0000004cH
	push	0
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+190]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN4@NetGetLoca

; 5054 :    {
; 5055 :       fnOperationReturn( iNetStatus, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	508					; 000001fcH
	call	_fnOperationReturn
	add	esp, 8

; 5056 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetGetLoca
$LN4@NetGetLoca:

; 5057 :    }
; 5058 : 
; 5059 :    fnOperationReturn( iNetGetLocalHostAddress, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	514					; 00000202H
	call	_fnOperationReturn
	add	esp, 8

; 5060 :    return( 0 );

	xor	eax, eax
$LN1@NetGetLoca:

; 5061 : 
; 5062 : } // NetGetLocalHostAddress

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_NetGetLocalHostAddress@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
_lpNetwork$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_NetStopListen@8 PROC

; 1977 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1978 :    LPTASK      lpTask;
; 1979 :    LPNETWORK   lpNetwork;
; 1980 : 
; 1981 :    // If task not active or disabled, return zCALL_ERROR.
; 1982 :    if ( (lpTask = fnOperationCall( iNetStopListen, lpTaskView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	509					; 000001fdH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetStopLis

; 1983 :    {
; 1984 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStopLis
$LN2@NetStopLis:

; 1985 :    }
; 1986 : 
; 1987 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN3@NetStopLis

; 1988 :    {
; 1989 :       fnOperationReturn( iNetStopListen, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	509					; 000001fdH
	call	_fnOperationReturn
	add	esp, 8

; 1990 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStopLis
$LN3@NetStopLis:

; 1991 :    }
; 1992 : 
; 1993 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	movsx	edx, WORD PTR [ecx+140]
	test	edx, edx
	jle	SHORT $LN4@NetStopLis

; 1994 :    {
; 1995 :       TraceLineS( "(kzoeneta) ** Stopping listen for network ",

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET $SG14282
	call	_TraceLineS@8
$LN4@NetStopLis:

; 1996 :                   lpNetwork->szNetworkName );
; 1997 :    }
; 1998 : 
; 1999 :    if ( lpNetwork->bListen == FALSE )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+154]
	and	edx, 1
	jne	SHORT $LN5@NetStopLis

; 2000 :    {
; 2001 :       TraceLineS( "(kzoeneta) ** Network not listening!",

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	OFFSET $SG14284
	call	_TraceLineS@8

; 2002 :                   lpNetwork->szNetworkName );
; 2003 :       fnOperationReturn( iNetStopListen, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	509					; 000001fdH
	call	_fnOperationReturn
	add	esp, 8

; 2004 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@NetStopLis
$LN5@NetStopLis:

; 2005 :    }
; 2006 : 
; 2007 :    if ( (*lpNetwork->lpfnStopListen)( lpTaskView,
; 2008 :                                       &lpNetwork->pNetworkHandle ) != 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+166]
	call	edx
	cwde
	test	eax, eax
	je	SHORT $LN6@NetStopLis

; 2009 :    {
; 2010 :       fnOperationReturn( iNetStopListen, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	509					; 000001fdH
	call	_fnOperationReturn
	add	esp, 8

; 2011 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetStopLis
$LN6@NetStopLis:

; 2012 :    }
; 2013 : 
; 2014 :    lpNetwork->bListen = FALSE;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+154]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [ecx+154], eax

; 2015 : 
; 2016 :    fnOperationReturn( iNetStopListen, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	509					; 000001fdH
	call	_fnOperationReturn
	add	esp, 8

; 2017 :    return( 0 );

	xor	eax, eax
$LN1@NetStopLis:

; 2018 : 
; 2019 : } // NetStopListen

	mov	esp, ebp
	pop	ebp
	ret	8
_NetStopListen@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpTask$ = -12						; size = 4
_lpNetwork$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_NetListen@8 PROC

; 1905 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1906 :    LPTASK      lpTask;
; 1907 :    LPNETWORK   lpNetwork;
; 1908 :    zSHORT      nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1909 : 
; 1910 :    // If task not active or disabled, return zCALL_ERROR.
; 1911 :    if ( (lpTask = fnOperationCall( iNetListen, lpTaskView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	push	504					; 000001f8H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetListen

; 1912 :    {
; 1913 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetListen
$LN2@NetListen:

; 1914 :    }
; 1915 : 
; 1916 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN3@NetListen

; 1917 :    {
; 1918 :       fnOperationReturn( iNetListen, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	504					; 000001f8H
	call	_fnOperationReturn
	add	esp, 8

; 1919 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetListen
$LN3@NetListen:

; 1920 :    }
; 1921 : 
; 1922 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN4@NetListen

; 1923 :    {
; 1924 :       TraceLineS( "(kzoeneta) ** Starting NetListen for network ",

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET $SG14266
	call	_TraceLineS@8
$LN4@NetListen:

; 1925 :                   lpNetwork->szNetworkName );
; 1926 :    }
; 1927 : 
; 1928 :    if ( lpNetwork->bListen )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+154]
	and	eax, 1
	je	SHORT $LN5@NetListen

; 1929 :    {
; 1930 :       TraceLineS( "(kzoeneta) ** Network already listening!",

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	OFFSET $SG14268
	call	_TraceLineS@8

; 1931 :                   lpNetwork->szNetworkName );
; 1932 :       fnOperationReturn( iNetListen, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	504					; 000001f8H
	call	_fnOperationReturn
	add	esp, 8

; 1933 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@NetListen
$LN5@NetListen:

; 1934 :    }
; 1935 : 
; 1936 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN6@NetListen

; 1937 :    {
; 1938 :       TraceLineS( "(kzoeneta) ** Starting listen for network ",

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET $SG14270
	call	_TraceLineS@8
$LN6@NetListen:

; 1939 :                   lpNetwork->szNetworkName );
; 1940 :    }
; 1941 : 
; 1942 :    if ( (*lpNetwork->lpfnListen)( &lpNetwork->pNetworkHandle,
; 1943 :                                   0, lpTaskView ) != 0 )

	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+162]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN7@NetListen

; 1944 :    {
; 1945 :       fnOperationReturn( iNetListen, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	504					; 000001f8H
	call	_fnOperationReturn
	add	esp, 8

; 1946 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetListen
$LN7@NetListen:

; 1947 :    }
; 1948 : 
; 1949 :    lpNetwork->bListen = TRUE;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+154]
	or	ecx, 1
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [edx+154], ecx

; 1950 : 
; 1951 :    fnOperationReturn( iNetListen, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	504					; 000001f8H
	call	_fnOperationReturn
	add	esp, 8

; 1952 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@NetListen:

; 1953 : 
; 1954 : } // NetListen

	mov	esp, ebp
	pop	ebp
	ret	8
_NetListen@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpSystemTask$ = -36					; size = 4
_lProcessID$ = -32					; size = 4
_lpLibrary$ = -28					; size = 4
_lpNetConn$1 = -24					; size = 4
_lpPrevNetwork$ = -20					; size = 4
_lpSrchNetwork$ = -16					; size = 4
_lpTask$ = -12						; size = 4
_lpNetwork$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_NetClose@8 PROC

; 1770 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1771 :    LPTASK      lpTask;
; 1772 :    LPTASK      lpSystemTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemTask$[ebp], eax

; 1773 :    LPNETWORK   lpPrevNetwork;
; 1774 :    LPNETWORK   lpSrchNetwork;
; 1775 :    LPNETWORK   lpNetwork;
; 1776 :    LPLIBRARY   lpLibrary;
; 1777 :    zLONG       lProcessID;
; 1778 :    zSHORT      nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 1779 : 
; 1780 :    TraceLineS( "(kzoeneta) ** NetClose for Network: ", pchNetworkName );

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	push	OFFSET $SG14241
	call	_TraceLineS@8

; 1781 : 
; 1782 :    // If task not active or disabled, return zCALL_ERROR.
; 1783 :    if ( (lpTask = fnOperationCall( iNetClose, lpTaskView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	push	502					; 000001f6H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN7@NetClose

; 1784 :    {
; 1785 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetClose
$LN7@NetClose:

; 1786 :    }
; 1787 : 
; 1788 :    zLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysLockCoreMutex@4

; 1789 : 
; 1790 :    if ( (lpNetwork = fnFindNetwork( lpTask, pchNetworkName, TRUE )) == 0 )

	push	1
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnFindNetwork@12
	mov	DWORD PTR _lpNetwork$[ebp], eax
	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN8@NetClose

; 1791 :    {
; 1792 :       fnOperationReturn( iNetClose, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	502					; 000001f6H
	call	_fnOperationReturn
	add	esp, 8

; 1793 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetClose
$LN8@NetClose:

; 1794 :    }
; 1795 : 
; 1796 :    if ( lpNetwork->bListen &&

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+154]
	and	eax, 1
	je	SHORT $LN2@NetClose
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_NetStopListen@8
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN2@NetClose

; 1797 :         NetStopListen( lpTaskView, lpNetwork->szNetworkName ) == zCALL_ERROR )
; 1798 :    {
; 1799 :       // Error trying to stop a listen, but we keep trying to close the network.
; 1800 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN2@NetClose:

; 1801 :    }
; 1802 : 
; 1803 :    // Try closing any open connections.
; 1804 :    while ( lpNetwork->hFirstNetConn )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [edx+150], 0
	je	SHORT $LN3@NetClose

; 1805 :    {
; 1806 :       LPNETCONN lpNetConn = zGETPTR( lpNetwork->hFirstNetConn );

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+150]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetConn$1[ebp], eax

; 1807 : 
; 1808 :       fnRemoveConnectionFromNetwork( lpNetwork,

	push	1
	mov	edx, DWORD PTR _lpNetConn$1[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	push	ecx
	call	_fnRemoveConnectionFromNetwork@12

; 1809 :                                      lpNetConn->pvConn,
; 1810 :                                      TRUE );
; 1811 :    }

	jmp	SHORT $LN2@NetClose
$LN3@NetClose:

; 1812 : 
; 1813 :    lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 1814 : // if ( lpNetwork->lpfnServDirClose )
; 1815 : // {
; 1816 : //    lpLibrary = zGETPTR( lpNetwork->hServDirLib );
; 1817 : //    if ( lProcessID != lpLibrary->lProcessID )
; 1818 : //       LoadNetworkOperations( lpTask, lpNetwork );
; 1819 : // }
; 1820 : 
; 1821 :    if ( lpNetwork->lpfnServDirClose &&
; 1822 :         LoadNetworkOperations( lpTask, lpNetwork ) == 0 &&

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [edx+214], 0
	je	SHORT $LN10@NetClose
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_LoadNetworkOperations
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN10@NetClose
	push	0
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+214]
	call	eax
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN10@NetClose

; 1823 :         (*lpNetwork->lpfnServDirClose)( lpTask,
; 1824 :                                         &lpNetwork->pvServDirData, 0 ) != 0 )
; 1825 :    {
; 1826 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN10@NetClose:

; 1827 :    }
; 1828 : 
; 1829 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	movsx	ecx, WORD PTR [eax+140]
	test	ecx, ecx
	jle	SHORT $LN11@NetClose

; 1830 :       TraceLineS( "(kzoeneta) ** Closing network ", lpNetwork->szNetworkName );

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	push	OFFSET $SG14247
	call	_TraceLineS@8
$LN11@NetClose:

; 1831 : 
; 1832 :    if ( lpNetwork->lpfnClose &&

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [eax+158], 0
	je	SHORT $LN12@NetClose
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+158]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@NetClose

; 1833 :         (*lpNetwork->lpfnClose)( lpTaskView, &lpNetwork->pNetworkHandle ) != 0 )
; 1834 :    {
; 1835 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN12@NetClose:

; 1836 :    }
; 1837 : 
; 1838 :    if ( lpNetwork->hLibrary )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN13@NetClose

; 1839 :    {
; 1840 :       lpLibrary = zGETPTR( lpNetwork->hLibrary );

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 1841 :       if ( lProcessID == lpLibrary->lProcessID )

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR _lProcessID$[ebp]
	cmp	edx, DWORD PTR [ecx+271]
	jne	SHORT $LN13@NetClose

; 1842 :          SysFreeLibrary( lpTaskView, lpNetwork->hLibrary );

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysFreeLibrary@8
$LN13@NetClose:

; 1843 :    }
; 1844 : 
; 1845 :    if ( lpNetwork->lpfnServDirClose &&

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [eax+214], 0
	je	SHORT $LN15@NetClose
	push	0
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR [eax+214]
	call	ecx
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN15@NetClose

; 1846 :         (*lpNetwork->lpfnServDirClose)( lpTask,
; 1847 :                                         &lpNetwork->pvServDirData, 0 ) != 0 )
; 1848 :    {
; 1849 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN15@NetClose:

; 1850 :    }
; 1851 : 
; 1852 :    if ( lpNetwork->hServDirLib )

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	cmp	DWORD PTR [ecx+206], 0
	je	SHORT $LN16@NetClose

; 1853 :    {
; 1854 :       SysFreeLibrary( lpTaskView, lpNetwork->hServDirLib );

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+206]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysFreeLibrary@8

; 1855 :       lpNetwork->hServDirLib = 0;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [edx+206], 0
$LN16@NetClose:

; 1856 :    }
; 1857 : 
; 1858 :    // Remove the network from the chain.
; 1859 :    lpPrevNetwork = 0;

	mov	DWORD PTR _lpPrevNetwork$[ebp], 0

; 1860 :    for ( lpSrchNetwork = zGETPTR( AnchorBlock->hFirstNetwork );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+122]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchNetwork$[ebp], eax
	jmp	SHORT $LN6@NetClose
$LN4@NetClose:

; 1862 :          lpSrchNetwork = zGETPTR( lpSrchNetwork->hNextNetwork ) )

	mov	edx, DWORD PTR _lpSrchNetwork$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchNetwork$[ebp], eax
$LN6@NetClose:

; 1861 :          lpSrchNetwork != lpNetwork;

	mov	ecx, DWORD PTR _lpSrchNetwork$[ebp]
	cmp	ecx, DWORD PTR _lpNetwork$[ebp]
	je	SHORT $LN5@NetClose

; 1863 :    {
; 1864 :       lpPrevNetwork = lpSrchNetwork;

	mov	edx, DWORD PTR _lpSrchNetwork$[ebp]
	mov	DWORD PTR _lpPrevNetwork$[ebp], edx

; 1865 :    }

	jmp	SHORT $LN4@NetClose
$LN5@NetClose:

; 1866 : 
; 1867 :    if ( lpPrevNetwork )

	cmp	DWORD PTR _lpPrevNetwork$[ebp], 0
	je	SHORT $LN17@NetClose

; 1868 :       lpPrevNetwork->hNextNetwork = lpNetwork->hNextNetwork;

	mov	eax, DWORD PTR _lpPrevNetwork$[ebp]
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN18@NetClose
$LN17@NetClose:

; 1869 :    else
; 1870 :       AnchorBlock->hFirstNetwork = lpNetwork->hNextNetwork;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+122], edx
$LN18@NetClose:

; 1871 : 
; 1872 :    zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1873 : 
; 1874 :    fnFreeDataspace( lpNetwork );

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1875 : 
; 1876 :    fnOperationReturn( iNetClose, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	502					; 000001f6H
	call	_fnOperationReturn
	add	esp, 8

; 1877 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@NetClose:

; 1878 : 
; 1879 : } // NetClose

	mov	esp, ebp
	pop	ebp
	ret	8
_NetClose@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeneta.c
_TEXT	SEGMENT
_lpvNetHandle$ = -15196					; size = 4
_lpfnInit$ = -15192					; size = 4
_lpSystemTask$ = -15188					; size = 4
_lpfnClose$ = -15184					; size = 4
_lpfnOpenConn$ = -15180					; size = 4
_lpfnCloseConn$ = -15176				; size = 4
_lpfnSend$ = -15172					; size = 4
_lpfnReceive$ = -15168					; size = 4
_lpfnListen$ = -15164					; size = 4
_lpfnStopListen$ = -15160				; size = 4
_lpfnGetAddress$ = -15156				; size = 4
_hNetwork$ = -15152					; size = 4
_vSystemView$ = -15148					; size = 4
_lpTask$ = -15144					; size = 4
_hLibrary$ = -15140					; size = 4
_lpNetwork$ = -15136					; size = 4
_szDefaultNetwork$ = -15132				; size = 4096
_szGroup$ = -11036					; size = 4096
_szServerDirApp$ = -6940				; size = 4096
_szLocalName$1 = -2844					; size = 300
_szMsg$2 = -2544					; size = 200
_szMsg$3 = -2344					; size = 200
_szMsg$4 = -2144					; size = 200
_szMsg$5 = -1944					; size = 200
_szMsg$6 = -1744					; size = 200
_szMsg$7 = -1544					; size = 200
_szMsg$8 = -1344					; size = 200
_szMsg$9 = -1144					; size = 200
_szMsg$10 = -944					; size = 200
_szMsg$11 = -744					; size = 200
_szExecutableName$ = -544				; size = 257
_szFileName$ = -284					; size = 257
_szTraceLevel$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_pchNetworkName$ = 12					; size = 4
_pchExecutable$ = 16					; size = 4
_NetStartup@12 PROC

; 1396 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 15196				; 00003b5cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1397 :    LPTASK           lpTask;
; 1398 :    LPTASK           lpSystemTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemTask$[ebp], eax

; 1399 :    zVIEW            vSystemView = zGETPTR( lpSystemTask->hFirstView );

	mov	edx, DWORD PTR _lpSystemTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vSystemView$[ebp], eax

; 1400 :    LPNETWORK        lpNetwork;
; 1401 :    zPVOID           hNetwork;
; 1402 :    zCHAR            szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1403 :    zPVOID           lpvNetHandle;
; 1404 :    LPLIBRARY        hLibrary;
; 1405 :    zCHAR            szGroup[ 4096 ];
; 1406 :    zCHAR            szServerDirApp[ 4096 ];
; 1407 :    zCHAR            szTraceLevel[ 20 ];
; 1408 :    zCHAR            szDefaultNetwork[ 4096 ];
; 1409 :    zCHAR            szExecutableName[ zMAX_FILENAME_LTH + 1 ];
; 1410 : // zBOOL            bOldTrace;
; 1411 :    zLPFN_NETSTART   lpfnInit;
; 1412 :    zLPFN_NETCLOSE   lpfnClose;
; 1413 :    zLPFN_NETLISTEN  lpfnListen;
; 1414 :    zLPFN_NETCLOSE   lpfnStopListen;
; 1415 :    zLPFN_NETOPCONN  lpfnOpenConn;
; 1416 :    zLPFN_NETCLCONN  lpfnCloseConn;
; 1417 :    zLPFN_NETGETADDR lpfnGetAddress;
; 1418 :    zLPFN_NETIO      lpfnSend;
; 1419 :    zLPFN_NETIO      lpfnReceive;
; 1420 : 
; 1421 :    // If task not active or disabled, return zCALL_ERROR.
; 1422 :    if ( (lpTask = fnOperationCall( iNetStartup, lpTaskView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	push	507					; 000001fbH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@NetStartup

; 1423 :    {
; 1424 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN2@NetStartup:

; 1425 :    }
; 1426 : 
; 1427 :    // If network name isn't supplied, use the default.
; 1428 :    if ( pchNetworkName == 0 || *pchNetworkName == 0 )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	je	SHORT $LN4@NetStartup
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	$LN3@NetStartup
$LN4@NetStartup:

; 1429 :    {
; 1430 :       SysReadZeidonIni( -1, "[Zeidon]", "DefaultNetwork", szDefaultNetwork );

	lea	ecx, DWORD PTR _szDefaultNetwork$[ebp]
	push	ecx
	push	OFFSET $SG14150
	push	OFFSET $SG14151
	push	-1
	call	_SysReadZeidonIni@16

; 1431 :       if ( szDefaultNetwork[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szDefaultNetwork$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN5@NetStartup

; 1432 :       {
; 1433 :          SysMessageBox( lpTaskView, szlNetworkError, "No default network for NetStartup", 1 );

	push	1
	push	OFFSET $SG14153
	push	OFFSET _szlNetworkError
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 1434 :          fnOperationReturn( iNetStartup, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1435 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN5@NetStartup:

; 1436 :       }
; 1437 : 
; 1438 :       pchNetworkName = szDefaultNetwork;

	lea	ecx, DWORD PTR _szDefaultNetwork$[ebp]
	mov	DWORD PTR _pchNetworkName$[ebp], ecx

; 1439 : 
; 1440 :       SysReadZeidonIni( -1, "[Zeidon]", "DefaultNetworkExec", szExecutableName );

	lea	edx, DWORD PTR _szExecutableName$[ebp]
	push	edx
	push	OFFSET $SG14154
	push	OFFSET $SG14155
	push	-1
	call	_SysReadZeidonIni@16

; 1441 :       if ( szExecutableName[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szExecutableName$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN6@NetStartup

; 1442 :       {
; 1443 :          // If no exec name give, use network name for executable too.
; 1444 :          zstrcpy( szExecutableName, szDefaultNetwork);

	lea	eax, DWORD PTR _szDefaultNetwork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szExecutableName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN6@NetStartup:

; 1445 :       }
; 1446 : 
; 1447 :       pchExecutable = szExecutableName;

	lea	edx, DWORD PTR _szExecutableName$[ebp]
	mov	DWORD PTR _pchExecutable$[ebp], edx
$LN3@NetStartup:

; 1448 :    }
; 1449 : 
; 1450 :    // Since networks are chained off the system task we need to protect
; 1451 :    // ourselves from other threads.
; 1452 :    zLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysLockCoreMutex@4

; 1453 : 
; 1454 :    // Check to make sure that the network name doesn't already exist.
; 1455 :    if ( fnFindNetwork( lpTask, pchNetworkName, FALSE ) != 0 )

	push	0
	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnFindNetwork@12
	test	eax, eax
	je	SHORT $LN7@NetStartup

; 1456 :    {
; 1457 :       fnOperationReturn( iNetStartup, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1458 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1459 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@NetStartup
$LN7@NetStartup:

; 1460 :    }
; 1461 : 
; 1462 :    if ( zstrchr( pchNetworkName, cDirSep ) == 0 )

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@NetStartup

; 1463 :    {
; 1464 :       SysGetLocalDirectory( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysGetLocalDirectory@4

; 1465 :       zstrcat( szFileName, pchExecutable );

	mov	eax, DWORD PTR _pchExecutable$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1466 :    }

	jmp	SHORT $LN9@NetStartup
$LN8@NetStartup:

; 1467 :    else
; 1468 :       zstrcpy( szFileName, pchExecutable );

	mov	edx, DWORD PTR _pchExecutable$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN9@NetStartup:

; 1469 : 
; 1470 :    // Try loading the library.
; 1471 :    hLibrary = SysLoadLibrary( vSystemView, szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSystemView$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 1472 :    if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $LN10@NetStartup

; 1473 :    {
; 1474 :       zCHAR szMsg[ 200 ];
; 1475 : 
; 1476 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1477 :       zsprintf( szMsg, "Can't find library '%s'", pchExecutable );

	mov	eax, DWORD PTR _pchExecutable$[ebp]
	push	eax
	push	OFFSET $SG14161
	lea	ecx, DWORD PTR _szMsg$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1478 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	push	OFFSET $SG14162
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 1479 :       fnOperationReturn( iNetStartup, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1480 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN10@NetStartup:

; 1481 :    }
; 1482 : 
; 1483 :    // ===
; 1484 :    // === Make sure that the Network Handler contains all the necessary
; 1485 :    // === operations.
; 1486 :    // ===
; 1487 : 
; 1488 :    lpfnInit = (zLPFN_NETSTART) SysGetProc( hLibrary, "zNetStart" );

	push	OFFSET $SG14163
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnInit$[ebp], eax

; 1489 :    if ( lpfnInit == 0 )

	cmp	DWORD PTR _lpfnInit$[ebp], 0
	jne	SHORT $LN11@NetStartup

; 1490 :    {
; 1491 :       zCHAR szMsg[ 200 ];
; 1492 : 
; 1493 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1494 :       zsprintf( szMsg, "Can't find operation zNetStart in library '%s'",

	mov	eax, DWORD PTR _pchExecutable$[ebp]
	push	eax
	push	OFFSET $SG14165
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1495 :                 pchExecutable );
; 1496 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$3[ebp]
	push	edx
	push	OFFSET $SG14166
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 1497 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSystemView$[ebp]
	push	edx
	call	_SysFreeLibrary@8

; 1498 :       fnOperationReturn( iNetStartup, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1499 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN11@NetStartup:

; 1500 :    }
; 1501 : 
; 1502 :    lpfnClose = (zLPFN_NETCLOSE) SysGetProc( hLibrary, "zNetClose" );

	push	OFFSET $SG14167
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnClose$[ebp], eax

; 1503 :    if ( lpfnClose == 0 )

	cmp	DWORD PTR _lpfnClose$[ebp], 0
	jne	SHORT $LN12@NetStartup

; 1504 :    {
; 1505 :       zCHAR szMsg[ 200 ];
; 1506 : 
; 1507 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1508 :       zsprintf( szMsg, "Can't find operation zNetClose in library '%s'",

	mov	edx, DWORD PTR _pchExecutable$[ebp]
	push	edx
	push	OFFSET $SG14169
	lea	eax, DWORD PTR _szMsg$4[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1509 :                 pchExecutable );
; 1510 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$4[ebp]
	push	ecx
	push	OFFSET $SG14170
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 1511 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSystemView$[ebp]
	push	ecx
	call	_SysFreeLibrary@8

; 1512 :       fnOperationReturn( iNetStartup, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1513 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN12@NetStartup:

; 1514 :    }
; 1515 : 
; 1516 :    lpfnListen = (zLPFN_NETLISTEN) SysGetProc( hLibrary, "zNetListen" );

	push	OFFSET $SG14171
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnListen$[ebp], eax

; 1517 :    if ( lpfnListen == 0 )

	cmp	DWORD PTR _lpfnListen$[ebp], 0
	jne	SHORT $LN13@NetStartup

; 1518 :    {
; 1519 :       zCHAR szMsg[ 200 ];
; 1520 : 
; 1521 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1522 :       zsprintf( szMsg, "Can't find operation zNetListen in library '%s'",

	mov	ecx, DWORD PTR _pchExecutable$[ebp]
	push	ecx
	push	OFFSET $SG14173
	lea	edx, DWORD PTR _szMsg$5[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1523 :                 pchExecutable );
; 1524 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$5[ebp]
	push	eax
	push	OFFSET $SG14174
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 1525 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSystemView$[ebp]
	push	eax
	call	_SysFreeLibrary@8

; 1526 :       fnOperationReturn( iNetStartup, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1527 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN13@NetStartup:

; 1528 :    }
; 1529 : 
; 1530 :    lpfnStopListen = (zLPFN_NETCLOSE) SysGetProc( hLibrary, "zNetStopListen" );

	push	OFFSET $SG14175
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnStopListen$[ebp], eax

; 1531 :    if ( lpfnStopListen == 0 )

	cmp	DWORD PTR _lpfnStopListen$[ebp], 0
	jne	SHORT $LN14@NetStartup

; 1532 :    {
; 1533 :       zCHAR szMsg[ 200 ];
; 1534 : 
; 1535 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1536 :       zsprintf( szMsg, "Can't find operation zNetStopListen in library '%s'",

	mov	eax, DWORD PTR _pchExecutable$[ebp]
	push	eax
	push	OFFSET $SG14177
	lea	ecx, DWORD PTR _szMsg$6[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1537 :                 pchExecutable );
; 1538 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$6[ebp]
	push	edx
	push	OFFSET $SG14178
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 1539 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSystemView$[ebp]
	push	edx
	call	_SysFreeLibrary@8

; 1540 :       fnOperationReturn( iNetStartup, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1541 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN14@NetStartup:

; 1542 :    }
; 1543 : 
; 1544 :    lpfnOpenConn = (zLPFN_NETOPCONN) SysGetProc( hLibrary,

	push	OFFSET $SG14179
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnOpenConn$[ebp], eax

; 1545 :                                                 "zNetOpenConnection" );
; 1546 :    if ( lpfnOpenConn == 0 )

	cmp	DWORD PTR _lpfnOpenConn$[ebp], 0
	jne	SHORT $LN15@NetStartup

; 1547 :    {
; 1548 :       zCHAR szMsg[ 200 ];
; 1549 : 
; 1550 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1551 :       zsprintf( szMsg, "Can't find operation zNetOpenConnection in library '%s'",

	mov	edx, DWORD PTR _pchExecutable$[ebp]
	push	edx
	push	OFFSET $SG14181
	lea	eax, DWORD PTR _szMsg$7[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1552 :                 pchExecutable );
; 1553 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$7[ebp]
	push	ecx
	push	OFFSET $SG14182
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 1554 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSystemView$[ebp]
	push	ecx
	call	_SysFreeLibrary@8

; 1555 :       fnOperationReturn( iNetStartup, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1556 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN15@NetStartup:

; 1557 :    }
; 1558 : 
; 1559 :    lpfnCloseConn = (zLPFN_NETCLCONN) SysGetProc( hLibrary,

	push	OFFSET $SG14183
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnCloseConn$[ebp], eax

; 1560 :                                                  "zNetCloseConnection" );
; 1561 :    if ( lpfnCloseConn == 0 )

	cmp	DWORD PTR _lpfnCloseConn$[ebp], 0
	jne	SHORT $LN16@NetStartup

; 1562 :    {
; 1563 :       zCHAR szMsg[ 200 ];
; 1564 : 
; 1565 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1566 :       zsprintf( szMsg, "Can't find operation zNetCloseConnection in library '%s'",

	mov	ecx, DWORD PTR _pchExecutable$[ebp]
	push	ecx
	push	OFFSET $SG14185
	lea	edx, DWORD PTR _szMsg$8[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1567 :                 pchExecutable );
; 1568 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$8[ebp]
	push	eax
	push	OFFSET $SG14186
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 1569 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSystemView$[ebp]
	push	eax
	call	_SysFreeLibrary@8

; 1570 :       fnOperationReturn( iNetStartup, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1571 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN16@NetStartup:

; 1572 :    }
; 1573 : 
; 1574 :    lpfnSend = (zLPFN_NETIO) SysGetProc( hLibrary, "zNetSend" );

	push	OFFSET $SG14187
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnSend$[ebp], eax

; 1575 :    if ( lpfnSend == 0 )

	cmp	DWORD PTR _lpfnSend$[ebp], 0
	jne	SHORT $LN17@NetStartup

; 1576 :    {
; 1577 :       zCHAR szMsg[ 200 ];
; 1578 : 
; 1579 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1580 :       zsprintf( szMsg, "Can't find operation zNetSend in library '%s'",

	mov	eax, DWORD PTR _pchExecutable$[ebp]
	push	eax
	push	OFFSET $SG14189
	lea	ecx, DWORD PTR _szMsg$9[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1581 :                 pchExecutable );
; 1582 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$9[ebp]
	push	edx
	push	OFFSET $SG14190
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 1583 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSystemView$[ebp]
	push	edx
	call	_SysFreeLibrary@8

; 1584 :       fnOperationReturn( iNetStartup, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1585 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN17@NetStartup:

; 1586 :    }
; 1587 : 
; 1588 :    lpfnReceive = (zLPFN_NETIO) SysGetProc( hLibrary, "zNetReceive" );

	push	OFFSET $SG14191
	mov	ecx, DWORD PTR _hLibrary$[ebp]
	push	ecx
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnReceive$[ebp], eax

; 1589 :    if ( lpfnReceive == 0 )

	cmp	DWORD PTR _lpfnReceive$[ebp], 0
	jne	SHORT $LN18@NetStartup

; 1590 :    {
; 1591 :       zCHAR szMsg[ 200 ];
; 1592 : 
; 1593 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1594 :       zsprintf( szMsg, "Cannot find operation zNetReceive in library '%s'",

	mov	edx, DWORD PTR _pchExecutable$[ebp]
	push	edx
	push	OFFSET $SG14193
	lea	eax, DWORD PTR _szMsg$10[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1595 :                 pchExecutable );
; 1596 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$10[ebp]
	push	ecx
	push	OFFSET $SG14194
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 1597 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSystemView$[ebp]
	push	ecx
	call	_SysFreeLibrary@8

; 1598 :       fnOperationReturn( iNetStartup, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1599 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN18@NetStartup:

; 1600 :    }
; 1601 : 
; 1602 :    lpfnGetAddress = (zLPFN_NETGETADDR) SysGetProc( hLibrary, "zNetGetHostAddress" );

	push	OFFSET $SG14195
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _lpfnGetAddress$[ebp], eax

; 1603 :    if ( lpfnGetAddress == 0 )

	cmp	DWORD PTR _lpfnGetAddress$[ebp], 0
	jne	SHORT $LN19@NetStartup

; 1604 :    {
; 1605 :       zCHAR szMsg[ 200 ];
; 1606 : 
; 1607 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1608 :       zsprintf( szMsg, "Cannot find operation zNetGetLocalHostAddress in "

	mov	ecx, DWORD PTR _pchExecutable$[ebp]
	push	ecx
	push	OFFSET $SG14197
	lea	edx, DWORD PTR _szMsg$11[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1609 :                 "library '%s'", pchExecutable );
; 1610 :       SysMessageBox( lpTaskView, "Zeidon Network Error", szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$11[ebp]
	push	eax
	push	OFFSET $SG14198
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 1611 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSystemView$[ebp]
	push	eax
	call	_SysFreeLibrary@8

; 1612 :       fnOperationReturn( iNetStartup, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1613 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN19@NetStartup:

; 1614 :    }
; 1615 : 
; 1616 :    // We got here, so the DLL contains all the operations it needs, so
; 1617 :    // call init operation.
; 1618 :    TraceLineS( "(kzoeneta) ** Starting network ", szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	OFFSET $SG14199
	call	_TraceLineS@8

; 1619 :    if ( (*lpfnInit)( pchNetworkName, &lpvNetHandle ) != 0 )

	lea	eax, DWORD PTR _lpvNetHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	call	DWORD PTR _lpfnInit$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN20@NetStartup

; 1620 :    {
; 1621 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1622 :       SysFreeLibrary( vSystemView, hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSystemView$[ebp]
	push	ecx
	call	_SysFreeLibrary@8

; 1623 :       fnOperationReturn( iNetStartup, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1624 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN20@NetStartup:

; 1625 :    }
; 1626 : 
; 1627 :    // If we get here then we're in business.  Create the network buffer and
; 1628 :    // add the network to the network chain.
; 1629 :    hNetwork = (LPNETWORK)

	push	0
	push	0
	push	1
	push	479					; 000001dfH
	mov	eax, DWORD PTR _lpSystemTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNetwork$[ebp], eax

; 1630 :           fnAllocDataspace( (LPDATAHEADER) lpSystemTask->hFirstDataHeader,
; 1631 :                             sizeof( NetworkRecord ), TRUE, 0, 0 );
; 1632 :    lpNetwork = zGETPTR( hNetwork );

	mov	edx, DWORD PTR _hNetwork$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetwork$[ebp], eax

; 1633 :    if ( lpNetwork == 0 )

	cmp	DWORD PTR _lpNetwork$[ebp], 0
	jne	SHORT $LN21@NetStartup

; 1634 :    {
; 1635 :       zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1636 :       SysMessageBox( lpTaskView, szlNetworkError, "Out of memory for network", 1 );

	push	1
	push	OFFSET $SG14202
	push	OFFSET _szlNetworkError
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 1637 :       fnOperationReturn( iNetStartup, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1638 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@NetStartup
$LN21@NetStartup:

; 1639 :    }
; 1640 : 
; 1641 :    zmemset( lpNetwork, 0, sizeof( NetworkRecord ) );

	push	479					; 000001dfH
	push	0
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1642 : 
; 1643 : // Following functions are NOT necessary.  Turn off tracing flag so we
; 1644 :    // don't show warning messages.
; 1645 : // bOldTrace = lpTask->bTrace;
; 1646 : // lpTask->bTrace = FALSE;
; 1647 : //
; 1648 : // lpNetwork->lpfnBufferEnd  = 0;//(zLPFN_NETCLCONN) SysGetProc( hLibrary, "zNetBufferEnd" );
; 1649 : // lpNetwork->lpfnSendPacket = 0;//(zLPFN_NETSENDPKT)SysGetProc( hLibrary, "zNetSendPacket" );
; 1650 : // lpNetwork->lpfnRecvPacket = 0;//(zLPFN_NETRECVPKT)SysGetProc( hLibrary, "zNetReceivePacket" );
; 1651 : // lpNetwork->lpfnSetMode    = 0;//(zLPFN_NETSETM)   SysGetProc( hLibrary, "zNetSetMode" );
; 1652 : //
; 1653 : // lpTask->bTrace = bOldTrace;
; 1654 : 
; 1655 :    zstrcpy( lpNetwork->szNetworkName, pchNetworkName );

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strcpy
	add	esp, 8

; 1656 :    zstrcpy( lpNetwork->szExecutable, pchExecutable );

	mov	edx, DWORD PTR _pchExecutable$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	call	_strcpy
	add	esp, 8

; 1657 :    lpNetwork->nConnCount     = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	WORD PTR [edx+148], cx

; 1658 :    lpNetwork->lProcessID     = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1659 :    lpNetwork->bListen        = FALSE;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR [edx+154]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	DWORD PTR [ecx+154], eax

; 1660 :    lpNetwork->pNetworkHandle = lpvNetHandle;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR _lpvNetHandle$[ebp]
	mov	DWORD PTR [edx+12], eax

; 1661 :    lpNetwork->hLibrary       = hLibrary;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 1662 :    lpNetwork->lpfnClose      = lpfnClose;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR _lpfnClose$[ebp]
	mov	DWORD PTR [eax+158], ecx

; 1663 :    lpNetwork->lpfnOpenConn   = lpfnOpenConn;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR _lpfnOpenConn$[ebp]
	mov	DWORD PTR [edx+178], eax

; 1664 :    lpNetwork->lpfnCloseConn  = lpfnCloseConn;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR _lpfnCloseConn$[ebp]
	mov	DWORD PTR [ecx+182], edx

; 1665 :    lpNetwork->lpfnSend       = lpfnSend;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR _lpfnSend$[ebp]
	mov	DWORD PTR [eax+170], ecx

; 1666 :    lpNetwork->lpfnReceive    = lpfnReceive;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR _lpfnReceive$[ebp]
	mov	DWORD PTR [edx+174], eax

; 1667 :    lpNetwork->lpfnListen     = lpfnListen;

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR _lpfnListen$[ebp]
	mov	DWORD PTR [ecx+162], edx

; 1668 :    lpNetwork->lpfnStopListen = lpfnStopListen;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR _lpfnStopListen$[ebp]
	mov	DWORD PTR [eax+166], ecx

; 1669 :    lpNetwork->lpfnGetAddress = lpfnGetAddress;

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	eax, DWORD PTR _lpfnGetAddress$[ebp]
	mov	DWORD PTR [edx+190], eax

; 1670 : 
; 1671 :    zsprintf( szGroup, "[%s]", pchNetworkName );

	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	push	OFFSET $SG14203
	lea	edx, DWORD PTR _szGroup$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1672 :    SysReadZeidonIni( -1, szGroup, "TraceLevel", szTraceLevel );

	lea	eax, DWORD PTR _szTraceLevel$[ebp]
	push	eax
	push	OFFSET $SG14204
	lea	ecx, DWORD PTR _szGroup$[ebp]
	push	ecx
	push	-1
	call	_SysReadZeidonIni@16

; 1673 :    lpNetwork->nTraceLevel = (zSHORT) zatol( szTraceLevel );

	lea	edx, DWORD PTR _szTraceLevel$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	WORD PTR [ecx+140], ax

; 1674 :    SysReadZeidonIni( -1, szGroup, "ServerCoreTraceLevel", szTraceLevel );

	lea	edx, DWORD PTR _szTraceLevel$[ebp]
	push	edx
	push	OFFSET $SG14205
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16

; 1675 :    lpNetwork->nServerCoreTraceLevel = (zSHORT) zatol( szTraceLevel );

	lea	ecx, DWORD PTR _szTraceLevel$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	WORD PTR [edx+142], ax

; 1676 :    SysReadZeidonIni( -1, szGroup, "ServerNetTraceLevel", szTraceLevel );

	lea	eax, DWORD PTR _szTraceLevel$[ebp]
	push	eax
	push	OFFSET $SG14206
	lea	ecx, DWORD PTR _szGroup$[ebp]
	push	ecx
	push	-1
	call	_SysReadZeidonIni@16

; 1677 :    lpNetwork->nServerNetTraceLevel = (zSHORT) zatol( szTraceLevel );

	lea	edx, DWORD PTR _szTraceLevel$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	WORD PTR [ecx+144], ax

; 1678 :    SysReadZeidonIni( -1, szGroup, "ServerDBHTraceLevel", szTraceLevel );

	lea	edx, DWORD PTR _szTraceLevel$[ebp]
	push	edx
	push	OFFSET $SG14207
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16

; 1679 :    lpNetwork->nServerDBHTraceLevel = (zSHORT) zatol( szTraceLevel );

	lea	ecx, DWORD PTR _szTraceLevel$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	mov	WORD PTR [edx+146], ax

; 1680 : 
; 1681 :    lpNetwork->hNextNetwork = AnchorBlock->hFirstNetwork;

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+122]
	mov	DWORD PTR [eax], edx

; 1682 :    AnchorBlock->hFirstNetwork = hNetwork;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hNetwork$[ebp]
	mov	DWORD PTR [eax+122], ecx

; 1683 : 
; 1684 :    zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4

; 1685 : 
; 1686 : #if 0
; 1687 :    // Following functions are NOT necessary.  Turn off tracing flag so we
; 1688 :    // don't show warning messages.
; 1689 :    bOldTrace = lpTask->bTrace;
; 1690 :    lpTask->bTrace = FALSE;
; 1691 : 
; 1692 :    lpNetwork->lpfnBufferEnd  = (zLPFN_NETCLCONN)
; 1693 :                                  SysGetProc( hLibrary, "zNetBufferEnd" );
; 1694 :    lpNetwork->lpfnSendPacket = (zLPFN_NETSENDPKT)
; 1695 :                                  SysGetProc( hLibrary, "zNetSendPacket" );
; 1696 :    lpNetwork->lpfnRecvPacket = (zLPFN_NETRECVPKT)
; 1697 :                                  SysGetProc( hLibrary, "zNetReceivePacket" );
; 1698 :    lpNetwork->lpfnSetMode    = (zLPFN_NETSETM)
; 1699 :                                  SysGetProc( hLibrary, "zNetSetMode" );
; 1700 : 
; 1701 :    lpTask->bTrace = bOldTrace;
; 1702 : #endif
; 1703 : 
; 1704 :    if ( lpNetwork->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpNetwork$[ebp]
	movsx	eax, WORD PTR [edx+140]
	test	eax, eax
	jle	SHORT $LN22@NetStartup

; 1705 :    {
; 1706 :       zCHAR szLocalName[ 300 ];
; 1707 : 
; 1708 :       NetGetLocalHostAddress( lpTaskView, pchNetworkName, szLocalName );

	lea	ecx, DWORD PTR _szLocalName$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_NetGetLocalHostAddress@12

; 1709 :       TraceLineS( "(kzoeneta) ** Local host address = ", szLocalName );

	lea	ecx, DWORD PTR _szLocalName$1[ebp]
	push	ecx
	push	OFFSET $SG14209
	call	_TraceLineS@8
$LN22@NetStartup:

; 1710 :    }
; 1711 : 
; 1712 :    //
; 1713 :    // Now load the server directory functions.
; 1714 :    //
; 1715 : 
; 1716 :    SysReadZeidonIni( -1, szGroup, "ServerDirApp", szServerDirApp );

	lea	edx, DWORD PTR _szServerDirApp$[ebp]
	push	edx
	push	OFFSET $SG14210
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16

; 1717 :    if ( szServerDirApp[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szServerDirApp$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN23@NetStartup

; 1718 :       strcpy( szServerDirApp, "zSimpDir" );

	push	OFFSET $SG14212
	lea	ecx, DWORD PTR _szServerDirApp$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN23@NetStartup:

; 1719 : 
; 1720 :    if ( zstrchr( szServerDirApp, cDirSep ) == 0 )

	movsx	edx, BYTE PTR _cDirSep
	push	edx
	lea	eax, DWORD PTR _szServerDirApp$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN24@NetStartup

; 1721 :    {
; 1722 :       SysGetLocalDirectory( lpNetwork->szFileName );

	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 222				; 000000deH
	push	ecx
	call	_SysGetLocalDirectory@4

; 1723 :       zstrcat( lpNetwork->szFileName, szServerDirApp );

	lea	edx, DWORD PTR _szServerDirApp$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNetwork$[ebp]
	add	eax, 222				; 000000deH
	push	eax
	call	_strcat
	add	esp, 8

; 1724 :    }

	jmp	SHORT $LN25@NetStartup
$LN24@NetStartup:

; 1725 :    else
; 1726 :       zstrcpy( lpNetwork->szFileName, szServerDirApp );

	lea	ecx, DWORD PTR _szServerDirApp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNetwork$[ebp]
	add	edx, 222				; 000000deH
	push	edx
	call	_strcpy
	add	esp, 8
$LN25@NetStartup:

; 1727 : 
; 1728 :    // Try loading the library.
; 1729 :    if ( LoadNetworkOperations( (LPTASK) zGETPTR( lpTaskView->hTask ),
; 1730 :                                lpNetwork ) == 0 )

	mov	eax, DWORD PTR _lpNetwork$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_LoadNetworkOperations
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN26@NetStartup

; 1731 :    {
; 1732 :       (*lpNetwork->lpfnServDirInit)( lpTask, pchNetworkName,

	push	0
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNetwork$[ebp]
	mov	edx, DWORD PTR [ecx+210]
	call	edx

; 1733 :                                      &lpNetwork->pvServDirData, 0 );
; 1734 :    }

	jmp	SHORT $LN27@NetStartup
$LN26@NetStartup:

; 1735 :    else
; 1736 :    {
; 1737 :       NetClose( lpTaskView, pchNetworkName );

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_NetClose@8

; 1738 :       fnOperationReturn( iNetStartup, lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1739 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@NetStartup
$LN27@NetStartup:

; 1740 :    }
; 1741 : 
; 1742 :    fnOperationReturn( iNetStartup, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	507					; 000001fbH
	call	_fnOperationReturn
	add	esp, 8

; 1743 :    return( 0 );

	xor	eax, eax
$LN1@NetStartup:

; 1744 : 
; 1745 : } // NetStartup

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_NetStartup@12 ENDP
_TEXT	ENDS
END
