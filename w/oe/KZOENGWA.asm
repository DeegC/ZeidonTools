; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\w\oe\KZOENGWA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_g_uTraceLineLimit
PUBLIC	_g_chScrollTrace
PUBLIC	_g_chTraceOE_Warning
PUBLIC	_g_chTraceZDrActions
PUBLIC	_g_chTraceWebActions
PUBLIC	_g_chTraceMemory
PUBLIC	_g_chPrintPreview
PUBLIC	_g_chPrintDialog
PUBLIC	_g_wOENG_Message
PUBLIC	_szClassName
PUBLIC	_szThreadClassName
PUBLIC	_g_szTimeStamp
PUBLIC	_g_lTimeOut
PUBLIC	_g_uIdleTimerId
PUBLIC	_g_uKillTimerId
PUBLIC	_g_nIdIdleEvt
PUBLIC	_g_nIdKillEvt
PUBLIC	_g_hLogFile
PUBLIC	_szZeidonParmName
PUBLIC	_szLogFileName
PUBLIC	_szlWorkstation
PUBLIC	_szlUserID
PUBLIC	_szlPassword
PUBLIC	_szlINTL
PUBLIC	_szPlaceFormat
PUBLIC	_szMark
PUBLIC	_g_lMark
PUBLIC	_g_vSystemTaskView
PUBLIC	_g_bThreadStarted
PUBLIC	_AnchorBlock
_BSS	SEGMENT
$SG96384 DB	01H DUP (?)
	ALIGN	4

$SG96385 DB	01H DUP (?)
	ALIGN	4

$SG96443 DB	01H DUP (?)
	ALIGN	4

$SG96646 DB	01H DUP (?)
	ALIGN	4

$SG96651 DB	01H DUP (?)
	ALIGN	4

$SG96654 DB	01H DUP (?)
	ALIGN	4

$SG96658 DB	01H DUP (?)
	ALIGN	4

$SG96663 DB	01H DUP (?)
	ALIGN	4

$SG96667 DB	01H DUP (?)
	ALIGN	4

$SG96671 DB	01H DUP (?)
	ALIGN	4

$SG96675 DB	01H DUP (?)
	ALIGN	4

$SG96679 DB	01H DUP (?)
	ALIGN	4

$SG96683 DB	01H DUP (?)
	ALIGN	4

$SG96686 DB	01H DUP (?)
	ALIGN	4

$SG96689 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_hInst:DWORD
COMM	_g_hWndMainFrame:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

_g_chScrollTrace DB 01H DUP (?)
	ALIGN	4

_g_chTraceOE_Warning DB 01H DUP (?)
	ALIGN	4

_g_chTraceZDrActions DB 01H DUP (?)
	ALIGN	4

_g_chTraceWebActions DB 01H DUP (?)
	ALIGN	4

_g_chTraceMemory DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_szZeidonEnvDirectory:BYTE:0105H
COMM	_g_szFindString:BYTE:0100H
COMM	_g_szCopyBuffer:BYTE:0200H
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

_g_chPrintPreview DB 01H DUP (?)
	ALIGN	4

_g_chPrintDialog DB 01H DUP (?)
	ALIGN	4

_g_wOENG_Message DD 01H DUP (?)
_g_szTimeStamp DB 014H DUP (?)
_g_lTimeOut DD	01H DUP (?)
_g_uIdleTimerId DD 01H DUP (?)
_g_uKillTimerId DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_hWndLB:DWORD
COMM	_g_hwndTraceWindow:DWORD:014H
COMM	_g_nTraceWindowCnt:DWORD
COMM	_g_nTraceWindowHead:DWORD
COMM	_g_nTraceWindowDisplayed:DWORD
COMM	_fpAbout:DWORD
COMM	_fpLogon:DWORD
COMM	_fpSetTrace:DWORD
COMM	_fpLogTrace:DWORD
COMM	_fpTraceList:DWORD
COMM	_fpLineLimit:DWORD
COMM	_fpFindString:DWORD
COMM	_fpShowDLL:DWORD
COMM	_fpSqlServerErrHandler:DWORD
COMM	_fpSqlServerMsgHandler:DWORD
COMM	_fpDfltListWndProc:DWORD
_DATA	ENDS
_BSS	SEGMENT
_szLogFileName DB 0100H DUP (?)
_g_lMark DD	01H DUP (?)
_g_vSystemTaskView DD 01H DUP (?)
_g_bThreadStarted DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_hThread:DWORD
COMM	_g_dwThreadID:DWORD
COMM	_g_hThreadWnd:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG96971 DB	01H DUP (?)
	ALIGN	4

$SG96033 DB	01H DUP (?)
	ALIGN	4

_AnchorBlock DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_szZeidonParmName DB 'ZEIDON', 00H
CONST	ENDS
_DATA	SEGMENT
$SG96279 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96280 DB	'Wrap to continue search?', 00H
	ORG $+3
$SG96286 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96287 DB	'Wrap to continue search?', 00H
	ORG $+3
$SG96289 DB	'Search string not found - ', 00H
	ORG $+1
$SG96290 DB	'Zeidon Object Engine', 00H
	ORG $+3
$SG96328 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96331 DB	'KillZeidon', 00H
	ORG $+1
$SG96329 DB	'Zeidon Applications are still active.', 0aH, 'If you con'
	DB	'tinue, you will lose unsaved data.', 0aH, 'Do you still want '
	DB	'to kill Zeidon?', 00H
	ORG $+3
$SG96332 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96338 DB	'(wa) nCountry :    ', 00H
$SG96339 DB	'(wa) lpCountry :   ', 00H
$SG96340 DB	'(wa) lpLanguage :  ', 00H
$SG96341 DB	'(wa) lpList :      ', 00H
$SG96342 DB	'(wa) nMeasure :    ', 00H
$SG96343 DB	'(wa) nTime :       ', 00H
$SG96344 DB	'(wa) lpTime :      ', 00H
$SG96345 DB	'(wa) lp1159 :      ', 00H
$SG96346 DB	'(wa) lp2359 :      ', 00H
$SG96347 DB	'(wa) nTLZero :     ', 00H
$SG96348 DB	'(wa) lpShortDate : ', 00H
$SG96349 DB	'(wa) lpLongDate :  ', 00H
$SG96350 DB	'(wa) lpTimeFmt :   ', 00H
$SG96351 DB	'(wa) lpCurrency :  ', 00H
$SG96352 DB	'(wa) nCurrency :   ', 00H
$SG96353 DB	'(wa) nCurrDigits : ', 00H
$SG96354 DB	'(wa) nNegCurr :    ', 00H
$SG96355 DB	'(wa) lpThousand :  ', 00H
$SG96356 DB	'(wa) lpDecimal :   ', 00H
$SG96357 DB	'(wa) nDigits :     ', 00H
$SG96358 DB	'(wa) nLZero :      ', 00H
$SG96359 DB	'is available', 00H
	ORG $+3
$SG96360 DB	'(wa) No international information ', 00H
	ORG $+1
$SG96378 DB	'Anchor Block  Alloc: ', 00H
	ORG $+2
$SG96379 DB	'   Used: ', 00H
	ORG $+2
$SG96380 DB	'   Free: ', 00H
	ORG $+2
$SG96381 DB	'ListTasks:', 00H
	ORG $+1
$SG96386 DB	' Page table info - ', 00H
$SG96390 DB	'Application:''', 00H
	ORG $+2
$SG96392 DB	'''', 00H
	ORG $+2
$SG96393 DB	'   View Object:''', 00H
	ORG $+3
$SG96395 DB	'''', 00H
	ORG $+2
$SG96431 DB	'LogFile', 00H
$SG96442 DB	'\zeidon.ini', 00H
$SG96402 DB	'OE Setting Idle Timer for hWnd: 0x%08x   g_hWndMainFrame'
	DB	': 0x%08x  Id: %d', 00H
	ORG $+3
$SG96433 DB	'KZOENGWA - Termination', 00H
	ORG $+1
$SG96441 DB	'ZEIDON', 00H
	ORG $+1
$SG96444 DB	'LocalDir', 00H
	ORG $+3
$SG96445 DB	'Workstation', 00H
$SG96448 DB	'ZeidonRT.ini', 00H
	ORG $+3
$SG96449 DB	'WindowPos', 00H
	ORG $+2
$SG96450 DB	'ObjectEngine', 00H
	ORG $+3
$SG96451 DB	'LineLimit', 00H
	ORG $+2
$SG96452 DB	'ObjectEngine', 00H
	ORG $+3
$SG96453 DB	'FindString', 00H
	ORG $+1
$SG96454 DB	'ObjectEngine', 00H
	ORG $+3
$SG96455 DB	'ScrollTrace', 00H
$SG96456 DB	'ObjectEngine', 00H
	ORG $+3
$SG96457 DB	'PrintPreview', 00H
	ORG $+3
$SG96458 DB	'ObjectEngine', 00H
	ORG $+3
$SG96459 DB	'PrintDialog', 00H
$SG96460 DB	'ObjectEngine', 00H
	ORG $+3
$SG96461 DB	'TraceOE_Warning', 00H
$SG96462 DB	'ObjectEngine', 00H
	ORG $+3
$SG96463 DB	'TraceAction', 00H
$SG96464 DB	'ObjectEngine', 00H
	ORG $+3
$SG96465 DB	'TraceWeb', 00H
	ORG $+3
$SG96466 DB	'ObjectEngine', 00H
	ORG $+3
$SG96469 DB	'ShowTaskID', 00H
	ORG $+1
$SG96470 DB	'ObjectEngine', 00H
	ORG $+3
$SG96473 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96490 DB	'(wa) changing international info - ', 00H
$SG96474 DB	'Zeidon Applications are still active.', 0aH, 'Do you sti'
	DB	'll want to shut down?', 00H
	ORG $+2
$SG96477 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96478 DB	'Zeidon Applications are still active.', 0aH, 'Do you wis'
	DB	'h to try and close them?', 00H
	ORG $+3
$SG96492 DB	'%04d%02d%02d%02d%02d%02d.log', 00H
	ORG $+3
$SG96495 DB	'(ng) Log file Opened ''', 00H
	ORG $+1
$SG96496 DB	'''', 00H
	ORG $+2
$SG96530 DB	'ZEIDON', 00H
	ORG $+1
$SG96620 DB	'KZOENGWA', 00H
	ORG $+3
$SG96621 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96623 DB	'Trace Window', 00H
	ORG $+3
$SG96624 DB	'ListBox', 00H
$SG96626 DB	'ZEIDON', 00H
	ORG $+1
$SG96627 DB	'ZEIDON', 00H
	ORG $+1
$SG96628 DB	'\zeidon.ini', 00H
$SG96629 DB	'TraceWindows', 00H
	ORG $+3
$SG96630 DB	'ObjectEngine', 00H
	ORG $+3
$SG96634 DB	'Trace Window', 00H
	ORG $+3
$SG96635 DB	'ListBox', 00H
$SG96636 DB	'KZOESRVC', 00H
	ORG $+3
$SG96640 DB	'----Zeidon configuration file: ', 00H
$SG96641 DB	'LocalDir', 00H
	ORG $+3
$SG96644 DB	'ZeidonRT.ini', 00H
	ORG $+3
$SG96645 DB	'--LocalDir configuration file: ', 00H
$SG96647 DB	'LineLimit', 00H
	ORG $+2
$SG96648 DB	'ObjectEngine', 00H
	ORG $+3
$SG96652 DB	'FindString', 00H
	ORG $+1
$SG96653 DB	'ObjectEngine', 00H
	ORG $+3
$SG96655 DB	'ScrollTrace', 00H
$SG96656 DB	'ObjectEngine', 00H
	ORG $+3
$SG96659 DB	'PrintPreview', 00H
	ORG $+3
$SG96660 DB	'ObjectEngine', 00H
	ORG $+3
$SG96664 DB	'PrintDialog', 00H
$SG96665 DB	'ObjectEngine', 00H
	ORG $+3
$SG96668 DB	'TraceOE_Warning', 00H
$SG96669 DB	'ObjectEngine', 00H
	ORG $+3
$SG96672 DB	'TraceAction', 00H
$SG96673 DB	'ObjectEngine', 00H
	ORG $+3
$SG96676 DB	'TraceWeb', 00H
	ORG $+3
$SG96677 DB	'ObjectEngine', 00H
	ORG $+3
$SG96680 DB	'ShowTaskID', 00H
	ORG $+1
$SG96681 DB	'ObjectEngine', 00H
	ORG $+3
$SG96684 DB	'ShowOpenFile', 00H
	ORG $+3
$SG96685 DB	'ObjectEngine', 00H
	ORG $+3
$SG96687 DB	'ShowOI_Times', 00H
	ORG $+3
$SG96688 DB	'ObjectEngine', 00H
	ORG $+3
$SG96690 DB	'ShowTaskMsgs', 00H
	ORG $+3
$SG96691 DB	'ObjectEngine', 00H
	ORG $+3
$SG96692 DB	'LineLimit', 00H
	ORG $+2
$SG96693 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96696 DB	'FindString', 00H
	ORG $+1
$SG96697 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96698 DB	'ScrollTrace', 00H
$SG96699 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96701 DB	'PrintPreview', 00H
	ORG $+3
$SG96702 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96705 DB	'PrintDialog', 00H
$SG96706 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96708 DB	'TraceOE_Warning', 00H
$SG96709 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96711 DB	'TraceAction', 00H
$SG96712 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96714 DB	'TraceWeb', 00H
	ORG $+3
$SG96715 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96717 DB	'ShowTaskID', 00H
	ORG $+1
$SG96718 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96720 DB	'ShowOpenFile', 00H
	ORG $+3
$SG96721 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96722 DB	'ShowOI_Times', 00H
	ORG $+3
$SG96723 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96724 DB	'ShowTaskMsgs', 00H
	ORG $+3
$SG96725 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96726 DB	'WindowStartup', 00H
	ORG $+2
$SG96727 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96730 DB	'Hidden', 00H
	ORG $+1
$SG96733 DB	'SysTray', 00H
$SG96738 DB	'DropEngineIfNoTasks', 00H
$SG96739 DB	'ObjectEngine', 00H
	ORG $+3
$SG96742 DB	'NETAPI', 00H
	ORG $+1
$SG96744 DB	'NetWkstaGetInfo', 00H
$SG96749 DB	'Encrypted', 00H
	ORG $+2
$SG96754 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG96756 DB	'KZDBHWOB', 00H
	ORG $+3
$SG96757 DB	'ROOT', 00H
	ORG $+3
$SG96758 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG96759 DB	'StartMessage', 00H
	ORG $+3
$SG96760 DB	'[Debug]', 00H
$SG96762 DB	'Object Engine Start Message', 00H
$SG96834 DB	'(kzoengwa) DBH Trace Level for all tasks set to ', 00H
	ORG $+3
_g_uTraceLineLimit DD 0fa0H
_szClassName DB	'KZOENGWAWClass', 00H
	ORG $+1
_szThreadClassName DB 'KZOENGWAW_Thread_Class', 00H
	ORG $+1
_g_nIdIdleEvt DD 0eH
_g_nIdKillEvt DD 0fH
$SG96922 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96923 DB	'Error opening trace file!', 00H
	ORG $+2
$SG96924 DB	'(ng) Log file Opened ''', 00H
	ORG $+1
$SG96925 DB	'''', 00H
	ORG $+2
$SG96928 DB	'(ng) End of Log', 00H
$SG96935 DB	'LogFile', 00H
_g_hLogFile DD	0ffffffffH
_szlWorkstation DB '[Workstation]', 00H
	ORG $+2
$SG96939 DB	'\', 00H
	ORG $+2
_szlUserID DB	'UserID', 00H
	ORG $+1
$SG96940 DB	'ZEIDON00.LOG', 00H
	ORG $+3
_szlPassword DB	'Password', 00H
	ORG $+3
_szlINTL DB	'Intl', 00H
	ORG $+3
_szPlaceFormat DB '%u,%u,%d,%d,%d,%d,%d,%d,%d,%d', 00H
	ORG $+2
$SG95942 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG96967 DB	'LocalDir', 00H
	ORG $+3
_szMark	DB	'|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-'
	DB	'|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|', 00H
$SG96970 DB	'ZeidonRT.ini', 00H
	ORG $+3
$SG96972 DB	'WindowPos', 00H
	ORG $+2
$SG96973 DB	'ObjectEngine', 00H
	ORG $+3
$SG96974 DB	'WindowPos', 00H
	ORG $+2
$SG96975 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG95966 DB	'OE Setting Kill Timer for hWnd: 0x%08x   g_hWndMainFrame'
	DB	': 0x%08x  Id: %d', 00H
	ORG $+3
$SG95967 DB	'Zencas Timeout', 00H
	ORG $+1
$SG95972 DB	'KillZeidon', 00H
	ORG $+1
$SG95968 DB	'Due to inactivity, your Zencas session will', 0aH, 'be t'
	DB	'imed out in one minute. Click OK if you', 0aH, 'want to conti'
	DB	'nue using Zencas.', 00H
	ORG $+1
$SG95973 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG95974 DB	'KillZeidon: ', 00H
	ORG $+3
$SG95976 DB	'KillZeidon: ', 00H
	ORG $+3
$SG97020 DB	'ZEIDON', 00H
	ORG $+1
$SG96023 DB	'KZOENGWA - INIT', 00H
$SG96024 DB	'Can''t create init mutex', 00H
$SG96025 DB	'Zeidon Object Engine', 00H
	ORG $+3
$SG96027 DB	'KZOENGWA - INIT 2!!!', 00H
	ORG $+3
$SG96028 DB	'Only one instance of KZOENGWA can exist at once.', 00H
	ORG $+3
$SG96029 DB	'Zeidon Object Engine', 00H
	ORG $+3
$SG96030 DB	'KZOENGWA - INIT 2!!!', 00H
	ORG $+3
$SG96034 DB	'Engine started for Win32', 00H
	ORG $+3
$SG96035 DB	'TRACE_ACCEL', 00H
$SG96038 DB	'Zeidon - Object Services Init', 00H
	ORG $+2
$SG96039 DB	'TimeOut', 00H
$SG96040 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96042 DB	'KillZeidon', 00H
	ORG $+1
$SG96043 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG96046 DB	'Object Services', 00H
$SG96047 DB	'TimeOut requires KillZeidon specification', 00H
_DATA	ENDS
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_InitInstance
PUBLIC	_InitApplication
PUBLIC	_MainWndProc@16
PUBLIC	_AboutDlgProc@16
PUBLIC	_LogonDlgProc@16
PUBLIC	_SetTraceDlgProc@16
PUBLIC	_LimitDlgProc@16
PUBLIC	_FindStringDlgProc@16
PUBLIC	_ShowDLLDlgProc@16
PUBLIC	_TraceListWndProc@16
PUBLIC	_LogTraceDlgProc@16
PUBLIC	_fnProcessOENG_Message
PUBLIC	_TrayMessage
PUBLIC	_SetupSysTray
PUBLIC	_DetachSysTray
PUBLIC	_HandlePopupMenu@12
PUBLIC	_ReadWindowPlacement
PUBLIC	_CheckWindowPos
PUBLIC	_fnThreadProc@4
PUBLIC	_MainThrdWndProc@16
PUBLIC	_WriteTraceToLog
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_isspace:PROC
EXTRN	_toupper:PROC
EXTRN	_memset:PROC
EXTRN	_strchr:PROC
EXTRN	_strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	_stricmp:PROC
EXTRN	__imp__GetEnvironmentVariableA@12:PROC
EXTRN	__imp__SetEnvironmentVariableA@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__WinExec@8:PROC
EXTRN	__imp__lstrcpynA@12:PROC
EXTRN	__imp__OpenMutexA@12:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__WritePrivateProfileStringA@16:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__GetTextMetricsA@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__MoveWindow@24:PROC
EXTRN	__imp__GetWindowPlacement@8:PROC
EXTRN	__imp__SetWindowPlacement@8:PROC
EXTRN	__imp__IsWindowVisible@4:PROC
EXTRN	__imp__DialogBoxParamA@20:PROC
EXTRN	__imp__EndDialog@8:PROC
EXTRN	__imp__GetDlgItem@8:PROC
EXTRN	__imp__SetDlgItemInt@16:PROC
EXTRN	__imp__GetDlgItemInt@16:PROC
EXTRN	__imp__SetDlgItemTextA@12:PROC
EXTRN	__imp__GetDlgItemTextA@16:PROC
EXTRN	__imp__SendDlgItemMessageA@20:PROC
EXTRN	__imp__SetFocus@4:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
EXTRN	__imp__SetTimer@16:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__EnableWindow@8:PROC
EXTRN	__imp__LoadAcceleratorsA@8:PROC
EXTRN	__imp__TranslateAcceleratorA@12:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__LoadMenuA@8:PROC
EXTRN	__imp__GetMenu@4:PROC
EXTRN	__imp__SetMenu@8:PROC
EXTRN	__imp__DrawMenuBar@4:PROC
EXTRN	__imp__DestroyMenu@4:PROC
EXTRN	__imp__CheckMenuItem@12:PROC
EXTRN	__imp__EnableMenuItem@12:PROC
EXTRN	__imp__GetSubMenu@8:PROC
EXTRN	__imp__RemoveMenu@12:PROC
EXTRN	__imp__DeleteMenu@12:PROC
EXTRN	__imp__TrackPopupMenu@28:PROC
EXTRN	__imp__SetActiveWindow@4:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__GetDC@4:PROC
EXTRN	__imp__ReleaseDC@8:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__MessageBeep@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__DestroyIcon@4:PROC
EXTRN	__imp__Shell_NotifyIconA@8:PROC
EXTRN	_atoi:PROC
EXTRN	_atol:PROC
EXTRN	__ltoa:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_SysDescribeZeidonPageTable@4:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_DisplayOpenFiles@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_MiListOE_Memory@8:PROC
EXTRN	_UfEncryptString@12:PROC
EXTRN	_UfDecryptString@12:PROC
EXTRN	_SysMutexQueryStatus@0:PROC
EXTRN	_ProcessZeidonMessage@8:PROC
EXTRN	_SysAppendcDirSep@4:PROC
EXTRN	_fnSysCloseFile@12:PROC
EXTRN	_SysConvertEnvironmentString@8:PROC
EXTRN	_SysGetDateTime@4:PROC
EXTRN	_SysGetDateTimeDifference@16:PROC
EXTRN	_SysGetHandleFromPointer@4:PROC
EXTRN	_SysGetPointerFromHandle@4:PROC
EXTRN	_SysGetUserID@12:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysMessageList@4:PROC
EXTRN	_fnSysOpenFile@12:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysSetUserID@12:PROC
EXTRN	_SysTranslateString@8:PROC
EXTRN	_SysUpdateZeidonIni@12:PROC
EXTRN	_fnSysWriteLine@16:PROC
EXTRN	_SfStartNetworks@8:PROC
EXTRN	_SfActivateSysEmptyOI@16:PROC
EXTRN	_SfAllocTaskMemory@12:PROC
EXTRN	_SfFreeTaskMemory@4:PROC
EXTRN	_SfLockView@4:PROC
EXTRN	_GetTracingFlags@0:PROC
EXTRN	_InitializeAnchorBlock@16:PROC
EXTRN	_FreeAnchorBlock@4:PROC
EXTRN	_SysCreateInternational@0:PROC
EXTRN	_SysFreeInternational@4:PROC
EXTRN	__beginthreadex:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_ppvFile$ = -536					; size = 4
_wItemCnt$ = -532					; size = 2
_k$ = -528						; size = 4
_idx$ = -524						; size = 2
_wItem$ = -520						; size = 2
_szTraceText$ = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_WriteTraceToLog PROC

; 626  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 627  :    char   szTraceText[ 512 ];
; 628  :    zPVOID ppvFile = 0;

	mov	DWORD PTR _ppvFile$[ebp], 0

; 629  :    zSHORT idx;
; 630  :    WORD   wItem;
; 631  :    WORD   wItemCnt;
; 632  :    UINT   k;
; 633  : 
; 634  :    // The file has been opened, get all text from all the
; 635  :    // list boxes and write it to the trace file
; 636  :    for ( k = 0; k < g_nTraceWindowCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@WriteTrace
$LN2@WriteTrace:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@WriteTrace:
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _g_nTraceWindowCnt
	jae	$LN1@WriteTrace

; 637  :    {
; 638  :       idx = (g_nTraceWindowHead + k + 1) % g_nTraceWindowCnt;

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _g_nTraceWindowHead
	lea	eax, DWORD PTR [eax+edx+1]
	xor	edx, edx
	div	DWORD PTR _g_nTraceWindowCnt
	mov	WORD PTR _idx$[ebp], dx

; 639  :       wItemCnt = (WORD) SendMessage( g_hwndTraceWindow[ idx ],

	push	0
	push	0
	push	395					; 0000018bH
	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wItemCnt$[ebp], ax

; 640  :                                      LB_GETCOUNT, 0, 0L );
; 641  :       for ( wItem = 0; wItem < wItemCnt; wItem++ )

	xor	eax, eax
	mov	WORD PTR _wItem$[ebp], ax
	jmp	SHORT $LN7@WriteTrace
$LN5@WriteTrace:
	mov	cx, WORD PTR _wItem$[ebp]
	add	cx, 1
	mov	WORD PTR _wItem$[ebp], cx
$LN7@WriteTrace:
	movzx	edx, WORD PTR _wItem$[ebp]
	movzx	eax, WORD PTR _wItemCnt$[ebp]
	cmp	edx, eax
	jge	SHORT $LN6@WriteTrace

; 642  :       {
; 643  :          SendMessage( g_hwndTraceWindow[ idx ], LB_GETTEXT, wItem,

	lea	ecx, DWORD PTR _szTraceText$[ebp]
	push	ecx
	movzx	edx, WORD PTR _wItem$[ebp]
	push	edx
	push	393					; 00000189H
	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 644  :                       (LONG)(LPSTR) szTraceText );
; 645  :          fnSysWriteLine( lpTask, g_hLogFile, &ppvFile, szTraceText );

	lea	edx, DWORD PTR _szTraceText$[ebp]
	push	edx
	lea	eax, DWORD PTR _ppvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_hLogFile
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 646  :       }

	jmp	SHORT $LN5@WriteTrace
$LN6@WriteTrace:

; 647  :    }

	jmp	$LN2@WriteTrace
$LN1@WriteTrace:

; 648  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_WriteTraceToLog ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_nRC$1 = -560						; size = 4
_lDiffSeconds$2 = -556					; size = 4
_uIdTimer$3 = -552					; size = 4
tv64 = -548						; size = 4
_szTempName$4 = -544					; size = 257
_szFileName$5 = -284					; size = 257
_szDateTime$6 = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainThrdWndProc@16 PROC

; 290  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 560				; 00000230H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 291  :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	ja	SHORT $LN17@MainThrdWn
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	$LN13@MainThrdWn
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN4@MainThrdWn
	cmp	DWORD PTR tv64[ebp], 16			; 00000010H
	je	$LN12@MainThrdWn
	jmp	$LN14@MainThrdWn
$LN17@MainThrdWn:
	cmp	DWORD PTR tv64[ebp], 275		; 00000113H
	je	SHORT $LN5@MainThrdWn
	jmp	$LN14@MainThrdWn
$LN4@MainThrdWn:

; 292  :    {
; 293  :       case WM_DESTROY:                // message: window being destroyed
; 294  :          PostQuitMessage( 0 );

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 295  :          break;

	jmp	$LN2@MainThrdWn
$LN5@MainThrdWn:

; 296  : 
; 297  :       case WM_TIMER:
; 298  :       {
; 299  :          zCHAR szFileName[ zMAX_FILENAME_LTH + 1 ];
; 300  :          zCHAR szTempName[ zMAX_FILENAME_LTH + 1 ];
; 301  :          UINT uIdTimer = wParam;

	mov	ecx, DWORD PTR _wParam$[ebp]
	mov	DWORD PTR _uIdTimer$3[ebp], ecx

; 302  : 
; 303  :       // TraceLine( "WM_TIMER !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! %d  Wnd: 0x%08x", uIdTimer, hWnd );
; 304  : 
; 305  :          if ( uIdTimer == g_uIdleTimerId )

	mov	edx, DWORD PTR _uIdTimer$3[ebp]
	cmp	edx, DWORD PTR _g_uIdleTimerId
	jne	$LN6@MainThrdWn

; 306  :          {
; 307  :             zLONG lDiffSeconds;
; 308  :             zCHAR szDateTime[ 20 ];
; 309  : 
; 310  :          // TraceLine( "App idle for count %d", lCount );
; 311  : 
; 312  :             SysGetDateTime( szDateTime );

	lea	eax, DWORD PTR _szDateTime$6[ebp]
	push	eax
	call	_SysGetDateTime@4

; 313  :             SysGetDateTimeDifference( &lDiffSeconds,

	push	5
	lea	ecx, DWORD PTR _szDateTime$6[ebp]
	push	ecx
	push	OFFSET _g_szTimeStamp
	lea	edx, DWORD PTR _lDiffSeconds$2[ebp]
	push	edx
	call	_SysGetDateTimeDifference@16

; 314  :                                       g_szTimeStamp,
; 315  :                                       szDateTime, zDT_SECOND );
; 316  :             if ( g_uKillTimerId == 0 && lDiffSeconds > g_lTimeOut )

	cmp	DWORD PTR _g_uKillTimerId, 0
	jne	$LN7@MainThrdWn
	mov	eax, DWORD PTR _lDiffSeconds$2[ebp]
	cmp	eax, DWORD PTR _g_lTimeOut
	jle	$LN7@MainThrdWn

; 317  :             {
; 318  :                int nRC;
; 319  : 
; 320  :                TraceLine( "OE Setting Kill Timer for hWnd: 0x%08x   g_hWndMainFrame: 0x%08x  Id: %d",

	mov	ecx, DWORD PTR _g_nIdKillEvt
	push	ecx
	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	OFFSET $SG95966
	call	_TraceLine
	add	esp, 16					; 00000010H

; 321  :                           hWnd, g_hWndMainFrame, g_nIdKillEvt );
; 322  :                g_uKillTimerId = SetTimer( hWnd, g_nIdKillEvt,

	push	0
	push	60000					; 0000ea60H
	mov	ecx, DWORD PTR _g_nIdKillEvt
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__SetTimer@16
	mov	DWORD PTR _g_uKillTimerId, eax

; 323  :                                           60000, 0 );  // 60000 ==> one minute
; 324  :                nRC = MessageBox( hWnd, "Due to inactivity, your Zencas session will\n"

	push	262160					; 00040010H
	push	OFFSET $SG95967
	push	OFFSET $SG95968
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
	mov	DWORD PTR _nRC$1[ebp], eax

; 325  :                                    "be timed out in one minute. Click OK if you\n"
; 326  :                                    "want to continue using Zencas.",
; 327  :                                  "Zencas Timeout", MB_OK | MB_ICONSTOP | MB_TOPMOST | MB_APPLMODAL );
; 328  :                if ( nRC == IDOK )

	cmp	DWORD PTR _nRC$1[ebp], 1
	jne	SHORT $LN7@MainThrdWn

; 329  :                {
; 330  :                   if ( g_uKillTimerId )

	cmp	DWORD PTR _g_uKillTimerId, 0
	je	SHORT $LN9@MainThrdWn

; 331  :                   {
; 332  :                      KillTimer( hWnd, g_uKillTimerId );

	mov	ecx, DWORD PTR _g_uKillTimerId
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__KillTimer@8

; 333  :                      g_uKillTimerId = 0;

	mov	DWORD PTR _g_uKillTimerId, 0
$LN9@MainThrdWn:

; 334  :                   }
; 335  : 
; 336  :                   SysGetDateTime( g_szTimeStamp );

	push	OFFSET _g_szTimeStamp
	call	_SysGetDateTime@4
$LN7@MainThrdWn:

; 337  :                }
; 338  :             }
; 339  : 
; 340  :             return( 0 );  // an application should return zero if it processes this message

	xor	eax, eax
	jmp	$LN1@MainThrdWn
$LN6@MainThrdWn:

; 341  :          }
; 342  : 
; 343  :          if ( uIdTimer == g_uKillTimerId )

	mov	eax, DWORD PTR _uIdTimer$3[ebp]
	cmp	eax, DWORD PTR _g_uKillTimerId
	jne	$LN10@MainThrdWn

; 344  :          {
; 345  :             KillTimer( g_hWndMainFrame, g_uKillTimerId );

	mov	ecx, DWORD PTR _g_uKillTimerId
	push	ecx
	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	call	DWORD PTR __imp__KillTimer@8

; 346  :             g_uKillTimerId = 0;

	mov	DWORD PTR _g_uKillTimerId, 0

; 347  : 
; 348  :             SysReadZeidonIni( -1, "[ObjectEngine]", "KillZeidon", szTempName );

	lea	eax, DWORD PTR _szTempName$4[ebp]
	push	eax
	push	OFFSET $SG95972
	push	OFFSET $SG95973
	push	-1
	call	_SysReadZeidonIni@16

; 349  :             SysConvertEnvironmentString( szFileName, szTempName );

	lea	ecx, DWORD PTR _szTempName$4[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$5[ebp]
	push	edx
	call	_SysConvertEnvironmentString@8

; 350  :             TraceLineS( "KillZeidon: ", szFileName );

	lea	eax, DWORD PTR _szFileName$5[ebp]
	push	eax
	push	OFFSET $SG95974
	call	_TraceLineS@8

; 351  :             if ( szFileName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szFileName$5[ebp+edx]
	test	eax, eax
	je	SHORT $LN11@MainThrdWn

; 352  :             {
; 353  :                TraceLineS( "KillZeidon: ", szFileName );

	lea	ecx, DWORD PTR _szFileName$5[ebp]
	push	ecx
	push	OFFSET $SG95976
	call	_TraceLineS@8

; 354  :                Sleep( 5000 );

	push	5000					; 00001388H
	call	DWORD PTR __imp__Sleep@4

; 355  :                WinExec( szFileName, SW_SHOWNORMAL );

	push	1
	lea	edx, DWORD PTR _szFileName$5[ebp]
	push	edx
	call	DWORD PTR __imp__WinExec@8
$LN11@MainThrdWn:

; 356  :             }
; 357  : 
; 358  :             return( 0 );  // an application should return zero if it processes this message

	xor	eax, eax
	jmp	SHORT $LN1@MainThrdWn
$LN10@MainThrdWn:

; 359  :          }
; 360  : 
; 361  :          return( 1 ); // we did not process the timer message

	mov	eax, 1
	jmp	SHORT $LN1@MainThrdWn
$LN12@MainThrdWn:

; 362  :       }
; 363  : 
; 364  :       case WM_CLOSE:
; 365  :          PostMessage( g_hWndMainFrame, WM_CLOSE, 0, 0 );

	push	0
	push	0
	push	16					; 00000010H
	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	call	DWORD PTR __imp__PostMessageA@16

; 366  :          return( 0 ); // do not call DefWindProc

	xor	eax, eax
	jmp	SHORT $LN1@MainThrdWn
$LN13@MainThrdWn:

; 367  :                       // Hartmut:
; 368  :                       // I think, I solved the problem.  It is triggered
; 369  :                       // by "DropEngineIfNoTasks".  The invisible
; 370  :                       // "Thread Main Window" gets WM_CLOSE and promotes
; 371  :                       // the WM_CLOSE to the visible main window.  It
; 372  :                       // should NOT call DefWndProc (which sends
; 373  :                       // WM_DESTROY), which causes the problem of
; 374  :                       // extremely slow shutdown ... probably due to a
; 375  :                       // race condition (MUTEX) between the 2 threads.
; 376  :       // break;
; 377  : 
; 378  :       case WM_COMMAND:
; 379  :          return( MainWndProc( hWnd, uMsg, wParam, lParam ) );

	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _uMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	_MainWndProc@16
	jmp	SHORT $LN1@MainThrdWn
$LN14@MainThrdWn:

; 380  : 
; 381  :       default:
; 382  :          if ( uMsg == g_wOENG_Message )

	mov	edx, DWORD PTR _uMsg$[ebp]
	cmp	edx, DWORD PTR _g_wOENG_Message
	jne	SHORT $LN2@MainThrdWn

; 383  :             fnProcessOENG_Message( hWnd, uMsg, wParam, lParam );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	_fnProcessOENG_Message
	add	esp, 16					; 00000010H
$LN2@MainThrdWn:

; 384  :    }
; 385  : 
; 386  :    return( DefWindowProc( hWnd, uMsg, wParam, lParam ) );

	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _uMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__DefWindowProcA@16
$LN1@MainThrdWn:

; 387  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MainThrdWndProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_msg$ = -28						; size = 28
_p$ = 8							; size = 4
_fnThreadProc@4 PROC

; 248  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 249  :    MSG msg;
; 250  : 
; 251  :    g_hThreadWnd = CreateWindow(

	push	0
	mov	eax, DWORD PTR _hInst
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	OFFSET $SG95942
	push	OFFSET _szThreadClassName
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _g_hThreadWnd, eax

; 252  :       szThreadClassName,              // see RegisterClass( ) call
; 253  :       "Zeidon Object Services",       // text for window title bar
; 254  :       0,                              // window style
; 255  :       0,                              // default horizontal position
; 256  :       0,                              // default vertical position
; 257  :       0,                              // default width
; 258  :       0,                              // default height
; 259  :       0,                              // overlapped windows have no parent
; 260  :       0,                              // menu for trace window
; 261  :       hInst,                          // this instance owns this window
; 262  :       0                               // pointer not needed
; 263  :    );
; 264  : 
; 265  :    g_bThreadStarted = TRUE;

	mov	BYTE PTR _g_bThreadStarted, 1
$LN2@fnThreadPr:

; 266  : 
; 267  :    // Acquire and dispatch messages until a WM_QUIT message is received
; 268  :    while ( GetMessage( &msg,          // message structure

	push	0
	push	0
	mov	ecx, DWORD PTR _g_hThreadWnd
	push	ecx
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetMessageA@16
	test	eax, eax
	je	SHORT $LN3@fnThreadPr

; 269  :                        g_hThreadWnd,  // handle of window receiving the message
; 270  :                        0,             // lowest message to examine
; 271  :                        0 ) )          // highest message to examine
; 272  :    {
; 273  :       if ( !TranslateAccelerator( g_hThreadWnd, 0, &msg ) )

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _g_hThreadWnd
	push	ecx
	call	DWORD PTR __imp__TranslateAcceleratorA@12
	test	eax, eax
	jne	SHORT $LN4@fnThreadPr

; 274  :       {
; 275  :          TranslateMessage( &msg );    // Translate message

	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__TranslateMessage@4

; 276  :          DispatchMessage( &msg );     // Dispatches message to window

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
$LN4@fnThreadPr:

; 277  :       }
; 278  :    }

	jmp	SHORT $LN2@fnThreadPr
$LN3@fnThreadPr:

; 279  : 
; 280  : #ifndef __BORLANDC__
; 281  :    return( msg.wParam );              // returns the value from PostQuitMessage

	mov	eax, DWORD PTR _msg$[ebp+8]

; 282  : #endif
; 283  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnThreadProc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_uSizeX$ = -16						; size = 2
_uSizeY$ = -12						; size = 2
_uSquareX$ = -8						; size = 2
_uSquareY$ = -4						; size = 2
_pwp$ = 8						; size = 4
_CheckWindowPos PROC

; 3288 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3289 :    zUSHORT uSquareX = GetSystemMetrics( SM_CXICON );

	push	11					; 0000000bH
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	WORD PTR _uSquareX$[ebp], ax

; 3290 :    zUSHORT uSquareY = GetSystemMetrics( SM_CYICON );

	push	12					; 0000000cH
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	WORD PTR _uSquareY$[ebp], ax

; 3291 :    zUSHORT uSizeX = GetSystemMetrics( SM_CXSCREEN ) - uSquareX;

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	movzx	ecx, WORD PTR _uSquareX$[ebp]
	sub	eax, ecx
	mov	WORD PTR _uSizeX$[ebp], ax

; 3292 :    zUSHORT uSizeY = GetSystemMetrics( SM_CYSCREEN ) - uSquareY;

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	movzx	edx, WORD PTR _uSquareY$[ebp]
	sub	eax, edx
	mov	WORD PTR _uSizeY$[ebp], ax

; 3293 : 
; 3294 :    // If the restored position is not visible, let default positioning occur.
; 3295 : // TraceRect( "CheckWindowPos Rect:", wp->rcNormalPosition );
; 3296 : // TraceLineI( "uSizeX: ", uSizeX );
; 3297 : // TraceLineI( "uSizeY: ", uSizeY );
; 3298 :    if ( pwp->rcNormalPosition.top > uSizeY ||
; 3299 :         pwp->rcNormalPosition.left > uSizeX ||
; 3300 :         pwp->rcNormalPosition.bottom <= uSquareY ||

	movzx	eax, WORD PTR _uSizeY$[ebp]
	mov	ecx, DWORD PTR _pwp$[ebp]
	cmp	DWORD PTR [ecx+32], eax
	jg	SHORT $LN3@CheckWindo
	movzx	edx, WORD PTR _uSizeX$[ebp]
	mov	eax, DWORD PTR _pwp$[ebp]
	cmp	DWORD PTR [eax+28], edx
	jg	SHORT $LN3@CheckWindo
	movzx	ecx, WORD PTR _uSquareY$[ebp]
	mov	edx, DWORD PTR _pwp$[ebp]
	cmp	DWORD PTR [edx+40], ecx
	jle	SHORT $LN3@CheckWindo
	movzx	eax, WORD PTR _uSquareX$[ebp]
	mov	ecx, DWORD PTR _pwp$[ebp]
	cmp	DWORD PTR [ecx+36], eax
	jg	SHORT $LN2@CheckWindo
$LN3@CheckWindo:

; 3301 :         pwp->rcNormalPosition.right <= uSquareX )
; 3302 :    {
; 3303 :       return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@CheckWindo
$LN2@CheckWindo:

; 3304 :    }
; 3305 : 
; 3306 :    return( TRUE );

	mov	al, 1
$LN1@CheckWindo:

; 3307 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CheckWindowPos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_pch$1 = -840						; size = 4
_pchComma$2 = -836					; size = 4
_lValue$3 = -832					; size = 4
_nRead$ = -828						; size = 4
_wp$ = -824						; size = 44
_szTempName$ = -780					; size = 260
_szBuffer$ = -520					; size = 256
_szFileName$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_pwp$ = 12						; size = 4
_ReadWindowPlacement PROC

; 3311 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 840				; 00000348H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 3312 :    WINDOWPLACEMENT wp;
; 3313 :    char szFileName[ 260 ];
; 3314 :    char szTempName[ 260 ];
; 3315 :    char szBuffer[ 256 ];
; 3316 :    int nRead = 0;

	mov	DWORD PTR _nRead$[ebp], 0

; 3317 : 
; 3318 :    SysReadZeidonIni( -1, szlWorkstation, "LocalDir", szTempName );

	lea	eax, DWORD PTR _szTempName$[ebp]
	push	eax
	push	OFFSET $SG96967
	push	OFFSET _szlWorkstation
	push	-1
	call	_SysReadZeidonIni@16

; 3319 :    SysConvertEnvironmentString( szFileName, szTempName );

	lea	ecx, DWORD PTR _szTempName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysConvertEnvironmentString@8

; 3320 :    if ( szFileName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szFileName$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN4@ReadWindow

; 3321 :    {
; 3322 :       SysAppendcDirSep( szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 3323 :       zstrcat( szFileName, "ZeidonRT.ini" );

	push	OFFSET $SG96970
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3324 :       GetPrivateProfileString( "ObjectEngine",     // section name

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	256					; 00000100H
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96971
	push	OFFSET $SG96972
	push	OFFSET $SG96973
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 3325 :                                "WindowPos",        // key name
; 3326 :                                "",                 // default string
; 3327 :                                szBuffer,           // destination buffer
; 3328 :                                sizeof( szBuffer ), // size of destination buffer
; 3329 :                                szFileName );       // ini filename
; 3330 :    }

	jmp	SHORT $LN5@ReadWindow
$LN4@ReadWindow:

; 3331 :    else
; 3332 :       SysReadZeidonIni( -1, "[ObjectEngine]", "WindowPos", szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96974
	push	OFFSET $SG96975
	push	-1
	call	_SysReadZeidonIni@16
$LN5@ReadWindow:

; 3333 : 
; 3334 :    if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	$LN6@ReadWindow

; 3335 :    {
; 3336 :    // nRead = scanf( szBuffer, szPlaceFormat,
; 3337 :    //                &wp.flags, &wp.showCmd,
; 3338 :    //                &wp.ptMinPosition.x, &wp.ptMinPosition.y,
; 3339 :    //                &wp.ptMaxPosition.x, &wp.ptMaxPosition.y,
; 3340 :    //                &wp.rcNormalPosition.left,
; 3341 :    //                &wp.rcNormalPosition.top,
; 3342 :    //                &wp.rcNormalPosition.right,
; 3343 :    //                &wp.rcNormalPosition.bottom );
; 3344 :       zPCHAR pch = szBuffer;

	lea	edx, DWORD PTR _szBuffer$[ebp]
	mov	DWORD PTR _pch$1[ebp], edx
$LN2@ReadWindow:

; 3345 :       zPCHAR pchComma;
; 3346 :       zLONG  lValue;
; 3347 : 
; 3348 :       while ( pch )

	cmp	DWORD PTR _pch$1[ebp], 0
	je	$LN6@ReadWindow

; 3349 :       {
; 3350 :          pchComma = zstrchr( pch, ',' );

	push	44					; 0000002cH
	mov	eax, DWORD PTR _pch$1[ebp]
	push	eax
	call	_strchr
	add	esp, 8
	mov	DWORD PTR _pchComma$2[ebp], eax

; 3351 :          if ( pchComma )

	cmp	DWORD PTR _pchComma$2[ebp], 0
	je	SHORT $LN7@ReadWindow

; 3352 :          {
; 3353 :             *pchComma = 0;

	mov	ecx, DWORD PTR _pchComma$2[ebp]
	mov	BYTE PTR [ecx], 0

; 3354 :             pchComma++;

	mov	edx, DWORD PTR _pchComma$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pchComma$2[ebp], edx
$LN7@ReadWindow:

; 3355 :          }
; 3356 : 
; 3357 :          lValue = zatol( pch );

	mov	eax, DWORD PTR _pch$1[ebp]
	push	eax
	call	_atol
	add	esp, 4
	mov	DWORD PTR _lValue$3[ebp], eax

; 3358 :          nRead++;

	mov	ecx, DWORD PTR _nRead$[ebp]
	add	ecx, 1
	mov	DWORD PTR _nRead$[ebp], ecx

; 3359 :          if ( nRead == 1 )

	cmp	DWORD PTR _nRead$[ebp], 1
	jne	SHORT $LN8@ReadWindow

; 3360 :             wp.flags = lValue;

	mov	edx, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+4], edx
	jmp	$LN9@ReadWindow
$LN8@ReadWindow:

; 3361 :          else
; 3362 :          if ( nRead == 2 )

	cmp	DWORD PTR _nRead$[ebp], 2
	jne	SHORT $LN10@ReadWindow

; 3363 :             wp.showCmd = lValue;

	mov	eax, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+8], eax
	jmp	$LN9@ReadWindow
$LN10@ReadWindow:

; 3364 :          else
; 3365 :          if ( nRead == 3 )

	cmp	DWORD PTR _nRead$[ebp], 3
	jne	SHORT $LN12@ReadWindow

; 3366 :             wp.ptMinPosition.x = lValue;

	mov	ecx, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+12], ecx
	jmp	$LN9@ReadWindow
$LN12@ReadWindow:

; 3367 :          else
; 3368 :          if ( nRead == 4 )

	cmp	DWORD PTR _nRead$[ebp], 4
	jne	SHORT $LN14@ReadWindow

; 3369 :             wp.ptMinPosition.y = lValue;

	mov	edx, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+16], edx
	jmp	$LN9@ReadWindow
$LN14@ReadWindow:

; 3370 :          else
; 3371 :          if ( nRead == 5 )

	cmp	DWORD PTR _nRead$[ebp], 5
	jne	SHORT $LN16@ReadWindow

; 3372 :             wp.ptMaxPosition.x = lValue;

	mov	eax, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+20], eax
	jmp	SHORT $LN9@ReadWindow
$LN16@ReadWindow:

; 3373 :          else
; 3374 :          if ( nRead == 6 )

	cmp	DWORD PTR _nRead$[ebp], 6
	jne	SHORT $LN18@ReadWindow

; 3375 :             wp.ptMaxPosition.y = lValue;

	mov	ecx, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+24], ecx
	jmp	SHORT $LN9@ReadWindow
$LN18@ReadWindow:

; 3376 :          else
; 3377 :          if ( nRead == 7 )

	cmp	DWORD PTR _nRead$[ebp], 7
	jne	SHORT $LN20@ReadWindow

; 3378 :             wp.rcNormalPosition.left = lValue;

	mov	edx, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+28], edx
	jmp	SHORT $LN9@ReadWindow
$LN20@ReadWindow:

; 3379 :          else
; 3380 :          if ( nRead == 8 )

	cmp	DWORD PTR _nRead$[ebp], 8
	jne	SHORT $LN22@ReadWindow

; 3381 :             wp.rcNormalPosition.top = lValue;

	mov	eax, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+32], eax
	jmp	SHORT $LN9@ReadWindow
$LN22@ReadWindow:

; 3382 :          else
; 3383 :          if ( nRead == 9 )

	cmp	DWORD PTR _nRead$[ebp], 9
	jne	SHORT $LN24@ReadWindow

; 3384 :             wp.rcNormalPosition.right = lValue;

	mov	ecx, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+36], ecx
	jmp	SHORT $LN9@ReadWindow
$LN24@ReadWindow:

; 3385 :          else
; 3386 :          if ( nRead == 10 )

	cmp	DWORD PTR _nRead$[ebp], 10		; 0000000aH
	jne	SHORT $LN9@ReadWindow

; 3387 :             wp.rcNormalPosition.bottom = lValue;

	mov	edx, DWORD PTR _lValue$3[ebp]
	mov	DWORD PTR _wp$[ebp+40], edx
$LN9@ReadWindow:

; 3388 : 
; 3389 :          pch = pchComma;

	mov	eax, DWORD PTR _pchComma$2[ebp]
	mov	DWORD PTR _pch$1[ebp], eax

; 3390 :       }

	jmp	$LN2@ReadWindow
$LN6@ReadWindow:

; 3391 :    }
; 3392 : 
; 3393 :    if ( nRead != 10 )

	cmp	DWORD PTR _nRead$[ebp], 10		; 0000000aH
	je	SHORT $LN27@ReadWindow

; 3394 :       return( FALSE );

	xor	al, al
	jmp	SHORT $LN1@ReadWindow
$LN27@ReadWindow:

; 3395 : 
; 3396 :    wp.length = sizeof( wp );

	mov	DWORD PTR _wp$[ebp], 44			; 0000002cH

; 3397 :    *pwp = wp;

	mov	ecx, 11					; 0000000bH
	lea	esi, DWORD PTR _wp$[ebp]
	mov	edi, DWORD PTR _pwp$[ebp]
	rep movsd

; 3398 :    return( TRUE );

	mov	al, 1
$LN1@ReadWindow:

; 3399 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_ReadWindowPlacement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_hMenuTrackPopup$ = -36					; size = 4
tv150 = -32						; size = 4
_bIsVisible$ = -28					; size = 4
tv145 = -24						; size = 4
tv137 = -20						; size = 4
tv95 = -16						; size = 4
tv85 = -12						; size = 4
tv75 = -8						; size = 4
_hMenu$ = -4						; size = 4
_hwnd$ = 8						; size = 4
_point$ = 12						; size = 8
_HandlePopupMenu@12 PROC

; 3502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 3503 : 
; 3504 :    HMENU hMenu;
; 3505 :    HMENU hMenuTrackPopup;
; 3506 :    BOOL bIsVisible;
; 3507 :    // Get the menu for the windows
; 3508 :    hMenu = LoadMenu( hInst, MAKEINTRESOURCE( ID_SYSTRAY_MNU ) );

	push	323					; 00000143H
	mov	eax, DWORD PTR _hInst
	push	eax
	call	DWORD PTR __imp__LoadMenuA@8
	mov	DWORD PTR _hMenu$[ebp], eax

; 3509 : 
; 3510 :    if ( hMenu == 0 )

	cmp	DWORD PTR _hMenu$[ebp], 0
	jne	SHORT $LN2@HandlePopu

; 3511 :       return;

	jmp	$LN1@HandlePopu
$LN2@HandlePopu:

; 3512 : 
; 3513 :    // Get the first menu in it which we will use for the call to
; 3514 :    // TrackPopup( ). This could also have been created on the fly using
; 3515 :    // CreatePopupMenu and then we could have used InsertMenu( ) or
; 3516 :    // AppendMenu.
; 3517 :    hMenuTrackPopup = GetSubMenu( hMenu, 0 );

	push	0
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSubMenu@8
	mov	DWORD PTR _hMenuTrackPopup$[ebp], eax

; 3518 : 
; 3519 :    CheckMenuItem( hMenu, IDM_SHOWTASKID,

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	and	eax, 1
	je	SHORT $LN4@HandlePopu
	mov	DWORD PTR tv75[ebp], 8
	jmp	SHORT $LN5@HandlePopu
$LN4@HandlePopu:
	mov	DWORD PTR tv75[ebp], 0
$LN5@HandlePopu:
	mov	ecx, DWORD PTR tv75[ebp]
	push	ecx
	push	124					; 0000007cH
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 3520 :                   MF_BYCOMMAND |
; 3521 :                     (AnchorBlock->bShowTaskID ? MF_CHECKED : MF_UNCHECKED) );
; 3522 :    CheckMenuItem( hMenu, IDM_SETOETRACE,

	movsx	eax, BYTE PTR _g_chTraceOE_Warning
	test	eax, eax
	je	SHORT $LN6@HandlePopu
	movsx	ecx, BYTE PTR _g_chTraceOE_Warning
	cmp	ecx, 110				; 0000006eH
	je	SHORT $LN6@HandlePopu
	movsx	edx, BYTE PTR _g_chTraceOE_Warning
	cmp	edx, 78					; 0000004eH
	je	SHORT $LN6@HandlePopu
	mov	DWORD PTR tv85[ebp], 8
	jmp	SHORT $LN7@HandlePopu
$LN6@HandlePopu:
	mov	DWORD PTR tv85[ebp], 0
$LN7@HandlePopu:
	mov	eax, DWORD PTR tv85[ebp]
	push	eax
	push	133					; 00000085H
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 3523 :                   MF_BYCOMMAND |
; 3524 :                      (g_chTraceOE_Warning == 0 ||
; 3525 :                         g_chTraceOE_Warning == 'n' ||
; 3526 :                         g_chTraceOE_Warning == 'N' ? MF_UNCHECKED :
; 3527 :                                                      MF_CHECKED) );
; 3528 :    CheckMenuItem( hMenu, IDM_SETZDRTRACE,

	movsx	edx, BYTE PTR _g_chTraceZDrActions
	test	edx, edx
	je	SHORT $LN8@HandlePopu
	movsx	eax, BYTE PTR _g_chTraceZDrActions
	cmp	eax, 110				; 0000006eH
	je	SHORT $LN8@HandlePopu
	movsx	ecx, BYTE PTR _g_chTraceZDrActions
	cmp	ecx, 78					; 0000004eH
	je	SHORT $LN8@HandlePopu
	mov	DWORD PTR tv95[ebp], 8
	jmp	SHORT $LN9@HandlePopu
$LN8@HandlePopu:
	mov	DWORD PTR tv95[ebp], 0
$LN9@HandlePopu:
	mov	edx, DWORD PTR tv95[ebp]
	push	edx
	push	134					; 00000086H
	mov	eax, DWORD PTR _hMenu$[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 3529 :                   MF_BYCOMMAND |
; 3530 :                      (g_chTraceZDrActions == 0 ||
; 3531 :                         g_chTraceZDrActions == 'n' ||
; 3532 :                         g_chTraceZDrActions == 'N' ? MF_UNCHECKED :
; 3533 :                                                      MF_CHECKED) );
; 3534 :    CheckMenuItem( hMenu, IDM_SETWEBTRACE,

	movsx	ecx, BYTE PTR _g_chTraceWebActions
	test	ecx, ecx
	je	SHORT $LN10@HandlePopu
	movsx	edx, BYTE PTR _g_chTraceWebActions
	cmp	edx, 110				; 0000006eH
	je	SHORT $LN10@HandlePopu
	movsx	eax, BYTE PTR _g_chTraceWebActions
	cmp	eax, 78					; 0000004eH
	je	SHORT $LN10@HandlePopu
	mov	DWORD PTR tv137[ebp], 8
	jmp	SHORT $LN11@HandlePopu
$LN10@HandlePopu:
	mov	DWORD PTR tv137[ebp], 0
$LN11@HandlePopu:
	mov	ecx, DWORD PTR tv137[ebp]
	push	ecx
	push	135					; 00000087H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 3535 :                   MF_BYCOMMAND |
; 3536 :                      (g_chTraceWebActions == 0 ||
; 3537 :                         g_chTraceWebActions == 'n' ||
; 3538 :                         g_chTraceWebActions == 'N' ? MF_UNCHECKED :
; 3539 :                                                      MF_CHECKED) );
; 3540 : 
; 3541 :    // This is required when using a notify icon -- see KB article
; 3542 :    // PRB: Menus for Notification Icons Don't Work Correctly
; 3543 :    SetForegroundWindow( hwnd );

	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 3544 : 
; 3545 :    bIsVisible = IsWindowVisible( hwnd );

	mov	ecx, DWORD PTR _hwnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsWindowVisible@4
	mov	DWORD PTR _bIsVisible$[ebp], eax

; 3546 :    EnableMenuItem( hMenu, IDM_SHOWTRACE, bIsVisible ? MF_GRAYED : MF_ENABLED );

	cmp	DWORD PTR _bIsVisible$[ebp], 0
	je	SHORT $LN12@HandlePopu
	mov	DWORD PTR tv145[ebp], 1
	jmp	SHORT $LN13@HandlePopu
$LN12@HandlePopu:
	mov	DWORD PTR tv145[ebp], 0
$LN13@HandlePopu:
	mov	edx, DWORD PTR tv145[ebp]
	push	edx
	push	321					; 00000141H
	mov	eax, DWORD PTR _hMenu$[ebp]
	push	eax
	call	DWORD PTR __imp__EnableMenuItem@12

; 3547 :    EnableMenuItem( hMenu, IDM_HIDEWINDOW, bIsVisible ? MF_ENABLED : MF_GRAYED );

	cmp	DWORD PTR _bIsVisible$[ebp], 0
	je	SHORT $LN14@HandlePopu
	mov	DWORD PTR tv150[ebp], 0
	jmp	SHORT $LN15@HandlePopu
$LN14@HandlePopu:
	mov	DWORD PTR tv150[ebp], 1
$LN15@HandlePopu:
	mov	ecx, DWORD PTR tv150[ebp]
	push	ecx
	push	320					; 00000140H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__EnableMenuItem@12

; 3548 : 
; 3549 : 
; 3550 :    TrackPopupMenu( hMenuTrackPopup, TPM_LEFTBUTTON | TPM_RIGHTBUTTON,

	push	0
	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _point$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _point$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _hMenuTrackPopup$[ebp]
	push	eax
	call	DWORD PTR __imp__TrackPopupMenu@28

; 3551 :                    point.x, point.y, 0, hwnd, NULL );
; 3552 : 
; 3553 :    // This is required when using a notify icon -- see KB article
; 3554 :    // PRB: Menus for Notification Icons Don't Work Correctly
; 3555 :    PostMessage( hwnd, WM_USER, 0, 0 );

	push	0
	push	0
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _hwnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__PostMessageA@16
$LN1@HandlePopu:

; 3556 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_HandlePopupMenu@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_DetachSysTray PROC

; 3484 : {

	push	ebp
	mov	ebp, esp

; 3485 :    TrayMessage( NIM_DELETE, zTRAY_MESSAGE_SHOW, NULL, NULL);

	push	0
	push	0
	push	2
	push	2
	call	_TrayMessage
	add	esp, 16					; 00000010H

; 3486 : }

	pop	ebp
	ret	0
_DetachSysTray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_hIcon$ = -140						; size = 4
_bReturn$ = -133					; size = 1
_szTip$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_SetupSysTray PROC

; 3459 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3460 :    zBOOL bReturn = FALSE;

	mov	BYTE PTR _bReturn$[ebp], 0

; 3461 :    HICON hIcon = NULL;

	mov	DWORD PTR _hIcon$[ebp], 0

; 3462 :    char szTip[ 128 ];
; 3463 : 
; 3464 :    hIcon = LoadIcon( hInstance, "ZEIDON" );

	push	OFFSET $SG97020
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _hIcon$[ebp], eax

; 3465 :    GetWindowText( g_hWndMainFrame, szTip, 127 );

	push	127					; 0000007fH
	lea	ecx, DWORD PTR _szTip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	call	DWORD PTR __imp__GetWindowTextA@12

; 3466 :    bReturn = TrayMessage( NIM_ADD, zTRAY_MESSAGE_SHOW, hIcon, szTip );

	lea	eax, DWORD PTR _szTip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hIcon$[ebp]
	push	ecx
	push	2
	push	0
	call	_TrayMessage
	add	esp, 16					; 00000010H
	mov	BYTE PTR _bReturn$[ebp], al

; 3467 : 
; 3468 :    return bReturn;

	mov	al, BYTE PTR _bReturn$[ebp]

; 3469 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SetupSysTray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_res$ = -513						; size = 1
_tnd$ = -512						; size = 508
__$ArrayPad$ = -4					; size = 4
_dwMessage$ = 8						; size = 4
_uID$ = 12						; size = 4
_hIcon$ = 16						; size = 4
_pszTip$ = 20						; size = 4
_TrayMessage PROC

; 3417 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 516				; 00000204H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3418 :    zBOOL res;
; 3419 : 
; 3420 :    NOTIFYICONDATA tnd;
; 3421 : 
; 3422 :    tnd.cbSize      = sizeof( NOTIFYICONDATA );

	mov	DWORD PTR _tnd$[ebp], 508		; 000001fcH

; 3423 :    tnd.hWnd        = g_hWndMainFrame;

	mov	eax, DWORD PTR _g_hWndMainFrame
	mov	DWORD PTR _tnd$[ebp+4], eax

; 3424 :    tnd.uID         = uID;

	mov	ecx, DWORD PTR _uID$[ebp]
	mov	DWORD PTR _tnd$[ebp+8], ecx

; 3425 : 
; 3426 :    tnd.uFlags      = NIF_MESSAGE | NIF_ICON | NIF_TIP;

	mov	DWORD PTR _tnd$[ebp+12], 7

; 3427 :    tnd.uCallbackMessage = zWM_NOTIFYICON;// notification message for message loop

	mov	DWORD PTR _tnd$[ebp+16], 32868		; 00008064H

; 3428 :    tnd.hIcon      = hIcon;

	mov	edx, DWORD PTR _hIcon$[ebp]
	mov	DWORD PTR _tnd$[ebp+20], edx

; 3429 :    if ( pszTip )

	cmp	DWORD PTR _pszTip$[ebp], 0
	je	SHORT $LN2@TrayMessag

; 3430 :    {
; 3431 :       lstrcpyn( tnd.szTip, pszTip, sizeof( tnd.szTip ) );

	push	128					; 00000080H
	mov	eax, DWORD PTR _pszTip$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tnd$[ebp+24]
	push	ecx
	call	DWORD PTR __imp__lstrcpynA@12

; 3432 :    }

	jmp	SHORT $LN3@TrayMessag
$LN2@TrayMessag:

; 3433 :    else
; 3434 :    {
; 3435 :       tnd.szTip[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _tnd$[ebp+eax+24], 0
$LN3@TrayMessag:

; 3436 :    }
; 3437 : 
; 3438 :    res = Shell_NotifyIcon(dwMessage, &tnd);

	lea	ecx, DWORD PTR _tnd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMessage$[ebp]
	push	edx
	call	DWORD PTR __imp__Shell_NotifyIconA@8
	mov	BYTE PTR _res$[ebp], al

; 3439 : 
; 3440 :    if ( hIcon )

	cmp	DWORD PTR _hIcon$[ebp], 0
	je	SHORT $LN4@TrayMessag

; 3441 :        DestroyIcon( hIcon );

	mov	eax, DWORD PTR _hIcon$[ebp]
	push	eax
	call	DWORD PTR __imp__DestroyIcon@4
$LN4@TrayMessag:

; 3442 : 
; 3443 :    return( res );

	mov	al, BYTE PTR _res$[ebp]

; 3444 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TrayMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_fnProcessOENG_Message PROC

; 2061 : {

	push	ebp
	mov	ebp, esp

; 2062 : #ifdef __WIN32__
; 2063 : 
; 2064 :    // We'll let core handle it.
; 2065 :    ProcessZeidonMessage( wParam, lParam );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	call	_ProcessZeidonMessage@8

; 2066 :    return;
; 2067 : 
; 2068 : #else
; 2069 : 
; 2070 :    // The only thing we handle in Win 3.x is conversion from decimal to string.
; 2071 : 
; 2072 :    zPDECIMAL pdDecimal  = (zPDECIMAL) lParam;
; 2073 :    zSHORT    nPrecision = (zSHORT) wParam;
; 2074 :    zCHAR     szStr[ 100 ] = "abcdefghijklmnopqrstuvwxyz";
; 2075 :    zPCHAR    pszReturn;
; 2076 : 
; 2077 : // SysMessageBox( "DGC", "processing message", 1 );
; 2078 : 
; 2079 :    pszReturn = (zPCHAR) ((zLONG) lParam + sizeof( zPDECIMAL ));
; 2080 : 
; 2081 :    if ( nPrecision > 0 )
; 2082 :       zsprintf( szStr, "%*Lf", (int) wParam, *pdDecimal );
; 2083 :    else
; 2084 :       zsprintf( szStr, "%Lf", *pdDecimal );
; 2085 : 
; 2086 :    zstrcpy( pszReturn, szStr );
; 2087 : 
; 2088 : #endif
; 2089 : }

	pop	ebp
	ret	0
_fnProcessOENG_Message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_lpTask$1 = -528					; size = 4
_lpTask$2 = -524					; size = 4
tv64 = -520						; size = 4
_szTraceText$3 = -516					; size = 512
__$ArrayPad$ = -4					; size = 4
_hWndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_LogTraceDlgProc@16 PROC

; 3190 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 528				; 00000210H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3191 :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	$LN13@LogTraceDl
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN4@LogTraceDl
	jmp	$LN20@LogTraceDl
$LN4@LogTraceDl:

; 3192 :    {
; 3193 :       case WM_COMMAND:
; 3194 :          if ( wParam == IDC_OPEN ) // open pushbutton

	cmp	DWORD PTR _wParam$[ebp], 203		; 000000cbH
	jne	$LN5@LogTraceDl

; 3195 :          {
; 3196 :             LPTASK lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$2[ebp], eax

; 3197 :             GetDlgItemText( hWndDlg, IDC_LOGFILE,

	push	256					; 00000100H
	push	OFFSET _szLogFileName
	push	205					; 000000cdH
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDlgItemTextA@16

; 3198 :                             szLogFileName, sizeof( szLogFileName ) );
; 3199 :             if ( (g_hLogFile = fnSysOpenFile( lpTask, szLogFileName,
; 3200 :                                               COREFILE_CREATE )) == -1 )

	push	32					; 00000020H
	push	OFFSET _szLogFileName
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _g_hLogFile, eax
	cmp	DWORD PTR _g_hLogFile, -1
	jne	SHORT $LN7@LogTraceDl

; 3201 :             {
; 3202 :                MessageBox( GetActiveWindow( ),

	push	16					; 00000010H
	push	OFFSET $SG96922
	push	OFFSET $SG96923
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 3203 :                            "Error opening trace file!",
; 3204 :                            "Zeidon Object Services", MB_ICONSTOP | MB_OK );
; 3205 :             }

	jmp	SHORT $LN8@LogTraceDl
$LN7@LogTraceDl:

; 3206 :             else
; 3207 :             {
; 3208 :                char szTraceText[ 512 ];
; 3209 : 
; 3210 :                // Send message that log file opened.
; 3211 :                zstrcpy( szTraceText, "(ng) Log file Opened '" );

	push	OFFSET $SG96924
	lea	edx, DWORD PTR _szTraceText$3[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3212 :                zstrcat( szTraceText, szLogFileName );

	push	OFFSET _szLogFileName
	lea	eax, DWORD PTR _szTraceText$3[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3213 :                zstrcat( szTraceText, "'" );

	push	OFFSET $SG96925
	lea	ecx, DWORD PTR _szTraceText$3[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3214 :                SysMessageList( szTraceText );

	lea	edx, DWORD PTR _szTraceText$3[ebp]
	push	edx
	call	_SysMessageList@4

; 3215 : 
; 3216 :                WriteTraceToLog( lpTask );

	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_WriteTraceToLog
	add	esp, 4

; 3217 : 
; 3218 :                EndDialog( hWndDlg, TRUE );

	push	1
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndDialog@8
$LN8@LogTraceDl:

; 3219 :             }
; 3220 :          }

	jmp	SHORT $LN13@LogTraceDl
$LN5@LogTraceDl:

; 3221 :          else
; 3222 :          if ( wParam == IDC_CLOSE )

	cmp	DWORD PTR _wParam$[ebp], 204		; 000000ccH
	jne	SHORT $LN9@LogTraceDl

; 3223 :          {
; 3224 :             LPTASK lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$1[ebp], eax

; 3225 :             SysMessageList( "(ng) End of Log" );

	push	OFFSET $SG96928
	call	_SysMessageList@4

; 3226 :             fnSysCloseFile( lpTask, g_hLogFile, 0 );

	push	0
	mov	ecx, DWORD PTR _g_hLogFile
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 3227 :             g_hLogFile = -1;

	mov	DWORD PTR _g_hLogFile, -1

; 3228 :             EndDialog( hWndDlg, TRUE );

	push	1
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__EndDialog@8

; 3229 :          }

	jmp	SHORT $LN13@LogTraceDl
$LN9@LogTraceDl:

; 3230 :          else
; 3231 :          if ( wParam == IDC_CANCEL )

	cmp	DWORD PTR _wParam$[ebp], 202		; 000000caH
	jne	SHORT $LN11@LogTraceDl

; 3232 :             EndDialog( hWndDlg, TRUE );

	push	1
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndDialog@8
	jmp	SHORT $LN13@LogTraceDl
$LN11@LogTraceDl:

; 3233 :          else
; 3234 :             return( FALSE );

	xor	eax, eax
	jmp	$LN1@LogTraceDl
$LN13@LogTraceDl:

; 3235 : 
; 3236 :          // fall through
; 3237 : 
; 3238 :       case WM_INITDIALOG:
; 3239 :          if ( g_hLogFile != -1 )

	cmp	DWORD PTR _g_hLogFile, -1
	je	SHORT $LN14@LogTraceDl

; 3240 :          {
; 3241 :             EnableWindow( GetDlgItem( hWndDlg, IDC_OPEN ), FALSE );

	push	0
	push	203					; 000000cbH
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__EnableWindow@8

; 3242 :             SetDlgItemText( hWndDlg, IDC_LOGFILE, szLogFileName );

	push	OFFSET _szLogFileName
	push	205					; 000000cdH
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SetDlgItemTextA@12

; 3243 :             SendDlgItemMessage( hWndDlg, IDC_CLOSE,

	push	1
	push	1
	push	244					; 000000f4H
	push	204					; 000000ccH
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 3244 :                                 BM_SETSTYLE,
; 3245 :                                 (WORD) BS_DEFPUSHBUTTON, 1L );
; 3246 :             SetFocus( GetDlgItem( hWndDlg, IDC_CLOSE ) );

	push	204					; 000000ccH
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetFocus@4

; 3247 :             EnableWindow( GetDlgItem( hWndDlg, IDC_LOGFILE ), FALSE );

	push	0
	push	205					; 000000cdH
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__EnableWindow@8

; 3248 :          }

	jmp	$LN15@LogTraceDl
$LN14@LogTraceDl:

; 3249 :          else
; 3250 :          {
; 3251 :             EnableWindow( GetDlgItem( hWndDlg, IDC_CLOSE ), FALSE );

	push	0
	push	204					; 000000ccH
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__EnableWindow@8

; 3252 :             SendDlgItemMessage( hWndDlg, IDC_OPEN,

	push	1
	push	1
	push	244					; 000000f4H
	push	203					; 000000cbH
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 3253 :                                 BM_SETSTYLE,
; 3254 :                                 (WORD) BS_DEFPUSHBUTTON, 1L );
; 3255 :             if ( szLogFileName[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szLogFileName[ecx]
	test	edx, edx
	jne	$LN16@LogTraceDl

; 3256 :             {
; 3257 :                SysReadZeidonIni( -1, szlWorkstation, "LogFile", szLogFileName );

	push	OFFSET _szLogFileName
	push	OFFSET $SG96935
	push	OFFSET _szlWorkstation
	push	-1
	call	_SysReadZeidonIni@16

; 3258 :                if ( szLogFileName[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szLogFileName[ecx]
	test	edx, edx
	jne	SHORT $LN16@LogTraceDl

; 3259 :                {
; 3260 :                   if ( AnchorBlock->szZeidonLoc[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	movsx	eax, BYTE PTR [edx+ecx+909]
	test	eax, eax
	je	SHORT $LN18@LogTraceDl

; 3261 :                      zstrcpy( szLogFileName, AnchorBlock->szZeidonLoc );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 909				; 0000038dH
	push	ecx
	push	OFFSET _szLogFileName
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN19@LogTraceDl
$LN18@LogTraceDl:

; 3262 :                   else
; 3263 :                      zstrcpy( szLogFileName, "\\" );

	push	OFFSET $SG96939
	push	OFFSET _szLogFileName
	call	_strcpy
	add	esp, 8
$LN19@LogTraceDl:

; 3264 : 
; 3265 :                   zstrcat( szLogFileName, "ZEIDON00.LOG" );

	push	OFFSET $SG96940
	push	OFFSET _szLogFileName
	call	_strcat
	add	esp, 8
$LN16@LogTraceDl:

; 3266 :                }
; 3267 :             }
; 3268 : 
; 3269 :             SetWindowText( GetDlgItem( hWndDlg, IDC_LOGFILE ),

	push	OFFSET _szLogFileName
	push	205					; 000000cdH
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDlgItem@8
	push	eax
	call	DWORD PTR __imp__SetWindowTextA@8
$LN15@LogTraceDl:

; 3270 :                            szLogFileName );
; 3271 :          }
; 3272 : 
; 3273 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@LogTraceDl
$LN20@LogTraceDl:

; 3274 : 
; 3275 :       default:
; 3276 :          return( FALSE );

	xor	eax, eax
$LN1@LogTraceDl:

; 3277 :    }
; 3278 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_LogTraceDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_iDiff$1 = -28						; size = 4
_lpTask$2 = -24						; size = 4
_lpData$3 = -20						; size = 4
tv64 = -16						; size = 4
_nOldHead$4 = -12					; size = 4
_nItemCount$5 = -8					; size = 2
_wCmd$6 = -4						; size = 2
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_TraceListWndProc@16 PROC

; 3090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 3091 :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 74			; 0000004aH
	je	SHORT $LN4@TraceListW
	cmp	DWORD PTR tv64[ebp], 384		; 00000180H
	je	SHORT $LN6@TraceListW
	jmp	$LN15@TraceListW
$LN4@TraceListW:

; 3092 :    {
; 3093 :       case WM_COPYDATA:
; 3094 :       {
; 3095 :          COPYDATASTRUCT * lpData = (COPYDATASTRUCT *) lParam;

	mov	ecx, DWORD PTR _lParam$[ebp]
	mov	DWORD PTR _lpData$3[ebp], ecx

; 3096 : 
; 3097 :          if ( lpData->dwData != LB_ADDSTRING )

	mov	edx, DWORD PTR _lpData$3[ebp]
	cmp	DWORD PTR [edx], 384			; 00000180H
	je	SHORT $LN5@TraceListW

; 3098 :             return fpDfltListWndProc( hWnd, uMsg, wParam, lParam );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR _fpDfltListWndProc
	jmp	$LN1@TraceListW
$LN5@TraceListW:

; 3099 : 
; 3100 :          lParam = (LPARAM) lpData->lpData;

	mov	ecx, DWORD PTR _lpData$3[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _lParam$[ebp], edx
$LN6@TraceListW:

; 3101 :       }
; 3102 : 
; 3103 :          // Yes...fall through.
; 3104 : 
; 3105 :       case LB_ADDSTRING:              // Trace going to list box
; 3106 :       {
; 3107 :          WORD nItemCount;
; 3108 : 
; 3109 :          if ( g_hLogFile != -1 )

	cmp	DWORD PTR _g_hLogFile, -1
	je	SHORT $LN7@TraceListW

; 3110 :          {
; 3111 :             LPTASK lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$2[ebp], eax

; 3112 :             fnSysWriteLine( lpTask, g_hLogFile, 0, (zPCHAR) lParam );

	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _g_hLogFile
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnSysWriteLine@16
$LN7@TraceListW:

; 3113 :          }
; 3114 : 
; 3115 :          // If g_uTraceLineLimit is 0 then don't add lines to trace window.
; 3116 :          if ( g_uTraceLineLimit == 0 )

	cmp	DWORD PTR _g_uTraceLineLimit, 0
	jne	SHORT $LN8@TraceListW

; 3117 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@TraceListW
$LN8@TraceListW:

; 3118 : 
; 3119 :          // Add the trace line to the trace listbox.  If the line we added
; 3120 :          // puts the listbox over the limit start filling the next listbox.
; 3121 :          nItemCount = (WORD) SendMessage( g_hwndTraceWindow[ g_nTraceWindowHead ],

	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	push	0
	push	384					; 00000180H
	mov	eax, DWORD PTR _g_nTraceWindowHead
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _nItemCount$5[ebp], ax

; 3122 :                                           LB_ADDSTRING, 0, lParam );
; 3123 :          if ( nItemCount >= g_uTraceLineLimit )

	movzx	edx, WORD PTR _nItemCount$5[ebp]
	cmp	edx, DWORD PTR _g_uTraceLineLimit
	jb	$LN9@TraceListW

; 3124 :          {
; 3125 :             UINT nOldHead = g_nTraceWindowHead;

	mov	eax, DWORD PTR _g_nTraceWindowHead
	mov	DWORD PTR _nOldHead$4[ebp], eax

; 3126 : 
; 3127 :             // Set head to next window.
; 3128 :             g_nTraceWindowHead = ( g_nTraceWindowHead + 1 ) % g_nTraceWindowCnt;

	mov	eax, DWORD PTR _g_nTraceWindowHead
	add	eax, 1
	xor	edx, edx
	div	DWORD PTR _g_nTraceWindowCnt
	mov	DWORD PTR _g_nTraceWindowHead, edx

; 3129 : 
; 3130 :             // Clear the new listbox.
; 3131 :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowHead ],

	push	0
	push	0
	push	388					; 00000184H
	mov	ecx, DWORD PTR _g_nTraceWindowHead
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 3132 :                          LB_RESETCONTENT, 0, 0 );
; 3133 : 
; 3134 :             // Change the listbox that is displayed unless the head listbox
; 3135 :             // is not the one currently being displayed.
; 3136 :             if ( nOldHead == g_nTraceWindowDisplayed )

	mov	eax, DWORD PTR _nOldHead$4[ebp]
	cmp	eax, DWORD PTR _g_nTraceWindowDisplayed
	jne	SHORT $LN11@TraceListW

; 3137 :             {
; 3138 :                ShowWindow( g_hwndTraceWindow[ nOldHead ], SW_HIDE );

	push	0
	mov	ecx, DWORD PTR _nOldHead$4[ebp]
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8

; 3139 :                ShowWindow( g_hwndTraceWindow[ g_nTraceWindowHead ], SW_SHOW );

	push	5
	mov	eax, DWORD PTR _g_nTraceWindowHead
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 3140 :                g_nTraceWindowDisplayed = g_nTraceWindowHead;

	mov	edx, DWORD PTR _g_nTraceWindowHead
	mov	DWORD PTR _g_nTraceWindowDisplayed, edx

; 3141 :             }

	jmp	$LN12@TraceListW
$LN11@TraceListW:

; 3142 :             else
; 3143 :             {
; 3144 :                // OK...user is looking at an older trace window.  We will keep
; 3145 :                // the user on this trace window but we need to change the
; 3146 :                // checkboxes.
; 3147 :                WORD wCmd;
; 3148 :                UINT iDiff;
; 3149 : 
; 3150 :                // Find the difference between the displayed window and the head.
; 3151 :                iDiff = (g_nTraceWindowDisplayed + g_nTraceWindowCnt -

	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	add	eax, DWORD PTR _g_nTraceWindowCnt
	sub	eax, DWORD PTR _nOldHead$4[ebp]
	xor	edx, edx
	div	DWORD PTR _g_nTraceWindowCnt
	mov	DWORD PTR _iDiff$1[ebp], edx

; 3152 :                                                nOldHead) % g_nTraceWindowCnt;
; 3153 : 
; 3154 :                // Determine the old trace window index.
; 3155 :                wCmd = (g_nTraceWindowCnt - iDiff) % g_nTraceWindowCnt +

	mov	eax, DWORD PTR _g_nTraceWindowCnt
	sub	eax, DWORD PTR _iDiff$1[ebp]
	xor	edx, edx
	div	DWORD PTR _g_nTraceWindowCnt
	add	edx, 300				; 0000012cH
	mov	WORD PTR _wCmd$6[ebp], dx

; 3156 :                                                            IDM_TRACEWINDOW01;
; 3157 : 
; 3158 :                // Turn off the check mark...we will no longer be displaying the
; 3159 :                // current window.
; 3160 :                CheckMenuItem( GetMenu( g_hWndMainFrame ), wCmd,

	push	0
	movzx	eax, WORD PTR _wCmd$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 3161 :                               MF_BYCOMMAND | MF_UNCHECKED );
; 3162 : 
; 3163 :                wCmd++;

	mov	dx, WORD PTR _wCmd$6[ebp]
	add	dx, 1
	mov	WORD PTR _wCmd$6[ebp], dx

; 3164 :                if ( wCmd >= IDM_TRACEWINDOW01 + g_nTraceWindowCnt )

	movzx	eax, WORD PTR _wCmd$6[ebp]
	mov	ecx, DWORD PTR _g_nTraceWindowCnt
	add	ecx, 300				; 0000012cH
	cmp	eax, ecx
	jb	SHORT $LN13@TraceListW

; 3165 :                   wCmd = IDM_TRACEWINDOW01;

	mov	edx, 300				; 0000012cH
	mov	WORD PTR _wCmd$6[ebp], dx
$LN13@TraceListW:

; 3166 : 
; 3167 :                // Turn the next one on.
; 3168 :                CheckMenuItem( GetMenu( g_hWndMainFrame ), wCmd,

	push	8
	movzx	eax, WORD PTR _wCmd$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12
$LN12@TraceListW:

; 3169 :                               MF_BYCOMMAND | MF_CHECKED );
; 3170 : 
; 3171 :             }
; 3172 :          }

	jmp	SHORT $LN10@TraceListW
$LN9@TraceListW:

; 3173 :          else
; 3174 :          if ( g_chScrollTrace )

	movsx	edx, BYTE PTR _g_chScrollTrace
	test	edx, edx
	je	SHORT $LN10@TraceListW

; 3175 :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowHead ],

	push	0
	movzx	eax, WORD PTR _nItemCount$5[ebp]
	push	eax
	push	390					; 00000186H
	mov	ecx, DWORD PTR _g_nTraceWindowHead
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
$LN10@TraceListW:

; 3176 :                          LB_SETCURSEL, nItemCount, 0L );
; 3177 : 
; 3178 :          return( nItemCount );

	movzx	eax, WORD PTR _nItemCount$5[ebp]
	jmp	SHORT $LN1@TraceListW
$LN15@TraceListW:

; 3179 :       }
; 3180 : 
; 3181 :       default:
; 3182 :          return( fpDfltListWndProc( hWnd, uMsg, wParam, lParam ) );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR _fpDfltListWndProc
$LN1@TraceListW:

; 3183 :    }
; 3184 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TraceListWndProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_hWndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_ShowDLLDlgProc@16 PROC

; 2917 : {

	push	ebp
	mov	ebp, esp

; 2918 : #ifdef __WIN32__
; 2919 :    return( 0 );

	xor	eax, eax

; 2920 : #else
; 2921 :    WORD  wLBIndex;
; 2922 :    WORD  wCheckState;
; 2923 : 
; 2924 :    switch ( uMsg )
; 2925 :    {
; 2926 :       case WM_COMMAND:
; 2927 : #if 0
; 2928 :          {
; 2929 :             zCHAR szWorkString[ 256 ];
; 2930 : 
; 2931 :             zstrcpy( szWorkString, "DLLDlg WM_COMMAND  Message " );
; 2932 : 
; 2933 :             zltoa( (zLONG) (unsigned) uMsg,
; 2934 :                    (szWorkString + zstrlen( szWorkString )) );
; 2935 :             zstrcat( szWorkString, "(" );
; 2936 :             _ltoa( (zLONG) (unsigned) uMsg,
; 2937 :                    (szWorkString + zstrlen( szWorkString )), 16 );
; 2938 : 
; 2939 :             zstrcat( szWorkString, ") wParam " );
; 2940 :             zltoa( (zLONG) wParam, (szWorkString + zstrlen( szWorkString )) );
; 2941 :             zstrcat( szWorkString, "(" );
; 2942 :             _ltoa( (zLONG) wParam,
; 2943 :                    (szWorkString + zstrlen( szWorkString )), 16 );
; 2944 : 
; 2945 :             zstrcat( szWorkString, ") lParam " );
; 2946 :             zltoa( lParam, (szWorkString + zstrlen( szWorkString )) );
; 2947 :             zstrcat( szWorkString, "(" );
; 2948 :             _ltoa( lParam, (szWorkString + zstrlen( szWorkString )), 16 );
; 2949 :             zstrcat( szWorkString, ")" );
; 2950 : 
; 2951 :             SendMessage( g_hWndLB, LB_ADDSTRING, 0,
; 2952 :                          (zLONG)(zPCHAR) szWorkString );
; 2953 :          }
; 2954 : #endif
; 2955 :          switch ( wParam )
; 2956 :          {
; 2957 :             case IDC_OK:
; 2958 :             {
; 2959 :                wLBIndex = (WORD) SendDlgItemMessage( hWndDlg, IDC_DLLLB,
; 2960 :                                                      LB_GETCURSEL, 0, 0L );
; 2961 :                if ( wLBIndex != LB_ERR )
; 2962 :                {
; 2963 :                   wCheckState = (WORD) SendDlgItemMessage( hWndDlg,
; 2964 :                                                            IDC_FREEDLL,
; 2965 :                                                            BM_GETCHECK,
; 2966 :                                                            0, 0L );
; 2967 : #if 0
; 2968 :                   if ( wCheckState == 1 )
; 2969 :                   {
; 2970 :                      WORD  hModHandle;
; 2971 :                      zCHAR szWorkString[ 256 ];
; 2972 : 
; 2973 :                      zstrcpy( szWorkString, "Selected item: " );
; 2974 :                      SendDlgItemMessage( hWndDlg, IDC_DLLLB, LB_GETTEXT,
; 2975 :                                       wLBIndex,
; 2976 :                                       (zLONG)(zPCHAR)
; 2977 :                                       (szWorkString + zstrlen( szWorkString )));
; 2978 :                      zstrcat( szWorkString, " Handle: " );
; 2979 :                      hModHandle = LOWORD( (LPARAM) SendDlgItemMessage
; 2980 :                                             ( hWndDlg, IDC_DLLLB,
; 2981 :                                               LB_GETITEMDATA, wLBIndex, 0L ) );
; 2982 :                      _ltoa( (zLONG) (WORD) hModHandle,
; 2983 :                             (szWorkString + zstrlen( szWorkString )), 16 );
; 2984 :                      SendMessage( g_hWndLB, LB_ADDSTRING, 0,
; 2985 :                                   (zLONG)(zPCHAR) szWorkString );
; 2986 :                      FreeLibrary( hModHandle );
; 2987 :                   }
; 2988 : #endif
; 2989 :                }
; 2990 : 
; 2991 :                EndDialog( hWndDlg, TRUE );
; 2992 :                return( FALSE );
; 2993 :             }
; 2994 : 
; 2995 :             case IDC_CANCEL:
; 2996 :                EndDialog( hWndDlg, TRUE );
; 2997 :                return( FALSE );
; 2998 : 
; 2999 :             case IDC_FREEDLL:
; 3000 :                return( FALSE );
; 3001 : 
; 3002 :             case IDC_DLLLB:
; 3003 :                return( FALSE );
; 3004 : 
; 3005 :             default:
; 3006 :                return( FALSE );
; 3007 :          }
; 3008 : 
; 3009 :          // fall through
; 3010 : 
; 3011 :       case WM_INITDIALOG:
; 3012 :       {
; 3013 :          zCHAR       szLBItem[ 80 ];
; 3014 :          GLOBALENTRY ge;
; 3015 :          WORD        wFlags = GLOBAL_ALL;
; 3016 :          BOOL        bOkay;
; 3017 :          UINT        nShow = WM_USER;
; 3018 : #if 0
; 3019 :          zltoa( (zLONG) nShow, szLBItem );
; 3020 :          SendMessage( g_hWndLB, LB_ADDSTRING, 0, (zLONG)(zPCHAR) szLBItem );
; 3021 : #endif
; 3022 :          zmemset( (zPCHAR) &ge, 0, sizeof( ge ) );
; 3023 :          ge.dwSize = sizeof( GLOBALENTRY );
; 3024 :          bOkay = GlobalFirst( &ge, wFlags );
; 3025 :          while ( bOkay )
; 3026 :          {
; 3027 :             if ( ge.wType == GT_MODULE )
; 3028 :             {
; 3029 :                int   nCCount, i;
; 3030 :                char  ModuleName[ 13 ];
; 3031 :                WORD  wSel;
; 3032 :                WORD  wModNamePtr_Offset = 38; // offset in modules segment
; 3033 :                WORD  wModName_Offset;
; 3034 :                WORD  wLoadCount_Offset = 2;  // offset in modules segment
; 3035 :                WORD  wHandle_Offset = 82;    // offset in modules segment
; 3036 :                WORD  far *lpwLoadCount;
; 3037 :                WORD  far *lpwModuleNamePtr;
; 3038 :                char  far *lpcModuleName;
; 3039 :                WORD  far *lpwHandle;
; 3040 : 
; 3041 :                wSel = GlobalHandleToSel( ge.hOwner );
; 3042 : 
; 3043 :                lpwModuleNamePtr = MAKELP( wSel, wModNamePtr_Offset );
; 3044 :                wModName_Offset = *lpwModuleNamePtr;
; 3045 :                lpcModuleName = MAKELP( wSel, wModName_Offset );
; 3046 :                lpwLoadCount = MAKELP( wSel, wLoadCount_Offset );
; 3047 :                lpwHandle = MAKELP( wSel, wHandle_Offset );
; 3048 : 
; 3049 :                nCCount = *lpcModuleName++;
; 3050 :                for ( i = 0; i < nCCount; i++ )
; 3051 :                   ModuleName[ i ] = *lpcModuleName++;
; 3052 : 
; 3053 :                ModuleName[ i ] = 0;
; 3054 : 
; 3055 :                zstrcpy( szLBItem, ModuleName );
; 3056 :                i = zstrlen( szLBItem );
; 3057 :                while ( i < 9 )
; 3058 :                   szLBItem[ i++ ] = ' ';
; 3059 : 
; 3060 :                szLBItem[ i ] = 0;
; 3061 : 
; 3062 :                // show load count for module
; 3063 :                zltoa( *lpwLoadCount, szLBItem + zstrlen( szLBItem ) );
; 3064 : 
; 3065 :                //  add name and count to listbox
; 3066 :                wLBIndex = (WORD) SendDlgItemMessage( hWndDlg, IDC_DLLLB,
; 3067 :                                                  LB_ADDSTRING, 0,
; 3068 :                                                  (zLONG)(zPCHAR) szLBItem );
; 3069 :                // save handle of library
; 3070 :                SendDlgItemMessage( hWndDlg, IDC_DLLLB, LB_SETITEMDATA,
; 3071 :                                    wLBIndex, MAKELPARAM( *lpwHandle, 0 ) );
; 3072 :             }
; 3073 : 
; 3074 :             bOkay = GlobalNext( &ge, wFlags );
; 3075 :          }
; 3076 : 
; 3077 :          return( TRUE );
; 3078 :       }
; 3079 : 
; 3080 :       default:
; 3081 :          return( FALSE );
; 3082 :    }
; 3083 : #endif
; 3084 : }

	pop	ebp
	ret	16					; 00000010H
_ShowDLLDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_hWndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_FindStringDlgProc@16 PROC

; 2792 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2793 :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	SHORT $LN9@FindString
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN4@FindString
	jmp	$LN10@FindString
$LN4@FindString:

; 2794 :    {
; 2795 :       case WM_COMMAND:
; 2796 :          if ( wParam == IDC_OK )

	cmp	DWORD PTR _wParam$[ebp], 201		; 000000c9H
	jne	SHORT $LN5@FindString

; 2797 :          {
; 2798 :             GetDlgItemText( hWndDlg, IDC_FINDSTRING,

	push	256					; 00000100H
	push	OFFSET _g_szFindString
	push	224					; 000000e0H
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDlgItemTextA@16

; 2799 :                             g_szFindString, sizeof( g_szFindString ) );
; 2800 :             EndDialog( hWndDlg, IDOK );

	push	1
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__EndDialog@8

; 2801 :          }

	jmp	SHORT $LN6@FindString
$LN5@FindString:

; 2802 :          else
; 2803 :          if ( wParam == IDC_CANCEL )

	cmp	DWORD PTR _wParam$[ebp], 202		; 000000caH
	jne	SHORT $LN7@FindString

; 2804 :             EndDialog( hWndDlg, IDCANCEL );

	push	2
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__EndDialog@8
	jmp	SHORT $LN6@FindString
$LN7@FindString:

; 2805 :          else
; 2806 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@FindString
$LN6@FindString:

; 2807 : 
; 2808 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@FindString
$LN9@FindString:

; 2809 : 
; 2810 :       case WM_INITDIALOG:
; 2811 :          SendDlgItemMessage( hWndDlg, IDC_FINDSTRING, EM_LIMITTEXT,

	push	0
	push	256					; 00000100H
	push	197					; 000000c5H
	push	224					; 000000e0H
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20

; 2812 :                              sizeof( g_szFindString ), 0L );
; 2813 :          SetDlgItemText( hWndDlg, IDC_FINDSTRING, g_szFindString );

	push	OFFSET _g_szFindString
	push	224					; 000000e0H
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SetDlgItemTextA@12

; 2814 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@FindString
$LN10@FindString:

; 2815 : 
; 2816 :       default:
; 2817 :          return( FALSE );

	xor	eax, eax
$LN1@FindString:

; 2818 :    }
; 2819 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_FindStringDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_nTransFlag$1 = -8					; size = 4
tv64 = -4						; size = 4
_hWndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_LimitDlgProc@16 PROC

; 2882 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2883 :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	SHORT $LN9@LimitDlgPr
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN4@LimitDlgPr
	jmp	$LN10@LimitDlgPr
$LN4@LimitDlgPr:

; 2884 :    {
; 2885 :       case WM_COMMAND:
; 2886 :          if ( wParam == IDC_OK )

	cmp	DWORD PTR _wParam$[ebp], 201		; 000000c9H
	jne	SHORT $LN5@LimitDlgPr

; 2887 :          {
; 2888 :             BOOL nTransFlag;
; 2889 :             g_uTraceLineLimit = GetDlgItemInt( hWndDlg, IDC_LINELIMIT,

	push	0
	lea	ecx, DWORD PTR _nTransFlag$1[ebp]
	push	ecx
	push	206					; 000000ceH
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDlgItemInt@16
	mov	DWORD PTR _g_uTraceLineLimit, eax

; 2890 :                                                &nTransFlag, 0 );
; 2891 :             EndDialog( hWndDlg, TRUE );

	push	1
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__EndDialog@8

; 2892 :          }

	jmp	SHORT $LN9@LimitDlgPr
$LN5@LimitDlgPr:

; 2893 :          else
; 2894 :          if ( wParam == IDC_CANCEL )

	cmp	DWORD PTR _wParam$[ebp], 202		; 000000caH
	jne	SHORT $LN7@LimitDlgPr

; 2895 :             EndDialog( hWndDlg, TRUE );

	push	1
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndDialog@8
	jmp	SHORT $LN9@LimitDlgPr
$LN7@LimitDlgPr:

; 2896 :          else
; 2897 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@LimitDlgPr
$LN9@LimitDlgPr:

; 2898 : 
; 2899 :          // fall through
; 2900 : 
; 2901 :       case WM_INITDIALOG:
; 2902 :          SetDlgItemInt( hWndDlg, IDC_LINELIMIT, g_uTraceLineLimit, 0 );

	push	0
	mov	edx, DWORD PTR _g_uTraceLineLimit
	push	edx
	push	206					; 000000ceH
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SetDlgItemInt@16

; 2903 :          SetDlgItemInt( hWndDlg, IDC_LINEUSAGE,

	push	0
	push	0
	push	0
	push	395					; 0000018bH
	mov	ecx, DWORD PTR _g_hWndLB
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
	movzx	edx, ax
	push	edx
	push	207					; 000000cfH
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SetDlgItemInt@16

; 2904 :                         (WORD) SendMessage( g_hWndLB,
; 2905 :                                             LB_GETCOUNT, 0, 0 ), 0 );
; 2906 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@LimitDlgPr
$LN10@LimitDlgPr:

; 2907 : 
; 2908 :       default:
; 2909 :          return( FALSE );

	xor	eax, eax
$LN1@LimitDlgPr:

; 2910 :    }
; 2911 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_LimitDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
tv64 = -12						; size = 4
_lpTask$1 = -8						; size = 4
_iTraceLevel$2 = -4					; size = 4
_hWndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_SetTraceDlgProc@16 PROC

; 2825 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2826 :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	$LN20@SetTraceDl
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN7@SetTraceDl
	jmp	$LN21@SetTraceDl
$LN7@SetTraceDl:

; 2827 :    {
; 2828 :       case WM_COMMAND:
; 2829 :          if ( wParam == IDC_OK )

	cmp	DWORD PTR _wParam$[ebp], 201		; 000000c9H
	jne	$LN8@SetTraceDl

; 2830 :          {
; 2831 :             int iTraceLevel = -1;

	mov	DWORD PTR _iTraceLevel$2[ebp], -1

; 2832 : 
; 2833 :             if ( SendDlgItemMessage( hWndDlg, IDC_TRACE0, BM_GETCHECK, 0, 0 ) )

	push	0
	push	0
	push	240					; 000000f0H
	push	220					; 000000dcH
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	test	eax, eax
	je	SHORT $LN10@SetTraceDl

; 2834 :                iTraceLevel = 0;

	mov	DWORD PTR _iTraceLevel$2[ebp], 0
	jmp	SHORT $LN11@SetTraceDl
$LN10@SetTraceDl:

; 2835 :             else
; 2836 :             if ( SendDlgItemMessage( hWndDlg, IDC_TRACE1, BM_GETCHECK, 0, 0 ) )

	push	0
	push	0
	push	240					; 000000f0H
	push	221					; 000000ddH
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	test	eax, eax
	je	SHORT $LN12@SetTraceDl

; 2837 :                iTraceLevel = 1;

	mov	DWORD PTR _iTraceLevel$2[ebp], 1
	jmp	SHORT $LN11@SetTraceDl
$LN12@SetTraceDl:

; 2838 :             else
; 2839 :             if ( SendDlgItemMessage( hWndDlg, IDC_TRACE2, BM_GETCHECK, 0, 0 ) )

	push	0
	push	0
	push	240					; 000000f0H
	push	222					; 000000deH
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	test	eax, eax
	je	SHORT $LN14@SetTraceDl

; 2840 :                iTraceLevel = 2;

	mov	DWORD PTR _iTraceLevel$2[ebp], 2
	jmp	SHORT $LN11@SetTraceDl
$LN14@SetTraceDl:

; 2841 :             else
; 2842 :             if ( SendDlgItemMessage( hWndDlg, IDC_TRACE3, BM_GETCHECK, 0, 0 ) )

	push	0
	push	0
	push	240					; 000000f0H
	push	223					; 000000dfH
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	test	eax, eax
	je	SHORT $LN11@SetTraceDl

; 2843 :                iTraceLevel = 3;

	mov	DWORD PTR _iTraceLevel$2[ebp], 3
$LN11@SetTraceDl:

; 2844 : 
; 2845 :             if ( iTraceLevel >= 0 )

	cmp	DWORD PTR _iTraceLevel$2[ebp], 0
	jl	SHORT $LN17@SetTraceDl

; 2846 :             {
; 2847 :                LPTASK lpTask;
; 2848 : 
; 2849 :                for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$1[ebp], eax
	jmp	SHORT $LN6@SetTraceDl
$LN4@SetTraceDl:

; 2851 :                      lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	ecx, DWORD PTR _lpTask$1[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$1[ebp], eax
$LN6@SetTraceDl:

; 2850 :                      lpTask;

	cmp	DWORD PTR _lpTask$1[ebp], 0
	je	SHORT $LN5@SetTraceDl

; 2852 :                {
; 2853 :                   lpTask->nDBHandlerTraceLevel = iTraceLevel;

	mov	eax, DWORD PTR _lpTask$1[ebp]
	mov	cx, WORD PTR _iTraceLevel$2[ebp]
	mov	WORD PTR [eax+92], cx

; 2854 :                }

	jmp	SHORT $LN4@SetTraceDl
$LN5@SetTraceDl:

; 2855 : 
; 2856 :                TraceLineI( "(kzoengwa) DBH Trace Level for all tasks set to ",

	mov	edx, DWORD PTR _iTraceLevel$2[ebp]
	push	edx
	push	OFFSET $SG96834
	call	_TraceLineI@8
$LN17@SetTraceDl:

; 2857 :                            (zLONG) iTraceLevel );
; 2858 :             }
; 2859 : 
; 2860 :             EndDialog( hWndDlg, TRUE );

	push	1
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__EndDialog@8

; 2861 :          }

	jmp	SHORT $LN9@SetTraceDl
$LN8@SetTraceDl:

; 2862 :          else
; 2863 :          if ( wParam == IDC_CANCEL )

	cmp	DWORD PTR _wParam$[ebp], 202		; 000000caH
	jne	SHORT $LN18@SetTraceDl

; 2864 :             EndDialog( hWndDlg, TRUE );

	push	1
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndDialog@8
	jmp	SHORT $LN9@SetTraceDl
$LN18@SetTraceDl:

; 2865 :          else
; 2866 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@SetTraceDl
$LN9@SetTraceDl:

; 2867 : 
; 2868 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@SetTraceDl
$LN20@SetTraceDl:

; 2869 : 
; 2870 :       case WM_INITDIALOG:
; 2871 :          return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@SetTraceDl
$LN21@SetTraceDl:

; 2872 : 
; 2873 :       default:
; 2874 :          return( FALSE );

	xor	eax, eax
$LN1@SetTraceDl:

; 2875 :    }
; 2876 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetTraceDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
tv64 = -104						; size = 4
_szEncrypt$ = -100					; size = 32
_szPassword$ = -68					; size = 32
_szUserID$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_hWndDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_LogonDlgProc@16 PROC

; 2736 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2737 :    char szUserID[ 32 ];
; 2738 :    char szPassword[ 32 ];
; 2739 :    char szEncrypt[ 32 ];
; 2740 : 
; 2741 :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	$LN12@LogonDlgPr
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN4@LogonDlgPr
	jmp	$LN13@LogonDlgPr
$LN4@LogonDlgPr:

; 2742 :    {
; 2743 :       case WM_COMMAND:
; 2744 :          if ( wParam == IDC_OK )

	cmp	DWORD PTR _wParam$[ebp], 201		; 000000c9H
	jne	$LN5@LogonDlgPr

; 2745 :          {
; 2746 :             GetDlgItemText( hWndDlg, IDC_USERID,

	push	32					; 00000020H
	lea	ecx, DWORD PTR _szUserID$[ebp]
	push	ecx
	push	210					; 000000d2H
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDlgItemTextA@16

; 2747 :                             szUserID, sizeof( szUserID ) );
; 2748 :             GetDlgItemText( hWndDlg, IDC_PASSWORD,

	push	32					; 00000020H
	lea	eax, DWORD PTR _szPassword$[ebp]
	push	eax
	push	211					; 000000d3H
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDlgItemTextA@16

; 2749 :                             szPassword, sizeof( szPassword ) );
; 2750 : 
; 2751 :             if ( szUserID[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szUserID$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN7@LogonDlgPr

; 2752 :             {
; 2753 :                // Set global Userid and password in CORE
; 2754 :                SysSetUserID( 0, szUserID, szPassword );

	lea	edx, DWORD PTR _szPassword$[ebp]
	push	edx
	lea	eax, DWORD PTR _szUserID$[ebp]
	push	eax
	push	0
	call	_SysSetUserID@12

; 2755 :                // See if the save button is checked
; 2756 :                if ( SendDlgItemMessage( hWndDlg, IDC_SAVEUSERID,

	push	0
	push	0
	push	240					; 000000f0H
	push	212					; 000000d4H
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SendDlgItemMessageA@20
	test	eax, eax
	je	SHORT $LN9@LogonDlgPr

; 2757 :                                         BM_GETCHECK, 0, 0L ) )
; 2758 :                {
; 2759 :                   SysUpdateZeidonIni( szlWorkstation, szlUserID, szUserID );

	lea	edx, DWORD PTR _szUserID$[ebp]
	push	edx
	push	OFFSET _szlUserID
	push	OFFSET _szlWorkstation
	call	_SysUpdateZeidonIni@12

; 2760 :                   UfEncryptString( szEncrypt, szPassword, 26 );

	push	26					; 0000001aH
	lea	eax, DWORD PTR _szPassword$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szEncrypt$[ebp]
	push	ecx
	call	_UfEncryptString@12

; 2761 :                   SysUpdateZeidonIni( szlWorkstation, szlPassword, szEncrypt );

	lea	edx, DWORD PTR _szEncrypt$[ebp]
	push	edx
	push	OFFSET _szlPassword
	push	OFFSET _szlWorkstation
	call	_SysUpdateZeidonIni@12
$LN9@LogonDlgPr:

; 2762 :                }
; 2763 : 
; 2764 :                EndDialog( hWndDlg, TRUE );

	push	1
	mov	eax, DWORD PTR _hWndDlg$[ebp]
	push	eax
	call	DWORD PTR __imp__EndDialog@8

; 2765 :             }

	jmp	SHORT $LN8@LogonDlgPr
$LN7@LogonDlgPr:

; 2766 :             else
; 2767 :                return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@LogonDlgPr
$LN8@LogonDlgPr:

; 2768 :          }

	jmp	SHORT $LN12@LogonDlgPr
$LN5@LogonDlgPr:

; 2769 :          else
; 2770 :          if ( wParam == IDC_CANCEL )

	cmp	DWORD PTR _wParam$[ebp], 202		; 000000caH
	jne	SHORT $LN10@LogonDlgPr

; 2771 :             EndDialog( hWndDlg, TRUE );

	push	1
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndDialog@8
	jmp	SHORT $LN12@LogonDlgPr
$LN10@LogonDlgPr:

; 2772 :          else
; 2773 :             return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@LogonDlgPr
$LN12@LogonDlgPr:

; 2774 : 
; 2775 :          // fall through
; 2776 : 
; 2777 :       case WM_INITDIALOG:
; 2778 :          SysGetUserID( 0, szUserID, szPassword );

	lea	edx, DWORD PTR _szPassword$[ebp]
	push	edx
	lea	eax, DWORD PTR _szUserID$[ebp]
	push	eax
	push	0
	call	_SysGetUserID@12

; 2779 :          SetDlgItemText( hWndDlg, IDC_USERID, szUserID );

	lea	ecx, DWORD PTR _szUserID$[ebp]
	push	ecx
	push	210					; 000000d2H
	mov	edx, DWORD PTR _hWndDlg$[ebp]
	push	edx
	call	DWORD PTR __imp__SetDlgItemTextA@12

; 2780 :          SetDlgItemText( hWndDlg, IDC_PASSWORD, szPassword );

	lea	eax, DWORD PTR _szPassword$[ebp]
	push	eax
	push	211					; 000000d3H
	mov	ecx, DWORD PTR _hWndDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetDlgItemTextA@12

; 2781 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@LogonDlgPr
$LN13@LogonDlgPr:

; 2782 : 
; 2783 :       default:
; 2784 :          return( FALSE );

	xor	eax, eax
$LN1@LogonDlgPr:

; 2785 :    }
; 2786 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_LogonDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
tv64 = -4						; size = 4
_hDlg$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_AboutDlgProc@16 PROC

; 2103 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2104 :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 272		; 00000110H
	je	SHORT $LN5@AboutDlgPr
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	SHORT $LN4@AboutDlgPr
	jmp	SHORT $LN6@AboutDlgPr
$LN4@AboutDlgPr:

; 2105 :    {
; 2106 :       case WM_COMMAND:
; 2107 :          EndDialog( hDlg, TRUE );

	push	1
	mov	ecx, DWORD PTR _hDlg$[ebp]
	push	ecx
	call	DWORD PTR __imp__EndDialog@8
$LN5@AboutDlgPr:

; 2108 : 
; 2109 :          // fall through
; 2110 : 
; 2111 :       case WM_INITDIALOG:
; 2112 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@AboutDlgPr
$LN6@AboutDlgPr:

; 2113 : 
; 2114 :       default:
; 2115 :          return( FALSE );

	xor	eax, eax
$LN1@AboutDlgPr:

; 2116 :    }
; 2117 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_AboutDlgProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_point$1 = -8232					; size = 8
_hTask$2 = -8224					; size = 4
_lpOldInt$3 = -8220					; size = 4
_lpTask2$4 = -8216					; size = 4
_lpTaskTemp$5 = -8212					; size = 4
_nOldTraceWindow$6 = -8208				; size = 4
_iDiff$7 = -8204					; size = 4
_idx$8 = -8200						; size = 4
_hLogFile$9 = -8196					; size = 4
_j$10 = -8192						; size = 4
_ulAlloc$11 = -8188					; size = 4
_lpDataHeader$12 = -8184				; size = 4
tv796 = -8180						; size = 4
tv791 = -8176						; size = 4
tv782 = -8172						; size = 4
tv777 = -8168						; size = 4
_lTextLth$13 = -8164					; size = 4
tv516 = -8160						; size = 4
tv768 = -8156						; size = 4
tv521 = -8152						; size = 4
_hMenu$14 = -8148					; size = 4
_hTask$15 = -8144					; size = 4
_nResponse$16 = -8140					; size = 4
tv749 = -8136						; size = 4
tv754 = -8132						; size = 4
tv763 = -8128						; size = 4
_hNewInt$17 = -8124					; size = 4
$T18 = -8120						; size = 4
$T19 = -8116						; size = 4
$T20 = -8112						; size = 4
_hTask$21 = -8108					; size = 4
_nNewTraceWindow$22 = -8104				; size = 4
_ulUsed$23 = -8100					; size = 4
tv489 = -8096						; size = 4
_lpTask$24 = -8092					; size = 4
_lpTask$25 = -8088					; size = 4
_lpFreespace$26 = -8084					; size = 4
_ulFree$27 = -8080					; size = 4
_hTermMutex$28 = -8076					; size = 4
_k$29 = -8072						; size = 4
_k$30 = -8068						; size = 4
_pchMem$31 = -8064					; size = 4
_i$32 = -8060						; size = 4
_lpViewOD$33 = -8056					; size = 4
_lpTask$34 = -8052					; size = 4
_hMenu$35 = -8048					; size = 4
_nFound$36 = -8044					; size = 4
_wCurSel$37 = -8040					; size = 2
_wCurSel$38 = -8036					; size = 2
_wCurSel$39 = -8032					; size = 2
_lpApp$40 = -8028					; size = 4
_nResponse$41 = -8024					; size = 4
_hwndTrace$42 = -8020					; size = 4
_nLth$43 = -8016					; size = 2
_hMenu$44 = -8012					; size = 4
tv64 = -8008						; size = 4
_wCurSel$45 = -8004					; size = 2
_wItemCnt$46 = -8000					; size = 2
_lpTask$47 = -7996					; size = 4
_wCurSel$48 = -7992					; size = 2
_lpIntl$49 = -7988					; size = 4
_k$50 = -7984						; size = 2
_wCommand$51 = -7980					; size = 2
_wp$52 = -7976						; size = 44
_rect$ = -7932						; size = 16
_SysTime$53 = -7916					; size = 16
_szMsg$54 = -7900					; size = 4000
_szFindString$55 = -3900				; size = 512
_szTempName$56 = -3388					; size = 257
_szTempName$57 = -3128					; size = 260
_szTraceText$58 = -2868					; size = 512
_szText$59 = -2356					; size = 512
_szFileName$60 = -1844					; size = 257
_szFileName$61 = -1584					; size = 256
_szIniName$62 = -1328					; size = 260
_szMessage$63 = -1068					; size = 512
_szMessage$64 = -556					; size = 160
_szFileName$65 = -396					; size = 260
_szBuffer$66 = -136					; size = 130
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainWndProc@16 PROC

; 669  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 8232				; 00002028H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 670  :    RECT   rect;
; 671  : 
; 672  :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	ja	SHORT $LN237@MainWndPro
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	$LN32@MainWndPro
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 24			; 00000018H
	ja	$LN208@MainWndPro
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN239@MainWndPro[edx]
	jmp	DWORD PTR $LN240@MainWndPro[eax*4]
$LN237@MainWndPro:
	cmp	DWORD PTR tv64[ebp], 2050		; 00000802H
	ja	SHORT $LN238@MainWndPro
	cmp	DWORD PTR tv64[ebp], 2050		; 00000802H
	je	$LN207@MainWndPro
	cmp	DWORD PTR tv64[ebp], 274		; 00000112H
	je	SHORT $LN30@MainWndPro
	cmp	DWORD PTR tv64[ebp], 2049		; 00000801H
	je	$LN204@MainWndPro
	jmp	$LN208@MainWndPro
$LN238@MainWndPro:
	cmp	DWORD PTR tv64[ebp], 32868		; 00008064H
	je	SHORT $LN28@MainWndPro
	jmp	$LN208@MainWndPro
$LN28@MainWndPro:

; 673  :    {
; 674  :       //entry for systray notifications
; 675  :       case zWM_NOTIFYICON:
; 676  :          if (lParam == WM_RBUTTONDOWN )

	cmp	DWORD PTR _lParam$[ebp], 516		; 00000204H
	jne	SHORT $LN29@MainWndPro

; 677  :          {
; 678  :             POINT point;
; 679  : 
; 680  :             GetCursorPos( &point );

	lea	ecx, DWORD PTR _point$1[ebp]
	push	ecx
	call	DWORD PTR __imp__GetCursorPos@4

; 681  :             HandlePopupMenu( hWnd, point );

	mov	edx, DWORD PTR _point$1[ebp+4]
	push	edx
	mov	eax, DWORD PTR _point$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	_HandlePopupMenu@12
$LN29@MainWndPro:

; 682  :          }
; 683  : 
; 684  :          break;

	jmp	$LN2@MainWndPro
$LN30@MainWndPro:

; 685  : 
; 686  :       case WM_SYSCOMMAND:
; 687  :          //if ( (wParam & 0xFFF0) == SC_MINIMIZE )
; 688  :          //   return( 0 );
; 689  : 
; 690  :          return( DefWindowProc( hWnd, uMsg, wParam, lParam ) );

	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__DefWindowProcA@16
	jmp	$LN210@MainWndPro
$LN31@MainWndPro:

; 691  : 
; 692  :       case WM_SIZE:
; 693  :       {
; 694  :          UINT i;
; 695  : 
; 696  :          GetClientRect( hWnd, &rect );

	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8

; 697  : 
; 698  :          for ( i = 0; i < g_nTraceWindowCnt; i++ )

	mov	DWORD PTR _i$32[ebp], 0
	jmp	SHORT $LN6@MainWndPro
$LN4@MainWndPro:
	mov	edx, DWORD PTR _i$32[ebp]
	add	edx, 1
	mov	DWORD PTR _i$32[ebp], edx
$LN6@MainWndPro:
	mov	eax, DWORD PTR _i$32[ebp]
	cmp	eax, DWORD PTR _g_nTraceWindowCnt
	jae	SHORT $LN5@MainWndPro

; 699  :             MoveWindow( g_hwndTraceWindow[ i ], rect.left, rect.top,

	push	1
	mov	ecx, DWORD PTR _rect$[ebp+12]
	sub	ecx, DWORD PTR _rect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _rect$[ebp+8]
	sub	edx, DWORD PTR _rect$[ebp]
	push	edx
	mov	eax, DWORD PTR _rect$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$32[ebp]
	mov	eax, DWORD PTR _g_hwndTraceWindow[edx*4]
	push	eax
	call	DWORD PTR __imp__MoveWindow@24
	jmp	SHORT $LN4@MainWndPro
$LN5@MainWndPro:

; 700  :                         rect.right - rect.left, rect.bottom - rect.top, TRUE );
; 701  :          break;

	jmp	$LN2@MainWndPro
$LN32@MainWndPro:

; 702  :       }
; 703  : 
; 704  :       case WM_COMMAND:
; 705  :       {
; 706  :          WORD wCommand;
; 707  : #ifdef __WIN32__
; 708  :          wCommand = LOWORD( wParam ); // command identifier

	mov	ecx, DWORD PTR _wParam$[ebp]
	and	ecx, 65535				; 0000ffffH
	mov	WORD PTR _wCommand$51[ebp], cx

; 709  : #else
; 710  :          wCommand = wParam;         // command identifier
; 711  : #endif
; 712  : //       TraceLineI( "OE WM_COMMAND wCommand: ", wCommand );
; 713  :          if ( wCommand == IDM_SHOWTRACE )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 321				; 00000141H
	jne	SHORT $LN33@MainWndPro

; 714  :          {
; 715  :             ShowWindow( g_hWndMainFrame, SW_RESTORE );

	push	9
	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 716  :          }

	jmp	$LN34@MainWndPro
$LN33@MainWndPro:

; 717  :          else
; 718  :          if ( wCommand == IDM_LOGON )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 111				; 0000006fH
	jne	SHORT $LN35@MainWndPro

; 719  :          {
; 720  :             DialogBox( hInst, MAKEINTRESOURCE( IDD_LOGON ), hWnd, fpLogon );

	push	0
	mov	edx, DWORD PTR _fpLogon
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	104					; 00000068H
	mov	ecx, DWORD PTR _hInst
	push	ecx
	call	DWORD PTR __imp__DialogBoxParamA@20

; 721  :          }

	jmp	$LN34@MainWndPro
$LN35@MainWndPro:

; 722  :          else
; 723  :          if ( wCommand == IDM_LOGTRACE )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 121				; 00000079H
	jne	SHORT $LN37@MainWndPro

; 724  :          {
; 725  :             DialogBox( hInst, MAKEINTRESOURCE( IDD_LOGTRACE ),

	push	0
	mov	eax, DWORD PTR _fpLogTrace
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	push	101					; 00000065H
	mov	edx, DWORD PTR _hInst
	push	edx
	call	DWORD PTR __imp__DialogBoxParamA@20

; 726  :                        hWnd, fpLogTrace );
; 727  :          }

	jmp	$LN34@MainWndPro
$LN37@MainWndPro:

; 728  :          else
; 729  :          if ( wCommand == IDM_SHOWDLL )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 114				; 00000072H
	jne	SHORT $LN39@MainWndPro

; 730  :          {
; 731  :             DialogBox( hInst, MAKEINTRESOURCE( IDD_SHOWDLL ),

	push	0
	mov	ecx, DWORD PTR _fpShowDLL
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	push	103					; 00000067H
	mov	eax, DWORD PTR _hInst
	push	eax
	call	DWORD PTR __imp__DialogBoxParamA@20

; 732  :                        hWnd, fpShowDLL );
; 733  :          }

	jmp	$LN34@MainWndPro
$LN39@MainWndPro:

; 734  :          else
; 735  :          if ( wCommand == IDM_LINELIMIT )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 123				; 0000007bH
	jne	SHORT $LN41@MainWndPro

; 736  :          {
; 737  :             DialogBox( hInst, MAKEINTRESOURCE( IDD_LINELIMIT ),

	push	0
	mov	edx, DWORD PTR _fpLineLimit
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	102					; 00000066H
	mov	ecx, DWORD PTR _hInst
	push	ecx
	call	DWORD PTR __imp__DialogBoxParamA@20

; 738  :                        hWnd, fpLineLimit );
; 739  :             if ( g_uTraceLineLimit == 0 )

	cmp	DWORD PTR _g_uTraceLineLimit, 0
	jne	SHORT $LN43@MainWndPro

; 740  :             {
; 741  :                SendMessage( g_hWndLB, LB_RESETCONTENT, 0, 0L );

	push	0
	push	0
	push	388					; 00000184H
	mov	edx, DWORD PTR _g_hWndLB
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 742  :                AnchorBlock->bTraceCnt = FALSE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 743  :             }

	jmp	SHORT $LN44@MainWndPro
$LN43@MainWndPro:

; 744  :             else
; 745  :                AnchorBlock->bTraceCnt = TRUE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	or	ecx, 2
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx
$LN44@MainWndPro:

; 746  :          }

	jmp	$LN34@MainWndPro
$LN41@MainWndPro:

; 747  :          else
; 748  :          if ( wCommand == IDM_FINDSTRING ||
; 749  :               wCommand == IDM_FINDNEXT ||

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 150				; 00000096H
	je	SHORT $LN47@MainWndPro
	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 151				; 00000097H
	je	SHORT $LN47@MainWndPro
	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 152				; 00000098H
	jne	$LN45@MainWndPro
$LN47@MainWndPro:

; 750  :               wCommand == IDM_FINDPREV )
; 751  :          {
; 752  :             if ( wCommand == IDM_FINDSTRING )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 150				; 00000096H
	jne	SHORT $LN48@MainWndPro

; 753  :             {
; 754  :                if ( DialogBox( hInst, MAKEINTRESOURCE( IDD_FINDSTRING ),
; 755  :                                hWnd, fpFindString ) != IDOK )

	push	0
	mov	ecx, DWORD PTR _fpFindString
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	push	107					; 0000006bH
	mov	eax, DWORD PTR _hInst
	push	eax
	call	DWORD PTR __imp__DialogBoxParamA@20
	cmp	eax, 1
	je	SHORT $LN48@MainWndPro

; 756  :                {
; 757  :                   break;

	jmp	$LN2@MainWndPro
$LN48@MainWndPro:

; 758  :                }
; 759  :             }
; 760  : 
; 761  :             if ( g_szFindString[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _g_szFindString[edx]
	test	eax, eax
	jne	SHORT $LN50@MainWndPro

; 762  :                break;

	jmp	$LN2@MainWndPro
	jmp	$LN51@MainWndPro
$LN50@MainWndPro:

; 763  :             else
; 764  :             {
; 765  :                char szFindString[ 512 ];
; 766  :                char szText[ 512 ];
; 767  :                int  nFound = 0;

	mov	DWORD PTR _nFound$36[ebp], 0

; 768  :                HWND hwndTrace = g_hwndTraceWindow[ g_nTraceWindowDisplayed ];

	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	mov	DWORD PTR _hwndTrace$42[ebp], edx

; 769  :                WORD wItemCnt = (WORD) SendMessage( hwndTrace, LB_GETCOUNT, 0, 0 );

	push	0
	push	0
	push	395					; 0000018bH
	mov	eax, DWORD PTR _hwndTrace$42[ebp]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wItemCnt$46[ebp], ax

; 770  :                WORD wCurSel = (WORD) SendMessage( hwndTrace, LB_GETCURSEL, 0, 0L );

	push	0
	push	0
	push	392					; 00000188H
	mov	ecx, DWORD PTR _hwndTrace$42[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wCurSel$48[ebp], ax

; 771  :                WORD k;
; 772  : 
; 773  :                zstrcpy( szFindString, g_szFindString );

	push	OFFSET _g_szFindString
	lea	edx, DWORD PTR _szFindString$55[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 774  :                SysTranslateString( szFindString, 'L' );

	push	76					; 0000004cH
	lea	eax, DWORD PTR _szFindString$55[ebp]
	push	eax
	call	_SysTranslateString@8

; 775  :                if ( wCommand == IDM_FINDPREV )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 152				; 00000098H
	jne	SHORT $LN52@MainWndPro

; 776  :                {
; 777  :                   if ( wCurSel <= 0 )

	movzx	edx, WORD PTR _wCurSel$48[ebp]
	test	edx, edx
	jg	SHORT $LN54@MainWndPro

; 778  :                   {
; 779  :                      wCurSel = wItemCnt;

	mov	ax, WORD PTR _wItemCnt$46[ebp]
	mov	WORD PTR _wCurSel$48[ebp], ax

; 780  :                      k = wItemCnt - 1;

	movzx	ecx, WORD PTR _wItemCnt$46[ebp]
	sub	ecx, 1
	mov	WORD PTR _k$50[ebp], cx

; 781  :                   }

	jmp	SHORT $LN55@MainWndPro
$LN54@MainWndPro:

; 782  :                   else
; 783  :                   {
; 784  :                      k = wCurSel - 1;

	movzx	edx, WORD PTR _wCurSel$48[ebp]
	sub	edx, 1
	mov	WORD PTR _k$50[ebp], dx
$LN55@MainWndPro:

; 785  :                   }
; 786  :                }

	jmp	SHORT $LN7@MainWndPro
$LN52@MainWndPro:

; 787  :                else
; 788  :                {
; 789  :                   if ( wCurSel > wItemCnt - 1 || wCurSel == (WORD) -1 )

	movzx	eax, WORD PTR _wCurSel$48[ebp]
	movzx	ecx, WORD PTR _wItemCnt$46[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jg	SHORT $LN58@MainWndPro
	movzx	edx, WORD PTR _wCurSel$48[ebp]
	cmp	edx, 65535				; 0000ffffH
	jne	SHORT $LN56@MainWndPro
$LN58@MainWndPro:

; 790  :                   {
; 791  :                      wCurSel = (WORD) -1;

	mov	eax, 65535				; 0000ffffH
	mov	WORD PTR _wCurSel$48[ebp], ax

; 792  :                      k = 0;

	xor	ecx, ecx
	mov	WORD PTR _k$50[ebp], cx

; 793  :                   }

	jmp	SHORT $LN7@MainWndPro
$LN56@MainWndPro:

; 794  :                   else
; 795  :                   {
; 796  :                      k = wCurSel + 1;

	movzx	edx, WORD PTR _wCurSel$48[ebp]
	add	edx, 1
	mov	WORD PTR _k$50[ebp], dx
$LN7@MainWndPro:

; 797  :                   }
; 798  :                }
; 799  : 
; 800  :                while ( wItemCnt )

	movzx	eax, WORD PTR _wItemCnt$46[ebp]
	test	eax, eax
	je	$LN8@MainWndPro

; 801  :                {
; 802  :                   if ( k < wItemCnt )

	movzx	ecx, WORD PTR _k$50[ebp]
	movzx	edx, WORD PTR _wItemCnt$46[ebp]
	cmp	ecx, edx
	jge	$LN59@MainWndPro

; 803  :                   {
; 804  :                      SendMessage( hwndTrace, LB_GETTEXT, k, (LPARAM) szText );

	lea	eax, DWORD PTR _szText$59[ebp]
	push	eax
	movzx	ecx, WORD PTR _k$50[ebp]
	push	ecx
	push	393					; 00000189H
	mov	edx, DWORD PTR _hwndTrace$42[ebp]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 805  :                      SysTranslateString( szText, 'L' );

	push	76					; 0000004cH
	lea	eax, DWORD PTR _szText$59[ebp]
	push	eax
	call	_SysTranslateString@8

; 806  :                      if ( zstrstr( szText, szFindString ) )

	lea	ecx, DWORD PTR _szFindString$55[ebp]
	push	ecx
	lea	edx, DWORD PTR _szText$59[ebp]
	push	edx
	call	_strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN59@MainWndPro

; 807  :                      {
; 808  :                         SendMessage( hwndTrace, LB_SETCURSEL, k, 0L );

	push	0
	movzx	eax, WORD PTR _k$50[ebp]
	push	eax
	push	390					; 00000186H
	mov	ecx, DWORD PTR _hwndTrace$42[ebp]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 809  :                         SetFocus( hwndTrace );

	mov	edx, DWORD PTR _hwndTrace$42[ebp]
	push	edx
	call	DWORD PTR __imp__SetFocus@4

; 810  :                         nFound++;

	mov	eax, DWORD PTR _nFound$36[ebp]
	add	eax, 1
	mov	DWORD PTR _nFound$36[ebp], eax

; 811  :                         break;

	jmp	$LN8@MainWndPro
$LN59@MainWndPro:

; 812  :                      }
; 813  :                   }
; 814  : 
; 815  :                   if ( k == wCurSel )

	movzx	ecx, WORD PTR _k$50[ebp]
	movzx	edx, WORD PTR _wCurSel$48[ebp]
	cmp	ecx, edx
	jne	SHORT $LN61@MainWndPro

; 816  :                      break;

	jmp	$LN8@MainWndPro
	jmp	$LN62@MainWndPro
$LN61@MainWndPro:

; 817  :                   else
; 818  :                   if ( wCommand == IDM_FINDPREV )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 152				; 00000098H
	jne	$LN63@MainWndPro

; 819  :                   {
; 820  :                      if ( k <= 0 )

	movzx	ecx, WORD PTR _k$50[ebp]
	test	ecx, ecx
	jg	SHORT $LN65@MainWndPro

; 821  :                      {
; 822  :                         if ( wCurSel == wItemCnt )

	movzx	edx, WORD PTR _wCurSel$48[ebp]
	movzx	eax, WORD PTR _wItemCnt$46[ebp]
	cmp	edx, eax
	jne	SHORT $LN67@MainWndPro

; 823  :                            break;       // no need to wrap

	jmp	$LN8@MainWndPro
	jmp	SHORT $LN68@MainWndPro
$LN67@MainWndPro:

; 824  :                         else
; 825  :                         if ( MessageBox( hWnd, "Wrap to continue search?",
; 826  :                                          "Zeidon Object Services",
; 827  :                                          MB_ICONQUESTION |
; 828  :                                             MB_YESNO | MB_APPLMODAL ) == IDNO )

	push	36					; 00000024H
	push	OFFSET $SG96279
	push	OFFSET $SG96280
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	eax, 7
	jne	SHORT $LN68@MainWndPro

; 829  :                         {
; 830  :                            SetFocus( hwndTrace );

	mov	edx, DWORD PTR _hwndTrace$42[ebp]
	push	edx
	call	DWORD PTR __imp__SetFocus@4

; 831  :                            nFound = 1;  // pretend we found one

	mov	DWORD PTR _nFound$36[ebp], 1

; 832  :                            break;       // don't keep looking

	jmp	$LN8@MainWndPro
$LN68@MainWndPro:

; 833  :                         }
; 834  : 
; 835  :                         k = wItemCnt - 1;

	movzx	eax, WORD PTR _wItemCnt$46[ebp]
	sub	eax, 1
	mov	WORD PTR _k$50[ebp], ax

; 836  :                      }

	jmp	SHORT $LN66@MainWndPro
$LN65@MainWndPro:

; 837  :                      else
; 838  :                      {
; 839  :                         k--;

	mov	cx, WORD PTR _k$50[ebp]
	sub	cx, 1
	mov	WORD PTR _k$50[ebp], cx
$LN66@MainWndPro:

; 840  :                      }
; 841  :                   }

	jmp	SHORT $LN62@MainWndPro
$LN63@MainWndPro:

; 842  :                   else
; 843  :                   {
; 844  :                      if ( k >= wItemCnt - 1 )

	movzx	edx, WORD PTR _k$50[ebp]
	movzx	eax, WORD PTR _wItemCnt$46[ebp]
	sub	eax, 1
	cmp	edx, eax
	jl	SHORT $LN70@MainWndPro

; 845  :                      {
; 846  :                         if ( wCurSel == -1 )

	movzx	ecx, WORD PTR _wCurSel$48[ebp]
	cmp	ecx, -1
	jne	SHORT $LN72@MainWndPro

; 847  :                            break;       // no need to wrap

	jmp	SHORT $LN8@MainWndPro
	jmp	SHORT $LN73@MainWndPro
$LN72@MainWndPro:

; 848  :                         else
; 849  :                         if ( MessageBox( hWnd, "Wrap to continue search?",
; 850  :                                          "Zeidon Object Services",
; 851  :                                          MB_ICONQUESTION |
; 852  :                                             MB_YESNO | MB_APPLMODAL ) == IDNO )

	push	36					; 00000024H
	push	OFFSET $SG96286
	push	OFFSET $SG96287
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__MessageBoxA@16
	cmp	eax, 7
	jne	SHORT $LN73@MainWndPro

; 853  :                         {
; 854  :                            SetFocus( hwndTrace );

	mov	eax, DWORD PTR _hwndTrace$42[ebp]
	push	eax
	call	DWORD PTR __imp__SetFocus@4

; 855  :                            nFound = 1;  // pretend we found one

	mov	DWORD PTR _nFound$36[ebp], 1

; 856  :                            break;       // don't keep looking

	jmp	SHORT $LN8@MainWndPro
$LN73@MainWndPro:

; 857  :                         }
; 858  : 
; 859  :                         k = 0;

	xor	ecx, ecx
	mov	WORD PTR _k$50[ebp], cx

; 860  :                      }

	jmp	SHORT $LN62@MainWndPro
$LN70@MainWndPro:

; 861  :                      else
; 862  :                      {
; 863  :                         k++;

	mov	dx, WORD PTR _k$50[ebp]
	add	dx, 1
	mov	WORD PTR _k$50[ebp], dx
$LN62@MainWndPro:

; 864  :                      }
; 865  :                   }
; 866  :                }

	jmp	$LN7@MainWndPro
$LN8@MainWndPro:

; 867  : 
; 868  :                if ( nFound == 0 )

	cmp	DWORD PTR _nFound$36[ebp], 0
	jne	SHORT $LN51@MainWndPro

; 869  :                {
; 870  :                   zstrcpy( szText, "Search string not found - " );

	push	OFFSET $SG96289
	lea	eax, DWORD PTR _szText$59[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 871  :                   zstrcat( szText, g_szFindString );

	push	OFFSET _g_szFindString
	lea	ecx, DWORD PTR _szText$59[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 872  :                   MessageBox( hWnd, szText, "Zeidon Object Engine",

	push	64					; 00000040H
	push	OFFSET $SG96290
	lea	edx, DWORD PTR _szText$59[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
$LN51@MainWndPro:

; 873  :                               MB_OK | MB_ICONINFORMATION );
; 874  :                }
; 875  :             }
; 876  :          }

	jmp	$LN34@MainWndPro
$LN45@MainWndPro:

; 877  :          else
; 878  :          if ( wCommand == IDM_COPYSTRING || wCommand == IDM_CUTSTRING )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 165				; 000000a5H
	je	SHORT $LN78@MainWndPro
	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 167				; 000000a7H
	jne	$LN76@MainWndPro
$LN78@MainWndPro:

; 879  :          {
; 880  :             WORD wCurSel = (WORD) SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	push	0
	push	392					; 00000188H
	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wCurSel$45[ebp], ax

; 881  :                                                LB_GETCURSEL, 0, 0 );
; 882  :             zLONG lTextLth =

	push	0
	movzx	edx, WORD PTR _wCurSel$45[ebp]
	push	edx
	push	394					; 0000018aH
	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16
	mov	DWORD PTR _lTextLth$13[ebp], eax

; 883  :                 SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],
; 884  :                              LB_GETTEXTLEN, wCurSel, 0L );
; 885  :             if ( lTextLth < sizeof( g_szCopyBuffer ) )

	cmp	DWORD PTR _lTextLth$13[ebp], 512	; 00000200H
	jae	SHORT $LN79@MainWndPro

; 886  :             {
; 887  :                SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	OFFSET _g_szCopyBuffer
	movzx	edx, WORD PTR _wCurSel$45[ebp]
	push	edx
	push	393					; 00000189H
	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 888  :                             LB_GETTEXT, wCurSel, (LPARAM) g_szCopyBuffer );
; 889  :             }

	jmp	SHORT $LN80@MainWndPro
$LN79@MainWndPro:

; 890  :             else
; 891  :             {
; 892  :                char *pchMem;
; 893  : 
; 894  :                SfAllocTaskMemory( g_vSystemTaskView,

	mov	edx, DWORD PTR _lTextLth$13[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _pchMem$31[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_vSystemTaskView
	push	ecx
	call	_SfAllocTaskMemory@12

; 895  :                                   (zCOREMEM) &pchMem, lTextLth + 1 );
; 896  :                SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	mov	edx, DWORD PTR _pchMem$31[ebp]
	push	edx
	movzx	eax, WORD PTR _wCurSel$45[ebp]
	push	eax
	push	393					; 00000189H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 897  :                             LB_GETTEXT, wCurSel, (LPARAM) pchMem );
; 898  :                pchMem[ sizeof( g_szCopyBuffer ) - 1 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 511
	mov	edx, DWORD PTR _pchMem$31[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 899  :                strcpy( g_szCopyBuffer, pchMem );

	mov	eax, DWORD PTR _pchMem$31[ebp]
	push	eax
	push	OFFSET _g_szCopyBuffer
	call	_strcpy
	add	esp, 8

; 900  :                SfFreeTaskMemory( pchMem );

	mov	ecx, DWORD PTR _pchMem$31[ebp]
	push	ecx
	call	_SfFreeTaskMemory@4
$LN80@MainWndPro:

; 901  :             }
; 902  : 
; 903  :             if ( wCommand == IDM_CUTSTRING )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 167				; 000000a7H
	jne	SHORT $LN81@MainWndPro

; 904  :             {
; 905  :                SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	movzx	eax, WORD PTR _wCurSel$45[ebp]
	push	eax
	push	386					; 00000182H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 906  :                             LB_DELETESTRING, wCurSel, 0L );
; 907  :                SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	movzx	eax, WORD PTR _wCurSel$45[ebp]
	push	eax
	push	390					; 00000186H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
$LN81@MainWndPro:

; 908  :                             LB_SETCURSEL, wCurSel, 0L );
; 909  :             }
; 910  :          }

	jmp	$LN34@MainWndPro
$LN76@MainWndPro:

; 911  :          else
; 912  :          if ( wCommand == IDM_PASTESTRING )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 166				; 000000a6H
	jne	SHORT $LN82@MainWndPro

; 913  :          {
; 914  :             WORD wCurSel =

	push	0
	push	0
	push	392					; 00000188H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wCurSel$39[ebp], ax

; 915  :                (WORD) SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],
; 916  :                                    LB_GETCURSEL, 0, 0 );
; 917  :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	OFFSET _g_szCopyBuffer
	movzx	eax, WORD PTR _wCurSel$39[ebp]
	add	eax, 1
	push	eax
	push	385					; 00000181H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 918  :                          LB_INSERTSTRING,
; 919  :                          wCurSel + 1, (LPARAM) g_szCopyBuffer );
; 920  :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	movzx	eax, WORD PTR _wCurSel$39[ebp]
	add	eax, 1
	push	eax
	push	390					; 00000186H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 921  :                          LB_SETCURSEL, wCurSel + 1, 0L );
; 922  :          }

	jmp	$LN34@MainWndPro
$LN82@MainWndPro:

; 923  :          else
; 924  :          if ( wCommand == IDM_DELETESELECTED )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 154				; 0000009aH
	jne	SHORT $LN84@MainWndPro

; 925  :          {
; 926  :             WORD wCurSel = (WORD) SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	push	0
	push	392					; 00000188H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wCurSel$38[ebp], ax

; 927  :                                                LB_GETCURSEL, 0, 0 );
; 928  :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	movzx	eax, WORD PTR _wCurSel$38[ebp]
	push	eax
	push	386					; 00000182H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 929  :                          LB_DELETESTRING, wCurSel, 0L );
; 930  :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	movzx	eax, WORD PTR _wCurSel$38[ebp]
	push	eax
	push	390					; 00000186H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 931  :                          LB_SETCURSEL, wCurSel, 0L );
; 932  :          }

	jmp	$LN34@MainWndPro
$LN84@MainWndPro:

; 933  :          else
; 934  :          if ( wCommand == IDM_INSERTMARKER )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 155				; 0000009bH
	jne	$LN86@MainWndPro

; 935  :          {
; 936  :             WORD wCurSel = (WORD) SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	push	0
	push	392					; 00000188H
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
	mov	WORD PTR _wCurSel$37[ebp], ax

; 937  :                                                LB_GETCURSEL, 0, 0 );
; 938  :             zSHORT nLth = sizeof( szMark ) - 1;

	mov	eax, 103				; 00000067H
	mov	WORD PTR _nLth$43[ebp], ax

; 939  :             zLONG  j, k;
; 940  : 
; 941  :             g_lMark++;

	mov	ecx, DWORD PTR _g_lMark
	add	ecx, 1
	mov	DWORD PTR _g_lMark, ecx

; 942  :             k = g_lMark;

	mov	edx, DWORD PTR _g_lMark
	mov	DWORD PTR _k$30[ebp], edx
$LN9@MainWndPro:

; 943  :             while ( k )

	cmp	DWORD PTR _k$30[ebp], 0
	je	SHORT $LN10@MainWndPro

; 944  :             {
; 945  :                nLth--;

	mov	ax, WORD PTR _nLth$43[ebp]
	sub	ax, 1
	mov	WORD PTR _nLth$43[ebp], ax

; 946  :                j = k % 10;

	mov	eax, DWORD PTR _k$30[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _j$10[ebp], edx

; 947  :                szMark[ nLth ] = (char) (j + '0');

	mov	edx, DWORD PTR _j$10[ebp]
	add	edx, 48					; 00000030H
	movsx	eax, WORD PTR _nLth$43[ebp]
	mov	BYTE PTR _szMark[eax], dl

; 948  :                k /= 10;

	mov	eax, DWORD PTR _k$30[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _k$30[ebp], eax

; 949  :             }

	jmp	SHORT $LN9@MainWndPro
$LN10@MainWndPro:

; 950  : 
; 951  :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	OFFSET _szMark
	movzx	edx, WORD PTR _wCurSel$37[ebp]
	add	edx, 1
	push	edx
	push	385					; 00000181H
	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 952  :                          LB_INSERTSTRING,
; 953  :                          wCurSel + 1, (LPARAM) szMark );
; 954  :             SendMessage( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	movzx	edx, WORD PTR _wCurSel$37[ebp]
	add	edx, 1
	push	edx
	push	390					; 00000186H
	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 955  :                          LB_SETCURSEL, wCurSel + 1, 0L );
; 956  :          }

	jmp	$LN34@MainWndPro
$LN86@MainWndPro:

; 957  :          else
; 958  :          if ( wCommand == IDM_PRINTPREVIEW    ||
; 959  :               wCommand == IDM_PREVIEW_ZOOMOUT ||
; 960  :               wCommand == IDM_PREVIEW_ZOOM    ||

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 160				; 000000a0H
	je	SHORT $LN90@MainWndPro
	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 161				; 000000a1H
	je	SHORT $LN90@MainWndPro
	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 162				; 000000a2H
	je	SHORT $LN90@MainWndPro
	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 163				; 000000a3H
	jne	$LN88@MainWndPro
$LN90@MainWndPro:

; 961  :               wCommand == IDM_PREVIEW_ZOOMIN )
; 962  :          {
; 963  :             HMENU hMenu = GetMenu( hWnd );

	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _hMenu$44[ebp], eax

; 964  : 
; 965  :             CheckMenuItem( hMenu, IDM_PRINTPREVIEW,

	push	0
	push	160					; 000000a0H
	mov	ecx, DWORD PTR _hMenu$44[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 966  :                            MF_BYCOMMAND | MF_UNCHECKED );
; 967  :             CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMOUT,

	push	0
	push	161					; 000000a1H
	mov	edx, DWORD PTR _hMenu$44[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 968  :                            MF_BYCOMMAND | MF_UNCHECKED );
; 969  :             CheckMenuItem( hMenu, IDM_PREVIEW_ZOOM,

	push	0
	push	162					; 000000a2H
	mov	eax, DWORD PTR _hMenu$44[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 970  :                            MF_BYCOMMAND | MF_UNCHECKED );
; 971  :             CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMIN,

	push	0
	push	163					; 000000a3H
	mov	ecx, DWORD PTR _hMenu$44[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 972  :                            MF_BYCOMMAND | MF_UNCHECKED );
; 973  :             switch ( wCommand )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	mov	DWORD PTR tv489[ebp], edx
	cmp	DWORD PTR tv489[ebp], 161		; 000000a1H
	je	SHORT $LN91@MainWndPro
	cmp	DWORD PTR tv489[ebp], 162		; 000000a2H
	je	SHORT $LN92@MainWndPro
	cmp	DWORD PTR tv489[ebp], 163		; 000000a3H
	je	SHORT $LN93@MainWndPro
	jmp	SHORT $LN94@MainWndPro
$LN91@MainWndPro:

; 974  :             {
; 975  :                case IDM_PREVIEW_ZOOMOUT:
; 976  :                   g_chPrintPreview = '0';

	mov	BYTE PTR _g_chPrintPreview, 48		; 00000030H

; 977  :                   CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMOUT,

	push	8
	push	161					; 000000a1H
	mov	eax, DWORD PTR _hMenu$44[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 978  :                                  MF_BYCOMMAND | MF_CHECKED );
; 979  :                   break;

	jmp	SHORT $LN11@MainWndPro
$LN92@MainWndPro:

; 980  : 
; 981  :                case IDM_PREVIEW_ZOOM:
; 982  :                   g_chPrintPreview = '1';

	mov	BYTE PTR _g_chPrintPreview, 49		; 00000031H

; 983  :                   CheckMenuItem( hMenu, IDM_PREVIEW_ZOOM,

	push	8
	push	162					; 000000a2H
	mov	ecx, DWORD PTR _hMenu$44[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 984  :                                  MF_BYCOMMAND | MF_CHECKED );
; 985  :                   break;

	jmp	SHORT $LN11@MainWndPro
$LN93@MainWndPro:

; 986  : 
; 987  :                case IDM_PREVIEW_ZOOMIN:
; 988  :                   g_chPrintPreview = '2';

	mov	BYTE PTR _g_chPrintPreview, 50		; 00000032H

; 989  :                   CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMIN,

	push	8
	push	163					; 000000a3H
	mov	edx, DWORD PTR _hMenu$44[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 990  :                                  MF_BYCOMMAND | MF_CHECKED );
; 991  :                   break;

	jmp	SHORT $LN11@MainWndPro
$LN94@MainWndPro:

; 992  : 
; 993  :                case IDM_PRINTPREVIEW:
; 994  :                default:
; 995  :                   g_chPrintPreview = 0;

	mov	BYTE PTR _g_chPrintPreview, 0

; 996  :                   CheckMenuItem( hMenu, IDM_PRINTPREVIEW,

	push	8
	push	160					; 000000a0H
	mov	eax, DWORD PTR _hMenu$44[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12
$LN11@MainWndPro:

; 997  :                                  MF_BYCOMMAND | MF_CHECKED );
; 998  :                   break;
; 999  :             }
; 1000 : 
; 1001 :             if ( g_chPrintPreview )

	movsx	ecx, BYTE PTR _g_chPrintPreview
	test	ecx, ecx
	je	SHORT $LN95@MainWndPro

; 1002 :             {
; 1003 :                g_chPrintDialog = 0;

	mov	BYTE PTR _g_chPrintDialog, 0

; 1004 :                CheckMenuItem( hMenu, IDM_PRINTDIALOG,

	push	0
	push	164					; 000000a4H
	mov	edx, DWORD PTR _hMenu$44[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12
$LN95@MainWndPro:

; 1005 :                               MF_BYCOMMAND | MF_UNCHECKED );
; 1006 :             }
; 1007 :          }

	jmp	$LN34@MainWndPro
$LN88@MainWndPro:

; 1008 :          else
; 1009 :          if ( wCommand == IDM_PRINTDIALOG )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 164				; 000000a4H
	jne	$LN96@MainWndPro

; 1010 :          {
; 1011 :             HMENU hMenu = GetMenu( hWnd );

	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _hMenu$35[ebp], eax

; 1012 :             g_chPrintDialog = g_chPrintDialog ? 0 : 'Y';

	movsx	edx, BYTE PTR _g_chPrintDialog
	test	edx, edx
	je	SHORT $LN211@MainWndPro
	mov	DWORD PTR tv516[ebp], 0
	jmp	SHORT $LN212@MainWndPro
$LN211@MainWndPro:
	mov	DWORD PTR tv516[ebp], 89		; 00000059H
$LN212@MainWndPro:
	mov	al, BYTE PTR tv516[ebp]
	mov	BYTE PTR _g_chPrintDialog, al

; 1013 :             CheckMenuItem( hMenu, IDM_PRINTDIALOG,

	movsx	ecx, BYTE PTR _g_chPrintDialog
	test	ecx, ecx
	je	SHORT $LN213@MainWndPro
	mov	DWORD PTR tv521[ebp], 8
	jmp	SHORT $LN214@MainWndPro
$LN213@MainWndPro:
	mov	DWORD PTR tv521[ebp], 0
$LN214@MainWndPro:
	mov	edx, DWORD PTR tv521[ebp]
	push	edx
	push	164					; 000000a4H
	mov	eax, DWORD PTR _hMenu$35[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1014 :                            MF_BYCOMMAND |
; 1015 :                              (g_chPrintDialog ? MF_CHECKED : MF_UNCHECKED) );
; 1016 :             if ( g_chPrintDialog == 'Y' )

	movsx	ecx, BYTE PTR _g_chPrintDialog
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN98@MainWndPro

; 1017 :             {
; 1018 :                g_chPrintPreview = 0;

	mov	BYTE PTR _g_chPrintPreview, 0

; 1019 :                CheckMenuItem( hMenu, IDM_PRINTPREVIEW,

	push	8
	push	160					; 000000a0H
	mov	edx, DWORD PTR _hMenu$35[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 1020 :                               MF_BYCOMMAND | MF_CHECKED );
; 1021 :                CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMOUT,

	push	0
	push	161					; 000000a1H
	mov	eax, DWORD PTR _hMenu$35[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1022 :                               MF_BYCOMMAND | MF_UNCHECKED );
; 1023 :                CheckMenuItem( hMenu, IDM_PREVIEW_ZOOM,

	push	0
	push	162					; 000000a2H
	mov	ecx, DWORD PTR _hMenu$35[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 1024 :                               MF_BYCOMMAND | MF_UNCHECKED );
; 1025 :                CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMIN,

	push	0
	push	163					; 000000a3H
	mov	edx, DWORD PTR _hMenu$35[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12
$LN98@MainWndPro:

; 1026 :                               MF_BYCOMMAND | MF_UNCHECKED );
; 1027 :             }
; 1028 :          }

	jmp	$LN34@MainWndPro
$LN96@MainWndPro:

; 1029 :          else
; 1030 :          if ( wCommand == IDM_SHOWTASKID )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 124				; 0000007cH
	jne	SHORT $LN99@MainWndPro

; 1031 :          {
; 1032 :             HMENU hMenu = GetMenu( hWnd );

	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _hMenu$14[ebp], eax

; 1033 :             if ( AnchorBlock->bShowTaskID )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	and	eax, 1
	je	SHORT $LN101@MainWndPro

; 1034 :             {
; 1035 :                AnchorBlock->bShowTaskID = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1495]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+1495], edx

; 1036 :                CheckMenuItem( hMenu, IDM_SHOWTASKID,

	push	0
	push	124					; 0000007cH
	mov	ecx, DWORD PTR _hMenu$14[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 1037 :                               MF_BYCOMMAND | MF_UNCHECKED );
; 1038 :             }

	jmp	SHORT $LN102@MainWndPro
$LN101@MainWndPro:

; 1039 :             else
; 1040 :             {
; 1041 :                AnchorBlock->bShowTaskID = 1;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	or	eax, 1
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1495], eax

; 1042 :                CheckMenuItem( hMenu, IDM_SHOWTASKID,

	push	8
	push	124					; 0000007cH
	mov	edx, DWORD PTR _hMenu$14[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12
$LN102@MainWndPro:

; 1043 :                               MF_BYCOMMAND | MF_CHECKED );
; 1044 :             }
; 1045 :          }

	jmp	$LN34@MainWndPro
$LN99@MainWndPro:

; 1046 :          else
; 1047 :          if ( wCommand == IDM_ABOUT )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 131				; 00000083H
	jne	SHORT $LN103@MainWndPro

; 1048 :          {
; 1049 :             DialogBox( hInst, MAKEINTRESOURCE( IDD_ABOUT ), hWnd, fpAbout );

	push	0
	mov	ecx, DWORD PTR _fpAbout
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	push	105					; 00000069H
	mov	eax, DWORD PTR _hInst
	push	eax
	call	DWORD PTR __imp__DialogBoxParamA@20

; 1050 :          }

	jmp	$LN34@MainWndPro
$LN103@MainWndPro:

; 1051 :          else
; 1052 :          if ( wCommand == IDM_HIDEWINDOW )   // If launched in systray mode

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 320				; 00000140H
	jne	SHORT $LN105@MainWndPro

; 1053 :          {                                   // a different menu is loaded
; 1054 :             ShowWindow( hWnd, SW_HIDE );     // having no Exit option but a hide Window

	push	0
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8

; 1055 :          }

	jmp	$LN34@MainWndPro
$LN105@MainWndPro:

; 1056 :          else
; 1057 :          if ( wCommand == IDM_EXITPROGRAM )   // F3 Exit

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 116				; 00000074H
	jne	SHORT $LN107@MainWndPro

; 1058 :          {
; 1059 :          // SendMessage( (HWND) AnchorBlock->lOE_hMainWnd, // hWnd,
; 1060 :          //              WM_COMMAND, (WPARAM) IDM_LISTTASKS, 10000L );
; 1061 :             PostMessage( hWnd, WM_CLOSE, 0, 0L );

	push	0
	push	0
	push	16					; 00000010H
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__PostMessageA@16

; 1062 :             break;

	jmp	$LN2@MainWndPro

; 1063 :          }

	jmp	$LN34@MainWndPro
$LN107@MainWndPro:

; 1064 :          else
; 1065 :          if ( wCommand == IDM_KILLZEIDON )   // Kill Zeidon

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 117				; 00000075H
	jne	$LN109@MainWndPro

; 1066 :          {
; 1067 :             LPTASK hTask;
; 1068 :             LPTASK lpTask;
; 1069 :             int nResponse = IDYES;

	mov	DWORD PTR _nResponse$16[ebp], 6

; 1070 : 
; 1071 :             // See if any tasks are active.
; 1072 :             hTask = AnchorBlock->hFirstTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	mov	DWORD PTR _hTask$15[ebp], ecx

; 1073 :             lpTask = zGETPTR( hTask );

	mov	edx, DWORD PTR _hTask$15[ebp]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$34[ebp], eax
$LN13@MainWndPro:

; 1074 : 
; 1075 :             while ( lpTask )

	cmp	DWORD PTR _lpTask$34[ebp], 0
	je	SHORT $LN14@MainWndPro

; 1076 :             {
; 1077 :                if ( hTask != AnchorBlock->hMainTask &&

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hTask$15[ebp]
	cmp	ecx, DWORD PTR [eax+106]
	je	SHORT $LN111@MainWndPro
	mov	edx, DWORD PTR _lpTask$34[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	je	SHORT $LN111@MainWndPro

; 1078 :                     IsWindow( (HWND) lpTask->hMainWnd ) )
; 1079 :                {
; 1080 :                   break;

	jmp	SHORT $LN14@MainWndPro
$LN111@MainWndPro:

; 1081 :                }
; 1082 : 
; 1083 :                lpTask = zGETPTR( lpTask->hNextTask );

	mov	ecx, DWORD PTR _lpTask$34[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$34[ebp], eax

; 1084 :             }

	jmp	SHORT $LN13@MainWndPro
$LN14@MainWndPro:

; 1085 : 
; 1086 :             if ( lpTask )

	cmp	DWORD PTR _lpTask$34[ebp], 0
	je	SHORT $LN112@MainWndPro

; 1087 :             {
; 1088 :                nResponse =

	push	8244					; 00002034H
	push	OFFSET $SG96328
	push	OFFSET $SG96329
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
	mov	DWORD PTR _nResponse$16[ebp], eax
$LN112@MainWndPro:

; 1089 :                   MessageBox( hWnd,
; 1090 :                               "Zeidon Applications are still active.\n"
; 1091 :                               "If you continue, you will lose unsaved data.\n"
; 1092 :                               "Do you still want to kill Zeidon?",
; 1093 :                               "Zeidon Object Services",
; 1094 :                               MB_ICONEXCLAMATION |
; 1095 :                               MB_YESNO | MB_TASKMODAL );
; 1096 :             }
; 1097 : 
; 1098 :             if ( nResponse == IDYES )

	cmp	DWORD PTR _nResponse$16[ebp], 6
	jne	SHORT $LN113@MainWndPro

; 1099 :             {
; 1100 :                zCHAR szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1101 :                zCHAR szTempName[ zMAX_FILENAME_LTH + 1 ];
; 1102 : 
; 1103 :                SysReadZeidonIni( -1, "[ObjectEngine]", "KillZeidon", szTempName );

	lea	ecx, DWORD PTR _szTempName$56[ebp]
	push	ecx
	push	OFFSET $SG96331
	push	OFFSET $SG96332
	push	-1
	call	_SysReadZeidonIni@16

; 1104 :                SysConvertEnvironmentString( szFileName, szTempName );

	lea	edx, DWORD PTR _szTempName$56[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$60[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 1105 :                if ( szFileName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szFileName$60[ebp+edx]
	test	eax, eax
	je	SHORT $LN113@MainWndPro

; 1106 :                   WinExec( szFileName, SW_SHOWNORMAL );

	push	1
	lea	ecx, DWORD PTR _szFileName$60[ebp]
	push	ecx
	call	DWORD PTR __imp__WinExec@8
$LN113@MainWndPro:

; 1107 :             }
; 1108 : 
; 1109 :             break;

	jmp	$LN2@MainWndPro

; 1110 :          }

	jmp	$LN34@MainWndPro
$LN109@MainWndPro:

; 1111 :          else
; 1112 :          if ( wCommand == IDM_SHOWINTL )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 115				; 00000073H
	jne	$LN115@MainWndPro

; 1113 :          {
; 1114 :             LPINTERNATIONAL lpIntl = zGETPTR( AnchorBlock->hInternational );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2515]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpIntl$49[ebp], eax

; 1115 :             if ( lpIntl )

	cmp	DWORD PTR _lpIntl$49[ebp], 0
	je	$LN117@MainWndPro

; 1116 :             {
; 1117 :                TraceLineI( "(wa) nCountry :    ", lpIntl->nCountry );

	mov	edx, DWORD PTR _lpIntl$49[ebp]
	movsx	eax, WORD PTR [edx+2]
	push	eax
	push	OFFSET $SG96338
	call	_TraceLineI@8

; 1118 :                TraceLineS( "(wa) lpCountry :   ", lpIntl->szCountry );

	mov	ecx, DWORD PTR _lpIntl$49[ebp]
	add	ecx, 4
	push	ecx
	push	OFFSET $SG96339
	call	_TraceLineS@8

; 1119 :                TraceLineS( "(wa) lpLanguage :  ", lpIntl->szLanguage );

	mov	edx, DWORD PTR _lpIntl$49[ebp]
	add	edx, 37					; 00000025H
	push	edx
	push	OFFSET $SG96340
	call	_TraceLineS@8

; 1120 :                TraceLineS( "(wa) lpList :      ", lpIntl->szList );

	mov	eax, DWORD PTR _lpIntl$49[ebp]
	add	eax, 72					; 00000048H
	push	eax
	push	OFFSET $SG96341
	call	_TraceLineS@8

; 1121 :                TraceLineI( "(wa) nMeasure :    ", lpIntl->nMeasure );

	mov	ecx, DWORD PTR _lpIntl$49[ebp]
	movsx	edx, WORD PTR [ecx+77]
	push	edx
	push	OFFSET $SG96342
	call	_TraceLineI@8

; 1122 :                TraceLineI( "(wa) nTime :       ", lpIntl->nTime );

	mov	eax, DWORD PTR _lpIntl$49[ebp]
	movsx	ecx, WORD PTR [eax+79]
	push	ecx
	push	OFFSET $SG96343
	call	_TraceLineI@8

; 1123 :                TraceLineS( "(wa) lpTime :      ", lpIntl->szTime );

	mov	edx, DWORD PTR _lpIntl$49[ebp]
	add	edx, 81					; 00000051H
	push	edx
	push	OFFSET $SG96344
	call	_TraceLineS@8

; 1124 :                TraceLineS( "(wa) lp1159 :      ", lpIntl->sz1159 );

	mov	eax, DWORD PTR _lpIntl$49[ebp]
	add	eax, 86					; 00000056H
	push	eax
	push	OFFSET $SG96345
	call	_TraceLineS@8

; 1125 :                TraceLineS( "(wa) lp2359 :      ", lpIntl->sz2359 );

	mov	ecx, DWORD PTR _lpIntl$49[ebp]
	add	ecx, 91					; 0000005bH
	push	ecx
	push	OFFSET $SG96346
	call	_TraceLineS@8

; 1126 :                TraceLineI( "(wa) nTLZero :     ", lpIntl->nTLZero );

	mov	edx, DWORD PTR _lpIntl$49[ebp]
	movsx	eax, WORD PTR [edx+96]
	push	eax
	push	OFFSET $SG96347
	call	_TraceLineI@8

; 1127 :                TraceLineS( "(wa) lpShortDate : ", lpIntl->hShortDate );

	mov	ecx, DWORD PTR _lpIntl$49[ebp]
	mov	edx, DWORD PTR [ecx+98]
	push	edx
	push	OFFSET $SG96348
	call	_TraceLineS@8

; 1128 :                TraceLineS( "(wa) lpLongDate :  ", lpIntl->hLongDate );

	mov	eax, DWORD PTR _lpIntl$49[ebp]
	mov	ecx, DWORD PTR [eax+102]
	push	ecx
	push	OFFSET $SG96349
	call	_TraceLineS@8

; 1129 :                TraceLineS( "(wa) lpTimeFmt :   ", lpIntl->hTimeFmt );

	mov	edx, DWORD PTR _lpIntl$49[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	push	OFFSET $SG96350
	call	_TraceLineS@8

; 1130 :                TraceLineS( "(wa) lpCurrency :  ", lpIntl->szCurrency );

	mov	ecx, DWORD PTR _lpIntl$49[ebp]
	add	ecx, 110				; 0000006eH
	push	ecx
	push	OFFSET $SG96351
	call	_TraceLineS@8

; 1131 :                TraceLineI( "(wa) nCurrency :   ", lpIntl->nCurrency );

	mov	edx, DWORD PTR _lpIntl$49[ebp]
	movsx	eax, WORD PTR [edx+120]
	push	eax
	push	OFFSET $SG96352
	call	_TraceLineI@8

; 1132 :                TraceLineI( "(wa) nCurrDigits : ", lpIntl->nCurrDigits );

	mov	ecx, DWORD PTR _lpIntl$49[ebp]
	movsx	edx, WORD PTR [ecx+122]
	push	edx
	push	OFFSET $SG96353
	call	_TraceLineI@8

; 1133 :                TraceLineI( "(wa) nNegCurr :    ", lpIntl->nNegCurr );

	mov	eax, DWORD PTR _lpIntl$49[ebp]
	movsx	ecx, WORD PTR [eax+124]
	push	ecx
	push	OFFSET $SG96354
	call	_TraceLineI@8

; 1134 :                TraceLineS( "(wa) lpThousand :  ", lpIntl->szThousand );

	mov	edx, DWORD PTR _lpIntl$49[ebp]
	add	edx, 126				; 0000007eH
	push	edx
	push	OFFSET $SG96355
	call	_TraceLineS@8

; 1135 :                TraceLineS( "(wa) lpDecimal :   ", lpIntl->szDecimal );

	mov	eax, DWORD PTR _lpIntl$49[ebp]
	add	eax, 131				; 00000083H
	push	eax
	push	OFFSET $SG96356
	call	_TraceLineS@8

; 1136 :                TraceLineI( "(wa) nDigits :     ", lpIntl->nDigits );

	mov	ecx, DWORD PTR _lpIntl$49[ebp]
	movsx	edx, WORD PTR [ecx+136]
	push	edx
	push	OFFSET $SG96357
	call	_TraceLineI@8

; 1137 :                TraceLineI( "(wa) nLZero :      ", lpIntl->nLZero );

	mov	eax, DWORD PTR _lpIntl$49[ebp]
	movsx	ecx, WORD PTR [eax+138]
	push	ecx
	push	OFFSET $SG96358
	call	_TraceLineI@8

; 1138 :             }

	jmp	SHORT $LN118@MainWndPro
$LN117@MainWndPro:

; 1139 :             else
; 1140 :                TraceLineS( "(wa) No international information ",

	push	OFFSET $SG96359
	push	OFFSET $SG96360
	call	_TraceLineS@8
$LN118@MainWndPro:

; 1141 :                            "is available" );
; 1142 :             break;

	jmp	$LN2@MainWndPro

; 1143 :          }

	jmp	$LN34@MainWndPro
$LN115@MainWndPro:

; 1144 :          else
; 1145 :          if ( wCommand == IDM_CLEARTRACE )    // Empty all trace windows

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 122				; 0000007aH
	jne	$LN119@MainWndPro

; 1146 :          {
; 1147 :             UINT k;
; 1148 : 
; 1149 :             ShowWindow( g_hwndTraceWindow[ g_nTraceWindowDisplayed ],

	push	0
	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 1150 :                         SW_HIDE );
; 1151 :             for ( k = 0; k < g_nTraceWindowCnt; k++ )

	mov	DWORD PTR _k$29[ebp], 0
	jmp	SHORT $LN17@MainWndPro
$LN15@MainWndPro:
	mov	edx, DWORD PTR _k$29[ebp]
	add	edx, 1
	mov	DWORD PTR _k$29[ebp], edx
$LN17@MainWndPro:
	mov	eax, DWORD PTR _k$29[ebp]
	cmp	eax, DWORD PTR _g_nTraceWindowCnt
	jae	SHORT $LN16@MainWndPro

; 1152 :                SendMessage( g_hwndTraceWindow[ k ], LB_RESETCONTENT, 0, 0 );

	push	0
	push	0
	push	388					; 00000184H
	mov	ecx, DWORD PTR _k$29[ebp]
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
	jmp	SHORT $LN15@MainWndPro
$LN16@MainWndPro:

; 1153 : 
; 1154 :             ShowWindow( g_hwndTraceWindow[ 0 ], SW_SHOW );

	push	5
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8

; 1155 :             g_nTraceWindowHead      = 0;

	mov	DWORD PTR _g_nTraceWindowHead, 0

; 1156 :             g_nTraceWindowDisplayed = 0;

	mov	DWORD PTR _g_nTraceWindowDisplayed, 0

; 1157 :          }

	jmp	$LN34@MainWndPro
$LN119@MainWndPro:

; 1158 :          else
; 1159 :          if ( wCommand == IDM_SETDBHTRACE )   // Set DBHandler trace level

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 132				; 00000084H
	jne	SHORT $LN121@MainWndPro

; 1160 :          {
; 1161 :             DialogBox( hInst, MAKEINTRESOURCE( IDD_SETTRACE ),

	push	0
	mov	ecx, DWORD PTR _fpSetTrace
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	push	106					; 0000006aH
	mov	eax, DWORD PTR _hInst
	push	eax
	call	DWORD PTR __imp__DialogBoxParamA@20

; 1162 :                        hWnd, fpSetTrace );
; 1163 :          }

	jmp	$LN34@MainWndPro
$LN121@MainWndPro:

; 1164 :          else
; 1165 :          if ( wCommand == IDM_SETOETRACE )   // Set OE Warning trace

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 133				; 00000085H
	jne	SHORT $LN123@MainWndPro

; 1166 :          {
; 1167 :             g_chTraceOE_Warning = g_chTraceOE_Warning ? 0 : 'Y';

	movsx	edx, BYTE PTR _g_chTraceOE_Warning
	test	edx, edx
	je	SHORT $LN215@MainWndPro
	mov	DWORD PTR tv749[ebp], 0
	jmp	SHORT $LN216@MainWndPro
$LN215@MainWndPro:
	mov	DWORD PTR tv749[ebp], 89		; 00000059H
$LN216@MainWndPro:
	mov	al, BYTE PTR tv749[ebp]
	mov	BYTE PTR _g_chTraceOE_Warning, al

; 1168 :             CheckMenuItem( GetMenu( hWnd ), IDM_SETOETRACE,

	movsx	ecx, BYTE PTR _g_chTraceOE_Warning
	test	ecx, ecx
	jne	SHORT $LN217@MainWndPro
	mov	DWORD PTR tv754[ebp], 0
	jmp	SHORT $LN218@MainWndPro
$LN217@MainWndPro:
	mov	DWORD PTR tv754[ebp], 8
$LN218@MainWndPro:
	mov	edx, DWORD PTR tv754[ebp]
	push	edx
	push	133					; 00000085H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1169 :                            MF_BYCOMMAND |
; 1170 :                            (g_chTraceOE_Warning == 0 ? MF_UNCHECKED :
; 1171 :                                                        MF_CHECKED) );
; 1172 :          }

	jmp	$LN34@MainWndPro
$LN123@MainWndPro:

; 1173 :          else
; 1174 :          if ( wCommand == IDM_SETZDRTRACE )   // Set ZDr Action trace

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 134				; 00000086H
	jne	SHORT $LN125@MainWndPro

; 1175 :          {
; 1176 :             g_chTraceZDrActions = g_chTraceZDrActions ? 0 : 'Y';

	movsx	edx, BYTE PTR _g_chTraceZDrActions
	test	edx, edx
	je	SHORT $LN219@MainWndPro
	mov	DWORD PTR tv763[ebp], 0
	jmp	SHORT $LN220@MainWndPro
$LN219@MainWndPro:
	mov	DWORD PTR tv763[ebp], 89		; 00000059H
$LN220@MainWndPro:
	mov	al, BYTE PTR tv763[ebp]
	mov	BYTE PTR _g_chTraceZDrActions, al

; 1177 :             CheckMenuItem( GetMenu( hWnd ), IDM_SETZDRTRACE,

	movsx	ecx, BYTE PTR _g_chTraceZDrActions
	test	ecx, ecx
	jne	SHORT $LN221@MainWndPro
	mov	DWORD PTR tv768[ebp], 0
	jmp	SHORT $LN222@MainWndPro
$LN221@MainWndPro:
	mov	DWORD PTR tv768[ebp], 8
$LN222@MainWndPro:
	mov	edx, DWORD PTR tv768[ebp]
	push	edx
	push	134					; 00000086H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1178 :                            MF_BYCOMMAND |
; 1179 :                            (g_chTraceZDrActions == 0 ? MF_UNCHECKED :
; 1180 :                                                        MF_CHECKED) );
; 1181 :          }

	jmp	$LN34@MainWndPro
$LN125@MainWndPro:

; 1182 :          else
; 1183 :          if ( wCommand == IDM_SETWEBTRACE )   // Set ZDr Action trace

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 135				; 00000087H
	jne	SHORT $LN127@MainWndPro

; 1184 :          {
; 1185 :             g_chTraceWebActions = g_chTraceWebActions ? 0 : 'Y';

	movsx	edx, BYTE PTR _g_chTraceWebActions
	test	edx, edx
	je	SHORT $LN223@MainWndPro
	mov	DWORD PTR tv777[ebp], 0
	jmp	SHORT $LN224@MainWndPro
$LN223@MainWndPro:
	mov	DWORD PTR tv777[ebp], 89		; 00000059H
$LN224@MainWndPro:
	mov	al, BYTE PTR tv777[ebp]
	mov	BYTE PTR _g_chTraceWebActions, al

; 1186 :             CheckMenuItem( GetMenu( hWnd ), IDM_SETWEBTRACE,

	movsx	ecx, BYTE PTR _g_chTraceWebActions
	test	ecx, ecx
	jne	SHORT $LN225@MainWndPro
	mov	DWORD PTR tv782[ebp], 0
	jmp	SHORT $LN226@MainWndPro
$LN225@MainWndPro:
	mov	DWORD PTR tv782[ebp], 8
$LN226@MainWndPro:
	mov	edx, DWORD PTR tv782[ebp]
	push	edx
	push	135					; 00000087H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1187 :                            MF_BYCOMMAND |
; 1188 :                            (g_chTraceWebActions == 0 ? MF_UNCHECKED :
; 1189 :                                                        MF_CHECKED) );
; 1190 :          }

	jmp	$LN34@MainWndPro
$LN127@MainWndPro:

; 1191 : #ifdef ALLOC_FREE_TRACE
; 1192 :          else
; 1193 :          if ( wCommand == IDM_SETMEMORYTRACE )   // Set Memory trace
; 1194 :          {
; 1195 :             g_chTraceMemory = g_chTraceMemory ? 0 : 'Y';
; 1196 :             AnchorBlock->bTraceMem = g_chTraceMemory ? TRUE : FALSE;
; 1197 :             CheckMenuItem( GetMenu( hWnd ), IDM_SETMEMORYTRACE,
; 1198 :                            MF_BYCOMMAND |
; 1199 :                            (g_chTraceMemory == 0 ? MF_UNCHECKED :
; 1200 :                                                    MF_CHECKED) );
; 1201 :          }
; 1202 :          else
; 1203 :          if ( wCommand == IDM_TRACEMEMORYALLOCATIONS )
; 1204 :          {
; 1205 :             if ( AnchorBlock->bTraceMem )
; 1206 :                fnListDataspaceLeak( AnchorBlock, 0, 1 );
; 1207 :          }
; 1208 :          else
; 1209 :          if ( wCommand == IDM_TRACEMEMORYDATA )
; 1210 :          {
; 1211 :             if ( AnchorBlock->bTraceMem )
; 1212 :                fnListDataspaceLeak( AnchorBlock, 0, 2 );
; 1213 :          }
; 1214 :          else
; 1215 :          if ( wCommand == IDM_CLEARMEMORYALLOCATIONS )
; 1216 :          {
; 1217 :             if ( AnchorBlock->bTraceMem )
; 1218 :                fnListDataspaceLeak( AnchorBlock, 0, -1 );
; 1219 :          }
; 1220 : #endif
; 1221 : #ifdef LOAD_FREE_TRACE
; 1222 :          else
; 1223 :          if ( wCommand == IDM_SETLOADTRACE )   // Set Load trace
; 1224 :          {
; 1225 :             g_chTraceLoad = g_chTraceLoad ? 0 : 'Y';
; 1226 :             AnchorBlock->bTraceLoad = g_chTraceLoad ? TRUE : FALSE;
; 1227 :             CheckMenuItem( GetMenu( hWnd ), IDM_SETLOADTRACE,
; 1228 :                            MF_BYCOMMAND |
; 1229 :                            (g_chTraceLoad == 0 ? MF_UNCHECKED :
; 1230 :                                                    MF_CHECKED) );
; 1231 :          }
; 1232 :          else
; 1233 :          if ( wCommand == IDM_TRACELOADALLOCATIONS )
; 1234 :          {
; 1235 :             if ( AnchorBlock->bTraceLoad )
; 1236 :                fnListDataspaceLeak( AnchorBlock, 0, 1 );
; 1237 :          }
; 1238 :          else
; 1239 :          if ( wCommand == IDM_TRACELOADDATA )
; 1240 :          {
; 1241 :             if ( AnchorBlock->bTraceLoad )
; 1242 :                fnListDataspaceLeak( AnchorBlock, 0, 2 );
; 1243 :          }
; 1244 :          else
; 1245 :          if ( wCommand == IDM_CLEARLOADALLOCATIONS )
; 1246 :          {
; 1247 :             if ( AnchorBlock->bTraceLoad )
; 1248 :                fnListDataspaceLeak( AnchorBlock, 0, -1 );
; 1249 :          }
; 1250 : #endif
; 1251 :          else
; 1252 :          if ( wCommand == IDM_SCROLLTRACE )   // Scroll trace

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 136				; 00000088H
	jne	SHORT $LN129@MainWndPro

; 1253 :          {
; 1254 :             g_chScrollTrace = g_chScrollTrace ? 0 : 'Y';

	movsx	edx, BYTE PTR _g_chScrollTrace
	test	edx, edx
	je	SHORT $LN227@MainWndPro
	mov	DWORD PTR tv791[ebp], 0
	jmp	SHORT $LN228@MainWndPro
$LN227@MainWndPro:
	mov	DWORD PTR tv791[ebp], 89		; 00000059H
$LN228@MainWndPro:
	mov	al, BYTE PTR tv791[ebp]
	mov	BYTE PTR _g_chScrollTrace, al

; 1255 :             CheckMenuItem( GetMenu( hWnd ), IDM_SCROLLTRACE,

	movsx	ecx, BYTE PTR _g_chScrollTrace
	test	ecx, ecx
	je	SHORT $LN229@MainWndPro
	mov	DWORD PTR tv796[ebp], 8
	jmp	SHORT $LN230@MainWndPro
$LN229@MainWndPro:
	mov	DWORD PTR tv796[ebp], 0
$LN230@MainWndPro:
	mov	edx, DWORD PTR tv796[ebp]
	push	edx
	push	136					; 00000088H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1256 :                            MF_BYCOMMAND |
; 1257 :                               (g_chScrollTrace ? MF_CHECKED : MF_UNCHECKED) );
; 1258 :          }

	jmp	$LN34@MainWndPro
$LN129@MainWndPro:

; 1259 :          else
; 1260 :          if ( wCommand == IDM_TRACEDATASPACE )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 153				; 00000099H
	jne	SHORT $LN131@MainWndPro

; 1261 :          {
; 1262 :             MiListOE_Memory( 0, -1 );  // toggle dataspace alloc/free tracing

	push	-1
	push	0
	call	_MiListOE_Memory@8

; 1263 :          }

	jmp	$LN34@MainWndPro
$LN131@MainWndPro:

; 1264 :          else
; 1265 :          if ( wCommand == IDM_LISTTASKS )   // Display task information

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 112				; 00000070H
	jne	$LN133@MainWndPro

; 1266 :          {
; 1267 :             if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN135@MainWndPro

; 1268 :             {
; 1269 :             // LPTASK lpTask;
; 1270 :             // LPTASK hTask;
; 1271 :                char   szMessage[ 512 ];
; 1272 : 
; 1273 : #if 1  // DGC 6/13/97  Can't print allocated memory right now.
; 1274 :                LPDATAHEADER    lpDataHeader;
; 1275 :                FreespaceRecord *lpFreespace;
; 1276 :                zULONG ulAlloc;
; 1277 :                zULONG ulUsed;
; 1278 :                zULONG ulFree;
; 1279 : 
; 1280 :                // Get System available memory
; 1281 :             // lFree = GlobalCompact( 0 );
; 1282 :             // lFree = (lFree / 1024) + 10000;
; 1283 :             // zstrcpy( szMessage, "System Memory Available:" );
; 1284 :             // zltoa( lFree, szMessage + 200 );
; 1285 :             // zstrcat( szMessage, szMessage + 201 );
; 1286 :             // zstrcat( szMessage, "K" );
; 1287 :             // SysMessageList( szMessage );
; 1288 : 
; 1289 :                // Display Anchor block memory utilization
; 1290 :                lpDataHeader = (LPDATAHEADER) AnchorBlock;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR _lpDataHeader$12[ebp], eax

; 1291 :                ulFree  = 0;

	mov	DWORD PTR _ulFree$27[ebp], 0

; 1292 :                ulUsed  = 0;

	mov	DWORD PTR _ulUsed$23[ebp], 0

; 1293 :                ulAlloc = lpDataHeader->ulUseableSize; // used memory spaces

	mov	ecx, DWORD PTR _lpDataHeader$12[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR _ulAlloc$11[ebp], edx

; 1294 :                lpFreespace = &lpDataHeader->Freespace;

	mov	eax, DWORD PTR _lpDataHeader$12[ebp]
	add	eax, 46					; 0000002eH
	mov	DWORD PTR _lpFreespace$26[ebp], eax
$LN18@MainWndPro:

; 1295 :                while ( lpFreespace )

	cmp	DWORD PTR _lpFreespace$26[ebp], 0
	je	SHORT $LN19@MainWndPro

; 1296 :                {
; 1297 :                   ulFree += lpFreespace->ulFreeLth;

	mov	ecx, DWORD PTR _lpFreespace$26[ebp]
	mov	edx, DWORD PTR _ulFree$27[ebp]
	add	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _ulFree$27[ebp], edx

; 1298 :                   lpFreespace = zGETPTR( lpFreespace->hNextFreespace );

	mov	eax, DWORD PTR _lpFreespace$26[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpFreespace$26[ebp], eax

; 1299 :                }

	jmp	SHORT $LN18@MainWndPro
$LN19@MainWndPro:

; 1300 : 
; 1301 :                zstrcpy( szMessage, "Anchor Block  Alloc: " );

	push	OFFSET $SG96378
	lea	edx, DWORD PTR _szMessage$63[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1302 :                ulUsed = ulAlloc - ulFree;

	mov	eax, DWORD PTR _ulAlloc$11[ebp]
	sub	eax, DWORD PTR _ulFree$27[ebp]
	mov	DWORD PTR _ulUsed$23[ebp], eax

; 1303 :                zltoa( ulAlloc, szMessage + 200 );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _szMessage$63[ebp+200]
	push	ecx
	mov	edx, DWORD PTR _ulAlloc$11[ebp]
	push	edx
	call	__ltoa
	add	esp, 12					; 0000000cH

; 1304 :                zstrcat( szMessage, szMessage + 200 );

	lea	eax, DWORD PTR _szMessage$63[ebp+200]
	push	eax
	lea	ecx, DWORD PTR _szMessage$63[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1305 :                zstrcat( szMessage, "   Used: " );

	push	OFFSET $SG96379
	lea	edx, DWORD PTR _szMessage$63[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1306 :                zltoa( ulUsed, szMessage + 200 );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _szMessage$63[ebp+200]
	push	eax
	mov	ecx, DWORD PTR _ulUsed$23[ebp]
	push	ecx
	call	__ltoa
	add	esp, 12					; 0000000cH

; 1307 :                zstrcat( szMessage, szMessage + 200 );

	lea	edx, DWORD PTR _szMessage$63[ebp+200]
	push	edx
	lea	eax, DWORD PTR _szMessage$63[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1308 :                zstrcat( szMessage, "   Free: " );

	push	OFFSET $SG96380
	lea	ecx, DWORD PTR _szMessage$63[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1309 :                zltoa( ulFree, szMessage + 200 );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _szMessage$63[ebp+200]
	push	edx
	mov	eax, DWORD PTR _ulFree$27[ebp]
	push	eax
	call	__ltoa
	add	esp, 12					; 0000000cH

; 1310 :                zstrcat( szMessage, szMessage + 200 );

	lea	ecx, DWORD PTR _szMessage$63[ebp+200]
	push	ecx
	lea	edx, DWORD PTR _szMessage$63[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1311 :                SysMessageList( szMessage );

	lea	eax, DWORD PTR _szMessage$63[ebp]
	push	eax
	call	_SysMessageList@4

; 1312 : #endif
; 1313 : 
; 1314 : #if 1
; 1315 :                // Display open files.
; 1316 :                DisplayOpenFiles( "ListTasks:", 0 );

	push	0
	push	OFFSET $SG96381
	call	_DisplayOpenFiles@8
$LN135@MainWndPro:

; 1317 : #else
; 1318 : 
; 1319 :             //xTraceDataHeader( (LPDATAHEADER) AnchorBlock, TRUE );
; 1320 : 
; 1321 :                // Display Tasks and memory utilization.
; 1322 :             // fnStartBrowseOfTaskList( -1, FALSE );  should do this, but can't
; 1323 :                hTask = AnchorBlock->hFirstTask;
; 1324 :                while ( hTask )
; 1325 :                {
; 1326 :                // LPTASKDOMAIN lpTaskDomain;
; 1327 :                   LPTASK       hNextTask;
; 1328 :                   LPSUBTASK    lpSubtask;
; 1329 :                // LPOPENFILE   lpOpenFile;
; 1330 :                   int          nError;
; 1331 : 
; 1332 :                   lpTask = zGETPTR( hTask );
; 1333 :                   hNextTask = lpTask->hNextTask;
; 1334 :                   if ( lpTask->hNextTask )
; 1335 :                      zsprintf( szMessage, "Task (0x%08x", hTask );
; 1336 :                   else
; 1337 :                      zsprintf( szMessage, "Main Task (0x%08x", hTask );
; 1338 : 
; 1339 :                   zstrcat( szMessage, ") - Status:" );
; 1340 : 
; 1341 :                   // Make sure tasks window is still active.
; 1342 :                   nError = 0;
; 1343 :                   if ( lpTask->bShutdown )
; 1344 :                   {
; 1345 :                      zstrcat( szMessage, "SHUTDOWN" );
; 1346 :                   }
; 1347 :                   else
; 1348 :                // if ( IsWindow( (HWND) lpTask->hMainWnd ) )
; 1349 :                   {
; 1350 :                      zstrcat( szMessage, "OK" );
; 1351 :                   }
; 1352 : #if 0
; 1353 :                   else
; 1354 :                   {
; 1355 : #ifdef __WIN32__
; 1356 :                      DWORD dw;
; 1357 : 
; 1358 :                      zstrcat( szMessage, "ERROR/" );
; 1359 :                      if ( !GetExitCodeProcess( (HANDLE) lpTask, //???
; 1360 :                                                &dw ) ||
; 1361 :                           dw != STILL_ACTIVE )
; 1362 : #else
; 1363 :                      zstrcat( szMessage, "ERROR/" );
; 1364 :                      if ( IsTask( (HTASK) lpTask->lTaskID ) )
; 1365 : #endif
; 1366 :                      {
; 1367 :                         zstrcat( szMessage, "INVALID WINDOW HANDLE!" );
; 1368 :                      }
; 1369 :                      else
; 1370 :                      {
; 1371 :                         zstrcat( szMessage, "DELETED" );
; 1372 :                         nError = 1;
; 1373 :                      }
; 1374 :                   }
; 1375 : #endif
; 1376 : 
; 1377 :                   SysMessageList( szMessage );
; 1378 :                   zstrcpy( szMessage, "      Title: '" );
; 1379 :                   if ( lpTask->szTaskTitle[ 0 ] )
; 1380 :                      zstrcat( szMessage, lpTask->szTaskTitle );
; 1381 : 
; 1382 :                   zstrcat( szMessage, "'" );
; 1383 : 
; 1384 :                   if ( lpTask->szUserId[ 0 ] )
; 1385 :                   {
; 1386 :                      zstrcat( szMessage, "   UserId: " );
; 1387 :                      zstrcat( szMessage, lpTask->szUserId );
; 1388 :                   }
; 1389 : 
; 1390 :                   SysMessageList( szMessage );
; 1391 : 
; 1392 :                   if ( nError == 1 )
; 1393 :                   {
; 1394 :                      DeleteTask( lpTask );
; 1395 :                   }
; 1396 :                   else
; 1397 :                   {
; 1398 :                      // Display subtask list.
; 1399 :                      lpSubtask = zGETPTR( lpTask->hFirstSubtask );
; 1400 :                      while ( lpSubtask )
; 1401 :                      {
; 1402 : #if 0  // Change to 1 to get subtask info.  NOT TESTED!
; 1403 :                         LPSUBTASK lpTempSubtask;
; 1404 :                         LPAPP     lpTempApp;
; 1405 : 
; 1406 :                         zstrcpy( szMessage, "      Subtask:'" );
; 1407 : 
; 1408 :                         lpSubtaskView = zGETPTR( lpSubtask->hFirstView );
; 1409 :                         while( lpSubtaskView )
; 1410 :                         {
; 1411 :                            if ( lpSubtaskView->hSubtask )
; 1412 :                               break;
; 1413 : 
; 1414 :                            lpSubtaskView = zGETPTR( lpSubtaskView->hNextView );
; 1415 :                         }
; 1416 : 
; 1417 :                         lpTempSubtask = zGETPTR( lpSubtaskView->hSubtask );
; 1418 :                         lpTempApp     = zGETPTR( lpTempSubtask->hApp );
; 1419 : 
; 1420 :                         if ( lpSubtaskView && lpSubtaskView->hViewName )
; 1421 :                         {
; 1422 :                            zstrcat( szMessage,
; 1423 :                                     zGETPTR( lpSubtaskView->hViewName ) );
; 1424 :                            zstrcat( szMessage, "'" );
; 1425 :                         }
; 1426 :                         else
; 1427 :                            zstrcat( szMessage, "(unnamed)'" );
; 1428 : 
; 1429 :                         zstrcat( szMessage, ", Application:'" );
; 1430 :                         zstrcat( szMessage, zGETPTR( lpTempApp->hName ) );
; 1431 :                         zstrcat( szMessage, "'" );
; 1432 :                         SysMessageList( szMessage );
; 1433 : 
; 1434 :                         // Now report on views
; 1435 :                         lpSubtaskView = zGETPTR( lpSubtask->hFirstView );
; 1436 :                         while( lpSubtaskView )
; 1437 :                         {
; 1438 :                            zstrcpy( szMessage, "         View:'" );
; 1439 :                            if ( lpSubtaskView->hSubtaskView == 0 )
; 1440 :                            {
; 1441 :                               if ( lpSubtaskView->hViewName )
; 1442 :                               {
; 1443 :                                  zstrcat( szMessage,
; 1444 :                                           zGETPTR( lpSubtaskView->hViewName ) );
; 1445 :                                  zstrcat( szMessage, "'" );
; 1446 :                               }
; 1447 :                               else
; 1448 :                                  zstrcat( szMessage, "(unnamed)'" );
; 1449 : 
; 1450 :                               if ( lpSubtaskView->hViewCsr )
; 1451 :                               {
; 1452 :                                  LPVIEWCSR lpViewCsr =
; 1453 :                                           zGETPTR( lpSubtaskView->hViewCsr );
; 1454 :                                  LPVIEWOI  lpViewOI  =
; 1455 :                                           zGETPTR( lpViewCsr->hViewOI );
; 1456 :                                  LPVIEWOD  lpViewOD  =
; 1457 :                                           zGETPTR( lpViewOI->hViewOD );
; 1458 : 
; 1459 :                                  zstrcat( szMessage, ", Object:'" );
; 1460 :                                  zstrcat( szMessage,
; 1461 :                                           lpViewOD->szName );
; 1462 :                                  zstrcat( szMessage, "'" );
; 1463 :                               }
; 1464 : 
; 1465 :                               SysMessageList( szMessage );
; 1466 :                            }
; 1467 : 
; 1468 :                            lpSubtaskView = zGETPTR( lpSubtaskView->hNextView );
; 1469 :                         }
; 1470 : #endif
; 1471 :                         lpSubtask = zGETPTR( lpSubtask->hNextSubtask );
; 1472 :                      }
; 1473 : 
; 1474 :                      // Display open files.
; 1475 :                      DisplayOpenFiles( "ListTasks:", hTask );
; 1476 : 
; 1477 : #if 0  // DGC 6/13/97  Can't print allocated memory right now.
; 1478 :                      // Display memory utilization.
; 1479 :                      lpDataHeader = zGETPTR( lpTask->hFirstDataHeader );
; 1480 :                      lFree  = 0;
; 1481 :                      lUsed  = 0;
; 1482 :                      lAlloc = 0;
; 1483 :                      while ( lpDataHeader )
; 1484 :                      {
; 1485 :                         lAlloc += lpDataHeader->lCurrentNumberOfEntries;
; 1486 :                         lpFreespace = &lpDataHeader->Freespace;
; 1487 :                         while ( lpFreespace )
; 1488 :                         {
; 1489 :                            lFree += lpFreespace->lFreeLth;
; 1490 :                            lpFreespace = lpFreespace->hNextFreespace;
; 1491 :                         }
; 1492 : 
; 1493 :                         lpDataHeader = lpDataHeader->hNextDataHeader;
; 1494 :                      }
; 1495 : 
; 1496 :                      zstrcpy( szMessage, "      Memory Alloc:" );
; 1497 :                      lUsed = lAlloc - lFree;
; 1498 :                      zltoa( lAlloc, szMessage + 200 );
; 1499 :                      zstrcat( szMessage, szMessage + 200 );
; 1500 :                      zstrcat( szMessage, ",  Used:" );
; 1501 :                      zltoa( lUsed, szMessage + 200 );
; 1502 :                      zstrcat( szMessage, szMessage + 200 );
; 1503 :                      zstrcat( szMessage, ",  Free:" );
; 1504 :                      zltoa( lFree, szMessage + 200 );
; 1505 :                      zstrcat( szMessage, szMessage + 200 );
; 1506 :                      SysMessageList( szMessage );
; 1507 : #endif
; 1508 :                   }
; 1509 : 
; 1510 : #if 0  //x
; 1511 :                   // Display task domains.
; 1512 :                   zstrcpy( szMessage, "      Domains:" );
; 1513 :                   SysMessageList( szMessage );
; 1514 :                   for ( lpTaskDomain = zGETPTR( lpTask->hFirstTaskDomain );
; 1515 :                         lpTaskDomain;
; 1516 :                         lpTaskDomain = zGETPTR( lpTaskDomain->hNextTaskDomainForTask ) )
; 1517 :                   {
; 1518 :                      LPDOMAIN lpDomain = zGETPTR( lpTaskDomain->hDomain );
; 1519 : 
; 1520 :                      if ( lpDomain )
; 1521 :                      {
; 1522 :                         char sz[ 20 ];
; 1523 : 
; 1524 :                         zstrcpy( szMessage, "         Domain Name : " );
; 1525 :                         zstrcat( szMessage, lpDomain->szName );
; 1526 :                         SysMessageList( szMessage );
; 1527 :                         if ( *lpDomain->szDomainOper )
; 1528 :                         {
; 1529 :                            zstrcpy( szMessage, "         Domain Oper : " );
; 1530 :                            zstrcat( szMessage, lpDomain->szDomainOper );
; 1531 :                            SysMessageList( szMessage );
; 1532 :                         }
; 1533 : 
; 1534 :                         zltoa( lpDomain->lApDmTok, sz );
; 1535 :                         zstrcpy( szMessage, "         Domain Token: " );
; 1536 :                         zstrcat( szMessage, sz );
; 1537 :                         SysMessageList( szMessage );
; 1538 :                         zltoa( (zLONG) lpDomain, sz );
; 1539 :                         zstrcpy( szMessage, "         Domain Ptr  : " );
; 1540 :                         zstrcat( szMessage, sz );
; 1541 :                         SysMessageList( szMessage );
; 1542 :                         SysMessageList( " " );
; 1543 :                      }
; 1544 :                   }
; 1545 : #endif
; 1546 :                   // Look for another task.
; 1547 :                   hTask = hNextTask;
; 1548 :                }
; 1549 : 
; 1550 :             // fnEndBrowseOfTaskList( FALSE );  should do this but can't
; 1551 : #endif
; 1552 :             }
; 1553 :          }

	jmp	$LN34@MainWndPro
$LN133@MainWndPro:

; 1554 :          else
; 1555 :          if ( wCommand == IDM_LISTMUTEXSTATUS )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 170				; 000000aaH
	jne	SHORT $LN136@MainWndPro

; 1556 :          {
; 1557 :             char szMsg[ 4000 ];
; 1558 : 
; 1559 :             SysMutexQueryStatus( );

	call	_SysMutexQueryStatus@0

; 1560 :             TraceLineS( "", "" );

	push	OFFSET $SG96384
	push	OFFSET $SG96385
	call	_TraceLineS@8

; 1561 :             MiListOE_Memory( 0, 0 );

	push	0
	push	0
	call	_MiListOE_Memory@8

; 1562 :             SysDescribeZeidonPageTable( szMsg );

	lea	edx, DWORD PTR _szMsg$54[ebp]
	push	edx
	call	_SysDescribeZeidonPageTable@4

; 1563 :             TraceLineS( " Page table info - ", szMsg );

	lea	eax, DWORD PTR _szMsg$54[ebp]
	push	eax
	push	OFFSET $SG96386
	call	_TraceLineS@8

; 1564 :          }

	jmp	$LN34@MainWndPro
$LN136@MainWndPro:

; 1565 :          else
; 1566 :          if ( wCommand == IDM_LISTVOBJS )   // Display objects

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 113				; 00000071H
	jne	$LN138@MainWndPro

; 1567 :          {
; 1568 :             if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN140@MainWndPro

; 1569 :             {
; 1570 :                LPAPP    lpApp;
; 1571 :                LPVIEWOD lpViewOD;
; 1572 :                char szMessage[ 160 ];
; 1573 : 
; 1574 :                lpApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+126]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpApp$40[ebp], eax
$LN20@MainWndPro:

; 1575 :                while ( lpApp )

	cmp	DWORD PTR _lpApp$40[ebp], 0
	je	$LN140@MainWndPro

; 1576 :                {
; 1577 :                   zstrcpy( szMessage, "Application:'" );

	push	OFFSET $SG96390
	lea	ecx, DWORD PTR _szMessage$64[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1578 :                   if ( *lpApp->szName )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpApp$40[ebp]
	movsx	edx, BYTE PTR [ecx+eax+6]
	test	edx, edx
	je	SHORT $LN141@MainWndPro

; 1579 :                      zstrcat( szMessage, lpApp->szName );

	mov	eax, DWORD PTR _lpApp$40[ebp]
	add	eax, 6
	push	eax
	lea	ecx, DWORD PTR _szMessage$64[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN141@MainWndPro:

; 1580 : 
; 1581 :                   zstrcat( szMessage, "'" );

	push	OFFSET $SG96392
	lea	edx, DWORD PTR _szMessage$64[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1582 :                   SysMessageList( szMessage );

	lea	eax, DWORD PTR _szMessage$64[ebp]
	push	eax
	call	_SysMessageList@4

; 1583 :                   lpViewOD = zGETPTR( lpApp->hFirstViewOD );

	mov	ecx, DWORD PTR _lpApp$40[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewOD$33[ebp], eax
$LN22@MainWndPro:

; 1584 :                   while ( lpViewOD )

	cmp	DWORD PTR _lpViewOD$33[ebp], 0
	je	SHORT $LN23@MainWndPro

; 1585 :                   {
; 1586 :                      zstrcpy( szMessage, "   View Object:'" );

	push	OFFSET $SG96393
	lea	eax, DWORD PTR _szMessage$64[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1587 :                      if ( *lpViewOD->szName )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewOD$33[ebp]
	movsx	ecx, BYTE PTR [eax+edx+10]
	test	ecx, ecx
	je	SHORT $LN142@MainWndPro

; 1588 :                         zstrcat( szMessage, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$33[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szMessage$64[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN142@MainWndPro:

; 1589 : 
; 1590 :                      zstrcat( szMessage, "'" );

	push	OFFSET $SG96395
	lea	ecx, DWORD PTR _szMessage$64[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1591 :                      SysMessageList( szMessage );

	lea	edx, DWORD PTR _szMessage$64[ebp]
	push	edx
	call	_SysMessageList@4

; 1592 :                      lpViewOD = zGETPTR( lpViewOD->hNextViewOD );

	mov	eax, DWORD PTR _lpViewOD$33[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpViewOD$33[ebp], eax

; 1593 :                   }

	jmp	$LN22@MainWndPro
$LN23@MainWndPro:

; 1594 : 
; 1595 :                   lpApp = zGETPTR( lpApp->hNextApp );

	mov	edx, DWORD PTR _lpApp$40[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpApp$40[ebp], eax

; 1596 :                }

	jmp	$LN20@MainWndPro
$LN140@MainWndPro:

; 1597 :             }
; 1598 :          }

	jmp	$LN34@MainWndPro
$LN138@MainWndPro:

; 1599 :          else
; 1600 :          if ( wCommand == IDM_RESETTIMEOUT )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 218				; 000000daH
	jne	SHORT $LN143@MainWndPro

; 1601 :          {
; 1602 :             if ( g_lTimeOut )

	cmp	DWORD PTR _g_lTimeOut, 0
	je	SHORT $LN145@MainWndPro

; 1603 :                SysGetDateTime( g_szTimeStamp );

	push	OFFSET _g_szTimeStamp
	call	_SysGetDateTime@4
$LN145@MainWndPro:

; 1604 : 
; 1605 :             return( 0 );

	xor	eax, eax
	jmp	$LN210@MainWndPro

; 1606 :          }

	jmp	$LN34@MainWndPro
$LN143@MainWndPro:

; 1607 :          else
; 1608 :          if ( wCommand == IDM_IDLE )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 219				; 000000dbH
	jne	SHORT $LN146@MainWndPro

; 1609 :          {
; 1610 :             if ( g_lTimeOut && g_uIdleTimerId == 0 )

	cmp	DWORD PTR _g_lTimeOut, 0
	je	SHORT $LN148@MainWndPro
	cmp	DWORD PTR _g_uIdleTimerId, 0
	jne	SHORT $LN148@MainWndPro

; 1611 :             {
; 1612 :                SysGetDateTime( g_szTimeStamp );

	push	OFFSET _g_szTimeStamp
	call	_SysGetDateTime@4

; 1613 :                TraceLine( "OE Setting Idle Timer for hWnd: 0x%08x   g_hWndMainFrame: 0x%08x  Id: %d",

	mov	eax, DWORD PTR _g_nIdIdleEvt
	push	eax
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	push	OFFSET $SG96402
	call	_TraceLine
	add	esp, 16					; 00000010H

; 1614 :                           hWnd, g_hWndMainFrame, g_nIdIdleEvt );
; 1615 :                g_uIdleTimerId = SetTimer( hWnd, g_nIdIdleEvt,

	push	0
	push	30000					; 00007530H
	mov	eax, DWORD PTR _g_nIdIdleEvt
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetTimer@16
	mov	DWORD PTR _g_uIdleTimerId, eax
$LN148@MainWndPro:

; 1616 :                                           30000, 0 );  // 30000 ==> 30 seconds
; 1617 :             }
; 1618 : 
; 1619 :             return( 0 );

	xor	eax, eax
	jmp	$LN210@MainWndPro

; 1620 :          }

	jmp	$LN34@MainWndPro
$LN146@MainWndPro:

; 1621 :          else
; 1622 :          if ( wCommand == IDM_GETOEWARNINGTRACE )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 215				; 000000d7H
	jne	SHORT $LN149@MainWndPro

; 1623 :             return( (zLONG) g_chTraceOE_Warning );

	movsx	eax, BYTE PTR _g_chTraceOE_Warning
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN149@MainWndPro:

; 1624 :          else
; 1625 :          if ( wCommand == IDM_GETACTIONTRACE )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 204				; 000000ccH
	jne	SHORT $LN151@MainWndPro

; 1626 :             return( (zLONG) g_chTraceZDrActions );

	movsx	eax, BYTE PTR _g_chTraceZDrActions
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN151@MainWndPro:

; 1627 :          else
; 1628 :          if ( wCommand == IDM_GETWEBTRACE )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 214				; 000000d6H
	jne	SHORT $LN153@MainWndPro

; 1629 :             return( (zLONG) g_chTraceWebActions );

	movsx	eax, BYTE PTR _g_chTraceWebActions
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN153@MainWndPro:

; 1630 :          else
; 1631 :          if ( wCommand == IDM_GETMEMORYTRACE )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 217				; 000000d9H
	jne	SHORT $LN155@MainWndPro

; 1632 :             return( (zLONG) g_chTraceMemory );

	movsx	eax, BYTE PTR _g_chTraceMemory
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN155@MainWndPro:

; 1633 :          else
; 1634 :          if ( wCommand == IDM_GETTRACELOGFILE )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 216				; 000000d8H
	jne	SHORT $LN157@MainWndPro

; 1635 :             return( (zLONG) g_hLogFile );

	mov	eax, DWORD PTR _g_hLogFile
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN157@MainWndPro:

; 1636 :          else
; 1637 :          if ( wCommand == IDM_GETOEMAINHWND )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 200				; 000000c8H
	jne	SHORT $LN159@MainWndPro

; 1638 :             return( (zLONG) g_hWndMainFrame );

	mov	eax, DWORD PTR _g_hWndMainFrame
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN159@MainWndPro:

; 1639 :          else
; 1640 :          if ( wCommand == IDM_GETOELISTHWND )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 201				; 000000c9H
	jne	SHORT $LN161@MainWndPro

; 1641 :             return( (zLONG) g_hwndTraceWindow[ g_nTraceWindowHead ] );

	mov	eax, DWORD PTR _g_nTraceWindowHead
	mov	eax, DWORD PTR _g_hwndTraceWindow[eax*4]
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN161@MainWndPro:

; 1642 :          else
; 1643 :          if ( wCommand == IDM_GETTRACELIMIT )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 202				; 000000caH
	jne	SHORT $LN163@MainWndPro

; 1644 :             return( (zLONG) g_uTraceLineLimit );

	mov	eax, DWORD PTR _g_uTraceLineLimit
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN163@MainWndPro:

; 1645 :          else
; 1646 :          if ( wCommand == IDM_GETSCROLLTRACE )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 203				; 000000cbH
	jne	SHORT $LN165@MainWndPro

; 1647 :             return( (zLONG) g_chScrollTrace );

	movsx	eax, BYTE PTR _g_chScrollTrace
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN165@MainWndPro:

; 1648 :          else
; 1649 :          if ( wCommand == IDM_GETPRINTPREVIEW )

	movzx	eax, WORD PTR _wCommand$51[ebp]
	cmp	eax, 206				; 000000ceH
	jne	SHORT $LN167@MainWndPro

; 1650 :             return( (zLONG) g_chPrintPreview );

	movsx	eax, BYTE PTR _g_chPrintPreview
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN167@MainWndPro:

; 1651 :          else
; 1652 :          if ( wCommand == IDM_GETPRINTDIALOG )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 207				; 000000cfH
	jne	SHORT $LN169@MainWndPro

; 1653 :             return( (zLONG) g_chPrintDialog );

	movsx	eax, BYTE PTR _g_chPrintDialog
	jmp	$LN210@MainWndPro
	jmp	$LN34@MainWndPro
$LN169@MainWndPro:

; 1654 :          else
; 1655 :          if ( wCommand == IDM_GETFINDSTRING )

	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 205				; 000000cdH
	jne	SHORT $LN171@MainWndPro

; 1656 :          {
; 1657 :             zstrcpy( (zPCHAR) lParam, g_szFindString );

	push	OFFSET _g_szFindString
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1658 :             return( zstrlen( g_szFindString ) );

	push	OFFSET _g_szFindString
	call	_strlen
	add	esp, 4
	jmp	$LN210@MainWndPro

; 1659 :          }

	jmp	$LN34@MainWndPro
$LN171@MainWndPro:

; 1660 :          else
; 1661 :          if ( wCommand >= IDM_TRACEWINDOW01 && wCommand <= IDM_TRACEWINDOW20 )

	movzx	ecx, WORD PTR _wCommand$51[ebp]
	cmp	ecx, 300				; 0000012cH
	jl	$LN34@MainWndPro
	movzx	edx, WORD PTR _wCommand$51[ebp]
	cmp	edx, 319				; 0000013fH
	jg	$LN34@MainWndPro

; 1662 :          {
; 1663 :             UINT idx = wCommand - IDM_TRACEWINDOW01;

	movzx	eax, WORD PTR _wCommand$51[ebp]
	sub	eax, 300				; 0000012cH
	mov	DWORD PTR _idx$8[ebp], eax

; 1664 :             UINT iDiff;
; 1665 :             UINT nNewTraceWindow;
; 1666 :             UINT nOldTraceWindow;
; 1667 : 
; 1668 :             nNewTraceWindow = (g_nTraceWindowHead + g_nTraceWindowCnt - idx)

	mov	eax, DWORD PTR _g_nTraceWindowHead
	add	eax, DWORD PTR _g_nTraceWindowCnt
	sub	eax, DWORD PTR _idx$8[ebp]
	xor	edx, edx
	div	DWORD PTR _g_nTraceWindowCnt
	mov	DWORD PTR _nNewTraceWindow$22[ebp], edx

; 1669 :                                                           % g_nTraceWindowCnt;
; 1670 : 
; 1671 :             // If user selected the window already displayed then don't do
; 1672 :             // anything.
; 1673 :             if ( nNewTraceWindow == g_nTraceWindowDisplayed )

	mov	ecx, DWORD PTR _nNewTraceWindow$22[ebp]
	cmp	ecx, DWORD PTR _g_nTraceWindowDisplayed
	jne	SHORT $LN174@MainWndPro

; 1674 :                break;

	jmp	$LN2@MainWndPro
$LN174@MainWndPro:

; 1675 : 
; 1676 :             // Find the difference between the displayed window and the head.
; 1677 :             iDiff = ( g_nTraceWindowDisplayed + g_nTraceWindowCnt -

	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	add	eax, DWORD PTR _g_nTraceWindowCnt
	sub	eax, DWORD PTR _g_nTraceWindowHead
	xor	edx, edx
	div	DWORD PTR _g_nTraceWindowCnt
	mov	DWORD PTR _iDiff$7[ebp], edx

; 1678 :                                     g_nTraceWindowHead ) % g_nTraceWindowCnt;
; 1679 : 
; 1680 :             // Determine the old trace window index.
; 1681 :             nOldTraceWindow = ( g_nTraceWindowCnt - iDiff )

	mov	eax, DWORD PTR _g_nTraceWindowCnt
	sub	eax, DWORD PTR _iDiff$7[ebp]
	xor	edx, edx
	div	DWORD PTR _g_nTraceWindowCnt
	mov	DWORD PTR _nOldTraceWindow$6[ebp], edx

; 1682 :                                                           % g_nTraceWindowCnt;
; 1683 : 
; 1684 :             // Turn off the check mark...we will no longer be displaying the
; 1685 :             // current window.
; 1686 :             CheckMenuItem( GetMenu( hWnd ),

	push	0
	mov	edx, DWORD PTR _nOldTraceWindow$6[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1687 :                            IDM_TRACEWINDOW01 + nOldTraceWindow,
; 1688 :                            MF_BYCOMMAND | MF_UNCHECKED );
; 1689 : 
; 1690 :             // Make the current window invisible.
; 1691 :             ShowWindow( g_hwndTraceWindow[ g_nTraceWindowDisplayed ], SW_HIDE );

	push	0
	mov	ecx, DWORD PTR _g_nTraceWindowDisplayed
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__ShowWindow@8

; 1692 : 
; 1693 :             // Turn on the check for the window the user wants.
; 1694 :             CheckMenuItem( GetMenu( hWnd ), wCommand,

	push	8
	movzx	eax, WORD PTR _wCommand$51[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetMenu@4
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 1695 :                            MF_BYCOMMAND | MF_CHECKED );
; 1696 : 
; 1697 :             g_nTraceWindowDisplayed = nNewTraceWindow;

	mov	edx, DWORD PTR _nNewTraceWindow$22[ebp]
	mov	DWORD PTR _g_nTraceWindowDisplayed, edx

; 1698 : 
; 1699 :             // Make the new current window visible.
; 1700 :             ShowWindow( g_hwndTraceWindow[ g_nTraceWindowDisplayed ], SW_SHOW );

	push	5
	mov	eax, DWORD PTR _g_nTraceWindowDisplayed
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8
$LN34@MainWndPro:

; 1701 :          }
; 1702 : 
; 1703 :          break;

	jmp	$LN2@MainWndPro
$LN175@MainWndPro:

; 1704 :       }
; 1705 : 
; 1706 :       case WM_QUERYENDSESSION:
; 1707 :       case WM_CLOSE:
; 1708 :          // Close message, if any zeidon tasks are still registered,
; 1709 :          // prompt whether to send a close message to each one and
; 1710 :          // try and bring it down. If either the user says no to
; 1711 :          // automatically closing tasks or any tasks rejects the close
; 1712 :          // message, reject the close and set focus to the first
; 1713 :          // remaining active task.
; 1714 :          // When we receive a WM_QUERYENDSESSION, the user is shutting
; 1715 :          // down Windows.  If any Zeidon tasks are still active, then
; 1716 :          // don't permit Windows to shut down.
; 1717 :          if ( szLogFileName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szLogFileName[eax]
	test	ecx, ecx
	je	SHORT $LN176@MainWndPro

; 1718 :             SysUpdateZeidonIni( szlWorkstation, "LogFile", szLogFileName );

	push	OFFSET _szLogFileName
	push	OFFSET $SG96431
	push	OFFSET _szlWorkstation
	call	_SysUpdateZeidonIni@12
$LN176@MainWndPro:

; 1719 : 
; 1720 :          if ( AnchorBlock )       // Anchor block OK?

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN177@MainWndPro

; 1721 :          {
; 1722 :             LPTASK hTask;
; 1723 :             LPTASK lpTask;
; 1724 :             LPTASK lpTaskTemp;
; 1725 :             int nResponse = IDNO;

	mov	DWORD PTR _nResponse$41[ebp], 7

; 1726 :             HANDLE hTermMutex;
; 1727 : 
; 1728 :             // Create a mutex.  Code in kzoesyaa.c will check to see if this
; 1729 :             // mutex exists during registration.  If it does then Core will
; 1730 :             // fail the registration.  This makes sure that core is completely
; 1731 :             // shut down before the registration can start.  Note that we'll
; 1732 :             // let the Win32 OS clean up the mutex for us when we shut down.
; 1733 :             hTermMutex = CreateMutex( NULL, FALSE, "KZOENGWA - Termination" );

	push	OFFSET $SG96433
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	DWORD PTR _hTermMutex$28[ebp], eax

; 1734 : 
; 1735 :             // First, see if any tasks are active
; 1736 :             hTask = AnchorBlock->hFirstTask;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	mov	DWORD PTR _hTask$21[ebp], eax

; 1737 :             lpTask = zGETPTR( hTask );

	mov	ecx, DWORD PTR _hTask$21[ebp]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$47[ebp], eax

; 1738 : 
; 1739 :             // If the logfile is still open then close it.
; 1740 :             if ( lpTask && g_hLogFile != -1 )

	cmp	DWORD PTR _lpTask$47[ebp], 0
	je	SHORT $LN24@MainWndPro
	cmp	DWORD PTR _g_hLogFile, -1
	je	SHORT $LN24@MainWndPro

; 1741 :             {
; 1742 :                fnSysCloseFile( lpTask, g_hLogFile, 0 );

	push	0
	mov	edx, DWORD PTR _g_hLogFile
	push	edx
	mov	eax, DWORD PTR _lpTask$47[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 1743 :                g_hLogFile = -1;

	mov	DWORD PTR _g_hLogFile, -1
$LN24@MainWndPro:

; 1744 :             }
; 1745 : 
; 1746 :             while ( lpTask )

	cmp	DWORD PTR _lpTask$47[ebp], 0
	je	SHORT $LN25@MainWndPro

; 1747 :             {
; 1748 :                if ( hTask != AnchorBlock->hMainTask &&

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hTask$21[ebp]
	cmp	edx, DWORD PTR [ecx+106]
	je	SHORT $LN179@MainWndPro
	mov	eax, DWORD PTR _lpTask$47[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	je	SHORT $LN179@MainWndPro

; 1749 :                     IsWindow( (HWND) lpTask->hMainWnd ) )
; 1750 :                {
; 1751 :                   break;

	jmp	SHORT $LN25@MainWndPro
$LN179@MainWndPro:

; 1752 :                }
; 1753 : 
; 1754 :                lpTask = zGETPTR( lpTask->hNextTask );

	mov	edx, DWORD PTR _lpTask$47[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$47[ebp], eax

; 1755 :             }

	jmp	SHORT $LN24@MainWndPro
$LN25@MainWndPro:

; 1756 : 
; 1757 :             if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$47[ebp], 0
	jne	SHORT $LN180@MainWndPro

; 1758 :                lpTaskTemp = zGETPTR( AnchorBlock->hFirstTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTaskTemp$5[ebp], eax
	jmp	SHORT $LN181@MainWndPro
$LN180@MainWndPro:

; 1759 :             else
; 1760 :                lpTaskTemp = lpTask;

	mov	eax, DWORD PTR _lpTask$47[ebp]
	mov	DWORD PTR _lpTaskTemp$5[ebp], eax
$LN181@MainWndPro:

; 1761 : 
; 1762 :             if ( uMsg == WM_CLOSE )

	cmp	DWORD PTR _uMsg$[ebp], 16		; 00000010H
	jne	$LN182@MainWndPro

; 1763 :             {
; 1764 :                char  szIniName[ 260 ];
; 1765 :                char  szFileName[ 260 ];
; 1766 :                char  szTempName[ 260 ];
; 1767 :                char  szBuffer[ sizeof( "-2147483647," ) * 10 ];
; 1768 :                WINDOWPLACEMENT wp;
; 1769 : 
; 1770 :                wp.length = sizeof( wp );

	mov	DWORD PTR _wp$52[ebp], 44		; 0000002cH

; 1771 :                if ( GetWindowPlacement( hWnd, &wp ) )

	lea	ecx, DWORD PTR _wp$52[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__GetWindowPlacement@8
	test	eax, eax
	je	SHORT $LN183@MainWndPro

; 1772 :                {
; 1773 :                   // write window placement to Zeidon.ini file.
; 1774 : 
; 1775 :                   wsprintf( szBuffer, szPlaceFormat,

	mov	eax, DWORD PTR _wp$52[ebp+40]
	push	eax
	mov	ecx, DWORD PTR _wp$52[ebp+36]
	push	ecx
	mov	edx, DWORD PTR _wp$52[ebp+32]
	push	edx
	mov	eax, DWORD PTR _wp$52[ebp+28]
	push	eax
	mov	ecx, DWORD PTR _wp$52[ebp+24]
	push	ecx
	mov	edx, DWORD PTR _wp$52[ebp+20]
	push	edx
	mov	eax, DWORD PTR _wp$52[ebp+16]
	push	eax
	mov	ecx, DWORD PTR _wp$52[ebp+12]
	push	ecx
	mov	edx, DWORD PTR _wp$52[ebp+8]
	push	edx
	mov	eax, DWORD PTR _wp$52[ebp+4]
	push	eax
	push	OFFSET _szPlaceFormat
	lea	ecx, DWORD PTR _szBuffer$66[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 48					; 00000030H

; 1776 :                             wp.flags, wp.showCmd,
; 1777 :                             wp.ptMinPosition.x, wp.ptMinPosition.y,
; 1778 :                             wp.ptMaxPosition.x, wp.ptMaxPosition.y,
; 1779 :                             wp.rcNormalPosition.left,
; 1780 :                             wp.rcNormalPosition.top,
; 1781 :                             wp.rcNormalPosition.right,
; 1782 :                             wp.rcNormalPosition.bottom );
; 1783 :                }

	jmp	SHORT $LN184@MainWndPro
$LN183@MainWndPro:

; 1784 :                else
; 1785 :                   szBuffer[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T20[ebp], eax
	cmp	DWORD PTR $T20[ebp], 130		; 00000082H
	jae	SHORT $LN231@MainWndPro
	jmp	SHORT $LN232@MainWndPro
$LN231@MainWndPro:
	call	___report_rangecheckfailure
$LN232@MainWndPro:
	mov	ecx, DWORD PTR $T20[ebp]
	mov	BYTE PTR _szBuffer$66[ebp+ecx], 0
$LN184@MainWndPro:

; 1786 : 
; 1787 :             // SysReadZeidonIni( -1, szlWorkstation, "LocalDir", szTempName );
; 1788 :                GetEnvironmentVariable( "ZEIDON", szIniName, sizeof( szIniName ) );

	push	260					; 00000104H
	lea	edx, DWORD PTR _szIniName$62[ebp]
	push	edx
	push	OFFSET $SG96441
	call	DWORD PTR __imp__GetEnvironmentVariableA@12

; 1789 :                zstrcat( szIniName, "\\zeidon.ini" );

	push	OFFSET $SG96442
	lea	eax, DWORD PTR _szIniName$62[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1790 :                GetPrivateProfileString( "Workstation", "LocalDir", "",

	lea	ecx, DWORD PTR _szIniName$62[ebp]
	push	ecx
	push	260					; 00000104H
	lea	edx, DWORD PTR _szTempName$57[ebp]
	push	edx
	push	OFFSET $SG96443
	push	OFFSET $SG96444
	push	OFFSET $SG96445
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 1791 :                                         szTempName, sizeof( szTempName ), szIniName );
; 1792 :                SysConvertEnvironmentString( szFileName, szTempName );

	lea	eax, DWORD PTR _szTempName$57[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$65[ebp]
	push	ecx
	call	_SysConvertEnvironmentString@8

; 1793 :                if ( szFileName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szFileName$65[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN185@MainWndPro

; 1794 :                {
; 1795 :                   SysAppendcDirSep( szFileName );

	lea	edx, DWORD PTR _szFileName$65[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 1796 :                   zstrcat( szFileName, "ZeidonRT.ini" );

	push	OFFSET $SG96448
	lea	eax, DWORD PTR _szFileName$65[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1797 :                }

	jmp	SHORT $LN186@MainWndPro
$LN185@MainWndPro:

; 1798 :                else
; 1799 :                   zstrcpy( szFileName, szIniName );

	lea	ecx, DWORD PTR _szIniName$62[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$65[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN186@MainWndPro:

; 1800 : 
; 1801 :                WritePrivateProfileString( "ObjectEngine", // section name

	lea	eax, DWORD PTR _szFileName$65[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuffer$66[ebp]
	push	ecx
	push	OFFSET $SG96449
	push	OFFSET $SG96450
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1802 :                                           "WindowPos",    // key name
; 1803 :                                           szBuffer,       // string to add
; 1804 :                                           szFileName );   // ini filename
; 1805 :                zltoa( g_uTraceLineLimit, szBuffer );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _szBuffer$66[ebp]
	push	edx
	mov	eax, DWORD PTR _g_uTraceLineLimit
	push	eax
	call	__ltoa
	add	esp, 12					; 0000000cH

; 1806 :                WritePrivateProfileString( "ObjectEngine", "LineLimit",

	lea	ecx, DWORD PTR _szFileName$65[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuffer$66[ebp]
	push	edx
	push	OFFSET $SG96451
	push	OFFSET $SG96452
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1807 :                                           szBuffer, szFileName );
; 1808 :                WritePrivateProfileString( "ObjectEngine", "FindString",

	lea	eax, DWORD PTR _szFileName$65[ebp]
	push	eax
	push	OFFSET _g_szFindString
	push	OFFSET $SG96453
	push	OFFSET $SG96454
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1809 :                                           g_szFindString, szFileName );
; 1810 :                szBuffer[ 1 ] = 0;

	mov	DWORD PTR $T19[ebp], 1
	cmp	DWORD PTR $T19[ebp], 130		; 00000082H
	jae	SHORT $LN233@MainWndPro
	jmp	SHORT $LN234@MainWndPro
$LN233@MainWndPro:
	call	___report_rangecheckfailure
$LN234@MainWndPro:
	mov	ecx, DWORD PTR $T19[ebp]
	mov	BYTE PTR _szBuffer$66[ebp+ecx], 0

; 1811 :                szBuffer[ 0 ] = g_chScrollTrace;

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _g_chScrollTrace
	mov	BYTE PTR _szBuffer$66[ebp+eax], cl

; 1812 :                WritePrivateProfileString( "ObjectEngine", "ScrollTrace",

	lea	edx, DWORD PTR _szFileName$65[ebp]
	push	edx
	lea	eax, DWORD PTR _szBuffer$66[ebp]
	push	eax
	push	OFFSET $SG96455
	push	OFFSET $SG96456
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1813 :                                           szBuffer, szFileName );
; 1814 :                szBuffer[ 0 ] = g_chPrintPreview;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _g_chPrintPreview
	mov	BYTE PTR _szBuffer$66[ebp+edx], al

; 1815 :                WritePrivateProfileString( "ObjectEngine", "PrintPreview",

	lea	ecx, DWORD PTR _szFileName$65[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuffer$66[ebp]
	push	edx
	push	OFFSET $SG96457
	push	OFFSET $SG96458
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1816 :                                           szBuffer, szFileName );
; 1817 :                szBuffer[ 0 ] = g_chPrintDialog;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _g_chPrintDialog
	mov	BYTE PTR _szBuffer$66[ebp+ecx], dl

; 1818 :                WritePrivateProfileString( "ObjectEngine", "PrintDialog",

	lea	eax, DWORD PTR _szFileName$65[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuffer$66[ebp]
	push	ecx
	push	OFFSET $SG96459
	push	OFFSET $SG96460
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1819 :                                           szBuffer, szFileName );
; 1820 :                szBuffer[ 0 ] = g_chTraceOE_Warning;

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _g_chTraceOE_Warning
	mov	BYTE PTR _szBuffer$66[ebp+eax], cl

; 1821 :                WritePrivateProfileString( "ObjectEngine", "TraceOE_Warning",

	lea	edx, DWORD PTR _szFileName$65[ebp]
	push	edx
	lea	eax, DWORD PTR _szBuffer$66[ebp]
	push	eax
	push	OFFSET $SG96461
	push	OFFSET $SG96462
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1822 :                                           szBuffer, szFileName );
; 1823 :                szBuffer[ 0 ] = g_chTraceZDrActions;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _g_chTraceZDrActions
	mov	BYTE PTR _szBuffer$66[ebp+edx], al

; 1824 :                WritePrivateProfileString( "ObjectEngine", "TraceAction",

	lea	ecx, DWORD PTR _szFileName$65[ebp]
	push	ecx
	lea	edx, DWORD PTR _szBuffer$66[ebp]
	push	edx
	push	OFFSET $SG96463
	push	OFFSET $SG96464
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1825 :                                           szBuffer, szFileName );
; 1826 :                szBuffer[ 0 ] = g_chTraceWebActions;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _g_chTraceWebActions
	mov	BYTE PTR _szBuffer$66[ebp+ecx], dl

; 1827 :                WritePrivateProfileString( "ObjectEngine", "TraceWeb",

	lea	eax, DWORD PTR _szFileName$65[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuffer$66[ebp]
	push	ecx
	push	OFFSET $SG96465
	push	OFFSET $SG96466
	call	DWORD PTR __imp__WritePrivateProfileStringA@16

; 1828 :                                           szBuffer, szFileName );
; 1829 :                if ( AnchorBlock && AnchorBlock->bShowTaskID )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN187@MainWndPro
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	and	eax, 1
	je	SHORT $LN187@MainWndPro

; 1830 :                   szBuffer[ 0 ] = 'Y';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szBuffer$66[ebp+edx], 89	; 00000059H
	jmp	SHORT $LN188@MainWndPro
$LN187@MainWndPro:

; 1831 :                else
; 1832 :                   szBuffer[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T18[ebp], ecx
	cmp	DWORD PTR $T18[ebp], 130		; 00000082H
	jae	SHORT $LN235@MainWndPro
	jmp	SHORT $LN236@MainWndPro
$LN235@MainWndPro:
	call	___report_rangecheckfailure
$LN236@MainWndPro:
	mov	edx, DWORD PTR $T18[ebp]
	mov	BYTE PTR _szBuffer$66[ebp+edx], 0
$LN188@MainWndPro:

; 1833 : 
; 1834 :                WritePrivateProfileString( "ObjectEngine", "ShowTaskID",

	lea	eax, DWORD PTR _szFileName$65[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuffer$66[ebp]
	push	ecx
	push	OFFSET $SG96469
	push	OFFSET $SG96470
	call	DWORD PTR __imp__WritePrivateProfileStringA@16
$LN182@MainWndPro:

; 1835 :                                           szBuffer, szFileName );
; 1836 :             }
; 1837 : 
; 1838 :             if ( uMsg == WM_QUERYENDSESSION )

	cmp	DWORD PTR _uMsg$[ebp], 17		; 00000011H
	jne	SHORT $LN189@MainWndPro

; 1839 :             {
; 1840 :                if ( lpTask )

	cmp	DWORD PTR _lpTask$47[ebp], 0
	je	SHORT $LN190@MainWndPro

; 1841 :                {
; 1842 :                   // There are Zeidon tasks running.  Determine if the user
; 1843 :                   // really wants to shut down.
; 1844 :                   nResponse =

	push	8244					; 00002034H
	push	OFFSET $SG96473
	push	OFFSET $SG96474
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__MessageBoxA@16
	mov	DWORD PTR _nResponse$41[ebp], eax

; 1845 :                         MessageBox( hWnd,
; 1846 :                                     "Zeidon Applications are still active.\n"
; 1847 :                                     "Do you still want to shut down?",
; 1848 :                                     "Zeidon Object Services",
; 1849 :                                     MB_ICONEXCLAMATION |
; 1850 :                                     MB_YESNO | MB_TASKMODAL );
; 1851 :                   if ( nResponse == IDNO )

	cmp	DWORD PTR _nResponse$41[ebp], 7
	jne	SHORT $LN190@MainWndPro

; 1852 :                   {
; 1853 :                      ReleaseMutex( hTermMutex );

	mov	eax, DWORD PTR _hTermMutex$28[ebp]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1854 :                      CloseHandle( hTermMutex );

	mov	ecx, DWORD PTR _hTermMutex$28[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 1855 :                      return( FALSE );  // User doesn't want to shut down.

	xor	eax, eax
	jmp	$LN210@MainWndPro
$LN190@MainWndPro:

; 1856 :                   }
; 1857 :                }
; 1858 : 
; 1859 :                return( TRUE );   // Allow shutdown.

	mov	eax, 1
	jmp	$LN210@MainWndPro
$LN189@MainWndPro:

; 1860 :             }
; 1861 : 
; 1862 : #define zZEIDON_DRIVER_MSG                                   0x4000
; 1863 : #define zZEIDON_COMMUNICATE_OE              (zZEIDON_DRIVER_MSG + 1)
; 1864 : #define zZEIDON_POSTED_CLOSE                (zZEIDON_DRIVER_MSG + 2)
; 1865 : 
; 1866 :             // If any tasks are active, prompt for shutdown
; 1867 :             if ( lpTask )

	cmp	DWORD PTR _lpTask$47[ebp], 0
	je	$LN192@MainWndPro

; 1868 :             {
; 1869 :                MessageBeep( 0 );

	push	0
	call	DWORD PTR __imp__MessageBeep@4

; 1870 : #if 0
; 1871 :                nResponse = IDYES;
; 1872 :                MessageBox( hWnd,
; 1873 :                            "Zeidon Applications are still active.\n"
; 1874 :                            "Please close them before exiting!",
; 1875 :                            "Zeidon Object Services",
; 1876 :                            MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OK );
; 1877 : #else
; 1878 :                nResponse =

	push	8484					; 00002124H
	push	OFFSET $SG96477
	push	OFFSET $SG96478
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__MessageBoxA@16
	mov	DWORD PTR _nResponse$41[ebp], eax

; 1879 :                      MessageBox( hWnd,
; 1880 :                                  "Zeidon Applications are still active.\n"
; 1881 :                                  "Do you wish to try and close them?",
; 1882 :                                  "Zeidon Object Services",
; 1883 :                                  MB_ICONQUESTION | MB_YESNO |
; 1884 :                                  MB_TASKMODAL | MB_DEFBUTTON2 );
; 1885 :                if ( nResponse == IDYES )

	cmp	DWORD PTR _nResponse$41[ebp], 6
	jne	$LN193@MainWndPro

; 1886 :                {
; 1887 :                   nResponse = IDNO;

	mov	DWORD PTR _nResponse$41[ebp], 7

; 1888 :                   lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$47[ebp], eax
$LN26@MainWndPro:

; 1889 :                   while ( TRUE )

	mov	edx, 1
	test	edx, edx
	je	$LN27@MainWndPro

; 1890 :                   {
; 1891 :                      LPTASK lpTask2;
; 1892 : 
; 1893 :                      if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$47[ebp], 0
	jne	SHORT $LN195@MainWndPro

; 1894 :                         break;

	jmp	$LN27@MainWndPro
$LN195@MainWndPro:

; 1895 : 
; 1896 :                      // Chain forward 1 so close can remove this task
; 1897 :                      lpTask2 = zGETPTR( lpTask->hNextTask );

	mov	eax, DWORD PTR _lpTask$47[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask2$4[ebp], eax

; 1898 :                      if ( zGETHNDL( lpTask ) != AnchorBlock->hMainTask &&
; 1899 :                           IsWindow( (HWND) lpTask->hMainWnd ) &&

	mov	edx, DWORD PTR _lpTask$47[ebp]
	push	edx
	call	_SysGetHandleFromPointer@4
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [ecx+106]
	je	SHORT $LN196@MainWndPro
	mov	edx, DWORD PTR _lpTask$47[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	je	SHORT $LN196@MainWndPro
	push	-1
	push	0
	push	16385					; 00004001H
	mov	ecx, DWORD PTR _lpTask$47[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
	cmp	eax, -1
	jne	SHORT $LN196@MainWndPro

; 1900 :                           SendMessage( (HWND) lpTask->hMainWnd,
; 1901 :                                        zZEIDON_COMMUNICATE_OE, 0, -1L ) == -1 )
; 1902 :                      {
; 1903 :                         nResponse = IDYES;

	mov	DWORD PTR _nResponse$41[ebp], 6

; 1904 :                      // TraceLineI( "OE IDYES for Task: ", lpTask->lTaskID );
; 1905 : 
; 1906 :                         PostMessage( (HWND) lpTask->hMainWnd,

	push	0
	push	0
	push	16386					; 00004002H
	mov	eax, DWORD PTR _lpTask$47[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR __imp__PostMessageA@16
$LN196@MainWndPro:

; 1907 :                                      zZEIDON_POSTED_CLOSE, 0, 0L );
; 1908 :                      }
; 1909 :                   // else
; 1910 :                   //    TraceLineI( "OE IDNO for Task: ", lpTask->lTaskID );
; 1911 : 
; 1912 :                      lpTask = lpTask2;

	mov	edx, DWORD PTR _lpTask2$4[ebp]
	mov	DWORD PTR _lpTask$47[ebp], edx

; 1913 :                   }

	jmp	$LN26@MainWndPro
$LN27@MainWndPro:

; 1914 :                }

	jmp	SHORT $LN192@MainWndPro
$LN193@MainWndPro:

; 1915 :                else
; 1916 :                {
; 1917 :                   ReleaseMutex( hTermMutex );

	mov	eax, DWORD PTR _hTermMutex$28[ebp]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 1918 :                   CloseHandle( hTermMutex );

	mov	ecx, DWORD PTR _hTermMutex$28[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 1919 :                   SetActiveWindow( (HWND) lpTask->hMainWnd );

	mov	edx, DWORD PTR _lpTask$47[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR __imp__SetActiveWindow@4

; 1920 :                   return( 1 );

	mov	eax, 1
	jmp	$LN210@MainWndPro
$LN192@MainWndPro:

; 1921 :                }
; 1922 : #endif
; 1923 :             }
; 1924 : 
; 1925 :             // If an attempt was made to close applications, then
; 1926 :             // see if all applications have left.
; 1927 :             lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$47[ebp], eax

; 1928 :             if ( nResponse == IDYES )

	cmp	DWORD PTR _nResponse$41[ebp], 6
	jne	SHORT $LN177@MainWndPro

; 1929 :             {
; 1930 :                // We stay up so other tasks have time to come down cleanly
; 1931 : // Stay up!    PostMessage( hWnd, WM_CLOSE, 0, 0L );
; 1932 :                return( 0 );

	xor	eax, eax
	jmp	$LN210@MainWndPro
$LN177@MainWndPro:

; 1933 :             }
; 1934 :          }
; 1935 : 
; 1936 :          break;

	jmp	$LN2@MainWndPro
$LN198@MainWndPro:

; 1937 : 
; 1938 :       case WM_DESTROY:                  // message: window being destroyed
; 1939 :       {
; 1940 :          LPTASK lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$24[ebp], eax

; 1941 :          // It's OK to leave, Shutdown Object Services
; 1942 : 
; 1943 :          if ( g_uKillTimerId )

	cmp	DWORD PTR _g_uKillTimerId, 0
	je	SHORT $LN199@MainWndPro

; 1944 :             KillTimer( hWnd, g_uKillTimerId );

	mov	edx, DWORD PTR _g_uKillTimerId
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__KillTimer@8
$LN199@MainWndPro:

; 1945 : 
; 1946 : #ifdef __WIN32__
; 1947 :          DetachSysTray( ); // remove Icon from systray

	call	_DetachSysTray

; 1948 :          DestroyWindow( g_hThreadWnd );

	mov	ecx, DWORD PTR _g_hThreadWnd
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4

; 1949 : #endif
; 1950 : 
; 1951 :          FreeProcInstance( fpAbout );
; 1952 :          FreeProcInstance( fpLogon );
; 1953 :          FreeProcInstance( fpSetTrace );
; 1954 :          FreeProcInstance( fpLogTrace );
; 1955 :          FreeProcInstance( fpTraceList );
; 1956 :          FreeProcInstance( fpLineLimit );
; 1957 :          FreeProcInstance( fpFindString );
; 1958 :          FreeProcInstance( fpShowDLL );
; 1959 :          FreeProcInstance( fpSqlServerErrHandler );
; 1960 :          FreeProcInstance( fpSqlServerMsgHandler );
; 1961 : 
; 1962 :          lpTask->bOE_TaskShutdown = TRUE;

	mov	edx, DWORD PTR _lpTask$24[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR _lpTask$24[ebp]
	mov	DWORD PTR [ecx+443], eax

; 1963 :          FreeAnchorBlock( lpTask );

	mov	edx, DWORD PTR _lpTask$24[ebp]
	push	edx
	call	_FreeAnchorBlock@4

; 1964 :          AnchorBlock = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 1965 : 
; 1966 :          PostQuitMessage( 0 );

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 1967 :          break;

	jmp	$LN2@MainWndPro
$LN200@MainWndPro:

; 1968 :       }
; 1969 : 
; 1970 :       case WM_WININICHANGE:
; 1971 :          // If multiple sections or the Intl section of the win.ini
; 1972 :          // file has been updated, go rebuild the international info
; 1973 :          if ( lParam == 0L || zstrcmpi( szlINTL, (zPCHAR) lParam ) == 0 )

	cmp	DWORD PTR _lParam$[ebp], 0
	je	SHORT $LN202@MainWndPro
	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	push	OFFSET _szlINTL
	call	__stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN201@MainWndPro
$LN202@MainWndPro:

; 1974 :          {
; 1975 :             zPVOID            hNewInt;
; 1976 :             LPINTERNATIONAL   lpOldInt;
; 1977 : 
; 1978 :             // Get possible changes
; 1979 :             if ( (hNewInt = SysCreateInternational( )) != 0 )

	call	_SysCreateInternational@0
	mov	DWORD PTR _hNewInt$17[ebp], eax
	cmp	DWORD PTR _hNewInt$17[ebp], 0
	je	SHORT $LN201@MainWndPro

; 1980 :             {
; 1981 :                TraceLineS( "(wa) changing international info - ",

	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	push	OFFSET $SG96490
	call	_TraceLineS@8

; 1982 :                            (zPCHAR) lParam );
; 1983 : 
; 1984 :                // switch pointers
; 1985 :                lpOldInt = zGETPTR( AnchorBlock->hInternational );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpOldInt$3[ebp], eax

; 1986 :                AnchorBlock->hInternational = hNewInt;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hNewInt$17[ebp]
	mov	DWORD PTR [ecx+2515], edx

; 1987 : 
; 1988 :                // free old values
; 1989 :                SysFreeInternational( lpOldInt );

	mov	eax, DWORD PTR _lpOldInt$3[ebp]
	push	eax
	call	_SysFreeInternational@4
$LN201@MainWndPro:

; 1990 :             }
; 1991 :          }
; 1992 : 
; 1993 :          break;

	jmp	$LN2@MainWndPro
$LN204@MainWndPro:

; 1994 : 
; 1995 :       case WM_WRITELOG:
; 1996 :          {
; 1997 :             SYSTEMTIME SysTime;
; 1998 :             LPTASK hTask;
; 1999 :             LPTASK lpTask;
; 2000 :             char szFileName[ 256 ];
; 2001 :             long hLogFile = g_hLogFile;

	mov	ecx, DWORD PTR _g_hLogFile
	mov	DWORD PTR _hLogFile$9[ebp], ecx

; 2002 : 
; 2003 :             GetLocalTime( &SysTime );

	lea	edx, DWORD PTR _SysTime$53[ebp]
	push	edx
	call	DWORD PTR __imp__GetLocalTime@4

; 2004 : 
; 2005 :             // szFileName looks like this:  YYYYMMDDhhmmss
; 2006 :             sprintf( szFileName, "%04d%02d%02d%02d%02d%02d.log",

	movzx	eax, WORD PTR _SysTime$53[ebp+12]
	push	eax
	movzx	ecx, WORD PTR _SysTime$53[ebp+10]
	push	ecx
	movzx	edx, WORD PTR _SysTime$53[ebp+8]
	push	edx
	movzx	eax, WORD PTR _SysTime$53[ebp+6]
	push	eax
	movzx	ecx, WORD PTR _SysTime$53[ebp+2]
	push	ecx
	movzx	edx, WORD PTR _SysTime$53[ebp]
	push	edx
	push	OFFSET $SG96492
	lea	eax, DWORD PTR _szFileName$61[ebp]
	push	eax
	call	_sprintf
	add	esp, 32					; 00000020H

; 2007 :                      SysTime.wYear, SysTime.wMonth,
; 2008 :                      SysTime.wDay, SysTime.wHour,
; 2009 :                      SysTime.wMinute, SysTime.wSecond );
; 2010 : 
; 2011 :             // First, see if any tasks are active
; 2012 :             hTask = AnchorBlock->hFirstTask;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	mov	DWORD PTR _hTask$2[ebp], edx

; 2013 :             lpTask = zGETPTR( hTask );

	mov	eax, DWORD PTR _hTask$2[ebp]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$25[ebp], eax

; 2014 : 
; 2015 :             if ( lpTask && szFileName[ 0 ] )

	cmp	DWORD PTR _lpTask$25[ebp], 0
	je	$LN205@MainWndPro
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szFileName$61[ebp+edx]
	test	eax, eax
	je	SHORT $LN205@MainWndPro

; 2016 :             {
; 2017 :                if ( (g_hLogFile = fnSysOpenFile( lpTask, szFileName,
; 2018 :                                                  COREFILE_CREATE )) != -1 )

	push	32					; 00000020H
	lea	ecx, DWORD PTR _szFileName$61[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$25[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _g_hLogFile, eax
	cmp	DWORD PTR _g_hLogFile, -1
	je	SHORT $LN205@MainWndPro

; 2019 :                {
; 2020 :                   char szTraceText[ 512 ];
; 2021 : 
; 2022 :                   // Send message that log file opened.
; 2023 :                   zstrcpy( szTraceText, "(ng) Log file Opened '" );

	push	OFFSET $SG96495
	lea	eax, DWORD PTR _szTraceText$58[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2024 :                   zstrcat( szTraceText, szFileName );

	lea	ecx, DWORD PTR _szFileName$61[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTraceText$58[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2025 :                   zstrcat( szTraceText, "'" );

	push	OFFSET $SG96496
	lea	eax, DWORD PTR _szTraceText$58[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2026 :                   SysMessageList( szTraceText );

	lea	ecx, DWORD PTR _szTraceText$58[ebp]
	push	ecx
	call	_SysMessageList@4

; 2027 : 
; 2028 :                   WriteTraceToLog( lpTask );

	mov	edx, DWORD PTR _lpTask$25[ebp]
	push	edx
	call	_WriteTraceToLog
	add	esp, 4
$LN205@MainWndPro:

; 2029 :                }
; 2030 :             }
; 2031 : 
; 2032 :             g_hLogFile = hLogFile;

	mov	eax, DWORD PTR _hLogFile$9[ebp]
	mov	DWORD PTR _g_hLogFile, eax

; 2033 :          }
; 2034 : 
; 2035 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN210@MainWndPro
$LN207@MainWndPro:

; 2036 : 
; 2037 :       case WM_QUERYALIVE:
; 2038 :          return( -1 );   // yup ... we're still here

	or	eax, -1
	jmp	SHORT $LN210@MainWndPro
$LN208@MainWndPro:

; 2039 : 
; 2040 :       default:
; 2041 :          if ( uMsg == g_wOENG_Message )

	mov	ecx, DWORD PTR _uMsg$[ebp]
	cmp	ecx, DWORD PTR _g_wOENG_Message
	jne	SHORT $LN2@MainWndPro

; 2042 :             fnProcessOENG_Message( hWnd, uMsg, wParam, lParam );

	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	_fnProcessOENG_Message
	add	esp, 16					; 00000010H
$LN2@MainWndPro:

; 2043 : 
; 2044 :          break; // return( DefWindowProc( hWnd, uMsg, wParam, lParam ) );
; 2045 :    }
; 2046 : 
; 2047 :    return( DefWindowProc( hWnd, uMsg, wParam, lParam ) );

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16
$LN210@MainWndPro:

; 2048 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN240@MainWndPro:
	DD	$LN198@MainWndPro
	DD	$LN31@MainWndPro
	DD	$LN175@MainWndPro
	DD	$LN200@MainWndPro
	DD	$LN208@MainWndPro
$LN239@MainWndPro:
	DB	0
	DB	4
	DB	4
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_MainWndProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_wc$ = -40						; size = 40
_hInstance$ = 8						; size = 4
_InitApplication PROC

; 2128 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 2129 :     WNDCLASS  wc;
; 2130 : 
; 2131 :     // Fill in window class structure with parameters that describe the
; 2132 :     // main window.
; 2133 : 
; 2134 :     wc.style = 0;                     // Class style(s).

	mov	DWORD PTR _wc$[ebp], 0

; 2135 :     wc.lpfnWndProc = MainWndProc;     // Function to retrieve messages for

	mov	DWORD PTR _wc$[ebp+4], OFFSET _MainWndProc@16

; 2136 :                                       // windows of this class.
; 2137 :     wc.cbClsExtra = 0;                // No per-class extra data.

	mov	DWORD PTR _wc$[ebp+8], 0

; 2138 :     wc.cbWndExtra = 0;                // No per-window extra data.

	mov	DWORD PTR _wc$[ebp+12], 0

; 2139 :     wc.hInstance = hInstance;         // Application that owns the class.

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wc$[ebp+16], eax

; 2140 :     wc.hIcon = LoadIcon( hInstance, "ZEIDON" );

	push	OFFSET $SG96530
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wc$[ebp+20], eax

; 2141 :     wc.hCursor = LoadCursor( 0, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 2142 :     wc.hbrBackground = GetStockObject( WHITE_BRUSH );

	push	0
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 2143 :     wc.lpszMenuName =  0;             // Name of menu resource in .RC file.

	mov	DWORD PTR _wc$[ebp+32], 0

; 2144 :     wc.lpszClassName = szClassName;   // Name used in call to CreateWindow.

	mov	DWORD PTR _wc$[ebp+36], OFFSET _szClassName

; 2145 : 
; 2146 : #ifdef __WIN32__
; 2147 :    // For Win32 we need to create an invisible window to handle Zeidon msgs.
; 2148 : 
; 2149 :    if ( !RegisterClass( &wc ) )

	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	eax, ax
	test	eax, eax
	jne	SHORT $LN2@InitApplic

; 2150 :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@InitApplic
$LN2@InitApplic:

; 2151 : 
; 2152 :     wc.style = 0;                       // Class style(s).

	mov	DWORD PTR _wc$[ebp], 0

; 2153 :     wc.lpfnWndProc = MainThrdWndProc;   // Function to retrieve messages.

	mov	DWORD PTR _wc$[ebp+4], OFFSET _MainThrdWndProc@16

; 2154 :     wc.cbClsExtra = 0;                  // No per-class extra data.

	mov	DWORD PTR _wc$[ebp+8], 0

; 2155 :     wc.cbWndExtra = 0;                  // No per-window extra data.

	mov	DWORD PTR _wc$[ebp+12], 0

; 2156 :     wc.hInstance  = hInstance;          // Application that owns the class.

	mov	ecx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wc$[ebp+16], ecx

; 2157 :     wc.hIcon      = 0;

	mov	DWORD PTR _wc$[ebp+20], 0

; 2158 :     wc.lpszMenuName =  0;               // Name of menu resource in .RC file.

	mov	DWORD PTR _wc$[ebp+32], 0

; 2159 :     wc.lpszClassName = szThreadClassName; // Name used in call to CreateWindow.

	mov	DWORD PTR _wc$[ebp+36], OFFSET _szThreadClassName

; 2160 : 
; 2161 : #endif
; 2162 : 
; 2163 :     // Register the window class and return success/failure code.
; 2164 : 
; 2165 :     return( RegisterClass( &wc ));

	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	eax, ax
$LN1@InitApplic:

; 2166 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InitApplication ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_dwStyle$ = -1276					; size = 4
_hProcessWnd$ = -1272					; size = 4
_nPosX$ = -1268						; size = 4
_nPosY$ = -1264						; size = 4
_nWidth$ = -1260					; size = 4
_nHeight$ = -1256					; size = 4
_uReturnLth$1 = -1252					; size = 2
tv503 = -1248						; size = 4
tv650 = -1244						; size = 4
tv667 = -1240						; size = 4
tv683 = -1236						; size = 4
tv761 = -1232						; size = 4
tv808 = -1228						; size = 4
tv767 = -1224						; size = 4
tv773 = -1220						; size = 4
tv779 = -1216						; size = 4
tv785 = -1212						; size = 4
tv791 = -1208						; size = 4
tv798 = -1204						; size = 4
_lpfnNetWkstaGetInfo$2 = -1200				; size = 4
_hNetApi$3 = -1196					; size = 4
$T4 = -1192						; size = 4
tv828 = -1188						; size = 4
tv818 = -1184						; size = 4
tv485 = -1180						; size = 4
tv466 = -1176						; size = 4
_hDC$ = -1172						; size = 4
_uRC$5 = -1168						; size = 2
_vDbhWork$ = -1164					; size = 4
_uLth$6 = -1160						; size = 2
_lpTask$ = -1156					; size = 4
_szEncrypted$7 = -1149					; size = 1
_lpTraceFlags$ = -1148					; size = 4
_i$ = -1144						; size = 4
_hMenu$ = -1140						; size = 4
_rect$ = -1136						; size = 16
_txtm$ = -1120						; size = 56
_wp$ = -1064						; size = 44
_Buffer$8 = -1020					; size = 80
_szTempName$ = -940					; size = 257
_szFileName$ = -680					; size = 257
_szPassword$9 = -420					; size = 32
_szUser$10 = -388					; size = 32
_szLanUser$11 = -356					; size = 32
_szIniPassword$12 = -324				; size = 32
_szIniUser$13 = -292					; size = 32
_szBuffer$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
_InitInstance PROC

; 2187 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1276				; 000004fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2188 :    zVIEW        vDbhWork;
; 2189 :    RECT         rect;
; 2190 :    HDC          hDC;  // handle to the context display
; 2191 :    TEXTMETRIC   txtm; // characteristics of text chars
; 2192 :    UINT         i;
; 2193 :    int          nHeight, nPosY;
; 2194 :    int          nWidth, nPosX;
; 2195 : // FARPROC      lpFarProc[ 2 ];
; 2196 :    LPTASK       lpTask;
; 2197 :    HMENU        hMenu;
; 2198 :    HWND         hProcessWnd;
; 2199 :    WINDOWPLACEMENT wp;
; 2200 :    char         szFileName[ zMAX_FILENAME_LTH + 1 ];
; 2201 :    char         szTempName[ zMAX_FILENAME_LTH + 1 ];
; 2202 :    char         szBuffer[ 256 ];
; 2203 :    LPTRACINGFLAGS lpTraceFlags;
; 2204 :    DWORD dwStyle = 0;

	mov	DWORD PTR _dwStyle$[ebp], 0

; 2205 : 
; 2206 :    // Save the instance handle in static variable, which will be used in
; 2207 :    // many subsequence calls from this application to Windows.
; 2208 : 
; 2209 :    hInst = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hInst, eax

; 2210 :    zmemset( szFileName, 0, zMAX_FILENAME_LTH + 1 );

	push	257					; 00000101H
	push	0
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2211 : 
; 2212 :    // Get the dimensions of the screen.
; 2213 :    nWidth = (GetSystemMetrics( SM_CXSCREEN ) * 3) / 4;

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	imul	eax, eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _nWidth$[ebp], eax

; 2214 :    nHeight = (GetSystemMetrics( SM_CYSCREEN ) * 3) / 4;

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	imul	eax, eax, 3
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _nHeight$[ebp], eax

; 2215 :    nPosX =  GetSystemMetrics( SM_CXSCREEN ) / 8;

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _nPosX$[ebp], eax

; 2216 :    nPosY =  GetSystemMetrics( SM_CYSCREEN ) / 8;

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR _nPosY$[ebp], eax

; 2217 : 
; 2218 :    // Create a main window for this application instance.
; 2219 :    hMenu = LoadMenu( hInstance, "KZOENGWA" );

	push	OFFSET $SG96620
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	DWORD PTR __imp__LoadMenuA@8
	mov	DWORD PTR _hMenu$[ebp], eax

; 2220 :    g_hWndMainFrame = CreateWindow(

	push	0
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _nHeight$[ebp]
	push	edx
	mov	eax, DWORD PTR _nWidth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nPosY$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nPosX$[ebp]
	push	edx
	push	13565952				; 00cf0000H
	push	OFFSET $SG96621
	push	OFFSET _szClassName
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _g_hWndMainFrame, eax

; 2221 :       szClassName,                    // see RegisterClass( ) call
; 2222 :       "Zeidon Object Services",       // text for window title bar
; 2223 :       WS_OVERLAPPEDWINDOW,            // window style
; 2224 :       nPosX,                          // default horizontal position
; 2225 :       nPosY,                          // default vertical position
; 2226 :       nWidth,                         // default width
; 2227 :       nHeight,                        // default height
; 2228 :       0,                              // overlapped windows have no parent
; 2229 :       hMenu,                          // menu for trace window
; 2230 :       hInstance,                      // this instance owns this window
; 2231 :       0 );                            // pointer not needed
; 2232 : 
; 2233 :    // If window could not be created, return "failure".
; 2234 :    if ( g_hWndMainFrame == 0 )

	cmp	DWORD PTR _g_hWndMainFrame, 0
	jne	SHORT $LN13@InitInstan

; 2235 :       return( FALSE );

	xor	eax, eax
	jmp	$LN65@InitInstan
$LN13@InitInstan:

; 2236 : 
; 2237 :    GetClientRect( g_hWndMainFrame, &rect );

	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	call	DWORD PTR __imp__GetClientRect@8

; 2238 : 
; 2239 :    // First, create the listbox that will receive TraceLine messages from
; 2240 :    // core.
; 2241 :    g_hWndLB = CreateWindow(

	push	0
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	mov	ecx, DWORD PTR _rect$[ebp+12]
	sub	ecx, DWORD PTR _rect$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _rect$[ebp+8]
	sub	edx, DWORD PTR _rect$[ebp]
	push	edx
	mov	eax, DWORD PTR _rect$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	push	1089470720				; 40f00100H
	push	OFFSET $SG96623
	push	OFFSET $SG96624
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _g_hWndLB, eax

; 2242 :       "ListBox",                      // see RegisterClass( ) call
; 2243 :       "Trace Window",                 // text for window title bar
; 2244 :       WS_CHILD | WS_VSCROLL | WS_HSCROLL |
; 2245 :          WS_CAPTION | LBS_NOINTEGRALHEIGHT,
; 2246 :       rect.left,                      // default horizontal position
; 2247 :       rect.top,                       // default vertical position
; 2248 :       (rect.right - rect.left),       // default width
; 2249 :       (rect.bottom - rect.top),       // default height
; 2250 :       g_hWndMainFrame,                // parent Window
; 2251 :       0,                              // use the window class menu
; 2252 :       hInstance,                      // this instance owns this window
; 2253 :       0                               // pointer not needed
; 2254 :    );
; 2255 : 
; 2256 :    if ( strlen( g_szZeidonEnvDirectory ) > 0 )

	push	OFFSET _g_szZeidonEnvDirectory
	call	_strlen
	add	esp, 4
	test	eax, eax
	jbe	SHORT $LN14@InitInstan

; 2257 :       SetEnvironmentVariable( "ZEIDON", g_szZeidonEnvDirectory );

	push	OFFSET _g_szZeidonEnvDirectory
	push	OFFSET $SG96626
	call	DWORD PTR __imp__SetEnvironmentVariableA@8
$LN14@InitInstan:

; 2258 : 
; 2259 :    GetEnvironmentVariable( "ZEIDON", szFileName, zMAX_FILENAME_LTH + 1 );

	push	257					; 00000101H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	OFFSET $SG96627
	call	DWORD PTR __imp__GetEnvironmentVariableA@12

; 2260 :    zstrcat( szFileName, "\\zeidon.ini" );

	push	OFFSET $SG96628
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2261 :    g_nTraceWindowCnt = GetPrivateProfileInt( "ObjectEngine", "TraceWindows",

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	2
	push	OFFSET $SG96629
	push	OFFSET $SG96630
	call	DWORD PTR __imp__GetPrivateProfileIntA@16
	mov	DWORD PTR _g_nTraceWindowCnt, eax

; 2262 :                                              2, szFileName );
; 2263 :    if ( g_nTraceWindowCnt < 1 )

	cmp	DWORD PTR _g_nTraceWindowCnt, 1
	jae	SHORT $LN15@InitInstan

; 2264 :       g_nTraceWindowCnt = 2;

	mov	DWORD PTR _g_nTraceWindowCnt, 2
	jmp	SHORT $LN16@InitInstan
$LN15@InitInstan:

; 2265 :    else
; 2266 :    if ( g_nTraceWindowCnt > MAX_TRACE_WINDOWS )

	cmp	DWORD PTR _g_nTraceWindowCnt, 20	; 00000014H
	jbe	SHORT $LN16@InitInstan

; 2267 :       g_nTraceWindowCnt = MAX_TRACE_WINDOWS;

	mov	DWORD PTR _g_nTraceWindowCnt, 20	; 00000014H
$LN16@InitInstan:

; 2268 : 
; 2269 :    // Create the trace windows in the circuluar list.
; 2270 :    for ( i = 0; i < g_nTraceWindowCnt; i++ )

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@InitInstan
$LN2@InitInstan:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN4@InitInstan:
	mov	eax, DWORD PTR _i$[ebp]
	cmp	eax, DWORD PTR _g_nTraceWindowCnt
	jae	$LN3@InitInstan

; 2271 :    {
; 2272 :       g_hwndTraceWindow[ i ] = CreateWindow(

	push	0
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	mov	eax, DWORD PTR _rect$[ebp+12]
	sub	eax, DWORD PTR _rect$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _rect$[ebp+8]
	sub	ecx, DWORD PTR _rect$[ebp]
	push	ecx
	mov	edx, DWORD PTR _rect$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _rect$[ebp]
	push	eax
	push	1089470720				; 40f00100H
	push	OFFSET $SG96634
	push	OFFSET $SG96635
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	ecx, DWORD PTR _i$[ebp]
	mov	DWORD PTR _g_hwndTraceWindow[ecx*4], eax

; 2273 :          "ListBox",                      // see RegisterClass( ) call
; 2274 :          "Trace Window",                 // text for window title bar
; 2275 :          WS_CHILD | WS_VSCROLL | WS_HSCROLL |
; 2276 :             WS_CAPTION | LBS_NOINTEGRALHEIGHT,
; 2277 :          rect.left,                      // default horizontal position
; 2278 :          rect.top,                       // default vertical position
; 2279 :          (rect.right - rect.left),       // default width
; 2280 :          (rect.bottom - rect.top),       // default height
; 2281 :          g_hWndMainFrame,                // parent Window
; 2282 :          0,                              // use the window class menu
; 2283 :          hInstance,                      // this instance owns this window
; 2284 :          0                               // pointer not needed
; 2285 :       );
; 2286 : 
; 2287 :       SendMessage( g_hwndTraceWindow[ i ], WM_SETFONT,

	push	0
	push	16					; 00000010H
	call	DWORD PTR __imp__GetStockObject@4
	push	eax
	push	48					; 00000030H
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _g_hwndTraceWindow[edx*4]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16

; 2288 :                    (WPARAM) GetStockObject( SYSTEM_FIXED_FONT ), 0 );
; 2289 : 
; 2290 :       hDC = GetDC( g_hwndTraceWindow[ i ] );         // get the display context

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _g_hwndTraceWindow[ecx*4]
	push	edx
	call	DWORD PTR __imp__GetDC@4
	mov	DWORD PTR _hDC$[ebp], eax

; 2291 :       GetTextMetrics( hDC, &txtm );

	lea	eax, DWORD PTR _txtm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hDC$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetTextMetricsA@8

; 2292 :       ReleaseDC ( g_hwndTraceWindow[ i ], hDC );     // free the resource

	mov	edx, DWORD PTR _hDC$[ebp]
	push	edx
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__ReleaseDC@8

; 2293 :       SendMessage( g_hwndTraceWindow[ i ], LB_SETHORIZONTALEXTENT,

	push	0
	mov	edx, DWORD PTR _txtm$[ebp+24]
	shl	edx, 8
	push	edx
	push	404					; 00000194H
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _g_hwndTraceWindow[eax*4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 2294 :                    txtm.tmMaxCharWidth * 256, 0L );
; 2295 :    }

	jmp	$LN2@InitInstan
$LN3@InitInstan:

; 2296 : 
; 2297 :    hMenu = GetMenu( g_hWndMainFrame );

	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _hMenu$[ebp], eax

; 2298 : 
; 2299 :    // Delete the unused menu items.
; 2300 :    for ( i = g_nTraceWindowCnt; i < MAX_TRACE_WINDOWS; i++ )

	mov	eax, DWORD PTR _g_nTraceWindowCnt
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN7@InitInstan
$LN5@InitInstan:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN7@InitInstan:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jae	SHORT $LN6@InitInstan

; 2301 :       DeleteMenu( hMenu, IDM_TRACEWINDOW01 + i, MF_BYCOMMAND );

	push	0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	mov	eax, DWORD PTR _hMenu$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteMenu@12
	jmp	SHORT $LN5@InitInstan
$LN6@InitInstan:

; 2302 : 
; 2303 :    ShowWindow( g_hwndTraceWindow[ 0 ], SW_SHOW );

	push	5
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _g_hwndTraceWindow[edx]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 2304 :    g_nTraceWindowHead      = 0;

	mov	DWORD PTR _g_nTraceWindowHead, 0

; 2305 :    g_nTraceWindowDisplayed = 0;

	mov	DWORD PTR _g_nTraceWindowDisplayed, 0

; 2306 : 
; 2307 :    CheckMenuItem( hMenu, IDM_TRACEWINDOW01,

	push	8
	push	300					; 0000012cH
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2308 :                   MF_BYCOMMAND | MF_CHECKED );
; 2309 : 
; 2310 :    // Make proc instances for message procedures
; 2311 :    fpAbout = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpAbout, OFFSET _AboutDlgProc@16

; 2312 :       MakeProcInstance( (FARPROC) AboutDlgProc, hInstance );
; 2313 :    fpLogon = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpLogon, OFFSET _LogonDlgProc@16

; 2314 :       MakeProcInstance( (FARPROC) LogonDlgProc, hInstance );
; 2315 :    fpSetTrace = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpSetTrace, OFFSET _SetTraceDlgProc@16

; 2316 :       MakeProcInstance( (FARPROC) SetTraceDlgProc, hInstance );
; 2317 :    fpLogTrace = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpLogTrace, OFFSET _LogTraceDlgProc@16

; 2318 :       MakeProcInstance( (FARPROC) LogTraceDlgProc, hInstance );
; 2319 :    fpTraceList = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpTraceList, OFFSET _TraceListWndProc@16

; 2320 :       MakeProcInstance( (FARPROC) TraceListWndProc, hInstance );
; 2321 :    fpLineLimit = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpLineLimit, OFFSET _LimitDlgProc@16

; 2322 :       MakeProcInstance( (FARPROC) LimitDlgProc, hInstance );
; 2323 :    fpFindString = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpFindString, OFFSET _FindStringDlgProc@16

; 2324 :       MakeProcInstance( (FARPROC) FindStringDlgProc, hInstance );
; 2325 :    fpShowDLL = (zFARPROC_CALLBACK)

	mov	DWORD PTR _fpShowDLL, OFFSET _ShowDLLDlgProc@16

; 2326 :       MakeProcInstance( (FARPROC) ShowDLLDlgProc, hInstance );
; 2327 : 
; 2328 :    // Change the WndProc for the list window so we can trap LB_ADDSTRING
; 2329 :    // messages and write them to the trace log (if open)
; 2330 :    fpDfltListWndProc = (zFARPROC_CALLBACK)

	push	OFFSET _TraceListWndProc@16
	push	-4					; fffffffcH
	mov	edx, DWORD PTR _g_hWndLB
	push	edx
	call	DWORD PTR __imp__SetWindowLongA@12
	mov	DWORD PTR _fpDfltListWndProc, eax

; 2331 :       SetWindowLong( g_hWndLB, GWL_WNDPROC, (DWORD) TraceListWndProc );
; 2332 : 
; 2333 :    // Register message of Object Services.
; 2334 :    g_wOENG_Message = RegisterWindowMessage( "KZOESRVC" );

	push	OFFSET $SG96636
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	DWORD PTR _g_wOENG_Message, eax

; 2335 : 
; 2336 : #ifdef __WIN32__
; 2337 :    // We need to start up the message loop thread.
; 2338 :    g_bThreadStarted = FALSE;

	mov	BYTE PTR _g_bThreadStarted, 0

; 2339 : 
; 2340 : #ifdef __BORLANDC__
; 2341 :    // start address, stack size, argument, security, initflag, thread address
; 2342 :    // unsigned long _RTLENTRY _EXPFUNC
; 2343 :    // _beginthreadNT( void (_USERENTRY *__start)(void *),
; 2344 :    //                 unsigned __stksize, void *__arg,
; 2345 :    //                 void *__security_attr,
; 2346 :    //                 unsigned long __create_flags,
; 2347 :    //                 unsigned long *__thread_id );
; 2348 : 
; 2349 : #else
; 2350 :    // security, stack size, start address, arglist, initflag, thread address
; 2351 :    g_hThread = _beginthreadex( NULL, 0, fnThreadProc, 0, 0, &g_dwThreadID );

	push	OFFSET _g_dwThreadID
	push	0
	push	0
	push	OFFSET _fnThreadProc@4
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _g_hThread, eax

; 2352 : #endif
; 2353 : 
; 2354 :    if ( g_hThread )

	cmp	DWORD PTR _g_hThread, 0
	je	SHORT $LN8@InitInstan

; 2355 :       CloseHandle( (HANDLE) g_hThread );

	mov	eax, DWORD PTR _g_hThread
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
$LN8@InitInstan:

; 2356 : 
; 2357 :    // Now wait until the thread has finished its initialization.
; 2358 :    while ( g_bThreadStarted == FALSE )

	movzx	ecx, BYTE PTR _g_bThreadStarted
	test	ecx, ecx
	jne	SHORT $LN9@InitInstan

; 2359 :       Sleep( 10 );

	push	10					; 0000000aH
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LN8@InitInstan
$LN9@InitInstan:

; 2360 : 
; 2361 :    hProcessWnd = g_hThreadWnd;

	mov	edx, DWORD PTR _g_hThreadWnd
	mov	DWORD PTR _hProcessWnd$[ebp], edx

; 2362 : #else
; 2363 :    hProcessWnd = g_hWndMainFrame;
; 2364 : #endif
; 2365 : 
; 2366 :    // Initialize Object services anchor block
; 2367 :    AnchorBlock = InitializeAnchorBlock( (zLONG) hInstance,

	mov	eax, DWORD PTR _g_wOENG_Message
	push	eax
	mov	ecx, DWORD PTR _g_hWndLB
	push	ecx
	mov	edx, DWORD PTR _hProcessWnd$[ebp]
	push	edx
	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	_InitializeAnchorBlock@16
	mov	DWORD PTR _AnchorBlock, eax

; 2368 :                                         (zLONG) hProcessWnd,
; 2369 :                                         (zLONG) g_hWndLB,
; 2370 :                                         (zLONG) g_wOENG_Message );
; 2371 : 
; 2372 :    // If initialization failed, destroy the instance and return.
; 2373 :    if ( AnchorBlock == 0 || AnchorBlock == (LPANCHOR) zCALL_ERROR )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN20@InitInstan
	cmp	DWORD PTR _AnchorBlock, -16		; fffffff0H
	jne	SHORT $LN19@InitInstan
$LN20@InitInstan:

; 2374 :    {
; 2375 :       DestroyWindow( g_hWndMainFrame );

	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	call	DWORD PTR __imp__DestroyWindow@4

; 2376 :       return( 0 );

	xor	eax, eax
	jmp	$LN65@InitInstan
$LN19@InitInstan:

; 2377 :    }
; 2378 : 
; 2379 :    AnchorBlock->OS_Data.hMainWindow = (zLONG) g_hWndMainFrame;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _g_hWndMainFrame
	mov	DWORD PTR [edx+1503], eax

; 2380 :    lpTask            = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$[ebp], eax

; 2381 :    g_vSystemTaskView = zGETPTR( lpTask->hFirstView );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _g_vSystemTaskView, eax

; 2382 : 
; 2383 :    TraceLineS( "----Zeidon configuration file: ", szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	OFFSET $SG96640
	call	_TraceLineS@8

; 2384 :    SysReadZeidonIni( -1, szlWorkstation, "LocalDir", szTempName );

	lea	eax, DWORD PTR _szTempName$[ebp]
	push	eax
	push	OFFSET $SG96641
	push	OFFSET _szlWorkstation
	push	-1
	call	_SysReadZeidonIni@16

; 2385 :    SysConvertEnvironmentString( szFileName, szTempName );

	lea	ecx, DWORD PTR _szTempName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysConvertEnvironmentString@8

; 2386 :    if ( szFileName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szFileName$[ebp+ecx]
	test	edx, edx
	je	$LN21@InitInstan

; 2387 :    {
; 2388 :       SysAppendcDirSep( szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2389 :       zstrcat( szFileName, "ZeidonRT.ini" );

	push	OFFSET $SG96644
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2390 :       TraceLineS( "--LocalDir configuration file: ", szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	OFFSET $SG96645
	call	_TraceLineS@8

; 2391 :       GetPrivateProfileString( "ObjectEngine", "LineLimit", "",

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96646
	push	OFFSET $SG96647
	push	OFFSET $SG96648
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2392 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2393 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN23@InitInstan

; 2394 :       {
; 2395 :          g_uTraceLineLimit = atoi( szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _g_uTraceLineLimit, eax

; 2396 :          if ( g_uTraceLineLimit == 0 )

	cmp	DWORD PTR _g_uTraceLineLimit, 0
	jne	SHORT $LN23@InitInstan

; 2397 :          {
; 2398 :             AnchorBlock->bTraceCnt = FALSE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2399 :             SendMessage( g_hWndLB, LB_RESETCONTENT, 0, 0L );

	push	0
	push	0
	push	388					; 00000184H
	mov	eax, DWORD PTR _g_hWndLB
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN23@InitInstan:

; 2400 :          }
; 2401 :       }
; 2402 : 
; 2403 :       GetPrivateProfileString( "ObjectEngine", "FindString", "",

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96651
	push	OFFSET $SG96652
	push	OFFSET $SG96653
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2404 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2405 :       zstrcpy( g_szFindString, szBuffer );

	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET _g_szFindString
	call	_strcpy
	add	esp, 8

; 2406 :       GetPrivateProfileString( "ObjectEngine", "ScrollTrace", "",

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96654
	push	OFFSET $SG96655
	push	OFFSET $SG96656
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2407 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2408 :       if ( szBuffer[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN25@InitInstan

; 2409 :          g_chScrollTrace = szBuffer[ 0 ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _szBuffer$[ebp+ecx]
	mov	BYTE PTR _g_chScrollTrace, dl
$LN25@InitInstan:

; 2410 : 
; 2411 :       GetPrivateProfileString( "ObjectEngine", "PrintPreview", "",

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96658
	push	OFFSET $SG96659
	push	OFFSET $SG96660
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2412 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2413 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN26@InitInstan

; 2414 :       {
; 2415 :          g_chPrintPreview = szBuffer[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szBuffer$[ebp+eax]
	mov	BYTE PTR _g_chPrintPreview, cl

; 2416 :          if ( g_chPrintPreview == 'Y' )

	movsx	edx, BYTE PTR _g_chPrintPreview
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN26@InitInstan

; 2417 :             g_chPrintPreview = '0';

	mov	BYTE PTR _g_chPrintPreview, 48		; 00000030H
$LN26@InitInstan:

; 2418 :       }
; 2419 : 
; 2420 :       GetPrivateProfileString( "ObjectEngine", "PrintDialog", "",

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96663
	push	OFFSET $SG96664
	push	OFFSET $SG96665
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2421 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2422 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN28@InitInstan

; 2423 :          g_chPrintDialog = szBuffer[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szBuffer$[ebp+eax]
	mov	BYTE PTR _g_chPrintDialog, cl
$LN28@InitInstan:

; 2424 : 
; 2425 :       GetPrivateProfileString( "ObjectEngine", "TraceOE_Warning", "",

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	256					; 00000100H
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96667
	push	OFFSET $SG96668
	push	OFFSET $SG96669
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2426 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2427 :       if ( szBuffer[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szBuffer$[ebp+edx]
	test	eax, eax
	je	SHORT $LN29@InitInstan

; 2428 :          g_chTraceOE_Warning = szBuffer[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _szBuffer$[ebp+edx]
	mov	BYTE PTR _g_chTraceOE_Warning, al
$LN29@InitInstan:

; 2429 : 
; 2430 :       GetPrivateProfileString( "ObjectEngine", "TraceAction", "",

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96671
	push	OFFSET $SG96672
	push	OFFSET $SG96673
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2431 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2432 :       if ( szBuffer[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN30@InitInstan

; 2433 :          g_chTraceZDrActions = szBuffer[ 0 ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _szBuffer$[ebp+ecx]
	mov	BYTE PTR _g_chTraceZDrActions, dl
$LN30@InitInstan:

; 2434 : 
; 2435 :       GetPrivateProfileString( "ObjectEngine", "TraceWeb", "",

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	256					; 00000100H
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96675
	push	OFFSET $SG96676
	push	OFFSET $SG96677
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2436 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2437 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN31@InitInstan

; 2438 :          g_chTraceWebActions = szBuffer[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szBuffer$[ebp+eax]
	mov	BYTE PTR _g_chTraceWebActions, cl
$LN31@InitInstan:

; 2439 : 
; 2440 :       GetPrivateProfileString( "ObjectEngine", "ShowTaskID", "",

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	256					; 00000100H
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96679
	push	OFFSET $SG96680
	push	OFFSET $SG96681
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2441 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2442 :       if ( szBuffer[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szBuffer$[ebp+edx]
	test	eax, eax
	je	SHORT $LN32@InitInstan

; 2443 :          AnchorBlock->bShowTaskID = 1;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1495]
	or	edx, 1
	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+1495], edx
$LN32@InitInstan:

; 2444 : 
; 2445 :       lpTraceFlags = GetTracingFlags( );

	call	_GetTracingFlags@0
	mov	DWORD PTR _lpTraceFlags$[ebp], eax

; 2446 : 
; 2447 :       GetPrivateProfileString( "ObjectEngine", "ShowOpenFile", "",

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96683
	push	OFFSET $SG96684
	push	OFFSET $SG96685
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2448 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2449 :       lpTraceFlags->bOpenFile = (toupper( szBuffer[ 0 ] ) == 'Y') ? TRUE : FALSE;

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	push	edx
	call	_toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN66@InitInstan
	mov	DWORD PTR tv466[ebp], 1
	jmp	SHORT $LN67@InitInstan
$LN66@InitInstan:
	mov	DWORD PTR tv466[ebp], 0
$LN67@InitInstan:
	mov	eax, DWORD PTR tv466[ebp]
	and	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _lpTraceFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -5					; fffffffbH
	or	edx, eax
	mov	eax, DWORD PTR _lpTraceFlags$[ebp]
	mov	DWORD PTR [eax], edx

; 2450 : 
; 2451 :       GetPrivateProfileString( "ObjectEngine", "ShowOI_Times", "",

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96686
	push	OFFSET $SG96687
	push	OFFSET $SG96688
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2452 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2453 :       lpTraceFlags->bOI_Times = (toupper( szBuffer[ 0 ] ) == 'Y') ? TRUE : FALSE;

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	push	edx
	call	_toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN68@InitInstan
	mov	DWORD PTR tv485[ebp], 1
	jmp	SHORT $LN69@InitInstan
$LN68@InitInstan:
	mov	DWORD PTR tv485[ebp], 0
$LN69@InitInstan:
	mov	eax, DWORD PTR tv485[ebp]
	and	eax, 1
	mov	ecx, DWORD PTR _lpTraceFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -2					; fffffffeH
	or	edx, eax
	mov	eax, DWORD PTR _lpTraceFlags$[ebp]
	mov	DWORD PTR [eax], edx

; 2454 : 
; 2455 :       GetPrivateProfileString( "ObjectEngine", "ShowTaskMsgs", "",

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	256					; 00000100H
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96689
	push	OFFSET $SG96690
	push	OFFSET $SG96691
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 2456 :                                szBuffer, sizeof( szBuffer ), szFileName );
; 2457 :       lpTraceFlags->bTaskMsgs = (toupper( szBuffer[ 0 ] ) == 'Y') ? TRUE : FALSE;

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	push	edx
	call	_toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN70@InitInstan
	mov	DWORD PTR tv503[ebp], 1
	jmp	SHORT $LN71@InitInstan
$LN70@InitInstan:
	mov	DWORD PTR tv503[ebp], 0
$LN71@InitInstan:
	mov	eax, DWORD PTR tv503[ebp]
	and	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _lpTraceFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -3					; fffffffdH
	or	edx, eax
	mov	eax, DWORD PTR _lpTraceFlags$[ebp]
	mov	DWORD PTR [eax], edx

; 2458 :    }

	jmp	$LN22@InitInstan
$LN21@InitInstan:

; 2459 :    else
; 2460 :    {
; 2461 :       SysReadZeidonIni( -1, "[ObjectEngine]", "LineLimit", szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96692
	push	OFFSET $SG96693
	push	-1
	call	_SysReadZeidonIni@16

; 2462 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN33@InitInstan

; 2463 :       {
; 2464 :          g_uTraceLineLimit = atoi( szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_atoi
	add	esp, 4
	mov	DWORD PTR _g_uTraceLineLimit, eax

; 2465 :          if ( g_uTraceLineLimit == 0 )

	cmp	DWORD PTR _g_uTraceLineLimit, 0
	jne	SHORT $LN33@InitInstan

; 2466 :          {
; 2467 :             AnchorBlock->bTraceCnt = FALSE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2468 :             SendMessage( g_hWndLB, LB_RESETCONTENT, 0, 0L );

	push	0
	push	0
	push	388					; 00000184H
	mov	eax, DWORD PTR _g_hWndLB
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN33@InitInstan:

; 2469 :          }
; 2470 :       }
; 2471 : 
; 2472 :       SysReadZeidonIni( -1, "[ObjectEngine]", "FindString", szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96696
	push	OFFSET $SG96697
	push	-1
	call	_SysReadZeidonIni@16

; 2473 :       zstrcpy( g_szFindString, szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET _g_szFindString
	call	_strcpy
	add	esp, 8

; 2474 :       SysReadZeidonIni( -1, "[ObjectEngine]", "ScrollTrace", szBuffer );

	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96698
	push	OFFSET $SG96699
	push	-1
	call	_SysReadZeidonIni@16

; 2475 :       if ( szBuffer[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szBuffer$[ebp+edx]
	test	eax, eax
	je	SHORT $LN35@InitInstan

; 2476 :          g_chScrollTrace = szBuffer[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _szBuffer$[ebp+edx]
	mov	BYTE PTR _g_chScrollTrace, al
$LN35@InitInstan:

; 2477 : 
; 2478 :       SysReadZeidonIni( -1, "[ObjectEngine]", "PrintPreview", szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96701
	push	OFFSET $SG96702
	push	-1
	call	_SysReadZeidonIni@16

; 2479 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN36@InitInstan

; 2480 :       {
; 2481 :          g_chPrintPreview = szBuffer[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szBuffer$[ebp+eax]
	mov	BYTE PTR _g_chPrintPreview, cl

; 2482 :          if ( g_chPrintPreview == 'Y' )

	movsx	edx, BYTE PTR _g_chPrintPreview
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN36@InitInstan

; 2483 :             g_chPrintPreview = '0';

	mov	BYTE PTR _g_chPrintPreview, 48		; 00000030H
$LN36@InitInstan:

; 2484 :       }
; 2485 : 
; 2486 :       SysReadZeidonIni( -1, "[ObjectEngine]", "PrintDialog", szBuffer );

	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96705
	push	OFFSET $SG96706
	push	-1
	call	_SysReadZeidonIni@16

; 2487 :       if ( szBuffer[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szBuffer$[ebp+edx]
	test	eax, eax
	je	SHORT $LN38@InitInstan

; 2488 :          g_chPrintDialog = szBuffer[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _szBuffer$[ebp+edx]
	mov	BYTE PTR _g_chPrintDialog, al
$LN38@InitInstan:

; 2489 : 
; 2490 :       SysReadZeidonIni( -1, "[ObjectEngine]", "TraceOE_Warning", szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96708
	push	OFFSET $SG96709
	push	-1
	call	_SysReadZeidonIni@16

; 2491 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN39@InitInstan

; 2492 :          g_chTraceOE_Warning = szBuffer[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _szBuffer$[ebp+eax]
	mov	BYTE PTR _g_chTraceOE_Warning, cl
$LN39@InitInstan:

; 2493 : 
; 2494 :       SysReadZeidonIni( -1, "[ObjectEngine]", "TraceAction", szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96711
	push	OFFSET $SG96712
	push	-1
	call	_SysReadZeidonIni@16

; 2495 :       if ( szBuffer[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN40@InitInstan

; 2496 :          g_chTraceZDrActions = szBuffer[ 0 ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _szBuffer$[ebp+ecx]
	mov	BYTE PTR _g_chTraceZDrActions, dl
$LN40@InitInstan:

; 2497 : 
; 2498 :       SysReadZeidonIni( -1, "[ObjectEngine]", "TraceWeb", szBuffer );

	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96714
	push	OFFSET $SG96715
	push	-1
	call	_SysReadZeidonIni@16

; 2499 :       if ( szBuffer[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szBuffer$[ebp+edx]
	test	eax, eax
	je	SHORT $LN41@InitInstan

; 2500 :          g_chTraceWebActions = szBuffer[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _szBuffer$[ebp+edx]
	mov	BYTE PTR _g_chTraceWebActions, al
$LN41@InitInstan:

; 2501 : 
; 2502 :       SysReadZeidonIni( -1, "[ObjectEngine]", "ShowTaskID", szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96717
	push	OFFSET $SG96718
	push	-1
	call	_SysReadZeidonIni@16

; 2503 :       if ( szBuffer[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN42@InitInstan

; 2504 :          AnchorBlock->bShowTaskID = 1;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	or	eax, 1
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1495], eax
$LN42@InitInstan:

; 2505 : 
; 2506 :       lpTraceFlags = GetTracingFlags( );

	call	_GetTracingFlags@0
	mov	DWORD PTR _lpTraceFlags$[ebp], eax

; 2507 : 
; 2508 :       SysReadZeidonIni( -1, "[ObjectEngine]", "ShowOpenFile", szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96720
	push	OFFSET $SG96721
	push	-1
	call	_SysReadZeidonIni@16

; 2509 :       lpTraceFlags->bOpenFile = (toupper( szBuffer[ 0 ] ) == 'Y') ? TRUE : FALSE;

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	push	edx
	call	_toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN72@InitInstan
	mov	DWORD PTR tv650[ebp], 1
	jmp	SHORT $LN73@InitInstan
$LN72@InitInstan:
	mov	DWORD PTR tv650[ebp], 0
$LN73@InitInstan:
	mov	eax, DWORD PTR tv650[ebp]
	and	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _lpTraceFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, -5					; fffffffbH
	or	edx, eax
	mov	eax, DWORD PTR _lpTraceFlags$[ebp]
	mov	DWORD PTR [eax], edx

; 2510 : 
; 2511 :       SysReadZeidonIni( -1, "[ObjectEngine]", "ShowOI_Times", szBuffer );

	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	OFFSET $SG96722
	push	OFFSET $SG96723
	push	-1
	call	_SysReadZeidonIni@16

; 2512 :       lpTraceFlags->bOI_Times = (toupper( szBuffer[ 0 ] ) == 'Y') ? TRUE : FALSE;

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szBuffer$[ebp+eax]
	push	ecx
	call	_toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN74@InitInstan
	mov	DWORD PTR tv667[ebp], 1
	jmp	SHORT $LN75@InitInstan
$LN74@InitInstan:
	mov	DWORD PTR tv667[ebp], 0
$LN75@InitInstan:
	mov	edx, DWORD PTR tv667[ebp]
	and	edx, 1
	mov	eax, DWORD PTR _lpTraceFlags$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -2					; fffffffeH
	or	ecx, edx
	mov	edx, DWORD PTR _lpTraceFlags$[ebp]
	mov	DWORD PTR [edx], ecx

; 2513 : 
; 2514 :       SysReadZeidonIni( -1, "[ObjectEngine]", "ShowTaskMsgs", szBuffer );

	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96724
	push	OFFSET $SG96725
	push	-1
	call	_SysReadZeidonIni@16

; 2515 :       lpTraceFlags->bTaskMsgs = (toupper( szBuffer[ 0 ] ) == 'Y') ? TRUE : FALSE;

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szBuffer$[ebp+edx]
	push	eax
	call	_toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN76@InitInstan
	mov	DWORD PTR tv683[ebp], 1
	jmp	SHORT $LN77@InitInstan
$LN76@InitInstan:
	mov	DWORD PTR tv683[ebp], 0
$LN77@InitInstan:
	mov	ecx, DWORD PTR tv683[ebp]
	and	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _lpTraceFlags$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, -3					; fffffffdH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpTraceFlags$[ebp]
	mov	DWORD PTR [ecx], eax
$LN22@InitInstan:

; 2516 :    }
; 2517 : 
; 2518 :    // Retrieve WindowStartup parameter and show window in hidden,
; 2519 :    // systray or normal mode.
; 2520 :    SysReadZeidonIni( -1, "[ObjectEngine]", "WindowStartup", szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96726
	push	OFFSET $SG96727
	push	-1
	call	_SysReadZeidonIni@16

; 2521 :    if ( zstricmp( szBuffer, "Hidden" ) == 0 )

	push	OFFSET $SG96730
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN43@InitInstan

; 2522 :    {
; 2523 :       ShowWindow( g_hWndMainFrame, SW_HIDE );

	push	0
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 2524 :    }

	jmp	$LN44@InitInstan
$LN43@InitInstan:

; 2525 :    else
; 2526 :    if ( zstricmp( szBuffer, "SysTray" ) == 0 )

	push	OFFSET $SG96733
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN45@InitInstan

; 2527 :    {
; 2528 :       if ( ReadWindowPlacement( lpTask, &wp ) && CheckWindowPos( &wp ) )

	lea	eax, DWORD PTR _wp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_ReadWindowPlacement
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN47@InitInstan
	lea	eax, DWORD PTR _wp$[ebp]
	push	eax
	call	_CheckWindowPos
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN47@InitInstan

; 2529 :          SetWindowPlacement( g_hWndMainFrame, &wp );

	lea	edx, DWORD PTR _wp$[ebp]
	push	edx
	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	call	DWORD PTR __imp__SetWindowPlacement@8
$LN47@InitInstan:

; 2530 : 
; 2531 :       ShowWindow( g_hWndMainFrame, SW_HIDE );

	push	0
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 2532 :       SetupSysTray( hInstance );

	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	_SetupSysTray
	add	esp, 4

; 2533 :       hMenu = GetMenu( g_hWndMainFrame );

	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _hMenu$[ebp], eax

; 2534 :       if ( hMenu )

	cmp	DWORD PTR _hMenu$[ebp], 0
	je	SHORT $LN48@InitInstan

; 2535 :          DestroyMenu( hMenu );

	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__DestroyMenu@4
$LN48@InitInstan:

; 2536 : 
; 2537 :       // Load Systray specific menu.
; 2538 :       hMenu = LoadMenu( hInst, MAKEINTRESOURCE( ID_KZOENGWA_MNU ));

	push	322					; 00000142H
	mov	edx, DWORD PTR _hInst
	push	edx
	call	DWORD PTR __imp__LoadMenuA@8
	mov	DWORD PTR _hMenu$[ebp], eax

; 2539 :       // Delete the unused menu items.
; 2540 :       for ( i = g_nTraceWindowCnt; i < MAX_TRACE_WINDOWS; i++ )

	mov	eax, DWORD PTR _g_nTraceWindowCnt
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN12@InitInstan
$LN10@InitInstan:
	mov	ecx, DWORD PTR _i$[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN12@InitInstan:
	cmp	DWORD PTR _i$[ebp], 20			; 00000014H
	jae	SHORT $LN11@InitInstan

; 2541 :          DeleteMenu( hMenu, IDM_TRACEWINDOW01 + i, MF_BYCOMMAND );

	push	0
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 300				; 0000012cH
	push	edx
	mov	eax, DWORD PTR _hMenu$[ebp]
	push	eax
	call	DWORD PTR __imp__DeleteMenu@12
	jmp	SHORT $LN10@InitInstan
$LN11@InitInstan:

; 2542 : 
; 2543 :       SetMenu( g_hWndMainFrame, hMenu );

	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	call	DWORD PTR __imp__SetMenu@8

; 2544 :    }

	jmp	SHORT $LN44@InitInstan
$LN45@InitInstan:

; 2545 :    else
; 2546 :    if ( ReadWindowPlacement( lpTask, &wp ) && CheckWindowPos( &wp ) )

	lea	eax, DWORD PTR _wp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_ReadWindowPlacement
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN49@InitInstan
	lea	eax, DWORD PTR _wp$[ebp]
	push	eax
	call	_CheckWindowPos
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN49@InitInstan

; 2547 :       SetWindowPlacement( g_hWndMainFrame, &wp );

	lea	edx, DWORD PTR _wp$[ebp]
	push	edx
	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	call	DWORD PTR __imp__SetWindowPlacement@8
	jmp	SHORT $LN44@InitInstan
$LN49@InitInstan:

; 2548 :    else
; 2549 :       ShowWindow( g_hWndMainFrame, SW_SHOW );  // Show the window

	push	5
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8
$LN44@InitInstan:

; 2550 : 
; 2551 :    SysReadZeidonIni( -1, "ObjectEngine", "DropEngineIfNoTasks", szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96738
	push	OFFSET $SG96739
	push	-1
	call	_SysReadZeidonIni@16

; 2552 :    if ( ztoupper( *szBuffer ) == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	push	edx
	call	_toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN51@InitInstan

; 2553 :       AnchorBlock->bDropEngineIfNoTasks = TRUE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	or	ecx, 4
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx
$LN51@InitInstan:

; 2554 : 
; 2555 :    CheckMenuItem( hMenu, IDM_SCROLLTRACE,

	movsx	eax, BYTE PTR _g_chScrollTrace
	test	eax, eax
	je	SHORT $LN78@InitInstan
	mov	DWORD PTR tv761[ebp], 8
	jmp	SHORT $LN79@InitInstan
$LN78@InitInstan:
	mov	DWORD PTR tv761[ebp], 0
$LN79@InitInstan:
	mov	ecx, DWORD PTR tv761[ebp]
	push	ecx
	push	136					; 00000088H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2556 :                   MF_BYCOMMAND |
; 2557 :                      (g_chScrollTrace ? MF_CHECKED : MF_UNCHECKED) );
; 2558 :    CheckMenuItem( hMenu, IDM_PRINTPREVIEW,

	movsx	eax, BYTE PTR _g_chPrintPreview
	test	eax, eax
	je	SHORT $LN80@InitInstan
	mov	DWORD PTR tv767[ebp], 0
	jmp	SHORT $LN81@InitInstan
$LN80@InitInstan:
	mov	DWORD PTR tv767[ebp], 8
$LN81@InitInstan:
	mov	ecx, DWORD PTR tv767[ebp]
	push	ecx
	push	160					; 000000a0H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2559 :                   MF_BYCOMMAND |
; 2560 :                      (g_chPrintPreview ? MF_UNCHECKED : MF_CHECKED) );
; 2561 :    CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMOUT,

	movsx	eax, BYTE PTR _g_chPrintPreview
	cmp	eax, 48					; 00000030H
	jne	SHORT $LN82@InitInstan
	mov	DWORD PTR tv773[ebp], 8
	jmp	SHORT $LN83@InitInstan
$LN82@InitInstan:
	mov	DWORD PTR tv773[ebp], 0
$LN83@InitInstan:
	mov	ecx, DWORD PTR tv773[ebp]
	push	ecx
	push	161					; 000000a1H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2562 :                   MF_BYCOMMAND |
; 2563 :                      (g_chPrintPreview == '0' ? MF_CHECKED : MF_UNCHECKED) );
; 2564 :    CheckMenuItem( hMenu, IDM_PREVIEW_ZOOM,

	movsx	eax, BYTE PTR _g_chPrintPreview
	cmp	eax, 49					; 00000031H
	jne	SHORT $LN84@InitInstan
	mov	DWORD PTR tv779[ebp], 8
	jmp	SHORT $LN85@InitInstan
$LN84@InitInstan:
	mov	DWORD PTR tv779[ebp], 0
$LN85@InitInstan:
	mov	ecx, DWORD PTR tv779[ebp]
	push	ecx
	push	162					; 000000a2H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2565 :                   MF_BYCOMMAND |
; 2566 :                      (g_chPrintPreview == '1' ? MF_CHECKED : MF_UNCHECKED) );
; 2567 :    CheckMenuItem( hMenu, IDM_PREVIEW_ZOOMIN,

	movsx	eax, BYTE PTR _g_chPrintPreview
	cmp	eax, 50					; 00000032H
	jne	SHORT $LN86@InitInstan
	mov	DWORD PTR tv785[ebp], 8
	jmp	SHORT $LN87@InitInstan
$LN86@InitInstan:
	mov	DWORD PTR tv785[ebp], 0
$LN87@InitInstan:
	mov	ecx, DWORD PTR tv785[ebp]
	push	ecx
	push	163					; 000000a3H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2568 :                   MF_BYCOMMAND |
; 2569 :                      (g_chPrintPreview == '2' ? MF_CHECKED : MF_UNCHECKED) );
; 2570 :    CheckMenuItem( hMenu, IDM_PRINTDIALOG,

	movsx	eax, BYTE PTR _g_chPrintDialog
	test	eax, eax
	je	SHORT $LN88@InitInstan
	mov	DWORD PTR tv791[ebp], 8
	jmp	SHORT $LN89@InitInstan
$LN88@InitInstan:
	mov	DWORD PTR tv791[ebp], 0
$LN89@InitInstan:
	mov	ecx, DWORD PTR tv791[ebp]
	push	ecx
	push	164					; 000000a4H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2571 :                   MF_BYCOMMAND |
; 2572 :                      (g_chPrintDialog ? MF_CHECKED : MF_UNCHECKED) );
; 2573 :    CheckMenuItem( hMenu, IDM_SHOWTASKID,

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, 1
	je	SHORT $LN90@InitInstan
	mov	DWORD PTR tv798[ebp], 8
	jmp	SHORT $LN91@InitInstan
$LN90@InitInstan:
	mov	DWORD PTR tv798[ebp], 0
$LN91@InitInstan:
	mov	edx, DWORD PTR tv798[ebp]
	push	edx
	push	124					; 0000007cH
	mov	eax, DWORD PTR _hMenu$[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 2574 :                   MF_BYCOMMAND |
; 2575 :                     (AnchorBlock->bShowTaskID ? MF_CHECKED : MF_UNCHECKED) );
; 2576 :    CheckMenuItem( hMenu, IDM_SETOETRACE,

	movsx	ecx, BYTE PTR _g_chTraceOE_Warning
	test	ecx, ecx
	je	SHORT $LN92@InitInstan
	movsx	edx, BYTE PTR _g_chTraceOE_Warning
	cmp	edx, 110				; 0000006eH
	je	SHORT $LN92@InitInstan
	movsx	eax, BYTE PTR _g_chTraceOE_Warning
	cmp	eax, 78					; 0000004eH
	je	SHORT $LN92@InitInstan
	mov	DWORD PTR tv808[ebp], 8
	jmp	SHORT $LN93@InitInstan
$LN92@InitInstan:
	mov	DWORD PTR tv808[ebp], 0
$LN93@InitInstan:
	mov	ecx, DWORD PTR tv808[ebp]
	push	ecx
	push	133					; 00000085H
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2577 :                   MF_BYCOMMAND |
; 2578 :                      (g_chTraceOE_Warning == 0 ||
; 2579 :                         g_chTraceOE_Warning == 'n' ||
; 2580 :                         g_chTraceOE_Warning == 'N' ? MF_UNCHECKED :
; 2581 :                                                      MF_CHECKED) );
; 2582 :    CheckMenuItem( hMenu, IDM_SETZDRTRACE,

	movsx	eax, BYTE PTR _g_chTraceZDrActions
	test	eax, eax
	je	SHORT $LN94@InitInstan
	movsx	ecx, BYTE PTR _g_chTraceZDrActions
	cmp	ecx, 110				; 0000006eH
	je	SHORT $LN94@InitInstan
	movsx	edx, BYTE PTR _g_chTraceZDrActions
	cmp	edx, 78					; 0000004eH
	je	SHORT $LN94@InitInstan
	mov	DWORD PTR tv818[ebp], 8
	jmp	SHORT $LN95@InitInstan
$LN94@InitInstan:
	mov	DWORD PTR tv818[ebp], 0
$LN95@InitInstan:
	mov	eax, DWORD PTR tv818[ebp]
	push	eax
	push	134					; 00000086H
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__CheckMenuItem@12

; 2583 :                   MF_BYCOMMAND |
; 2584 :                      (g_chTraceZDrActions == 0 ||
; 2585 :                         g_chTraceZDrActions == 'n' ||
; 2586 :                         g_chTraceZDrActions == 'N' ? MF_UNCHECKED :
; 2587 :                                                      MF_CHECKED) );
; 2588 :    CheckMenuItem( hMenu, IDM_SETWEBTRACE,

	movsx	edx, BYTE PTR _g_chTraceWebActions
	test	edx, edx
	je	SHORT $LN96@InitInstan
	movsx	eax, BYTE PTR _g_chTraceWebActions
	cmp	eax, 110				; 0000006eH
	je	SHORT $LN96@InitInstan
	movsx	ecx, BYTE PTR _g_chTraceWebActions
	cmp	ecx, 78					; 0000004eH
	je	SHORT $LN96@InitInstan
	mov	DWORD PTR tv828[ebp], 8
	jmp	SHORT $LN97@InitInstan
$LN96@InitInstan:
	mov	DWORD PTR tv828[ebp], 0
$LN97@InitInstan:
	mov	edx, DWORD PTR tv828[ebp]
	push	edx
	push	135					; 00000087H
	mov	eax, DWORD PTR _hMenu$[ebp]
	push	eax
	call	DWORD PTR __imp__CheckMenuItem@12

; 2589 :                   MF_BYCOMMAND |
; 2590 :                      (g_chTraceWebActions == 0 ||
; 2591 :                         g_chTraceWebActions == 'n' ||
; 2592 :                         g_chTraceWebActions == 'N' ? MF_UNCHECKED :
; 2593 :                                                      MF_CHECKED) );
; 2594 : 
; 2595 : #if ( 1 )
; 2596 :    // Try and retrieve the workstation userid;
; 2597 :    {
; 2598 :       HANDLE hNetApi;
; 2599 :       FARPROC lpfnNetWkstaGetInfo;
; 2600 :       char far * Buffer[ 20 ];
; 2601 :       char    szLanUser[ 32 ];
; 2602 :       char    szIniUser[ 32 ];
; 2603 :       char    szIniPassword[ 32 ];
; 2604 :       char    szPassword[ 32 ];
; 2605 :       char    szUser[ 32 ];
; 2606 :       char    szEncrypted[ 1 ];
; 2607 :       USHORT  uReturnLth;
; 2608 :       USHORT  uLth;
; 2609 :       USHORT  uRC;
; 2610 : 
; 2611 :       SysReadZeidonIni( -1, szlWorkstation, szlUserID, szIniUser );

	lea	ecx, DWORD PTR _szIniUser$13[ebp]
	push	ecx
	push	OFFSET _szlUserID
	push	OFFSET _szlWorkstation
	push	-1
	call	_SysReadZeidonIni@16

; 2612 :       SysReadZeidonIni( -1, szlWorkstation, szlPassword, szIniPassword );

	lea	edx, DWORD PTR _szIniPassword$12[ebp]
	push	edx
	push	OFFSET _szlPassword
	push	OFFSET _szlWorkstation
	push	-1
	call	_SysReadZeidonIni@16

; 2613 :       szLanUser[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T4[ebp], ecx
	cmp	DWORD PTR $T4[ebp], 32			; 00000020H
	jae	SHORT $LN98@InitInstan
	jmp	SHORT $LN99@InitInstan
$LN98@InitInstan:
	call	___report_rangecheckfailure
$LN99@InitInstan:
	mov	edx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szLanUser$11[ebp+edx], 0

; 2614 :       if ( (hNetApi = GetModuleHandle( "NETAPI" )) != 0 )

	push	OFFSET $SG96742
	call	DWORD PTR __imp__GetModuleHandleA@4
	mov	DWORD PTR _hNetApi$3[ebp], eax
	cmp	DWORD PTR _hNetApi$3[ebp], 0
	je	SHORT $LN52@InitInstan

; 2615 :       {
; 2616 :          if ( (lpfnNetWkstaGetInfo =
; 2617 :                       GetProcAddress( hNetApi, "NetWkstaGetInfo" )) != 0 )

	push	OFFSET $SG96744
	mov	eax, DWORD PTR _hNetApi$3[ebp]
	push	eax
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _lpfnNetWkstaGetInfo$2[ebp], eax
	cmp	DWORD PTR _lpfnNetWkstaGetInfo$2[ebp], 0
	je	SHORT $LN52@InitInstan

; 2618 :          {
; 2619 :             uRC = (*lpfnNetWkstaGetInfo)( (zPCHAR) NULL, (zUSHORT) 10,

	lea	ecx, DWORD PTR _uReturnLth$1[ebp]
	push	ecx
	push	80					; 00000050H
	mov	edx, 4
	imul	eax, edx, 0
	lea	ecx, DWORD PTR _Buffer$8[ebp+eax]
	push	ecx
	push	10					; 0000000aH
	push	0
	call	DWORD PTR _lpfnNetWkstaGetInfo$2[ebp]
	mov	WORD PTR _uRC$5[ebp], ax

; 2620 :                                           (zPCHAR) &Buffer[ 0 ],
; 2621 :                                           (zUSHORT) 80,
; 2622 :                                           (zPUSHORT) &uReturnLth );
; 2623 :             if ( uRC == 0 )

	movzx	edx, WORD PTR _uRC$5[ebp]
	test	edx, edx
	jne	SHORT $LN52@InitInstan

; 2624 :                zstrcpy( szLanUser, Buffer[ 1 ] );

	mov	eax, 4
	shl	eax, 0
	mov	ecx, DWORD PTR _Buffer$8[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _szLanUser$11[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN52@InitInstan:

; 2625 :          }
; 2626 :       }
; 2627 : 
; 2628 :       if ( szLanUser[ 0 ] || szIniUser[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szLanUser$11[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN57@InitInstan
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szIniUser$13[ebp+ecx]
	test	edx, edx
	je	$LN55@InitInstan
$LN57@InitInstan:

; 2629 :       {
; 2630 :          SysReadZeidonIni( -1, szlWorkstation, "Encrypted", szEncrypted );

	lea	eax, DWORD PTR _szEncrypted$7[ebp]
	push	eax
	push	OFFSET $SG96749
	push	OFFSET _szlWorkstation
	push	-1
	call	_SysReadZeidonIni@16

; 2631 : 
; 2632 :          if ( szIniUser[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szIniUser$13[ebp+edx]
	test	eax, eax
	jne	SHORT $LN58@InitInstan

; 2633 :             zstrcpy( szIniUser, szLanUser );

	lea	ecx, DWORD PTR _szLanUser$11[ebp]
	push	ecx
	lea	edx, DWORD PTR _szIniUser$13[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN58@InitInstan:

; 2634 : 
; 2635 :          if ( szEncrypted[ 0 ] == 'E' || szEncrypted[ 0 ] == 'e' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szEncrypted$7[ebp+ecx]
	cmp	edx, 69					; 00000045H
	je	SHORT $LN61@InitInstan
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szEncrypted$7[ebp+ecx]
	cmp	edx, 101				; 00000065H
	jne	SHORT $LN59@InitInstan
$LN61@InitInstan:

; 2636 :          {
; 2637 :          /*
; 2638 :             UfEncryptString( szUser, "sa", 26 );
; 2639 :                              TraceLineS( "----Encrypted Username: ", szUser );
; 2640 :             UfEncryptString( szPassword, "sql!4ever&ever", 26 );
; 2641 :                              TraceLineS( "----Encrypted Password: ", szPassword );
; 2642 : 
; 2643 :                              UfDecryptString( szIniUser, szUser,  26 );
; 2644 :                              TraceLineS( "----Decrypted Username: ", szIniUser );
; 2645 :                              UfDecryptString( szIniPassword, szPassword, 26 );
; 2646 :                              TraceLineS( "----Decrypted Password: ", szIniPassword );
; 2647 :          */
; 2648 : 
; 2649 :             uLth = zstrlen( szIniUser );

	lea	eax, DWORD PTR _szIniUser$13[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _uLth$6[ebp], ax

; 2650 :             UfDecryptString( szUser, szIniUser, uLth );

	movzx	ecx, WORD PTR _uLth$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _szIniUser$13[ebp]
	push	edx
	lea	eax, DWORD PTR _szUser$10[ebp]
	push	eax
	call	_UfDecryptString@12

; 2651 :          // TraceLineS( "----Decrypted Username2: ", szUser );
; 2652 :             uLth = zstrlen( szIniPassword );

	lea	ecx, DWORD PTR _szIniPassword$12[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _uLth$6[ebp], ax

; 2653 :             UfDecryptString( szPassword, szIniPassword, uLth );

	movzx	edx, WORD PTR _uLth$6[ebp]
	push	edx
	lea	eax, DWORD PTR _szIniPassword$12[ebp]
	push	eax
	lea	ecx, DWORD PTR _szPassword$9[ebp]
	push	ecx
	call	_UfDecryptString@12

; 2654 :          // TraceLineS( "----Decrypted Password2: ", szPassword );
; 2655 :          }

	jmp	SHORT $LN60@InitInstan
$LN59@InitInstan:

; 2656 :          else
; 2657 :          {
; 2658 :             zstrcpy( szUser, szIniUser );

	lea	edx, DWORD PTR _szIniUser$13[ebp]
	push	edx
	lea	eax, DWORD PTR _szUser$10[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2659 :             zstrcpy( szPassword, szIniPassword );

	lea	ecx, DWORD PTR _szIniPassword$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _szPassword$9[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN60@InitInstan:

; 2660 :          }
; 2661 : 
; 2662 :       // if ( zstrlen( szIniPassword ) == 26 )
; 2663 :       //    UfDecryptString( szPassword, szIniPassword, 26 );
; 2664 :       // else
; 2665 :       //    zstrcpy( szPassword, szIniPassword );
; 2666 : 
; 2667 :          SysSetUserID( lpTask, szUser, szPassword );

	lea	eax, DWORD PTR _szPassword$9[ebp]
	push	eax
	lea	ecx, DWORD PTR _szUser$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_SysSetUserID@12

; 2668 :       }

	jmp	SHORT $LN56@InitInstan
$LN55@InitInstan:

; 2669 :       else
; 2670 :       {
; 2671 :          // Throw up the Logon dialog box
; 2672 :          DialogBox( hInst, MAKEINTRESOURCE( IDD_LOGON ),

	push	0
	mov	eax, DWORD PTR _fpLogon
	push	eax
	mov	ecx, DWORD PTR _g_hWndMainFrame
	push	ecx
	push	104					; 00000068H
	mov	edx, DWORD PTR _hInst
	push	edx
	call	DWORD PTR __imp__DialogBoxParamA@20
$LN56@InitInstan:

; 2673 :                     g_hWndMainFrame, fpLogon );
; 2674 :       }
; 2675 :    }
; 2676 : #endif
; 2677 : 
; 2678 :    // Create the DBH work object and name the view for later use.
; 2679 :    GetViewByName( &vDbhWork, zDBHANDLER_WORK_VIEW_NAME,

	push	8
	mov	eax, DWORD PTR _g_vSystemTaskView
	push	eax
	push	OFFSET $SG96754
	lea	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_GetViewByName@16

; 2680 :                   g_vSystemTaskView, zLEVEL_SYSTEM );
; 2681 :    if ( vDbhWork == 0 )

	cmp	DWORD PTR _vDbhWork$[ebp], 0
	jne	SHORT $LN62@InitInstan

; 2682 :    {
; 2683 :       SfActivateSysEmptyOI( &vDbhWork, "KZDBHWOB",

	push	0
	mov	edx, DWORD PTR _g_vSystemTaskView
	push	edx
	push	OFFSET $SG96756
	lea	eax, DWORD PTR _vDbhWork$[ebp]
	push	eax
	call	_SfActivateSysEmptyOI@16

; 2684 :                             g_vSystemTaskView, zSINGLE );
; 2685 :       SfLockView( vDbhWork );

	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SfLockView@4

; 2686 :       CreateEntity( vDbhWork, "ROOT", zPOS_AFTER );

	push	3
	push	OFFSET $SG96757
	mov	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_CreateEntity@12

; 2687 :       SetNameForView( vDbhWork, zDBHANDLER_WORK_VIEW_NAME,

	push	8
	mov	eax, DWORD PTR _g_vSystemTaskView
	push	eax
	push	OFFSET $SG96758
	mov	ecx, DWORD PTR _vDbhWork$[ebp]
	push	ecx
	call	_SetNameForView@16
$LN62@InitInstan:

; 2688 :                       g_vSystemTaskView, zLEVEL_SYSTEM );
; 2689 :    }
; 2690 : 
; 2691 :    // Just a way to test if we are opening the right INI file.
; 2692 :    SysReadZeidonIni( -1, "[Debug]", "StartMessage", szBuffer );

	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	OFFSET $SG96759
	push	OFFSET $SG96760
	push	-1
	call	_SysReadZeidonIni@16

; 2693 :    if ( szBuffer[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szBuffer$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN63@InitInstan

; 2694 :       fnSysMessageBox( lpTask, "Object Engine Start Message", szBuffer, 0 );

	push	0
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	push	OFFSET $SG96762
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16
$LN63@InitInstan:

; 2695 : 
; 2696 :    // Now automatically start all networks.
; 2697 :    SfStartNetworks( g_vSystemTaskView, 0 );

	push	0
	mov	edx, DWORD PTR _g_vSystemTaskView
	push	edx
	call	_SfStartNetworks@8

; 2698 : 
; 2699 : #if 0 // moving to RegisterZeidon  2005.04.18  dks
; 2700 : 
; 2701 :    // Check to see if there is an application update function.
; 2702 :    SysReadZeidonIni( -1, "[Zeidon]", "ApplicationUpdate", szBuffer );
; 2703 :    if ( *szBuffer )
; 2704 :    {
; 2705 :       zSHORT (POPERATION pfn )( void );
; 2706 :       LPLIBRARY hLibrary = SysLoadLibrary( vDbhWork, szBuffer );
; 2707 : 
; 2708 :       if ( hLibrary )
; 2709 :       {
; 2710 :          pfn = SysGetProc( hLibrary, "PerformApplicationUpdate" );
; 2711 :          if ( pfn )
; 2712 :             (*pfn)( );
; 2713 : 
; 2714 :          fnSysFreeLibrary( lpTask, hLibrary, FALSE );
; 2715 :       }
; 2716 :    }
; 2717 : 
; 2718 : #endif
; 2719 : 
; 2720 :    // If we were activated by a RegisterZeidonApplication, then some other
; 2721 :    // window is probably active and wants focus. Check to see if another
; 2722 :    // task exists and set focus to it after the logon is complete.
; 2723 :    if ( lpTask && zGETHNDL( lpTask ) != AnchorBlock->hMainTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN64@InitInstan
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_SysGetHandleFromPointer@4
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [ecx+106]
	je	SHORT $LN64@InitInstan

; 2724 :    {
; 2725 :       SetActiveWindow( (HWND) lpTask->hMainWnd );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR __imp__SetActiveWindow@4
$LN64@InitInstan:

; 2726 :    }
; 2727 : 
; 2728 :    // Make the window visible; update its client area; and return "success"
; 2729 :    return( g_hWndMainFrame );         // Returns the value from PostQuitMessage

	mov	eax, DWORD PTR _g_hWndMainFrame
$LN65@InitInstan:

; 2730 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_InitInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	___stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoengwa.c
_TEXT	SEGMENT
_msg$ = -1108						; size = 28
_hAccel$ = -1080					; size = 4
_hServicesStarted$ = -1076				; size = 4
_pchSrc$ = -1072					; size = 4
_hMutex2$ = -1068					; size = 4
_hMutex1$ = -1064					; size = 4
_hMenu$ = -1060						; size = 4
_pchTgt$ = -1056					; size = 4
_pchZeidonDir$ = -1052					; size = 4
_szCmdLineBuffer$ = -1048				; size = 780
_szWork$ = -268						; size = 261
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC

; 402  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1108				; 00000454H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 403  :    MSG    msg;        // message
; 404  :    HACCEL hAccel;
; 405  :    HMENU  hMenu;
; 406  :    zCHAR  szWork[ MAX_PATH + 1 ];
; 407  : 
; 408  : #ifdef __WIN32__
; 409  :    char szCmdLineBuffer[ 3 * MAX_PATH ];
; 410  :    HANDLE hMutex1 = 0;

	mov	DWORD PTR _hMutex1$[ebp], 0

; 411  :    HANDLE hMutex2 = 0;

	mov	DWORD PTR _hMutex2$[ebp], 0

; 412  :    HANDLE hServicesStarted;
; 413  : 
; 414  :    LPSTR pchZeidonDir = NULL;

	mov	DWORD PTR _pchZeidonDir$[ebp], 0

; 415  :    LPSTR pchSrc = NULL;

	mov	DWORD PTR _pchSrc$[ebp], 0

; 416  :    LPSTR pchTgt = NULL;

	mov	DWORD PTR _pchTgt$[ebp], 0

; 417  : 
; 418  :    memset( szCmdLineBuffer, 0, 3 * MAX_PATH );

	push	780					; 0000030cH
	push	0
	lea	eax, DWORD PTR _szCmdLineBuffer$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 419  :    memset( g_szZeidonEnvDirectory, 0, MAX_PATH + 1 );

	push	261					; 00000105H
	push	0
	push	OFFSET _g_szZeidonEnvDirectory
	call	_memset
	add	esp, 12					; 0000000cH

; 420  :    pchSrc = lpCmdLine;

	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	mov	DWORD PTR _pchSrc$[ebp], ecx

; 421  :    pchTgt = szCmdLineBuffer;

	lea	edx, DWORD PTR _szCmdLineBuffer$[ebp]
	mov	DWORD PTR _pchTgt$[ebp], edx
$LN2@WinMain:

; 422  : 
; 423  :    // convert everything to uppercase
; 424  :    while( *pchSrc )

	mov	eax, DWORD PTR _pchSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@WinMain

; 425  :    {
; 426  :       *pchTgt = toupper( *pchSrc );

	mov	edx, DWORD PTR _pchSrc$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_toupper
	add	esp, 4
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [ecx], al

; 427  :       pchSrc++;

	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx

; 428  :       pchTgt++;

	mov	eax, DWORD PTR _pchTgt$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTgt$[ebp], eax

; 429  :    }

	jmp	SHORT $LN2@WinMain
$LN3@WinMain:

; 430  : 
; 431  :    // search for "ZEIDON" token
; 432  :    pchZeidonDir = strstr( szCmdLineBuffer, szZeidonParmName );

	push	OFFSET _szZeidonParmName
	lea	ecx, DWORD PTR _szCmdLineBuffer$[ebp]
	push	ecx
	call	_strstr
	add	esp, 8
	mov	DWORD PTR _pchZeidonDir$[ebp], eax
$LN4@WinMain:

; 433  :    while( pchZeidonDir && *pchZeidonDir != '=' )

	cmp	DWORD PTR _pchZeidonDir$[ebp], 0
	je	SHORT $LN5@WinMain
	mov	edx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN5@WinMain

; 434  :       pchZeidonDir++;

	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchZeidonDir$[ebp], ecx
	jmp	SHORT $LN4@WinMain
$LN5@WinMain:

; 435  : 
; 436  :    // skip '='
; 437  :    if ( pchZeidonDir && *pchZeidonDir == '=' )

	cmp	DWORD PTR _pchZeidonDir$[ebp], 0
	je	SHORT $LN6@WinMain
	mov	edx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 61					; 0000003dH
	jne	SHORT $LN6@WinMain

; 438  :       pchZeidonDir++;

	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchZeidonDir$[ebp], ecx
$LN6@WinMain:

; 439  : 
; 440  :    // eliminate leading whitespaces
; 441  :    while ( pchZeidonDir && isspace( *pchZeidonDir ) )

	cmp	DWORD PTR _pchZeidonDir$[ebp], 0
	je	SHORT $LN7@WinMain
	mov	edx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	_isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN7@WinMain

; 442  :       pchZeidonDir++;

	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchZeidonDir$[ebp], ecx
	jmp	SHORT $LN6@WinMain
$LN7@WinMain:

; 443  : 
; 444  :    // if current char is a " we have to copy anything up to the next " char
; 445  :    if ( pchZeidonDir && *pchZeidonDir == '"' )

	cmp	DWORD PTR _pchZeidonDir$[ebp], 0
	je	SHORT $LN15@WinMain
	mov	edx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	jne	SHORT $LN15@WinMain

; 446  :    {
; 447  :       pchZeidonDir++;

	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchZeidonDir$[ebp], ecx

; 448  :       pchTgt = g_szZeidonEnvDirectory;

	mov	DWORD PTR _pchTgt$[ebp], OFFSET _g_szZeidonEnvDirectory
$LN8@WinMain:

; 449  :       while( *pchZeidonDir != '"' && *pchZeidonDir )

	mov	edx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 34					; 00000022H
	je	SHORT $LN9@WinMain
	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@WinMain

; 450  :       {
; 451  :          *pchTgt = *pchZeidonDir;

	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 452  :          pchTgt++;

	mov	eax, DWORD PTR _pchTgt$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTgt$[ebp], eax

; 453  :          pchZeidonDir++;

	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchZeidonDir$[ebp], ecx

; 454  :       }

	jmp	SHORT $LN8@WinMain
$LN9@WinMain:

; 455  :    }

	jmp	SHORT $LN16@WinMain
$LN15@WinMain:

; 456  :    else // otherwise we copy anything up to the next whitespace
; 457  :    {
; 458  :       pchTgt = g_szZeidonEnvDirectory;

	mov	DWORD PTR _pchTgt$[ebp], OFFSET _g_szZeidonEnvDirectory
$LN10@WinMain:

; 459  :       while( pchZeidonDir && *pchZeidonDir && ! isspace( *pchZeidonDir ) )

	cmp	DWORD PTR _pchZeidonDir$[ebp], 0
	je	SHORT $LN16@WinMain
	mov	edx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN16@WinMain
	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	_isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@WinMain

; 460  :       {
; 461  :          *pchTgt = *pchZeidonDir;

	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 462  :          pchTgt++;

	mov	eax, DWORD PTR _pchTgt$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTgt$[ebp], eax

; 463  :          pchZeidonDir++;

	mov	ecx, DWORD PTR _pchZeidonDir$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchZeidonDir$[ebp], ecx

; 464  :       }

	jmp	SHORT $LN10@WinMain
$LN16@WinMain:

; 465  :    }
; 466  : 
; 467  :    // Make sure only one copy of kzoengwa is running.  Start by creating
; 468  :    // a mutex to protect process of checking.
; 469  :    if ( (hMutex1 = CreateMutex( NULL, FALSE, "KZOENGWA - INIT" )) == 0 )

	push	OFFSET $SG96023
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	DWORD PTR _hMutex1$[ebp], eax
	cmp	DWORD PTR _hMutex1$[ebp], 0
	jne	SHORT $LN17@WinMain

; 470  :    {
; 471  :       SysMessageBox( 0, "Zeidon Object Engine", "Can't create init mutex", 1 );

	push	1
	push	OFFSET $SG96024
	push	OFFSET $SG96025
	push	0
	call	_SysMessageBox@16

; 472  :       return( FALSE );

	xor	eax, eax
	jmp	$LN1@WinMain
$LN17@WinMain:

; 473  :    }
; 474  : 
; 475  :    // Lock mutex.
; 476  :    WaitForSingleObject( hMutex1, INFINITE );

	push	-1
	mov	edx, DWORD PTR _hMutex1$[ebp]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8

; 477  : 
; 478  :    // Now see if a second mutex has already been created.  If it has then
; 479  :    // KZOENGWA has already been started.
; 480  :    if ( (hMutex2 = OpenMutex( MUTEX_ALL_ACCESS,
; 481  :                               FALSE, "KZOENGWA - INIT 2!!!" )) != 0 )

	push	OFFSET $SG96027
	push	0
	push	2031617					; 001f0001H
	call	DWORD PTR __imp__OpenMutexA@12
	mov	DWORD PTR _hMutex2$[ebp], eax
	cmp	DWORD PTR _hMutex2$[ebp], 0
	je	SHORT $LN18@WinMain

; 482  :    {
; 483  :       // Close all the mutexes and get out.
; 484  :       CloseHandle( hMutex2 );

	mov	eax, DWORD PTR _hMutex2$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 485  :       ReleaseMutex( hMutex1 );

	mov	ecx, DWORD PTR _hMutex1$[ebp]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 486  :       CloseHandle( hMutex1 );

	mov	edx, DWORD PTR _hMutex1$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 487  : 
; 488  :       SysMessageBox( 0, "Zeidon Object Engine",

	push	1
	push	OFFSET $SG96028
	push	OFFSET $SG96029
	push	0
	call	_SysMessageBox@16

; 489  :                      "Only one instance of KZOENGWA can exist at once.", 1 );
; 490  : 
; 491  :       return( FALSE );

	xor	eax, eax
	jmp	$LN1@WinMain
$LN18@WinMain:

; 492  :    }
; 493  : 
; 494  :    // If we get here then this is the only instance of KZOENGWA so
; 495  :    // create the second mutes.  Note that we DON'T lock it.
; 496  :    hMutex2 = CreateMutex( NULL, FALSE, "KZOENGWA - INIT 2!!!" );

	push	OFFSET $SG96030
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	DWORD PTR _hMutex2$[ebp], eax

; 497  : 
; 498  :    // We don't need it anymore so dump the first mutex.
; 499  :    ReleaseMutex( hMutex1 );

	mov	eax, DWORD PTR _hMutex1$[ebp]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4

; 500  :    CloseHandle( hMutex1 );

	mov	ecx, DWORD PTR _hMutex1$[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 501  : 
; 502  :    if ( InitApplication( hInstance ) == 0 ) // Initialize shared things

	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	_InitApplication
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@WinMain

; 503  :    {
; 504  :       CloseHandle( hMutex2 );    // Get rid of the instance mutex

	mov	eax, DWORD PTR _hMutex2$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 505  :       return( FALSE );           // Exits if unable to initialize

	xor	eax, eax
	jmp	$LN1@WinMain
$LN19@WinMain:

; 506  :    }
; 507  : 
; 508  : #else
; 509  :    if ( hPrevInstance == 0 )     // Other instances of app running?
; 510  :    {
; 511  :       // If we need to increase the size of the message queue, here is where
; 512  :       // it will need to be done.  We need to do this to prevent the loss
; 513  :       // of TraceLine messages.
; 514  : 
; 515  :       zSHORT nMsg = 32;  // the maximum size is 120, the default size is 8
; 516  : 
; 517  :       while ( nMsg > 8 && SetMessageQueue( nMsg ) == 0 )
; 518  :          nMsg -= 8;
; 519  : 
; 520  : 
; 521  :       // run in enhanced or protected mode only - not in real mode
; 522  :       if ( (GetWinFlags( ) & WF_PMODE) != WF_PMODE )
; 523  :       {
; 524  :          MessageBox( GetActiveWindow( ),
; 525  :                      "Zeidon cannot be executed in real mode",
; 526  :                      "Zeidon", MB_ICONSTOP | MB_OK );
; 527  :          return( FALSE );
; 528  :       }
; 529  : 
; 530  :       if ( InitApplication( hInstance ) == 0 ) // Initialize shared things
; 531  :          return( FALSE );                      // Exits if unable to initialize
; 532  :    }
; 533  :    else
; 534  :    {
; 535  :       AnchorBlock = SysGetAnchorBlock( );
; 536  :       if ( AnchorBlock )
; 537  :          SetActiveWindow( (HWND) AnchorBlock->lOE_hMainWnd );
; 538  : 
; 539  :       return( FALSE );
; 540  :    }
; 541  : #endif
; 542  : 
; 543  :    // Perform initializations that apply to a specific instance
; 544  :    if ( InitInstance( hInstance, nCmdShow ) == 0 )

	mov	ecx, DWORD PTR _nCmdShow$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	call	_InitInstance
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@WinMain

; 545  :    {
; 546  : #ifdef __WIN32__
; 547  :       // Get rid of the second instance mutex.
; 548  :       CloseHandle( hMutex2 );

	mov	eax, DWORD PTR _hMutex2$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 549  : #endif
; 550  :       return( FALSE );

	xor	eax, eax
	jmp	$LN1@WinMain
$LN20@WinMain:

; 551  :    }
; 552  : 
; 553  : #ifdef __WIN32__
; 554  :    TraceLineS( "Engine started for Win32", "" );

	push	OFFSET $SG96033
	push	OFFSET $SG96034
	call	_TraceLineS@8

; 555  : #endif
; 556  : 
; 557  :    hAccel = LoadAccelerators( hInstance, "TRACE_ACCEL" );

	push	OFFSET $SG96035
	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadAcceleratorsA@8
	mov	DWORD PTR _hAccel$[ebp], eax

; 558  : 
; 559  : #ifndef ALLOC_FREE_TRACE
; 560  :    hMenu = GetMenu( g_hWndMainFrame );

	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _hMenu$[ebp], eax

; 561  :    if ( hMenu )

	cmp	DWORD PTR _hMenu$[ebp], 0
	je	SHORT $LN21@WinMain

; 562  :    {
; 563  :       hMenu = GetSubMenu( hMenu, 1 );

	push	1
	mov	eax, DWORD PTR _hMenu$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSubMenu@8
	mov	DWORD PTR _hMenu$[ebp], eax

; 564  :    // DeleteMenu( hMenu, IDM_SETMEMORYTRACE, MF_BYCOMMAND );
; 565  :       RemoveMenu( hMenu, 9, MF_BYPOSITION );

	push	1024					; 00000400H
	push	9
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__RemoveMenu@12

; 566  :       DrawMenuBar( g_hWndMainFrame );

	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	call	DWORD PTR __imp__DrawMenuBar@4
$LN21@WinMain:

; 567  :    }
; 568  : #endif
; 569  : 
; 570  : #ifndef LOAD_FREE_TRACE
; 571  :    hMenu = GetMenu( g_hWndMainFrame );

	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	call	DWORD PTR __imp__GetMenu@4
	mov	DWORD PTR _hMenu$[ebp], eax

; 572  :    if ( hMenu )

	cmp	DWORD PTR _hMenu$[ebp], 0
	je	SHORT $LN22@WinMain

; 573  :    {
; 574  :       hMenu = GetSubMenu( hMenu, 1 );

	push	1
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSubMenu@8
	mov	DWORD PTR _hMenu$[ebp], eax

; 575  :    // DeleteMenu( hMenu, IDM_SETLOADTRACE, MF_BYCOMMAND );
; 576  :       RemoveMenu( hMenu, 13, MF_BYPOSITION );

	push	1024					; 00000400H
	push	13					; 0000000dH
	mov	edx, DWORD PTR _hMenu$[ebp]
	push	edx
	call	DWORD PTR __imp__RemoveMenu@12

; 577  :       DrawMenuBar( g_hWndMainFrame );

	mov	eax, DWORD PTR _g_hWndMainFrame
	push	eax
	call	DWORD PTR __imp__DrawMenuBar@4
$LN22@WinMain:

; 578  :    }
; 579  : #endif
; 580  : 
; 581  :    AnchorBlock->nStatus = AnchorInitialized; // Flag init as complete

	mov	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+84], cx

; 582  : 
; 583  :    // Open a Win32 event so we can signal to everybody that we're done.
; 584  :    hServicesStarted = CreateEvent( NULL, TRUE, FALSE,

	push	OFFSET $SG96038
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	DWORD PTR _hServicesStarted$[ebp], eax

; 585  :                                    "Zeidon - Object Services Init" );
; 586  :    SetEvent( hServicesStarted );

	mov	eax, DWORD PTR _hServicesStarted$[ebp]
	push	eax
	call	DWORD PTR __imp__SetEvent@4

; 587  :    CloseHandle( hServicesStarted );

	mov	ecx, DWORD PTR _hServicesStarted$[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 588  : 
; 589  :    SysReadZeidonIni( -1, "[ObjectEngine]", "TimeOut", szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	push	OFFSET $SG96039
	push	OFFSET $SG96040
	push	-1
	call	_SysReadZeidonIni@16

; 590  :    if ( szWork[ 0 ] && (g_lTimeOut = zatol( szWork )) != 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szWork$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN12@WinMain
	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	call	_atol
	add	esp, 4
	mov	DWORD PTR _g_lTimeOut, eax
	cmp	DWORD PTR _g_lTimeOut, 0
	je	SHORT $LN12@WinMain

; 591  :    {
; 592  :       SysReadZeidonIni( -1, "[ObjectEngine]", "KillZeidon", szWork );

	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	push	OFFSET $SG96042
	push	OFFSET $SG96043
	push	-1
	call	_SysReadZeidonIni@16

; 593  :       if ( szWork[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szWork$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN24@WinMain

; 594  :          SysGetDateTime( g_szTimeStamp );

	push	OFFSET _g_szTimeStamp
	call	_SysGetDateTime@4
	jmp	SHORT $LN12@WinMain
$LN24@WinMain:

; 595  :       else
; 596  :       {
; 597  :          MessageBox( 0, "TimeOut requires KillZeidon specification",

	push	0
	push	OFFSET $SG96046
	push	OFFSET $SG96047
	push	0
	call	DWORD PTR __imp__MessageBoxA@16

; 598  :                      "Object Services", MB_OK );
; 599  :          g_lTimeOut = 0;

	mov	DWORD PTR _g_lTimeOut, 0
$LN12@WinMain:

; 600  :       }
; 601  :    }
; 602  : 
; 603  :    // Acquire and dispatch messages until a WM_QUIT message is received
; 604  :    while ( GetMessage( &msg,     // message structure

	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__GetMessageA@16
	test	eax, eax
	je	SHORT $LN13@WinMain

; 605  :                        0,        // handle of window receiving the message
; 606  :                        0,        // lowest message to examine
; 607  :                        0 ) )     // highest message to examine
; 608  :    {
; 609  :       if ( !TranslateAccelerator( g_hWndMainFrame, hAccel, &msg ) )

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hAccel$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hWndMainFrame
	push	edx
	call	DWORD PTR __imp__TranslateAcceleratorA@12
	test	eax, eax
	jne	SHORT $LN26@WinMain

; 610  :       {
; 611  :          TranslateMessage( &msg );  // Translate message

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__TranslateMessage@4

; 612  :          DispatchMessage( &msg );   // Dispatches message to window

	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	DWORD PTR __imp__DispatchMessageA@4
$LN26@WinMain:

; 613  :       }
; 614  :    }

	jmp	SHORT $LN12@WinMain
$LN13@WinMain:

; 615  : 
; 616  : #ifdef __WIN32__
; 617  :    // Get rid of the second instance mutex.
; 618  :    CloseHandle( hMutex2 );

	mov	edx, DWORD PTR _hMutex2$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 619  : #endif
; 620  : 
; 621  :    return( msg.wParam );         // Returns the value from PostQuitMessage

	mov	eax, DWORD PTR _msg$[ebp+8]
$LN1@WinMain:

; 622  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
