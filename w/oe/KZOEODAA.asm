; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEODAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG14813 DB	01H DUP (?)
$SG14814 DB	01H DUP (?)
$SG14835 DB	01H DUP (?)
$SG14836 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG14359 DB	'DB_OPER', 00H
$SG14360 DB	'DB_OPER', 00H
$SG14361 DB	'DB_OPER', 00H
$SG14364 DB	'DERIVEDE', 00H
	ORG $+3
$SG14365 DB	'DERIVEDE', 00H
	ORG $+3
$SG14366 DB	'DERIVEDE', 00H
	ORG $+3
$SG14371 DB	'DERIVEDOPERXPG', 00H
	ORG $+1
$SG14372 DB	'DERIVEDOPERXPG', 00H
	ORG $+1
$SG14373 DB	'DERIVEDOPERXPG', 00H
	ORG $+1
$SG14376 DB	'DERIVEDZ', 00H
	ORG $+3
$SG14377 DB	'DERIVEDZ', 00H
	ORG $+3
$SG14378 DB	'DERIVEDZ', 00H
	ORG $+3
$SG14382 DB	'DEBUGCHG', 00H
	ORG $+3
$SG14383 DB	'DEBUGCHG', 00H
	ORG $+3
$SG14384 DB	'DEBUGCHG', 00H
	ORG $+3
$SG14389 DB	'FORKEY', 00H
	ORG $+1
$SG14390 DB	'FORKEY', 00H
	ORG $+1
$SG14391 DB	'FORKEY', 00H
	ORG $+1
$SG14441 DB	', ', 00H
	ORG $+1
$SG14449 DB	'XML_SIMPLE_NAME', 00H
$SG14450 DB	'XML_SIMPLE_NAME', 00H
$SG14451 DB	'XML_SIMPLE_NAME', 00H
$SG14454 DB	'XML_NAME_EXTERNAL', 00H
	ORG $+2
$SG14455 DB	'XML_NAME_EXTERNAL', 00H
	ORG $+2
$SG14456 DB	'XML_NAME_EXTERNAL', 00H
	ORG $+2
$SG14498 DB	'JOIN', 00H
	ORG $+3
$SG14499 DB	'JOIN', 00H
	ORG $+3
$SG14500 DB	'JOIN', 00H
	ORG $+3
$SG13598 DB	'CACHENUM', 00H
	ORG $+3
$SG13599 DB	'CACHENUM', 00H
	ORG $+3
$SG13600 DB	'CACHENUM', 00H
	ORG $+3
$SG13613 DB	'DBH_Data', 00H
	ORG $+3
$SG13614 DB	'DBH_Data', 00H
	ORG $+3
$SG13615 DB	'DBH_Data', 00H
	ORG $+3
$SG13618 DB	'ER_DATE', 00H
$SG13619 DB	'ER_DATE', 00H
$SG13620 DB	'ER_DATE', 00H
$SG13649 DB	'ORDERBY', 00H
$SG13650 DB	'ORDERBY', 00H
$SG13651 DB	'ORDERBY', 00H
$SG13658 DB	'OCEOPERN', 00H
	ORG $+3
$SG13659 DB	'OCEOPERN', 00H
	ORG $+3
$SG13660 DB	'OCEOPERN', 00H
	ORG $+3
$SG13678 DB	'SironDB_Type', 00H
	ORG $+3
$SG13679 DB	'SironDB_Type', 00H
	ORG $+3
$SG13680 DB	'SironDB_Type', 00H
	ORG $+3
$SG14815 DB	'Object Definition: %s  for App: %s', 00H
	ORG $+1
$SG14816 DB	'Y', 00H
	ORG $+2
$SG14817 DB	'N', 00H
	ORG $+2
$SG14818 DB	'%se%s  PDelete: %s  EREntTok: 0x%08x  ERRelTok: 0x%08x', 00H
	ORG $+1
$SG14820 DB	'Attribute for entity NOT parented by Entity: ', 00H
	ORG $+2
$SG14821 DB	'  ForeignKey', 00H
	ORG $+3
$SG14822 DB	'  ', 00H
	ORG $+1
$SG14823 DB	'Y', 00H
	ORG $+2
$SG14824 DB	'N', 00H
	ORG $+2
$SG14825 DB	'%s  a%s  Key: %s%s  ERAttTok: 0x%08x  XVAAttTok: 0x%08x', 00H
$SG14826 DB	'Y', 00H
	ORG $+2
$SG14827 DB	'N', 00H
	ORG $+2
$SG14828 DB	'%s  r%s  RecordID: 0x%08x  PrimarySecondary: %c  Join: %'
	DB	's', 00H
	ORG $+2
$SG14830 DB	'<null>', 00H
	ORG $+1
$SG14946 DB	'(od) opening Object Def file Name: ', 00H
$SG14829 DB	'%s    rr%s  RecordID: 0x%08x  OwnerMember: %c   Set1: %s'
	DB	' 0x%08x   Set2: %s 0x%08x', 00H
	ORG $+2
$SG14831 DB	'<null>', 00H
	ORG $+1
$SG14832 DB	'<null>', 00H
	ORG $+1
$SG14952 DB	'pZeidon', 00H
$SG13957 DB	'ABSTRACT', 00H
	ORG $+3
$SG14833 DB	'%s      rf%s  [Attrib Name: %s  ERAttTok: 0x%08x  XVAAtt'
	DB	'Tok: 0x%08x]  SrcDataField: %s 0x%08x [Attrib: %s  ERAttTok: '
	DB	'0x%08x  XVAAttTok: 0x%08x]  RelDataField: %s 0x%08x [Attrib: '
	DB	'%s  ERAttTok: 0x%08x  XVAAttTok: 0x%08x]', 00H
	ORG $+1
$SG13958 DB	'ABSTRACT', 00H
	ORG $+3
$SG14834 DB	'%s    df%s  FldID: 0x%08x  [Attrib Name: %s  ERAttTok: 0'
	DB	'x%08x  XVAAttTok: 0x%08x]', 00H
	ORG $+2
$SG14950 DB	'Zeidon', 00H
	ORG $+1
$SG13959 DB	'ABSTRACT', 00H
	ORG $+3
$SG13962 DB	'ABSTRACTCHILD', 00H
	ORG $+2
$SG13963 DB	'ABSTRACTCHILD', 00H
	ORG $+2
$SG13964 DB	'ABSTRACTCHILD', 00H
	ORG $+2
$SG13967 DB	'ACT_LIMIT', 00H
	ORG $+2
$SG13968 DB	'ACT_LIMIT', 00H
	ORG $+2
$SG13969 DB	'ACT_LIMIT', 00H
	ORG $+2
$SG14011 DB	'ECEOPERN', 00H
	ORG $+3
$SG14012 DB	'ECEOPERN', 00H
	ORG $+3
$SG14013 DB	'ECEOPERN', 00H
	ORG $+3
$SG14035 DB	'HANG_FK', 00H
$SG14036 DB	'HANG_FK', 00H
$SG14037 DB	'HANG_FK', 00H
$SG14050 DB	'MAX_LTH', 00H
$SG14051 DB	'MAX_LTH', 00H
$SG14052 DB	'MAX_LTH', 00H
$SG15083 DB	'Deleting Object Definition (0x%08x): %s for App: %s', 00H
$SG14073 DB	'XML_NAME', 00H
	ORG $+3
$SG14074 DB	'XML_NAME', 00H
	ORG $+3
$SG14075 DB	'XML_NAME', 00H
	ORG $+3
$SG15126 DB	'View referencing ''%s'' = ', 00H
_DATA	ENDS
PUBLIC	_ActivateViewObject@12
PUBLIC	_DropViewObject@12
PUBLIC	_fnDeleteViewObject@4
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnProcessObjectEntity
PUBLIC	_fnProcessEntityEntity
PUBLIC	_fnProcessAttribEntity
PUBLIC	_fnProcessDataRecordEntity
PUBLIC	_fnProcessDataFieldEntity
PUBLIC	_fnProcessRelRecordEntity
PUBLIC	_fnProcessRelFieldEntity
PUBLIC	_fnCheckIfViewOD_IsUsed@8
PUBLIC	_DisplayObjectDefinition
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	__imp___strlwr:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__atol:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_GetTaskDBHandlerTraceLevel@4:PROC
EXTRN	_SysCloseFile@12:PROC
EXTRN	_SysOpenFile@12:PROC
EXTRN	_SysParseLine@12:PROC
EXTRN	_SysReadLine@12:PROC
EXTRN	_SysReadLineLth@16:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnStoreStringInDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnStartBrowseOfTaskList@8:PROC
EXTRN	_fnEndBrowseOfTaskList@4:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__toupper:PROC
EXTRN	_fnDropTaskOperation@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_g_ulMaxRecordStringLth:DWORD
EXTRN	_szObjectSuffix:DWORD
EXTRN	_szlOBJECT:DWORD
EXTRN	_szlENTITY:DWORD
EXTRN	_szlCHILDENTITY:DWORD
EXTRN	_szlATTRIB:DWORD
EXTRN	_szlAPDM_TOK:DWORD
EXTRN	_szlAUTOCREATE:DWORD
EXTRN	_szlAUTOLOADFROMPARENT:DWORD
EXTRN	_szlAUTO_SEQ:DWORD
EXTRN	_szlXVAATT_TOK:DWORD
EXTRN	_szlCARDMAX:DWORD
EXTRN	_szlCARDMIN:DWORD
EXTRN	_szlCASESENS:DWORD
EXTRN	_szlCREATE:DWORD
EXTRN	_szlCR_DATE:DWORD
EXTRN	_szlDATAFIELD:DWORD
EXTRN	_szlDATARECORD:DWORD
EXTRN	_szlDBNAME:DWORD
EXTRN	_szlDECIMAL:DWORD
EXTRN	_szlDELETE:DWORD
EXTRN	_szlDERIVED:DWORD
EXTRN	_szlDERIVEDF:DWORD
EXTRN	_szlDFT_DBNAME:DWORD
EXTRN	_szlDFT_SERVER:DWORD
EXTRN	_szlDUPENTIN:DWORD
EXTRN	_szlDUPRELIN:DWORD
EXTRN	_szlECACC:DWORD
EXTRN	_szlECCAN:DWORD
EXTRN	_szlECCR:DWORD
EXTRN	_szlECDEL:DWORD
EXTRN	_szlECEOPER:DWORD
EXTRN	_szlECEXC:DWORD
EXTRN	_szlECINC:DWORD
EXTRN	_szlERATT_TOK:DWORD
EXTRN	_szlERENT_TOK:DWORD
EXTRN	_szlERREL_LINK:DWORD
EXTRN	_szlERREL_TOK:DWORD
EXTRN	_szlEXCLUDE:DWORD
EXTRN	_szlFLDID:DWORD
EXTRN	_szlFLDLTH:DWORD
EXTRN	_szlFLDNAME:DWORD
EXTRN	_szlFLDOFFSET:DWORD
EXTRN	_szlFLDTYPE:DWORD
EXTRN	_szlFULLPERSIST:DWORD
EXTRN	_szlGENKEY:DWORD
EXTRN	_szlGKHANDLER:DWORD
EXTRN	_szlHANDLER:DWORD
EXTRN	_szlHIDDEN:DWORD
EXTRN	_szlINCLSRC:DWORD
EXTRN	_szlINCLUDE:DWORD
EXTRN	_szlINCRLOAD:DWORD
EXTRN	_szlINIT:DWORD
EXTRN	_szlKEY:DWORD
EXTRN	_szlLOCK:DWORD
EXTRN	_szlLTH:DWORD
EXTRN	_szlNAME:DWORD
EXTRN	_szlNETCOMPRESS:DWORD
EXTRN	_szlNETWORK:DWORD
EXTRN	_szlOCACT:DWORD
EXTRN	_szlOCACTE:DWORD
EXTRN	_szlOCCOM:DWORD
EXTRN	_szlOCDROP:DWORD
EXTRN	_szlOCEOPER:DWORD
EXTRN	_szlOFRECID:DWORD
EXTRN	_szlOFBUFSZ:DWORD
EXTRN	_szlOPER_LIBNM:DWORD
EXTRN	_szlOWNER_MEMB:DWORD
EXTRN	_szlPDELETE:DWORD
EXTRN	_szlPERSIST:DWORD
EXTRN	_szlRECID:DWORD
EXTRN	_szlRECNAME:DWORD
EXTRN	_szlRECURSIVE:DWORD
EXTRN	_szlRELFIELD:DWORD
EXTRN	_szlRELRECORD:DWORD
EXTRN	_szlRELXVAATT_TOK:DWORD
EXTRN	_szlREQUIRED:DWORD
EXTRN	_szlSERVER:DWORD
EXTRN	_szlSEQUENCING:DWORD
EXTRN	_szlSEQ_AD:DWORD
EXTRN	_szlSETID1:DWORD
EXTRN	_szlSETID2:DWORD
EXTRN	_szlSETNAME1:DWORD
EXTRN	_szlSETNAME2:DWORD
EXTRN	_szlSRCXVAATT_TOK:DWORD
EXTRN	_szlTYPE:DWORD
EXTRN	_szlUP_DATE:DWORD
EXTRN	_szlUSERID:DWORD
EXTRN	_szlUPDATE:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpApp$ = -360						; size = 4
tv272 = -356						; size = 4
tv268 = -352						; size = 4
tv264 = -348						; size = 4
tv256 = -344						; size = 4
tv252 = -340						; size = 4
tv248 = -336						; size = 4
tv240 = -332						; size = 4
tv236 = -328						; size = 4
tv232 = -324						; size = 4
tv179 = -320						; size = 4
tv163 = -316						; size = 4
tv157 = -312						; size = 4
tv132 = -308						; size = 4
$T1 = -304						; size = 4
_lpDataField2$ = -300					; size = 4
_lpViewAttrib1$ = -296					; size = 4
_lpViewAttrib2$ = -292					; size = 4
_lpRelField$ = -288					; size = 4
_nLth$ = -284						; size = 2
_lpDataRecord$ = -280					; size = 4
_lpDataField$ = -276					; size = 4
_lpRelRecord$ = -272					; size = 4
_lpViewEntity$ = -268					; size = 4
_lpViewAttrib$ = -264					; size = 4
_szIndent$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpViewOD$ = 8						; size = 4
_DisplayObjectDefinition PROC

; 1649 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 360				; 00000168H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1650 :    LPVIEWENTITY   lpViewEntity;
; 1651 :    LPVIEWATTRIB   lpViewAttrib;
; 1652 :    LPVIEWATTRIB   lpViewAttrib1;
; 1653 :    LPVIEWATTRIB   lpViewAttrib2;
; 1654 :    LPDATARECORD   lpDataRecord;
; 1655 :    LPRELRECORD    lpRelRecord;
; 1656 :    LPDATAFIELD    lpDataField;
; 1657 :    LPDATAFIELD    lpDataField2;
; 1658 :    LPRELFIELD     lpRelField;
; 1659 :    LPAPP  lpApp = zGETPTR( lpViewOD->hApp );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 1660 :    zCHAR  szIndent[ 256 ];
; 1661 :    zSHORT nLth = 0;

	xor	edx, edx
	mov	WORD PTR _nLth$[ebp], dx

; 1662 : 
; 1663 :    zmemset( szIndent, ' ', sizeof( szIndent ) - 1 );

	push	255					; 000000ffH
	push	32					; 00000020H
	lea	eax, DWORD PTR _szIndent$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1664 :    TraceLineS( "", "" );

	push	OFFSET $SG14813
	push	OFFSET $SG14814
	call	_TraceLineS@8

; 1665 :    TraceLine( "Object Definition: %s  for App: %s", lpViewOD->szName, lpApp->szName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14815
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 1666 : 
; 1667 :    lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN2@DisplayObj:

; 1668 :    while ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$LN3@DisplayObj

; 1669 :    {
; 1670 :       // Set up 4 character indentation based on Entity Level.
; 1671 :       szIndent[ nLth ] = ' ';

	movsx	edx, WORD PTR _nLth$[ebp]
	mov	BYTE PTR _szIndent$[ebp+edx], 32	; 00000020H

; 1672 :       nLth = (lpViewEntity->nLevel - 1) * 4;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	lea	edx, DWORD PTR [ecx*4-4]
	mov	WORD PTR _nLth$[ebp], dx

; 1673 :       szIndent[ nLth ] = 0;

	movsx	eax, WORD PTR _nLth$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN16@DisplayObj
	jmp	SHORT $LN17@DisplayObj
$LN16@DisplayObj:
	call	___report_rangecheckfailure
$LN17@DisplayObj:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szIndent$[ebp+ecx], 0

; 1674 : 
; 1675 :       TraceLine( "%se%s  PDelete: %s  EREntTok: 0x%08x  ERRelTok: 0x%08x",

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 7
	and	eax, 1
	je	SHORT $LN18@DisplayObj
	mov	DWORD PTR tv132[ebp], OFFSET $SG14816
	jmp	SHORT $LN19@DisplayObj
$LN18@DisplayObj:
	mov	DWORD PTR tv132[ebp], OFFSET $SG14817
$LN19@DisplayObj:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+199]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+195]
	push	ecx
	mov	edx, DWORD PTR tv132[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szIndent$[ebp]
	push	ecx
	push	OFFSET $SG14818
	call	_TraceLine
	add	esp, 24					; 00000018H

; 1676 :                  szIndent, lpViewEntity->szName,
; 1677 :                  lpViewEntity->bPDelete ? "Y" : "N",
; 1678 :                  lpViewEntity->lEREntTok,
; 1679 :                  lpViewEntity->lERRelTok );
; 1680 : 
; 1681 :       lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@DisplayObj:

; 1682 :       while ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN5@DisplayObj

; 1683 :       {
; 1684 :          if ( zGETPTR( lpViewAttrib->hViewEntity ) != lpViewEntity )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN14@DisplayObj

; 1685 :             TraceLineS( "Attribute for entity NOT parented by Entity: ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG14820
	call	_TraceLineS@8
$LN14@DisplayObj:

; 1686 : 
; 1687 :          TraceLine( "%s  a%s  Key: %s%s  ERAttTok: 0x%08x  XVAAttTok: 0x%08x",

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN20@DisplayObj
	mov	DWORD PTR tv157[ebp], OFFSET $SG14821
	jmp	SHORT $LN21@DisplayObj
$LN20@DisplayObj:
	mov	DWORD PTR tv157[ebp], OFFSET $SG14822
$LN21@DisplayObj:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN22@DisplayObj
	mov	DWORD PTR tv163[ebp], OFFSET $SG14823
	jmp	SHORT $LN23@DisplayObj
$LN22@DisplayObj:
	mov	DWORD PTR tv163[ebp], OFFSET $SG14824
$LN23@DisplayObj:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+181]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+177]
	push	edx
	mov	eax, DWORD PTR tv157[ebp]
	push	eax
	mov	ecx, DWORD PTR tv163[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szIndent$[ebp]
	push	eax
	push	OFFSET $SG14825
	call	_TraceLine
	add	esp, 28					; 0000001cH

; 1688 :                     szIndent, lpViewAttrib->szName,
; 1689 :                     lpViewAttrib->bKey ? "Y" : "N",
; 1690 :                     lpViewAttrib->bForeignKey ? "  ForeignKey" : "  ",
; 1691 :                     lpViewAttrib->lERAttTok,
; 1692 :                     lpViewAttrib->lXVAAttTok );
; 1693 : 
; 1694 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1695 :       }

	jmp	$LN4@DisplayObj
$LN5@DisplayObj:

; 1696 : 
; 1697 :       lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax
$LN6@DisplayObj:

; 1698 :       while ( lpDataRecord )

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	je	$LN7@DisplayObj

; 1699 :       {
; 1700 :          TraceLine( "%s  r%s  RecordID: 0x%08x  PrimarySecondary: %c  Join: %s",

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	movsx	eax, BYTE PTR [edx+275]
	test	eax, eax
	je	SHORT $LN24@DisplayObj
	mov	DWORD PTR tv179[ebp], OFFSET $SG14826
	jmp	SHORT $LN25@DisplayObj
$LN24@DisplayObj:
	mov	DWORD PTR tv179[ebp], OFFSET $SG14827
$LN25@DisplayObj:
	mov	ecx, DWORD PTR tv179[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+271]
	push	edx
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	lea	ecx, DWORD PTR _szIndent$[ebp]
	push	ecx
	push	OFFSET $SG14828
	call	_TraceLine
	add	esp, 24					; 00000018H

; 1701 :                     szIndent, lpDataRecord->szRecordName,
; 1702 :                     lpDataRecord->lRecordID, lpDataRecord->cRecordType,
; 1703 :                     lpDataRecord->cJoin ? "Y" : "N" );
; 1704 : 
; 1705 :          lpRelRecord = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax
$LN8@DisplayObj:

; 1706 :          while ( lpRelRecord )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	$LN9@DisplayObj

; 1707 :          {
; 1708 :             TraceLine( "%s    rr%s  RecordID: 0x%08x  OwnerMember: %c   Set1: %s 0x%08x   Set2: %s 0x%08x",

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+787]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 531				; 00000213H
	push	eax
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+527]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 271				; 0000010fH
	push	eax
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR [eax+267]
	push	ecx
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	add	edx, 11					; 0000000bH
	push	edx
	lea	eax, DWORD PTR _szIndent$[ebp]
	push	eax
	push	OFFSET $SG14829
	call	_TraceLine
	add	esp, 36					; 00000024H

; 1709 :                        szIndent, lpRelRecord->szRecordName,
; 1710 :                        lpRelRecord->lRecordID,
; 1711 :                        lpRelRecord->cOwnerMember,
; 1712 :                        lpRelRecord->szSetName1,
; 1713 :                        lpRelRecord->lSetID1,
; 1714 :                        lpRelRecord->szSetName2,
; 1715 :                        lpRelRecord->lSetID2 );
; 1716 : 
; 1717 :             lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN10@DisplayObj:

; 1718 :             while ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN11@DisplayObj

; 1719 :             {
; 1720 :                lpViewAttrib = zGETPTR( lpRelField->hViewAttrib );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1721 :                lpDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField$[ebp], eax

; 1722 :                lpDataField2 = zGETPTR( lpRelField->hRelDataField );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField2$[ebp], eax

; 1723 :                lpViewAttrib1 = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib1$[ebp], eax

; 1724 :                lpViewAttrib2 = zGETPTR( lpDataField2->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField2$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib2$[ebp], eax

; 1725 : 
; 1726 :                TraceLine( "%s      rf%s  [Attrib Name: %s  ERAttTok: 0x%08x  XVAAttTok: 0x%08x]"

	cmp	DWORD PTR _lpViewAttrib2$[ebp], 0
	je	SHORT $LN26@DisplayObj
	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	mov	edx, DWORD PTR [ecx+181]
	mov	DWORD PTR tv232[ebp], edx
	jmp	SHORT $LN27@DisplayObj
$LN26@DisplayObj:
	mov	DWORD PTR tv232[ebp], 0
$LN27@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib2$[ebp], 0
	je	SHORT $LN28@DisplayObj
	mov	eax, DWORD PTR _lpViewAttrib2$[ebp]
	mov	ecx, DWORD PTR [eax+177]
	mov	DWORD PTR tv236[ebp], ecx
	jmp	SHORT $LN29@DisplayObj
$LN28@DisplayObj:
	mov	DWORD PTR tv236[ebp], 0
$LN29@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib2$[ebp], 0
	je	SHORT $LN30@DisplayObj
	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR tv240[ebp], edx
	jmp	SHORT $LN31@DisplayObj
$LN30@DisplayObj:
	mov	DWORD PTR tv240[ebp], OFFSET $SG14830
$LN31@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib1$[ebp], 0
	je	SHORT $LN32@DisplayObj
	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	mov	ecx, DWORD PTR [eax+181]
	mov	DWORD PTR tv248[ebp], ecx
	jmp	SHORT $LN33@DisplayObj
$LN32@DisplayObj:
	mov	DWORD PTR tv248[ebp], 0
$LN33@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib1$[ebp], 0
	je	SHORT $LN34@DisplayObj
	mov	edx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	eax, DWORD PTR [edx+177]
	mov	DWORD PTR tv252[ebp], eax
	jmp	SHORT $LN35@DisplayObj
$LN34@DisplayObj:
	mov	DWORD PTR tv252[ebp], 0
$LN35@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib1$[ebp], 0
	je	SHORT $LN36@DisplayObj
	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR tv256[ebp], ecx
	jmp	SHORT $LN37@DisplayObj
$LN36@DisplayObj:
	mov	DWORD PTR tv256[ebp], OFFSET $SG14831
$LN37@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN38@DisplayObj
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+181]
	mov	DWORD PTR tv264[ebp], eax
	jmp	SHORT $LN39@DisplayObj
$LN38@DisplayObj:
	mov	DWORD PTR tv264[ebp], 0
$LN39@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN40@DisplayObj
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+177]
	mov	DWORD PTR tv268[ebp], edx
	jmp	SHORT $LN41@DisplayObj
$LN40@DisplayObj:
	mov	DWORD PTR tv268[ebp], 0
$LN41@DisplayObj:
	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN42@DisplayObj
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR tv272[ebp], eax
	jmp	SHORT $LN43@DisplayObj
$LN42@DisplayObj:
	mov	DWORD PTR tv272[ebp], OFFSET $SG14832
$LN43@DisplayObj:
	mov	ecx, DWORD PTR tv232[ebp]
	push	ecx
	mov	edx, DWORD PTR tv236[ebp]
	push	edx
	mov	eax, DWORD PTR tv240[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField2$[ebp]
	mov	edx, DWORD PTR [ecx+266]
	push	edx
	mov	eax, DWORD PTR _lpDataField2$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR tv248[ebp]
	push	ecx
	mov	edx, DWORD PTR tv252[ebp]
	push	edx
	mov	eax, DWORD PTR tv256[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+266]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR tv264[ebp]
	push	ecx
	mov	edx, DWORD PTR tv268[ebp]
	push	edx
	mov	eax, DWORD PTR tv272[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelField$[ebp]
	add	ecx, 18					; 00000012H
	push	ecx
	lea	edx, DWORD PTR _szIndent$[ebp]
	push	edx
	push	OFFSET $SG14833
	call	_TraceLine
	add	esp, 64					; 00000040H

; 1727 :                             "  SrcDataField: %s 0x%08x [Attrib: %s  ERAttTok: 0x%08x  XVAAttTok: 0x%08x]"
; 1728 :                             "  RelDataField: %s 0x%08x [Attrib: %s  ERAttTok: 0x%08x  XVAAttTok: 0x%08x]",
; 1729 :                           szIndent, lpRelField->szFldName,
; 1730 :                           lpViewAttrib ? lpViewAttrib->szName : "<null>",
; 1731 :                           lpViewAttrib ? lpViewAttrib->lERAttTok : 0,
; 1732 :                           lpViewAttrib ? lpViewAttrib->lXVAAttTok : 0,
; 1733 :                           lpDataField->szFldName,
; 1734 :                           lpDataField->lFldID,
; 1735 :                           lpViewAttrib1 ? lpViewAttrib1->szName : "<null>",
; 1736 :                           lpViewAttrib1 ? lpViewAttrib1->lERAttTok : 0,
; 1737 :                           lpViewAttrib1 ? lpViewAttrib1->lXVAAttTok : 0,
; 1738 :                           lpDataField2->szFldName,
; 1739 :                           lpDataField2->lFldID,
; 1740 :                           lpViewAttrib2 ? lpViewAttrib2->szName : "<null>",
; 1741 :                           lpViewAttrib2 ? lpViewAttrib2->lERAttTok : 0,
; 1742 :                           lpViewAttrib2 ? lpViewAttrib2->lXVAAttTok : 0 );
; 1743 : 
; 1744 :                lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax

; 1745 :             }

	jmp	$LN10@DisplayObj
$LN11@DisplayObj:

; 1746 : 
; 1747 :             lpRelRecord = zGETPTR( lpRelRecord->hNextRelRecord );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 1748 :          }

	jmp	$LN8@DisplayObj
$LN9@DisplayObj:

; 1749 : 
; 1750 :          lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN12@DisplayObj:

; 1751 :          while ( lpDataField )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN13@DisplayObj

; 1752 :          {
; 1753 :             lpViewAttrib = zGETPTR( lpDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1754 :             TraceLine( "%s    df%s  FldID: 0x%08x  [Attrib Name: %s  ERAttTok: 0x%08x  XVAAttTok: 0x%08x]",

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+181]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+177]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	edx, DWORD PTR [ecx+266]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szIndent$[ebp]
	push	ecx
	push	OFFSET $SG14834
	call	_TraceLine
	add	esp, 28					; 0000001cH

; 1755 :                        szIndent, lpDataField->szFldName,
; 1756 :                        lpDataField->lFldID,
; 1757 :                        lpViewAttrib->szName,
; 1758 :                        lpViewAttrib->lERAttTok,
; 1759 :                        lpViewAttrib->lXVAAttTok );
; 1760 : 
; 1761 :             lpDataField = zGETPTR( lpDataField->hNextDataField );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField$[ebp], eax

; 1762 :          }

	jmp	$LN12@DisplayObj
$LN13@DisplayObj:

; 1763 : 
; 1764 :          lpDataRecord = zGETPTR( lpDataRecord->hNextDataRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 1765 :       }

	jmp	$LN6@DisplayObj
$LN7@DisplayObj:

; 1766 : 
; 1767 :       lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1768 :    }

	jmp	$LN2@DisplayObj
$LN3@DisplayObj:

; 1769 : 
; 1770 :    TraceLineS( "", "" );

	push	OFFSET $SG14835
	push	OFFSET $SG14836
	call	_TraceLineS@8
$LN15@DisplayObj:

; 1771 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_DisplayObjectDefinition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpApp$ = -24						; size = 4
_hViewOD$ = -20						; size = 4
_lpTask$ = -16						; size = 4
_lpView$ = -12						; size = 4
_nRC$ = -8						; size = 2
_bBrowseStarted$ = -1					; size = 1
_zView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_fnCheckIfViewOD_IsUsed@8 PROC

; 1604 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1605 :    LPTASK   lpTask;
; 1606 :    zVIEW    lpView;
; 1607 :    LPAPP    lpApp   = zGETPTR( lpViewOD->hApp );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 1608 :    LPVIEWOD hViewOD = zGETHNDL( lpViewOD );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewOD$[ebp], eax

; 1609 :    zBOOL    bBrowseStarted = FALSE;

	mov	BYTE PTR _bBrowseStarted$[ebp], 0

; 1610 :    zSHORT   nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 1611 : 
; 1612 :    // Go through the app and make sure there are no views referencing lpViewOD.
; 1613 :    for ( lpView = zGETPTR( lpApp->hFirstView );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1889]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax
	jmp	SHORT $LN4@fnCheckIfV
$LN2@fnCheckIfV:

; 1615 :          lpView = zGETPTR( lpView->hNextView ) )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax
$LN4@fnCheckIfV:

; 1614 :          lpView;

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN3@fnCheckIfV

; 1616 :    {
; 1617 :       if ( lpView->hViewOD == hViewOD )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	cmp	eax, DWORD PTR _hViewOD$[ebp]
	jne	SHORT $LN11@fnCheckIfV

; 1618 :          goto EndOfFunction;

	jmp	$EndOfFunction$15
$LN11@fnCheckIfV:

; 1619 :    }

	jmp	SHORT $LN2@fnCheckIfV
$LN3@fnCheckIfV:

; 1620 : 
; 1621 :    fnStartBrowseOfTaskList( zView->hTask, FALSE );

	push	0
	mov	ecx, DWORD PTR _zView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	_fnStartBrowseOfTaskList@8

; 1622 :    bBrowseStarted = TRUE;

	mov	BYTE PTR _bBrowseStarted$[ebp], 1

; 1623 : 
; 1624 :    for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN7@fnCheckIfV
$LN5@fnCheckIfV:

; 1626 :          lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN7@fnCheckIfV:

; 1625 :          lpTask;

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN6@fnCheckIfV

; 1627 :    {
; 1628 :       for ( lpView = zGETPTR( lpTask->hFirstView );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax
	jmp	SHORT $LN10@fnCheckIfV
$LN8@fnCheckIfV:

; 1630 :             lpView = zGETPTR( lpView->hNextView ) )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax
$LN10@fnCheckIfV:

; 1629 :             lpView;

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN9@fnCheckIfV

; 1631 :       {
; 1632 :          if ( lpView->hViewOD == hViewOD )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	cmp	eax, DWORD PTR _hViewOD$[ebp]
	jne	SHORT $LN12@fnCheckIfV

; 1633 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$15
$LN12@fnCheckIfV:

; 1634 :       }

	jmp	SHORT $LN8@fnCheckIfV
$LN9@fnCheckIfV:

; 1635 :    }

	jmp	SHORT $LN5@fnCheckIfV
$LN6@fnCheckIfV:

; 1636 : 
; 1637 :    // If we get here then everything's OK.
; 1638 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$EndOfFunction$15:

; 1639 : 
; 1640 : EndOfFunction:
; 1641 :    if ( bBrowseStarted )

	movzx	edx, BYTE PTR _bBrowseStarted$[ebp]
	test	edx, edx
	je	SHORT $LN13@fnCheckIfV

; 1642 :       fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4
$LN13@fnCheckIfV:

; 1643 : 
; 1644 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 1645 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnCheckIfViewOD_IsUsed@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpTask$1 = -64						; size = 4
_lSearchTok$2 = -60					; size = 4
_lpViewAttrib$3 = -56					; size = 4
_lpFirstDataRecord$4 = -52				; size = 4
tv179 = -48						; size = 4
tv178 = -44						; size = 4
tv142 = -40						; size = 4
tv141 = -36						; size = 4
tv129 = -32						; size = 4
tv128 = -28						; size = 4
tv80 = -24						; size = 4
tv79 = -20						; size = 4
tv68 = -16						; size = 4
_lpSearchViewEntity$5 = -12				; size = 4
_lpSearchDataField$6 = -8				; size = 4
_pchAttrName$ = -4					; size = 4
_lpViewOD$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpDataRecord$ = 16					; size = 4
_lpRelRecord$ = 20					; size = 4
_lpRelField$ = 24					; size = 4
_lpProcessInfo$ = 28					; size = 4
_fnProcessRelFieldEntity PROC

; 1512 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1513 :    zPCHAR pchAttrName;
; 1514 : 
; 1515 :    pchAttrName = lpProcessInfo->szAttrName;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 8
	mov	DWORD PTR _pchAttrName$[ebp], eax

; 1516 :    switch ( pchAttrName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR tv68[ebp], cl
	cmp	BYTE PTR tv68[ebp], 70			; 00000046H
	je	SHORT $LN9@fnProcessR
	cmp	BYTE PTR tv68[ebp], 81			; 00000051H
	jle	$LN2@fnProcessR
	cmp	BYTE PTR tv68[ebp], 83			; 00000053H
	jle	SHORT $LN11@fnProcessR
	jmp	$LN2@fnProcessR
$LN9@fnProcessR:

; 1517 :    {
; 1518 :       // Rel Field attributes beginning with 'F'
; 1519 :       case 'F':
; 1520 :          if ( zstrcmp( pchAttrName, szlFLDNAME ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDNAME
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN24@fnProcessR
	mov	eax, DWORD PTR _szlFLDNAME
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN25@fnProcessR
$LN24@fnProcessR:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDNAME
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN22@fnProcessR
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN23@fnProcessR
$LN22@fnProcessR:
	mov	DWORD PTR tv79[ebp], -1
$LN23@fnProcessR:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], eax
$LN25@fnProcessR:
	cmp	DWORD PTR tv80[ebp], 0
	jne	SHORT $LN10@fnProcessR

; 1521 :             zstrcpy( lpRelField->szFldName, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpRelField$[ebp]
	add	eax, 18					; 00000012H
	push	eax
	call	_strcpy
	add	esp, 8
$LN10@fnProcessR:

; 1522 : 
; 1523 :          break;

	jmp	$LN2@fnProcessR
$LN11@fnProcessR:

; 1524 : 
; 1525 :       // Rel Field attributes beginning with 'R' or 'S'
; 1526 :       case 'R':
; 1527 :       case 'S':
; 1528 :          if ( zstrcmp( pchAttrName, szlRELXVAATT_TOK ) == 0 ||

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlRELXVAATT_TOK
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN28@fnProcessR
	mov	edx, DWORD PTR _szlRELXVAATT_TOK
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN29@fnProcessR
$LN28@fnProcessR:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlRELXVAATT_TOK
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN26@fnProcessR
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN27@fnProcessR
$LN26@fnProcessR:
	mov	DWORD PTR tv128[ebp], -1
$LN27@fnProcessR:
	mov	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv129[ebp], edx
$LN29@fnProcessR:
	cmp	DWORD PTR tv129[ebp], 0
	je	SHORT $LN13@fnProcessR
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlSRCXVAATT_TOK
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN32@fnProcessR
	mov	ecx, DWORD PTR _szlSRCXVAATT_TOK
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv142[ebp], eax
	jmp	SHORT $LN33@fnProcessR
$LN32@fnProcessR:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlSRCXVAATT_TOK
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN30@fnProcessR
	mov	DWORD PTR tv141[ebp], 1
	jmp	SHORT $LN31@fnProcessR
$LN30@fnProcessR:
	mov	DWORD PTR tv141[ebp], -1
$LN31@fnProcessR:
	mov	ecx, DWORD PTR tv141[ebp]
	mov	DWORD PTR tv142[ebp], ecx
$LN33@fnProcessR:
	cmp	DWORD PTR tv142[ebp], 0
	jne	$LN2@fnProcessR
$LN13@fnProcessR:

; 1529 :               zstrcmp( pchAttrName, szlSRCXVAATT_TOK ) == 0 )
; 1530 :          {
; 1531 :             LPVIEWENTITY  lpSearchViewEntity;
; 1532 :             LPDATAFIELD   lpSearchDataField;
; 1533 :             LPDATARECORD  lpFirstDataRecord;
; 1534 :             LPVIEWATTRIB  lpViewAttrib;
; 1535 :             zLONG         lSearchTok;
; 1536 : 
; 1537 :             // Get Token value to search for.
; 1538 :             lSearchTok = zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lSearchTok$2[ebp], eax

; 1539 : 
; 1540 :             // Search through the Current Entity and Entities up the
; 1541 :             // parent chain to find the data field corresponding to the
; 1542 :             // view attribute matching the xva token.
; 1543 :             lpSearchViewEntity = lpViewEntity;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpSearchViewEntity$5[ebp], ecx
$LN4@fnProcessR:

; 1544 :             while ( lpSearchViewEntity )

	cmp	DWORD PTR _lpSearchViewEntity$5[ebp], 0
	je	SHORT $LN5@fnProcessR

; 1545 :             {
; 1546 :                lpFirstDataRecord = zGETPTR( lpSearchViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpSearchViewEntity$5[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstDataRecord$4[ebp], eax

; 1547 :                for ( lpSearchDataField =

	mov	ecx, DWORD PTR _lpFirstDataRecord$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchDataField$6[ebp], eax
	jmp	SHORT $LN8@fnProcessR
$LN6@fnProcessR:

; 1550 :                      lpSearchDataField =

	mov	eax, DWORD PTR _lpSearchDataField$6[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchDataField$6[ebp], eax
$LN8@fnProcessR:

; 1548 :                            zGETPTR( lpFirstDataRecord->hFirstDataField );
; 1549 :                      lpSearchDataField;

	cmp	DWORD PTR _lpSearchDataField$6[ebp], 0
	je	SHORT $LN7@fnProcessR

; 1551 :                            zGETPTR( lpSearchDataField->hNextDataField ) )
; 1552 :                {
; 1553 :                   lpViewAttrib = zGETPTR( lpSearchDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpSearchDataField$6[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$3[ebp], eax

; 1554 :                   if ( lpViewAttrib->lXVAAttTok == lSearchTok )

	mov	ecx, DWORD PTR _lpViewAttrib$3[ebp]
	mov	edx, DWORD PTR [ecx+181]
	cmp	edx, DWORD PTR _lSearchTok$2[ebp]
	jne	SHORT $LN14@fnProcessR

; 1555 :                      break;

	jmp	SHORT $LN7@fnProcessR
$LN14@fnProcessR:

; 1556 :                }

	jmp	SHORT $LN6@fnProcessR
$LN7@fnProcessR:

; 1557 : 
; 1558 :                if ( lpSearchDataField )

	cmp	DWORD PTR _lpSearchDataField$6[ebp], 0
	je	SHORT $LN15@fnProcessR

; 1559 :                   break;

	jmp	SHORT $LN5@fnProcessR
$LN15@fnProcessR:

; 1560 : 
; 1561 :                lpSearchViewEntity = zGETPTR( lpSearchViewEntity->hParent );

	mov	eax, DWORD PTR _lpSearchViewEntity$5[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$5[ebp], eax

; 1562 :             }

	jmp	SHORT $LN4@fnProcessR
$LN5@fnProcessR:

; 1563 : 
; 1564 :             if ( lpSearchDataField )

	cmp	DWORD PTR _lpSearchDataField$6[ebp], 0
	je	SHORT $LN16@fnProcessR

; 1565 :             {
; 1566 :                if ( zstrcmp( pchAttrName, szlRELXVAATT_TOK ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRELXVAATT_TOK
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN36@fnProcessR
	mov	eax, DWORD PTR _szlRELXVAATT_TOK
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv179[ebp], eax
	jmp	SHORT $LN37@fnProcessR
$LN36@fnProcessR:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRELXVAATT_TOK
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN34@fnProcessR
	mov	DWORD PTR tv178[ebp], 1
	jmp	SHORT $LN35@fnProcessR
$LN34@fnProcessR:
	mov	DWORD PTR tv178[ebp], -1
$LN35@fnProcessR:
	mov	eax, DWORD PTR tv178[ebp]
	mov	DWORD PTR tv179[ebp], eax
$LN37@fnProcessR:
	cmp	DWORD PTR tv179[ebp], 0
	jne	SHORT $LN18@fnProcessR

; 1567 :                   lpRelField->hRelDataField = zGETHNDL( lpSearchDataField );

	mov	ecx, DWORD PTR _lpSearchDataField$6[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	DWORD PTR [edx+14], eax
	jmp	SHORT $LN19@fnProcessR
$LN18@fnProcessR:

; 1568 :                else
; 1569 :                   lpRelField->hSrcDataField = zGETHNDL( lpSearchDataField );

	mov	eax, DWORD PTR _lpSearchDataField$6[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	DWORD PTR [ecx+10], eax
$LN19@fnProcessR:

; 1570 :             }

	jmp	SHORT $LN2@fnProcessR
$LN16@fnProcessR:

; 1571 :             else
; 1572 :             {
; 1573 :                LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+322]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 1574 :                // If the attribute was not found, issue Error
; 1575 :                // "KZOEE059 - Invalid file, Invalid Attribute
; 1576 :                //             Token located on line "
; 1577 :                fnIssueCoreError( lpTask, lpProcessInfo->lpView, 16, 59,

	push	0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	add	edx, 41					; 00000029H
	push	edx
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+298]
	push	ecx
	push	59					; 0000003bH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+322]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN2@fnProcessR:

; 1578 :                                  lpProcessInfo->lLine,
; 1579 :                                  lpProcessInfo->szFileName, 0 );
; 1580 :             }
; 1581 :          }
; 1582 : 
; 1583 :          break;
; 1584 : 
; 1585 :       default:
; 1586 :          break;
; 1587 : 
; 1588 :    }   // End Rel Field Attribute switch
; 1589 : 
; 1590 :    return( 0 );

	xor	eax, eax

; 1591 : } // fnProcessRelFieldEntity

	mov	esp, ebp
	pop	ebp
	ret	0
_fnProcessRelFieldEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
tv214 = -64						; size = 4
tv213 = -60						; size = 4
tv197 = -56						; size = 4
tv196 = -52						; size = 4
tv180 = -48						; size = 4
tv179 = -44						; size = 4
tv163 = -40						; size = 4
tv162 = -36						; size = 4
tv146 = -32						; size = 4
tv145 = -28						; size = 4
tv129 = -24						; size = 4
tv128 = -20						; size = 4
tv80 = -16						; size = 4
tv79 = -12						; size = 4
tv68 = -8						; size = 4
_pchAttrName$ = -4					; size = 4
_lpViewOD$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpDataRecord$ = 16					; size = 4
_lpRelRecord$ = 20					; size = 4
_lpProcessInfo$ = 24					; size = 4
_fnProcessRelRecordEntity PROC

; 1447 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1448 :    zPCHAR pchAttrName;
; 1449 : 
; 1450 :    pchAttrName = lpProcessInfo->szAttrName;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 8
	mov	DWORD PTR _pchAttrName$[ebp], eax

; 1451 :    switch ( pchAttrName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR tv68[ebp], cl
	cmp	BYTE PTR tv68[ebp], 79			; 0000004fH
	je	SHORT $LN4@fnProcessR
	cmp	BYTE PTR tv68[ebp], 82			; 00000052H
	je	$LN6@fnProcessR
	cmp	BYTE PTR tv68[ebp], 83			; 00000053H
	je	$LN10@fnProcessR
	jmp	$LN2@fnProcessR
$LN4@fnProcessR:

; 1452 :    {
; 1453 :       // Rel Record attributes beginning with 'O'
; 1454 :       case 'O':
; 1455 :          if ( zstrcmp( pchAttrName, szlOWNER_MEMB ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlOWNER_MEMB
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN22@fnProcessR
	mov	eax, DWORD PTR _szlOWNER_MEMB
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN23@fnProcessR
$LN22@fnProcessR:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlOWNER_MEMB
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN20@fnProcessR
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN21@fnProcessR
$LN20@fnProcessR:
	mov	DWORD PTR tv79[ebp], -1
$LN21@fnProcessR:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], eax
$LN23@fnProcessR:
	cmp	DWORD PTR tv80[ebp], 0
	jne	SHORT $LN5@fnProcessR

; 1456 :             lpRelRecord->cOwnerMember = lpProcessInfo->szLine[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR [eax+10], cl
$LN5@fnProcessR:

; 1457 : 
; 1458 :          break;

	jmp	$LN2@fnProcessR
$LN6@fnProcessR:

; 1459 : 
; 1460 :       // Rel Record attributes beginning with 'R'
; 1461 :       case 'R':
; 1462 :          if ( zstrcmp( pchAttrName, szlRECID ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECID
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN26@fnProcessR
	mov	eax, DWORD PTR _szlRECID
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN27@fnProcessR
$LN26@fnProcessR:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECID
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN24@fnProcessR
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN25@fnProcessR
$LN24@fnProcessR:
	mov	DWORD PTR tv128[ebp], -1
$LN25@fnProcessR:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv129[ebp], eax
$LN27@fnProcessR:
	cmp	DWORD PTR tv129[ebp], 0
	jne	SHORT $LN7@fnProcessR

; 1463 :             lpRelRecord->lRecordID = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	DWORD PTR [ecx+267], eax
	jmp	SHORT $LN8@fnProcessR
$LN7@fnProcessR:

; 1464 :          else
; 1465 :          if ( zstrcmp( pchAttrName, szlRECNAME ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECNAME
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN30@fnProcessR
	mov	eax, DWORD PTR _szlRECNAME
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN31@fnProcessR
$LN30@fnProcessR:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECNAME
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN28@fnProcessR
	mov	DWORD PTR tv145[ebp], 1
	jmp	SHORT $LN29@fnProcessR
$LN28@fnProcessR:
	mov	DWORD PTR tv145[ebp], -1
$LN29@fnProcessR:
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv146[ebp], eax
$LN31@fnProcessR:
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $LN8@fnProcessR

; 1466 :             zstrcpy( lpRelRecord->szRecordName, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	_strcpy
	add	esp, 8
$LN8@fnProcessR:

; 1467 : 
; 1468 :          break;

	jmp	$LN2@fnProcessR
$LN10@fnProcessR:

; 1469 : 
; 1470 :       // Rel Record attributes beginning with 'S'
; 1471 :       case 'S':
; 1472 :          if ( zstrcmp( pchAttrName, szlSETID1 ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlSETID1
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN34@fnProcessR
	mov	edx, DWORD PTR _szlSETID1
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN35@fnProcessR
$LN34@fnProcessR:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlSETID1
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN32@fnProcessR
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN33@fnProcessR
$LN32@fnProcessR:
	mov	DWORD PTR tv162[ebp], -1
$LN33@fnProcessR:
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR tv163[ebp], edx
$LN35@fnProcessR:
	cmp	DWORD PTR tv163[ebp], 0
	jne	SHORT $LN11@fnProcessR

; 1473 :             lpRelRecord->lSetID1 = zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	DWORD PTR [edx+527], eax
	jmp	$LN2@fnProcessR
$LN11@fnProcessR:

; 1474 :          else
; 1475 :          if ( zstrcmp( pchAttrName, szlSETID2 ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlSETID2
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN38@fnProcessR
	mov	ecx, DWORD PTR _szlSETID2
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv180[ebp], eax
	jmp	SHORT $LN39@fnProcessR
$LN38@fnProcessR:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlSETID2
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN36@fnProcessR
	mov	DWORD PTR tv179[ebp], 1
	jmp	SHORT $LN37@fnProcessR
$LN36@fnProcessR:
	mov	DWORD PTR tv179[ebp], -1
$LN37@fnProcessR:
	mov	ecx, DWORD PTR tv179[ebp]
	mov	DWORD PTR tv180[ebp], ecx
$LN39@fnProcessR:
	cmp	DWORD PTR tv180[ebp], 0
	jne	SHORT $LN13@fnProcessR

; 1476 :             lpRelRecord->lSetID2 = zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	DWORD PTR [ecx+787], eax
	jmp	$LN2@fnProcessR
$LN13@fnProcessR:

; 1477 :          else
; 1478 :          if ( zstrcmp( pchAttrName, szlSETNAME1 ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlSETNAME1
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN42@fnProcessR
	mov	eax, DWORD PTR _szlSETNAME1
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv197[ebp], eax
	jmp	SHORT $LN43@fnProcessR
$LN42@fnProcessR:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlSETNAME1
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN40@fnProcessR
	mov	DWORD PTR tv196[ebp], 1
	jmp	SHORT $LN41@fnProcessR
$LN40@fnProcessR:
	mov	DWORD PTR tv196[ebp], -1
$LN41@fnProcessR:
	mov	eax, DWORD PTR tv196[ebp]
	mov	DWORD PTR tv197[ebp], eax
$LN43@fnProcessR:
	cmp	DWORD PTR tv197[ebp], 0
	jne	SHORT $LN15@fnProcessR

; 1479 :             zstrcpy( lpRelRecord->szSetName1, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 271				; 0000010fH
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN2@fnProcessR
$LN15@fnProcessR:

; 1480 :          else
; 1481 :          if ( zstrcmp( pchAttrName, szlSETNAME2 ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlSETNAME2
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN46@fnProcessR
	mov	edx, DWORD PTR _szlSETNAME2
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN47@fnProcessR
$LN46@fnProcessR:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlSETNAME2
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN44@fnProcessR
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN45@fnProcessR
$LN44@fnProcessR:
	mov	DWORD PTR tv213[ebp], -1
$LN45@fnProcessR:
	mov	edx, DWORD PTR tv213[ebp]
	mov	DWORD PTR tv214[ebp], edx
$LN47@fnProcessR:
	cmp	DWORD PTR tv214[ebp], 0
	jne	SHORT $LN2@fnProcessR

; 1482 :             zstrcpy( lpRelRecord->szSetName2, lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	add	edx, 531				; 00000213H
	push	edx
	call	_strcpy
	add	esp, 8
$LN2@fnProcessR:

; 1483 :          break;
; 1484 : 
; 1485 :       default:
; 1486 :          break;
; 1487 : 
; 1488 :    }   // End Rel Record Attribute switch
; 1489 : 
; 1490 :    return( 0 );

	xor	eax, eax

; 1491 : } // fnProcessRelRecordEntity

	mov	esp, ebp
	pop	ebp
	ret	0
_fnProcessRelRecordEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpTask$1 = -68						; size = 4
_lSearchTok$2 = -64					; size = 4
tv199 = -60						; size = 4
tv198 = -56						; size = 4
tv182 = -52						; size = 4
tv181 = -48						; size = 4
tv164 = -44						; size = 4
tv163 = -40						; size = 4
tv147 = -36						; size = 4
tv146 = -32						; size = 4
tv129 = -28						; size = 4
tv128 = -24						; size = 4
tv80 = -20						; size = 4
tv79 = -16						; size = 4
tv68 = -12						; size = 4
_lpSearchViewAttrib$3 = -8				; size = 4
_pchAttrName$ = -4					; size = 4
_lpViewOD$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpDataRecord$ = 16					; size = 4
_lpDataField$ = 20					; size = 4
_lpProcessInfo$ = 24					; size = 4
_fnProcessDataFieldEntity PROC

; 1359 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H

; 1360 :    zPCHAR pchAttrName;
; 1361 : 
; 1362 :    pchAttrName = lpProcessInfo->szAttrName;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 8
	mov	DWORD PTR _pchAttrName$[ebp], eax

; 1363 :    switch ( pchAttrName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR tv68[ebp], cl
	cmp	BYTE PTR tv68[ebp], 70			; 00000046H
	je	SHORT $LN7@fnProcessD
	cmp	BYTE PTR tv68[ebp], 88			; 00000058H
	je	$LN17@fnProcessD
	jmp	$LN2@fnProcessD
$LN7@fnProcessD:

; 1364 :    {
; 1365 :       // Data Field attributes beginning with 'F'
; 1366 :       case 'F':
; 1367 :          if ( zstrcmp( pchAttrName, szlFLDID ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDID
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN26@fnProcessD
	mov	eax, DWORD PTR _szlFLDID
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN27@fnProcessD
$LN26@fnProcessD:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDID
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN24@fnProcessD
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN25@fnProcessD
$LN24@fnProcessD:
	mov	DWORD PTR tv79[ebp], -1
$LN25@fnProcessD:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], eax
$LN27@fnProcessD:
	cmp	DWORD PTR tv80[ebp], 0
	jne	SHORT $LN8@fnProcessD

; 1368 :             lpDataField->lFldID = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR [ecx+266], eax
	jmp	$LN9@fnProcessD
$LN8@fnProcessD:

; 1369 :          else
; 1370 :          if ( zstrcmp( pchAttrName, szlFLDLTH ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDLTH
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN30@fnProcessD
	mov	eax, DWORD PTR _szlFLDLTH
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN31@fnProcessD
$LN30@fnProcessD:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDLTH
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN28@fnProcessD
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN29@fnProcessD
$LN28@fnProcessD:
	mov	DWORD PTR tv128[ebp], -1
$LN29@fnProcessD:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv129[ebp], eax
$LN31@fnProcessD:
	cmp	DWORD PTR tv129[ebp], 0
	jne	SHORT $LN10@fnProcessD

; 1371 :             lpDataField->uFldLth = ( zUSHORT ) zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	WORD PTR [ecx+271], ax
	jmp	$LN9@fnProcessD
$LN10@fnProcessD:

; 1372 :          else
; 1373 :          if ( zstrcmp( pchAttrName, szlFLDNAME ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDNAME
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN34@fnProcessD
	mov	eax, DWORD PTR _szlFLDNAME
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv147[ebp], eax
	jmp	SHORT $LN35@fnProcessD
$LN34@fnProcessD:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFLDNAME
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN32@fnProcessD
	mov	DWORD PTR tv146[ebp], 1
	jmp	SHORT $LN33@fnProcessD
$LN32@fnProcessD:
	mov	DWORD PTR tv146[ebp], -1
$LN33@fnProcessD:
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR tv147[ebp], eax
$LN35@fnProcessD:
	cmp	DWORD PTR tv147[ebp], 0
	jne	SHORT $LN12@fnProcessD

; 1374 :             zstrcpy( lpDataField->szFldName, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	$LN9@fnProcessD
$LN12@fnProcessD:

; 1375 :          else
; 1376 :          if ( zstrcmp( pchAttrName, szlFLDOFFSET ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlFLDOFFSET
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN38@fnProcessD
	mov	edx, DWORD PTR _szlFLDOFFSET
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv164[ebp], eax
	jmp	SHORT $LN39@fnProcessD
$LN38@fnProcessD:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlFLDOFFSET
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN36@fnProcessD
	mov	DWORD PTR tv163[ebp], 1
	jmp	SHORT $LN37@fnProcessD
$LN36@fnProcessD:
	mov	DWORD PTR tv163[ebp], -1
$LN37@fnProcessD:
	mov	edx, DWORD PTR tv163[ebp]
	mov	DWORD PTR tv164[ebp], edx
$LN39@fnProcessD:
	cmp	DWORD PTR tv164[ebp], 0
	jne	SHORT $LN14@fnProcessD

; 1377 :             lpDataField->uFldOffset = (zUSHORT) zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	WORD PTR [edx+273], ax
	jmp	SHORT $LN9@fnProcessD
$LN14@fnProcessD:

; 1378 :          else
; 1379 :          if ( zstrcmp( pchAttrName, szlFLDTYPE ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlFLDTYPE
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN42@fnProcessD
	mov	ecx, DWORD PTR _szlFLDTYPE
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv182[ebp], eax
	jmp	SHORT $LN43@fnProcessD
$LN42@fnProcessD:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlFLDTYPE
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN40@fnProcessD
	mov	DWORD PTR tv181[ebp], 1
	jmp	SHORT $LN41@fnProcessD
$LN40@fnProcessD:
	mov	DWORD PTR tv181[ebp], -1
$LN41@fnProcessD:
	mov	ecx, DWORD PTR tv181[ebp]
	mov	DWORD PTR tv182[ebp], ecx
$LN43@fnProcessD:
	cmp	DWORD PTR tv182[ebp], 0
	jne	SHORT $LN9@fnProcessD

; 1380 :             lpDataField->cFldType = lpProcessInfo->szLine[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _lpDataField$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR [ecx+270], dl
$LN9@fnProcessD:

; 1381 : 
; 1382 :          break;

	jmp	$LN2@fnProcessD
$LN17@fnProcessD:

; 1383 : 
; 1384 :       // Data Field attributes beginning with 'X'
; 1385 :       case 'X':
; 1386 :          if ( zstrcmp( pchAttrName, szlXVAATT_TOK ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlXVAATT_TOK
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN46@fnProcessD
	mov	ecx, DWORD PTR _szlXVAATT_TOK
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv199[ebp], eax
	jmp	SHORT $LN47@fnProcessD
$LN46@fnProcessD:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlXVAATT_TOK
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN44@fnProcessD
	mov	DWORD PTR tv198[ebp], 1
	jmp	SHORT $LN45@fnProcessD
$LN44@fnProcessD:
	mov	DWORD PTR tv198[ebp], -1
$LN45@fnProcessD:
	mov	ecx, DWORD PTR tv198[ebp]
	mov	DWORD PTR tv199[ebp], ecx
$LN47@fnProcessD:
	cmp	DWORD PTR tv199[ebp], 0
	jne	$LN2@fnProcessD

; 1387 :          {
; 1388 :             zLONG         lSearchTok;
; 1389 :             LPVIEWATTRIB  lpSearchViewAttrib;
; 1390 : 
; 1391 :             // Get Token value to search for
; 1392 :             lSearchTok = zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lSearchTok$2[ebp], eax

; 1393 : 
; 1394 :             // Search through the Current Entity to find
; 1395 :             // the attribute owning this relationship field
; 1396 :             for ( lpSearchViewAttrib =

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewAttrib$3[ebp], eax
	jmp	SHORT $LN6@fnProcessD
$LN4@fnProcessD:

; 1399 :                   lpSearchViewAttrib =

	mov	eax, DWORD PTR _lpSearchViewAttrib$3[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewAttrib$3[ebp], eax
$LN6@fnProcessD:

; 1397 :                               zGETPTR( lpViewEntity->hFirstOD_Attrib );
; 1398 :                   lpSearchViewAttrib;

	cmp	DWORD PTR _lpSearchViewAttrib$3[ebp], 0
	je	SHORT $LN5@fnProcessD

; 1400 :                               zGETPTR( lpSearchViewAttrib->hNextOD_Attrib ) )
; 1401 :             {
; 1402 :                if ( lpSearchViewAttrib->lXVAAttTok == lSearchTok )

	mov	edx, DWORD PTR _lpSearchViewAttrib$3[ebp]
	mov	eax, DWORD PTR [edx+181]
	cmp	eax, DWORD PTR _lSearchTok$2[ebp]
	jne	SHORT $LN19@fnProcessD

; 1403 :                   break;

	jmp	SHORT $LN5@fnProcessD
$LN19@fnProcessD:

; 1404 :             }

	jmp	SHORT $LN4@fnProcessD
$LN5@fnProcessD:

; 1405 : 
; 1406 :             if ( lpSearchViewAttrib )

	cmp	DWORD PTR _lpSearchViewAttrib$3[ebp], 0
	je	SHORT $LN20@fnProcessD

; 1407 :                lpDataField->hViewAttrib = zGETHNDL( lpSearchViewAttrib );

	mov	ecx, DWORD PTR _lpSearchViewAttrib$3[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR [edx+6], eax
	jmp	SHORT $LN2@fnProcessD
$LN20@fnProcessD:

; 1408 :             else
; 1409 :             {
; 1410 :                LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+322]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 1411 :                // If the attribute was not found, issue Error
; 1412 :                // "KZOEE059 - Invalid file, Invalid Attribute
; 1413 :                //             Token located on line "
; 1414 :                fnIssueCoreError( lpTask, lpProcessInfo->lpView, 16, 59,

	push	0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 41					; 00000029H
	push	eax
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+298]
	push	edx
	push	59					; 0000003bH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+322]
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN2@fnProcessD:

; 1415 :                                  lpProcessInfo->lLine,
; 1416 :                                  lpProcessInfo->szFileName, 0 );
; 1417 :             }
; 1418 :          }
; 1419 :          break;
; 1420 : 
; 1421 :       default:
; 1422 :          break;
; 1423 : 
; 1424 :    }   // End Data Field Attribute switch
; 1425 : 
; 1426 :    return( 0 );

	xor	eax, eax

; 1427 : } // fnProcessDataFieldEntity

	mov	esp, ebp
	pop	ebp
	ret	0
_fnProcessDataFieldEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
tv163 = -40						; size = 4
tv162 = -36						; size = 4
tv146 = -32						; size = 4
tv145 = -28						; size = 4
tv129 = -24						; size = 4
tv128 = -20						; size = 4
tv80 = -16						; size = 4
tv79 = -12						; size = 4
tv68 = -8						; size = 4
_pchAttrName$ = -4					; size = 4
_lpViewOD$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpDataRecord$ = 16					; size = 4
_lpProcessInfo$ = 20					; size = 4
_fnProcessDataRecordEntity PROC

; 1300 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1301 :    zPCHAR pchAttrName;
; 1302 : 
; 1303 :    pchAttrName = lpProcessInfo->szAttrName;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 8
	mov	DWORD PTR _pchAttrName$[ebp], eax

; 1304 :    switch ( pchAttrName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	mov	cl, BYTE PTR [eax+edx]
	mov	BYTE PTR tv68[ebp], cl
	cmp	BYTE PTR tv68[ebp], 74			; 0000004aH
	je	SHORT $LN4@fnProcessD
	cmp	BYTE PTR tv68[ebp], 82			; 00000052H
	je	$LN6@fnProcessD
	cmp	BYTE PTR tv68[ebp], 84			; 00000054H
	je	$LN10@fnProcessD
	jmp	$LN2@fnProcessD
$LN4@fnProcessD:

; 1305 :    {
; 1306 :       // Data Record attributes beginning with 'J'
; 1307 :       case 'J':
; 1308 :          if ( zstrcmp( pchAttrName, "JOIN" ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14498
	cmp	eax, ecx
	jne	SHORT $LN16@fnProcessD
	push	OFFSET $SG14499
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN17@fnProcessD
$LN16@fnProcessD:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14500
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN14@fnProcessD
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN15@fnProcessD
$LN14@fnProcessD:
	mov	DWORD PTR tv79[ebp], -1
$LN15@fnProcessD:
	mov	eax, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], eax
$LN17@fnProcessD:
	cmp	DWORD PTR tv80[ebp], 0
	jne	SHORT $LN5@fnProcessD

; 1309 :             lpDataRecord->cJoin = lpProcessInfo->szLine[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR [eax+275], cl
$LN5@fnProcessD:

; 1310 : 
; 1311 :          break;

	jmp	$LN2@fnProcessD
$LN6@fnProcessD:

; 1312 : 
; 1313 :       // Data Record attributes beginning with 'R'
; 1314 :       case 'R':
; 1315 :          if ( zstrcmp( pchAttrName, szlRECID ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECID
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN20@fnProcessD
	mov	eax, DWORD PTR _szlRECID
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN21@fnProcessD
$LN20@fnProcessD:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECID
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN18@fnProcessD
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN19@fnProcessD
$LN18@fnProcessD:
	mov	DWORD PTR tv128[ebp], -1
$LN19@fnProcessD:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv129[ebp], eax
$LN21@fnProcessD:
	cmp	DWORD PTR tv129[ebp], 0
	jne	SHORT $LN7@fnProcessD

; 1316 :             lpDataRecord->lRecordID = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	DWORD PTR [ecx+271], eax
	jmp	SHORT $LN8@fnProcessD
$LN7@fnProcessD:

; 1317 :          else
; 1318 :          if ( zstrcmp( pchAttrName, szlRECNAME ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECNAME
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN24@fnProcessD
	mov	eax, DWORD PTR _szlRECNAME
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN25@fnProcessD
$LN24@fnProcessD:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlRECNAME
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN22@fnProcessD
	mov	DWORD PTR tv145[ebp], 1
	jmp	SHORT $LN23@fnProcessD
$LN22@fnProcessD:
	mov	DWORD PTR tv145[ebp], -1
$LN23@fnProcessD:
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv146[ebp], eax
$LN25@fnProcessD:
	cmp	DWORD PTR tv146[ebp], 0
	jne	SHORT $LN8@fnProcessD

; 1319 :             zstrcpy( lpDataRecord->szRecordName, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	call	_strcpy
	add	esp, 8
$LN8@fnProcessD:

; 1320 : 
; 1321 :          break;

	jmp	SHORT $LN2@fnProcessD
$LN10@fnProcessD:

; 1322 : 
; 1323 :       // Data Record attributes beginning with 'T'
; 1324 :       case 'T':
; 1325 :          if ( zstrcmp( pchAttrName, szlTYPE ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlTYPE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN28@fnProcessD
	mov	edx, DWORD PTR _szlTYPE
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN29@fnProcessD
$LN28@fnProcessD:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlTYPE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN26@fnProcessD
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN27@fnProcessD
$LN26@fnProcessD:
	mov	DWORD PTR tv162[ebp], -1
$LN27@fnProcessD:
	mov	edx, DWORD PTR tv162[ebp]
	mov	DWORD PTR tv163[ebp], edx
$LN29@fnProcessD:
	cmp	DWORD PTR tv163[ebp], 0
	jne	SHORT $LN2@fnProcessD

; 1326 :          {
; 1327 :             // Type is 'P' primary, 'S' - Secondary
; 1328 :             lpDataRecord->cRecordType = lpProcessInfo->szLine[ 0 ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	mov	al, BYTE PTR [ecx+eax]
	mov	BYTE PTR [edx+14], al
$LN2@fnProcessD:

; 1329 :          }
; 1330 : 
; 1331 :          break;
; 1332 : 
; 1333 :       default:
; 1334 :          break;
; 1335 : 
; 1336 :    }   // End DataRecord Attribute switch
; 1337 : 
; 1338 :    return( 0 );

	xor	eax, eax

; 1339 : } // fnProcessDataRecordEntity

	mov	esp, ebp
	pop	ebp
	ret	0
_fnProcessDataRecordEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpTask$1 = -364					; size = 4
_lpTask$2 = -360					; size = 4
_lpDomain$3 = -356					; size = 4
_lpTask$4 = -352					; size = 4
_lpTask$5 = -348					; size = 4
_ptr$6 = -344						; size = 4
_pch$7 = -340						; size = 4
_lpTask$8 = -336					; size = 4
_lpTask$9 = -332					; size = 4
_lSearchTok$10 = -328					; size = 4
tv894 = -324						; size = 4
tv993 = -320						; size = 4
tv992 = -316						; size = 4
tv944 = -312						; size = 4
tv943 = -308						; size = 4
tv927 = -304						; size = 4
tv926 = -300						; size = 4
tv911 = -296						; size = 4
tv910 = -292						; size = 4
tv895 = -288						; size = 4
tv79 = -284						; size = 4
tv843 = -280						; size = 4
tv842 = -276						; size = 4
tv822 = -272						; size = 4
tv821 = -268						; size = 4
tv776 = -264						; size = 4
tv775 = -260						; size = 4
tv755 = -256						; size = 4
tv754 = -252						; size = 4
tv715 = -248						; size = 4
tv714 = -244						; size = 4
tv698 = -240						; size = 4
tv697 = -236						; size = 4
tv585 = -232						; size = 4
tv584 = -228						; size = 4
tv562 = -224						; size = 4
tv561 = -220						; size = 4
tv540 = -216						; size = 4
tv539 = -212						; size = 4
tv524 = -208						; size = 4
tv523 = -204						; size = 4
tv502 = -200						; size = 4
tv501 = -196						; size = 4
tv486 = -192						; size = 4
tv485 = -188						; size = 4
tv469 = -184						; size = 4
tv468 = -180						; size = 4
tv450 = -176						; size = 4
tv449 = -172						; size = 4
tv400 = -168						; size = 4
tv399 = -164						; size = 4
tv382 = -160						; size = 4
tv381 = -156						; size = 4
tv347 = -152						; size = 4
tv346 = -148						; size = 4
tv330 = -144						; size = 4
tv329 = -140						; size = 4
tv311 = -136						; size = 4
tv310 = -132						; size = 4
tv273 = -128						; size = 4
tv272 = -124						; size = 4
tv257 = -120						; size = 4
tv256 = -116						; size = 4
tv241 = -112						; size = 4
tv240 = -108						; size = 4
tv219 = -104						; size = 4
tv218 = -100						; size = 4
tv80 = -96						; size = 4
_lpHoldAttrib$11 = -92					; size = 4
_lSearchTok$12 = -88					; size = 4
_ulLth$13 = -84						; size = 4
tv614 = -80						; size = 4
tv158 = -76						; size = 4
tv68 = -72						; size = 4
_lpSearchViewEntity$14 = -68				; size = 4
_ulOffsetIncrement$15 = -64				; size = 4
_lpDomain$16 = -60					; size = 4
_bErr$17 = -53						; size = 1
_lpSearchAttrib$18 = -52				; size = 4
_pchAttrName$ = -48					; size = 4
_szTempMsg$19 = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpViewEntity$ = 16					; size = 4
_lpViewAttrib$ = 20					; size = 4
_lpProcessInfo$ = 24					; size = 4
_fnProcessAttribEntity PROC

; 770  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 364				; 0000016cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 771  :    zPCHAR pchAttrName;
; 772  : 
; 773  :    pchAttrName = lpProcessInfo->szAttrName;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 8
	mov	DWORD PTR _pchAttrName$[ebp], eax

; 774  :    switch ( pchAttrName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 65					; 00000041H
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 23			; 00000017H
	ja	$LN2@fnProcessA
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN239@fnProcessA[eax*4]
$LN19@fnProcessA:

; 775  :    {
; 776  :       // Attrib attributes beginning with 'A'
; 777  :       case 'A':
; 778  :          if ( zstrcmp( pchAttrName, szlAPDM_TOK ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlAPDM_TOK
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN123@fnProcessA
	mov	edx, DWORD PTR _szlAPDM_TOK
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN124@fnProcessA
$LN123@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlAPDM_TOK
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN121@fnProcessA
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN122@fnProcessA
$LN121@fnProcessA:
	mov	DWORD PTR tv79[ebp], -1
$LN122@fnProcessA:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], edx
$LN124@fnProcessA:
	cmp	DWORD PTR tv80[ebp], 0
	jne	$LN20@fnProcessA

; 779  :          {
; 780  :             zLONG    lSearchTok;
; 781  :             LPDOMAIN lpDomain;
; 782  : 
; 783  :             if ( lpProcessInfo->bLth || lpProcessInfo->bType )

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+326]
	test	ecx, ecx
	jne	SHORT $LN23@fnProcessA
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	movzx	eax, BYTE PTR [edx+327]
	test	eax, eax
	je	SHORT $LN22@fnProcessA
$LN23@fnProcessA:

; 784  :             {
; 785  :                LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+322]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 786  :                //  "KZOEE055 - Invalid file, LTH or TYPE before DOMAIN on line"
; 787  :                fnIssueCoreError( lpTask, lpView, 16, 55,

	push	0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	add	ecx, 41					; 00000029H
	push	ecx
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+298]
	push	eax
	push	55					; 00000037H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 788  :                                  lpProcessInfo->lLine,
; 789  :                                  lpProcessInfo->szFileName, 0 );
; 790  :                lpProcessInfo->nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [ecx+318], ax

; 791  :                break;

	jmp	$LN2@fnProcessA
$LN22@fnProcessA:

; 792  :             }
; 793  : 
; 794  :             lpProcessInfo->bDomain = TRUE;

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	BYTE PTR [edx+328], 1

; 795  :             lSearchTok = zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lSearchTok$10[ebp], eax

; 796  : 
; 797  :             for ( lpDomain = zGETPTR( lpProcessInfo->lpApp->hFirstDomain );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+306]
	mov	ecx, DWORD PTR [eax+72]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$16[ebp], eax
	jmp	SHORT $LN6@fnProcessA
$LN4@fnProcessA:

; 799  :                   lpDomain = zGETPTR( lpDomain->hNextDomain ) )

	mov	edx, DWORD PTR _lpDomain$16[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$16[ebp], eax
$LN6@fnProcessA:

; 798  :                   lpDomain;

	cmp	DWORD PTR _lpDomain$16[ebp], 0
	je	SHORT $LN5@fnProcessA

; 800  :             {
; 801  :                if ( lpDomain->lApDmTok == lSearchTok )

	mov	ecx, DWORD PTR _lpDomain$16[ebp]
	mov	edx, DWORD PTR [ecx+39]
	cmp	edx, DWORD PTR _lSearchTok$10[ebp]
	jne	SHORT $LN24@fnProcessA

; 802  :                   break;

	jmp	SHORT $LN5@fnProcessA
$LN24@fnProcessA:

; 803  :             }

	jmp	SHORT $LN4@fnProcessA
$LN5@fnProcessA:

; 804  : 
; 805  :             if ( lpDomain )

	cmp	DWORD PTR _lpDomain$16[ebp], 0
	je	$LN25@fnProcessA

; 806  :             {
; 807  :                zBOOL bErr = 0;

	mov	BYTE PTR _bErr$17[ebp], 0

; 808  : 
; 809  :                lpViewAttrib->hDomain = zGETHNDL( lpDomain );

	mov	eax, DWORD PTR _lpDomain$16[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+198], eax

; 810  :                lpViewAttrib->cDecimal = lpDomain->cDecimal;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _lpDomain$16[ebp]
	mov	cl, BYTE PTR [eax+64]
	mov	BYTE PTR [edx+207], cl

; 811  :                lpViewAttrib->cType = lpDomain->cType;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _lpDomain$16[ebp]
	mov	cl, BYTE PTR [eax+63]
	mov	BYTE PTR [edx+202], cl

; 812  :                switch ( lpDomain->cType )

	mov	edx, DWORD PTR _lpDomain$16[ebp]
	movsx	eax, BYTE PTR [edx+63]
	mov	DWORD PTR tv158[ebp], eax
	mov	ecx, DWORD PTR tv158[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv158[ebp], ecx
	cmp	DWORD PTR tv158[ebp], 18		; 00000012H
	ja	$LN34@fnProcessA
	mov	edx, DWORD PTR tv158[ebp]
	movzx	eax, BYTE PTR $LN237@fnProcessA[edx]
	jmp	DWORD PTR $LN240@fnProcessA[eax*4]
$LN27@fnProcessA:

; 813  :                {
; 814  :                   case zTYPE_STRING:
; 815  :                      if ( lpDomain->ulMaxStringLth )

	mov	ecx, DWORD PTR _lpDomain$16[ebp]
	cmp	DWORD PTR [ecx+59], 0
	je	SHORT $LN28@fnProcessA

; 816  :                         lpViewAttrib->ulLth = lpDomain->ulMaxStringLth;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _lpDomain$16[ebp]
	mov	ecx, DWORD PTR [eax+59]
	mov	DWORD PTR [edx+203], ecx
	jmp	SHORT $LN29@fnProcessA
$LN28@fnProcessA:

; 817  :                      else
; 818  :                         lpViewAttrib->ulLth = 254;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+203], 254		; 000000feH
$LN29@fnProcessA:

; 819  : 
; 820  :                      break;

	jmp	$LN7@fnProcessA
$LN30@fnProcessA:

; 821  : 
; 822  :                   case zTYPE_INTEGER:
; 823  :                      lpViewAttrib->ulLth = sizeof( zLONG );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+203], 4

; 824  :                      break;

	jmp	$LN7@fnProcessA
$LN31@fnProcessA:

; 825  : 
; 826  :                   case zTYPE_DECIMAL:
; 827  :                      lpViewAttrib->ulLth = sizeof( zDECIMAL );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+203], 40			; 00000028H

; 828  :                      break;

	jmp	$LN7@fnProcessA
$LN32@fnProcessA:

; 829  : 
; 830  :                   case zTYPE_DATETIME:
; 831  :                      lpViewAttrib->ulLth = sizeof( zLONG ) + sizeof( zSHORT );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+203], 6

; 832  :                      break;

	jmp	SHORT $LN7@fnProcessA
$LN33@fnProcessA:

; 833  : 
; 834  :                   case zTYPE_BLOB:
; 835  :                      lpViewEntity->bContainsBlob = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, -2147483648			; 80000000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx

; 836  : 
; 837  :                      lpViewAttrib->ulLth = sizeof( zPCHAR ) +

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+203], 7

; 838  :                                           sizeof( zSHORT ) + sizeof( zCHAR );
; 839  :                      break;

	jmp	SHORT $LN7@fnProcessA
$LN34@fnProcessA:

; 840  : 
; 841  :                   default:
; 842  :                   {
; 843  :                      LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+322]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$9[ebp], eax

; 844  :                      // "KZOEE246 - Invalid Attribute type "
; 845  :                      fnIssueCoreError( lpTask, lpView, 16, 246, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	246					; 000000f6H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$9[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 846  :                                        lpViewEntity->szName,
; 847  :                                        lpViewAttrib->szName );
; 848  :                      bErr = TRUE;

	mov	BYTE PTR _bErr$17[ebp], 1

; 849  :                      lpProcessInfo->nCurrState = 10;  // set error

	mov	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [eax+318], dx
$LN7@fnProcessA:

; 850  :                      break;
; 851  :                   }
; 852  :                }
; 853  : 
; 854  :                if ( bErr )

	movzx	ecx, BYTE PTR _bErr$17[ebp]
	test	ecx, ecx
	je	SHORT $LN35@fnProcessA

; 855  :                   break;

	jmp	$LN2@fnProcessA
$LN35@fnProcessA:

; 856  :             }

	jmp	SHORT $LN26@fnProcessA
$LN25@fnProcessA:

; 857  :             else
; 858  :             {
; 859  :                // DGC 3-7-96
; 860  :                // The following 'if' was put in so that when testing DBHandlers
; 861  :                // we can tell core to ignore domain errors if the trace level
; 862  :                // is 2 or greater.  The 'if' statement can be taken out if it
; 863  :                // proves to cause problems.
; 864  :                if ( GetTaskDBHandlerTraceLevel( lpProcessInfo->lpView ) < 2 )

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+322]
	push	eax
	call	_GetTaskDBHandlerTraceLevel@4
	movsx	ecx, ax
	cmp	ecx, 2
	jge	SHORT $LN26@fnProcessA

; 865  :                {
; 866  :                   LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+322]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$8[ebp], eax

; 867  :                   //  "KZOEE056 - Domain not found on line "
; 868  :                   fnIssueCoreError( lpTask, lpView, 16, 56,

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	add	edx, 41					; 00000029H
	push	edx
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+298]
	push	eax
	push	56					; 00000038H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$8[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN26@fnProcessA:

; 869  :                                     lpProcessInfo->lLine,
; 870  :                                     lpProcessInfo->szLine,
; 871  :                                     lpProcessInfo->szFileName );
; 872  :                }
; 873  :             }
; 874  :          }

	jmp	$LN21@fnProcessA
$LN20@fnProcessA:

; 875  :          else
; 876  :          if ( zstrcmp( pchAttrName, szlAUTO_SEQ ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlAUTO_SEQ
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN127@fnProcessA
	mov	ecx, DWORD PTR _szlAUTO_SEQ
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv219[ebp], eax
	jmp	SHORT $LN128@fnProcessA
$LN127@fnProcessA:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlAUTO_SEQ
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN125@fnProcessA
	mov	DWORD PTR tv218[ebp], 1
	jmp	SHORT $LN126@fnProcessA
$LN125@fnProcessA:
	mov	DWORD PTR tv218[ebp], -1
$LN126@fnProcessA:
	mov	ecx, DWORD PTR tv218[ebp]
	mov	DWORD PTR tv219[ebp], ecx
$LN128@fnProcessA:
	cmp	DWORD PTR tv219[ebp], 0
	jne	SHORT $LN21@fnProcessA

; 877  :          {
; 878  :             lpViewOD->bAutoSeq = TRUE;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [ecx+240], eax

; 879  :             lpViewEntity->bAutoSeq = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 1048576				; 00100000H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax

; 880  :             lpViewAttrib->bAutoSeq = TRUE;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+193], eax
$LN21@fnProcessA:

; 881  :          }
; 882  : 
; 883  :          break;

	jmp	$LN2@fnProcessA
$LN38@fnProcessA:

; 884  : 
; 885  :       // Attrib attributes beginning with 'C'
; 886  :       case 'C':
; 887  :          if ( zstrcmp( pchAttrName, szlCASESENS ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlCASESENS
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN131@fnProcessA
	mov	eax, DWORD PTR _szlCASESENS
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv241[ebp], eax
	jmp	SHORT $LN132@fnProcessA
$LN131@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlCASESENS
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN129@fnProcessA
	mov	DWORD PTR tv240[ebp], 1
	jmp	SHORT $LN130@fnProcessA
$LN129@fnProcessA:
	mov	DWORD PTR tv240[ebp], -1
$LN130@fnProcessA:
	mov	eax, DWORD PTR tv240[ebp]
	mov	DWORD PTR tv241[ebp], eax
$LN132@fnProcessA:
	cmp	DWORD PTR tv241[ebp], 0
	jne	SHORT $LN39@fnProcessA

; 888  :             lpViewAttrib->bCaseSens = TRUE;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+193], edx
	jmp	SHORT $LN40@fnProcessA
$LN39@fnProcessA:

; 889  :          else
; 890  :          if ( zstrcmp( pchAttrName, szlCR_DATE ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlCR_DATE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN135@fnProcessA
	mov	edx, DWORD PTR _szlCR_DATE
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv257[ebp], eax
	jmp	SHORT $LN136@fnProcessA
$LN135@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlCR_DATE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN133@fnProcessA
	mov	DWORD PTR tv256[ebp], 1
	jmp	SHORT $LN134@fnProcessA
$LN133@fnProcessA:
	mov	DWORD PTR tv256[ebp], -1
$LN134@fnProcessA:
	mov	edx, DWORD PTR tv256[ebp]
	mov	DWORD PTR tv257[ebp], edx
$LN136@fnProcessA:
	cmp	DWORD PTR tv257[ebp], 0
	jne	SHORT $LN40@fnProcessA

; 891  :             lpViewAttrib->bCrDate = TRUE;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+193], ecx
$LN40@fnProcessA:

; 892  : 
; 893  :          break;

	jmp	$LN2@fnProcessA
$LN42@fnProcessA:

; 894  : 
; 895  :       // Attrib attributes beginning with 'D'
; 896  :       case 'D':
; 897  :          if ( zstrcmp( pchAttrName, "DB_OPER" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14359
	cmp	ecx, edx
	jne	SHORT $LN139@fnProcessA
	push	OFFSET $SG14360
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv273[ebp], eax
	jmp	SHORT $LN140@fnProcessA
$LN139@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14361
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN137@fnProcessA
	mov	DWORD PTR tv272[ebp], 1
	jmp	SHORT $LN138@fnProcessA
$LN137@fnProcessA:
	mov	DWORD PTR tv272[ebp], -1
$LN138@fnProcessA:
	mov	ecx, DWORD PTR tv272[ebp]
	mov	DWORD PTR tv273[ebp], ecx
$LN140@fnProcessA:
	cmp	DWORD PTR tv273[ebp], 0
	jne	$LN43@fnProcessA

; 898  :          {
; 899  :             lpViewEntity->bHasDB_Oper = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	or	eax, 1
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+239], eax

; 900  :             lpViewAttrib->cDB_Oper    = lpProcessInfo->szLine[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR [ecx+254], dl

; 901  : 
; 902  :             // If entity contains a db operation, then that entity is read-only.
; 903  :             lpViewEntity->bCreate     =

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx

; 904  :                lpViewEntity->bDelete  =
; 905  :                lpViewEntity->bUpdate  =
; 906  :                lpViewEntity->bInclude =
; 907  :                lpViewEntity->bExclude =
; 908  :                lpViewEntity->bInclSrc = 0;
; 909  :          }

	jmp	$LN44@fnProcessA
$LN43@fnProcessA:

; 910  :          else
; 911  :          if ( zstrcmp( pchAttrName, "DERIVEDE" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14364
	cmp	ecx, edx
	jne	SHORT $LN143@fnProcessA
	push	OFFSET $SG14365
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv311[ebp], eax
	jmp	SHORT $LN144@fnProcessA
$LN143@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14366
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN141@fnProcessA
	mov	DWORD PTR tv310[ebp], 1
	jmp	SHORT $LN142@fnProcessA
$LN141@fnProcessA:
	mov	DWORD PTR tv310[ebp], -1
$LN142@fnProcessA:
	mov	ecx, DWORD PTR tv310[ebp]
	mov	DWORD PTR tv311[ebp], ecx
$LN144@fnProcessA:
	cmp	DWORD PTR tv311[ebp], 0
	jne	SHORT $LN45@fnProcessA

; 912  :          {
; 913  :             lpViewAttrib->hDerivedExpr =

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+246], eax

; 914  :                fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader,
; 915  :                                          lpProcessInfo->szLine );
; 916  :          }

	jmp	$LN44@fnProcessA
$LN45@fnProcessA:

; 917  :          else
; 918  :          if ( zstrcmp( pchAttrName, szlDERIVEDF ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDERIVEDF
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN147@fnProcessA
	mov	eax, DWORD PTR _szlDERIVEDF
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv330[ebp], eax
	jmp	SHORT $LN148@fnProcessA
$LN147@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDERIVEDF
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN145@fnProcessA
	mov	DWORD PTR tv329[ebp], 1
	jmp	SHORT $LN146@fnProcessA
$LN145@fnProcessA:
	mov	DWORD PTR tv329[ebp], -1
$LN146@fnProcessA:
	mov	eax, DWORD PTR tv329[ebp]
	mov	DWORD PTR tv330[ebp], eax
$LN148@fnProcessA:
	cmp	DWORD PTR tv330[ebp], 0
	jne	SHORT $LN47@fnProcessA

; 919  :             zstrcpy( lpViewAttrib->szDerivedOper, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 213				; 000000d5H
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	$LN44@fnProcessA
$LN47@fnProcessA:

; 920  :          else
; 921  :          if ( zstrcmp( pchAttrName, "DERIVEDOPERXPG" ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14371
	cmp	edx, eax
	jne	SHORT $LN151@fnProcessA
	push	OFFSET $SG14372
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv347[ebp], eax
	jmp	SHORT $LN152@fnProcessA
$LN151@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14373
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN149@fnProcessA
	mov	DWORD PTR tv346[ebp], 1
	jmp	SHORT $LN150@fnProcessA
$LN149@fnProcessA:
	mov	DWORD PTR tv346[ebp], -1
$LN150@fnProcessA:
	mov	edx, DWORD PTR tv346[ebp]
	mov	DWORD PTR tv347[ebp], edx
$LN152@fnProcessA:
	cmp	DWORD PTR tv347[ebp], 0
	jne	$LN49@fnProcessA

; 922  :          {
; 923  :             zULONG ulLth;
; 924  :             zPCHAR ptr;
; 925  :             zPCHAR pch;
; 926  : 
; 927  :             ulLth = zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$13[ebp], eax

; 928  :             lpViewAttrib->hDerivedXPG = (zPCHAR)

	push	0
	push	0
	push	1
	mov	edx, DWORD PTR _ulLth$13[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+255], eax

; 929  :                             fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 930  :                                               ulLth, 1, 0, 0 );
; 931  :             ptr = (zPCHAR) zGETPTR( lpViewAttrib->hDerivedXPG );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+255]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _ptr$6[ebp], eax

; 932  :             SysReadLineLth( lpView, &pch, lpProcessInfo->hFile, ulLth );

	mov	edx, DWORD PTR _ulLth$13[ebp]
	push	edx
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	lea	edx, DWORD PTR _pch$7[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysReadLineLth@16

; 933  :             zmemcpy( ptr, pch, ulLth );

	mov	ecx, DWORD PTR _ulLth$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$7[ebp]
	push	edx
	mov	eax, DWORD PTR _ptr$6[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 934  :          }

	jmp	$LN44@fnProcessA
$LN49@fnProcessA:

; 935  :          else
; 936  :          if ( zstrcmp( pchAttrName, "DERIVEDZ" ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14376
	cmp	edx, eax
	jne	SHORT $LN155@fnProcessA
	push	OFFSET $SG14377
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv382[ebp], eax
	jmp	SHORT $LN156@fnProcessA
$LN155@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14378
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN153@fnProcessA
	mov	DWORD PTR tv381[ebp], 1
	jmp	SHORT $LN154@fnProcessA
$LN153@fnProcessA:
	mov	DWORD PTR tv381[ebp], -1
$LN154@fnProcessA:
	mov	edx, DWORD PTR tv381[ebp]
	mov	DWORD PTR tv382[ebp], edx
$LN156@fnProcessA:
	cmp	DWORD PTR tv382[ebp], 0
	jne	SHORT $LN51@fnProcessA

; 937  :             lpViewAttrib->bDerivedIntrnl = TRUE;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+193], ecx
	jmp	$LN44@fnProcessA
$LN51@fnProcessA:

; 938  :          else
; 939  :          if ( lpViewAttrib->hDomain == 0 &&

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	jne	$LN53@fnProcessA
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlDECIMAL
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN159@fnProcessA
	mov	edx, DWORD PTR _szlDECIMAL
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv400[ebp], eax
	jmp	SHORT $LN160@fnProcessA
$LN159@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlDECIMAL
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN157@fnProcessA
	mov	DWORD PTR tv399[ebp], 1
	jmp	SHORT $LN158@fnProcessA
$LN157@fnProcessA:
	mov	DWORD PTR tv399[ebp], -1
$LN158@fnProcessA:
	mov	edx, DWORD PTR tv399[ebp]
	mov	DWORD PTR tv400[ebp], edx
$LN160@fnProcessA:
	cmp	DWORD PTR tv400[ebp], 0
	jne	SHORT $LN53@fnProcessA

; 940  :               zstrcmp( pchAttrName, szlDECIMAL ) == 0 )
; 941  :          {
; 942  :             lpViewAttrib->cDecimal = (zCHAR) zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	BYTE PTR [edx+207], al

; 943  :          }

	jmp	$LN44@fnProcessA
$LN53@fnProcessA:

; 944  :          else
; 945  :          if ( zstrcmp( pchAttrName, "DEBUGCHG" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14382
	cmp	ecx, edx
	jne	SHORT $LN163@fnProcessA
	push	OFFSET $SG14383
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv450[ebp], eax
	jmp	SHORT $LN164@fnProcessA
$LN163@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14384
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN161@fnProcessA
	mov	DWORD PTR tv449[ebp], 1
	jmp	SHORT $LN162@fnProcessA
$LN161@fnProcessA:
	mov	DWORD PTR tv449[ebp], -1
$LN162@fnProcessA:
	mov	ecx, DWORD PTR tv449[ebp]
	mov	DWORD PTR tv450[ebp], ecx
$LN164@fnProcessA:
	cmp	DWORD PTR tv450[ebp], 0
	jne	SHORT $LN44@fnProcessA

; 946  :          {
; 947  :             lpViewEntity->bDebugChange = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	or	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+239], eax

; 948  :             lpViewAttrib->bDebugChange = TRUE;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	or	eax, 16384				; 00004000H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+193], eax
$LN44@fnProcessA:

; 949  :          }
; 950  : 
; 951  :          break;

	jmp	$LN2@fnProcessA
$LN56@fnProcessA:

; 952  : 
; 953  :       // Attrib attributes beginning with 'E'
; 954  :       case 'E':
; 955  :          if ( zstrcmp( pchAttrName, szlERATT_TOK ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlERATT_TOK
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN167@fnProcessA
	mov	eax, DWORD PTR _szlERATT_TOK
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv469[ebp], eax
	jmp	SHORT $LN168@fnProcessA
$LN167@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlERATT_TOK
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN165@fnProcessA
	mov	DWORD PTR tv468[ebp], 1
	jmp	SHORT $LN166@fnProcessA
$LN165@fnProcessA:
	mov	DWORD PTR tv468[ebp], -1
$LN166@fnProcessA:
	mov	eax, DWORD PTR tv468[ebp]
	mov	DWORD PTR tv469[ebp], eax
$LN168@fnProcessA:
	cmp	DWORD PTR tv469[ebp], 0
	jne	SHORT $LN57@fnProcessA

; 956  :             lpViewAttrib->lERAttTok  = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+177], eax
$LN57@fnProcessA:

; 957  : 
; 958  :          break;

	jmp	$LN2@fnProcessA
$LN58@fnProcessA:

; 959  : 
; 960  :       // Attrib attributes beginning with 'F'
; 961  :       case 'F':
; 962  :          if ( zstrcmp( pchAttrName, "FORKEY" ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14389
	cmp	eax, ecx
	jne	SHORT $LN171@fnProcessA
	push	OFFSET $SG14390
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv486[ebp], eax
	jmp	SHORT $LN172@fnProcessA
$LN171@fnProcessA:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14391
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN169@fnProcessA
	mov	DWORD PTR tv485[ebp], 1
	jmp	SHORT $LN170@fnProcessA
$LN169@fnProcessA:
	mov	DWORD PTR tv485[ebp], -1
$LN170@fnProcessA:
	mov	eax, DWORD PTR tv485[ebp]
	mov	DWORD PTR tv486[ebp], eax
$LN172@fnProcessA:
	cmp	DWORD PTR tv486[ebp], 0
	jne	SHORT $LN59@fnProcessA

; 963  :             lpViewAttrib->bForeignKey = TRUE;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	or	edx, 4
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+193], edx
$LN59@fnProcessA:

; 964  : 
; 965  :          break;

	jmp	$LN2@fnProcessA
$LN60@fnProcessA:

; 966  : 
; 967  :       // Attrib attributes beginning with 'G'
; 968  :       case 'G':
; 969  :          if ( zstrcmp( pchAttrName, szlGENKEY ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlGENKEY
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN175@fnProcessA
	mov	edx, DWORD PTR _szlGENKEY
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv502[ebp], eax
	jmp	SHORT $LN176@fnProcessA
$LN175@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlGENKEY
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN173@fnProcessA
	mov	DWORD PTR tv501[ebp], 1
	jmp	SHORT $LN174@fnProcessA
$LN173@fnProcessA:
	mov	DWORD PTR tv501[ebp], -1
$LN174@fnProcessA:
	mov	edx, DWORD PTR tv501[ebp]
	mov	DWORD PTR tv502[ebp], edx
$LN176@fnProcessA:
	cmp	DWORD PTR tv502[ebp], 0
	jne	SHORT $LN61@fnProcessA

; 970  :          {
; 971  :             lpViewAttrib->bGenkey = TRUE;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	or	ecx, 8
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+193], ecx

; 972  :             lpViewEntity->bGenkey = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx

; 973  :             lpViewOD->bGenkey     = TRUE;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [edx+240], ecx
$LN61@fnProcessA:

; 974  :          }
; 975  : 
; 976  :          break;

	jmp	$LN2@fnProcessA
$LN62@fnProcessA:

; 977  : 
; 978  :       // Attrib attributes beginning with 'H'
; 979  :       case 'H':
; 980  :          if ( zstrcmp( pchAttrName, szlHIDDEN ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlHIDDEN
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN179@fnProcessA
	mov	ecx, DWORD PTR _szlHIDDEN
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv524[ebp], eax
	jmp	SHORT $LN180@fnProcessA
$LN179@fnProcessA:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlHIDDEN
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN177@fnProcessA
	mov	DWORD PTR tv523[ebp], 1
	jmp	SHORT $LN178@fnProcessA
$LN177@fnProcessA:
	mov	DWORD PTR tv523[ebp], -1
$LN178@fnProcessA:
	mov	ecx, DWORD PTR tv523[ebp]
	mov	DWORD PTR tv524[ebp], ecx
$LN180@fnProcessA:
	cmp	DWORD PTR tv524[ebp], 0
	jne	SHORT $LN63@fnProcessA

; 981  :          {
; 982  :             lpViewAttrib->bHidden = TRUE;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+193], eax
$LN63@fnProcessA:

; 983  :          }
; 984  : 
; 985  :          break;

	jmp	$LN2@fnProcessA
$LN64@fnProcessA:

; 986  : 
; 987  :       // Attrib attributes beginning with 'I'
; 988  :       case 'I':
; 989  :          if ( zstrcmp( pchAttrName, szlINIT ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlINIT
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN183@fnProcessA
	mov	eax, DWORD PTR _szlINIT
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv540[ebp], eax
	jmp	SHORT $LN184@fnProcessA
$LN183@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlINIT
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN181@fnProcessA
	mov	DWORD PTR tv539[ebp], 1
	jmp	SHORT $LN182@fnProcessA
$LN181@fnProcessA:
	mov	DWORD PTR tv539[ebp], -1
$LN182@fnProcessA:
	mov	eax, DWORD PTR tv539[ebp]
	mov	DWORD PTR tv540[ebp], eax
$LN184@fnProcessA:
	cmp	DWORD PTR tv540[ebp], 0
	jne	SHORT $LN65@fnProcessA

; 990  :          {
; 991  :             lpViewAttrib->hInit = fnStoreStringInDataspace

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+209], eax

; 992  :                   ( AnchorBlock->hMainFirstDataHeader, lpProcessInfo->szLine );
; 993  :             lpViewEntity->bAttrInit = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 131072				; 00020000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
$LN65@fnProcessA:

; 994  :          }
; 995  : 
; 996  :          break;

	jmp	$LN2@fnProcessA
$LN66@fnProcessA:

; 997  : 
; 998  :       // Attrib attributes beginning with 'K'
; 999  :       case 'K':
; 1000 :          if ( zstrcmp( pchAttrName, szlKEY ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlKEY
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN187@fnProcessA
	mov	ecx, DWORD PTR _szlKEY
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv562[ebp], eax
	jmp	SHORT $LN188@fnProcessA
$LN187@fnProcessA:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlKEY
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN185@fnProcessA
	mov	DWORD PTR tv561[ebp], 1
	jmp	SHORT $LN186@fnProcessA
$LN185@fnProcessA:
	mov	DWORD PTR tv561[ebp], -1
$LN186@fnProcessA:
	mov	ecx, DWORD PTR tv561[ebp]
	mov	DWORD PTR tv562[ebp], ecx
$LN188@fnProcessA:
	cmp	DWORD PTR tv562[ebp], 0
	jne	SHORT $LN67@fnProcessA

; 1001 :          {
; 1002 :             lpProcessInfo->nKeyCnt++;   // dks ... 2006.01.25

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	ax, WORD PTR [edx+320]
	add	ax, 1
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [ecx+320], ax

; 1003 :             lpViewAttrib->bKey = TRUE;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	or	eax, 2
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+193], eax

; 1004 :             lpViewAttrib->bNoPersistUpd = TRUE;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	or	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+193], eax
$LN67@fnProcessA:

; 1005 :          }
; 1006 : 
; 1007 :          break;

	jmp	$LN2@fnProcessA
$LN68@fnProcessA:

; 1008 : 
; 1009 :       // Attrib attributes beginning with 'L'
; 1010 :       case 'L':
; 1011 :          if ( zstrcmp( pchAttrName, szlLTH ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlLTH
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN191@fnProcessA
	mov	eax, DWORD PTR _szlLTH
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv585[ebp], eax
	jmp	SHORT $LN192@fnProcessA
$LN191@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlLTH
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN189@fnProcessA
	mov	DWORD PTR tv584[ebp], 1
	jmp	SHORT $LN190@fnProcessA
$LN189@fnProcessA:
	mov	DWORD PTR tv584[ebp], -1
$LN190@fnProcessA:
	mov	eax, DWORD PTR tv584[ebp]
	mov	DWORD PTR tv585[ebp], eax
$LN192@fnProcessA:
	cmp	DWORD PTR tv585[ebp], 0
	jne	$LN69@fnProcessA

; 1012 :          {
; 1013 :             LPVIEWATTRIB lpSearchAttrib;
; 1014 :             LPVIEWATTRIB lpHoldAttrib;
; 1015 :             zLONG        lSearchTok;
; 1016 :             zULONG       ulOffsetIncrement;
; 1017 : 
; 1018 :             if ( lpProcessInfo->bType == FALSE &&

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	movzx	edx, BYTE PTR [ecx+327]
	test	edx, edx
	jne	SHORT $LN70@fnProcessA
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+328]
	test	ecx, ecx
	jne	SHORT $LN70@fnProcessA

; 1019 :                  lpProcessInfo->bDomain == FALSE )
; 1020 :             {
; 1021 :                LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+322]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$5[ebp], eax

; 1022 :                //  "KZOEE057 - Invalid file, LTH before type
; 1023 :                //              and DOMAIN on line "
; 1024 :                fnIssueCoreError( lpTask, lpView, 16, 57,

	push	0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	add	edx, 41					; 00000029H
	push	edx
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+298]
	push	ecx
	push	57					; 00000039H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$5[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1025 :                                  lpProcessInfo->lLine,
; 1026 :                                  lpProcessInfo->szFileName, 0 );
; 1027 :                lpProcessInfo->nCurrState = 10;  // set error

	mov	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [edx+318], cx

; 1028 :                break;

	jmp	$LN2@fnProcessA
$LN70@fnProcessA:

; 1029 :             }
; 1030 : 
; 1031 :             lpProcessInfo->bLth = TRUE;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	BYTE PTR [eax+326], 1

; 1032 :             lpViewAttrib->ulLth = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+203], eax

; 1033 : 
; 1034 :             // We're going to explicitly change the length in some cases.
; 1035 :             switch ( lpViewAttrib->cType )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR tv614[ebp], eax
	mov	ecx, DWORD PTR tv614[ebp]
	sub	ecx, 66					; 00000042H
	mov	DWORD PTR tv614[ebp], ecx
	cmp	DWORD PTR tv614[ebp], 17		; 00000011H
	ja	$LN78@fnProcessA
	mov	edx, DWORD PTR tv614[ebp]
	movzx	eax, BYTE PTR $LN238@fnProcessA[edx]
	jmp	DWORD PTR $LN241@fnProcessA[eax*4]
$LN71@fnProcessA:

; 1036 :             {
; 1037 :                case zTYPE_INTEGER:
; 1038 :                   lpViewAttrib->ulLth = sizeof( zLONG );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+203], 4

; 1039 :                   ulOffsetIncrement = lpViewAttrib->ulLth;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+203]
	mov	DWORD PTR _ulOffsetIncrement$15[ebp], eax

; 1040 :                   break;

	jmp	$LN9@fnProcessA
$LN72@fnProcessA:

; 1041 : 
; 1042 :                case zTYPE_DECIMAL:
; 1043 :                   lpViewAttrib->ulLth = sizeof( zDECIMAL );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+203], 40			; 00000028H

; 1044 :                   ulOffsetIncrement = lpViewAttrib->ulLth;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+203]
	mov	DWORD PTR _ulOffsetIncrement$15[ebp], eax

; 1045 :                   break;

	jmp	SHORT $LN9@fnProcessA
$LN73@fnProcessA:

; 1046 : 
; 1047 :                case zTYPE_BLOB:
; 1048 :                case zTYPE_STRING:
; 1049 :                   if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	jne	SHORT $LN74@fnProcessA

; 1050 :                      lpViewAttrib->ulLth = 1 + sizeof( zPVOID ) + sizeof( zULONG );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+203], 9
	jmp	SHORT $LN75@fnProcessA
$LN74@fnProcessA:

; 1051 :                   else
; 1052 :                      lpViewAttrib->ulLth++;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+203]
	add	edx, 1
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+203], edx
$LN75@fnProcessA:

; 1053 : 
; 1054 :                   // Determine offset increment
; 1055 :                   if ( lpViewAttrib->ulLth > g_ulMaxRecordStringLth )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+203]
	cmp	edx, DWORD PTR _g_ulMaxRecordStringLth
	jbe	SHORT $LN76@fnProcessA

; 1056 :                      ulOffsetIncrement = g_ulMaxRecordStringLth;

	mov	eax, DWORD PTR _g_ulMaxRecordStringLth
	mov	DWORD PTR _ulOffsetIncrement$15[ebp], eax
	jmp	SHORT $LN77@fnProcessA
$LN76@fnProcessA:

; 1057 :                   else
; 1058 :                      ulOffsetIncrement = lpViewAttrib->ulLth;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+203]
	mov	DWORD PTR _ulOffsetIncrement$15[ebp], edx
$LN77@fnProcessA:

; 1059 : 
; 1060 :                   break;

	jmp	SHORT $LN9@fnProcessA
$LN78@fnProcessA:

; 1061 : 
; 1062 :                default:
; 1063 :                   ulOffsetIncrement = lpViewAttrib->ulLth;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+203]
	mov	DWORD PTR _ulOffsetIncrement$15[ebp], ecx
$LN9@fnProcessA:

; 1064 :                   break;
; 1065 :             }
; 1066 : 
; 1067 :             // Add room for attribute flags.
; 1068 :             ulOffsetIncrement += sizeof( AttribFlagsRecord );

	mov	edx, DWORD PTR _ulOffsetIncrement$15[ebp]
	add	edx, 4
	mov	DWORD PTR _ulOffsetIncrement$15[ebp], edx

; 1069 : 
; 1070 :             if ( lpViewAttrib->bPersist )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	je	$LN79@fnProcessA

; 1071 :             {
; 1072 :                lpViewAttrib->ulRecordOffset = lpProcessInfo->ulRecordOffset;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+330]
	mov	DWORD PTR [edx+250], ecx

; 1073 : 
; 1074 :                // Now that we have determined a length, set the
; 1075 :                // offset of the attribute in token order, First
; 1076 :                // look for the first attribute with a token
; 1077 :                // greater than ours. Record offsets are kept
; 1078 :                // in token order so entity linking can take
; 1079 :                // place from multiple objects and attributes
; 1080 :                // can be correctly interpreted by all objects.
; 1081 : 
; 1082 :                lpHoldAttrib   = 0;

	mov	DWORD PTR _lpHoldAttrib$11[ebp], 0

; 1083 :                lSearchTok     = 0;

	mov	DWORD PTR _lSearchTok$12[ebp], 0

; 1084 :                for ( lpSearchAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchAttrib$18[ebp], eax
	jmp	SHORT $LN13@fnProcessA
$LN11@fnProcessA:

; 1086 :                      lpSearchAttrib = zGETPTR( lpSearchAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchAttrib$18[ebp], eax
$LN13@fnProcessA:

; 1085 :                      lpSearchAttrib;

	cmp	DWORD PTR _lpSearchAttrib$18[ebp], 0
	je	SHORT $LN12@fnProcessA

; 1087 :                {
; 1088 :                   if ( lpSearchAttrib->bPersist &&
; 1089 :                        lpSearchAttrib->lERAttTok > lpViewAttrib->lERAttTok &&

	mov	eax, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	je	SHORT $LN81@fnProcessA
	mov	edx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [edx+177]
	cmp	ecx, DWORD PTR [eax+177]
	jle	SHORT $LN81@fnProcessA
	cmp	DWORD PTR _lSearchTok$12[ebp], 0
	je	SHORT $LN82@fnProcessA
	mov	edx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	eax, DWORD PTR _lSearchTok$12[ebp]
	cmp	eax, DWORD PTR [edx+177]
	jle	SHORT $LN81@fnProcessA
$LN82@fnProcessA:

; 1090 :                        (lSearchTok == 0 ||
; 1091 :                         lSearchTok > lpSearchAttrib->lERAttTok) )
; 1092 :                   {
; 1093 :                      lSearchTok = lpSearchAttrib->lERAttTok;

	mov	ecx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	edx, DWORD PTR [ecx+177]
	mov	DWORD PTR _lSearchTok$12[ebp], edx

; 1094 :                      lpHoldAttrib = lpSearchAttrib;

	mov	eax, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	DWORD PTR _lpHoldAttrib$11[ebp], eax
$LN81@fnProcessA:

; 1095 :                   }
; 1096 :                }

	jmp	SHORT $LN11@fnProcessA
$LN12@fnProcessA:

; 1097 : 
; 1098 :                // if an attribute was found, go through the
; 1099 :                // attributes again and add the offset
; 1100 :                // increment to all attributes with tokens
; 1101 :                // greater than the current attributes token
; 1102 :                if ( lpHoldAttrib )

	cmp	DWORD PTR _lpHoldAttrib$11[ebp], 0
	je	SHORT $LN83@fnProcessA

; 1103 :                {
; 1104 :                   lpViewAttrib->ulRecordOffset = lpHoldAttrib->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _lpHoldAttrib$11[ebp]
	mov	eax, DWORD PTR [edx+250]
	mov	DWORD PTR [ecx+250], eax

; 1105 :                   lpSearchAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchAttrib$18[ebp], eax
$LN14@fnProcessA:

; 1106 :                   while ( lpSearchAttrib )

	cmp	DWORD PTR _lpSearchAttrib$18[ebp], 0
	je	SHORT $LN83@fnProcessA

; 1107 :                   {
; 1108 :                      if ( lpSearchAttrib->bPersist &&

	mov	eax, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	je	SHORT $LN84@fnProcessA
	mov	edx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [edx+177]
	cmp	ecx, DWORD PTR [eax+177]
	jle	SHORT $LN84@fnProcessA

; 1109 :                           lpSearchAttrib->lERAttTok > lpViewAttrib->lERAttTok )
; 1110 :                      {
; 1111 :                         lpSearchAttrib->ulRecordOffset += ulOffsetIncrement;

	mov	edx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	eax, DWORD PTR [edx+250]
	add	eax, DWORD PTR _ulOffsetIncrement$15[ebp]
	mov	ecx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	DWORD PTR [ecx+250], eax
$LN84@fnProcessA:

; 1112 :                      }
; 1113 : 
; 1114 :                      lpSearchAttrib = zGETPTR( lpSearchAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpSearchAttrib$18[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchAttrib$18[ebp], eax

; 1115 :                   }

	jmp	SHORT $LN14@fnProcessA
$LN83@fnProcessA:

; 1116 :                }
; 1117 : 
; 1118 :                // Finally, increment the offset increment value
; 1119 :                lpProcessInfo->ulRecordOffset += ulOffsetIncrement;

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+330]
	add	edx, DWORD PTR _ulOffsetIncrement$15[ebp]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	DWORD PTR [eax+330], edx

; 1120 :                lpViewEntity->ulRecordSize = lpProcessInfo->ulRecordOffset;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+330]
	mov	DWORD PTR [ecx+207], eax

; 1121 : 
; 1122 :             }  // end of persistent attribute stuff

	jmp	SHORT $LN69@fnProcessA
$LN79@fnProcessA:

; 1123 :             else
; 1124 :             {
; 1125 :                lpViewAttrib->ulRecordOffset = lpProcessInfo->ulNonPersistOffset;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+334]
	mov	DWORD PTR [ecx+250], eax

; 1126 :                lpProcessInfo->ulNonPersistOffset += ulOffsetIncrement;

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+334]
	add	edx, DWORD PTR _ulOffsetIncrement$15[ebp]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	DWORD PTR [eax+334], edx

; 1127 :                lpViewEntity->ulNonPersistSize = lpProcessInfo->ulNonPersistOffset;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+334]
	mov	DWORD PTR [ecx+211], eax
$LN69@fnProcessA:

; 1128 :             }
; 1129 :          }
; 1130 : 
; 1131 :          break;

	jmp	$LN2@fnProcessA
$LN85@fnProcessA:

; 1132 : 
; 1133 :       // Attrib attributes beginning with 'N'
; 1134 :       case 'N':
; 1135 :          if ( zstrcmp( pchAttrName, szlNAME ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlNAME
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN195@fnProcessA
	mov	edx, DWORD PTR _szlNAME
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv698[ebp], eax
	jmp	SHORT $LN196@fnProcessA
$LN195@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlNAME
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN193@fnProcessA
	mov	DWORD PTR tv697[ebp], 1
	jmp	SHORT $LN194@fnProcessA
$LN193@fnProcessA:
	mov	DWORD PTR tv697[ebp], -1
$LN194@fnProcessA:
	mov	edx, DWORD PTR tv697[ebp]
	mov	DWORD PTR tv698[ebp], edx
$LN196@fnProcessA:
	cmp	DWORD PTR tv698[ebp], 0
	jne	SHORT $LN86@fnProcessA

; 1136 :             zstrcpy( lpViewAttrib->szName, lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcpy
	add	esp, 8
$LN86@fnProcessA:

; 1137 : 
; 1138 :          break;

	jmp	$LN2@fnProcessA
$LN87@fnProcessA:

; 1139 : 
; 1140 :       // Attrib attributes beginning with 'P'
; 1141 :       case 'P':
; 1142 :          if ( zstrcmp( pchAttrName, szlPERSIST ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlPERSIST
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN199@fnProcessA
	mov	ecx, DWORD PTR _szlPERSIST
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv715[ebp], eax
	jmp	SHORT $LN200@fnProcessA
$LN199@fnProcessA:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlPERSIST
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN197@fnProcessA
	mov	DWORD PTR tv714[ebp], 1
	jmp	SHORT $LN198@fnProcessA
$LN197@fnProcessA:
	mov	DWORD PTR tv714[ebp], -1
$LN198@fnProcessA:
	mov	ecx, DWORD PTR tv714[ebp]
	mov	DWORD PTR tv715[ebp], ecx
$LN200@fnProcessA:
	cmp	DWORD PTR tv715[ebp], 0
	jne	$LN88@fnProcessA

; 1143 :          {
; 1144 :             if ( lpProcessInfo->bType ||
; 1145 :                  lpProcessInfo->bLth  ||

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	movzx	eax, BYTE PTR [edx+327]
	test	eax, eax
	jne	SHORT $LN90@fnProcessA
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	movzx	edx, BYTE PTR [ecx+326]
	test	edx, edx
	jne	SHORT $LN90@fnProcessA
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+328]
	test	ecx, ecx
	je	SHORT $LN89@fnProcessA
$LN90@fnProcessA:

; 1146 :                  lpProcessInfo->bDomain )
; 1147 :             {
; 1148 :                LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+322]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$4[ebp], eax

; 1149 :                //  "KZOEE058 - Invalid file, PERSIST after
; 1150 :                //              DOMAIN, TYPE or LTH on line "
; 1151 :                fnIssueCoreError( lpTask, lpView, 16, 58,

	push	0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	add	edx, 41					; 00000029H
	push	edx
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+298]
	push	ecx
	push	58					; 0000003aH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$4[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1152 :                                  lpProcessInfo->lLine,
; 1153 :                                  lpProcessInfo->szFileName, 0 );
; 1154 :                lpProcessInfo->nCurrState = 10;  // set error

	mov	ecx, 10					; 0000000aH
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [edx+318], cx

; 1155 :                break;

	jmp	$LN2@fnProcessA
$LN89@fnProcessA:

; 1156 :             }
; 1157 : 
; 1158 :             lpProcessInfo->bPersist = TRUE;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	BYTE PTR [eax+329], 1

; 1159 :             lpViewAttrib->bPersist = TRUE;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	or	edx, 1
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+193], edx
$LN88@fnProcessA:

; 1160 :          }
; 1161 : 
; 1162 :          break;

	jmp	$LN2@fnProcessA
$LN91@fnProcessA:

; 1163 : 
; 1164 :       // Attrib attributes beginning with 'R'
; 1165 :       case 'R':
; 1166 :          if ( zstrcmp( pchAttrName, szlREQUIRED ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlREQUIRED
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN203@fnProcessA
	mov	edx, DWORD PTR _szlREQUIRED
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv755[ebp], eax
	jmp	SHORT $LN204@fnProcessA
$LN203@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlREQUIRED
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN201@fnProcessA
	mov	DWORD PTR tv754[ebp], 1
	jmp	SHORT $LN202@fnProcessA
$LN201@fnProcessA:
	mov	DWORD PTR tv754[ebp], -1
$LN202@fnProcessA:
	mov	edx, DWORD PTR tv754[ebp]
	mov	DWORD PTR tv755[ebp], edx
$LN204@fnProcessA:
	cmp	DWORD PTR tv755[ebp], 0
	jne	SHORT $LN92@fnProcessA

; 1167 :          {
; 1168 :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN92@fnProcessA

; 1169 :                lpViewAttrib->bRequired = TRUE;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+193], eax
$LN92@fnProcessA:

; 1170 :          }
; 1171 : 
; 1172 :          break;

	jmp	$LN2@fnProcessA
$LN94@fnProcessA:

; 1173 : 
; 1174 :       // Attrib attributes beginning with 'S'
; 1175 :       case 'S':
; 1176 :          if ( zstrcmp( pchAttrName, szlSEQUENCING ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlSEQUENCING
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN207@fnProcessA
	mov	eax, DWORD PTR _szlSEQUENCING
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv776[ebp], eax
	jmp	SHORT $LN208@fnProcessA
$LN207@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlSEQUENCING
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN205@fnProcessA
	mov	DWORD PTR tv775[ebp], 1
	jmp	SHORT $LN206@fnProcessA
$LN205@fnProcessA:
	mov	DWORD PTR tv775[ebp], -1
$LN206@fnProcessA:
	mov	eax, DWORD PTR tv775[ebp]
	mov	DWORD PTR tv776[ebp], eax
$LN208@fnProcessA:
	cmp	DWORD PTR tv776[ebp], 0
	jne	$LN95@fnProcessA

; 1177 :          {
; 1178 :             lpViewAttrib->cSequencing = (zUCHAR) zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	BYTE PTR [ecx+197], al

; 1179 : 
; 1180 :             // Set flag to indicate that the OD has ordering.
; 1181 :             lpViewOD->bAutoSeq = TRUE;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [ecx+240], eax

; 1182 : 
; 1183 :             // Indicate that the owning entity has at least 1
; 1184 :             // attribute that is used for ordering.
; 1185 :             if ( lpViewEntity->hParent == 0 || lpViewEntity->uCardMax > 1 )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN99@fnProcessA
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movzx	ecx, WORD PTR [eax+221]
	cmp	ecx, 1
	jle	SHORT $LN97@fnProcessA
$LN99@fnProcessA:

; 1186 :                lpViewEntity->bAttrOrder = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 262144				; 00040000H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax
	jmp	SHORT $LN98@fnProcessA
$LN97@fnProcessA:

; 1187 :             else
; 1188 :             {
; 1189 :                LPVIEWENTITY lpSearchViewEntity;
; 1190 : 
; 1191 :                // The current entity's relationship with its parent is 1-1.
; 1192 :                // This means that the ordering must be for a parent entity--
; 1193 :                // we don't order 1 entity.  Find the parent entity.
; 1194 :                for ( lpSearchViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$14[ebp], eax
	jmp	SHORT $LN18@fnProcessA
$LN16@fnProcessA:

; 1196 :                      lpSearchViewEntity = zGETPTR( lpSearchViewEntity->hParent ) )

	mov	ecx, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$14[ebp], eax
$LN18@fnProcessA:

; 1195 :                      lpSearchViewEntity->uCardMax <= 1;

	mov	eax, DWORD PTR _lpSearchViewEntity$14[ebp]
	movzx	ecx, WORD PTR [eax+221]
	cmp	ecx, 1
	jg	SHORT $LN17@fnProcessA

; 1197 :                {
; 1198 :                   // If there is no parent then we're done.
; 1199 :                   if ( lpSearchViewEntity->hParent == 0 )

	mov	edx, DWORD PTR _lpSearchViewEntity$14[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	SHORT $LN100@fnProcessA

; 1200 :                      break;

	jmp	SHORT $LN17@fnProcessA
$LN100@fnProcessA:

; 1201 :                }

	jmp	SHORT $LN16@fnProcessA
$LN17@fnProcessA:

; 1202 : 
; 1203 :                lpSearchViewEntity->bAttrOrder =

	mov	eax, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 524288				; 00080000H
	mov	edx, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	DWORD PTR [edx+235], ecx
	mov	eax, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 262144				; 00040000H
	mov	edx, DWORD PTR _lpSearchViewEntity$14[ebp]
	mov	DWORD PTR [edx+235], ecx
$LN98@fnProcessA:

; 1204 :                   lpSearchViewEntity->bAttrOrderChild = TRUE;
; 1205 :             }
; 1206 :          }

	jmp	$LN96@fnProcessA
$LN95@fnProcessA:

; 1207 :          else
; 1208 :          if ( zstrcmp( pchAttrName, szlSEQ_AD ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlSEQ_AD
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN211@fnProcessA
	mov	ecx, DWORD PTR _szlSEQ_AD
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv822[ebp], eax
	jmp	SHORT $LN212@fnProcessA
$LN211@fnProcessA:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlSEQ_AD
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN209@fnProcessA
	mov	DWORD PTR tv821[ebp], 1
	jmp	SHORT $LN210@fnProcessA
$LN209@fnProcessA:
	mov	DWORD PTR tv821[ebp], -1
$LN210@fnProcessA:
	mov	ecx, DWORD PTR tv821[ebp]
	mov	DWORD PTR tv822[ebp], ecx
$LN212@fnProcessA:
	cmp	DWORD PTR tv822[ebp], 0
	jne	SHORT $LN96@fnProcessA

; 1209 :          {
; 1210 :             if ( lpProcessInfo->szLine[ 0 ] == 'D' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 68					; 00000044H
	jne	SHORT $LN96@fnProcessA

; 1211 :                lpViewAttrib->bSequencingD = TRUE;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	or	edx, 2048				; 00000800H
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+193], edx
$LN96@fnProcessA:

; 1212 :          }
; 1213 :          break;

	jmp	$LN2@fnProcessA
$LN103@fnProcessA:

; 1214 : 
; 1215 :       // Attrib attributes beginning with 'T'
; 1216 :       case 'T':
; 1217 :          if ( zstrcmp( pchAttrName, szlTYPE ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlTYPE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN215@fnProcessA
	mov	edx, DWORD PTR _szlTYPE
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv843[ebp], eax
	jmp	SHORT $LN216@fnProcessA
$LN215@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlTYPE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN213@fnProcessA
	mov	DWORD PTR tv842[ebp], 1
	jmp	SHORT $LN214@fnProcessA
$LN213@fnProcessA:
	mov	DWORD PTR tv842[ebp], -1
$LN214@fnProcessA:
	mov	edx, DWORD PTR tv842[ebp]
	mov	DWORD PTR tv843[ebp], edx
$LN216@fnProcessA:
	cmp	DWORD PTR tv843[ebp], 0
	jne	$LN104@fnProcessA

; 1218 :          {
; 1219 :             if ( lpViewAttrib->hDomain == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+198], 0
	jne	SHORT $LN105@fnProcessA

; 1220 :             {
; 1221 :                lpProcessInfo->bType = TRUE;

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	BYTE PTR [ecx+327], 1

; 1222 :                lpViewAttrib->cType = lpProcessInfo->szLine[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR [ecx+202], dl

; 1223 :             }

	jmp	$LN104@fnProcessA
$LN105@fnProcessA:

; 1224 :             else
; 1225 :             {
; 1226 :                LPDOMAIN lpDomain = zGETPTR( lpViewAttrib->hDomain );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+198]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$3[ebp], eax

; 1227 : 
; 1228 :                if ( lpDomain->cType != lpProcessInfo->szLine[ 0 ] )

	mov	edx, DWORD PTR _lpDomain$3[ebp]
	movsx	eax, BYTE PTR [edx+63]
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	eax, edx
	je	$LN107@fnProcessA

; 1229 :                {
; 1230 :                   LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+322]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 1231 :                   zCHAR szTempMsg[ 40 ];
; 1232 : 
; 1233 :                   // "KZOEE062 - Conflict between E/R Attribute type and TE Field Type: "
; 1234 :                   zstrcpy( szTempMsg, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szTempMsg$19[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1235 :                   zstrcat( szTempMsg, ", " );

	push	OFFSET $SG14441
	lea	edx, DWORD PTR _szTempMsg$19[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1236 :                   zstrcat( szTempMsg, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szTempMsg$19[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1237 :                   fnIssueCoreError( lpTask, lpView, 16, 62,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szTempMsg$19[ebp]
	push	eax
	push	0
	push	62					; 0000003eH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1238 :                                     0, szTempMsg,
; 1239 :                                     lpViewAttrib->szName );
; 1240 :                   lpProcessInfo->nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [ecx+318], ax

; 1241 :                   break;

	jmp	$LN2@fnProcessA

; 1242 :                }

	jmp	SHORT $LN104@fnProcessA
$LN107@fnProcessA:

; 1243 :                else
; 1244 :                   lpProcessInfo->bType = TRUE;

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	BYTE PTR [edx+327], 1
$LN104@fnProcessA:

; 1245 :             }
; 1246 :          }
; 1247 : 
; 1248 :          break;

	jmp	$LN2@fnProcessA
$LN109@fnProcessA:

; 1249 : 
; 1250 :       // Attrib attributes beginning with 'U'
; 1251 :       case 'U':
; 1252 :          if ( zstrcmp( pchAttrName, szlUP_DATE ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlUP_DATE
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN219@fnProcessA
	mov	ecx, DWORD PTR _szlUP_DATE
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv895[ebp], eax
	jmp	SHORT $LN220@fnProcessA
$LN219@fnProcessA:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlUP_DATE
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN217@fnProcessA
	mov	DWORD PTR tv894[ebp], 1
	jmp	SHORT $LN218@fnProcessA
$LN217@fnProcessA:
	mov	DWORD PTR tv894[ebp], -1
$LN218@fnProcessA:
	mov	ecx, DWORD PTR tv894[ebp]
	mov	DWORD PTR tv895[ebp], ecx
$LN220@fnProcessA:
	cmp	DWORD PTR tv895[ebp], 0
	jne	SHORT $LN110@fnProcessA

; 1253 :          {
; 1254 :             lpViewAttrib->bUpDate = TRUE;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+193], eax

; 1255 :          }

	jmp	$LN111@fnProcessA
$LN110@fnProcessA:

; 1256 :          else
; 1257 :          if ( zstrcmp( pchAttrName, szlUSERID ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlUSERID
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN223@fnProcessA
	mov	eax, DWORD PTR _szlUSERID
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv911[ebp], eax
	jmp	SHORT $LN224@fnProcessA
$LN223@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlUSERID
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN221@fnProcessA
	mov	DWORD PTR tv910[ebp], 1
	jmp	SHORT $LN222@fnProcessA
$LN221@fnProcessA:
	mov	DWORD PTR tv910[ebp], -1
$LN222@fnProcessA:
	mov	eax, DWORD PTR tv910[ebp]
	mov	DWORD PTR tv911[ebp], eax
$LN224@fnProcessA:
	cmp	DWORD PTR tv911[ebp], 0
	jne	SHORT $LN111@fnProcessA

; 1258 :          {
; 1259 :             lpViewAttrib->bUserID = TRUE;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+193], edx
$LN111@fnProcessA:

; 1260 :          }
; 1261 : 
; 1262 :          break;

	jmp	$LN2@fnProcessA
$LN113@fnProcessA:

; 1263 : 
; 1264 :       case 'X':
; 1265 :          if ( zstrcmp( pchAttrName, "XML_SIMPLE_NAME" ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14449
	cmp	edx, eax
	jne	SHORT $LN227@fnProcessA
	push	OFFSET $SG14450
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv927[ebp], eax
	jmp	SHORT $LN228@fnProcessA
$LN227@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14451
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN225@fnProcessA
	mov	DWORD PTR tv926[ebp], 1
	jmp	SHORT $LN226@fnProcessA
$LN225@fnProcessA:
	mov	DWORD PTR tv926[ebp], -1
$LN226@fnProcessA:
	mov	edx, DWORD PTR tv926[ebp]
	mov	DWORD PTR tv927[ebp], edx
$LN228@fnProcessA:
	cmp	DWORD PTR tv927[ebp], 0
	jne	SHORT $LN114@fnProcessA

; 1266 :             zstrcpy( lpViewAttrib->szXML_SimpleName, lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 43					; 0000002bH
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	$LN2@fnProcessA
$LN114@fnProcessA:

; 1267 :          else
; 1268 :          if ( zstrcmp( pchAttrName, "XML_NAME_EXTERNAL" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14454
	cmp	ecx, edx
	jne	SHORT $LN231@fnProcessA
	push	OFFSET $SG14455
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv944[ebp], eax
	jmp	SHORT $LN232@fnProcessA
$LN231@fnProcessA:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14456
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN229@fnProcessA
	mov	DWORD PTR tv943[ebp], 1
	jmp	SHORT $LN230@fnProcessA
$LN229@fnProcessA:
	mov	DWORD PTR tv943[ebp], -1
$LN230@fnProcessA:
	mov	ecx, DWORD PTR tv943[ebp]
	mov	DWORD PTR tv944[ebp], ecx
$LN232@fnProcessA:
	cmp	DWORD PTR tv944[ebp], 0
	jne	SHORT $LN116@fnProcessA

; 1269 :             zstrcpy( lpViewAttrib->szXML_ExternalName, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	$LN2@fnProcessA
$LN116@fnProcessA:

; 1270 :          else
; 1271 :          if ( zstrcmp( pchAttrName, szlXVAATT_TOK ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlXVAATT_TOK
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN235@fnProcessA
	mov	eax, DWORD PTR _szlXVAATT_TOK
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv993[ebp], eax
	jmp	SHORT $LN236@fnProcessA
$LN235@fnProcessA:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlXVAATT_TOK
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN233@fnProcessA
	mov	DWORD PTR tv992[ebp], 1
	jmp	SHORT $LN234@fnProcessA
$LN233@fnProcessA:
	mov	DWORD PTR tv992[ebp], -1
$LN234@fnProcessA:
	mov	eax, DWORD PTR tv992[ebp]
	mov	DWORD PTR tv993[ebp], eax
$LN236@fnProcessA:
	cmp	DWORD PTR tv993[ebp], 0
	jne	SHORT $LN2@fnProcessA

; 1272 :             lpViewAttrib->lXVAAttTok = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+181], eax
$LN2@fnProcessA:

; 1273 : 
; 1274 :          break;
; 1275 : 
; 1276 :       default:
; 1277 :          break;
; 1278 :    }   // End Attribute Attribute switch
; 1279 : 
; 1280 :    return( 0 );

	xor	eax, eax

; 1281 : } // fnProcessAttribEntity

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN239@fnProcessA:
	DD	$LN19@fnProcessA
	DD	$LN2@fnProcessA
	DD	$LN38@fnProcessA
	DD	$LN42@fnProcessA
	DD	$LN56@fnProcessA
	DD	$LN58@fnProcessA
	DD	$LN60@fnProcessA
	DD	$LN62@fnProcessA
	DD	$LN64@fnProcessA
	DD	$LN2@fnProcessA
	DD	$LN66@fnProcessA
	DD	$LN68@fnProcessA
	DD	$LN2@fnProcessA
	DD	$LN85@fnProcessA
	DD	$LN2@fnProcessA
	DD	$LN87@fnProcessA
	DD	$LN2@fnProcessA
	DD	$LN91@fnProcessA
	DD	$LN94@fnProcessA
	DD	$LN103@fnProcessA
	DD	$LN109@fnProcessA
	DD	$LN2@fnProcessA
	DD	$LN2@fnProcessA
	DD	$LN113@fnProcessA
$LN240@fnProcessA:
	DD	$LN33@fnProcessA
	DD	$LN30@fnProcessA
	DD	$LN31@fnProcessA
	DD	$LN27@fnProcessA
	DD	$LN32@fnProcessA
	DD	$LN34@fnProcessA
$LN237@fnProcessA:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
	npad	1
$LN241@fnProcessA:
	DD	$LN73@fnProcessA
	DD	$LN71@fnProcessA
	DD	$LN72@fnProcessA
	DD	$LN78@fnProcessA
$LN238@fnProcessA:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	2
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	0
_fnProcessAttribEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpTask$1 = -352					; size = 4
tv958 = -348						; size = 4
tv957 = -344						; size = 4
tv937 = -340						; size = 4
tv936 = -336						; size = 4
tv916 = -332						; size = 4
tv915 = -328						; size = 4
tv895 = -324						; size = 4
tv894 = -320						; size = 4
tv859 = -316						; size = 4
tv858 = -312						; size = 4
_lpParent$2 = -308					; size = 4
tv824 = -304						; size = 4
tv823 = -300						; size = 4
tv807 = -296						; size = 4
tv806 = -292						; size = 4
tv790 = -288						; size = 4
tv789 = -284						; size = 4
tv765 = -280						; size = 4
tv764 = -276						; size = 4
tv749 = -272						; size = 4
tv748 = -268						; size = 4
tv733 = -264						; size = 4
tv732 = -260						; size = 4
tv717 = -256						; size = 4
tv716 = -252						; size = 4
tv694 = -248						; size = 4
tv693 = -244						; size = 4
tv678 = -240						; size = 4
tv677 = -236						; size = 4
tv662 = -232						; size = 4
tv661 = -228						; size = 4
tv646 = -224						; size = 4
tv645 = -220						; size = 4
tv625 = -216						; size = 4
tv624 = -212						; size = 4
tv608 = -208						; size = 4
tv607 = -204						; size = 4
tv575 = -200						; size = 4
tv574 = -196						; size = 4
tv554 = -192						; size = 4
tv553 = -188						; size = 4
tv533 = -184						; size = 4
tv532 = -180						; size = 4
tv520 = -176						; size = 4
tv519 = -172						; size = 4
tv471 = -168						; size = 4
tv470 = -164						; size = 4
tv450 = -160						; size = 4
tv449 = -156						; size = 4
tv429 = -152						; size = 4
tv428 = -148						; size = 4
tv408 = -144						; size = 4
tv407 = -140						; size = 4
tv387 = -136						; size = 4
tv386 = -132						; size = 4
tv360 = -128						; size = 4
tv359 = -124						; size = 4
tv336 = -120						; size = 4
tv335 = -116						; size = 4
tv314 = -112						; size = 4
tv313 = -108						; size = 4
tv298 = -104						; size = 4
tv297 = -100						; size = 4
tv277 = -96						; size = 4
tv276 = -92						; size = 4
tv256 = -88						; size = 4
tv255 = -84						; size = 4
tv240 = -80						; size = 4
tv239 = -76						; size = 4
_lpParent$3 = -72					; size = 4
tv211 = -68						; size = 4
tv210 = -64						; size = 4
tv193 = -60						; size = 4
tv192 = -56						; size = 4
tv177 = -52						; size = 4
tv176 = -48						; size = 4
tv161 = -44						; size = 4
tv160 = -40						; size = 4
tv144 = -36						; size = 4
tv143 = -32						; size = 4
tv128 = -28						; size = 4
tv95 = -24						; size = 4
tv80 = -20						; size = 4
tv79 = -16						; size = 4
tv68 = -12						; size = 4
_lpParentViewEntity$4 = -8				; size = 4
_pchAttrName$ = -4					; size = 4
_lpViewOD$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpProcessInfo$ = 16					; size = 4
_fnProcessEntityEntity PROC

; 447  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 352				; 00000160H

; 448  :    zPCHAR pchAttrName;
; 449  : 
; 450  :    pchAttrName = lpProcessInfo->szAttrName;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 8
	mov	DWORD PTR _pchAttrName$[ebp], eax

; 451  :    switch ( pchAttrName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	sub	edx, 65					; 00000041H
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 23			; 00000017H
	ja	$LN2@fnProcessE
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN274@fnProcessE[eax*4]
$LN7@fnProcessE:

; 452  :    {
; 453  :       // Entity attributes beginning with 'A'
; 454  :       case 'A':
; 455  :          if ( zstrcmp( pchAttrName, "ABSTRACT" ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG13957
	cmp	edx, eax
	jne	SHORT $LN112@fnProcessE
	push	OFFSET $SG13958
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN113@fnProcessE
$LN112@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13959
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN110@fnProcessE
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN111@fnProcessE
$LN110@fnProcessE:
	mov	DWORD PTR tv79[ebp], -1
$LN111@fnProcessE:
	mov	edx, DWORD PTR tv79[ebp]
	mov	DWORD PTR tv80[ebp], edx
$LN113@fnProcessE:
	cmp	DWORD PTR tv80[ebp], 0
	jne	SHORT $LN8@fnProcessE

; 456  :             lpViewEntity->bAbstract = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	or	ecx, 2048				; 00000800H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+239], ecx
	jmp	$LN9@fnProcessE
$LN8@fnProcessE:

; 457  :          else
; 458  :          if ( zstrcmp( pchAttrName, "ABSTRACTCHILD" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13962
	cmp	ecx, edx
	jne	SHORT $LN116@fnProcessE
	push	OFFSET $SG13963
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN117@fnProcessE
$LN116@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG13964
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN114@fnProcessE
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN115@fnProcessE
$LN114@fnProcessE:
	mov	DWORD PTR tv95[ebp], -1
$LN115@fnProcessE:
	mov	ecx, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv128[ebp], ecx
$LN117@fnProcessE:
	cmp	DWORD PTR tv128[ebp], 0
	jne	SHORT $LN10@fnProcessE

; 459  :             lpViewEntity->bAbstractChild = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	or	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+239], eax
	jmp	$LN9@fnProcessE
$LN10@fnProcessE:

; 460  :          else
; 461  :          if ( zstrcmp( pchAttrName, "ACT_LIMIT" ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13967
	cmp	eax, ecx
	jne	SHORT $LN120@fnProcessE
	push	OFFSET $SG13968
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN121@fnProcessE
$LN120@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13969
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN118@fnProcessE
	mov	DWORD PTR tv143[ebp], 1
	jmp	SHORT $LN119@fnProcessE
$LN118@fnProcessE:
	mov	DWORD PTR tv143[ebp], -1
$LN119@fnProcessE:
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv144[ebp], eax
$LN121@fnProcessE:
	cmp	DWORD PTR tv144[ebp], 0
	jne	SHORT $LN12@fnProcessE

; 462  :             lpViewEntity->lActivateLimit = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+226], eax
	jmp	$LN9@fnProcessE
$LN12@fnProcessE:

; 463  :          else
; 464  :          if ( zstrcmp( pchAttrName, szlAUTOCREATE ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlAUTOCREATE
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN124@fnProcessE
	mov	eax, DWORD PTR _szlAUTOCREATE
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv161[ebp], eax
	jmp	SHORT $LN125@fnProcessE
$LN124@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlAUTOCREATE
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN122@fnProcessE
	mov	DWORD PTR tv160[ebp], 1
	jmp	SHORT $LN123@fnProcessE
$LN122@fnProcessE:
	mov	DWORD PTR tv160[ebp], -1
$LN123@fnProcessE:
	mov	eax, DWORD PTR tv160[ebp]
	mov	DWORD PTR tv161[ebp], eax
$LN125@fnProcessE:
	cmp	DWORD PTR tv161[ebp], 0
	jne	SHORT $LN14@fnProcessE

; 465  :             lpViewEntity->bAutoCreate = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 4096				; 00001000H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+235], edx
	jmp	SHORT $LN9@fnProcessE
$LN14@fnProcessE:

; 466  :          else
; 467  :          if ( zstrcmp( pchAttrName, szlAUTOLOADFROMPARENT ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlAUTOLOADFROMPARENT
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN128@fnProcessE
	mov	edx, DWORD PTR _szlAUTOLOADFROMPARENT
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN129@fnProcessE
$LN128@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlAUTOLOADFROMPARENT
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN126@fnProcessE
	mov	DWORD PTR tv176[ebp], 1
	jmp	SHORT $LN127@fnProcessE
$LN126@fnProcessE:
	mov	DWORD PTR tv176[ebp], -1
$LN127@fnProcessE:
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR tv177[ebp], edx
$LN129@fnProcessE:
	cmp	DWORD PTR tv177[ebp], 0
	jne	SHORT $LN9@fnProcessE

; 468  :             lpViewEntity->bAutoLoadFromParent = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 1073741824				; 40000000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
$LN9@fnProcessE:

; 469  : 
; 470  :          break;

	jmp	$LN2@fnProcessE
$LN17@fnProcessE:

; 471  : 
; 472  :       // Entity attributes beginning with 'C'
; 473  :       case 'C':
; 474  :          if ( zstrcmp( pchAttrName, szlCARDMAX ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlCARDMAX
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN132@fnProcessE
	mov	ecx, DWORD PTR _szlCARDMAX
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN133@fnProcessE
$LN132@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlCARDMAX
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN130@fnProcessE
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN131@fnProcessE
$LN130@fnProcessE:
	mov	DWORD PTR tv192[ebp], -1
$LN131@fnProcessE:
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR tv193[ebp], ecx
$LN133@fnProcessE:
	cmp	DWORD PTR tv193[ebp], 0
	jne	SHORT $LN18@fnProcessE

; 475  :             lpViewEntity->uCardMax =(zUSHORT) zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	WORD PTR [ecx+221], ax
	jmp	$LN19@fnProcessE
$LN18@fnProcessE:

; 476  :          else
; 477  :          if ( zstrcmp( pchAttrName, szlCARDMIN ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlCARDMIN
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN136@fnProcessE
	mov	eax, DWORD PTR _szlCARDMIN
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv211[ebp], eax
	jmp	SHORT $LN137@fnProcessE
$LN136@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlCARDMIN
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN134@fnProcessE
	mov	DWORD PTR tv210[ebp], 1
	jmp	SHORT $LN135@fnProcessE
$LN134@fnProcessE:
	mov	DWORD PTR tv210[ebp], -1
$LN135@fnProcessE:
	mov	eax, DWORD PTR tv210[ebp]
	mov	DWORD PTR tv211[ebp], eax
$LN137@fnProcessE:
	cmp	DWORD PTR tv211[ebp], 0
	jne	SHORT $LN20@fnProcessE

; 478  :          {
; 479  :             lpViewEntity->uCardMin = (zUSHORT) zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	WORD PTR [ecx+219], ax

; 480  :             // If min cardinality is non-zero then mark
; 481  :             // the parent as having a required child.
; 482  :             if ( lpViewEntity->uCardMin && lpViewEntity->hParent )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movzx	eax, WORD PTR [edx+219]
	test	eax, eax
	je	SHORT $LN22@fnProcessE
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN22@fnProcessE

; 483  :             {
; 484  :                LPVIEWENTITY lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$3[ebp], eax

; 485  : 
; 486  :                lpParent->bRequiredChild = TRUE;

	mov	ecx, DWORD PTR _lpParent$3[ebp]
	mov	edx, DWORD PTR [ecx+239]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR _lpParent$3[ebp]
	mov	DWORD PTR [eax+239], edx
$LN22@fnProcessE:

; 487  :             }
; 488  :          }

	jmp	SHORT $LN19@fnProcessE
$LN20@fnProcessE:

; 489  :          else
; 490  :          if ( zstrcmp( pchAttrName, szlCREATE ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlCREATE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN140@fnProcessE
	mov	edx, DWORD PTR _szlCREATE
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv240[ebp], eax
	jmp	SHORT $LN141@fnProcessE
$LN140@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlCREATE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN138@fnProcessE
	mov	DWORD PTR tv239[ebp], 1
	jmp	SHORT $LN139@fnProcessE
$LN138@fnProcessE:
	mov	DWORD PTR tv239[ebp], -1
$LN139@fnProcessE:
	mov	edx, DWORD PTR tv239[ebp]
	mov	DWORD PTR tv240[ebp], edx
$LN141@fnProcessE:
	cmp	DWORD PTR tv240[ebp], 0
	jne	SHORT $LN19@fnProcessE

; 491  :             lpViewEntity->bCreate = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 1
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
$LN19@fnProcessE:

; 492  : 
; 493  :          break;

	jmp	$LN2@fnProcessE
$LN24@fnProcessE:

; 494  : 
; 495  :       // Entity attributes beginning with 'D'
; 496  :       case 'D':
; 497  :          if ( zstrcmp( pchAttrName, szlDBNAME ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlDBNAME
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN144@fnProcessE
	mov	ecx, DWORD PTR _szlDBNAME
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN145@fnProcessE
$LN144@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlDBNAME
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN142@fnProcessE
	mov	DWORD PTR tv255[ebp], 1
	jmp	SHORT $LN143@fnProcessE
$LN142@fnProcessE:
	mov	DWORD PTR tv255[ebp], -1
$LN143@fnProcessE:
	mov	ecx, DWORD PTR tv255[ebp]
	mov	DWORD PTR tv256[ebp], ecx
$LN145@fnProcessE:
	cmp	DWORD PTR tv256[ebp], 0
	jne	$LN25@fnProcessE

; 498  :          {
; 499  :             if ( zstrcmp( lpViewOD->szDfltDBName, lpProcessInfo->szLine ) == 0 )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+43]
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	ecx, BYTE PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN148@fnProcessE
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 43					; 0000002bH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN149@fnProcessE
$LN148@fnProcessE:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+43]
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	ecx, BYTE PTR [edx]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN146@fnProcessE
	mov	DWORD PTR tv276[ebp], 1
	jmp	SHORT $LN147@fnProcessE
$LN146@fnProcessE:
	mov	DWORD PTR tv276[ebp], -1
$LN147@fnProcessE:
	mov	edx, DWORD PTR tv276[ebp]
	mov	DWORD PTR tv277[ebp], edx
$LN149@fnProcessE:
	cmp	DWORD PTR tv277[ebp], 0
	jne	SHORT $LN27@fnProcessE

; 500  :                zstrcpy( lpViewEntity->szDBName, lpViewOD->szDfltDBName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 43					; 0000002bH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN28@fnProcessE
$LN27@fnProcessE:

; 501  :             else
; 502  :                zstrcpy( lpViewEntity->szDBName, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN28@fnProcessE:

; 503  :          }

	jmp	$LN26@fnProcessE
$LN25@fnProcessE:

; 504  :          else
; 505  :          if ( zstrcmp( pchAttrName, szlDELETE ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDELETE
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN152@fnProcessE
	mov	eax, DWORD PTR _szlDELETE
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN153@fnProcessE
$LN152@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDELETE
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN150@fnProcessE
	mov	DWORD PTR tv297[ebp], 1
	jmp	SHORT $LN151@fnProcessE
$LN150@fnProcessE:
	mov	DWORD PTR tv297[ebp], -1
$LN151@fnProcessE:
	mov	eax, DWORD PTR tv297[ebp]
	mov	DWORD PTR tv298[ebp], eax
$LN153@fnProcessE:
	cmp	DWORD PTR tv298[ebp], 0
	jne	SHORT $LN29@fnProcessE

; 506  :             lpViewEntity->bDelete = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 2
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+235], edx
	jmp	$LN26@fnProcessE
$LN29@fnProcessE:

; 507  :          else
; 508  :          if ( zstrcmp( pchAttrName, szlDERIVED ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlDERIVED
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN156@fnProcessE
	mov	edx, DWORD PTR _szlDERIVED
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv314[ebp], eax
	jmp	SHORT $LN157@fnProcessE
$LN156@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlDERIVED
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN154@fnProcessE
	mov	DWORD PTR tv313[ebp], 1
	jmp	SHORT $LN155@fnProcessE
$LN154@fnProcessE:
	mov	DWORD PTR tv313[ebp], -1
$LN155@fnProcessE:
	mov	edx, DWORD PTR tv313[ebp]
	mov	DWORD PTR tv314[ebp], edx
$LN157@fnProcessE:
	cmp	DWORD PTR tv314[ebp], 0
	jne	SHORT $LN31@fnProcessE

; 509  :          {
; 510  :             lpViewEntity->bDerived = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 8192				; 00002000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx

; 511  :             lpViewEntity->bDerivedPath = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 16384				; 00004000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx

; 512  :             lpViewOD->bHasDerivedPath = TRUE;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	or	ecx, 4
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [edx+240], ecx

; 513  :          }

	jmp	$LN26@fnProcessE
$LN31@fnProcessE:

; 514  :          else
; 515  :          if ( zstrcmp( pchAttrName, szlDUPENTIN ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlDUPENTIN
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN160@fnProcessE
	mov	ecx, DWORD PTR _szlDUPENTIN
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv336[ebp], eax
	jmp	SHORT $LN161@fnProcessE
$LN160@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlDUPENTIN
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN158@fnProcessE
	mov	DWORD PTR tv335[ebp], 1
	jmp	SHORT $LN159@fnProcessE
$LN158@fnProcessE:
	mov	DWORD PTR tv335[ebp], -1
$LN159@fnProcessE:
	mov	ecx, DWORD PTR tv335[ebp]
	mov	DWORD PTR tv336[ebp], ecx
$LN161@fnProcessE:
	cmp	DWORD PTR tv336[ebp], 0
	jne	SHORT $LN33@fnProcessE

; 516  :          {
; 517  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN35@fnProcessE

; 518  :             {
; 519  :                lpViewEntity->bDupInstance = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 33554432				; 02000000H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+235], edx

; 520  :                lpViewOD->bHasDupInstance = TRUE;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	or	edx, 1
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [eax+240], edx
$LN35@fnProcessE:

; 521  :             }
; 522  :          }

	jmp	$LN26@fnProcessE
$LN33@fnProcessE:

; 523  :          else
; 524  :          if ( zstrcmp( pchAttrName, szlDUPRELIN ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlDUPRELIN
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN164@fnProcessE
	mov	edx, DWORD PTR _szlDUPRELIN
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv360[ebp], eax
	jmp	SHORT $LN165@fnProcessE
$LN164@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlDUPRELIN
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN162@fnProcessE
	mov	DWORD PTR tv359[ebp], 1
	jmp	SHORT $LN163@fnProcessE
$LN162@fnProcessE:
	mov	DWORD PTR tv359[ebp], -1
$LN163@fnProcessE:
	mov	edx, DWORD PTR tv359[ebp]
	mov	DWORD PTR tv360[ebp], edx
$LN165@fnProcessE:
	cmp	DWORD PTR tv360[ebp], 0
	jne	SHORT $LN26@fnProcessE

; 525  :          {
; 526  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN26@fnProcessE

; 527  :             {
; 528  :                lpViewEntity->bDupRel     = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 67108864				; 04000000H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax

; 529  :                lpViewEntity->bDupRelPath = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 134217728				; 08000000H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax

; 530  :                lpViewOD->bHasDupRel      = TRUE;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	or	eax, 2
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [ecx+240], eax
$LN26@fnProcessE:

; 531  :             }
; 532  :          }
; 533  : 
; 534  :          break;

	jmp	$LN2@fnProcessE
$LN38@fnProcessE:

; 535  : 
; 536  :       // Entity attributes beginning with 'E'
; 537  :       case 'E':
; 538  : 
; 539  : #ifdef __LOAD_CONSTR__
; 540  :          if ( zstrcmp( pchAttrName, szlECACC ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlECACC
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN168@fnProcessE
	mov	eax, DWORD PTR _szlECACC
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv387[ebp], eax
	jmp	SHORT $LN169@fnProcessE
$LN168@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlECACC
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN166@fnProcessE
	mov	DWORD PTR tv386[ebp], 1
	jmp	SHORT $LN167@fnProcessE
$LN166@fnProcessE:
	mov	DWORD PTR tv386[ebp], -1
$LN167@fnProcessE:
	mov	eax, DWORD PTR tv386[ebp]
	mov	DWORD PTR tv387[ebp], eax
$LN169@fnProcessE:
	cmp	DWORD PTR tv387[ebp], 0
	jne	SHORT $LN39@fnProcessE

; 541  :          {
; 542  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN41@fnProcessE

; 543  :                lpViewEntity->bAcceptConstraint = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+239], ecx
$LN41@fnProcessE:

; 544  :          }

	jmp	$LN40@fnProcessE
$LN39@fnProcessE:

; 545  :          else
; 546  :          if ( zstrcmp( pchAttrName, szlECCAN ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlECCAN
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN172@fnProcessE
	mov	ecx, DWORD PTR _szlECCAN
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv408[ebp], eax
	jmp	SHORT $LN173@fnProcessE
$LN172@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlECCAN
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN170@fnProcessE
	mov	DWORD PTR tv407[ebp], 1
	jmp	SHORT $LN171@fnProcessE
$LN170@fnProcessE:
	mov	DWORD PTR tv407[ebp], -1
$LN171@fnProcessE:
	mov	ecx, DWORD PTR tv407[ebp]
	mov	DWORD PTR tv408[ebp], ecx
$LN173@fnProcessE:
	cmp	DWORD PTR tv408[ebp], 0
	jne	SHORT $LN42@fnProcessE

; 547  :          {
; 548  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN44@fnProcessE

; 549  :                lpViewEntity->bCancelConstraint = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+239], edx
$LN44@fnProcessE:

; 550  :          }

	jmp	$LN40@fnProcessE
$LN42@fnProcessE:

; 551  :          else
; 552  :          if ( zstrcmp( pchAttrName, szlECCR ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlECCR
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN176@fnProcessE
	mov	edx, DWORD PTR _szlECCR
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv429[ebp], eax
	jmp	SHORT $LN177@fnProcessE
$LN176@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlECCR
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN174@fnProcessE
	mov	DWORD PTR tv428[ebp], 1
	jmp	SHORT $LN175@fnProcessE
$LN174@fnProcessE:
	mov	DWORD PTR tv428[ebp], -1
$LN175@fnProcessE:
	mov	edx, DWORD PTR tv428[ebp]
	mov	DWORD PTR tv429[ebp], edx
$LN177@fnProcessE:
	cmp	DWORD PTR tv429[ebp], 0
	jne	SHORT $LN45@fnProcessE

; 553  :          {
; 554  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN47@fnProcessE

; 555  :                lpViewEntity->bCreateConstraint = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	or	eax, 2
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+239], eax
$LN47@fnProcessE:

; 556  :          }

	jmp	$LN40@fnProcessE
$LN45@fnProcessE:

; 557  :          else
; 558  :          if ( zstrcmp( pchAttrName, szlECDEL ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlECDEL
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN180@fnProcessE
	mov	eax, DWORD PTR _szlECDEL
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv450[ebp], eax
	jmp	SHORT $LN181@fnProcessE
$LN180@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlECDEL
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN178@fnProcessE
	mov	DWORD PTR tv449[ebp], 1
	jmp	SHORT $LN179@fnProcessE
$LN178@fnProcessE:
	mov	DWORD PTR tv449[ebp], -1
$LN179@fnProcessE:
	mov	eax, DWORD PTR tv449[ebp]
	mov	DWORD PTR tv450[ebp], eax
$LN181@fnProcessE:
	cmp	DWORD PTR tv450[ebp], 0
	jne	SHORT $LN48@fnProcessE

; 559  :          {
; 560  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN50@fnProcessE

; 561  :                lpViewEntity->bDeleteConstraint = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	or	ecx, 4
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+239], ecx
$LN50@fnProcessE:

; 562  :          }

	jmp	$LN40@fnProcessE
$LN48@fnProcessE:

; 563  :          else
; 564  :          if ( zstrcmp( pchAttrName, szlECEOPER ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlECEOPER
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN184@fnProcessE
	mov	ecx, DWORD PTR _szlECEOPER
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv471[ebp], eax
	jmp	SHORT $LN185@fnProcessE
$LN184@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlECEOPER
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN182@fnProcessE
	mov	DWORD PTR tv470[ebp], 1
	jmp	SHORT $LN183@fnProcessE
$LN182@fnProcessE:
	mov	DWORD PTR tv470[ebp], -1
$LN183@fnProcessE:
	mov	ecx, DWORD PTR tv470[ebp]
	mov	DWORD PTR tv471[ebp], ecx
$LN185@fnProcessE:
	cmp	DWORD PTR tv471[ebp], 0
	jne	SHORT $LN51@fnProcessE

; 565  :             zstrcpy( lpViewEntity->szECEOpername, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 146				; 00000092H
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	$LN40@fnProcessE
$LN51@fnProcessE:

; 566  :          else
; 567  :          if ( zstrcmp( pchAttrName, "ECEOPERN" ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14011
	cmp	eax, ecx
	jne	SHORT $LN188@fnProcessE
	push	OFFSET $SG14012
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv520[ebp], eax
	jmp	SHORT $LN189@fnProcessE
$LN188@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14013
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN186@fnProcessE
	mov	DWORD PTR tv519[ebp], 1
	jmp	SHORT $LN187@fnProcessE
$LN186@fnProcessE:
	mov	DWORD PTR tv519[ebp], -1
$LN187@fnProcessE:
	mov	eax, DWORD PTR tv519[ebp]
	mov	DWORD PTR tv520[ebp], eax
$LN189@fnProcessE:
	cmp	DWORD PTR tv520[ebp], 0
	jne	SHORT $LN53@fnProcessE

; 568  :          {
; 569  :             // ECEOPERN is no longer a valid attribute, but we keep it here to
; 570  :             // avoid error messages.
; 571  :          }

	jmp	$LN40@fnProcessE
$LN53@fnProcessE:

; 572  :          else
; 573  :          if ( zstrcmp( pchAttrName, szlECEXC ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlECEXC
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN192@fnProcessE
	mov	edx, DWORD PTR _szlECEXC
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv533[ebp], eax
	jmp	SHORT $LN193@fnProcessE
$LN192@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlECEXC
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN190@fnProcessE
	mov	DWORD PTR tv532[ebp], 1
	jmp	SHORT $LN191@fnProcessE
$LN190@fnProcessE:
	mov	DWORD PTR tv532[ebp], -1
$LN191@fnProcessE:
	mov	edx, DWORD PTR tv532[ebp]
	mov	DWORD PTR tv533[ebp], edx
$LN193@fnProcessE:
	cmp	DWORD PTR tv533[ebp], 0
	jne	SHORT $LN55@fnProcessE

; 574  :          {
; 575  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN57@fnProcessE

; 576  :                lpViewEntity->bExcludeConstraint = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+239], eax
$LN57@fnProcessE:

; 577  :          }

	jmp	$LN40@fnProcessE
$LN55@fnProcessE:

; 578  :          else
; 579  :          if ( zstrcmp( pchAttrName, szlECINC ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlECINC
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN196@fnProcessE
	mov	eax, DWORD PTR _szlECINC
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv554[ebp], eax
	jmp	SHORT $LN197@fnProcessE
$LN196@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlECINC
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN194@fnProcessE
	mov	DWORD PTR tv553[ebp], 1
	jmp	SHORT $LN195@fnProcessE
$LN194@fnProcessE:
	mov	DWORD PTR tv553[ebp], -1
$LN195@fnProcessE:
	mov	eax, DWORD PTR tv553[ebp]
	mov	DWORD PTR tv554[ebp], eax
$LN197@fnProcessE:
	cmp	DWORD PTR tv554[ebp], 0
	jne	SHORT $LN58@fnProcessE

; 580  :          {
; 581  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN60@fnProcessE

; 582  :                lpViewEntity->bIncludeConstraint = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	or	ecx, 8
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+239], ecx
$LN60@fnProcessE:

; 583  :          }

	jmp	$LN40@fnProcessE
$LN58@fnProcessE:

; 584  :          else
; 585  : #endif
; 586  :          if ( zstrcmp( pchAttrName, szlERENT_TOK ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlERENT_TOK
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN200@fnProcessE
	mov	ecx, DWORD PTR _szlERENT_TOK
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv575[ebp], eax
	jmp	SHORT $LN201@fnProcessE
$LN200@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlERENT_TOK
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN198@fnProcessE
	mov	DWORD PTR tv574[ebp], 1
	jmp	SHORT $LN199@fnProcessE
$LN198@fnProcessE:
	mov	DWORD PTR tv574[ebp], -1
$LN199@fnProcessE:
	mov	ecx, DWORD PTR tv574[ebp]
	mov	DWORD PTR tv575[ebp], ecx
$LN201@fnProcessE:
	cmp	DWORD PTR tv575[ebp], 0
	jne	$LN61@fnProcessE

; 587  :          {
; 588  :             LPVIEWENTITY lpParentViewEntity;
; 589  : 
; 590  :             lpViewEntity->lEREntTok = zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+195], eax

; 591  : 
; 592  :             // See if the entity is structurally recursive
; 593  :             for ( lpParentViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$4[ebp], eax
	jmp	SHORT $LN6@fnProcessE
$LN4@fnProcessE:

; 595  :                   lpParentViewEntity = zGETPTR( lpParentViewEntity->hParent ) )

	mov	ecx, DWORD PTR _lpParentViewEntity$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$4[ebp], eax
$LN6@fnProcessE:

; 594  :                   lpParentViewEntity;

	cmp	DWORD PTR _lpParentViewEntity$4[ebp], 0
	je	SHORT $LN5@fnProcessE

; 596  :             {
; 597  :                if ( lpParentViewEntity->lEREntTok == lpViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpParentViewEntity$4[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	jne	SHORT $LN63@fnProcessE

; 598  :                {
; 599  :                   lpParentViewEntity->bRecursivePar = TRUE;

	mov	eax, DWORD PTR _lpParentViewEntity$4[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 536870912				; 20000000H
	mov	edx, DWORD PTR _lpParentViewEntity$4[ebp]
	mov	DWORD PTR [edx+235], ecx

; 600  :                   lpViewEntity->bRecursiveSt = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 1024				; 00000400H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx

; 601  :                   break;

	jmp	SHORT $LN5@fnProcessE
$LN63@fnProcessE:

; 602  :                }
; 603  :             }

	jmp	SHORT $LN4@fnProcessE
$LN5@fnProcessE:

; 604  :          }

	jmp	$LN40@fnProcessE
$LN61@fnProcessE:

; 605  :          else
; 606  :          if ( zstrcmp( pchAttrName, szlERREL_TOK ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlERREL_TOK
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN204@fnProcessE
	mov	ecx, DWORD PTR _szlERREL_TOK
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv608[ebp], eax
	jmp	SHORT $LN205@fnProcessE
$LN204@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlERREL_TOK
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN202@fnProcessE
	mov	DWORD PTR tv607[ebp], 1
	jmp	SHORT $LN203@fnProcessE
$LN202@fnProcessE:
	mov	DWORD PTR tv607[ebp], -1
$LN203@fnProcessE:
	mov	ecx, DWORD PTR tv607[ebp]
	mov	DWORD PTR tv608[ebp], ecx
$LN205@fnProcessE:
	cmp	DWORD PTR tv608[ebp], 0
	jne	SHORT $LN64@fnProcessE

; 607  :             lpViewEntity->lERRelTok = zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+199], eax
	jmp	$LN40@fnProcessE
$LN64@fnProcessE:

; 608  :          else
; 609  :          if ( zstrcmp( pchAttrName, szlERREL_LINK ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlERREL_LINK
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN208@fnProcessE
	mov	eax, DWORD PTR _szlERREL_LINK
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv625[ebp], eax
	jmp	SHORT $LN209@fnProcessE
$LN208@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlERREL_LINK
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN206@fnProcessE
	mov	DWORD PTR tv624[ebp], 1
	jmp	SHORT $LN207@fnProcessE
$LN206@fnProcessE:
	mov	DWORD PTR tv624[ebp], -1
$LN207@fnProcessE:
	mov	eax, DWORD PTR tv624[ebp]
	mov	DWORD PTR tv625[ebp], eax
$LN209@fnProcessE:
	cmp	DWORD PTR tv625[ebp], 0
	jne	SHORT $LN66@fnProcessE

; 610  :          {
; 611  :             if ( lpProcessInfo->szLine[ 0 ] == '1' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 49					; 00000031H
	jne	SHORT $LN68@fnProcessE

; 612  :                lpViewEntity->bRelLink1 = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 268435456				; 10000000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
$LN68@fnProcessE:

; 613  :          }

	jmp	$LN40@fnProcessE
$LN66@fnProcessE:

; 614  :          else
; 615  :          if ( zstrcmp( pchAttrName, szlEXCLUDE ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlEXCLUDE
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN212@fnProcessE
	mov	ecx, DWORD PTR _szlEXCLUDE
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv646[ebp], eax
	jmp	SHORT $LN213@fnProcessE
$LN212@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlEXCLUDE
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN210@fnProcessE
	mov	DWORD PTR tv645[ebp], 1
	jmp	SHORT $LN211@fnProcessE
$LN210@fnProcessE:
	mov	DWORD PTR tv645[ebp], -1
$LN211@fnProcessE:
	mov	ecx, DWORD PTR tv645[ebp]
	mov	DWORD PTR tv646[ebp], ecx
$LN213@fnProcessE:
	cmp	DWORD PTR tv646[ebp], 0
	jne	SHORT $LN40@fnProcessE

; 616  :             lpViewEntity->bExclude = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax
$LN40@fnProcessE:

; 617  : 
; 618  :          break;

	jmp	$LN2@fnProcessE
$LN70@fnProcessE:

; 619  : 
; 620  :       // Entity attributes beginning with 'F'
; 621  :       case 'F':
; 622  :          if ( zstrcmp( pchAttrName, szlFULLPERSIST ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFULLPERSIST
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN216@fnProcessE
	mov	eax, DWORD PTR _szlFULLPERSIST
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv662[ebp], eax
	jmp	SHORT $LN217@fnProcessE
$LN216@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlFULLPERSIST
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN214@fnProcessE
	mov	DWORD PTR tv661[ebp], 1
	jmp	SHORT $LN215@fnProcessE
$LN214@fnProcessE:
	mov	DWORD PTR tv661[ebp], -1
$LN215@fnProcessE:
	mov	eax, DWORD PTR tv661[ebp]
	mov	DWORD PTR tv662[ebp], eax
$LN217@fnProcessE:
	cmp	DWORD PTR tv662[ebp], 0
	jne	SHORT $LN71@fnProcessE

; 623  :             lpViewEntity->bFullPersist = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 4194304				; 00400000H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+235], edx
$LN71@fnProcessE:

; 624  : 
; 625  :          break;

	jmp	$LN2@fnProcessE
$LN72@fnProcessE:

; 626  : 
; 627  :       // Entity attributes beginning with 'H'
; 628  :       case 'H':
; 629  :          if ( zstrcmp( pchAttrName, szlHIDDEN ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlHIDDEN
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN220@fnProcessE
	mov	edx, DWORD PTR _szlHIDDEN
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv678[ebp], eax
	jmp	SHORT $LN221@fnProcessE
$LN220@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlHIDDEN
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN218@fnProcessE
	mov	DWORD PTR tv677[ebp], 1
	jmp	SHORT $LN219@fnProcessE
$LN218@fnProcessE:
	mov	DWORD PTR tv677[ebp], -1
$LN219@fnProcessE:
	mov	edx, DWORD PTR tv677[ebp]
	mov	DWORD PTR tv678[ebp], edx
$LN221@fnProcessE:
	cmp	DWORD PTR tv678[ebp], 0
	jne	SHORT $LN73@fnProcessE

; 630  :             lpViewEntity->bHidden = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	jmp	$LN74@fnProcessE
$LN73@fnProcessE:

; 631  :          else
; 632  :          if ( zstrcmp( pchAttrName, "HANG_FK" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14035
	cmp	ecx, edx
	jne	SHORT $LN224@fnProcessE
	push	OFFSET $SG14036
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv694[ebp], eax
	jmp	SHORT $LN225@fnProcessE
$LN224@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14037
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN222@fnProcessE
	mov	DWORD PTR tv693[ebp], 1
	jmp	SHORT $LN223@fnProcessE
$LN222@fnProcessE:
	mov	DWORD PTR tv693[ebp], -1
$LN223@fnProcessE:
	mov	ecx, DWORD PTR tv693[ebp]
	mov	DWORD PTR tv694[ebp], ecx
$LN225@fnProcessE:
	cmp	DWORD PTR tv694[ebp], 0
	jne	SHORT $LN74@fnProcessE

; 633  :          {
; 634  :             if ( toupper( lpProcessInfo->szLine[ 0 ] ) == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN74@fnProcessE

; 635  :                lpViewEntity->bHangingFKey = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+239], edx
$LN74@fnProcessE:

; 636  :          }
; 637  : 
; 638  :          break;

	jmp	$LN2@fnProcessE
$LN77@fnProcessE:

; 639  : 
; 640  :       // Entity attributes beginning with 'I'
; 641  :       case 'I':
; 642  :          if ( zstrcmp( pchAttrName, szlINCLSRC ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlINCLSRC
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN228@fnProcessE
	mov	edx, DWORD PTR _szlINCLSRC
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv717[ebp], eax
	jmp	SHORT $LN229@fnProcessE
$LN228@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlINCLSRC
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN226@fnProcessE
	mov	DWORD PTR tv716[ebp], 1
	jmp	SHORT $LN227@fnProcessE
$LN226@fnProcessE:
	mov	DWORD PTR tv716[ebp], -1
$LN227@fnProcessE:
	mov	edx, DWORD PTR tv716[ebp]
	mov	DWORD PTR tv717[ebp], edx
$LN229@fnProcessE:
	cmp	DWORD PTR tv717[ebp], 0
	jne	SHORT $LN78@fnProcessE

; 643  :             lpViewEntity->bInclSrc = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	jmp	$LN79@fnProcessE
$LN78@fnProcessE:

; 644  :          else
; 645  :          if ( zstrcmp( pchAttrName, szlINCLUDE ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlINCLUDE
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN232@fnProcessE
	mov	ecx, DWORD PTR _szlINCLUDE
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv733[ebp], eax
	jmp	SHORT $LN233@fnProcessE
$LN232@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlINCLUDE
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN230@fnProcessE
	mov	DWORD PTR tv732[ebp], 1
	jmp	SHORT $LN231@fnProcessE
$LN230@fnProcessE:
	mov	DWORD PTR tv732[ebp], -1
$LN231@fnProcessE:
	mov	ecx, DWORD PTR tv732[ebp]
	mov	DWORD PTR tv733[ebp], ecx
$LN233@fnProcessE:
	cmp	DWORD PTR tv733[ebp], 0
	jne	SHORT $LN80@fnProcessE

; 646  :             lpViewEntity->bInclude = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 8
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax
	jmp	$LN79@fnProcessE
$LN80@fnProcessE:

; 647  :          else
; 648  :          if ( zstrcmp( pchAttrName, szlINCRLOAD ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlINCRLOAD
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN236@fnProcessE
	mov	eax, DWORD PTR _szlINCRLOAD
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv749[ebp], eax
	jmp	SHORT $LN237@fnProcessE
$LN236@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlINCRLOAD
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN234@fnProcessE
	mov	DWORD PTR tv748[ebp], 1
	jmp	SHORT $LN235@fnProcessE
$LN234@fnProcessE:
	mov	DWORD PTR tv748[ebp], -1
$LN235@fnProcessE:
	mov	eax, DWORD PTR tv748[ebp]
	mov	DWORD PTR tv749[ebp], eax
$LN237@fnProcessE:
	cmp	DWORD PTR tv749[ebp], 0
	jne	SHORT $LN79@fnProcessE

; 649  :             lpViewEntity->bIncrLoad = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 2097152				; 00200000H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+235], edx
$LN79@fnProcessE:

; 650  : 
; 651  :          break;

	jmp	$LN2@fnProcessE
$LN83@fnProcessE:

; 652  : 
; 653  :       case 'L':
; 654  :          if ( zstrcmp( pchAttrName, szlLOCK ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlLOCK
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN240@fnProcessE
	mov	edx, DWORD PTR _szlLOCK
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv765[ebp], eax
	jmp	SHORT $LN241@fnProcessE
$LN240@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlLOCK
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN238@fnProcessE
	mov	DWORD PTR tv764[ebp], 1
	jmp	SHORT $LN239@fnProcessE
$LN238@fnProcessE:
	mov	DWORD PTR tv764[ebp], -1
$LN239@fnProcessE:
	mov	edx, DWORD PTR tv764[ebp]
	mov	DWORD PTR tv765[ebp], edx
$LN241@fnProcessE:
	cmp	DWORD PTR tv765[ebp], 0
	jne	SHORT $LN86@fnProcessE

; 655  :          {
; 656  :             lpViewEntity->nLock = (zBYTE) zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	BYTE PTR [edx+230], al

; 657  : 
; 658  :             // Keep track of highest entity locking level.
; 659  :             if ( lpViewEntity->nLock > lpViewOD->nEntityLock )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+230]
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+237]
	cmp	ecx, eax
	jle	SHORT $LN86@fnProcessE

; 660  :                lpViewOD->nEntityLock = lpViewEntity->nLock;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	al, BYTE PTR [edx+230]
	mov	BYTE PTR [ecx+237], al
$LN86@fnProcessE:

; 661  :          }
; 662  : 
; 663  :       // Entity attributes beginning with 'M'
; 664  :       case 'M':
; 665  :          if ( zstrcmp( pchAttrName, "MAX_LTH" ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14050
	cmp	edx, eax
	jne	SHORT $LN244@fnProcessE
	push	OFFSET $SG14051
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv790[ebp], eax
	jmp	SHORT $LN245@fnProcessE
$LN244@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14052
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN242@fnProcessE
	mov	DWORD PTR tv789[ebp], 1
	jmp	SHORT $LN243@fnProcessE
$LN242@fnProcessE:
	mov	DWORD PTR tv789[ebp], -1
$LN243@fnProcessE:
	mov	edx, DWORD PTR tv789[ebp]
	mov	DWORD PTR tv790[ebp], edx
$LN245@fnProcessE:
	cmp	DWORD PTR tv790[ebp], 0
	jne	SHORT $LN87@fnProcessE

; 666  :             lpViewEntity->ulMaxLth = (zULONG) zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+203], eax
$LN87@fnProcessE:

; 667  : 
; 668  :          break;

	jmp	$LN2@fnProcessE
$LN88@fnProcessE:

; 669  : 
; 670  :       // Entity attributes beginning with 'N'
; 671  :       case 'N':
; 672  :          if ( zstrcmp( pchAttrName, szlNAME ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlNAME
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN248@fnProcessE
	mov	ecx, DWORD PTR _szlNAME
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv807[ebp], eax
	jmp	SHORT $LN249@fnProcessE
$LN248@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlNAME
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN246@fnProcessE
	mov	DWORD PTR tv806[ebp], 1
	jmp	SHORT $LN247@fnProcessE
$LN246@fnProcessE:
	mov	DWORD PTR tv806[ebp], -1
$LN247@fnProcessE:
	mov	ecx, DWORD PTR tv806[ebp]
	mov	DWORD PTR tv807[ebp], ecx
$LN249@fnProcessE:
	cmp	DWORD PTR tv807[ebp], 0
	jne	SHORT $LN89@fnProcessE

; 673  :             zstrcpy( lpViewEntity->szName, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	call	_strcpy
	add	esp, 8
$LN89@fnProcessE:

; 674  : 
; 675  :          break;

	jmp	$LN2@fnProcessE
$LN90@fnProcessE:

; 676  : 
; 677  :       // Entity attributes beginning with 'P'
; 678  :       case 'P':
; 679  :          if ( zstrcmp( pchAttrName, szlPDELETE ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlPDELETE
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN252@fnProcessE
	mov	eax, DWORD PTR _szlPDELETE
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv824[ebp], eax
	jmp	SHORT $LN253@fnProcessE
$LN252@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlPDELETE
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN250@fnProcessE
	mov	DWORD PTR tv823[ebp], 1
	jmp	SHORT $LN251@fnProcessE
$LN250@fnProcessE:
	mov	DWORD PTR tv823[ebp], -1
$LN251@fnProcessE:
	mov	eax, DWORD PTR tv823[ebp]
	mov	DWORD PTR tv824[ebp], eax
$LN253@fnProcessE:
	cmp	DWORD PTR tv824[ebp], 0
	jne	$LN91@fnProcessE

; 680  :          {
; 681  :             if ( lpProcessInfo->szLine[ 0 ] == 'D' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 68					; 00000044H
	jne	SHORT $LN92@fnProcessE

; 682  :                lpViewEntity->bPDelete = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
	jmp	SHORT $LN91@fnProcessE
$LN92@fnProcessE:

; 683  :             else
; 684  :             if ( lpProcessInfo->szLine[ 0 ] == 'R' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 82					; 00000052H
	jne	SHORT $LN91@fnProcessE

; 685  :             {
; 686  :                LPVIEWENTITY lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$2[ebp], eax

; 687  : 
; 688  :                lpViewEntity->bPRestrict = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+235], edx

; 689  :                lpParent->bCheckRestrict = TRUE;

	mov	ecx, DWORD PTR _lpParent$2[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 512				; 00000200H
	mov	eax, DWORD PTR _lpParent$2[ebp]
	mov	DWORD PTR [eax+235], edx
$LN91@fnProcessE:

; 690  :             }
; 691  :          }
; 692  : 
; 693  :          break;

	jmp	$LN2@fnProcessE
$LN95@fnProcessE:

; 694  : 
; 695  :       // Entity attributes beginning with 'R'
; 696  :       case 'R':
; 697  :          if ( zstrcmp( pchAttrName, szlRECURSIVE ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlRECURSIVE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN256@fnProcessE
	mov	edx, DWORD PTR _szlRECURSIVE
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv859[ebp], eax
	jmp	SHORT $LN257@fnProcessE
$LN256@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlRECURSIVE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN254@fnProcessE
	mov	DWORD PTR tv858[ebp], 1
	jmp	SHORT $LN255@fnProcessE
$LN254@fnProcessE:
	mov	DWORD PTR tv858[ebp], -1
$LN255@fnProcessE:
	mov	edx, DWORD PTR tv858[ebp]
	mov	DWORD PTR tv859[ebp], edx
$LN257@fnProcessE:
	cmp	DWORD PTR tv859[ebp], 0
	jne	$LN96@fnProcessE

; 698  :          {
; 699  :             if ( lpViewEntity->bRecursiveSt )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN97@fnProcessE

; 700  :                lpViewEntity->bRecursive = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 2048				; 00000800H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax
	jmp	SHORT $LN96@fnProcessE
$LN97@fnProcessE:

; 701  :             else
; 702  :             {
; 703  :                LPTASK lpTask = zGETPTR( lpProcessInfo->lpView->hTask );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+322]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 704  : // "KZOEE063 - Entity attrib RECURSIVE Y, but not structurally recursive "
; 705  :                fnIssueCoreError( lpTask, lpProcessInfo->lpView, 16, 63,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 41					; 00000029H
	push	eax
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+298]
	push	edx
	push	63					; 0000003fH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+322]
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 706  :                                  lpProcessInfo->lLine,
; 707  :                                  lpProcessInfo->szFileName,
; 708  :                                  lpViewEntity->szName );
; 709  :                lpProcessInfo->nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [ecx+318], ax
$LN96@fnProcessE:

; 710  :             }
; 711  :          }
; 712  : 
; 713  :          break;

	jmp	$LN2@fnProcessE
$LN99@fnProcessE:

; 714  : 
; 715  :       // Entity attributes beginning with 'S'
; 716  :       case 'S':
; 717  :          if ( zstrcmp( pchAttrName, szlSERVER ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlSERVER
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN260@fnProcessE
	mov	eax, DWORD PTR _szlSERVER
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv895[ebp], eax
	jmp	SHORT $LN261@fnProcessE
$LN260@fnProcessE:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlSERVER
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN258@fnProcessE
	mov	DWORD PTR tv894[ebp], 1
	jmp	SHORT $LN259@fnProcessE
$LN258@fnProcessE:
	mov	DWORD PTR tv894[ebp], -1
$LN259@fnProcessE:
	mov	eax, DWORD PTR tv894[ebp]
	mov	DWORD PTR tv895[ebp], eax
$LN261@fnProcessE:
	cmp	DWORD PTR tv895[ebp], 0
	jne	$LN100@fnProcessE

; 718  :          {
; 719  :             if ( zstrcmp( lpViewOD->szDfltServer, lpProcessInfo->szLine ) == 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+76]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	cmp	edx, eax
	jne	SHORT $LN264@fnProcessE
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv916[ebp], eax
	jmp	SHORT $LN265@fnProcessE
$LN264@fnProcessE:
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+76]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN262@fnProcessE
	mov	DWORD PTR tv915[ebp], 1
	jmp	SHORT $LN263@fnProcessE
$LN262@fnProcessE:
	mov	DWORD PTR tv915[ebp], -1
$LN263@fnProcessE:
	mov	ecx, DWORD PTR tv915[ebp]
	mov	DWORD PTR tv916[ebp], ecx
$LN265@fnProcessE:
	cmp	DWORD PTR tv916[ebp], 0
	jne	SHORT $LN101@fnProcessE

; 720  :                zstrcpy( lpViewEntity->szServer, lpViewOD->szDfltServer );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 76					; 0000004cH
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 113				; 00000071H
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN100@fnProcessE
$LN101@fnProcessE:

; 721  :             else
; 722  :                zstrcpy( lpViewEntity->szServer, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 113				; 00000071H
	push	eax
	call	_strcpy
	add	esp, 8
$LN100@fnProcessE:

; 723  :          }
; 724  : 
; 725  :          break;

	jmp	$LN2@fnProcessE
$LN103@fnProcessE:

; 726  : 
; 727  :       // Entity attributes beginning with 'U'
; 728  :       case 'U':
; 729  :          if ( zstrcmp( pchAttrName, szlUPDATE ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlUPDATE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN268@fnProcessE
	mov	edx, DWORD PTR _szlUPDATE
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv937[ebp], eax
	jmp	SHORT $LN269@fnProcessE
$LN268@fnProcessE:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlUPDATE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN266@fnProcessE
	mov	DWORD PTR tv936[ebp], 1
	jmp	SHORT $LN267@fnProcessE
$LN266@fnProcessE:
	mov	DWORD PTR tv936[ebp], -1
$LN267@fnProcessE:
	mov	edx, DWORD PTR tv936[ebp]
	mov	DWORD PTR tv937[ebp], edx
$LN269@fnProcessE:
	cmp	DWORD PTR tv937[ebp], 0
	jne	SHORT $LN104@fnProcessE

; 730  :          {
; 731  :             if ( lpProcessInfo->szLine[ 0 ] != 'N' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 78					; 0000004eH
	je	SHORT $LN104@fnProcessE

; 732  :                lpViewEntity->bUpdate = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 4
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax
$LN104@fnProcessE:

; 733  :          }
; 734  : 
; 735  :          break;

	jmp	SHORT $LN2@fnProcessE
$LN106@fnProcessE:

; 736  : 
; 737  :       // Entity attributes beginning with 'X'
; 738  :       case 'X':
; 739  :          if ( zstrcmp( pchAttrName, "XML_NAME" ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14073
	cmp	eax, ecx
	jne	SHORT $LN272@fnProcessE
	push	OFFSET $SG14074
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv958[ebp], eax
	jmp	SHORT $LN273@fnProcessE
$LN272@fnProcessE:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14075
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN270@fnProcessE
	mov	DWORD PTR tv957[ebp], 1
	jmp	SHORT $LN271@fnProcessE
$LN270@fnProcessE:
	mov	DWORD PTR tv957[ebp], -1
$LN271@fnProcessE:
	mov	eax, DWORD PTR tv957[ebp]
	mov	DWORD PTR tv958[ebp], eax
$LN273@fnProcessE:
	cmp	DWORD PTR tv958[ebp], 0
	jne	SHORT $LN2@fnProcessE

; 740  :             zstrcpy( lpViewEntity->szXML_Name, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 47					; 0000002fH
	push	eax
	call	_strcpy
	add	esp, 8
$LN2@fnProcessE:

; 741  : 
; 742  :          break;
; 743  : 
; 744  :       // Skip other Entity attributes
; 745  :       default:
; 746  :          break;
; 747  :    }
; 748  : 
; 749  :    return( 0 );

	xor	eax, eax

; 750  : } // fnProcessEntityEntity

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN274@fnProcessE:
	DD	$LN7@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN17@fnProcessE
	DD	$LN24@fnProcessE
	DD	$LN38@fnProcessE
	DD	$LN70@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN72@fnProcessE
	DD	$LN77@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN83@fnProcessE
	DD	$LN86@fnProcessE
	DD	$LN88@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN90@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN95@fnProcessE
	DD	$LN99@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN103@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN2@fnProcessE
	DD	$LN106@fnProcessE
_fnProcessEntityEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpSystemApp$1 = -272					; size = 4
_ptr$2 = -268						; size = 4
_pch$3 = -264						; size = 4
tv789 = -260						; size = 4
tv788 = -256						; size = 4
tv771 = -252						; size = 4
tv770 = -248						; size = 4
tv753 = -244						; size = 4
tv752 = -240						; size = 4
tv732 = -236						; size = 4
tv731 = -232						; size = 4
tv711 = -228						; size = 4
tv710 = -224						; size = 4
tv690 = -220						; size = 4
tv689 = -216						; size = 4
tv669 = -212						; size = 4
tv668 = -208						; size = 4
tv656 = -204						; size = 4
tv655 = -200						; size = 4
tv607 = -196						; size = 4
tv606 = -192						; size = 4
tv590 = -188						; size = 4
tv589 = -184						; size = 4
tv573 = -180						; size = 4
tv565 = -176						; size = 4
tv564 = -172						; size = 4
tv544 = -168						; size = 4
tv543 = -164						; size = 4
tv527 = -160						; size = 4
tv526 = -156						; size = 4
tv510 = -152						; size = 4
tv509 = -148						; size = 4
tv492 = -144						; size = 4
tv491 = -140						; size = 4
tv449 = -136						; size = 4
tv448 = -132						; size = 4
tv419 = -128						; size = 4
tv418 = -124						; size = 4
tv393 = -120						; size = 4
tv392 = -116						; size = 4
tv353 = -112						; size = 4
tv352 = -108						; size = 4
tv320 = -104						; size = 4
tv319 = -100						; size = 4
tv294 = -96						; size = 4
tv293 = -92						; size = 4
tv277 = -88						; size = 4
tv276 = -84						; size = 4
tv242 = -80						; size = 4
tv241 = -76						; size = 4
tv214 = -72						; size = 4
tv213 = -68						; size = 4
tv185 = -64						; size = 4
tv184 = -60						; size = 4
tv157 = -56						; size = 4
tv156 = -52						; size = 4
tv128 = -48						; size = 4
tv95 = -44						; size = 4
tv78 = -40						; size = 4
tv77 = -36						; size = 4
_ulLth$4 = -32						; size = 4
tv66 = -28						; size = 4
_hndl$ = -24						; size = 4
_lpLName$5 = -20					; size = 4
_lpLName$6 = -16					; size = 4
_lpDBHandler$7 = -12					; size = 4
_lpGKHandler$8 = -8					; size = 4
_pchAttrName$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewOD$ = 12						; size = 4
_lpProcessInfo$ = 16					; size = 4
_fnProcessObjectEntity PROC

; 112  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H

; 113  :    zPCHAR  pchAttrName;
; 114  :    zPVOID  hndl;
; 115  : 
; 116  :    pchAttrName = lpProcessInfo->szAttrName;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	add	eax, 8
	mov	DWORD PTR _pchAttrName$[ebp], eax

; 117  : 
; 118  :    switch ( *pchAttrName )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv66[ebp], edx
	mov	eax, DWORD PTR tv66[ebp]
	sub	eax, 67					; 00000043H
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 16			; 00000010H
	ja	$LN2@fnProcessO
	mov	ecx, DWORD PTR tv66[ebp]
	movzx	edx, BYTE PTR $LN199@fnProcessO[ecx]
	jmp	DWORD PTR $LN200@fnProcessO[edx*4]
$LN17@fnProcessO:

; 119  :    {
; 120  :       // Object Attributes beginning with C
; 121  :       case 'C':
; 122  :          if ( zstrcmp( pchAttrName, "CACHENUM" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13598
	cmp	ecx, edx
	jne	SHORT $LN87@fnProcessO
	push	OFFSET $SG13599
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN88@fnProcessO
$LN87@fnProcessO:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG13600
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN85@fnProcessO
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN86@fnProcessO
$LN85@fnProcessO:
	mov	DWORD PTR tv77[ebp], -1
$LN86@fnProcessO:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$LN88@fnProcessO:
	cmp	DWORD PTR tv78[ebp], 0
	jne	SHORT $LN18@fnProcessO

; 123  :             lpViewOD->cCacheNbr = (zCHAR) zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	BYTE PTR [ecx+238], al
$LN18@fnProcessO:

; 124  : 
; 125  :          break;

	jmp	$LN2@fnProcessO
$LN19@fnProcessO:

; 126  : 
; 127  :       // Object Attributes beginning with D
; 128  :       case 'D':
; 129  :          if ( zstrcmp( pchAttrName, szlDFT_DBNAME ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDFT_DBNAME
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN91@fnProcessO
	mov	eax, DWORD PTR _szlDFT_DBNAME
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN92@fnProcessO
$LN91@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDFT_DBNAME
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN89@fnProcessO
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN90@fnProcessO
$LN89@fnProcessO:
	mov	DWORD PTR tv95[ebp], -1
$LN90@fnProcessO:
	mov	eax, DWORD PTR tv95[ebp]
	mov	DWORD PTR tv128[ebp], eax
$LN92@fnProcessO:
	cmp	DWORD PTR tv128[ebp], 0
	jne	$LN20@fnProcessO

; 130  :          {
; 131  :             LPLNAME lpLName;
; 132  : 
; 133  :             lpLName = zGETPTR( lpProcessInfo->lpApp->hFirstLName );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+306]
	mov	eax, DWORD PTR [edx+1897]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLName$6[ebp], eax
$LN4@fnProcessO:

; 134  :             while ( lpLName )

	cmp	DWORD PTR _lpLName$6[ebp], 0
	je	$LN5@fnProcessO

; 135  :             {
; 136  :                if ( lpLName->nType == 2 &&

	mov	ecx, DWORD PTR _lpLName$6[ebp]
	movsx	edx, WORD PTR [ecx+6]
	cmp	edx, 2
	jne	SHORT $LN22@fnProcessO
	mov	eax, DWORD PTR _lpLName$6[ebp]
	movsx	ecx, BYTE PTR [eax+8]
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	edx, BYTE PTR [eax]
	cmp	ecx, edx
	jne	SHORT $LN95@fnProcessO
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpLName$6[ebp]
	add	edx, 8
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv157[ebp], eax
	jmp	SHORT $LN96@fnProcessO
$LN95@fnProcessO:
	mov	eax, DWORD PTR _lpLName$6[ebp]
	movsx	ecx, BYTE PTR [eax+8]
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	edx, BYTE PTR [eax]
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN93@fnProcessO
	mov	DWORD PTR tv156[ebp], 1
	jmp	SHORT $LN94@fnProcessO
$LN93@fnProcessO:
	mov	DWORD PTR tv156[ebp], -1
$LN94@fnProcessO:
	mov	eax, DWORD PTR tv156[ebp]
	mov	DWORD PTR tv157[ebp], eax
$LN96@fnProcessO:
	cmp	DWORD PTR tv157[ebp], 0
	jne	SHORT $LN22@fnProcessO

; 137  :                     zstrcmp( lpLName->szLName,
; 138  :                              lpProcessInfo->szLine ) == 0 )
; 139  :                {
; 140  :                   break;

	jmp	SHORT $LN5@fnProcessO
$LN22@fnProcessO:

; 141  :                }
; 142  : 
; 143  :                lpLName = zGETPTR( lpLName->hNextLName );

	mov	ecx, DWORD PTR _lpLName$6[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLName$6[ebp], eax

; 144  :             }

	jmp	$LN4@fnProcessO
$LN5@fnProcessO:

; 145  : 
; 146  :             if ( lpLName )

	cmp	DWORD PTR _lpLName$6[ebp], 0
	je	SHORT $LN23@fnProcessO

; 147  :             {
; 148  :                lpViewOD->bLogicalDBName = TRUE;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	or	ecx, 256				; 00000100H
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [edx+240], ecx

; 149  :                zstrcpy( lpViewOD->szDfltDBName, lpLName->szPName );

	mov	eax, DWORD PTR _lpLName$6[ebp]
	add	eax, 41					; 00000029H
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 43					; 0000002bH
	push	ecx
	call	_strcpy
	add	esp, 8

; 150  :             }

	jmp	SHORT $LN24@fnProcessO
$LN23@fnProcessO:

; 151  :             else
; 152  :                zstrcpy( lpViewOD->szDfltDBName, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 43					; 0000002bH
	push	ecx
	call	_strcpy
	add	esp, 8
$LN24@fnProcessO:

; 153  :          }

	jmp	$LN21@fnProcessO
$LN20@fnProcessO:

; 154  :          else
; 155  :          if ( zstrcmp( pchAttrName, szlDFT_SERVER ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDFT_SERVER
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN99@fnProcessO
	mov	eax, DWORD PTR _szlDFT_SERVER
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN100@fnProcessO
$LN99@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlDFT_SERVER
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN97@fnProcessO
	mov	DWORD PTR tv184[ebp], 1
	jmp	SHORT $LN98@fnProcessO
$LN97@fnProcessO:
	mov	DWORD PTR tv184[ebp], -1
$LN98@fnProcessO:
	mov	eax, DWORD PTR tv184[ebp]
	mov	DWORD PTR tv185[ebp], eax
$LN100@fnProcessO:
	cmp	DWORD PTR tv185[ebp], 0
	jne	$LN25@fnProcessO

; 156  :          {
; 157  :             LPLNAME lpLName;
; 158  : 
; 159  :             lpLName = zGETPTR( lpProcessInfo->lpApp->hFirstLName );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+306]
	mov	eax, DWORD PTR [edx+1897]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLName$5[ebp], eax
$LN6@fnProcessO:

; 160  :             while ( lpLName )

	cmp	DWORD PTR _lpLName$5[ebp], 0
	je	$LN7@fnProcessO

; 161  :             {
; 162  :                if ( lpLName->nType == 1 &&

	mov	ecx, DWORD PTR _lpLName$5[ebp]
	movsx	edx, WORD PTR [ecx+6]
	cmp	edx, 1
	jne	SHORT $LN27@fnProcessO
	mov	eax, DWORD PTR _lpLName$5[ebp]
	movsx	ecx, BYTE PTR [eax+8]
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	edx, BYTE PTR [eax]
	cmp	ecx, edx
	jne	SHORT $LN103@fnProcessO
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpLName$5[ebp]
	add	edx, 8
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv214[ebp], eax
	jmp	SHORT $LN104@fnProcessO
$LN103@fnProcessO:
	mov	eax, DWORD PTR _lpLName$5[ebp]
	movsx	ecx, BYTE PTR [eax+8]
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	edx, BYTE PTR [eax]
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN101@fnProcessO
	mov	DWORD PTR tv213[ebp], 1
	jmp	SHORT $LN102@fnProcessO
$LN101@fnProcessO:
	mov	DWORD PTR tv213[ebp], -1
$LN102@fnProcessO:
	mov	eax, DWORD PTR tv213[ebp]
	mov	DWORD PTR tv214[ebp], eax
$LN104@fnProcessO:
	cmp	DWORD PTR tv214[ebp], 0
	jne	SHORT $LN27@fnProcessO

; 163  :                     zstrcmp( lpLName->szLName, lpProcessInfo->szLine ) == 0 )
; 164  :                {
; 165  :                   break;

	jmp	SHORT $LN7@fnProcessO
$LN27@fnProcessO:

; 166  :                }
; 167  : 
; 168  :                lpLName = zGETPTR( lpLName->hNextLName );

	mov	ecx, DWORD PTR _lpLName$5[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLName$5[ebp], eax

; 169  :             }

	jmp	$LN6@fnProcessO
$LN7@fnProcessO:

; 170  : 
; 171  :             if ( lpLName )

	cmp	DWORD PTR _lpLName$5[ebp], 0
	je	SHORT $LN28@fnProcessO

; 172  :             {
; 173  :                lpViewOD->bLogicalServerName = TRUE;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [edx+240], ecx

; 174  :                zstrcpy( lpViewOD->szDfltServer, lpLName->szPName );

	mov	eax, DWORD PTR _lpLName$5[ebp]
	add	eax, 41					; 00000029H
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	_strcpy
	add	esp, 8

; 175  :             }

	jmp	SHORT $LN29@fnProcessO
$LN28@fnProcessO:

; 176  :             else
; 177  :                zstrcpy( lpViewOD->szDfltServer, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	_strcpy
	add	esp, 8
$LN29@fnProcessO:

; 178  :          }

	jmp	$LN21@fnProcessO
$LN25@fnProcessO:

; 179  :          else
; 180  :          if ( zstrcmp( pchAttrName, "DBH_Data" ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13613
	cmp	eax, ecx
	jne	SHORT $LN107@fnProcessO
	push	OFFSET $SG13614
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv242[ebp], eax
	jmp	SHORT $LN108@fnProcessO
$LN107@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13615
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN105@fnProcessO
	mov	DWORD PTR tv241[ebp], 1
	jmp	SHORT $LN106@fnProcessO
$LN105@fnProcessO:
	mov	DWORD PTR tv241[ebp], -1
$LN106@fnProcessO:
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR tv242[ebp], eax
$LN108@fnProcessO:
	cmp	DWORD PTR tv242[ebp], 0
	jne	$LN21@fnProcessO

; 181  :          {
; 182  :             zULONG ulLth;
; 183  :             zPVOID ptr;
; 184  :             zPCHAR pch;
; 185  : 
; 186  :             ulLth = zatol( lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$4[ebp], eax

; 187  :             lpViewOD->hDBH_Data = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _ulLth$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [ecx+244], eax

; 188  :                                                     ulLth, 1, 0, 0 );
; 189  :             ptr = zGETPTR( lpViewOD->hDBH_Data );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+244]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _ptr$2[ebp], eax

; 190  : 
; 191  :             SysReadLineLth( lpView, &pch, lpProcessInfo->hFile, ulLth );

	mov	ecx, DWORD PTR _ulLth$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	lea	ecx, DWORD PTR _pch$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysReadLineLth@16

; 192  :             zmemcpy( ptr, pch, ulLth );

	mov	eax, DWORD PTR _ulLth$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _ptr$2[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN21@fnProcessO:

; 193  :          }
; 194  : 
; 195  :          break;

	jmp	$LN2@fnProcessO
$LN31@fnProcessO:

; 196  : 
; 197  :       case 'E':
; 198  :          if ( zstrcmp( pchAttrName, "ER_DATE" ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13618
	cmp	ecx, edx
	jne	SHORT $LN111@fnProcessO
	push	OFFSET $SG13619
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv277[ebp], eax
	jmp	SHORT $LN112@fnProcessO
$LN111@fnProcessO:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG13620
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN109@fnProcessO
	mov	DWORD PTR tv276[ebp], 1
	jmp	SHORT $LN110@fnProcessO
$LN109@fnProcessO:
	mov	DWORD PTR tv276[ebp], -1
$LN110@fnProcessO:
	mov	ecx, DWORD PTR tv276[ebp]
	mov	DWORD PTR tv277[ebp], ecx
$LN112@fnProcessO:
	cmp	DWORD PTR tv277[ebp], 0
	jne	SHORT $LN32@fnProcessO

; 199  :             zstrcpy( lpViewOD->szER_Date, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN32@fnProcessO:

; 200  : 
; 201  :          break;

	jmp	$LN2@fnProcessO
$LN33@fnProcessO:

; 202  : 
; 203  :       // Object Attributes beginning with G
; 204  :       case 'G':
; 205  :          if ( zstrcmp( pchAttrName, szlGKHANDLER ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlGKHANDLER
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN115@fnProcessO
	mov	eax, DWORD PTR _szlGKHANDLER
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv294[ebp], eax
	jmp	SHORT $LN116@fnProcessO
$LN115@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlGKHANDLER
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN113@fnProcessO
	mov	DWORD PTR tv293[ebp], 1
	jmp	SHORT $LN114@fnProcessO
$LN113@fnProcessO:
	mov	DWORD PTR tv293[ebp], -1
$LN114@fnProcessO:
	mov	eax, DWORD PTR tv293[ebp]
	mov	DWORD PTR tv294[ebp], eax
$LN116@fnProcessO:
	cmp	DWORD PTR tv294[ebp], 0
	jne	$LN34@fnProcessO

; 206  :          {
; 207  :             // Search Application and then system application
; 208  :             // handlers and link lpViewOD->hGKHandler to the
; 209  :             // appropriate handler found.
; 210  :             // Start searches from lpApp->hFirstGKHandler.
; 211  :             LPGKHANDLER lpGKHandler;
; 212  : 
; 213  :             // Look for GKHandler under current application.
; 214  :             lpGKHandler = zGETPTR( lpProcessInfo->lpApp->hFirstGKHandler );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+306]
	mov	eax, DWORD PTR [edx+80]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$8[ebp], eax
$LN8@fnProcessO:

; 215  :             while ( lpGKHandler &&

	cmp	DWORD PTR _lpGKHandler$8[ebp], 0
	je	SHORT $LN9@fnProcessO
	mov	ecx, DWORD PTR _lpGKHandler$8[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	cmp	edx, eax
	jne	SHORT $LN119@fnProcessO
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpGKHandler$8[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv320[ebp], eax
	jmp	SHORT $LN120@fnProcessO
$LN119@fnProcessO:
	mov	ecx, DWORD PTR _lpGKHandler$8[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN117@fnProcessO
	mov	DWORD PTR tv319[ebp], 1
	jmp	SHORT $LN118@fnProcessO
$LN117@fnProcessO:
	mov	DWORD PTR tv319[ebp], -1
$LN118@fnProcessO:
	mov	ecx, DWORD PTR tv319[ebp]
	mov	DWORD PTR tv320[ebp], ecx
$LN120@fnProcessO:
	cmp	DWORD PTR tv320[ebp], 0
	je	SHORT $LN9@fnProcessO

; 216  :                     zstrcmp( lpGKHandler->szName, lpProcessInfo->szLine ) != 0 )
; 217  :             {
; 218  :                lpGKHandler = zGETPTR( lpGKHandler->hNextGKHandler );

	mov	edx, DWORD PTR _lpGKHandler$8[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$8[ebp], eax

; 219  :             }

	jmp	SHORT $LN8@fnProcessO
$LN9@fnProcessO:

; 220  : 
; 221  :             // If GKhandler wasn't found under current application, look
; 222  :             // for it in the system application.
; 223  :             if ( lpGKHandler == 0 )

	cmp	DWORD PTR _lpGKHandler$8[ebp], 0
	jne	$LN35@fnProcessO

; 224  :             {
; 225  :                LPAPP lpSystemApp = lpProcessInfo->lpSystemApp;

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+302]
	mov	DWORD PTR _lpSystemApp$1[ebp], edx

; 226  : 
; 227  :                for ( lpGKHandler = zGETPTR( lpSystemApp->hFirstGKHandler );

	mov	eax, DWORD PTR _lpSystemApp$1[ebp]
	mov	ecx, DWORD PTR [eax+80]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$8[ebp], eax
	jmp	SHORT $LN12@fnProcessO
$LN10@fnProcessO:

; 229  :                      lpGKHandler = zGETPTR( lpGKHandler->hNextGKHandler ) )

	mov	edx, DWORD PTR _lpGKHandler$8[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$8[ebp], eax
$LN12@fnProcessO:

; 228  :                      lpGKHandler;

	cmp	DWORD PTR _lpGKHandler$8[ebp], 0
	je	SHORT $LN35@fnProcessO

; 230  :                {
; 231  :                   if ( zstrcmp( lpGKHandler->szName, lpProcessInfo->szLine ) == 0 )

	mov	ecx, DWORD PTR _lpGKHandler$8[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	cmp	edx, eax
	jne	SHORT $LN123@fnProcessO
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpGKHandler$8[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv353[ebp], eax
	jmp	SHORT $LN124@fnProcessO
$LN123@fnProcessO:
	mov	ecx, DWORD PTR _lpGKHandler$8[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN121@fnProcessO
	mov	DWORD PTR tv352[ebp], 1
	jmp	SHORT $LN122@fnProcessO
$LN121@fnProcessO:
	mov	DWORD PTR tv352[ebp], -1
$LN122@fnProcessO:
	mov	ecx, DWORD PTR tv352[ebp]
	mov	DWORD PTR tv353[ebp], ecx
$LN124@fnProcessO:
	cmp	DWORD PTR tv353[ebp], 0
	jne	SHORT $LN36@fnProcessO

; 232  :                      break;

	jmp	SHORT $LN35@fnProcessO
$LN36@fnProcessO:

; 233  :                }

	jmp	SHORT $LN10@fnProcessO
$LN35@fnProcessO:

; 234  :             }
; 235  : 
; 236  :             // If GKHandler wasn't found, create the GKHandler.
; 237  :             if ( lpGKHandler == 0 )

	cmp	DWORD PTR _lpGKHandler$8[ebp], 0
	jne	SHORT $LN37@fnProcessO

; 238  :             {
; 239  :                hndl = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10035					; 00002733H
	push	0
	push	1
	push	43					; 0000002bH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$[ebp], eax

; 240  :                                         sizeof( GKHandlerRecord ), 1, 0,
; 241  :                                         iGKHandler );
; 242  : 
; 243  :                // Set info in GKHandler object.
; 244  :                lpGKHandler = zGETPTR( hndl );

	mov	ecx, DWORD PTR _hndl$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$8[ebp], eax

; 245  :                if ( lpGKHandler )

	cmp	DWORD PTR _lpGKHandler$8[ebp], 0
	je	SHORT $LN37@fnProcessO

; 246  :                {
; 247  :                   lpGKHandler->hNextGKHandler =

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+306]
	mov	ecx, DWORD PTR _lpGKHandler$8[ebp]
	mov	edx, DWORD PTR [eax+80]
	mov	DWORD PTR [ecx+2], edx

; 248  :                                        lpProcessInfo->lpApp->hFirstGKHandler;
; 249  :                   lpProcessInfo->lpApp->hFirstGKHandler = hndl;

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+306]
	mov	edx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [ecx+80], edx

; 250  : 
; 251  :                   zstrcpy( lpGKHandler->szName, lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpGKHandler$8[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcpy
	add	esp, 8

; 252  :                   lpGKHandler->hApp = lpProcessInfo->lpApp;

	mov	eax, DWORD PTR _lpGKHandler$8[ebp]
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+306]
	mov	DWORD PTR [eax+6], edx
$LN37@fnProcessO:

; 253  :                }
; 254  :             }
; 255  : 
; 256  :             // If lpGKHandler is still not set, then set error.
; 257  :             // Otherwise link lpViewOD to the handler.
; 258  :             if ( lpGKHandler == 0 )

	cmp	DWORD PTR _lpGKHandler$8[ebp], 0
	jne	SHORT $LN39@fnProcessO

; 259  :             {
; 260  :                //  "KZOEE0xx - xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
; 261  :                // fnIssueCoreError( lpTask, lpView, 16, 54, lLine, szFileName, 0 );
; 262  :                lpProcessInfo->nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [ecx+318], ax

; 263  :             }

	jmp	SHORT $LN34@fnProcessO
$LN39@fnProcessO:

; 264  :             else
; 265  :                lpViewOD->hGKHandler = zGETHNDL( lpGKHandler );

	mov	edx, DWORD PTR _lpGKHandler$8[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [ecx+212], eax
$LN34@fnProcessO:

; 266  : 
; 267  :          }  // if ( zstrcmp( pchAttrName, szlGKHANDLER ) == 0 )...
; 268  : 
; 269  :          break;

	jmp	$LN2@fnProcessO
$LN41@fnProcessO:

; 270  : 
; 271  :       // Object Attributes beginning with H
; 272  :       case 'H':
; 273  :          if ( zstrcmp( pchAttrName, szlHANDLER ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlHANDLER
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN127@fnProcessO
	mov	eax, DWORD PTR _szlHANDLER
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv393[ebp], eax
	jmp	SHORT $LN128@fnProcessO
$LN127@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlHANDLER
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN125@fnProcessO
	mov	DWORD PTR tv392[ebp], 1
	jmp	SHORT $LN126@fnProcessO
$LN125@fnProcessO:
	mov	DWORD PTR tv392[ebp], -1
$LN126@fnProcessO:
	mov	eax, DWORD PTR tv392[ebp]
	mov	DWORD PTR tv393[ebp], eax
$LN128@fnProcessO:
	cmp	DWORD PTR tv393[ebp], 0
	jne	$LN42@fnProcessO

; 274  :          {
; 275  :             // Search Application and then system application
; 276  :             // handlers and link lpViewOD->hDBHandler to the
; 277  :             // appropriate handler found.
; 278  :             // Start searches from lpApp->hFirstDBHandler.
; 279  :             LPDBHANDLER lpDBHandler;
; 280  : 
; 281  :             // Look for DBHandler under current application.
; 282  :             lpDBHandler = zGETPTR( lpProcessInfo->lpApp->hFirstDBHandler );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+306]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$7[ebp], eax
$LN13@fnProcessO:

; 283  :             while ( lpDBHandler &&

	cmp	DWORD PTR _lpDBHandler$7[ebp], 0
	je	SHORT $LN14@fnProcessO
	mov	ecx, DWORD PTR _lpDBHandler$7[ebp]
	movsx	edx, BYTE PTR [ecx+11]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	cmp	edx, eax
	jne	SHORT $LN131@fnProcessO
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpDBHandler$7[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv419[ebp], eax
	jmp	SHORT $LN132@fnProcessO
$LN131@fnProcessO:
	mov	ecx, DWORD PTR _lpDBHandler$7[ebp]
	movsx	edx, BYTE PTR [ecx+11]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN129@fnProcessO
	mov	DWORD PTR tv418[ebp], 1
	jmp	SHORT $LN130@fnProcessO
$LN129@fnProcessO:
	mov	DWORD PTR tv418[ebp], -1
$LN130@fnProcessO:
	mov	ecx, DWORD PTR tv418[ebp]
	mov	DWORD PTR tv419[ebp], ecx
$LN132@fnProcessO:
	cmp	DWORD PTR tv419[ebp], 0
	je	SHORT $LN14@fnProcessO

; 284  :                     zstrcmp( lpDBHandler->szName, lpProcessInfo->szLine ) != 0 )
; 285  :             {
; 286  :                lpDBHandler = zGETPTR( lpDBHandler->hNextDBHandler );

	mov	edx, DWORD PTR _lpDBHandler$7[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$7[ebp], eax

; 287  :             }

	jmp	SHORT $LN13@fnProcessO
$LN14@fnProcessO:

; 288  : 
; 289  :             // If DBHandler wasn't found under current application, look
; 290  :             // for it in the system application.
; 291  :             if ( lpDBHandler == 0 )

	cmp	DWORD PTR _lpDBHandler$7[ebp], 0
	jne	$LN43@fnProcessO

; 292  :             {
; 293  :                lpDBHandler =

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+302]
	mov	eax, DWORD PTR [edx+76]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$7[ebp], eax
$LN15@fnProcessO:

; 294  :                      zGETPTR( lpProcessInfo->lpSystemApp->hFirstDBHandler );
; 295  :                while ( lpDBHandler &&

	cmp	DWORD PTR _lpDBHandler$7[ebp], 0
	je	$LN43@fnProcessO
	mov	ecx, DWORD PTR _lpDBHandler$7[ebp]
	movsx	edx, BYTE PTR [ecx+11]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	cmp	edx, eax
	jne	SHORT $LN135@fnProcessO
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpDBHandler$7[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv449[ebp], eax
	jmp	SHORT $LN136@fnProcessO
$LN135@fnProcessO:
	mov	ecx, DWORD PTR _lpDBHandler$7[ebp]
	movsx	edx, BYTE PTR [ecx+11]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	eax, BYTE PTR [ecx]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN133@fnProcessO
	mov	DWORD PTR tv448[ebp], 1
	jmp	SHORT $LN134@fnProcessO
$LN133@fnProcessO:
	mov	DWORD PTR tv448[ebp], -1
$LN134@fnProcessO:
	mov	ecx, DWORD PTR tv448[ebp]
	mov	DWORD PTR tv449[ebp], ecx
$LN136@fnProcessO:
	cmp	DWORD PTR tv449[ebp], 0
	je	SHORT $LN43@fnProcessO

; 296  :                        zstrcmp( lpDBHandler->szName, lpProcessInfo->szLine ) != 0 )
; 297  :                {
; 298  :                   lpDBHandler = zGETPTR( lpDBHandler->hNextDBHandler );

	mov	edx, DWORD PTR _lpDBHandler$7[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$7[ebp], eax

; 299  :                }

	jmp	$LN15@fnProcessO
$LN43@fnProcessO:

; 300  :             }
; 301  : 
; 302  :             // If DBHandler wasn't found, create the DBHandler.
; 303  :             if ( lpDBHandler == 0 )

	cmp	DWORD PTR _lpDBHandler$7[ebp], 0
	jne	SHORT $LN44@fnProcessO

; 304  :             {
; 305  :                hndl = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10005					; 00002715H
	push	0
	push	1
	push	44					; 0000002cH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$[ebp], eax

; 306  :                                         sizeof( DBHandlerRecord ), 1, 0,
; 307  :                                         iDBHandler );
; 308  : 
; 309  :                // Set info in DBHandler object.
; 310  :                lpDBHandler = zGETPTR( hndl );

	mov	eax, DWORD PTR _hndl$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$7[ebp], eax

; 311  :                if ( lpDBHandler )

	cmp	DWORD PTR _lpDBHandler$7[ebp], 0
	je	SHORT $LN44@fnProcessO

; 312  :                {
; 313  :                   lpDBHandler->hNextDBHandler =

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+306]
	mov	eax, DWORD PTR _lpDBHandler$7[ebp]
	mov	ecx, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+2], ecx

; 314  :                                        lpProcessInfo->lpApp->hFirstDBHandler;
; 315  :                   lpProcessInfo->lpApp->hFirstDBHandler = hndl;

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+306]
	mov	ecx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [eax+76], ecx

; 316  : 
; 317  :                   zstrcpy( lpDBHandler->szName, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpDBHandler$7[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	call	_strcpy
	add	esp, 8

; 318  :                   lpDBHandler->hApp = lpProcessInfo->lpApp;

	mov	edx, DWORD PTR _lpDBHandler$7[ebp]
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+306]
	mov	DWORD PTR [edx+6], ecx
$LN44@fnProcessO:

; 319  :                }
; 320  :             }
; 321  : 
; 322  :             // If lpDBHandler is still not set, then set error.
; 323  :             // Otherwise link lpViewOD to the handler.
; 324  :             if ( lpDBHandler == 0 )

	cmp	DWORD PTR _lpDBHandler$7[ebp], 0
	jne	SHORT $LN46@fnProcessO

; 325  :             {
; 326  :                //  "KZOEE0xx - xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
; 327  :                // fnIssueCoreError( lpTask, lpView, 16, 54, lLine, szFileName, 0 );
; 328  :                lpProcessInfo->nCurrState = 10;  // set error

	mov	edx, 10					; 0000000aH
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	WORD PTR [eax+318], dx

; 329  :             }

	jmp	SHORT $LN42@fnProcessO
$LN46@fnProcessO:

; 330  :             else
; 331  :                lpViewOD->hDBHandler = zGETHNDL( lpDBHandler );

	mov	ecx, DWORD PTR _lpDBHandler$7[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [edx+208], eax
$LN42@fnProcessO:

; 332  : 
; 333  :          }  // if ( zstrcmp( pchAttrName, "HANDLER" ) == 0 )...
; 334  : 
; 335  :          break;

	jmp	$LN2@fnProcessO
$LN48@fnProcessO:

; 336  : 
; 337  :       // Object Attributes beginning with L
; 338  :       case 'L':
; 339  :          if ( zstrcmp( pchAttrName, szlLOCK ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlLOCK
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN139@fnProcessO
	mov	ecx, DWORD PTR _szlLOCK
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv492[ebp], eax
	jmp	SHORT $LN140@fnProcessO
$LN139@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlLOCK
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN137@fnProcessO
	mov	DWORD PTR tv491[ebp], 1
	jmp	SHORT $LN138@fnProcessO
$LN137@fnProcessO:
	mov	DWORD PTR tv491[ebp], -1
$LN138@fnProcessO:
	mov	ecx, DWORD PTR tv491[ebp]
	mov	DWORD PTR tv492[ebp], ecx
$LN140@fnProcessO:
	cmp	DWORD PTR tv492[ebp], 0
	jne	SHORT $LN49@fnProcessO

; 340  :             lpViewOD->nLock = (zBYTE) zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	BYTE PTR [ecx+236], al
$LN49@fnProcessO:

; 341  : 
; 342  :          break;

	jmp	$LN2@fnProcessO

; 343  : 
; 344  :       // Object Attributes beginning with M
; 345  :       case 'M':
; 346  :          break;

	jmp	$LN2@fnProcessO
$LN51@fnProcessO:

; 347  : 
; 348  :       // Object Attributes beginning with N
; 349  :       case 'N':
; 350  :          if ( zstrcmp( pchAttrName, szlNAME ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlNAME
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN143@fnProcessO
	mov	eax, DWORD PTR _szlNAME
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv510[ebp], eax
	jmp	SHORT $LN144@fnProcessO
$LN143@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlNAME
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN141@fnProcessO
	mov	DWORD PTR tv509[ebp], 1
	jmp	SHORT $LN142@fnProcessO
$LN141@fnProcessO:
	mov	DWORD PTR tv509[ebp], -1
$LN142@fnProcessO:
	mov	eax, DWORD PTR tv509[ebp]
	mov	DWORD PTR tv510[ebp], eax
$LN144@fnProcessO:
	cmp	DWORD PTR tv510[ebp], 0
	jne	SHORT $LN52@fnProcessO

; 351  :             zstrcpy( lpViewOD->szName, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	$LN53@fnProcessO
$LN52@fnProcessO:

; 352  :          else
; 353  :          if ( zstrcmp( pchAttrName, szlNETWORK ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlNETWORK
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN147@fnProcessO
	mov	edx, DWORD PTR _szlNETWORK
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv527[ebp], eax
	jmp	SHORT $LN148@fnProcessO
$LN147@fnProcessO:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlNETWORK
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN145@fnProcessO
	mov	DWORD PTR tv526[ebp], 1
	jmp	SHORT $LN146@fnProcessO
$LN145@fnProcessO:
	mov	DWORD PTR tv526[ebp], -1
$LN146@fnProcessO:
	mov	edx, DWORD PTR tv526[ebp]
	mov	DWORD PTR tv527[ebp], edx
$LN148@fnProcessO:
	cmp	DWORD PTR tv527[ebp], 0
	jne	SHORT $LN54@fnProcessO

; 354  :             zstrcpy( lpViewOD->szNetwork, lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	$LN53@fnProcessO
$LN54@fnProcessO:

; 355  :          else
; 356  :          if ( zstrcmp( pchAttrName, szlNETCOMPRESS) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlNETCOMPRESS
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN151@fnProcessO
	mov	ecx, DWORD PTR _szlNETCOMPRESS
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv544[ebp], eax
	jmp	SHORT $LN152@fnProcessO
$LN151@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlNETCOMPRESS
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN149@fnProcessO
	mov	DWORD PTR tv543[ebp], 1
	jmp	SHORT $LN150@fnProcessO
$LN149@fnProcessO:
	mov	DWORD PTR tv543[ebp], -1
$LN150@fnProcessO:
	mov	ecx, DWORD PTR tv543[ebp]
	mov	DWORD PTR tv544[ebp], ecx
$LN152@fnProcessO:
	cmp	DWORD PTR tv544[ebp], 0
	jne	SHORT $LN53@fnProcessO

; 357  :          {
; 358  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN53@fnProcessO

; 359  :                lpViewOD->bNetCompress = TRUE;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	or	edx, 4096				; 00001000H
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [eax+240], edx
$LN53@fnProcessO:

; 360  :          }
; 361  : 
; 362  :          break;

	jmp	$LN2@fnProcessO
$LN58@fnProcessO:

; 363  : 
; 364  :       // Object Attributes beginning with O
; 365  :       case 'O':
; 366  :          if ( zstrcmp( pchAttrName, "ORDERBY" ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG13649
	cmp	edx, eax
	jne	SHORT $LN155@fnProcessO
	push	OFFSET $SG13650
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv565[ebp], eax
	jmp	SHORT $LN156@fnProcessO
$LN155@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13651
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN153@fnProcessO
	mov	DWORD PTR tv564[ebp], 1
	jmp	SHORT $LN154@fnProcessO
$LN153@fnProcessO:
	mov	DWORD PTR tv564[ebp], -1
$LN154@fnProcessO:
	mov	edx, DWORD PTR tv564[ebp]
	mov	DWORD PTR tv565[ebp], edx
$LN156@fnProcessO:
	cmp	DWORD PTR tv565[ebp], 0
	jne	SHORT $LN59@fnProcessO

; 367  :             lpViewOD->bUseOrderBy = (lpProcessInfo->szLine[ 0 ] == 'Y');

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN157@fnProcessO
	mov	DWORD PTR tv573[ebp], 1
	jmp	SHORT $LN158@fnProcessO
$LN157@fnProcessO:
	mov	DWORD PTR tv573[ebp], 0
$LN158@fnProcessO:
	mov	edx, DWORD PTR tv573[ebp]
	and	edx, 1
	shl	edx, 13					; 0000000dH
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	and	ecx, -8193				; ffffdfffH
	or	ecx, edx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [edx+240], ecx
	jmp	$LN60@fnProcessO
$LN59@fnProcessO:

; 368  : #ifdef __LOAD_CONSTR__
; 369  :          else
; 370  :          if ( zstrcmp( pchAttrName, szlOPER_LIBNM ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOPER_LIBNM
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN161@fnProcessO
	mov	ecx, DWORD PTR _szlOPER_LIBNM
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv590[ebp], eax
	jmp	SHORT $LN162@fnProcessO
$LN161@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOPER_LIBNM
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN159@fnProcessO
	mov	DWORD PTR tv589[ebp], 1
	jmp	SHORT $LN160@fnProcessO
$LN159@fnProcessO:
	mov	DWORD PTR tv589[ebp], -1
$LN160@fnProcessO:
	mov	ecx, DWORD PTR tv589[ebp]
	mov	DWORD PTR tv590[ebp], ecx
$LN162@fnProcessO:
	cmp	DWORD PTR tv590[ebp], 0
	jne	SHORT $LN61@fnProcessO

; 371  :             zstrcpy( lpViewOD->szOperLibname, lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 142				; 0000008eH
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	$LN60@fnProcessO
$LN61@fnProcessO:

; 372  :          else
; 373  :          if ( zstrcmp( pchAttrName, szlOCEOPER ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlOCEOPER
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN165@fnProcessO
	mov	eax, DWORD PTR _szlOCEOPER
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv607[ebp], eax
	jmp	SHORT $LN166@fnProcessO
$LN165@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlOCEOPER
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN163@fnProcessO
	mov	DWORD PTR tv606[ebp], 1
	jmp	SHORT $LN164@fnProcessO
$LN163@fnProcessO:
	mov	DWORD PTR tv606[ebp], -1
$LN164@fnProcessO:
	mov	eax, DWORD PTR tv606[ebp]
	mov	DWORD PTR tv607[ebp], eax
$LN166@fnProcessO:
	cmp	DWORD PTR tv607[ebp], 0
	jne	SHORT $LN63@fnProcessO

; 374  :             zstrcpy( lpViewOD->szOCEOpername, lpProcessInfo->szLine );

	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 175				; 000000afH
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	$LN60@fnProcessO
$LN63@fnProcessO:

; 375  :          else
; 376  :          if ( zstrcmp( pchAttrName, "OCEOPERN" ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG13658
	cmp	edx, eax
	jne	SHORT $LN169@fnProcessO
	push	OFFSET $SG13659
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv656[ebp], eax
	jmp	SHORT $LN170@fnProcessO
$LN169@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13660
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN167@fnProcessO
	mov	DWORD PTR tv655[ebp], 1
	jmp	SHORT $LN168@fnProcessO
$LN167@fnProcessO:
	mov	DWORD PTR tv655[ebp], -1
$LN168@fnProcessO:
	mov	edx, DWORD PTR tv655[ebp]
	mov	DWORD PTR tv656[ebp], edx
$LN170@fnProcessO:
	cmp	DWORD PTR tv656[ebp], 0
	jne	SHORT $LN65@fnProcessO

; 377  :          {
; 378  :             // OCEOPERN is no longer a valid attribute, but we keep it here to
; 379  :             // avoid error messages.
; 380  :          }

	jmp	$LN60@fnProcessO
$LN65@fnProcessO:

; 381  :          else
; 382  :          if ( zstrcmp( pchAttrName, szlOCACT ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOCACT
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN173@fnProcessO
	mov	ecx, DWORD PTR _szlOCACT
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv669[ebp], eax
	jmp	SHORT $LN174@fnProcessO
$LN173@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOCACT
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN171@fnProcessO
	mov	DWORD PTR tv668[ebp], 1
	jmp	SHORT $LN172@fnProcessO
$LN171@fnProcessO:
	mov	DWORD PTR tv668[ebp], -1
$LN172@fnProcessO:
	mov	ecx, DWORD PTR tv668[ebp]
	mov	DWORD PTR tv669[ebp], ecx
$LN174@fnProcessO:
	cmp	DWORD PTR tv669[ebp], 0
	jne	SHORT $LN67@fnProcessO

; 383  :          {
; 384  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN69@fnProcessO

; 385  :                lpViewOD->bActivateConstraint = TRUE;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	or	edx, 8
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [eax+240], edx
$LN69@fnProcessO:

; 386  :          }

	jmp	$LN60@fnProcessO
$LN67@fnProcessO:

; 387  :          else
; 388  :          if ( zstrcmp( pchAttrName, szlOCACTE ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlOCACTE
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN177@fnProcessO
	mov	edx, DWORD PTR _szlOCACTE
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv690[ebp], eax
	jmp	SHORT $LN178@fnProcessO
$LN177@fnProcessO:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlOCACTE
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN175@fnProcessO
	mov	DWORD PTR tv689[ebp], 1
	jmp	SHORT $LN176@fnProcessO
$LN175@fnProcessO:
	mov	DWORD PTR tv689[ebp], -1
$LN176@fnProcessO:
	mov	edx, DWORD PTR tv689[ebp]
	mov	DWORD PTR tv690[ebp], edx
$LN178@fnProcessO:
	cmp	DWORD PTR tv690[ebp], 0
	jne	SHORT $LN70@fnProcessO

; 389  :          {
; 390  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN72@fnProcessO

; 391  :                lpViewOD->bActivateEmptyConstraint = TRUE;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [ecx+240], eax
$LN72@fnProcessO:

; 392  :          }

	jmp	$LN60@fnProcessO
$LN70@fnProcessO:

; 393  :          else
; 394  :          if ( zstrcmp( pchAttrName, szlOCCOM ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlOCCOM
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN181@fnProcessO
	mov	eax, DWORD PTR _szlOCCOM
	push	eax
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv711[ebp], eax
	jmp	SHORT $LN182@fnProcessO
$LN181@fnProcessO:
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _szlOCCOM
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN179@fnProcessO
	mov	DWORD PTR tv710[ebp], 1
	jmp	SHORT $LN180@fnProcessO
$LN179@fnProcessO:
	mov	DWORD PTR tv710[ebp], -1
$LN180@fnProcessO:
	mov	eax, DWORD PTR tv710[ebp]
	mov	DWORD PTR tv711[ebp], eax
$LN182@fnProcessO:
	cmp	DWORD PTR tv711[ebp], 0
	jne	SHORT $LN73@fnProcessO

; 395  :          {
; 396  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN75@fnProcessO

; 397  :                lpViewOD->bCommitConstraint = TRUE;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [edx+240], ecx
$LN75@fnProcessO:

; 398  :          }

	jmp	$LN60@fnProcessO
$LN73@fnProcessO:

; 399  :          else
; 400  :          if ( zstrcmp( pchAttrName, szlOCDROP ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOCDROP
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN185@fnProcessO
	mov	ecx, DWORD PTR _szlOCDROP
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv732[ebp], eax
	jmp	SHORT $LN186@fnProcessO
$LN185@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOCDROP
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN183@fnProcessO
	mov	DWORD PTR tv731[ebp], 1
	jmp	SHORT $LN184@fnProcessO
$LN183@fnProcessO:
	mov	DWORD PTR tv731[ebp], -1
$LN184@fnProcessO:
	mov	ecx, DWORD PTR tv731[ebp]
	mov	DWORD PTR tv732[ebp], ecx
$LN186@fnProcessO:
	cmp	DWORD PTR tv732[ebp], 0
	jne	SHORT $LN76@fnProcessO

; 401  :          {
; 402  :             if ( lpProcessInfo->szLine[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpProcessInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN78@fnProcessO

; 403  :                lpViewOD->bDropOIConstraint = TRUE;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [eax+240], edx
$LN78@fnProcessO:

; 404  :          }

	jmp	$LN60@fnProcessO
$LN76@fnProcessO:

; 405  :          else
; 406  :          if ( zstrcmp( pchAttrName, szlOFBUFSZ ) == 0 )

	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlOFBUFSZ
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN189@fnProcessO
	mov	edx, DWORD PTR _szlOFBUFSZ
	push	edx
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv753[ebp], eax
	jmp	SHORT $LN190@fnProcessO
$LN189@fnProcessO:
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _szlOFBUFSZ
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN187@fnProcessO
	mov	DWORD PTR tv752[ebp], 1
	jmp	SHORT $LN188@fnProcessO
$LN187@fnProcessO:
	mov	DWORD PTR tv752[ebp], -1
$LN188@fnProcessO:
	mov	edx, DWORD PTR tv752[ebp]
	mov	DWORD PTR tv753[ebp], edx
$LN190@fnProcessO:
	cmp	DWORD PTR tv753[ebp], 0
	jne	SHORT $LN79@fnProcessO

; 407  :          {
; 408  :             lpViewOD->nOfBufSz = (zSHORT) zatol( lpProcessInfo->szLine );

	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	WORD PTR [edx+230], ax

; 409  :          }

	jmp	$LN60@fnProcessO
$LN79@fnProcessO:

; 410  :          else
; 411  :          if ( zstrcmp( pchAttrName, szlOFRECID ) == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOFRECID
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN193@fnProcessO
	mov	ecx, DWORD PTR _szlOFRECID
	push	ecx
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv771[ebp], eax
	jmp	SHORT $LN194@fnProcessO
$LN193@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _szlOFRECID
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN191@fnProcessO
	mov	DWORD PTR tv770[ebp], 1
	jmp	SHORT $LN192@fnProcessO
$LN191@fnProcessO:
	mov	DWORD PTR tv770[ebp], -1
$LN192@fnProcessO:
	mov	ecx, DWORD PTR tv770[ebp]
	mov	DWORD PTR tv771[ebp], ecx
$LN194@fnProcessO:
	cmp	DWORD PTR tv771[ebp], 0
	jne	SHORT $LN60@fnProcessO

; 412  :          {
; 413  :             lpViewOD->nOfRecID = (zSHORT) zatol( lpProcessInfo->szLine );

	mov	edx, DWORD PTR _lpProcessInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	WORD PTR [ecx+228], ax
$LN60@fnProcessO:

; 414  :          }
; 415  : #endif
; 416  :          break;

	jmp	$LN2@fnProcessO
$LN82@fnProcessO:

; 417  : 
; 418  :       // Object Attributes beginning with S
; 419  :       case 'S':
; 420  :          if ( zstrcmp( pchAttrName, "SironDB_Type" ) == 0 )

	mov	edx, DWORD PTR _pchAttrName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG13678
	cmp	eax, ecx
	jne	SHORT $LN197@fnProcessO
	push	OFFSET $SG13679
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv789[ebp], eax
	jmp	SHORT $LN198@fnProcessO
$LN197@fnProcessO:
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG13680
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN195@fnProcessO
	mov	DWORD PTR tv788[ebp], 1
	jmp	SHORT $LN196@fnProcessO
$LN195@fnProcessO:
	mov	DWORD PTR tv788[ebp], -1
$LN196@fnProcessO:
	mov	eax, DWORD PTR tv788[ebp]
	mov	DWORD PTR tv789[ebp], eax
$LN198@fnProcessO:
	cmp	DWORD PTR tv789[ebp], 0
	jne	SHORT $LN2@fnProcessO

; 421  :             lpViewOD->cSironDB_Type = lpProcessInfo->szLine[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpProcessInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	cl, BYTE PTR [edx+ecx]
	mov	BYTE PTR [eax+239], cl
$LN2@fnProcessO:

; 422  : 
; 423  :          break;
; 424  : 
; 425  :    } // switch ( *pchAttrName )...
; 426  : 
; 427  :    return( 0 );

	xor	eax, eax

; 428  : 
; 429  : } // fnProcessObjectEntity

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN200@fnProcessO:
	DD	$LN17@fnProcessO
	DD	$LN19@fnProcessO
	DD	$LN31@fnProcessO
	DD	$LN33@fnProcessO
	DD	$LN41@fnProcessO
	DD	$LN48@fnProcessO
	DD	$LN51@fnProcessO
	DD	$LN58@fnProcessO
	DD	$LN82@fnProcessO
	DD	$LN2@fnProcessO
$LN199@fnProcessO:
	DB	0
	DB	1
	DB	2
	DB	9
	DB	3
	DB	4
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	6
	DB	7
	DB	9
	DB	9
	DB	9
	DB	8
_fnProcessObjectEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpRelField$1 = -32					; size = 4
_lpDataField$2 = -28					; size = 4
_lpApp$ = -24						; size = 4
_lpRelRecord$3 = -20					; size = 4
_lpViewAttrib$4 = -16					; size = 4
_lpPrevViewOD$ = -12					; size = 4
_lpDataRecord$5 = -8					; size = 4
_lpViewEntity$6 = -4					; size = 4
_lpViewOD$ = 8						; size = 4
_fnDeleteViewObject@4 PROC

; 2443 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 2444 :    LPAPP    lpApp;
; 2445 :    LPVIEWOD lpPrevViewOD;
; 2446 : 
; 2447 :    if ( AnchorBlock == 0 || lpViewOD == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN23@fnDeleteVi
	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN22@fnDeleteVi
$LN23@fnDeleteVi:

; 2448 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDeleteVi
$LN22@fnDeleteVi:

; 2449 : 
; 2450 :    if ( lpViewOD->nTableID != iViewOD )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10011				; 0000271bH
	je	SHORT $LN24@fnDeleteVi

; 2451 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDeleteVi
$LN24@fnDeleteVi:

; 2452 : 
; 2453 :    // Get Application for this ViewOD.
; 2454 :    lpApp = zGETPTR( lpViewOD->hApp );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 2455 : 
; 2456 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN25@fnDeleteVi

; 2457 :       TraceLine( "Deleting Object Definition (0x%08x): %s for App: %s",

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG15083
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN25@fnDeleteVi:

; 2458 :                  zGETHNDL( lpViewOD ), lpViewOD->szName, lpApp->szName );
; 2459 : 
; 2460 :    lpPrevViewOD = 0;

	mov	DWORD PTR _lpPrevViewOD$[ebp], 0

; 2461 : 
; 2462 :    // Unchain this view OD from the application.
; 2463 :    if ( zGETPTR( lpApp->hFirstViewOD ) != lpViewOD )

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewOD$[ebp]
	je	SHORT $LN26@fnDeleteVi

; 2464 :    {
; 2465 :       lpPrevViewOD = zGETPTR( lpApp->hFirstViewOD );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevViewOD$[ebp], eax
$LN2@fnDeleteVi:

; 2466 :       while ( lpPrevViewOD &&

	cmp	DWORD PTR _lpPrevViewOD$[ebp], 0
	je	SHORT $LN3@fnDeleteVi
	mov	ecx, DWORD PTR _lpPrevViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewOD$[ebp]
	je	SHORT $LN3@fnDeleteVi

; 2467 :               zGETPTR( lpPrevViewOD->hNextViewOD ) != lpViewOD )
; 2468 :       {
; 2469 :          lpPrevViewOD = zGETPTR( lpPrevViewOD->hNextViewOD );

	mov	eax, DWORD PTR _lpPrevViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevViewOD$[ebp], eax

; 2470 :       }

	jmp	SHORT $LN2@fnDeleteVi
$LN3@fnDeleteVi:

; 2471 : 
; 2472 :       if ( lpPrevViewOD )

	cmp	DWORD PTR _lpPrevViewOD$[ebp], 0
	je	SHORT $LN28@fnDeleteVi

; 2473 :          lpPrevViewOD->hNextViewOD = lpViewOD->hNextViewOD;

	mov	edx, DWORD PTR _lpPrevViewOD$[ebp]
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx
$LN28@fnDeleteVi:

; 2474 :    }

	jmp	SHORT $LN4@fnDeleteVi
$LN26@fnDeleteVi:

; 2475 :    else
; 2476 :       lpApp->hFirstViewOD = lpViewOD->hNextViewOD;

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+84], ecx
$LN4@fnDeleteVi:

; 2477 : 
; 2478 :    // Free TaskOperations for this OD.
; 2479 :    while ( lpViewOD->hFirstTaskOperation )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [edx+216], 0
	je	SHORT $LN6@fnDeleteVi

; 2480 :       fnDropTaskOperation( 0, zGETPTR( lpViewOD->hFirstTaskOperation ) );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+216]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	push	0
	call	_fnDropTaskOperation@8
	jmp	SHORT $LN4@fnDeleteVi
$LN6@fnDeleteVi:

; 2481 : 
; 2482 :    // Free up view Entity information.
; 2483 :    while ( lpViewOD->hFirstOD_Entity )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [edx+224], 0
	je	$LN7@fnDeleteVi

; 2484 :    {
; 2485 :       LPVIEWENTITY lpViewEntity;
; 2486 : 
; 2487 :       lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$6[ebp], eax
$LN8@fnDeleteVi:

; 2488 : 
; 2489 :       // Free TaskOperations for this OD.
; 2490 :       while ( lpViewEntity->hFirstTaskOperation )

	mov	edx, DWORD PTR _lpViewEntity$6[ebp]
	cmp	DWORD PTR [edx+183], 0
	je	SHORT $LN10@fnDeleteVi

; 2491 :          fnDropTaskOperation( 0, zGETPTR( lpViewEntity->hFirstTaskOperation ) );

	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+183]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	push	0
	call	_fnDropTaskOperation@8
	jmp	SHORT $LN8@fnDeleteVi
$LN10@fnDeleteVi:

; 2492 : 
; 2493 :       // Free up Data Record information for view entity.
; 2494 :       while ( lpViewEntity->hFirstDataRecord )

	mov	edx, DWORD PTR _lpViewEntity$6[ebp]
	cmp	DWORD PTR [edx+191], 0
	je	$LN18@fnDeleteVi

; 2495 :       {
; 2496 :          LPDATARECORD lpDataRecord;
; 2497 : 
; 2498 :          lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$5[ebp], eax
$LN12@fnDeleteVi:

; 2499 : 
; 2500 :          // Free up Data Field information for Data Record.
; 2501 :          while ( lpDataRecord->hFirstDataField )

	mov	edx, DWORD PTR _lpDataRecord$5[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN14@fnDeleteVi

; 2502 :          {
; 2503 :             LPDATAFIELD lpDataField;
; 2504 : 
; 2505 :             lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$5[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField$2[ebp], eax

; 2506 :             lpDataRecord->hFirstDataField = lpDataField->hNextDataField;

	mov	edx, DWORD PTR _lpDataRecord$5[ebp]
	mov	eax, DWORD PTR _lpDataField$2[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+10], ecx

; 2507 :             fnFreeDataspace( lpDataField );

	mov	edx, DWORD PTR _lpDataField$2[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 2508 :          }

	jmp	SHORT $LN12@fnDeleteVi
$LN14@fnDeleteVi:

; 2509 : 
; 2510 :          // Free up Rel Record information for Data Record.
; 2511 :          while ( lpDataRecord->hFirstRelRecord )

	mov	eax, DWORD PTR _lpDataRecord$5[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN15@fnDeleteVi

; 2512 :          {
; 2513 :             LPRELRECORD lpRelRecord;
; 2514 : 
; 2515 :             lpRelRecord = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$3[ebp], eax
$LN16@fnDeleteVi:

; 2516 : 
; 2517 :             // Free up Rel Field information for Rel Record.
; 2518 :             while ( lpRelRecord->hFirstRelField )

	mov	eax, DWORD PTR _lpRelRecord$3[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN17@fnDeleteVi

; 2519 :             {
; 2520 :                LPRELFIELD lpRelField;
; 2521 : 
; 2522 :                lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	ecx, DWORD PTR _lpRelRecord$3[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$1[ebp], eax

; 2523 :                lpRelRecord->hFirstRelField = lpRelField->hNextRelField;

	mov	eax, DWORD PTR _lpRelRecord$3[ebp]
	mov	ecx, DWORD PTR _lpRelField$1[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+6], edx

; 2524 :                fnFreeDataspace( lpRelField );

	mov	eax, DWORD PTR _lpRelField$1[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2525 :             }

	jmp	SHORT $LN16@fnDeleteVi
$LN17@fnDeleteVi:

; 2526 : 
; 2527 :             lpDataRecord->hFirstRelRecord = lpRelRecord->hNextRelRecord;

	mov	ecx, DWORD PTR _lpDataRecord$5[ebp]
	mov	edx, DWORD PTR _lpRelRecord$3[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+6], eax

; 2528 :             fnFreeDataspace( lpRelRecord );

	mov	ecx, DWORD PTR _lpRelRecord$3[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 2529 :          }

	jmp	SHORT $LN14@fnDeleteVi
$LN15@fnDeleteVi:

; 2530 : 
; 2531 :          lpViewEntity->hFirstDataRecord = lpDataRecord->hNextDataRecord;

	mov	edx, DWORD PTR _lpViewEntity$6[ebp]
	mov	eax, DWORD PTR _lpDataRecord$5[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+191], ecx

; 2532 :          fnFreeDataspace( lpDataRecord );

	mov	edx, DWORD PTR _lpDataRecord$5[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 2533 :       }

	jmp	$LN10@fnDeleteVi
$LN18@fnDeleteVi:

; 2534 : 
; 2535 :       // Free up View Attrib information for View Entity.
; 2536 :       while ( lpViewEntity->hFirstOD_Attrib )

	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	cmp	DWORD PTR [eax+179], 0
	je	$LN19@fnDeleteVi

; 2537 :       {
; 2538 :          LPVIEWATTRIB lpViewAttrib;
; 2539 : 
; 2540 :          lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$6[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$4[ebp], eax
$LN20@fnDeleteVi:

; 2541 : 
; 2542 :          // Free TaskOperations for this OD.
; 2543 :          while ( lpViewAttrib->hFirstTaskOperation )

	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	cmp	DWORD PTR [eax+185], 0
	je	SHORT $LN21@fnDeleteVi

; 2544 :             fnDropTaskOperation( 0, zGETPTR( lpViewAttrib->hFirstTaskOperation ) );

	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+185]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	push	0
	call	_fnDropTaskOperation@8
	jmp	SHORT $LN20@fnDeleteVi
$LN21@fnDeleteVi:

; 2545 : 
; 2546 :          fnFreeDataspace( zGETPTR( lpViewAttrib->hDerivedExpr ) );

	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	mov	ecx, DWORD PTR [eax+246]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2547 :          fnFreeDataspace( zGETPTR( lpViewAttrib->hDerivedXPG ) );

	mov	edx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	eax, DWORD PTR [edx+255]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2548 :          fnFreeDataspace( zGETPTR( lpViewAttrib->hInit ) );

	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+209]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2549 :          lpViewEntity->hFirstOD_Attrib = lpViewAttrib->hNextOD_Attrib;

	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+179], edx

; 2550 :          fnFreeDataspace( lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2551 :       }

	jmp	$LN18@fnDeleteVi
$LN19@fnDeleteVi:

; 2552 : 
; 2553 :       lpViewOD->hFirstOD_Entity = lpViewEntity->hNextHier;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$6[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+224], eax

; 2554 :       fnFreeDataspace( lpViewEntity );

	mov	ecx, DWORD PTR _lpViewEntity$6[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 2555 :    }

	jmp	$LN6@fnDeleteVi
$LN7@fnDeleteVi:

; 2556 : 
; 2557 :    if ( lpViewOD->hDBH_Data )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [edx+244], 0
	je	SHORT $LN29@fnDeleteVi

; 2558 :       fnFreeDataspace( zGETPTR( lpViewOD->hDBH_Data ) );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+244]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN29@fnDeleteVi:

; 2559 : 
; 2560 :    fnFreeDataspace( lpViewOD );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 2561 : 
; 2562 :    return( 0 );

	xor	eax, eax
$LN1@fnDeleteVi:

; 2563 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnDeleteViewObject@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpApp$ = -228						; size = 4
_lpSubtask$1 = -224					; size = 4
_lpCurrentTask$ = -220					; size = 4
_hApp$ = -216						; size = 4
_nRC$ = -212						; size = 2
_lpViewOD$ = -208					; size = 4
_szMsg$2 = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_pchViewOD_Name$ = 12					; size = 4
_bSystemObject$ = 16					; size = 1
_DropViewObject@12 PROC

; 2590 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2591 :    LPTASK         lpCurrentTask;
; 2592 :    LPAPP          hApp, lpApp;
; 2593 :    LPVIEWOD       lpViewOD;
; 2594 :    zSHORT         nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 2595 : 
; 2596 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 2597 :    if ( (lpCurrentTask = fnOperationCall( iDropViewObject, lpView,
; 2598 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	223					; 000000dfH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN5@DropViewOb

; 2599 :    {
; 2600 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DropViewOb
$LN5@DropViewOb:

; 2601 :    }
; 2602 : 
; 2603 :    if ( bSystemObject )

	movzx	edx, BYTE PTR _bSystemObject$[ebp]
	test	edx, edx
	je	SHORT $LN6@DropViewOb

; 2604 :       hApp = AnchorBlock->hSystemApp;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+110]
	mov	DWORD PTR _hApp$[ebp], ecx
	jmp	SHORT $LN7@DropViewOb
$LN6@DropViewOb:

; 2605 :    else
; 2606 :    if ( lpView->hSubtask )

	mov	edx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN8@DropViewOb

; 2607 :    {
; 2608 :       LPSUBTASK lpSubtask = zGETPTR( lpView->hSubtask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$1[ebp], eax

; 2609 :       hApp = lpSubtask->hApp;

	mov	edx, DWORD PTR _lpSubtask$1[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR _hApp$[ebp], eax

; 2610 :    }

	jmp	SHORT $LN7@DropViewOb
$LN8@DropViewOb:

; 2611 :    else
; 2612 :    if ( lpView->hViewOD )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	SHORT $LN10@DropViewOb

; 2613 :    {
; 2614 :       lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2615 :       hApp = lpViewOD->hApp;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _hApp$[ebp], edx

; 2616 :    }

	jmp	SHORT $LN7@DropViewOb
$LN10@DropViewOb:

; 2617 :    else
; 2618 :       hApp = lpCurrentTask->hApp;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hApp$[ebp], ecx
$LN7@DropViewOb:

; 2619 : 
; 2620 :    lpApp = zGETPTR( hApp );

	mov	edx, DWORD PTR _hApp$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 2621 : 
; 2622 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 2623 : 
; 2624 :    if ( pchViewOD_Name )

	cmp	DWORD PTR _pchViewOD_Name$[ebp], 0
	je	SHORT $LN12@DropViewOb

; 2625 :    {
; 2626 :       // Find the first occurrence of the view OD.
; 2627 :       for ( lpViewOD = zGETPTR( lpApp->hFirstViewOD );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
	jmp	SHORT $LN4@DropViewOb
$LN2@DropViewOb:

; 2629 :             lpViewOD = zGETPTR( lpViewOD->hNextViewOD ) )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
$LN4@DropViewOb:

; 2628 :             lpViewOD;

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN3@DropViewOb

; 2630 :       {
; 2631 :          // See if this is the ViewOD we're looking for.
; 2632 :          if ( zstrcmpi( lpViewOD->szName, pchViewOD_Name ) == 0 )

	mov	ecx, DWORD PTR _pchViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@DropViewOb

; 2633 :             break;

	jmp	SHORT $LN3@DropViewOb
$LN14@DropViewOb:

; 2634 :       }

	jmp	SHORT $LN2@DropViewOb
$LN3@DropViewOb:

; 2635 :    }

	jmp	SHORT $LN13@DropViewOb
$LN12@DropViewOb:

; 2636 :    else
; 2637 :       lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
$LN13@DropViewOb:

; 2638 : 
; 2639 :    if ( lpViewOD == 0 || lpViewOD->bDeprecated )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN16@DropViewOb
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN15@DropViewOb
$LN16@DropViewOb:

; 2640 :    {
; 2641 :       // Couldn't find it.  Nothing to do.
; 2642 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2643 :       fnOperationReturn( iDropViewObject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	223					; 000000dfH
	call	_fnOperationReturn
	add	esp, 8

; 2644 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@DropViewOb
$LN15@DropViewOb:

; 2645 :    }
; 2646 : 
; 2647 :    // Set flag to indicate this OD is deprecated.
; 2648 :    lpViewOD->bDeprecated = TRUE;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	or	eax, 2048				; 00000800H
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	DWORD PTR [ecx+240], eax

; 2649 : 
; 2650 :    // Check to see if any views still reference the view.  If so, then
; 2651 :    // we can't drop it.  We'll do it later.
; 2652 :    if ( fnCheckIfViewOD_IsUsed( lpView, lpViewOD ) == zCALL_ERROR )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCheckIfViewOD_IsUsed@8
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN17@DropViewOb

; 2653 :    {
; 2654 :       zCHAR szMsg[ 200 ];
; 2655 : 
; 2656 :       zsprintf( szMsg, "View referencing '%s' = ", lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG15126
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2657 :       TraceLineX( szMsg, (zLONG) lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	call	_TraceLineX@8

; 2658 :       nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 2659 :    }

	jmp	SHORT $LN18@DropViewOb
$LN17@DropViewOb:

; 2660 :    else
; 2661 :    {
; 2662 :       // ViewOD is not in use so remove it.
; 2663 :       fnDeleteViewObject( lpViewOD );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	call	_fnDeleteViewObject@4
$LN18@DropViewOb:

; 2664 :    }
; 2665 : 
; 2666 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2667 : 
; 2668 :    fnOperationReturn( iDropViewObject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	223					; 000000dfH
	call	_fnOperationReturn
	add	esp, 8

; 2669 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DropViewOb:

; 2670 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_DropViewObject@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeodaa.c
_TEXT	SEGMENT
_lpSubtask$1 = -448					; size = 4
_hViewOD$ = -444					; size = 4
_lpPrevRelField$2 = -440				; size = 4
_lpPrevRelRecord$3 = -436				; size = 4
_lpPrevDataField$4 = -432				; size = 4
_lpPrevDataRecord$5 = -428				; size = 4
_lpPrevViewAttrib$6 = -424				; size = 4
_lpParent$7 = -420					; size = 4
_lpRelField$ = -416					; size = 4
_lpDataField$ = -412					; size = 4
tv559 = -408						; size = 4
_hViewEntity$ = -404					; size = 4
_lpApp$ = -400						; size = 4
_lpRelRecord$ = -396					; size = 4
_lpSearchEntity$8 = -392				; size = 4
_hApp$ = -388						; size = 4
_hFile$ = -384						; size = 4
_lpDataRecord$ = -380					; size = 4
_lpPrevViewEntity$9 = -376				; size = 4
_nHierNbr$ = -372					; size = 2
_lpTask$ = -368						; size = 4
_nEOF$ = -364						; size = 2
_lpViewAttrib$ = -360					; size = 4
_hndl$ = -356						; size = 4
_lpViewOD$ = -352					; size = 4
_lpViewEntity$ = -348					; size = 4
_ProcessInfo$ = -344					; size = 338
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_bSystemObject$ = 16					; size = 1
_ActivateViewObject@12 PROC

; 1790 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 448				; 000001c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1791 :    ProcessInfoRecord ProcessInfo;
; 1792 :    LPVIEWENTITY   lpViewEntity;
; 1793 :    LPVIEWATTRIB   lpViewAttrib;
; 1794 :    LPDATARECORD   lpDataRecord;
; 1795 :    LPDATAFIELD    lpDataField;
; 1796 :    LPRELRECORD    lpRelRecord;
; 1797 :    LPRELFIELD     lpRelField;
; 1798 :    LPTASK         lpTask;
; 1799 :    LPAPP          lpApp;
; 1800 :    LPVIEWOD       lpViewOD;
; 1801 :    zPVOID         hApp;
; 1802 :    zPVOID         hViewOD;
; 1803 :    zPVOID         hViewEntity;
; 1804 :    zPVOID         hndl;
; 1805 :    zLONG          hFile;
; 1806 :    zSHORT         nEOF;
; 1807 :    zSHORT         nHierNbr;
; 1808 : 
; 1809 : // if ( zstrcmpi( cpcViewOD_Name, "TZ__PRFO" ) == 0 )
; 1810 : // {
; 1811 : //    nEOF = 0;
; 1812 : //    nEOF /= nEOF;
; 1813 : // }
; 1814 : 
; 1815 :    // First, make sure Anchor Block exists, if not return 0.
; 1816 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN25@ActivateVi

; 1817 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@ActivateVi
$LN25@ActivateVi:

; 1818 : 
; 1819 :    // Now, check that task is active
; 1820 :    lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 1821 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN26@ActivateVi

; 1822 :       return( 0 ); // if not, error

	xor	eax, eax
	jmp	$LN1@ActivateVi
$LN26@ActivateVi:

; 1823 : 
; 1824 :    if ( bSystemObject )

	movzx	edx, BYTE PTR _bSystemObject$[ebp]
	test	edx, edx
	je	SHORT $LN27@ActivateVi

; 1825 :       hApp = AnchorBlock->hSystemApp;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+110]
	mov	DWORD PTR _hApp$[ebp], ecx
	jmp	SHORT $LN28@ActivateVi
$LN27@ActivateVi:

; 1826 :    else
; 1827 :    if ( lpView->hSubtask )

	mov	edx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN29@ActivateVi

; 1828 :    {
; 1829 :       LPSUBTASK lpSubtask = zGETPTR( lpView->hSubtask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$1[ebp], eax

; 1830 :       hApp = lpSubtask->hApp;

	mov	edx, DWORD PTR _lpSubtask$1[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR _hApp$[ebp], eax

; 1831 :    }

	jmp	SHORT $LN28@ActivateVi
$LN29@ActivateVi:

; 1832 :    else
; 1833 :    if ( lpView->hViewOD )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	SHORT $LN31@ActivateVi

; 1834 :    {
; 1835 :       lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1836 :       hApp = lpViewOD->hApp;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR _hApp$[ebp], edx

; 1837 :    }

	jmp	SHORT $LN28@ActivateVi
$LN31@ActivateVi:

; 1838 :    else
; 1839 :       hApp = lpTask->hApp;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hApp$[ebp], ecx
$LN28@ActivateVi:

; 1840 : 
; 1841 :    if ( hApp == 0 )

	cmp	DWORD PTR _hApp$[ebp], 0
	jne	SHORT $LN33@ActivateVi

; 1842 :       return( 0 );    // if not, error

	xor	eax, eax
	jmp	$LN1@ActivateVi
$LN33@ActivateVi:

; 1843 : 
; 1844 :    lpApp = zGETPTR( hApp );

	mov	edx, DWORD PTR _hApp$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 1845 : // TraceLine( "ActivateViewObject App (0x%08x): %s   ViewOD: %s", hApp, lpApp->szName, cpcViewOD_Name );
; 1846 : 
; 1847 :    // Next, see if View Object is already active in App.  Note that we haven't
; 1848 :    // locked the mutex yet because 99% of the time the OD has already been
; 1849 :    // activated and we don't want the overhead of locking the mutex.  If the
; 1850 :    // OD hasn't been loaded we'll lock the mutex and then check again.
; 1851 :    for ( lpViewOD = zGETPTR( lpApp->hFirstViewOD );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
	jmp	SHORT $LN4@ActivateVi
$LN2@ActivateVi:

; 1853 :          lpViewOD = zGETPTR( lpViewOD->hNextViewOD ) )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
$LN4@ActivateVi:

; 1852 :          lpViewOD;

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN3@ActivateVi

; 1854 :    {
; 1855 :    // TraceLine( "ActivateViewObject App (0x%08x): %s   checking ViewOD (0x%08x): %s",
; 1856 :    //            hApp, lpApp->szName, zGETHNDL( lpViewOD ), lpViewOD->szName );
; 1857 : 
; 1858 :       // See if this is the ViewOD we're looking for.
; 1859 :       if ( zstrcmpi( lpViewOD->szName, cpcViewOD_Name ) == 0 )

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN34@ActivateVi

; 1860 :       {
; 1861 :          // This is the right ViewOD.  See if we're supposed to reload it.
; 1862 :          if ( lpViewOD->bDeprecated )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN35@ActivateVi

; 1863 :             break; // we need to reload this guy so break loop

	jmp	SHORT $LN3@ActivateVi
$LN35@ActivateVi:

; 1864 : 
; 1865 :          // Everything OK so return.
; 1866 :          return( lpViewOD );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	jmp	$LN1@ActivateVi
$LN34@ActivateVi:

; 1867 :       }
; 1868 :    }

	jmp	SHORT $LN2@ActivateVi
$LN3@ActivateVi:

; 1869 : 
; 1870 : // if ( zstrcmp( cpcViewOD_Name, "mGLBudgt" ) == 0 )
; 1871 : //  {
; 1872 : //    nEOF = 1;
; 1873 : //    nEOF /= nEOF - nEOF;
; 1874 : // }
; 1875 : 
; 1876 :    // Set ProcessInfo record.
; 1877 :    zmemset( (zPVOID) &ProcessInfo, 0, sizeof( ProcessInfo ) );

	push	338					; 00000152H
	push	0
	lea	edx, DWORD PTR _ProcessInfo$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 1878 :    ProcessInfo.hApp        = hApp;

	mov	eax, DWORD PTR _hApp$[ebp]
	mov	DWORD PTR _ProcessInfo$[ebp+310], eax

; 1879 :    ProcessInfo.lpApp       = lpApp;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR _ProcessInfo$[ebp+306], ecx

; 1880 :    ProcessInfo.lpSystemApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+110]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _ProcessInfo$[ebp+302], eax

; 1881 :    ProcessInfo.lpTask      = lpTask;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR _ProcessInfo$[ebp+314], ecx

; 1882 :    ProcessInfo.lpView      = lpView;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _ProcessInfo$[ebp+322], edx

; 1883 : 
; 1884 :    // Set up the directory of where to find the object file.
; 1885 :    zstrcpy( ProcessInfo.szFileName, lpApp->szObjectDir );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+41]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1886 :    zstrcat( ProcessInfo.szFileName, cpcViewOD_Name );

	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	lea	eax, DWORD PTR _ProcessInfo$[ebp+41]
	push	eax
	call	_strcat
	add	esp, 8

; 1887 :    zstrcat( ProcessInfo.szFileName, szObjectSuffix );

	mov	ecx, DWORD PTR _szObjectSuffix
	push	ecx
	lea	edx, DWORD PTR _ProcessInfo$[ebp+41]
	push	edx
	call	_strcat
	add	esp, 8

; 1888 : 
; 1889 :    // DGC 7/11/96 -- The following is a hack for compatability with Unix.
; 1890 :    // Unix file names are case-sensitive.  Since DOS/Windows files (when
; 1891 :    // copied to a unix system via a network) are assigned lower-case letters
; 1892 :    // in Unix, we will (for now) make all Zeidon System file names lowercase.
; 1893 :    zstrlower( ProcessInfo.szFileName );

	lea	eax, DWORD PTR _ProcessInfo$[ebp+41]
	push	eax
	call	DWORD PTR __imp___strlwr
	add	esp, 4

; 1894 : 
; 1895 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 1896 : 
; 1897 :    // Check again to see if the ViewOD is in the list.  It's possible that
; 1898 :    // the OD was loaded by another process after we checked for the OD but
; 1899 :    // before we set the mutex.
; 1900 :    // This is all done to save the overhead of locking the mutex when it
; 1901 :    // doesn't need to be done (see above).
; 1902 :    for ( lpViewOD = zGETPTR( lpApp->hFirstViewOD );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
	jmp	SHORT $LN7@ActivateVi
$LN5@ActivateVi:

; 1904 :          lpViewOD = zGETPTR( lpViewOD->hNextViewOD ) )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
$LN7@ActivateVi:

; 1903 :          lpViewOD;

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN6@ActivateVi

; 1905 :    {
; 1906 :       // See if this is the ViewOD we're looking for.
; 1907 :       if ( zstrcmpi( lpViewOD->szName, cpcViewOD_Name ) == 0 )

	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN36@ActivateVi

; 1908 :       {
; 1909 :          // This is the right ViewOD.  See if we're supposed to reload it.
; 1910 :          if ( lpViewOD->bDeprecated )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN37@ActivateVi

; 1911 :             break; // We need to reload this guy so break loop.

	jmp	SHORT $LN6@ActivateVi
$LN37@ActivateVi:

; 1912 : 
; 1913 :          // Everything OK so return.
; 1914 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1915 :          return( lpViewOD );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	jmp	$LN1@ActivateVi
$LN36@ActivateVi:

; 1916 :       }
; 1917 :    }

	jmp	SHORT $LN5@ActivateVi
$LN6@ActivateVi:

; 1918 : 
; 1919 :    if ( (hFile = SysOpenFile( lpView, ProcessInfo.szFileName,
; 1920 :                               COREFILE_READ )) == -1 )

	push	128					; 00000080H
	lea	eax, DWORD PTR _ProcessInfo$[ebp+41]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax
	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN38@ActivateVi

; 1921 :    {
; 1922 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1923 : 
; 1924 :       //  "KZOEE050 - Error opening View Object file "
; 1925 :       fnIssueCoreError( lpTask, lpView, 8, 50, 0, ProcessInfo.szFileName, 0 );

	push	0
	lea	edx, DWORD PTR _ProcessInfo$[ebp+41]
	push	edx
	push	0
	push	50					; 00000032H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1926 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@ActivateVi
$LN38@ActivateVi:

; 1927 :    }
; 1928 : 
; 1929 :    // Display the name and date time stamp of file just opened.
; 1930 :    if ( AnchorBlock->TraceFlags.bOpenFile )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN39@ActivateVi

; 1931 :       TraceLineS( "(od) opening Object Def file Name: ", ProcessInfo.szFileName );

	lea	ecx, DWORD PTR _ProcessInfo$[ebp+41]
	push	ecx
	push	OFFSET $SG14946
	call	_TraceLineS@8
$LN39@ActivateVi:

; 1932 : 
; 1933 :    ProcessInfo.hFile = hFile;

	mov	edx, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR _ProcessInfo$[ebp], edx

; 1934 : 
; 1935 :    // Object file opened, load the object definition.
; 1936 :    ProcessInfo.nCurrState = 0;    // 0 ==> Looking for Object Entity

	xor	eax, eax
	mov	WORD PTR _ProcessInfo$[ebp+318], ax

; 1937 :    nEOF = SysReadLine( lpView, &ProcessInfo.szLine, hFile );

	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ProcessInfo$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysReadLine@12
	mov	WORD PTR _nEOF$[ebp], ax

; 1938 : 
; 1939 :    // Invalid file, fall out.
; 1940 :    if ( ProcessInfo.szLine[ 0 ] == 'z' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ProcessInfo$[ebp+4]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 122				; 0000007aH
	jne	SHORT $LN40@ActivateVi

; 1941 :    {
; 1942 :       // New style.
; 1943 :       if ( zstrncmp( &ProcessInfo.szLine[ 6 ], "Zeidon", 6 ) != 0 )

	push	6
	push	OFFSET $SG14950
	mov	edx, 1
	imul	eax, edx, 6
	add	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN42@ActivateVi

; 1944 :       {
; 1945 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1946 : 
; 1947 :          //  "KZOEE051 - Invalid View Object file header in "
; 1948 :          fnIssueCoreError( lpTask, lpView, 16, 51, 0, ProcessInfo.szFileName, 0 );

	push	0
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+41]
	push	ecx
	push	0
	push	51					; 00000033H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1949 :          SysCloseFile( lpView, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysCloseFile@12

; 1950 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@ActivateVi
$LN42@ActivateVi:

; 1951 :       }
; 1952 :    }

	jmp	SHORT $LN41@ActivateVi
$LN40@ActivateVi:

; 1953 :    else
; 1954 :    if ( zstrncmp( ProcessInfo.szLine, "pZeidon", 7 ) != 0 )

	push	7
	push	OFFSET $SG14952
	mov	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN41@ActivateVi

; 1955 :    {
; 1956 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1957 : 
; 1958 :       //  "KZOEE051 - Invalid View Object file header in "
; 1959 :       fnIssueCoreError( lpTask, lpView, 16, 51, 0, ProcessInfo.szFileName, 0 );

	push	0
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+41]
	push	ecx
	push	0
	push	51					; 00000033H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1960 :       SysCloseFile( lpView, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysCloseFile@12

; 1961 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@ActivateVi
$LN41@ActivateVi:

; 1962 :    }
; 1963 : 
; 1964 :    nEOF = SysReadLine( lpView, &ProcessInfo.szLine, hFile );  // get second line

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysReadLine@12
	mov	WORD PTR _nEOF$[ebp], ax

; 1965 : 
; 1966 :    ProcessInfo.lLine = 2;

	mov	DWORD PTR _ProcessInfo$[ebp+298], 2
$LN8@ActivateVi:

; 1967 :    while ( nEOF > 0 )

	movsx	eax, WORD PTR _nEOF$[ebp]
	test	eax, eax
	jle	$LN9@ActivateVi

; 1968 :    {
; 1969 :       if ( ProcessInfo.szLine[ 0 ] == 'e' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ProcessInfo$[ebp+4]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 101				; 00000065H
	jne	$LN44@ActivateVi

; 1970 :       {
; 1971 :          // If currently processing an attribute, make sure length is specified.
; 1972 :          if ( ProcessInfo.nCurrState == 3 &&  // processing ATTRIB

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	edx, 3
	jne	SHORT $LN46@ActivateVi
	movzx	eax, BYTE PTR _ProcessInfo$[ebp+326]
	test	eax, eax
	jne	SHORT $LN46@ActivateVi

; 1973 :               ProcessInfo.bLth == FALSE )
; 1974 :          {
; 1975 :             if ( lpViewAttrib->cType == 'B' )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	jne	SHORT $LN47@ActivateVi

; 1976 :             {
; 1977 :                lpViewAttrib->ulLth = 7;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+203], 7

; 1978 :                ProcessInfo.bLth = TRUE;

	mov	BYTE PTR _ProcessInfo$[ebp+326], 1

; 1979 :             }

	jmp	SHORT $LN46@ActivateVi
$LN47@ActivateVi:

; 1980 :             else
; 1981 :             {
; 1982 :                //  "KZOEE052 - Invalid Object file, Attrib w/o lth on line "
; 1983 :                fnIssueCoreError( lpTask, lpView, 16, 52, ProcessInfo.lLine,

	push	0
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+41]
	push	ecx
	mov	edx, DWORD PTR _ProcessInfo$[ebp+298]
	push	edx
	push	52					; 00000034H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1984 :                                  ProcessInfo.szFileName, 0 );
; 1985 :                ProcessInfo.nCurrState = 10;  // set error

	mov	edx, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], dx

; 1986 :                break;

	jmp	$LN9@ActivateVi
$LN46@ActivateVi:

; 1987 :             }
; 1988 :          }
; 1989 : 
; 1990 :          // An Entity type has been found, validate the Entity name and that
; 1991 :          // it has been found when it was expected.
; 1992 :          if ( ProcessInfo.nCurrState == 0 &&  // looking for OBJECT

	movsx	eax, WORD PTR _ProcessInfo$[ebp+318]
	test	eax, eax
	jne	$LN49@ActivateVi
	push	6
	mov	ecx, DWORD PTR _szlOBJECT
	push	ecx
	mov	edx, 1
	shl	edx, 0
	add	edx, DWORD PTR _ProcessInfo$[ebp+4]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN49@ActivateVi

; 1993 :               zstrncmp( &ProcessInfo.szLine[ 1 ], szlOBJECT, 6 ) == 0 )
; 1994 :          {
; 1995 :             // We were looking for an OBJECT and it was found
; 1996 :             ProcessInfo.nCurrState = 1;  // working on OBJECT

	mov	eax, 1
	mov	WORD PTR _ProcessInfo$[ebp+318], ax

; 1997 :             hViewOD = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10011					; 0000271bH
	push	0
	push	1
	push	268					; 0000010cH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewOD$[ebp], eax

; 1998 :                                         sizeof( ViewOD_Record ), 1, 0,
; 1999 :                                         iViewOD );
; 2000 :             lpViewOD = zGETPTR( hViewOD );

	mov	eax, DWORD PTR _hViewOD$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2001 :          // TraceLine( "ActivateViewObject: %s  ViewOD: (0x%08x) 0x%08x",
; 2002 :          //            cpcViewOD_Name, lpViewOD, hViewOD );
; 2003 :             if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN51@ActivateVi

; 2004 :                ProcessInfo.nCurrState = 10;  // set error

	mov	ecx, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], cx
	jmp	SHORT $LN52@ActivateVi
$LN51@ActivateVi:

; 2005 :             else
; 2006 :             {
; 2007 :                lpViewOD->hApp = hApp;  // set application for object

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR _hApp$[ebp]
	mov	DWORD PTR [edx+6], eax

; 2008 :                lpViewEntity = 0;

	mov	DWORD PTR _lpViewEntity$[ebp], 0

; 2009 :                nHierNbr     = 0;

	xor	ecx, ecx
	mov	WORD PTR _nHierNbr$[ebp], cx
$LN52@ActivateVi:

; 2010 :             }
; 2011 :          }

	jmp	$LN50@ActivateVi
$LN49@ActivateVi:

; 2012 :          else
; 2013 :          if ( ProcessInfo.nCurrState &&

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	test	edx, edx
	je	$LN53@ActivateVi
	push	11					; 0000000bH
	mov	eax, DWORD PTR _szlCHILDENTITY
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	add	ecx, DWORD PTR _ProcessInfo$[ebp+4]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN55@ActivateVi
	push	6
	mov	edx, DWORD PTR _szlENTITY
	push	edx
	mov	eax, 1
	shl	eax, 0
	add	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN53@ActivateVi
$LN55@ActivateVi:

; 2014 :               (zstrncmp( &ProcessInfo.szLine[ 1 ], szlCHILDENTITY, 11 ) == 0 ||
; 2015 :                zstrncmp( &ProcessInfo.szLine[ 1 ], szlENTITY, 6 ) == 0) )
; 2016 :          {
; 2017 :             // Processing OBJECT, ENTITY, OR ATTRIB and ENTITY appears.
; 2018 :             LPVIEWENTITY lpPrevViewEntity;
; 2019 : 
; 2020 :             if ( lpViewEntity )        // dks ... 2006.01.25

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN56@ActivateVi

; 2021 :             {
; 2022 :                if ( ProcessInfo.nKeyCnt == 1 )

	movsx	ecx, WORD PTR _ProcessInfo$[ebp+320]
	cmp	ecx, 1
	jne	SHORT $LN56@ActivateVi

; 2023 :                   lpViewEntity->bSingleKey = TRUE;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+235], eax
$LN56@ActivateVi:

; 2024 :             }
; 2025 : 
; 2026 :             ProcessInfo.nKeyCnt = 0;   // dks ... 2006.01.25

	xor	edx, edx
	mov	WORD PTR _ProcessInfo$[ebp+320], dx

; 2027 : 
; 2028 :             // Attribute matching when task debug is on.
; 2029 :             lpViewAttrib = 0;

	mov	DWORD PTR _lpViewAttrib$[ebp], 0

; 2030 :             lpDataRecord = 0;

	mov	DWORD PTR _lpDataRecord$[ebp], 0

; 2031 :             ProcessInfo.ulRecordOffset = 0; // offset of attribute in record

	mov	DWORD PTR _ProcessInfo$[ebp+330], 0

; 2032 :             ProcessInfo.ulNonPersistOffset = 0;

	mov	DWORD PTR _ProcessInfo$[ebp+334], 0

; 2033 :             ProcessInfo.nCurrState = 2;    // processing ENTITY

	mov	eax, 2
	mov	WORD PTR _ProcessInfo$[ebp+318], ax

; 2034 : 
; 2035 :             lpPrevViewEntity = lpViewEntity;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpPrevViewEntity$9[ebp], ecx

; 2036 :             hViewEntity = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10012					; 0000271cH
	push	0
	push	1
	push	251					; 000000fbH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewEntity$[ebp], eax

; 2037 :                                             sizeof( ViewEntityRecord ), 1, 0,
; 2038 :                                             iViewEntity );
; 2039 :             lpViewEntity = zGETPTR( hViewEntity );

	mov	ecx, DWORD PTR _hViewEntity$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2040 :             if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN58@ActivateVi

; 2041 :                ProcessInfo.nCurrState = 10;  // set error

	mov	edx, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], dx
	jmp	$LN59@ActivateVi
$LN58@ActivateVi:

; 2042 :             else
; 2043 :             {
; 2044 :                // Parse the Attribute line received.
; 2045 :                SysParseLine( ProcessInfo.szAttrName, &ProcessInfo.szLine,

	mov	eax, 1
	shl	eax, 0
	add	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+4]
	push	ecx
	lea	edx, DWORD PTR _ProcessInfo$[ebp+8]
	push	edx
	call	_SysParseLine@12

; 2046 :                              &ProcessInfo.szLine[ 1 ] );
; 2047 : 
; 2048 :                // Set the Level for the Entity.
; 2049 :                lpViewEntity->nLevel = (zSHORT) (zatol( ProcessInfo.szLine ) - 1);

	mov	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	sub	eax, 1
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	WORD PTR [ecx+215], ax

; 2050 : 
; 2051 :                // Set hierarchical number for the entity.
; 2052 :                nHierNbr++;

	mov	dx, WORD PTR _nHierNbr$[ebp]
	add	dx, 1
	mov	WORD PTR _nHierNbr$[ebp], dx

; 2053 :                lpViewEntity->nHierNbr = nHierNbr;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	cx, WORD PTR _nHierNbr$[ebp]
	mov	WORD PTR [eax+217], cx

; 2054 :                lpViewOD->uEntities = nHierNbr;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	ax, WORD PTR _nHierNbr$[ebp]
	mov	WORD PTR [edx+234], ax

; 2055 : 
; 2056 :                // Chain new Entity to the previous entity.
; 2057 :                if ( lpPrevViewEntity )

	cmp	DWORD PTR _lpPrevViewEntity$9[ebp], 0
	je	$LN60@ActivateVi

; 2058 :                {
; 2059 :                   LPVIEWENTITY lpParent;
; 2060 :                   LPVIEWENTITY lpSearchEntity;
; 2061 : 
; 2062 :                   lpPrevViewEntity->hNextHier = hViewEntity;

	mov	ecx, DWORD PTR _lpPrevViewEntity$9[ebp]
	mov	edx, DWORD PTR _hViewEntity$[ebp]
	mov	DWORD PTR [ecx+2], edx

; 2063 :                   lpViewEntity->hPrevHier     = zGETHNDL( lpPrevViewEntity );

	mov	eax, DWORD PTR _lpPrevViewEntity$9[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN10@ActivateVi:

; 2064 : 
; 2065 :                   // Now set the parent of the entity.
; 2066 :                   while ( lpPrevViewEntity &&

	cmp	DWORD PTR _lpPrevViewEntity$9[ebp], 0
	je	SHORT $LN11@ActivateVi
	mov	edx, DWORD PTR _lpPrevViewEntity$9[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	sub	edx, 1
	cmp	eax, edx
	je	SHORT $LN11@ActivateVi

; 2067 :                           lpPrevViewEntity->nLevel !=
; 2068 :                                           (lpViewEntity->nLevel - 1) )
; 2069 :                   {
; 2070 :                      lpPrevViewEntity = zGETPTR( lpPrevViewEntity->hParent );

	mov	eax, DWORD PTR _lpPrevViewEntity$9[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevViewEntity$9[ebp], eax

; 2071 :                   }

	jmp	SHORT $LN10@ActivateVi
$LN11@ActivateVi:

; 2072 : 
; 2073 :                   if ( lpPrevViewEntity == 0 )

	cmp	DWORD PTR _lpPrevViewEntity$9[ebp], 0
	jne	SHORT $LN62@ActivateVi

; 2074 :                   {
; 2075 :                      //  "KZOEE053 - Invalid Entity level found on line "
; 2076 :                      fnIssueCoreError( lpTask, lpView, 16, 53, ProcessInfo.lLine,

	push	0
	lea	edx, DWORD PTR _ProcessInfo$[ebp+41]
	push	edx
	mov	eax, DWORD PTR _ProcessInfo$[ebp+298]
	push	eax
	push	53					; 00000035H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2077 :                                        ProcessInfo.szFileName, 0 );
; 2078 :                      ProcessInfo.nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], ax
$LN62@ActivateVi:

; 2079 :                   }
; 2080 : 
; 2081 :                   lpViewEntity->hParent = zGETHNDL( lpPrevViewEntity );

	mov	ecx, DWORD PTR _lpPrevViewEntity$9[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+10], eax

; 2082 :                // if ( lpViewEntity->hParent == (LPVIEWENTITY) 1 )
; 2083 :                //    SysMessageBox( 0, "ActivateViewObject", "1", -1 );
; 2084 : 
; 2085 :                   // Set persistent indicator based on persistent
; 2086 :                   // indicator of parent chain.
; 2087 :                   lpParent = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$7[ebp], eax

; 2088 :                   if ( lpParent->bDerivedPath )

	mov	edx, DWORD PTR _lpParent$7[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	je	SHORT $LN63@ActivateVi

; 2089 :                      lpViewEntity->bDerivedPath = TRUE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	or	edx, 16384				; 00004000H
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [eax+235], edx
$LN63@ActivateVi:

; 2090 : 
; 2091 :                   if ( lpParent->bDupRelPath )

	mov	ecx, DWORD PTR _lpParent$7[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN64@ActivateVi

; 2092 :                   {
; 2093 :                      lpViewEntity->bDupRelPath = TRUE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	or	ecx, 134217728				; 08000000H
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx

; 2094 :                      lpViewEntity->bDupRel     = FALSE;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, -67108865				; fbffffffH
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [edx+235], ecx
$LN64@ActivateVi:

; 2095 :                   }
; 2096 : 
; 2097 :                   // Set the sibling pointers.
; 2098 :                   for ( lpSearchEntity = zGETPTR( lpViewEntity->hPrevHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntity$8[ebp], eax
	jmp	SHORT $LN14@ActivateVi
$LN12@ActivateVi:

; 2100 :                         lpSearchEntity = zGETPTR( lpSearchEntity->hPrevHier ) )

	mov	edx, DWORD PTR _lpSearchEntity$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchEntity$8[ebp], eax
$LN14@ActivateVi:

; 2099 :                         lpSearchEntity;

	cmp	DWORD PTR _lpSearchEntity$8[ebp], 0
	je	SHORT $LN13@ActivateVi

; 2101 :                   {
; 2102 :                      // If lpSearchEntity is the lpParent then we're done
; 2103 :                      // searching.
; 2104 :                      if ( lpSearchEntity == lpParent )

	mov	ecx, DWORD PTR _lpSearchEntity$8[ebp]
	cmp	ecx, DWORD PTR _lpParent$7[ebp]
	jne	SHORT $LN65@ActivateVi

; 2105 :                         break;

	jmp	SHORT $LN13@ActivateVi
$LN65@ActivateVi:

; 2106 : 
; 2107 :                      // If we find an entity with the same level as the
; 2108 :                      // current entity then we have found the prev sibling.
; 2109 :                      if ( lpSearchEntity->nLevel == lpViewEntity->nLevel )

	mov	edx, DWORD PTR _lpSearchEntity$8[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jne	SHORT $LN66@ActivateVi

; 2110 :                      {
; 2111 :                         lpSearchEntity->hNextSibling = zGETHNDL( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSearchEntity$8[ebp]
	mov	DWORD PTR [ecx+247], eax

; 2112 :                         lpViewEntity->hPrevSibling = zGETHNDL( lpSearchEntity );

	mov	edx, DWORD PTR _lpSearchEntity$8[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+243], eax

; 2113 :                         break;

	jmp	SHORT $LN13@ActivateVi
$LN66@ActivateVi:

; 2114 :                      }
; 2115 :                   }

	jmp	$LN12@ActivateVi
$LN13@ActivateVi:

; 2116 :                }

	jmp	SHORT $LN59@ActivateVi
$LN60@ActivateVi:

; 2117 :                else
; 2118 :                   lpViewOD->hFirstOD_Entity = hViewEntity;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR _hViewEntity$[ebp]
	mov	DWORD PTR [edx+224], eax
$LN59@ActivateVi:

; 2119 :             }
; 2120 :          }

	jmp	$LN50@ActivateVi
$LN53@ActivateVi:

; 2121 :          else
; 2122 :          if ( (ProcessInfo.nCurrState == 2 ||   // processing ENTITY
; 2123 :                ProcessInfo.nCurrState == 3) &&  // processing ATTRIB

	movsx	ecx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	ecx, 2
	je	SHORT $LN69@ActivateVi
	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	edx, 3
	jne	$LN67@ActivateVi
$LN69@ActivateVi:
	push	6
	mov	eax, DWORD PTR _szlATTRIB
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	add	ecx, DWORD PTR _ProcessInfo$[ebp+4]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN67@ActivateVi

; 2124 :               zstrncmp( &ProcessInfo.szLine[ 1 ], szlATTRIB, 6 ) == 0 )
; 2125 :          {
; 2126 :             // Processing ENTITY, OR ATTRIB and ATTRIB appears.
; 2127 :             LPVIEWATTRIB lpPrevViewAttrib;
; 2128 : 
; 2129 :             ProcessInfo.nCurrState = 3;  // processing ATTRIB

	mov	edx, 3
	mov	WORD PTR _ProcessInfo$[ebp+318], dx

; 2130 :             ProcessInfo.bPersist = FALSE;

	mov	BYTE PTR _ProcessInfo$[ebp+329], 0

; 2131 :             ProcessInfo.bLth     = FALSE;

	mov	BYTE PTR _ProcessInfo$[ebp+326], 0

; 2132 :             ProcessInfo.bDomain  = FALSE;

	mov	BYTE PTR _ProcessInfo$[ebp+328], 0

; 2133 :             ProcessInfo.bType    = FALSE;

	mov	BYTE PTR _ProcessInfo$[ebp+327], 0

; 2134 :             lpPrevViewAttrib = lpViewAttrib;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpPrevViewAttrib$6[ebp], eax

; 2135 :             hndl = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10013					; 0000271dH
	push	0
	push	1
	push	259					; 00000103H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$[ebp], eax

; 2136 :                                      sizeof( ViewAttribRecord ), 1, 0,
; 2137 :                                      iViewAttrib );
; 2138 :             lpViewAttrib = zGETPTR( hndl );

	mov	eax, DWORD PTR _hndl$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 2139 :             if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN70@ActivateVi

; 2140 :                ProcessInfo.nCurrState = 10;  // set error

	mov	ecx, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], cx
	jmp	SHORT $LN71@ActivateVi
$LN70@ActivateVi:

; 2141 :             else
; 2142 :             {
; 2143 :                lpViewAttrib->hViewEntity = hViewEntity;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR _hViewEntity$[ebp]
	mov	DWORD PTR [edx+6], eax

; 2144 : 
; 2145 :                // Chain new Attrib to Entity or prev Attrib.
; 2146 :                if ( lpPrevViewAttrib )

	cmp	DWORD PTR _lpPrevViewAttrib$6[ebp], 0
	je	SHORT $LN72@ActivateVi

; 2147 :                   lpPrevViewAttrib->hNextOD_Attrib = hndl;

	mov	ecx, DWORD PTR _lpPrevViewAttrib$6[ebp]
	mov	edx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [ecx+2], edx
	jmp	SHORT $LN71@ActivateVi
$LN72@ActivateVi:

; 2148 :                else
; 2149 :                   lpViewEntity->hFirstOD_Attrib = hndl;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [eax+179], ecx
$LN71@ActivateVi:

; 2150 :             }
; 2151 :          }

	jmp	$LN50@ActivateVi
$LN67@ActivateVi:

; 2152 :          else
; 2153 :          if ( ProcessInfo.nCurrState == 3 &&

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	edx, 3
	jne	$LN74@ActivateVi
	push	10					; 0000000aH
	mov	eax, DWORD PTR _szlDATARECORD
	push	eax
	mov	ecx, 1
	shl	ecx, 0
	add	ecx, DWORD PTR _ProcessInfo$[ebp+4]
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN74@ActivateVi

; 2154 :               zstrncmp( &ProcessInfo.szLine[ 1 ], szlDATARECORD, 10 ) == 0 )
; 2155 :          {
; 2156 :             LPDATARECORD lpPrevDataRecord;
; 2157 : 
; 2158 :             ProcessInfo.nCurrState = 4;  // processing DATARECORD

	mov	edx, 4
	mov	WORD PTR _ProcessInfo$[ebp+318], dx

; 2159 :             lpDataField  = 0;

	mov	DWORD PTR _lpDataField$[ebp], 0

; 2160 :             lpRelRecord  = 0;

	mov	DWORD PTR _lpRelRecord$[ebp], 0

; 2161 :             lpPrevDataRecord = lpDataRecord;

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	DWORD PTR _lpPrevDataRecord$5[ebp], eax

; 2162 :             hndl = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10014					; 0000271eH
	push	0
	push	1
	push	280					; 00000118H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$[ebp], eax

; 2163 :                                      sizeof( DataRecordRecord ), 1, 0,
; 2164 :                                      iDataRecord );
; 2165 :             lpDataRecord = zGETPTR( hndl );

	mov	eax, DWORD PTR _hndl$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 2166 :             if ( lpDataRecord == 0 )

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	jne	SHORT $LN76@ActivateVi

; 2167 :                ProcessInfo.nCurrState = 10;  // set error

	mov	ecx, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], cx
	jmp	SHORT $LN77@ActivateVi
$LN76@ActivateVi:

; 2168 :             else
; 2169 :             {
; 2170 :                if ( lpPrevDataRecord )

	cmp	DWORD PTR _lpPrevDataRecord$5[ebp], 0
	je	SHORT $LN78@ActivateVi

; 2171 :                   lpPrevDataRecord->hNextDataRecord = hndl;

	mov	edx, DWORD PTR _lpPrevDataRecord$5[ebp]
	mov	eax, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [edx+2], eax
	jmp	SHORT $LN77@ActivateVi
$LN78@ActivateVi:

; 2172 :                else
; 2173 :                   lpViewEntity->hFirstDataRecord = hndl;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [ecx+191], edx
$LN77@ActivateVi:

; 2174 :             }
; 2175 :          }

	jmp	$LN50@ActivateVi
$LN74@ActivateVi:

; 2176 :          else
; 2177 :          if ( (ProcessInfo.nCurrState == 4 ||   // processing DATARECORD
; 2178 :                ProcessInfo.nCurrState == 5) &&  // processing DATAFIELD

	movsx	eax, WORD PTR _ProcessInfo$[ebp+318]
	cmp	eax, 4
	je	SHORT $LN82@ActivateVi
	movsx	ecx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	ecx, 5
	jne	$LN80@ActivateVi
$LN82@ActivateVi:
	push	9
	mov	edx, DWORD PTR _szlDATAFIELD
	push	edx
	mov	eax, 1
	shl	eax, 0
	add	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN80@ActivateVi

; 2179 :               zstrncmp( &ProcessInfo.szLine[ 1 ], szlDATAFIELD, 9 ) == 0 )
; 2180 :          {
; 2181 :             LPDATAFIELD  lpPrevDataField;
; 2182 : 
; 2183 :             ProcessInfo.nCurrState = 5;  // processing DATAFIELD

	mov	ecx, 5
	mov	WORD PTR _ProcessInfo$[ebp+318], cx

; 2184 :             lpPrevDataField = lpDataField;

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	DWORD PTR _lpPrevDataField$4[ebp], edx

; 2185 :             hndl = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10015					; 0000271fH
	push	0
	push	1
	push	279					; 00000117H
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$[ebp], eax

; 2186 :                                      sizeof( DataFieldRecord ), 1, 0,
; 2187 :                                      iDataField );
; 2188 :             lpDataField = zGETPTR( hndl );

	mov	edx, DWORD PTR _hndl$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField$[ebp], eax

; 2189 :             if ( lpDataField == 0 )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	jne	SHORT $LN83@ActivateVi

; 2190 :                ProcessInfo.nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], ax
	jmp	SHORT $LN84@ActivateVi
$LN83@ActivateVi:

; 2191 :             else
; 2192 :             {
; 2193 :                if ( lpPrevDataField )

	cmp	DWORD PTR _lpPrevDataField$4[ebp], 0
	je	SHORT $LN85@ActivateVi

; 2194 :                   lpPrevDataField->hNextDataField = hndl;

	mov	ecx, DWORD PTR _lpPrevDataField$4[ebp]
	mov	edx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [ecx+2], edx
	jmp	SHORT $LN84@ActivateVi
$LN85@ActivateVi:

; 2195 :                else
; 2196 :                   lpDataRecord->hFirstDataField = hndl;

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [eax+10], ecx
$LN84@ActivateVi:

; 2197 :             }
; 2198 :          }

	jmp	$LN50@ActivateVi
$LN80@ActivateVi:

; 2199 :          else
; 2200 :          if ( (ProcessInfo.nCurrState == 5 ||   // processing DATAFIELD
; 2201 :                ProcessInfo.nCurrState == 6 ||   // processing RELRECORD
; 2202 :                ProcessInfo.nCurrState == 7) &&  // processing RELFIELD

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	edx, 5
	je	SHORT $LN89@ActivateVi
	movsx	eax, WORD PTR _ProcessInfo$[ebp+318]
	cmp	eax, 6
	je	SHORT $LN89@ActivateVi
	movsx	ecx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	ecx, 7
	jne	$LN87@ActivateVi
$LN89@ActivateVi:
	push	9
	mov	edx, DWORD PTR _szlRELRECORD
	push	edx
	mov	eax, 1
	shl	eax, 0
	add	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN87@ActivateVi

; 2203 :               zstrncmp( &ProcessInfo.szLine[ 1 ], szlRELRECORD, 9 ) == 0 )
; 2204 :          {
; 2205 :             LPRELRECORD  lpPrevRelRecord;
; 2206 : 
; 2207 :             ProcessInfo.nCurrState = 6;  // processing RELRECORD

	mov	ecx, 6
	mov	WORD PTR _ProcessInfo$[ebp+318], cx

; 2208 :             lpRelField = 0;

	mov	DWORD PTR _lpRelField$[ebp], 0

; 2209 :             lpPrevRelRecord = lpRelRecord;

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	DWORD PTR _lpPrevRelRecord$3[ebp], edx

; 2210 :             hndl = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10016					; 00002720H
	push	0
	push	1
	push	795					; 0000031bH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$[ebp], eax

; 2211 :                                      sizeof( RelRecordRecord ), 1, 0,
; 2212 :                                      iRelRecord );
; 2213 :             lpRelRecord = zGETPTR( hndl );

	mov	edx, DWORD PTR _hndl$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 2214 :             if ( lpRelRecord == 0 )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	jne	SHORT $LN90@ActivateVi

; 2215 :                ProcessInfo.nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], ax
	jmp	SHORT $LN91@ActivateVi
$LN90@ActivateVi:

; 2216 :             else
; 2217 :             {
; 2218 :                if ( lpPrevRelRecord )

	cmp	DWORD PTR _lpPrevRelRecord$3[ebp], 0
	je	SHORT $LN92@ActivateVi

; 2219 :                   lpPrevRelRecord->hNextRelRecord = hndl;

	mov	ecx, DWORD PTR _lpPrevRelRecord$3[ebp]
	mov	edx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [ecx+2], edx
	jmp	SHORT $LN91@ActivateVi
$LN92@ActivateVi:

; 2220 :                else
; 2221 :                   lpDataRecord->hFirstRelRecord = hndl;

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [eax+6], ecx
$LN91@ActivateVi:

; 2222 :             }
; 2223 :          }

	jmp	$LN50@ActivateVi
$LN87@ActivateVi:

; 2224 :          else
; 2225 :          if ( (ProcessInfo.nCurrState == 5 ||   // processing DATAFIELD
; 2226 :                ProcessInfo.nCurrState == 6 ||   // processing RELRECORD
; 2227 :                ProcessInfo.nCurrState == 7) &&  // processing RELFIELD

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	edx, 5
	je	SHORT $LN96@ActivateVi
	movsx	eax, WORD PTR _ProcessInfo$[ebp+318]
	cmp	eax, 6
	je	SHORT $LN96@ActivateVi
	movsx	ecx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	ecx, 7
	jne	$LN94@ActivateVi
$LN96@ActivateVi:
	push	8
	mov	edx, DWORD PTR _szlRELFIELD
	push	edx
	mov	eax, 1
	shl	eax, 0
	add	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN94@ActivateVi

; 2228 :               zstrncmp( &ProcessInfo.szLine[ 1 ], szlRELFIELD, 8 ) == 0 )
; 2229 :          {
; 2230 :             LPRELFIELD  lpPrevRelField;
; 2231 : 
; 2232 :             ProcessInfo.nCurrState = 7;  // processing RELFIELD

	mov	ecx, 7
	mov	WORD PTR _ProcessInfo$[ebp+318], cx

; 2233 :             lpPrevRelField = lpRelField;

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	DWORD PTR _lpPrevRelField$2[ebp], edx

; 2234 :             hndl = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10017					; 00002721H
	push	0
	push	1
	push	278					; 00000116H
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$[ebp], eax

; 2235 :                                      sizeof( RelFieldRecord ), 1, 0,
; 2236 :                                      iRelField );
; 2237 :             lpRelField = zGETPTR( hndl );

	mov	edx, DWORD PTR _hndl$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax

; 2238 :             if ( lpRelField == 0 )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	jne	SHORT $LN97@ActivateVi

; 2239 :                ProcessInfo.nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], ax
	jmp	SHORT $LN98@ActivateVi
$LN97@ActivateVi:

; 2240 :             else
; 2241 :             {
; 2242 :                if ( lpPrevRelField )

	cmp	DWORD PTR _lpPrevRelField$2[ebp], 0
	je	SHORT $LN99@ActivateVi

; 2243 :                   lpPrevRelField->hNextRelField = hndl;

	mov	ecx, DWORD PTR _lpPrevRelField$2[ebp]
	mov	edx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [ecx+2], edx
	jmp	SHORT $LN98@ActivateVi
$LN99@ActivateVi:

; 2244 :                else
; 2245 :                   lpRelRecord->hFirstRelField = hndl;

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR [eax+6], ecx
$LN98@ActivateVi:

; 2246 :             }
; 2247 :          }

	jmp	SHORT $LN50@ActivateVi
$LN94@ActivateVi:

; 2248 :          else
; 2249 :          {
; 2250 :             //  "KZOEE054 - Invalid record found on line "
; 2251 :             fnIssueCoreError( lpTask, lpView, 16, 54, ProcessInfo.lLine,

	push	0
	lea	edx, DWORD PTR _ProcessInfo$[ebp+41]
	push	edx
	mov	eax, DWORD PTR _ProcessInfo$[ebp+298]
	push	eax
	push	54					; 00000036H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2252 :                               ProcessInfo.szFileName, 0 );
; 2253 :             ProcessInfo.nCurrState = 10;  // set error

	mov	eax, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], ax
$LN50@ActivateVi:

; 2254 :          }
; 2255 :       }

	jmp	$LN45@ActivateVi
$LN44@ActivateVi:

; 2256 :       else
; 2257 :       if ( ProcessInfo.szLine[ 0 ] == 'a' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ProcessInfo$[ebp+4]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 97					; 00000061H
	jne	$LN101@ActivateVi

; 2258 :       {
; 2259 :          // Parse the Attribute line received.
; 2260 :          SysParseLine( ProcessInfo.szAttrName, &ProcessInfo.szLine,

	mov	edx, 1
	shl	edx, 0
	add	edx, DWORD PTR _ProcessInfo$[ebp+4]
	push	edx
	lea	eax, DWORD PTR _ProcessInfo$[ebp+4]
	push	eax
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+8]
	push	ecx
	call	_SysParseLine@12

; 2261 :                        &ProcessInfo.szLine[ 1 ] );
; 2262 : 
; 2263 :          switch ( ProcessInfo.nCurrState )

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	mov	DWORD PTR tv559[ebp], edx
	mov	eax, DWORD PTR tv559[ebp]
	sub	eax, 1
	mov	DWORD PTR tv559[ebp], eax
	cmp	DWORD PTR tv559[ebp], 6
	ja	$LN15@ActivateVi
	mov	ecx, DWORD PTR tv559[ebp]
	jmp	DWORD PTR $LN121@ActivateVi[ecx*4]
$LN103@ActivateVi:

; 2264 :          {
; 2265 :             //
; 2266 :             //  ATTRIBUTES FOR OBJECT ENTITY
; 2267 :             //
; 2268 :             case 1:  // Processing Attributes for Object Entity
; 2269 :                fnProcessObjectEntity( lpView, lpViewOD, &ProcessInfo );

	lea	edx, DWORD PTR _ProcessInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnProcessObjectEntity
	add	esp, 12					; 0000000cH

; 2270 :                break;

	jmp	$LN15@ActivateVi
$LN104@ActivateVi:

; 2271 : 
; 2272 :             //
; 2273 :             //  ATTRIBUTES FOR ENTITY ENTITY
; 2274 :             //
; 2275 :             case 2:  // Processing Attributes for Entity Entity
; 2276 :                fnProcessEntityEntity( lpViewOD, lpViewEntity, &ProcessInfo );

	lea	edx, DWORD PTR _ProcessInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	call	_fnProcessEntityEntity
	add	esp, 12					; 0000000cH

; 2277 :                break;

	jmp	$LN15@ActivateVi
$LN105@ActivateVi:

; 2278 : 
; 2279 :             //
; 2280 :             //  ATTRIBUTES FOR ATTRIB ENTITY
; 2281 :             //
; 2282 :             case 3:  // Processing Attributes for Attribute Entity
; 2283 :                fnProcessAttribEntity( lpView, lpViewOD, lpViewEntity,

	lea	edx, DWORD PTR _ProcessInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnProcessAttribEntity
	add	esp, 20					; 00000014H

; 2284 :                                       lpViewAttrib, &ProcessInfo );
; 2285 :                break;

	jmp	$LN15@ActivateVi
$LN106@ActivateVi:

; 2286 : 
; 2287 :             //
; 2288 :             //  ATTRIBUTES FOR DATARECORD ENTITY
; 2289 :             //
; 2290 :             case 4:  // Processing Attributes for Data Record Entity
; 2291 :                fnProcessDataRecordEntity( lpViewOD, lpViewEntity,

	lea	ecx, DWORD PTR _ProcessInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDataRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	call	_fnProcessDataRecordEntity
	add	esp, 16					; 00000010H

; 2292 :                                           lpDataRecord, &ProcessInfo );
; 2293 :                break;

	jmp	$LN15@ActivateVi
$LN107@ActivateVi:

; 2294 : 
; 2295 :             //
; 2296 :             //  ATTRIBUTES FOR DATAFIELD ENTITY
; 2297 :             //
; 2298 :             case 5:  // Processing Attributes for Data Field Entity
; 2299 :                fnProcessDataFieldEntity( lpViewOD, lpViewEntity, lpDataRecord,

	lea	edx, DWORD PTR _ProcessInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataField$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	call	_fnProcessDataFieldEntity
	add	esp, 20					; 00000014H

; 2300 :                                          lpDataField, &ProcessInfo );
; 2301 :                break;

	jmp	SHORT $LN15@ActivateVi
$LN108@ActivateVi:

; 2302 : 
; 2303 :             //
; 2304 :             //  ATTRIBUTES FOR RELRECORD ENTITY
; 2305 :             //
; 2306 :             case 6:  // Processing Attributes for Rel Record Entity
; 2307 :                fnProcessRelRecordEntity( lpViewOD, lpViewEntity, lpDataRecord,

	lea	ecx, DWORD PTR _ProcessInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	call	_fnProcessRelRecordEntity
	add	esp, 20					; 00000014H

; 2308 :                                          lpRelRecord, &ProcessInfo );
; 2309 :                break;

	jmp	SHORT $LN15@ActivateVi
$LN109@ActivateVi:

; 2310 : 
; 2311 :             //
; 2312 :             //  ATTRIBUTES FOR RELFIELD ENTITY
; 2313 :             //
; 2314 :             case 7:  // Processing Attributes for Rel Field Entity
; 2315 :                fnProcessRelFieldEntity( lpViewOD, lpViewEntity, lpDataRecord,

	lea	eax, DWORD PTR _ProcessInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelField$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	call	_fnProcessRelFieldEntity
	add	esp, 24					; 00000018H
$LN15@ActivateVi:

; 2316 :                                         lpRelRecord, lpRelField, &ProcessInfo );
; 2317 :                break;
; 2318 : 
; 2319 :             default:
; 2320 :                break;
; 2321 : 
; 2322 :          }   // End switch ( nCurrState )
; 2323 :       }      // End if for 'e' or 'a' records

	jmp	SHORT $LN45@ActivateVi
$LN101@ActivateVi:

; 2324 :       else
; 2325 :       {
; 2326 :          //  "KZOEE054 - Invalid record found on line "
; 2327 :          fnIssueCoreError( lpTask, lpView, 16, 54, ProcessInfo.lLine,

	push	0
	lea	eax, DWORD PTR _ProcessInfo$[ebp+41]
	push	eax
	mov	ecx, DWORD PTR _ProcessInfo$[ebp+298]
	push	ecx
	push	54					; 00000036H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2328 :                            ProcessInfo.szFileName, 0 );
; 2329 :          ProcessInfo.nCurrState = 10;  // set error

	mov	ecx, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], cx
$LN45@ActivateVi:

; 2330 :       }
; 2331 : 
; 2332 :       // If an error occurred, force exit from loop.
; 2333 :       if ( ProcessInfo.nCurrState == 10 )

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN17@ActivateVi

; 2334 :          nEOF = 0;    // Error occurred force exit from loop

	xor	eax, eax
	mov	WORD PTR _nEOF$[ebp], ax
	jmp	SHORT $LN112@ActivateVi
$LN17@ActivateVi:

; 2335 :       else
; 2336 :       {
; 2337 :          // Read away until non-blank line or end-of-file reached.
; 2338 :          while ( (nEOF = SysReadLine( lpView, &ProcessInfo.szLine, hFile )) > 0 )

	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ProcessInfo$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysReadLine@12
	mov	WORD PTR _nEOF$[ebp], ax
	movsx	ecx, WORD PTR _nEOF$[ebp]
	test	ecx, ecx
	jle	SHORT $LN112@ActivateVi

; 2339 :          {
; 2340 :             ProcessInfo.lLine++;

	mov	edx, DWORD PTR _ProcessInfo$[ebp+298]
	add	edx, 1
	mov	DWORD PTR _ProcessInfo$[ebp+298], edx

; 2341 :             if ( ProcessInfo.szLine[ 0 ] == ' ' ||
; 2342 :                  ProcessInfo.szLine[ 0 ] == ';' ||

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ProcessInfo$[ebp+4]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN114@ActivateVi
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _ProcessInfo$[ebp+4]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 59					; 0000003bH
	je	SHORT $LN114@ActivateVi
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _ProcessInfo$[ebp+4]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN113@ActivateVi
$LN114@ActivateVi:

; 2343 :                  ProcessInfo.szLine[ 0 ] == 0 )
; 2344 :             {
; 2345 :                // Line contains a char that we should ignore, so read next line.
; 2346 :                continue;

	jmp	SHORT $LN17@ActivateVi
$LN113@ActivateVi:

; 2347 :             }
; 2348 : 
; 2349 :             // If we get here then we found a valid line so break loop.
; 2350 :             break;

	jmp	SHORT $LN112@ActivateVi

; 2351 :          }

	jmp	SHORT $LN17@ActivateVi
$LN112@ActivateVi:

; 2352 :       }
; 2353 :    } // while ( nEOF > 0 )...

	jmp	$LN8@ActivateVi
$LN9@ActivateVi:

; 2354 : 
; 2355 :    // Close the Object file.
; 2356 :    SysCloseFile( lpView, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysCloseFile@12

; 2357 : 
; 2358 :    // If currently processing an attribute, make sure length is specified.
; 2359 :    if ( ProcessInfo.nCurrState == 3 &&  // processing ATTRIB

	movsx	edx, WORD PTR _ProcessInfo$[ebp+318]
	cmp	edx, 3
	jne	SHORT $LN115@ActivateVi
	movzx	eax, BYTE PTR _ProcessInfo$[ebp+326]
	test	eax, eax
	jne	SHORT $LN115@ActivateVi

; 2360 :         ProcessInfo.bLth == FALSE )
; 2361 :    {
; 2362 :       if ( lpViewAttrib->cType == 'B' )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	jne	SHORT $LN116@ActivateVi

; 2363 :       {
; 2364 :          lpViewAttrib->ulLth = 7;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+203], 7

; 2365 :          ProcessInfo.bLth = TRUE;

	mov	BYTE PTR _ProcessInfo$[ebp+326], 1

; 2366 :       }

	jmp	SHORT $LN115@ActivateVi
$LN116@ActivateVi:

; 2367 :       else
; 2368 :       {
; 2369 :          //  "KZOEE052 - Invalid Object file, Attrib w/o lth on line "
; 2370 :          fnIssueCoreError( lpTask, lpView, 16, 52, ProcessInfo.lLine,

	push	0
	lea	ecx, DWORD PTR _ProcessInfo$[ebp+41]
	push	ecx
	mov	edx, DWORD PTR _ProcessInfo$[ebp+298]
	push	edx
	push	52					; 00000034H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2371 :                            ProcessInfo.szFileName, 0 );
; 2372 :          ProcessInfo.nCurrState = 10;  // set error

	mov	edx, 10					; 0000000aH
	mov	WORD PTR _ProcessInfo$[ebp+318], dx
$LN115@ActivateVi:

; 2373 :       }
; 2374 :    }
; 2375 : 
; 2376 :    // If an error did NOT occur, add this object to the application.
; 2377 :    if ( lpViewOD && ProcessInfo.nCurrState != 10 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN118@ActivateVi
	movsx	eax, WORD PTR _ProcessInfo$[ebp+318]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN118@ActivateVi

; 2378 :    {
; 2379 :    // LPVIEWOD  lpViewODT;
; 2380 : 
; 2381 :       lpViewOD->hNextViewOD = lpApp->hFirstViewOD;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+2], eax

; 2382 :       lpApp->hFirstViewOD = hViewOD;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR _hViewOD$[ebp]
	mov	DWORD PTR [ecx+84], edx

; 2383 :    // TraceLine( "ActivateViewObject App (0x%08x): %s   loaded ViewOD (0x%08x): %s",
; 2384 :    //            zGETHNDL( lpApp ), lpApp->szName, zGETHNDL( lpViewOD ), lpViewOD->szName );
; 2385 :    //
; 2386 :    // for ( lpViewODT = zGETPTR( lpApp->hFirstViewOD );
; 2387 :    //       lpViewODT;
; 2388 :    //       lpViewODT = zGETPTR( lpViewODT->hNextViewOD ) )
; 2389 :    // {
; 2390 :    //    TraceLine( "ActivateViewObject (after add) App (0x%08x): %s  ViewOD (0x%08x): %s",
; 2391 :    //               zGETHNDL( lpApp ), lpApp->szName, zGETHNDL( lpViewODT ), lpViewODT->szName );
; 2392 :    // }
; 2393 :    }

	jmp	SHORT $LN119@ActivateVi
$LN118@ActivateVi:

; 2394 :    else
; 2395 :    {
; 2396 :       fnDeleteViewObject( lpViewOD );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	call	_fnDeleteViewObject@4

; 2397 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2398 :       return( 0 ); // return null Object pointer

	xor	eax, eax
	jmp	$LN1@ActivateVi
$LN119@ActivateVi:

; 2399 :    }
; 2400 : 
; 2401 :    // Now loop through all the entities/attributes and reset the offset
; 2402 :    // values to skip over the attribute flag structure.
; 2403 :    for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN21@ActivateVi
$LN19@ActivateVi:

; 2405 :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN21@ActivateVi:

; 2404 :          lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN20@ActivateVi

; 2406 :    {
; 2407 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN24@ActivateVi
$LN22@ActivateVi:

; 2409 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN24@ActivateVi:

; 2408 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN23@ActivateVi

; 2410 :       {
; 2411 :          lpViewAttrib->ulRecordOffset += sizeof( AttribFlagsRecord );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+250]
	add	ecx, 4
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+250], ecx

; 2412 :       }

	jmp	SHORT $LN22@ActivateVi
$LN23@ActivateVi:

; 2413 :    }

	jmp	SHORT $LN19@ActivateVi
$LN20@ActivateVi:

; 2414 : 
; 2415 : // TraceLine( "ActivateViewObject App (0x%08x): %s   checking ViewOD (0x%08x): %s  LibName: %s  DBHandler: 0x%08x  From: %s",
; 2416 : //            zGETHNDL( lpApp ), lpApp->szName, zGETHNDL( lpViewOD ),
; 2417 : //            cpcViewOD_Name, lpViewOD->szOperLibname, lpViewOD->hDBHandler,
; 2418 : //            ProcessInfo.szFileName );
; 2419 : 
; 2420 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2421 : 
; 2422 : // if ( zstrcmp( cpcViewOD_Name, "mGLBudgt" ) == 0 )
; 2423 : //    DisplayObjectDefinition( lpViewOD );
; 2424 : 
; 2425 :    return( lpViewOD );  // return Object Definition pointer

	mov	eax, DWORD PTR _lpViewOD$[ebp]
$LN1@ActivateVi:

; 2426 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN121@ActivateVi:
	DD	$LN103@ActivateVi
	DD	$LN104@ActivateVi
	DD	$LN105@ActivateVi
	DD	$LN106@ActivateVi
	DD	$LN107@ActivateVi
	DD	$LN108@ActivateVi
	DD	$LN109@ActivateVi
_ActivateViewObject@12 ENDP
_TEXT	ENDS
END
