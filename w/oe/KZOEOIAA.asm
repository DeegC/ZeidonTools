; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEOIAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_gszKeyDelimStr
_BSS	SEGMENT
$SG14413 DB	01H DUP (?)
	ALIGN	4

$SG15601 DB	01H DUP (?)
	ALIGN	4

$SG13572 DB	01H DUP (?)
	ALIGN	4

$SG13575 DB	01H DUP (?)
	ALIGN	4

$SG13577 DB	01H DUP (?)
	ALIGN	4

$SG16719 DB	01H DUP (?)
	ALIGN	4

$SG16791 DB	01H DUP (?)
	ALIGN	4

$SG14777 DB	01H DUP (?)
	ALIGN	4

?ZeroAttribFlags@?BO@??fnWriteOI_ToTextStream@@9@9 DD 01H DUP (?) ; `fnWriteOI_ToTextStream'::`30'::ZeroAttribFlags
$SG14876 DB	01H DUP (?)
	ALIGN	4

$SG14945 DB	01H DUP (?)
	ALIGN	4

$SG14952 DB	01H DUP (?)
	ALIGN	4

$SG14953 DB	01H DUP (?)
	ALIGN	4

$SG14954 DB	01H DUP (?)
	ALIGN	4

$SG14960 DB	01H DUP (?)
	ALIGN	4

$SG14971 DB	01H DUP (?)
	ALIGN	4

$SG14972 DB	01H DUP (?)
	ALIGN	4

$SG14978 DB	01H DUP (?)
	ALIGN	4

$SG16039 DB	01H DUP (?)
	ALIGN	4

$SG14088 DB	01H DUP (?)
	ALIGN	4

$SG14090 DB	01H DUP (?)
	ALIGN	4

$SG14092 DB	01H DUP (?)
	ALIGN	4

$SG14099 DB	01H DUP (?)
	ALIGN	4

$SG15124 DB	01H DUP (?)
	ALIGN	4

$SG18216 DB	01H DUP (?)
	ALIGN	4

$SG15150 DB	01H DUP (?)
	ALIGN	4

$SG18227 DB	01H DUP (?)
	ALIGN	4

$SG14172 DB	01H DUP (?)
	ALIGN	4

$SG17326 DB	01H DUP (?)
	ALIGN	4

$SG17382 DB	01H DUP (?)
	ALIGN	4

$SG17401 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG17408 DB	'(oi) Target Entity = ', 00H
	ORG $+2
$SG17423 DB	'(oi) Entity type mismatch during cursor restoration for '
	DB	'entity ', 00H
$SG14351 DB	'More than one zLEVEL_ option requested', 00H
	ORG $+1
$SG17425 DB	'ZEND', 00H
	ORG $+3
$SG18455 DB	'KZDBHQUA', 00H
	ORG $+3
$SG18456 DB	'EntitySpec', 00H
	ORG $+1
$SG18457 DB	'*root*', 00H
	ORG $+1
$SG18458 DB	'EntityName', 00H
	ORG $+1
$SG18459 DB	'EntitySpec', 00H
	ORG $+1
$SG18460 DB	'QualAttrib', 00H
	ORG $+1
$SG18461 DB	'*root*', 00H
	ORG $+1
$SG18462 DB	'EntityName', 00H
	ORG $+1
$SG18463 DB	'QualAttrib', 00H
	ORG $+1
$SG18464 DB	'AttributeName', 00H
	ORG $+2
$SG18465 DB	'QualAttrib', 00H
	ORG $+1
$SG18466 DB	'=', 00H
	ORG $+2
$SG18467 DB	'Oper', 00H
	ORG $+3
$SG18468 DB	'QualAttrib', 00H
	ORG $+1
$SG18469 DB	'KeyList', 00H
$SG18470 DB	'IntegerValue', 00H
	ORG $+3
$SG18471 DB	'KeyList', 00H
$SG15404 DB	'ZeidonLock', 00H
	ORG $+1
$SG15407 DB	'@%s', 00H
$SG14419 DB	'Out of buffer space', 00H
$SG14420 DB	'Internal Core Error', 00H
$SG16485 DB	'- ParentEntity == ChildEntity', 00H
	ORG $+2
$SG16486 DB	'(oi) Hangin key error! ', 00H
$SG15463 DB	'ZPLOCKO', 00H
$SG17525 DB	'KZDBHQUA', 00H
	ORG $+3
$SG17547 DB	'TZCMULWO', 00H
	ORG $+3
$SG17548 DB	'TZCMULWO', 00H
	ORG $+3
$SG17549 DB	'TZCMULWO', 00H
	ORG $+3
$SG17550 DB	'(%s) = %lf seconds', 00H
	ORG $+1
$SG17551 DB	'(oi) Total time for SfActivateOI_FromStream ', 00H
	ORG $+3
$SG14484 DB	'KZ', 00H
	ORG $+1
$SG14486 DB	'DBH_MsgProc', 00H
$SG14488 DB	'_DBH_MsgProc', 00H
	ORG $+3
$SG17568 DB	'Zeidon OE', 00H
	ORG $+2
$SG17566 DB	'SfActivateSysOI_FromFile now REQUIRES a non-zero qualifi'
	DB	'cation view for Object Definition: %s', 00H
	ORG $+2
$SG17567 DB	'SfActivateSysOI_FromFile now REQUIRES a non-zero qualifi'
	DB	'cation view.  System will now crash', 00H
$SG16556 DB	'KZDBHQUA', 00H
	ORG $+3
$SG16559 DB	'EntitySpec', 00H
	ORG $+1
$SG16560 DB	'EntityName', 00H
	ORG $+1
$SG17588 DB	'SfActivateSysEmptyOI now REQUIRES a non-zero qualificati'
	DB	'on view for Object Definition: %s.', 00H
	ORG $+1
$SG17590 DB	'Zeidon OE', 00H
	ORG $+2
$SG17589 DB	'SfActivateSysEmptyOI now REQUIRES a non-zero qualificati'
	DB	'on view.  System will now crash', 00H
$SG13494 DB	'More than one zLEVEL_ option requested', 00H
	ORG $+1
$SG16569 DB	'QualAttrib', 00H
	ORG $+1
$SG16570 DB	'QualAttrib', 00H
	ORG $+1
$SG13499 DB	'with zLEVEL_SAME', 00H
	ORG $+3
$SG13500 DB	'lpAppQualView', 00H
	ORG $+2
$SG16574 DB	'EntityName', 00H
	ORG $+1
$SG16575 DB	'EntityName', 00H
	ORG $+1
$SG16576 DB	'EntityName', 00H
	ORG $+1
$SG14529 DB	'KZ', 00H
	ORG $+1
$SG14530 DB	'(oi) Attempting to load GK-handler as ', 00H
	ORG $+1
$SG14531 DB	'(oi) Attempting to load GK-handler as ', 00H
	ORG $+1
$SG16581 DB	'AttributeName', 00H
	ORG $+2
$SG14533 DB	'GKH_MsgProc', 00H
$SG16582 DB	'AttributeName', 00H
	ORG $+2
$SG16583 DB	'AttributeName', 00H
	ORG $+2
$SG14535 DB	'_GKH_MsgProc', 00H
	ORG $+3
$SG16588 DB	'Oper', 00H
	ORG $+3
$SG16589 DB	'Oper', 00H
	ORG $+3
$SG16590 DB	'Oper', 00H
	ORG $+3
$SG16594 DB	'Value', 00H
	ORG $+2
$SG16595 DB	'Value', 00H
	ORG $+2
$SG16596 DB	'Value', 00H
	ORG $+2
_gszKeyDelimStr DB '/|\', 09H, 0aH, '`~!@#$%^&*-_=+;<>?aAzZ10', 00H
	ORG $+2
$SG13543 DB	'EntitySpec', 00H
	ORG $+1
$SG13544 DB	'EntitySpec', 00H
	ORG $+1
$SG13545 DB	'EntitySpec', 00H
	ORG $+1
$SG13546 DB	'EntitySpec', 00H
	ORG $+1
$SG13547 DB	'SourceViewName', 00H
	ORG $+1
$SG13550 DB	'SourceViewID', 00H
	ORG $+3
$SG15599 DB	'Couldn''t find original OI!', 00H
	ORG $+1
$SG15600 DB	'Internal Core Error', 00H
$SG13552 DB	'SourceEntityName', 00H
	ORG $+3
$SG13553 DB	'SourceAttributeName', 00H
$SG15602 DB	'(oi) Activating Optimistic Check view', 00H
	ORG $+2
$SG13554 DB	'Oper', 00H
	ORG $+3
$SG13556 DB	'IS', 00H
	ORG $+1
$SG15605 DB	'(oi) Error loading Optimistic check view.  RC = ', 00H
	ORG $+3
$SG13557 DB	'(', 00H
	ORG $+2
$SG13558 DB	'Oper', 00H
	ORG $+3
$SG15607 DB	'(oi) Optimistic locking compare RC = ', 00H
	ORG $+2
$SG14586 DB	'View doesn''t have an OI', 00H
$SG13562 DB	'AND', 00H
$SG13563 DB	'Oper', 00H
	ORG $+3
$SG13564 DB	'EntityName', 00H
	ORG $+1
$SG13565 DB	'AttributeName', 00H
	ORG $+2
$SG13566 DB	'=', 00H
	ORG $+2
$SG13567 DB	'Oper', 00H
	ORG $+3
$SG13568 DB	'Value', 00H
	ORG $+2
$SG13569 DB	')', 00H
	ORG $+2
$SG13570 DB	'Oper', 00H
	ORG $+3
$SG13571 DB	'Value', 00H
	ORG $+2
$SG13573 DB	'SourceViewName', 00H
	ORG $+1
$SG13574 DB	'SourceViewID', 00H
	ORG $+3
$SG13576 DB	'SourceEntityName', 00H
	ORG $+3
$SG13578 DB	'SourceAttributeName', 00H
$SG16713 DB	'@%s', 00H
$SG16714 DB	'=', 00H
	ORG $+2
$SG16715 DB	'LOD_Name', 00H
	ORG $+3
$SG16716 DB	'ZeidonLock', 00H
	ORG $+1
$SG16717 DB	'ZeidonLock', 00H
	ORG $+1
$SG16718 DB	'AND', 00H
$SG13646 DB	'LOD_Name', 00H
	ORG $+3
$SG13647 DB	'LOD_Name', 00H
	ORG $+3
$SG16720 DB	'=', 00H
	ORG $+2
$SG13648 DB	'LOD_Name', 00H
	ORG $+3
$SG16721 DB	'KeyValue', 00H
	ORG $+3
$SG16722 DB	'ZeidonLock', 00H
	ORG $+1
$SG16723 DB	'Value', 00H
	ORG $+2
$SG16724 DB	'ZPLOCKO', 00H
$SG13652 DB	'KeyValue', 00H
	ORG $+3
$SG13653 DB	'KeyValue', 00H
	ORG $+3
$SG13654 DB	'KeyValue', 00H
	ORG $+3
$SG16727 DB	'AllowRead', 00H
	ORG $+2
$SG16728 DB	'ZeidonLock', 00H
	ORG $+1
$SG13658 DB	'UserName', 00H
	ORG $+3
$SG13659 DB	'UserName', 00H
	ORG $+3
$SG13660 DB	'UserName', 00H
	ORG $+3
$SG16733 DB	'LOD ''%s'' is locked', 00H
	ORG $+1
$SG16734 DB	'Entity ''%s'' is locked', 00H
	ORG $+2
$SG16735 DB	'UserName', 00H
	ORG $+3
$SG16736 DB	'ZeidonLock', 00H
	ORG $+1
$SG16737 DB	'Timestamp', 00H
	ORG $+2
$SG13665 DB	'Timestamp', 00H
	ORG $+2
$SG16738 DB	'ZeidonLock', 00H
	ORG $+1
$SG13666 DB	'Timestamp', 00H
	ORG $+2
$SG16739 DB	'YYYY-M-D HH:MI:SS', 00H
	ORG $+2
$SG13667 DB	'Timestamp', 00H
	ORG $+2
$SG16740 DB	'(oi) Object locked by ', 00H
	ORG $+1
$SG16741 DB	'(oi) Object locked on ', 00H
	ORG $+1
$SG16742 DB	'(oi) Concatenated key = ', 00H
	ORG $+3
$SG13671 DB	'AllowRead', 00H
	ORG $+2
$SG13672 DB	'AllowRead', 00H
	ORG $+2
$SG13673 DB	'AllowRead', 00H
	ORG $+2
$SG16792 DB	'==== Activate error: Infinite recursive subobject ====', 00H
	ORG $+1
$SG16793 DB	'Object Name   = ', 00H
	ORG $+3
$SG13721 DB	'ZPLOCKO', 00H
$SG16794 DB	'Parent Entity = ', 00H
	ORG $+3
$SG16795 DB	'Parent level  = ', 00H
	ORG $+3
$SG14747 DB	'Object Name = ', 00H
	ORG $+1
$SG16796 DB	'Child Entity  = ', 00H
	ORG $+3
$SG16797 DB	'Child level   = ', 00H
	ORG $+3
$SG13732 DB	'#Global Entity Lock', 00H
$SG13733 DB	'#%s', 00H
$SG13735 DB	'LOD_Name', 00H
	ORG $+3
$SG13736 DB	'ZeidonLock', 00H
	ORG $+1
$SG13737 DB	'ZeidonLock', 00H
	ORG $+1
$SG13740 DB	'N', 00H
	ORG $+2
$SG13741 DB	'Locking semaphore', 00H
	ORG $+2
$SG14766 DB	'(oi) Can''t start network = ', 00H
$SG14767 DB	'Network cannot be started.', 00H
	ORG $+1
$SG14768 DB	'KZOEOIAA', 00H
	ORG $+3
$SG14769 DB	'xx', 00H
	ORG $+1
$SG13747 DB	'Waited too long to write pessimistic lock semaphore', 00H
$SG14778 DB	'(oi) Warning ============================', 00H
	ORG $+2
$SG14779 DB	'(oi) Object definition = ', 00H
	ORG $+2
$SG14780 DB	'(oi) Entity name = ', 00H
$SG14781 DB	'(oi) EI Flags    = ', 00H
$SG14783 DB	'OE Warning', 00H
	ORG $+1
$SG14782 DB	'Return code indicates that Commit was successful but OI '
	DB	'still has instances marked as changed.', 00H
	ORG $+1
$SG14784 DB	'%s  %s   Object Definition: %s   EntityName: %s   EI Fla'
	DB	'gs 0x%08x', 00H
	ORG $+2
$SG14785 DB	'OE Warning', 00H
	ORG $+1
$SG14794 DB	'%lf seconds', 00H
$SG14795 DB	'(oi) Total time for CommitMultipleOIs = ', 00H
	ORG $+3
$SG13790 DB	'ZPLOCKO', 00H
$SG13800 DB	'#Global Entity Lock', 00H
$SG13801 DB	'#%s', 00H
$SG13802 DB	'ZeidonLock', 00H
	ORG $+1
$SG13805 DB	'Locking semaphore', 00H
	ORG $+2
$SG16927 DB	'ZPLOCKO', 00H
$SG16929 DB	'ZeidonLock', 00H
	ORG $+1
$SG16932 DB	'@%s', 00H
$SG16935 DB	'Y', 00H
	ORG $+2
$SG15911 DB	'mOITAG %lx', 00H
	ORG $+1
$SG16936 DB	'N', 00H
	ORG $+2
$SG15912 DB	'mOITAG      %lx', 00H
$SG15917 DB	'mOITAG %lx', 00H
	ORG $+1
$SG15918 DB	'mOITAG      %lx', 00H
$SG15926 DB	'mOIFLAGS %lx', 00H
	ORG $+3
$SG15927 DB	'mOIFLAGS    %lx', 00H
$SG15938 DB	'%x %x', 00H
	ORG $+2
$SG15946 DB	'mETAG %lx', 00H
	ORG $+2
$SG15947 DB	'mETAG      %lx', 00H
	ORG $+1
$SG15952 DB	'mETAG %lx', 00H
	ORG $+2
$SG15953 DB	'mETAG      %lx', 00H
	ORG $+1
$SG15958 DB	'mEKEY %lx', 00H
	ORG $+2
$SG15959 DB	'mEKEY      %lx', 00H
	ORG $+1
$SG18015 DB	'.bubblesort ', 00H
	ORG $+3
$SG14946 DB	'----------------- Warning ----------------', 00H
	ORG $+1
$SG14947 DB	'create', 00H
	ORG $+1
$SG14948 DB	'delete', 00H
	ORG $+1
$SG14949 DB	'created', 00H
$SG14950 DB	'deleted', 00H
$SG14951 DB	'Warning: Trying to commit an entity that has been %s but'
	DB	' does not have %s authority in the current cluster.  OD.Entit'
	DB	'yName = %s.%s', 00H
	ORG $+1
$SG14955 DB	'Number of views in the cluster: ', 00H
	ORG $+3
$SG14957 DB	'(null) View not flagged as changed', 00H
	ORG $+1
$SG14958 DB	'   View ID = ', 00H
	ORG $+2
$SG14959 DB	'   View ID = %lx, Object name = %s', 00H
	ORG $+1
$SG15985 DB	',%lx', 00H
	ORG $+3
$SG14961 DB	'%s.%s', 00H
	ORG $+2
$SG15988 DB	'a%lx%s ', 00H
$SG14964 DB	'OD.Entity with Create flag = ', 00H
	ORG $+2
$SG15989 DB	'%s%s', 00H
	ORG $+3
$SG14965 DB	'OD.Entity with Delete flag = ', 00H
	ORG $+2
$SG15990 DB	'a%-9s ', 00H
	ORG $+1
$SG14966 DB	'OI ID = ', 00H
	ORG $+3
$SG14968 DB	'%s.%s', 00H
	ORG $+2
$SG14969 DB	'OD.Entity with create authority = ', 00H
	ORG $+1
$SG14970 DB	'OI ID = ', 00H
	ORG $+3
$SG14973 DB	'create', 00H
	ORG $+1
$SG14974 DB	'delete', 00H
	ORG $+1
$SG14975 DB	'created', 00H
$SG14976 DB	'deleted', 00H
$SG14979 DB	'-------------------', 00H
$SG14977 DB	'Warning: Trying to commit an entity that has been %s but'
	DB	' does not have %s authority in the current cluster.  OD.Entit'
	DB	'yName = %s.%s. See trace for more information.', 00H
$SG18061 DB	'Maximum # of order attributes used', 00H
	ORG $+1
$SG18062 DB	'KZOEE013 - Internal operation call error: ', 00H
	ORG $+1
$SG18063 DB	'fnOrderOI_ByDefaultAttribs', 00H
	ORG $+1
$SG18064 DB	'Maximum # of order attributes used', 00H
	ORG $+1
$SG16034 DB	'a %x', 00H
	ORG $+3
$SG16058 DB	'i%lx %lx', 00H
	ORG $+3
$SG16053 DB	'(oi) Error (OD: %s) - Src View Entity: %s Token: %d  Vie'
	DB	'w Entity: %s Token = %d', 00H
$SG16055 DB	'Error writing OI: ER Tokens don''t match for linked enti'
	DB	'ties!', 00H
	ORG $+3
$SG14015 DB	'More than one zLEVEL_ option requested', 00H
	ORG $+1
$SG16064 DB	'c%x 0', 00H
	ORG $+2
$SG14022 DB	'with zLEVEL_SAME', 00H
	ORG $+3
$SG14023 DB	'lpAppQualView', 00H
	ORG $+2
$SG16072 DB	'c%x 0', 00H
	ORG $+2
$SG16074 DB	'c%x %lx', 00H
$SG14031 DB	'Expecting valid OI for zACTIVATE_CONTINUE', 00H
	ORG $+2
$SG14035 DB	'Root entity has no default sequencing attributes', 00H
	ORG $+3
$SG18134 DB	'Out of space for entities', 00H
	ORG $+2
$SG14038 DB	'kzdbhqua', 00H
	ORG $+3
$SG18135 DB	'KZOEE013 - Internal operation call error: ', 00H
	ORG $+1
$SG18136 DB	'fnOrderOI_ByDefaultAttribs', 00H
	ORG $+1
$SG18137 DB	'Maximum # of order entities used', 00H
	ORG $+3
$SG14041 DB	'(', 00H
	ORG $+2
$SG14042 DB	')', 00H
	ORG $+2
$SG14043 DB	'AND', 00H
$SG14044 DB	'(', 00H
	ORG $+2
$SG14045 DB	')', 00H
	ORG $+2
$SG14049 DB	'OR', 00H
	ORG $+1
$SG14050 DB	'(', 00H
	ORG $+2
$SG14053 DB	'AND', 00H
$SG14054 DB	'AttributeName', 00H
	ORG $+2
$SG14059 DB	'<', 00H
	ORG $+2
$SG14060 DB	'>', 00H
	ORG $+2
$SG14061 DB	'=', 00H
	ORG $+2
$SG14062 DB	'Value', 00H
	ORG $+2
$SG14064 DB	')', 00H
	ORG $+2
$SG14072 DB	'ZPLOCKO', 00H
$SG15097 DB	'No GenKey handler set for LOD: %s', 00H
	ORG $+2
$SG14074 DB	'KZDBHQUA', 00H
	ORG $+3
$SG15099 DB	'OIs have different GenKey handlers', 00H
	ORG $+1
$SG14080 DB	'__Load-in-progress', 00H
	ORG $+1
$SG16137 DB	'        ', 00H
	ORG $+3
$SG14089 DB	'(oi) -------------------------------', 00H
	ORG $+3
$SG14091 DB	'(oi) Database unavailable--try again', 00H
	ORG $+3
$SG18189 DB	'Sequencing error > 40', 00H
	ORG $+2
$SG14093 DB	'(oi) -------------------------------', 00H
	ORG $+3
$SG18190 DB	'KZOEE013 - Internal operation call error: ', 00H
	ORG $+1
$SG18191 DB	'fnOrderEntitiesByDefaultAttribs', 00H
$SG15119 DB	'KZGKHWOB', 00H
	ORG $+3
$SG18192 DB	'Maximum # of order attributes used', 00H
	ORG $+1
$SG15120 DB	'KZGKHWOB', 00H
	ORG $+3
$SG14096 DB	'(oi) Database Deadlock - Object=', 00H
	ORG $+3
$SG16145 DB	'mCONTROL %lx', 00H
	ORG $+3
$SG15121 DB	'_KZGKHWOB', 00H
	ORG $+2
$SG14097 DB	' Activate Retry Count=', 00H
	ORG $+1
$SG14100 DB	'(oi) Deadlock Crash - Retry Count exceeded', 00H
	ORG $+1
$SG16149 DB	'ZEND', 00H
	ORG $+3
$SG15125 DB	'EntityID', 00H
	ORG $+3
$SG15126 DB	'Genkey', 00H
	ORG $+1
$SG14103 DB	'__Load-in-progress', 00H
	ORG $+1
$SG16152 DB	'ZEND', 00H
	ORG $+3
$SG15129 DB	'EntityCount', 00H
$SG14105 DB	'(oi) Database Memory Limit Reached (Task: 0x%08x) - Obje'
	DB	'ct: %s', 00H
	ORG $+1
$SG15130 DB	'Genkey', 00H
	ORG $+1
$SG15131 DB	'Genkey', 00H
	ORG $+1
$SG16156 DB	'(%s) = %lf seconds', 00H
	ORG $+1
$SG15132 DB	'EntityID', 00H
	ORG $+3
$SG16157 DB	'(oi) Total time for SfWriteOI_ToStream ', 00H
$SG15133 DB	'Genkey', 00H
	ORG $+1
$SG15134 DB	'EntityCount', 00H
$SG15135 DB	'Genkey', 00H
	ORG $+1
$SG15136 DB	'TableName', 00H
	ORG $+2
$SG15137 DB	'Genkey', 00H
	ORG $+1
$SG14113 DB	'QualAttrib', 00H
	ORG $+1
$SG15138 DB	'EntityName', 00H
	ORG $+1
$SG14114 DB	'SubQualAttrib', 00H
	ORG $+2
$SG15139 DB	'Genkey', 00H
	ORG $+1
$SG15140 DB	'EntityCount', 00H
$SG14116 DB	'__Load-in-progress', 00H
	ORG $+1
$SG15141 DB	'Genkey', 00H
	ORG $+1
$SG14119 DB	'Network cannot be started.', 00H
	ORG $+1
$SG14120 DB	'KZOEOIAA', 00H
	ORG $+3
$SG18217 DB	'Ordering attributes -- resetting entity cursor.', 00H
$SG14121 DB	'xx', 00H
	ORG $+1
$SG18222 DB	'Unset or Null Cursor', 00H
	ORG $+3
$SG18223 DB	'KZOEE013 - Internal operation call error: ', 00H
	ORG $+1
$SG15151 DB	'EntityID', 00H
	ORG $+3
$SG18224 DB	'OrderEntities', 00H
	ORG $+2
$SG15152 DB	'Genkey', 00H
	ORG $+1
$SG15155 DB	'Infinite loop trying to set FKs?', 00H
	ORG $+3
$SG18228 DB	'Ordering attributes -- Entity cursor is null!', 00H
	ORG $+2
$SG14140 DB	'%lf seconds for object %s ', 00H
	ORG $+1
$SG14141 DB	'(oi) Total time for ActivateObjectInstance = ', 00H
	ORG $+2
$SG17241 DB	'CONTROL', 00H
$SG17242 DB	'CONTROL', 00H
$SG17243 DB	'CONTROL', 00H
$SG17247 DB	'ETAG', 00H
	ORG $+3
$SG17248 DB	'ETAG', 00H
	ORG $+3
$SG17249 DB	'ETAG', 00H
	ORG $+3
$SG17251 DB	'EKEY', 00H
	ORG $+3
$SG17252 DB	'EKEY', 00H
	ORG $+3
$SG17253 DB	'EKEY', 00H
	ORG $+3
$SG17257 DB	'OITAG', 00H
	ORG $+2
$SG17258 DB	'OITAG', 00H
	ORG $+2
$SG17259 DB	'OITAG', 00H
	ORG $+2
$SG18285 DB	'Error occurs after: ', 00H
	ORG $+3
$SG17261 DB	'OIFLAGS', 00H
$SG18286 DB	'Error parsing command.  See trace for more.', 00H
$SG17262 DB	'OIFLAGS', 00H
$SG17263 DB	'OIFLAGS', 00H
$SG14217 DB	'More than one zLEVEL_ option requested', 00H
	ORG $+1
$SG17292 DB	'(WARNING) Couldn''t find entity ', 00H
$SG17293 DB	'(WARNING) in LOD ', 00H
	ORG $+2
$SG14222 DB	'with zLEVEL_SAME', 00H
	ORG $+3
$SG14223 DB	'lpAppQualView', 00H
	ORG $+2
$SG18326 DB	'KZDBHQUA', 00H
	ORG $+3
$SG14234 DB	'TZCMULWO.POR', 00H
	ORG $+3
$SG18331 DB	'ACTIVATE ', 00H
	ORG $+2
$SG14235 DB	'(oi) opening ', 00H
	ORG $+2
$SG18334 DB	'EntitySpec', 00H
	ORG $+1
$SG18335 DB	'EntityName', 00H
	ORG $+1
$SG18336 DB	'EntitySpec', 00H
	ORG $+1
$SG18340 DB	'WHERE ', 00H
	ORG $+1
$SG17346 DB	'.', 00H
	ORG $+2
$SG17361 DB	'Error from UUDECODE_NextLineToBuffer: ', 00H
	ORG $+1
$SG17364 DB	'UUDECODE length invalid: ', 00H
	ORG $+2
$SG16368 DB	'Trying to drop original OI but it''s not there!', 00H
	ORG $+1
$SG17396 DB	'(oi) Error (OD: %s) - Tgt View Entity: %s Token: %d  Vie'
	DB	'w Entity: %s Token = %d', 00H
$SG17398 DB	'ER Tokens don''t match for linked entities!', 00H
	ORG $+1
$SG17402 DB	'(oi) Failed entity linking', 00H
	ORG $+1
$SG17403 DB	'(oi) Link Src # = ', 00H
	ORG $+1
$SG17405 DB	'(oi) Source Entity = ', 00H
	ORG $+2
$SG17406 DB	'(oi) Link Tgt # = ', 00H
_DATA	ENDS
PUBLIC	_ActivateEmptyObjectInstance@16
PUBLIC	_ActivateObjectInstance@20
PUBLIC	_ActivateOI_FromFile@20
PUBLIC	_ActivateOI_FromOI@12
PUBLIC	_ActivateOI_FromOI_ForTask@16
PUBLIC	_CommitObjectInstance@4
PUBLIC	_CommitMultipleOIs@16
PUBLIC	_CreateViewCluster@8
PUBLIC	_DropViewCluster@4
PUBLIC	_AddToViewCluster@12
PUBLIC	_AppendViewCluster@8
PUBLIC	_AddViewToViewCluster@8
PUBLIC	_CommitMultipleObjectInstances@8
PUBLIC	_CommitOI_ToFile@12
PUBLIC	_GenerateQualFromEntityList@20
PUBLIC	_DropObjectInstance@4
PUBLIC	_ObjectInstanceUpdated@4
PUBLIC	_ObjectInstanceUpdatedFromFile@4
PUBLIC	_OrderEntityForView@12
PUBLIC	_OrderEntitiesByDefaultAttribs@8
PUBLIC	_OrderOI_ByDefaultAttribs@4
PUBLIC	_SfActivateSysOI_FromFile@20
PUBLIC	_SfActivateSysEmptyOI@16
PUBLIC	_SfWriteOI_ToStream@20
PUBLIC	_SfActivateOI_FromStream@24
PUBLIC	_fnActivateEmptyObjectInstance
PUBLIC	_fnActivateObjectInstance
PUBLIC	_fnDropObjectInstance
PUBLIC	_fnDropViewOI
PUBLIC	_fnDateTimeFormat
PUBLIC	_fnGetObjCnstrntOper
PUBLIC	_fnInvokeOCEOperation
PUBLIC	_fnCleanupInstance
PUBLIC	_fnGetDBHandlerOper@12
PUBLIC	_fnGetGKHandlerOper
PUBLIC	_fnDropViewCsr
PUBLIC	_fnOrderEntitiesByDefaultAttribs
PUBLIC	_fnOrderOI_ByDefaultAttribs
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_UUENCODE_NextEncodedLine@16
PUBLIC	_UUDECODE_NextLineToBuffer@16
PUBLIC	_fnCommitObjectInstance@28
PUBLIC	_fnCompareEIAttrs@36
PUBLIC	_fnCreateConcatKey@16
PUBLIC	_fnResolveQualOI
PUBLIC	_fnSetLockingAttributes@36
PUBLIC	_fnCreatePessimisticSemaphore@20
PUBLIC	_fnDeletePessimisticSemaphore@20
PUBLIC	_fnRelinkObjectInstance@4
PUBLIC	_fnReadDataFromFileStream@20
PUBLIC	_fnReadDataFromBuffer@20
PUBLIC	_fnActivateOI_FromBuffer@24
PUBLIC	_fnSetForeignKeysForInstance@4
PUBLIC	_fnCheckCreateDeleteFlags@24
PUBLIC	_fnInitializeGenKeys@28
PUBLIC	_fnMarkDuplicateRelationship@8
PUBLIC	_fnCommitPreLoops
PUBLIC	_fnDeleteLocksOnTwins@24
PUBLIC	_fnRemoveLocksOnOIs@16
PUBLIC	_fnCommitSingleOI@16
PUBLIC	_fnPutDataToFile@20
PUBLIC	_fnWriteOI_ToTextStream
PUBLIC	_fnClearLinks@4
PUBLIC	_fnAddHangingEntity@8
PUBLIC	_fnCreateQualification@36
PUBLIC	_fnFindKeyDelim@16
PUBLIC	_fnCheckLocksOnTwins@24
PUBLIC	_fnCheckForRecursiveLoop@8
PUBLIC	_fnLoadChildEntities
PUBLIC	_fnSetLocksOnTwins@24
PUBLIC	_fnActivateOI_FromTextStream
PUBLIC	_fnCmprEntities
PUBLIC	_fnSortCmpr
PUBLIC	_Heapify
PUBLIC	_BuildHeap
PUBLIC	_fnHeapSort
PUBLIC	_fnQuickSort
PUBLIC	_fnBubbleSort
PUBLIC	_fnOrderEntityForView@16
PUBLIC	_fnGetSortAttrsFromEntity@16
PUBLIC	_fnQualError@8
PUBLIC	_CreateQualFromCommand
PUBLIC	__real@408f400000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp___strnicmp:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp__strtoul:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_DisplayEntityInstance@8:PROC
EXTRN	_DisplayEntityInstancePath@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_DeleteEntity@12:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorPrevEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_SetCursorFirstEntityByInteger@20:PROC
EXTRN	_MiSetOI_ReleaseForView@8:PROC
EXTRN	_MiCompareOI_ToRelease@8:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_GetIntegerFromAttribute@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_AddToAttributeFromInteger@16:PROC
EXTRN	_SetAttributeFromAttribute@24:PROC
EXTRN	_UfFormatDateTime@12:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_NetStartup@12:PROC
EXTRN	_NetActivateOI@28:PROC
EXTRN	_NetCommitOI@28:PROC
EXTRN	_NetStatus@8:PROC
EXTRN	_SysAssignDecimalFromNull@4:PROC
EXTRN	_SysCompareDecimalToDecimal@8:PROC
EXTRN	_MiGetViewEntityForView@8:PROC
EXTRN	_SysAllocMemory@20:PROC
EXTRN	_SysAppendcDirSep@4:PROC
EXTRN	_fnSysCloseFile@12:PROC
EXTRN	_SysCloseFileWithControl@16:PROC
EXTRN	_SysConvertEnvironmentString@8:PROC
EXTRN	_SysDiagnosticMessage@16:PROC
EXTRN	_SysFree@4:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysGetDateTime@4:PROC
EXTRN	_SysGetProc@8:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysGetTickCount@0:PROC
EXTRN	_SysGetUserID@12:PROC
EXTRN	_SysLoadLibrary@8:PROC
EXTRN	_SysMalloc@4:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysOpenFile@12:PROC
EXTRN	_SysParseLine@12:PROC
EXTRN	_SysReadLine@12:PROC
EXTRN	_SysReadLineLth@16:PROC
EXTRN	_SysTranslateString@8:PROC
EXTRN	_SysWait@4:PROC
EXTRN	_SysWriteLine@12:PROC
EXTRN	_SysWriteLineLth@20:PROC
EXTRN	_GetAddrForAttribute@16:PROC
EXTRN	_StoreValueInRecord@20:PROC
EXTRN	_GetValueFromRecord@24:PROC
EXTRN	_GetStringFromRecord@20:PROC
EXTRN	_ConvertDecimalToString@52:PROC
EXTRN	_ActivateViewObject@12:PROC
EXTRN	_UfDateTimeToString@12:PROC
EXTRN	_UfStringToDateTime@8:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnGetAttribFlagsPtr@8:PROC
EXTRN	_fnSetAttributeFromString:PROC
EXTRN	_fnSetAttributeFromInteger:PROC
EXTRN	_fnGetAttrAddrFromEntityInstance:PROC
EXTRN	_fnStoreValueInEntityInstance:PROC
EXTRN	_fnGetStringFromAttribute:PROC
EXTRN	_fnGetIntegerFromAttribute:PROC
EXTRN	_fnSetAttributeFromBlob:PROC
EXTRN	_fnGetAddrForAttribute:PROC
EXTRN	_fnGetAttributeLength:PROC
EXTRN	_fnCreateAttributeRecord:PROC
EXTRN	_fnCopyAttributeRecord:PROC
EXTRN	_fnDeleteAttributeRecord:PROC
EXTRN	_fnSetAttributeFromVariable:PROC
EXTRN	_fnGetVariableFromAttribute:PROC
EXTRN	_fnCompareDateTimeToDateTime:PROC
EXTRN	_fnAttributeValueNull:PROC
EXTRN	_fnGetAttribOper:PROC
EXTRN	_fnSetUpdateIndicator:PROC
EXTRN	_fnSetEntityCursor:PROC
EXTRN	_fnValidateCursorParameters:PROC
EXTRN	_fnResetCursorForViewChildren:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnEntityInstanceIsDead@4:PROC
EXTRN	_fnSetEntityKey@12:PROC
EXTRN	_fnCreateEntity@20:PROC
EXTRN	_fnEstablishViewForInstance:PROC
EXTRN	_fnIncludeSubobjectFromSubobject:PROC
EXTRN	_fnReclaimHiddenInstances@4:PROC
EXTRN	_fnInstanceLinkedToInstance:PROC
EXTRN	_fnInstanceKeysMatch:PROC
EXTRN	_fnRelinkInstanceToInstance:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnDisplayEntityInstance:PROC
EXTRN	_fnCompareOI_ToOI:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidView:PROC
EXTRN	_fnValidViewObject:PROC
EXTRN	_fnValidViewCsr:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnValidViewAttrib:PROC
EXTRN	_fnAddEntityToDebugChange@4:PROC
EXTRN	_fnRemoveEntityFromDebugChange@4:PROC
EXTRN	_fnDeclareView@20:PROC
EXTRN	_fnSetViewFromView:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	_fnSetViewToSubobject:PROC
EXTRN	_fnResetView:PROC
EXTRN	_fnResetViewFromSubobject:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__isspace:PROC
EXTRN	__imp__toupper:PROC
EXTRN	_fnCreateEntityCsrHandle@12:PROC
EXTRN	_fnFindLastEntityUnderParent@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_szlReleaseCompatible:DWORD
EXTRN	_szlReleaseCurrent:DWORD
EXTRN	_cDirSep:BYTE
EXTRN	_lNullInteger:DWORD
EXTRN	_stNullDateTime:FWORD
EXTRN	_szlNewPortableHeader:DWORD
EXTRN	_szlmZeidon:DWORD
EXTRN	_szlEntityName:DWORD
EXTRN	_szlEntitySpec:DWORD
EXTRN	_szlOper:DWORD
EXTRN	_szlQualAttrib:DWORD
EXTRN	_szlOE_SystemError:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_vaList$ = -76						; size = 4
_lpViewEntity$1 = -72					; size = 4
_lpViewOD$ = -68					; size = 4
tv87 = -64						; size = 4
_vQual$ = -60						; size = 4
_nRC$ = -56						; size = 2
_nExpecting$ = -52					; size = 2
_k$2 = -48						; size = 2
_pch$ = -44						; size = 4
_szActivateView$ = -40					; size = 33
__$ArrayPad$ = -4					; size = 4
_pvReturnView$ = 8					; size = 4
_pchOD_Name$ = 12					; size = 4
_vSubtask$ = 16						; size = 4
_pchCommand$ = 20					; size = 4
_lControl$ = 24						; size = 4
_CreateQualFromCommand PROC

; 14106: {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 14107:    va_list     vaList;
; 14108:    LPVIEWOD    lpViewOD;
; 14109:    zVIEW       vQual = 0;

	mov	DWORD PTR _vQual$[ebp], 0

; 14110:    zPCHAR      pch;
; 14111:    zCHAR       szActivateView[ zZEIDON_NAME_LTH + 1 ];
; 14112:    zSHORT      nExpecting = ACTIVATE;

	mov	eax, 1
	mov	WORD PTR _nExpecting$[ebp], ax

; 14113:    zSHORT      nRC = zCALL_ERROR;  // We'll assume an error.

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 14114: 
; 14115:    va_start( vaList, lControl );

	lea	edx, DWORD PTR _lControl$[ebp+4]
	mov	DWORD PTR _vaList$[ebp], edx

; 14116: 
; 14117:    lpViewOD = ActivateViewObject( vSubtask, pchOD_Name, FALSE );

	push	0
	mov	eax, DWORD PTR _pchOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 14118:    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN9@CreateQual

; 14119:       goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN9@CreateQual:

; 14120: 
; 14121:    // Create an empty qualification.
; 14122:    if ( SfActivateSysEmptyOI( &vQual, "KZDBHQUA", vSubtask, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	OFFSET $SG18326
	lea	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SfActivateSysEmptyOI@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN10@CreateQual

; 14123:       goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN10@CreateQual:

; 14124: 
; 14125:    pch = pchCommand;

	mov	edx, DWORD PTR _pchCommand$[ebp]
	mov	DWORD PTR _pch$[ebp], edx
$LN2@CreateQual:

; 14126:    while ( *pch )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@CreateQual

; 14127:    {
; 14128:       // skip blanks.
; 14129:       if ( zisspace( *pch ) )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN11@CreateQual

; 14130:       {
; 14131:          pch++;

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx

; 14132:          continue;

	jmp	SHORT $LN2@CreateQual
$LN11@CreateQual:

; 14133:       }
; 14134: 
; 14135:       switch ( ztoupper( *pch ) )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	DWORD PTR tv87[ebp], eax
	cmp	DWORD PTR tv87[ebp], 65			; 00000041H
	je	SHORT $LN12@CreateQual
	cmp	DWORD PTR tv87[ebp], 87			; 00000057H
	je	$LN17@CreateQual
	jmp	$LN4@CreateQual
$LN12@CreateQual:

; 14136:       {
; 14137:          case 'A':
; 14138:             if ( zstrncmpi( pch, "ACTIVATE ", 9 ) == 0 )

	push	9
	push	OFFSET $SG18331
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN13@CreateQual

; 14139:             {
; 14140:                zSHORT       k;
; 14141:                LPVIEWENTITY lpViewEntity;
; 14142: 
; 14143:                if ( nExpecting != ACTIVATE )

	movsx	edx, WORD PTR _nExpecting$[ebp]
	cmp	edx, 1
	je	SHORT $LN15@CreateQual

; 14144:                {
; 14145:                   fnQualError( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_fnQualError@8

; 14146:                   goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN15@CreateQual:

; 14147:                }
; 14148: 
; 14149:                // Skip over activate text.
; 14150:                pch += 9;

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 9
	mov	DWORD PTR _pch$[ebp], ecx

; 14151: 
; 14152:                // Get activate view name.
; 14153:                for ( k = 0; !zisspace( *pch ) && *pch != 0 ; pch++, k++ )

	xor	edx, edx
	mov	WORD PTR _k$2[ebp], dx
	jmp	SHORT $LN8@CreateQual
$LN6@CreateQual:
	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
	mov	cx, WORD PTR _k$2[ebp]
	add	cx, 1
	mov	WORD PTR _k$2[ebp], cx
$LN8@CreateQual:
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN7@CreateQual
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN7@CreateQual

; 14154:                {
; 14155:                   if ( k > zZEIDON_NAME_LTH )

	movsx	eax, WORD PTR _k$2[ebp]
	cmp	eax, 32					; 00000020H
	jle	SHORT $LN16@CreateQual

; 14156:                   {
; 14157:                      fnQualError( pch, 0 );

	push	0
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_fnQualError@8

; 14158:                      goto EndOfFunction;

	jmp	$EndOfFunction$25
$LN16@CreateQual:

; 14159:                   }
; 14160: 
; 14161:                   szActivateView[ k ] = *pch;

	movsx	edx, WORD PTR _k$2[ebp]
	mov	eax, DWORD PTR _pch$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szActivateView$[ebp+edx], cl

; 14162:                }

	jmp	SHORT $LN6@CreateQual
$LN7@CreateQual:

; 14163: 
; 14164:                lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 14165:                CreateEntity( vQual, "EntitySpec", zPOS_NEXT );

	push	3
	push	OFFSET $SG18334
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_CreateEntity@12

; 14166:                SetAttributeFromString( vQual, "EntitySpec", "EntityName",

	mov	edx, DWORD PTR _lpViewEntity$1[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG18335
	push	OFFSET $SG18336
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 14167:                                        lpViewEntity->szName );
; 14168: 
; 14169:                nExpecting = WHERE;

	mov	ecx, 2
	mov	WORD PTR _nExpecting$[ebp], cx

; 14170:             }

	jmp	SHORT $LN14@CreateQual
$LN13@CreateQual:

; 14171:             else
; 14172:             {
; 14173:                fnQualError( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_fnQualError@8

; 14174:                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$25
$LN14@CreateQual:

; 14175:             }
; 14176: 
; 14177:             break;

	jmp	SHORT $LN4@CreateQual
$LN17@CreateQual:

; 14178: 
; 14179:          case 'W':
; 14180:             if ( zstrncmpi( pch, "WHERE ", 6 ) == 0 )

	push	6
	push	OFFSET $SG18340
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN18@CreateQual

; 14181:             {
; 14182:                if ( nExpecting != WHERE )

	movsx	ecx, WORD PTR _nExpecting$[ebp]
	cmp	ecx, 2
	je	SHORT $LN20@CreateQual

; 14183:                {
; 14184:                   fnQualError( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_fnQualError@8

; 14185:                   goto EndOfFunction;

	jmp	SHORT $EndOfFunction$25
$LN20@CreateQual:

; 14186:                }
; 14187: 
; 14188:                // Skip over where text.
; 14189:                pch += 6;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 6
	mov	DWORD PTR _pch$[ebp], eax

; 14190: 
; 14191:                nExpecting = QUAL;

	mov	ecx, 3
	mov	WORD PTR _nExpecting$[ebp], cx

; 14192:             }

	jmp	SHORT $LN4@CreateQual
$LN18@CreateQual:

; 14193:             else
; 14194:             {
; 14195:                fnQualError( pch, 0 );

	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_fnQualError@8

; 14196:                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$25
$LN4@CreateQual:

; 14197:             }
; 14198: 
; 14199:             break;
; 14200: 
; 14201:       } // switch ( ztoupper( *pch ) )...
; 14202: 
; 14203:    } // while ( *pch )...

	jmp	$LN2@CreateQual
$LN3@CreateQual:

; 14204: 
; 14205:    // If we get here then everything's good.
; 14206:    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$25:

; 14207: 
; 14208: EndOfFunction:
; 14209:    va_end( vaList );

	mov	DWORD PTR _vaList$[ebp], 0

; 14210: 
; 14211:    // We need to clean up a little more if we have an error.
; 14212:    if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN21@CreateQual

; 14213:    {
; 14214:       if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $LN21@CreateQual

; 14215:          DropObjectInstance( vQual );

	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_DropObjectInstance@4
$LN21@CreateQual:

; 14216:    }
; 14217: 
; 14218:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 14219: }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateQualFromCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchCommand$ = 8					; size = 4
_nErrorNbr$ = 12					; size = 2
_fnQualError@8 PROC

; 14075: {

	push	ebp
	mov	ebp, esp

; 14076:    TraceLineS( "Error occurs after: ", pchCommand );

	mov	eax, DWORD PTR _pchCommand$[ebp]
	push	eax
	push	OFFSET $SG18285
	call	_TraceLineS@8

; 14077:    SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG18286
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 14078:                   "Error parsing command.  See trace for more.", 1 );
; 14079: }

	pop	ebp
	ret	8
_fnQualError@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpTask$1 = -12						; size = 4
_lpViewAttrib$ = -8					; size = 4
_nSeq$2 = -4						; size = 2
_lpView$ = 8						; size = 4
_plAttribCnt$ = 12					; size = 4
_lpAttribList$ = 16					; size = 4
_lpViewEntity$ = 20					; size = 4
_fnGetSortAttrsFromEntity@16 PROC

; 13476: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 13477:    LPVIEWATTRIB lpViewAttrib;
; 13478: 
; 13479:    // Loop through all the view attribs looking for default sorting attribs.
; 13480:    // When one is found, add it to the attrib list.
; 13481:    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnGetSortA
$LN2@fnGetSortA:

; 13483:          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnGetSortA:

; 13482:          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnGetSortA

; 13484:    {
; 13485:       if ( lpViewAttrib->bAutoSeq )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN5@fnGetSortA

; 13486:       {
; 13487:          *plAttribCnt = 1;

	mov	eax, DWORD PTR _plAttribCnt$[ebp]
	mov	DWORD PTR [eax], 1

; 13488:          lpAttribList[ 0 ].lpViewAttrib = lpViewAttrib;

	mov	ecx, 13					; 0000000dH
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpAttribList$[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [eax+edx], ecx

; 13489:          lpAttribList[ 0 ].bOrder = FALSE;

	mov	edx, 13					; 0000000dH
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	BYTE PTR [ecx+eax+8], 0

; 13490: 
; 13491:          // Make sure next attrib is 0.
; 13492:          lpAttribList[ 1 ].lpViewAttrib = 0;

	mov	edx, 13					; 0000000dH
	shl	edx, 0
	mov	eax, DWORD PTR _lpAttribList$[ebp]
	mov	DWORD PTR [eax+edx], 0

; 13493: 
; 13494:          return( 1 ); // There is only 1 autoseq attr per entity, so return.

	mov	eax, 1
	jmp	$LN1@fnGetSortA

; 13495:       }

	jmp	$LN6@fnGetSortA
$LN5@fnGetSortA:

; 13496:       else
; 13497:       if ( lpViewAttrib->cSequencing > 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	edx, BYTE PTR [ecx+197]
	test	edx, edx
	jle	$LN6@fnGetSortA

; 13498:       {
; 13499:          zSHORT nSeq;
; 13500: 
; 13501:          nSeq = lpViewAttrib->cSequencing;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movzx	cx, BYTE PTR [eax+197]
	mov	WORD PTR _nSeq$2[ebp], cx

; 13502:          if ( nSeq >= MAX_SEQ_ATTS )

	movsx	edx, WORD PTR _nSeq$2[ebp]
	cmp	edx, 20					; 00000014H
	jl	SHORT $LN8@fnGetSortA

; 13503:          {
; 13504:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 13505:             // "KZOEE013 - Internal operation call error"
; 13506:             TraceLineS( "KZOEE013 - Internal operation call error: ",

	push	OFFSET $SG18061
	push	OFFSET $SG18062
	call	_TraceLineS@8

; 13507:                         "Maximum # of order attributes used" );
; 13508:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,

	push	OFFSET $SG18063
	push	OFFSET $SG18064
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13509:                               "Maximum # of order attributes used",
; 13510:                               "fnOrderOI_ByDefaultAttribs" );
; 13511:             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnGetSortA
$LN8@fnGetSortA:

; 13512:          }
; 13513: 
; 13514:          if ( *plAttribCnt < nSeq )

	movsx	ecx, WORD PTR _nSeq$2[ebp]
	mov	edx, DWORD PTR _plAttribCnt$[ebp]
	cmp	DWORD PTR [edx], ecx
	jge	SHORT $LN9@fnGetSortA

; 13515:             *plAttribCnt = nSeq;

	movsx	eax, WORD PTR _nSeq$2[ebp]
	mov	ecx, DWORD PTR _plAttribCnt$[ebp]
	mov	DWORD PTR [ecx], eax
$LN9@fnGetSortA:

; 13516: 
; 13517:          lpAttribList[ nSeq - 1 ].lpViewAttrib = lpViewAttrib;

	movsx	edx, WORD PTR _nSeq$2[ebp]
	sub	edx, 1
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 13518:          if ( lpViewAttrib->bSequencingD )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN6@fnGetSortA

; 13519:             lpAttribList[ nSeq - 1 ].bOrder = TRUE;

	movsx	edx, WORD PTR _nSeq$2[ebp]
	sub	edx, 1
	imul	eax, edx, 13
	mov	ecx, DWORD PTR _lpAttribList$[ebp]
	mov	BYTE PTR [ecx+eax+8], 1
$LN6@fnGetSortA:

; 13520:       }
; 13521:    } // for ( lpViewAttrib )...

	jmp	$LN2@fnGetSortA
$LN3@fnGetSortA:

; 13522: 
; 13523:    return( 0 );

	xor	eax, eax
$LN1@fnGetSortA:

; 13524: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnGetSortAttrsFromEntity@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_SortData$ = -116					; size = 16
_lpViewEntityCsr$1 = -100				; size = 4
_lpNextHier$2 = -96					; size = 4
_lpPrevHier$3 = -92					; size = 4
_lpViewOI$4 = -88					; size = 4
_lpViewCsr$5 = -84					; size = 4
_lpViewEntity$6 = -80					; size = 4
_lpViewAttrib$7 = -76					; size = 4
_lpLastOldChild$ = -72					; size = 4
_lpCurrentTask$ = -68					; size = 4
_hViewEntity$8 = -64					; size = 4
_ulBack$ = -60						; size = 4
_hEIBuffer$ = -56					; size = 4
_lpLastEntityInstance$ = -52				; size = 4
_lpLastChild$ = -48					; size = 4
_ulFront$ = -44						; size = 4
_lpView$9 = -40						; size = 4
_lpSearch$10 = -36					; size = 4
_lpFirstEntityInstance$ = -32				; size = 4
_ulEntityCnt$ = -28					; size = 4
_lpViewAttrListPtr$ = -24				; size = 4
_k$ = -20						; size = 4
_lpEI1$ = -16						; size = 4
_lpEIBuffer$ = -12					; size = 4
_nRC$ = -8						; size = 2
_bDerivedAttribPresent$ = -1				; size = 1
_zView$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_lpViewAttrList$ = 16					; size = 4
_bUseBubbleSort$ = 20					; size = 1
_fnOrderEntityForView@16 PROC

; 12931: {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 12932:    SortDataRecord    SortData;
; 12933:    LPVIEWATTRLIST    lpViewAttrListPtr;
; 12934:    LPENTITYINSTANCE  lpEI1;
; 12935:    LPENTITYINSTANCE  lpLastChild;
; 12936:    LPENTITYINSTANCE  lpLastOldChild;
; 12937:    LPENTITYINSTANCE  *lpEIBuffer;
; 12938:    LPENTITYINSTANCE  lpFirstEntityInstance;
; 12939:    LPENTITYINSTANCE  lpLastEntityInstance;
; 12940:    zULONG            ulEntityCnt;
; 12941:    zULONG            ulFront, ulBack, k;
; 12942:    zLONG             hEIBuffer;
; 12943:    zBOOL             bDerivedAttribPresent = FALSE;

	mov	BYTE PTR _bDerivedAttribPresent$[ebp], 0

; 12944:    zSHORT            nRC;
; 12945: 
; 12946:    // Only used with derived attributes ...
; 12947:    LPTASK            lpCurrentTask;
; 12948: 
; 12949:    // If instance is null, there is nothing to sort ...
; 12950:    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN26@fnOrderEnt

; 12951:       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOrderEnt
$LN26@fnOrderEnt:

; 12952: 
; 12953:    // Error if trying to sort "unset".
; 12954:    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN27@fnOrderEnt

; 12955:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOrderEnt
$LN27@fnOrderEnt:

; 12956: 
; 12957:    lpCurrentTask = zGETPTR( zView->hTask );

	mov	eax, DWORD PTR _zView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 12958: // lpCurrentTask = fnFindTask( 0 );  // dks 2006.04.05  back to 10b
; 12959: 
; 12960:    // Scan through the view attributes for any derived attributes.
; 12961:    for ( lpViewAttrListPtr = lpViewAttrList;

	mov	edx, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx
	jmp	SHORT $LN4@fnOrderEnt
$LN2@fnOrderEnt:

; 12963:          lpViewAttrListPtr++ )

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	eax, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax
$LN4@fnOrderEnt:

; 12962:          lpViewAttrListPtr->lpViewAttrib;

	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@fnOrderEnt

; 12964:    {
; 12965:       LPVIEWATTRIB lpViewAttrib = lpViewAttrListPtr->lpViewAttrib;

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpViewAttrib$7[ebp], eax

; 12966: 
; 12967:       if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$7[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN28@fnOrderEnt

; 12968:       {
; 12969:          bDerivedAttribPresent = TRUE;

	mov	BYTE PTR _bDerivedAttribPresent$[ebp], 1

; 12970:          lpViewAttrListPtr->pfObjectOper =

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	call	_fnGetAttribOper
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN28@fnOrderEnt:

; 12971:                        fnGetAttribOper( zView, lpViewAttrib, lpCurrentTask );
; 12972:       }
; 12973:    }

	jmp	SHORT $LN2@fnOrderEnt
$LN3@fnOrderEnt:

; 12974: 
; 12975:    // Count the number of entities after lpEntityInstance.
; 12976:    ulEntityCnt = 1; // account for the current lpEntityInstance

	mov	DWORD PTR _ulEntityCnt$[ebp], 1

; 12977:    for ( lpLastEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLastEntityInstance$[ebp], eax
	jmp	SHORT $LN7@fnOrderEnt
$LN5@fnOrderEnt:

; 12979:          lpLastEntityInstance = zGETPTR( lpLastEntityInstance->hNextTwin ) )

	mov	ecx, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastEntityInstance$[ebp], eax
$LN7@fnOrderEnt:

; 12978:          lpLastEntityInstance->hNextTwin;

	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN6@fnOrderEnt

; 12980:    {
; 12981:       ulEntityCnt++;

	mov	ecx, DWORD PTR _ulEntityCnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], ecx

; 12982:    }

	jmp	SHORT $LN5@fnOrderEnt
$LN6@fnOrderEnt:

; 12983: 
; 12984:    // Add the number of entities prior to lpEntityInstance.
; 12985:    for ( lpFirstEntityInstance = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpFirstEntityInstance$[ebp], edx
	jmp	SHORT $LN10@fnOrderEnt
$LN8@fnOrderEnt:

; 12987:          lpFirstEntityInstance = zGETPTR( lpFirstEntityInstance->hPrevTwin ) )

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstEntityInstance$[ebp], eax
$LN10@fnOrderEnt:

; 12986:          lpFirstEntityInstance->hPrevTwin;

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN9@fnOrderEnt

; 12988:    {
; 12989:       ulEntityCnt++;

	mov	eax, DWORD PTR _ulEntityCnt$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], eax

; 12990:    }

	jmp	SHORT $LN8@fnOrderEnt
$LN9@fnOrderEnt:

; 12991: 
; 12992:    // If we only have 1 entity then there's nothing to sort.
; 12993:    if ( ulEntityCnt == 1 )

	cmp	DWORD PTR _ulEntityCnt$[ebp], 1
	jne	SHORT $LN29@fnOrderEnt

; 12994:       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOrderEnt
$LN29@fnOrderEnt:

; 12995: 
; 12996:    // Now allocate space to hold all the entity instances.
; 12997:    hEIBuffer = SysAllocMemory( (zCOREMEM) &lpEIBuffer,

	push	0
	push	32768					; 00008000H
	push	0
	mov	ecx, DWORD PTR _ulEntityCnt$[ebp]
	shl	ecx, 2
	push	ecx
	lea	edx, DWORD PTR _lpEIBuffer$[ebp]
	push	edx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hEIBuffer$[ebp], eax

; 12998:                                sizeof( LPENTITYINSTANCE ) * ulEntityCnt,
; 12999:                                0, zCOREMEM_ALLOC, 0 );
; 13000: 
; 13001:    // Copy the list of entity pointers into the buffer.  We'll put all the
; 13002:    // hidden instances at the end because we don't need/want to sort them.
; 13003:    ulFront = 0;

	mov	DWORD PTR _ulFront$[ebp], 0

; 13004:    ulBack  = ulEntityCnt - 1;

	mov	eax, DWORD PTR _ulEntityCnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ulBack$[ebp], eax

; 13005:    for ( lpEI1 = lpFirstEntityInstance;

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEI1$[ebp], ecx
	jmp	SHORT $LN13@fnOrderEnt
$LN11@fnOrderEnt:

; 13007:          lpEI1 = zGETPTR( lpEI1->hNextTwin ) )

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$LN13@fnOrderEnt:

; 13006:          lpEI1;

	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	SHORT $LN12@fnOrderEnt

; 13008:    {
; 13009:       if ( lpEI1->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN30@fnOrderEnt

; 13010:          lpEIBuffer[ ulBack-- ] = lpEI1;  // put hidden EI at the end

	mov	eax, DWORD PTR _ulBack$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
	mov	eax, DWORD PTR _ulBack$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ulBack$[ebp], eax
	jmp	SHORT $LN31@fnOrderEnt
$LN30@fnOrderEnt:

; 13011:       else
; 13012:          lpEIBuffer[ ulFront++ ] = lpEI1;

	mov	ecx, DWORD PTR _ulFront$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
	mov	ecx, DWORD PTR _ulFront$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ulFront$[ebp], ecx
$LN31@fnOrderEnt:

; 13013:    }

	jmp	SHORT $LN11@fnOrderEnt
$LN12@fnOrderEnt:

; 13014: 
; 13015:    // ulFront is a count of all the non-hidden EIs.  If there's only one EI
; 13016:    // then don't bother sorting.
; 13017:    if ( ulFront <= 1 )

	cmp	DWORD PTR _ulFront$[ebp], 1
	ja	SHORT $LN32@fnOrderEnt

; 13018:    {
; 13019:       SysFreeMemory( hEIBuffer );

	mov	edx, DWORD PTR _hEIBuffer$[ebp]
	push	edx
	call	_SysFreeMemory@4

; 13020:       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOrderEnt
$LN32@fnOrderEnt:

; 13021:    }
; 13022: 
; 13023:    // If any derived attributes in the order keys, go set them for all of
; 13024:    // the entities now.
; 13025:    if ( bDerivedAttribPresent )

	movzx	eax, BYTE PTR _bDerivedAttribPresent$[ebp]
	test	eax, eax
	je	$LN33@fnOrderEnt

; 13026:    {
; 13027:       zVIEW lpView;
; 13028: 
; 13029:       if ( (nRC = fnDeclareView( &lpView, lpCurrentTask, zView, 0, 0 )) != 0 )

	push	0
	push	0
	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpView$9[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN34@fnOrderEnt

; 13030:       {
; 13031:          SysFreeMemory( hEIBuffer );

	mov	edx, DWORD PTR _hEIBuffer$[ebp]
	push	edx
	call	_SysFreeMemory@4

; 13032:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnOrderEnt
$LN34@fnOrderEnt:

; 13033:       }
; 13034: 
; 13035:       fnSetViewFromView( lpView, zView );

	mov	eax, DWORD PTR _zView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$9[ebp]
	push	ecx
	call	_fnSetViewFromView
	add	esp, 8

; 13036:       for ( lpEI1 = lpFirstEntityInstance;

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEI1$[ebp], edx
	jmp	SHORT $LN16@fnOrderEnt
$LN14@fnOrderEnt:

; 13038:             lpEI1 = zGETPTR( lpEI1->hNextTwin ) )

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$LN16@fnOrderEnt:

; 13037:             lpEI1;

	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	$LN15@fnOrderEnt

; 13039:       {
; 13040:          LPVIEWENTITYCSR   lpViewEntityCsr;
; 13041: 
; 13042:          if ( lpEI1->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN35@fnOrderEnt

; 13043:             continue;

	jmp	SHORT $LN14@fnOrderEnt
$LN35@fnOrderEnt:

; 13044: 
; 13045:          lpViewEntityCsr = fnEstablishViewForInstance( lpView, 0, lpEI1 );

	mov	ecx, DWORD PTR _lpEI1$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$9[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$1[ebp], eax

; 13046: 
; 13047:          // Set all of the derived attributes (that are used as sort keys)
; 13048:          // for the entity instance.
; 13049:          for ( lpViewAttrListPtr = lpViewAttrList;

	mov	eax, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax
	jmp	SHORT $LN19@fnOrderEnt
$LN17@fnOrderEnt:

; 13051:                lpViewAttrListPtr++ )

	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	ecx, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], ecx
$LN19@fnOrderEnt:

; 13050:                lpViewAttrListPtr->lpViewAttrib;

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN18@fnOrderEnt

; 13052:          {
; 13053:             LPVIEWENTITY hViewEntity;
; 13054:             LPVIEWENTITY lpViewEntity;
; 13055: 
; 13056:             if ( lpViewAttrListPtr->pfObjectOper == 0 )

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN36@fnOrderEnt

; 13057:                continue;

	jmp	SHORT $LN17@fnOrderEnt
$LN36@fnOrderEnt:

; 13058: 
; 13059:             // If the view entity for the sorting attribute is different
; 13060:             // from the view entity for the EI we're sorting then the attr
; 13061:             // must be from a child entity.  Make sure a child EI exists
; 13062:             // before we call the derived operation.
; 13063:             hViewEntity = lpViewAttrListPtr->lpViewAttrib->hViewEntity;

	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR _hViewEntity$8[ebp], eax

; 13064:             if ( hViewEntity != lpEI1->hViewEntity )

	mov	ecx, DWORD PTR _lpEI1$[ebp]
	mov	edx, DWORD PTR _hViewEntity$8[ebp]
	cmp	edx, DWORD PTR [ecx+2]
	je	SHORT $LN37@fnOrderEnt

; 13065:             {
; 13066:                LPENTITYINSTANCE lpSearch;
; 13067: 
; 13068:                for ( lpSearch = zGETPTR( lpEI1->hNextHier );

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$10[ebp], eax
	jmp	SHORT $LN22@fnOrderEnt
$LN20@fnOrderEnt:

; 13070:                      lpSearch = zGETPTR( lpSearch->hNextHier ) )

	mov	edx, DWORD PTR _lpSearch$10[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$10[ebp], eax
$LN22@fnOrderEnt:

; 13069:                      lpSearch;

	cmp	DWORD PTR _lpSearch$10[ebp], 0
	je	SHORT $LN21@fnOrderEnt

; 13071:                {
; 13072:                   if ( lpSearch->nLevel <= lpEI1->nLevel )

	mov	ecx, DWORD PTR _lpSearch$10[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $LN38@fnOrderEnt

; 13073:                   {
; 13074:                      lpSearch = 0;

	mov	DWORD PTR _lpSearch$10[ebp], 0

; 13075:                      break;

	jmp	SHORT $LN21@fnOrderEnt
$LN38@fnOrderEnt:

; 13076:                   }
; 13077: 
; 13078:                   if ( lpSearch->hViewEntity == hViewEntity )

	mov	edx, DWORD PTR _lpSearch$10[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hViewEntity$8[ebp]
	jne	SHORT $LN39@fnOrderEnt

; 13079:                      break;

	jmp	SHORT $LN21@fnOrderEnt
$LN39@fnOrderEnt:

; 13080:                }

	jmp	SHORT $LN20@fnOrderEnt
$LN21@fnOrderEnt:

; 13081: 
; 13082:                // If lpSearch is 0 then we didn't find a child EI matching
; 13083:                // hViewEntity so don't call the derived operation.
; 13084:                if ( lpSearch == 0 )

	cmp	DWORD PTR _lpSearch$10[ebp], 0
	jne	SHORT $LN40@fnOrderEnt

; 13085:                   continue;

	jmp	$LN17@fnOrderEnt
	jmp	SHORT $LN37@fnOrderEnt
$LN40@fnOrderEnt:

; 13086:                else
; 13087:                {
; 13088:                   // Establish cursor position for the child entity. (dks and DonC 2009.12.23)
; 13089:                   fnEstablishViewForInstance( lpView, 0, lpSearch );

	mov	ecx, DWORD PTR _lpSearch$10[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$9[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
$LN37@fnOrderEnt:

; 13090:                }
; 13091:             }
; 13092: 
; 13093:             lpViewEntity = zGETPTR( hViewEntity );

	mov	eax, DWORD PTR _hViewEntity$8[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$6[ebp], eax

; 13094: 
; 13095:             nRC = (*lpViewAttrListPtr->pfObjectOper)( lpView, lpViewEntity,

	push	2
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	WORD PTR _nRC$[ebp], ax

; 13096:                                                       lpViewAttrListPtr->lpViewAttrib,
; 13097:                                                       zDERIVED_GET );
; 13098:             if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN42@fnOrderEnt

; 13099:             {
; 13100:                SysFreeMemory( hEIBuffer );

	mov	edx, DWORD PTR _hEIBuffer$[ebp]
	push	edx
	call	_SysFreeMemory@4

; 13101:                fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$9[ebp]
	push	eax
	call	_fnDropView@4

; 13102:                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnOrderEnt
$LN42@fnOrderEnt:

; 13103:             }
; 13104:          }

	jmp	$LN17@fnOrderEnt
$LN18@fnOrderEnt:

; 13105: 
; 13106:       } // for each lpEI1...

	jmp	$LN14@fnOrderEnt
$LN15@fnOrderEnt:

; 13107: 
; 13108:       fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$9[ebp]
	push	ecx
	call	_fnDropView@4
$LN33@fnOrderEnt:

; 13109: 
; 13110:    } // if ( bDerivedAttribPresent )...
; 13111: 
; 13112:    // Set up information for sorting.
; 13113:    SortData.lpViewAttrList = lpViewAttrList;

	mov	edx, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _SortData$[ebp+4], edx

; 13114:    SortData.lpCurrentTask  = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _SortData$[ebp], eax

; 13115:    CreateViewFromViewForTask( &SortData.lpView1, zView, zView );

	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	lea	eax, DWORD PTR _SortData$[ebp+8]
	push	eax
	call	_CreateViewFromViewForTask@12

; 13116:    CreateViewFromViewForTask( &SortData.lpView2, zView, zView );

	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	lea	eax, DWORD PTR _SortData$[ebp+12]
	push	eax
	call	_CreateViewFromViewForTask@12

; 13117: 
; 13118:    // Call operation to sort the entity list.  We use ulFront instead of
; 13119:    // ulEntityCnt because we only want to sort the non-hidden EIs.
; 13120:    if ( bUseBubbleSort )

	movzx	ecx, BYTE PTR _bUseBubbleSort$[ebp]
	test	ecx, ecx
	je	SHORT $LN43@fnOrderEnt

; 13121:       fnBubbleSort( &SortData, lpEIBuffer, ulFront );

	mov	edx, DWORD PTR _ulFront$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SortData$[ebp]
	push	ecx
	call	_fnBubbleSort
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN44@fnOrderEnt
$LN43@fnOrderEnt:

; 13122:    else
; 13123:       fnQuickSort( &SortData, lpEIBuffer, ulFront );

	mov	edx, DWORD PTR _ulFront$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SortData$[ebp]
	push	ecx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH
$LN44@fnOrderEnt:

; 13124:    // fnHeapSort( &SortData, lpEIBuffer, ulFront );  // does not work (yet)!
; 13125: 
; 13126:    fnDropView( SortData.lpView1 );

	mov	edx, DWORD PTR _SortData$[ebp+8]
	push	edx
	call	_fnDropView@4

; 13127:    fnDropView( SortData.lpView2 );

	mov	eax, DWORD PTR _SortData$[ebp+12]
	push	eax
	call	_fnDropView@4

; 13128: 
; 13129:    // Subtract 1 from ulEntityCnt so it points to the last EI.  This will
; 13130:    // save us a little time later on.
; 13131:    ulEntityCnt--;

	mov	ecx, DWORD PTR _ulEntityCnt$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ulEntityCnt$[ebp], ecx

; 13132: 
; 13133:    //---------------------------------------------------------------------
; 13134:    // Re-arrange the EI pointers.
; 13135:    //---------------------------------------------------------------------
; 13136: 
; 13137:    // If we sorted the root instances then set the root entity instance.
; 13138:    if ( lpFirstEntityInstance->nLevel == 1 )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	eax, 1
	jne	SHORT $LN45@fnOrderEnt

; 13139:    {
; 13140:       LPVIEWCSR lpViewCsr = zGETPTR( zView->hViewCsr );

	mov	ecx, DWORD PTR _zView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$5[ebp], eax

; 13141:       LPVIEWOI  lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$5[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$4[ebp], eax

; 13142: 
; 13143:       lpViewOI->hRootEntityInstance = zGETHNDL( lpEIBuffer[ 0 ] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$4[ebp]
	mov	DWORD PTR [ecx+26], eax
$LN45@fnOrderEnt:

; 13144:    }
; 13145: 
; 13146:    // Reset the EI pointer for the entity before the "old" first entity.
; 13147:    if ( lpFirstEntityInstance->hPrevHier )

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN46@fnOrderEnt

; 13148:    {
; 13149:       LPENTITYINSTANCE lpPrevHier = zGETPTR( lpFirstEntityInstance->hPrevHier );

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$3[ebp], eax

; 13150: 
; 13151:       // Change lpPrevHier to point to the "new" first entity.
; 13152:       lpPrevHier->hNextHier = zGETHNDL( lpEIBuffer[ 0 ] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevHier$3[ebp]
	mov	DWORD PTR [ecx+14], eax

; 13153: 
; 13154:       lpEIBuffer[ 0 ]->hPrevHier = lpFirstEntityInstance->hPrevHier;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	mov	DWORD PTR [edx+18], ecx

; 13155:    }

	jmp	SHORT $LN47@fnOrderEnt
$LN46@fnOrderEnt:

; 13156:    else
; 13157:       lpEIBuffer[ 0 ]->hPrevHier = 0;

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR [edx+18], 0
$LN47@fnOrderEnt:

; 13158: 
; 13159:    // Get the last child of the last old or "unsorted" entity.
; 13160:    lpLastOldChild = fnFindLastEntityUnderParent( lpLastEntityInstance, FALSE );

	push	0
	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastOldChild$[ebp], eax

; 13161: 
; 13162:    // Get the last child for the last "sorted" entity.
; 13163:    lpLastChild = fnFindLastEntityUnderParent( lpEIBuffer[ ulEntityCnt ], FALSE );

	push	0
	mov	ecx, DWORD PTR _ulEntityCnt$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastChild$[ebp], eax

; 13164: 
; 13165:    // Reset the EI pointer for the entity after the "old" last entity.
; 13166:    if ( lpLastOldChild->hNextHier )

	mov	ecx, DWORD PTR _lpLastOldChild$[ebp]
	cmp	DWORD PTR [ecx+14], 0
	je	SHORT $LN48@fnOrderEnt

; 13167:    {
; 13168:       LPENTITYINSTANCE lpNextHier = zGETPTR( lpLastOldChild->hNextHier );

	mov	edx, DWORD PTR _lpLastOldChild$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$2[ebp], eax

; 13169: 
; 13170:       lpLastChild->hNextHier = lpLastOldChild->hNextHier;

	mov	ecx, DWORD PTR _lpLastChild$[ebp]
	mov	edx, DWORD PTR _lpLastOldChild$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+14], eax

; 13171:       lpNextHier->hPrevHier = zGETHNDL( lpLastChild );

	mov	ecx, DWORD PTR _lpLastChild$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpNextHier$2[ebp]
	mov	DWORD PTR [edx+18], eax

; 13172: 
; 13173:    }

	jmp	SHORT $LN49@fnOrderEnt
$LN48@fnOrderEnt:

; 13174:    else
; 13175:       lpLastChild->hNextHier = 0;

	mov	eax, DWORD PTR _lpLastChild$[ebp]
	mov	DWORD PTR [eax+14], 0
$LN49@fnOrderEnt:

; 13176: 
; 13177:    // Now we'll loop through ALL the EIs and set the
; 13178:    // PrevHier/NextHier/PrevTwin/NextTwin pointers.
; 13179:    for ( k = 0; k <= ulEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN25@fnOrderEnt
$LN23@fnOrderEnt:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN25@fnOrderEnt:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _ulEntityCnt$[ebp]
	ja	$LN24@fnOrderEnt

; 13180:    {
; 13181:       // If 'k' is > 0 then we need to set up Prev pointers.
; 13182:       if ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $LN50@fnOrderEnt

; 13183:       {
; 13184:          lpEIBuffer[ k ]->hPrevHier = zGETHNDL( lpLastChild );

	mov	eax, DWORD PTR _lpLastChild$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+18], eax

; 13185:          lpEIBuffer[ k ]->hPrevTwin = zGETHNDL( lpEIBuffer[ k - 1 ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [edx+26], eax

; 13186:       }

	jmp	SHORT $LN51@fnOrderEnt
$LN50@fnOrderEnt:

; 13187:       else
; 13188:          lpEIBuffer[ k ]->hPrevTwin = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+26], 0
$LN51@fnOrderEnt:

; 13189: 
; 13190:       // Find the last child (hierarchically) under the current EI.
; 13191:       lpLastChild = fnFindLastEntityUnderParent( lpEIBuffer[ k ], FALSE );

	push	0
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastChild$[ebp], eax

; 13192: 
; 13193:       // If 'k' is < ulEntityCnt then we need to set up Next pointers.
; 13194:       if ( k < ulEntityCnt )

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _ulEntityCnt$[ebp]
	jae	SHORT $LN52@fnOrderEnt

; 13195:       {
; 13196:          lpEIBuffer[ k ]->hNextTwin = zGETHNDL( lpEIBuffer[ k + 1 ] );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ecx+22], eax

; 13197:          lpLastChild->hNextHier     = zGETHNDL( lpEIBuffer[ k + 1 ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEIBuffer$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpLastChild$[ebp]
	mov	DWORD PTR [edx+14], eax

; 13198:       }

	jmp	SHORT $LN53@fnOrderEnt
$LN52@fnOrderEnt:

; 13199:       else
; 13200:          lpEIBuffer[ k ]->hNextTwin = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEIBuffer$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR [edx+22], 0
$LN53@fnOrderEnt:

; 13201:    }

	jmp	$LN23@fnOrderEnt
$LN24@fnOrderEnt:

; 13202: 
; 13203:    SysFreeMemory( hEIBuffer );

	mov	eax, DWORD PTR _hEIBuffer$[ebp]
	push	eax
	call	_SysFreeMemory@4

; 13204: 
; 13205:    return( 0 );

	xor	eax, eax
$LN1@fnOrderEnt:

; 13206: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnOrderEntityForView@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_t$1 = -16						; size = 4
_k$ = -12						; size = 4
_j$ = -8						; size = 4
_bSwaps$ = -1						; size = 1
_lpSortData$ = 8					; size = 4
_lpEI$ = 12						; size = 4
_ulRecordCnt$ = 16					; size = 4
_fnBubbleSort PROC

; 12889: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 12890:    zULONG k, j;
; 12891:    zBOOL  bSwaps;
; 12892: 
; 12893:    for ( k = ulRecordCnt - 1; k > 0; k-- )

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN4@fnBubbleSo
$LN2@fnBubbleSo:
	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN4@fnBubbleSo:
	cmp	DWORD PTR _k$[ebp], 0
	jbe	$LN1@fnBubbleSo

; 12894:    {
; 12895:       bSwaps = FALSE;

	mov	BYTE PTR _bSwaps$[ebp], 0

; 12896: 
; 12897:       for ( j = 0; j < k; j++ )

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN7@fnBubbleSo
$LN5@fnBubbleSo:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN7@fnBubbleSo:
	mov	eax, DWORD PTR _j$[ebp]
	cmp	eax, DWORD PTR _k$[ebp]
	jae	SHORT $LN6@fnBubbleSo

; 12898:       {
; 12899:          // If EI[ j ] is > EI[ j + 1 ] then swap them.
; 12900:          if ( fnSortCmpr( lpSortData, lpEI[ j ], lpEI[ j + 1 ] ) )

	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+4]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN8@fnBubbleSo

; 12901:          {
; 12902:             bSwaps = TRUE;

	mov	BYTE PTR _bSwaps$[ebp], 1

; 12903:             SWAP_EI( lpEI[ j ], lpEI[ j + 1 ] );

	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	mov	DWORD PTR _t$1[ebp], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4]
	mov	DWORD PTR [ecx+eax*4+4], edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$1[ebp]
	mov	DWORD PTR [ecx+eax*4], edx
$LN8@fnBubbleSo:

; 12904:          }
; 12905:       }

	jmp	SHORT $LN5@fnBubbleSo
$LN6@fnBubbleSo:

; 12906: 
; 12907:       // If there were no swaps then everything's in order so get out.
; 12908:       if ( bSwaps == FALSE )

	movzx	eax, BYTE PTR _bSwaps$[ebp]
	test	eax, eax
	jne	SHORT $LN9@fnBubbleSo

; 12909:          break;

	jmp	SHORT $LN1@fnBubbleSo
$LN9@fnBubbleSo:

; 12910:    }

	jmp	$LN2@fnBubbleSo
$LN1@fnBubbleSo:

; 12911: 
; 12912: } // fnBubbleSort

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnBubbleSort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_t$1 = -28						; size = 4
_t$2 = -24						; size = 4
_t$3 = -20						; size = 4
_ulLeft$ = -16						; size = 4
_ulRight$ = -12						; size = 4
_k$ = -8						; size = 4
_j$ = -4						; size = 4
_lpSortData$ = 8					; size = 4
_lpEI$ = 12						; size = 4
_ulRecordCnt$ = 16					; size = 4
_fnQuickSort PROC

; 12839: {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
$LN2@fnQuickSor:

; 12840:    zULONG k, j, ulLeft, ulRight;
; 12841: 
; 12842:    while ( ulRecordCnt > 1 )

	cmp	DWORD PTR _ulRecordCnt$[ebp], 1
	jbe	$LN1@fnQuickSor

; 12843:    {
; 12844:       SWAP_EI( lpEI[ 0 ], lpEI[ ulRecordCnt / 2 ] );

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _t$3[ebp], edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	shr	edx, 1
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [esi+ecx]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$3[ebp]
	mov	DWORD PTR [ecx+eax], edx

; 12845: 
; 12846:       for ( k = 0, j = ulRecordCnt; ; )

	mov	DWORD PTR _k$[ebp], 0
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	mov	DWORD PTR _j$[ebp], eax
$LN9@fnQuickSor:

; 12847:       {
; 12848:          // Search for an EI that is "less than" lpEI[ 0 ].
; 12849:          do
; 12850:             j--;

	mov	ecx, DWORD PTR _j$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _j$[ebp], ecx

; 12851:          while ( j > 0 && fnSortCmpr( lpSortData, lpEI[ j ], lpEI[ 0 ] ) );

	je	SHORT $LN12@fnQuickSor
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	mov	eax, DWORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN9@fnQuickSor
$LN12@fnQuickSor:

; 12852: 
; 12853:          // Search for an EI that is "less than" lpEI[ 0 ].
; 12854:          do
; 12855:             k++;

	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 12856:          while ( k < j && !fnSortCmpr( lpSortData, lpEI[ k ], lpEI[ 0 ] ) );

	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _j$[ebp]
	jae	SHORT $LN11@fnQuickSor
	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN12@fnQuickSor
$LN11@fnQuickSor:

; 12857: 
; 12858:          if ( k >= j )

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _j$[ebp]
	jb	SHORT $LN15@fnQuickSor

; 12859:             break;

	jmp	SHORT $LN5@fnQuickSor
$LN15@fnQuickSor:

; 12860: 
; 12861:          SWAP_EI( lpEI[ k ], lpEI[ j ] );

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _t$2[ebp], ecx
	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4]
	mov	DWORD PTR [eax+edx*4], ecx
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR _t$2[ebp]
	mov	DWORD PTR [eax+edx*4], ecx

; 12862:       }

	jmp	$LN9@fnQuickSor
$LN5@fnQuickSor:

; 12863: 
; 12864:       SWAP_EI( lpEI[ j ], lpEI[ 0 ] );

	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	mov	DWORD PTR _t$1[ebp], edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _j$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [edx+ecx], eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _t$1[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 12865: 
; 12866:       ulLeft = j;

	mov	ecx, DWORD PTR _j$[ebp]
	mov	DWORD PTR _ulLeft$[ebp], ecx

; 12867:       ulRight = ulRecordCnt - ++j;

	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, DWORD PTR _j$[ebp]
	mov	DWORD PTR _ulRight$[ebp], eax

; 12868:       if ( ulLeft < ulRight )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRight$[ebp]
	jae	SHORT $LN16@fnQuickSor

; 12869:       {
; 12870:          fnQuickSort( lpSortData, lpEI, ulLeft );

	mov	edx, DWORD PTR _ulLeft$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH

; 12871: 
; 12872:          lpEI += j;

	mov	edx, DWORD PTR _j$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _lpEI$[ebp], ecx

; 12873:          ulRecordCnt = ulRight;

	mov	edx, DWORD PTR _ulRight$[ebp]
	mov	DWORD PTR _ulRecordCnt$[ebp], edx

; 12874:       }

	jmp	SHORT $LN17@fnQuickSor
$LN16@fnQuickSor:

; 12875:       else
; 12876:       {
; 12877:          fnQuickSort( lpSortData, lpEI + j, ulRight );

	mov	eax, DWORD PTR _ulRight$[ebp]
	push	eax
	mov	ecx, DWORD PTR _j$[ebp]
	mov	edx, DWORD PTR _lpEI$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_fnQuickSort
	add	esp, 12					; 0000000cH

; 12878:          ulRecordCnt = ulLeft;

	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulRecordCnt$[ebp], edx
$LN17@fnQuickSor:

; 12879:       }
; 12880: 
; 12881:    } // while ( ulRecordCnt > 1 )...

	jmp	$LN2@fnQuickSor
$LN1@fnQuickSor:

; 12882: 
; 12883: } // fnQuickSort

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_fnQuickSort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_ul$ = -4						; size = 4
_lpSortData$ = 8					; size = 4
_lpEI$ = 12						; size = 4
_ulRecordCnt$ = 16					; size = 4
_fnHeapSort PROC

; 12801: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 12802: // zULONG ulHoldCnt = ulRecordCnt;
; 12803: // zULONG ulHoldMax = ulMaxRecords;
; 12804: // zULONG *p1;
; 12805:    zULONG ul;
; 12806: 
; 12807:    BuildHeap( lpSortData, lpEI, ulRecordCnt );

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_BuildHeap
	add	esp, 12					; 0000000cH
$LN2@fnHeapSort:

; 12808: 
; 12809:    while ( ulRecordCnt > 1 )

	cmp	DWORD PTR _ulRecordCnt$[ebp], 1
	jbe	SHORT $LN1@fnHeapSort

; 12810:    {
; 12811:       ulRecordCnt--;

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ulRecordCnt$[ebp], eax

; 12812:    // ulMaxRecords--;
; 12813:    //
; 12814:    // p1 = CSIMP_GETSORTIDX_PTR( ulRecordCnt + 1, m_pUseIdx->m_pxIdx );
; 12815:    // ul = *p1;
; 12816:    // *p1 = *(m_pUseIdx->m_pxIdx);
; 12817:    // *(m_pUseIdx->m_pxIdx) = ul;
; 12818: 
; 12819:    // ul = Heapify( 1 );
; 12820:       ul = Heapify( lpSortData, lpEI, ulRecordCnt, 1 );

	push	1
	mov	ecx, DWORD PTR _ulRecordCnt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEI$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax
$LN4@fnHeapSort:

; 12821:       while ( ul )

	cmp	DWORD PTR _ul$[ebp], 0
	je	SHORT $LN5@fnHeapSort

; 12822:       {
; 12823:       // ul = Heapify( ul );
; 12824:          ul = Heapify( lpSortData, lpEI, ulRecordCnt, ul );

	mov	ecx, DWORD PTR _ul$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax

; 12825:       }

	jmp	SHORT $LN4@fnHeapSort
$LN5@fnHeapSort:

; 12826:    }

	jmp	SHORT $LN2@fnHeapSort
$LN1@fnHeapSort:

; 12827: 
; 12828: // ulRecordCnt = ulHoldCnt;
; 12829: // ulMaxRecords = ulHoldMax;
; 12830: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnHeapSort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
tv68 = -12						; size = 4
_ul$ = -8						; size = 4
_k$ = -4						; size = 4
_lpSortData$ = 8					; size = 4
_lpEI$ = 12						; size = 4
_ulRecordCnt$ = 16					; size = 4
_BuildHeap PROC

; 12774: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 12775:    zULONG k;
; 12776:    zULONG ul;
; 12777: 
; 12778: #ifdef DEBUG_ALL
; 12779:    OutputDebugString( "\nShowing heap prior to build heap ...\n" );
; 12780:    ShowHeap( this, m_pUseIdx->m_pxIdx );
; 12781: #endif
; 12782: 
; 12783:    k = ulRecordCnt / 2;

	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	shr	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN2@BuildHeap:

; 12784:    while ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jbe	SHORT $LN1@BuildHeap

; 12785:    {
; 12786:       ul = Heapify( lpSortData, lpEI, ulRecordCnt, k-- );

	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR tv68[ebp], ecx
	mov	edx, DWORD PTR tv68[ebp]
	push	edx
	mov	eax, DWORD PTR _ulRecordCnt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax
	mov	eax, DWORD PTR _k$[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@BuildHeap:

; 12787:       while ( ul )

	cmp	DWORD PTR _ul$[ebp], 0
	je	SHORT $LN5@BuildHeap

; 12788:       {
; 12789:          ul = Heapify( lpSortData, lpEI, ulRecordCnt, ul );

	mov	ecx, DWORD PTR _ul$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulRecordCnt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	push	ecx
	call	_Heapify
	add	esp, 16					; 00000010H
	mov	DWORD PTR _ul$[ebp], eax

; 12790:       }

	jmp	SHORT $LN4@BuildHeap
$LN5@BuildHeap:

; 12791:    }

	jmp	SHORT $LN2@BuildHeap
$LN1@BuildHeap:

; 12792: }  // end of:  BuildHeap

	mov	esp, ebp
	pop	ebp
	ret	0
_BuildHeap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_t$1 = -12						; size = 4
_ulLargest$ = -8					; size = 4
_ulLeft$ = -4						; size = 4
_lpSortData$ = 8					; size = 4
_lpEI$ = 12						; size = 4
_ulRecordCnt$ = 16					; size = 4
_k$ = 20						; size = 4
_Heapify PROC

; 12722: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi

; 12723: // ASSERT_TRACE( "Heapify error", 0, k <= ulRecordCnt );
; 12724:    zULONG ulLeft = k << 1;

	mov	eax, DWORD PTR _k$[ebp]
	shl	eax, 1
	mov	DWORD PTR _ulLeft$[ebp], eax

; 12725:    zULONG ulLargest;
; 12726: 
; 12727:    if ( ulLeft > ulRecordCnt )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRecordCnt$[ebp]
	jbe	SHORT $LN2@Heapify

; 12728:    {
; 12729:       return( 0 );

	xor	eax, eax
	jmp	$LN1@Heapify
$LN2@Heapify:

; 12730:    }
; 12731: 
; 12732:    ulLargest = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], edx

; 12733: // if ( CompareRecords( ulLeft, ulLargest ) > 0 )
; 12734:    if ( fnSortCmpr( lpSortData, lpEI[ ulLeft - 1 ], lpEI[ ulLargest - 1 ] ) )

	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, DWORD PTR _ulLeft$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	push	edx
	mov	eax, DWORD PTR _lpSortData$[ebp]
	push	eax
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN3@Heapify

; 12735:    {
; 12736:       ulLargest = ulLeft;

	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], edx
$LN3@Heapify:

; 12737:    }
; 12738: 
; 12739:    ulLeft++;   // ulRight (use ulLeft to conserve stack space)

	mov	eax, DWORD PTR _ulLeft$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulLeft$[ebp], eax

; 12740:    if ( ulLeft <= ulRecordCnt )

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	cmp	ecx, DWORD PTR _ulRecordCnt$[ebp]
	ja	SHORT $LN4@Heapify

; 12741:    {
; 12742:    // if ( CompareRecords( ulLeft, ulLargest ) > 0 )
; 12743:       if ( fnSortCmpr( lpSortData, lpEI[ ulLeft - 1 ], lpEI[ ulLargest - 1 ] ) )

	mov	edx, DWORD PTR _ulLargest$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	mov	edx, DWORD PTR _ulLeft$[ebp]
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4-4]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	push	edx
	call	_fnSortCmpr
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN4@Heapify

; 12744:       {
; 12745:          ulLargest = ulLeft;

	mov	ecx, DWORD PTR _ulLeft$[ebp]
	mov	DWORD PTR _ulLargest$[ebp], ecx
$LN4@Heapify:

; 12746:       }
; 12747:    }
; 12748: 
; 12749:    if ( k != ulLargest )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _ulLargest$[ebp]
	je	SHORT $LN6@Heapify

; 12750:    {
; 12751:       SWAP_EI( lpEI[ k - 1 ], lpEI[ ulLargest - 1 ] );

	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4-4]
	mov	DWORD PTR _t$1[ebp], edx
	mov	eax, DWORD PTR _ulLargest$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _k$[ebp]
	mov	esi, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [esi+edx*4-4]
	mov	DWORD PTR [ecx+eax*4-4], edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _t$1[ebp]
	mov	DWORD PTR [ecx+eax*4-4], edx

; 12752:    // zULONG *p1;
; 12753:    // zULONG *p2;
; 12754: 
; 12755:    // // Use uLeft to conserve stack.
; 12756:    // p1 = CSIMP_GETSORTIDX_PTR( k, m_pUseIdx->m_pxIdx );
; 12757:    // p2 = CSIMP_GETSORTIDX_PTR( ulLargest, m_pUseIdx->m_pxIdx );
; 12758:    // ulLeft = *p1;
; 12759:    // *p1 = *p2;
; 12760:    // *p2 = ulLeft;
; 12761:       return( ulLargest );

	mov	eax, DWORD PTR _ulLargest$[ebp]
	jmp	SHORT $LN1@Heapify
$LN6@Heapify:

; 12762:    }
; 12763: 
; 12764:    return( 0 );

	xor	eax, eax
$LN1@Heapify:

; 12765: }  // end of:  Heapify

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_Heapify ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpCompareEI2$ = -16					; size = 4
_lpCompareEI1$ = -12					; size = 4
_lpAttrListPtr$ = -8					; size = 4
_nComp$ = -4						; size = 2
_lpSortData$ = 8					; size = 4
_lpEI1$ = 12						; size = 4
_lpEI2$ = 16						; size = 4
_fnSortCmpr PROC

; 12577: {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 12578:    LPVIEWATTRLIST   lpAttrListPtr;
; 12579:    LPENTITYINSTANCE lpCompareEI1;
; 12580:    LPENTITYINSTANCE lpCompareEI2;
; 12581:    zSHORT           nComp;
; 12582: 
; 12583:    // Compare sort keys from major to minor.  When an inequality is
; 12584:    // found, see if an entity swap is needed.
; 12585:    for ( lpAttrListPtr = lpSortData->lpViewAttrList;

	mov	eax, DWORD PTR _lpSortData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _lpAttrListPtr$[ebp], ecx
	jmp	SHORT $LN4@fnSortCmpr
$LN2@fnSortCmpr:

; 12587:          lpAttrListPtr++ )

	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	add	edx, 13					; 0000000dH
	mov	DWORD PTR _lpAttrListPtr$[ebp], edx
$LN4@fnSortCmpr:

; 12586:          lpAttrListPtr->lpViewAttrib;

	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN3@fnSortCmpr

; 12588:    {
; 12589:       // Check to see if the sort key belongs to the same entity that we are
; 12590:       // sorting.  If not we need to retrieve the EI for the sort key.
; 12591:       if ( lpAttrListPtr->lpViewAttrib->hViewEntity != lpEI1->hViewEntity &&

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [edx+6]
	cmp	ecx, DWORD PTR [eax+2]
	je	$LN9@fnSortCmpr
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_fnCmprEntities
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	$LN9@fnSortCmpr

; 12592:            fnCmprEntities( lpAttrListPtr->lpViewAttrib->hViewEntity,
; 12593:                            lpEI1->hViewEntity ) != 0 )
; 12594:       {
; 12595:          // Sort key is from a different entity than the swap entity.  This
; 12596:          // could happen if the user is sorting entities using the value of a
; 12597:          // child entity.  We need to retrieve the EI for the child entity.
; 12598:          // Since cursor positions are undefined at this point we will assume
; 12599:          // the first child entity.
; 12600:          lpCompareEI1 = zGETPTR( lpEI1->hNextHier );

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI1$[ebp], eax
$LN5@fnSortCmpr:

; 12601:          while ( lpCompareEI1 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $LN6@fnSortCmpr

; 12602:          {
; 12603:             // Check to see if this is the EI we are looking for.
; 12604:             if ( lpCompareEI1->hViewEntity ==

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpCompareEI1$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR [edx+6]
	jne	SHORT $LN11@fnSortCmpr

; 12605:                                   lpAttrListPtr->lpViewAttrib->hViewEntity )
; 12606:             {
; 12607:                break;  // it is the EI we are looking for

	jmp	SHORT $LN6@fnSortCmpr
$LN11@fnSortCmpr:

; 12608:             }
; 12609: 
; 12610:             // Check the next EI.
; 12611:             lpCompareEI1 = zGETPTR( lpCompareEI1->hNextHier );

	mov	edx, DWORD PTR _lpCompareEI1$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI1$[ebp], eax

; 12612: 
; 12613:             if ( lpCompareEI1 == 0 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	jne	SHORT $LN12@fnSortCmpr

; 12614:                break;

	jmp	SHORT $LN6@fnSortCmpr
$LN12@fnSortCmpr:

; 12615: 
; 12616:             // If the level of the current EI is <= the level of the parent
; 12617:             // EI then we never found a matching child entity ... so break.
; 12618:             if ( lpCompareEI1->nLevel <= lpEI1->nLevel )

	mov	ecx, DWORD PTR _lpCompareEI1$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEI1$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $LN13@fnSortCmpr

; 12619:             {
; 12620:                lpCompareEI1 = 0;

	mov	DWORD PTR _lpCompareEI1$[ebp], 0

; 12621:                break;

	jmp	SHORT $LN6@fnSortCmpr
$LN13@fnSortCmpr:

; 12622:             }
; 12623:          }

	jmp	SHORT $LN5@fnSortCmpr
$LN6@fnSortCmpr:

; 12624: 
; 12625:          // Do the same thing for the second EI.
; 12626:          lpCompareEI2 = zGETPTR( lpEI2->hNextHier );

	mov	edx, DWORD PTR _lpEI2$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI2$[ebp], eax
$LN7@fnSortCmpr:

; 12627:          while ( lpCompareEI2 )

	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	je	SHORT $LN8@fnSortCmpr

; 12628:          {
; 12629:             // Check to see if this is the EI we are looking for.
; 12630:             if ( lpCompareEI2->hViewEntity ==

	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _lpCompareEI2$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR [edx+6]
	jne	SHORT $LN14@fnSortCmpr

; 12631:                                   lpAttrListPtr->lpViewAttrib->hViewEntity )
; 12632:             {
; 12633:                break;  // it is the EI we are looking for

	jmp	SHORT $LN8@fnSortCmpr
$LN14@fnSortCmpr:

; 12634:             }
; 12635: 
; 12636:             // Check the next EI.
; 12637:             lpCompareEI2 = zGETPTR( lpCompareEI2->hNextHier );

	mov	edx, DWORD PTR _lpCompareEI2$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareEI2$[ebp], eax

; 12638: 
; 12639:             if ( lpCompareEI2 == 0 )

	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	jne	SHORT $LN15@fnSortCmpr

; 12640:                break;

	jmp	SHORT $LN8@fnSortCmpr
$LN15@fnSortCmpr:

; 12641: 
; 12642:             // If the level of the current EI is <= the level of the parent
; 12643:             // EI then we never found a matching child entity ... so break.
; 12644:             if ( lpCompareEI2->nLevel <= lpEI2->nLevel )

	mov	ecx, DWORD PTR _lpCompareEI2$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEI2$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $LN16@fnSortCmpr

; 12645:             {
; 12646:                lpCompareEI2 = 0;

	mov	DWORD PTR _lpCompareEI2$[ebp], 0

; 12647:                break;

	jmp	SHORT $LN8@fnSortCmpr
$LN16@fnSortCmpr:

; 12648:             }
; 12649:          }

	jmp	SHORT $LN7@fnSortCmpr
$LN8@fnSortCmpr:

; 12650: 
; 12651:          // If either of the compare entities are 0 then they don't
; 12652:          // exist so set nComp and break.
; 12653:          if ( lpCompareEI1 == 0 || lpCompareEI2 == 0 )

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $LN18@fnSortCmpr
	cmp	DWORD PTR _lpCompareEI2$[ebp], 0
	jne	SHORT $LN17@fnSortCmpr
$LN18@fnSortCmpr:

; 12654:          {
; 12655:             // If they are the same then they are both 0 and we'll assume
; 12656:             // that they compare equal.
; 12657:             if ( lpCompareEI1 == lpCompareEI2 )

	mov	edx, DWORD PTR _lpCompareEI1$[ebp]
	cmp	edx, DWORD PTR _lpCompareEI2$[ebp]
	jne	SHORT $LN19@fnSortCmpr

; 12658:                nComp = 0;

	xor	eax, eax
	mov	WORD PTR _nComp$[ebp], ax
	jmp	SHORT $LN20@fnSortCmpr
$LN19@fnSortCmpr:

; 12659:             else
; 12660:             if ( lpCompareEI1 ) // EI1 is valid but EI2 is not so we'll assume EI1 > EI2.

	cmp	DWORD PTR _lpCompareEI1$[ebp], 0
	je	SHORT $LN21@fnSortCmpr

; 12661:                nComp = 1;

	mov	ecx, 1
	mov	WORD PTR _nComp$[ebp], cx
	jmp	SHORT $LN20@fnSortCmpr
$LN21@fnSortCmpr:

; 12662:             else
; 12663:                nComp = -1;

	or	edx, -1
	mov	WORD PTR _nComp$[ebp], dx
$LN20@fnSortCmpr:

; 12664: 
; 12665:             break;

	jmp	SHORT $LN3@fnSortCmpr
$LN17@fnSortCmpr:

; 12666:          }
; 12667:       }

	jmp	SHORT $LN10@fnSortCmpr
$LN9@fnSortCmpr:

; 12668:       else
; 12669:       {
; 12670:          // We are comparing the same entity we are swapping.
; 12671:          lpCompareEI1 = lpEI1;

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	DWORD PTR _lpCompareEI1$[ebp], eax

; 12672:          lpCompareEI2 = lpEI2;

	mov	ecx, DWORD PTR _lpEI2$[ebp]
	mov	DWORD PTR _lpCompareEI2$[ebp], ecx
$LN10@fnSortCmpr:

; 12673:       }
; 12674: 
; 12675:       // Now actually perform the compare.
; 12676:       nComp = fnCompareEIAttrs( lpSortData->lpCurrentTask,

	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx+9]
	push	eax
	mov	ecx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _lpCompareEI2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	mov	ecx, DWORD PTR [eax+9]
	push	ecx
	mov	edx, DWORD PTR _lpAttrListPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCompareEI1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSortData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _lpSortData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnCompareEIAttrs@36
	mov	WORD PTR _nComp$[ebp], ax

; 12677:                                 lpSortData->lpView1, lpCompareEI1,
; 12678:                                 lpAttrListPtr->lpViewAttrib,
; 12679:                                 lpAttrListPtr->pszContextName,
; 12680:                                 lpSortData->lpView2, lpCompareEI2,
; 12681:                                 lpAttrListPtr->lpViewAttrib,
; 12682:                                 lpAttrListPtr->pszContextName );
; 12683: 
; 12684:       // If the compare wasn't equal then we don't need to compare any more
; 12685:       // because we know the EIs are different.
; 12686:       if ( nComp )

	movsx	eax, WORD PTR _nComp$[ebp]
	test	eax, eax
	je	SHORT $LN23@fnSortCmpr

; 12687:          break;

	jmp	SHORT $LN3@fnSortCmpr
$LN23@fnSortCmpr:

; 12688: 
; 12689:    } // for...

	jmp	$LN2@fnSortCmpr
$LN3@fnSortCmpr:

; 12690: 
; 12691:    // If the EIs are different then find out if they need to be swapped.
; 12692:    if ( nComp )

	movsx	ecx, WORD PTR _nComp$[ebp]
	test	ecx, ecx
	je	SHORT $LN24@fnSortCmpr

; 12693:    {
; 12694:       if ( nComp < 0 && lpAttrListPtr->bOrder )

	movsx	edx, WORD PTR _nComp$[ebp]
	test	edx, edx
	jge	SHORT $LN25@fnSortCmpr
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN25@fnSortCmpr

; 12695:          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnSortCmpr
$LN25@fnSortCmpr:

; 12696: 
; 12697:       if ( nComp > 0 && lpAttrListPtr->bOrder == FALSE )

	movsx	edx, WORD PTR _nComp$[ebp]
	test	edx, edx
	jle	SHORT $LN24@fnSortCmpr
	mov	eax, DWORD PTR _lpAttrListPtr$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $LN24@fnSortCmpr

; 12698:          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnSortCmpr
$LN24@fnSortCmpr:

; 12699:    }
; 12700: 
; 12701:    // If we get here then the EIs are in correct order.
; 12702:    return( 0 );

	xor	eax, eax
$LN1@fnSortCmpr:

; 12703: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSortCmpr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewEntity2$ = -8					; size = 4
_lpViewEntity1$ = -4					; size = 4
_hViewEntity1$ = 8					; size = 4
_hViewEntity2$ = 12					; size = 4
_fnCmprEntities PROC

; 12545: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12546:    LPVIEWENTITY lpViewEntity1 = zGETPTR( hViewEntity1 );

	mov	eax, DWORD PTR _hViewEntity1$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity1$[ebp], eax

; 12547:    LPVIEWENTITY lpViewEntity2 = zGETPTR( hViewEntity2 );

	mov	ecx, DWORD PTR _hViewEntity2$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity2$[ebp], eax

; 12548: 
; 12549: #if 0
; 12550:    TraceLine( "fnSortCmpr Checking Entities: %s : 0x%08x, %s : 0x%08x",
; 12551:               lpViewEntity1->szName, lpViewEntity1->lEREntTok,
; 12552:               lpViewEntity2->szName, lpViewEntity2->lEREntTok );
; 12553: #endif
; 12554: 
; 12555:    // It appears that it is "good enough" for the entity tokens to
; 12556:    // match when doing the compare.  In such a case, for example,
; 12557:    // CtrlCtrl matches Control in TZWDLGSO.   dks 2005.12.26
; 12558:    if ( lpViewEntity1 && lpViewEntity2 &&

	cmp	DWORD PTR _lpViewEntity1$[ebp], 0
	je	SHORT $LN2@fnCmprEnti
	cmp	DWORD PTR _lpViewEntity2$[ebp], 0
	je	SHORT $LN2@fnCmprEnti
	mov	edx, DWORD PTR _lpViewEntity1$[ebp]
	mov	eax, DWORD PTR _lpViewEntity2$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $LN2@fnCmprEnti

; 12559:         lpViewEntity1->lEREntTok == lpViewEntity2->lEREntTok )
; 12560:    {
; 12561:       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnCmprEnti
$LN2@fnCmprEnti:

; 12562:    }
; 12563: 
; 12564:    return( 1 );

	mov	eax, 1
$LN1@fnCmprEnti:

; 12565: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCmprEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchStart$1 = -992					; size = 4
_l$2 = -988						; size = 4
_lpWk$3 = -984						; size = 4
_pchAttr$ = -980					; size = 4
_uPos$ = -976						; size = 4
_lXVATok$4 = -972					; size = 4
_lPrevIndicators$ = -968				; size = 4
_lpTask$ = -964						; size = 4
tv243 = -960						; size = 4
_pRelinkBufferEnd$ = -956				; size = 4
tv73 = -952						; size = 4
_lpWkViewEntity$5 = -948				; size = 4
_l$6 = -944						; size = 4
_lpFirstViewCsr$7 = -940				; size = 4
_l$8 = -936						; size = 4
$T9 = -932						; size = 4
$T10 = -928						; size = 4
tv505 = -924						; size = 4
tv69 = -920						; size = 4
tv417 = -916						; size = 4
tv416 = -912						; size = 4
_uFlags$11 = -908					; size = 4
tv316 = -904						; size = 4
tv315 = -900						; size = 4
tv298 = -896						; size = 4
tv297 = -892						; size = 4
tv280 = -888						; size = 4
tv279 = -884						; size = 4
tv262 = -880						; size = 4
tv261 = -876						; size = 4
tv244 = -872						; size = 4
_lpSearchViewEntityCsr$12 = -868			; size = 4
tv232 = -864						; size = 4
_nHierNbr$13 = -860					; size = 2
_nHierNbr$14 = -856					; size = 2
_lpViewOD$ = -852					; size = 4
_lpTgtViewEntity$15 = -848				; size = 4
_lLinkTgt$16 = -844					; size = 4
_lpCursorEI$ = -840					; size = 4
_lLinkSrc$17 = -836					; size = 4
_lLineCount$ = -832					; size = 4
_lIndicators$ = -828					; size = 4
_lInstanceCount$ = -824					; size = 4
_AttribFlags$18 = -820					; size = 4
_lpAttribFlags$19 = -816				; size = 4
_ulLthDecoded$ = -812					; size = 4
_nErrorAttribCnt$ = -808				; size = 2
_nErrorEntityCnt$ = -804				; size = 2
_lpViewCsr$ = -800					; size = 4
_bIgnoreAttribErrors$ = -794				; size = 1
_bEntityIsCompressed$ = -793				; size = 1
_lpTgtInstance$ = -792					; size = 4
_lpSrcInstance$ = -788					; size = 4
_j$20 = -784						; size = 2
_bMsgBox$ = -778					; size = 1
_bIgnoreEntityErrors$ = -777				; size = 1
_lpViewOI$ = -776					; size = 4
_lEntityCnt$ = -772					; size = 4
_pRelinkBufferPtr$ = -768				; size = 4
_nErrorEntityLvl$ = -764				; size = 2
_ulLth$ = -760						; size = 4
_bOI_IsUpdated$ = -753					; size = 1
_nEOF$ = -752						; size = 2
_lpViewEntity$ = -748					; size = 4
_nLevel$ = -744						; size = 2
_k$ = -740						; size = 4
_bSkipAttributes$ = -733				; size = 1
_lpViewAttrib$ = -732					; size = 4
_lpViewEntityCsr$ = -728				; size = 4
_lpEntityInstance$ = -724				; size = 4
_nRC$ = -720						; size = 2
_pchLine$ = -716					; size = 4
_pRelinkBufferTable$ = -712				; size = 40
_sz$21 = -672						; size = 400
_szWorkString$ = -272					; size = 256
_szAttribFlags$22 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpfnStreamFunc$ = 12					; size = 4
_lpvData$ = 16						; size = 4
_plControl$ = 20					; size = 4
_fnActivateOI_FromTextStream PROC

; 10621: {

	push	ebp
	mov	ebp, esp
	sub	esp, 992				; 000003e0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 10622:    LPVIEWOD          lpViewOD;
; 10623:    LPVIEWOI          lpViewOI;
; 10624:    LPVIEWENTITY      lpViewEntity;
; 10625:    LPVIEWATTRIB      lpViewAttrib;
; 10626:    LPVIEWCSR         lpViewCsr;
; 10627:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10628:    LPENTITYINSTANCE  lpEntityInstance;
; 10629:    LPENTITYINSTANCE  lpSrcInstance;
; 10630:    LPENTITYINSTANCE  lpTgtInstance;
; 10631:    LPENTITYINSTANCE  lpCursorEI;    // Used to set cursors.
; 10632:    LPTASK            lpTask;
; 10633:    zPCHAR            pchAttr;
; 10634:    zPCHAR            pchLine;
; 10635:    zPLONG            pRelinkBufferTable[ 10 ] = { 0 };

	mov	DWORD PTR _pRelinkBufferTable$[ebp], 0
	xor	eax, eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+4], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+8], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+12], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+16], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+20], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+24], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+28], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+32], eax
	mov	DWORD PTR _pRelinkBufferTable$[ebp+36], eax

; 10636:    zPLONG            pRelinkBufferPtr;
; 10637:    zPLONG            pRelinkBufferEnd;
; 10638:    zULONG            ulLth;
; 10639:    zULONG            ulLthDecoded;
; 10640:    zULONG            uPos;
; 10641:    zBOOL             bIgnoreEntityErrors;
; 10642:    zBOOL             bIgnoreAttribErrors;
; 10643:    zBOOL             bEntityIsCompressed;
; 10644:    zBOOL             bOI_IsUpdated = FALSE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 0

; 10645:    zBOOL             bSkipAttributes = FALSE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 0

; 10646:    zBOOL             bMsgBox = TRUE;

	mov	BYTE PTR _bMsgBox$[ebp], 1

; 10647:    zCHAR             szWorkString[ 256 ];
; 10648:    zLONG             lIndicators = 0, lPrevIndicators;

	mov	DWORD PTR _lIndicators$[ebp], 0

; 10649:    zLONG             lEntityCnt = 0;

	mov	DWORD PTR _lEntityCnt$[ebp], 0

; 10650:    zLONG             lLineCount = 0;

	mov	DWORD PTR _lLineCount$[ebp], 0

; 10651:    zLONG             k;
; 10652:    zSHORT            nErrorEntityLvl;
; 10653:    zSHORT            nErrorEntityCnt;
; 10654:    zSHORT            nErrorAttribCnt;
; 10655:    zSHORT            nEOF;
; 10656:    zSHORT            nLevel;
; 10657:    zSHORT            nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 10658: 
; 10659:    // The following should only be used for cursor processing.
; 10660:    zLONG             lInstanceCount = 0;

	mov	DWORD PTR _lInstanceCount$[ebp], 0

; 10661: 
; 10662:    bIgnoreEntityErrors = (*plControl & zIGNORE_ENTITY_ERRORS) ? 1 : 0;

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 4096				; 00001000H
	je	SHORT $LN219@fnActivate
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN220@fnActivate
$LN219@fnActivate:
	mov	DWORD PTR tv69[ebp], 0
$LN220@fnActivate:
	mov	cl, BYTE PTR tv69[ebp]
	mov	BYTE PTR _bIgnoreEntityErrors$[ebp], cl

; 10663:    bIgnoreAttribErrors = (*plControl & zIGNORE_ATTRIB_ERRORS) ? 1 : 0;

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 8192				; 00002000H
	je	SHORT $LN221@fnActivate
	mov	DWORD PTR tv73[ebp], 1
	jmp	SHORT $LN222@fnActivate
$LN221@fnActivate:
	mov	DWORD PTR tv73[ebp], 0
$LN222@fnActivate:
	mov	cl, BYTE PTR tv73[ebp]
	mov	BYTE PTR _bIgnoreAttribErrors$[ebp], cl

; 10664: 
; 10665:    nErrorEntityLvl = 0;

	xor	edx, edx
	mov	WORD PTR _nErrorEntityLvl$[ebp], dx

; 10666:    nErrorEntityCnt = 0;

	xor	eax, eax
	mov	WORD PTR _nErrorEntityCnt$[ebp], ax

; 10667:    nErrorAttribCnt = 0;

	xor	ecx, ecx
	mov	WORD PTR _nErrorAttribCnt$[ebp], cx

; 10668: 
; 10669:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 10670:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 10671:    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10672:    lpTask    = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 10673: 
; 10674:    // Initialize buffer pointers to indicate it hasn't been allocated yet.
; 10675:    pRelinkBufferEnd = pRelinkBufferPtr = 0;

	mov	DWORD PTR _pRelinkBufferPtr$[ebp], 0
	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR _pRelinkBufferEnd$[ebp], ecx

; 10676: 
; 10677:    // Process the stream
; 10678:    lpViewEntityCsr = 0;

	mov	DWORD PTR _lpViewEntityCsr$[ebp], 0

; 10679:    lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0
$LN2@fnActivate:

; 10680:    while ( (nEOF = (*lpfnStreamFunc)( lpView, lpvData,
; 10681:                                       &pchLine, 0, 0 )) == 1 )

	push	0
	push	0
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
	movsx	edx, WORD PTR _nEOF$[ebp]
	cmp	edx, 1
	jne	$LN3@fnActivate

; 10682:    {
; 10683:       lLineCount++;

	mov	eax, DWORD PTR _lLineCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lLineCount$[ebp], eax

; 10684:       if ( pRelinkBufferPtr == pRelinkBufferEnd )

	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	cmp	ecx, DWORD PTR _pRelinkBufferEnd$[ebp]
	jne	$LN45@fnActivate

; 10685:       {
; 10686:          k = lEntityCnt / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 10687: 
; 10688:          // If we've loaded 160000 * 10 entities then bomb.
; 10689:          if ( k > 10 )

	cmp	DWORD PTR _k$[ebp], 10			; 0000000aH
	jle	SHORT $LN46@fnActivate

; 10690:          {
; 10691:             // if the relink entity pointer is at the end of the
; 10692:             // space allocated, issue an error
; 10693:             //  "KZOEE090 - Maximum number of entities in portable file exceeded "
; 10694:             (*lpfnStreamFunc)( lpView, lpvData, 0, 0, 90 );

	push	90					; 0000005aH
	push	0
	push	0
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10695:             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 10696:             break;

	jmp	$LN3@fnActivate
$LN46@fnActivate:

; 10697:          }
; 10698: 
; 10699:          pRelinkBufferTable[ k ] =

	push	10107					; 0000277bH
	push	0
	push	1
	push	640000					; 0009c400H
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _pRelinkBufferTable$[ebp+ecx*4], eax

; 10700:             (zPLONG) fnAllocDataspace( lpTask->hFirstDataHeader,
; 10701:                                        640000L, TRUE, 0, iRelinkBuffer );  // moved up from 64000 dks/don 2007.01.04
; 10702: 
; 10703:          pRelinkBufferTable[ k ] = zGETPTR( pRelinkBufferTable[ k ] );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pRelinkBufferTable$[ebp+edx*4]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _pRelinkBufferTable$[ebp+ecx*4], eax

; 10704: 
; 10705:          pRelinkBufferEnd = pRelinkBufferTable[ k ] + 640000 / 4;  // Space for 160000 entities ... moved up from 16000 dks/don 2007.01.04

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pRelinkBufferTable$[ebp+edx*4]
	add	eax, 640000				; 0009c400H
	mov	DWORD PTR _pRelinkBufferEnd$[ebp], eax

; 10706:          pRelinkBufferPtr = pRelinkBufferTable[ k ];

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pRelinkBufferTable$[ebp+ecx*4]
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], edx
$LN45@fnActivate:

; 10707: 
; 10708:       }
; 10709: 
; 10710:       if ( nErrorEntityLvl )

	movsx	eax, WORD PTR _nErrorEntityLvl$[ebp]
	test	eax, eax
	je	$LN47@fnActivate

; 10711:       {
; 10712:          if ( pchLine[ 0 ] == 'e' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 101				; 00000065H
	jne	$LN48@fnActivate

; 10713:          {
; 10714:             SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_SysParseLine@12

; 10715:             if ( *plControl & zCOMPRESSED )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 131072				; 00020000H
	je	SHORT $LN50@fnActivate

; 10716:                nLevel = (zSHORT) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nLevel$[ebp], ax
	jmp	SHORT $LN51@fnActivate
$LN50@fnActivate:

; 10717:             else
; 10718:                nLevel = (zSHORT) zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nLevel$[ebp], ax
$LN51@fnActivate:

; 10719: 
; 10720:             if ( nLevel > nErrorEntityLvl )

	movsx	eax, WORD PTR _nLevel$[ebp]
	movsx	ecx, WORD PTR _nErrorEntityLvl$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN52@fnActivate

; 10721:                pchLine[ 0 ] = ' ';

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [ecx+eax], 32			; 00000020H
$LN52@fnActivate:

; 10722: 
; 10723:             *pRelinkBufferPtr = 0;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR [edx], 0

; 10724:             pRelinkBufferPtr++;

	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	eax, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], eax

; 10725:             lEntityCnt++;

	mov	ecx, DWORD PTR _lEntityCnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lEntityCnt$[ebp], ecx

; 10726:          }

	jmp	SHORT $LN47@fnActivate
$LN48@fnActivate:

; 10727:          else
; 10728:          if ( pchLine[ 0 ] == 'a' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 97					; 00000061H
	jne	SHORT $LN47@fnActivate

; 10729:             pchLine[ 0 ] = ' ';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [edx+ecx], 32			; 00000020H
$LN47@fnActivate:

; 10730:       }
; 10731: 
; 10732:       if ( pchLine[ 0 ] == 'm' )  // Meta information

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 109				; 0000006dH
	jne	$LN54@fnActivate

; 10733:       {
; 10734:          // Meta information is information about the OI (as opposed to the
; 10735:          // info *in* the OI).
; 10736:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_SysParseLine@12

; 10737:          switch ( szWorkString[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _szWorkString$[ebp+edx]
	mov	BYTE PTR tv232[ebp], al
	cmp	BYTE PTR tv232[ebp], 67			; 00000043H
	je	SHORT $LN56@fnActivate
	cmp	BYTE PTR tv232[ebp], 69			; 00000045H
	je	$LN58@fnActivate
	cmp	BYTE PTR tv232[ebp], 79			; 0000004fH
	je	$LN62@fnActivate
	jmp	$LN4@fnActivate
$LN56@fnActivate:

; 10738:          {
; 10739:             case 'C':
; 10740:                if ( zstrcmp( szWorkString, "CONTROL" ) == 0 )

	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	movsx	edx, BYTE PTR $SG17241
	cmp	ecx, edx
	jne	SHORT $LN225@fnActivate
	push	OFFSET $SG17242
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv244[ebp], eax
	jmp	SHORT $LN226@fnActivate
$LN225@fnActivate:
	movsx	ecx, BYTE PTR _szWorkString$[ebp]
	movsx	edx, BYTE PTR $SG17243
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN223@fnActivate
	mov	DWORD PTR tv243[ebp], 1
	jmp	SHORT $LN224@fnActivate
$LN223@fnActivate:
	mov	DWORD PTR tv243[ebp], -1
$LN224@fnActivate:
	mov	eax, DWORD PTR tv243[ebp]
	mov	DWORD PTR tv244[ebp], eax
$LN226@fnActivate:
	cmp	DWORD PTR tv244[ebp], 0
	jne	SHORT $LN57@fnActivate

; 10741:                   lpViewOI->lActivateControl = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+48], eax
$LN57@fnActivate:

; 10742: 
; 10743:                break;

	jmp	$LN4@fnActivate
$LN58@fnActivate:

; 10744: 
; 10745:             case 'E':
; 10746:                if ( zstrcmp( szWorkString, "ETAG" ) == 0 )

	movsx	eax, BYTE PTR _szWorkString$[ebp]
	movsx	ecx, BYTE PTR $SG17247
	cmp	eax, ecx
	jne	SHORT $LN229@fnActivate
	push	OFFSET $SG17248
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv262[ebp], eax
	jmp	SHORT $LN230@fnActivate
$LN229@fnActivate:
	movsx	eax, BYTE PTR _szWorkString$[ebp]
	movsx	ecx, BYTE PTR $SG17249
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN227@fnActivate
	mov	DWORD PTR tv261[ebp], 1
	jmp	SHORT $LN228@fnActivate
$LN227@fnActivate:
	mov	DWORD PTR tv261[ebp], -1
$LN228@fnActivate:
	mov	edx, DWORD PTR tv261[ebp]
	mov	DWORD PTR tv262[ebp], edx
$LN230@fnActivate:
	cmp	DWORD PTR tv262[ebp], 0
	jne	SHORT $LN59@fnActivate

; 10747:                   lpEntityInstance->lTag = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+46], eax
	jmp	$LN60@fnActivate
$LN59@fnActivate:

; 10748:                else
; 10749:                if ( zstrcmp( szWorkString, "EKEY" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR $SG17251
	cmp	edx, eax
	jne	SHORT $LN233@fnActivate
	push	OFFSET $SG17252
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv280[ebp], eax
	jmp	SHORT $LN234@fnActivate
$LN233@fnActivate:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR $SG17253
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN231@fnActivate
	mov	DWORD PTR tv279[ebp], 1
	jmp	SHORT $LN232@fnActivate
$LN231@fnActivate:
	mov	DWORD PTR tv279[ebp], -1
$LN232@fnActivate:
	mov	ecx, DWORD PTR tv279[ebp]
	mov	DWORD PTR tv280[ebp], ecx
$LN234@fnActivate:
	cmp	DWORD PTR tv280[ebp], 0
	jne	SHORT $LN60@fnActivate

; 10750:                   lpEntityInstance->ulKey = (zULONG) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+50], eax
$LN60@fnActivate:

; 10751: 
; 10752:                break;

	jmp	$LN4@fnActivate
$LN62@fnActivate:

; 10753: 
; 10754:             case 'O':
; 10755:                if ( zstrcmp( szWorkString, "OITAG" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR $SG17257
	cmp	edx, eax
	jne	SHORT $LN237@fnActivate
	push	OFFSET $SG17258
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN238@fnActivate
$LN237@fnActivate:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR $SG17259
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN235@fnActivate
	mov	DWORD PTR tv297[ebp], 1
	jmp	SHORT $LN236@fnActivate
$LN235@fnActivate:
	mov	DWORD PTR tv297[ebp], -1
$LN236@fnActivate:
	mov	ecx, DWORD PTR tv297[ebp]
	mov	DWORD PTR tv298[ebp], ecx
$LN238@fnActivate:
	cmp	DWORD PTR tv298[ebp], 0
	jne	SHORT $LN63@fnActivate

; 10756:                   lpViewOI->lTag = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+52], eax
	jmp	$LN4@fnActivate
$LN63@fnActivate:

; 10757:                else
; 10758:                if ( zstrcmp( szWorkString, "OIFLAGS" ) == 0 )

	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR $SG17261
	cmp	edx, eax
	jne	SHORT $LN241@fnActivate
	push	OFFSET $SG17262
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv316[ebp], eax
	jmp	SHORT $LN242@fnActivate
$LN241@fnActivate:
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	movsx	eax, BYTE PTR $SG17263
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN239@fnActivate
	mov	DWORD PTR tv315[ebp], 1
	jmp	SHORT $LN240@fnActivate
$LN239@fnActivate:
	mov	DWORD PTR tv315[ebp], -1
$LN240@fnActivate:
	mov	ecx, DWORD PTR tv315[ebp]
	mov	DWORD PTR tv316[ebp], ecx
$LN242@fnActivate:
	cmp	DWORD PTR tv316[ebp], 0
	jne	SHORT $LN4@fnActivate

; 10759:                {
; 10760:                   zULONG uFlags = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _uFlags$11[ebp], eax

; 10761: 
; 10762:                   // If zOI_ISLOCKED flag is set then the OI has pessimistic
; 10763:                   // locks set.
; 10764:                   if ( uFlags & zOI_ISLOCKED )

	mov	eax, DWORD PTR _uFlags$11[ebp]
	and	eax, 1
	je	SHORT $LN66@fnActivate

; 10765:                      lpViewOI->bIsLocked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN66@fnActivate:

; 10766: 
; 10767:                   if ( uFlags & zOI_READONLY )

	mov	ecx, DWORD PTR _uFlags$11[ebp]
	and	ecx, 2
	je	SHORT $LN4@fnActivate

; 10768:                      lpView->bReadOnly = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$LN4@fnActivate:

; 10769:                }
; 10770: 
; 10771:                break;
; 10772:          }
; 10773:       }

	jmp	$LN55@fnActivate
$LN54@fnActivate:

; 10774:       else
; 10775:       if ( pchLine[ 0 ] == 'e' )  // Entity type

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 101				; 00000065H
	jne	$LN68@fnActivate

; 10776:       {
; 10777:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12

; 10778:          if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN70@fnActivate

; 10779:             nLevel = (zSHORT) zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nLevel$[ebp], ax
	jmp	SHORT $LN71@fnActivate
$LN70@fnActivate:

; 10780:          else
; 10781:             nLevel = (zSHORT) zatol( pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nLevel$[ebp], ax
$LN71@fnActivate:

; 10782: 
; 10783:          if ( *plControl & zINCREMENTAL )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 65536				; 00010000H
	je	$LN10@fnActivate
$LN6@fnActivate:

; 10784:          {
; 10785:             while ( pchLine[ 0 ] != ',' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 44					; 0000002cH
	je	SHORT $LN7@fnActivate

; 10786:                pchLine++;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx
	jmp	SHORT $LN6@fnActivate
$LN7@fnActivate:

; 10787: 
; 10788:             pchLine++;

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchLine$[ebp], edx

; 10789:             lPrevIndicators = lIndicators;

	mov	eax, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR _lPrevIndicators$[ebp], eax

; 10790: 
; 10791:             if ( *plControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	je	SHORT $LN73@fnActivate

; 10792:                lIndicators = (zLONG) zxtob( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lIndicators$[ebp], eax
	jmp	SHORT $LN10@fnActivate
$LN73@fnActivate:

; 10793:             else
; 10794:                lIndicators = (zLONG) zatob( pchLine ); /* HH, 14.10.96 */

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lIndicators$[ebp], eax
$LN10@fnActivate:

; 10795:          }
; 10796: 
; 10797:          for ( ; ; )  // Validate view entity received
; 10798:          {
; 10799:             zSHORT nHierNbr;
; 10800: 
; 10801:             lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10802:             lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10803: 
; 10804:             // If the root cursor is not the first cursor, skip ViewEntities
; 10805:             // until we get to the entity matching the root cursor
; 10806:             if ( lpViewEntityCsr != zGETPTR( lpViewCsr->hFirstOD_EntityCsr ) )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], eax
	je	SHORT $LN75@fnActivate

; 10807:             {
; 10808:                LPVIEWENTITYCSR lpSearchViewEntityCsr;
; 10809: 
; 10810:                lpSearchViewEntityCsr =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntityCsr$12[ebp], eax
$LN11@fnActivate:

; 10811:                                     zGETPTR( lpViewCsr->hFirstOD_EntityCsr );
; 10812: 
; 10813:                while ( lpSearchViewEntityCsr != lpViewEntityCsr )

	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$12[ebp]
	cmp	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	je	SHORT $LN75@fnActivate

; 10814:                {
; 10815:                   lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10816:                   lpSearchViewEntityCsr++;

	mov	ecx, DWORD PTR _lpSearchViewEntityCsr$12[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpSearchViewEntityCsr$12[ebp], ecx

; 10817:                }

	jmp	SHORT $LN11@fnActivate
$LN75@fnActivate:

; 10818:             }
; 10819: 
; 10820:             if ( *plControl & zCOMPRESSED )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 131072				; 00020000H
	je	SHORT $LN13@fnActivate

; 10821:                nHierNbr = (zSHORT) zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nHierNbr$14[ebp], ax
$LN13@fnActivate:

; 10822: 
; 10823:             while ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	$LN14@fnActivate

; 10824:             {
; 10825:                if ( *plControl & zCOMPRESSED )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 131072				; 00020000H
	je	SHORT $LN77@fnActivate

; 10826:                {
; 10827:                   if ( lpViewEntity->nHierNbr == nHierNbr )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	movsx	eax, WORD PTR _nHierNbr$14[ebp]
	cmp	edx, eax
	jne	SHORT $LN79@fnActivate

; 10828:                      break;

	jmp	$LN14@fnActivate
$LN79@fnActivate:

; 10829:                }

	jmp	SHORT $LN78@fnActivate
$LN77@fnActivate:

; 10830:                else
; 10831:                if ( zstrcmp( lpViewEntity->szName, szWorkString ) == 0 )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	movsx	eax, BYTE PTR _szWorkString$[ebp]
	cmp	edx, eax
	jne	SHORT $LN245@fnActivate
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv417[ebp], eax
	jmp	SHORT $LN246@fnActivate
$LN245@fnActivate:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	movsx	edx, BYTE PTR _szWorkString$[ebp]
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN243@fnActivate
	mov	DWORD PTR tv416[ebp], 1
	jmp	SHORT $LN244@fnActivate
$LN243@fnActivate:
	mov	DWORD PTR tv416[ebp], -1
$LN244@fnActivate:
	mov	eax, DWORD PTR tv416[ebp]
	mov	DWORD PTR tv417[ebp], eax
$LN246@fnActivate:
	cmp	DWORD PTR tv417[ebp], 0
	jne	SHORT $LN78@fnActivate

; 10832:                   break;

	jmp	SHORT $LN14@fnActivate
$LN78@fnActivate:

; 10833: 
; 10834:                lpViewEntity    = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10835:                lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10836:             }

	jmp	$LN13@fnActivate
$LN14@fnActivate:

; 10837: 
; 10838:             if ( lpViewEntityCsr == 0 )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	jne	SHORT $LN81@fnActivate

; 10839:             {
; 10840:                // OK, No cursor was found in the current view, if there are
; 10841:                // outstanding subobjects, do a reset and try again to find
; 10842:                // the entity
; 10843:                if ( lpViewCsr->hFirstViewSubobject )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $LN83@fnActivate

; 10844:                   fnResetViewFromSubobject( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnResetViewFromSubobject
	add	esp, 4
	jmp	SHORT $LN84@fnActivate
$LN83@fnActivate:

; 10845:                else
; 10846:                {
; 10847:                   lpViewEntity = 0;

	mov	DWORD PTR _lpViewEntity$[ebp], 0

; 10848:                   break;  // Ouch, Entity does not exist, give up

	jmp	$LN9@fnActivate
$LN84@fnActivate:

; 10849:                }
; 10850:             }

	jmp	$LN82@fnActivate
$LN81@fnActivate:

; 10851:             else
; 10852:             {
; 10853:                // We've found a cursor which matches the entity type
; 10854:                // now check to see if a SetViewToSubobject or a reset is
; 10855:                // needed to create the entity at the appropriate level
; 10856:                if ( lpViewEntityCsr->nLevel == nLevel )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	edx, eax
	jne	SHORT $LN85@fnActivate

; 10857:                {
; 10858:                   break;

	jmp	$LN9@fnActivate

; 10859:                }

	jmp	$LN82@fnActivate
$LN85@fnActivate:

; 10860:                else
; 10861:                if ( lpViewEntityCsr->nLevel > nLevel )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	edx, eax
	jle	SHORT $LN87@fnActivate

; 10862:                {
; 10863:                   if ( lpViewCsr->hFirstViewSubobject == 0 )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	jne	SHORT $LN15@fnActivate

; 10864:                      break;

	jmp	$LN9@fnActivate
$LN15@fnActivate:

; 10865: 
; 10866:                   while ( lpViewEntityCsr->nLevel > nLevel &&

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN16@fnActivate
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $LN16@fnActivate

; 10867:                           lpViewCsr->hFirstViewSubobject )
; 10868:                   {
; 10869:                      fnResetViewFromSubobject( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10870:                   }

	jmp	SHORT $LN15@fnActivate
$LN16@fnActivate:

; 10871:                }

	jmp	SHORT $LN82@fnActivate
$LN87@fnActivate:

; 10872:                else
; 10873:                {
; 10874:                   // The view entity csr level is < the entity level.
; 10875:                   // In this case, the current (last) instance must be the
; 10876:                   // parent of the instance we are about to create and
; 10877:                   // it must have recursive behaviour. Otherwise we will
; 10878:                   // drop out and issue a level error
; 10879:                   if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN90@fnActivate

; 10880:                   {
; 10881:                      LPVIEWENTITY lpWkViewEntity =

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$5[ebp], eax

; 10882:                                  zGETPTR( lpEntityInstance->hViewEntity );
; 10883: 
; 10884:                      if ( lpWkViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpWkViewEntity$5[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN90@fnActivate

; 10885:                         fnSetViewToSubobject( lpView, lpWkViewEntity, 0 );

	push	0
	mov	edx, DWORD PTR _lpWkViewEntity$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
$LN90@fnActivate:

; 10886:                   }
; 10887: 
; 10888:                   break;

	jmp	SHORT $LN9@fnActivate
$LN82@fnActivate:

; 10889:                }
; 10890:             }  // if ( lpViewEntityCsr == 0 )...else...
; 10891:          }  // for ( ; ; )...

	jmp	$LN10@fnActivate
$LN9@fnActivate:

; 10892: 
; 10893:          bSkipAttributes = FALSE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 0

; 10894: 
; 10895:          if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	$LN92@fnActivate

; 10896:          {
; 10897:             // Let's at least trace it out.
; 10898:             TraceLineS( "(WARNING) Couldn't find entity ", szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	push	OFFSET $SG17292
	call	_TraceLineS@8

; 10899:             TraceLineS( "(WARNING) in LOD ", lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG17293
	call	_TraceLineS@8

; 10900: 
; 10901:             if ( bIgnoreEntityErrors == FALSE || nLevel == 1 )

	movzx	eax, BYTE PTR _bIgnoreEntityErrors$[ebp]
	test	eax, eax
	je	SHORT $LN95@fnActivate
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN94@fnActivate
$LN95@fnActivate:

; 10902:             {
; 10903:                //  "KZOEE074 - Invalid Entity name on line "
; 10904:                (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) szWorkString, 0, 74 );

	push	74					; 0000004aH
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10905:                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 10906:                break;

	jmp	$LN3@fnActivate
$LN94@fnActivate:

; 10907:             }
; 10908: 
; 10909:             nErrorEntityLvl = nLevel;

	mov	ax, WORD PTR _nLevel$[ebp]
	mov	WORD PTR _nErrorEntityLvl$[ebp], ax

; 10910:             nErrorEntityCnt++;

	mov	cx, WORD PTR _nErrorEntityCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nErrorEntityCnt$[ebp], cx

; 10911:          }

	jmp	$LN93@fnActivate
$LN92@fnActivate:

; 10912:          else
; 10913:          if ( *plControl & zACTIVATE_ROOTONLY && nLevel > 1 )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 268435456				; 10000000H
	je	SHORT $LN96@fnActivate
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 1
	jle	SHORT $LN96@fnActivate

; 10914:          {
; 10915:             // Current entity is not a root and user indicated that she only
; 10916:             // wants roots.  Set flag to indicate we want to skip setting
; 10917:             // attribute values.
; 10918:             bSkipAttributes = TRUE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 1

; 10919:             continue;

	jmp	$LN2@fnActivate

; 10920:          }

	jmp	$LN93@fnActivate
$LN96@fnActivate:

; 10921:          else
; 10922:          if ( lpViewEntityCsr->nLevel != nLevel )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	je	SHORT $LN98@fnActivate

; 10923:          {
; 10924:             // if the view cursor level does not equal the entity
; 10925:             // level coming in, issue an error
; 10926:             //  "KZOEE075 - Invalid Entity level on line "
; 10927:             (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) szWorkString, 0, 75 );

	push	75					; 0000004bH
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 10928:             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 10929:             break;

	jmp	$LN3@fnActivate

; 10930:          }

	jmp	SHORT $LN93@fnActivate
$LN98@fnActivate:

; 10931:          else
; 10932:          {
; 10933:             if ( nLevel == 1 && lpViewEntityCsr->hEntityInstance &&

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	SHORT $LN100@fnActivate
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN100@fnActivate
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 1
	jne	SHORT $LN100@fnActivate

; 10934:                  lpViewOI->bMultipleRootLevels == FALSE )
; 10935:             {
; 10936:                // Doing this stuff means that there are multiple level 1
; 10937:                // roots in the the file, but that the user has requested
; 10938:                // activation of the the instance with zSINGLE rather than
; 10939:                // zMULTIPLE.  We will act like the EOF condition has
; 10940:                // occurred and set return code to indicate that we found
; 10941:                // multiple roots.
; 10942:                nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 10943:                bSkipAttributes = TRUE;

	mov	BYTE PTR _bSkipAttributes$[ebp], 1

; 10944:                continue;

	jmp	$LN2@fnActivate

; 10945:             }

	jmp	SHORT $LN93@fnActivate
$LN100@fnActivate:

; 10946:             else
; 10947:             {
; 10948:                nRC = fnCreateEntity( lpView, lpViewEntity,

	push	0
	push	3
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 10949:                                      lpViewEntityCsr, zPOS_AFTER, 0 );
; 10950:                if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN102@fnActivate

; 10951:                   break;

	jmp	$LN3@fnActivate
$LN102@fnActivate:

; 10952: 
; 10953:                nErrorEntityLvl = 0;

	xor	eax, eax
	mov	WORD PTR _nErrorEntityLvl$[ebp], ax
$LN93@fnActivate:

; 10954:             }
; 10955:          }
; 10956: 
; 10957:          // The current entity is compressed if:
; 10958:          // o  The portable file is stored in compressed format.
; 10959:          // o  The max size of all the attributes for the entity is smaller
; 10960:          //    then the buffer we set up to hold all the attribute values.
; 10961:          bEntityIsCompressed = (*plControl & zCOMPRESSED) &&

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	je	SHORT $LN247@fnActivate
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+203], 10000		; 00002710H
	jae	SHORT $LN247@fnActivate
	mov	DWORD PTR tv505[ebp], 1
	jmp	SHORT $LN248@fnActivate
$LN247@fnActivate:
	mov	DWORD PTR tv505[ebp], 0
$LN248@fnActivate:
	mov	cl, BYTE PTR tv505[ebp]
	mov	BYTE PTR _bEntityIsCompressed$[ebp], cl

; 10962:                                (lpViewEntity->ulMaxLth < zENTITY_BUFFER_SIZE);
; 10963: 
; 10964:          if ( nErrorEntityLvl == 0 )

	movsx	edx, WORD PTR _nErrorEntityLvl$[ebp]
	test	edx, edx
	jne	$LN103@fnActivate

; 10965:          {
; 10966:             // if this is not the first instance, set the indicators on
; 10967:             // the previous instance. NOTE this is done after all updates
; 10968:             // so the update flag can be reset!
; 10969:             if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN105@fnActivate

; 10970:             {
; 10971:                if ( *plControl & zINCREMENTAL )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 65536				; 00010000H
	je	$LN106@fnActivate

; 10972:                {
; 10973:                   lpEntityInstance->u.nIndicators = lPrevIndicators;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lPrevIndicators$[ebp]
	mov	DWORD PTR [edx+6], eax

; 10974:                   lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -257				; fffffeffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 10975: 
; 10976:                   // A hack to make sure that a delete/excluded entity is
; 10977:                   // flagged as hidden.  This tries to fix a bug.
; 10978:                   if ( lpEntityInstance->u.nInd.bDeleted  ||

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN109@fnActivate
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	je	SHORT $LN108@fnActivate
$LN109@fnActivate:

; 10979:                        lpEntityInstance->u.nInd.bExcluded )
; 10980:                   {
; 10981:                      lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN108@fnActivate:

; 10982:                   }
; 10983: 
; 10984:                   if ( lpEntityInstance->u.nInd.bCreated  ||
; 10985:                        lpEntityInstance->u.nInd.bDeleted  ||
; 10986:                        lpEntityInstance->u.nInd.bIncluded ||
; 10987:                        lpEntityInstance->u.nInd.bExcluded ||

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN111@fnActivate
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN111@fnActivate
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN111@fnActivate
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN111@fnActivate
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN110@fnActivate
$LN111@fnActivate:

; 10988:                        lpEntityInstance->u.nInd.bUpdated )
; 10989:                   {
; 10990:                      bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$LN110@fnActivate:

; 10991:                   }
; 10992:                }

	jmp	SHORT $LN105@fnActivate
$LN106@fnActivate:

; 10993:                else
; 10994:                   lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN105@fnActivate:

; 10995:             }
; 10996: 
; 10997:             // Set lpEntityInstance to instance just created.
; 10998:             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 10999:             *pRelinkBufferPtr = (zLONG) lpEntityInstance;

	mov	edx, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx], eax

; 11000:             pRelinkBufferPtr++;

	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], ecx

; 11001:             lEntityCnt++;

	mov	edx, DWORD PTR _lEntityCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lEntityCnt$[ebp], edx

; 11002:             lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 11003:             lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 11004:          }

	jmp	SHORT $LN104@fnActivate
$LN103@fnActivate:

; 11005:          else
; 11006:          {
; 11007:             *pRelinkBufferPtr = 0;

	mov	eax, DWORD PTR _pRelinkBufferPtr$[ebp]
	mov	DWORD PTR [eax], 0

; 11008:             pRelinkBufferPtr++;

	mov	ecx, DWORD PTR _pRelinkBufferPtr$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pRelinkBufferPtr$[ebp], ecx

; 11009:             lEntityCnt++;

	mov	edx, DWORD PTR _lEntityCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lEntityCnt$[ebp], edx

; 11010: 
; 11011:             // If we're ignoring errors then set the error code back to 0
; 11012:             // so that we can keep processing entities.
; 11013:             if ( bIgnoreEntityErrors )

	movzx	eax, BYTE PTR _bIgnoreEntityErrors$[ebp]
	test	eax, eax
	je	SHORT $LN104@fnActivate

; 11014:                nErrorEntityLvl = 0;

	xor	ecx, ecx
	mov	WORD PTR _nErrorEntityLvl$[ebp], cx
$LN104@fnActivate:

; 11015:          }
; 11016:       }  // if ( pchLine[ 0 ] == 'e' )...

	jmp	$LN55@fnActivate
$LN68@fnActivate:

; 11017:       else
; 11018:       if ( pchLine[ 0 ] == 'a' && lpViewEntity )  // Attrib and entity exists

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 97					; 00000061H
	jne	$LN113@fnActivate
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$LN113@fnActivate

; 11019:       {
; 11020:          LPATTRIBFLAGS     lpAttribFlags;
; 11021:          AttribFlagsRecord AttribFlags;
; 11022: 
; 11023:          if ( bEntityIsCompressed && pchLine[ 1 ] == ' ' )

	movzx	eax, BYTE PTR _bEntityIsCompressed$[ebp]
	test	eax, eax
	je	$LN115@fnActivate
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	$LN115@fnActivate

; 11024:          {
; 11025:             zPCHAR pchStart;
; 11026: 
; 11027:             // The entity is stored in a compressed format.  The line we just
; 11028:             // read contains an 'a' followed by the length of all the attribute
; 11029:             // data in hex.
; 11030:             ulLth = zxtol( pchLine + 2 );

	push	16					; 00000010H
	push	0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 2
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _ulLth$[ebp], eax

; 11031:             nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11032:             if ( nEOF != 1 )

	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, 1
	je	SHORT $LN116@fnActivate

; 11033:             {
; 11034:                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 11035:                break;

	jmp	$LN3@fnActivate
$LN116@fnActivate:

; 11036:             }
; 11037: 
; 11038:             pchStart = pchLine;

	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchStart$1[ebp], edx

; 11039: 
; 11040:             // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11041:             if ( bSkipAttributes )

	movzx	eax, BYTE PTR _bSkipAttributes$[ebp]
	test	eax, eax
	je	SHORT $LN117@fnActivate

; 11042:                continue;

	jmp	$LN2@fnActivate
$LN117@fnActivate:

; 11043: 
; 11044:             // pchLine should now point to a buffer containing all the
; 11045:             // attribute values.  Copy each value to the entity.
; 11046:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN19@fnActivate
$LN17@fnActivate:

; 11048:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN19@fnActivate:

; 11047:                   lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN18@fnActivate

; 11049:             {
; 11050:                if ( lpViewAttrib->szDerivedOper[ 0 ] &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+213]
	test	edx, edx
	je	SHORT $LN118@fnActivate
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	jne	SHORT $LN118@fnActivate

; 11051:                     lpViewAttrib->bPersist == FALSE )
; 11052:                {
; 11053:                   continue;

	jmp	SHORT $LN17@fnActivate
$LN118@fnActivate:

; 11054:                }
; 11055: 
; 11056:                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN119@fnActivate

; 11057:                   continue;

	jmp	SHORT $LN17@fnActivate
$LN119@fnActivate:

; 11058: 
; 11059:                if ( *pchLine == 0 )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	$LN120@fnActivate

; 11060:                {
; 11061:                   // Attribute value is null.  Skip over 0.
; 11062:                   pchLine++;

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 11063: 
; 11064:                   // Make sure that a record (data stick exists).
; 11065:                   if ( (lpViewAttrib->bPersist &&
; 11066:                         lpEntityInstance->hPersistRecord == 0) ||

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	je	SHORT $LN124@fnActivate
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+60], 0
	je	SHORT $LN123@fnActivate
$LN124@fnActivate:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN122@fnActivate
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+64], 0
	jne	SHORT $LN122@fnActivate
$LN123@fnActivate:

; 11067:                        (lpViewAttrib->bPersist == FALSE &&
; 11068:                         lpEntityInstance->hNonPersistRecord == 0) )
; 11069:                   {
; 11070:                      // Set a null value so that the record gets created.
; 11071:                      if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11072:                                                     lpViewAttrib,
; 11073:                                                     "", 0 ) != 0 )

	push	0
	push	OFFSET $SG17326
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN122@fnActivate

; 11074:                      {
; 11075:                         nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11076:                         break;

	jmp	$LN18@fnActivate
$LN122@fnActivate:

; 11077:                      }
; 11078:                   }
; 11079:                }

	jmp	$LN121@fnActivate
$LN120@fnActivate:

; 11080:                else
; 11081:                {
; 11082:                   if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	SHORT $LN126@fnActivate

; 11083:                   {
; 11084:                      zLONG l;
; 11085: 
; 11086:                      l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$2[ebp], eax

; 11087:                      if ( fnSetAttributeFromInteger( lpView, lpViewEntityCsr,
; 11088:                                                      lpViewAttrib, l ) != 0 )

	mov	eax, DWORD PTR _l$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromInteger
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN128@fnActivate

; 11089:                      {
; 11090:                         nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11091:                         break;

	jmp	$LN18@fnActivate
$LN128@fnActivate:

; 11092:                      }
; 11093:                   }

	jmp	SHORT $LN127@fnActivate
$LN126@fnActivate:

; 11094:                   else
; 11095:                   {
; 11096:                      if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11097:                                                     lpViewAttrib,
; 11098:                                                     pchLine, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN127@fnActivate

; 11099:                      {
; 11100:                         nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11101:                         break;

	jmp	$LN18@fnActivate
$LN127@fnActivate:

; 11102:                      }
; 11103:                   }
; 11104: 
; 11105:                   pchLine += zstrlen( pchLine ) + 1;

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchLine$[ebp], edx
$LN121@fnActivate:

; 11106:                }
; 11107: 
; 11108:                // Now set the attribute flags.
; 11109:                if ( (*plControl & zINCREMENTAL) &&

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 65536				; 00010000H
	je	SHORT $LN130@fnActivate
	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 33554432				; 02000000H
	je	SHORT $LN130@fnActivate

; 11110:                     (*plControl & zATTRIBFLAGS) )
; 11111:                {
; 11112:                   lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$19[ebp], eax

; 11113:                                                        lpViewAttrib );
; 11114:                   lpAttribFlags->u.uFlags = zxtob( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpAttribFlags$19[ebp]
	mov	DWORD PTR [ecx], eax

; 11115: 
; 11116:                   pchLine += zstrlen( pchLine ) + 1;

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchLine$[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchLine$[ebp], edx
$LN130@fnActivate:

; 11117:                }
; 11118:             }

	jmp	$LN17@fnActivate
$LN18@fnActivate:

; 11119: 
; 11120:             if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN131@fnActivate

; 11121:                break;

	jmp	$LN3@fnActivate
$LN131@fnActivate:

; 11122: 
; 11123:             // Continue with the next line in the file.
; 11124:             continue;

	jmp	$LN2@fnActivate
$LN115@fnActivate:

; 11125: 
; 11126:          } // if ( bEntityIsCompressed )...
; 11127: 
; 11128:          // If we get here, then bEntityIsCompressed is FALSE.  But it's still
; 11129:          // possible that the OI is stored in a compressed format--it's just
; 11130:          // that the attributes couldn't be squeezed into one line.  If the OI
; 11131:          // is compressed, then the attribute names are stored as the XVA
; 11132:          // tokens instead of the names.
; 11133: 
; 11134:          // First get the attribute name/number into szWorkString.  The end of
; 11135:          // the name/number is indicated when we find a space or comma.
; 11136:          for ( k = 0, pchLine++;

	mov	DWORD PTR _k$[ebp], 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx
	jmp	SHORT $LN22@fnActivate
$LN20@fnActivate:

; 11138:                k++ )

	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
$LN22@fnActivate:

; 11137:                pchLine[ k ] && pchLine[ k ] != ' ' && pchLine[ k ] != ',';

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN21@fnActivate
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN21@fnActivate
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, DWORD PTR _k$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	je	SHORT $LN21@fnActivate

; 11139:          {
; 11140:             szWorkString[ k ] = pchLine[ k ];

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR _szWorkString$[ebp+ecx], dl

; 11141:          }

	jmp	SHORT $LN20@fnActivate
$LN21@fnActivate:

; 11142: 
; 11143:          // Terminate szWorkString.
; 11144:          szWorkString[ k ] = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR $T10[ebp], eax
	cmp	DWORD PTR $T10[ebp], 256		; 00000100H
	jae	SHORT $LN249@fnActivate
	jmp	SHORT $LN250@fnActivate
$LN249@fnActivate:
	call	___report_rangecheckfailure
$LN250@fnActivate:
	mov	ecx, DWORD PTR $T10[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 0

; 11145: 
; 11146:          // If the next char in the line is a comma then we also need to
; 11147:          // retrieve the attribute flags.
; 11148:          if ( pchLine[ k ] == ',' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	$LN132@fnActivate

; 11149:          {
; 11150:             zCHAR  szAttribFlags[ 12 ];
; 11151:             zSHORT j;
; 11152: 
; 11153:             k++;  // Skip over the ','.

	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx

; 11154:             j = 0;

	xor	edx, edx
	mov	WORD PTR _j$20[ebp], dx
$LN23@fnActivate:

; 11155:             while ( pchLine[ k ] && pchLine[ k ] != ' ' )

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN24@fnActivate
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN24@fnActivate

; 11156:                szAttribFlags[ j++ ] = pchLine[ k++ ];

	movsx	ecx, WORD PTR _j$20[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szAttribFlags$22[ebp+ecx], al
	mov	cx, WORD PTR _j$20[ebp]
	add	cx, 1
	mov	WORD PTR _j$20[ebp], cx
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
	jmp	SHORT $LN23@fnActivate
$LN24@fnActivate:

; 11157: 
; 11158:             szAttribFlags[ j ] = 0;

	movsx	eax, WORD PTR _j$20[ebp]
	mov	DWORD PTR $T9[ebp], eax
	cmp	DWORD PTR $T9[ebp], 12			; 0000000cH
	jae	SHORT $LN251@fnActivate
	jmp	SHORT $LN252@fnActivate
$LN251@fnActivate:
	call	___report_rangecheckfailure
$LN252@fnActivate:
	mov	ecx, DWORD PTR $T9[ebp]
	mov	BYTE PTR _szAttribFlags$22[ebp+ecx], 0

; 11159: 
; 11160:             AttribFlags.u.uFlags = zxtob( szAttribFlags );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _szAttribFlags$22[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _AttribFlags$18[ebp], eax

; 11161:          }

	jmp	SHORT $LN133@fnActivate
$LN132@fnActivate:

; 11162:          else
; 11163:          {
; 11164:             // If flags aren't specified then they are assumed 0 *unless* this
; 11165:             // OI wasn't stored with attrib flags (this means it was stored
; 11166:             // with a pre-10a version).  In this case we have to assume that
; 11167:             // every attribute has been changed.
; 11168:             AttribFlags.u.uFlags = 0; // Turn off all flags.

	mov	DWORD PTR _AttribFlags$18[ebp], 0

; 11169:             if ( (*plControl & zATTRIBFLAGS ) == 0 )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 33554432				; 02000000H
	jne	SHORT $LN133@fnActivate

; 11170:             {
; 11171:                // No attrib flags--turn on 'changed' bit.
; 11172:                AttribFlags.u.bFlags.bUpdated = TRUE;

	mov	edx, DWORD PTR _AttribFlags$18[ebp]
	or	edx, 2
	mov	DWORD PTR _AttribFlags$18[ebp], edx
$LN133@fnActivate:

; 11173:             }
; 11174:          }
; 11175: 
; 11176:          if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	je	$LN135@fnActivate

; 11177:          {
; 11178:             zLONG lXVATok;
; 11179: 
; 11180:             // Point pchLine to first char of attribute value if there is
; 11181:             // more info after the attribute name.
; 11182:             if ( pchLine[ k ] )

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN137@fnActivate

; 11183:                pchLine += k + 1;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchLine$[ebp]
	lea	eax, DWORD PTR [edx+ecx+1]
	mov	DWORD PTR _pchLine$[ebp], eax
$LN137@fnActivate:

; 11184: 
; 11185:             lXVATok = zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lXVATok$4[ebp], eax

; 11186: 
; 11187:             // Look for the attribute that matches the XVA token.
; 11188:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN27@fnActivate
$LN25@fnActivate:

; 11190:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN27@fnActivate:

; 11189:                   lpViewAttrib && lpViewAttrib->lXVAAttTok != lXVATok;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN26@fnActivate
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+181]
	cmp	ecx, DWORD PTR _lXVATok$4[ebp]
	je	SHORT $LN26@fnActivate

; 11191:             {
; 11192:                // nothing needs to be done here
; 11193:             }

	jmp	SHORT $LN25@fnActivate
$LN26@fnActivate:

; 11194:          }

	jmp	$LN136@fnActivate
$LN135@fnActivate:

; 11195:          else
; 11196:          {
; 11197:             // Point pchLine to first char of attribute value if there is
; 11198:             // more info after the attribute name.
; 11199: 
; 11200:             // Skip over any blanks that filled out the name.
; 11201:             if ( pchLine[ k ] )

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _k$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN138@fnActivate

; 11202:             {
; 11203:                if ( k < 9 )

	cmp	DWORD PTR _k$[ebp], 9
	jge	SHORT $LN139@fnActivate

; 11204:                   pchLine += 10;

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _pchLine$[ebp], ecx
	jmp	SHORT $LN138@fnActivate
$LN139@fnActivate:

; 11205:                else
; 11206:                   pchLine += k + 1;

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pchLine$[ebp]
	lea	ecx, DWORD PTR [eax+edx+1]
	mov	DWORD PTR _pchLine$[ebp], ecx
$LN138@fnActivate:

; 11207:             }
; 11208: 
; 11209:             // Look for the attribute that matches the attribute name.
; 11210:             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN30@fnActivate
$LN28@fnActivate:

; 11212:                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN30@fnActivate:

; 11211:                   lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN136@fnActivate

; 11213:             {
; 11214:                if ( zstrcmpi( lpViewAttrib->szName, szWorkString ) == 0 )

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN141@fnActivate

; 11215:                   break;

	jmp	SHORT $LN136@fnActivate
$LN141@fnActivate:

; 11216:             }

	jmp	SHORT $LN28@fnActivate
$LN136@fnActivate:

; 11217:          }
; 11218: 
; 11219:          // If entity not found return error.
; 11220:          if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN142@fnActivate

; 11221:          {
; 11222:             if ( bIgnoreAttribErrors == FALSE )

	movzx	edx, BYTE PTR _bIgnoreAttribErrors$[ebp]
	test	edx, edx
	jne	SHORT $LN144@fnActivate

; 11223:             {
; 11224:                zCHAR sz[ 400 ];
; 11225: 
; 11226:                zstrcpy( sz, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _sz$21[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 11227:                zstrcat( sz, "." );

	push	OFFSET $SG17346
	lea	edx, DWORD PTR _sz$21[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 11228:                zstrcat( sz, szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$21[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 11229: 
; 11230:                //  "KZOEE104 - Invalid Attribute name for Entity"
; 11231:                (*lpfnStreamFunc)( lpView, lpvData, (zPPCHAR) sz, 0, 104 );

	push	104					; 00000068H
	push	0
	lea	edx, DWORD PTR _sz$21[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
$LN144@fnActivate:

; 11232: 
; 11233:                // DGC 10-4-95
; 11234:                // We no longer consider this an error worth bombing out.
; 11235:                // nRC = zCALL_ERROR;
; 11236:                // break;
; 11237:             }
; 11238: 
; 11239:             nErrorAttribCnt++;

	mov	dx, WORD PTR _nErrorAttribCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nErrorAttribCnt$[ebp], dx

; 11240:          }

	jmp	$LN143@fnActivate
$LN142@fnActivate:

; 11241:          else
; 11242:          if ( lpViewAttrib->cType == zTYPE_BLOB ||

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN147@fnActivate
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	$LN145@fnActivate
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 31					; 0000001fH
	jne	$LN145@fnActivate
$LN147@fnActivate:

; 11243:               (lpViewAttrib->cType == zTYPE_STRING &&
; 11244:                *pchLine == zSTRING_STORED_AS_BLOB) )
; 11245:          {
; 11246:             // If a string is stored with special characters (e.g. '\n') then
; 11247:             // is is stored as a blob.  This is indicated if the first char
; 11248:             // in pchLine is zSTRING_STORED_AS_BLOB.
; 11249:             if ( lpViewAttrib->cType == zTYPE_STRING &&

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN148@fnActivate
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 31					; 0000001fH
	jne	SHORT $LN148@fnActivate

; 11250:                  *pchLine == zSTRING_STORED_AS_BLOB )
; 11251:             {
; 11252:                pchLine++;  // Point pchLine past zSTRING_STORED_AS_BLOB.

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLine$[ebp], ecx

; 11253:                ulLth = zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11254:                if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN150@fnActivate

; 11255:                   nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$LN150@fnActivate:

; 11256:             }

	jmp	$LN149@fnActivate
$LN148@fnActivate:

; 11257:             else // must be blob, so need to check for encoding
; 11258:             {
; 11259:                ulLthDecoded = 0;

	mov	DWORD PTR _ulLthDecoded$[ebp], 0

; 11260:                if ( *pchLine == zBLOB_STORED_ENCODED )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 85					; 00000055H
	jne	$LN151@fnActivate

; 11261:                {
; 11262:                   pchLine++;  // point pchLine past zBLOB_STORED_ENCODED

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchLine$[ebp], eax

; 11263:                   ulLth = zatol( pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11264:                   if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$LN153@fnActivate

; 11265:                   {
; 11266:                      // If are ignoring attributes, just skip the encoded lines.
; 11267:                      if ( bSkipAttributes )

	movzx	edx, BYTE PTR _bSkipAttributes$[ebp]
	test	edx, edx
	je	SHORT $LN154@fnActivate

; 11268:                      {
; 11269:                         nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$LN31@fnActivate:

; 11270:                         while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN32@fnActivate

; 11271:                         {
; 11272:                            if ( *pchLine == 0x60 )  // terminating "`" line

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 96					; 00000060H
	jne	SHORT $LN156@fnActivate

; 11273:                               break;

	jmp	SHORT $LN32@fnActivate
$LN156@fnActivate:

; 11274: 
; 11275:                            nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11276:                         }

	jmp	SHORT $LN31@fnActivate
$LN32@fnActivate:

; 11277:                      }

	jmp	$LN153@fnActivate
$LN154@fnActivate:

; 11278:                      else
; 11279:                      {
; 11280:                         // Init the blob attribute to have a buffer for decoding.
; 11281:                         if ( fnSetAttributeFromBlob( lpView, lpViewEntityCsr,
; 11282:                                                      lpViewAttrib,
; 11283:                                                      0, ulLth ) != 0 )

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN157@fnActivate

; 11284:                         {
; 11285:                            nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11286:                            break;

	jmp	$LN3@fnActivate
$LN157@fnActivate:

; 11287:                         }
; 11288: 
; 11289:                         fnGetAddrForAttribute( &pchAttr, lpView, lpViewEntityCsr, 0,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttr$[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 11290:                                                lpViewAttrib );
; 11291: 
; 11292:                         // Now decode the blob lines until the 'zero length' line is found.
; 11293:                         uPos = 0;

	mov	DWORD PTR _uPos$[ebp], 0

; 11294:                         nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$LN33@fnActivate:

; 11295:                         while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN34@fnActivate

; 11296:                         {
; 11297:                            nRC = UUDECODE_NextLineToBuffer( pchLine, pchAttr, ulLth, &uPos );

	lea	edx, DWORD PTR _uPos$[ebp]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_UUDECODE_NextLineToBuffer@16
	mov	WORD PTR _nRC$[ebp], ax

; 11298:                            //TraceLineS( "Decoded Line: ", pchLine);
; 11299:                            if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN158@fnActivate

; 11300:                            {
; 11301:                               TraceLineI( "Error from UUDECODE_NextLineToBuffer: ", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG17361
	call	_TraceLineI@8

; 11302:                               nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11303:                               break;

	jmp	SHORT $LN34@fnActivate
$LN158@fnActivate:

; 11304:                            }
; 11305: 
; 11306:                            if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN159@fnActivate

; 11307:                               break;

	jmp	SHORT $LN34@fnActivate
$LN159@fnActivate:

; 11308: 
; 11309:                            ulLthDecoded = ulLthDecoded + nRC;

	movsx	ecx, WORD PTR _nRC$[ebp]
	add	ecx, DWORD PTR _ulLthDecoded$[ebp]
	mov	DWORD PTR _ulLthDecoded$[ebp], ecx

; 11310:                            nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11311:                         }

	jmp	$LN33@fnActivate
$LN34@fnActivate:

; 11312: 
; 11313:                         if ( ulLthDecoded != ulLth )

	mov	edx, DWORD PTR _ulLthDecoded$[ebp]
	cmp	edx, DWORD PTR _ulLth$[ebp]
	je	SHORT $LN153@fnActivate

; 11314:                         {
; 11315:                            TraceLineI( "UUDECODE length invalid: ", ulLthDecoded );

	mov	eax, DWORD PTR _ulLthDecoded$[ebp]
	push	eax
	push	OFFSET $SG17364
	call	_TraceLineI@8

; 11316:                            nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 11317:                            break;

	jmp	$LN3@fnActivate
$LN153@fnActivate:

; 11318:                         }
; 11319:                      }
; 11320:                   }
; 11321:                }

	jmp	SHORT $LN149@fnActivate
$LN151@fnActivate:

; 11322:                else
; 11323:                {
; 11324:                   ulLth = zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax

; 11325:                   if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN149@fnActivate

; 11326:                      nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );

	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax
$LN149@fnActivate:

; 11327:                }
; 11328:             }
; 11329: 
; 11330:          // ulLth = zatol( pchLine );
; 11331:             if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$LN162@fnActivate

; 11332:             {
; 11333:             // nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, ulLth, 0 );
; 11334:                if ( nEOF != 1 )

	movsx	ecx, WORD PTR _nEOF$[ebp]
	cmp	ecx, 1
	je	SHORT $LN164@fnActivate

; 11335:                {
; 11336:                   nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11337:                   break;

	jmp	$LN3@fnActivate
$LN164@fnActivate:

; 11338:                }
; 11339: 
; 11340:                lLineCount++;

	mov	eax, DWORD PTR _lLineCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lLineCount$[ebp], eax

; 11341: 
; 11342:                // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11343:                if ( bSkipAttributes )

	movzx	ecx, BYTE PTR _bSkipAttributes$[ebp]
	test	ecx, ecx
	je	SHORT $LN165@fnActivate

; 11344:                   continue;

	jmp	$LN2@fnActivate
$LN165@fnActivate:

; 11345: 
; 11346:                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN166@fnActivate

; 11347:                {
; 11348:                   if ( ulLthDecoded > 0 )

	cmp	DWORD PTR _ulLthDecoded$[ebp], 0
	jbe	SHORT $LN168@fnActivate

; 11349:                   {
; 11350:                      // Do nothing since it has been stored during decode
; 11351:                   }

	jmp	SHORT $LN169@fnActivate
$LN168@fnActivate:

; 11352:                   else
; 11353:                   {
; 11354:                      if ( fnSetAttributeFromBlob( lpView, lpViewEntityCsr,
; 11355:                                                   lpViewAttrib,
; 11356:                                                   pchLine, ulLth ) != 0 )

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetAttributeFromBlob
	add	esp, 20					; 00000014H
	cwde
	test	eax, eax
	je	SHORT $LN169@fnActivate

; 11357:                      {
; 11358:                         nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 11359:                         break;

	jmp	$LN3@fnActivate
$LN169@fnActivate:

; 11360:                      }
; 11361:                   }
; 11362:                }

	jmp	SHORT $LN167@fnActivate
$LN166@fnActivate:

; 11363:                else
; 11364:                {
; 11365:                   // PAS 03-09-2001 - x00 is no longer put at the end of
; 11366:                   //                  a string that was stored as a BLOB
; 11367:                   //                  (with length), so always terminate
; 11368:                   pchLine[ ulLth - 1 ] = 0;

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx-1], 0

; 11369:                   if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11370:                                                  lpViewAttrib,
; 11371:                                                  pchLine, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN167@fnActivate

; 11372:                   {
; 11373:                      nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11374:                      break;

	jmp	$LN3@fnActivate
$LN167@fnActivate:

; 11375:                   }
; 11376:                }
; 11377:             }

	jmp	SHORT $LN163@fnActivate
$LN162@fnActivate:

; 11378:             else
; 11379:                // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11380:                if ( bSkipAttributes )

	movzx	eax, BYTE PTR _bSkipAttributes$[ebp]
	test	eax, eax
	je	SHORT $LN163@fnActivate

; 11381:                   continue;

	jmp	$LN2@fnActivate
$LN163@fnActivate:

; 11382: 
; 11383:             // Now set the attribute flags.
; 11384:             lpAttribFlags = fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$19[ebp], eax

; 11385:                                                  lpViewAttrib );
; 11386:             lpAttribFlags->u.uFlags = AttribFlags.u.uFlags;

	mov	ecx, DWORD PTR _lpAttribFlags$19[ebp]
	mov	edx, DWORD PTR _AttribFlags$18[ebp]
	mov	DWORD PTR [ecx], edx

; 11387:          }

	jmp	$LN143@fnActivate
$LN145@fnActivate:

; 11388:          else
; 11389:          {
; 11390:             // If bSkipAttributes is TRUE, then we need to skip over these attributes.
; 11391:             if ( bSkipAttributes )

	movzx	eax, BYTE PTR _bSkipAttributes$[ebp]
	test	eax, eax
	je	SHORT $LN173@fnActivate

; 11392:                continue;

	jmp	$LN2@fnActivate
$LN173@fnActivate:

; 11393: 
; 11394:             if ( *plControl & zCOMPRESSED &&

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 131072				; 00020000H
	je	$LN174@fnActivate
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	$LN174@fnActivate

; 11395:                  lpViewAttrib->cType == zTYPE_INTEGER )
; 11396:             {
; 11397:                zLONG  l;
; 11398: 
; 11399:                if ( *pchLine == '*' )

	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN176@fnActivate

; 11400:                {
; 11401:                   // Integer attribute is NULL.
; 11402:                   fnSetAttributeFromString( lpView, lpViewEntityCsr,

	push	0
	push	OFFSET $SG17382
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H

; 11403:                                             lpViewAttrib, "", 0 );
; 11404:                }

	jmp	$LN177@fnActivate
$LN176@fnActivate:

; 11405:                else
; 11406:                {
; 11407:                   if ( *pchLine == '-' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 45					; 0000002dH
	jne	SHORT $LN178@fnActivate

; 11408:                      l = zxtol( pchLine + 1 ) * -1;

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	imul	ecx, eax, -1
	mov	DWORD PTR _l$8[ebp], ecx
	jmp	SHORT $LN179@fnActivate
$LN178@fnActivate:

; 11409:                   else
; 11410:                      l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$8[ebp], eax
$LN179@fnActivate:

; 11411: 
; 11412:                   if ( fnSetAttributeFromInteger( lpView, lpViewEntityCsr,
; 11413:                                                   lpViewAttrib, l ) != 0 )

	mov	eax, DWORD PTR _l$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromInteger
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN177@fnActivate

; 11414:                   {
; 11415:                      nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11416:                      break;

	jmp	$LN3@fnActivate
$LN177@fnActivate:

; 11417:                   }
; 11418:                }
; 11419:             }

	jmp	SHORT $LN175@fnActivate
$LN174@fnActivate:

; 11420:             else
; 11421:             {
; 11422:                if ( fnSetAttributeFromString( lpView, lpViewEntityCsr,
; 11423:                                               lpViewAttrib, pchLine, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSetAttributeFromString
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN175@fnActivate

; 11424:                {
; 11425:                   nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 11426:                   break;

	jmp	$LN3@fnActivate
$LN175@fnActivate:

; 11427:                }
; 11428:             }
; 11429: 
; 11430:             // Now set the attribute flags.
; 11431:             lpAttribFlags = fnGetAttribFlagsPtr( zGETPTR( lpViewEntityCsr->hEntityInstance ),

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$19[ebp], eax

; 11432:                                                  lpViewAttrib );
; 11433:             lpAttribFlags->u.uFlags = AttribFlags.u.uFlags;

	mov	eax, DWORD PTR _lpAttribFlags$19[ebp]
	mov	ecx, DWORD PTR _AttribFlags$18[ebp]
	mov	DWORD PTR [eax], ecx
$LN143@fnActivate:

; 11434:          }
; 11435: 
; 11436:          nRC = 0;  // Everything OK so far...

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 11437: 
; 11438:       }  // ...else...if ( pchLine[ 0 ] == 'a' && lpViewEntity )...

	jmp	$LN55@fnActivate
$LN113@fnActivate:

; 11439:       else
; 11440:       if ( pchLine[ 0 ] == 'i' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 105				; 00000069H
	jne	$LN182@fnActivate

; 11441:       {
; 11442:          zLONG  lLinkTgt;
; 11443:          zLONG  lLinkSrc;
; 11444: 
; 11445:          // If we are reading root only then don't bother with the link cards.
; 11446:          if ( *plControl & zACTIVATE_ROOTONLY )

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	and	edx, 268435456				; 10000000H
	je	SHORT $LN184@fnActivate

; 11447:             continue;

	jmp	$LN2@fnActivate
$LN184@fnActivate:

; 11448: 
; 11449:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 1
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_SysParseLine@12

; 11450:          if ( *plControl & zCOMPRESSED )

	mov	eax, DWORD PTR _plControl$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN185@fnActivate

; 11451:          {
; 11452:             lLinkTgt = zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLinkTgt$16[ebp], eax

; 11453:             lLinkSrc = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lLinkSrc$17[ebp], eax

; 11454:          }

	jmp	SHORT $LN186@fnActivate
$LN185@fnActivate:

; 11455:          else
; 11456:          {
; 11457:             lLinkTgt = zatol( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lLinkTgt$16[ebp], eax

; 11458:             lLinkSrc = zatol( pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lLinkSrc$17[ebp], eax
$LN186@fnActivate:

; 11459:          }
; 11460: 
; 11461:          k = lLinkSrc / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkSrc$17[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 11462:          lpSrcInstance = (LPENTITYINSTANCE) *(pRelinkBufferTable[ k ] +

	mov	eax, DWORD PTR _lLinkSrc$17[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pRelinkBufferTable$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _lpSrcInstance$[ebp], edx

; 11463:                                                      lLinkSrc % 160000);  // moved up from 16000 dks/don 2007.01.04
; 11464:          k = lLinkTgt / 160000;  // moved up from 16000 dks/don 2007.01.04

	mov	eax, DWORD PTR _lLinkTgt$16[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	DWORD PTR _k$[ebp], eax

; 11465:          lpTgtInstance = (LPENTITYINSTANCE) *(pRelinkBufferTable[ k ] +

	mov	eax, DWORD PTR _lLinkTgt$16[ebp]
	cdq
	mov	ecx, 160000				; 00027100H
	idiv	ecx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pRelinkBufferTable$[ebp+eax*4]
	mov	edx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR _lpTgtInstance$[ebp], edx

; 11466:                                                      lLinkTgt % 160000);  // moved up from 16000 dks/don 2007.01.04
; 11467: 
; 11468:          if ( lpTgtInstance && lpSrcInstance )

	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	$LN187@fnActivate
	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	$LN187@fnActivate

; 11469:          {
; 11470:             LPVIEWENTITY lpTgtViewEntity;
; 11471: 
; 11472:             lpViewEntity    = zGETPTR( lpSrcInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11473:             lpTgtViewEntity = zGETPTR( lpTgtInstance->hViewEntity );

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewEntity$15[ebp], eax

; 11474: 
; 11475:             if ( lpTgtViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpTgtViewEntity$15[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $LN189@fnActivate

; 11476:             {
; 11477:                TraceLine( "(oi) Error (OD: %s) - Tgt View Entity: %s Token: %d  View Entity: %s Token = %d",

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$15[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$15[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG17396
	call	_TraceLine
	add	esp, 24					; 00000018H

; 11478:                           lpViewOD->szName, lpTgtViewEntity->szName, lpTgtViewEntity->lEREntTok,
; 11479:                           lpViewEntity->szName, lpViewEntity->lEREntTok );
; 11480:                if ( bMsgBox )

	movzx	edx, BYTE PTR _bMsgBox$[ebp]
	test	edx, edx
	je	SHORT $LN191@fnActivate

; 11481:                {
; 11482:                   bMsgBox = FALSE;

	mov	BYTE PTR _bMsgBox$[ebp], 0

; 11483:                   SysMessageBox( lpView, szlOE_SystemError,

	push	1
	push	OFFSET $SG17398
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16
$LN191@fnActivate:

; 11484:                                  "ER Tokens don't match for linked entities!", 1 );
; 11485:                }
; 11486:             }

	jmp	SHORT $LN190@fnActivate
$LN189@fnActivate:

; 11487:             else
; 11488:             {
; 11489:                lpTgtInstance->hPersistRecord = lpSrcInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 11490:                if ( lpSrcInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSrcInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN192@fnActivate

; 11491:                   lpTgtInstance->hNextLinked = lpSrcInstance->hNextLinked;

	mov	eax, DWORD PTR _lpTgtInstance$[ebp]
	mov	ecx, DWORD PTR _lpSrcInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR [eax+42], edx
	jmp	SHORT $LN193@fnActivate
$LN192@fnActivate:

; 11492:                else
; 11493:                   lpTgtInstance->hNextLinked = zGETHNDL( lpSrcInstance );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$LN193@fnActivate:

; 11494: 
; 11495:                lpSrcInstance->hNextLinked = zGETHNDL( lpTgtInstance );

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$LN190@fnActivate:

; 11496:             }
; 11497:          }

	jmp	$LN188@fnActivate
$LN187@fnActivate:

; 11498:          else
; 11499:          {
; 11500:             TraceLineS( "(oi) Failed entity linking", "" );

	push	OFFSET $SG17401
	push	OFFSET $SG17402
	call	_TraceLineS@8

; 11501: 
; 11502:             TraceLineI( "(oi) Link Src # = ", lLinkSrc );

	mov	edx, DWORD PTR _lLinkSrc$17[ebp]
	push	edx
	push	OFFSET $SG17403
	call	_TraceLineI@8

; 11503:             if ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	SHORT $LN194@fnActivate

; 11504:             {
; 11505:                lpViewEntity = zGETPTR( lpSrcInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11506:                TraceLineS( "(oi) Source Entity = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG17405
	call	_TraceLineS@8
$LN194@fnActivate:

; 11507:             }
; 11508: 
; 11509:             TraceLineI( "(oi) Link Tgt # = ", lLinkTgt );

	mov	eax, DWORD PTR _lLinkTgt$16[ebp]
	push	eax
	push	OFFSET $SG17406
	call	_TraceLineI@8

; 11510:             if ( lpTgtInstance )

	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	SHORT $LN188@fnActivate

; 11511:             {
; 11512:                lpViewEntity = zGETPTR( lpTgtInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 11513:                TraceLineS( "(oi) Target Entity = ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG17408
	call	_TraceLineS@8
$LN188@fnActivate:

; 11514:             }
; 11515:          }
; 11516: 
; 11517:       }  // ...else...if ( pchLine[ 0 ] == 'i' )

	jmp	$LN55@fnActivate
$LN182@fnActivate:

; 11518:       else
; 11519:       if ( pchLine[ 0 ] == 'c' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchLine$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 99					; 00000063H
	jne	$LN196@fnActivate

; 11520:       {
; 11521:          zSHORT nHierNbr;
; 11522:          zLONG  l;
; 11523: 
; 11524:          // First make sure that the last created entity instance has it's
; 11525:          // indicators set.
; 11526:          if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN198@fnActivate

; 11527:          {
; 11528:             if ( *plControl & zINCREMENTAL )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65536				; 00010000H
	je	$LN199@fnActivate

; 11529:             {
; 11530:                lpEntityInstance->u.nIndicators = lIndicators;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR [ecx+6], edx

; 11531:                lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 11532: 
; 11533:                // A hack to make sure that a delete/excluded entity is
; 11534:                // flagged as hidden.  This tries to fix a bug.
; 11535:                if ( lpEntityInstance->u.nInd.bDeleted  ||

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN202@fnActivate
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN201@fnActivate
$LN202@fnActivate:

; 11536:                     lpEntityInstance->u.nInd.bExcluded )
; 11537:                {
; 11538:                   lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN201@fnActivate:

; 11539:                }
; 11540: 
; 11541:                if ( lpEntityInstance->u.nInd.bCreated  ||
; 11542:                     lpEntityInstance->u.nInd.bDeleted  ||
; 11543:                     lpEntityInstance->u.nInd.bIncluded ||
; 11544:                     lpEntityInstance->u.nInd.bExcluded ||

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN204@fnActivate
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN204@fnActivate
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	jne	SHORT $LN204@fnActivate
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN204@fnActivate
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN203@fnActivate
$LN204@fnActivate:

; 11545:                     lpEntityInstance->u.nInd.bUpdated )
; 11546:                {
; 11547:                   bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$LN203@fnActivate:

; 11548:                }
; 11549:             }

	jmp	SHORT $LN200@fnActivate
$LN199@fnActivate:

; 11550:             else
; 11551:                lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN200@fnActivate:

; 11552: 
; 11553:             // Set lpEntityInstance to 0 to indicate that the indicators for
; 11554:             // the last entity instance has been set.
; 11555:             lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0
$LN198@fnActivate:

; 11556:          }
; 11557: 
; 11558:          // Cursor positions are saved in cursor records.  A cursor record
; 11559:          // looks like:
; 11560:          //    cEnt-hier-nbr, absolute-instance-count
; 11561:          // For example, the cursor record for the root might look like:
; 11562:          //    c1, 1
; 11563:          // Numbers are stored in hex format.
; 11564: 
; 11565:          // If lInstanceCount is 0, then we need to set up some stuff.
; 11566:          if ( lInstanceCount == 0 )

	cmp	DWORD PTR _lInstanceCount$[ebp], 0
	jne	$LN205@fnActivate

; 11567:          {
; 11568:             LPVIEWCSR lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$7[ebp], eax

; 11569: 
; 11570:             // Indicate that cursor positions have been loaded.
; 11571:             *plControl = *plControl | zSAVE_CURSORS;

	mov	ecx, DWORD PTR _plControl$[ebp]
	mov	edx, DWORD PTR [ecx]
	or	edx, 262144				; 00040000H
	mov	eax, DWORD PTR _plControl$[ebp]
	mov	DWORD PTR [eax], edx

; 11572: 
; 11573:             // Initialize all entity cursors to be NULL.
; 11574:             for ( lpViewEntityCsr = zGETPTR( lpFirstViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpFirstViewCsr$7[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $LN37@fnActivate
$LN35@fnActivate:

; 11576:                   lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$LN37@fnActivate:

; 11575:                   lpViewEntityCsr;

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN36@fnActivate

; 11577:             {
; 11578:                lpViewEntityCsr->hEntityInstance = 0;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], 0

; 11579:             }

	jmp	SHORT $LN35@fnActivate
$LN36@fnActivate:

; 11580: 
; 11581:             lpViewEntityCsr = zGETPTR( lpFirstViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpFirstViewCsr$7[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 11582:             lpCursorEI      = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCursorEI$[ebp], eax

; 11583:             lInstanceCount  = 1;

	mov	DWORD PTR _lInstanceCount$[ebp], 1
$LN205@fnActivate:

; 11584:          }
; 11585: 
; 11586:          // Get entity hier number and absolute instance position from record.
; 11587:          SysParseLine( szWorkString, &pchLine, pchLine + 1 );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_SysParseLine@12

; 11588:          nHierNbr = (zSHORT) zxtol( szWorkString );

	push	16					; 00000010H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nHierNbr$13[ebp], ax

; 11589:          l = zxtol( pchLine );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _l$6[ebp], eax
$LN38@fnActivate:

; 11590: 
; 11591:          // Entity cursors that are NULL do not have a cursor record.  If the
; 11592:          // hier nbr read from the record is greater than the "current"
; 11593:          // entity cursor, then at least one cursor is NULL.
; 11594:          while ( lpViewEntityCsr->nHierNbr < nHierNbr )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	movsx	edx, WORD PTR _nHierNbr$13[ebp]
	cmp	ecx, edx
	jge	SHORT $LN39@fnActivate

; 11595:             lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
	jmp	SHORT $LN38@fnActivate
$LN39@fnActivate:

; 11596: 
; 11597:          if ( l == 0 )

	cmp	DWORD PTR _l$6[ebp], 0
	jne	SHORT $LN40@fnActivate

; 11598:          {
; 11599:             lpViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], 1

; 11600:          // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 11601:          //    SysMessageBox( 0, "fnActivateOI_FromStream", "UNSET_CSR", -1 );
; 11602:          }

	jmp	$LN207@fnActivate
$LN40@fnActivate:

; 11603:          else
; 11604:          {
; 11605:             // Look for the entity instance that has the absolute position l.
; 11606:             while ( lInstanceCount < l )

	mov	eax, DWORD PTR _lInstanceCount$[ebp]
	cmp	eax, DWORD PTR _l$6[ebp]
	jge	SHORT $LN41@fnActivate

; 11607:             {
; 11608:                lpCursorEI = zGETPTR( lpCursorEI->hNextHier );

	mov	ecx, DWORD PTR _lpCursorEI$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCursorEI$[ebp], eax

; 11609:                lInstanceCount++;

	mov	eax, DWORD PTR _lInstanceCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _lInstanceCount$[ebp], eax

; 11610:             }

	jmp	SHORT $LN40@fnActivate
$LN41@fnActivate:

; 11611: 
; 11612:             if ( lpViewEntityCsr->hViewEntity == lpCursorEI->hViewEntity )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR _lpCursorEI$[ebp]
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+2]
	jne	SHORT $LN208@fnActivate

; 11613:             {
; 11614:                lpViewEntityCsr->hEntityInstance = zGETHNDL( lpCursorEI );

	mov	ecx, DWORD PTR _lpCursorEI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 11615:             // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 11616:             //    SysMessageBox( 0, "fnActivateOI_FromStream2", "UNSET_CSR", -1 );
; 11617:             }

	jmp	SHORT $LN207@fnActivate
$LN208@fnActivate:

; 11618:             else
; 11619:             {
; 11620:                LPVIEWENTITY lpWk = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk$3[ebp], eax

; 11621: 
; 11622:                TraceLineS( "(oi) Entity type mismatch during cursor restoration"

	mov	edx, DWORD PTR _lpWk$3[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG17423
	call	_TraceLineS@8
$LN207@fnActivate:

; 11623:                            " for entity ", lpWk->szName );
; 11624:             }
; 11625:          }
; 11626: 
; 11627:          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 11628: 
; 11629:       }  // ...else...if ( pchLine[ 0 ] == 'c' )

	jmp	SHORT $LN55@fnActivate
$LN196@fnActivate:

; 11630:       else
; 11631:       if ( zstrncmp( pchLine, "ZEND", 4 ) == 0 )

	push	4
	push	OFFSET $SG17425
	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN55@fnActivate

; 11632:       {
; 11633:          // "ZEND" means we got to the end of the current OI so break out
; 11634:          // of loop.
; 11635:          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 11636:          break;

	jmp	SHORT $LN3@fnActivate
$LN55@fnActivate:

; 11637:       }
; 11638: 
; 11639:    } // while ( (nEOF = (*lpfnStreamFunc)( ... )) == 1 )

	jmp	$LN2@fnActivate
$LN3@fnActivate:

; 11640: 
; 11641:    for ( lEntityCnt = 0; pRelinkBufferTable[ lEntityCnt ]; lEntityCnt++ )

	mov	DWORD PTR _lEntityCnt$[ebp], 0
	jmp	SHORT $LN44@fnActivate
$LN42@fnActivate:
	mov	ecx, DWORD PTR _lEntityCnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lEntityCnt$[ebp], ecx
$LN44@fnActivate:
	mov	edx, DWORD PTR _lEntityCnt$[ebp]
	cmp	DWORD PTR _pRelinkBufferTable$[ebp+edx*4], 0
	je	SHORT $LN43@fnActivate

; 11642:       fnFreeDataspace( pRelinkBufferTable[ lEntityCnt ] );

	mov	eax, DWORD PTR _lEntityCnt$[ebp]
	mov	ecx, DWORD PTR _pRelinkBufferTable$[ebp+eax*4]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $LN42@fnActivate
$LN43@fnActivate:

; 11643: 
; 11644:    if ( nEOF == zCALL_ERROR )

	movsx	edx, WORD PTR _nEOF$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN211@fnActivate

; 11645:       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN211@fnActivate:

; 11646: 
; 11647:    // Mark the final instance indicators after updating all of the attributes.
; 11648:    if ( nRC >= 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN212@fnActivate

; 11649:    {
; 11650:       if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN213@fnActivate

; 11651:       {
; 11652:          if ( *plControl & zINCREMENTAL )

	mov	edx, DWORD PTR _plControl$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 65536				; 00010000H
	je	$LN214@fnActivate

; 11653:          {
; 11654:             lpEntityInstance->u.nIndicators = lIndicators;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR _lIndicators$[ebp]
	mov	DWORD PTR [ecx+6], edx

; 11655:             lpEntityInstance->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 11656: 
; 11657:             if ( lpEntityInstance->u.nInd.bCreated  ||
; 11658:                  lpEntityInstance->u.nInd.bDeleted  ||
; 11659:                  lpEntityInstance->u.nInd.bIncluded ||
; 11660:                  lpEntityInstance->u.nInd.bExcluded ||

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN217@fnActivate
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN217@fnActivate
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN217@fnActivate
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	jne	SHORT $LN217@fnActivate
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN216@fnActivate
$LN217@fnActivate:

; 11661:                  lpEntityInstance->u.nInd.bUpdated )
; 11662:             {
; 11663:                bOI_IsUpdated = TRUE;

	mov	BYTE PTR _bOI_IsUpdated$[ebp], 1
$LN216@fnActivate:

; 11664:             }
; 11665:          }

	jmp	SHORT $LN213@fnActivate
$LN214@fnActivate:

; 11666:          else
; 11667:             lpEntityInstance->u.nInd.bUpdated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN213@fnActivate:

; 11668:       }
; 11669: 
; 11670:       // Check if OI is updated.
; 11671:       lpViewOI->bUpdated     = bOI_IsUpdated;

	movzx	ecx, BYTE PTR _bOI_IsUpdated$[ebp]
	and	ecx, 1
	shl	ecx, 4
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -17				; ffffffefH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 11672:       lpViewOI->bUpdatedFile = FALSE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN212@fnActivate:

; 11673:    }
; 11674: 
; 11675:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN218@fnActivate:

; 11676: 
; 11677: } // fnActivateOI_FromTextStream

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateOI_FromTextStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_tViewArrayBlock$ = -512				; size = 64
_lpViewOD$ = -448					; size = 4
tv176 = -444						; size = 4
_lpLockInstance$1 = -440				; size = 4
_lpViewEntityCsr$ = -436				; size = 4
_lpEntityInstance$ = -432				; size = 4
_vLock$ = -428						; size = 8
_lpViewAttrib$ = -420					; size = 4
_nRC$ = -416						; size = 2
_lpViewEntity$ = -412					; size = 4
_nKeyCnt$ = -408					; size = 2
_lpKeyViewAttrib$ = -404				; size = 160
_szKeyString$ = -244					; size = 201
_szLockName$ = -40					; size = 35
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_bLOD_Lock$ = 12					; size = 1
_lpView$ = 16						; size = 4
_lpFirstEntityInstance$ = 20				; size = 4
_lpViewOI$ = 24						; size = 4
_bAllowRead$ = 28					; size = 1
_fnSetLocksOnTwins@24 PROC

; 10235: {

	push	ebp
	mov	ebp, esp
	sub	esp, 512				; 00000200H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 10236:    ViewClusterRecord vLock;
; 10237:    LPVIEWENTITY      lpViewEntity;
; 10238:    LPVIEWATTRIB      lpViewAttrib;
; 10239:    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 10240:    LPENTITYINSTANCE  lpEntityInstance;
; 10241:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 10242:    LPVIEWOD          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10243:    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	push	60					; 0000003cH
	push	0
	lea	edx, DWORD PTR _tViewArrayBlock$[ebp+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 10244:    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 10245:    zCHAR             szLockName[ 35 ];
; 10246:    zSHORT            nKeyCnt;
; 10247:    zSHORT            nRC = zCALL_ERROR;       // Assume everything error.

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 10248: 
; 10249:    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 10250:    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 10251: 
; 10252:    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10253: 
; 10254:    // To save time later find all the keys in the LOD and store them in a table.
; 10255:    nKeyCnt = 0;

	xor	eax, eax
	mov	WORD PTR _nKeyCnt$[ebp], ax

; 10256:    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnSetLocks
$LN2@fnSetLocks:

; 10258:          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnSetLocks:

; 10257:          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN3@fnSetLocks

; 10259:    {
; 10260:       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN8@fnSetLocks

; 10261:          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
$LN8@fnSetLocks:

; 10262:    }

	jmp	SHORT $LN2@fnSetLocks
$LN3@fnSetLocks:

; 10263: 
; 10264:    // Create an empty lock OI.
; 10265:    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, lpView, "ZPLOCKO", FALSE ) != 0 )

	push	0
	push	OFFSET $SG16927
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnDeclareView@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN9@fnSetLocks

; 10266:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetLocks
$LN9@fnSetLocks:

; 10267: 
; 10268:    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN10@fnSetLocks

; 10269:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetLocks
$LN10@fnSetLocks:

; 10270: 
; 10271:    // Get the lpViewEntity and lpViewEntityCsr for the lock OI.
; 10272:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vLock.vOI, "ZeidonLock", 0 );

	push	0
	push	OFFSET $SG16929
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10273: 
; 10274:    if ( bLOD_Lock )

	movzx	ecx, BYTE PTR _bLOD_Lock$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@fnSetLocks

; 10275:    {
; 10276:       // We are setting a LOD level lock so we set LockName to the name of
; 10277:       // the LOD.
; 10278:       zstrcpy( szLockName, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 10279:    }

	jmp	SHORT $LN12@fnSetLocks
$LN11@fnSetLocks:

; 10280:    else
; 10281:    {
; 10282:       // We are setting a lock at the entity level so use the name of the
; 10283:       // entity for the LockName.  In addition, to handle the rare case where
; 10284:       // a LOD and entity name are the same we prefix all entity names with
; 10285:       // a '@' because it's an invalid character for entity names.  This
; 10286:       // insures that the LockName for the entity does not match a LOD name.
; 10287:       lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10288:       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG16932
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN12@fnSetLocks:

; 10289:    }
; 10290: 
; 10291:    // Loop through each of the root entities and create a locking record.
; 10292:    for ( lpEntityInstance = lpFirstEntityInstance;

	mov	edx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $LN7@fnSetLocks
$LN5@fnSetLocks:

; 10294:          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnSetLocks:

; 10293:          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN6@fnSetLocks

; 10295:    {
; 10296:       LPENTITYINSTANCE lpLockInstance;
; 10297: 
; 10298:       // Create the concat key string.
; 10299:       fnCreateConcatKey( szKeyString, lpEntityInstance,

	movzx	edx, WORD PTR _nKeyCnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	call	_fnCreateConcatKey@16

; 10300:                          lpKeyViewAttrib, nKeyCnt );
; 10301: 
; 10302:       if ( fnCreateEntity( vLock.vOI, lpViewEntity, lpViewEntityCsr,
; 10303:                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCreateEntity@20
	cwde
	test	eax, eax
	je	SHORT $LN13@fnSetLocks

; 10304:       {
; 10305:          goto EndOfFunction;

	jmp	$EndOfFunction$21
$LN13@fnSetLocks:

; 10306:       }
; 10307: 
; 10308:       // fnCreateEntity DOES NOT set the bCreated flag so set it.
; 10309:       lpLockInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLockInstance$1[ebp], eax

; 10310:       lpLockInstance->u.nInd.bCreated = TRUE;

	mov	eax, DWORD PTR _lpLockInstance$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2
	mov	edx, DWORD PTR _lpLockInstance$1[ebp]
	mov	DWORD PTR [edx+6], ecx

; 10311: 
; 10312:       if ( fnSetLockingAttributes( lpCurrentTask,
; 10313:                                    vLock.vOI, lpViewEntity, lpViewEntityCsr,
; 10314:                                    szLockName, szKeyString,
; 10315:                                    TRUE, TRUE, bAllowRead ? "Y" : "N" ) != 0 )

	movzx	eax, BYTE PTR _bAllowRead$[ebp]
	test	eax, eax
	je	SHORT $LN19@fnSetLocks
	mov	DWORD PTR tv176[ebp], OFFSET $SG16935
	jmp	SHORT $LN20@fnSetLocks
$LN19@fnSetLocks:
	mov	DWORD PTR tv176[ebp], OFFSET $SG16936
$LN20@fnSetLocks:
	mov	ecx, DWORD PTR tv176[ebp]
	push	ecx
	push	1
	push	1
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSetLockingAttributes@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN14@fnSetLocks

; 10316:       {
; 10317:          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$21
$LN14@fnSetLocks:

; 10318:       }
; 10319:    } // for ( lpEntityInstance...)

	jmp	$LN5@fnSetLocks
$LN6@fnSetLocks:

; 10320: 
; 10321:    // Now commit the lock OI.
; 10322:    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN15@fnSetLocks

; 10323:       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$21
$LN15@fnSetLocks:

; 10324: 
; 10325:    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 10326:                                 0, &tViewArrayBlock ) != 0 )

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	cwde
	test	eax, eax
	je	SHORT $LN16@fnSetLocks

; 10327:    {
; 10328:       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$21
$LN16@fnSetLocks:

; 10329:    }
; 10330: 
; 10331:    lpViewOI->bIsLocked = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 10332: 
; 10333:    // If we get here then everything is OK.
; 10334:    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$EndOfFunction$21:

; 10335: 
; 10336: EndOfFunction:
; 10337:    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $LN17@fnSetLocks

; 10338:       fnDropView( vLock.vOI );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4
$LN17@fnSetLocks:

; 10339: 
; 10340:    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 10341: 
; 10342:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSetLocks:

; 10343: 
; 10344: } // fnSetLocksOnTwins

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnSetLocksOnTwins@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_hViewEntity$ = -44					; size = 4
_lpViewEntityCsr$ = -40					; size = 4
_lpViewOD$ = -36					; size = 4
_lCurrentEREntTok$1 = -32				; size = 4
_hChildViewEntity$ = -28				; size = 4
_lpViewEntity$ = -24					; size = 4
_lpChildViewEntity$ = -20				; size = 4
_lpChildEntityInstance$ = -16				; size = 4
_nReturnCode$ = -12					; size = 2
_nEntityInstanceLevel$ = -8				; size = 2
_nRC$ = -4						; size = 2
_lpCurrentTask$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpEntityInstance$ = 16					; size = 4
_lpQualView$ = 20					; size = 4
_pOper$ = 24						; size = 4
_lpPtr$ = 28						; size = 4
_fnLoadChildEntities PROC

; 9998 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 9999 :    LPVIEWOD         lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10000:    LPVIEWENTITY     hViewEntity;
; 10001:    LPVIEWENTITY     lpViewEntity;
; 10002:    LPVIEWENTITY     lpChildViewEntity;
; 10003:    LPVIEWENTITY     hChildViewEntity;
; 10004:    LPVIEWENTITYCSR  lpViewEntityCsr;
; 10005:    LPENTITYINSTANCE lpChildEntityInstance;
; 10006:    zSHORT           nEntityInstanceLevel;
; 10007:    zSHORT           nReturnCode = 0;

	xor	edx, edx
	mov	WORD PTR _nReturnCode$[ebp], dx

; 10008:    zSHORT           nRC;
; 10009: 
; 10010:    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 10011:    nEntityInstanceLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nEntityInstanceLevel$[ebp], ax

; 10012: 
; 10013:    // If view entity is recursive, then reset lpViewEntity to point to the
; 10014:    // parent view entity that has the same EREntTok as the current lpViewEntity.
; 10015:    if ( lpViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN17@fnLoadChil

; 10016:    {
; 10017:       zLONG lCurrentEREntTok;
; 10018: 
; 10019:       lCurrentEREntTok = lpViewEntity->lEREntTok;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+195]
	mov	DWORD PTR _lCurrentEREntTok$1[ebp], ecx

; 10020:       lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN2@fnLoadChil:

; 10021:       while ( lpViewEntity->lEREntTok != lCurrentEREntTok )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+195]
	cmp	edx, DWORD PTR _lCurrentEREntTok$1[ebp]
	je	SHORT $LN17@fnLoadChil

; 10022:          lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN2@fnLoadChil
$LN17@fnLoadChil:

; 10023:    }
; 10024: 
; 10025:    hViewEntity = zGETHNDL( lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewEntity$[ebp], eax

; 10026: 
; 10027:    // The first child ViewEntity of the current lpViewEntity is the next
; 10028:    // view entity in hierachical order.
; 10029:    hChildViewEntity  = lpViewEntity->hNextHier;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _hChildViewEntity$[ebp], ecx

; 10030:    lpChildViewEntity = zGETPTR( hChildViewEntity );

	mov	edx, DWORD PTR _hChildViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildViewEntity$[ebp], eax

; 10031: 
; 10032:    // Check to see if there are child entity definitions.  If not, there are
; 10033:    // no children to load, so exit.  There is no child entity if:
; 10034:    //    o lpChildViewEntity is null (there are no entities after
; 10035:    //      lpViewEntity).
; 10036:    //    o The level number of the next view entity is "equal to" (which means
; 10037:    //      that the next view entity is a sibling) or "less than" (which means
; 10038:    //      that the next view entity is the sibling of an ancestor).
; 10039:    if ( lpChildViewEntity == 0 ||

	cmp	DWORD PTR _lpChildViewEntity$[ebp], 0
	je	SHORT $LN19@fnLoadChil
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jg	SHORT $LN18@fnLoadChil
$LN19@fnLoadChil:

; 10040:         lpChildViewEntity->nLevel <= lpViewEntity->nLevel )
; 10041:    {
; 10042:       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnLoadChil
$LN18@fnLoadChil:

; 10043:    }
; 10044: 
; 10045:    // Load all the child entities of lpEntityInstance, starting with the first
; 10046:    // child entity definition via hierarchical ordering.  After loading a type
; 10047:    // of entity, find the next child entity type and (if there are more) load
; 10048:    // those.  Keep going until there are no more child entity types for
; 10049:    // lpEntityInstance.
; 10050: 
; 10051:    for ( ;

	jmp	SHORT $LN6@fnLoadChil
$LN4@fnLoadChil:

; 10053:          lpChildViewEntity = zGETPTR( lpChildViewEntity->hNextSibling ) )

	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+247]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildViewEntity$[ebp], eax
$LN6@fnLoadChil:

; 10052:          lpChildViewEntity;

	cmp	DWORD PTR _lpChildViewEntity$[ebp], 0
	je	$LN5@fnLoadChil

; 10054:    {
; 10055:       hChildViewEntity = zGETHNDL( lpChildViewEntity );

	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hChildViewEntity$[ebp], eax

; 10056: 
; 10057:       // If the max cardinality of the child instance is 1 then it's possible
; 10058:       // that the child was already activated by the DBHandler.  Check to see
; 10059:       // if a child EI already exists.
; 10060:       if ( lpChildViewEntity->uCardMax == 1 )

	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	movzx	edx, WORD PTR [ecx+221]
	cmp	edx, 1
	jne	$LN20@fnLoadChil

; 10061:       {
; 10062:          // Because the object might be recursive, we also
; 10063:          // need to check to make sure that the level of the child entity
; 10064:          // instance is exactly 1 more the the level of the parent entity.
; 10065:          lpChildEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
$LN7@fnLoadChil:

; 10066:          while ( lpChildEntityInstance &&

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	SHORT $LN8@fnLoadChil
	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hChildViewEntity$[ebp]
	jne	SHORT $LN22@fnLoadChil
	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nEntityInstanceLevel$[ebp]
	add	eax, 1
	cmp	edx, eax
	je	SHORT $LN8@fnLoadChil
$LN22@fnLoadChil:

; 10067:                  (lpChildEntityInstance->hViewEntity != hChildViewEntity ||
; 10068:                   lpChildEntityInstance->nLevel != nEntityInstanceLevel + 1) )
; 10069:          {
; 10070:             if ( lpChildEntityInstance->nLevel <= nEntityInstanceLevel )

	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nEntityInstanceLevel$[ebp]
	cmp	edx, eax
	jg	SHORT $LN9@fnLoadChil

; 10071:             {
; 10072:                lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0

; 10073:                break;

	jmp	SHORT $LN8@fnLoadChil
$LN9@fnLoadChil:

; 10074:             }
; 10075: 
; 10076:             while ( lpChildEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN10@fnLoadChil

; 10077:                lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
	jmp	SHORT $LN9@fnLoadChil
$LN10@fnLoadChil:

; 10078: 
; 10079:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10080:          }

	jmp	SHORT $LN7@fnLoadChil
$LN8@fnLoadChil:

; 10081: 
; 10082:          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 10083:       }

	jmp	SHORT $LN21@fnLoadChil
$LN20@fnLoadChil:

; 10084:       else
; 10085:          lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0
$LN21@fnLoadChil:

; 10086: 
; 10087:       // If lpChildEntityInstance is still 0 then we need to load it.
; 10088:       if ( lpChildEntityInstance == 0 )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	jne	$LN24@fnLoadChil

; 10089:       {
; 10090:          // If the child entity not either a derived path or a duplicate
; 10091:          // relationship path then attempt to load that entity.
; 10092:          if ( lpChildViewEntity->bDerivedPath == FALSE &&

	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	$LN25@fnLoadChil
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 27					; 0000001bH
	and	ecx, 1
	jne	$LN25@fnLoadChil

; 10093:               lpChildViewEntity->bDupRelPath == FALSE )
; 10094:          {
; 10095:             // Child entities couldn't be loaded via cacheing, so call the
; 10096:             // db-handler.
; 10097:             nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),

	mov	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	32800					; 00008020H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10098:                             DBH_Entity | DBH_Load, 0, lpViewOD,
; 10099:                             lpChildViewEntity, lpView, lpQualView, lpPtr );
; 10100:             if ( nRC == zDB_DEADLOCK )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -3					; fffffffdH
	jne	SHORT $LN26@fnLoadChil

; 10101:                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnLoadChil
$LN26@fnLoadChil:

; 10102: 
; 10103:             if ( lpCurrentTask->bLoadAllocLimit )

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	je	SHORT $LN27@fnLoadChil

; 10104:             {
; 10105:                lpCurrentTask->bLoadAllocLimit = FALSE;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -16385				; ffffbfffH
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 10106:                return( zMEMORY_LIMIT );

	mov	eax, -7					; fffffff9H
	jmp	$LN1@fnLoadChil
$LN27@fnLoadChil:

; 10107:             }
; 10108: 
; 10109:             if ( nRC < -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jge	SHORT $LN28@fnLoadChil

; 10110:                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnLoadChil
$LN28@fnLoadChil:

; 10111: 
; 10112:             // Check to see if the activate limit was reached.
; 10113:             if ( nRC == 2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 2
	jne	SHORT $LN25@fnLoadChil

; 10114:                nReturnCode = 2;

	mov	ecx, 2
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN25@fnLoadChil:

; 10115:          }
; 10116: 
; 10117:          // If we didn't load any child entities see if we need to create a
; 10118:          // child entity because of the "hanging keys" problem.
; 10119:          if ( nRC == -1 && lpChildViewEntity->bHangingFKey )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jne	SHORT $LN30@fnLoadChil
	mov	eax, DWORD PTR _lpChildViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN30@fnLoadChil

; 10120:             fnAddHangingEntity( lpView, lpChildViewEntity );

	mov	edx, DWORD PTR _lpChildViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAddHangingEntity@8
$LN30@fnLoadChil:

; 10121: 
; 10122:          // If any children were loaded, call this proc recursively to load all
; 10123:          // of THEIR children.
; 10124: 
; 10125:          // Find the first child entity of lpChildViewEntity.
; 10126:          lpChildEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
$LN11@fnLoadChil:

; 10127: 
; 10128:          // Now find the first child entity instance that matches
; 10129:          // lpChildViewEntity.  Because the object might be recursive, we also
; 10130:          // need to check to make sure that the level of the child entity
; 10131:          // instance is exactly 1 more the the level of the parent entity.
; 10132:          while ( lpChildEntityInstance &&

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	SHORT $LN24@fnLoadChil
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hChildViewEntity$[ebp]
	jne	SHORT $LN31@fnLoadChil
	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nEntityInstanceLevel$[ebp]
	add	ecx, 1
	cmp	eax, ecx
	je	SHORT $LN24@fnLoadChil
$LN31@fnLoadChil:

; 10133:                  (lpChildEntityInstance->hViewEntity != hChildViewEntity ||
; 10134:                   lpChildEntityInstance->nLevel != nEntityInstanceLevel + 1) )
; 10135:          {
; 10136:             if ( lpChildEntityInstance->nLevel <= nEntityInstanceLevel )

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nEntityInstanceLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN13@fnLoadChil

; 10137:             {
; 10138:                lpChildEntityInstance = 0;

	mov	DWORD PTR _lpChildEntityInstance$[ebp], 0

; 10139:                break;

	jmp	SHORT $LN24@fnLoadChil
$LN13@fnLoadChil:

; 10140:             }
; 10141: 
; 10142:             while ( lpChildEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN14@fnLoadChil

; 10143:                lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax
	jmp	SHORT $LN13@fnLoadChil
$LN14@fnLoadChil:

; 10144: 
; 10145:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10146:          }

	jmp	SHORT $LN11@fnLoadChil
$LN24@fnLoadChil:

; 10147: 
; 10148:       } // if ( lpChildEntityInstance == 0 )...
; 10149: 
; 10150:       // If nRC == -1, then no children were loaded.
; 10151:       if ( nRC >= 0 && lpChildEntityInstance )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN33@fnLoadChil
	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	$LN33@fnLoadChil
$LN15@fnLoadChil:

; 10152:       {
; 10153:          // Load the children of the just-loaded children.
; 10154:          while ( lpChildEntityInstance )

	cmp	DWORD PTR _lpChildEntityInstance$[ebp], 0
	je	$LN33@fnLoadChil

; 10155:          {
; 10156:             //
; 10157:             // Make lpChildEntityInstance the current instance.
; 10158:             //
; 10159:             lpViewEntityCsr =

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 10160:                 fnEstablishViewForInstance( lpView, 0, lpChildEntityInstance );
; 10161: 
; 10162:             // If the entity is flagged as recursive, then set the view to
; 10163:             // have the current child entity as the parent of the recursive
; 10164:             // relationship before calling fnLoadChildEntities.
; 10165:             if ( lpChildViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	$LN34@fnLoadChil

; 10166:             {
; 10167:                fnSetViewToSubobject( lpView, lpChildViewEntity,

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpChildViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH

; 10168:                                      lpViewEntityCsr );
; 10169: 
; 10170:                // Check to make sure the recursive entity instance hasn't
; 10171:                // already been loaded as a parent.  If it has then this is
; 10172:                // an error because the OI has an infinite looping sub-object.
; 10173:                // If the return value is TRUE then there was an error.
; 10174:                if ( fnCheckForRecursiveLoop( lpView,
; 10175:                                              lpChildEntityInstance ) == 0 )

	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnCheckForRecursiveLoop@8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN36@fnLoadChil

; 10176:                {
; 10177:                   // Everything ok so load children.
; 10178:                   nRC = fnLoadChildEntities( lpCurrentTask, lpView,

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10179:                                              lpChildEntityInstance, lpQualView,
; 10180:                                              pOper, lpPtr );
; 10181:                   if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	je	SHORT $LN38@fnLoadChil
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -7					; fffffff9H
	jne	SHORT $LN37@fnLoadChil
$LN38@fnLoadChil:

; 10182:                      return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnLoadChil
$LN37@fnLoadChil:

; 10183: 
; 10184:                   if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN39@fnLoadChil

; 10185:                      return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnLoadChil
$LN39@fnLoadChil:

; 10186: 
; 10187:                   if ( nRC == 2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 2
	jne	SHORT $LN36@fnLoadChil

; 10188:                      nReturnCode = 2;

	mov	ecx, 2
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN36@fnLoadChil:

; 10189:                }
; 10190: 
; 10191:                fnResetViewFromSubobject( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 10192:             }

	jmp	SHORT $LN35@fnLoadChil
$LN34@fnLoadChil:

; 10193:             else
; 10194:             {
; 10195:                nRC = fnLoadChildEntities( lpCurrentTask, lpView,

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10196:                                           lpChildEntityInstance, lpQualView,
; 10197:                                           pOper, lpPtr );
; 10198:                if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -3					; fffffffdH
	je	SHORT $LN42@fnLoadChil
	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -7					; fffffff9H
	jne	SHORT $LN41@fnLoadChil
$LN42@fnLoadChil:

; 10199:                   return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnLoadChil
$LN41@fnLoadChil:

; 10200: 
; 10201:                if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN43@fnLoadChil

; 10202:                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnLoadChil
$LN43@fnLoadChil:

; 10203: 
; 10204:                if ( nRC == 2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 2
	jne	SHORT $LN35@fnLoadChil

; 10205:                   nReturnCode = 2;

	mov	ecx, 2
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN35@fnLoadChil:

; 10206:             }
; 10207: 
; 10208:             // Get next twin.
; 10209:             lpChildEntityInstance = zGETPTR( lpChildEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildEntityInstance$[ebp], eax

; 10210: 
; 10211:          }  // while ( lpChildEntityInstance )...

	jmp	$LN15@fnLoadChil
$LN33@fnLoadChil:

; 10212: 
; 10213:       }  // if ( nRC > 0 && lpChildEntityInstance &&... )...
; 10214: 
; 10215:    } // for ( lpChildViewEntity )

	jmp	$LN4@fnLoadChil
$LN5@fnLoadChil:

; 10216: 
; 10217:    return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
$LN1@fnLoadChil:

; 10218: 
; 10219: }  // fnLoadChildEntities

	mov	esp, ebp
	pop	ebp
	ret	0
_fnLoadChildEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -844					; size = 4
_lpViewOD$1 = -840					; size = 4
_lpViewEntity$ = -836					; size = 4
_lpParentViewAttrib$2 = -832				; size = 4
_lpViewAttrib$ = -828					; size = 4
_lpParent$ = -824					; size = 4
_lpParentViewEntity$3 = -820				; size = 4
_nKeyCnt$ = -816					; size = 2
_bKeysMatch$4 = -809					; size = 1
_k$5 = -808						; size = 2
_lpKeys$ = -804						; size = 800
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_fnCheckForRecursiveLoop@8 PROC

; 9863 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 844				; 0000034cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9864 :    LPVIEWENTITY     lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9865 :    LPENTITYINSTANCE lpParent;
; 9866 :    LPVIEWATTRIB     lpKeys[ 200 ];
; 9867 :    LPVIEWATTRIB     lpViewAttrib;
; 9868 :    LPTASK           lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 9869 :    zSHORT           nKeyCnt;
; 9870 : 
; 9871 :    // In an attempt to make things faster later let's get all the keys for
; 9872 :    // lpEntityInstance.
; 9873 :    nKeyCnt = 0;

	xor	ecx, ecx
	mov	WORD PTR _nKeyCnt$[ebp], cx

; 9874 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnCheckFor
$LN2@fnCheckFor:

; 9876 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnCheckFor:

; 9875 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN3@fnCheckFor

; 9877 :    {
; 9878 :       if ( lpViewAttrib->bKey == FALSE )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN14@fnCheckFor

; 9879 :         continue;

	jmp	SHORT $LN2@fnCheckFor
$LN14@fnCheckFor:

; 9880 : 
; 9881 :       lpKeys[ nKeyCnt++ ] = lpViewAttrib;

	movsx	edx, WORD PTR _nKeyCnt$[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeys$[ebp+edx*4], eax
	mov	cx, WORD PTR _nKeyCnt$[ebp]
	add	cx, 1
	mov	WORD PTR _nKeyCnt$[ebp], cx

; 9882 :    }

	jmp	SHORT $LN2@fnCheckFor
$LN3@fnCheckFor:

; 9883 : 
; 9884 : 
; 9885 :    for ( lpParent = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax
	jmp	SHORT $LN7@fnCheckFor
$LN5@fnCheckFor:

; 9887 :          lpParent = zGETPTR( lpParent->hParent ) )

	mov	ecx, DWORD PTR _lpParent$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax
$LN7@fnCheckFor:

; 9886 :          lpParent;

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	$LN6@fnCheckFor

; 9888 :    {
; 9889 :       LPVIEWENTITY lpParentViewEntity = zGETPTR( lpParent->hViewEntity );

	mov	eax, DWORD PTR _lpParent$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$3[ebp], eax

; 9890 :       zBOOL        bKeysMatch;
; 9891 :       zSHORT       k;
; 9892 : 
; 9893 :       // We only care about the parent if it's also recursive.  If NONE of the
; 9894 :       // recursive flags are set then skip it.  It's possible--althought
; 9895 :       // highly unlikely--that the entity we are looking for also exists as
; 9896 :       // a non-recursive entity between the recursive parent & child.
; 9897 :       if ( lpParentViewEntity->bRecursiveSt  == 0 &&
; 9898 :            lpParentViewEntity->bRecursive    == 0 &&

	mov	edx, DWORD PTR _lpParentViewEntity$3[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN15@fnCheckFor
	mov	ecx, DWORD PTR _lpParentViewEntity$3[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN15@fnCheckFor
	mov	eax, DWORD PTR _lpParentViewEntity$3[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 29					; 0000001dH
	and	ecx, 1
	jne	SHORT $LN15@fnCheckFor

; 9899 :            lpParentViewEntity->bRecursivePar == 0 )
; 9900 :       {
; 9901 :          continue;

	jmp	SHORT $LN5@fnCheckFor
$LN15@fnCheckFor:

; 9902 :       }
; 9903 : 
; 9904 :       // The parent must be the same ER entity as the child.
; 9905 :       if ( lpParentViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	edx, DWORD PTR _lpParentViewEntity$3[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $LN16@fnCheckFor

; 9906 :          continue;

	jmp	$LN5@fnCheckFor
$LN16@fnCheckFor:

; 9907 : 
; 9908 :       // Make sure the keys are different.  We will start by assuming they
; 9909 :       // are the same until proven otherwise.
; 9910 :       bKeysMatch = TRUE;

	mov	BYTE PTR _bKeysMatch$4[ebp], 1

; 9911 :       for ( k = 0; k < nKeyCnt; k++ )

	xor	edx, edx
	mov	WORD PTR _k$5[ebp], dx
	jmp	SHORT $LN10@fnCheckFor
$LN8@fnCheckFor:
	mov	ax, WORD PTR _k$5[ebp]
	add	ax, 1
	mov	WORD PTR _k$5[ebp], ax
$LN10@fnCheckFor:
	movsx	ecx, WORD PTR _k$5[ebp]
	movsx	edx, WORD PTR _nKeyCnt$[ebp]
	cmp	ecx, edx
	jge	$LN9@fnCheckFor

; 9912 :       {
; 9913 :          LPVIEWATTRIB lpParentViewAttrib;
; 9914 : 
; 9915 :          // Now find the key value in the parent.
; 9916 :          if ( lpViewEntity == lpParentViewEntity )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	eax, DWORD PTR _lpParentViewEntity$3[ebp]
	jne	SHORT $LN17@fnCheckFor

; 9917 :             lpParentViewAttrib = lpKeys[ k ];

	movsx	ecx, WORD PTR _k$5[ebp]
	mov	edx, DWORD PTR _lpKeys$[ebp+ecx*4]
	mov	DWORD PTR _lpParentViewAttrib$2[ebp], edx
	jmp	SHORT $LN18@fnCheckFor
$LN17@fnCheckFor:

; 9918 :          else
; 9919 :          {
; 9920 :             // We have to hunt for it.
; 9921 :             for ( lpParentViewAttrib = zGETPTR( lpParentViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpParentViewEntity$3[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewAttrib$2[ebp], eax
	jmp	SHORT $LN13@fnCheckFor
$LN11@fnCheckFor:

; 9923 :                   lpParentViewAttrib = zGETPTR( lpParentViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpParentViewAttrib$2[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewAttrib$2[ebp], eax
$LN13@fnCheckFor:

; 9922 :                   lpParentViewAttrib->lERAttTok != lpKeys[ k ]->lERAttTok;

	movsx	ecx, WORD PTR _k$5[ebp]
	mov	edx, DWORD PTR _lpKeys$[ebp+ecx*4]
	mov	eax, DWORD PTR _lpParentViewAttrib$2[ebp]
	mov	ecx, DWORD PTR [eax+177]
	cmp	ecx, DWORD PTR [edx+177]
	je	SHORT $LN18@fnCheckFor

; 9924 :             {
; 9925 :                ; // nothing needs to be done here
; 9926 :             }

	jmp	SHORT $LN11@fnCheckFor
$LN18@fnCheckFor:

; 9927 :          }
; 9928 : 
; 9929 :          if ( fnCompareEIAttrs( lpCurrentTask,
; 9930 :                                 0, lpParent, lpParentViewAttrib, 0,
; 9931 :                                 0, lpEntityInstance, lpKeys[ k ], 0 ) != 0 )

	push	0
	movsx	edx, WORD PTR _k$5[ebp]
	mov	eax, DWORD PTR _lpKeys$[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _lpParentViewAttrib$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParent$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCompareEIAttrs@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN19@fnCheckFor

; 9932 :          {
; 9933 :             bKeysMatch = FALSE;

	mov	BYTE PTR _bKeysMatch$4[ebp], 0

; 9934 :             break;

	jmp	SHORT $LN9@fnCheckFor
$LN19@fnCheckFor:

; 9935 :          }
; 9936 :       }

	jmp	$LN8@fnCheckFor
$LN9@fnCheckFor:

; 9937 : 
; 9938 :       // If bKeysMatch is still TRUE then lpParent and lpEntityInstance
; 9939 :       // reference the same data.  This is an error that will cause an
; 9940 :       // infinite loop in the recursive subobject.
; 9941 :       if ( bKeysMatch )

	movzx	eax, BYTE PTR _bKeysMatch$4[ebp]
	test	eax, eax
	je	$LN20@fnCheckFor

; 9942 :       {
; 9943 :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 9944 : 
; 9945 :          TraceLineS( "==== Activate error: Infinite recursive subobject ====", "" );

	push	OFFSET $SG16791
	push	OFFSET $SG16792
	call	_TraceLineS@8

; 9946 :          TraceLineS( "Object Name   = ", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG16793
	call	_TraceLineS@8

; 9947 :          TraceLineS( "Parent Entity = ", lpParentViewEntity->szName );

	mov	ecx, DWORD PTR _lpParentViewEntity$3[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG16794
	call	_TraceLineS@8

; 9948 :          TraceLineI( "Parent level  = ", lpParent->nLevel );

	mov	edx, DWORD PTR _lpParent$[ebp]
	movsx	eax, WORD PTR [edx+58]
	push	eax
	push	OFFSET $SG16795
	call	_TraceLineI@8

; 9949 :          TraceLineS( "Child Entity  = ", lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG16796
	call	_TraceLineS@8

; 9950 :          TraceLineI( "Child level   = ", lpEntityInstance->nLevel );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	push	eax
	push	OFFSET $SG16797
	call	_TraceLineI@8

; 9951 :          DisplayEntityInstance( lpView, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DisplayEntityInstance@8

; 9952 : 
; 9953 :          //  "KZOEE095 - Recursive error."
; 9954 :          fnIssueCoreError( lpCurrentTask, lpView, 16, 95, 0, lpViewOD->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	0
	push	95					; 0000005fH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 9955 : 
; 9956 :          return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@fnCheckFor
$LN20@fnCheckFor:

; 9957 :       }
; 9958 : 
; 9959 :    } // for each lpParent...

	jmp	$LN5@fnCheckFor
$LN6@fnCheckFor:

; 9960 : 
; 9961 :    // If we get here then everything must be OK.
; 9962 :    return( FALSE );

	xor	eax, eax
$LN1@fnCheckFor:

; 9963 : 
; 9964 : } // fnCheckForRecursiveLoop.

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnCheckForRecursiveLoop@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpValueViewAttrib$ = -800				; size = 4
_pch$1 = -796						; size = 4
_lpViewEntity$ = -792					; size = 4
_lpEntityInstance$ = -788				; size = 4
_lpQualAttribEntityCsr$ = -784				; size = 4
_lpViewAttrib$ = -780					; size = 4
_k$2 = -776						; size = 2
_nRC$ = -772						; size = 2
_vLock$ = -768						; size = 4
_vQual$ = -764						; size = 4
_nKeyCnt$ = -760					; size = 2
_lpKeyViewAttrib$ = -756				; size = 160
_szMsg$3 = -596						; size = 200
_szKeyString$ = -396					; size = 201
_szWhat$4 = -192					; size = 100
_szDate$5 = -92						; size = 50
_szLockName$ = -40					; size = 35
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_bLOD_Lock$ = 12					; size = 1
_bAllowReadOnly$ = 16					; size = 1
_lpView$ = 20						; size = 4
_lpFirstEntityInstance$ = 24				; size = 4
_lpViewOD$ = 28						; size = 4
_fnCheckLocksOnTwins@24 PROC

; 9443 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 800				; 00000320H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9444 :    LPVIEWENTITY      lpViewEntity;
; 9445 :    LPVIEWATTRIB      lpViewAttrib;
; 9446 :    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 9447 :    LPENTITYINSTANCE  lpEntityInstance;
; 9448 :    LPVIEWENTITYCSR   lpQualAttribEntityCsr = 0;

	mov	DWORD PTR _lpQualAttribEntityCsr$[ebp], 0

; 9449 :    LPVIEWATTRIB      lpValueViewAttrib;
; 9450 :    zVIEW             vQual = 0;

	mov	DWORD PTR _vQual$[ebp], 0

; 9451 :    zVIEW             vLock = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 9452 :    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 9453 :    zCHAR             szLockName[ 35 ];
; 9454 :    zSHORT            nKeyCnt;
; 9455 :    zSHORT            nRC = zCALL_ERROR;       // Assume everything error.

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 9456 : 
; 9457 :    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9458 : 
; 9459 :    // To save time later find all the keys in the LOD and store them in a table.
; 9460 :    nKeyCnt = 0;

	xor	eax, eax
	mov	WORD PTR _nKeyCnt$[ebp], ax

; 9461 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnCheckLoc
$LN2@fnCheckLoc:

; 9463 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnCheckLoc:

; 9462 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN3@fnCheckLoc

; 9464 :    {
; 9465 :       if ( lpViewAttrib->bKey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN8@fnCheckLoc

; 9466 :          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	ecx, WORD PTR _nKeyCnt$[ebp]
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+ecx*4], edx
	mov	ax, WORD PTR _nKeyCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nKeyCnt$[ebp], ax
$LN8@fnCheckLoc:

; 9467 :    }

	jmp	SHORT $LN2@fnCheckLoc
$LN3@fnCheckLoc:

; 9468 : 
; 9469 :    if ( bLOD_Lock )

	movzx	ecx, BYTE PTR _bLOD_Lock$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@fnCheckLoc

; 9470 :    {
; 9471 :       // We are checking a LOD level lock so we set LockName to the name of
; 9472 :       // the LOD.
; 9473 :       zstrcpy( szLockName, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 9474 :    }

	jmp	SHORT $LN10@fnCheckLoc
$LN9@fnCheckLoc:

; 9475 :    else
; 9476 :    {
; 9477 :       // We are checking a lock at the entity level so use the name of the
; 9478 :       // entity for the LockName.  In addition, to handle the rare case where
; 9479 :       // a LOD and entity name are the same we prefix all entity names with
; 9480 :       // a '@' because it's an invalid character for entity names.  This
; 9481 :       // insures that the LockName for the entity does not match a LOD name.
; 9482 :       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG16713
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN10@fnCheckLoc:

; 9483 :    }
; 9484 : 
; 9485 :    // Create EntitySpec and QualAttribs.  This creates a qual that
; 9486 :    // is analogous to:
; 9487 :    //    ACTIVATE view WHERE view.ZeidonLock.LOD_Name = lod-name AND
; 9488 :    //                        view.ZeidonLock.KeyValue = ?
; 9489 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,

	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	push	OFFSET $SG16714
	push	OFFSET $SG16715
	push	OFFSET $SG16716
	push	OFFSET $SG16717
	lea	ecx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vQual$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCreateQualification@36

; 9490 :                           &lpQualAttribEntityCsr, "ZeidonLock", "ZeidonLock",
; 9491 :                           "LOD_Name", "=", szLockName );
; 9492 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,

	push	0
	push	OFFSET $SG16718
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreateQualification@36

; 9493 :                           &lpQualAttribEntityCsr, 0, 0, 0, "AND", 0 );
; 9494 :    fnCreateQualification( lpCurrentTask, lpView, &vQual,

	push	OFFSET $SG16719
	push	OFFSET $SG16720
	push	OFFSET $SG16721
	push	OFFSET $SG16722
	push	0
	lea	eax, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCreateQualification@36

; 9495 :                           &lpQualAttribEntityCsr,
; 9496 :                           0, "ZeidonLock", "KeyValue", "=", "" );
; 9497 : 
; 9498 :    // Get the lpViewAttrib for the Value attribute for later use with
; 9499 :    // fnSetAttributeFromVariable.
; 9500 :    lpValueViewAttrib =

	push	0
	push	OFFSET $SG16723
	mov	ecx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpValueViewAttrib$[ebp], eax

; 9501 :            fnValidViewAttrib( vQual,
; 9502 :                               zGETPTR( lpQualAttribEntityCsr->hViewEntity ),
; 9503 :                               "Value", 0 );
; 9504 : 
; 9505 :    // Loop through each of the root entities and make sure that none of the
; 9506 :    // key values already exist.
; 9507 :    for ( lpEntityInstance = lpFirstEntityInstance;

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN7@fnCheckLoc
$LN5@fnCheckLoc:

; 9509 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnCheckLoc:

; 9508 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN6@fnCheckLoc

; 9510 :    {
; 9511 :       zSHORT k;
; 9512 : 
; 9513 :       // Create the concat key string and set the value in the qual object.
; 9514 :       fnCreateConcatKey( szKeyString, lpEntityInstance,

	movzx	ecx, WORD PTR _nKeyCnt$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szKeyString$[ebp]
	push	ecx
	call	_fnCreateConcatKey@16

; 9515 :                          lpKeyViewAttrib, nKeyCnt );
; 9516 :       fnSetAttributeFromVariable( vQual, lpQualAttribEntityCsr,

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	lea	eax, DWORD PTR _szKeyString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpValueViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualAttribEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H

; 9517 :                                   lpValueViewAttrib, (zPVOID) szKeyString,
; 9518 :                                   'S', 0, 0, lpCurrentTask, 0 );
; 9519 : 
; 9520 : 
; 9521 :       k = ActivateObjectInstance( &vLock, "ZPLOCKO", lpView, vQual, 0 );

	push	0
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	OFFSET $SG16724
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_ActivateObjectInstance@20
	mov	WORD PTR _k$2[ebp], ax

; 9522 :       if ( k < -1 )

	movsx	ecx, WORD PTR _k$2[ebp]
	cmp	ecx, -1
	jge	SHORT $LN11@fnCheckLoc

; 9523 :          goto EndOfFunction;

	jmp	$EndOfFunction$20
$LN11@fnCheckLoc:

; 9524 : 
; 9525 :       if ( k >= 0 )

	movsx	edx, WORD PTR _k$2[ebp]
	test	edx, edx
	jl	$LN12@fnCheckLoc

; 9526 :       {
; 9527 :          zPCHAR pch;
; 9528 : 
; 9529 :          // Uh-oh -- we found a lock record matching the keys.  Check to see
; 9530 :          // if we can at least keep the view as read-only.
; 9531 :          GetAddrForAttribute( &pch, vLock, "ZeidonLock", "AllowRead" );

	push	OFFSET $SG16727
	push	OFFSET $SG16728
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pch$1[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 9532 :          if ( *pch != 'Y' || bAllowReadOnly == FALSE )

	mov	edx, DWORD PTR _pch$1[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN14@fnCheckLoc
	movzx	ecx, BYTE PTR _bAllowReadOnly$[ebp]
	test	ecx, ecx
	jne	$LN12@fnCheckLoc
$LN14@fnCheckLoc:

; 9533 :          {
; 9534 :             zCHAR szWhat[ 100 ];
; 9535 :             zCHAR szMsg[ 200 ];
; 9536 :             zCHAR szDate[ 50 ];
; 9537 : 
; 9538 :             // User attempted to get some sort of lock but it's already locked
; 9539 :             // OR
; 9540 :             // someone has an exclusive lock that doesn't even allow
; 9541 :             // read-only views so don't allow activate.
; 9542 : 
; 9543 :             if ( bLOD_Lock )

	movzx	edx, BYTE PTR _bLOD_Lock$[ebp]
	test	edx, edx
	je	SHORT $LN15@fnCheckLoc

; 9544 :                zsprintf( szWhat, "LOD '%s' is locked", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG16733
	lea	ecx, DWORD PTR _szWhat$4[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN16@fnCheckLoc
$LN15@fnCheckLoc:

; 9545 :             else
; 9546 :                zsprintf( szWhat, "Entity '%s' is locked", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG16734
	lea	eax, DWORD PTR _szWhat$4[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN16@fnCheckLoc:

; 9547 : 
; 9548 :             GetAddrForAttribute( &pch, vLock, "ZeidonLock", "UserName" );

	push	OFFSET $SG16735
	push	OFFSET $SG16736
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pch$1[ebp]
	push	edx
	call	_GetAddrForAttribute@16

; 9549 :             GetStringFromAttribute( szMsg, vLock, "ZeidonLock", "Timestamp" );

	push	OFFSET $SG16737
	push	OFFSET $SG16738
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 9550 :             UfFormatDateTime( szDate, szMsg, "YYYY-M-D HH:MI:SS" );

	push	OFFSET $SG16739
	lea	edx, DWORD PTR _szMsg$3[ebp]
	push	edx
	lea	eax, DWORD PTR _szDate$5[ebp]
	push	eax
	call	_UfFormatDateTime@12

; 9551 :             TraceLineS( "(oi) Object locked by ", pch );

	mov	ecx, DWORD PTR _pch$1[ebp]
	push	ecx
	push	OFFSET $SG16740
	call	_TraceLineS@8

; 9552 :             TraceLineS( "(oi) Object locked on ", szDate );

	lea	edx, DWORD PTR _szDate$5[ebp]
	push	edx
	push	OFFSET $SG16741
	call	_TraceLineS@8

; 9553 :             TraceLineS( "(oi) Concatenated key = ", szKeyString );

	lea	eax, DWORD PTR _szKeyString$[ebp]
	push	eax
	push	OFFSET $SG16742
	call	_TraceLineS@8

; 9554 :          // zsprintf( szMsg, "By '%s' on %s", pch, szDate );
; 9555 :          // fnIssueCoreError( lpTask, lpView, 16, 94, 0, szWhat, szMsg );
; 9556 : 
; 9557 :             nRC = zLOCK_ERROR;

	mov	ecx, -5					; fffffffbH
	mov	WORD PTR _nRC$[ebp], cx

; 9558 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$20
$LN12@fnCheckLoc:

; 9559 :          }
; 9560 :       }
; 9561 : 
; 9562 :       // We don't need it anymore so...
; 9563 :       fnDropView( vLock );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4

; 9564 :       vLock = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 9565 : 
; 9566 :    } // for ( lpEntityInstance...)

	jmp	$LN5@fnCheckLoc
$LN6@fnCheckLoc:

; 9567 : 
; 9568 :    // If we get here then everything is OK.
; 9569 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$20:

; 9570 : 
; 9571 : EndOfFunction:
; 9572 :    if ( vQual )

	cmp	DWORD PTR _vQual$[ebp], 0
	je	SHORT $LN17@fnCheckLoc

; 9573 :       fnDropView( vQual );

	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnDropView@4
$LN17@fnCheckLoc:

; 9574 : 
; 9575 :    if ( vLock )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $LN18@fnCheckLoc

; 9576 :       fnDropView( vLock );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4
$LN18@fnCheckLoc:

; 9577 : 
; 9578 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 9579 : 
; 9580 : } // fnCheckLocksOnTwins

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnCheckLocksOnTwins@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchOldDelim$ = -12					; size = 4
_pchNewDelim$ = -8					; size = 4
_pch$ = -4						; size = 4
_chCurrentDelim$ = 8					; size = 1
_pchStart$ = 12						; size = 4
_pchEnd$ = 16						; size = 4
_pchNewString$ = 20					; size = 4
_fnFindKeyDelim@16 PROC

; 9295 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 9296 :    zPCHAR pchOldDelim;
; 9297 :    zPCHAR pchNewDelim;
; 9298 :    zPCHAR pch;
; 9299 : 
; 9300 :    if ( chCurrentDelim == 0 )

	movsx	eax, BYTE PTR _chCurrentDelim$[ebp]
	test	eax, eax
	jne	SHORT $LN12@fnFindKeyD

; 9301 :       return( gszKeyDelimStr[ 0 ] );

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	al, BYTE PTR _gszKeyDelimStr[edx]
	jmp	$LN1@fnFindKeyD
$LN12@fnFindKeyD:

; 9302 : 
; 9303 :    // Look for current delim in string.
; 9304 :    pchOldDelim = zstrchr( gszKeyDelimStr, chCurrentDelim );

	movsx	eax, BYTE PTR _chCurrentDelim$[ebp]
	push	eax
	push	OFFSET _gszKeyDelimStr
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchOldDelim$[ebp], eax

; 9305 : 
; 9306 :    // Point to next delim in string.
; 9307 :    pchNewDelim = pchOldDelim + 1;

	mov	ecx, DWORD PTR _pchOldDelim$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], ecx
$LN2@fnFindKeyD:

; 9308 : 
; 9309 :    // Look for next delim in gszKeyDelimStr not in buffer or new string.
; 9310 :    while ( zstrchr( pchNewString, *pchNewDelim ) )

	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pchNewString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@fnFindKeyD

; 9311 :       pchNewDelim++;

	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], edx
	jmp	SHORT $LN2@fnFindKeyD
$LN3@fnFindKeyD:

; 9312 : 
; 9313 :    for ( pch = pchStart; pch < pchEnd; pch++ )

	mov	eax, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN6@fnFindKeyD
$LN4@fnFindKeyD:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN6@fnFindKeyD:
	mov	edx, DWORD PTR _pch$[ebp]
	cmp	edx, DWORD PTR _pchEnd$[ebp]
	jae	SHORT $LN5@fnFindKeyD

; 9314 :    {
; 9315 :       if ( *pch == *pchNewDelim )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN13@fnFindKeyD

; 9316 :       {
; 9317 :          pchNewDelim++;

	mov	ecx, DWORD PTR _pchNewDelim$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], ecx
$LN7@fnFindKeyD:

; 9318 : 
; 9319 :          // Make sure new delim isn't in new string.
; 9320 :          while ( zstrchr( pchNewString, *pchNewDelim ) )

	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pchNewString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN8@fnFindKeyD

; 9321 :             pchNewDelim++;

	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchNewDelim$[ebp], edx
	jmp	SHORT $LN7@fnFindKeyD
$LN8@fnFindKeyD:

; 9322 : 
; 9323 :          // Reset pch to start looking at the beginning of the string again.
; 9324 :          pch = pchStart;

	mov	eax, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], eax

; 9325 : 
; 9326 :          continue;

	jmp	SHORT $LN4@fnFindKeyD
$LN13@fnFindKeyD:

; 9327 :       }
; 9328 :    }

	jmp	SHORT $LN4@fnFindKeyD
$LN5@fnFindKeyD:

; 9329 : 
; 9330 :    // Convert all pchOldDelims to pchNewDelim.
; 9331 :    for ( pch = pchStart; pch < pchEnd; pch++ )

	mov	ecx, DWORD PTR _pchStart$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $LN11@fnFindKeyD
$LN9@fnFindKeyD:
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$LN11@fnFindKeyD:
	mov	eax, DWORD PTR _pch$[ebp]
	cmp	eax, DWORD PTR _pchEnd$[ebp]
	jae	SHORT $LN10@fnFindKeyD

; 9332 :    {
; 9333 :       if ( *pch == *pchOldDelim )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchOldDelim$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN14@fnFindKeyD

; 9334 :          *pch = *pchNewDelim;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	eax, DWORD PTR _pchNewDelim$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
$LN14@fnFindKeyD:

; 9335 :    }

	jmp	SHORT $LN9@fnFindKeyD
$LN10@fnFindKeyD:

; 9336 : 
; 9337 :    return( *pchNewDelim );

	mov	edx, DWORD PTR _pchNewDelim$[ebp]
	mov	al, BYTE PTR [edx]
$LN1@fnFindKeyD:

; 9338 : 
; 9339 : } // fnFindKeyDelim

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnFindKeyDelim@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
tv283 = -56						; size = 4
tv282 = -52						; size = 4
tv256 = -48						; size = 4
tv255 = -44						; size = 4
tv228 = -40						; size = 4
tv227 = -36						; size = 4
tv200 = -32						; size = 4
tv199 = -28						; size = 4
_lpViewEntity$ = -24					; size = 4
_lpViewEntityCsr$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lCnt$ = -12						; size = 4
_vQual$ = -8						; size = 4
_pchAttribName$1 = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_lpView$ = 12						; size = 4
_pvQual$ = 16						; size = 4
_plpViewEntityCsr$ = 20					; size = 4
_pchEntitySpec$ = 24					; size = 4
_pchEntityName$ = 28					; size = 4
_pchAttributeName$ = 32					; size = 4
_pchOper$ = 36						; size = 4
_pchValue$ = 40						; size = 4
_fnCreateQualification@36 PROC

; 9126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 9127 :    LPVIEWENTITY      lpViewEntity;
; 9128 :    LPVIEWATTRIB      lpViewAttrib;
; 9129 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 9130 :    zVIEW             vQual;
; 9131 :    zLONG             lCnt;
; 9132 : 
; 9133 :    if ( *pvQual == 0 )

	mov	eax, DWORD PTR _pvQual$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@fnCreateQu

; 9134 :    {
; 9135 :       if ( fnDeclareView( pvQual, lpCurrentTask, lpView,
; 9136 :                           "KZDBHQUA", TRUE ) != 0 )

	push	1
	push	OFFSET $SG16556
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvQual$[ebp]
	push	eax
	call	_fnDeclareView@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN6@fnCreateQu

; 9137 :       {
; 9138 :          *pvQual = 0;

	mov	edx, DWORD PTR _pvQual$[ebp]
	mov	DWORD PTR [edx], 0

; 9139 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN6@fnCreateQu:

; 9140 :       }
; 9141 : 
; 9142 :       if ( fnActivateEmptyObjectInstance( lpCurrentTask, *pvQual,
; 9143 :                                           zSINGLE ) != 0 )

	push	0
	mov	eax, DWORD PTR _pvQual$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN5@fnCreateQu

; 9144 :       {
; 9145 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN5@fnCreateQu:

; 9146 :       }
; 9147 :    }
; 9148 : 
; 9149 :    vQual = *pvQual;

	mov	ecx, DWORD PTR _pvQual$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vQual$[ebp], edx

; 9150 : 
; 9151 :    // If pchEntitySpec was supplied, then create an entity spec.
; 9152 :    if ( pchEntitySpec )

	cmp	DWORD PTR _pchEntitySpec$[ebp], 0
	je	$LN8@fnCreateQu

; 9153 :    {
; 9154 :       // Get lpViewEntity, lpViewEntityCsr, and lpViewAttrib.
; 9155 :       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vQual, "EntitySpec", 0 );

	push	0
	push	OFFSET $SG16559
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9156 :       lpViewAttrib = fnValidViewAttrib( vQual, lpViewEntity, "EntityName", 0 );

	push	0
	push	OFFSET $SG16560
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 9157 : 
; 9158 :       // Make sure entity spec doesn't already exist.
; 9159 :       if ( fnSetEntityCursor( vQual, lpViewEntity, lpViewEntityCsr,
; 9160 :                               lpViewAttrib, zPOS_FIRST | zQUAL_STRING,
; 9161 :                               (zPVOID) pchEntitySpec,
; 9162 :                               0, 0, 0, 0, 0, lpCurrentTask ) != zCURSOR_SET )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pchEntitySpec$[ebp]
	push	edx
	push	1025					; 00000401H
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN8@fnCreateQu

; 9163 :       {
; 9164 :          if ( fnCreateEntity( vQual, lpViewEntity, lpViewEntityCsr,
; 9165 :                               zPOS_NEXT, FALSE ) != 0 )

	push	0
	push	3
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnCreateEntity@20
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN10@fnCreateQu

; 9166 :          {
; 9167 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN10@fnCreateQu:

; 9168 :          }
; 9169 : 
; 9170 :          if ( fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9171 :                                           (zPVOID) pchEntitySpec, 'S', 0, 0,
; 9172 :                                           lpCurrentTask, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _pchEntitySpec$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN8@fnCreateQu

; 9173 :          {
; 9174 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN8@fnCreateQu:

; 9175 :          }
; 9176 :       }
; 9177 :    }
; 9178 : 
; 9179 :    // If no oper was supplied we're done.
; 9180 :    if ( pchOper == 0 )

	cmp	DWORD PTR _pchOper$[ebp], 0
	jne	SHORT $LN12@fnCreateQu

; 9181 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCreateQu
$LN12@fnCreateQu:

; 9182 : 
; 9183 :    if ( plpViewEntityCsr )

	cmp	DWORD PTR _plpViewEntityCsr$[ebp], 0
	je	SHORT $LN13@fnCreateQu

; 9184 :    {
; 9185 :       if ( *plpViewEntityCsr )

	mov	eax, DWORD PTR _plpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN15@fnCreateQu

; 9186 :       {
; 9187 :          // User supplied valid cursor so use it.
; 9188 :          lpViewEntityCsr = *plpViewEntityCsr;

	mov	ecx, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 9189 :          lpViewEntity    = zGETPTR( (*plpViewEntityCsr)->hViewEntity );

	mov	eax, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9190 :       }

	jmp	SHORT $LN16@fnCreateQu
$LN15@fnCreateQu:

; 9191 :       else
; 9192 :       {
; 9193 :          // Get lpViewEntity and plpViewEntityCsr.
; 9194 :          lpViewEntity    = fnValidViewEntity( plpViewEntityCsr, vQual, "QualAttrib", 0 );

	push	0
	push	OFFSET $SG16569
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9195 :          lpViewEntityCsr = *plpViewEntityCsr;

	mov	edx, DWORD PTR _plpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$LN16@fnCreateQu:

; 9196 :       }
; 9197 :    }

	jmp	SHORT $LN14@fnCreateQu
$LN13@fnCreateQu:

; 9198 :    else
; 9199 :    {
; 9200 :       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, vQual, "QualAttrib", 0 );

	push	0
	push	OFFSET $SG16570
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN14@fnCreateQu:

; 9201 :    }
; 9202 : 
; 9203 :    // Create the new qual attrib.
; 9204 :    if ( fnCreateEntity( vQual, lpViewEntity, lpViewEntityCsr,
; 9205 :                         zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_fnCreateEntity@20
	cwde
	test	eax, eax
	je	SHORT $LN17@fnCreateQu

; 9206 :    {
; 9207 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN17@fnCreateQu:

; 9208 :    }
; 9209 : 
; 9210 :    // Loop through each of the view attribs.  When we find one we want, set
; 9211 :    // the value.  We keep track of the # of attributes we set so we don't
; 9212 :    // have to keep searching even when we've set all the values.
; 9213 :    lCnt = 0;

	mov	DWORD PTR _lCnt$[ebp], 0

; 9214 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnCreateQu
$LN2@fnCreateQu:

; 9216 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnCreateQu:

; 9215 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnCreateQu

; 9217 :    {
; 9218 :       zPCHAR pchAttribName = lpViewAttrib->szName;

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _pchAttribName$1[ebp], edx

; 9219 : 
; 9220 :       if ( zstrcmp( pchAttribName, "EntityName" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG16574
	cmp	ecx, edx
	jne	SHORT $LN36@fnCreateQu
	push	OFFSET $SG16575
	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN37@fnCreateQu
$LN36@fnCreateQu:
	mov	ecx, DWORD PTR _pchAttribName$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG16576
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN34@fnCreateQu
	mov	DWORD PTR tv199[ebp], 1
	jmp	SHORT $LN35@fnCreateQu
$LN34@fnCreateQu:
	mov	DWORD PTR tv199[ebp], -1
$LN35@fnCreateQu:
	mov	ecx, DWORD PTR tv199[ebp]
	mov	DWORD PTR tv200[ebp], ecx
$LN37@fnCreateQu:
	cmp	DWORD PTR tv200[ebp], 0
	jne	SHORT $LN18@fnCreateQu

; 9221 :       {
; 9222 :          if ( pchEntityName &&

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	SHORT $LN20@fnCreateQu
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN20@fnCreateQu

; 9223 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9224 :                                           (zPVOID) pchEntityName, 'S', 0, 0,
; 9225 :                                           lpCurrentTask, 0 ) != 0 )
; 9226 :          {
; 9227 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN20@fnCreateQu:

; 9228 :          }
; 9229 : 
; 9230 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $LN21@fnCreateQu

; 9231 :             break;               // We've set all values so break.

	jmp	$LN3@fnCreateQu
$LN21@fnCreateQu:

; 9232 :       }

	jmp	$LN19@fnCreateQu
$LN18@fnCreateQu:

; 9233 :       else
; 9234 :       if ( zstrcmp( pchAttribName, "AttributeName" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG16581
	cmp	ecx, edx
	jne	SHORT $LN40@fnCreateQu
	push	OFFSET $SG16582
	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv228[ebp], eax
	jmp	SHORT $LN41@fnCreateQu
$LN40@fnCreateQu:
	mov	ecx, DWORD PTR _pchAttribName$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG16583
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN38@fnCreateQu
	mov	DWORD PTR tv227[ebp], 1
	jmp	SHORT $LN39@fnCreateQu
$LN38@fnCreateQu:
	mov	DWORD PTR tv227[ebp], -1
$LN39@fnCreateQu:
	mov	ecx, DWORD PTR tv227[ebp]
	mov	DWORD PTR tv228[ebp], ecx
$LN41@fnCreateQu:
	cmp	DWORD PTR tv228[ebp], 0
	jne	SHORT $LN22@fnCreateQu

; 9235 :       {
; 9236 :          if ( pchAttributeName &&

	cmp	DWORD PTR _pchAttributeName$[ebp], 0
	je	SHORT $LN24@fnCreateQu
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchAttributeName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN24@fnCreateQu

; 9237 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9238 :                                           (zPVOID) pchAttributeName, 'S', 0, 0,
; 9239 :                                           lpCurrentTask, 0 ) != 0 )
; 9240 :          {
; 9241 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN24@fnCreateQu:

; 9242 :          }
; 9243 : 
; 9244 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $LN25@fnCreateQu

; 9245 :             break;               // We've set all values so break.

	jmp	$LN3@fnCreateQu
$LN25@fnCreateQu:

; 9246 :       }

	jmp	$LN19@fnCreateQu
$LN22@fnCreateQu:

; 9247 :       else
; 9248 :       if ( zstrcmp( pchAttribName, "Oper" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG16588
	cmp	ecx, edx
	jne	SHORT $LN44@fnCreateQu
	push	OFFSET $SG16589
	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv256[ebp], eax
	jmp	SHORT $LN45@fnCreateQu
$LN44@fnCreateQu:
	mov	ecx, DWORD PTR _pchAttribName$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG16590
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN42@fnCreateQu
	mov	DWORD PTR tv255[ebp], 1
	jmp	SHORT $LN43@fnCreateQu
$LN42@fnCreateQu:
	mov	DWORD PTR tv255[ebp], -1
$LN43@fnCreateQu:
	mov	ecx, DWORD PTR tv255[ebp]
	mov	DWORD PTR tv256[ebp], ecx
$LN45@fnCreateQu:
	cmp	DWORD PTR tv256[ebp], 0
	jne	SHORT $LN26@fnCreateQu

; 9249 :       {
; 9250 :          if ( fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9251 :                                           (zPVOID) pchOper, 'S', 0, 0,
; 9252 :                                           lpCurrentTask, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN28@fnCreateQu

; 9253 :          {
; 9254 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreateQu
$LN28@fnCreateQu:

; 9255 :          }
; 9256 : 
; 9257 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $LN29@fnCreateQu

; 9258 :             break;               // We've set all values so break.

	jmp	$LN3@fnCreateQu
$LN29@fnCreateQu:

; 9259 :       }

	jmp	$LN19@fnCreateQu
$LN26@fnCreateQu:

; 9260 :       else
; 9261 :       if ( zstrcmp( pchAttribName, "Value" ) == 0 )

	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG16594
	cmp	ecx, edx
	jne	SHORT $LN48@fnCreateQu
	push	OFFSET $SG16595
	mov	eax, DWORD PTR _pchAttribName$1[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv283[ebp], eax
	jmp	SHORT $LN49@fnCreateQu
$LN48@fnCreateQu:
	mov	ecx, DWORD PTR _pchAttribName$1[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG16596
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN46@fnCreateQu
	mov	DWORD PTR tv282[ebp], 1
	jmp	SHORT $LN47@fnCreateQu
$LN46@fnCreateQu:
	mov	DWORD PTR tv282[ebp], -1
$LN47@fnCreateQu:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR tv283[ebp], ecx
$LN49@fnCreateQu:
	cmp	DWORD PTR tv283[ebp], 0
	jne	SHORT $LN19@fnCreateQu

; 9262 :       {
; 9263 :          if ( pchValue &&

	cmp	DWORD PTR _pchValue$[ebp], 0
	je	SHORT $LN31@fnCreateQu
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	push	0
	push	83					; 00000053H
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN31@fnCreateQu

; 9264 :               fnSetAttributeFromVariable( vQual, lpViewEntityCsr, lpViewAttrib,
; 9265 :                                           (zPVOID) pchValue, 'S', 0, 0,
; 9266 :                                           lpCurrentTask, 0 ) != 0 )
; 9267 :          {
; 9268 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnCreateQu
$LN31@fnCreateQu:

; 9269 :          }
; 9270 : 
; 9271 :          if ( ++lCnt == 4 )

	mov	edx, DWORD PTR _lCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lCnt$[ebp], edx
	cmp	DWORD PTR _lCnt$[ebp], 4
	jne	SHORT $LN19@fnCreateQu

; 9272 :             break;               // We've set all values so break.

	jmp	SHORT $LN3@fnCreateQu
$LN19@fnCreateQu:

; 9273 :       }
; 9274 : 
; 9275 :    } // for...

	jmp	$LN2@fnCreateQu
$LN3@fnCreateQu:

; 9276 : 
; 9277 :    return( 0 );

	xor	eax, eax
$LN1@fnCreateQu:

; 9278 : 
; 9279 : } // fnCreateQualification

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_fnCreateQualification@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpSrcAttrib$1 = -52					; size = 4
_pchPtr$2 = -48						; size = 4
_ulLth$3 = -44						; size = 4
_lpSrcDataField$4 = -40					; size = 4
_lpTargetDataField$5 = -36				; size = 4
_lpChildRelRecord$ = -32				; size = 4
_lpChildDataRecord$ = -28				; size = 4
_lpEntityInstance$6 = -24				; size = 4
_lpParentEntity$7 = -20					; size = 4
_lpTargetAttrib$8 = -16					; size = 4
_lpViewEntityCsr$9 = -12				; size = 4
_lpRelField$ = -8					; size = 4
_chType$10 = -2						; size = 1
_bEntityCreated$ = -1					; size = 1
_lpView$ = 8						; size = 4
_lpChildEntity$ = 12					; size = 4
_fnAddHangingEntity@8 PROC

; 9044 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 9045 :    LPDATARECORD lpChildDataRecord = zGETPTR( lpChildEntity->hFirstDataRecord );

	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax+191]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildDataRecord$[ebp], eax

; 9046 :    LPRELRECORD  lpChildRelRecord  = zGETPTR( lpChildDataRecord->hFirstRelRecord );

	mov	edx, DWORD PTR _lpChildDataRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildRelRecord$[ebp], eax

; 9047 :    LPRELFIELD   lpRelField;
; 9048 :    zBOOL        bEntityCreated = FALSE;

	mov	BYTE PTR _bEntityCreated$[ebp], 0

; 9049 : 
; 9050 :    for ( lpRelField = zGETPTR( lpChildRelRecord->hFirstRelField );

	mov	ecx, DWORD PTR _lpChildRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
	jmp	SHORT $LN4@fnAddHangi
$LN2@fnAddHangi:

; 9052 :          lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN4@fnAddHangi:

; 9051 :          lpRelField;

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN3@fnAddHangi

; 9053 :    {
; 9054 :       LPVIEWENTITY     lpParentEntity;
; 9055 :       LPVIEWATTRIB     lpTargetAttrib;
; 9056 :       LPVIEWATTRIB     lpSrcAttrib;
; 9057 :       LPDATAFIELD      lpTargetDataField;
; 9058 :       LPDATAFIELD      lpSrcDataField;
; 9059 :       LPVIEWENTITYCSR  lpViewEntityCsr;
; 9060 :       LPENTITYINSTANCE lpEntityInstance;
; 9061 :       zPCHAR           pchPtr;
; 9062 :       zCHAR            chType;
; 9063 :       zULONG           ulLth;
; 9064 : 
; 9065 :       // Check to see if the Rel field (the target field) is not-null.  Note
; 9066 :       // the the rel field had better be in a parent entity!
; 9067 :       lpTargetDataField = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTargetDataField$5[ebp], eax

; 9068 :       lpTargetAttrib    = zGETPTR( lpTargetDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpTargetDataField$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTargetAttrib$8[ebp], eax

; 9069 :       lpParentEntity    = zGETPTR( lpTargetAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpTargetAttrib$8[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntity$7[ebp], eax

; 9070 : 
; 9071 :       if ( lpParentEntity == lpChildEntity )

	mov	edx, DWORD PTR _lpParentEntity$7[ebp]
	cmp	edx, DWORD PTR _lpChildEntity$[ebp]
	jne	SHORT $LN5@fnAddHangi

; 9072 :       {
; 9073 :          TraceLineS( "(oi) Hangin key error! ", "- ParentEntity == ChildEntity" );

	push	OFFSET $SG16485
	push	OFFSET $SG16486
	call	_TraceLineS@8

; 9074 :          continue;

	jmp	SHORT $LN2@fnAddHangi
$LN5@fnAddHangi:

; 9075 :       }
; 9076 : 
; 9077 :       // Get the entity csr.
; 9078 :       fnValidViewEntity( &lpViewEntityCsr, lpView, lpParentEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpParentEntity$7[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$9[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 9079 : 
; 9080 :       if ( fnAttributeValueNull( lpView,

	mov	eax, DWORD PTR _lpTargetAttrib$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$9[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN6@fnAddHangi

; 9081 :                                  zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 9082 :                                  lpTargetAttrib ) )
; 9083 :       {
; 9084 :          continue;

	jmp	$LN2@fnAddHangi
$LN6@fnAddHangi:

; 9085 :       }
; 9086 : 
; 9087 :       // If we get here then the target attrib is not null.  This means we
; 9088 :       // need to create an entity instance (if not already created) and
; 9089 :       // copy the attribute value.
; 9090 : 
; 9091 :       if ( bEntityCreated == FALSE )

	movzx	edx, BYTE PTR _bEntityCreated$[ebp]
	test	edx, edx
	jne	SHORT $LN7@fnAddHangi

; 9092 :       {
; 9093 :          // Get the entity csr.
; 9094 :          fnValidViewEntity( &lpViewEntityCsr, lpView, lpChildEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$9[ebp]
	push	edx
	call	_fnValidViewEntity@16

; 9095 : 
; 9096 :          fnCreateEntity( lpView, lpChildEntity, lpViewEntityCsr, zPOS_NEXT, 0 );

	push	0
	push	3
	mov	eax, DWORD PTR _lpViewEntityCsr$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpChildEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnCreateEntity@20

; 9097 :          lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$9[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$6[ebp], eax

; 9098 :          lpEntityInstance->u.nInd.bHangingEntity = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$6[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1
	mov	ecx, DWORD PTR _lpEntityInstance$6[ebp]
	mov	DWORD PTR [ecx+6], eax

; 9099 : 
; 9100 :          bEntityCreated = TRUE;

	mov	BYTE PTR _bEntityCreated$[ebp], 1
$LN7@fnAddHangi:

; 9101 :       }
; 9102 : 
; 9103 :       GetValueFromRecord( lpView, lpParentEntity, lpTargetAttrib, &pchPtr,

	lea	edx, DWORD PTR _ulLth$3[ebp]
	push	edx
	lea	eax, DWORD PTR _chType$10[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchPtr$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTargetAttrib$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentEntity$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_GetValueFromRecord@24

; 9104 :                           &chType, &ulLth );
; 9105 : 
; 9106 :       lpSrcDataField = zGETPTR( lpRelField->hSrcDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcDataField$4[ebp], eax

; 9107 :       lpSrcAttrib    = zGETPTR( lpSrcDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpSrcDataField$4[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcAttrib$1[ebp], eax

; 9108 : 
; 9109 :       StoreValueInRecord( lpView, lpChildEntity, lpSrcAttrib, pchPtr, ulLth );

	mov	eax, DWORD PTR _ulLth$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchPtr$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcAttrib$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_StoreValueInRecord@20

; 9110 :    }

	jmp	$LN2@fnAddHangi
$LN3@fnAddHangi:

; 9111 : 
; 9112 :    return( 0 );

	xor	eax, eax

; 9113 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnAddHangingEntity@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_hEntityInstance$ = -12					; size = 4
_lpNextLinked$ = -8					; size = 4
_lpSearchLink$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnClearLinks@4 PROC

; 8574 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8575 :    LPENTITYINSTANCE lpNextLinked;
; 8576 :    LPENTITYINSTANCE lpSearchLink;
; 8577 :    LPENTITYINSTANCE hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 8578 : 
; 8579 :    lpNextLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax

; 8580 : 
; 8581 :    if ( lpNextLinked->hNextLinked == hEntityInstance )

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	cmp	ecx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $LN4@fnClearLin

; 8582 :       lpNextLinked->hNextLinked = 0;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+42], 0
	jmp	SHORT $LN1@fnClearLin
$LN4@fnClearLin:

; 8583 :    else
; 8584 :    {
; 8585 :       lpSearchLink = lpNextLinked;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$LN2@fnClearLin:

; 8586 :       while ( lpSearchLink->hNextLinked != hEntityInstance )

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	cmp	edx, DWORD PTR _hEntityInstance$[ebp]
	je	SHORT $LN3@fnClearLin

; 8587 :          lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
	jmp	SHORT $LN2@fnClearLin
$LN3@fnClearLin:

; 8588 : 
; 8589 :       lpSearchLink->hNextLinked = lpEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$LN1@fnClearLin:

; 8590 :    }
; 8591 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnClearLinks@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_ViewEntityCsr$ = -584					; size = 30
_lpApp$ = -552						; size = 4
_lpTask$1 = -548					; size = 4
_uPos$ = -544						; size = 4
_lTemp$2 = -540						; size = 4
_lpTask$ = -536						; size = 4
$T3 = -532						; size = 4
_lpViewCsr$ = -528					; size = 4
_lpViewOD$ = -524					; size = 4
$T4 = -520						; size = 4
$T5 = -516						; size = 4
tv217 = -512						; size = 4
_lHierCount$ = -508					; size = 4
_lInstanceCount$6 = -504				; size = 4
_lpSrcViewEntity$7 = -500				; size = 4
_vWork$8 = -496						; size = 4
_l$9 = -492						; size = 4
_lpCurrentEI$10 = -488					; size = 4
_lpWorkViewEntityCsr$11 = -484				; size = 4
_l$12 = -480						; size = 4
_nRC$ = -476						; size = 2
_lLastLinkedInstance$ = -472				; size = 4
_pch$13 = -468						; size = 4
_lpLinked$14 = -464					; size = 4
_nLevel$ = -460						; size = 2
_pchBuffer$ = -456					; size = 4
_uFlags$15 = -452					; size = 4
_lpViewEntityCsr$16 = -448				; size = 4
_lpSrchInstance$17 = -444				; size = 4
_pchAttr$ = -440					; size = 4
_lpViewEntity$ = -436					; size = 4
_lpViewOI$ = -432					; size = 4
_lpSourceEntityInstance$18 = -428			; size = 4
_bMsgBox$ = -422					; size = 1
_bValuesStored$19 = -421				; size = 1
_lpAttribFlags$ = -420					; size = 4
_ulLth$ = -416						; size = 4
_pchBufferEnd$20 = -412					; size = 4
_bNoTwins$21 = -408					; size = 1
_bEntityIsCompressed$22 = -407				; size = 1
_bAttribIsNull$23 = -406				; size = 1
_bStringContainsSpecialChars$24 = -405			; size = 1
_lpViewAttrib$ = -404					; size = 4
_cStreamType$25 = -397					; size = 1
_lpEntityInstance$ = -396				; size = 4
_k$ = -392						; size = 2
_szAttribName$26 = -388					; size = 50
_szLth$27 = -336					; size = 20
_szWorkString$ = -316					; size = 300
_szAttribFlags$28 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpfnStreamFunc$ = 12					; size = 4
_lpvData$ = 16						; size = 4
_bIncremental$ = 20					; size = 1
_lControl$ = 24						; size = 4
_fnWriteOI_ToTextStream PROC

; 6957 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 584				; 00000248H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6958 :    LPAPP                lpApp;
; 6959 :    LPVIEWOD             lpViewOD;
; 6960 :    LPVIEWOI             lpViewOI;
; 6961 :    LPVIEWENTITY         lpViewEntity;
; 6962 :    LPVIEWATTRIB         lpViewAttrib;
; 6963 :    LPVIEWCSR            lpViewCsr;
; 6964 :    LPENTITYINSTANCE     lpEntityInstance;
; 6965 :    ViewEntityCsrRecord  ViewEntityCsr;
; 6966 :    LPTASK               lpTask;
; 6967 :    LPATTRIBFLAGS        lpAttribFlags;
; 6968 :    zPCHAR               pchAttr;
; 6969 :    zPCHAR               pchBuffer = 0;

	mov	DWORD PTR _pchBuffer$[ebp], 0

; 6970 :    zCHAR                szWorkString[ 300 ];
; 6971 :    zLONG                lLastLinkedInstance;
; 6972 :    zLONG                lHierCount;
; 6973 :    zULONG               ulLth;
; 6974 :    zULONG               uPos;
; 6975 :    zBOOL                bMsgBox = TRUE;

	mov	BYTE PTR _bMsgBox$[ebp], 1

; 6976 :    zSHORT               nLevel;
; 6977 :    zSHORT               k;
; 6978 :    zSHORT               nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 6979 : 
; 6980 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6981 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6982 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6983 :    lpApp     = zGETPTR( lpViewOD->hApp );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 6984 :    lpTask    = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 6985 : 
; 6986 :    // If user wants entity tags, write out the tag for the OI.
; 6987 :    if ( lControl & zENTITY_TAGS )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 524288				; 00080000H
	je	SHORT $LN48@fnWriteOI_

; 6988 :    {
; 6989 :       if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	je	SHORT $LN50@fnWriteOI_

; 6990 :          zsprintf( szWorkString, "mOITAG %lx", (zLONG) lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	push	OFFSET $SG15911
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN51@fnWriteOI_
$LN50@fnWriteOI_:

; 6991 :       else
; 6992 :          zsprintf( szWorkString, "mOITAG      %lx", (zLONG) lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	push	OFFSET $SG15912
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN51@fnWriteOI_:

; 6993 : 
; 6994 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN52@fnWriteOI_

; 6995 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN193@fnWriteOI_
$LN52@fnWriteOI_:

; 6996 :    }

	jmp	SHORT $LN49@fnWriteOI_
$LN48@fnWriteOI_:

; 6997 :    else
; 6998 :    if ( lpViewOI->lTag )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN49@fnWriteOI_

; 6999 :    {
; 7000 :       // If the tag for the current OI is non-zero, then we'll write it.
; 7001 :       if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN54@fnWriteOI_

; 7002 :          zsprintf( szWorkString, "mOITAG %lx", lpViewOI->lTag );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	push	OFFSET $SG15917
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN55@fnWriteOI_
$LN54@fnWriteOI_:

; 7003 :       else
; 7004 :          zsprintf( szWorkString, "mOITAG      %lx", lpViewOI->lTag );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+52]
	push	eax
	push	OFFSET $SG15918
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN55@fnWriteOI_:

; 7005 : 
; 7006 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN49@fnWriteOI_

; 7007 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN193@fnWriteOI_
$LN49@fnWriteOI_:

; 7008 :    }
; 7009 : 
; 7010 :    // Set some flags.
; 7011 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnWriteOI_
$LN2@fnWriteOI_:

; 7013 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnWriteOI_:

; 7012 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN3@fnWriteOI_

; 7014 :    {
; 7015 :       lpEntityInstance->u.nInd.bWritten =

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -4097				; ffffefffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 7016 :          lpEntityInstance->u.nInd.bRecordOwner = FALSE;
; 7017 : 
; 7018 :       lpEntityInstance->lHierCount = 0;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+54], 0

; 7019 :    }

	jmp	SHORT $LN2@fnWriteOI_
$LN3@fnWriteOI_:

; 7020 : 
; 7021 :    // We need to write some information about the OI.
; 7022 :    if ( lControl & zINCREMENTAL )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	je	$LN57@fnWriteOI_

; 7023 :    {
; 7024 :       zULONG uFlags = 0;

	mov	DWORD PTR _uFlags$15[ebp], 0

; 7025 : 
; 7026 :       uFlags = 0;

	mov	DWORD PTR _uFlags$15[ebp], 0

; 7027 :       if ( lpViewOI->bIsLocked )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 7
	and	ecx, 1
	je	SHORT $LN58@fnWriteOI_

; 7028 :          uFlags |= zOI_ISLOCKED;

	mov	edx, DWORD PTR _uFlags$15[ebp]
	or	edx, 1
	mov	DWORD PTR _uFlags$15[ebp], edx
$LN58@fnWriteOI_:

; 7029 : 
; 7030 :       if ( lpView->bReadOnly )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN59@fnWriteOI_

; 7031 :          uFlags |= zOI_READONLY;

	mov	edx, DWORD PTR _uFlags$15[ebp]
	or	edx, 2
	mov	DWORD PTR _uFlags$15[ebp], edx
$LN59@fnWriteOI_:

; 7032 : 
; 7033 :       if ( uFlags )

	cmp	DWORD PTR _uFlags$15[ebp], 0
	je	SHORT $LN57@fnWriteOI_

; 7034 :       {
; 7035 :          if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	je	SHORT $LN61@fnWriteOI_

; 7036 :             zsprintf( szWorkString, "mOIFLAGS %lx", uFlags );

	mov	ecx, DWORD PTR _uFlags$15[ebp]
	push	ecx
	push	OFFSET $SG15926
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN62@fnWriteOI_
$LN61@fnWriteOI_:

; 7037 :          else
; 7038 :             zsprintf( szWorkString, "mOIFLAGS    %lx", uFlags );

	mov	eax, DWORD PTR _uFlags$15[ebp]
	push	eax
	push	OFFSET $SG15927
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN62@fnWriteOI_:

; 7039 : 
; 7040 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN57@fnWriteOI_

; 7041 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN193@fnWriteOI_
$LN57@fnWriteOI_:

; 7042 :       }
; 7043 :    }
; 7044 : 
; 7045 :    // If we are writting the OI in a compressed format, we need a buffer.
; 7046 :    if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	je	SHORT $LN64@fnWriteOI_

; 7047 :    {
; 7048 :       // Allocate a buffer to contain attribute data for an entity.
; 7049 :       pchBuffer = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10105					; 00002779H
	push	0
	push	0
	push	10000					; 00002710H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchBuffer$[ebp], eax

; 7050 :                                     zENTITY_BUFFER_SIZE, 0, 0, iBuffer );
; 7051 :       pchBuffer = zGETPTR( pchBuffer );

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchBuffer$[ebp], eax
$LN64@fnWriteOI_:

; 7052 :    }
; 7053 : 
; 7054 :    // write out the entity instances
; 7055 :    lpAttribFlags = 0;

	mov	DWORD PTR _lpAttribFlags$[ebp], 0

; 7056 :    lHierCount = 0;

	mov	DWORD PTR _lHierCount$[ebp], 0

; 7057 :    lLastLinkedInstance = -1;      // last linked relative instance counter

	mov	DWORD PTR _lLastLinkedInstance$[ebp], -1

; 7058 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN7@fnWriteOI_
$LN5@fnWriteOI_:

; 7060 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnWriteOI_:

; 7059 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN6@fnWriteOI_

; 7061 :    {
; 7062 :       zBOOL  bEntityIsCompressed;
; 7063 :       zPCHAR pchBufferEnd;
; 7064 :       zBOOL  bValuesStored;
; 7065 : 
; 7066 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7067 : 
; 7068 :       // This entity can be compressed if:
; 7069 :       // o  lControl specifies compression.
; 7070 :       // o  The max size of all the attributes for the entity is smaller
; 7071 :       //    then the buffer we set up to hold all the attribute values.
; 7072 :       bEntityIsCompressed = lControl & zCOMPRESSED &&

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN194@fnWriteOI_
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+203], 10000		; 00002710H
	jae	SHORT $LN194@fnWriteOI_
	mov	DWORD PTR tv217[ebp], 1
	jmp	SHORT $LN195@fnWriteOI_
$LN194@fnWriteOI_:
	mov	DWORD PTR tv217[ebp], 0
$LN195@fnWriteOI_:
	mov	al, BYTE PTR tv217[ebp]
	mov	BYTE PTR _bEntityIsCompressed$22[ebp], al

; 7073 :                             lpViewEntity->ulMaxLth < zENTITY_BUFFER_SIZE;
; 7074 : 
; 7075 : #if 0
; 7076 :       // DGC 02/25/98
; 7077 :       // Following code is called and may be (?) needed.
; 7078 :       if ( bIncremental &&
; 7079 :            lpEntityInstance->u.nInd.bExcluded &&
; 7080 :            lpEntityInstance->u.nInd.bDeleted &&
; 7081 :            lpEntityInstance->u.nInd.bCreated == FALSE &&
; 7082 :            lpEntityInstance->u.nInd.bIncluded == FALSE &&
; 7083 :            lpEntityInstance->u.nInd.bRelOwner &&
; 7084 :            lpViewEntity->bDelete == FALSE &&
; 7085 :            lpViewEntity->bExclude )
; 7086 :       {
; 7087 :          LPENTITYINSTANCE lpDupInstance;
; 7088 :          LPVIEWENTITY     lpDupViewEntity;
; 7089 : 
; 7090 :          lpDupInstance = lpEntityInstance;
; 7091 :          for ( ; ; )
; 7092 :          {
; 7093 :             lpDupInstance = fnFindDuplicateRelationship( lpDupInstance, 1, 0 );
; 7094 :             if ( lpDupInstance == 0 || lpDupInstance == lpEntityInstance )
; 7095 :                break;
; 7096 : 
; 7097 :             lpDupViewEntity = zGETPTR( lpDupInstance->hViewEntity );
; 7098 :             if ( lpDupInstance->u.nInd.bDeleted &&
; 7099 :                  lpDupViewEntity->bDerivedPath == FALSE &&
; 7100 :                  lpDupViewEntity->bDelete )
; 7101 :             {
; 7102 :                lpEntityInstance->u.nInd.bExcluded = FALSE;
; 7103 :                break;
; 7104 :             }
; 7105 :             else
; 7106 :             {
; 7107 :                lpDupInstance->u.nInd.bRelOwner = FALSE;
; 7108 :             }
; 7109 :          }
; 7110 :       }
; 7111 : #endif
; 7112 : 
; 7113 :       // Look to see if the current instance should be written out.  If
; 7114 :       // not we'll skip it and go on to the next one.  All non-hidden
; 7115 :       // instances get written so we'll look for that first.
; 7116 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	$LN65@fnWriteOI_

; 7117 :       {
; 7118 :          // The EI is hidden.  Don't write the current EI if we're not
; 7119 :          // writing incrementals or if the EI is dead.
; 7120 :          if ( bIncremental == FALSE ||

	movzx	eax, BYTE PTR _bIncremental$[ebp]
	test	eax, eax
	je	SHORT $LN67@fnWriteOI_
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnEntityInstanceIsDead@4
	movsx	edx, ax
	test	edx, edx
	je	$LN65@fnWriteOI_
$LN67@fnWriteOI_:

; 7121 :               fnEntityInstanceIsDead( lpEntityInstance ) )
; 7122 :          {
; 7123 :             nLevel = lpEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nLevel$[ebp], cx

; 7124 : 
; 7125 :             for ( lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN10@fnWriteOI_
$LN8@fnWriteOI_:

; 7127 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN10@fnWriteOI_:

; 7126 :                   lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN9@fnWriteOI_

; 7128 :             {
; 7129 :                if ( lpEntityInstance->nLevel <= nLevel )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN68@fnWriteOI_

; 7130 :                   break;

	jmp	SHORT $LN9@fnWriteOI_
$LN68@fnWriteOI_:

; 7131 :             }

	jmp	SHORT $LN8@fnWriteOI_
$LN9@fnWriteOI_:

; 7132 : 
; 7133 :             if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN69@fnWriteOI_

; 7134 :                break;

	jmp	$LN6@fnWriteOI_
	jmp	SHORT $LN70@fnWriteOI_
$LN69@fnWriteOI_:

; 7135 :             else
; 7136 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN70@fnWriteOI_:

; 7137 : 
; 7138 :             // Continue with the next EI.
; 7139 :             continue;

	jmp	$LN5@fnWriteOI_
$LN65@fnWriteOI_:

; 7140 :          }
; 7141 :       }
; 7142 : 
; 7143 :       lpEntityInstance->lHierCount = lHierCount++;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lHierCount$[ebp]
	mov	DWORD PTR [edx+54], eax
	mov	ecx, DWORD PTR _lHierCount$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lHierCount$[ebp], ecx

; 7144 : 
; 7145 :       // Build the entity name line.
; 7146 :       szWorkString[ 0 ] = 'e';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szWorkString$[ebp+eax], 101	; 00000065H

; 7147 :       if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN71@fnWriteOI_

; 7148 :       {
; 7149 :          // Use the hierarchical number instead of the entity name.
; 7150 :          zsprintf( szWorkString + 1, "%x %x", lpViewEntity->nHierNbr,

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	push	edx
	push	OFFSET $SG15938
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 7151 :                    lpEntityInstance->nLevel );
; 7152 :          k = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7153 :       }

	jmp	$LN72@fnWriteOI_
$LN71@fnWriteOI_:

; 7154 :       else
; 7155 :       {
; 7156 :          zstrcpy( szWorkString + 1, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp+1]
	push	eax
	call	_strcpy
	add	esp, 8

; 7157 :          k = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7158 : 
; 7159 :          szWorkString[ k++ ] = ' ';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 32	; 00000020H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN11@fnWriteOI_:

; 7160 :          while ( k < 11 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 11					; 0000000bH
	jge	SHORT $LN12@fnWriteOI_

; 7161 :             szWorkString[ k++ ] = ' ';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 32	; 00000020H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN11@fnWriteOI_
$LN12@fnWriteOI_:

; 7162 : 
; 7163 :          zltoa( lpEntityInstance->nLevel, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7164 :          k = zstrlen( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax
$LN72@fnWriteOI_:

; 7165 :       }
; 7166 : 
; 7167 :       // if we are writing an incremental file, write out the indicators.
; 7168 :       if ( bIncremental )

	movzx	eax, BYTE PTR _bIncremental$[ebp]
	test	eax, eax
	je	$LN73@fnWriteOI_

; 7169 :       {
; 7170 :          szWorkString[ k++ ] = ',';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 44	; 0000002cH
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7171 :          zbtoa( lpEntityInstance->u.nIndicators, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7172 : 
; 7173 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN73@fnWriteOI_

; 7174 :          {
; 7175 :             zLONG lTemp;
; 7176 : 
; 7177 :             // Convert number for decimal format to hexadecimal.
; 7178 :             lTemp = zatol( &szWorkString[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	lea	eax, DWORD PTR _szWorkString$[ebp+edx]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lTemp$2[ebp], eax

; 7179 :             zltox( lTemp, &szWorkString[ k ] );

	push	16					; 00000010H
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lTemp$2[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN73@fnWriteOI_:

; 7180 :          }
; 7181 :       }
; 7182 : 
; 7183 :       // Write out the entity name.
; 7184 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN75@fnWriteOI_

; 7185 :          goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN75@fnWriteOI_:

; 7186 : 
; 7187 :       // If user wants entity tags, write it.
; 7188 :       if ( lControl & zENTITY_TAGS )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 524288				; 00080000H
	je	SHORT $LN76@fnWriteOI_

; 7189 :       {
; 7190 :          if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	je	SHORT $LN78@fnWriteOI_

; 7191 :             zsprintf( szWorkString, "mETAG %lx", (zLONG) lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	OFFSET $SG15946
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN79@fnWriteOI_
$LN78@fnWriteOI_:

; 7192 :          else
; 7193 :             zsprintf( szWorkString, "mETAG      %lx", (zLONG) lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	OFFSET $SG15947
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN79@fnWriteOI_:

; 7194 : 
; 7195 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN80@fnWriteOI_

; 7196 :             goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN80@fnWriteOI_:

; 7197 :       }

	jmp	SHORT $LN77@fnWriteOI_
$LN76@fnWriteOI_:

; 7198 :       else
; 7199 :       if ( lpEntityInstance->lTag )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+46], 0
	je	SHORT $LN77@fnWriteOI_

; 7200 :       {
; 7201 :          // If the tag for the current entity instance is non-zero, then we'll
; 7202 :          // write it.
; 7203 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN82@fnWriteOI_

; 7204 :             zsprintf( szWorkString, "mETAG %lx", lpEntityInstance->lTag );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+46]
	push	eax
	push	OFFSET $SG15952
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN83@fnWriteOI_
$LN82@fnWriteOI_:

; 7205 :          else
; 7206 :             zsprintf( szWorkString, "mETAG      %lx", lpEntityInstance->lTag );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+46]
	push	eax
	push	OFFSET $SG15953
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN83@fnWriteOI_:

; 7207 : 
; 7208 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN77@fnWriteOI_

; 7209 :             goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN77@fnWriteOI_:

; 7210 :       }
; 7211 : 
; 7212 :       if ( lControl & zENTITY_KEYS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2097152				; 00200000H
	je	SHORT $LN85@fnWriteOI_

; 7213 :       {
; 7214 :          if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN86@fnWriteOI_

; 7215 :             zsprintf( szWorkString, "mEKEY %lx", lpEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET $SG15958
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN87@fnWriteOI_
$LN86@fnWriteOI_:

; 7216 :          else
; 7217 :             zsprintf( szWorkString, "mEKEY      %lx", lpEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET $SG15959
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN87@fnWriteOI_:

; 7218 : 
; 7219 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN85@fnWriteOI_

; 7220 :             goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN85@fnWriteOI_:

; 7221 :       }
; 7222 : 
; 7223 :       // If the EI has already been written (this means it's linked to another
; 7224 :       // EI that has already been written) and it has no non-persist record,
; 7225 :       // then we don't need to write it's attribute values.
; 7226 :       lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 7227 :       if ( lpEntityInstance->u.nInd.bWritten )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	je	SHORT $LN89@fnWriteOI_

; 7228 :       {
; 7229 :          lLastLinkedInstance = lpEntityInstance->lHierCount;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	mov	DWORD PTR _lLastLinkedInstance$[ebp], edx

; 7230 : 
; 7231 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE &&

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN89@fnWriteOI_
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+64], 0
	jne	SHORT $LN89@fnWriteOI_

; 7232 :               lpEntityInstance->hNonPersistRecord == FALSE )
; 7233 :          {
; 7234 :             bEntityIsCompressed = FALSE; // Make sure we don't write anything

	mov	BYTE PTR _bEntityIsCompressed$22[ebp], 0

; 7235 :             lpViewAttrib = 0;

	mov	DWORD PTR _lpViewAttrib$[ebp], 0
$LN89@fnWriteOI_:

; 7236 :          }
; 7237 :       }
; 7238 : 
; 7239 :       // Set flag to indicate that entity instance has been written to
; 7240 :       // the stream.  Let's also mark all the linked instances.
; 7241 :       if ( lpEntityInstance->u.nInd.bWritten == FALSE &&

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	jne	$LN91@fnWriteOI_
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN91@fnWriteOI_

; 7242 :            lpEntityInstance->hNextLinked )
; 7243 :       {
; 7244 :          LPENTITYINSTANCE lpLinked;
; 7245 : 
; 7246 :          // Set the record owner.  This means that this EI will not have
; 7247 :          // link lines written (e.g. "i38,102") for it.
; 7248 :          lpEntityInstance->u.nInd.bRecordOwner = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 7249 : 
; 7250 :          for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$14[ebp], eax
	jmp	SHORT $LN15@fnWriteOI_
$LN13@fnWriteOI_:

; 7252 :                lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpLinked$14[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$14[ebp], eax
$LN15@fnWriteOI_:

; 7251 :                lpLinked != lpEntityInstance;

	mov	ecx, DWORD PTR _lpLinked$14[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN91@fnWriteOI_

; 7253 :          {
; 7254 :             // For a little insurance we'll only set the flags for EIs in
; 7255 :             // the same OI.
; 7256 :             if ( lpLinked->hViewOI == lpEntityInstance->hViewOI )

	mov	edx, DWORD PTR _lpLinked$14[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	jne	SHORT $LN92@fnWriteOI_

; 7257 :                lpLinked->u.nInd.bWritten = TRUE;

	mov	edx, DWORD PTR _lpLinked$14[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _lpLinked$14[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN92@fnWriteOI_:

; 7258 :          }

	jmp	SHORT $LN13@fnWriteOI_
$LN91@fnWriteOI_:

; 7259 :       }
; 7260 : 
; 7261 :       lpEntityInstance->u.nInd.bWritten = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 7262 : 
; 7263 :       // Some stuff needs to be done if we're storing in compressed format...
; 7264 :       if ( bEntityIsCompressed )

	movzx	edx, BYTE PTR _bEntityIsCompressed$22[ebp]
	test	edx, edx
	je	SHORT $LN93@fnWriteOI_

; 7265 :       {
; 7266 :          // pchBufferEnd points to the first unused byte in the compression
; 7267 :          // buffer.
; 7268 :          pchBufferEnd = pchBuffer;

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _pchBufferEnd$20[ebp], eax

; 7269 : 
; 7270 :          // In rare cases an entity will have all NULL attribute
; 7271 :          // values (this will usually occur when an instance is linked).
; 7272 :          // If that happens, don't bother writting the attribute values.
; 7273 :          bValuesStored = FALSE;

	mov	BYTE PTR _bValuesStored$19[ebp], 0
$LN93@fnWriteOI_:

; 7274 :       }
; 7275 : 
; 7276 :       ViewEntityCsr.hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _ViewEntityCsr$[ebp+26], eax

; 7277 : 
; 7278 :       // Write the attribute values.
; 7279 :       for ( ;              // assigned above

	jmp	SHORT $LN18@fnWriteOI_
$LN16@fnWriteOI_:

; 7281 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN18@fnWriteOI_:

; 7280 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN17@fnWriteOI_

; 7282 :       {
; 7283 :          static AttribFlagsRecord ZeroAttribFlags = { 0 };
; 7284 : 
; 7285 :          // If attribute is derived, don't bother.
; 7286 :          if ( lpViewAttrib->szDerivedOper[ 0 ] &&

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN94@fnWriteOI_
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	jne	SHORT $LN94@fnWriteOI_

; 7287 :               lpViewAttrib->bPersist == FALSE )
; 7288 :          {
; 7289 :             continue;

	jmp	SHORT $LN16@fnWriteOI_
$LN94@fnWriteOI_:

; 7290 :          }
; 7291 : 
; 7292 :          // If we are only writing keys and this attr isn't a key then skip it.
; 7293 :          if ( lControl & zWRITE_KEYS_ONLY && lpViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1048576				; 00100000H
	je	SHORT $LN95@fnWriteOI_
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN95@fnWriteOI_

; 7294 :             continue;

	jmp	SHORT $LN16@fnWriteOI_
$LN95@fnWriteOI_:

; 7295 : 
; 7296 :          // Get a pointer to the attribute flags if we are writing incremental
; 7297 :          // flags.  If we're not writing incremental then we'll leave the ptr
; 7298 :          // as it is--WHICH HAD BETTER BE 0.
; 7299 :          if ( bIncremental )

	movzx	ecx, BYTE PTR _bIncremental$[ebp]
	test	ecx, ecx
	je	SHORT $LN96@fnWriteOI_

; 7300 :          {
; 7301 :             lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$[ebp], eax

; 7302 :                                                  lpViewAttrib );
; 7303 : 
; 7304 :             // If lpAttribFlags is 0 then this means that a data record
; 7305 :             // (i.e. data stick) has been created for this attrib.  Just set
; 7306 :             // lpAttribFlags to point to a 0 flag record.
; 7307 :             if ( lpAttribFlags == 0 )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	jne	SHORT $LN96@fnWriteOI_

; 7308 :                lpAttribFlags = &ZeroAttribFlags;

	mov	DWORD PTR _lpAttribFlags$[ebp], OFFSET ?ZeroAttribFlags@?BO@??fnWriteOI_ToTextStream@@9@9
$LN96@fnWriteOI_:

; 7309 :          }
; 7310 : 
; 7311 :          if ( bEntityIsCompressed && lpViewAttrib->cType != zTYPE_BLOB )

	movzx	ecx, BYTE PTR _bEntityIsCompressed$22[ebp]
	test	ecx, ecx
	je	$LN98@fnWriteOI_
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	je	$LN98@fnWriteOI_

; 7312 :          {
; 7313 :             // If the entity is linked with another, then we don't need to store
; 7314 :             // the attribute value, but we do need to store a dummy value in the
; 7315 :             // attribute buffer.
; 7316 :             if ( lpViewAttrib->bPersist &&

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	je	SHORT $LN100@fnWriteOI_
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+54]
	cmp	ecx, DWORD PTR _lLastLinkedInstance$[ebp]
	jne	SHORT $LN100@fnWriteOI_

; 7317 :                  lpEntityInstance->lHierCount == lLastLinkedInstance )
; 7318 :             {
; 7319 :                *pchBufferEnd++ = 0;

	mov	edx, DWORD PTR _pchBufferEnd$20[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _pchBufferEnd$20[ebp]
	add	eax, 1
	mov	DWORD PTR _pchBufferEnd$20[ebp], eax

; 7320 :                continue;

	jmp	$LN16@fnWriteOI_
$LN100@fnWriteOI_:

; 7321 :             }
; 7322 : 
; 7323 :             if ( lpViewAttrib->cType == zTYPE_INTEGER )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN101@fnWriteOI_

; 7324 :             {
; 7325 :                zLONG l;
; 7326 : 
; 7327 :                if ( fnGetIntegerFromAttribute( &l, lpView, &ViewEntityCsr,
; 7328 :                                                lpViewAttrib ) != 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _l$9[ebp]
	push	eax
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN103@fnWriteOI_

; 7329 :                {
; 7330 :                   // Integer is null so set null value.
; 7331 :                   *pchBufferEnd = 0;

	mov	edx, DWORD PTR _pchBufferEnd$20[ebp]
	mov	BYTE PTR [edx], 0

; 7332 :                }

	jmp	SHORT $LN104@fnWriteOI_
$LN103@fnWriteOI_:

; 7333 :                else
; 7334 :                if ( l >= 0 )

	cmp	DWORD PTR _l$9[ebp], 0
	jl	SHORT $LN105@fnWriteOI_

; 7335 :                   zltox( l, pchBufferEnd );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pchBufferEnd$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _l$9[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN104@fnWriteOI_
$LN105@fnWriteOI_:

; 7336 :                else
; 7337 :                {
; 7338 :                   *pchBufferEnd = '-';

	mov	edx, DWORD PTR _pchBufferEnd$20[ebp]
	mov	BYTE PTR [edx], 45			; 0000002dH

; 7339 :                   zltox( l * -1, pchBufferEnd + 1 );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pchBufferEnd$20[ebp]
	add	eax, 1
	push	eax
	imul	ecx, DWORD PTR _l$9[ebp], -1
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN104@fnWriteOI_:

; 7340 :                }
; 7341 :             }

	jmp	SHORT $LN102@fnWriteOI_
$LN101@fnWriteOI_:

; 7342 :             else
; 7343 :                fnGetStringFromAttribute( pchBufferEnd, zENTITY_BUFFER_SIZE,

	push	0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	lea	eax, DWORD PTR _ViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	10000					; 00002710H
	mov	edx, DWORD PTR _pchBufferEnd$20[ebp]
	push	edx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
$LN102@fnWriteOI_:

; 7344 :                                          lpView, &ViewEntityCsr,
; 7345 :                                          lpViewAttrib, 0 );
; 7346 : 
; 7347 :             // Check to see if we have a valid (i.e. non-null) attribute
; 7348 :             // value.  If we do, then we've stored a "real" value.
; 7349 :             if ( *pchBufferEnd )

	mov	eax, DWORD PTR _pchBufferEnd$20[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN107@fnWriteOI_

; 7350 :                bValuesStored = TRUE;

	mov	BYTE PTR _bValuesStored$19[ebp], 1
$LN107@fnWriteOI_:

; 7351 : 
; 7352 :             pchBufferEnd += zstrlen( pchBufferEnd ) + 1;

	mov	edx, DWORD PTR _pchBufferEnd$20[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchBufferEnd$20[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchBufferEnd$20[ebp], edx

; 7353 : 
; 7354 :             // If the attrib flags is not 0 then we need to write them as well.
; 7355 :             if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $LN108@fnWriteOI_

; 7356 :             {
; 7357 :                zltox( (zLONG) lpAttribFlags->u.uFlags, pchBufferEnd );

	push	16					; 00000010H
	mov	eax, DWORD PTR _pchBufferEnd$20[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7358 :                pchBufferEnd += zstrlen( pchBufferEnd ) + 1;

	mov	eax, DWORD PTR _pchBufferEnd$20[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _pchBufferEnd$20[ebp]
	lea	edx, DWORD PTR [ecx+eax+1]
	mov	DWORD PTR _pchBufferEnd$20[ebp], edx
$LN108@fnWriteOI_:

; 7359 :             }
; 7360 : 
; 7361 :          } // if ( bEntityIsCompressed && lpViewAttrib->cType != zTYPE_BLOB )...

	jmp	$LN99@fnWriteOI_
$LN98@fnWriteOI_:

; 7362 :          else
; 7363 :          {
; 7364 :             zBOOL bStringContainsSpecialChars;
; 7365 :             zCHAR szAttribFlags[ 12 ];
; 7366 : 
; 7367 :             // If the current entity instance is a linked instance then we
; 7368 :             // don't need to store the attribute values because they'll be
; 7369 :             // included from the linked instance.  This is only TRUE for
; 7370 :             // persistent attributes.  Non-persistent attrs need to be stored
; 7371 :             // with the current EI.
; 7372 :             if ( lpViewAttrib->bPersist &&

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	je	SHORT $LN109@fnWriteOI_
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+54]
	cmp	eax, DWORD PTR _lLastLinkedInstance$[ebp]
	jne	SHORT $LN109@fnWriteOI_

; 7373 :                  lpEntityInstance->lHierCount == lLastLinkedInstance )
; 7374 :             {
; 7375 :                continue;

	jmp	$LN16@fnWriteOI_
$LN109@fnWriteOI_:

; 7376 :             }
; 7377 : 
; 7378 :             // If lpAttribFlags is not 0 then we're supposed to send the
; 7379 :             // attrib flags for each attribute.  To save space we won't bother
; 7380 :             // sending the flags if they are all off.
; 7381 :             if ( lpAttribFlags && lpAttribFlags->u.uFlags == 0 )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $LN110@fnWriteOI_
	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN110@fnWriteOI_

; 7382 :                lpAttribFlags = 0;   // Indicates: don't bother sending flags.

	mov	DWORD PTR _lpAttribFlags$[ebp], 0
$LN110@fnWriteOI_:

; 7383 : 
; 7384 :             // If the attrib flags is not 0 then set up string.
; 7385 :             if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $LN111@fnWriteOI_

; 7386 :                zsprintf( szAttribFlags, ",%lx", lpAttribFlags->u.uFlags );

	mov	edx, DWORD PTR _lpAttribFlags$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET $SG15985
	lea	ecx, DWORD PTR _szAttribFlags$28[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN112@fnWriteOI_
$LN111@fnWriteOI_:

; 7387 :             else
; 7388 :                szAttribFlags[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T5[ebp], eax
	cmp	DWORD PTR $T5[ebp], 12			; 0000000cH
	jae	SHORT $LN196@fnWriteOI_
	jmp	SHORT $LN197@fnWriteOI_
$LN196@fnWriteOI_:
	call	___report_rangecheckfailure
$LN197@fnWriteOI_:
	mov	ecx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _szAttribFlags$28[ebp+ecx], 0
$LN112@fnWriteOI_:

; 7389 : 
; 7390 :             // If we are here and zCOMPRESSED has been specified, then
; 7391 :             // the entity can't be compressed for some reason (the attribute
; 7392 :             // might be a blob, etc.) but we can still save a few bytes by
; 7393 :             // using XVATOK instead of the name.
; 7394 :             if ( lControl & zCOMPRESSED )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	je	SHORT $LN113@fnWriteOI_

; 7395 :                zsprintf( szWorkString, "a%lx%s ", lpViewAttrib->lXVAAttTok,

	lea	eax, DWORD PTR _szAttribFlags$28[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+181]
	push	edx
	push	OFFSET $SG15988
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN114@fnWriteOI_
$LN113@fnWriteOI_:

; 7396 :                          szAttribFlags );
; 7397 :             else
; 7398 :             {
; 7399 :                zCHAR szAttribName[ 50 ];
; 7400 : 
; 7401 :                zsprintf( szAttribName, "%s%s", lpViewAttrib->szName,

	lea	ecx, DWORD PTR _szAttribFlags$28[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG15989
	lea	eax, DWORD PTR _szAttribName$26[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 7402 :                          szAttribFlags );
; 7403 :                zsprintf( szWorkString, "a%-9s ", szAttribName );

	lea	ecx, DWORD PTR _szAttribName$26[ebp]
	push	ecx
	push	OFFSET $SG15990
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN114@fnWriteOI_:

; 7404 :             }
; 7405 : 
; 7406 :             k = zstrlen( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 7407 : 
; 7408 :             fnGetAddrForAttribute( &pchAttr, lpView, &ViewEntityCsr, 0,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _ViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchAttr$[ebp]
	push	ecx
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H

; 7409 :                                    lpViewAttrib );
; 7410 : 
; 7411 :             // If we are dealing with a string, check to see if
; 7412 :             // it contains any special chars (e.g. '\n'). If it does, then
; 7413 :             // we have to store the string as a blob.
; 7414 :             bStringContainsSpecialChars = FALSE;

	mov	BYTE PTR _bStringContainsSpecialChars$24[ebp], 0

; 7415 :             if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN115@fnWriteOI_

; 7416 :             {
; 7417 :                zPCHAR pch = pchAttr;

	mov	ecx, DWORD PTR _pchAttr$[ebp]
	mov	DWORD PTR _pch$13[ebp], ecx

; 7418 : 
; 7419 :                // We also store the string as a blob if it has more than
; 7420 :                // 254 chars.
; 7421 :                if ( zstrlen( pch ) > 254 )

	mov	edx, DWORD PTR _pch$13[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 254				; 000000feH
	jbe	SHORT $LN19@fnWriteOI_

; 7422 :                   bStringContainsSpecialChars = TRUE;

	mov	BYTE PTR _bStringContainsSpecialChars$24[ebp], 1
	jmp	SHORT $LN115@fnWriteOI_
$LN19@fnWriteOI_:

; 7423 :                else
; 7424 :                   while ( pch[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pch$13[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN115@fnWriteOI_

; 7425 :                   {
; 7426 :                      if ( CHAR_IS_SPECIAL( pch[ 0 ] ) )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pch$13[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN118@fnWriteOI_

; 7427 :                      {
; 7428 :                         bStringContainsSpecialChars = TRUE;

	mov	BYTE PTR _bStringContainsSpecialChars$24[ebp], 1

; 7429 :                         break;

	jmp	SHORT $LN115@fnWriteOI_
$LN118@fnWriteOI_:

; 7430 :                      }
; 7431 : 
; 7432 :                      pch++;

	mov	edx, DWORD PTR _pch$13[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$13[ebp], edx

; 7433 :                   }

	jmp	SHORT $LN19@fnWriteOI_
$LN115@fnWriteOI_:

; 7434 :             }
; 7435 : 
; 7436 :             if ( lpViewAttrib->cType == zTYPE_BLOB ||

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	je	SHORT $LN121@fnWriteOI_
	movzx	edx, BYTE PTR _bStringContainsSpecialChars$24[ebp]
	test	edx, edx
	je	$LN119@fnWriteOI_
$LN121@fnWriteOI_:

; 7437 :                  bStringContainsSpecialChars )
; 7438 :             {
; 7439 :                zCHAR cStreamType;
; 7440 : 
; 7441 :                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN122@fnWriteOI_

; 7442 :                {
; 7443 :                   fnGetAttributeLength( &ulLth, lpView,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _ViewEntityCsr$[ebp+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 7444 :                                         zGETPTR( ViewEntityCsr.hEntityInstance ),
; 7445 :                                         lpViewAttrib );
; 7446 :                   cStreamType = zTYPE_BLOB;

	mov	BYTE PTR _cStreamType$25[ebp], 66	; 00000042H

; 7447 :                }

	jmp	SHORT $LN123@fnWriteOI_
$LN122@fnWriteOI_:

; 7448 :                else
; 7449 :                {
; 7450 :                   ulLth = zstrlen( pchAttr ) + 1;

	mov	eax, DWORD PTR _pchAttr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _ulLth$[ebp], eax

; 7451 :                   if ( ulLth == 1 )

	cmp	DWORD PTR _ulLth$[ebp], 1
	jne	SHORT $LN124@fnWriteOI_

; 7452 :                      ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0
$LN124@fnWriteOI_:

; 7453 : 
; 7454 :                   cStreamType = zTYPE_STRING;

	mov	BYTE PTR _cStreamType$25[ebp], 83	; 00000053H
$LN123@fnWriteOI_:

; 7455 :                }
; 7456 : 
; 7457 :                // If the attribute has a length, then write the length and
; 7458 :                // then the value.
; 7459 :                if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	$LN125@fnWriteOI_

; 7460 :                {
; 7461 :                   // If we're storing a string with "special" chars, then the
; 7462 :                   // first byte before the length is the "special" flag.
; 7463 :                   if ( bStringContainsSpecialChars )

	movzx	ecx, BYTE PTR _bStringContainsSpecialChars$24[ebp]
	test	ecx, ecx
	je	SHORT $LN127@fnWriteOI_

; 7464 :                      szWorkString[ k++ ] = zSTRING_STORED_AS_BLOB;

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 31	; 0000001fH
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN128@fnWriteOI_
$LN127@fnWriteOI_:

; 7465 :                   else
; 7466 :                   if ( lControl & zENCODE_BLOBS )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 4194304				; 00400000H
	je	SHORT $LN128@fnWriteOI_

; 7467 :                      szWorkString[ k++ ] = zBLOB_STORED_ENCODED;

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 85	; 00000055H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN128@fnWriteOI_:

; 7468 : 
; 7469 :                   zltoa( ulLth, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7470 : 
; 7471 :                   // write out the attribute name and length
; 7472 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN130@fnWriteOI_

; 7473 :                                           zTYPE_STRING ) )
; 7474 :                      goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN130@fnWriteOI_:

; 7475 : 
; 7476 :                   // write out the data
; 7477 :                   if ( cStreamType == zTYPE_BLOB && (lControl & zENCODE_BLOBS) )

	movsx	edx, BYTE PTR _cStreamType$25[ebp]
	cmp	edx, 66					; 00000042H
	jne	$LN131@fnWriteOI_
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 4194304				; 00400000H
	je	$LN131@fnWriteOI_

; 7478 :                   {
; 7479 :                      uPos = 0;

	mov	DWORD PTR _uPos$[ebp], 0
$LN21@fnWriteOI_:

; 7480 :                      while ( UUENCODE_NextEncodedLine( szWorkString, pchAttr,
; 7481 :                                                        ulLth, &uPos ) == 1)

	lea	ecx, DWORD PTR _uPos$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchAttr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_UUENCODE_NextEncodedLine@16
	movsx	edx, ax
	cmp	edx, 1
	jne	SHORT $LN22@fnWriteOI_

; 7482 :                      {
; 7483 :                         //TraceLineS( "Encoded Line: ", szWorkString);
; 7484 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, cStreamType ) )

	movzx	eax, BYTE PTR _cStreamType$25[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN133@fnWriteOI_

; 7485 :                            goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN133@fnWriteOI_:

; 7486 :                      }

	jmp	SHORT $LN21@fnWriteOI_
$LN22@fnWriteOI_:

; 7487 : 
; 7488 :                      //TraceLineS( "Encoded Line: ", szWorkString);
; 7489 :                      if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, cStreamType ) )

	movzx	edx, BYTE PTR _cStreamType$25[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	cwde
	test	eax, eax
	je	SHORT $LN134@fnWriteOI_

; 7490 :                         goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN134@fnWriteOI_:

; 7491 :                   }

	jmp	$LN132@fnWriteOI_
$LN131@fnWriteOI_:

; 7492 :                   else
; 7493 :                   if ( cStreamType == zTYPE_STRING )

	movsx	ecx, BYTE PTR _cStreamType$25[ebp]
	cmp	ecx, 83					; 00000053H
	jne	$LN135@fnWriteOI_

; 7494 :                   {
; 7495 :                      // PAS 03/09/2001 - to eliminate x00 in the portable
; 7496 :                      //                  files, we temporarily change the
; 7497 :                      //                  byte to the char 0.
; 7498 :                      if ( lControl & zNO_NULL_STRING_TERM )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 8388608				; 00800000H
	je	SHORT $LN137@fnWriteOI_

; 7499 :                      {
; 7500 :                         pchAttr[ ulLth - 1 ] = '0';

	mov	eax, DWORD PTR _pchAttr$[ebp]
	add	eax, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [eax-1], 48			; 00000030H

; 7501 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,

	movzx	ecx, BYTE PTR _cStreamType$25[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchAttr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	cwde
	test	eax, eax
	je	SHORT $LN139@fnWriteOI_

; 7502 :                                                 ulLth, cStreamType ) )
; 7503 :                         {
; 7504 :                            pchAttr[ ulLth - 1 ] = 0;

	mov	ecx, DWORD PTR _pchAttr$[ebp]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [ecx-1], 0

; 7505 :                            goto EndOfFunction;

	jmp	$EndOfFunction$202

; 7506 :                         }

	jmp	SHORT $LN140@fnWriteOI_
$LN139@fnWriteOI_:

; 7507 :                         else
; 7508 :                            pchAttr[ ulLth - 1 ] = 0;

	mov	edx, DWORD PTR _pchAttr$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx-1], 0
$LN140@fnWriteOI_:

; 7509 : 
; 7510 :                      // PAS 03/09/2001 - and above, we change it back before
; 7511 :                      //                  returning
; 7512 :                      }

	jmp	SHORT $LN138@fnWriteOI_
$LN137@fnWriteOI_:

; 7513 :                      else
; 7514 :                      {
; 7515 :                         if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,

	movzx	eax, BYTE PTR _cStreamType$25[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN138@fnWriteOI_

; 7516 :                                                 ulLth, cStreamType ) )
; 7517 :                         {
; 7518 :                            goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN138@fnWriteOI_:

; 7519 :                         }
; 7520 :                      }
; 7521 :                   }

	jmp	SHORT $LN132@fnWriteOI_
$LN135@fnWriteOI_:

; 7522 :                   else
; 7523 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, pchAttr,

	movzx	eax, BYTE PTR _cStreamType$25[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN132@fnWriteOI_

; 7524 :                                           ulLth, cStreamType ) )
; 7525 :                   {
; 7526 :                      goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN132@fnWriteOI_:

; 7527 :                   }
; 7528 :                }

	jmp	$LN126@fnWriteOI_
$LN125@fnWriteOI_:

; 7529 :                else
; 7530 :                if ( lpAttribFlags )

	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	$LN126@fnWriteOI_

; 7531 :                {
; 7532 :                   // We need to write the attrib flags so write the attribute
; 7533 :                   // value as NULL.
; 7534 :                   if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN144@fnWriteOI_

; 7535 :                   {
; 7536 :                      // Add "0" to the end of the string.
; 7537 :                      szWorkString[ k++ ] = '0';

	movsx	edx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 48	; 00000030H
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN144@fnWriteOI_:

; 7538 :                   }
; 7539 : 
; 7540 :                   // Null-terminate the string.
; 7541 :                   szWorkString[ k++ ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
	cmp	DWORD PTR $T4[ebp], 300			; 0000012cH
	jae	SHORT $LN198@fnWriteOI_
	jmp	SHORT $LN199@fnWriteOI_
$LN198@fnWriteOI_:
	call	___report_rangecheckfailure
$LN199@fnWriteOI_:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0

; 7542 : 
; 7543 :                   // Write it.
; 7544 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN126@fnWriteOI_

; 7545 :                                           zTYPE_STRING ) )
; 7546 :                   {
; 7547 :                      goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN126@fnWriteOI_:

; 7548 :                   }
; 7549 :                }
; 7550 :             } // if ( lpViewAttrib->cType == zTYPE_BLOB || )...

	jmp	$LN99@fnWriteOI_
$LN119@fnWriteOI_:

; 7551 :             else
; 7552 :             {
; 7553 :                zBOOL bAttribIsNull;
; 7554 : 
; 7555 :                // Check to see if we are writing compressed.  This might happen
; 7556 :                // if there are too many attributes to write in the compress
; 7557 :                // buffer.
; 7558 :                if ( lControl & zCOMPRESSED &&

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	je	$LN146@fnWriteOI_
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 76					; 0000004cH
	jne	$LN146@fnWriteOI_

; 7559 :                     lpViewAttrib->cType == zTYPE_INTEGER )
; 7560 :                {
; 7561 :                   zLONG l;
; 7562 : 
; 7563 :                   // We are writing a compressed file so convert the value to
; 7564 :                   // a hex number.
; 7565 :                   if ( fnGetIntegerFromAttribute( &l, lpView, &ViewEntityCsr,
; 7566 :                                                   lpViewAttrib ) == -1 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	lea	eax, DWORD PTR _ViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _l$12[ebp]
	push	edx
	call	_fnGetIntegerFromAttribute
	add	esp, 16					; 00000010H
	cwde
	cmp	eax, -1
	jne	SHORT $LN148@fnWriteOI_

; 7567 :                   {
; 7568 :                      bAttribIsNull = TRUE;

	mov	BYTE PTR _bAttribIsNull$23[ebp], 1

; 7569 : 
; 7570 :                      // Write the attribute value as a '*' to indicate that the
; 7571 :                      // integer is null.
; 7572 :                      szWorkString[ k++ ] = '*';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 42	; 0000002aH
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7573 :                      szWorkString[ k++ ] = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	DWORD PTR $T3[ebp], eax
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
	cmp	DWORD PTR $T3[ebp], 300			; 0000012cH
	jae	SHORT $LN200@fnWriteOI_
	jmp	SHORT $LN201@fnWriteOI_
$LN200@fnWriteOI_:
	call	___report_rangecheckfailure
$LN201@fnWriteOI_:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 0

; 7574 :                   }

	jmp	SHORT $LN149@fnWriteOI_
$LN148@fnWriteOI_:

; 7575 :                   else
; 7576 :                   {
; 7577 :                      bAttribIsNull = FALSE;

	mov	BYTE PTR _bAttribIsNull$23[ebp], 0

; 7578 : 
; 7579 :                      if ( l < 0 )

	cmp	DWORD PTR _l$12[ebp], 0
	jge	SHORT $LN150@fnWriteOI_

; 7580 :                      {
; 7581 :                         szWorkString[ k++ ] = '-';

	movsx	eax, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 45	; 0000002dH
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx

; 7582 :                         l = l * -1;

	imul	edx, DWORD PTR _l$12[ebp], -1
	mov	DWORD PTR _l$12[ebp], edx
$LN150@fnWriteOI_:

; 7583 :                      }
; 7584 : 
; 7585 :                      zltox( l, &szWorkString[ k ] );

	push	16					; 00000010H
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _l$12[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN149@fnWriteOI_:

; 7586 :                   }
; 7587 :                }

	jmp	SHORT $LN147@fnWriteOI_
$LN146@fnWriteOI_:

; 7588 :                else
; 7589 :                {
; 7590 :                   if ( fnGetStringFromAttribute( &szWorkString[ k ], 255,
; 7591 :                                                  lpView,
; 7592 :                                                  &ViewEntityCsr,
; 7593 :                                                  lpViewAttrib, 0 ) == -1 )

	push	0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	255					; 000000ffH
	movsx	eax, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN151@fnWriteOI_

; 7594 :                   {
; 7595 :                      bAttribIsNull = TRUE;

	mov	BYTE PTR _bAttribIsNull$23[ebp], 1

; 7596 :                   }

	jmp	SHORT $LN147@fnWriteOI_
$LN151@fnWriteOI_:

; 7597 :                   else
; 7598 :                      bAttribIsNull = FALSE;

	mov	BYTE PTR _bAttribIsNull$23[ebp], 0
$LN147@fnWriteOI_:

; 7599 :                }
; 7600 : 
; 7601 :                // Write the value if it's not null OR if there are attribute
; 7602 :                // flags.  If there are attrib flags then we need to
; 7603 :                // keep track of null values.
; 7604 :                if ( bAttribIsNull == FALSE || lpAttribFlags )

	movzx	eax, BYTE PTR _bAttribIsNull$23[ebp]
	test	eax, eax
	je	SHORT $LN154@fnWriteOI_
	cmp	DWORD PTR _lpAttribFlags$[ebp], 0
	je	SHORT $LN99@fnWriteOI_
$LN154@fnWriteOI_:

; 7605 :                {
; 7606 :                   if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0,

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN99@fnWriteOI_

; 7607 :                                           zTYPE_STRING ) )
; 7608 :                   {
; 7609 :                      goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN99@fnWriteOI_:

; 7610 :                   }
; 7611 :                }
; 7612 : 
; 7613 :             } // if ( lpViewAttrib->cType == zTYPE_BLOB || )...else...
; 7614 : 
; 7615 :          } // if ( lControl & zCOMPRESSED )...else...
; 7616 : 
; 7617 :       } // for ( lpViewAttrib... )...

	jmp	$LN16@fnWriteOI_
$LN17@fnWriteOI_:

; 7618 : 
; 7619 :       if ( bEntityIsCompressed && bValuesStored )

	movzx	edx, BYTE PTR _bEntityIsCompressed$22[ebp]
	test	edx, edx
	je	$LN156@fnWriteOI_
	movzx	eax, BYTE PTR _bValuesStored$19[ebp]
	test	eax, eax
	je	$LN156@fnWriteOI_

; 7620 :       {
; 7621 :          zCHAR szLth[ 20 ];
; 7622 : 
; 7623 :          ulLth = (zULONG) (pchBufferEnd - pchBuffer);

	mov	ecx, DWORD PTR _pchBufferEnd$20[ebp]
	sub	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	DWORD PTR _ulLth$[ebp], ecx

; 7624 : 
; 7625 :          // Set first char to 'a' to indicate that it's attribute data.
; 7626 :          // The next char is a space to differentiate it with a normal
; 7627 :          // attribute value line.
; 7628 :          zsprintf( szLth, "a %x", ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	push	OFFSET $SG16034
	lea	eax, DWORD PTR _szLth$27[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7629 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szLth, zstrlen( szLth ),

	push	83					; 00000053H
	lea	ecx, DWORD PTR _szLth$27[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR _szLth$27[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN158@fnWriteOI_

; 7630 :                                  zTYPE_STRING ) )
; 7631 :          {
; 7632 :             goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN158@fnWriteOI_:

; 7633 :          }
; 7634 : 
; 7635 :          // Now send the buffer.
; 7636 :          if ( (*lpfnStreamFunc)( lpView, lpvData, pchBuffer, ulLth, zTYPE_STRING ) )

	push	83					; 00000053H
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN159@fnWriteOI_

; 7637 :             goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN159@fnWriteOI_:

; 7638 :       }

	jmp	SHORT $LN157@fnWriteOI_
$LN156@fnWriteOI_:

; 7639 :       else
; 7640 :       {
; 7641 :          if ( (lControl & zCOMPRESSED) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	jne	SHORT $LN157@fnWriteOI_

; 7642 :          {
; 7643 :             // Write a blank line just to make things look pretty.
; 7644 :             if ( (*lpfnStreamFunc)( lpView, lpvData, "", 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	push	OFFSET $SG16039
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN157@fnWriteOI_

; 7645 :                goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN157@fnWriteOI_:

; 7646 :          }
; 7647 :       }
; 7648 : 
; 7649 :    } // for ( lpEntityInstance... )...

	jmp	$LN5@fnWriteOI_
$LN6@fnWriteOI_:

; 7650 : 
; 7651 :    // If any intra-object linked instances were found, create
; 7652 :    // link records now.
; 7653 :    if ( lLastLinkedInstance > -1 )

	cmp	DWORD PTR _lLastLinkedInstance$[ebp], -1
	jle	$LN162@fnWriteOI_

; 7654 :    {
; 7655 :       LPENTITYINSTANCE lpSourceEntityInstance;
; 7656 : 
; 7657 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN25@fnWriteOI_
$LN23@fnWriteOI_:

; 7659 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN25@fnWriteOI_:

; 7658 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN162@fnWriteOI_

; 7660 :       {
; 7661 :          // If we've gone past the last linked instance break.
; 7662 :          if ( lpEntityInstance->lHierCount > lLastLinkedInstance )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	cmp	edx, DWORD PTR _lLastLinkedInstance$[ebp]
	jle	SHORT $LN163@fnWriteOI_

; 7663 :             break;

	jmp	$LN162@fnWriteOI_
$LN163@fnWriteOI_:

; 7664 : 
; 7665 :          // Look to see if the current instance should be written out.  If
; 7666 :          // not we'll skip it and go on to the next one.  All non-hidden
; 7667 :          // instances get written so we'll look for that first.
; 7668 :          if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	$LN164@fnWriteOI_

; 7669 :          {
; 7670 :             // We'll skip hidden entities if:
; 7671 :             // o  We aren't writing incrementals
; 7672 :             //    -or-
; 7673 :             // o  The EI is "dead" e.g. created and deleted.
; 7674 :             if ( bIncremental == FALSE ||

	movzx	edx, BYTE PTR _bIncremental$[ebp]
	test	edx, edx
	je	SHORT $LN166@fnWriteOI_
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnEntityInstanceIsDead@4
	movsx	ecx, ax
	test	ecx, ecx
	je	$LN164@fnWriteOI_
$LN166@fnWriteOI_:

; 7675 :                  fnEntityInstanceIsDead( lpEntityInstance ) )
; 7676 :             {
; 7677 :                // The current instance should not be written to the file.
; 7678 :                // This also means that it's children should not be written.
; 7679 :                // Skip the children.
; 7680 :                nLevel = lpEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$[ebp], ax

; 7681 :                for ( lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN28@fnWriteOI_
$LN26@fnWriteOI_:

; 7683 :                      lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN28@fnWriteOI_:

; 7682 :                      lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN27@fnWriteOI_

; 7684 :                {
; 7685 :                   if ( lpEntityInstance->nLevel <= nLevel )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN167@fnWriteOI_

; 7686 :                      break;

	jmp	SHORT $LN27@fnWriteOI_
$LN167@fnWriteOI_:

; 7687 :                }

	jmp	SHORT $LN26@fnWriteOI_
$LN27@fnWriteOI_:

; 7688 : 
; 7689 :                // If no more instance break loop.
; 7690 :                if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN168@fnWriteOI_

; 7691 :                   break;

	jmp	$LN162@fnWriteOI_
$LN168@fnWriteOI_:

; 7692 : 
; 7693 :                // Do the following so that when the 'for' loop gets the next
; 7694 :                // entity instance it will be the one we want.
; 7695 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7696 : 
; 7697 :                // Skip the hidden instance.
; 7698 :                continue;

	jmp	$LN23@fnWriteOI_
$LN164@fnWriteOI_:

; 7699 :             }
; 7700 :          }
; 7701 : 
; 7702 :          // If the entity is not linked to another entity then there are no
; 7703 :          // link cards to write, so skip it.
; 7704 :          if ( lpEntityInstance->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN169@fnWriteOI_

; 7705 :             continue;

	jmp	$LN23@fnWriteOI_
$LN169@fnWriteOI_:

; 7706 : 
; 7707 :          // If the entity is the record owner then we don't write link cards.
; 7708 :          // Link cards are written for the non-record owner.
; 7709 :          if ( lpEntityInstance->u.nInd.bRecordOwner )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN170@fnWriteOI_

; 7710 :             continue;

	jmp	$LN23@fnWriteOI_
$LN170@fnWriteOI_:

; 7711 : 
; 7712 :          // Look for the record owner in the same OI.
; 7713 :          lpSourceEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntityInstance$18[ebp], eax
$LN29@fnWriteOI_:

; 7714 :          while ( lpSourceEntityInstance->hViewOI != lpEntityInstance->hViewOI ||

	mov	eax, DWORD PTR _lpSourceEntityInstance$18[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $LN171@fnWriteOI_
	mov	eax, DWORD PTR _lpSourceEntityInstance$18[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 6
	and	ecx, 1
	jne	SHORT $LN30@fnWriteOI_
$LN171@fnWriteOI_:

; 7715 :                  lpSourceEntityInstance->u.nInd.bRecordOwner == FALSE )
; 7716 :          {
; 7717 :             lpSourceEntityInstance =

	mov	edx, DWORD PTR _lpSourceEntityInstance$18[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntityInstance$18[ebp], eax

; 7718 :                                  zGETPTR( lpSourceEntityInstance->hNextLinked );
; 7719 :             if ( lpSourceEntityInstance == lpEntityInstance )

	mov	ecx, DWORD PTR _lpSourceEntityInstance$18[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	jne	SHORT $LN172@fnWriteOI_

; 7720 :                break;

	jmp	SHORT $LN30@fnWriteOI_
$LN172@fnWriteOI_:

; 7721 :          }

	jmp	SHORT $LN29@fnWriteOI_
$LN30@fnWriteOI_:

; 7722 : 
; 7723 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7724 : 
; 7725 :          // If lpSourceEntityInstance == lpEntityInstance then no other
; 7726 :          // linked instances where found in the loop above.
; 7727 :          if ( lpSourceEntityInstance == lpEntityInstance )

	mov	ecx, DWORD PTR _lpSourceEntityInstance$18[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	jne	$LN173@fnWriteOI_

; 7728 :          {
; 7729 :             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 7730 :             zVIEW           vWork;
; 7731 :             LPVIEWENTITYCSR lpWorkViewEntityCsr;
; 7732 : 
; 7733 :             CreateViewFromViewForTask( &vWork, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vWork$8[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 7734 :             lpWorkViewEntityCsr =

	mov	eax, DWORD PTR _lpSourceEntityInstance$18[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vWork$8[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpWorkViewEntityCsr$11[ebp], eax
$LN31@fnWriteOI_:

; 7735 :                fnEstablishViewForInstance( vWork, 0, lpSourceEntityInstance );
; 7736 : 
; 7737 :             while ( lpWorkViewEntityCsr )

	cmp	DWORD PTR _lpWorkViewEntityCsr$11[ebp], 0
	je	SHORT $LN32@fnWriteOI_

; 7738 :             {
; 7739 :                fnDisplayEntityInstance( vWork, lpWorkViewEntityCsr, 0, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	push	edx
	mov	eax, DWORD PTR _vWork$8[ebp]
	push	eax
	call	_fnDisplayEntityInstance
	add	esp, 16					; 00000010H

; 7740 :                lpWorkViewEntityCsr = zGETPTR( lpWorkViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpWorkViewEntityCsr$11[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntityCsr$11[ebp], eax

; 7741 :             }

	jmp	SHORT $LN31@fnWriteOI_
$LN32@fnWriteOI_:

; 7742 : 
; 7743 :             DropView( vWork );

	mov	eax, DWORD PTR _vWork$8[ebp]
	push	eax
	call	_DropView@4

; 7744 : 
; 7745 :             // "KZOEE078 - Internal error, linked instance "
; 7746 :             // "           has no visible owner"
; 7747 :             fnIssueCoreError( lpTask, lpView, 16, 78, (zLONG) 0,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	78					; 0000004eH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN173@fnWriteOI_:

; 7748 :                               lpViewEntity->szName, 0 );
; 7749 :          }
; 7750 : 
; 7751 : #ifdef DEBUG
; 7752 :          // Check to make sure the linked EI's have the same ER token.
; 7753 :          {
; 7754 :             LPVIEWENTITY lpSrcViewEntity;
; 7755 : 
; 7756 :             lpViewEntity    = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 7757 :             lpSrcViewEntity = zGETPTR( lpSourceEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSourceEntityInstance$18[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$7[ebp], eax

; 7758 : 
; 7759 :             if ( lpSrcViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	edx, DWORD PTR _lpSrcViewEntity$7[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $LN174@fnWriteOI_

; 7760 :             {
; 7761 :                TraceLine( "(oi) Error (OD: %s) - Src View Entity: %s Token: %d  View Entity: %s Token = %d",

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+195]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$7[ebp]
	mov	eax, DWORD PTR [edx+195]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntity$7[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG16053
	call	_TraceLine
	add	esp, 24					; 00000018H

; 7762 :                           lpViewOD->szName, lpSrcViewEntity->szName, lpSrcViewEntity->lEREntTok,
; 7763 :                           lpViewEntity->szName, lpViewEntity->lEREntTok );
; 7764 :                if ( bMsgBox )

	movzx	eax, BYTE PTR _bMsgBox$[ebp]
	test	eax, eax
	je	SHORT $LN174@fnWriteOI_

; 7765 :                {
; 7766 :                   bMsgBox = FALSE;

	mov	BYTE PTR _bMsgBox$[ebp], 0

; 7767 :                   SysMessageBox( lpView, szlOE_SystemError,

	push	1
	push	OFFSET $SG16055
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16
$LN174@fnWriteOI_:

; 7768 :                                  "Error writing OI: ER Tokens don't match for linked entities!", 1 );
; 7769 :                }
; 7770 :             }
; 7771 :          }
; 7772 : #endif
; 7773 : 
; 7774 :          if ( lControl & zCOMPRESSED )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 131072				; 00020000H
	je	SHORT $LN176@fnWriteOI_

; 7775 :          {
; 7776 :             zsprintf( szWorkString, "i%lx %lx",

	mov	ecx, DWORD PTR _lpSourceEntityInstance$18[ebp]
	mov	edx, DWORD PTR [ecx+54]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+54]
	push	ecx
	push	OFFSET $SG16058
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 7777 :                       lpEntityInstance->lHierCount,
; 7778 :                       lpSourceEntityInstance->lHierCount );
; 7779 :          }

	jmp	$LN177@fnWriteOI_
$LN176@fnWriteOI_:

; 7780 :          else
; 7781 :          {
; 7782 :             szWorkString[ 0 ] = 'i';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szWorkString$[ebp+ecx], 105	; 00000069H

; 7783 :             zltoa( lpEntityInstance->lHierCount, &szWorkString[ 1 ] );

	push	10					; 0000000aH
	mov	edx, 1
	shl	edx, 0
	lea	eax, DWORD PTR _szWorkString$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+54]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 7784 :             k = zstrlen( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax
$LN35@fnWriteOI_:

; 7785 :             do
; 7786 :             {
; 7787 :                szWorkString[ k++ ] = ' ';

	movsx	ecx, WORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 32	; 00000020H
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx

; 7788 :             } while ( k < 11 );

	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 11					; 0000000bH
	jl	SHORT $LN35@fnWriteOI_

; 7789 : 
; 7790 :             zltoa( lpSourceEntityInstance->lHierCount, &szWorkString[ k ] );

	push	10					; 0000000aH
	movsx	ecx, WORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lpSourceEntityInstance$18[ebp]
	mov	ecx, DWORD PTR [eax+54]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN177@fnWriteOI_:

; 7791 :          }
; 7792 : 
; 7793 :          if ( lpEntityInstance->lHierCount != lpSourceEntityInstance->lHierCount )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpSourceEntityInstance$18[ebp]
	mov	ecx, DWORD PTR [edx+54]
	cmp	ecx, DWORD PTR [eax+54]
	je	SHORT $LN178@fnWriteOI_

; 7794 :          {
; 7795 :             if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN178@fnWriteOI_

; 7796 :                goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN178@fnWriteOI_:

; 7797 :          }
; 7798 : 
; 7799 :       } // for ...

	jmp	$LN23@fnWriteOI_
$LN162@fnWriteOI_:

; 7800 : 
; 7801 :    } // if ( lLastLinkedInstance > -1 )...
; 7802 : 
; 7803 :    //
; 7804 :    // Check to see if we need to save the cursor positions.
; 7805 :    //
; 7806 :    // We save the cursor positions by storing each entity cursor as:
; 7807 :    //    cent-#, absolute-entity-instance-#
; 7808 :    // The numbers are stored as hex values.  For example, the root cursor
; 7809 :    // would be saved as:
; 7810 :    //    c1, 1
; 7811 :    // Absence of the cursor record means the cursor is null.
; 7812 :    //
; 7813 :    // Note: if lpEntityInstance->u.nInd.bWritten is 0, then the entity
; 7814 :    // instance wasn't written to the stream.
; 7815 :    //
; 7816 :    if ( lControl & zSAVE_CURSORS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 262144				; 00040000H
	je	$LN180@fnWriteOI_

; 7817 :    {
; 7818 :       LPVIEWENTITYCSR  lpViewEntityCsr;
; 7819 :       LPENTITYINSTANCE lpCurrentEI;
; 7820 :       zLONG            lInstanceCount;
; 7821 : 
; 7822 :       lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7823 :       lInstanceCount = 1;

	mov	DWORD PTR _lInstanceCount$6[ebp], 1

; 7824 : 
; 7825 :       for ( lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$16[ebp], eax
	jmp	SHORT $LN38@fnWriteOI_
$LN36@fnWriteOI_:

; 7827 :             lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier ) )

	mov	edx, DWORD PTR _lpViewEntityCsr$16[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$16[ebp], eax
$LN38@fnWriteOI_:

; 7826 :             lpViewEntityCsr;

	cmp	DWORD PTR _lpViewEntityCsr$16[ebp], 0
	je	$LN180@fnWriteOI_

; 7828 :       {
; 7829 :          // If the entity cursor is NULL then ignore this cursor.
; 7830 :          if ( lpViewEntityCsr->hEntityInstance == 0 )

	mov	ecx, DWORD PTR _lpViewEntityCsr$16[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $LN181@fnWriteOI_

; 7831 :             continue;

	jmp	SHORT $LN36@fnWriteOI_
$LN181@fnWriteOI_:

; 7832 : 
; 7833 :          if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	edx, DWORD PTR _lpViewEntityCsr$16[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	SHORT $LN182@fnWriteOI_

; 7834 :          {
; 7835 :             zsprintf( szWorkString, "c%x 0", lpViewEntityCsr->nHierNbr );

	mov	eax, DWORD PTR _lpViewEntityCsr$16[ebp]
	movsx	ecx, WORD PTR [eax+24]
	push	ecx
	push	OFFSET $SG16064
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7836 : 
; 7837 :             if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	cwde
	test	eax, eax
	je	SHORT $LN183@fnWriteOI_

; 7838 :                goto EndOfFunction;

	jmp	$EndOfFunction$202
$LN183@fnWriteOI_:

; 7839 : 
; 7840 :             continue;

	jmp	SHORT $LN36@fnWriteOI_
$LN182@fnWriteOI_:

; 7841 :          }
; 7842 : 
; 7843 :          lpCurrentEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$16[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentEI$10[ebp], eax

; 7844 : 
; 7845 :          if ( lpCurrentEI->u.nInd.bWritten == FALSE )

	mov	eax, DWORD PTR _lpCurrentEI$10[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	jne	$LN184@fnWriteOI_

; 7846 :          {
; 7847 :             LPENTITYINSTANCE lpSrchInstance;
; 7848 :             zBOOL            bNoTwins = TRUE;

	mov	BYTE PTR _bNoTwins$21[ebp], 1

; 7849 : 
; 7850 :             // The current entity instance wasn't written to the stream.  If
; 7851 :             // none of it's twins were written to the stream then the cursor
; 7852 :             // is considered NULL.
; 7853 : 
; 7854 :             // Search previous twins.
; 7855 :             for ( lpSrchInstance = zGETPTR( lpCurrentEI->hPrevTwin );

	mov	edx, DWORD PTR _lpCurrentEI$10[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$17[ebp], eax
	jmp	SHORT $LN41@fnWriteOI_
$LN39@fnWriteOI_:

; 7857 :                   lpSrchInstance = zGETPTR( lpSrchInstance->hPrevTwin ) )

	mov	ecx, DWORD PTR _lpSrchInstance$17[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$17[ebp], eax
$LN41@fnWriteOI_:

; 7856 :                   lpSrchInstance;

	cmp	DWORD PTR _lpSrchInstance$17[ebp], 0
	je	SHORT $LN40@fnWriteOI_

; 7858 :             {
; 7859 :                if ( lpSrchInstance->u.nInd.bWritten )

	mov	eax, DWORD PTR _lpSrchInstance$17[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	je	SHORT $LN186@fnWriteOI_

; 7860 :                {
; 7861 :                   bNoTwins = FALSE;

	mov	BYTE PTR _bNoTwins$21[ebp], 0

; 7862 :                   break;

	jmp	SHORT $LN40@fnWriteOI_
$LN186@fnWriteOI_:

; 7863 :                }
; 7864 :             }

	jmp	SHORT $LN39@fnWriteOI_
$LN40@fnWriteOI_:

; 7865 : 
; 7866 :             // Search next twins.
; 7867 :             if ( bNoTwins )

	movzx	edx, BYTE PTR _bNoTwins$21[ebp]
	test	edx, edx
	je	SHORT $LN187@fnWriteOI_

; 7868 :             {
; 7869 :                for ( lpSrchInstance = zGETPTR( lpCurrentEI->hNextTwin );

	mov	eax, DWORD PTR _lpCurrentEI$10[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$17[ebp], eax
	jmp	SHORT $LN44@fnWriteOI_
$LN42@fnWriteOI_:

; 7871 :                      lpSrchInstance = zGETPTR( lpSrchInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpSrchInstance$17[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$17[ebp], eax
$LN44@fnWriteOI_:

; 7870 :                      lpSrchInstance;

	cmp	DWORD PTR _lpSrchInstance$17[ebp], 0
	je	SHORT $LN187@fnWriteOI_

; 7872 :                {
; 7873 :                   if ( lpSrchInstance->u.nInd.bWritten )

	mov	ecx, DWORD PTR _lpSrchInstance$17[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 12					; 0000000cH
	and	edx, 1
	je	SHORT $LN188@fnWriteOI_

; 7874 :                   {
; 7875 :                      bNoTwins = FALSE;

	mov	BYTE PTR _bNoTwins$21[ebp], 0

; 7876 :                      break;

	jmp	SHORT $LN187@fnWriteOI_
$LN188@fnWriteOI_:

; 7877 :                   }
; 7878 :                }

	jmp	SHORT $LN42@fnWriteOI_
$LN187@fnWriteOI_:

; 7879 :             }
; 7880 : 
; 7881 :             // If we didn't find any twins then the cursor is considered
; 7882 :             // NULL so don't write the cursor record to the stream.
; 7883 :             if ( bNoTwins )

	movzx	eax, BYTE PTR _bNoTwins$21[ebp]
	test	eax, eax
	je	SHORT $LN189@fnWriteOI_

; 7884 :                continue;

	jmp	$LN36@fnWriteOI_
$LN189@fnWriteOI_:

; 7885 : 
; 7886 :             // Cursor points to invalid entity but the entity does have
; 7887 :             // valid twins, so send record indicating that the cursor is
; 7888 :             // currently not set.
; 7889 :             zsprintf( szWorkString, "c%x 0", lpViewEntityCsr->nHierNbr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$16[ebp]
	movsx	edx, WORD PTR [ecx+24]
	push	edx
	push	OFFSET $SG16072
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 7890 :          }

	jmp	SHORT $LN185@fnWriteOI_
$LN184@fnWriteOI_:

; 7891 :          else
; 7892 :          {
; 7893 :             for ( ;

	jmp	SHORT $LN47@fnWriteOI_
$LN45@fnWriteOI_:

; 7895 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN47@fnWriteOI_:

; 7894 :                   lpEntityInstance != lpCurrentEI;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpCurrentEI$10[ebp]
	je	SHORT $LN46@fnWriteOI_

; 7896 :             {
; 7897 :                // If the entity instance wasn't written to the stream, then
; 7898 :                // don't bother counting it.
; 7899 :                if ( lpEntityInstance->u.nInd.bWritten == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 12					; 0000000cH
	and	edx, 1
	jne	SHORT $LN190@fnWriteOI_

; 7900 :                   continue;

	jmp	SHORT $LN45@fnWriteOI_
$LN190@fnWriteOI_:

; 7901 : 
; 7902 :                lInstanceCount++;

	mov	eax, DWORD PTR _lInstanceCount$6[ebp]
	add	eax, 1
	mov	DWORD PTR _lInstanceCount$6[ebp], eax

; 7903 :             }

	jmp	SHORT $LN45@fnWriteOI_
$LN46@fnWriteOI_:

; 7904 : 
; 7905 :             zsprintf( szWorkString, "c%x %lx", lpViewEntityCsr->nHierNbr,

	mov	ecx, DWORD PTR _lInstanceCount$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$16[ebp]
	movsx	eax, WORD PTR [edx+24]
	push	eax
	push	OFFSET $SG16074
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN185@fnWriteOI_:

; 7906 :                       lInstanceCount );
; 7907 :          }
; 7908 : 
; 7909 :          if ( (*lpfnStreamFunc)( lpView, lpvData, szWorkString, 0, zTYPE_STRING ) )

	push	83					; 00000053H
	push	0
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN191@fnWriteOI_

; 7910 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$202
$LN191@fnWriteOI_:

; 7911 :       }

	jmp	$LN36@fnWriteOI_
$LN180@fnWriteOI_:

; 7912 :    }
; 7913 : 
; 7914 :    // If we get here then everything's OK.
; 7915 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$202:

; 7916 : 
; 7917 : EndOfFunction:
; 7918 : 
; 7919 :    if ( pchBuffer )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	je	SHORT $LN192@fnWriteOI_

; 7920 :       fnFreeDataspace( pchBuffer );

	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
$LN192@fnWriteOI_:

; 7921 : 
; 7922 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN193@fnWriteOI_:

; 7923 : 
; 7924 : } // fnWriteOI_ToTextStream

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnWriteOI_ToTextStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpFileData$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpvData$ = 12						; size = 4
_pchBuffer$ = 16					; size = 4
_ulLth$ = 20						; size = 4
_cDataType$ = 24					; size = 1
_fnPutDataToFile@20 PROC

; 6934 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 6935 :    LPFILEDATA lpFileData = (LPFILEDATA) lpvData;

	mov	eax, DWORD PTR _lpvData$[ebp]
	mov	DWORD PTR _lpFileData$[ebp], eax

; 6936 : 
; 6937 :    if ( ulLth )

	cmp	DWORD PTR _ulLth$[ebp], 0
	je	SHORT $LN2@fnPutDataT

; 6938 :       return( SysWriteLineLth( lpTaskView, lpFileData->hFile, pchBuffer, ulLth, TRUE ) );

	push	1
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysWriteLineLth@20
	jmp	SHORT $LN1@fnPutDataT
	jmp	SHORT $LN1@fnPutDataT
$LN2@fnPutDataT:

; 6939 :    else
; 6940 :       return( SysWriteLine( lpTaskView, lpFileData->hFile, pchBuffer ) );

	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysWriteLine@12
$LN1@fnPutDataT:

; 6941 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnPutDataToFile@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lHiddenCnt$ = -84					; size = 4
_lpVE_Parent$1 = -80					; size = 4
_lpEI_Parent$2 = -76					; size = 4
_lpTask$3 = -72						; size = 4
_lpTask$4 = -68						; size = 4
_lpTask$5 = -64						; size = 4
_lpViewCsr$ = -60					; size = 4
_lpVE_NextHier$6 = -56					; size = 4
_lpLastEntityInstance$ = -52				; size = 4
_lpRootEntityInstance$ = -48				; size = 4
_lCmprCntrl$7 = -44					; size = 4
_vCheckView$8 = -40					; size = 4
_pOper$ = -36						; size = 4
_lpPtr$ = -32						; size = 4
_lpViewOI$ = -28					; size = 4
_lpViewOD$ = -24					; size = 4
_lpLinked$ = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpEntityInstance$ = -12				; size = 4
_nRC$ = -8						; size = 2
_bRelational$ = -2					; size = 1
_bDelete$9 = -1						; size = 1
_lpView$ = 8						; size = 4
_lControl$ = 12						; size = 4
_lpCurrentTask$ = 16					; size = 4
_lpTaskDBHandler$ = 20					; size = 4
_fnCommitSingleOI@16 PROC

; 6203 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H

; 6204 :    LPVIEWOD             lpViewOD;
; 6205 :    LPVIEWOI             lpViewOI;
; 6206 :    LPVIEWCSR            lpViewCsr;
; 6207 :    LPVIEWENTITY         lpViewEntity;
; 6208 :    LPENTITYINSTANCE     lpEntityInstance;
; 6209 :    LPENTITYINSTANCE     lpLastEntityInstance;
; 6210 :    LPENTITYINSTANCE     lpRootEntityInstance;
; 6211 :    LPENTITYINSTANCE     lpLinked;
; 6212 :    zPDBHOPER            pOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _pOper$[ebp], ecx

; 6213 :    zPVOID               lpPtr = lpTaskDBHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 6214 :    zLONG                lHiddenCnt;
; 6215 :    zSHORT               nRC;
; 6216 : 
; 6217 :    // DGC 1998/11/17
; 6218 :    // We have code that is special just for relational DBs.  At the moment we
; 6219 :    // only support relational DBs so I'm setting the following variable to
; 6220 :    // be always TRUE.  When we support other DB types we'll have to do
; 6221 :    // something different.
; 6222 :    zBOOL                bRelational = TRUE;

	mov	BYTE PTR _bRelational$[ebp], 1

; 6223 : 
; 6224 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6225 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6226 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6227 : 
; 6228 :    nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Object | DBH_NewObject, 0,

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	16392					; 00004008H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6229 :                    lpViewOD, 0, lpView, 0, &lpPtr );
; 6230 : 
; 6231 :    // Make sure OI does not contain versioned instances.
; 6232 :    if ( lpViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $LN43@fnCommitSi

; 6233 :    {
; 6234 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$5[ebp], eax

; 6235 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 6236 :       fnIssueCoreError( lpTask, lpView, 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$5[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6237 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCommitSi
$LN43@fnCommitSi:

; 6238 :    }
; 6239 : 
; 6240 :    // Check to see if the OI was activated using optmistic locking.
; 6241 :    if ( lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING &&

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 67108864				; 04000000H
	je	$LN44@fnCommitSi
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+236]
	cmp	eax, 1
	je	SHORT $LN45@fnCommitSi
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movzx	edx, BYTE PTR [ecx+236]
	cmp	edx, 2
	jne	$LN44@fnCommitSi
$LN45@fnCommitSi:

; 6242 :         (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 6243 :          lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )
; 6244 :    {
; 6245 :       zVIEW vCheckView;
; 6246 :       zLONG lCmprCntrl;
; 6247 : 
; 6248 :       // Since we have optimistic locking, we should have a copy of the
; 6249 :       // original OI (the OI after it was loaded).  Make sure we got it.
; 6250 :       if ( lpViewOI->vOriginalOI == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	jne	SHORT $LN46@fnCommitSi

; 6251 :       {
; 6252 :          // This should never happen (if it does it's a core error) so we'll
; 6253 :          // just use SysMessageBox.
; 6254 :          SysMessageBox( lpView, "Internal Core Error",

	push	1
	push	OFFSET $SG15599
	push	OFFSET $SG15600
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 6255 :                         "Couldn't find original OI!", 1 );
; 6256 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCommitSi
$LN46@fnCommitSi:

; 6257 :       }
; 6258 : 
; 6259 :       // Now activate the OI again using the qualification object but
; 6260 :       // WITHOUT optimistic locking.
; 6261 :       TraceLineS( "(oi) Activating Optimistic Check view", "" );

	push	OFFSET $SG15601
	push	OFFSET $SG15602
	call	_TraceLineS@8

; 6262 :       nRC = ActivateObjectInstance( &vCheckView, lpViewOD->szName,

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, -67108865				; fbffffffH
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _vCheckView$8[ebp]
	push	edx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _nRC$[ebp], ax

; 6263 :                                     lpView, zGETPTR( lpViewOI->vQualOI ),
; 6264 :                                     (lpViewOI->lActivateControl &
; 6265 :                                                ~(zACTIVATE_WITH_LOCKING)) );
; 6266 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN47@fnCommitSi

; 6267 :       {
; 6268 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$4[ebp], eax

; 6269 :          // We've got an error loading the optimistic check view, so get out.
; 6270 :          if ( vCheckView )

	cmp	DWORD PTR _vCheckView$8[ebp], 0
	je	SHORT $LN48@fnCommitSi

; 6271 :             DropView( vCheckView );

	mov	eax, DWORD PTR _vCheckView$8[ebp]
	push	eax
	call	_DropView@4
$LN48@fnCommitSi:

; 6272 : 
; 6273 :          TraceLineI( "(oi) Error loading Optimistic check view.  RC = ", nRC );

	movsx	ecx, WORD PTR _nRC$[ebp]
	push	ecx
	push	OFFSET $SG15605
	call	_TraceLineI@8

; 6274 : 
; 6275 :          // "KZOEE092 - Couldn't re-activate OI for optimistic lock check",
; 6276 :          fnIssueCoreError( lpTask, lpView, 8, 92, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	92					; 0000005cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$4[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6277 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCommitSi
$LN47@fnCommitSi:

; 6278 :       }
; 6279 : 
; 6280 :       // We're about to compare the OIs but first check to see if we should
; 6281 :       // ignore non-key values for include-only entities.
; 6282 :       lCmprCntrl = zCOMPAREOI_PERSISTONLY | zCOMPAREOI_RETURN;

	mov	DWORD PTR _lCmprCntrl$7[ebp], 2

; 6283 :       if ( lpViewOD->nLock == zLL_OPTIMISTIC_NOINC )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movzx	edx, BYTE PTR [ecx+236]
	cmp	edx, 1
	jne	SHORT $LN49@fnCommitSi

; 6284 :          lCmprCntrl |= zCOMPAREOI_IGNOREINC;

	mov	eax, DWORD PTR _lCmprCntrl$7[ebp]
	or	eax, 1
	mov	DWORD PTR _lCmprCntrl$7[ebp], eax
$LN49@fnCommitSi:

; 6285 : 
; 6286 :       // We now have a copy of the original OI and the current one.  Compare
; 6287 :       // the two and see if they are the same.  If they are not, then there
; 6288 :       // is an error.
; 6289 :       nRC = fnCompareOI_ToOI( zGETPTR( lpViewOI->vOriginalOI ), vCheckView,

	mov	ecx, DWORD PTR _lCmprCntrl$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _vCheckView$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCompareOI_ToOI
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 6290 :                               lCmprCntrl );
; 6291 :       TraceLineI( "(oi) Optimistic locking compare RC = ", nRC );

	movsx	edx, WORD PTR _nRC$[ebp]
	push	edx
	push	OFFSET $SG15607
	call	_TraceLineI@8

; 6292 :       DropView( vCheckView );  // We no longer need this...

	mov	eax, DWORD PTR _vCheckView$8[ebp]
	push	eax
	call	_DropView@4

; 6293 :       if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN44@fnCommitSi

; 6294 :       {
; 6295 :          LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 6296 :          // "KZOEE093 - Optimistic locking error -- OI has changed since it was activated",
; 6297 :          fnIssueCoreError( lpTask, lpView, 8, 93, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	93					; 0000005dH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$3[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6298 :          return( zOPTIMISTIC_LOCK_ERROR );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@fnCommitSi
$LN44@fnCommitSi:

; 6299 :       }
; 6300 : 
; 6301 :    } // if ( OPTIMISTIC LOCKING )...
; 6302 : 
; 6303 :    // Perform some pre-commit stuff.  fnCommitPreLoops does:
; 6304 :    //    o  Sets any auto-sequence attributes.
; 6305 :    //    o  Turns off "hidden" flag so db-handler can access all data.
; 6306 :    nRC = fnCommitPreLoops( lpCurrentTask, lpView, &lpLastEntityInstance,

	lea	eax, DWORD PTR _lHiddenCnt$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpLastEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCommitPreLoops
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 6307 :                            &lHiddenCnt );
; 6308 :    if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN51@fnCommitSi

; 6309 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnCommitSi
$LN51@fnCommitSi:

; 6310 : 
; 6311 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 6312 : 
; 6313 :    // Now we pass the chain once each to do relationship deletes, deletes,
; 6314 :    // relationship inserts, and updates. The delete passes are done in reverse
; 6315 :    // hierarchical order so deletes occur from the bottom up.
; 6316 : 
; 6317 :    //==============================================================
; 6318 :    // PASS Number 1, do excludes (relationship deletes).
; 6319 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN52@fnCommitSi

; 6320 :    {
; 6321 :       for ( lpEntityInstance = lpLastEntityInstance;

	mov	edx, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $LN4@fnCommitSi
$LN2@fnCommitSi:

; 6323 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnCommitSi:

; 6322 :             lpEntityInstance && nRC == 0;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN52@fnCommitSi
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN52@fnCommitSi

; 6324 :       {
; 6325 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6326 : 
; 6327 :          // EIs down a derived path don't get committed to the database.
; 6328 :          // Since all children of a derived EI are also derived we can skip
; 6329 :          // the twins of the current EI.
; 6330 :          if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	je	SHORT $LN53@fnCommitSi
$LN5@fnCommitSi:

; 6331 :          {
; 6332 :             while ( lpEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN6@fnCommitSi

; 6333 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN5@fnCommitSi
$LN6@fnCommitSi:

; 6334 : 
; 6335 :             continue;

	jmp	SHORT $LN2@fnCommitSi
$LN53@fnCommitSi:

; 6336 :          }
; 6337 : 
; 6338 : #if ( VIEWENT_RULES )
; 6339 :          // Skip the EI if we don't allow excluding this entity.
; 6340 :          if ( lpViewEntity->bExclude == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN54@fnCommitSi

; 6341 :             continue;

	jmp	SHORT $LN2@fnCommitSi
$LN54@fnCommitSi:

; 6342 : #endif
; 6343 : 
; 6344 :          // Exclude entity if the entity...
; 6345 :          if ( lpEntityInstance->u.nInd.bExcluded             && // was excluded...
; 6346 :               lpEntityInstance->u.nInd.bDBHExcluded == FALSE && // wasn't committed...
; 6347 :               lpEntityInstance->u.nInd.bIncluded == FALSE    && // wasn't inc'd and...

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	je	SHORT $LN55@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 16					; 00000010H
	and	eax, 1
	jne	SHORT $LN55@fnCommitSi
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN55@fnCommitSi
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN55@fnCommitSi

; 6348 :               lpEntityInstance->u.nInd.bCreated == FALSE )      // wasn't created
; 6349 :          {
; 6350 :             // Set entity cursor to point to lpEntityInstance.
; 6351 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6352 : 
; 6353 :             // Call DBHandler routine.
; 6354 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_DeleteRel, 0,

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32776					; 00008008H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6355 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );
; 6356 : 
; 6357 :             lpEntityInstance->u.nInd.bDBHExcluded = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 65536				; 00010000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6358 : 
; 6359 :             // Set the bDBHExcluded flag for all linked EIs that have the
; 6360 :             // exact same relationship.
; 6361 :             fnMarkDuplicateRelationship( lpEntityInstance, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnMarkDuplicateRelationship@8
$LN55@fnCommitSi:

; 6362 :          }
; 6363 : 
; 6364 :       }  // for ( lpEntityInstance ...)...

	jmp	$LN2@fnCommitSi
$LN52@fnCommitSi:

; 6365 : 
; 6366 :    }  // if ( lpFirstDeleteRel )...
; 6367 : 
; 6368 :    //==============================================================
; 6369 :    // PASS Number 2, do deletes.
; 6370 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN56@fnCommitSi

; 6371 :    {
; 6372 :       for ( lpEntityInstance = lpLastEntityInstance;

	mov	eax, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN9@fnCommitSi
$LN7@fnCommitSi:

; 6374 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN9@fnCommitSi:

; 6373 :             lpEntityInstance && nRC == 0;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN56@fnCommitSi
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN56@fnCommitSi

; 6375 :       {
; 6376 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6377 : 
; 6378 :          // EIs down a derived path don't get committed to the database.
; 6379 :          // Since all children of a derived EI are also derived we can skip
; 6380 :          // the twins of the current EI.
; 6381 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	je	SHORT $LN57@fnCommitSi
$LN10@fnCommitSi:

; 6382 :          {
; 6383 :             while ( lpEntityInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN11@fnCommitSi

; 6384 :                lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN10@fnCommitSi
$LN11@fnCommitSi:

; 6385 : 
; 6386 :             continue;

	jmp	SHORT $LN7@fnCommitSi
$LN57@fnCommitSi:

; 6387 :          }
; 6388 : 
; 6389 : #if ( VIEWENT_RULES )
; 6390 :          // If we don't allow deletes then skip it.
; 6391 :          if ( lpViewEntity->bDelete == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN58@fnCommitSi

; 6392 :             continue;

	jmp	SHORT $LN7@fnCommitSi
$LN58@fnCommitSi:

; 6393 : #endif
; 6394 : 
; 6395 :          // Delete entity if prev dbcall was OK and the entity...
; 6396 :          if ( lpEntityInstance->u.nInd.bDeleted             && // was deleted and...
; 6397 :               lpEntityInstance->u.nInd.bDBHDeleted == FALSE && // wasn't committed and...
; 6398 :               lpEntityInstance->u.nInd.bCreated == FALSE    && // wasn't created and...

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	je	$LN59@fnCommitSi
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	jne	$LN59@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	jne	$LN59@fnCommitSi
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	jne	$LN59@fnCommitSi

; 6399 :               lpEntityInstance->u.nInd.bIncluded == FALSE )    // wasn't included
; 6400 :          {
; 6401 :             zBOOL bDelete = FALSE;  // process each entity normally

	mov	BYTE PTR _bDelete$9[ebp], 0

; 6402 : 
; 6403 :             // Set entity cursor to point to lpEntityInstance.
; 6404 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6405 : 
; 6406 :             // Start dks ... 2006.01.25
; 6407 :             if ( lpEntityInstance->hParent )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	$LN60@fnCommitSi

; 6408 :             {
; 6409 :                LPVIEWENTITY      lpVE_Parent;
; 6410 :                LPVIEWENTITY      lpVE_NextHier;
; 6411 :                LPENTITYINSTANCE  lpEI_Parent;
; 6412 : 
; 6413 :                lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6414 :                lpVE_NextHier = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVE_NextHier$6[ebp], eax

; 6415 :                lpVE_Parent = zGETPTR( lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVE_Parent$1[ebp], eax

; 6416 :                lpEI_Parent = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI_Parent$2[ebp], eax

; 6417 :                if ( lpEI_Parent->u.nInd.bDeleted &&    // parent was deleted and...
; 6418 :                     lpViewEntity->bPDelete &&          // entity has ParentDelete behavior and...
; 6419 :                     lpVE_Parent->bSingleKey &&         // parent entity is single key and...
; 6420 :                     lpEntityInstance->hPrevTwin &&     // more than one instance to delete and...
; 6421 :                     lpViewEntity->bDerivedPath == FALSE && // cannot be derived

	mov	edx, DWORD PTR _lpEI_Parent$2[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN60@fnCommitSi
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 7
	and	edx, 1
	je	SHORT $LN60@fnCommitSi
	mov	eax, DWORD PTR _lpVE_Parent$1[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 16					; 00000010H
	and	ecx, 1
	je	SHORT $LN60@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN60@fnCommitSi
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	jne	SHORT $LN60@fnCommitSi
	cmp	DWORD PTR _lpVE_NextHier$6[ebp], 0
	je	SHORT $LN62@fnCommitSi
	mov	edx, DWORD PTR _lpVE_NextHier$6[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+2]
	je	SHORT $LN60@fnCommitSi
$LN62@fnCommitSi:

; 6422 :                     (lpVE_NextHier == 0 ||
; 6423 :                      lpVE_NextHier->hParent != lpEntityInstance->hViewEntity) )  // cannot have child entities
; 6424 :                {
; 6425 :                   // This should be the condition we are looking for ... dks ... 2006.01.25
; 6426 :                   bDelete = TRUE;       // call DBHandler once in the loop below

	mov	BYTE PTR _bDelete$9[ebp], 1
$LN60@fnCommitSi:

; 6427 :                }
; 6428 :             }
; 6429 :             // End dks ... 2006.01.25
; 6430 : 
; 6431 :             // Call DBHandler routine.
; 6432 :             if ( bDelete )  // dks ... 2006.01.25

	movzx	edx, BYTE PTR _bDelete$9[ebp]
	test	edx, edx
	je	SHORT $LN63@fnCommitSi

; 6433 :             {
; 6434 :                lpEntityInstance->u.nInd.bDBHDeleteAll = TRUE;  // call delete special case

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 262144				; 00040000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6435 :                nRC = (*pOper)( (zLONG) lpView->hTask,

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	33796					; 00008404H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN12@fnCommitSi:

; 6436 :                                DBH_Entity | DBH_Delete | DBH_DeleteAll, 0,
; 6437 :                                lpViewOD, lpViewEntity, lpView, 0, &lpPtr );
; 6438 : 
; 6439 :                // Flag each twin that message has been sent to handler.
; 6440 :                while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN13@fnCommitSi

; 6441 :                {
; 6442 :                   lpEntityInstance->u.nInd.bDBHDeleted = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 16384				; 00004000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6443 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 6444 :                }

	jmp	SHORT $LN12@fnCommitSi
$LN13@fnCommitSi:

; 6445 :             }

	jmp	SHORT $LN64@fnCommitSi
$LN63@fnCommitSi:

; 6446 :             else
; 6447 :             {
; 6448 :                // This is the only original code prior to 2006.01.25
; 6449 :                nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Delete, 0,

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	32772					; 00008004H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN64@fnCommitSi:

; 6450 :                                lpViewOD, lpViewEntity, lpView, 0, &lpPtr );
; 6451 :             }  // dks ... 2006.01.25
; 6452 : 
; 6453 :             // Flag that message has been sent to handler.
; 6454 :             lpEntityInstance->u.nInd.bDBHDeleted = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 16384				; 00004000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6455 : 
; 6456 :             // Turn on the DBHDeleted flag for all linked instances.  This
; 6457 :             // will keep them from being deleted again.
; 6458 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $LN16@fnCommitSi
$LN14@fnCommitSi:

; 6460 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$LN16@fnCommitSi:

; 6459 :                   lpLinked && lpLinked != lpEntityInstance;

	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $LN59@fnCommitSi
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN59@fnCommitSi

; 6461 :             {
; 6462 :                lpLinked->u.nInd.bDBHDeleted = TRUE;

	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 16384				; 00004000H
	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6463 :             }

	jmp	SHORT $LN14@fnCommitSi
$LN59@fnCommitSi:

; 6464 :          }
; 6465 : 
; 6466 :       }  // while ( lpEntityInstance && nRC == 0 )...

	jmp	$LN7@fnCommitSi
$LN56@fnCommitSi:

; 6467 : 
; 6468 :    }  // if ( lpFirstDelete )...
; 6469 : 
; 6470 :    //==============================================================
; 6471 :    // PASS Number 3, do creates.
; 6472 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN65@fnCommitSi

; 6473 :    {
; 6474 :       for ( lpEntityInstance = lpRootEntityInstance;

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN19@fnCommitSi
$LN17@fnCommitSi:

; 6476 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN19@fnCommitSi:

; 6475 :             lpEntityInstance && nRC == 0;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN65@fnCommitSi
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN65@fnCommitSi

; 6477 :       {
; 6478 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6479 : 
; 6480 :          // EIs down a derived path don't get committed to the database.
; 6481 :          // Since all children of a derived EI are also derived we can skip
; 6482 :          // the twins of the current EI.
; 6483 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	je	SHORT $LN66@fnCommitSi
$LN20@fnCommitSi:

; 6484 :          {
; 6485 :             while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN21@fnCommitSi

; 6486 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN20@fnCommitSi
$LN21@fnCommitSi:

; 6487 : 
; 6488 :             continue;

	jmp	SHORT $LN17@fnCommitSi
$LN66@fnCommitSi:

; 6489 :          }
; 6490 : 
; 6491 : #if ( VIEWENT_RULES )
; 6492 :          // If we don't allow creates then skip it.
; 6493 :          if ( lpViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	jne	SHORT $LN67@fnCommitSi

; 6494 :             continue;

	jmp	SHORT $LN17@fnCommitSi
$LN67@fnCommitSi:

; 6495 : #endif
; 6496 : 
; 6497 :          // Create the entity if the entity...
; 6498 :          if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE && // not committed and...
; 6499 :               lpEntityInstance->u.nInd.bCreated             && // was created and...
; 6500 :               lpEntityInstance->u.nInd.bDeleted == FALSE    && // wasn't deleted and...

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	jne	$LN68@fnCommitSi
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	je	$LN68@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	jne	$LN68@fnCommitSi
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	$LN68@fnCommitSi

; 6501 :               lpEntityInstance->u.nInd.bHidden == FALSE )      // is not hidden
; 6502 :          {
; 6503 :             // Set entity cursor to point to lpEntityInstance.
; 6504 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6505 : 
; 6506 :             // Call DBHandler routine.
; 6507 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Insert, 0,

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	32769					; 00008001H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6508 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );
; 6509 : 
; 6510 :             // Flag that message sent to handler
; 6511 :             lpEntityInstance->u.nInd.bDBHCreated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 8192				; 00002000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 6512 : 
; 6513 :             // Turn on the dbh flag for all linked instances.  This will
; 6514 :             // keep them from being created again.
; 6515 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $LN24@fnCommitSi
$LN22@fnCommitSi:

; 6517 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$LN24@fnCommitSi:

; 6516 :                   lpLinked && lpLinked != lpEntityInstance;

	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $LN68@fnCommitSi
	mov	eax, DWORD PTR _lpLinked$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN68@fnCommitSi

; 6518 :             {
; 6519 :                lpLinked->u.nInd.bDBHCreated = TRUE;

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 8192				; 00002000H
	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6520 : 
; 6521 :                // If the linked instance is flagged as created then we need
; 6522 :                // to set it's included flag on so that the *relationship*
; 6523 :                // is still created.
; 6524 :                if ( lpLinked->u.nInd.bCreated )

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN69@fnCommitSi

; 6525 :                   lpLinked->u.nInd.bIncluded = TRUE;

	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN69@fnCommitSi:

; 6526 :             }

	jmp	SHORT $LN22@fnCommitSi
$LN68@fnCommitSi:

; 6527 :          }
; 6528 :       } // for ( lpEntityInstance && nRC == 0 )

	jmp	$LN17@fnCommitSi
$LN65@fnCommitSi:

; 6529 : 
; 6530 :    } // if ( nRC )...
; 6531 : 
; 6532 :    //==============================================================
; 6533 :    // PASS Number 4, do insert relationships
; 6534 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN70@fnCommitSi

; 6535 :    {
; 6536 :       for ( lpEntityInstance = lpRootEntityInstance;

	mov	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN27@fnCommitSi
$LN25@fnCommitSi:

; 6538 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN27@fnCommitSi:

; 6537 :             lpEntityInstance && nRC == 0;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN70@fnCommitSi
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN70@fnCommitSi

; 6539 :       {
; 6540 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6541 : 
; 6542 :          // EIs down a derived path don't get committed to the database.
; 6543 :          // Since all children of a derived EI are also derived we can skip
; 6544 :          // the twins of the current EI.
; 6545 :          if ( lpViewEntity->bDerivedPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	je	SHORT $LN71@fnCommitSi
$LN28@fnCommitSi:

; 6546 :          {
; 6547 :             while ( lpEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN29@fnCommitSi

; 6548 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN28@fnCommitSi
$LN29@fnCommitSi:

; 6549 : 
; 6550 :             continue;

	jmp	SHORT $LN25@fnCommitSi
$LN71@fnCommitSi:

; 6551 :          }
; 6552 : 
; 6553 : #if ( VIEWENT_RULES )
; 6554 :          // If we don't allow includes then skip it.
; 6555 :          if ( lpViewEntity->bInclude == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN72@fnCommitSi

; 6556 :             continue;

	jmp	SHORT $LN25@fnCommitSi
$LN72@fnCommitSi:

; 6557 : #endif
; 6558 : 
; 6559 :          // If the entity doesn't have a parent (i.e. it's the root) then
; 6560 :          // we don't want to include it...there's nothing to include.  So
; 6561 :          // just flag it as already included.
; 6562 :          if ( lpEntityInstance->hParent == 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	jne	SHORT $LN73@fnCommitSi

; 6563 :          {
; 6564 :             lpEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6565 :             continue;

	jmp	$LN25@fnCommitSi
$LN73@fnCommitSi:

; 6566 :          }
; 6567 : 
; 6568 :          // Include relationship if prev dbcall was OK and the entity...
; 6569 :          if ( lpEntityInstance->u.nInd.bIncluded             && // was included and...
; 6570 :               lpEntityInstance->u.nInd.bExcluded == FALSE    && // wasn't committed and...
; 6571 :               lpEntityInstance->u.nInd.bDBHIncluded == FALSE && // wasn't committed and...

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	je	$LN74@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN74@fnCommitSi
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	jne	SHORT $LN74@fnCommitSi
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN74@fnCommitSi

; 6572 :               lpEntityInstance->u.nInd.bHidden == FALSE )       // is not hidden.
; 6573 :          {
; 6574 :             // Set entity cursor to point to lpEntityInstance.
; 6575 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6576 : 
; 6577 :             // Call DBHandler routine.
; 6578 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_InsertRel, 0,

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	0
	push	32770					; 00008002H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6579 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );
; 6580 : 
; 6581 :             lpEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 32768				; 00008000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6582 : 
; 6583 :             // Set the bDBHIncluded flag for all linked EIs that have the
; 6584 :             // exact same relationship as lpEntityInstance.
; 6585 :             fnMarkDuplicateRelationship( lpEntityInstance, TRUE );

	push	1
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnMarkDuplicateRelationship@8
$LN74@fnCommitSi:

; 6586 :          }
; 6587 :       } // for ( lpEntityInstance != lpStopInstance && nRC == 0 )

	jmp	$LN25@fnCommitSi
$LN70@fnCommitSi:

; 6588 :    } // if ( nRC >= 0 )...
; 6589 : 
; 6590 :    //==============================================================
; 6591 :    // PASS Number 5, do entity updates
; 6592 :    if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN75@fnCommitSi

; 6593 :    {
; 6594 :       for ( lpEntityInstance = lpRootEntityInstance;

	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN32@fnCommitSi
$LN30@fnCommitSi:

; 6596 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN32@fnCommitSi:

; 6595 :             lpEntityInstance && nRC == 0;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN75@fnCommitSi
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN75@fnCommitSi

; 6597 :       {
; 6598 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 6599 : 
; 6600 :          // EIs down a derived path don't get committed to the database.
; 6601 :          // Since all children of a derived EI are also derived we can skip
; 6602 :          // the twins of the current EI.
; 6603 :          if ( lpViewEntity->bDerivedPath )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	je	SHORT $LN76@fnCommitSi
$LN33@fnCommitSi:

; 6604 :          {
; 6605 :             while ( lpEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN34@fnCommitSi

; 6606 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN33@fnCommitSi
$LN34@fnCommitSi:

; 6607 : 
; 6608 :             continue;

	jmp	SHORT $LN30@fnCommitSi
$LN76@fnCommitSi:

; 6609 :          }
; 6610 : 
; 6611 : #if ( VIEWENT_RULES )
; 6612 :          if ( lpViewEntity->bUpdate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 2
	and	eax, 1
	jne	SHORT $LN77@fnCommitSi

; 6613 :          {
; 6614 :             // the DB is relational and we need to update because of an
; 6615 :             // included or excluded entity.
; 6616 :             if ( bRelational == FALSE ||

	movzx	ecx, BYTE PTR _bRelational$[ebp]
	test	ecx, ecx
	je	SHORT $LN79@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	jne	SHORT $LN77@fnCommitSi
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN77@fnCommitSi
$LN79@fnCommitSi:

; 6617 :                  (lpEntityInstance->u.nInd.bIncluded == FALSE &&
; 6618 :                   lpEntityInstance->u.nInd.bExcluded == FALSE) )
; 6619 :             {
; 6620 :                continue;

	jmp	$LN30@fnCommitSi
$LN77@fnCommitSi:

; 6621 :             }
; 6622 :          }
; 6623 : #endif
; 6624 : 
; 6625 :          // Update entity if the entity...
; 6626 :          if ( lpEntityInstance->u.nInd.bDBHUpdated == FALSE && // not already updated...
; 6627 :               lpEntityInstance->u.nInd.bUpdated == TRUE     && // was updated and...
; 6628 :               lpEntityInstance->u.nInd.bHidden == FALSE     && // isn't hidden and...
; 6629 :               lpEntityInstance->u.nInd.bCreated == FALSE    && // wasn't created and...

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 17					; 00000011H
	and	ecx, 1
	jne	$LN80@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	je	$LN80@fnCommitSi
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	$LN80@fnCommitSi
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	$LN80@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	jne	$LN80@fnCommitSi

; 6630 :               lpEntityInstance->u.nInd.bDeleted == FALSE )     // wasn't deleted and...
; 6631 :          {
; 6632 :             // Set entity cursor to point to lpEntityInstance.
; 6633 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6634 : 
; 6635 :             // Call DBHandler routine.
; 6636 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_Update, 0,

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	0
	push	32784					; 00008010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6637 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );
; 6638 : 
; 6639 :             // Flag that message sent to handler
; 6640 :             lpEntityInstance->u.nInd.bDBHUpdated = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 131072				; 00020000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6641 : 
; 6642 :             // If the EI is flagged as excluded then we have updated the EI
; 6643 :             // to blank out an empty key so now flag it as hidden.
; 6644 :             if ( lpEntityInstance->u.nInd.bExcluded )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	je	SHORT $LN82@fnCommitSi

; 6645 :                lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN82@fnCommitSi:

; 6646 : 
; 6647 :             // Turn on the dbh flag for all linked instances.  This will
; 6648 :             // keep them from being updated again.
; 6649 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
	jmp	SHORT $LN37@fnCommitSi
$LN35@fnCommitSi:

; 6651 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$[ebp], eax
$LN37@fnCommitSi:

; 6650 :                   lpLinked && lpLinked != lpEntityInstance;

	cmp	DWORD PTR _lpLinked$[ebp], 0
	je	SHORT $LN36@fnCommitSi
	mov	eax, DWORD PTR _lpLinked$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN36@fnCommitSi

; 6652 :             {
; 6653 :                lpLinked->u.nInd.bDBHUpdated = TRUE;

	mov	ecx, DWORD PTR _lpLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 131072				; 00020000H
	mov	eax, DWORD PTR _lpLinked$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6654 :             }

	jmp	SHORT $LN35@fnCommitSi
$LN36@fnCommitSi:

; 6655 :          }

	jmp	SHORT $LN81@fnCommitSi
$LN80@fnCommitSi:

; 6656 :          else
; 6657 :          if ( lpEntityInstance->u.nInd.bSequenceUpdt )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 19					; 00000013H
	and	edx, 1
	je	SHORT $LN81@fnCommitSi

; 6658 :          {
; 6659 :             // Set entity cursor to point to lpEntityInstance.
; 6660 :             fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 6661 : 
; 6662 :             // Call DBHandler routine.
; 6663 :             nRC = (*pOper)( (zLONG) lpView->hTask, DBH_Entity | DBH_UpdateSeq, 0,

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	34816					; 00008800H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6664 :                             lpViewOD, lpViewEntity, lpView, 0, &lpPtr );
; 6665 : 
; 6666 :             // Flag that message sent to handler
; 6667 :             lpEntityInstance->u.nInd.bDBHUpdated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 131072				; 00020000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN81@fnCommitSi:

; 6668 :          }
; 6669 :       }  // for ( lpEntityInstance && nRC == 0 )...

	jmp	$LN30@fnCommitSi
$LN75@fnCommitSi:

; 6670 :    }  // if ( nRC == 0 )...
; 6671 : 
; 6672 :    //==============================================================
; 6673 :    // All deletes, updates, and inserts have been performed.
; 6674 : 
; 6675 :    // Turn the hidden flag back on for deleted/excluded instances.
; 6676 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN40@fnCommitSi
$LN38@fnCommitSi:

; 6678 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN40@fnCommitSi:

; 6677 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN41@fnCommitSi

; 6679 :    {
; 6680 :       if ( lpEntityInstance->u.nInd.bDeleted ||

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN85@fnCommitSi
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN84@fnCommitSi
$LN85@fnCommitSi:

; 6681 :            lpEntityInstance->u.nInd.bExcluded )
; 6682 :       {
; 6683 :          lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN84@fnCommitSi:

; 6684 :       }
; 6685 :    }

	jmp	SHORT $LN38@fnCommitSi
$LN41@fnCommitSi:

; 6686 : 
; 6687 :    // If the view is left at a subobject after processing, reset it
; 6688 :    // back to the top level
; 6689 :    while ( fnResetViewFromSubobject( lpView ) == 0 );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetViewFromSubobject
	add	esp, 4
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN42@fnCommitSi
	jmp	SHORT $LN41@fnCommitSi
$LN42@fnCommitSi:

; 6690 : 
; 6691 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN86@fnCommitSi

; 6692 :    {
; 6693 :       if ( nRC < zDUPLICATE_ROOT )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -4					; fffffffcH
	jge	SHORT $LN87@fnCommitSi

; 6694 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnCommitSi
	jmp	SHORT $LN86@fnCommitSi
$LN87@fnCommitSi:

; 6695 :       else
; 6696 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnCommitSi
$LN86@fnCommitSi:

; 6697 :    }
; 6698 : 
; 6699 :    return( 0 ); // Everything OK.

	xor	eax, eax
$LN1@fnCommitSi:

; 6700 : 
; 6701 : } // fnCommitSingleOI

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnCommitSingleOI@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_tViewArrayBlock$ = -116				; size = 64
_vLock$ = -52						; size = 8
_lpViewCsr$1 = -44					; size = 4
_lpViewEntity$2 = -40					; size = 4
_lpViewCsr$3 = -36					; size = 4
_lpViewOI$4 = -32					; size = 4
_lpViewOD$5 = -28					; size = 4
_vSubtask$ = -24					; size = 4
_lpViewOI$6 = -20					; size = 4
_lpEntityInstance$7 = -16				; size = 4
_nRC$ = -12						; size = 2
_k$ = -8						; size = 2
_bDropLocks$ = -1					; size = 1
_lpCurrentTask$ = 8					; size = 4
_lpViewCluster$ = 12					; size = 4
_nViewCount$ = 16					; size = 2
_pnViewErrorIdx$ = 20					; size = 4
_fnRemoveLocksOnOIs@16 PROC

; 6019 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 6020 :    ViewClusterRecord vLock;
; 6021 :    VIEWARRAYBLOCK    tViewArrayBlock = {0};

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 6022 :    zVIEW             vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 6023 :    zBOOL             bDropLocks;
; 6024 :    zSHORT            k;
; 6025 :    zSHORT            nRC = zCALL_ERROR;       // Assume error.

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 6026 : 
; 6027 :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 6028 :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 6029 : 
; 6030 :    // vSubtask is just the first valid view in the list.
; 6031 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@fnRemoveLo
$LN2@fnRemoveLo:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@fnRemoveLo:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN3@fnRemoveLo

; 6032 :    {
; 6033 :       if ( lpViewCluster[ k ].vOI )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $LN14@fnRemoveLo

; 6034 :       {
; 6035 :          vSubtask = lpViewCluster[ k ].vOI;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	DWORD PTR _vSubtask$[ebp], ecx

; 6036 :          break;

	jmp	SHORT $LN3@fnRemoveLo
$LN14@fnRemoveLo:

; 6037 :       }
; 6038 :    }

	jmp	SHORT $LN2@fnRemoveLo
$LN3@fnRemoveLo:

; 6039 : 
; 6040 :    bDropLocks = FALSE;

	mov	BYTE PTR _bDropLocks$[ebp], 0

; 6041 : 
; 6042 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN7@fnRemoveLo
$LN5@fnRemoveLo:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN7@fnRemoveLo:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN6@fnRemoveLo

; 6043 :    {
; 6044 :       LPVIEWOD  lpViewOD;
; 6045 :       LPVIEWCSR lpViewCsr;
; 6046 :       LPVIEWOI  lpViewOI;
; 6047 : 
; 6048 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN15@fnRemoveLo

; 6049 :          continue;

	jmp	SHORT $LN5@fnRemoveLo
$LN15@fnRemoveLo:

; 6050 : 
; 6051 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN16@fnRemoveLo

; 6052 :          continue;

	jmp	SHORT $LN5@fnRemoveLo
$LN16@fnRemoveLo:

; 6053 : 
; 6054 :       lpViewOD  = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$5[ebp], eax

; 6055 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$3[ebp], eax

; 6056 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$3[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$6[ebp], eax

; 6057 : 
; 6058 :       // If view wasn't activated with locking forget about it.
; 6059 :       if ( lpViewOI->bIsLocked == FALSE )

	mov	eax, DWORD PTR _lpViewOI$6[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 7
	and	ecx, 1
	jne	SHORT $LN17@fnRemoveLo

; 6060 :          continue;

	jmp	$LN5@fnRemoveLo
$LN17@fnRemoveLo:

; 6061 : 
; 6062 :       // If bDropLocks is FALSE then we haven't created the vLock object yet.
; 6063 :       if ( bDropLocks == FALSE )

	movzx	edx, BYTE PTR _bDropLocks$[ebp]
	test	edx, edx
	jne	SHORT $LN18@fnRemoveLo

; 6064 :       {
; 6065 :          // Create an empty lock OI.
; 6066 :          if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask,
; 6067 :                              "ZPLOCKO", FALSE ) != 0 )

	push	0
	push	OFFSET $SG15463
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDeclareView@20
	cwde
	test	eax, eax
	je	SHORT $LN19@fnRemoveLo

; 6068 :          {
; 6069 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnRemoveLo
$LN19@fnRemoveLo:

; 6070 :          }
; 6071 : 
; 6072 :          if ( fnActivateEmptyObjectInstance( lpCurrentTask,
; 6073 :                                              vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN20@fnRemoveLo

; 6074 :          {
; 6075 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnRemoveLo
$LN20@fnRemoveLo:

; 6076 :          }
; 6077 : 
; 6078 :          // Set flag to indicate:
; 6079 :          //    o The lock OI has been created.
; 6080 :          //    o We need to commit the lock object so that locks are removed.
; 6081 :          bDropLocks = TRUE;

	mov	BYTE PTR _bDropLocks$[ebp], 1
$LN18@fnRemoveLo:

; 6082 :       }
; 6083 : 
; 6084 :       // If the view has LOD-level locking release the LOD-level lock.
; 6085 :       if ( lpViewOD->nLock > zLL_PESSIMISTIC )

	mov	ecx, DWORD PTR _lpViewOD$5[ebp]
	movzx	edx, BYTE PTR [ecx+236]
	cmp	edx, 3
	jle	SHORT $LN21@fnRemoveLo

; 6086 :       {
; 6087 :          if ( fnDeleteLocksOnTwins( lpCurrentTask, vLock.vOI,
; 6088 :                                     zGETPTR( lpViewOI->hRootEntityInstance ),
; 6089 :                                     lpViewCluster[ k ].vOI,
; 6090 :                                     TRUE, lpViewOI ) != 0 )

	mov	eax, DWORD PTR _lpViewOI$6[ebp]
	push	eax
	push	1
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$6[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeleteLocksOnTwins@24
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN21@fnRemoveLo

; 6091 :          {
; 6092 :             goto EndOfFunction;

	jmp	$EndOfFunction$34
$LN21@fnRemoveLo:

; 6093 :          }
; 6094 :       }
; 6095 : 
; 6096 :       // If the view has entity-level locking release the entity-level lock.
; 6097 :       if ( lpViewOD->nEntityLock > zLL_PESSIMISTIC )

	mov	eax, DWORD PTR _lpViewOD$5[ebp]
	movzx	ecx, BYTE PTR [eax+237]
	cmp	ecx, 3
	jle	$LN23@fnRemoveLo

; 6098 :       {
; 6099 :          LPENTITYINSTANCE lpEntityInstance;
; 6100 : 
; 6101 :          for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$6[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$7[ebp], eax
	jmp	SHORT $LN10@fnRemoveLo
$LN8@fnRemoveLo:

; 6103 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$7[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$7[ebp], eax
$LN10@fnRemoveLo:

; 6102 :                lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$7[ebp], 0
	je	SHORT $LN23@fnRemoveLo

; 6104 :          {
; 6105 :             LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$7[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 6106 : 
; 6107 :             // If entity has no locking skip it.
; 6108 :             if ( lpViewEntity->nLock == 0 )

	mov	edx, DWORD PTR _lpViewEntity$2[ebp]
	movzx	eax, BYTE PTR [edx+230]
	test	eax, eax
	jne	SHORT $LN24@fnRemoveLo

; 6109 :                continue;

	jmp	SHORT $LN8@fnRemoveLo
$LN24@fnRemoveLo:

; 6110 : 
; 6111 :             // If the instance is not the first twin then skip it.
; 6112 :             if ( lpEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$7[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN25@fnRemoveLo

; 6113 :                continue;

	jmp	SHORT $LN8@fnRemoveLo
$LN25@fnRemoveLo:

; 6114 : 
; 6115 :             if ( fnDeleteLocksOnTwins( lpCurrentTask, vLock.vOI,
; 6116 :                                        lpEntityInstance,
; 6117 :                                        lpViewCluster[ k ].vOI, FALSE,
; 6118 :                                        lpViewOI ) != 0 )

	mov	edx, DWORD PTR _lpViewOI$6[ebp]
	push	edx
	push	0
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnDeleteLocksOnTwins@24
	cwde
	test	eax, eax
	je	SHORT $LN26@fnRemoveLo

; 6119 :             {
; 6120 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 6121 :                break;

	jmp	SHORT $LN23@fnRemoveLo
$LN26@fnRemoveLo:

; 6122 :             }
; 6123 : 
; 6124 :          } // for ( lpEntityInstance )...

	jmp	SHORT $LN8@fnRemoveLo
$LN23@fnRemoveLo:

; 6125 :       }
; 6126 : 
; 6127 :    } // for ( k = 0... )...

	jmp	$LN5@fnRemoveLo
$LN6@fnRemoveLo:

; 6128 : 
; 6129 :    // If we didn't find any views that should be locked then get out.
; 6130 :    if ( bDropLocks == FALSE )

	movzx	edx, BYTE PTR _bDropLocks$[ebp]
	test	edx, edx
	jne	SHORT $LN27@fnRemoveLo

; 6131 :    {
; 6132 :       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 6133 :       goto EndOfFunction;

	jmp	$EndOfFunction$34
$LN27@fnRemoveLo:

; 6134 :    }
; 6135 : 
; 6136 :    // Now commit the lock OI.  This should delete the locks.
; 6137 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN28@fnRemoveLo

; 6138 :       goto EndOfFunction;

	jmp	$EndOfFunction$34
$LN28@fnRemoveLo:

; 6139 : 
; 6140 :    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 6141 :                                 0, &tViewArrayBlock ) != 0 )

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	1
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCommitObjectInstance@28
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN29@fnRemoveLo

; 6142 :    {
; 6143 :       goto EndOfFunction;

	jmp	$EndOfFunction$34
$LN29@fnRemoveLo:

; 6144 :    }
; 6145 : 
; 6146 :    // Flag all the OI's as no longer locked.
; 6147 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN13@fnRemoveLo
$LN11@fnRemoveLo:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN13@fnRemoveLo:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN12@fnRemoveLo

; 6148 :    {
; 6149 :       LPVIEWCSR lpViewCsr;
; 6150 :       LPVIEWOI  lpViewOI;
; 6151 : 
; 6152 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN30@fnRemoveLo

; 6153 :          continue;

	jmp	SHORT $LN11@fnRemoveLo
$LN30@fnRemoveLo:

; 6154 : 
; 6155 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN31@fnRemoveLo

; 6156 :          continue;

	jmp	SHORT $LN11@fnRemoveLo
$LN31@fnRemoveLo:

; 6157 : 
; 6158 :       lpViewCsr = zGETPTR( lpViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 6159 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$4[ebp], eax

; 6160 : 
; 6161 :       lpViewOI->bIsLocked = FALSE;

	mov	edx, DWORD PTR _lpViewOI$4[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -129				; ffffff7fH
	mov	ecx, DWORD PTR _lpViewOI$4[ebp]
	mov	DWORD PTR [ecx+36], eax

; 6162 : 
; 6163 :    } // for ( k = 0... )...

	jmp	SHORT $LN11@fnRemoveLo
$LN12@fnRemoveLo:

; 6164 : 
; 6165 :    // If we get here then everything's OK.
; 6166 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$EndOfFunction$34:

; 6167 : 
; 6168 : EndOfFunction:
; 6169 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $LN32@fnRemoveLo

; 6170 :       fnDropView( vLock.vOI );

	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnDropView@4
$LN32@fnRemoveLo:

; 6171 : 
; 6172 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 6173 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnRemoveLo:

; 6174 : 
; 6175 : } // fnRemoveLocksOnOIs

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnRemoveLocksOnOIs@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewOD$ = -440					; size = 4
_lpLockEntity$ = -436					; size = 4
_lpViewEntity$ = -432					; size = 4
_lpLockEntityCsr$ = -428				; size = 4
_lpViewAttrib$ = -424					; size = 4
_nRC$ = -420						; size = 2
_lpLockEntityInstance$1 = -416				; size = 4
_lpEntityInstance$ = -412				; size = 4
_nKeyCnt$ = -408					; size = 2
_lpKeyViewAttrib$ = -404				; size = 160
_szKeyString$ = -244					; size = 201
_szLockName$ = -40					; size = 35
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_vLock$ = 12						; size = 4
_lpFirstEntityInstance$ = 16				; size = 4
_lpView$ = 20						; size = 4
_bLOD_Lock$ = 24					; size = 1
_lpViewOI$ = 28						; size = 4
_fnDeleteLocksOnTwins@24 PROC

; 5921 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 440				; 000001b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5922 :    LPVIEWENTITY      lpLockEntity;
; 5923 :    LPVIEWENTITY      lpViewEntity;
; 5924 :    LPVIEWATTRIB      lpViewAttrib;
; 5925 :    LPVIEWATTRIB      lpKeyViewAttrib[ zMAX_KEYS_FOR_LOCK ];
; 5926 :    LPENTITYINSTANCE  lpEntityInstance;
; 5927 :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 5928 :    LPVIEWOD          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5929 :    zCHAR             szKeyString[ zMAX_KEYLTH_FOR_LOCK + 1 ];
; 5930 :    zCHAR             szLockName[ 35 ];
; 5931 :    zSHORT            nKeyCnt;
; 5932 :    zSHORT            nRC = zCALL_ERROR;       // Assume error.

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 5933 : 
; 5934 :    lpViewEntity = zGETPTR( lpFirstEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5935 : 
; 5936 :    // To save time later find all the keys in the LOD and store them in a table.
; 5937 :    nKeyCnt = 0;

	xor	edx, edx
	mov	WORD PTR _nKeyCnt$[ebp], dx

; 5938 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnDeleteLo
$LN2@fnDeleteLo:

; 5940 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnDeleteLo:

; 5939 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN3@fnDeleteLo

; 5941 :    {
; 5942 :       if ( lpViewAttrib->bKey )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN8@fnDeleteLo

; 5943 :          lpKeyViewAttrib[ nKeyCnt++ ] = lpViewAttrib;

	movsx	eax, WORD PTR _nKeyCnt$[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _lpKeyViewAttrib$[ebp+eax*4], ecx
	mov	dx, WORD PTR _nKeyCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nKeyCnt$[ebp], dx
$LN8@fnDeleteLo:

; 5944 :    }

	jmp	SHORT $LN2@fnDeleteLo
$LN3@fnDeleteLo:

; 5945 : 
; 5946 :    // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 5947 :    lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock, "ZeidonLock", 0 );

	push	0
	push	OFFSET $SG15404
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 5948 : 
; 5949 :    if ( bLOD_Lock )

	movzx	edx, BYTE PTR _bLOD_Lock$[ebp]
	test	edx, edx
	je	SHORT $LN9@fnDeleteLo

; 5950 :    {
; 5951 :       // We are checking a LOD level lock so we set LockName to the name of
; 5952 :       // the LOD.
; 5953 :       zstrcpy( szLockName, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5954 :    }

	jmp	SHORT $LN10@fnDeleteLo
$LN9@fnDeleteLo:

; 5955 :    else
; 5956 :    {
; 5957 :       // We are checking a lock at the entity level so use the name of the
; 5958 :       // entity for the LockName.  In addition, to handle the rare case where
; 5959 :       // a LOD and entity name are the same we prefix all entity names with
; 5960 :       // a '@' because it's an invalid character for entity names.  This
; 5961 :       // insures that the LockName for the entity does not match a LOD name.
; 5962 :       zsprintf( szLockName, "@%s", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG15407
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN10@fnDeleteLo:

; 5963 :    }
; 5964 : 
; 5965 :    // Loop through each of the twin entities and create a locking record.  We
; 5966 :    // are going to cheat by then turning off the Create flag and turning on
; 5967 :    // the Delete and Hidden flags.  This will allow us to delete the lock
; 5968 :    // records off the DB without activating them first.
; 5969 :    for ( lpEntityInstance = lpFirstEntityInstance;

	mov	ecx, DWORD PTR _lpFirstEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN7@fnDeleteLo
$LN5@fnDeleteLo:

; 5971 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnDeleteLo:

; 5970 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN6@fnDeleteLo

; 5972 :    {
; 5973 :       LPENTITYINSTANCE lpLockEntityInstance;
; 5974 : 
; 5975 :       // We don't care about instances that have been created.  Created
; 5976 :       // entities won't have a locking record because they where just created.
; 5977 :       // Same for included entities.
; 5978 :       if ( lpEntityInstance->u.nInd.bCreated ||

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN12@fnDeleteLo
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN11@fnDeleteLo
$LN12@fnDeleteLo:

; 5979 :            lpEntityInstance->u.nInd.bIncluded )
; 5980 :          continue;

	jmp	SHORT $LN5@fnDeleteLo
$LN11@fnDeleteLo:

; 5981 : 
; 5982 :       // Create the concat key string.
; 5983 :       fnCreateConcatKey( szKeyString, lpEntityInstance,

	movzx	edx, WORD PTR _nKeyCnt$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpKeyViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szKeyString$[ebp]
	push	edx
	call	_fnCreateConcatKey@16

; 5984 :                          lpKeyViewAttrib, nKeyCnt );
; 5985 : 
; 5986 :       if ( fnCreateEntity( vLock, lpLockEntity, lpLockEntityCsr,
; 5987 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCreateEntity@20
	cwde
	test	eax, eax
	je	SHORT $LN13@fnDeleteLo

; 5988 :          goto EndOfFunction;

	jmp	$EndOfFunction$16
$LN13@fnDeleteLo:

; 5989 : 
; 5990 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 5991 :                                    vLock, lpLockEntity, lpLockEntityCsr,
; 5992 :                                    szLockName, szKeyString, 0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _szKeyString$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSetLockingAttributes@36
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN14@fnDeleteLo

; 5993 :          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$16
$LN14@fnDeleteLo:

; 5994 : 
; 5995 :       // Here's where we cheat -- turn off Create flag and turn on the
; 5996 :       // Delete/Hidden flags so that when we commit the OI the locking
; 5997 :       // records will be deleted.
; 5998 :       lpLockEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLockEntityInstance$1[ebp], eax

; 5999 :       lpLockEntityInstance->u.nInd.bCreated = FALSE;

	mov	ecx, DWORD PTR _lpLockEntityInstance$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpLockEntityInstance$1[ebp]
	mov	DWORD PTR [eax+6], edx

; 6000 :       lpLockEntityInstance->u.nInd.bDeleted = lpLockEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpLockEntityInstance$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpLockEntityInstance$1[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpLockEntityInstance$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 8
	mov	eax, DWORD PTR _lpLockEntityInstance$1[ebp]
	mov	DWORD PTR [eax+6], edx

; 6001 : 
; 6002 :    } // for ( lpEntityInstance...)

	jmp	$LN5@fnDeleteLo
$LN6@fnDeleteLo:

; 6003 : 
; 6004 :    // If we get here then everything is OK.
; 6005 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$EndOfFunction$16:

; 6006 : 
; 6007 : EndOfFunction:
; 6008 : 
; 6009 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 6010 : 
; 6011 : } // fnDeleteLocksOnTwins

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnDeleteLocksOnTwins@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_uLth$1 = -64						; size = 4
_lpRelRecord$ = -60					; size = 4
_lpViewOD$ = -56					; size = 4
_lpLastInsertedViewEntity$ = -52			; size = 4
_lpRootEntityInstance$ = -48				; size = 4
_lpViewCsr$ = -44					; size = 4
_lpAttribFlags$2 = -40					; size = 4
_lpSeqPtr$3 = -36					; size = 4
_lpDataRecord$ = -32					; size = 4
_lpViewOI$ = -28					; size = 4
_lSeq$4 = -24						; size = 4
_lpViewAttrib$ = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpTwin$5 = -12						; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpCurrentTask$ = 8					; size = 4
_lpView$ = 12						; size = 4
_plpLastEntityInstance$ = 16				; size = 4
_plHiddenCnt$ = 20					; size = 4
_fnCommitPreLoops PROC

; 5575 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 5576 :    LPVIEWOD             lpViewOD;
; 5577 :    LPVIEWOI             lpViewOI;
; 5578 :    LPVIEWCSR            lpViewCsr;
; 5579 :    LPVIEWENTITY         lpViewEntity;
; 5580 :    LPVIEWENTITY         lpLastInsertedViewEntity;
; 5581 :    LPENTITYINSTANCE     lpEntityInstance;
; 5582 :    LPENTITYINSTANCE     lpRootEntityInstance;
; 5583 :    LPDATARECORD         lpDataRecord;
; 5584 :    LPVIEWATTRIB         lpViewAttrib;
; 5585 :    LPRELRECORD          lpRelRecord;
; 5586 :    zSHORT               nRC;
; 5587 : 
; 5588 :    lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 5589 : 
; 5590 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5591 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5592 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 5593 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 5594 : 
; 5595 :    // Change the "hidden" indicator to false if the entity instance was
; 5596 :    // deleted.  This will allow the db-handler to access the entity instance.
; 5597 :    *plHiddenCnt = 0;

	mov	edx, DWORD PTR _plHiddenCnt$[ebp]
	mov	DWORD PTR [edx], 0

; 5598 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 5599 :    for ( lpEntityInstance = lpRootEntityInstance;

	mov	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN4@fnCommitPr
$LN2@fnCommitPr:

; 5601 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnCommitPr:

; 5600 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@fnCommitPr

; 5602 :    {
; 5603 :       // Keep track of the last valid EI.
; 5604 :       *plpLastEntityInstance = lpEntityInstance;

	mov	ecx, DWORD PTR _plpLastEntityInstance$[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx], edx

; 5605 : 
; 5606 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5607 : 
; 5608 :       // If it is a derived path, skip it
; 5609 :       if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	je	SHORT $LN9@fnCommitPr

; 5610 :          continue;

	jmp	SHORT $LN2@fnCommitPr
$LN9@fnCommitPr:

; 5611 : 
; 5612 :       lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 5613 : 
; 5614 :       // If it has no data record, skip it
; 5615 :       if ( lpDataRecord == 0 )

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	jne	SHORT $LN10@fnCommitPr

; 5616 :          continue;

	jmp	SHORT $LN2@fnCommitPr
$LN10@fnCommitPr:

; 5617 : 
; 5618 :       lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 5619 : 
; 5620 :       // If the entity for the current entity instance has an automatic
; 5621 :       // sequence attribute AND it is the first twin under its parent,
; 5622 :       // ensure that the sequence numbers for all the twins are correct.
; 5623 :       if ( lpViewEntity->bAutoSeq &&
; 5624 :            lpEntityInstance->hPrevTwin == 0 &&  // Must be first twin.

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	je	$LN11@fnCommitPr
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	$LN11@fnCommitPr
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	$LN11@fnCommitPr

; 5625 :            lpEntityInstance->hNextTwin )   // Don't bother if only 1 twin.
; 5626 :       {
; 5627 :          zULONG           uLth;
; 5628 :          zLONG            lSeq;
; 5629 :          zPLONG           lpSeqPtr;
; 5630 :          LPENTITYINSTANCE lpTwin;
; 5631 : 
; 5632 :          // First, find the autoseq view attrib.
; 5633 :          lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN5@fnCommitPr:

; 5634 :          while ( lpViewAttrib->bAutoSeq == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN6@fnCommitPr

; 5635 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN5@fnCommitPr
$LN6@fnCommitPr:

; 5636 : 
; 5637 :          // For each of the twins, set the seq attribute.
; 5638 :          lSeq = 1;

	mov	DWORD PTR _lSeq$4[ebp], 1

; 5639 :          lpTwin = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpTwin$5[ebp], eax
$LN7@fnCommitPr:

; 5640 :          while ( lpTwin )

	cmp	DWORD PTR _lpTwin$5[ebp], 0
	je	$LN11@fnCommitPr

; 5641 :          {
; 5642 :             // If the twin wasn't deleted, then set it's sequence number.
; 5643 :             if ( lpTwin->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpTwin$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	$LN12@fnCommitPr

; 5644 :             {
; 5645 :                // Make sure the entity instance has a data record.
; 5646 :                if ( lpTwin->hPersistRecord == 0 )

	mov	eax, DWORD PTR _lpTwin$5[ebp]
	cmp	DWORD PTR [eax+60], 0
	jne	SHORT $LN13@fnCommitPr

; 5647 :                   fnCreateAttributeRecord( zGETPTR( lpViewOI->hAllocTask ),

	mov	ecx, DWORD PTR _lpTwin$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCreateAttributeRecord
	add	esp, 12					; 0000000cH
$LN13@fnCommitPr:

; 5648 :                                            lpViewEntity, lpTwin );
; 5649 : 
; 5650 :                fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpSeqPtr, &uLth,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTwin$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _uLth$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSeqPtr$3[ebp]
	push	edx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 5651 :                                                 lpTwin, lpViewAttrib );
; 5652 : 
; 5653 :                // Only update sequence attribute if the value of the seqence
; 5654 :                // attribute in the entity is different from the local counter.
; 5655 :                if ( *lpSeqPtr != lSeq )

	mov	eax, DWORD PTR _lpSeqPtr$3[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _lSeq$4[ebp]
	je	SHORT $LN14@fnCommitPr

; 5656 :                {
; 5657 :                   LPATTRIBFLAGS lpAttribFlags;
; 5658 : 
; 5659 :                   *lpSeqPtr = lSeq;

	mov	edx, DWORD PTR _lpSeqPtr$3[ebp]
	mov	eax, DWORD PTR _lSeq$4[ebp]
	mov	DWORD PTR [edx], eax

; 5660 :                   lpTwin->u.nInd.bSequenceUpdt = TRUE;

	mov	ecx, DWORD PTR _lpTwin$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 524288				; 00080000H
	mov	eax, DWORD PTR _lpTwin$5[ebp]
	mov	DWORD PTR [eax+6], edx

; 5661 : 
; 5662 :                   // Since changing the attribute value via a pointer doesn't
; 5663 :                   // change the attrib flag do so now.
; 5664 :                   lpAttribFlags = fnGetAttribFlagsPtr( lpTwin, lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTwin$5[ebp]
	push	edx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$2[ebp], eax

; 5665 :                   lpAttribFlags->u.bFlags.bUpdated = TRUE;

	mov	eax, DWORD PTR _lpAttribFlags$2[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 2
	mov	edx, DWORD PTR _lpAttribFlags$2[ebp]
	mov	DWORD PTR [edx], ecx

; 5666 : 
; 5667 :                   // Turn off the bDBHUpdated flag (if it's on) so that we
; 5668 :                   // make sure the entity is updated.  If the entity instance
; 5669 :                   // is linked with someone else it's possible that the
; 5670 :                   // entity was updated through the other link.
; 5671 :                   lpEntityInstance->u.nInd.bDBHUpdated = FALSE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -131073				; fffdffffH
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN14@fnCommitPr:

; 5672 :                }
; 5673 : 
; 5674 :                lSeq++;

	mov	eax, DWORD PTR _lSeq$4[ebp]
	add	eax, 1
	mov	DWORD PTR _lSeq$4[ebp], eax
$LN12@fnCommitPr:

; 5675 :             }
; 5676 : 
; 5677 :             lpTwin = zGETPTR( lpTwin->hNextTwin );

	mov	ecx, DWORD PTR _lpTwin$5[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTwin$5[ebp], eax

; 5678 :          }

	jmp	$LN7@fnCommitPr
$LN11@fnCommitPr:

; 5679 :       } // if ( lpViewEntity->bAutoSeq && lpEntityInstance->hPrevTwin == 0 )...
; 5680 : 
; 5681 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN15@fnCommitPr

; 5682 :       {
; 5683 :          // Increment Hidden counter
; 5684 :          (*plHiddenCnt)++;

	mov	edx, DWORD PTR _plHiddenCnt$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _plHiddenCnt$[ebp]
	mov	DWORD PTR [ecx], eax

; 5685 : 
; 5686 :          // Unhide the instance so the DBHandler can access it unless it is
; 5687 :          // "dead".  If it's "dead" the the DBHandler shouldn't care about it.
; 5688 :          if ( !fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnEntityInstanceIsDead@4
	cwde
	test	eax, eax
	jne	SHORT $LN15@fnCommitPr

; 5689 :             lpEntityInstance->u.nInd.bHidden = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -1025				; fffffbffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN15@fnCommitPr:

; 5690 :       }
; 5691 : 
; 5692 :    }  // for ( lpEntityInstance )...

	jmp	$LN2@fnCommitPr
$LN3@fnCommitPr:

; 5693 : 
; 5694 :    return( 0 );

	xor	eax, eax

; 5695 : 
; 5696 : } // fnCommitPreLoops

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCommitPreLoops ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -32					; size = 4
_lpGrandParent$1 = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpLnkViewEntity$ = -20					; size = 4
_lpParent$ = -16					; size = 4
_lpWrkEntityInstance$2 = -12				; size = 4
_lpLnkParent$ = -8					; size = 4
_lpLnkEntityInstance$ = -4				; size = 4
_lpEntityInstance$ = 8					; size = 4
_bIncludeFlag$ = 12					; size = 1
_fnMarkDuplicateRelationship@8 PROC

; 5399 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 5400 :    LPVIEWOI         lpViewOI;
; 5401 :    LPVIEWENTITY     lpViewEntity;
; 5402 :    LPVIEWENTITY     lpLnkViewEntity;
; 5403 :    LPENTITYINSTANCE lpParent;
; 5404 :    LPENTITYINSTANCE lpLnkParent;
; 5405 :    LPENTITYINSTANCE lpLnkEntityInstance;
; 5406 : 
; 5407 :    // Return 0 if instance passed is not linked
; 5408 :    if ( lpEntityInstance->hNextLinked == 0 )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	SHORT $LN14@fnMarkDupl

; 5409 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnMarkDupl
$LN14@fnMarkDupl:

; 5410 : 
; 5411 :    // Get Object instance for entity instance
; 5412 :    lpViewOI     = zGETPTR( lpEntityInstance->hViewOI );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5413 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5414 :    lpParent     = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax

; 5415 : 
; 5416 :    // If the parent isn't linked then there are no duplicate relationships.
; 5417 :    if ( lpParent == 0 || lpParent->hNextLinked == 0 )

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	SHORT $LN16@fnMarkDupl
	mov	ecx, DWORD PTR _lpParent$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN15@fnMarkDupl
$LN16@fnMarkDupl:

; 5418 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnMarkDupl
$LN15@fnMarkDupl:

; 5419 : 
; 5420 :    // Duplicate relationship searching phase I, see if a linked instance to
; 5421 :    // the target instance in the same object instance represents the
; 5422 :    // same relationship type AND has the same parent
; 5423 :    for ( lpLnkEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnMarkDupl
$LN2@fnMarkDupl:

; 5425 :          lpLnkEntityInstance = zGETPTR( lpLnkEntityInstance->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
$LN4@fnMarkDupl:

; 5424 :          lpLnkEntityInstance != lpEntityInstance;

	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	$LN3@fnMarkDupl

; 5426 :    {
; 5427 :       LPENTITYINSTANCE lpWrkEntityInstance;
; 5428 : 
; 5429 :       // Check to make sure linked EI has a parent--it is possible for a root
; 5430 :       // to be flagged as included and we don't care about roots.
; 5431 :       if ( lpLnkEntityInstance->u.nInd.bDeleted  ||

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN18@fnMarkDupl
	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	DWORD PTR [eax+30], 0
	jne	SHORT $LN17@fnMarkDupl
$LN18@fnMarkDupl:

; 5432 :            lpLnkEntityInstance->hParent == 0 )
; 5433 :       {
; 5434 :          continue;

	jmp	SHORT $LN2@fnMarkDupl
$LN17@fnMarkDupl:

; 5435 :       }
; 5436 : 
; 5437 :       // Check for appropriate include/exclude flag.
; 5438 :       if ( bIncludeFlag )

	movzx	ecx, BYTE PTR _bIncludeFlag$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@fnMarkDupl

; 5439 :       {
; 5440 :          if ( lpLnkEntityInstance->u.nInd.bIncluded == FALSE ||

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN22@fnMarkDupl
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN21@fnMarkDupl
$LN22@fnMarkDupl:

; 5441 :               lpLnkEntityInstance->u.nInd.bExcluded )
; 5442 :          {
; 5443 :             continue;

	jmp	SHORT $LN2@fnMarkDupl
$LN21@fnMarkDupl:

; 5444 :          }
; 5445 :       }

	jmp	SHORT $LN20@fnMarkDupl
$LN19@fnMarkDupl:

; 5446 :       else
; 5447 :       {
; 5448 :          if ( lpLnkEntityInstance->u.nInd.bIncluded ||

	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN24@fnMarkDupl
	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN20@fnMarkDupl
$LN24@fnMarkDupl:

; 5449 :               lpLnkEntityInstance->u.nInd.bExcluded == FALSE )
; 5450 :          {
; 5451 :             continue;

	jmp	SHORT $LN2@fnMarkDupl
$LN20@fnMarkDupl:

; 5452 :          }
; 5453 :       }
; 5454 : 
; 5455 :       lpLnkViewEntity = zGETPTR( lpLnkEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkViewEntity$[ebp], eax

; 5456 : 
; 5457 :       // Linked EI must have the same relationship and it can't be derived.
; 5458 :       if ( lpLnkViewEntity->lERRelTok != lpViewEntity->lERRelTok ||

	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $LN26@fnMarkDupl
	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	je	SHORT $LN25@fnMarkDupl
$LN26@fnMarkDupl:

; 5459 :            lpLnkViewEntity->bDerivedPath )
; 5460 :       {
; 5461 :          continue;

	jmp	$LN2@fnMarkDupl
$LN25@fnMarkDupl:

; 5462 :       }
; 5463 : 
; 5464 :       // Now check to see if the parent of the linked EI is linked to the
; 5465 :       // parent of the original EI.  If it is then the linked EI and the
; 5466 :       // original EI have the same relationship.
; 5467 : 
; 5468 :       lpLnkParent = zGETPTR( lpLnkEntityInstance->hParent );

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax

; 5469 : 
; 5470 :       for ( lpWrkEntityInstance = zGETPTR( lpLnkParent->hNextLinked );

	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$2[ebp], eax
	jmp	SHORT $LN7@fnMarkDupl
$LN5@fnMarkDupl:

; 5472 :             lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked ) )

	mov	eax, DWORD PTR _lpWrkEntityInstance$2[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$2[ebp], eax
$LN7@fnMarkDupl:

; 5471 :             lpWrkEntityInstance && lpWrkEntityInstance != lpLnkParent;

	cmp	DWORD PTR _lpWrkEntityInstance$2[ebp], 0
	je	SHORT $LN6@fnMarkDupl
	mov	edx, DWORD PTR _lpWrkEntityInstance$2[ebp]
	cmp	edx, DWORD PTR _lpLnkParent$[ebp]
	je	SHORT $LN6@fnMarkDupl

; 5473 :       {
; 5474 :          if ( lpWrkEntityInstance == lpParent )

	mov	eax, DWORD PTR _lpWrkEntityInstance$2[ebp]
	cmp	eax, DWORD PTR _lpParent$[ebp]
	jne	SHORT $LN27@fnMarkDupl

; 5475 :          {
; 5476 :             // The parents of the two linked EIs are also linked.  Set flag
; 5477 :             // and break loop.
; 5478 :             if ( bIncludeFlag )

	movzx	ecx, BYTE PTR _bIncludeFlag$[ebp]
	test	ecx, ecx
	je	SHORT $LN28@fnMarkDupl

; 5479 :                lpLnkEntityInstance->u.nInd.bDBHIncluded = TRUE;

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 32768				; 00008000H
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN29@fnMarkDupl
$LN28@fnMarkDupl:

; 5480 :             else
; 5481 :                lpLnkEntityInstance->u.nInd.bDBHExcluded = TRUE;

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 65536				; 00010000H
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN29@fnMarkDupl:

; 5482 : 
; 5483 :             break;

	jmp	SHORT $LN6@fnMarkDupl
$LN27@fnMarkDupl:

; 5484 :          }
; 5485 :       }

	jmp	SHORT $LN5@fnMarkDupl
$LN6@fnMarkDupl:

; 5486 :    }

	jmp	$LN2@fnMarkDupl
$LN3@fnMarkDupl:

; 5487 : 
; 5488 :    // Duplicate relationship searching, phase II, see if the parent of
; 5489 :    // the instance has a linked instance representing the same relationship
; 5490 :    // type which is also a child of one of the targets linked instances.
; 5491 :    // (i.e. the same relationship instance inverted).
; 5492 :    for ( lpLnkParent = zGETPTR( lpParent->hNextLinked );

	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax
	jmp	SHORT $LN10@fnMarkDupl
$LN8@fnMarkDupl:

; 5494 :          lpLnkParent = zGETPTR( lpLnkParent->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkParent$[ebp], eax
$LN10@fnMarkDupl:

; 5493 :          lpLnkParent != lpParent;

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	cmp	eax, DWORD PTR _lpParent$[ebp]
	je	$LN9@fnMarkDupl

; 5495 :    {
; 5496 :       LPENTITYINSTANCE lpGrandParent;
; 5497 : 
; 5498 :       // Check for appropriate include/exclude flag.
; 5499 :       if ( bIncludeFlag )

	movzx	ecx, BYTE PTR _bIncludeFlag$[ebp]
	test	ecx, ecx
	je	SHORT $LN30@fnMarkDupl

; 5500 :       {
; 5501 :          if ( lpLnkParent->u.nInd.bIncluded == FALSE ||

	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN33@fnMarkDupl
	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN32@fnMarkDupl
$LN33@fnMarkDupl:

; 5502 :               lpLnkParent->u.nInd.bExcluded )
; 5503 :          {
; 5504 :             continue;

	jmp	SHORT $LN8@fnMarkDupl
$LN32@fnMarkDupl:

; 5505 :          }
; 5506 :       }

	jmp	SHORT $LN31@fnMarkDupl
$LN30@fnMarkDupl:

; 5507 :       else
; 5508 :       {
; 5509 :          if ( lpLnkParent->u.nInd.bIncluded || lpLnkParent->u.nInd.bExcluded == FALSE )

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN35@fnMarkDupl
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN31@fnMarkDupl
$LN35@fnMarkDupl:

; 5510 :             continue;

	jmp	SHORT $LN8@fnMarkDupl
$LN31@fnMarkDupl:

; 5511 :       }
; 5512 : 
; 5513 :       lpLnkViewEntity = zGETPTR( lpLnkParent->hViewEntity );

	mov	ecx, DWORD PTR _lpLnkParent$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkViewEntity$[ebp], eax

; 5514 : 
; 5515 :       // Check to see if the relationship for the EI linked to the parent is
; 5516 :       // the same as the relationship of the original EI.
; 5517 :       if ( lpLnkViewEntity->lERRelTok != lpViewEntity->lERRelTok )

	mov	eax, DWORD PTR _lpLnkViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	je	SHORT $LN36@fnMarkDupl

; 5518 :          continue;  // Nope.

	jmp	$LN8@fnMarkDupl
$LN36@fnMarkDupl:

; 5519 : 
; 5520 :       // OK, we have an EI (lpLnkParent) that has the same relationship as
; 5521 :       // lpEntityInstance.  Check to see if the parent of lpLnkParent (lpGrandParent)
; 5522 :       // is linked with lpEntityInstance.  If they are linked then lpLnkParent
; 5523 :       // has the same physical relationship as lpEntityInstance.
; 5524 :       lpGrandParent = zGETPTR( lpLnkParent->hParent );

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGrandParent$1[ebp], eax

; 5525 :       for ( lpLnkEntityInstance = zGETPTR( lpEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
	jmp	SHORT $LN13@fnMarkDupl
$LN11@fnMarkDupl:

; 5527 :             lpLnkEntityInstance = zGETPTR( lpLnkEntityInstance->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
$LN13@fnMarkDupl:

; 5526 :             lpLnkEntityInstance != lpEntityInstance;

	mov	eax, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN12@fnMarkDupl

; 5528 :       {
; 5529 :          if ( lpLnkEntityInstance == lpGrandParent )

	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpGrandParent$1[ebp]
	jne	SHORT $LN37@fnMarkDupl

; 5530 :          {
; 5531 :             // If we've found an inverted structure in the same
; 5532 :             // object instance which is the same relationship type, set flag.
; 5533 :             if ( bIncludeFlag )

	movzx	edx, BYTE PTR _bIncludeFlag$[ebp]
	test	edx, edx
	je	SHORT $LN38@fnMarkDupl

; 5534 :                lpLnkParent->u.nInd.bDBHIncluded = TRUE;

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 32768				; 00008000H
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	DWORD PTR [edx+6], ecx
	jmp	SHORT $LN39@fnMarkDupl
$LN38@fnMarkDupl:

; 5535 :             else
; 5536 :                lpLnkParent->u.nInd.bDBHExcluded = TRUE;

	mov	eax, DWORD PTR _lpLnkParent$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 65536				; 00010000H
	mov	edx, DWORD PTR _lpLnkParent$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN39@fnMarkDupl:

; 5537 : 
; 5538 :             break;

	jmp	SHORT $LN12@fnMarkDupl
$LN37@fnMarkDupl:

; 5539 :          }
; 5540 :       }

	jmp	SHORT $LN11@fnMarkDupl
$LN12@fnMarkDupl:

; 5541 :    }

	jmp	$LN8@fnMarkDupl
$LN9@fnMarkDupl:

; 5542 : 
; 5543 :    return( 0 );

	xor	eax, eax
$LN1@fnMarkDupl:

; 5544 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnMarkDuplicateRelationship@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pDummy$1 = -372					; size = 4
_uLth$2 = -368						; size = 4
_pDummy$3 = -364					; size = 4
_uLth$4 = -360						; size = 4
_hTask$ = -356						; size = 4
_lpViewEntity$5 = -352					; size = 4
tv546 = -348						; size = 4
_lpTask$6 = -344					; size = 4
_lpDataRecord$7 = -340					; size = 4
_lpViewCsr$8 = -336					; size = 4
_bGenkeyNeededArray$ = -332				; size = 4
_lpViewAttrib$9 = -328					; size = 4
_lpViewAttrib$10 = -324					; size = 4
_lpViewOI_Array$ = -320					; size = 4
_lpViewEntity$11 = -316					; size = 4
_lpLastInsertedViewEntity$ = -312			; size = 4
_hGKHandler$ = -308					; size = 4
_lpLinked$12 = -304					; size = 4
_lpViewOD_Array$ = -300					; size = 4
_nDebugCnt$ = -296					; size = 2
_vSubtask$ = -292					; size = 4
_bFK_NeededArray$ = -288				; size = 4
_bHiddenOnly$ = -281					; size = 1
_nRC$ = -280						; size = 2
_lpViewEntity$13 = -276					; size = 4
_bSettingFKs$ = -269					; size = 1
_lpEntityInstance$ = -268				; size = 4
_k$ = -264						; size = 2
_szMsg$14 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpViewArray$ = 8					; size = 4
_nViewCount$ = 12					; size = 2
_pnViewErrorIdx$ = 16					; size = 4
_lpCurrentTask$ = 20					; size = 4
_lpKZGKHWOB$ = 24					; size = 4
_ppGKOper$ = 28						; size = 4
_pViewArrayBlock$ = 32					; size = 4
_fnInitializeGenKeys@28 PROC

; 4923 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 372				; 00000174H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4924 :    LPGKHANDLER      hGKHandler = 0;

	mov	DWORD PTR _hGKHandler$[ebp], 0

; 4925 :    LPVIEWOI         *lpViewOI_Array = pViewArrayBlock->pViewOI_Array;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lpViewOI_Array$[ebp], ecx

; 4926 :    LPVIEWOD         *lpViewOD_Array = pViewArrayBlock->pViewOD_Array;

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _lpViewOD_Array$[ebp], eax

; 4927 :    LPVIEWENTITY     lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 4928 :    LPENTITYINSTANCE lpEntityInstance;
; 4929 :    LPTASK           hTask;
; 4930 :    zVIEW            vSubtask;
; 4931 :    zBOOL            bHiddenOnly;
; 4932 :    zBOOL            bSettingFKs;
; 4933 :    zBOOL            *bGenkeyNeededArray = pViewArrayBlock->pbGenkeyNeededArray;

	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _bGenkeyNeededArray$[ebp], edx

; 4934 :    zBOOL            *bFK_NeededArray = pViewArrayBlock->pbFK_NeededArray;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _bFK_NeededArray$[ebp], ecx

; 4935 :    zSHORT           nDebugCnt;
; 4936 :    zSHORT           k;
; 4937 :    zSHORT           nRC;
; 4938 : 
; 4939 :    // Set up support arrays.
; 4940 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@fnInitiali
$LN2@fnInitiali:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@fnInitiali:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN3@fnInitiali

; 4941 :    {
; 4942 :       LPVIEWCSR lpViewCsr;
; 4943 : 
; 4944 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN41@fnInitiali

; 4945 :          continue;

	jmp	SHORT $LN2@fnInitiali
$LN41@fnInitiali:

; 4946 : 
; 4947 :       lpViewOD_Array[ k ] = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 4948 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$8[ebp], eax

; 4949 :       lpViewOI_Array[ k ] = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$8[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax

; 4950 :    }

	jmp	$LN2@fnInitiali
$LN3@fnInitiali:

; 4951 : 
; 4952 :    // We'll use one of the views as a subtask view.
; 4953 :    // vSubtask is just the first valid view in the list.
; 4954 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN7@fnInitiali
$LN5@fnInitiali:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN7@fnInitiali:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN6@fnInitiali

; 4955 :    {
; 4956 :       if ( lpViewArray[ k ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	SHORT $LN42@fnInitiali

; 4957 :       {
; 4958 :          vSubtask = lpViewArray[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 4959 :          break;

	jmp	SHORT $LN6@fnInitiali
$LN42@fnInitiali:

; 4960 :       }
; 4961 :    }

	jmp	SHORT $LN5@fnInitiali
$LN6@fnInitiali:

; 4962 : 
; 4963 :    hTask = vSubtask->hTask;

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hTask$[ebp], ecx

; 4964 : 
; 4965 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN10@fnInitiali
$LN8@fnInitiali:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN10@fnInitiali:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN9@fnInitiali

; 4966 :    {
; 4967 :       bGenkeyNeededArray[ k ] = FALSE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 4968 :       bFK_NeededArray[ k ] = FALSE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 4969 : 
; 4970 :       if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN43@fnInitiali

; 4971 :          continue;

	jmp	SHORT $LN8@fnInitiali
$LN43@fnInitiali:

; 4972 : 
; 4973 :       // Check to see if the View has genkeys.  If it does then make sure the
; 4974 :       // genkey handler has been loaded.
; 4975 :       if ( lpViewOD_Array[ k ]->bGenkey )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 9
	and	eax, 1
	je	$LN44@fnInitiali

; 4976 :       {
; 4977 :          if ( hGKHandler == 0 )

	cmp	DWORD PTR _hGKHandler$[ebp], 0
	jne	SHORT $LN45@fnInitiali

; 4978 :          {
; 4979 :             hGKHandler = lpViewOD_Array[ k ]->hGKHandler;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR _hGKHandler$[ebp], ecx

; 4980 : 
; 4981 :             // Make sure that the GKHandler has been set.
; 4982 :             if ( hGKHandler == 0 )

	cmp	DWORD PTR _hGKHandler$[ebp], 0
	jne	SHORT $LN47@fnInitiali

; 4983 :             {
; 4984 :                zCHAR    szMsg[ 256 ];
; 4985 : 
; 4986 :                zsprintf( szMsg, "No GenKey handler set for LOD: %s",

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOD_Array$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG15097
	lea	edx, DWORD PTR _szMsg$14[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4987 :                          lpViewOD_Array[ k ]->szName );
; 4988 :                SysMessageBox( vSubtask, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 4989 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnInitiali
$LN47@fnInitiali:

; 4990 :             }
; 4991 :          }

	jmp	SHORT $LN44@fnInitiali
$LN45@fnInitiali:

; 4992 :          else
; 4993 :          {
; 4994 :             // Make sure that all the views have the same GKHandler.
; 4995 :             if ( lpViewOD_Array[ k ]->hGKHandler != hGKHandler )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+212]
	cmp	eax, DWORD PTR _hGKHandler$[ebp]
	je	SHORT $LN44@fnInitiali

; 4996 :             {
; 4997 :                SysMessageBox( vSubtask, szlOE_SystemError,

	push	1
	push	OFFSET $SG15099
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 4998 :                               "OIs have different GenKey handlers", 1 );
; 4999 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnInitiali
$LN44@fnInitiali:

; 5000 :             }
; 5001 :          }
; 5002 :       }
; 5003 : 
; 5004 :       // Go through entity instance looking for entities that need genkeys.
; 5005 :       // Also check to see if the EI needs to set a foreign key.
; 5006 :       for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN13@fnInitiali
$LN11@fnInitiali:

; 5008 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN13@fnInitiali:

; 5007 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN12@fnInitiali

; 5009 :       {
; 5010 :          LPVIEWENTITY lpViewEntity;
; 5011 :          LPVIEWATTRIB lpViewAttrib;
; 5012 :          zPVOID       pDummy;
; 5013 :          zULONG       uLth;
; 5014 : 
; 5015 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$13[ebp], eax

; 5016 : 
; 5017 :          // Entities on a derived path don't get a genkey or a foreign key.
; 5018 :          if ( lpViewEntity->bDerivedPath )

	mov	edx, DWORD PTR _lpViewEntity$13[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	je	SHORT $LN49@fnInitiali
$LN14@fnInitiali:

; 5019 :          {
; 5020 :             // If an EI is down a derived path then all children are also a
; 5021 :             // derived path.  We can try to save a little time by ignoring
; 5022 :             // all the children.
; 5023 :             while ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN15@fnInitiali

; 5024 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN14@fnInitiali
$LN15@fnInitiali:

; 5025 : 
; 5026 :             continue;

	jmp	SHORT $LN11@fnInitiali
$LN49@fnInitiali:

; 5027 :          }
; 5028 : 
; 5029 :          // Check to see if the EI needs to set some foreign keys.
; 5030 :          // NOTE!
; 5031 :          // NOTE! The logic here matches the logic that is in
; 5032 :          // NOTE! fnCommitPreLoops( ). Any changes here should be reflected
; 5033 :          // NOTE! there.
; 5034 :          // NOTE!
; 5035 :          if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	$LN50@fnInitiali

; 5036 :          {
; 5037 :             // DGC 99.07.02
; 5038 :             // If the EI is flagged as created and the entity doesn't have
; 5039 :             // create authority then make sure that there is a linked EI in
; 5040 :             // the current cluster that does have create authority.
; 5041 :             if ( lpEntityInstance->u.nInd.bCreated &&
; 5042 :                  lpViewEntity->bCreate == FALSE &&

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN52@fnInitiali
	mov	edx, DWORD PTR _lpViewEntity$13[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	jne	SHORT $LN52@fnInitiali
	mov	ecx, DWORD PTR _lpViewEntity$13[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 25					; 00000019H
	and	edx, 1
	jne	SHORT $LN52@fnInitiali

; 5043 :                  lpViewEntity->bDupInstance == FALSE ) //BL, 2000.01.04 Bugfix Repository
; 5044 :             {
; 5045 :                fnCheckCreateDeleteFlags( lpEntityInstance, lpViewArray,

	push	1
	movzx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD_Array$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnCheckCreateDeleteFlags@24
$LN52@fnInitiali:

; 5046 :                                          lpViewOD_Array, lpViewOI_Array,
; 5047 :                                          nViewCount, TRUE );
; 5048 :             }
; 5049 : 
; 5050 :             if ( lpEntityInstance->u.nInd.bCreated
; 5051 : #if ( VIEWENT_RULES )
; 5052 :                   && lpViewEntity->bCreate

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN53@fnInitiali
	mov	ecx, DWORD PTR _lpViewEntity$13[ebp]
	mov	edx, DWORD PTR [ecx+235]
	and	edx, 1
	je	SHORT $LN53@fnInitiali

; 5053 : #endif
; 5054 :                )
; 5055 :             {
; 5056 :                // Foreign keys need to be set later.
; 5057 :                bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5058 :                lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5059 :             }

	jmp	SHORT $LN54@fnInitiali
$LN53@fnInitiali:

; 5060 :             else
; 5061 :             {
; 5062 :                if ( lpEntityInstance->u.nInd.bIncluded &&
; 5063 :                     lpEntityInstance->hParent          &&
; 5064 : #if ( VIEWENT_RULES )
; 5065 :                     lpViewEntity->bInclude &&

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN54@fnInitiali
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN54@fnInitiali
	mov	edx, DWORD PTR _lpViewEntity$13[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN54@fnInitiali
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN56@fnInitiali
	mov	eax, DWORD PTR _lpViewEntity$13[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, 1
	jne	SHORT $LN54@fnInitiali
$LN56@fnInitiali:

; 5066 : #endif
; 5067 :                     ( lpEntityInstance->u.nInd.bCreated == FALSE
; 5068 : #if ( VIEWENT_RULES )
; 5069 :                       || lpViewEntity->bCreate == FALSE
; 5070 : #endif
; 5071 :                   ) )
; 5072 :                {
; 5073 :                   // Foreign keys need to be set later.
; 5074 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [eax+edx], 1

; 5075 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4194304				; 00400000H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN54@fnInitiali:

; 5076 :                }
; 5077 :             }
; 5078 :          } // if ( lpEntityInstance->u.nInd.bHidden == FALSE )...

	jmp	$LN51@fnInitiali
$LN50@fnInitiali:

; 5079 :          else
; 5080 :          {
; 5081 :             if ( lpEntityInstance->u.nInd.bCreated == FALSE &&

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	jne	$LN51@fnInitiali
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	jne	$LN51@fnInitiali

; 5082 :                  lpEntityInstance->u.nInd.bIncluded == FALSE )
; 5083 :             {
; 5084 :                if ( lpEntityInstance->u.nInd.bExcluded
; 5085 : #if ( VIEWENT_RULES )
; 5086 :                     && lpViewEntity->bExclude

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN58@fnInitiali
	mov	ecx, DWORD PTR _lpViewEntity$13[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN58@fnInitiali

; 5087 : #endif
; 5088 :                   )
; 5089 :                {
; 5090 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5091 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5092 :                }

	jmp	SHORT $LN51@fnInitiali
$LN58@fnInitiali:

; 5093 :                else
; 5094 :                if ( lpEntityInstance->u.nInd.bDeleted
; 5095 : #if ( VIEWENT_RULES )
; 5096 :                     && lpViewEntity->bDelete

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN51@fnInitiali
	mov	ecx, DWORD PTR _lpViewEntity$13[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN51@fnInitiali

; 5097 : #endif
; 5098 :                   )
; 5099 :                {
; 5100 :                   bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5101 :                   lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4194304				; 00400000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN51@fnInitiali:

; 5102 :                }
; 5103 :             }
; 5104 :          } // if ( lpEntityInstance->u.nInd.bHidden == FALSE )...else...
; 5105 : 
; 5106 :          // At this point we've determined whether an EI needs an FK.  From
; 5107 :          // this point on we're only worried about genkeys.
; 5108 : 
; 5109 :          // If NoGenKey flag is set then we already created a genkey for
; 5110 :          // another linked instance.
; 5111 :          if ( lpEntityInstance->u.nInd.bNoGenKey )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 21					; 00000015H
	and	eax, 1
	je	SHORT $LN61@fnInitiali

; 5112 :             continue;

	jmp	$LN11@fnInitiali
$LN61@fnInitiali:

; 5113 : 
; 5114 :          // We only create genkeys for EIs that were created.  If it's
; 5115 :          // created make sure it's not also deleted.
; 5116 :          if ( lpEntityInstance->u.nInd.bCreated == FALSE ||

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN63@fnInitiali
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN62@fnInitiali
$LN63@fnInitiali:

; 5117 :               lpEntityInstance->u.nInd.bDeleted )
; 5118 :          {
; 5119 :             continue;

	jmp	$LN11@fnInitiali
$LN62@fnInitiali:

; 5120 :          }
; 5121 : 
; 5122 : #if ( VIEWENT_RULES )
; 5123 :          if ( lpViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$13[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	jne	SHORT $LN64@fnInitiali

; 5124 :             continue;

	jmp	$LN11@fnInitiali
$LN64@fnInitiali:

; 5125 : #endif
; 5126 : 
; 5127 :          if ( lpViewEntity->bGenkey == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$13[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 15					; 0000000fH
	and	edx, 1
	jne	SHORT $LN65@fnInitiali

; 5128 :             continue;

	jmp	$LN11@fnInitiali
$LN65@fnInitiali:

; 5129 : 
; 5130 :          // Check to see if the attribute is NULL.  If it is not then
; 5131 :          // we'll ignore it.
; 5132 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$13[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$10[ebp], eax
	jmp	SHORT $LN18@fnInitiali
$LN16@fnInitiali:

; 5134 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$10[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$10[ebp], eax
$LN18@fnInitiali:

; 5133 :                lpViewAttrib->bGenkey == FALSE;

	mov	ecx, DWORD PTR _lpViewAttrib$10[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN17@fnInitiali

; 5135 :          {
; 5136 :             ; // nothing needs to be done here
; 5137 :          }

	jmp	SHORT $LN16@fnInitiali
$LN17@fnInitiali:

; 5138 : 
; 5139 :          if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &pDummy,
; 5140 :                                                &uLth, lpEntityInstance,
; 5141 :                                                lpViewAttrib ) != -1 )

	mov	eax, DWORD PTR _lpViewAttrib$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$4[ebp]
	push	edx
	lea	eax, DWORD PTR _pDummy$3[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $LN66@fnInitiali

; 5142 :          {
; 5143 :             continue;   // Attrib is not null so ignore it.

	jmp	$LN11@fnInitiali
$LN66@fnInitiali:

; 5144 :          }
; 5145 : 
; 5146 :          // If genkey work object hasn't been activated, then activate it.
; 5147 :          if ( *lpKZGKHWOB == 0 )

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN67@fnInitiali

; 5148 :          {
; 5149 :             SfActivateSysEmptyOI( lpKZGKHWOB, "KZGKHWOB", vSubtask, zSINGLE );

	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG15119
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 5150 :             CreateEntity( *lpKZGKHWOB, "KZGKHWOB", zPOS_FIRST );

	push	1
	push	OFFSET $SG15120
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CreateEntity@12

; 5151 :             SetNameForView( *lpKZGKHWOB, "_KZGKHWOB", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET $SG15121
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetNameForView@16
$LN67@fnInitiali:

; 5152 :          }
; 5153 : 
; 5154 :          // lpKZGKHWOB is a work object that contains an entity for each
; 5155 :          // entity instance in the OI being committed and the number of
; 5156 :          // entity instances that need genkeys.
; 5157 :          //
; 5158 :          // If the lpViewEntity of the current entity instance is the same
; 5159 :          // as the previous entity instance, then increment the count in
; 5160 :          // lpKZGKHWOB by 1.  If they are different, then we need to find
; 5161 :          // the entity instance in lpKZGKHWOB that corresponds with the
; 5162 :          // current lpEntityInstance.  If one is not found, then it needs
; 5163 :          // to be created.
; 5164 :          if ( lpViewEntity != lpLastInsertedViewEntity )

	mov	eax, DWORD PTR _lpViewEntity$13[ebp]
	cmp	eax, DWORD PTR _lpLastInsertedViewEntity$[ebp]
	je	$LN68@fnInitiali

; 5165 :          {
; 5166 :             // lpViewEntity for current lpEntityInstance does not match
; 5167 :             // last lpEntityInstance.  Try to find the entity in lpKZGKHWOB
; 5168 :             // that corresponds with the lpViewEntity.
; 5169 :             nRC = SetCursorFirstEntityByInteger( *lpKZGKHWOB, "Genkey",

	push	OFFSET $SG15124
	mov	ecx, DWORD PTR _lpViewEntity$13[ebp]
	mov	edx, DWORD PTR [ecx+195]
	push	edx
	push	OFFSET $SG15125
	push	OFFSET $SG15126
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 5170 :                                                  "EntityID",
; 5171 :                                                  lpViewEntity->lEREntTok, "" );
; 5172 :             if ( nRC == zCURSOR_SET )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN70@fnInitiali

; 5173 :             {
; 5174 :                // Entity was found--increment genkey count by 1.
; 5175 :                AddToAttributeFromInteger( *lpKZGKHWOB, "Genkey",

	push	1
	push	OFFSET $SG15129
	push	OFFSET $SG15130
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_AddToAttributeFromInteger@16

; 5176 :                                           "EntityCount", 1 );
; 5177 :             }

	jmp	$LN71@fnInitiali
$LN70@fnInitiali:

; 5178 :             else
; 5179 :             {
; 5180 :                LPDATARECORD lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	edx, DWORD PTR _lpViewEntity$13[ebp]
	mov	eax, DWORD PTR [edx+191]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$7[ebp], eax

; 5181 : 
; 5182 :                // Entity not found--create entity and initialize.
; 5183 :                CreateEntity( *lpKZGKHWOB, "Genkey", zPOS_FIRST );

	push	1
	push	OFFSET $SG15131
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_CreateEntity@12

; 5184 :                SetAttributeFromInteger( *lpKZGKHWOB, "Genkey",

	mov	eax, DWORD PTR _lpViewEntity$13[ebp]
	mov	ecx, DWORD PTR [eax+195]
	push	ecx
	push	OFFSET $SG15132
	push	OFFSET $SG15133
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SetAttributeFromInteger@16

; 5185 :                                         "EntityID", lpViewEntity->lEREntTok );
; 5186 :                SetAttributeFromInteger( *lpKZGKHWOB, "Genkey",

	push	1
	push	OFFSET $SG15134
	push	OFFSET $SG15135
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromInteger@16

; 5187 :                                         "EntityCount", 1 );
; 5188 :                SetAttributeFromString( *lpKZGKHWOB, "Genkey",

	mov	eax, DWORD PTR _lpDataRecord$7[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET $SG15136
	push	OFFSET $SG15137
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromString@16

; 5189 :                                        "TableName", lpDataRecord->szRecordName );
; 5190 :                SetAttributeFromString( *lpKZGKHWOB, "Genkey",

	mov	eax, DWORD PTR _lpViewEntity$13[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG15138
	push	OFFSET $SG15139
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SetAttributeFromString@16
$LN71@fnInitiali:

; 5191 :                                        "EntityName", lpViewEntity->szName );
; 5192 :             }
; 5193 : 
; 5194 :             lpLastInsertedViewEntity = lpViewEntity;

	mov	eax, DWORD PTR _lpViewEntity$13[ebp]
	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], eax

; 5195 :          } // if ( lpViewEntity != lpLastInsertedViewEntity )...

	jmp	SHORT $LN69@fnInitiali
$LN68@fnInitiali:

; 5196 :          else
; 5197 :             AddToAttributeFromInteger( *lpKZGKHWOB, "Genkey", "EntityCount", 1 );

	push	1
	push	OFFSET $SG15140
	push	OFFSET $SG15141
	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_AddToAttributeFromInteger@16
$LN69@fnInitiali:

; 5198 : 
; 5199 :          bGenkeyNeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bGenkeyNeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5200 :          lpEntityInstance->u.nInd.bGenKeyNeeded = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1048576				; 00100000H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5201 : 
; 5202 :          // Set a flag for all linked instances to keep another genkey from
; 5203 :          // being created.
; 5204 :          if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN72@fnInitiali

; 5205 :          {
; 5206 :             LPENTITYINSTANCE lpLinked;
; 5207 : 
; 5208 :             for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$12[ebp], eax
	jmp	SHORT $LN21@fnInitiali
$LN19@fnInitiali:

; 5210 :                   lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpLinked$12[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$12[ebp], eax
$LN21@fnInitiali:

; 5209 :                   lpLinked != lpEntityInstance;

	mov	ecx, DWORD PTR _lpLinked$12[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN72@fnInitiali

; 5211 :             {
; 5212 :                lpLinked->u.nInd.bNoGenKey = TRUE;

	mov	edx, DWORD PTR _lpLinked$12[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2097152				; 00200000H
	mov	ecx, DWORD PTR _lpLinked$12[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5213 :             }

	jmp	SHORT $LN19@fnInitiali
$LN72@fnInitiali:

; 5214 :          }
; 5215 : 
; 5216 :       } // for ( lpEntityInstance )...

	jmp	$LN11@fnInitiali
$LN12@fnInitiali:

; 5217 :    } // for ( k = 0; k < nViewCount; k++ )

	jmp	$LN8@fnInitiali
$LN9@fnInitiali:

; 5218 : 
; 5219 :    // If the Genkey handler work object has been defined, then call the
; 5220 :    // genkey handler to start transactions.
; 5221 :    if ( *lpKZGKHWOB )

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN73@fnInitiali

; 5222 :    {
; 5223 :       if ( fnGetGKHandlerOper( *lpKZGKHWOB, lpCurrentTask, hGKHandler,
; 5224 :                                (zlpPGKHOPER) ppGKOper ) == zCALL_ERROR )

	mov	eax, DWORD PTR _ppGKOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hGKHandler$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnGetGKHandlerOper
	add	esp, 16					; 00000010H
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN74@fnInitiali

; 5225 :       {
; 5226 :          LPTASK lpTask = zGETPTR( vSubtask->hTask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$6[ebp], eax

; 5227 :          // "KZOEE082 - Error starting Genkey handler"
; 5228 :          fnIssueCoreError( lpTask, vSubtask, 16, 82, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	82					; 00000052H
	push	16					; 00000010H
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$6[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5229 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnInitiali
$LN74@fnInitiali:

; 5230 :       }
; 5231 : 
; 5232 :       // Call DBHandler routine to issue start of transaction.
; 5233 :       nRC = (**ppGKOper)( DBH_StartGenkey, vSubtask, 0, 0, *lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	64					; 00000040H
	mov	ecx, DWORD PTR _ppGKOper$[ebp]
	mov	edx, DWORD PTR [ecx]
	call	edx
	mov	WORD PTR _nRC$[ebp], ax

; 5234 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN75@fnInitiali

; 5235 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnInitiali
$LN75@fnInitiali:

; 5236 : 
; 5237 :       // Now set the gen keys.
; 5238 :       lpLastInsertedViewEntity = 0;

	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], 0

; 5239 :       for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN24@fnInitiali
$LN22@fnInitiali:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN24@fnInitiali:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN73@fnInitiali

; 5240 :       {
; 5241 :          // If we didn't find any genkeys for this view then skip it.
; 5242 :          if ( bGenkeyNeededArray[ k ] == FALSE )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _bGenkeyNeededArray$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN76@fnInitiali

; 5243 :             continue;

	jmp	SHORT $LN22@fnInitiali
$LN76@fnInitiali:

; 5244 : 
; 5245 :          // Go through entity instance looking for entities that need genkeys.
; 5246 :          for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOI_Array$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN27@fnInitiali
$LN25@fnInitiali:

; 5248 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN27@fnInitiali:

; 5247 :                lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN26@fnInitiali

; 5249 :          {
; 5250 :             LPVIEWENTITY lpViewEntity;
; 5251 :             LPVIEWATTRIB lpViewAttrib;
; 5252 :             zPVOID       pDummy;
; 5253 :             zULONG       uLth;
; 5254 : 
; 5255 :             // Look for an EI that needs a genkey.
; 5256 :             if ( lpEntityInstance->u.nInd.bGenKeyNeeded == FALSE )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 20					; 00000014H
	and	eax, 1
	jne	SHORT $LN77@fnInitiali

; 5257 :                continue;

	jmp	SHORT $LN25@fnInitiali
$LN77@fnInitiali:

; 5258 : 
; 5259 :             lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$11[ebp], eax

; 5260 : 
; 5261 :             // Check to see if the attribute is NULL.  If it is not then
; 5262 :             // we'll ignore it.
; 5263 :             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$11[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9[ebp], eax
	jmp	SHORT $LN30@fnInitiali
$LN28@fnInitiali:

; 5265 :                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$9[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9[ebp], eax
$LN30@fnInitiali:

; 5264 :                   lpViewAttrib->bGenkey == FALSE;

	mov	ecx, DWORD PTR _lpViewAttrib$9[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN29@fnInitiali

; 5266 :             {
; 5267 :                ; // nothing needs to be done here
; 5268 :             }

	jmp	SHORT $LN28@fnInitiali
$LN29@fnInitiali:

; 5269 : 
; 5270 :             if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &pDummy,
; 5271 :                                                   &uLth, lpEntityInstance,
; 5272 :                                                   lpViewAttrib ) != -1 )

	mov	eax, DWORD PTR _lpViewAttrib$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$2[ebp]
	push	edx
	lea	eax, DWORD PTR _pDummy$1[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	movsx	ecx, ax
	cmp	ecx, -1
	je	SHORT $LN78@fnInitiali

; 5273 :             {
; 5274 :                continue;   // attrib is not null so ignore it

	jmp	$LN25@fnInitiali
$LN78@fnInitiali:

; 5275 :             }
; 5276 : 
; 5277 :             if ( lpViewEntity != lpLastInsertedViewEntity )

	mov	edx, DWORD PTR _lpViewEntity$11[ebp]
	cmp	edx, DWORD PTR _lpLastInsertedViewEntity$[ebp]
	je	SHORT $LN79@fnInitiali

; 5278 :             {
; 5279 :                // lpViewEntity for current lpEntityInstance does not match
; 5280 :                // last lpEntityInstance.  Try to find the entity in lpKZGKHWOB
; 5281 :                // that corresponds with the lpViewEntity.
; 5282 :                nRC = SetCursorFirstEntityByInteger( *lpKZGKHWOB, "Genkey",

	push	OFFSET $SG15150
	mov	eax, DWORD PTR _lpViewEntity$11[ebp]
	mov	ecx, DWORD PTR [eax+195]
	push	ecx
	push	OFFSET $SG15151
	push	OFFSET $SG15152
	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SetCursorFirstEntityByInteger@20
	mov	WORD PTR _nRC$[ebp], ax

; 5283 :                                                     "EntityID",
; 5284 :                                                     lpViewEntity->lEREntTok, "" );
; 5285 : 
; 5286 :                lpLastInsertedViewEntity = lpViewEntity;

	mov	ecx, DWORD PTR _lpViewEntity$11[ebp]
	mov	DWORD PTR _lpLastInsertedViewEntity$[ebp], ecx
$LN79@fnInitiali:

; 5287 :             }
; 5288 : 
; 5289 :             fnEstablishViewForInstance( lpViewArray[ k ], 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 5290 : 
; 5291 :             // Tell genkey handler to set attribute value.
; 5292 :             nRC = (**ppGKOper)( DBH_GetGenkey, lpViewArray[ k ],

	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$11[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOD_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	push	128					; 00000080H
	mov	eax, DWORD PTR _ppGKOper$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	mov	WORD PTR _nRC$[ebp], ax

; 5293 :                                 lpViewOD_Array[ k ],
; 5294 :                                 lpViewEntity, *lpKZGKHWOB );
; 5295 :             if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN80@fnInitiali

; 5296 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnInitiali
$LN80@fnInitiali:

; 5297 : 
; 5298 :          } // for ( lpEntityInstance )...

	jmp	$LN25@fnInitiali
$LN26@fnInitiali:

; 5299 : 
; 5300 :       } // for ( k = 0; k < nViewCount; k++ )

	jmp	$LN22@fnInitiali
$LN73@fnInitiali:

; 5301 : 
; 5302 :    } // if ( *lpKZGKHWOB != 0 )...
; 5303 : 
; 5304 :    //
; 5305 :    // Now copy FKs.  We have to loop possibly many times to set the FKs.  It's
; 5306 :    // possible that the source for a FK is a FK from yet another EI.  We don't
; 5307 :    // want to copy a FK until we know that the source for a FK has been
; 5308 :    // properly set.  We also want to make sure we set the FK's for the EIs that
; 5309 :    // have been excluded/deleted before we copy FKs for the included/created.
; 5310 :    //
; 5311 :    bHiddenOnly = TRUE;  // We'll start by setting FKs for hidden EIs only.

	mov	BYTE PTR _bHiddenOnly$[ebp], 1

; 5312 :    nDebugCnt   = 0;     // We'll keep a counter in case we get an infinite loop.

	xor	eax, eax
	mov	WORD PTR _nDebugCnt$[ebp], ax

; 5313 :    bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1
$LN31@fnInitiali:

; 5314 :    while ( bSettingFKs )

	movzx	ecx, BYTE PTR _bSettingFKs$[ebp]
	test	ecx, ecx
	je	$LN32@fnInitiali

; 5315 :    {
; 5316 :       // We'll hope that we're done setting FKs after this iteration.  If we
; 5317 :       // find we need to set more FKs then we'll turn it back on.
; 5318 :       bSettingFKs = FALSE;

	mov	BYTE PTR _bSettingFKs$[ebp], 0

; 5319 : 
; 5320 :       if ( nDebugCnt++ > 100 )

	movsx	edx, WORD PTR _nDebugCnt$[ebp]
	mov	DWORD PTR tv546[ebp], edx
	mov	ax, WORD PTR _nDebugCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nDebugCnt$[ebp], ax
	cmp	DWORD PTR tv546[ebp], 100		; 00000064H
	jle	SHORT $LN81@fnInitiali

; 5321 :       {
; 5322 :          SysMessageBox( vSubtask, szlOE_SystemError,

	push	1
	push	OFFSET $SG15155
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysMessageBox@16

; 5323 :                         "Infinite loop trying to set FKs?", 1 );
; 5324 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnInitiali
$LN81@fnInitiali:

; 5325 :       }
; 5326 : 
; 5327 :       for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN35@fnInitiali
$LN33@fnInitiali:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN35@fnInitiali:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$LN34@fnInitiali

; 5328 :       {
; 5329 :          // If we didn't find any FKs for this view then skip it.
; 5330 :          if ( bFK_NeededArray[ k ] == FALSE )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _bFK_NeededArray$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN82@fnInitiali

; 5331 :             continue;

	jmp	SHORT $LN33@fnInitiali
$LN82@fnInitiali:

; 5332 : 
; 5333 :          // Let's hope that this view doesn't need FKs set after this
; 5334 :          // iteration.  If it does then we'll turn the flag back on.
; 5335 :          bFK_NeededArray[ k ] = FALSE;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 5336 : 
; 5337 :          // Go through entity instance looking for entities that need genkeys.
; 5338 :          // Also check to see if the EI needs to set a foreign key.
; 5339 :          for ( lpEntityInstance = zGETPTR( lpViewOI_Array[ k ]->hRootEntityInstance );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewOI_Array$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN38@fnInitiali
$LN36@fnInitiali:

; 5341 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN38@fnInitiali:

; 5340 :                lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN37@fnInitiali

; 5342 :          {
; 5343 :             LPVIEWENTITY lpViewEntity;
; 5344 : 
; 5345 :             // If the EI isn't flagged as needing a FK then skip it.
; 5346 :             if ( lpEntityInstance->u.nInd.bForeignKeys == FALSE )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 22					; 00000016H
	and	ecx, 1
	jne	SHORT $LN83@fnInitiali

; 5347 :                continue;

	jmp	SHORT $LN36@fnInitiali
$LN83@fnInitiali:

; 5348 : 
; 5349 :             // Entities on a derived path don't get a FK set..
; 5350 :             lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$5[ebp], eax

; 5351 :             if ( lpViewEntity->bDerivedPath )

	mov	ecx, DWORD PTR _lpViewEntity$5[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	je	SHORT $LN84@fnInitiali
$LN39@fnInitiali:

; 5352 :             {
; 5353 :                // If an EI is down a derived path then all children are also a
; 5354 :                // derived path.  We can try to save a little time by ignoring
; 5355 :                // all the children.
; 5356 :                while ( lpEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN40@fnInitiali

; 5357 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN39@fnInitiali
$LN40@fnInitiali:

; 5358 : 
; 5359 :                continue;

	jmp	$LN36@fnInitiali
$LN84@fnInitiali:

; 5360 :             }
; 5361 : 
; 5362 :             // If the EI is not hidden and we're setting FKs for hidden EIs
; 5363 :             // only then set flags for another try.
; 5364 :             if ( lpEntityInstance->u.nInd.bHidden == FALSE && bHiddenOnly )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN85@fnInitiali
	movzx	edx, BYTE PTR _bHiddenOnly$[ebp]
	test	edx, edx
	je	SHORT $LN85@fnInitiali

; 5365 :             {
; 5366 :                bFK_NeededArray[ k ] = TRUE;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [ecx+eax], 1

; 5367 :                bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1

; 5368 :                continue;

	jmp	$LN36@fnInitiali
$LN85@fnInitiali:

; 5369 :             }
; 5370 : 
; 5371 :             // Call a function to set the FK.  If the return code is 1 then
; 5372 :             // we couldn't set the FK because a source value hasn't been set
; 5373 :             // yet and we'll have to try again later.
; 5374 :             if ( fnSetForeignKeysForInstance( lpEntityInstance ) == 1 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnSetForeignKeysForInstance@4
	cwde
	cmp	eax, 1
	jne	SHORT $LN86@fnInitiali

; 5375 :             {
; 5376 :                bFK_NeededArray[ k ] = TRUE;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _bFK_NeededArray$[ebp]
	mov	BYTE PTR [edx+ecx], 1

; 5377 :                bSettingFKs = TRUE;

	mov	BYTE PTR _bSettingFKs$[ebp], 1
$LN86@fnInitiali:

; 5378 :             }
; 5379 : 
; 5380 :          } // for ( lpEntityInstance )...

	jmp	$LN36@fnInitiali
$LN37@fnInitiali:

; 5381 : 
; 5382 :       } // for ( k = 0; k < nViewCount; k++ )

	jmp	$LN33@fnInitiali
$LN34@fnInitiali:

; 5383 : 
; 5384 :       // After one iteration we can set non-hidden FKs.
; 5385 :       bHiddenOnly = FALSE;

	mov	BYTE PTR _bHiddenOnly$[ebp], 0

; 5386 : 
; 5387 :    } // while ( bSettingFKs )...

	jmp	$LN31@fnInitiali
$LN32@fnInitiali:

; 5388 : 
; 5389 :    return( 0 );

	xor	eax, eax
$LN1@fnInitiali:

; 5390 : 
; 5391 : } // fnInitializeGenKeys

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_fnInitializeGenKeys@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewCsr$1 = -1072					; size = 4
tv264 = -1068						; size = 4
tv260 = -1064						; size = 4
_lpCandidateViewOI$ = -1060				; size = 4
_lpCandidateViewOD$ = -1056				; size = 4
_lpViewOI$2 = -1052					; size = 4
tv184 = -1048						; size = 4
tv180 = -1044						; size = 4
_lpLinkedViewEntity$3 = -1040				; size = 4
_lpViewOD$4 = -1036					; size = 4
_lpCandidateViewEntity$ = -1032				; size = 4
_lpViewOI$ = -1028					; size = 4
_lpViewEntity$ = -1024					; size = 4
_lpLinked$5 = -1020					; size = 4
_lpView$6 = -1016					; size = 4
_bShowMsg$ = -1009					; size = 1
_k$ = -1008						; size = 2
_szMsg$7 = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_lpViewArray$ = 12					; size = 4
_lpViewOD_Array$ = 16					; size = 4
_lpViewOI_Array$ = 20					; size = 4
_nViewCount$ = 24					; size = 2
_bCheckCreate$ = 28					; size = 1
_fnCheckCreateDeleteFlags@24 PROC

; 4768 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1072				; 00000430H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4769 :    LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4770 :    LPVIEWENTITY lpCandidateViewEntity = 0;

	mov	DWORD PTR _lpCandidateViewEntity$[ebp], 0

; 4771 :    LPVIEWOD     lpCandidateViewOD = 0;

	mov	DWORD PTR _lpCandidateViewOD$[ebp], 0

; 4772 :    LPVIEWOI     lpCandidateViewOI = 0;

	mov	DWORD PTR _lpCandidateViewOI$[ebp], 0

; 4773 :    LPVIEWOI     lpViewOI;
; 4774 :    zBOOL        bShowMsg = TRUE;  // We'll assume a problem.

	mov	BYTE PTR _bShowMsg$[ebp], 1

; 4775 :    zSHORT       k;
; 4776 : 
; 4777 :    // Look for a linked entity instance that has create authority.
; 4778 :    if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	$LN14@fnCheckCre

; 4779 :    {
; 4780 :       LPENTITYINSTANCE lpLinked;
; 4781 : 
; 4782 :       for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$5[ebp], eax
	jmp	SHORT $LN4@fnCheckCre
$LN2@fnCheckCre:

; 4784 :             lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpLinked$5[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$5[ebp], eax
$LN4@fnCheckCre:

; 4783 :             lpLinked != lpEntityInstance;

	mov	ecx, DWORD PTR _lpLinked$5[ebp]
	cmp	ecx, DWORD PTR _lpEntityInstance$[ebp]
	je	$LN14@fnCheckCre

; 4785 :       {
; 4786 :          LPVIEWENTITY lpLinkedViewEntity;
; 4787 : 
; 4788 :          // If the EI doesn't have create authority then skip it.
; 4789 :          lpLinkedViewEntity = zGETPTR( lpLinked->hViewEntity );

	mov	edx, DWORD PTR _lpLinked$5[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$3[ebp], eax

; 4790 :          if ( bCheckCreate )

	movzx	ecx, BYTE PTR _bCheckCreate$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@fnCheckCre

; 4791 :          {
; 4792 :             if ( lpLinkedViewEntity->bCreate == FALSE )

	mov	edx, DWORD PTR _lpLinkedViewEntity$3[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	jne	SHORT $LN17@fnCheckCre

; 4793 :                continue;

	jmp	SHORT $LN2@fnCheckCre
$LN17@fnCheckCre:

; 4794 :          }

	jmp	SHORT $LN16@fnCheckCre
$LN15@fnCheckCre:

; 4795 :          else
; 4796 :          {
; 4797 :             if ( lpLinkedViewEntity->bDelete == FALSE )

	mov	ecx, DWORD PTR _lpLinkedViewEntity$3[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN16@fnCheckCre

; 4798 :                continue;

	jmp	SHORT $LN2@fnCheckCre
$LN16@fnCheckCre:

; 4799 :          }
; 4800 : 
; 4801 :          lpViewOI = zGETPTR( lpLinked->hViewOI );

	mov	eax, DWORD PTR _lpLinked$5[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4802 : 
; 4803 :          // Check to see if the linked EI belongs to one of the
; 4804 :          // OIs in the current cluster.
; 4805 :          for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN7@fnCheckCre
$LN5@fnCheckCre:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN7@fnCheckCre:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN6@fnCheckCre

; 4806 :          {
; 4807 :             if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN19@fnCheckCre

; 4808 :                continue;

	jmp	SHORT $LN5@fnCheckCre
$LN19@fnCheckCre:

; 4809 : 
; 4810 :             if ( lpViewOI == lpViewOI_Array[ k ] )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOI_Array$[ebp]
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	cmp	ecx, DWORD PTR [eax+edx*4]
	jne	SHORT $LN20@fnCheckCre

; 4811 :             {
; 4812 :                // We found a linked EI in the current cluster with
; 4813 :                // create authority.  Everything's OK.
; 4814 :                bShowMsg = FALSE;

	mov	BYTE PTR _bShowMsg$[ebp], 0

; 4815 :                break;

	jmp	SHORT $LN6@fnCheckCre
$LN20@fnCheckCre:

; 4816 :             }
; 4817 :          }

	jmp	SHORT $LN5@fnCheckCre
$LN6@fnCheckCre:

; 4818 : 
; 4819 :          if ( bShowMsg == FALSE )

	movzx	edx, BYTE PTR _bShowMsg$[ebp]
	test	edx, edx
	jne	SHORT $LN21@fnCheckCre

; 4820 :             break;

	jmp	SHORT $LN14@fnCheckCre
$LN21@fnCheckCre:

; 4821 : 
; 4822 :          // If we get here then we've found an EI that has create/delete
; 4823 :          // authority but is not part of an OI in the cluster.
; 4824 :          // This is a candidate for adding to the cluster.
; 4825 :          lpCandidateViewEntity = zGETPTR( lpLinked->hViewEntity );

	mov	eax, DWORD PTR _lpLinked$5[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCandidateViewEntity$[ebp], eax

; 4826 :          lpCandidateViewOD     = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCandidateViewOD$[ebp], eax

; 4827 :          lpCandidateViewOI     = lpViewOI;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR _lpCandidateViewOI$[ebp], ecx

; 4828 :       } // for ( lpLinked...)...

	jmp	$LN2@fnCheckCre
$LN14@fnCheckCre:

; 4829 :    }
; 4830 : 
; 4831 :    // If bShowMsg is TRUE then we didn't find an EI with create
; 4832 :    // authority in the current cluster.  Show diagnostic message.
; 4833 :    if ( bShowMsg )

	movzx	edx, BYTE PTR _bShowMsg$[ebp]
	test	edx, edx
	je	$LN1@fnCheckCre

; 4834 :    {
; 4835 :       zCHAR    szMsg[ 1000 ];
; 4836 :       zVIEW    lpView = 0;

	mov	DWORD PTR _lpView$6[ebp], 0

; 4837 :       LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$2[ebp], eax

; 4838 :       LPVIEWOD lpViewOD = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$2[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$4[ebp], eax

; 4839 : 
; 4840 :       // Find the view that references lpViewOI.
; 4841 :       for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN10@fnCheckCre
$LN8@fnCheckCre:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN10@fnCheckCre:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN9@fnCheckCre

; 4842 :       {
; 4843 :          LPVIEWCSR lpViewCsr;
; 4844 : 
; 4845 :          if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN23@fnCheckCre

; 4846 :             continue;

	jmp	SHORT $LN8@fnCheckCre
$LN23@fnCheckCre:

; 4847 : 
; 4848 :          lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 4849 :          if ( lpViewCsr->hViewOI == lpEntityInstance->hViewOI )

	mov	edx, DWORD PTR _lpViewCsr$1[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	jne	SHORT $LN24@fnCheckCre

; 4850 :          {
; 4851 :             // We found it.
; 4852 :             lpView = lpViewArray[ k ];

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _lpView$6[ebp], ecx

; 4853 :             break;

	jmp	SHORT $LN9@fnCheckCre
$LN24@fnCheckCre:

; 4854 :          }
; 4855 :       }

	jmp	SHORT $LN8@fnCheckCre
$LN9@fnCheckCre:

; 4856 : 
; 4857 :       TraceLineS( "----------------- Warning ----------------", "" );

	push	OFFSET $SG14945
	push	OFFSET $SG14946
	call	_TraceLineS@8

; 4858 :       zsprintf( szMsg, "Warning: Trying to commit an entity that "

	movzx	edx, BYTE PTR _bCheckCreate$[ebp]
	test	edx, edx
	je	SHORT $LN30@fnCheckCre
	mov	DWORD PTR tv180[ebp], OFFSET $SG14947
	jmp	SHORT $LN31@fnCheckCre
$LN30@fnCheckCre:
	mov	DWORD PTR tv180[ebp], OFFSET $SG14948
$LN31@fnCheckCre:
	movzx	eax, BYTE PTR _bCheckCreate$[ebp]
	test	eax, eax
	je	SHORT $LN32@fnCheckCre
	mov	DWORD PTR tv184[ebp], OFFSET $SG14949
	jmp	SHORT $LN33@fnCheckCre
$LN32@fnCheckCre:
	mov	DWORD PTR tv184[ebp], OFFSET $SG14950
$LN33@fnCheckCre:
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$4[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR tv180[ebp]
	push	eax
	mov	ecx, DWORD PTR tv184[ebp]
	push	ecx
	push	OFFSET $SG14951
	lea	edx, DWORD PTR _szMsg$7[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 4859 :                 "has been %s but does not have %s "
; 4860 :                 "authority in the current cluster.  OD.EntityName = %s.%s",
; 4861 :                 bCheckCreate ? "created" : "deleted",
; 4862 :                 bCheckCreate ? "create" : "delete",
; 4863 :                 lpViewOD->szName, lpViewEntity->szName );
; 4864 :       TraceLineS( szMsg, "" );

	push	OFFSET $SG14952
	lea	eax, DWORD PTR _szMsg$7[ebp]
	push	eax
	call	_TraceLineS@8

; 4865 :       TraceLineS( "", "" );

	push	OFFSET $SG14953
	push	OFFSET $SG14954
	call	_TraceLineS@8

; 4866 : 
; 4867 :       // List the views in the cluster.
; 4868 :       TraceLineI( "Number of views in the cluster: ", nViewCount );

	movsx	ecx, WORD PTR _nViewCount$[ebp]
	push	ecx
	push	OFFSET $SG14955
	call	_TraceLineI@8

; 4869 :       for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN13@fnCheckCre
$LN11@fnCheckCre:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN13@fnCheckCre:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN12@fnCheckCre

; 4870 :       {
; 4871 :          if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN25@fnCheckCre

; 4872 :          {
; 4873 :             TraceLineS( "   View ID = ", "(null) View not flagged as changed" );

	push	OFFSET $SG14957
	push	OFFSET $SG14958
	call	_TraceLineS@8

; 4874 :             continue;

	jmp	SHORT $LN11@fnCheckCre
$LN25@fnCheckCre:

; 4875 :          }
; 4876 : 
; 4877 :          zsprintf( szMsg, "   View ID = %lx, Object name = %s",

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewOD_Array$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	add	ecx, 10					; 0000000aH
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET $SG14959
	lea	edx, DWORD PTR _szMsg$7[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4878 :                    lpViewArray[ k ], lpViewOD_Array[ k ]->szName );
; 4879 :          TraceLineS( szMsg, "" );

	push	OFFSET $SG14960
	lea	eax, DWORD PTR _szMsg$7[ebp]
	push	eax
	call	_TraceLineS@8

; 4880 :       }

	jmp	$LN11@fnCheckCre
$LN12@fnCheckCre:

; 4881 : 
; 4882 : 
; 4883 :       zsprintf( szMsg, "%s.%s", lpViewOD->szName, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$4[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14961
	lea	eax, DWORD PTR _szMsg$7[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 4884 :       if ( bCheckCreate )

	movzx	ecx, BYTE PTR _bCheckCreate$[ebp]
	test	ecx, ecx
	je	SHORT $LN26@fnCheckCre

; 4885 :          TraceLineS( "OD.Entity with Create flag = ", szMsg );

	lea	edx, DWORD PTR _szMsg$7[ebp]
	push	edx
	push	OFFSET $SG14964
	call	_TraceLineS@8
	jmp	SHORT $LN27@fnCheckCre
$LN26@fnCheckCre:

; 4886 :       else
; 4887 :          TraceLineS( "OD.Entity with Delete flag = ", szMsg );

	lea	eax, DWORD PTR _szMsg$7[ebp]
	push	eax
	push	OFFSET $SG14965
	call	_TraceLineS@8
$LN27@fnCheckCre:

; 4888 :       TraceLineX( "OI ID = ", (zLONG) lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$2[ebp]
	push	ecx
	push	OFFSET $SG14966
	call	_TraceLineX@8

; 4889 : 
; 4890 :       if ( lpCandidateViewEntity )

	cmp	DWORD PTR _lpCandidateViewEntity$[ebp], 0
	je	SHORT $LN28@fnCheckCre

; 4891 :       {
; 4892 :          zsprintf( szMsg, "%s.%s", lpCandidateViewOD->szName,

	mov	edx, DWORD PTR _lpCandidateViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpCandidateViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14968
	lea	ecx, DWORD PTR _szMsg$7[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4893 :                    lpCandidateViewEntity->szName );
; 4894 :          TraceLineS( "OD.Entity with create authority = ", szMsg );

	lea	edx, DWORD PTR _szMsg$7[ebp]
	push	edx
	push	OFFSET $SG14969
	call	_TraceLineS@8

; 4895 :          TraceLineX( "OI ID = ", (zLONG) lpCandidateViewOI );

	mov	eax, DWORD PTR _lpCandidateViewOI$[ebp]
	push	eax
	push	OFFSET $SG14970
	call	_TraceLineX@8
$LN28@fnCheckCre:

; 4896 :       }
; 4897 : 
; 4898 :       TraceLineS( "", "" );

	push	OFFSET $SG14971
	push	OFFSET $SG14972
	call	_TraceLineS@8

; 4899 :       CreateViewFromViewForTask( &lpView, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$6[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 4900 :       fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$6[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 4901 :       DisplayEntityInstancePath( lpView, lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$6[ebp]
	push	eax
	call	_DisplayEntityInstancePath@8

; 4902 :       zsprintf( szMsg, "Warning: Trying to commit an entity that "

	movzx	ecx, BYTE PTR _bCheckCreate$[ebp]
	test	ecx, ecx
	je	SHORT $LN34@fnCheckCre
	mov	DWORD PTR tv260[ebp], OFFSET $SG14973
	jmp	SHORT $LN35@fnCheckCre
$LN34@fnCheckCre:
	mov	DWORD PTR tv260[ebp], OFFSET $SG14974
$LN35@fnCheckCre:
	movzx	edx, BYTE PTR _bCheckCreate$[ebp]
	test	edx, edx
	je	SHORT $LN36@fnCheckCre
	mov	DWORD PTR tv264[ebp], OFFSET $SG14975
	jmp	SHORT $LN37@fnCheckCre
$LN36@fnCheckCre:
	mov	DWORD PTR tv264[ebp], OFFSET $SG14976
$LN37@fnCheckCre:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$4[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR tv260[ebp]
	push	edx
	mov	eax, DWORD PTR tv264[ebp]
	push	eax
	push	OFFSET $SG14977
	lea	ecx, DWORD PTR _szMsg$7[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H

; 4903 :                 "has been %s but does not have %s "
; 4904 :                 "authority in the current cluster.  OD.EntityName = %s.%s. "
; 4905 :                 "See trace for more information.",
; 4906 :                 bCheckCreate ? "created" : "deleted",
; 4907 :                 bCheckCreate ? "create" : "delete",
; 4908 :                 lpViewOD->szName, lpViewEntity->szName );
; 4909 :       SysDiagnosticMessage( lpView, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	edx, DWORD PTR _szMsg$7[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$6[ebp]
	push	ecx
	call	_SysDiagnosticMessage@16

; 4910 :       TraceLineS( "-------------------", "" );

	push	OFFSET $SG14978
	push	OFFSET $SG14979
	call	_TraceLineS@8

; 4911 :       fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$6[ebp]
	push	edx
	call	_fnDropView@4
$LN1@fnCheckCre:

; 4912 :    }
; 4913 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnCheckCreateDeleteFlags@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpTask$ = -124						; size = 4
_lpValue$1 = -120					; size = 4
_uLth$2 = -116						; size = 4
_lpDataRecord$ = -112					; size = 4
_lpViewOI$ = -108					; size = 4
_lpSrcViewEntity$3 = -104				; size = 4
_lpWkSrcViewEntity$4 = -100				; size = 4
_lpWkRelViewEntity$5 = -96				; size = 4
_lpRelRecord$ = -92					; size = 4
_lpSrcViewAttrib$6 = -88				; size = 4
_lpViewEntity$ = -84					; size = 4
_lpWkDataField$7 = -80					; size = 4
_s$8 = -76						; size = 3
_p$9 = -72						; size = 4
tv226 = -68						; size = 4
_lpRelViewEntity$10 = -64				; size = 4
_lpRelViewAttrib$11 = -60				; size = 4
_lpSrcInstance$12 = -56					; size = 4
_lpRelField$ = -52					; size = 4
_lpRelInstance$13 = -48					; size = 4
_d$14 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnSetForeignKeysForInstance@4 PROC

; 4571 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4572 :    LPVIEWENTITY   lpViewEntity;
; 4573 :    LPDATARECORD   lpDataRecord;
; 4574 :    LPRELRECORD    lpRelRecord;
; 4575 :    LPRELFIELD     lpRelField;
; 4576 :    LPVIEWOI       lpViewOI;
; 4577 :    LPTASK         lpTask;
; 4578 : 
; 4579 :    lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4580 : 
; 4581 :    // Get Task owning the view object instance
; 4582 :    lpTask = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4583 : 
; 4584 :    lpEntityInstance->u.nInd.bForeignKeys = 0;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -4194305				; ffbfffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 4585 : 
; 4586 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4587 :    if ( lpViewEntity->hParent == 0 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN11@fnSetForei

; 4588 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSetForei
$LN11@fnSetForei:

; 4589 : 
; 4590 :    lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 4591 :    lpRelRecord  = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 4592 :    if ( lpRelRecord == 0 )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	jne	SHORT $LN12@fnSetForei

; 4593 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSetForei
$LN12@fnSetForei:

; 4594 : 
; 4595 :    lpRelField   = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax

; 4596 :    if ( lpRelField == 0 )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	jne	SHORT $LN13@fnSetForei

; 4597 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSetForei
$LN13@fnSetForei:

; 4598 : 
; 4599 :    // For each rel field, check to see if the current entity
; 4600 :    // instance has a foreign key.  If it does, then the value
; 4601 :    // needs to be copied
; 4602 :    for ( ;

	jmp	SHORT $LN4@fnSetForei
$LN2@fnSetForei:

; 4604 :          lpRelField = zGETPTR( lpRelField->hNextRelField ) )

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN4@fnSetForei:

; 4603 :          lpRelField;

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN3@fnSetForei

; 4605 :    {
; 4606 :       LPVIEWATTRIB      lpSrcViewAttrib;
; 4607 :       LPVIEWATTRIB      lpRelViewAttrib;
; 4608 :       LPVIEWENTITY      lpRelViewEntity;
; 4609 :       LPVIEWENTITY      lpSrcViewEntity;
; 4610 :       LPENTITYINSTANCE  lpRelInstance;
; 4611 :       LPENTITYINSTANCE  lpSrcInstance;
; 4612 :       LPDATAFIELD       lpWkDataField;
; 4613 : 
; 4614 :       // If the rel field doesn't have a data field, then skip it.
; 4615 :       if ( lpRelField->hRelDataField == 0 )

	mov	eax, DWORD PTR _lpRelField$[ebp]
	cmp	DWORD PTR [eax+14], 0
	jne	SHORT $LN14@fnSetForei

; 4616 :          continue;

	jmp	SHORT $LN2@fnSetForei
$LN14@fnSetForei:

; 4617 : 
; 4618 :       lpWkDataField   = zGETPTR( lpRelField->hSrcDataField );

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkDataField$7[ebp], eax

; 4619 :       lpSrcViewAttrib = zGETPTR( lpWkDataField->hViewAttrib );

	mov	eax, DWORD PTR _lpWkDataField$7[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$6[ebp], eax

; 4620 :       lpWkDataField   = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkDataField$7[ebp], eax

; 4621 :       lpRelViewAttrib = zGETPTR( lpWkDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpWkDataField$7[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelViewAttrib$11[ebp], eax

; 4622 :       lpSrcViewEntity = zGETPTR( lpSrcViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpSrcViewAttrib$6[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$3[ebp], eax

; 4623 :       lpRelViewEntity = zGETPTR( lpRelViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpRelViewAttrib$11[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelViewEntity$10[ebp], eax

; 4624 : 
; 4625 :       // We now have the attributes--the source and relationship (i.e. target)
; 4626 :       // attributes.  One is part of the current entity (lpViewEntity) and
; 4627 :       // the other is a parent of the current entity.  Find the entity
; 4628 :       // instance of the parent entity.
; 4629 : 
; 4630 :       if ( lpRelViewEntity != lpViewEntity )

	mov	ecx, DWORD PTR _lpRelViewEntity$10[ebp]
	cmp	ecx, DWORD PTR _lpViewEntity$[ebp]
	je	$LN15@fnSetForei

; 4631 :       {
; 4632 :          // The relationship entity is different from the current entity.
; 4633 :          // Find the relationship entity instance.
; 4634 :          lpSrcInstance = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpSrcInstance$12[ebp], edx

; 4635 :          lpRelInstance = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelInstance$13[ebp], eax
$LN5@fnSetForei:

; 4636 :          while ( lpRelInstance->hViewEntity != lpRelViewAttrib->hViewEntity )

	mov	edx, DWORD PTR _lpRelInstance$13[ebp]
	mov	eax, DWORD PTR _lpRelViewAttrib$11[ebp]
	mov	ecx, DWORD PTR [edx+2]
	cmp	ecx, DWORD PTR [eax+6]
	je	SHORT $LN6@fnSetForei

; 4637 :          {
; 4638 :             LPVIEWENTITY lpWkRelViewEntity =

	mov	edx, DWORD PTR _lpRelInstance$13[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkRelViewEntity$5[ebp], eax

; 4639 :                                     zGETPTR( lpRelInstance->hViewEntity );
; 4640 : 
; 4641 :             // DGC 4/8/97
; 4642 :             // If the parent entity we are looking for is a recursive parent,
; 4643 :             // then it's possible that the entity instance we are looking for
; 4644 :             // has an lpViewEntity that is the recursive child entity.
; 4645 :             if ( lpRelViewEntity->bRecursivePar &&
; 4646 :                  lpWkRelViewEntity->bRecursive &&

	mov	ecx, DWORD PTR _lpRelViewEntity$10[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 29					; 0000001dH
	and	edx, 1
	je	SHORT $LN17@fnSetForei
	mov	eax, DWORD PTR _lpWkRelViewEntity$5[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN17@fnSetForei
	mov	edx, DWORD PTR _lpWkRelViewEntity$5[ebp]
	mov	eax, DWORD PTR _lpRelViewEntity$10[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $LN17@fnSetForei

; 4647 :                  lpWkRelViewEntity->lEREntTok == lpRelViewEntity->lEREntTok )
; 4648 :             {
; 4649 :                break;

	jmp	SHORT $LN6@fnSetForei
$LN17@fnSetForei:

; 4650 :             }
; 4651 : 
; 4652 :             lpRelInstance = zGETPTR( lpRelInstance->hParent );

	mov	edx, DWORD PTR _lpRelInstance$13[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelInstance$13[ebp], eax

; 4653 :          }

	jmp	SHORT $LN5@fnSetForei
$LN6@fnSetForei:

; 4654 :       } // if ( lpRelViewEntity != lpViewEntity )...

	jmp	SHORT $LN16@fnSetForei
$LN15@fnSetForei:

; 4655 :       else
; 4656 :       {
; 4657 :          // The source entity is different from the current entity.
; 4658 :          // Find the source entity instance.
; 4659 :          lpRelInstance = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpRelInstance$13[ebp], ecx

; 4660 :          lpSrcInstance = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$12[ebp], eax
$LN7@fnSetForei:

; 4661 :          while ( lpSrcInstance->hViewEntity != lpSrcViewAttrib->hViewEntity )

	mov	ecx, DWORD PTR _lpSrcInstance$12[ebp]
	mov	edx, DWORD PTR _lpSrcViewAttrib$6[ebp]
	mov	eax, DWORD PTR [ecx+2]
	cmp	eax, DWORD PTR [edx+6]
	je	SHORT $LN16@fnSetForei

; 4662 :          {
; 4663 :             LPVIEWENTITY lpWkSrcViewEntity =

	mov	ecx, DWORD PTR _lpSrcInstance$12[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkSrcViewEntity$4[ebp], eax

; 4664 :                                     zGETPTR( lpSrcInstance->hViewEntity );
; 4665 : 
; 4666 :             // DGC 4/8/97
; 4667 :             // If the parent entity we are looking for is a recursive parent,
; 4668 :             // then it's possible that the entity instance we are looking for
; 4669 :             // has an lpViewEntity that is the recursive child entity.
; 4670 :             if ( lpSrcViewEntity->bRecursivePar &&
; 4671 :                  lpWkSrcViewEntity->bRecursive &&

	mov	eax, DWORD PTR _lpSrcViewEntity$3[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 29					; 0000001dH
	and	ecx, 1
	je	SHORT $LN18@fnSetForei
	mov	edx, DWORD PTR _lpWkSrcViewEntity$4[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN18@fnSetForei
	mov	ecx, DWORD PTR _lpWkSrcViewEntity$4[ebp]
	mov	edx, DWORD PTR _lpSrcViewEntity$3[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $LN18@fnSetForei

; 4672 :                  lpWkSrcViewEntity->lEREntTok == lpSrcViewEntity->lEREntTok )
; 4673 :             {
; 4674 :                break;

	jmp	SHORT $LN16@fnSetForei
$LN18@fnSetForei:

; 4675 :             }
; 4676 : 
; 4677 :             lpSrcInstance = zGETPTR( lpSrcInstance->hParent );

	mov	ecx, DWORD PTR _lpSrcInstance$12[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$12[ebp], eax

; 4678 :          }

	jmp	SHORT $LN7@fnSetForei
$LN16@fnSetForei:

; 4679 :       } // if ( lpRelViewEntity != lpViewEntity )...else...
; 4680 : 
; 4681 :       if ( lpEntityInstance->u.nInd.bCreated ||

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN21@fnSetForei
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN19@fnSetForei
$LN21@fnSetForei:

; 4682 :            lpEntityInstance->u.nInd.bIncluded )
; 4683 :       {
; 4684 :          zULONG  uLth;
; 4685 :          zPVOID  lpValue;
; 4686 : 
; 4687 :          // If the source instance hasn't had *IT'S* FKs set then skip this
; 4688 :          // one and try again later.
; 4689 :          if ( lpSrcInstance->u.nInd.bForeignKeys )

	mov	ecx, DWORD PTR _lpSrcInstance$12[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 22					; 00000016H
	and	edx, 1
	je	SHORT $LN22@fnSetForei

; 4690 :          {
; 4691 :             // Turn the flag back on for this instance.
; 4692 :             lpEntityInstance->u.nInd.bForeignKeys = TRUE;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 4194304				; 00400000H
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 4693 :             return( 1 );

	mov	eax, 1
	jmp	$LN1@fnSetForei
$LN22@fnSetForei:

; 4694 :          }
; 4695 : 
; 4696 :          fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpValue,

	mov	eax, DWORD PTR _lpSrcViewAttrib$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcInstance$12[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$2[ebp]
	push	edx
	lea	eax, DWORD PTR _lpValue$1[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 4697 :                                           &uLth,
; 4698 :                                           lpSrcInstance,
; 4699 :                                           lpSrcViewAttrib );
; 4700 :          fnStoreValueInEntityInstance( lpRelInstance,

	mov	ecx, DWORD PTR _uLth$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpValue$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelViewAttrib$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewEntity$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelInstance$13[ebp]
	push	edx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H

; 4701 :                                        lpRelViewEntity,
; 4702 :                                        lpRelViewAttrib,
; 4703 :                                        lpValue, uLth );
; 4704 :       }

	jmp	$LN20@fnSetForei
$LN19@fnSetForei:

; 4705 :       else
; 4706 :       {
; 4707 :          zDECIMAL d;
; 4708 :          zCHAR    s[ 3 ] = "";

	mov	al, BYTE PTR $SG14876
	mov	BYTE PTR _s$8[ebp], al
	xor	ecx, ecx
	mov	WORD PTR _s$8[ebp+1], cx

; 4709 :          zPVOID   p;
; 4710 : 
; 4711 :          // Set foreign key to null.
; 4712 :          switch ( lpRelViewAttrib->cType )

	mov	edx, DWORD PTR _lpRelViewAttrib$11[ebp]
	movsx	eax, BYTE PTR [edx+202]
	mov	DWORD PTR tv226[ebp], eax
	mov	ecx, DWORD PTR tv226[ebp]
	sub	ecx, 68					; 00000044H
	mov	DWORD PTR tv226[ebp], ecx
	cmp	DWORD PTR tv226[ebp], 16		; 00000010H
	ja	SHORT $LN9@fnSetForei
	mov	edx, DWORD PTR tv226[ebp]
	movzx	eax, BYTE PTR $LN29@fnSetForei[edx]
	jmp	DWORD PTR $LN30@fnSetForei[eax*4]
$LN23@fnSetForei:

; 4713 :          {
; 4714 :             case zTYPE_DECIMAL:
; 4715 :                SysAssignDecimalFromNull( &d );

	lea	ecx, DWORD PTR _d$14[ebp]
	push	ecx
	call	_SysAssignDecimalFromNull@4

; 4716 :                p = (zPVOID) &d;

	lea	edx, DWORD PTR _d$14[ebp]
	mov	DWORD PTR _p$9[ebp], edx

; 4717 :                break;

	jmp	SHORT $LN9@fnSetForei
$LN24@fnSetForei:

; 4718 : 
; 4719 :             case zTYPE_INTEGER:
; 4720 :                p = (zPVOID) &lNullInteger;

	mov	DWORD PTR _p$9[ebp], OFFSET _lNullInteger

; 4721 :                break;

	jmp	SHORT $LN9@fnSetForei
$LN25@fnSetForei:

; 4722 : 
; 4723 :             case zTYPE_STRING:
; 4724 :                p = (zPVOID) s;

	lea	eax, DWORD PTR _s$8[ebp]
	mov	DWORD PTR _p$9[ebp], eax

; 4725 :                break;

	jmp	SHORT $LN9@fnSetForei
$LN26@fnSetForei:

; 4726 : 
; 4727 :             case zTYPE_DATE:
; 4728 :             case zTYPE_DATETIME:
; 4729 :                p = (zPVOID) &stNullDateTime;

	mov	DWORD PTR _p$9[ebp], OFFSET _stNullDateTime
$LN9@fnSetForei:

; 4730 :                break;
; 4731 :          }
; 4732 : 
; 4733 :          // Gig, 10/4/93
; 4734 :          // If the foreign key is a key to the target entity, then
; 4735 :          // we cannot null the key because we would lose the
; 4736 :          // capability of updating the entity (in this case it
; 4737 :          // better be deleted!!!)
; 4738 :          if ( lpRelViewAttrib->bKey == FALSE )

	mov	ecx, DWORD PTR _lpRelViewAttrib$11[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN20@fnSetForei

; 4739 :          {
; 4740 :             // HH: p points to correct datatype (set in 'switch' above).
; 4741 :             fnStoreValueInEntityInstance( lpRelInstance,

	push	0
	mov	eax, DWORD PTR _p$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRelViewAttrib$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRelViewEntity$10[ebp]
	push	edx
	mov	eax, DWORD PTR _lpRelInstance$13[ebp]
	push	eax
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
$LN20@fnSetForei:

; 4742 :                                           lpRelViewEntity,
; 4743 :                                           lpRelViewAttrib,
; 4744 :                                           (zPVOID) p, 0 );
; 4745 :          }
; 4746 :       }
; 4747 : 
; 4748 :       // Turn off the dbh flag to make sure that the DBHandler updates
; 4749 :       // the instance.
; 4750 :       lpRelInstance->u.nInd.bDBHUpdated = FALSE;

	mov	ecx, DWORD PTR _lpRelInstance$13[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _lpRelInstance$13[ebp]
	mov	DWORD PTR [eax+6], edx

; 4751 : 
; 4752 :    } // for ( lpRelField )...

	jmp	$LN2@fnSetForei
$LN3@fnSetForei:

; 4753 : 
; 4754 :    return( 0 );

	xor	eax, eax
$LN1@fnSetForei:

; 4755 : 
; 4756 : } // fnSetForeignKeysForInstance

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$LN30@fnSetForei:
	DD	$LN26@fnSetForei
	DD	$LN24@fnSetForei
	DD	$LN23@fnSetForei
	DD	$LN25@fnSetForei
	DD	$LN9@fnSetForei
$LN29@fnSetForei:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	0
_fnSetForeignKeysForInstance@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_ActBuffData$ = -20					; size = 12
_pchData$ = -8						; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_lpAppQualView$ = 16					; size = 4
_pchBuffer$ = 20					; size = 4
_uLth$ = 24						; size = 4
_lControl$ = 28						; size = 4
_fnActivateOI_FromBuffer@24 PROC

; 3172 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3173 :    BufferDataRecord ActBuffData;
; 3174 :    zPCHAR pchData;
; 3175 :    zSHORT nRC;
; 3176 : 
; 3177 :    // SfActivate needs to be able to change the data in the buffer.  Because of
; 3178 :    // this we will copy the buffer into a temporary buffer.  SfActivate also
; 3179 :    // expects an extra character at the end of the buffer to indicate the EOF.
; 3180 :    // So we need to allocate an extra byte.
; 3181 :    pchData = malloc( uLth + 1 );

	mov	eax, DWORD PTR _uLth$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pchData$[ebp], eax

; 3182 :    zmemcpy( pchData, pchBuffer, uLth );

	mov	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchData$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 3183 :    pchData[ uLth ] = 0;  // set the last byte to NULL

	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	BYTE PTR [ecx], 0

; 3184 : 
; 3185 :    // Set up data to be passed through to fnReadDataFromBuffer( ).
; 3186 :    ActBuffData.pchBuffer      = pchData;

	mov	edx, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp], edx

; 3187 :    ActBuffData.pchCurrentByte = pchData;

	mov	eax, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp+4], eax

; 3188 :    ActBuffData.pchEnd         = pchData + uLth;

	mov	ecx, DWORD PTR _pchData$[ebp]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	DWORD PTR _ActBuffData$[ebp+8], ecx

; 3189 : 
; 3190 :    nRC = SfActivateOI_FromStream( pvReturnView, cpcViewOD_Name,

	lea	edx, DWORD PTR _ActBuffData$[ebp]
	push	edx
	push	OFFSET _fnReadDataFromBuffer@20
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_SfActivateOI_FromStream@24
	mov	WORD PTR _nRC$[ebp], ax

; 3191 :                                   lpAppQualView, lControl,
; 3192 :                                   fnReadDataFromBuffer,
; 3193 :                                   (zPVOID) &ActBuffData );
; 3194 :    free( pchData );

	mov	ecx, DWORD PTR _pchData$[ebp]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 3195 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 3196 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnActivateOI_FromBuffer@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchExtraData$1 = -16					; size = 4
_lpTask$2 = -12						; size = 4
tv70 = -8						; size = 4
_lpBufferData$ = -4					; size = 4
_lpView$ = 8						; size = 4
_pvData$ = 12						; size = 4
_ppchReturnBuffer$ = 16					; size = 4
_uLth$ = 20						; size = 4
_nErrorNbr$ = 24					; size = 2
_fnReadDataFromBuffer@20 PROC

; 3074 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3075 :    LPBUFFERDATA lpBufferData = (LPBUFFERDATA) pvData;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpBufferData$[ebp], eax

; 3076 : 
; 3077 :    // If nErrorNbr is not 0, then flash the error message and get out.
; 3078 :    if ( nErrorNbr )

	movsx	ecx, WORD PTR _nErrorNbr$[ebp]
	test	ecx, ecx
	je	$LN6@fnReadData

; 3079 :    {
; 3080 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 3081 :       zPCHAR pchExtraData = (zPCHAR) ppchReturnBuffer;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR _pchExtraData$1[ebp], ecx

; 3082 : 
; 3083 :       switch ( nErrorNbr )

	movsx	edx, WORD PTR _nErrorNbr$[ebp]
	mov	DWORD PTR tv70[ebp], edx
	mov	eax, DWORD PTR tv70[ebp]
	sub	eax, 74					; 0000004aH
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 30			; 0000001eH
	ja	$LN2@fnReadData
	mov	ecx, DWORD PTR tv70[ebp]
	movzx	edx, BYTE PTR $LN19@fnReadData[ecx]
	jmp	DWORD PTR $LN20@fnReadData[edx*4]
$LN7@fnReadData:

; 3084 :       {
; 3085 :          case 74:
; 3086 :             // "KZOEE074 - Invalid Entity name on line "
; 3087 :             fnIssueCoreError( lpTask, lpView, 16, 74, 0,

	push	0
	mov	eax, DWORD PTR _pchExtraData$1[ebp]
	push	eax
	push	0
	push	74					; 0000004aH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3088 :                               pchExtraData, 0 );
; 3089 :             break;

	jmp	SHORT $LN2@fnReadData
$LN8@fnReadData:

; 3090 : 
; 3091 :          case 75:
; 3092 :             // "KZOEE075 - Invalid Entity level on line "
; 3093 :             fnIssueCoreError( lpTask, lpView, 16, 75, 0,

	push	0
	mov	eax, DWORD PTR _pchExtraData$1[ebp]
	push	eax
	push	0
	push	75					; 0000004bH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$2[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3094 :                               pchExtraData, 0 );
; 3095 :             break;

	jmp	SHORT $LN2@fnReadData
$LN9@fnReadData:

; 3096 : 
; 3097 :          case 90:
; 3098 :             // "KZOEE090 - Maximum number of entites in portable file exceeded"
; 3099 :             fnIssueCoreError( lpTask, lpView, 16, 90, 0, 0, "" );

	push	OFFSET $SG14413
	push	0
	push	0
	push	90					; 0000005aH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3100 :             break;

	jmp	SHORT $LN2@fnReadData
$LN10@fnReadData:

; 3101 : 
; 3102 :          case 104:
; 3103 :             // "KZOEE104 - Invalid Attribute name for Entity"
; 3104 :             fnIssueCoreError( lpTask, lpView, 16, 104, 0, pchExtraData, 0 );

	push	0
	mov	edx, DWORD PTR _pchExtraData$1[ebp]
	push	edx
	push	0
	push	104					; 00000068H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN2@fnReadData:

; 3105 :             break;
; 3106 : 
; 3107 :       } // switch ( nErrorNbr )
; 3108 : 
; 3109 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnReadData
$LN6@fnReadData:

; 3110 : 
; 3111 :    } // if ( nErrorNbr )...
; 3112 : 
; 3113 :    if ( lpBufferData->pchCurrentByte >= lpBufferData->pchEnd )

	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jb	SHORT $LN11@fnReadData

; 3114 :    {
; 3115 :       *ppchReturnBuffer = 0;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR [edx], 0

; 3116 :       return( 0 ); // EOF

	xor	eax, eax
	jmp	$LN1@fnReadData
$LN11@fnReadData:

; 3117 :    }
; 3118 : 
; 3119 :    if ( uLth )

	cmp	DWORD PTR _uLth$[ebp], 0
	je	SHORT $LN12@fnReadData

; 3120 :    {
; 3121 :       if ( lpBufferData->pchCurrentByte + uLth >= lpBufferData->pchEnd )

	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	cmp	ecx, DWORD PTR [edx+8]
	jb	SHORT $LN14@fnReadData

; 3122 :       {
; 3123 :          SysMessageBox( lpView, "Internal Core Error", "Out of buffer space", 1 );

	push	1
	push	OFFSET $SG14419
	push	OFFSET $SG14420
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 3124 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnReadData
$LN14@fnReadData:

; 3125 :       }
; 3126 : 
; 3127 :       *ppchReturnBuffer = lpBufferData->pchCurrentByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax

; 3128 :       lpBufferData->pchCurrentByte += uLth;

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [eax+4], edx

; 3129 : 
; 3130 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnReadData

; 3131 :    }

	jmp	$LN1@fnReadData
$LN12@fnReadData:

; 3132 :    else
; 3133 :    {
; 3134 :       *ppchReturnBuffer = lpBufferData->pchCurrentByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx], eax
$LN4@fnReadData:

; 3135 : 
; 3136 :       // Look for the end of the line or the end of the buffer.  Note that
; 3137 :       // pchEnd points to the "EOF" char and is not part of the data.
; 3138 :       while ( lpBufferData->pchCurrentByte[ 0 ] != '\n' &&
; 3139 :               lpBufferData->pchCurrentByte[ 0 ] != '\r' &&

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movsx	edx, BYTE PTR [ecx+edx]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN5@fnReadData
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 13					; 0000000dH
	je	SHORT $LN5@fnReadData
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN5@fnReadData

; 3140 :               lpBufferData->pchCurrentByte < lpBufferData->pchEnd )
; 3141 :       {
; 3142 :          lpBufferData->pchCurrentByte++;

	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 3143 :       }

	jmp	SHORT $LN4@fnReadData
$LN5@fnReadData:

; 3144 : 
; 3145 :       if ( (lpBufferData->pchCurrentByte[ 0 ] == '\r' &&
; 3146 :             lpBufferData->pchCurrentByte[ 1 ] == '\n' ) ||

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN17@fnReadData
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN16@fnReadData
$LN17@fnReadData:
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movsx	eax, BYTE PTR [edx+eax]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN15@fnReadData
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN15@fnReadData
$LN16@fnReadData:

; 3147 :            (lpBufferData->pchCurrentByte[ 0 ] == '\n' &&
; 3148 :             lpBufferData->pchCurrentByte[ 1 ] == '\r') )
; 3149 :       {
; 3150 :          *(lpBufferData->pchCurrentByte++) = 0;  // Null end of line and skip \r or \n

	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN15@fnReadData:

; 3151 :       }
; 3152 : 
; 3153 :       *(lpBufferData->pchCurrentByte++) = 0;  // Null end of line and skip \r or \n

	mov	ecx, DWORD PTR _lpBufferData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _lpBufferData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _lpBufferData$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 3154 : 
; 3155 :       return( 1 );

	mov	eax, 1
$LN1@fnReadData:

; 3156 :    }
; 3157 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN20@fnReadData:
	DD	$LN7@fnReadData
	DD	$LN8@fnReadData
	DD	$LN9@fnReadData
	DD	$LN10@fnReadData
	DD	$LN2@fnReadData
$LN19@fnReadData:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnReadDataFromBuffer@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchExtraData$1 = -16					; size = 4
_lpTask$2 = -12						; size = 4
tv70 = -8						; size = 4
_lpFileData$ = -4					; size = 4
_lpView$ = 8						; size = 4
_pvData$ = 12						; size = 4
_ppchReturnBuffer$ = 16					; size = 4
_uLth$ = 20						; size = 4
_nErrorNbr$ = 24					; size = 2
_fnReadDataFromFileStream@20 PROC

; 2350 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2351 :    LPFILEDATA lpFileData = (LPFILEDATA) pvData;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR _lpFileData$[ebp], eax

; 2352 : 
; 2353 :    // If nErrorNbr is not 0, then flash the error message and get out.
; 2354 :    if ( nErrorNbr )

	movsx	ecx, WORD PTR _nErrorNbr$[ebp]
	test	ecx, ecx
	je	$LN4@fnReadData

; 2355 :    {
; 2356 :       zPCHAR pchExtraData = (zPCHAR) ppchReturnBuffer;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR _pchExtraData$1[ebp], edx

; 2357 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 2358 : 
; 2359 :       switch ( nErrorNbr )

	movsx	edx, WORD PTR _nErrorNbr$[ebp]
	mov	DWORD PTR tv70[ebp], edx
	mov	eax, DWORD PTR tv70[ebp]
	sub	eax, 74					; 0000004aH
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 30			; 0000001eH
	ja	$LN2@fnReadData
	mov	ecx, DWORD PTR tv70[ebp]
	movzx	edx, BYTE PTR $LN12@fnReadData[ecx]
	jmp	DWORD PTR $LN13@fnReadData[edx*4]
$LN5@fnReadData:

; 2360 :       {
; 2361 :          case 74:
; 2362 :          {
; 2363 :             // "KZOEE074 - Invalid Entity name on line "
; 2364 :             fnIssueCoreError( lpTask, lpView, 16, 74, lpFileData->lLine,

	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchExtraData$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	74					; 0000004aH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2365 :                               pchExtraData, lpFileData->pchFileName );
; 2366 :             break;

	jmp	SHORT $LN2@fnReadData
$LN6@fnReadData:

; 2367 :          }
; 2368 : 
; 2369 :          case 75:
; 2370 :             // "KZOEE075 - Invalid Entity level on line "
; 2371 :             fnIssueCoreError( lpTask, lpView, 16, 75, lpFileData->lLine,

	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pchExtraData$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	75					; 0000004bH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2372 :                               pchExtraData, lpFileData->pchFileName );
; 2373 :             break;

	jmp	SHORT $LN2@fnReadData
$LN7@fnReadData:

; 2374 : 
; 2375 :          case 90:
; 2376 :             // "KZOEE090 - Maximum number of entites in portable file exceeded"
; 2377 :             fnIssueCoreError( lpTask, lpView, 16, 90, lpFileData->lLine,

	push	OFFSET $SG14172
	mov	edx, DWORD PTR _lpFileData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	90					; 0000005aH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2378 :                               lpFileData->pchFileName, "" );
; 2379 :             break;

	jmp	SHORT $LN2@fnReadData
$LN8@fnReadData:

; 2380 : 
; 2381 :          case 104:
; 2382 :             // "KZOEE104 - Invalid Attribute name for Entity"
; 2383 :             fnIssueCoreError( lpTask, lpView, 16, 104, 0, pchExtraData, 0 );

	push	0
	mov	edx, DWORD PTR _pchExtraData$1[ebp]
	push	edx
	push	0
	push	104					; 00000068H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN2@fnReadData:

; 2384 :             break;
; 2385 : 
; 2386 :       } // switch ( nErrorNbr )
; 2387 : 
; 2388 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnReadData
$LN4@fnReadData:

; 2389 : 
; 2390 :    } // if ( nErrorNbr )...
; 2391 : 
; 2392 :    lpFileData->lLine++;

	mov	edx, DWORD PTR _lpFileData$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2393 : 
; 2394 :    if ( uLth )

	cmp	DWORD PTR _uLth$[ebp], 0
	je	SHORT $LN9@fnReadData

; 2395 :       return( SysReadLineLth( lpView, ppchReturnBuffer, lpFileData->hFile, uLth ) );

	mov	edx, DWORD PTR _uLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFileData$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysReadLineLth@16
	jmp	SHORT $LN1@fnReadData
	jmp	SHORT $LN1@fnReadData
$LN9@fnReadData:

; 2396 :    else
; 2397 :       return( SysReadLine( lpView, ppchReturnBuffer, lpFileData->hFile ) );

	mov	ecx, DWORD PTR _lpFileData$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _ppchReturnBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysReadLine@12
$LN1@fnReadData:

; 2398 : 
; 2399 : } // fnReadDataFromFileStream

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	2
$LN13@fnReadData:
	DD	$LN5@fnReadData
	DD	$LN6@fnReadData
	DD	$LN7@fnReadData
	DD	$LN8@fnReadData
	DD	$LN2@fnReadData
$LN12@fnReadData:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
_fnReadDataFromFileStream@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_hDupRelParent$1 = -64					; size = 4
_lpViewOI$ = -60					; size = 4
_lpSearchViewEntity$2 = -56				; size = 4
_lpSourceInstance$3 = -52				; size = 4
_lpViewCsr$ = -48					; size = 4
_lpViewOD$ = -44					; size = 4
_lpDupEntityInstance$4 = -40				; size = 4
_lpRootInstance$ = -36					; size = 4
_lpSearchInstance$ = -32				; size = 4
_lpSourceEntity$5 = -28					; size = 4
_lpParentInstance$6 = -24				; size = 4
_lpSearchInstance$7 = -20				; size = 4
_lpEntityInstance$ = -16				; size = 4
_lpViewEntityCsr$8 = -12				; size = 4
_lpViewEntity$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_fnRelinkObjectInstance@4 PROC

; 1301 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 1302 :    LPVIEWENTITY      lpViewEntity;
; 1303 :    LPVIEWOD          lpViewOD;
; 1304 :    LPVIEWCSR         lpViewCsr;
; 1305 :    LPVIEWOI          lpViewOI;
; 1306 :    LPENTITYINSTANCE  lpRootInstance;
; 1307 :    LPENTITYINSTANCE  lpEntityInstance;
; 1308 :    LPENTITYINSTANCE  lpSearchInstance;
; 1309 :    zSHORT            nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1310 : 
; 1311 :    lpViewOD       = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1312 :    lpViewCsr      = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1313 :    lpViewOI       = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1314 :    lpRootInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootInstance$[ebp], eax

; 1315 : 
; 1316 :    if ( lpRootInstance == 0 )

	cmp	DWORD PTR _lpRootInstance$[ebp], 0
	jne	SHORT $LN17@fnRelinkOb

; 1317 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnRelinkOb
$LN17@fnRelinkOb:

; 1318 : 
; 1319 :    // If the object definition has view entities marked as
; 1320 :    // has dup instance, go through and attempt to relink them
; 1321 :    // together now
; 1322 :    if ( lpViewOD->bHasDupInstance )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	and	ecx, 1
	je	$LN18@fnRelinkOb

; 1323 :    {
; 1324 :       LPENTITYINSTANCE lpDupEntityInstance = 0;

	mov	DWORD PTR _lpDupEntityInstance$4[ebp], 0

; 1325 : 
; 1326 :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN19@fnRelinkOb

; 1327 :          nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN19@fnRelinkOb:

; 1328 : 
; 1329 :       // Look for EI's that are flagged as duplicate instances and link
; 1330 :       // together the same instances.  We will start looping with the first
; 1331 :       // EI and see if it is the same as any PREVIOUS EI's.  If we find a
; 1332 :       // match then they will be linked.
; 1333 :       for ( lpEntityInstance = lpRootInstance;

	mov	ecx, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN4@fnRelinkOb
$LN2@fnRelinkOb:

; 1335 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnRelinkOb:

; 1334 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN18@fnRelinkOb

; 1336 :       {
; 1337 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1338 : 
; 1339 :          // If this EI isn't a duplicate entity then skip it.
; 1340 :          if ( lpViewEntity->bDupInstance == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 25					; 00000019H
	and	ecx, 1
	jne	SHORT $LN20@fnRelinkOb

; 1341 :             continue;

	jmp	SHORT $LN2@fnRelinkOb
$LN20@fnRelinkOb:

; 1342 : 
; 1343 :          // To save some looping time we'll keep track of the first EI that
; 1344 :          // is flagged as a dup instance.
; 1345 :          if ( lpDupEntityInstance == 0 )

	cmp	DWORD PTR _lpDupEntityInstance$4[ebp], 0
	jne	SHORT $LN21@fnRelinkOb

; 1346 :             lpDupEntityInstance = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpDupEntityInstance$4[ebp], edx
$LN21@fnRelinkOb:

; 1347 : 
; 1348 :          // Now try to find the first EI that matches lpEntityInstance.  If
; 1349 :          // lpSearchInstance == lpEntityInstance then we've searched all the
; 1350 :          // previous EIs so we can stop looking.
; 1351 :          for ( lpSearchInstance = lpDupEntityInstance;

	mov	eax, DWORD PTR _lpDupEntityInstance$4[ebp]
	mov	DWORD PTR _lpSearchInstance$[ebp], eax
	jmp	SHORT $LN7@fnRelinkOb
$LN5@fnRelinkOb:

; 1353 :                lpSearchInstance = zGETPTR( lpSearchInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpSearchInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$[ebp], eax
$LN7@fnRelinkOb:

; 1352 :                lpSearchInstance != lpEntityInstance;

	mov	eax, DWORD PTR _lpSearchInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN6@fnRelinkOb

; 1354 :          {
; 1355 :             LPVIEWENTITY lpSearchViewEntity;
; 1356 : 
; 1357 :             lpSearchViewEntity = zGETPTR( lpSearchInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSearchInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntity$2[ebp], eax

; 1358 : 
; 1359 :             // If the entities are not the same ER entity then we can't link.
; 1360 :             if ( lpViewEntity->lEREntTok != lpSearchViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpSearchViewEntity$2[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN22@fnRelinkOb

; 1361 :                continue;

	jmp	SHORT $LN5@fnRelinkOb
$LN22@fnRelinkOb:

; 1362 : 
; 1363 :             // The search view entity must be flagged as duplicate instance.
; 1364 :             if ( lpSearchViewEntity->bDupInstance == FALSE )

	mov	eax, DWORD PTR _lpSearchViewEntity$2[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 25					; 00000019H
	and	ecx, 1
	jne	SHORT $LN23@fnRelinkOb

; 1365 :                continue;

	jmp	SHORT $LN5@fnRelinkOb
$LN23@fnRelinkOb:

; 1366 : 
; 1367 :             if ( !fnInstanceKeysMatch( lpEntityInstance, lpSearchInstance ) )

	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN24@fnRelinkOb

; 1368 :                continue;

	jmp	SHORT $LN5@fnRelinkOb
$LN24@fnRelinkOb:

; 1369 : 
; 1370 :             fnRelinkInstanceToInstance( lpEntityInstance, lpSearchInstance );

	mov	edx, DWORD PTR _lpSearchInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRelinkInstanceToInstance
	add	esp, 8

; 1371 : 
; 1372 :             // We found a match for the current lpEntityInstance so stop
; 1373 :             // looking for more matches.
; 1374 :             break;

	jmp	SHORT $LN6@fnRelinkOb

; 1375 : 
; 1376 :          } // for ( lpSearchInstance...)

	jmp	SHORT $LN5@fnRelinkOb
$LN6@fnRelinkOb:

; 1377 : 
; 1378 :       } // for ( lpEntityInstance...)

	jmp	$LN2@fnRelinkOb
$LN18@fnRelinkOb:

; 1379 : 
; 1380 :    } // if ( lpViewOD->bHasDupInstance )...
; 1381 : 
; 1382 :    // if the view object has duplicate relationships, try and
; 1383 :    // spawn any necessary includes to instantiate the relationships
; 1384 :    if ( lpViewOD->bHasDupRel )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 1
	and	edx, 1
	je	$LN25@fnRelinkOb

; 1385 :    {
; 1386 :       if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN26@fnRelinkOb

; 1387 :          nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN26@fnRelinkOb:

; 1388 : 
; 1389 :       // Loop through the view entities and look for entities that are
; 1390 :       // flagged as dup relationships.
; 1391 :       for ( lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN10@fnRelinkOb
$LN8@fnRelinkOb:

; 1393 :             lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN10@fnRelinkOb:

; 1392 :             lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$LN25@fnRelinkOb

; 1394 :       {
; 1395 :          LPVIEWENTITY      hDupRelParent;
; 1396 :          LPENTITYINSTANCE  lpParentInstance;
; 1397 : 
; 1398 :          if ( lpViewEntity->bDupRel == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 26					; 0000001aH
	and	ecx, 1
	jne	SHORT $LN27@fnRelinkOb

; 1399 :             continue;

	jmp	SHORT $LN8@fnRelinkOb
$LN27@fnRelinkOb:

; 1400 : 
; 1401 :          // Get the parent entity of the dup rel entity.  Then we will loop
; 1402 :          // through all the the EI's looking for instances of the parent.
; 1403 :          hDupRelParent = lpViewEntity->hParent;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	DWORD PTR _hDupRelParent$1[ebp], eax

; 1404 :          for ( lpParentInstance = lpRootInstance;

	mov	ecx, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpParentInstance$6[ebp], ecx
	jmp	SHORT $LN13@fnRelinkOb
$LN11@fnRelinkOb:

; 1406 :                lpParentInstance = zGETPTR( lpParentInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpParentInstance$6[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentInstance$6[ebp], eax
$LN13@fnRelinkOb:

; 1405 :                lpParentInstance;

	cmp	DWORD PTR _lpParentInstance$6[ebp], 0
	je	$LN12@fnRelinkOb

; 1407 :          {
; 1408 :             LPENTITYINSTANCE lpSearchInstance;
; 1409 :             LPENTITYINSTANCE lpSourceInstance;
; 1410 : 
; 1411 :             if ( lpParentInstance->hViewEntity != hDupRelParent )

	mov	ecx, DWORD PTR _lpParentInstance$6[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hDupRelParent$1[ebp]
	je	SHORT $LN28@fnRelinkOb

; 1412 :                continue;

	jmp	SHORT $LN11@fnRelinkOb
$LN28@fnRelinkOb:

; 1413 : 
; 1414 :             // We have found an an entity instance that is the parent of the
; 1415 :             // dup rel entity.  Now we have to check to see if we should
; 1416 :             // include another entity instance under the parent.  Look to
; 1417 :             // see if there is another EI in the OI who's relationship
; 1418 :             // matches the dup rel entity.
; 1419 :             for ( lpSearchInstance = lpRootInstance;

	mov	eax, DWORD PTR _lpRootInstance$[ebp]
	mov	DWORD PTR _lpSearchInstance$7[ebp], eax
	jmp	SHORT $LN16@fnRelinkOb
$LN14@fnRelinkOb:

; 1421 :                   lpSearchInstance = zGETPTR( lpSearchInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpSearchInstance$7[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchInstance$7[ebp], eax
$LN16@fnRelinkOb:

; 1420 :                   lpSearchInstance;

	cmp	DWORD PTR _lpSearchInstance$7[ebp], 0
	je	$LN15@fnRelinkOb

; 1422 :             {
; 1423 :                LPVIEWENTITY    lpSourceEntity;
; 1424 :                LPVIEWENTITYCSR lpViewEntityCsr;
; 1425 : 
; 1426 :                lpSourceEntity = zGETPTR( lpSearchInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSearchInstance$7[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntity$5[ebp], eax

; 1427 : 
; 1428 :                // If the relationship token of the source instance does not
; 1429 :                // match the token of the dup rel entity then try the next one.
; 1430 :                if ( lpSourceEntity->lERRelTok != lpViewEntity->lERRelTok )

	mov	edx, DWORD PTR _lpSourceEntity$5[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	je	SHORT $LN29@fnRelinkOb

; 1431 :                   continue;

	jmp	SHORT $LN14@fnRelinkOb
$LN29@fnRelinkOb:

; 1432 : 
; 1433 :                // Make sure the source entity is not derived or dup rel itself.
; 1434 :                if ( lpSourceEntity->bDerivedPath || lpSourceEntity->bDupRelPath )

	mov	edx, DWORD PTR _lpSourceEntity$5[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 14					; 0000000eH
	and	eax, 1
	jne	SHORT $LN31@fnRelinkOb
	mov	ecx, DWORD PTR _lpSourceEntity$5[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN30@fnRelinkOb
$LN31@fnRelinkOb:

; 1435 :                   continue;

	jmp	SHORT $LN14@fnRelinkOb
$LN30@fnRelinkOb:

; 1436 : 
; 1437 :                // Check to see if the relationship of the search instance is
; 1438 :                // the same or the inverse of lpViewEntity.
; 1439 :                if ( lpSourceEntity->lEREntTok == lpViewEntity->lEREntTok )

	mov	eax, DWORD PTR _lpSourceEntity$5[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	jne	SHORT $LN32@fnRelinkOb

; 1440 :                {
; 1441 :                   // If we get here then the following is an example of the
; 1442 :                   // situation:
; 1443 :                   //
; 1444 :                   //     (R)
; 1445 :                   //      |
; 1446 :                   //     (A)
; 1447 :                   //    /  \
; 1448 :                   //  (X)  (B)
; 1449 :                   //   |    |
; 1450 :                   //  (Y)  (X')
; 1451 :                   //        |
; 1452 :                   //       (Y')
; 1453 :                   //
; 1454 :                   // Y' is the dup rel entity (lpViewEntity) and X' is the
; 1455 :                   // parent (lpParent).  Y is the current lpSearchInstance and
; 1456 :                   // is the entity that we want to include under X'.  In this
; 1457 :                   // case we want to make sure that the values of the keys for
; 1458 :                   // X and X' are the same.
; 1459 :                   if ( !fnInstanceKeysMatch( lpParentInstance,

	mov	eax, DWORD PTR _lpSearchInstance$7[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpParentInstance$6[ebp]
	push	edx
	call	_fnInstanceKeysMatch
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN34@fnRelinkOb

; 1460 :                                              zGETPTR( lpSearchInstance->hParent ) ) )
; 1461 :                   {
; 1462 :                      // Keys don't match so it's not a candidate.  Try again
; 1463 :                      // with the next instance.
; 1464 :                      continue;

	jmp	$LN14@fnRelinkOb
$LN34@fnRelinkOb:

; 1465 :                   }
; 1466 : 
; 1467 :                   // Source for the include is Y (lpSearchInstance).
; 1468 :                   lpSourceInstance = lpSearchInstance;

	mov	ecx, DWORD PTR _lpSearchInstance$7[ebp]
	mov	DWORD PTR _lpSourceInstance$3[ebp], ecx

; 1469 :                }

	jmp	SHORT $LN33@fnRelinkOb
$LN32@fnRelinkOb:

; 1470 :                else
; 1471 :                {
; 1472 :                   // If we get here then the following is an example of the
; 1473 :                   // situation:
; 1474 :                   //
; 1475 :                   //                       (R)
; 1476 :                   //                        |
; 1477 :                   //                       (A)
; 1478 :                   //                      /  \
; 1479 :                   //  X and Y are  ==>  (Y)  (B)
; 1480 :                   //  inversed           |    |
; 1481 :                   //  from above   ==>  (X)  (X')
; 1482 :                   //                          |
; 1483 :                   //                         (Y')
; 1484 :                   //
; 1485 :                   // Y' is the dup rel entity (lpViewEntity) and X' is the
; 1486 :                   // parent (lpParent).  X is the current lpSearchInstance.
; 1487 :                   // The entity that we want to include under X' is the
; 1488 :                   // parent of X -- Y.  Make sure X and X' are the same.
; 1489 :                   if ( !fnInstanceKeysMatch( lpParentInstance,

	mov	edx, DWORD PTR _lpSearchInstance$7[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentInstance$6[ebp]
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN35@fnRelinkOb

; 1490 :                                              lpSearchInstance ) )
; 1491 :                   {
; 1492 :                      // Keys don't match so it's not a candidate.  Try again
; 1493 :                      // with the next instance.
; 1494 :                      continue;

	jmp	$LN14@fnRelinkOb
$LN35@fnRelinkOb:

; 1495 :                   }
; 1496 : 
; 1497 :                   // The source of the include is the parent of X.
; 1498 :                   lpSourceInstance = zGETPTR( lpSearchInstance->hParent );

	mov	edx, DWORD PTR _lpSearchInstance$7[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceInstance$3[ebp], eax

; 1499 :                   lpSourceEntity   = zGETPTR( lpSourceInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSourceInstance$3[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSourceEntity$5[ebp], eax
$LN33@fnRelinkOb:

; 1500 :                }
; 1501 : 
; 1502 :                // We have found a match!  First establish the cursor positions
; 1503 :                // to match our parent and source instances.
; 1504 :                lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8[ebp], eax

; 1505 :                lpViewEntityCsr += (lpViewEntity->nHierNbr - 1);

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpViewEntityCsr$8[ebp]
	mov	DWORD PTR _lpViewEntityCsr$8[ebp], ecx

; 1506 :                lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$8[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8[ebp], eax

; 1507 :                fnEstablishViewForInstance( lpView, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpParentInstance$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$8[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1508 :                                            lpParentInstance );
; 1509 : 
; 1510 :                lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$8[ebp], eax

; 1511 :                lpViewEntityCsr += (lpSourceEntity->nHierNbr - 1);

	mov	eax, DWORD PTR _lpSourceEntity$5[ebp]
	movsx	ecx, WORD PTR [eax+217]
	sub	ecx, 1
	imul	edx, ecx, 30
	add	edx, DWORD PTR _lpViewEntityCsr$8[ebp]
	mov	DWORD PTR _lpViewEntityCsr$8[ebp], edx

; 1512 :                fnEstablishViewForInstance( lpView, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpSourceInstance$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1513 :                                            lpSourceInstance );
; 1514 : 
; 1515 :                // Include the source instance to instantiate the dup rel entity.
; 1516 :                if ( fnIncludeSubobjectFromSubobject( lpView, lpViewEntity,
; 1517 :                                                      lpView, lpSourceEntity,
; 1518 :                                                      zPOS_FIRST, 0,
; 1519 :                                                      0 ) == zCALL_ERROR )

	push	0
	push	0
	push	1
	mov	eax, DWORD PTR _lpSourceEntity$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN36@fnRelinkOb

; 1520 :                {
; 1521 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnRelinkOb
$LN36@fnRelinkOb:

; 1522 :                }
; 1523 : 
; 1524 :                // We've found the source instance and included it so we're
; 1525 :                // done looking for a source instance to include so break.
; 1526 :                //break;
; 1527 : 
; 1528 :             } // for ( lpSearchInstance )...

	jmp	$LN14@fnRelinkOb
$LN15@fnRelinkOb:

; 1529 : 
; 1530 :          } // for ( lpParentInstance )...

	jmp	$LN11@fnRelinkOb
$LN12@fnRelinkOb:

; 1531 : 
; 1532 :       } // for ( lpViewEntity...)

	jmp	$LN8@fnRelinkOb
$LN25@fnRelinkOb:

; 1533 : 
; 1534 :    } // if ( lpViewOD->bHasDupRel )...
; 1535 : 
; 1536 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnRelinkOb:

; 1537 : 
; 1538 : } // fnRelinkObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	4
_fnRelinkObjectInstance@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_tViewArrayBlock$ = -160				; size = 64
_lpLockEntity$ = -96					; size = 4
_lpLockEntityCsr$ = -92					; size = 4
_vLock$ = -88						; size = 8
_lpViewOD$1 = -80					; size = 4
_lpViewCluster$ = -76					; size = 4
_lpEntityInstance$ = -72				; size = 4
_nRC$ = -68						; size = 2
_bArrayIsViewList$ = -61				; size = 1
_k$ = -60						; size = 2
_szLockName$ = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_lpArray$ = 12						; size = 4
_nViewCount$ = 16					; size = 2
_pnViewErrorIdx$ = 20					; size = 4
_vSubtask$ = 24						; size = 4
_fnDeletePessimisticSemaphore@20 PROC

; 1132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1133 :    ViewClusterRecord vLock;
; 1134 :    zCHAR             szLockName[ 50 ];
; 1135 :    LPVIEWENTITY      lpLockEntity;
; 1136 :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 1137 :    LPENTITYINSTANCE  lpEntityInstance;
; 1138 :    LPVIEWCLUSTER     lpViewCluster;
; 1139 :    VIEWARRAYBLOCK    tViewArrayBlock = {0};

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1140 :    zBOOL             bArrayIsViewList;
; 1141 :    zSHORT            k;
; 1142 :    zSHORT            nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 1143 : 
; 1144 :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 1145 :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 1146 : 
; 1147 :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $LN8@fnDeletePe

; 1148 :    {
; 1149 :       bArrayIsViewList = TRUE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 1

; 1150 :       lpViewCluster = (LPVIEWCLUSTER) lpArray;

	mov	edx, DWORD PTR _lpArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], edx

; 1151 : 
; 1152 :       // vSubtask is just the first valid view in the list.
; 1153 :       for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@fnDeletePe
$LN2@fnDeletePe:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@fnDeletePe:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN3@fnDeletePe

; 1154 :       {
; 1155 :          if ( lpViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $LN10@fnDeletePe

; 1156 :          {
; 1157 :             vSubtask = lpViewCluster[ k ].vOI;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 1158 :             break;

	jmp	SHORT $LN3@fnDeletePe
$LN10@fnDeletePe:

; 1159 :          }
; 1160 :       }

	jmp	SHORT $LN2@fnDeletePe
$LN3@fnDeletePe:

; 1161 :    }

	jmp	SHORT $LN9@fnDeletePe
$LN8@fnDeletePe:

; 1162 :    else
; 1163 :       bArrayIsViewList = FALSE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 0
$LN9@fnDeletePe:

; 1164 : 
; 1165 :    // Create an empty lock OI.
; 1166 :    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask, "ZPLOCKO", 0 ) != 0 )

	push	0
	push	OFFSET $SG13790
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDeclareView@20
	cwde
	test	eax, eax
	je	SHORT $LN11@fnDeletePe

; 1167 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDeletePe
$LN11@fnDeletePe:

; 1168 : 
; 1169 :    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN12@fnDeletePe

; 1170 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDeletePe
$LN12@fnDeletePe:

; 1171 : 
; 1172 :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN7@fnDeletePe
$LN5@fnDeletePe:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN7@fnDeletePe:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN6@fnDeletePe

; 1173 :    {
; 1174 :       LPVIEWOD lpViewOD;
; 1175 : 
; 1176 :       if ( bArrayIsViewList )

	movzx	edx, BYTE PTR _bArrayIsViewList$[ebp]
	test	edx, edx
	je	SHORT $LN13@fnDeletePe

; 1177 :       {
; 1178 :          if ( lpViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN15@fnDeletePe

; 1179 :             continue;

	jmp	SHORT $LN5@fnDeletePe
$LN15@fnDeletePe:

; 1180 : 
; 1181 :          // If we're keeping locks on this guy then skip him.
; 1182 :          if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN16@fnDeletePe

; 1183 :             continue;

	jmp	SHORT $LN5@fnDeletePe
$LN16@fnDeletePe:

; 1184 : 
; 1185 :          // Get ViewOD from view.
; 1186 :          lpViewOD = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 1187 :       }

	jmp	SHORT $LN14@fnDeletePe
$LN13@fnDeletePe:

; 1188 :       else
; 1189 :       {
; 1190 :          if ( lpArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN17@fnDeletePe

; 1191 :             continue;

	jmp	SHORT $LN5@fnDeletePe
$LN17@fnDeletePe:

; 1192 : 
; 1193 :          lpViewOD = (LPVIEWOD) lpArray[ k ];

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _lpViewOD$1[ebp], ecx
$LN14@fnDeletePe:

; 1194 :       }
; 1195 : 
; 1196 :       // If this ViewOD doesn't have any locking (which is possible if we're
; 1197 :       // committing a cluster) then we can skip it.
; 1198 :       if ( lpViewOD->nLock       < zLL_PESSIMISTIC &&

	mov	edx, DWORD PTR _lpViewOD$1[ebp]
	movzx	eax, BYTE PTR [edx+236]
	cmp	eax, 3
	jge	SHORT $LN18@fnDeletePe
	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	movzx	edx, BYTE PTR [ecx+237]
	cmp	edx, 3
	jge	SHORT $LN18@fnDeletePe

; 1199 :            lpViewOD->nEntityLock < zLL_PESSIMISTIC )
; 1200 :       {
; 1201 :          continue;

	jmp	$LN5@fnDeletePe
$LN18@fnDeletePe:

; 1202 :       }
; 1203 : 
; 1204 :       // Set lock name.  If OD does not have pessimistic locking at the entity
; 1205 :       // level then it's safe to lock out other users trying to lock the same
; 1206 :       // OD.  This allows us to use the entity name for the locking semaphore.
; 1207 :       // If the OD has entity locking we need to use a "global" entity locking
; 1208 :       // semaphore so that no one can lock entities at the same time.
; 1209 :       if ( lpViewOD->nEntityLock )

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	movzx	ecx, BYTE PTR [eax+237]
	test	ecx, ecx
	je	SHORT $LN19@fnDeletePe

; 1210 :       {
; 1211 :          // We are using entity level locking.
; 1212 :          zstrcpy( szLockName, "#Global Entity Lock" );

	push	OFFSET $SG13800
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1213 :       }

	jmp	SHORT $LN20@fnDeletePe
$LN19@fnDeletePe:

; 1214 :       else
; 1215 :       {
; 1216 :          // We are not using entity level locking so we can just lock out other
; 1217 :          // users using the same LOD.  We prefix the name with a '#' to to
; 1218 :          // indicate that this is the locking semaphore.
; 1219 :          zsprintf( szLockName, "#%s", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG13801
	lea	ecx, DWORD PTR _szLockName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN20@fnDeletePe:

; 1220 :       }
; 1221 : 
; 1222 :       // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 1223 :       lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock.vOI,

	push	0
	push	OFFSET $SG13802
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 1224 :                                         "ZeidonLock", 0 );
; 1225 : 
; 1226 :       if ( fnCreateEntity( vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1227 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLockEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCreateEntity@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN21@fnDeletePe

; 1228 :       {
; 1229 :          goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN21@fnDeletePe:

; 1230 :       }
; 1231 : 
; 1232 :       // Set entity name and key string (which is just a description).
; 1233 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 1234 :                                    vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1235 :                                    szLockName, "Locking semaphore",
; 1236 :                                    0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	push	OFFSET $SG13805
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSetLockingAttributes@36
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN22@fnDeletePe

; 1237 :       {
; 1238 :          goto EndOfFunction;

	jmp	$EndOfFunction$28
$LN22@fnDeletePe:

; 1239 :       }
; 1240 : 
; 1241 :       // Here's where we cheat -- turn off Create flag and turn on the
; 1242 :       // Delete/Hidden flags so that when we commit the OI the locking
; 1243 :       // records will be deleted.
; 1244 :       lpEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1245 :       lpEntityInstance->u.nInd.bCreated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 1246 :       lpEntityInstance->u.nInd.bDeleted = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 8
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 1247 :       lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 1248 :    }

	jmp	$LN5@fnDeletePe
$LN6@fnDeletePe:

; 1249 : 
; 1250 :    // Set flag indicating that current task no longer has a locking semaphore.
; 1251 :    lpCurrentTask->bPessimisticLockingSet = FALSE;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	and	edx, -257				; fffffeffH
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 1252 : 
; 1253 :    // Now commit the lock OI.  This should release the semaphore lock.
; 1254 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN23@fnDeletePe

; 1255 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$28
$LN23@fnDeletePe:

; 1256 : 
; 1257 :    if ( fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0, lpCurrentTask,
; 1258 :                                 0, &tViewArrayBlock ) != 0 )

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	1
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	lea	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnCommitObjectInstance@28
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN24@fnDeletePe

; 1259 :    {
; 1260 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$28
$LN24@fnDeletePe:

; 1261 :    }
; 1262 : 
; 1263 :    // If we get here everything's OK.
; 1264 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$EndOfFunction$28:

; 1265 : 
; 1266 : EndOfFunction:
; 1267 :    zUNLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysUnlockCoreMutex@4

; 1268 : 
; 1269 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $LN25@fnDeletePe

; 1270 :       fnDropView( vLock.vOI );

	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_fnDropView@4
$LN25@fnDeletePe:

; 1271 : 
; 1272 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 1273 : 
; 1274 :    if ( nRC == zCALL_ERROR && pnViewErrorIdx )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN26@fnDeletePe
	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN26@fnDeletePe

; 1275 :       *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$LN26@fnDeletePe:

; 1276 : 
; 1277 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnDeletePe:

; 1278 : 
; 1279 : } // fnDeletePessimisticSemaphore

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnDeletePessimisticSemaphore@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_tViewArrayBlock$ = -164				; size = 64
_lpLockEntity$ = -100					; size = 4
_lpEntityInstance$ = -96				; size = 4
_lpLockEntityCsr$ = -92					; size = 4
_vLock$ = -88						; size = 8
_lpViewOD$1 = -80					; size = 4
_lpViewCluster$ = -76					; size = 4
_nCommit$ = -72						; size = 2
_nRC$ = -68						; size = 2
_bMutexLocked$ = -64					; size = 1
_bCreateSemaphore$ = -63				; size = 1
_bGlobalLockCreated$ = -62				; size = 1
_bArrayIsViewList$ = -61				; size = 1
_k$ = -60						; size = 2
_szLockName$ = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_lpArray$ = 12						; size = 4
_nViewCount$ = 16					; size = 2
_pnViewErrorIdx$ = 20					; size = 4
_vSubtask$ = 24						; size = 4
_fnCreatePessimisticSemaphore@20 PROC

; 924  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 925  :    ViewClusterRecord vLock;
; 926  :    LPVIEWENTITY      lpLockEntity;
; 927  :    LPVIEWENTITYCSR   lpLockEntityCsr;
; 928  :    LPENTITYINSTANCE  lpEntityInstance;
; 929  :    LPVIEWCLUSTER     lpViewCluster;
; 930  :    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 931  :    zCHAR             szLockName[ 50 ];
; 932  :    zBOOL             bGlobalLockCreated = FALSE;

	mov	BYTE PTR _bGlobalLockCreated$[ebp], 0

; 933  :    zBOOL             bArrayIsViewList;
; 934  :    zBOOL             bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0

; 935  :    zBOOL             bCreateSemaphore;
; 936  :    zSHORT            nCommit;
; 937  :    zSHORT            k;
; 938  :    zSHORT            nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 939  : 
; 940  :    vLock.vOI = 0;

	mov	DWORD PTR _vLock$[ebp], 0

; 941  :    vLock.lControl = 0;

	mov	DWORD PTR _vLock$[ebp+4], 0

; 942  : 
; 943  :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $LN11@fnCreatePe

; 944  :    {
; 945  :       bArrayIsViewList = TRUE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 1

; 946  :       lpViewCluster = (LPVIEWCLUSTER) lpArray;

	mov	edx, DWORD PTR _lpArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], edx

; 947  : 
; 948  :       // vSubtask is just the first valid view in the list.
; 949  :       for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@fnCreatePe
$LN2@fnCreatePe:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@fnCreatePe:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN3@fnCreatePe

; 950  :       {
; 951  :          if ( lpViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $LN13@fnCreatePe

; 952  :          {
; 953  :             vSubtask = lpViewCluster[ k ].vOI;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 954  :             break;

	jmp	SHORT $LN3@fnCreatePe
$LN13@fnCreatePe:

; 955  :          }
; 956  :       }

	jmp	SHORT $LN2@fnCreatePe
$LN3@fnCreatePe:

; 957  :    }

	jmp	SHORT $LN12@fnCreatePe
$LN11@fnCreatePe:

; 958  :    else
; 959  :       bArrayIsViewList = FALSE;

	mov	BYTE PTR _bArrayIsViewList$[ebp], 0
$LN12@fnCreatePe:

; 960  : 
; 961  :    // Create an empty lock OI.
; 962  :    if ( fnDeclareView( &vLock.vOI, lpCurrentTask, vSubtask, "ZPLOCKO", 0 ) != 0 )

	push	0
	push	OFFSET $SG13721
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDeclareView@20
	cwde
	test	eax, eax
	je	SHORT $LN14@fnCreatePe

; 963  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreatePe
$LN14@fnCreatePe:

; 964  : 
; 965  :    if ( fnActivateEmptyObjectInstance( lpCurrentTask, vLock.vOI, zMULTIPLE ) != 0 )

	push	256					; 00000100H
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN15@fnCreatePe

; 966  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCreatePe
$LN15@fnCreatePe:

; 967  : 
; 968  :    // It's possible that the user wants to keep the locks for all the views.
; 969  :    // Following flag is TRUE if there is a least one lock.
; 970  :    bCreateSemaphore = FALSE;

	mov	BYTE PTR _bCreateSemaphore$[ebp], 0

; 971  : 
; 972  :    // Loop through all the views and set a lock.
; 973  :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN7@fnCreatePe
$LN5@fnCreatePe:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN7@fnCreatePe:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN6@fnCreatePe

; 974  :    {
; 975  :       LPVIEWOD lpViewOD;
; 976  : 
; 977  :       if ( bArrayIsViewList )

	movzx	edx, BYTE PTR _bArrayIsViewList$[ebp]
	test	edx, edx
	je	SHORT $LN16@fnCreatePe

; 978  :       {
; 979  :          if ( lpViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN18@fnCreatePe

; 980  :             continue;

	jmp	SHORT $LN5@fnCreatePe
$LN18@fnCreatePe:

; 981  : 
; 982  :          // If we're keeping locks on this guy then skip him.
; 983  :          if ( lpViewCluster[ k ].lControl & zCOMMIT_KEEPLOCKS )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 4096				; 00001000H
	je	SHORT $LN19@fnCreatePe

; 984  :             continue;

	jmp	SHORT $LN5@fnCreatePe
$LN19@fnCreatePe:

; 985  : 
; 986  :          // Get ViewOD from view.
; 987  :          lpViewOD = zGETPTR( lpViewCluster[ k ].vOI->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 988  :       }

	jmp	SHORT $LN17@fnCreatePe
$LN16@fnCreatePe:

; 989  :       else
; 990  :       {
; 991  :          if ( lpArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN20@fnCreatePe

; 992  :             continue;

	jmp	SHORT $LN5@fnCreatePe
$LN20@fnCreatePe:

; 993  : 
; 994  :          lpViewOD = (LPVIEWOD) lpArray[ k ];

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _lpViewOD$1[ebp], ecx
$LN17@fnCreatePe:

; 995  :       }
; 996  : 
; 997  :       // If this ViewOD doesn't have any locking (which is possible if we're
; 998  :       // committing a cluster) then we can skip it.
; 999  :       if ( lpViewOD->nLock       < zLL_PESSIMISTIC &&

	mov	edx, DWORD PTR _lpViewOD$1[ebp]
	movzx	eax, BYTE PTR [edx+236]
	cmp	eax, 3
	jge	SHORT $LN21@fnCreatePe
	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	movzx	edx, BYTE PTR [ecx+237]
	cmp	edx, 3
	jge	SHORT $LN21@fnCreatePe

; 1000 :            lpViewOD->nEntityLock < zLL_PESSIMISTIC )
; 1001 :       {
; 1002 :          continue;

	jmp	$LN5@fnCreatePe
$LN21@fnCreatePe:

; 1003 :       }
; 1004 : 
; 1005 :       bCreateSemaphore = TRUE;

	mov	BYTE PTR _bCreateSemaphore$[ebp], 1

; 1006 : 
; 1007 :       // Set lock name.  If OD does not have pessimistic locking at the entity
; 1008 :       // level then it's safe to lock out other users trying to lock the same
; 1009 :       // OD.  This allows us to use the entity name for the locking semaphore.
; 1010 :       // If the OD has entity locking we need to use a "global" entity locking
; 1011 :       // semaphore so that no one can lock entities at the same time.
; 1012 :       if ( lpViewOD->nEntityLock )

	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	movzx	ecx, BYTE PTR [eax+237]
	test	ecx, ecx
	je	SHORT $LN22@fnCreatePe

; 1013 :       {
; 1014 :          // If we've already created the global lock entity just continue.
; 1015 :          if ( bGlobalLockCreated )

	movzx	edx, BYTE PTR _bGlobalLockCreated$[ebp]
	test	edx, edx
	je	SHORT $LN24@fnCreatePe

; 1016 :             continue;

	jmp	$LN5@fnCreatePe
$LN24@fnCreatePe:

; 1017 : 
; 1018 :          bGlobalLockCreated = TRUE;

	mov	BYTE PTR _bGlobalLockCreated$[ebp], 1

; 1019 : 
; 1020 :          // We are using entity level locking.
; 1021 :          zstrcpy( szLockName, "#Global Entity Lock" );

	push	OFFSET $SG13732
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1022 :       }

	jmp	SHORT $LN23@fnCreatePe
$LN22@fnCreatePe:

; 1023 :       else
; 1024 :          // We are not using entity level locking so we can just lock out other
; 1025 :          // users using the same LOD.  We prefix the name with a '#' to to
; 1026 :          // indicate that this is the locking semaphore.
; 1027 :          zsprintf( szLockName, "#%s", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG13733
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN23@fnCreatePe:

; 1028 : 
; 1029 :       // Check to make sure we're not already setting the lock for this type.
; 1030 :       if ( SetCursorFirstEntityByString( vLock.vOI, "ZeidonLock", "LOD_Name",
; 1031 :                                          szLockName, 0 ) >= zCURSOR_SET )

	push	0
	lea	eax, DWORD PTR _szLockName$[ebp]
	push	eax
	push	OFFSET $SG13735
	push	OFFSET $SG13736
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	movsx	edx, ax
	test	edx, edx
	jl	SHORT $LN25@fnCreatePe

; 1032 :       {
; 1033 :          continue;

	jmp	$LN5@fnCreatePe
$LN25@fnCreatePe:

; 1034 :       }
; 1035 : 
; 1036 :       // Get the lpViewEntity and lpLockEntityCsr for the lock OI.
; 1037 :       lpLockEntity = fnValidViewEntity( &lpLockEntityCsr, vLock.vOI,

	push	0
	push	OFFSET $SG13737
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpLockEntity$[ebp], eax

; 1038 :                                         "ZeidonLock", 0 );
; 1039 : 
; 1040 :       if ( fnCreateEntity( vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1041 :                            zPOS_LAST, FALSE ) != 0 )

	push	0
	push	2
	mov	edx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnCreateEntity@20
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN26@fnCreatePe

; 1042 :       {
; 1043 :          goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN26@fnCreatePe:

; 1044 :       }
; 1045 : 
; 1046 :       // fnCreateEntity DOES NOT set the bCreated flag so set it.
; 1047 :       lpEntityInstance = zGETPTR( lpLockEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1048 :       lpEntityInstance->u.nInd.bCreated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 1049 : 
; 1050 :       // Set entity name and key string (which is just a description).
; 1051 :       if ( fnSetLockingAttributes( lpCurrentTask,
; 1052 :                                    vLock.vOI, lpLockEntity, lpLockEntityCsr,
; 1053 :                                    szLockName, "Locking semaphore",
; 1054 :                                    TRUE, TRUE, "N" ) != 0 )

	push	OFFSET $SG13740
	push	1
	push	1
	push	OFFSET $SG13741
	lea	edx, DWORD PTR _szLockName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSetLockingAttributes@36
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN27@fnCreatePe

; 1055 :          goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN27@fnCreatePe:

; 1056 : 
; 1057 :    } // for ( k... )...

	jmp	$LN5@fnCreatePe
$LN6@fnCreatePe:

; 1058 : 
; 1059 :    // If we didn't find any views that needed to drop their locks then get out.
; 1060 :    if ( bCreateSemaphore == FALSE )

	movzx	edx, BYTE PTR _bCreateSemaphore$[ebp]
	test	edx, edx
	jne	SHORT $LN28@fnCreatePe

; 1061 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnCreatePe
$LN28@fnCreatePe:

; 1062 : 
; 1063 :    // Now lock the pessimistic semaphore.  This will hopefully single-thread
; 1064 :    // creation of the semaphore.  It doesn't really do anything if we are
; 1065 :    // running as simple client-server.
; 1066 :    zLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysLockCoreMutex@4

; 1067 :    bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 1068 : 
; 1069 :    // Now commit the lock OI.  This should set the semaphore lock.  We'll try
; 1070 :    // a few times before giving up.
; 1071 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, 1 ) != 0 )

	push	1
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN29@fnCreatePe

; 1072 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN29@fnCreatePe:

; 1073 : 
; 1074 :    for ( k = 0; k < 10; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN10@fnCreatePe
$LN8@fnCreatePe:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN10@fnCreatePe:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 10					; 0000000aH
	jge	SHORT $LN9@fnCreatePe

; 1075 :    {
; 1076 :       // Try committing the semaphore.  If the return code indicates that
; 1077 :       // we have a duplicate root then somebody else is working with the
; 1078 :       // lock object so try again.
; 1079 :       nCommit = fnCommitObjectInstance( &vLock, &vLock.vOI, 1, 0,

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	mov	WORD PTR _nCommit$[ebp], ax

; 1080 :                                         lpCurrentTask, 0, &tViewArrayBlock );
; 1081 :       if ( nCommit == 0 )

	movsx	eax, WORD PTR _nCommit$[ebp]
	test	eax, eax
	jne	SHORT $LN30@fnCreatePe

; 1082 :          break;               // Everything OK.

	jmp	SHORT $LN9@fnCreatePe
$LN30@fnCreatePe:

; 1083 : 
; 1084 :       if ( nCommit == zDUPLICATE_ROOT )

	movsx	ecx, WORD PTR _nCommit$[ebp]
	cmp	ecx, -4					; fffffffcH
	jne	SHORT $LN31@fnCreatePe

; 1085 :       {
; 1086 :          SysWait( 1000 );     // Wait a second.

	push	1000					; 000003e8H
	call	_SysWait@4

; 1087 :          continue;            // Try again.

	jmp	SHORT $LN8@fnCreatePe
$LN31@fnCreatePe:

; 1088 :       }
; 1089 : 
; 1090 :       // Oops--there must be something wrong.  Get out.
; 1091 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$37

; 1092 :    }

	jmp	SHORT $LN8@fnCreatePe
$LN9@fnCreatePe:

; 1093 : 
; 1094 :    // If nCommit isn't 0 then we had problems trying to write the semaphore
; 1095 :    // record.  Show error and get out.
; 1096 :    if ( nCommit )

	movsx	edx, WORD PTR _nCommit$[ebp]
	test	edx, edx
	je	SHORT $LN32@fnCreatePe

; 1097 :    {
; 1098 :       fnSysMessageBox( lpCurrentTask, szlOE_SystemError,

	push	1
	push	OFFSET $SG13747
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 1099 :                        "Waited too long to write pessimistic lock semaphore", 1 );
; 1100 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$37
$LN32@fnCreatePe:

; 1101 :    }
; 1102 : 
; 1103 :    // Set flag indicating that current task has written locking semaphore.
; 1104 :    lpCurrentTask->bPessimisticLockingSet = TRUE;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 1105 : 
; 1106 :    // If we get here everything's OK.
; 1107 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$EndOfFunction$37:

; 1108 : 
; 1109 : EndOfFunction:
; 1110 :    // If something went wrong then unlock the mutex.
; 1111 :    if ( nRC && bMutexLocked )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN33@fnCreatePe
	movzx	ecx, BYTE PTR _bMutexLocked$[ebp]
	test	ecx, ecx
	je	SHORT $LN33@fnCreatePe

; 1112 :       zUNLOCK_MUTEX( zMUTEX_PESSIMISTICLOCK );

	push	9
	call	_fnSysUnlockCoreMutex@4
$LN33@fnCreatePe:

; 1113 : 
; 1114 :    if ( vLock.vOI )

	cmp	DWORD PTR _vLock$[ebp], 0
	je	SHORT $LN34@fnCreatePe

; 1115 :       fnDropView( vLock.vOI );

	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnDropView@4
$LN34@fnCreatePe:

; 1116 : 
; 1117 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 1118 : 
; 1119 :    if ( nRC == zCALL_ERROR && pnViewErrorIdx )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN35@fnCreatePe
	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN35@fnCreatePe

; 1120 :       *pnViewErrorIdx = k;

	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR [edx], ax
$LN35@fnCreatePe:

; 1121 : 
; 1122 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnCreatePe:

; 1123 : 
; 1124 : } // fnCreatePessimisticSemaphore

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnCreatePessimisticSemaphore@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
tv244 = -148						; size = 4
tv243 = -144						; size = 4
tv212 = -140						; size = 4
tv211 = -136						; size = 4
tv178 = -132						; size = 4
tv177 = -128						; size = 4
tv149 = -124						; size = 4
tv148 = -120						; size = 4
tv87 = -116						; size = 4
tv86 = -112						; size = 4
_lpViewAttrib$ = -108					; size = 4
_nCnt$ = -104						; size = 2
_szPassword$1 = -100					; size = 30
_szDateTime$2 = -68					; size = 30
_szUserName$3 = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_vLock$ = 12						; size = 4
_lpLockEntity$ = 16					; size = 4
_lpLockEntityCsr$ = 20					; size = 4
_pchLOD_Name$ = 24					; size = 4
_pchKeyString$ = 28					; size = 4
_bSetUserName$ = 32					; size = 1
_bSetTimestamp$ = 36					; size = 1
_pchAllowRead$ = 40					; size = 4
_fnSetLockingAttributes@36 PROC

; 812  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 148				; 00000094H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 813  :    LPVIEWATTRIB lpViewAttrib;
; 814  :    zSHORT       nCnt = 0;

	xor	eax, eax
	mov	WORD PTR _nCnt$[ebp], ax

; 815  : 
; 816  :    // Loop through each of the attributes in the lock OI.  When we find
; 817  :    // one we want set it.  To keep us from looping unnecessarily we keep
; 818  :    // track of the # of attributes we set.  When we get to 5 we're done.
; 819  :    for ( lpViewAttrib = zGETPTR( lpLockEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpLockEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnSetLocki
$LN2@fnSetLocki:

; 821  :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnSetLocki:

; 820  :          lpViewAttrib && nCnt < 5;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnSetLocki
	movsx	edx, WORD PTR _nCnt$[ebp]
	cmp	edx, 5
	jge	$LN3@fnSetLocki

; 822  :    {
; 823  :       if ( zstrcmp( lpViewAttrib->szName, "LOD_Name" ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR $SG13646
	cmp	ecx, edx
	jne	SHORT $LN24@fnSetLocki
	push	OFFSET $SG13647
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN25@fnSetLocki
$LN24@fnSetLocki:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR $SG13648
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN22@fnSetLocki
	mov	DWORD PTR tv86[ebp], 1
	jmp	SHORT $LN23@fnSetLocki
$LN22@fnSetLocki:
	mov	DWORD PTR tv86[ebp], -1
$LN23@fnSetLocki:
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv87[ebp], ecx
$LN25@fnSetLocki:
	cmp	DWORD PTR tv87[ebp], 0
	jne	SHORT $LN5@fnSetLocki

; 824  :       {
; 825  :          nCnt++;

	mov	dx, WORD PTR _nCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nCnt$[ebp], dx

; 826  : 
; 827  :          if ( pchLOD_Name &&

	cmp	DWORD PTR _pchLOD_Name$[ebp], 0
	je	SHORT $LN7@fnSetLocki
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _pchLOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN7@fnSetLocki

; 828  :               fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 829  :                                           lpViewAttrib,
; 830  :                                           (zPVOID) pchLOD_Name, 'S', 0, 0,
; 831  :                                           lpCurrentTask, 0 ) != 0 )
; 832  :          {
; 833  :             return( zCALL_ERROR ); // error setting attribute

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetLocki
$LN7@fnSetLocki:

; 834  :          }
; 835  :       }

	jmp	$LN6@fnSetLocki
$LN5@fnSetLocki:

; 836  :       else
; 837  :       if ( zstrcmp( lpViewAttrib->szName, "KeyValue" ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR $SG13652
	cmp	ecx, edx
	jne	SHORT $LN28@fnSetLocki
	push	OFFSET $SG13653
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN29@fnSetLocki
$LN28@fnSetLocki:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR $SG13654
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN26@fnSetLocki
	mov	DWORD PTR tv148[ebp], 1
	jmp	SHORT $LN27@fnSetLocki
$LN26@fnSetLocki:
	mov	DWORD PTR tv148[ebp], -1
$LN27@fnSetLocki:
	mov	ecx, DWORD PTR tv148[ebp]
	mov	DWORD PTR tv149[ebp], ecx
$LN29@fnSetLocki:
	cmp	DWORD PTR tv149[ebp], 0
	jne	SHORT $LN8@fnSetLocki

; 838  :       {
; 839  :          nCnt++;

	mov	dx, WORD PTR _nCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nCnt$[ebp], dx

; 840  : 
; 841  :          if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 842  :                                           lpViewAttrib,
; 843  :                                           (zPVOID) pchKeyString, 'S',
; 844  :                                           0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _pchKeyString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN10@fnSetLocki

; 845  :          {
; 846  :             return( zCALL_ERROR ); // error setting attribute

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetLocki
$LN10@fnSetLocki:

; 847  :          }
; 848  :       }

	jmp	$LN6@fnSetLocki
$LN8@fnSetLocki:

; 849  :       else
; 850  :       if ( zstrcmp( lpViewAttrib->szName, "UserName" ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR $SG13658
	cmp	ecx, edx
	jne	SHORT $LN32@fnSetLocki
	push	OFFSET $SG13659
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv178[ebp], eax
	jmp	SHORT $LN33@fnSetLocki
$LN32@fnSetLocki:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR $SG13660
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN30@fnSetLocki
	mov	DWORD PTR tv177[ebp], 1
	jmp	SHORT $LN31@fnSetLocki
$LN30@fnSetLocki:
	mov	DWORD PTR tv177[ebp], -1
$LN31@fnSetLocki:
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR tv178[ebp], ecx
$LN33@fnSetLocki:
	cmp	DWORD PTR tv178[ebp], 0
	jne	SHORT $LN11@fnSetLocki

; 851  :       {
; 852  :          nCnt++;

	mov	dx, WORD PTR _nCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nCnt$[ebp], dx

; 853  : 
; 854  :          if ( bSetUserName )

	movzx	eax, BYTE PTR _bSetUserName$[ebp]
	test	eax, eax
	je	SHORT $LN13@fnSetLocki

; 855  :          {
; 856  :             zCHAR szUserName[ 30 ];
; 857  :             zCHAR szPassword[ 30 ];
; 858  : 
; 859  :             SysGetUserID( vLock, szUserName, szPassword );

	lea	ecx, DWORD PTR _szPassword$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _szUserName$3[ebp]
	push	edx
	mov	eax, DWORD PTR _vLock$[ebp]
	push	eax
	call	_SysGetUserID@12

; 860  :             if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 861  :                                              lpViewAttrib,
; 862  :                                              (zPVOID) szUserName, 'S',
; 863  :                                              0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	push	0
	push	83					; 00000053H
	lea	edx, DWORD PTR _szUserName$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpLockEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vLock$[ebp]
	push	edx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	cwde
	test	eax, eax
	je	SHORT $LN13@fnSetLocki

; 864  :             {
; 865  :                return( zCALL_ERROR ); // error setting attribute

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetLocki
$LN13@fnSetLocki:

; 866  :             }
; 867  :          }
; 868  :       }

	jmp	$LN6@fnSetLocki
$LN11@fnSetLocki:

; 869  :       else
; 870  :       if ( zstrcmp( lpViewAttrib->szName, "Timestamp" ) == 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR $SG13665
	cmp	edx, eax
	jne	SHORT $LN36@fnSetLocki
	push	OFFSET $SG13666
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv212[ebp], eax
	jmp	SHORT $LN37@fnSetLocki
$LN36@fnSetLocki:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	movsx	ecx, BYTE PTR $SG13667
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN34@fnSetLocki
	mov	DWORD PTR tv211[ebp], 1
	jmp	SHORT $LN35@fnSetLocki
$LN34@fnSetLocki:
	mov	DWORD PTR tv211[ebp], -1
$LN35@fnSetLocki:
	mov	edx, DWORD PTR tv211[ebp]
	mov	DWORD PTR tv212[ebp], edx
$LN37@fnSetLocki:
	cmp	DWORD PTR tv212[ebp], 0
	jne	SHORT $LN15@fnSetLocki

; 871  :       {
; 872  :          nCnt++;

	mov	ax, WORD PTR _nCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nCnt$[ebp], ax

; 873  : 
; 874  :          if ( bSetTimestamp )

	movzx	ecx, BYTE PTR _bSetTimestamp$[ebp]
	test	ecx, ecx
	je	SHORT $LN17@fnSetLocki

; 875  :          {
; 876  :             zCHAR szDateTime[ 30 ];
; 877  : 
; 878  :             SysGetDateTime( szDateTime );

	lea	edx, DWORD PTR _szDateTime$2[ebp]
	push	edx
	call	_SysGetDateTime@4

; 879  :             if ( fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 880  :                                              lpViewAttrib,
; 881  :                                              (zPVOID) szDateTime, 'S',
; 882  :                                              0, 0, lpCurrentTask, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	lea	ecx, DWORD PTR _szDateTime$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN17@fnSetLocki

; 883  :             {
; 884  :                return( zCALL_ERROR ); // error setting attribute

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetLocki
$LN17@fnSetLocki:

; 885  :             }
; 886  :          }
; 887  :       }

	jmp	$LN6@fnSetLocki
$LN15@fnSetLocki:

; 888  :       else
; 889  :       if ( zstrcmp( lpViewAttrib->szName, "AllowRead" ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR $SG13671
	cmp	ecx, edx
	jne	SHORT $LN40@fnSetLocki
	push	OFFSET $SG13672
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv244[ebp], eax
	jmp	SHORT $LN41@fnSetLocki
$LN40@fnSetLocki:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR $SG13673
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN38@fnSetLocki
	mov	DWORD PTR tv243[ebp], 1
	jmp	SHORT $LN39@fnSetLocki
$LN38@fnSetLocki:
	mov	DWORD PTR tv243[ebp], -1
$LN39@fnSetLocki:
	mov	ecx, DWORD PTR tv243[ebp]
	mov	DWORD PTR tv244[ebp], ecx
$LN41@fnSetLocki:
	cmp	DWORD PTR tv244[ebp], 0
	jne	SHORT $LN6@fnSetLocki

; 890  :       {
; 891  :          nCnt++;

	mov	dx, WORD PTR _nCnt$[ebp]
	add	dx, 1
	mov	WORD PTR _nCnt$[ebp], dx

; 892  : 
; 893  :          if ( pchAllowRead &&

	cmp	DWORD PTR _pchAllowRead$[ebp], 0
	je	SHORT $LN6@fnSetLocki
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	push	0
	push	83					; 00000053H
	mov	ecx, DWORD PTR _pchAllowRead$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLockEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vLock$[ebp]
	push	ecx
	call	_fnSetAttributeFromVariable
	add	esp, 36					; 00000024H
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN6@fnSetLocki

; 894  :               fnSetAttributeFromVariable( vLock, lpLockEntityCsr,
; 895  :                                           lpViewAttrib,
; 896  :                                           (zPVOID) pchAllowRead, 'S',
; 897  :                                           0, 0, lpCurrentTask, 0 ) != 0 )
; 898  :          {
; 899  :             return( zCALL_ERROR ); // error setting attribute

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSetLocki
$LN6@fnSetLocki:

; 900  :          }
; 901  :       }
; 902  : 
; 903  :    } // for each lpViewAttrib...

	jmp	$LN2@fnSetLocki
$LN3@fnSetLocki:

; 904  : 
; 905  :    return( 0 );

	xor	eax, eax
$LN1@fnSetLocki:

; 906  : 
; 907  : } // fnSetLockingAttributes

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
_fnSetLockingAttributes@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchSourceAttributeName$1 = -40				; size = 4
_lpViewEntity$2 = -36					; size = 4
_pchOper$3 = -32					; size = 4
_vTemp$4 = -28						; size = 4
_pchSourceViewName$5 = -24				; size = 4
_pchSourceEntityName$6 = -20				; size = 4
_vSourceView$7 = -16					; size = 4
_lpViewAttrib$8 = -12					; size = 4
_nRC$ = -8						; size = 2
_bFirstKey$9 = -1					; size = 1
_vView$ = 8						; size = 4
_pchQualEntity$ = 12					; size = 4
_fnResolveQualOI PROC

; 688  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 689  :    zSHORT nRC;
; 690  : 
; 691  :    for ( nRC = SetCursorFirstEntity( vView, "EntitySpec", 0 );

	push	0
	push	OFFSET $SG13543
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@fnResolveQ
$LN2@fnResolveQ:

; 693  :          nRC = SetCursorNextEntity( vView, "EntitySpec", 0 ) )

	push	0
	push	OFFSET $SG13544
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@fnResolveQ:

; 692  :          nRC == zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN1@fnResolveQ

; 694  :    {
; 695  :       for ( nRC = SetCursorFirstEntity( vView, pchQualEntity, "EntitySpec" );

	push	OFFSET $SG13545
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN7@fnResolveQ
$LN5@fnResolveQ:

; 697  :             nRC = SetCursorNextEntity( vView, pchQualEntity, "EntitySpec" ) )

	push	OFFSET $SG13546
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN7@fnResolveQ:

; 696  :             nRC == zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN6@fnResolveQ

; 698  :       {
; 699  :          zVIEW  vSourceView;
; 700  :          zPCHAR pchSourceViewName;
; 701  :          zPCHAR pchSourceEntityName;
; 702  :          zPCHAR pchSourceAttributeName;
; 703  :          zPCHAR pchOper;
; 704  : 
; 705  :          // See if QualAttrib references another view.
; 706  :          GetAddrForAttribute( &pchSourceViewName, vView, pchQualEntity,

	push	OFFSET $SG13547
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchSourceViewName$5[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 707  :                               "SourceViewName" );
; 708  :          if ( *pchSourceViewName )

	mov	edx, DWORD PTR _pchSourceViewName$5[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN11@fnResolveQ

; 709  :             GetViewByName( &vSourceView, pchSourceViewName, vView, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSourceViewName$5[ebp]
	push	edx
	lea	eax, DWORD PTR _vSourceView$7[ebp]
	push	eax
	call	_GetViewByName@16
	jmp	SHORT $LN12@fnResolveQ
$LN11@fnResolveQ:

; 710  :          else
; 711  :             GetIntegerFromAttribute( (zPLONG) &vSourceView, vView,

	push	OFFSET $SG13550
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vSourceView$7[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16
$LN12@fnResolveQ:

; 712  :                                      pchQualEntity, "SourceViewID" );
; 713  : 
; 714  :          // If vSourceView is 0, then the current QualAttrib doesn't reference
; 715  :          // another view, so continue with the next QualAttrib.
; 716  :          if ( vSourceView == 0 )

	cmp	DWORD PTR _vSourceView$7[ebp], 0
	jne	SHORT $LN13@fnResolveQ

; 717  :             continue;

	jmp	SHORT $LN5@fnResolveQ
$LN13@fnResolveQ:

; 718  : 
; 719  :          // Get the source entity and attribute names.
; 720  :          GetAddrForAttribute( &pchSourceEntityName, vView, pchQualEntity,

	push	OFFSET $SG13552
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSourceEntityName$6[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 721  :                               "SourceEntityName" );
; 722  :          GetAddrForAttribute( &pchSourceAttributeName, vView, pchQualEntity,

	push	OFFSET $SG13553
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchSourceAttributeName$1[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 723  :                               "SourceAttributeName" );
; 724  : 
; 725  :          // Check to see if the operation is "IS".  If it is, then we have to
; 726  :          // save the key values.
; 727  :          GetAddrForAttribute( &pchOper, vView, pchQualEntity, "Oper" );

	push	OFFSET $SG13554
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchOper$3[ebp]
	push	eax
	call	_GetAddrForAttribute@16

; 728  :          if ( zstrcmpi( pchOper, "IS" ) == 0 )

	push	OFFSET $SG13556
	mov	ecx, DWORD PTR _pchOper$3[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	$LN14@fnResolveQ

; 729  :          {
; 730  :             LPVIEWENTITY lpViewEntity;
; 731  :             LPVIEWATTRIB lpViewAttrib;
; 732  :             zVIEW        vTemp;
; 733  :             zBOOL        bFirstKey = TRUE;

	mov	BYTE PTR _bFirstKey$9[ebp], 1

; 734  : 
; 735  :             // Save a copy of the current view so we can delete the QualAttrib
; 736  :             // entity later.
; 737  :             CreateViewFromViewForTask( &vTemp, vView, 0 );

	push	0
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTemp$4[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 738  : 
; 739  :             CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_CreateEntity@12

; 740  :             SetAttributeFromString( vView, pchQualEntity, "Oper", "(" );

	push	OFFSET $SG13557
	push	OFFSET $SG13558
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 741  : 
; 742  :             // The oper is "IS".  This means we need to replace the current
; 743  :             // QualAttrib with QualAttribs to compare each key.
; 744  :             lpViewEntity = MiGetViewEntityForView( vSourceView,

	mov	edx, DWORD PTR _pchSourceEntityName$6[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7[ebp]
	push	eax
	call	_MiGetViewEntityForView@8
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 745  :                                                    pchSourceEntityName );
; 746  :             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8[ebp], eax
	jmp	SHORT $LN10@fnResolveQ
$LN8@fnResolveQ:

; 748  :                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$8[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$8[ebp], eax
$LN10@fnResolveQ:

; 747  :                   lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$8[ebp], 0
	je	$LN9@fnResolveQ

; 749  :             {
; 750  :                // We only care about keys...
; 751  :                if ( lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$8[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN15@fnResolveQ

; 752  :                   continue;

	jmp	SHORT $LN8@fnResolveQ
$LN15@fnResolveQ:

; 753  : 
; 754  :                if ( bFirstKey )

	movzx	ecx, BYTE PTR _bFirstKey$9[ebp]
	test	ecx, ecx
	je	SHORT $LN16@fnResolveQ

; 755  :                   bFirstKey = FALSE;

	mov	BYTE PTR _bFirstKey$9[ebp], 0
	jmp	SHORT $LN17@fnResolveQ
$LN16@fnResolveQ:

; 756  :                else
; 757  :                {
; 758  :                   CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_CreateEntity@12

; 759  :                   SetAttributeFromString( vView, pchQualEntity, "Oper", "AND" );

	push	OFFSET $SG13562
	push	OFFSET $SG13563
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$LN17@fnResolveQ:

; 760  :                }
; 761  : 
; 762  :                CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 763  :                SetAttributeFromString( vView, pchQualEntity, "EntityName",

	mov	edx, DWORD PTR _pchSourceEntityName$6[ebp]
	push	edx
	push	OFFSET $SG13564
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 764  :                                        pchSourceEntityName );
; 765  :                SetAttributeFromString( vView, pchQualEntity, "AttributeName",

	mov	edx, DWORD PTR _lpViewAttrib$8[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG13565
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 766  :                                        lpViewAttrib->szName );
; 767  :                SetAttributeFromString( vView, pchQualEntity, "Oper", "=" );

	push	OFFSET $SG13566
	push	OFFSET $SG13567
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 768  :                SetAttributeFromAttribute( vView, pchQualEntity, "Value",

	mov	ecx, DWORD PTR _lpViewAttrib$8[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _pchSourceEntityName$6[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7[ebp]
	push	eax
	push	OFFSET $SG13568
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 769  :                                           vSourceView, pchSourceEntityName,
; 770  :                                           lpViewAttrib->szName );
; 771  :             } // for...

	jmp	$LN8@fnResolveQ
$LN9@fnResolveQ:

; 772  : 
; 773  :             CreateEntity( vView, pchQualEntity, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 774  :             SetAttributeFromString( vView, pchQualEntity, "Oper", ")" );

	push	OFFSET $SG13569
	push	OFFSET $SG13570
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 775  : 
; 776  :             DeleteEntity( vTemp, pchQualEntity, zREPOS_NONE );

	push	0
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTemp$4[ebp]
	push	edx
	call	_DeleteEntity@12

; 777  :             DropView( vTemp );

	mov	eax, DWORD PTR _vTemp$4[ebp]
	push	eax
	call	_DropView@4

; 778  : 
; 779  :             // We've done all that needs to be done, so process the next
; 780  :             // qual entity.
; 781  :             continue;

	jmp	$LN5@fnResolveQ
$LN14@fnResolveQ:

; 782  : 
; 783  :          } // if ( zstrcmpi( pchOper, "IS" )...
; 784  : 
; 785  :          // Copy attribute value from the source view to the qual view.
; 786  :          SetAttributeFromAttribute( vView, pchQualEntity, "Value",

	mov	ecx, DWORD PTR _pchSourceAttributeName$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchSourceEntityName$6[ebp]
	push	edx
	mov	eax, DWORD PTR _vSourceView$7[ebp]
	push	eax
	push	OFFSET $SG13571
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 787  :                                     vSourceView, pchSourceEntityName,
; 788  :                                     pchSourceAttributeName );
; 789  : 
; 790  :          // Set the qual attrib to be null.
; 791  :          SetAttributeFromString( vView, pchQualEntity, "SourceViewName", "" );

	push	OFFSET $SG13572
	push	OFFSET $SG13573
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 792  :          SetAttributeFromInteger( vView, pchQualEntity, "SourceViewID", 0 );

	push	0
	push	OFFSET $SG13574
	mov	edx, DWORD PTR _pchQualEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_SetAttributeFromInteger@16

; 793  :          SetAttributeFromString( vView, pchQualEntity, "SourceEntityName", "" );

	push	OFFSET $SG13575
	push	OFFSET $SG13576
	mov	ecx, DWORD PTR _pchQualEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 794  :          SetAttributeFromString( vView, pchQualEntity, "SourceAttributeName", "" );

	push	OFFSET $SG13577
	push	OFFSET $SG13578
	mov	eax, DWORD PTR _pchQualEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 795  : 
; 796  :       } // for each pchQualEntity...

	jmp	$LN5@fnResolveQ
$LN6@fnResolveQ:

; 797  : 
; 798  :    } // for each "EntitySpec"...

	jmp	$LN2@fnResolveQ
$LN1@fnResolveQ:

; 799  : 
; 800  : } // fnResolveQualOI

	mov	esp, ebp
	pop	ebp
	ret	0
_fnResolveQualOI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pViewArrayBlock$ = 8					; size = 4
_fnFreeViewArrayBlock PROC

; 14489: {

	push	ebp
	mov	ebp, esp

; 14490:    if ( pViewArrayBlock->pvArray && pViewArrayBlock->lCount > 2 )

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN2@fnFreeView
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	cmp	DWORD PTR [ecx], 2
	jle	SHORT $LN2@fnFreeView

; 14491:       SysFree( pViewArrayBlock->pvArray );

	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_SysFree@4
$LN2@fnFreeView:

; 14492: 
; 14493:    zmemset( pViewArrayBlock, 0, sizeof( VIEWARRAYBLOCK ) );

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 14494: }

	pop	ebp
	ret	0
_fnFreeViewArrayBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_nViewCount1$ = -8					; size = 4
_pv$ = -4						; size = 4
_pViewArrayBlock$ = 8					; size = 4
_nViewCount$ = 12					; size = 4
_fnInitViewArrayBlock PROC

; 14447: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 14448:    zPVOID *pv;
; 14449:    zLONG nViewCount1 = nViewCount + 1; // we need a trailing NULL pointer

	mov	eax, DWORD PTR _nViewCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _nViewCount1$[ebp], eax

; 14450: 
; 14451:    zmemset( pViewArrayBlock, 0, sizeof(VIEWARRAYBLOCK) );

	push	64					; 00000040H
	push	0
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 14452: 
; 14453:    if ( nViewCount > 1 )

	cmp	DWORD PTR _nViewCount$[ebp], 1
	jle	SHORT $LN2@fnInitView

; 14454:    {
; 14455:       // allocate 5 PVOID arrays of size nViewCount + 1
; 14456:       pv = SysMalloc( 5 * nViewCount1 * sizeof( zPVOID ) );

	imul	edx, DWORD PTR _nViewCount1$[ebp], 5
	shl	edx, 2
	push	edx
	call	_SysMalloc@4
	mov	DWORD PTR _pv$[ebp], eax

; 14457:       if ( pv == 0 )

	cmp	DWORD PTR _pv$[ebp], 0
	jne	SHORT $LN4@fnInitView

; 14458:          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnInitView
$LN4@fnInitView:

; 14459:    }

	jmp	SHORT $LN3@fnInitView
$LN2@fnInitView:

; 14460:    else
; 14461:    {
; 14462:       // Usually there is only 1 view in the cluster ... in which case we
; 14463:       // we do NOT malloc for performance reasons.
; 14464:       pv = pViewArrayBlock->pvDyn;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _pv$[ebp], eax
$LN3@fnInitView:

; 14465:    }
; 14466: 
; 14467:    pViewArrayBlock->lCount = nViewCount1;

	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	edx, DWORD PTR _nViewCount1$[ebp]
	mov	DWORD PTR [ecx], edx

; 14468:    pViewArrayBlock->pvArray = (zVIEW *) pv;

	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 14469:    pViewArrayBlock->pViewOI_Array = (LPVIEWOI *)(pv + nViewCount1);

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	mov	eax, DWORD PTR _pv$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 14470:    pViewArrayBlock->pViewOD_Array = (LPVIEWOD *)(pv + 2 * nViewCount1);

	mov	eax, DWORD PTR _nViewCount1$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _pv$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [eax+12], edx

; 14471:    pViewArrayBlock->pbGenkeyNeededArray = (zBOOL *)(pv + 3 * nViewCount1);

	imul	ecx, DWORD PTR _nViewCount1$[ebp], 3
	mov	edx, DWORD PTR _pv$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 14472:    pViewArrayBlock->pbFK_NeededArray    = (zBOOL *)(pv + 4 * nViewCount1);

	mov	edx, DWORD PTR _nViewCount1$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR _pv$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR _pViewArrayBlock$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 14473: 
; 14474:    return( 0 );

	xor	eax, eax
$LN1@fnInitView:

; 14475: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInitViewArrayBlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_ulLth$1 = -32						; size = 4
_lpAllocTask$ = -28					; size = 4
_lpViewOI$ = -24					; size = 4
_lpPtr$2 = -20						; size = 4
tv95 = -16						; size = 4
_pch$ = -12						; size = 4
_k$ = -8						; size = 2
_chDelim$ = -1						; size = 1
_pchKeyString$ = 8					; size = 4
_lpEntityInstance$ = 12					; size = 4
_lpKeyViewAttrib$ = 16					; size = 4
_nKeyCnt$ = 20						; size = 2
_fnCreateConcatKey@16 PROC

; 9351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi

; 9352 :    LPVIEWOI lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 9353 :    LPTASK   lpAllocTask = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 9354 :    zPCHAR   pch;
; 9355 :    zCHAR    chDelim;
; 9356 :    zSHORT   k;
; 9357 : 
; 9358 :    // Get the default key delimiter.
; 9359 :    chDelim = fnFindKeyDelim( 0, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	0
	call	_fnFindKeyDelim@16
	mov	BYTE PTR _chDelim$[ebp], al

; 9360 : 
; 9361 :    // Because the delimiter can change, the first char will be the delimiter
; 9362 :    // for the string.
; 9363 :    pch = pchKeyString;

	mov	ecx, DWORD PTR _pchKeyString$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx

; 9364 : 
; 9365 :    // Go through each of the keys are retrieve the values.
; 9366 :    for ( k = 0; k < nKeyCnt; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@fnCreateCo
$LN2@fnCreateCo:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@fnCreateCo:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nKeyCnt$[ebp]
	cmp	ecx, edx
	jge	$LN3@fnCreateCo

; 9367 :    {
; 9368 :       zPVOID  lpPtr;
; 9369 :       zULONG  ulLth;
; 9370 : 
; 9371 :       *pch++ = chDelim;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	cl, BYTE PTR _chDelim$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx

; 9372 : 
; 9373 :       // Get pointer to key value.
; 9374 :       if ( fnGetAttrAddrFromEntityInstance( (zCOREMEM) &lpPtr,
; 9375 :                                             &ulLth, lpEntityInstance,
; 9376 :                                             lpKeyViewAttrib[ k ] ) == -1 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpPtr$2[ebp]
	push	edx
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H
	cwde
	cmp	eax, -1
	jne	SHORT $LN7@fnCreateCo

; 9377 :       {
; 9378 :          // Key is null so just continue.
; 9379 :          continue;

	jmp	SHORT $LN2@fnCreateCo
$LN7@fnCreateCo:

; 9380 :       }
; 9381 : 
; 9382 :       // Convert internal key value to string.
; 9383 :       switch ( lpKeyViewAttrib[ k ]->cType )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	movsx	ecx, BYTE PTR [eax+202]
	mov	DWORD PTR tv95[ebp], ecx
	mov	edx, DWORD PTR tv95[ebp]
	sub	edx, 76					; 0000004cH
	mov	DWORD PTR tv95[ebp], edx
	cmp	DWORD PTR tv95[ebp], 8
	ja	SHORT $LN5@fnCreateCo
	mov	eax, DWORD PTR tv95[ebp]
	jmp	DWORD PTR $LN15@fnCreateCo[eax*4]
$LN8@fnCreateCo:

; 9384 :       {
; 9385 :          case zTYPE_STRING:
; 9386 :             // Don't need to convert it--just copy it.
; 9387 :             zstrcpy( pch, (zPCHAR) lpPtr );

	mov	ecx, DWORD PTR _lpPtr$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 9388 :             break;

	jmp	SHORT $LN5@fnCreateCo
$LN9@fnCreateCo:

; 9389 : 
; 9390 :          case zTYPE_INTEGER:
; 9391 :             zltoa( *((zPLONG) lpPtr), pch );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpPtr$2[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 9392 :             break;

	jmp	SHORT $LN5@fnCreateCo
$LN10@fnCreateCo:

; 9393 : 
; 9394 :          case zTYPE_DECIMAL:
; 9395 :             ConvertDecimalToString( pch, lpKeyViewAttrib[ k ],

	push	0
	mov	esi, DWORD PTR _lpPtr$2[ebp]
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	mov	edi, esp
	rep movsd
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpKeyViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	_ConvertDecimalToString@52

; 9396 :                                     *((zPDECIMAL) lpPtr), 0 );
; 9397 :             break;

	jmp	SHORT $LN5@fnCreateCo

; 9398 : 
; 9399 :          case zTYPE_BLOB:
; 9400 :             // No blobs should ever be keys.
; 9401 :             break;

	jmp	SHORT $LN5@fnCreateCo
$LN12@fnCreateCo:

; 9402 : 
; 9403 :          case zTYPE_DATETIME:
; 9404 :              UfDateTimeToString( (LPDATETIME) lpPtr, pch, 18 );

	push	18					; 00000012H
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpPtr$2[ebp]
	push	edx
	call	_UfDateTimeToString@12
$LN5@fnCreateCo:

; 9405 :             break;
; 9406 : 
; 9407 :       } // switch ( lpKeyViewAttribute[ k ]->cType )...
; 9408 : 
; 9409 :       // Make sure that the delimiter is not in the new value.
; 9410 :       if ( zstrchr( pch, chDelim ) != 0 )

	movsx	eax, BYTE PTR _chDelim$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN13@fnCreateCo

; 9411 :       {
; 9412 :          // The current delimiter exists in the key value so we must get a
; 9413 :          // new one.  fnFindKeyDelim will change all the old delims to match
; 9414 :          // the new delim.
; 9415 :          chDelim = fnFindKeyDelim( chDelim, pchKeyString, pch, pch );

	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchKeyString$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _chDelim$[ebp]
	push	edx
	call	_fnFindKeyDelim@16
	mov	BYTE PTR _chDelim$[ebp], al
$LN13@fnCreateCo:

; 9416 :       }
; 9417 : 
; 9418 :       // Set pch to point to the end of the string.
; 9419 :       pch = zstrchr( pch, 0 );

	push	0
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pch$[ebp], eax

; 9420 : 
; 9421 :    } // for ( k... )

	jmp	$LN2@fnCreateCo
$LN3@fnCreateCo:

; 9422 : 
; 9423 :    return( 0 );

	xor	eax, eax

; 9424 : 
; 9425 : } // fnCreateConcatKey

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN15@fnCreateCo:
	DD	$LN9@fnCreateCo
	DD	$LN10@fnCreateCo
	DD	$LN5@fnCreateCo
	DD	$LN5@fnCreateCo
	DD	$LN5@fnCreateCo
	DD	$LN5@fnCreateCo
	DD	$LN5@fnCreateCo
	DD	$LN8@fnCreateCo
	DD	$LN12@fnCreateCo
_fnCreateConcatKey@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_uLth$1 = -600						; size = 4
_ulLth$2 = -596						; size = 4
_uBlobLth$3 = -592					; size = 4
_lpViewEntityCsr$4 = -588				; size = 4
_lpViewEntityCsr$5 = -584				; size = 4
tv224 = -580						; size = 4
tv214 = -576						; size = 4
tv197 = -572						; size = 4
tv185 = -568						; size = 4
tv184 = -564						; size = 4
tv152 = -560						; size = 4
tv91 = -556						; size = 4
_bNull1$ = -552						; size = 2
_ulLth2$6 = -548					; size = 4
_ulLth1$7 = -544					; size = 4
tv169 = -540						; size = 4
_bNull2$ = -536						; size = 2
_pchValue1$ = -532					; size = 4
_pchValue2$ = -528					; size = 4
_chType2$ = -522					; size = 1
_chType1$ = -521					; size = 1
_nRC$ = -520						; size = 2
_AttrVal2$ = -516					; size = 256
_AttrVal1$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_lpView1$ = 12						; size = 4
_lpInstance1$ = 16					; size = 4
_lpViewAttrib1$ = 20					; size = 4
_pchContextName1$ = 24					; size = 4
_lpView2$ = 28						; size = 4
_lpInstance2$ = 32					; size = 4
_lpViewAttrib2$ = 36					; size = 4
_pchContextName2$ = 40					; size = 4
_fnCompareEIAttrs@36 PROC

; 12388: {

	push	ebp
	mov	ebp, esp
	sub	esp, 600				; 00000258H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 12389:    zPCHAR   pchValue1, pchValue2;
; 12390:    zSHORT   bNull1, bNull2;
; 12391:    zCHAR    chType1, chType2;
; 12392:    zSHORT   nRC;
; 12393: 
; 12394:    typedef union _AttrValues
; 12395:    {
; 12396:       zLONG          l;
; 12397:       zCHAR          sz[ 256 ];
; 12398:       zDECIMAL       d;
; 12399:       DateTimeRecord dt;
; 12400:    } AttrValues;
; 12401:    AttrValues AttrVal1, AttrVal2;
; 12402: 
; 12403:    bNull1 = fnAttributeValueNull( 0, lpInstance1, lpViewAttrib1 );

	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInstance1$[ebp]
	push	ecx
	push	0
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	mov	WORD PTR _bNull1$[ebp], ax

; 12404:    bNull2 = fnAttributeValueNull( 0, lpInstance2, lpViewAttrib2 );

	mov	edx, DWORD PTR _lpViewAttrib2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInstance2$[ebp]
	push	eax
	push	0
	call	_fnAttributeValueNull
	add	esp, 12					; 0000000cH
	mov	WORD PTR _bNull2$[ebp], ax

; 12405: 
; 12406:    if ( bNull1 )

	movsx	ecx, WORD PTR _bNull1$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@fnCompareE

; 12407:    {
; 12408:       if ( bNull2 )

	movsx	edx, WORD PTR _bNull2$[ebp]
	test	edx, edx
	je	SHORT $LN6@fnCompareE

; 12409:          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCompareE
	jmp	SHORT $LN7@fnCompareE
$LN6@fnCompareE:

; 12410:       else
; 12411:          return( -1 );

	or	eax, -1
	jmp	$LN1@fnCompareE
$LN7@fnCompareE:

; 12412:    }

	jmp	SHORT $LN5@fnCompareE
$LN4@fnCompareE:

; 12413:    else
; 12414:    if ( bNull2 )

	movsx	eax, WORD PTR _bNull2$[ebp]
	test	eax, eax
	je	SHORT $LN5@fnCompareE

; 12415:    {
; 12416:       // We know that attrib 1 is NOT null so it is > than attrib 2.
; 12417:       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnCompareE
$LN5@fnCompareE:

; 12418:    }
; 12419: 
; 12420:    chType1 = lpViewAttrib1->cType;

	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR _chType1$[ebp], dl

; 12421: 
; 12422:    // Check to see if we have a context.  If we do, use it to get the attr
; 12423:    // value.  If not, get a pointer to the internal value.
; 12424: 
; 12425:    if ( pchContextName1 && chType1 != zTYPE_BLOB && chType1 != zTYPE_DATETIME )

	cmp	DWORD PTR _pchContextName1$[ebp], 0
	je	$LN9@fnCompareE
	movsx	eax, BYTE PTR _chType1$[ebp]
	cmp	eax, 66					; 00000042H
	je	$LN9@fnCompareE
	movsx	ecx, BYTE PTR _chType1$[ebp]
	cmp	ecx, 84					; 00000054H
	je	$LN9@fnCompareE

; 12426:    {
; 12427:       LPVIEWENTITYCSR lpViewEntityCsr;
; 12428:       zULONG          ulLth;
; 12429: 
; 12430:       // Use the context name to get attribute value.
; 12431:       lpViewEntityCsr = fnEstablishViewForInstance( lpView1, 0, lpInstance1 );

	mov	edx, DWORD PTR _lpInstance1$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView1$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$5[ebp], eax

; 12432: 
; 12433:       // Use default context if pchContextName points to an empty string.
; 12434:       fnGetVariableFromAttribute( (zPVOID) &AttrVal1, &ulLth,

	mov	ecx, DWORD PTR _pchContextName1$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN30@fnCompareE
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $LN31@fnCompareE
$LN30@fnCompareE:
	mov	DWORD PTR tv91[ebp], 8
$LN31@fnCompareE:
	movzx	eax, WORD PTR tv91[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchContextName1$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView1$[ebp]
	push	edx
	push	256					; 00000100H
	movzx	eax, BYTE PTR _chType1$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ulLth$2[ebp]
	push	ecx
	lea	edx, DWORD PTR _AttrVal1$[ebp]
	push	edx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H

; 12435:                                   chType1, (zULONG) sizeof( AttrVal2 ),
; 12436:                                   lpView1, lpViewEntityCsr,
; 12437:                                   lpViewAttrib1,
; 12438:                                   pchContextName1,
; 12439:                                   lpCurrentTask,
; 12440:                                   (zSHORT) (*pchContextName1 ? 0 : zUSE_DEFAULT_CONTEXT) );
; 12441: 
; 12442:       pchValue1 = (zPCHAR) &AttrVal1;

	lea	eax, DWORD PTR _AttrVal1$[ebp]
	mov	DWORD PTR _pchValue1$[ebp], eax

; 12443:    }

	jmp	SHORT $LN10@fnCompareE
$LN9@fnCompareE:

; 12444:    else
; 12445:       fnGetAddrForAttribute( &pchValue1, 0, 0, lpInstance1, lpViewAttrib1 );

	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInstance1$[ebp]
	push	edx
	push	0
	push	0
	lea	eax, DWORD PTR _pchValue1$[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
$LN10@fnCompareE:

; 12446: 
; 12447:    chType2 = lpViewAttrib2->cType;

	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR _chType2$[ebp], dl

; 12448: 
; 12449:    if ( pchContextName2 && chType2 != zTYPE_BLOB && chType2 != zTYPE_DATETIME )

	cmp	DWORD PTR _pchContextName2$[ebp], 0
	je	$LN11@fnCompareE
	movsx	eax, BYTE PTR _chType2$[ebp]
	cmp	eax, 66					; 00000042H
	je	$LN11@fnCompareE
	movsx	ecx, BYTE PTR _chType2$[ebp]
	cmp	ecx, 84					; 00000054H
	je	$LN11@fnCompareE

; 12450:    {
; 12451:       LPVIEWENTITYCSR lpViewEntityCsr;
; 12452:       zLONG           uLth;
; 12453: 
; 12454:       // Use the context name to get attribute value.
; 12455:       lpViewEntityCsr = fnEstablishViewForInstance( lpView2, 0, lpInstance2 );

	mov	edx, DWORD PTR _lpInstance2$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView2$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$4[ebp], eax

; 12456: 
; 12457:       // Use default context if pchContextName points to an empty string.
; 12458:       fnGetVariableFromAttribute( (zPVOID) &AttrVal2, &uLth,

	mov	ecx, DWORD PTR _pchContextName2$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN32@fnCompareE
	mov	DWORD PTR tv152[ebp], 0
	jmp	SHORT $LN33@fnCompareE
$LN32@fnCompareE:
	mov	DWORD PTR tv152[ebp], 8
$LN33@fnCompareE:
	movzx	eax, WORD PTR tv152[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchContextName2$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView2$[ebp]
	push	edx
	push	256					; 00000100H
	movzx	eax, BYTE PTR _chType2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uLth$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _AttrVal2$[ebp]
	push	edx
	call	_fnGetVariableFromAttribute
	add	esp, 40					; 00000028H

; 12459:                                   chType2, (zULONG) sizeof( AttrVal2 ),
; 12460:                                   lpView2, lpViewEntityCsr,
; 12461:                                   lpViewAttrib2,
; 12462:                                   pchContextName2,
; 12463:                                   lpCurrentTask,
; 12464:                                   (zSHORT) ( *pchContextName2 ? 0 : zUSE_DEFAULT_CONTEXT ) );
; 12465: 
; 12466:       pchValue2 = (zPCHAR) &AttrVal2;

	lea	eax, DWORD PTR _AttrVal2$[ebp]
	mov	DWORD PTR _pchValue2$[ebp], eax

; 12467:    }

	jmp	SHORT $LN12@fnCompareE
$LN11@fnCompareE:

; 12468:    else
; 12469:       fnGetAddrForAttribute( &pchValue2, 0, 0, lpInstance2, lpViewAttrib2 );

	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInstance2$[ebp]
	push	edx
	push	0
	push	0
	lea	eax, DWORD PTR _pchValue2$[ebp]
	push	eax
	call	_fnGetAddrForAttribute
	add	esp, 20					; 00000014H
$LN12@fnCompareE:

; 12470: 
; 12471:    switch ( chType1 )

	movsx	ecx, BYTE PTR _chType1$[ebp]
	mov	DWORD PTR tv169[ebp], ecx
	mov	edx, DWORD PTR tv169[ebp]
	sub	edx, 66					; 00000042H
	mov	DWORD PTR tv169[ebp], edx
	cmp	DWORD PTR tv169[ebp], 18		; 00000012H
	ja	$LN2@fnCompareE
	mov	eax, DWORD PTR tv169[ebp]
	movzx	ecx, BYTE PTR $LN44@fnCompareE[eax]
	jmp	DWORD PTR $LN45@fnCompareE[ecx*4]
$LN13@fnCompareE:

; 12472:    {
; 12473:       case zTYPE_STRING:
; 12474:          if ( lpViewAttrib1->bCaseSens )

	mov	edx, DWORD PTR _lpViewAttrib1$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN14@fnCompareE

; 12475:             nRC = zstrcmp( pchValue1, pchValue2 );

	mov	ecx, DWORD PTR _pchValue1$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchValue2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN36@fnCompareE
	mov	edx, DWORD PTR _pchValue2$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue1$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv185[ebp], eax
	jmp	SHORT $LN37@fnCompareE
$LN36@fnCompareE:
	mov	ecx, DWORD PTR _pchValue1$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchValue2$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN34@fnCompareE
	mov	DWORD PTR tv184[ebp], 1
	jmp	SHORT $LN35@fnCompareE
$LN34@fnCompareE:
	mov	DWORD PTR tv184[ebp], -1
$LN35@fnCompareE:
	mov	edx, DWORD PTR tv184[ebp]
	mov	DWORD PTR tv185[ebp], edx
$LN37@fnCompareE:
	mov	ax, WORD PTR tv185[ebp]
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN15@fnCompareE
$LN14@fnCompareE:

; 12476:          else
; 12477:             nRC = zstrcmpi( pchValue1, pchValue2 );

	mov	ecx, DWORD PTR _pchValue2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchValue1$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN15@fnCompareE:

; 12478: 
; 12479:          if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN16@fnCompareE

; 12480:             nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN17@fnCompareE
$LN16@fnCompareE:

; 12481:          else
; 12482:          if ( nRC > 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jle	SHORT $LN17@fnCompareE

; 12483:             nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN17@fnCompareE:

; 12484: 
; 12485:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnCompareE
$LN19@fnCompareE:

; 12486: 
; 12487:       case zTYPE_INTEGER:
; 12488:          if ( *((zPLONG) pchValue1) == *((zPLONG) pchValue2) )

	mov	ecx, DWORD PTR _pchValue1$[ebp]
	mov	edx, DWORD PTR _pchValue2$[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN20@fnCompareE

; 12489:             nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN21@fnCompareE
$LN20@fnCompareE:

; 12490:          else
; 12491:             nRC = (*((zPLONG) pchValue1) < *((zPLONG) pchValue2)) ? -1 : 1;

	mov	edx, DWORD PTR _pchValue1$[ebp]
	mov	eax, DWORD PTR _pchValue2$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jge	SHORT $LN38@fnCompareE
	mov	DWORD PTR tv197[ebp], -1
	jmp	SHORT $LN39@fnCompareE
$LN38@fnCompareE:
	mov	DWORD PTR tv197[ebp], 1
$LN39@fnCompareE:
	mov	dx, WORD PTR tv197[ebp]
	mov	WORD PTR _nRC$[ebp], dx
$LN21@fnCompareE:

; 12492: 
; 12493:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnCompareE
$LN22@fnCompareE:

; 12494: 
; 12495:       case zTYPE_DECIMAL:
; 12496:          return( SysCompareDecimalToDecimal( (zPDECIMAL) pchValue1,

	mov	eax, DWORD PTR _pchValue2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue1$[ebp]
	push	ecx
	call	_SysCompareDecimalToDecimal@8
	jmp	$LN1@fnCompareE
$LN23@fnCompareE:

; 12497:                                              (zPDECIMAL) pchValue2 ) );
; 12498: 
; 12499:       case zTYPE_DATETIME:
; 12500:          nRC = fnCompareDateTimeToDateTime( (LPDTINTERNAL) pchValue1,

	mov	edx, DWORD PTR _pchValue2$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue1$[ebp]
	push	eax
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 12501:                                             (LPDTINTERNAL) pchValue2 );
; 12502:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnCompareE
$LN24@fnCompareE:

; 12503: 
; 12504:       case zTYPE_BLOB:
; 12505:       {
; 12506:          zULONG ulLth1, ulLth2, uBlobLth;
; 12507: 
; 12508:          fnGetAttributeLength( &ulLth1, 0, lpInstance1, lpViewAttrib1 );

	mov	ecx, DWORD PTR _lpViewAttrib1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInstance1$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _ulLth1$7[ebp]
	push	eax
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 12509:          fnGetAttributeLength( &ulLth2, 0, lpInstance2, lpViewAttrib2 );

	mov	ecx, DWORD PTR _lpViewAttrib2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInstance2$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _ulLth2$6[ebp]
	push	eax
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 12510: 
; 12511:          uBlobLth = min( ulLth1, ulLth2 );

	mov	ecx, DWORD PTR _ulLth1$7[ebp]
	cmp	ecx, DWORD PTR _ulLth2$6[ebp]
	jae	SHORT $LN40@fnCompareE
	mov	edx, DWORD PTR _ulLth1$7[ebp]
	mov	DWORD PTR tv214[ebp], edx
	jmp	SHORT $LN41@fnCompareE
$LN40@fnCompareE:
	mov	eax, DWORD PTR _ulLth2$6[ebp]
	mov	DWORD PTR tv214[ebp], eax
$LN41@fnCompareE:
	mov	ecx, DWORD PTR tv214[ebp]
	mov	DWORD PTR _uBlobLth$3[ebp], ecx

; 12512: 
; 12513:          nRC = zmemcmp( pchValue1, pchValue2, (int) uBlobLth );

	mov	edx, DWORD PTR _uBlobLth$3[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchValue1$[ebp]
	push	ecx
	call	_memcmp
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 12514:          if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN25@fnCompareE

; 12515:          {
; 12516:             if ( ulLth1 == ulLth2 )

	mov	eax, DWORD PTR _ulLth1$7[ebp]
	cmp	eax, DWORD PTR _ulLth2$6[ebp]
	jne	SHORT $LN27@fnCompareE

; 12517:                return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnCompareE
	jmp	SHORT $LN28@fnCompareE
$LN27@fnCompareE:

; 12518:             else
; 12519:                return( ulLth1 < ulLth2 ? -1 : 1 );

	mov	ecx, DWORD PTR _ulLth1$7[ebp]
	cmp	ecx, DWORD PTR _ulLth2$6[ebp]
	jae	SHORT $LN42@fnCompareE
	mov	DWORD PTR tv224[ebp], -1
	jmp	SHORT $LN43@fnCompareE
$LN42@fnCompareE:
	mov	DWORD PTR tv224[ebp], 1
$LN43@fnCompareE:
	mov	ax, WORD PTR tv224[ebp]
	jmp	SHORT $LN1@fnCompareE
$LN28@fnCompareE:

; 12520:          }

	jmp	SHORT $LN2@fnCompareE
$LN25@fnCompareE:

; 12521:          else
; 12522:             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnCompareE
$LN2@fnCompareE:

; 12523:       }
; 12524: 
; 12525:    } // end of switch ( lpSrcViewAttrib->cType )
; 12526: 
; 12527:    return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@fnCompareE:

; 12528: }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
	npad	3
$LN45@fnCompareE:
	DD	$LN24@fnCompareE
	DD	$LN19@fnCompareE
	DD	$LN22@fnCompareE
	DD	$LN13@fnCompareE
	DD	$LN23@fnCompareE
	DD	$LN2@fnCompareE
$LN44@fnCompareE:
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	4
_fnCompareEIAttrs@36 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pOper$ = -56						; size = 4
_pGKOper$ = -52						; size = 4
_lpViewCsr$ = -48					; size = 4
_lpViewOD$ = -44					; size = 4
_lpPtr$ = -40						; size = 4
_lpKZGKHWOB$ = -36					; size = 4
_vTemp$1 = -32						; size = 4
_vSubtask$ = -28					; size = 4
_lpViewOI$ = -24					; size = 4
_lpTaskDBHandler$ = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_nRC$ = -12						; size = 2
_k$ = -8						; size = 2
_bTransactionStartedHere$ = -1				; size = 1
_lpViewCluster$ = 8					; size = 4
_lpViewArray$ = 12					; size = 4
_nViewCount$ = 16					; size = 2
_pnViewErrorIdx$ = 20					; size = 4
_lpCurrentTask$ = 24					; size = 4
_lControl$ = 28						; size = 4
_pViewArrayBlock$ = 32					; size = 4
_fnCommitObjectInstance@28 PROC

; 6733 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 6734 :    LPVIEWOD             lpViewOD;
; 6735 :    LPVIEWOI             lpViewOI;
; 6736 :    LPVIEWCSR            lpViewCsr;
; 6737 :    LPTASKDBHANDLER      lpTaskDBHandler;
; 6738 :    LPENTITYINSTANCE     lpEntityInstance;
; 6739 :    zPGKHOPER            pGKOper = 0;

	mov	DWORD PTR _pGKOper$[ebp], 0

; 6740 :    zPDBHOPER            pOper;
; 6741 :    zPVOID               lpPtr;
; 6742 :    zVIEW                lpKZGKHWOB;
; 6743 :    zVIEW                vSubtask;
; 6744 :    zBOOL                bTransactionStartedHere;
; 6745 :    zSHORT               k;
; 6746 :    zSHORT               nRC;
; 6747 : 
; 6748 :    // Find the first non-zero view in the list.  We'll use this to pass into
; 6749 :    // the DBHandler so that the DBH knows what DB where dealing with.
; 6750 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@fnCommitOb
$LN2@fnCommitOb:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@fnCommitOb:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN3@fnCommitOb

; 6751 :    {
; 6752 :       if ( lpViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $LN17@fnCommitOb

; 6753 :       {
; 6754 :          vSubtask = lpViewCluster[ k ].vOI;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 6755 :          break;

	jmp	SHORT $LN3@fnCommitOb
$LN17@fnCommitOb:

; 6756 :       }
; 6757 :    }

	jmp	SHORT $LN2@fnCommitOb
$LN3@fnCommitOb:

; 6758 : 
; 6759 :    // Turn off the DBH flags for all entity instances.  This allows
; 6760 :    // us to figure out if the entity instance was processed.
; 6761 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN7@fnCommitOb
$LN5@fnCommitOb:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN7@fnCommitOb:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$LN6@fnCommitOb

; 6762 :    {
; 6763 :       if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN18@fnCommitOb

; 6764 :          continue;

	jmp	SHORT $LN5@fnCommitOb
$LN18@fnCommitOb:

; 6765 : 
; 6766 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6767 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6768 : 
; 6769 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN10@fnCommitOb
$LN8@fnCommitOb:

; 6771 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN10@fnCommitOb:

; 6770 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN9@fnCommitOb

; 6772 :       {
; 6773 :          lpEntityInstance->u.nInd.bDBHCreated =

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -4194305				; ffbfffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -2097153				; ffdfffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -1048577				; ffefffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -524289				; fff7ffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -131073				; fffdffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -65537				; fffeffffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -16385				; ffffbfffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -32769				; ffff7fffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -8193				; ffffdfffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6774 :             lpEntityInstance->u.nInd.bDBHIncluded  =
; 6775 :             lpEntityInstance->u.nInd.bDBHDeleted   =
; 6776 :             lpEntityInstance->u.nInd.bDBHExcluded  =
; 6777 :             lpEntityInstance->u.nInd.bDBHUpdated   =
; 6778 :             lpEntityInstance->u.nInd.bSequenceUpdt =
; 6779 :             lpEntityInstance->u.nInd.bGenKeyNeeded =
; 6780 :             lpEntityInstance->u.nInd.bNoGenKey     =
; 6781 :             lpEntityInstance->u.nInd.bForeignKeys  = 0;
; 6782 :       }

	jmp	$LN8@fnCommitOb
$LN9@fnCommitOb:

; 6783 :    }

	jmp	$LN5@fnCommitOb
$LN6@fnCommitOb:

; 6784 : 
; 6785 :    // Initialize the genkey handler and create the genkeys.  This will also
; 6786 :    // determine if any EI's need to have foreign keys set.
; 6787 :    lpKZGKHWOB = 0;

	mov	DWORD PTR _lpKZGKHWOB$[ebp], 0

; 6788 :    nRC = fnInitializeGenKeys( lpViewArray, nViewCount, pnViewErrorIdx,

	mov	ecx, DWORD PTR _pViewArrayBlock$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pGKOper$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	edx
	movzx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	push	ecx
	call	_fnInitializeGenKeys@28
	mov	WORD PTR _nRC$[ebp], ax

; 6789 :                               lpCurrentTask, &lpKZGKHWOB, &pGKOper,
; 6790 :                               pViewArrayBlock );
; 6791 :    if ( nRC == zCALL_ERROR )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN19@fnCommitOb

; 6792 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCommitOb
$LN19@fnCommitOb:

; 6793 : 
; 6794 :    // Make sure that DBHandler is out there.
; 6795 :    lpTaskDBHandler = fnGetDBHandlerOper( lpCurrentTask, vSubtask, &pOper );

	lea	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnGetDBHandlerOper@12
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 6796 :    if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $LN20@fnCommitOb

; 6797 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCommitOb
$LN20@fnCommitOb:

; 6798 : 
; 6799 :    if ( lpTaskDBHandler->bTranStarted )

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	and	ecx, 1
	je	SHORT $LN21@fnCommitOb

; 6800 :    {
; 6801 :       bTransactionStartedHere = FALSE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 0

; 6802 :       lpPtr = lpTaskDBHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 6803 :    }

	jmp	SHORT $LN22@fnCommitOb
$LN21@fnCommitOb:

; 6804 :    else
; 6805 :    {
; 6806 :       // Call DBHandler routine to issue start of transaction.
; 6807 :       lpViewOD = zGETPTR( vSubtask->hViewOD );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 6808 :       lpPtr = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 6809 :       nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	2
	push	16385					; 00004001H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 6810 :                       DBH_Object | DBH_TranBegin, DBH_StoreOI, lpViewOD,
; 6811 :                       0, vSubtask, 0, &lpPtr );
; 6812 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN23@fnCommitOb

; 6813 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnCommitOb
$LN23@fnCommitOb:

; 6814 : 
; 6815 :       bTransactionStartedHere = TRUE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 1

; 6816 :       lpTaskDBHandler->bTranStarted = TRUE;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+26]
	or	eax, 1
	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 6817 :       lpTaskDBHandler->lpConnection = lpPtr;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [edx+18], eax
$LN22@fnCommitOb:

; 6818 :    }
; 6819 : 
; 6820 :    // Commit each view separately.
; 6821 :    for ( k = 0; k < nViewCount && nRC >= 0; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN13@fnCommitOb
$LN11@fnCommitOb:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN13@fnCommitOb:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN12@fnCommitOb
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN12@fnCommitOb

; 6822 :    {
; 6823 :       // If the view is 0 then we're not supposed to commit it (maybe it
; 6824 :       // wasn't changed?) so just skip it.
; 6825 :       if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN24@fnCommitOb

; 6826 :          continue;

	jmp	SHORT $LN11@fnCommitOb
$LN24@fnCommitOb:

; 6827 : 
; 6828 :       nRC = fnCommitSingleOI( lpViewArray[ k ], lControl, lpCurrentTask,

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_fnCommitSingleOI@16
	mov	WORD PTR _nRC$[ebp], ax

; 6829 :                               lpTaskDBHandler );
; 6830 : 
; 6831 :       // If there was an error then stop committing.
; 6832 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN25@fnCommitOb

; 6833 :       {
; 6834 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN26@fnCommitOb

; 6835 :             *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$LN26@fnCommitOb:

; 6836 : 
; 6837 :          break;

	jmp	SHORT $LN12@fnCommitOb
$LN25@fnCommitOb:

; 6838 :       }
; 6839 :    }

	jmp	SHORT $LN11@fnCommitOb
$LN12@fnCommitOb:

; 6840 : 
; 6841 :    // If genkey work object defined, call genkey handler to commit genkeys.
; 6842 :    if ( lpKZGKHWOB )

	cmp	DWORD PTR _lpKZGKHWOB$[ebp], 0
	je	SHORT $LN27@fnCommitOb

; 6843 :    {
; 6844 :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN28@fnCommitOb

; 6845 :          (*pGKOper)( DBH_Commit, vSubtask, 0, 0, lpKZGKHWOB );

	mov	eax, DWORD PTR _lpKZGKHWOB$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	2
	call	DWORD PTR _pGKOper$[ebp]
	jmp	SHORT $LN29@fnCommitOb
$LN28@fnCommitOb:

; 6846 :       else
; 6847 :          (*pGKOper)( DBH_Rollback, vSubtask, 0, 0, lpKZGKHWOB );

	mov	edx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	4
	call	DWORD PTR _pGKOper$[ebp]
$LN29@fnCommitOb:

; 6848 : 
; 6849 :       fnDropObjectInstance( lpKZGKHWOB );

	mov	ecx, DWORD PTR _lpKZGKHWOB$[ebp]
	push	ecx
	call	_fnDropObjectInstance
	add	esp, 4
$LN27@fnCommitOb:

; 6850 :    }
; 6851 : 
; 6852 :    // End the transaction if the transaction was started in this function call.
; 6853 :    if ( bTransactionStartedHere || lControl & zCOMMIT_FORCETRAN )

	movzx	edx, BYTE PTR _bTransactionStartedHere$[ebp]
	test	edx, edx
	jne	SHORT $LN31@fnCommitOb
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN30@fnCommitOb
$LN31@fnCommitOb:

; 6854 :    {
; 6855 :       // We're about to close the transaction so set flag.
; 6856 :       lpTaskDBHandler->bTranStarted = FALSE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 6857 :       lpTaskDBHandler->lpConnection = 0;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 6858 : 
; 6859 :       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN32@fnCommitOb

; 6860 :       {
; 6861 :          // Call DBHandler routine to issue rollback.
; 6862 :          (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	16388					; 00004004H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]

; 6863 :                    DBH_Object | DBH_Rollback, 0, lpViewOD,
; 6864 :                    0, vSubtask, 0, &lpPtr );
; 6865 :       }

	jmp	SHORT $LN30@fnCommitOb
$LN32@fnCommitOb:

; 6866 :       else
; 6867 :       {
; 6868 :          // Incremental update succeeded; issue commit to DBhandler.
; 6869 :          nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	push	2
	push	16386					; 00004002H
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax
$LN30@fnCommitOb:

; 6870 :                          DBH_Object | DBH_Commit, DBH_StoreOI, lpViewOD, 0,
; 6871 :                          vSubtask, 0, &lpPtr );
; 6872 :       }
; 6873 :    }
; 6874 : 
; 6875 :    // If view was activated with locking then delete the locks.
; 6876 :    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN34@fnCommitOb

; 6877 :    {
; 6878 :       // A LOD has been committed using pessimistic locks.  Delete the locks
; 6879 :       // on the LODs.
; 6880 :       if ( fnRemoveLocksOnOIs( lpCurrentTask, lpViewCluster,
; 6881 :                                nViewCount, pnViewErrorIdx ) != 0 )

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nViewCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnRemoveLocksOnOIs@16
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN34@fnCommitOb

; 6882 :       {
; 6883 :          nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN34@fnCommitOb:

; 6884 :       }
; 6885 :    }
; 6886 : 
; 6887 :    // If the transaction failed, return an error.
; 6888 :    if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN36@fnCommitOb

; 6889 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnCommitOb
$LN36@fnCommitOb:

; 6890 : 
; 6891 :    // If the commit is OK and we have optimistic locking, then drop the
; 6892 :    // "old" OI and replace it with a copy of the new OI.
; 6893 :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN16@fnCommitOb
$LN14@fnCommitOb:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN16@fnCommitOb:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN15@fnCommitOb

; 6894 :    {
; 6895 :       zVIEW vTemp;
; 6896 : 
; 6897 :       if ( lpViewArray[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN37@fnCommitOb

; 6898 :          continue;

	jmp	SHORT $LN14@fnCommitOb
$LN37@fnCommitOb:

; 6899 : 
; 6900 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 6901 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 6902 : 
; 6903 :       if ( lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING &&

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	and	edx, 67108864				; 04000000H
	je	$LN38@fnCommitOb
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movzx	ecx, BYTE PTR [eax+236]
	cmp	ecx, 1
	je	SHORT $LN39@fnCommitOb
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+236]
	cmp	eax, 2
	jne	SHORT $LN38@fnCommitOb
$LN39@fnCommitOb:

; 6904 :            (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 6905 :             lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )
; 6906 :       {
; 6907 :          fnDropView( zGETPTR( lpViewOI->vOriginalOI ) );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4

; 6908 :          ActivateOI_FromOI_ForTask( &vTemp, lpViewArray[ k ], 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	lea	eax, DWORD PTR _vTemp$1[ebp]
	push	eax
	call	_ActivateOI_FromOI_ForTask@16

; 6909 :          lpViewOI->vOriginalOI = zGETHNDL( vTemp );

	mov	ecx, DWORD PTR _vTemp$1[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+40], eax

; 6910 :          vTemp->bOrigView      = TRUE;

	mov	eax, DWORD PTR _vTemp$1[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _vTemp$1[ebp]
	mov	DWORD PTR [edx+30], ecx

; 6911 :          vTemp->bViewLocked    = TRUE;

	mov	eax, DWORD PTR _vTemp$1[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _vTemp$1[ebp]
	mov	DWORD PTR [edx+30], ecx

; 6912 :          vTemp->hMainOI        = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _vTemp$1[ebp]
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR [eax+26], edx
$LN38@fnCommitOb:

; 6913 :       }
; 6914 : 
; 6915 :       if ( (lControl & zCOMMIT_NOCLEANUP) == 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 256				; 00000100H
	jne	SHORT $LN40@fnCommitOb

; 6916 :       {
; 6917 :          // Clean-up and reclaim hidden (i.e. deleted) instances.
; 6918 :          fnCleanupInstance( lpViewArray[ k ], 1 );

	push	1
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	call	_fnCleanupInstance
	add	esp, 8
$LN40@fnCommitOb:

; 6919 :       }
; 6920 : 
; 6921 :       // Mark the object instance as not updated.
; 6922 :       lpViewOI->bUpdated = lpViewOI->bUpdatedFile = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 6923 :    }

	jmp	$LN14@fnCommitOb
$LN15@fnCommitOb:

; 6924 : 
; 6925 :    return( 0 );

	xor	eax, eax
$LN1@fnCommitOb:

; 6926 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_fnCommitObjectInstance@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchOut$ = -20						; size = 4
_pchIn$ = -16						; size = 4
_nAvail$ = -12						; size = 2
_k$ = -8						; size = 2
_nChars$ = -4						; size = 2
_pchEncodedLine$ = 8					; size = 4
_pchBuffer$ = 12					; size = 4
_ulBufferLth$ = 16					; size = 4
_pulBufferPos$ = 20					; size = 4
_UUDECODE_NextLineToBuffer@16 PROC

; 14377: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	push	esi

; 14378: 
; 14379: // The decode macro subtracts 32 (a space) and masks the lower 6 bits
; 14380: #define DEC(c)  (((c) - 0x20) & 0x3F)
; 14381: 
; 14382:    zSHORT k, nChars, nAvail;
; 14383:    register zPCHAR pchIn;
; 14384:    register zPCHAR pchOut;
; 14385: 
; 14386:    nAvail = (zSHORT) (ulBufferLth - *pulBufferPos);

	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	mov	ecx, DWORD PTR _ulBufferLth$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	WORD PTR _nAvail$[ebp], cx

; 14387:    pchIn = pchEncodedLine;

	mov	edx, DWORD PTR _pchEncodedLine$[ebp]
	mov	DWORD PTR _pchIn$[ebp], edx

; 14388:    nChars = DEC( *pchIn );

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	mov	WORD PTR _nChars$[ebp], cx

; 14389:    if ( nChars == 0 )

	movsx	edx, WORD PTR _nChars$[ebp]
	test	edx, edx
	jne	SHORT $LN5@UUDECODE_N

; 14390:       return( 0 );

	xor	eax, eax
	jmp	$LN1@UUDECODE_N
$LN5@UUDECODE_N:

; 14391: 
; 14392:    if ( nChars > nAvail || nChars > 45 )

	movsx	eax, WORD PTR _nChars$[ebp]
	movsx	ecx, WORD PTR _nAvail$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN7@UUDECODE_N
	movsx	edx, WORD PTR _nChars$[ebp]
	cmp	edx, 45					; 0000002dH
	jle	SHORT $LN6@UUDECODE_N
$LN7@UUDECODE_N:

; 14393:    {
; 14394:       // no room left in buffer or invalid line length.
; 14395:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@UUDECODE_N
$LN6@UUDECODE_N:

; 14396:    }
; 14397: 
; 14398:    // check line length is correct
; 14399:    //    this can be eliminated if it is too much overhead
; 14400:    if ( (zUSHORT) zstrlen( pchEncodedLine ) != (zUSHORT) (((((nChars - 1) / 3) + 1) * 4) + 1))

	mov	eax, DWORD PTR _pchEncodedLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movzx	ecx, ax
	movsx	eax, WORD PTR _nChars$[ebp]
	sub	eax, 1
	cdq
	mov	esi, 3
	idiv	esi
	lea	edx, DWORD PTR [eax*4+5]
	movzx	eax, dx
	cmp	ecx, eax
	je	SHORT $LN8@UUDECODE_N

; 14401:    {
; 14402:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@UUDECODE_N
$LN8@UUDECODE_N:

; 14403:    }
; 14404: 
; 14405:    // fill the buffer (4 bytes go to 3)
; 14406:    pchOut = pchBuffer + *pulBufferPos;

	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _pchOut$[ebp], edx

; 14407:    for ( pchIn++, k = nChars; k > 0; pchIn += 4, k -= 3 )

	mov	eax, DWORD PTR _pchIn$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchIn$[ebp], eax
	mov	cx, WORD PTR _nChars$[ebp]
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@UUDECODE_N
$LN2@UUDECODE_N:
	mov	edx, DWORD PTR _pchIn$[ebp]
	add	edx, 4
	mov	DWORD PTR _pchIn$[ebp], edx
	movsx	eax, WORD PTR _k$[ebp]
	sub	eax, 3
	mov	WORD PTR _k$[ebp], ax
$LN4@UUDECODE_N:
	movsx	ecx, WORD PTR _k$[ebp]
	test	ecx, ecx
	jle	$LN3@UUDECODE_N

; 14408:    {
; 14409:       if ( k >= 3 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 3
	jl	$LN9@UUDECODE_N

; 14410:       {
; 14411:          *pchOut++ = DEC (*pchIn) << 2 | DEC (pchIn[ 1 ]) >> 4;

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 2
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [eax+edx]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	sar	edx, 4
	or	ecx, edx
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14412:          *pchOut++ = DEC (pchIn[ 1 ]) << 4 | DEC (pchIn[ 2 ]) >> 2;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 4
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [eax+edx]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	sar	edx, 2
	or	ecx, edx
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14413:          *pchOut++ = DEC (pchIn[ 2 ]) << 6 | DEC (pchIn[ 3 ]);

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 6
	mov	edx, 1
	imul	eax, edx, 3
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+eax]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	or	ecx, eax
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], cl
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14414:       }

	jmp	$LN10@UUDECODE_N
$LN9@UUDECODE_N:

; 14415:       else
; 14416:       {
; 14417:          if ( k >= 1 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 1
	jl	SHORT $LN11@UUDECODE_N

; 14418:          {
; 14419:             *pchOut++ = DEC (*pchIn) << 2 | DEC (pchIn[ 1 ]) >> 4;

	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	eax, 32					; 00000020H
	and	eax, 63					; 0000003fH
	shl	eax, 2
	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [edx+ecx]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	sar	ecx, 4
	or	eax, ecx
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax
$LN11@UUDECODE_N:

; 14420:          }
; 14421: 
; 14422:          if ( k >= 2 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 2
	jl	SHORT $LN10@UUDECODE_N

; 14423:          {
; 14424:             *pchOut++ = DEC (pchIn[ 1 ]) << 4 | DEC (pchIn[ 2 ]) >> 2;

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	sub	ecx, 32					; 00000020H
	and	ecx, 63					; 0000003fH
	shl	ecx, 4
	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [eax+edx]
	sub	edx, 32					; 00000020H
	and	edx, 63					; 0000003fH
	sar	edx, 2
	or	ecx, edx
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx
$LN10@UUDECODE_N:

; 14425:          }
; 14426:       }
; 14427:    }

	jmp	$LN2@UUDECODE_N
$LN3@UUDECODE_N:

; 14428: 
; 14429:    *pulBufferPos = *pulBufferPos + nChars;

	movsx	edx, WORD PTR _nChars$[ebp]
	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	DWORD PTR [ecx], edx

; 14430: 
; 14431:    return( nChars );

	mov	ax, WORD PTR _nChars$[ebp]
$LN1@UUDECODE_N:

; 14432: }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UUDECODE_NextLineToBuffer@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
tv229 = -52						; size = 4
tv216 = -48						; size = 4
tv196 = -44						; size = 4
tv177 = -40						; size = 4
tv163 = -36						; size = 4
tv141 = -32						; size = 4
tv95 = -28						; size = 4
tv77 = -24						; size = 4
_pchIn$ = -20						; size = 4
_pchOut$ = -16						; size = 4
_k$ = -12						; size = 2
_nChars$ = -8						; size = 2
_c$ = -1						; size = 1
_pchLineOut$ = 8					; size = 4
_pchBuffer$ = 12					; size = 4
_ulBufferLth$ = 16					; size = 4
_pulBufferPos$ = 20					; size = 4
_UUENCODE_NextEncodedLine@16 PROC

; 14259: {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 14260: 
; 14261: // The encode macro masks the lower 6 bits and adds 32 (a space), but
; 14262: // it translates a binary zero to a "`" rather than leaving it a space.
; 14263: // This is the generally accepted current technique (although not in the standard).
; 14264: #define ENC(c) ((c) ? ((c) & 0x3F) + 0x20: 0x60)
; 14265: 
; 14266:    zSHORT k, nChars;
; 14267:    zCHAR  c;
; 14268:    register zPCHAR pchIn;
; 14269:    register zPCHAR pchOut;
; 14270: 
; 14271:    pchOut = pchLineOut;

	mov	eax, DWORD PTR _pchLineOut$[ebp]
	mov	DWORD PTR _pchOut$[ebp], eax

; 14272:    nChars = (zSHORT) (ulBufferLth - *pulBufferPos);

	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	edx, DWORD PTR _ulBufferLth$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	WORD PTR _nChars$[ebp], dx

; 14273:    if ( nChars <= 0 )

	movsx	eax, WORD PTR _nChars$[ebp]
	test	eax, eax
	jg	SHORT $LN5@UUENCODE_N

; 14274:    {
; 14275:       // Buffer encoding complete
; 14276:       *pchOut++ = '`';

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14277:       *pchOut = 0;

	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax], 0

; 14278:       return( 0 );

	xor	eax, eax
	jmp	$LN1@UUENCODE_N
$LN5@UUENCODE_N:

; 14279:    }
; 14280: 
; 14281:    if ( nChars > 45 )

	movsx	ecx, WORD PTR _nChars$[ebp]
	cmp	ecx, 45					; 0000002dH
	jle	SHORT $LN6@UUENCODE_N

; 14282:       nChars = 45;

	mov	edx, 45					; 0000002dH
	mov	WORD PTR _nChars$[ebp], dx
$LN6@UUENCODE_N:

; 14283: 
; 14284:    // store the length as the first byte encoded
; 14285:    *pchOut++ = ENC( nChars );

	movsx	eax, WORD PTR _nChars$[ebp]
	test	eax, eax
	je	SHORT $LN12@UUENCODE_N
	movsx	ecx, WORD PTR _nChars$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, 32					; 00000020H
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN13@UUENCODE_N
$LN12@UUENCODE_N:
	mov	DWORD PTR tv77[ebp], 96			; 00000060H
$LN13@UUENCODE_N:
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR tv77[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14286:    pchIn = pchBuffer + *pulBufferPos;

	mov	edx, DWORD PTR _pulBufferPos$[ebp]
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	add	eax, DWORD PTR [edx]
	mov	DWORD PTR _pchIn$[ebp], eax

; 14287:    for ( k = nChars; k > 0; k -= 3, pchIn += 3 )

	mov	cx, WORD PTR _nChars$[ebp]
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@UUENCODE_N
$LN2@UUENCODE_N:
	movsx	edx, WORD PTR _k$[ebp]
	sub	edx, 3
	mov	WORD PTR _k$[ebp], dx
	mov	eax, DWORD PTR _pchIn$[ebp]
	add	eax, 3
	mov	DWORD PTR _pchIn$[ebp], eax
$LN4@UUENCODE_N:
	movsx	ecx, WORD PTR _k$[ebp]
	test	ecx, ecx
	jle	$LN3@UUENCODE_N

; 14288:    {
; 14289:       c = *pchIn >> 2;

	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx]
	sar	eax, 2
	mov	BYTE PTR _c$[ebp], al

; 14290:       *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $LN14@UUENCODE_N
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR tv95[ebp], edx
	jmp	SHORT $LN15@UUENCODE_N
$LN14@UUENCODE_N:
	mov	DWORD PTR tv95[ebp], 96			; 00000060H
$LN15@UUENCODE_N:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR tv95[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14291: 
; 14292:       if ( k == 1 )

	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 1
	jne	SHORT $LN7@UUENCODE_N

; 14293:       {
; 14294:          // only one byte valid - use 0 for next 2 input bytes
; 14295:          c = (*pchIn << 4) & 0x30;

	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx]
	shl	edx, 4
	and	edx, 48					; 00000030H
	mov	BYTE PTR _c$[ebp], dl

; 14296:          *pchOut++ = ENC( c );

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	SHORT $LN16@UUENCODE_N
	movsx	ecx, BYTE PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, 32					; 00000020H
	mov	DWORD PTR tv141[ebp], ecx
	jmp	SHORT $LN17@UUENCODE_N
$LN16@UUENCODE_N:
	mov	DWORD PTR tv141[ebp], 96		; 00000060H
$LN17@UUENCODE_N:
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR tv141[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14297:          *pchOut++ = ENC( 0 );

	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], 96			; 00000060H
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14298:          *pchOut++ = ENC( 0 );

	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx], 96			; 00000060H
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14299:       }

	jmp	$LN8@UUENCODE_N
$LN7@UUENCODE_N:

; 14300:       else
; 14301:       if ( k == 2 )

	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 2
	jne	$LN9@UUENCODE_N

; 14302:       {
; 14303:          // only 2 bytes valid - use 0 for last input byte
; 14304:          c = ((*pchIn << 4) & 0x30) | ((pchIn[ 1 ] >> 4) & 0x0F);

	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx]
	shl	edx, 4
	and	edx, 48					; 00000030H
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [ecx+eax]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	or	edx, eax
	mov	BYTE PTR _c$[ebp], dl

; 14305:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@UUENCODE_N
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR tv163[ebp], edx
	jmp	SHORT $LN19@UUENCODE_N
$LN18@UUENCODE_N:
	mov	DWORD PTR tv163[ebp], 96		; 00000060H
$LN19@UUENCODE_N:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR tv163[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14306:          c = (pchIn[ 1 ] << 2) & 0x3C;

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	shl	edx, 2
	and	edx, 60					; 0000003cH
	mov	BYTE PTR _c$[ebp], dl

; 14307:          *pchOut++ = ENC( c );

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	SHORT $LN20@UUENCODE_N
	movsx	ecx, BYTE PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, 32					; 00000020H
	mov	DWORD PTR tv177[ebp], ecx
	jmp	SHORT $LN21@UUENCODE_N
$LN20@UUENCODE_N:
	mov	DWORD PTR tv177[ebp], 96		; 00000060H
$LN21@UUENCODE_N:
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR tv177[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx

; 14308:          *pchOut++ = ENC( 0 );

	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], 96			; 00000060H
	mov	eax, DWORD PTR _pchOut$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOut$[ebp], eax

; 14309:       }

	jmp	$LN8@UUENCODE_N
$LN9@UUENCODE_N:

; 14310:       else
; 14311:       {
; 14312:          // all 3 bytes valid - use all 3 input bytes for the 4 output bytes
; 14313:          c = ((*pchIn << 4) & 0x30) | ((pchIn[ 1 ] >> 4) & 0x0F);

	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx]
	shl	edx, 4
	and	edx, 48					; 00000030H
	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [ecx+eax]
	sar	eax, 4
	and	eax, 15					; 0000000fH
	or	edx, eax
	mov	BYTE PTR _c$[ebp], dl

; 14314:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $LN22@UUENCODE_N
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR tv196[ebp], edx
	jmp	SHORT $LN23@UUENCODE_N
$LN22@UUENCODE_N:
	mov	DWORD PTR tv196[ebp], 96		; 00000060H
$LN23@UUENCODE_N:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR tv196[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14315:          c = ((pchIn[ 1 ] << 2) & 0x3C) | ((pchIn[ 2 ] >> 6) & 0x03);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	shl	edx, 2
	and	edx, 60					; 0000003cH
	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [ecx+eax]
	sar	eax, 6
	and	eax, 3
	or	edx, eax
	mov	BYTE PTR _c$[ebp], dl

; 14316:          *pchOut++ = ENC( c );

	movsx	ecx, BYTE PTR _c$[ebp]
	test	ecx, ecx
	je	SHORT $LN24@UUENCODE_N
	movsx	edx, BYTE PTR _c$[ebp]
	and	edx, 63					; 0000003fH
	add	edx, 32					; 00000020H
	mov	DWORD PTR tv216[ebp], edx
	jmp	SHORT $LN25@UUENCODE_N
$LN24@UUENCODE_N:
	mov	DWORD PTR tv216[ebp], 96		; 00000060H
$LN25@UUENCODE_N:
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR tv216[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pchOut$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOut$[ebp], edx

; 14317:          c = pchIn[ 2 ] & 0x3F;

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	and	edx, 63					; 0000003fH
	mov	BYTE PTR _c$[ebp], dl

; 14318:          *pchOut++ = ENC( c );

	movsx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	je	SHORT $LN26@UUENCODE_N
	movsx	ecx, BYTE PTR _c$[ebp]
	and	ecx, 63					; 0000003fH
	add	ecx, 32					; 00000020H
	mov	DWORD PTR tv229[ebp], ecx
	jmp	SHORT $LN27@UUENCODE_N
$LN26@UUENCODE_N:
	mov	DWORD PTR tv229[ebp], 96		; 00000060H
$LN27@UUENCODE_N:
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR tv229[ebp]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOut$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOut$[ebp], ecx
$LN8@UUENCODE_N:

; 14319:       }
; 14320:    }

	jmp	$LN2@UUENCODE_N
$LN3@UUENCODE_N:

; 14321: 
; 14322:    *pulBufferPos = *pulBufferPos + nChars;

	movsx	edx, WORD PTR _nChars$[ebp]
	mov	eax, DWORD PTR _pulBufferPos$[ebp]
	add	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pulBufferPos$[ebp]
	mov	DWORD PTR [ecx], edx

; 14323:    *pchOut = 0;

	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], 0

; 14324: 
; 14325:    return( 1 );

	mov	eax, 1
$LN1@UUENCODE_N:

; 14326: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_UUENCODE_NextEncodedLine@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpTask$1 = -1112					; size = 4
_lpViewCsr$ = -1108					; size = 4
_lpViewOI$ = -1104					; size = 4
_lpPrevHier$2 = -1100					; size = 4
_nChildLevel$3 = -1096					; size = 2
_lAttribCnt$4 = -1092					; size = 4
_lEntityCnt$ = -1088					; size = 4
_lpViewEntity$ = -1084					; size = 4
_nRC$ = -1080						; size = 2
_lpEntityInstance$ = -1076				; size = 4
_lpSrchViewEntity$5 = -1072				; size = 4
_k$ = -1068						; size = 4
_EntityList$ = -1064					; size = 800
_AttribList$ = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_fnOrderOI_ByDefaultAttribs PROC

; 13541: {

	push	ebp
	mov	ebp, esp
	sub	esp, 1112				; 00000458H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 13542:    struct EntityListStruct
; 13543:    {
; 13544:       LPVIEWENTITY   lpViewEntity;
; 13545:       LPVIEWATTRLIST lpPtr;
; 13546:    } EntityList[ MAX_SEQ_ENTS ];
; 13547: 
; 13548:    LPVIEWCSR          lpViewCsr;
; 13549:    LPVIEWOI           lpViewOI;
; 13550:    LPENTITYINSTANCE   lpEntityInstance;
; 13551:    LPVIEWENTITY       lpViewEntity;
; 13552:    ViewAttrListRecord AttribList[ MAX_SEQ_ATTS ];
; 13553:    zLONG              lEntityCnt;
; 13554:    zLONG              k;
; 13555:    zSHORT             nRC;
; 13556: 
; 13557:    // Fill EntityList with zeros.
; 13558:    zmemset( (zPVOID) EntityList, 0,

	push	800					; 00000320H
	push	0
	lea	eax, DWORD PTR _EntityList$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 13559:             sizeof( struct EntityListStruct ) * MAX_SEQ_ENTS );
; 13560:    lEntityCnt = 0;

	mov	DWORD PTR _lEntityCnt$[ebp], 0

; 13561: 
; 13562:    lpViewCsr        = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 13563:    lpViewOI         = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 13564: 
; 13565:    // For each of the entity instances, sort all groups of twin entities if
; 13566:    // the entity instance is the first twin.
; 13567:    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnOrderOI_
$LN2@fnOrderOI_:

; 13569:          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnOrderOI_:

; 13568:          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@fnOrderOI_

; 13570:    {
; 13571:       LPENTITYINSTANCE lpPrevHier;
; 13572: 
; 13573:       // Sort the group of entity instances if:
; 13574:       //    o  The entity instance is supposed to be sorted AND
; 13575:       //    o  The entity instance is the first twin (prev twin == 0) AND
; 13576:       //    o  There are more than 1 twins (next twin != 0).
; 13577: 
; 13578:       // If EI has a prev twin then it's not the first twin so don't bother
; 13579:       // sorting.
; 13580:       if ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN18@fnOrderOI_

; 13581:          continue;

	jmp	SHORT $LN2@fnOrderOI_
$LN18@fnOrderOI_:

; 13582: 
; 13583:       // If next twin is NULL then there is only one EI so there's nothing to
; 13584:       // sort.
; 13585:       if ( lpEntityInstance->hNextTwin == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	jne	SHORT $LN19@fnOrderOI_

; 13586:          continue;

	jmp	SHORT $LN2@fnOrderOI_
$LN19@fnOrderOI_:

; 13587: 
; 13588:       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13589: 
; 13590:       // If this entity doesn't have sorting attributes then skip it.
; 13591:       if ( lpViewEntity->bAutoSeq == FALSE && lpViewEntity->bAttrOrder == FALSE )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 20					; 00000014H
	and	edx, 1
	jne	SHORT $LN20@fnOrderOI_
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 18					; 00000012H
	and	ecx, 1
	jne	SHORT $LN20@fnOrderOI_

; 13592:          continue;

	jmp	SHORT $LN2@fnOrderOI_
$LN20@fnOrderOI_:

; 13593: 
; 13594:       // If we get here then we're going to sort the twins.  Save the prev
; 13595:       // hier EI of the current EI.  Once we are done sorting the EIs we can
; 13596:       // quickly find the first twin by using the prev hier ptr.
; 13597:       lpPrevHier = zGETPTR( lpEntityInstance->hPrevHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevHier$2[ebp], eax

; 13598: 
; 13599:       // First check to see if this lpViewEntity has been sorted already.
; 13600:       // If it has, then we already have the list of default sort attribs.
; 13601:       k = 0;

	mov	DWORD PTR _k$[ebp], 0
$LN5@fnOrderOI_:

; 13602:       while ( EntityList[ k ].lpViewEntity != lpViewEntity && k < lEntityCnt )

	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _EntityList$[ebp+ecx*8]
	cmp	edx, DWORD PTR _lpViewEntity$[ebp]
	je	SHORT $LN6@fnOrderOI_
	mov	eax, DWORD PTR _k$[ebp]
	cmp	eax, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $LN6@fnOrderOI_

; 13603:          k++;

	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
	jmp	SHORT $LN5@fnOrderOI_
$LN6@fnOrderOI_:

; 13604: 
; 13605:       // If k == lEntityCnt, then lpViewEntity has not been sorted yet.
; 13606:       // Go through each of the lpViewAttribs for the lpViewEntity and
; 13607:       // find all default sort attributes.
; 13608:       if ( k == lEntityCnt )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _lEntityCnt$[ebp]
	jne	$LN21@fnOrderOI_

; 13609:       {
; 13610:          zLONG  lAttribCnt;
; 13611: 
; 13612:          // If k >= MAX_SEQ_ENTS, then we have run out of space for entities.
; 13613:          if ( k >= MAX_SEQ_ENTS )

	cmp	DWORD PTR _k$[ebp], 100			; 00000064H
	jl	SHORT $LN22@fnOrderOI_

; 13614:          {
; 13615:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 13616:             // "KZOEE013 - Internal operation call error"
; 13617:             TraceLineS( "KZOEE013 - Internal operation call error: ",

	push	OFFSET $SG18134
	push	OFFSET $SG18135
	call	_TraceLineS@8

; 13618:                         "Out of space for entities" );
; 13619:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,

	push	OFFSET $SG18136
	push	OFFSET $SG18137
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13620:                               "Maximum # of order entities used",
; 13621:                               "fnOrderOI_ByDefaultAttribs" );
; 13622:             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOrderOI_
$LN22@fnOrderOI_:

; 13623:          }
; 13624: 
; 13625:          // Zero out attribute list.
; 13626:          lAttribCnt = 0;

	mov	DWORD PTR _lAttribCnt$4[ebp], 0

; 13627:          zmemset( (zPVOID) AttribList, 0,

	push	260					; 00000104H
	push	0
	lea	ecx, DWORD PTR _AttribList$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 13628:                   sizeof( ViewAttrListRecord ) * MAX_SEQ_ATTS );
; 13629: 
; 13630:          // Find all the sorting attributes and add them to AttribList.
; 13631:          nRC = fnGetSortAttrsFromEntity( lpView, &lAttribCnt, AttribList,

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _AttribList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lAttribCnt$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetSortAttrsFromEntity@16
	mov	WORD PTR _nRC$[ebp], ax

; 13632:                                          lpViewEntity );
; 13633: 
; 13634:          // If nRC != 0 then sorting is done by using autosequencing fields
; 13635:          // and there can be only one autoseq field per entity.  Otherwise
; 13636:          // check to see if the entity is sorted using child attributes and
; 13637:          // if so then add them to AttribList.
; 13638:          if ( nRC == 0 && lpViewEntity->bAttrOrderChild )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN23@fnOrderOI_
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 19					; 00000013H
	and	edx, 1
	je	$LN23@fnOrderOI_

; 13639:          {
; 13640:             LPVIEWENTITY lpSrchViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$5[ebp], eax
$LN7@fnOrderOI_:

; 13641: 
; 13642:             while ( lpSrchViewEntity &&

	cmp	DWORD PTR _lpSrchViewEntity$5[ebp], 0
	je	$LN23@fnOrderOI_
	mov	edx, DWORD PTR _lpSrchViewEntity$5[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jle	$LN23@fnOrderOI_

; 13643:                     lpSrchViewEntity->nLevel > lpViewEntity->nLevel )
; 13644:             {
; 13645:                // We can only sort using children that have a max cardinality
; 13646:                // of 1.  If it's greater than 1 then we can ignore it and all
; 13647:                // it's children.
; 13648:                if ( lpSrchViewEntity->uCardMax > 1 )

	mov	eax, DWORD PTR _lpSrchViewEntity$5[ebp]
	movzx	ecx, WORD PTR [eax+221]
	cmp	ecx, 1
	jle	SHORT $LN24@fnOrderOI_

; 13649:                {
; 13650:                   zSHORT nChildLevel;
; 13651: 
; 13652:                   // Entity doesn't have a twin so use next hier pointers to
; 13653:                   // skip the children.
; 13654:                   nChildLevel = lpSrchViewEntity->nLevel;

	mov	edx, DWORD PTR _lpSrchViewEntity$5[ebp]
	mov	ax, WORD PTR [edx+215]
	mov	WORD PTR _nChildLevel$3[ebp], ax

; 13655:                   for ( lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpSrchViewEntity$5[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$5[ebp], eax
	jmp	SHORT $LN11@fnOrderOI_
$LN9@fnOrderOI_:

; 13657:                         lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpSrchViewEntity$5[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$5[ebp], eax
$LN11@fnOrderOI_:

; 13656:                         lpSrchViewEntity;

	cmp	DWORD PTR _lpSrchViewEntity$5[ebp], 0
	je	SHORT $LN10@fnOrderOI_

; 13658:                   {
; 13659:                      if ( lpSrchViewEntity->nLevel > nChildLevel )

	mov	edx, DWORD PTR _lpSrchViewEntity$5[ebp]
	movsx	eax, WORD PTR [edx+215]
	movsx	ecx, WORD PTR _nChildLevel$3[ebp]
	cmp	eax, ecx
	jle	SHORT $LN25@fnOrderOI_

; 13660:                         break;

	jmp	SHORT $LN10@fnOrderOI_
$LN25@fnOrderOI_:

; 13661:                   }

	jmp	SHORT $LN9@fnOrderOI_
$LN10@fnOrderOI_:

; 13662: 
; 13663:                   continue;

	jmp	$LN7@fnOrderOI_
$LN24@fnOrderOI_:

; 13664:                }
; 13665: 
; 13666:                // If we get here then the max card is 1.
; 13667:                fnGetSortAttrsFromEntity( lpView, &lAttribCnt, AttribList,

	mov	edx, DWORD PTR _lpSrchViewEntity$5[ebp]
	push	edx
	lea	eax, DWORD PTR _AttribList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lAttribCnt$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnGetSortAttrsFromEntity@16

; 13668:                                          lpSrchViewEntity );
; 13669: 
; 13670:                lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpSrchViewEntity$5[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$5[ebp], eax

; 13671: 
; 13672:             } // while...

	jmp	$LN7@fnOrderOI_
$LN23@fnOrderOI_:

; 13673: 
; 13674:          } // if ( nRC == 0 && lpViewEntity->bAttrOrderChild )...
; 13675: 
; 13676:          // Allocate space to hold the attribute list.  We use
; 13677:          // "lAttribCnt + 1" to allocate space for the NULL attribute.
; 13678:          EntityList[ k ].lpPtr = (LPVIEWATTRLIST)

	push	10105					; 00002779H
	push	0
	push	0
	mov	edx, DWORD PTR _lAttribCnt$4[ebp]
	add	edx, 1
	imul	eax, edx, 13
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	eax, DWORD PTR [eax+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _EntityList$[ebp+ecx*8+4], eax

; 13679:                    fnAllocDataspace( ((LPTASK) zGETPTR (lpView->hTask))->hFirstDataHeader,
; 13680:                                      (sizeof( ViewAttrListRecord ) * (zULONG)
; 13681:                                         (lAttribCnt + 1)), 0, 0, iBuffer );
; 13682:          if ( EntityList[ k ].lpPtr == 0 )

	mov	edx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _EntityList$[ebp+edx*8+4], 0
	jne	SHORT $LN26@fnOrderOI_

; 13683:             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOrderOI_
$LN26@fnOrderOI_:

; 13684: 
; 13685:          EntityList[ k ].lpPtr = zGETPTR( EntityList[ k ].lpPtr );

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _EntityList$[ebp+eax*8+4]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _k$[ebp]
	mov	DWORD PTR _EntityList$[ebp+edx*8+4], eax

; 13686: 
; 13687:          // Copy attribute list + NULL attribute to entity list.
; 13688:          zmemcpy( (zPVOID) EntityList[ k ].lpPtr, (zPVOID) AttribList,

	mov	eax, DWORD PTR _lAttribCnt$4[ebp]
	add	eax, 1
	imul	ecx, eax, 13
	push	ecx
	lea	edx, DWORD PTR _AttribList$[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _EntityList$[ebp+eax*8+4]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 13689:                   sizeof( ViewAttrListRecord ) * (lAttribCnt + 1) );
; 13690:          EntityList[ k ].lpViewEntity = lpViewEntity;

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _EntityList$[ebp+edx*8], eax

; 13691: 
; 13692:          lEntityCnt++;

	mov	ecx, DWORD PTR _lEntityCnt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lEntityCnt$[ebp], ecx
$LN21@fnOrderOI_:

; 13693: 
; 13694:       } // if ( k == lEntityCnt )...
; 13695: 
; 13696:       nRC = fnOrderEntityForView( lpView, lpEntityInstance,

	push	0
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _EntityList$[ebp+edx*8+4]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13697:                                   EntityList[ k ].lpPtr, FALSE );
; 13698:       if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN27@fnOrderOI_

; 13699:       {
; 13700:          for ( k = 0; k < lEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN14@fnOrderOI_
$LN12@fnOrderOI_:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN14@fnOrderOI_:
	mov	edx, DWORD PTR _k$[ebp]
	cmp	edx, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $LN13@fnOrderOI_

; 13701:             fnFreeDataspace( EntityList[ k ].lpPtr );

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _EntityList$[ebp+eax*8+4]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $LN12@fnOrderOI_
$LN13@fnOrderOI_:

; 13702: 
; 13703:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnOrderOI_
$LN27@fnOrderOI_:

; 13704:       }
; 13705: 
; 13706:       // Set lpEntityInstance to be the first twin in its particular group.
; 13707:       if ( lpPrevHier )

	cmp	DWORD PTR _lpPrevHier$2[ebp], 0
	je	SHORT $LN28@fnOrderOI_

; 13708:          lpEntityInstance = zGETPTR( lpPrevHier->hNextHier );

	mov	edx, DWORD PTR _lpPrevHier$2[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN29@fnOrderOI_
$LN28@fnOrderOI_:

; 13709:       else
; 13710:          lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN29@fnOrderOI_:

; 13711: 
; 13712:    } // for ( lpEntityInstance )...

	jmp	$LN2@fnOrderOI_
$LN3@fnOrderOI_:

; 13713: 
; 13714:    for ( k = 0; k < lEntityCnt; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN17@fnOrderOI_
$LN15@fnOrderOI_:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN17@fnOrderOI_:
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _lEntityCnt$[ebp]
	jge	SHORT $LN16@fnOrderOI_

; 13715:       fnFreeDataspace( EntityList[ k ].lpPtr );

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _EntityList$[ebp+edx*8+4]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	jmp	SHORT $LN15@fnOrderOI_
$LN16@fnOrderOI_:

; 13716: 
; 13717:    return( 0 );

	xor	eax, eax
$LN1@fnOrderOI_:

; 13718: 
; 13719: } // fnOrderOI_ByDefaultAttribs

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnOrderOI_ByDefaultAttribs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpTask$1 = -552					; size = 4
_lAttribCnt$ = -548					; size = 4
_lpTopViewEntity$ = -544				; size = 4
_nRC$ = -540						; size = 2
_lpViewAttrib$ = -536					; size = 4
_lpViewEntity$ = -532					; size = 4
_nSeq$2 = -528						; size = 2
_AttribList$ = -524					; size = 520
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_fnOrderEntitiesByDefaultAttribs PROC

; 13781: {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
$LN2@fnOrderEnt:

; 13782:    ViewAttrListRecord AttribList[ 40 ]; // Max 40 attribs for sorting.
; 13783:    LPVIEWENTITY       lpViewEntity;
; 13784:    LPVIEWENTITY       lpTopViewEntity;
; 13785:    LPVIEWATTRIB       lpViewAttrib;
; 13786:    zLONG              lAttribCnt;
; 13787:    zSHORT             nRC;
; 13788: 
; 13789:    // Find first twin of lpEntityInstance.
; 13790:    while ( lpEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN3@fnOrderEnt

; 13791:       lpEntityInstance = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN2@fnOrderEnt
$LN3@fnOrderEnt:

; 13792: 
; 13793:    lpTopViewEntity = lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpTopViewEntity$[ebp], edx

; 13794: 
; 13795:    // Sort the group of entity instances if:
; 13796:    //   - The entity instance is supposed to be sorted AND
; 13797:    //   - There are more than 1 twins (next twin != 0).
; 13798:    if ( lpViewEntity->bAttrOrder == FALSE && lpViewEntity->bAutoSeq == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 18					; 00000012H
	and	ecx, 1
	jne	SHORT $LN10@fnOrderEnt
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	jne	SHORT $LN10@fnOrderEnt

; 13799:       return( 0 ); // No sorting for entity.

	xor	eax, eax
	jmp	$LN1@fnOrderEnt
$LN10@fnOrderEnt:

; 13800: 
; 13801:    if ( lpEntityInstance->hNextTwin == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	jne	SHORT $LN11@fnOrderEnt

; 13802:       return( 0 ); // Nothing to sort.

	xor	eax, eax
	jmp	$LN1@fnOrderEnt
$LN11@fnOrderEnt:

; 13803: 
; 13804:    zmemset( (zPVOID) AttribList, 0, sizeof( ViewAttrListRecord ) * 40 );

	push	520					; 00000208H
	push	0
	lea	edx, DWORD PTR _AttribList$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 13805:    lAttribCnt = 0;

	mov	DWORD PTR _lAttribCnt$[ebp], 0

; 13806: 
; 13807:    // Loop through all the attributes for the current entity and possibly
; 13808:    // loop through the attrs for child entities.
; 13809:    for ( ;

	jmp	SHORT $LN6@fnOrderEnt
$LN4@fnOrderEnt:

; 13811:             lpViewEntity == lpTopViewEntity;
; 13812:          lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN6@fnOrderEnt:

; 13810:          lpViewEntity->nLevel > lpTopViewEntity->nLevel ||

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpTopViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $LN12@fnOrderEnt
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	eax, DWORD PTR _lpTopViewEntity$[ebp]
	jne	$LN5@fnOrderEnt
$LN12@fnOrderEnt:

; 13813:    {
; 13814:       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN9@fnOrderEnt
$LN7@fnOrderEnt:

; 13816:             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN9@fnOrderEnt:

; 13815:             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN8@fnOrderEnt

; 13817:       {
; 13818:          zSHORT nSeq;
; 13819: 
; 13820:          // Forget about it if no sequencing value.
; 13821:          if ( lpViewAttrib->cSequencing == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	eax, BYTE PTR [edx+197]
	test	eax, eax
	jne	SHORT $LN13@fnOrderEnt

; 13822:             continue;

	jmp	SHORT $LN7@fnOrderEnt
$LN13@fnOrderEnt:

; 13823: 
; 13824:          nSeq = lpViewAttrib->cSequencing;

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	dx, BYTE PTR [ecx+197]
	mov	WORD PTR _nSeq$2[ebp], dx

; 13825:          if ( nSeq > 40 )

	movsx	eax, WORD PTR _nSeq$2[ebp]
	cmp	eax, 40					; 00000028H
	jle	SHORT $LN14@fnOrderEnt

; 13826:          {
; 13827:             LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 13828:             // "KZOEE013 - Internal operation call error"
; 13829:             TraceLineS( "KZOEE013 - Internal operation call error: ",

	push	OFFSET $SG18189
	push	OFFSET $SG18190
	call	_TraceLineS@8

; 13830:                         "Sequencing error > 40" );
; 13831:             fnIssueCoreError( lpTask, lpView, 16, 13, 0,

	push	OFFSET $SG18191
	push	OFFSET $SG18192
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13832:                               "Maximum # of order attributes used",
; 13833:                               "fnOrderEntitiesByDefaultAttribs" );
; 13834:             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnOrderEnt
$LN14@fnOrderEnt:

; 13835:          }
; 13836: 
; 13837:          if ( lAttribCnt < nSeq )

	movsx	edx, WORD PTR _nSeq$2[ebp]
	cmp	DWORD PTR _lAttribCnt$[ebp], edx
	jge	SHORT $LN15@fnOrderEnt

; 13838:             lAttribCnt = nSeq;

	movsx	eax, WORD PTR _nSeq$2[ebp]
	mov	DWORD PTR _lAttribCnt$[ebp], eax
$LN15@fnOrderEnt:

; 13839: 
; 13840:          AttribList[ nSeq - 1 ].lpViewAttrib = lpViewAttrib;

	movsx	ecx, WORD PTR _nSeq$2[ebp]
	sub	ecx, 1
	imul	edx, ecx, 13
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR _AttribList$[ebp+edx], eax

; 13841:          if ( lpViewAttrib->bSequencingD )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN16@fnOrderEnt

; 13842:             AttribList[ nSeq - 1 ].bOrder = TRUE;

	movsx	eax, WORD PTR _nSeq$2[ebp]
	sub	eax, 1
	imul	ecx, eax, 13
	mov	BYTE PTR _AttribList$[ebp+ecx+8], 1
$LN16@fnOrderEnt:

; 13843: 
; 13844:       } // for ( lpViewAttrib )...

	jmp	$LN7@fnOrderEnt
$LN8@fnOrderEnt:

; 13845: 
; 13846:       // If the top level entity isn't ordered by child entity attributes then
; 13847:       // we can break this loop.
; 13848:       if ( lpTopViewEntity->bAttrOrderChild == FALSE )

	mov	edx, DWORD PTR _lpTopViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 19					; 00000013H
	and	eax, 1
	jne	SHORT $LN17@fnOrderEnt

; 13849:          break;

	jmp	SHORT $LN5@fnOrderEnt
$LN17@fnOrderEnt:

; 13850: 
; 13851:    } // for ( lpViewEntity )...

	jmp	$LN4@fnOrderEnt
$LN5@fnOrderEnt:

; 13852: 
; 13853:    if ( lAttribCnt > 0 )

	cmp	DWORD PTR _lAttribCnt$[ebp], 0
	jle	SHORT $LN18@fnOrderEnt

; 13854:    {
; 13855:       nRC = fnOrderEntityForView( lpView, lpEntityInstance, AttribList, FALSE );

	push	0
	lea	ecx, DWORD PTR _AttribList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13856:       if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN18@fnOrderEnt

; 13857:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnOrderEnt
$LN18@fnOrderEnt:

; 13858:    }
; 13859: 
; 13860:    return( 0 );

	xor	eax, eax
$LN1@fnOrderEnt:

; 13861: 
; 13862: } // fnOrderEntitiesByDefaultAttribs

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnOrderEntitiesByDefaultAttribs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_ViewCluster$1 = -52					; size = 8
_lpViewOD$2 = -44					; size = 4
_lpSelectedInstance$ = -40				; size = 4
_lpViewSubobject$ = -36					; size = 4
_lpCurrentTask$3 = -32					; size = 4
_hViewCsr$ = -28					; size = 4
_lpWorkViewCsr$4 = -24					; size = 4
_lpView$ = -20						; size = 4
_lpViewOI$ = -16					; size = 4
_nRC$ = -12						; size = 2
_nState$5 = -8						; size = 2
_bMutexLocked$ = -1					; size = 1
_lpViewCsr$ = 8						; size = 4
_fnDropViewCsr PROC

; 8402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 8403 :    LPVIEWOI           lpViewOI;
; 8404 :    LPVIEWCSR          hViewCsr = (LPVIEWCSR) zGETHNDL( lpViewCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hViewCsr$[ebp], eax

; 8405 :    LPVIEWSUBOBJECT    lpViewSubobject;
; 8406 :    LPSELECTEDINSTANCE lpSelectedInstance;
; 8407 :    zVIEW              lpView;
; 8408 :    zBOOL              bMutexLocked;
; 8409 :    zSHORT             nRC;
; 8410 : 
; 8411 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $LN8@fnDropView

; 8412 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDropView
$LN8@fnDropView:

; 8413 : 
; 8414 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8415 : 
; 8416 : #ifdef __ACTIVATE_CONSTRAINTS__
; 8417 :    // Check to see if we are dropping the last ViewCsr for the OI.  If we are
; 8418 :    // then we need to call the DropOI constraint.
; 8419 :    if ( lpViewOI->hFirstViewCsr == hViewCsr && lpViewCsr->hNextViewCsr == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hViewCsr$[ebp]
	jne	$LN9@fnDropView
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+2], 0
	jne	$LN9@fnDropView

; 8420 :    {
; 8421 :       LPVIEWOD lpViewOD;
; 8422 : 
; 8423 :       // We are dropping the last view csr which means we are dropping the
; 8424 :       // OI as well.
; 8425 :       lpView   = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 8426 : 
; 8427 :       // If the OI has pessimistic locking then commit the OI to drop the
; 8428 :       // locks.
; 8429 :       if ( lpViewOI->bIsLocked )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 7
	and	eax, 1
	je	SHORT $LN10@fnDropView

; 8430 :       {
; 8431 :          ViewClusterRecord ViewCluster;
; 8432 : 
; 8433 :          ViewCluster.vOI      = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _ViewCluster$1[ebp], ecx

; 8434 :          ViewCluster.lControl = zCOMMIT_DROPLOCKSONLY;

	mov	DWORD PTR _ViewCluster$1[ebp+4], 2048	; 00000800H

; 8435 : 
; 8436 :          // We need to commit the object to release the pessimistic lock.
; 8437 :          nRC = CommitMultipleOIs( &ViewCluster, 1, 0, zCOMMIT_DROPLOCKSONLY );

	push	2048					; 00000800H
	push	0
	push	1
	lea	edx, DWORD PTR _ViewCluster$1[ebp]
	push	edx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax
$LN10@fnDropView:

; 8438 :       }
; 8439 : 
; 8440 :       // If object has drop oi constraint active, check for objections.
; 8441 :       lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$2[ebp], eax

; 8442 :       if ( lpViewOD->bDropOIConstraint )

	mov	edx, DWORD PTR _lpViewOD$2[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN9@fnDropView

; 8443 :       {
; 8444 :          zSHORT nState = 0;

	xor	ecx, ecx
	mov	WORD PTR _nState$5[ebp], cx

; 8445 :          LPTASK lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$3[ebp], eax

; 8446 : 
; 8447 :          if ( lpCurrentTask->bShutdown )

	mov	ecx, DWORD PTR _lpCurrentTask$3[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN12@fnDropView

; 8448 :             nState += zOCE_STATE_SHUTDOWN;

	movsx	eax, WORD PTR _nState$5[ebp]
	add	eax, 2
	mov	WORD PTR _nState$5[ebp], ax
$LN12@fnDropView:

; 8449 : 
; 8450 :          fnInvokeOCEOperation( zGETPTR( lpViewCsr->hView ),

	movzx	ecx, WORD PTR _nState$5[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _lpCurrentTask$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H

; 8451 :                                lpCurrentTask, zOCE_DROPOI, nState );
; 8452 :          lpViewOI->bDropConstraintInvoked = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN9@fnDropView:

; 8453 :       }
; 8454 :    }
; 8455 : #endif
; 8456 : 
; 8457 :    if ( lpViewOI->hTask == AnchorBlock->hMainTask )  // added dks

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN13@fnDropView

; 8458 :    {
; 8459 :       bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$[ebp], 1

; 8460 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 8461 :    }

	jmp	SHORT $LN14@fnDropView
$LN13@fnDropView:

; 8462 :    else
; 8463 :       bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$[ebp], 0
$LN14@fnDropView:

; 8464 : 
; 8465 :    // Unchain ViewCsr from View OI.
; 8466 :    if ( lpViewOI->hFirstViewCsr == hViewCsr )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+10]
	cmp	eax, DWORD PTR _hViewCsr$[ebp]
	jne	SHORT $LN15@fnDropView

; 8467 :       lpViewOI->hFirstViewCsr = lpViewCsr->hNextViewCsr;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+10], eax
	jmp	SHORT $LN4@fnDropView
$LN15@fnDropView:

; 8468 :    else
; 8469 :    {
; 8470 :       LPVIEWCSR lpWorkViewCsr;
; 8471 : 
; 8472 :       lpWorkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr ); // blew on this line 2006.07.03 dks

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewCsr$4[ebp], eax
$LN2@fnDropView:

; 8473 :       while ( lpWorkViewCsr->hNextViewCsr != hViewCsr )

	mov	eax, DWORD PTR _lpWorkViewCsr$4[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hViewCsr$[ebp]
	je	SHORT $LN3@fnDropView

; 8474 :          lpWorkViewCsr = zGETPTR( lpWorkViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpWorkViewCsr$4[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewCsr$4[ebp], eax
	jmp	SHORT $LN2@fnDropView
$LN3@fnDropView:

; 8475 : 
; 8476 :       lpWorkViewCsr->hNextViewCsr = lpViewCsr->hNextViewCsr;

	mov	ecx, DWORD PTR _lpWorkViewCsr$4[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax
$LN4@fnDropView:

; 8477 :    }
; 8478 : 
; 8479 :    while ( lpViewCsr->hFirstViewSubobject )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN6@fnDropView

; 8480 :    {
; 8481 :       lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 8482 :       lpViewCsr->hFirstViewSubobject = lpViewSubobject->hNextViewSubobject;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+30], eax

; 8483 :       fnFreeDataspace( lpViewSubobject );

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8484 :    }

	jmp	SHORT $LN4@fnDropView
$LN6@fnDropView:

; 8485 : 
; 8486 :    while ( lpViewCsr->hFirstSelectedInstance )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN7@fnDropView

; 8487 :    {
; 8488 :       lpSelectedInstance = zGETPTR( lpViewCsr->hFirstSelectedInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstance$[ebp], eax

; 8489 :       lpViewCsr->hFirstSelectedInstance =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+42], ecx

; 8490 :                               lpSelectedInstance->hNextSelectedInstance;
; 8491 :       fnFreeDataspace( lpSelectedInstance );

	mov	edx, DWORD PTR _lpSelectedInstance$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 8492 :    }

	jmp	SHORT $LN6@fnDropView
$LN7@fnDropView:

; 8493 : 
; 8494 :    // If the view which used to point to us *still* points to us, then
; 8495 :    // zero out the pointer since we are going away.
; 8496 :    lpView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 8497 :    if ( lpView && lpView->hViewCsr == hViewCsr )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN17@fnDropView
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	cmp	eax, DWORD PTR _hViewCsr$[ebp]
	jne	SHORT $LN17@fnDropView

; 8498 :       lpView->hViewCsr = 0;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+10], 0
$LN17@fnDropView:

; 8499 : 
; 8500 :    fnFreeDataspace( lpViewCsr );  // should this line be moved to after the following if block?? dks 2006.07.19

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 8501 : 
; 8502 :    // If the ViewOI has no more cursors, drop it!
; 8503 :    if ( lpViewOI->hFirstViewCsr == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN18@fnDropView

; 8504 :       fnDropViewOI( lpViewOI );  // dks 2006.09.18 error while cleaning up client OE

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	_fnDropViewOI
	add	esp, 4
$LN18@fnDropView:

; 8505 : 
; 8506 :    if ( bMutexLocked )

	movzx	edx, BYTE PTR _bMutexLocked$[ebp]
	test	edx, edx
	je	SHORT $LN19@fnDropView

; 8507 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN19@fnDropView:

; 8508 : 
; 8509 :    return( 0 );

	xor	eax, eax
$LN1@fnDropView:

; 8510 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropViewCsr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_hTaskGKHandler$1 = -164				; size = 4
_lProcessID$ = -160					; size = 4
_nRC$ = -156						; size = 2
_hLibrary$ = -152					; size = 4
_lpGKHandler$ = -148					; size = 4
_pGKOper$ = -144					; size = 4
_lpTaskGKHandler$ = -140				; size = 4
_szLibName$2 = -136					; size = 100
_szFuncName$3 = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_vSubtask$ = 8						; size = 4
_lpTask$ = 12						; size = 4
_hGKHandler$ = 16					; size = 4
_pOperReturn$ = 20					; size = 4
_fnGetGKHandlerOper PROC

; 3463 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3464 :    LPGKHANDLER      lpGKHandler;
; 3465 :    LPTASKGKHANDLER  lpTaskGKHandler;
; 3466 :    LPLIBRARY        hLibrary;
; 3467 :    zPGKHOPER        pGKOper;
; 3468 :    zSHORT           nRC;
; 3469 :    zLONG            lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 3470 : 
; 3471 :    lpGKHandler = zGETPTR( hGKHandler );

	mov	eax, DWORD PTR _hGKHandler$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$[ebp], eax

; 3472 : 
; 3473 :    // Make sure DBHandler can be found.
; 3474 :    if ( lpGKHandler == 0 )

	cmp	DWORD PTR _lpGKHandler$[ebp], 0
	jne	SHORT $LN5@fnGetGKHan

; 3475 :    {
; 3476 :       // "KZOEE081 - Object Definition does not have a Genkey handler
; 3477 :       // specified"
; 3478 :       fnIssueCoreError( lpTask, vSubtask, 8, 81, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	81					; 00000051H
	push	8
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3479 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetGKHan
$LN5@fnGetGKHan:

; 3480 :    }
; 3481 : 
; 3482 :    // See if GKHandler has already been invoked for this task.
; 3483 :    for ( lpTaskGKHandler = zGETPTR( lpTask->hFirstTaskGKHandler );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+138]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax
	jmp	SHORT $LN4@fnGetGKHan
$LN2@fnGetGKHan:

; 3485 :          lpTaskGKHandler = zGETPTR( lpTaskGKHandler->hNextTaskGKHandler ) )

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax
$LN4@fnGetGKHan:

; 3484 :          lpTaskGKHandler;

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	je	SHORT $LN3@fnGetGKHan

; 3486 :    {
; 3487 :       if ( lpTaskGKHandler->lProcessID != lProcessID )

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN6@fnGetGKHan

; 3488 :          continue;

	jmp	SHORT $LN2@fnGetGKHan
$LN6@fnGetGKHan:

; 3489 : 
; 3490 :       if ( lpTaskGKHandler->hGKHandler != hGKHandler )

	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	cmp	ecx, DWORD PTR _hGKHandler$[ebp]
	je	SHORT $LN7@fnGetGKHan

; 3491 :          continue;

	jmp	SHORT $LN2@fnGetGKHan
$LN7@fnGetGKHan:

; 3492 : 
; 3493 :       // If we get here we found the GKHandler that we want.
; 3494 :       break;

	jmp	SHORT $LN3@fnGetGKHan

; 3495 :    }

	jmp	SHORT $LN2@fnGetGKHan
$LN3@fnGetGKHan:

; 3496 : 
; 3497 :    // If TaskGKHandler wasn't found, then this is the first time the
; 3498 :    // GKHandler has been called for this task.
; 3499 :    if ( lpTaskGKHandler )

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	je	SHORT $LN8@fnGetGKHan

; 3500 :    {
; 3501 :       // The task DBHandler was found--return pointer to DBHandler routine.
; 3502 :       pGKOper = lpTaskGKHandler->pfGKHandlerOper;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3503 :    }

	jmp	$LN9@fnGetGKHan
$LN8@fnGetGKHan:

; 3504 :    else
; 3505 :    {
; 3506 :       zCHAR  szFuncName[ 30 ];
; 3507 :       zPVOID hTaskGKHandler;
; 3508 : 
; 3509 :       // Load the DBHandler library.  If it can't be found, return with error.
; 3510 :       if ( zstrncmp( lpGKHandler->szName, "KZ", 2 ) == 0 )

	push	2
	push	OFFSET $SG14529
	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@fnGetGKHan

; 3511 :       {
; 3512 :          // If handler name starts with KZ, then load handler from Zeidon
; 3513 :          // bin directory.
; 3514 :          zCHAR szLibName[ 100 ];
; 3515 : 
; 3516 :          zstrcpy( szLibName, AnchorBlock->szZeidonBin );

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 395				; 0000018bH
	push	edx
	lea	eax, DWORD PTR _szLibName$2[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 3517 :          zstrcat( szLibName, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szLibName$2[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3518 : 
; 3519 :          TraceLineS( "(oi) Attempting to load GK-handler as ", szLibName );

	lea	eax, DWORD PTR _szLibName$2[ebp]
	push	eax
	push	OFFSET $SG14530
	call	_TraceLineS@8

; 3520 :          hLibrary = SysLoadLibrary( vSubtask, szLibName );

	lea	ecx, DWORD PTR _szLibName$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3521 :       }

	jmp	SHORT $LN11@fnGetGKHan
$LN10@fnGetGKHan:

; 3522 :       else
; 3523 :       {
; 3524 :          TraceLineS( "(oi) Attempting to load GK-handler as ",

	mov	eax, DWORD PTR _lpGKHandler$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14531
	call	_TraceLineS@8

; 3525 :                      lpGKHandler->szName );
; 3526 :          hLibrary = SysLoadLibrary( vSubtask, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax
$LN11@fnGetGKHan:

; 3527 :       }
; 3528 : 
; 3529 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $LN12@fnGetGKHan

; 3530 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetGKHan
$LN12@fnGetGKHan:

; 3531 : 
; 3532 :       pGKOper = (zPGKHOPER) SysGetProc( hLibrary, "GKH_MsgProc" );

	push	OFFSET $SG14533
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3533 :       if ( pGKOper == 0 )

	cmp	DWORD PTR _pGKOper$[ebp], 0
	jne	SHORT $LN13@fnGetGKHan

; 3534 :       {
; 3535 :          // Try the old style name.
; 3536 :          zstrcpy( (zPCHAR) szFuncName, lpGKHandler->szName );

	mov	ecx, DWORD PTR _lpGKHandler$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	lea	edx, DWORD PTR _szFuncName$3[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3537 :          zstrcat( (zPCHAR) szFuncName, "_GKH_MsgProc" );

	push	OFFSET $SG14535
	lea	eax, DWORD PTR _szFuncName$3[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3538 : 
; 3539 :          // Find the address of entry func.  If it can't be found, return with
; 3540 :          // an error.
; 3541 :          pGKOper = (zPGKHOPER) SysGetProc( hLibrary, szFuncName );

	lea	ecx, DWORD PTR _szFuncName$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pGKOper$[ebp], eax

; 3542 :          if ( pGKOper == 0 )

	cmp	DWORD PTR _pGKOper$[ebp], 0
	jne	SHORT $LN13@fnGetGKHan

; 3543 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetGKHan
$LN13@fnGetGKHan:

; 3544 :       }
; 3545 : 
; 3546 :       // Call gkhandler routine to issue start of transaction.  Bomb out if
; 3547 :       // it doesn't work.
; 3548 :       nRC = (*pGKOper)( DBH_Init, vSubtask, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	4096					; 00001000H
	call	DWORD PTR _pGKOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3549 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN15@fnGetGKHan

; 3550 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnGetGKHan
$LN15@fnGetGKHan:

; 3551 : 
; 3552 :       // Create TaskGKHandler object and attatch to Task.
; 3553 :       hTaskGKHandler = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10036					; 00002734H
	push	0
	push	1
	push	26					; 0000001aH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskGKHandler$1[ebp], eax

; 3554 :                                          sizeof( TaskGKHandlerRecord ), 1, 0,
; 3555 :                                          iTaskGKHandler );
; 3556 :       lpTaskGKHandler = zGETPTR( hTaskGKHandler );

	mov	ecx, DWORD PTR _hTaskGKHandler$1[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax

; 3557 :       if ( lpTaskGKHandler == 0 )

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	jne	SHORT $LN16@fnGetGKHan

; 3558 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnGetGKHan
$LN16@fnGetGKHan:

; 3559 : 
; 3560 :       lpTaskGKHandler->hLibrary        = hLibrary;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+10], eax

; 3561 :       lpTaskGKHandler->pfGKHandlerOper = pGKOper;

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR _pGKOper$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 3562 :       lpTaskGKHandler->hGKHandler      = hGKHandler;

	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR _hGKHandler$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 3563 :       lpTaskGKHandler->lProcessID      = lProcessID;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+22], eax

; 3564 : 
; 3565 :       // Insert lpTaskGKHandler into lpTask chain.
; 3566 :       lpTaskGKHandler->hNextTaskGKHandler = lpTask->hFirstTaskGKHandler;

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+138]
	mov	DWORD PTR [ecx+2], eax

; 3567 :       lpTask->hFirstTaskGKHandler = hTaskGKHandler;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hTaskGKHandler$1[ebp]
	mov	DWORD PTR [ecx+138], edx
$LN9@fnGetGKHan:

; 3568 : 
; 3569 :    }  // if ( lpTaskGKHandler )...else...
; 3570 : 
; 3571 :    *pOperReturn = pGKOper;

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	ecx, DWORD PTR _pGKOper$[ebp]
	mov	DWORD PTR [eax], ecx

; 3572 : 
; 3573 :    return( 0 );

	xor	eax, eax
$LN1@fnGetGKHan:

; 3574 : 
; 3575 : } // fnGetGKHandlerOper

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetGKHandlerOper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpPtr$ = -176						; size = 4
_hTaskDBHandler$1 = -172				; size = 4
_lProcessID$ = -168					; size = 4
_lpViewOD$ = -164					; size = 4
_hDBHandler$ = -160					; size = 4
_nRC$ = -156						; size = 2
_hLibrary$ = -152					; size = 4
_lpDBHandler$ = -148					; size = 4
_pOper$ = -144						; size = 4
_lpTaskDBHandler$ = -140				; size = 4
_szLibName$2 = -136					; size = 100
_szFuncName$3 = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpView$ = 12						; size = 4
_pOperReturn$ = 16					; size = 4
_fnGetDBHandlerOper@12 PROC

; 3319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 176				; 000000b0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3320 :    LPDBHANDLER      hDBHandler;
; 3321 :    LPDBHANDLER      lpDBHandler;
; 3322 :    LPTASKDBHANDLER  lpTaskDBHandler;
; 3323 :    LPVIEWOD         lpViewOD;
; 3324 :    LPLIBRARY        hLibrary;
; 3325 :    zPVOID           lpPtr;
; 3326 :    zPDBHOPER        pOper;
; 3327 :    zSHORT           nRC;
; 3328 :    zLONG            lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 3329 : 
; 3330 :    *pOperReturn = 0;  // initialize

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	DWORD PTR [eax], 0

; 3331 : 
; 3332 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3333 :    hDBHandler = lpViewOD->hDBHandler;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	mov	DWORD PTR _hDBHandler$[ebp], ecx

; 3334 :    lpDBHandler = zGETPTR( hDBHandler );

	mov	edx, DWORD PTR _hDBHandler$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$[ebp], eax

; 3335 : // lpDBHandler = fnGetDBHandler( hTask, lpViewOD->szDBHandler );
; 3336 : 
; 3337 :    // Make sure DBHandler can be found.
; 3338 :    if ( lpDBHandler == 0 )

	cmp	DWORD PTR _lpDBHandler$[ebp], 0
	jne	SHORT $LN5@fnGetDBHan

; 3339 :    {
; 3340 :       // "KZOEE080 - Object Definition does not have a Database handler
; 3341 :       // specified"
; 3342 :       fnIssueCoreError( lpTask, lpView, 8, 80, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	80					; 00000050H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3343 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetDBHan
$LN5@fnGetDBHan:

; 3344 :    }
; 3345 : 
; 3346 :    // See if DBHandler has already been invoked for this task.
; 3347 :    for ( lpTaskDBHandler = zGETPTR( lpTask->hFirstTaskDBHandler );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+134]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
	jmp	SHORT $LN4@fnGetDBHan
$LN2@fnGetDBHan:

; 3349 :          lpTaskDBHandler = zGETPTR( lpTaskDBHandler->hNextTaskDBHandler ) )

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
$LN4@fnGetDBHan:

; 3348 :          lpTaskDBHandler;

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $LN3@fnGetDBHan

; 3350 :    {
; 3351 :       if ( lpTaskDBHandler->hDBHandler != hDBHandler )

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	cmp	ecx, DWORD PTR _hDBHandler$[ebp]
	je	SHORT $LN6@fnGetDBHan

; 3352 :          continue;

	jmp	SHORT $LN2@fnGetDBHan
$LN6@fnGetDBHan:

; 3353 : 
; 3354 :       if ( lpTaskDBHandler->lProcessID != lProcessID )

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+22]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN7@fnGetDBHan

; 3355 :          continue;

	jmp	SHORT $LN2@fnGetDBHan
$LN7@fnGetDBHan:

; 3356 : 
; 3357 :       // If we get here then we found the one we're looking for
; 3358 :       break;

	jmp	SHORT $LN3@fnGetDBHan

; 3359 :    }

	jmp	SHORT $LN2@fnGetDBHan
$LN3@fnGetDBHan:

; 3360 : 
; 3361 :    // If TaskDBHandler wasn't found, then this is the first time the
; 3362 :    // DBHandler has been called for this task.
; 3363 :    if ( lpTaskDBHandler )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $LN8@fnGetDBHan

; 3364 :    {
; 3365 :       // The task DBHandler was found--return pointer to DBHandler routine.
; 3366 :       pOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _pOper$[ebp], edx

; 3367 :    }

	jmp	$LN9@fnGetDBHan
$LN8@fnGetDBHan:

; 3368 :    else
; 3369 :    {
; 3370 :       zPVOID hTaskDBHandler;
; 3371 :       zCHAR  szFuncName[ 30 ];
; 3372 : 
; 3373 :       // Load the DBHandler library.  If it can't be found, return with error.
; 3374 :       if ( zstrncmpi( lpDBHandler->szName, "KZ", 2 ) == 0 )

	push	2
	push	OFFSET $SG14484
	mov	eax, DWORD PTR _lpDBHandler$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN10@fnGetDBHan

; 3375 :       {
; 3376 :          // If handler name starts with KZ, then load handler from Zeidon
; 3377 :          // bin directory.
; 3378 :          zCHAR szLibName[ 100 ];
; 3379 : 
; 3380 :          zstrcpy( szLibName, AnchorBlock->szZeidonBin );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 395				; 0000018bH
	push	ecx
	lea	edx, DWORD PTR _szLibName$2[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3381 :          zstrcat( szLibName, lpDBHandler->szName );

	mov	eax, DWORD PTR _lpDBHandler$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	lea	ecx, DWORD PTR _szLibName$2[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3382 :          hLibrary = SysLoadLibrary( lpView, szLibName );

	lea	edx, DWORD PTR _szLibName$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 3383 :       }

	jmp	SHORT $LN11@fnGetDBHan
$LN10@fnGetDBHan:

; 3384 :       else
; 3385 :          hLibrary = SysLoadLibrary( lpView, lpDBHandler->szName );

	mov	ecx, DWORD PTR _lpDBHandler$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax
$LN11@fnGetDBHan:

; 3386 : 
; 3387 :       if ( hLibrary == 0 )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	jne	SHORT $LN12@fnGetDBHan

; 3388 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetDBHan
$LN12@fnGetDBHan:

; 3389 : 
; 3390 :       // Define entry function name.  First try the default name.
; 3391 :       pOper = (zPDBHOPER) SysGetProc( hLibrary, "DBH_MsgProc" );

	push	OFFSET $SG14486
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	DWORD PTR _pOper$[ebp], eax

; 3392 :       if ( pOper == 0 )

	cmp	DWORD PTR _pOper$[ebp], 0
	jne	SHORT $LN13@fnGetDBHan

; 3393 :       {
; 3394 :          // Couldn't find the default name.  Try the old-style name.
; 3395 :          zstrcpy( (zPCHAR) szFuncName, lpDBHandler->szName );

	mov	ecx, DWORD PTR _lpDBHandler$[ebp]
	add	ecx, 11					; 0000000bH
	push	ecx
	lea	edx, DWORD PTR _szFuncName$3[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3396 :          zstrcat( (zPCHAR) szFuncName, "_DBH_MsgProc" );

	push	OFFSET $SG14488
	lea	eax, DWORD PTR _szFuncName$3[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3397 : 
; 3398 :          // Find the address of entry func.  If it can't be found, return with
; 3399 :          // an error.
; 3400 :          pOper = (zPDBHOPER) SysGetProc( hLibrary, szFuncName );

	lea	ecx, DWORD PTR _szFuncName$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _hLibrary$[ebp]
	push	edx
	call	_SysGetProc@8
	mov	DWORD PTR _pOper$[ebp], eax

; 3401 :          if ( pOper == 0 )

	cmp	DWORD PTR _pOper$[ebp], 0
	jne	SHORT $LN13@fnGetDBHan

; 3402 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetDBHan
$LN13@fnGetDBHan:

; 3403 :       }
; 3404 : 
; 3405 :       // Call DBHandler routine to issue start of transaction.  Bomb out if
; 3406 :       // it doesn't work.
; 3407 :       lpPtr = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 3408 :       nRC = (*pOper)( (zLONG) zGETHNDL( lpTask ), DBH_Init, 0,

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	0
	push	4096					; 00001000H
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 3409 :                       lpViewOD, 0, lpView, 0, (zPVOID) &lpPtr );
; 3410 :       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN15@fnGetDBHan

; 3411 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetDBHan
$LN15@fnGetDBHan:

; 3412 : 
; 3413 :       // Create TaskDBHandler object and attach to Task.
; 3414 :       hTaskDBHandler = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10009					; 00002719H
	push	0
	push	1
	push	30					; 0000001eH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskDBHandler$1[ebp], eax

; 3415 :                                          sizeof( TaskDBHandlerRecord ), 1, 0,
; 3416 :                                          iTaskDBHandler );
; 3417 :       lpTaskDBHandler = zGETPTR( hTaskDBHandler );

	mov	ecx, DWORD PTR _hTaskDBHandler$1[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 3418 :       if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $LN16@fnGetDBHan

; 3419 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetDBHan
$LN16@fnGetDBHan:

; 3420 : 
; 3421 :       lpTaskDBHandler->hLibrary        = hLibrary;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+10], eax

; 3422 :       lpTaskDBHandler->pfDBHandlerOper = pOper;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _pOper$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 3423 :       lpTaskDBHandler->hDBHandler      = hDBHandler;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR _hDBHandler$[ebp]
	mov	DWORD PTR [eax+6], ecx

; 3424 :       lpTaskDBHandler->lProcessID      = lProcessID;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+22], eax

; 3425 : 
; 3426 :       // Insert lpTaskDBHandler into lpTask chain.
; 3427 :       lpTaskDBHandler->hNextTaskDBHandler = lpTask->hFirstTaskDBHandler;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+134]
	mov	DWORD PTR [ecx+2], eax

; 3428 :       lpTask->hFirstTaskDBHandler = hTaskDBHandler;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hTaskDBHandler$1[ebp]
	mov	DWORD PTR [ecx+134], edx
$LN9@fnGetDBHan:

; 3429 :    }  // if ( lpTaskDBHandler )...else...
; 3430 : 
; 3431 :    *pOperReturn = pOper;

	mov	eax, DWORD PTR _pOperReturn$[ebp]
	mov	ecx, DWORD PTR _pOper$[ebp]
	mov	DWORD PTR [eax], ecx

; 3432 : 
; 3433 : // TraceLine( "fnGetDBHandlerOper in Process: %d   looking for DBHandler: 0x%08x for Task: %d (0x%08x)   Name: %s",
; 3434 : //            lProcessID, zGETHNDL( lpDBHandler ), hTask, hTask, lpTaskDBHandler->szName );
; 3435 : 
; 3436 :    return( lpTaskDBHandler );

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
$LN1@fnGetDBHan:

; 3437 : 
; 3438 : } // fnGetDBHandlerOper

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnGetDBHandlerOper@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpLinkedViewEntity$1 = -60				; size = 4
_lpLinkedViewEntity$2 = -56				; size = 4
_lpNextViewCsr$3 = -52					; size = 4
_lpAttribFlags$4 = -48					; size = 4
_lpRootEntityInstance$ = -44				; size = 4
_lpViewOI$ = -40					; size = 4
_lpViewEntity$ = -36					; size = 4
_lpParent$5 = -32					; size = 4
_lpViewAttrib$6 = -28					; size = 4
_lpWrkViewCsr$ = -24					; size = 4
_lpViewCsr$ = -20					; size = 4
_lpViewEntityCsr$7 = -16				; size = 4
_lpNextLinked$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_uIdx$8 = -4						; size = 2
_lpView$ = 8						; size = 4
_lHiddenCnt$ = 12					; size = 4
_fnCleanupInstance PROC

; 5718 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 5719 :    LPVIEWCSR         lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 5720 :    LPVIEWOI          lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 5721 :    LPVIEWENTITY      lpViewEntity;
; 5722 :    LPENTITYINSTANCE  lpRootEntityInstance;
; 5723 :    LPENTITYINSTANCE  lpEntityInstance;
; 5724 :    LPENTITYINSTANCE  lpNextLinked;
; 5725 :    LPVIEWCSR         lpWrkViewCsr;
; 5726 : 
; 5727 :    // Clean up any view cursors which point to a hidden entity
; 5728 :    // If the root was deleted, delete all view cursors except the one
; 5729 :    // used in this call - REMOVED 1/22/93...Causes reclamation problems and
; 5730 :    // also does not account for multiple roots in the instance, the
; 5731 :    // reclamation code below will clean up the instance except for
; 5732 :    // the deleted root, This is enough cleanup under the circumstances
; 5733 :    // 1/22/93 ... Gig
; 5734 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 5735 :    lpWrkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
$LN2@fnCleanupI:

; 5736 :    while ( lpWrkViewCsr )

	cmp	DWORD PTR _lpWrkViewCsr$[ebp], 0
	je	$LN3@fnCleanupI

; 5737 :    {
; 5738 :       LPVIEWCSR lpNextViewCsr;
; 5739 : 
; 5740 :       lpNextViewCsr = zGETPTR( lpWrkViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewCsr$3[ebp], eax

; 5741 : 
; 5742 :       // Get rid of any view cursors whose parent entity instance has been
; 5743 :       // deleted
; 5744 :       lpEntityInstance = zGETPTR( lpWrkViewCsr->hViewParentEntityInstance );

	mov	ecx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5745 :       if ( lpEntityInstance && lpEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN19@fnCleanupI
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN19@fnCleanupI

; 5746 :          fnDropViewCsr( lpWrkViewCsr );

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	push	edx
	call	_fnDropViewCsr
	add	esp, 4
	jmp	$LN20@fnCleanupI
$LN19@fnCleanupI:

; 5747 :       else
; 5748 :       {
; 5749 :          // Go through all view entity cursors (except the root) and set all
; 5750 :          // cursors pointing to a hidden instance to unset.
; 5751 :          LPVIEWENTITYCSR lpViewEntityCsr;
; 5752 :          zUSHORT         uIdx;
; 5753 : 
; 5754 :          // Turn Off Hierarchical stuff in ViewCsr
; 5755 :          lpViewCsr->hHierRootEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [eax+22], 0

; 5756 :          lpViewCsr->hHierEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 5757 : 
; 5758 :          lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$7[ebp], eax

; 5759 :          lpViewEntityCsr++;  // Skip the root.

	mov	ecx, DWORD PTR _lpViewEntityCsr$7[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$7[ebp], ecx

; 5760 :          for ( uIdx = 2; uIdx <= lpViewCsr->uEntities; uIdx++ )

	mov	edx, 2
	mov	WORD PTR _uIdx$8[ebp], dx
	jmp	SHORT $LN6@fnCleanupI
$LN4@fnCleanupI:
	mov	ax, WORD PTR _uIdx$8[ebp]
	add	ax, 1
	mov	WORD PTR _uIdx$8[ebp], ax
$LN6@fnCleanupI:
	movzx	ecx, WORD PTR _uIdx$8[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	movzx	eax, WORD PTR [edx+34]
	cmp	ecx, eax
	jg	SHORT $LN20@fnCleanupI

; 5761 :          {
; 5762 :             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$7[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 5763 :             if ( lpEntityInstance && lpEntityInstance != UNSET_CSR &&

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN21@fnCleanupI
	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	je	SHORT $LN21@fnCleanupI
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN21@fnCleanupI

; 5764 :                  lpEntityInstance->u.nInd.bHidden )
; 5765 :             {
; 5766 :                if ( lpEntityInstance != lpRootEntityInstance )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	edx, DWORD PTR _lpRootEntityInstance$[ebp]
	je	SHORT $LN22@fnCleanupI

; 5767 :                {
; 5768 :                   lpViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	eax, DWORD PTR _lpViewEntityCsr$7[ebp]
	mov	DWORD PTR [eax+26], 1
$LN22@fnCleanupI:

; 5769 :                // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 5770 :                //    SysMessageBox( 0, "fnCleanupInstance", "UNSET_CSR", -1 );
; 5771 :                }
; 5772 : 
; 5773 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$7[ebp]
	push	ecx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN21@fnCleanupI:

; 5774 :             }
; 5775 : 
; 5776 :             lpViewEntityCsr++;

	mov	edx, DWORD PTR _lpViewEntityCsr$7[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$7[ebp], edx

; 5777 :          }

	jmp	SHORT $LN4@fnCleanupI
$LN20@fnCleanupI:

; 5778 :       }
; 5779 : 
; 5780 :       lpWrkViewCsr = lpNextViewCsr;

	mov	eax, DWORD PTR _lpNextViewCsr$3[ebp]
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax

; 5781 :    }

	jmp	$LN2@fnCleanupI
$LN3@fnCleanupI:

; 5782 : 
; 5783 :    // Now un-mark all created, updated and included instances and
; 5784 :    // remove any deleted instances
; 5785 :    for ( lpEntityInstance = lpRootEntityInstance;

	mov	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN9@fnCleanupI
$LN7@fnCleanupI:

; 5787 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN9@fnCleanupI:

; 5786 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN8@fnCleanupI

; 5788 :    {
; 5789 :       LPVIEWATTRIB     lpViewAttrib;
; 5790 :       LPENTITYINSTANCE lpParent;
; 5791 : 
; 5792 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 5793 : 
; 5794 :       // Skip the entity if the DBH didn't do anything
; 5795 :       if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE &&
; 5796 :            lpEntityInstance->u.nInd.bDBHIncluded == FALSE &&
; 5797 :            lpEntityInstance->u.nInd.bDBHDeleted == FALSE &&
; 5798 :            lpEntityInstance->u.nInd.bDBHExcluded == FALSE &&

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	SHORT $LN23@fnCleanupI
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 15					; 0000000fH
	and	eax, 1
	jne	SHORT $LN23@fnCleanupI
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	SHORT $LN23@fnCleanupI
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 16					; 00000010H
	and	ecx, 1
	jne	SHORT $LN23@fnCleanupI
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 17					; 00000011H
	and	eax, 1
	jne	SHORT $LN23@fnCleanupI

; 5799 :            lpEntityInstance->u.nInd.bDBHUpdated == FALSE )
; 5800 :       {
; 5801 :          continue;

	jmp	SHORT $LN7@fnCleanupI
$LN23@fnCleanupI:

; 5802 :       }
; 5803 : 
; 5804 :       lpEntityInstance->u.nInd.bCreated =

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -17				; ffffffefH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -9					; fffffff7H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -5					; fffffffbH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 5805 :          lpEntityInstance->u.nInd.bUpdated =
; 5806 :          lpEntityInstance->u.nInd.bDeleted =
; 5807 :          lpEntityInstance->u.nInd.bIncluded =
; 5808 :          lpEntityInstance->u.nInd.bExcluded = FALSE;
; 5809 : 
; 5810 :       // If the EI was not updated, deleted, or created then we are done with
; 5811 :       // this entity.
; 5812 :       if ( lpEntityInstance->u.nInd.bDBHCreated == FALSE &&
; 5813 :            lpEntityInstance->u.nInd.bDBHDeleted == FALSE &&

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	jne	SHORT $LN24@fnCleanupI
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	jne	SHORT $LN24@fnCleanupI
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 17					; 00000011H
	and	eax, 1
	jne	SHORT $LN24@fnCleanupI

; 5814 :            lpEntityInstance->u.nInd.bDBHUpdated == FALSE )
; 5815 :       {
; 5816 :          continue;

	jmp	$LN7@fnCleanupI
$LN24@fnCleanupI:

; 5817 :       }
; 5818 : 
; 5819 :       // Turn off the updated flag for each of the attributes.
; 5820 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$6[ebp], eax
	jmp	SHORT $LN12@fnCleanupI
$LN10@fnCleanupI:

; 5822 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$6[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$6[ebp], eax
$LN12@fnCleanupI:

; 5821 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$6[ebp], 0
	je	SHORT $LN11@fnCleanupI

; 5823 :       {
; 5824 :          LPATTRIBFLAGS lpAttribFlags;
; 5825 : 
; 5826 :          // Skip non-persistent attributes.
; 5827 :          if ( lpViewAttrib->bPersist == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$6[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	jne	SHORT $LN25@fnCleanupI

; 5828 :             continue;

	jmp	SHORT $LN10@fnCleanupI
$LN25@fnCleanupI:

; 5829 : 
; 5830 :          lpAttribFlags = fnGetAttribFlagsPtr( lpEntityInstance, lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnGetAttribFlagsPtr@8
	mov	DWORD PTR _lpAttribFlags$4[ebp], eax

; 5831 :          lpAttribFlags->u.bFlags.bUpdated = FALSE;

	mov	eax, DWORD PTR _lpAttribFlags$4[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, -3					; fffffffdH
	mov	edx, DWORD PTR _lpAttribFlags$4[ebp]
	mov	DWORD PTR [edx], ecx

; 5832 :       }

	jmp	SHORT $LN10@fnCleanupI
$LN11@fnCleanupI:

; 5833 : 
; 5834 :       // Set flags for other linked instances.  If this instance isn't linked
; 5835 :       // then go on to next one.
; 5836 :       if ( lpEntityInstance->hNextLinked == 0 )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	jne	SHORT $LN26@fnCleanupI

; 5837 :          continue;

	jmp	$LN7@fnCleanupI
$LN26@fnCleanupI:

; 5838 : 
; 5839 :       for ( lpNextLinked = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
	jmp	SHORT $LN15@fnCleanupI
$LN13@fnCleanupI:

; 5841 :             lpNextLinked = zGETPTR( lpNextLinked->hNextLinked ) )

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
$LN15@fnCleanupI:

; 5840 :             lpNextLinked != lpEntityInstance;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	je	$LN14@fnCleanupI

; 5842 :       {
; 5843 :          LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpNextLinked->hViewEntity );

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$2[ebp], eax

; 5844 : 
; 5845 :          // Turn off flags in linked entities depending on what the DBHandler
; 5846 :          // did to the current EI.
; 5847 :          if ( lpEntityInstance->u.nInd.bDBHCreated )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	je	SHORT $LN27@fnCleanupI

; 5848 :             lpNextLinked->u.nInd.bCreated = FALSE;

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN27@fnCleanupI:

; 5849 : 
; 5850 :          if ( lpEntityInstance->u.nInd.bDBHUpdated )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 17					; 00000011H
	and	edx, 1
	je	SHORT $LN28@fnCleanupI

; 5851 :             lpNextLinked->u.nInd.bUpdated = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN28@fnCleanupI:

; 5852 : 
; 5853 :          if ( lpEntityInstance->u.nInd.bDBHDeleted )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	je	SHORT $LN29@fnCleanupI

; 5854 :             lpNextLinked->u.nInd.bDeleted = FALSE;

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN29@fnCleanupI:

; 5855 : 
; 5856 :          // Do some more processing if the EI is included/excluded.  If not
; 5857 :          // inc/exc then skip it.
; 5858 :          if ( lpEntityInstance->u.nInd.bDBHIncluded == FALSE &&

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 15					; 0000000fH
	and	eax, 1
	jne	SHORT $LN30@fnCleanupI
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 16					; 00000010H
	and	edx, 1
	jne	SHORT $LN30@fnCleanupI

; 5859 :               lpEntityInstance->u.nInd.bDBHExcluded == FALSE )
; 5860 :          {
; 5861 :             continue;

	jmp	$LN13@fnCleanupI
$LN30@fnCleanupI:

; 5862 :          }
; 5863 : 
; 5864 :          // If lpEntityInstance and lpNextLinked have the same relationship
; 5865 :          // with their respective parents then we don't want to inc/exc the
; 5866 :          // lpNextLinked because it's already been done.  If the two EIs are
; 5867 :          // in the same OI then they must have the same linked parents.
; 5868 :          if ( lpNextLinked->hViewOI == lpEntityInstance->hViewOI ||

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	je	SHORT $LN32@fnCleanupI
	mov	eax, DWORD PTR _lpLinkedViewEntity$2[ebp]
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $LN31@fnCleanupI
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN31@fnCleanupI
$LN32@fnCleanupI:

; 5869 :               ( lpLinkedViewEntity->lERRelTok == lpViewEntity->lERRelTok &&
; 5870 :                 fnInstanceLinkedToInstance( zGETPTR( lpNextLinked->hParent ),
; 5871 :                                             zGETPTR( lpEntityInstance->hParent ) ) ) )
; 5872 :          {
; 5873 :             if ( lpEntityInstance->u.nInd.bDBHIncluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 15					; 0000000fH
	and	eax, 1
	je	SHORT $LN33@fnCleanupI

; 5874 :                lpNextLinked->u.nInd.bIncluded = FALSE;

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN33@fnCleanupI:

; 5875 : 
; 5876 :             if ( lpEntityInstance->u.nInd.bDBHExcluded )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 16					; 00000010H
	and	edx, 1
	je	SHORT $LN31@fnCleanupI

; 5877 :                lpNextLinked->u.nInd.bExcluded = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN31@fnCleanupI:

; 5878 :          }
; 5879 :       }

	jmp	$LN13@fnCleanupI
$LN14@fnCleanupI:

; 5880 : 
; 5881 :       // if the instance has a parent and the parent is linked, see
; 5882 :       // if one of the linked parents is an inverted representation
; 5883 :       // of the same relationship
; 5884 :       lpParent = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$5[ebp], eax

; 5885 :       if ( lpParent == 0 || lpParent->hNextLinked == 0 )

	cmp	DWORD PTR _lpParent$5[ebp], 0
	je	SHORT $LN36@fnCleanupI
	mov	edx, DWORD PTR _lpParent$5[ebp]
	cmp	DWORD PTR [edx+42], 0
	jne	SHORT $LN35@fnCleanupI
$LN36@fnCleanupI:

; 5886 :          continue;

	jmp	$LN7@fnCleanupI
$LN35@fnCleanupI:

; 5887 : 
; 5888 :       for ( lpNextLinked = zGETPTR( lpParent->hNextLinked );

	mov	eax, DWORD PTR _lpParent$5[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
	jmp	SHORT $LN18@fnCleanupI
$LN16@fnCleanupI:

; 5890 :             lpNextLinked = zGETPTR( lpNextLinked->hNextLinked ) )

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$[ebp], eax
$LN18@fnCleanupI:

; 5889 :             lpNextLinked != lpParent;

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	cmp	ecx, DWORD PTR _lpParent$5[ebp]
	je	SHORT $LN17@fnCleanupI

; 5891 :       {
; 5892 :          LPVIEWENTITY lpLinkedViewEntity = zGETPTR( lpNextLinked->hViewEntity );

	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedViewEntity$1[ebp], eax

; 5893 : 
; 5894 :          if ( lpNextLinked->hParent &&
; 5895 :               lpLinkedViewEntity->lERRelTok == lpViewEntity->lERRelTok &&

	mov	ecx, DWORD PTR _lpNextLinked$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN37@fnCleanupI
	mov	edx, DWORD PTR _lpLinkedViewEntity$1[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	jne	SHORT $LN37@fnCleanupI
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN37@fnCleanupI

; 5896 :               fnInstanceLinkedToInstance( zGETPTR( lpNextLinked->hParent ),
; 5897 :                                           lpEntityInstance ) )
; 5898 :          {
; 5899 :             lpNextLinked->u.nInd.bIncluded = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 5900 :             lpNextLinked->u.nInd.bExcluded = FALSE;

	mov	eax, DWORD PTR _lpNextLinked$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _lpNextLinked$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN37@fnCleanupI:

; 5901 :          }
; 5902 :       }

	jmp	$LN16@fnCleanupI
$LN17@fnCleanupI:

; 5903 : 
; 5904 :    } // for each lpEntityInstance...

	jmp	$LN7@fnCleanupI
$LN8@fnCleanupI:

; 5905 : 
; 5906 :    // Call fnReclaim to clean up deleted instances
; 5907 :    if ( lHiddenCnt )

	cmp	DWORD PTR _lHiddenCnt$[ebp], 0
	je	SHORT $LN1@fnCleanupI

; 5908 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$LN1@fnCleanupI:

; 5909 : 
; 5910 : } // fnCleanupInstance

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCleanupInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pfn$ = -4						; size = 4
_lpView$ = 8						; size = 4
_lpCurrentTask$ = 12					; size = 4
_nEvent$ = 16						; size = 2
_nState$ = 20						; size = 2
_fnInvokeOCEOperation PROC

; 14063: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 14064:    zPOCEOPER   pfn;
; 14065: 
; 14066:    pfn = fnGetObjCnstrntOper( lpView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnGetObjCnstrntOper
	add	esp, 8
	mov	DWORD PTR _pfn$[ebp], eax

; 14067:    if ( pfn )

	cmp	DWORD PTR _pfn$[ebp], 0
	je	SHORT $LN2@fnInvokeOC

; 14068:       return( (zSHORT) (*pfn)( lpView, nEvent, nState ) );

	movzx	edx, WORD PTR _nState$[ebp]
	push	edx
	movzx	eax, WORD PTR _nEvent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _pfn$[ebp]
	jmp	SHORT $LN1@fnInvokeOC
$LN2@fnInvokeOC:

; 14069: 
; 14070:    return( 0 );

	xor	eax, eax
$LN1@fnInvokeOC:

; 14071: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInvokeOCEOperation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpLastTaskOperation$1 = -36				; size = 4
_hLibrary$ = -32					; size = 4
_lProcessID$ = -28					; size = 4
_hCurrentTask$ = -24					; size = 4
_pchOperLibName$ = -20					; size = 4
_hTaskOperation$ = -16					; size = 4
_lpViewOD$ = -12					; size = 4
_lpTaskOperation$ = -8					; size = 4
_bMutexLocked$2 = -1					; size = 1
_lpView$ = 8						; size = 4
_lpCurrentTask$ = 12					; size = 4
_fnGetObjCnstrntOper PROC

; 13952: {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 13953:    LPTASK      hCurrentTask = zGETHNDL( lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hCurrentTask$[ebp], eax

; 13954:    LPVIEWOD    lpViewOD;
; 13955:    LPLIBRARY   hLibrary;
; 13956:    LPTASKOPER  lpTaskOperation;
; 13957:    zPVOID      hTaskOperation;
; 13958:    zPCHAR      pchOperLibName;
; 13959:    zLONG       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 13960: 
; 13961:    // No Object Constraint operation pointer, return 0 ==> not found.
; 13962:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 13963:    if ( lpViewOD->szOCEOpername[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+175]
	test	eax, eax
	jne	SHORT $LN5@fnGetObjCn

; 13964:       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetObjCn
$LN5@fnGetObjCn:

; 13965: 
; 13966:    for ( lpTaskOperation = zGETPTR( lpViewOD->hFirstTaskOperation );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
	jmp	SHORT $LN4@fnGetObjCn
$LN2@fnGetObjCn:

; 13968:          lpTaskOperation = zGETPTR( lpTaskOperation->hNextTaskOperationForOEA ) )

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax
$LN4@fnGetObjCn:

; 13967:          lpTaskOperation;

	cmp	DWORD PTR _lpTaskOperation$[ebp], 0
	je	SHORT $LN3@fnGetObjCn

; 13969:    {
; 13970:       if ( lpTaskOperation->hTask == hCurrentTask &&

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+14]
	cmp	eax, DWORD PTR _hCurrentTask$[ebp]
	jne	SHORT $LN6@fnGetObjCn
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN6@fnGetObjCn

; 13971:            lpTaskOperation->lProcessID == lProcessID )
; 13972:       {
; 13973:          return( (zPOCEOPER) lpTaskOperation->pfnTaskOper );

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [eax+30]
	jmp	$LN1@fnGetObjCn
$LN6@fnGetObjCn:

; 13974:       }
; 13975:    }

	jmp	SHORT $LN2@fnGetObjCn
$LN3@fnGetObjCn:

; 13976: 
; 13977:    // No task object oper exists yet, create one if possible.
; 13978:    pchOperLibName = lpViewOD->szOperLibname;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 142				; 0000008eH
	mov	DWORD PTR _pchOperLibName$[ebp], ecx

; 13979:    if ( pchOperLibName == 0 || pchOperLibName[ 0 ] == 0 )

	je	SHORT $LN8@fnGetObjCn
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchOperLibName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN7@fnGetObjCn
$LN8@fnGetObjCn:

; 13980:       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetObjCn
$LN7@fnGetObjCn:

; 13981: 
; 13982:    hLibrary = SysLoadLibrary( lpView, pchOperLibName );

	mov	eax, DWORD PTR _pchOperLibName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysLoadLibrary@8
	mov	DWORD PTR _hLibrary$[ebp], eax

; 13983: 
; 13984:    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$LN9@fnGetObjCn

; 13985:    {
; 13986:       zBOOL bMutexLocked;
; 13987: 
; 13988:       hTaskOperation = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10034					; 00002732H
	push	0
	push	1
	push	38					; 00000026H
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTaskOperation$[ebp], eax

; 13989:                                          sizeof( TaskOperationRecord ), 1, 0,
; 13990:                                          iTaskOperation );
; 13991:       if ( hTaskOperation == 0 )

	cmp	DWORD PTR _hTaskOperation$[ebp], 0
	jne	SHORT $LN11@fnGetObjCn

; 13992:          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetObjCn
$LN11@fnGetObjCn:

; 13993: 
; 13994:       lpTaskOperation              = zGETPTR( hTaskOperation );

	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$[ebp], eax

; 13995:       lpTaskOperation->hViewOD     = lpView->hViewOD;

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+18], ecx

; 13996:       lpTaskOperation->hTask       = hCurrentTask;

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR _hCurrentTask$[ebp]
	mov	DWORD PTR [edx+14], eax

; 13997:       lpTaskOperation->lProcessID  = lProcessID;

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [ecx+34], edx

; 13998: 
; 13999:       // Set pointers for TaskOperation chain off of Task structure
; 14000:       // Note: this is a single linked list
; 14001:       if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hCurrentTask$[ebp]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN12@fnGetObjCn

; 14002:       {
; 14003:          bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$2[ebp], 1

; 14004:          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 14005:       }

	jmp	SHORT $LN13@fnGetObjCn
$LN12@fnGetObjCn:

; 14006:       else
; 14007:          bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$2[ebp], 0
$LN13@fnGetObjCn:

; 14008: 
; 14009:       lpTaskOperation->hNextTaskOperationForTask =

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+130]
	mov	DWORD PTR [edx+2], ecx

; 14010:                                           lpCurrentTask->hFirstTaskOperation;
; 14011:       lpCurrentTask->hFirstTaskOperation = hTaskOperation;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+130], eax

; 14012: 
; 14013:       if ( bMutexLocked )

	movzx	ecx, BYTE PTR _bMutexLocked$2[ebp]
	test	ecx, ecx
	je	SHORT $LN14@fnGetObjCn

; 14014:          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN14@fnGetObjCn:

; 14015: 
; 14016:       lpTaskOperation->pfnTaskOper = SysGetProc( hLibrary,

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 175				; 000000afH
	push	edx
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	_SysGetProc@8
	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 14017:                                                  lpViewOD->szOCEOpername );
; 14018: 
; 14019:       // Set pointers for TaskOperation chain off of ViewOD structure
; 14020:       // Note: this is a double linked list
; 14021:       if ( lpViewOD->hLastTaskOperation )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [edx+220], 0
	je	SHORT $LN15@fnGetObjCn

; 14022:       {
; 14023:          LPTASKOPER lpLastTaskOperation =

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+220]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastTaskOperation$1[ebp], eax

; 14024:                                      zGETPTR( lpViewOD->hLastTaskOperation );
; 14025: 
; 14026:          lpLastTaskOperation->hNextTaskOperationForOEA = hTaskOperation;

	mov	edx, DWORD PTR _lpLastTaskOperation$1[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+6], eax

; 14027:          lpTaskOperation->hPrevTaskOperationForOEA =

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+220]
	mov	DWORD PTR [ecx+10], eax

; 14028:                                                 lpViewOD->hLastTaskOperation;
; 14029:          lpViewOD->hLastTaskOperation = hTaskOperation;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [ecx+220], edx

; 14030:       }

	jmp	SHORT $LN16@fnGetObjCn
$LN15@fnGetObjCn:

; 14031:       else
; 14032:       {
; 14033:          lpViewOD->hFirstTaskOperation = hTaskOperation;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [eax+216], ecx

; 14034:          lpViewOD->hLastTaskOperation  = hTaskOperation;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR _hTaskOperation$[ebp]
	mov	DWORD PTR [edx+220], eax
$LN16@fnGetObjCn:

; 14035:       }
; 14036:    }

	jmp	SHORT $LN10@fnGetObjCn
$LN9@fnGetObjCn:

; 14037:    else
; 14038:       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnGetObjCn
$LN10@fnGetObjCn:

; 14039: 
; 14040:    return( (zPOCEOPER) lpTaskOperation->pfnTaskOper );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [ecx+30]
$LN1@fnGetObjCn:

; 14041: }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetObjCnstrntOper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pchDateTime$ = 8					; size = 4
_pchDate$ = 12						; size = 4
_pchTime$ = 16						; size = 4
_fnDateTimeFormat PROC

; 12336: {

	push	ebp
	mov	ebp, esp

; 12337:    zstrncpy( pchDate, pchDateTime + 4, 2 );      // copy month

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12338:    pchDate[ 2 ] = '/';                           // separator

	mov	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [eax+edx], 47			; 0000002fH

; 12339:    zstrncpy( pchDate + 3, pchDateTime + 6, 2 );  // copy day

	push	2
	mov	ecx, DWORD PTR _pchDateTime$[ebp]
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _pchDate$[ebp]
	add	edx, 3
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12340:    pchDate[ 5 ] = '/';                           // separator

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [edx+ecx], 47			; 0000002fH

; 12341:    zstrncpy( pchDate + 6, pchDateTime + 2, 2 );  // copy year

	push	2
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	add	eax, 2
	push	eax
	mov	ecx, DWORD PTR _pchDate$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12342:    pchDate[ 8 ] = 0;                             // null terminator

	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 12343: 
; 12344:    zstrncpy( pchTime, pchDateTime + 8, 2 );      // copy hours

	push	2
	mov	ecx, DWORD PTR _pchDateTime$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _pchTime$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12345:    pchTime[ 2 ] = ':';                           // separator

	mov	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _pchTime$[ebp]
	mov	BYTE PTR [ecx+eax], 58			; 0000003aH

; 12346:    zstrncpy( pchTime + 3, pchDateTime + 10, 2 ); // copy minutes

	push	2
	mov	edx, DWORD PTR _pchDateTime$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _pchTime$[ebp]
	add	eax, 3
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12347:    pchTime[ 5 ] = ':';                           // separator

	mov	ecx, 1
	imul	edx, ecx, 5
	mov	eax, DWORD PTR _pchTime$[ebp]
	mov	BYTE PTR [eax+edx], 58			; 0000003aH

; 12348:    zstrncpy( pchTime + 6, pchDateTime + 12, 2 ); // copy seconds

	push	2
	mov	ecx, DWORD PTR _pchDateTime$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _pchTime$[ebp]
	add	edx, 6
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 12349:    pchDate[ 8 ] = 0;                             // null terminator

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _pchDate$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 12350: }

	pop	ebp
	ret	0
_fnDateTimeFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpNextEntityInstance$ = -60				; size = 4
_lpPrevVsn$1 = -56					; size = 4
_lpNextVsn$2 = -52					; size = 4
_lpLastEntityInstance$ = -48				; size = 4
_lpViewEntity$3 = -44					; size = 4
_lpNextVsn$4 = -40					; size = 4
_vOriginalOI$5 = -36					; size = 4
_lpOwningTask$ = -32					; size = 4
_lpNextLinked$6 = -28					; size = 4
_lpPrevVsn$7 = -24					; size = 4
_lpSearchViewOI$8 = -20					; size = 4
_lpSearchVsn$ = -16					; size = 4
_lpSearchLink$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_bPrevVersion$ = -1					; size = 1
_lpViewOI$ = 8						; size = 4
_fnDropViewOI PROC

; 8607 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 8608 :    LPENTITYINSTANCE  lpEntityInstance;
; 8609 :    LPENTITYINSTANCE  lpNextEntityInstance;
; 8610 :    LPENTITYINSTANCE  lpLastEntityInstance;
; 8611 :    LPENTITYINSTANCE  lpSearchLink;
; 8612 :    LPENTITYINSTANCE  lpSearchVsn;
; 8613 :    LPTASK            lpOwningTask;
; 8614 :    zBOOL             bPrevVersion;
; 8615 : 
; 8616 :    lpOwningTask = zGETPTR( lpViewOI->hTask );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 8617 : 
; 8618 :    // If the ViewOI is in a task being shutdown and does not have any
; 8619 :    // instances shared with the system task, skip freeing up the instance
; 8620 :    // data, it will go away on completion of task cleanup.
; 8621 :    // If the task is running as a server task then we won't free memory
; 8622 :    // because it will be shut down shortly.
; 8623 :    // Things are unfortunately not working as suggested in the comment above.
; 8624 :    // So always do a drop, even when the task is a server task and is being
; 8625 :    // shutdown (US).
; 8626 :    // Check to see if we have any locking OI's.  If we do, drop them.
; 8627 :    if ( lpViewOI->vOriginalOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN23@fnDropView

; 8628 :    {
; 8629 :       zVIEW vOriginalOI = zGETPTR( lpViewOI->vOriginalOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vOriginalOI$5[ebp], eax

; 8630 : 
; 8631 :       // DGC 05/05/97
; 8632 :       // Following check shouldn't be needed once I fix a bug.
; 8633 :       if ( vOriginalOI->nTableID != iView )

	mov	edx, DWORD PTR _vOriginalOI$5[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10021				; 00002725H
	je	SHORT $LN24@fnDropView

; 8634 :       {
; 8635 :          fnSysMessageBox( zGETPTR( lpViewOI->hTask ), szlOE_SystemError,

	push	1
	push	OFFSET $SG16368
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSysMessageBox@16

; 8636 :                           "Trying to drop original OI but it's not there!", 1 );
; 8637 :       }

	jmp	SHORT $LN23@fnDropView
$LN24@fnDropView:

; 8638 :       else
; 8639 :          fnDropView( vOriginalOI );

	mov	ecx, DWORD PTR _vOriginalOI$5[ebp]
	push	ecx
	call	_fnDropView@4
$LN23@fnDropView:

; 8640 :    }
; 8641 : 
; 8642 :    if ( lpViewOI->vQualOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN26@fnDropView

; 8643 :       fnDropView( zGETPTR( lpViewOI->vQualOI ) );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$LN26@fnDropView:

; 8644 : 
; 8645 :    // If there are any outstanding versioned instances, find the
; 8646 :    // last entity instance in the object instance and work backward
; 8647 :    // from there to clean up outstanding versioned chains until all
; 8648 :    // versions are gone. First, find the last instance in the chain.
; 8649 :    if ( lpViewOI->nVersionedInstances )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	SHORT $LN27@fnDropView

; 8650 :    {
; 8651 :       lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN2@fnDropView:

; 8652 :       while ( lpEntityInstance->hNextHier )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $LN3@fnDropView

; 8653 :       {
; 8654 :          if ( lpEntityInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN28@fnDropView

; 8655 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN29@fnDropView
$LN28@fnDropView:

; 8656 :          else
; 8657 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN29@fnDropView:

; 8658 :       }

	jmp	SHORT $LN2@fnDropView
$LN3@fnDropView:

; 8659 : 
; 8660 :       lpLastEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpLastEntityInstance$[ebp], eax
$LN27@fnDropView:

; 8661 :    }
; 8662 : 
; 8663 :    // Delete the instance data associated with the ViewOI.
; 8664 : // AnchorBlock->nStatus = 101; // DGC debugging hack.
; 8665 :    if ( lpViewOI->hRootEntityInstance )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	$LN30@fnDropView
$LN6@fnDropView:

; 8666 :    for ( ; ; )
; 8667 :    {
; 8668 :       lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0

; 8669 : 
; 8670 :       // If there are versioned instances out there, let's clean them
; 8671 :       // up!!!  Go to the end of the chain and find one.
; 8672 :       if ( lpViewOI->nVersionedInstances )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	$LN31@fnDropView

; 8673 :       {
; 8674 :          LPENTITYINSTANCE lpPrevVsn;
; 8675 : 
; 8676 :          lpEntityInstance = lpLastEntityInstance;

	mov	ecx, DWORD PTR _lpLastEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx

; 8677 :          lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$7[ebp], eax
$LN7@fnDropView:

; 8678 : 
; 8679 :          // Search for an entity instance which has an outstanding
; 8680 :          // previous version.
; 8681 :          while ( lpEntityInstance &&

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN8@fnDropView
	cmp	DWORD PTR _lpPrevVsn$7[ebp], 0
	je	SHORT $LN32@fnDropView
	mov	ecx, DWORD PTR _lpPrevVsn$7[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	jne	SHORT $LN8@fnDropView
$LN32@fnDropView:

; 8682 :                  (lpPrevVsn == 0 || lpPrevVsn->u.nInd.bPrevVsnRoot == FALSE) )
; 8683 :          {
; 8684 :             // Since temporal entitys have no previous version, simply
; 8685 :             // unmark them and subtract 1 from the version count.
; 8686 :             if ( lpEntityInstance->u.nInd.bTemporal )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN33@fnDropView

; 8687 :             {
; 8688 :                lpEntityInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2049				; fffff7ffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 8689 :                lpViewOI->nVersionedInstances--;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [ecx+22], ax

; 8690 :                if ( lpViewOI->nVersionedInstances == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	jne	SHORT $LN33@fnDropView

; 8691 :                {
; 8692 :                   lpEntityInstance = 0;

	mov	DWORD PTR _lpEntityInstance$[ebp], 0

; 8693 :                   break;

	jmp	SHORT $LN8@fnDropView
$LN33@fnDropView:

; 8694 :                }
; 8695 :             }
; 8696 : 
; 8697 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8698 :             if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN35@fnDropView

; 8699 :                lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$7[ebp], eax
$LN35@fnDropView:

; 8700 :          }

	jmp	$LN7@fnDropView
$LN8@fnDropView:

; 8701 : 
; 8702 :          if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN36@fnDropView

; 8703 :             lpEntityInstance = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN31@fnDropView
$LN36@fnDropView:

; 8704 :          else
; 8705 :             lpViewOI->nVersionedInstances = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [edx+22], cx
$LN31@fnDropView:

; 8706 :       }
; 8707 : 
; 8708 :       // If no entity instance found which is a previous version, go
; 8709 :       // for the main entity instance chain!!
; 8710 :       if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN9@fnDropView

; 8711 :       {
; 8712 :          lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 8713 :          lpViewOI->hRootEntityInstance = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+26], 0
$LN9@fnDropView:

; 8714 :       }
; 8715 : 
; 8716 :       // Clean up the entity instances.
; 8717 :       while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN10@fnDropView

; 8718 :       {
; 8719 :          LPVIEWENTITY lpViewEntity;
; 8720 : 
; 8721 :          lpNextEntityInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextEntityInstance$[ebp], eax

; 8722 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$3[ebp], eax

; 8723 : 
; 8724 :          // If there are versioned instances in this instance, zero
; 8725 :          // all records for newer versions linked to this instance
; 8726 :          // whose record matches the link instance record.
; 8727 :          if ( lpEntityInstance->hNextVsn )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+34], 0
	je	$LN39@fnDropView

; 8728 :          {
; 8729 :             LPENTITYINSTANCE lpNextVsn;
; 8730 : 
; 8731 :             // If there are linked instances to the old version of an
; 8732 :             // entity instance, see if the prev-version indicator needs
; 8733 :             // to be unset for all the linked instances because the
; 8734 :             // new version is being dropped by fnDropViewOI.
; 8735 :             if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	$LN40@fnDropView

; 8736 :             {
; 8737 :                bPrevVersion = FALSE;

	mov	BYTE PTR _bPrevVersion$[ebp], 0

; 8738 :                lpSearchLink = zGETPTR( lpEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$LN11@fnDropView:

; 8739 :                while ( lpSearchLink && lpSearchLink != lpEntityInstance )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $LN12@fnDropView
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN12@fnDropView

; 8740 :                {
; 8741 :                   if ( lpSearchLink->hNextVsn )

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	SHORT $LN41@fnDropView

; 8742 :                   {
; 8743 :                      bPrevVersion = TRUE;

	mov	BYTE PTR _bPrevVersion$[ebp], 1

; 8744 :                      break;

	jmp	SHORT $LN12@fnDropView
$LN41@fnDropView:

; 8745 :                   }
; 8746 : 
; 8747 :                   lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8748 :                }

	jmp	SHORT $LN11@fnDropView
$LN12@fnDropView:

; 8749 : 
; 8750 :                if ( bPrevVersion == 0 )

	movzx	eax, BYTE PTR _bPrevVersion$[ebp]
	test	eax, eax
	jne	SHORT $LN40@fnDropView

; 8751 :                {
; 8752 :                   lpSearchLink = zGETPTR( lpEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$LN13@fnDropView:

; 8753 :                   while ( lpSearchLink &&

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $LN40@fnDropView
	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN40@fnDropView

; 8754 :                           lpSearchLink != lpEntityInstance )
; 8755 :                   {
; 8756 :                      lpSearchLink->u.nInd.bPrevVersion = FALSE;

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -257				; fffffeffH
	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	DWORD PTR [eax+6], edx

; 8757 :                      lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8758 :                   }

	jmp	SHORT $LN13@fnDropView
$LN40@fnDropView:

; 8759 :                }
; 8760 :             }
; 8761 : 
; 8762 :             // If the newer version record matches the older version
; 8763 :             // record (because the entity is NOT UPDATEABLE), clear
; 8764 :             // all the record pointers in the newer versions so we do
; 8765 :             // not attempt to free the same record multiple times.
; 8766 :             lpNextVsn = zGETPTR( lpEntityInstance->hNextVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$4[ebp], eax

; 8767 :             if ( lpNextVsn->hPersistRecord == lpEntityInstance->hPersistRecord )

	mov	edx, DWORD PTR _lpNextVsn$4[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	cmp	ecx, DWORD PTR [eax+60]
	jne	SHORT $LN39@fnDropView

; 8768 :             {
; 8769 :                lpSearchVsn = lpNextVsn;

	mov	edx, DWORD PTR _lpNextVsn$4[ebp]
	mov	DWORD PTR _lpSearchVsn$[ebp], edx
$LN15@fnDropView:

; 8770 :                while ( lpSearchVsn )

	cmp	DWORD PTR _lpSearchVsn$[ebp], 0
	je	SHORT $LN39@fnDropView

; 8771 :                {
; 8772 :                   lpSearchVsn->hPersistRecord = 0;

	mov	eax, DWORD PTR _lpSearchVsn$[ebp]
	mov	DWORD PTR [eax+60], 0

; 8773 :                   lpSearchLink = zGETPTR( lpSearchVsn->hNextLinked );

	mov	ecx, DWORD PTR _lpSearchVsn$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$LN17@fnDropView:

; 8774 :                   while ( lpSearchLink && lpSearchLink != lpSearchVsn )

	cmp	DWORD PTR _lpSearchLink$[ebp], 0
	je	SHORT $LN18@fnDropView
	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	cmp	eax, DWORD PTR _lpSearchVsn$[ebp]
	je	SHORT $LN18@fnDropView

; 8775 :                   {
; 8776 :                      lpSearchLink->hPersistRecord = 0;

	mov	ecx, DWORD PTR _lpSearchLink$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 8777 :                      lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax

; 8778 :                   }

	jmp	SHORT $LN17@fnDropView
$LN18@fnDropView:

; 8779 : 
; 8780 :                   lpSearchVsn = zGETPTR( lpSearchVsn->hNextVsn );

	mov	ecx, DWORD PTR _lpSearchVsn$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchVsn$[ebp], eax

; 8781 :                }

	jmp	SHORT $LN15@fnDropView
$LN39@fnDropView:

; 8782 :             }
; 8783 :          }
; 8784 : 
; 8785 :          // Reset version pointers.
; 8786 :          if ( lpEntityInstance->hNextVsn )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	SHORT $LN44@fnDropView

; 8787 :          {
; 8788 :             LPENTITYINSTANCE lpNextVsn =

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$2[ebp], eax

; 8789 :                                  zGETPTR( lpEntityInstance->hNextVsn );
; 8790 : 
; 8791 :             lpNextVsn->hPrevVsn = lpEntityInstance->hPrevVsn;

	mov	eax, DWORD PTR _lpNextVsn$2[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	mov	DWORD PTR [eax+38], edx
$LN44@fnDropView:

; 8792 :          }
; 8793 : 
; 8794 :          if ( lpEntityInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN45@fnDropView

; 8795 :          {
; 8796 :             LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$1[ebp], eax

; 8797 : 
; 8798 :             lpPrevVsn->hNextVsn = lpEntityInstance->hNextVsn;

	mov	eax, DWORD PTR _lpPrevVsn$1[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	mov	DWORD PTR [eax+34], edx
$LN45@fnDropView:

; 8799 :          }
; 8800 : 
; 8801 :          // If the entity instance is linked, remove the entity instance
; 8802 :          // from the link chain.
; 8803 :          if ( lpEntityInstance->hNextLinked )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	SHORT $LN46@fnDropView

; 8804 :          {
; 8805 :             LPENTITYINSTANCE lpNextLinked =

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$6[ebp], eax

; 8806 :                               zGETPTR( lpEntityInstance->hNextLinked );
; 8807 : 
; 8808 :             if ( lpNextLinked->hNextLinked == zGETHNDL( lpEntityInstance ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNextLinked$6[ebp]
	cmp	DWORD PTR [ecx+42], eax
	jne	SHORT $LN48@fnDropView

; 8809 :                lpNextLinked->hNextLinked = 0;

	mov	edx, DWORD PTR _lpNextLinked$6[ebp]
	mov	DWORD PTR [edx+42], 0
	jmp	SHORT $LN49@fnDropView
$LN48@fnDropView:

; 8810 :             else
; 8811 :             {
; 8812 :                lpSearchLink = lpNextLinked;

	mov	eax, DWORD PTR _lpNextLinked$6[ebp]
	mov	DWORD PTR _lpSearchLink$[ebp], eax
$LN19@fnDropView:

; 8813 :                while ( lpSearchLink->hNextLinked !=

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	cmp	DWORD PTR [edx+42], eax
	je	SHORT $LN20@fnDropView

; 8814 :                                              zGETHNDL( lpEntityInstance ) )
; 8815 :                   lpSearchLink = zGETPTR( lpSearchLink->hNextLinked );

	mov	eax, DWORD PTR _lpSearchLink$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLink$[ebp], eax
	jmp	SHORT $LN19@fnDropView
$LN20@fnDropView:

; 8816 : 
; 8817 :                lpSearchLink->hNextLinked = lpEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpSearchLink$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$LN49@fnDropView:

; 8818 :             }
; 8819 :          }

	jmp	SHORT $LN47@fnDropView
$LN46@fnDropView:

; 8820 :          else
; 8821 :             fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, TRUE );  // dks 2006.09.18 error while cleaning up client OE

	push	1
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$3[ebp]
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH
$LN47@fnDropView:

; 8822 : 
; 8823 :          fnDeleteAttributeRecord( lpViewEntity, lpEntityInstance, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$3[ebp]
	push	edx
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 8824 :          fnRemoveEntityFromDebugChange( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRemoveEntityFromDebugChange@4

; 8825 :          fnFreeDataspace( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8826 :          lpEntityInstance = lpNextEntityInstance;

	mov	edx, DWORD PTR _lpNextEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx

; 8827 :       }

	jmp	$LN9@fnDropView
$LN10@fnDropView:

; 8828 : 
; 8829 :       // Get out when no root instance exists any more.
; 8830 :       if ( lpViewOI->hRootEntityInstance == 0 )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN50@fnDropView

; 8831 :          break;

	jmp	SHORT $LN30@fnDropView
$LN50@fnDropView:

; 8832 :    }

	jmp	$LN6@fnDropView
$LN30@fnDropView:

; 8833 : 
; 8834 : // AnchorBlock->nStatus = AnchorInitialized;
; 8835 : 
; 8836 :    // Free the ViewOI.
; 8837 :    if ( lpOwningTask->hFirstViewOI == zGETHNDL( lpViewOI ) )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	cmp	DWORD PTR [edx+98], eax
	jne	SHORT $LN51@fnDropView

; 8838 :       lpOwningTask->hFirstViewOI = lpViewOI->hNextViewOI;

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+98], edx
	jmp	SHORT $LN52@fnDropView
$LN51@fnDropView:

; 8839 :    else
; 8840 :    {
; 8841 :       LPVIEWOI lpSearchViewOI;
; 8842 : 
; 8843 :       lpSearchViewOI = zGETPTR( lpOwningTask->hFirstViewOI );

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewOI$8[ebp], eax

; 8844 :       if ( lpSearchViewOI )

	cmp	DWORD PTR _lpSearchViewOI$8[ebp], 0
	je	SHORT $LN52@fnDropView
$LN21@fnDropView:

; 8845 :       {
; 8846 :          while ( lpSearchViewOI->hNextViewOI != zGETHNDL( lpViewOI ) )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSearchViewOI$8[ebp]
	cmp	DWORD PTR [ecx+2], eax
	je	SHORT $LN22@fnDropView

; 8847 :             lpSearchViewOI = zGETPTR( lpSearchViewOI->hNextViewOI );

	mov	edx, DWORD PTR _lpSearchViewOI$8[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewOI$8[ebp], eax
	jmp	SHORT $LN21@fnDropView
$LN22@fnDropView:

; 8848 : 
; 8849 :          lpSearchViewOI->hNextViewOI = lpViewOI->hNextViewOI;

	mov	ecx, DWORD PTR _lpSearchViewOI$8[ebp]
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax
$LN52@fnDropView:

; 8850 :       }
; 8851 :    }
; 8852 : 
; 8853 :    fnFreeDataspace( lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8854 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropViewOI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpLastView$ = -20					; size = 4
_lpFirstViewCsr$ = -16					; size = 4
_lpViewOI$ = -12					; size = 4
_lpCurrentView$ = -8					; size = 4
_lpViewCsr$ = -4					; size = 4
_lpView$ = 8						; size = 4
_fnDropObjectInstance PROC

; 8529 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8530 :    LPVIEWOI          lpViewOI;
; 8531 :    LPVIEWCSR         lpViewCsr;
; 8532 :    LPVIEWCSR         lpFirstViewCsr;
; 8533 :    zVIEW             lpCurrentView;
; 8534 :    zVIEW             lpLastView;
; 8535 : 
; 8536 :    // If no ViewCsr, go home ...
; 8537 :    if ( lpView->hViewCsr == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN7@fnDropObje

; 8538 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDropObje
$LN7@fnDropObje:

; 8539 : 
; 8540 :    // Get pointers to ViewOI and task owning the ViewOI.
; 8541 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8542 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$LN2@fnDropObje:

; 8543 : 
; 8544 : // {
; 8545 : //    LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );
; 8546 : //    TraceLine( "DropObjectInstance: 0x%08x   LOD: %s",
; 8547 : //               lpView, lpViewOD->szName );
; 8548 : //    if ( zstrcmp( "KZMSGQOO", lpViewOD->szName ) == 0 )
; 8549 : //       SysMessageBox( lpView, "Dropping LOD", lpViewOD->szName, 0 );
; 8550 : // }
; 8551 : 
; 8552 :    // Find the last view cursor for the ViewOI.
; 8553 :    while ( lpViewCsr->hNextViewCsr )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+2], 0
	je	SHORT $LN3@fnDropObje

; 8554 :       lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $LN2@fnDropObje
$LN3@fnDropObje:

; 8555 : 
; 8556 :    // Drop all the views.  When the last view is dropped, fnDropView will
; 8557 :    // drop the object instance.  The DropObjectInstance constraint will
; 8558 :    // be called then.
; 8559 :    lpLastView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastView$[ebp], eax

; 8560 :    lpCurrentView = 0;

	mov	DWORD PTR _lpCurrentView$[ebp], 0
$LN6@fnDropObje:

; 8561 :    do
; 8562 :    {
; 8563 :       lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$[ebp], eax

; 8564 :       lpCurrentView = zGETPTR( lpFirstViewCsr->hView );

	mov	eax, DWORD PTR _lpFirstViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentView$[ebp], eax

; 8565 :       fnDropView( lpCurrentView );

	mov	edx, DWORD PTR _lpCurrentView$[ebp]
	push	edx
	call	_fnDropView@4

; 8566 : 
; 8567 :    }  while ( lpCurrentView != lpLastView );

	mov	eax, DWORD PTR _lpCurrentView$[ebp]
	cmp	eax, DWORD PTR _lpLastView$[ebp]
	jne	SHORT $LN6@fnDropObje

; 8568 : 
; 8569 :    return( 0 );

	xor	eax, eax
$LN1@fnDropObje:

; 8570 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropObjectInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -64					; size = 4
tv265 = -60						; size = 4
tv249 = -56						; size = 4
tv174 = -52						; size = 4
tv157 = -48						; size = 4
_lpViewEntity$1 = -44					; size = 4
_pOper$ = -40						; size = 4
_lpPtr$ = -36						; size = 4
_lpTaskDBHandler$ = -32					; size = 4
_lpViewOD$ = -28					; size = 4
_lpViewOI$ = -24					; size = 4
_lpEntityInstance$ = -20				; size = 4
_nReturnCode$ = -16					; size = 2
_nRC$ = -12						; size = 2
_bAllowRead$2 = -5					; size = 1
_bAllowRead$3 = -4					; size = 1
_bTransactionStartedHere$ = -3				; size = 1
_bReadOnly$4 = -2					; size = 1
_bReadOnly$5 = -1					; size = 1
_lpCurrentTask$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpQualView$ = 16					; size = 4
_lControl$ = 20						; size = 4
_fnActivateObjectInstance PROC

; 10379: {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 10380:    LPVIEWOD          lpViewOD;
; 10381:    LPVIEWOI          lpViewOI;
; 10382:    LPVIEWCSR         lpViewCsr;
; 10383:    LPENTITYINSTANCE  lpEntityInstance;
; 10384:    LPTASKDBHANDLER   lpTaskDBHandler;
; 10385:    zPDBHOPER         pOper;
; 10386:    zPVOID            lpPtr;
; 10387:    zBOOL             bTransactionStartedHere;
; 10388:    zSHORT            nReturnCode;
; 10389:    zSHORT            nRC;
; 10390: 
; 10391:    lpPtr       = 0;

	mov	DWORD PTR _lpPtr$[ebp], 0

; 10392:    nReturnCode = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnCode$[ebp], ax

; 10393: 
; 10394:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 10395:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 10396:    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 10397:    lpTaskDBHandler = fnGetDBHandlerOper( lpCurrentTask, lpView,

	lea	ecx, DWORD PTR _pOper$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnGetDBHandlerOper@12
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 10398:                                          (zlpPDBHOPER) &pOper );
; 10399:    if ( lpTaskDBHandler == 0 )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	jne	SHORT $LN11@fnActivate

; 10400:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnActivate
$LN11@fnActivate:

; 10401: 
; 10402:    // Check to see if a transaction has already been started for the database.
; 10403:    // If it has already been started we don't want to do it again but set a
; 10404:    // flag to indicate we don't want to END the transaction later.
; 10405:    //
; 10406:    // We need to do this because fnActivateObjectInstance can be called
; 10407:    // recursively.
; 10408:    if ( lpTaskDBHandler->bTranStarted )

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, 1
	je	SHORT $LN12@fnActivate

; 10409:    {
; 10410:       bTransactionStartedHere = FALSE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 0

; 10411:       lpPtr = lpTaskDBHandler->lpConnection;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	mov	DWORD PTR _lpPtr$[ebp], ecx

; 10412:    }

	jmp	SHORT $LN13@fnActivate
$LN12@fnActivate:

; 10413:    else
; 10414:    {
; 10415:       // Call DBHandler routine to issue start of transaction.
; 10416:       nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	1
	push	16385					; 00004001H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10417:                       DBH_Object | DBH_TranBegin, DBH_LoadOI,
; 10418:                       lpViewOD, 0, lpView, lpQualView, &lpPtr );
; 10419:       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN14@fnActivate

; 10420:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnActivate
$LN14@fnActivate:

; 10421: 
; 10422:       // Set flag to indicate that we started the transaction here and will
; 10423:       // need to end the transaction before we exit the operation.
; 10424:       bTransactionStartedHere = TRUE;

	mov	BYTE PTR _bTransactionStartedHere$[ebp], 1

; 10425:       lpTaskDBHandler->bTranStarted = TRUE;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+26]
	or	eax, 1
	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 10426:       lpTaskDBHandler->lpConnection = lpPtr;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR [edx+18], eax
$LN13@fnActivate:

; 10427:    }
; 10428: 
; 10429:    // Retrieve the root entity(-ies).
; 10430:    nRC = (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),

	lea	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	push	32800					; 00008020H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 10431:                    DBH_Entity | DBH_Load, (int) lControl, lpViewOD,
; 10432:                    zGETPTR( lpViewOD->hFirstOD_Entity ),
; 10433:                    lpView, lpQualView, &lpPtr );
; 10434: 
; 10435:    // If nRC > 0, then the root entity was loaded OK but multiple roots were
; 10436:    // found and lControl = zSINGLE or the multi-root limit was reached.
; 10437:    // This means that not all roots where loaded.
; 10438:    // Set nRC back to 0 (indicate load was OK) and set nReturnCode = 1 (this
; 10439:    // will be returned by the Activate if everything else goes OK).
; 10440:    if ( nRC >= 1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, 1
	jl	SHORT $LN15@fnActivate

; 10441:    {
; 10442:       nReturnCode = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturnCode$[ebp], cx

; 10443:       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN15@fnActivate:

; 10444:    }
; 10445: 
; 10446:    // If we activated some information check to see if we need to set up
; 10447:    // some pessimistic locks.
; 10448:    if ( nRC >= 0 && lpViewOD->nLock >= zLL_PESSIMISTIC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	$LN16@fnActivate
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movzx	edx, BYTE PTR [ecx+236]
	cmp	edx, 3
	jl	$LN16@fnActivate

; 10449:    {
; 10450:       zBOOL bReadOnly = (lControl & zSINGLE_FOR_UPDATE) == 0 ||

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 67108864				; 04000000H
	je	SHORT $LN39@fnActivate
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movzx	edx, BYTE PTR [ecx+236]
	cmp	edx, 3
	je	SHORT $LN39@fnActivate
	mov	DWORD PTR tv157[ebp], 0
	jmp	SHORT $LN40@fnActivate
$LN39@fnActivate:
	mov	DWORD PTR tv157[ebp], 1
$LN40@fnActivate:
	mov	al, BYTE PTR tv157[ebp]
	mov	BYTE PTR _bReadOnly$5[ebp], al

; 10451:                         lpViewOD->nLock == zLL_PESSIMISTIC;
; 10452: 
; 10453:       nRC = fnCheckLocksOnTwins( lpCurrentTask, TRUE, bReadOnly, lpView,

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bReadOnly$5[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCheckLocksOnTwins@24
	mov	WORD PTR _nRC$[ebp], ax

; 10454:                                  zGETPTR( lpViewOI->hRootEntityInstance ),
; 10455:                                  lpViewOD );
; 10456: 
; 10457:       // If nRC >= 0 then we might need to set locks on the parent entities.
; 10458:       if ( nRC >= 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $LN16@fnActivate

; 10459:       {
; 10460:          zBOOL bAllowRead = lpViewOD->nLock == zLL_PESSIMISTIC_WITHREAD;

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+236]
	cmp	eax, 4
	jne	SHORT $LN41@fnActivate
	mov	DWORD PTR tv174[ebp], 1
	jmp	SHORT $LN42@fnActivate
$LN41@fnActivate:
	mov	DWORD PTR tv174[ebp], 0
$LN42@fnActivate:
	mov	cl, BYTE PTR tv174[ebp]
	mov	BYTE PTR _bAllowRead$3[ebp], cl

; 10461: 
; 10462:          if ( bReadOnly == FALSE &&

	movzx	edx, BYTE PTR _bReadOnly$5[ebp]
	test	edx, edx
	jne	SHORT $LN16@fnActivate
	movzx	eax, BYTE PTR _bAllowRead$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSetLocksOnTwins@24
	cwde
	test	eax, eax
	je	SHORT $LN16@fnActivate

; 10463:               fnSetLocksOnTwins( lpCurrentTask, TRUE, lpView,
; 10464:                                  zGETPTR( lpViewOI->hRootEntityInstance ),
; 10465:                                  lpViewOI, bAllowRead ) != 0 )
; 10466:          {
; 10467:             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN16@fnActivate:

; 10468:          }
; 10469:       }
; 10470:    }
; 10471: 
; 10472:    // For each of the root entities, call fnLoadChildEntities to load all of
; 10473:    // their children if lower-level entities are to be loaded.
; 10474:    if ( nRC >= 0 && (lControl & zACTIVATE_ROOTONLY) == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN19@fnActivate
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 268435456				; 10000000H
	jne	$LN19@fnActivate

; 10475:    {
; 10476:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN4@fnActivate
$LN2@fnActivate:

; 10478:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@fnActivate:

; 10477:             lpEntityInstance && nRC >= 0;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN3@fnActivate
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN3@fnActivate

; 10479:       {
; 10480:          // Make lpEntityInstance the current instance.
; 10481:          fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 10482: 
; 10483:          nRC = fnLoadChildEntities( lpCurrentTask, lpView, lpEntityInstance,

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pOper$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnLoadChildEntities
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 10484:                                     lpQualView, pOper, &lpPtr );
; 10485:          if ( nRC == zDB_DEADLOCK || nRC == zMEMORY_LIMIT )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -3					; fffffffdH
	je	SHORT $LN22@fnActivate
	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -7					; fffffff9H
	jne	SHORT $LN21@fnActivate
$LN22@fnActivate:

; 10486:             nReturnCode = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturnCode$[ebp], cx
$LN21@fnActivate:

; 10487: 
; 10488:          // If nRC is 2 then not all child entities where loaded because the
; 10489:          // Activate Limit constraint was reached.
; 10490:          if ( nRC == 2 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, 2
	jne	SHORT $LN23@fnActivate

; 10491:             nReturnCode = 2;

	mov	eax, 2
	mov	WORD PTR _nReturnCode$[ebp], ax
$LN23@fnActivate:

; 10492: 
; 10493:       }  // for ( lpEntityInstance )...

	jmp	$LN2@fnActivate
$LN3@fnActivate:

; 10494: 
; 10495:    } // if ( nRC >= 0 && (lControl & zACTIVATE_ROOTONLY) == 0 )...

	jmp	SHORT $LN20@fnActivate
$LN19@fnActivate:

; 10496:    else
; 10497:    if ( lControl == (lControl | zACTIVATE_ROOTONLY) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 268435456				; 10000000H
	cmp	DWORD PTR _lControl$[ebp], ecx
	jne	SHORT $LN20@fnActivate

; 10498:       lpViewOI->bRootOnly = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 2
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN20@fnActivate:

; 10499: 
; 10500:    // If we activated some information check to see if we need to set up
; 10501:    // some pessimistic locks.
; 10502:    if ( nRC >= 0 && lpViewOD->nEntityLock >= zLL_PESSIMISTIC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN25@fnActivate
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movzx	ecx, BYTE PTR [eax+237]
	cmp	ecx, 3
	jl	$LN25@fnActivate

; 10503:    {
; 10504:       // Loop through all the instances and check to see if
; 10505:       // the entity has locking.
; 10506:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN7@fnActivate
$LN5@fnActivate:

; 10508:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@fnActivate:

; 10507:             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN25@fnActivate

; 10509:       {
; 10510:          LPVIEWENTITY lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 10511:          zBOOL        bReadOnly;
; 10512: 
; 10513:          // If entity has no locking skip it.
; 10514:          if ( lpViewEntity->nLock == 0 )

	mov	edx, DWORD PTR _lpViewEntity$1[ebp]
	movzx	eax, BYTE PTR [edx+230]
	test	eax, eax
	jne	SHORT $LN26@fnActivate

; 10515:             continue;

	jmp	SHORT $LN5@fnActivate
$LN26@fnActivate:

; 10516: 
; 10517:          // If the instance is not the first twin then skip it.
; 10518:          if ( lpEntityInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN27@fnActivate

; 10519:             continue;

	jmp	SHORT $LN5@fnActivate
$LN27@fnActivate:

; 10520: 
; 10521:          // We're about to check the locks on the entity instances but if the
; 10522:          // zSINGLE_FOR_UPDATE flag is not set or if the locking level is only
; 10523:          // zLL_PESSIMISTIC then the entity instance is read-only.
; 10524:          bReadOnly = (lControl & zSINGLE_FOR_UPDATE) == 0 ||

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 67108864				; 04000000H
	je	SHORT $LN43@fnActivate
	mov	eax, DWORD PTR _lpViewEntity$1[ebp]
	movzx	ecx, BYTE PTR [eax+230]
	cmp	ecx, 3
	je	SHORT $LN43@fnActivate
	mov	DWORD PTR tv249[ebp], 0
	jmp	SHORT $LN44@fnActivate
$LN43@fnActivate:
	mov	DWORD PTR tv249[ebp], 1
$LN44@fnActivate:
	mov	dl, BYTE PTR tv249[ebp]
	mov	BYTE PTR _bReadOnly$4[ebp], dl

; 10525:                      lpViewEntity->nLock == zLL_PESSIMISTIC;
; 10526: 
; 10527:          // Make sure the entities aren't locked.
; 10528:          if ( fnCheckLocksOnTwins( lpCurrentTask, FALSE, bReadOnly, lpView,
; 10529:                                    lpEntityInstance, lpViewOD ) != 0 )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bReadOnly$4[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCheckLocksOnTwins@24
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN28@fnActivate

; 10530:          {
; 10531:             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 10532:             break;

	jmp	SHORT $LN25@fnActivate
$LN28@fnActivate:

; 10533:          }
; 10534: 
; 10535:          // If entity instances are not read-only then we need to set up locks
; 10536:          // for the entities.
; 10537:          if ( bReadOnly == FALSE )

	movzx	ecx, BYTE PTR _bReadOnly$4[ebp]
	test	ecx, ecx
	jne	SHORT $LN29@fnActivate

; 10538:          {
; 10539:             zBOOL bAllowRead = lpViewEntity->nLock == zLL_PESSIMISTIC_WITHREAD;

	mov	edx, DWORD PTR _lpViewEntity$1[ebp]
	movzx	eax, BYTE PTR [edx+230]
	cmp	eax, 4
	jne	SHORT $LN45@fnActivate
	mov	DWORD PTR tv265[ebp], 1
	jmp	SHORT $LN46@fnActivate
$LN45@fnActivate:
	mov	DWORD PTR tv265[ebp], 0
$LN46@fnActivate:
	mov	cl, BYTE PTR tv265[ebp]
	mov	BYTE PTR _bAllowRead$2[ebp], cl

; 10540: 
; 10541:             if ( fnSetLocksOnTwins( lpCurrentTask, FALSE, lpView,
; 10542:                                     lpEntityInstance, lpViewOI,
; 10543:                                     bAllowRead ) != 0 )

	movzx	edx, BYTE PTR _bAllowRead$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnSetLocksOnTwins@24
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN29@fnActivate

; 10544:             {
; 10545:                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 10546:                break;

	jmp	SHORT $LN25@fnActivate
$LN29@fnActivate:

; 10547:             }
; 10548:          }
; 10549:       } // for...

	jmp	$LN5@fnActivate
$LN25@fnActivate:

; 10550:    }
; 10551: 
; 10552:    // Check to see if we need to close the transaction.
; 10553:    if ( bTransactionStartedHere )

	movzx	eax, BYTE PTR _bTransactionStartedHere$[ebp]
	test	eax, eax
	je	$LN31@fnActivate

; 10554:    {
; 10555:       // We're about to close the transaction so set flag.
; 10556:       lpTaskDBHandler->bTranStarted = FALSE;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+26], edx

; 10557:       lpTaskDBHandler->lpConnection = 0;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 10558: 
; 10559:       if ( nRC >= -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $LN32@fnActivate

; 10560:       {
; 10561:          // Call DBHandler routine to commit transaction.
; 10562:          if ( (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),
; 10563:                         DBH_Object | DBH_Commit, DBH_LoadOI,
; 10564:                         lpViewOD, 0, lpView, 0, &lpPtr ) != 0 )

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	push	1
	push	16386					; 00004002H
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN34@fnActivate

; 10565:          {
; 10566:             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnActivate
$LN34@fnActivate:

; 10567:          }
; 10568:       }

	jmp	SHORT $LN31@fnActivate
$LN32@fnActivate:

; 10569:       else
; 10570:       {
; 10571:          // Call DBHandler routine to rollback transaction.
; 10572:          (*pOper)( (zLONG) zGETHNDL( lpCurrentTask ),

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	push	1
	push	16388					; 00004004H
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	DWORD PTR _pOper$[ebp]

; 10573:                    DBH_Object | DBH_Rollback, DBH_LoadOI,
; 10574:                    lpViewOD, 0, lpView, 0, &lpPtr );
; 10575:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@fnActivate
$LN31@fnActivate:

; 10576:       }
; 10577:    }
; 10578: 
; 10579:    // At this point if:
; 10580:    //    nRC = 0, nReturnCode = 1 -- 1 root loaded, mult found; children loaded
; 10581:    //    nRC = 0, nReturnCode = 0 -- all roots (possibly only 1) loaded.
; 10582:    //    nRC = -1                 -- No root found matching lpQual.
; 10583:    //    nRC < -1                 -- Error loading entities.
; 10584: 
; 10585:    if ( nRC >= -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jl	$LN35@fnActivate

; 10586:    {
; 10587:       // Before we exit, reset indicators in object instance to denote
; 10588:       // that entities are not to be created/include at commit time.
; 10589:       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN10@fnActivate
$LN8@fnActivate:

; 10591:             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN10@fnActivate:

; 10590:             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN9@fnActivate

; 10592:       {
; 10593:          lpEntityInstance->u.nInd.bCreated        =

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -131073				; fffdffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -65537				; fffeffffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -16385				; ffffbfffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -32769				; ffff7fffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -8193				; ffffdfffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -3					; fffffffdH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 10594:             lpEntityInstance->u.nInd.bIncluded    =
; 10595:             lpEntityInstance->u.nInd.bUpdated     =
; 10596:             lpEntityInstance->u.nInd.bDBHCreated  =
; 10597:             lpEntityInstance->u.nInd.bDBHIncluded =
; 10598:             lpEntityInstance->u.nInd.bDBHDeleted  =
; 10599:             lpEntityInstance->u.nInd.bDBHExcluded =
; 10600:             lpEntityInstance->u.nInd.bDBHUpdated  = 0;
; 10601:       }

	jmp	$LN8@fnActivate
$LN9@fnActivate:

; 10602: 
; 10603:       lpViewOI->bUpdated = lpViewOI->bUpdatedFile = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 10604: 
; 10605:       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN36@fnActivate

; 10606:          return( nReturnCode );

	mov	ax, WORD PTR _nReturnCode$[ebp]
	jmp	SHORT $LN1@fnActivate
	jmp	SHORT $LN35@fnActivate
$LN36@fnActivate:

; 10607:       else
; 10608:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@fnActivate
$LN35@fnActivate:

; 10609:    }
; 10610: 
; 10611:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnActivate:

; 10612: 
; 10613: }  //  fnActivateObjectInstance

	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateObjectInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpInstanceOwningTask$ = -76				; size = 4
tv171 = -72						; size = 4
_hViewOI$ = -68						; size = 4
_lpViewOD$ = -64					; size = 4
_lpParentViewEntityCsr$1 = -60				; size = 4
_hViewCsr$ = -56					; size = 4
_hInstanceOwningTask$ = -52				; size = 4
_uEntities$ = -48					; size = 2
_lpViewEntity$ = -44					; size = 4
_nHierNbr$ = -40					; size = 2
_lpViewCsr$ = -36					; size = 4
_lpViewOI$ = -32					; size = 4
_lpViewEntityCsr$ = -28					; size = 4
_szDateTime$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_lpCurrentTask$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lControl$ = 16						; size = 4
_fnActivateEmptyObjectInstance PROC

; 8885 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8886 :    LPTASK            hInstanceOwningTask;
; 8887 :    LPTASK            lpInstanceOwningTask;
; 8888 :    LPVIEWOD          lpViewOD;
; 8889 :    LPVIEWOI          lpViewOI;
; 8890 :    LPVIEWCSR         lpViewCsr;
; 8891 :    LPVIEWENTITY      lpViewEntity;
; 8892 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 8893 :    zCHAR             szDateTime[ 20 ];
; 8894 :    zPVOID            hViewOI;
; 8895 :    zPVOID            hViewCsr;
; 8896 :    zUSHORT           uEntities;
; 8897 :    zSHORT            nHierNbr;
; 8898 : 
; 8899 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 8900 : 
; 8901 :    // Determine the task which owns the instance, NOTE, this task
; 8902 :    // should be returned by fnValidView in the future since fnValidView
; 8903 :    // has already done the same search! Gig...9/1/92
; 8904 :    if ( lpView->bApplicationView )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN7@fnActivate

; 8905 :       hInstanceOwningTask = AnchorBlock->hMainTask;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	mov	DWORD PTR _hInstanceOwningTask$[ebp], edx
	jmp	SHORT $LN8@fnActivate
$LN7@fnActivate:

; 8906 :    else
; 8907 :       hInstanceOwningTask = lpView->hTask;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hInstanceOwningTask$[ebp], ecx
$LN8@fnActivate:

; 8908 : 
; 8909 :    lpInstanceOwningTask = zGETPTR( hInstanceOwningTask );

	mov	edx, DWORD PTR _hInstanceOwningTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstanceOwningTask$[ebp], eax

; 8910 : 
; 8911 :    // Create a ViewOI Record
; 8912 :    // NOTE: We create view oi records in the main dataspace so all
; 8913 :    // tasks can go through the ViewOI's on clean-up to determine if
; 8914 :    // an application is in use
; 8915 :    hViewOI = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10018					; 00002722H
	push	0
	push	1
	push	65					; 00000041H
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewOI$[ebp], eax

; 8916 :                                sizeof( ViewOI_Record ), 1, 0, iViewOI );
; 8917 :    lpViewOI = zGETPTR( hViewOI );

	mov	edx, DWORD PTR _hViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8918 :    if ( lpViewOI == 0 )

	cmp	DWORD PTR _lpViewOI$[ebp], 0
	jne	SHORT $LN9@fnActivate

; 8919 :    {
; 8920 :    // fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 8921 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnActivate
$LN9@fnActivate:

; 8922 :    }
; 8923 : 
; 8924 :    // Get the count of entities.
; 8925 :    uEntities = lpViewOD->uEntities;

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	cx, WORD PTR [eax+234]
	mov	WORD PTR _uEntities$[ebp], cx

; 8926 : 
; 8927 :    // Allocate space for View
; 8928 :    // Create a ViewOI Record
; 8929 :    hViewCsr = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10019					; 00002723H
	push	0
	push	1
	movzx	edx, WORD PTR _uEntities$[ebp]
	imul	eax, edx, 30
	add	eax, 46					; 0000002eH
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewCsr$[ebp], eax

; 8930 :                                 sizeof( ViewCsrRecord ) + (zULONG)
; 8931 :                                   (uEntities * sizeof( ViewEntityCsrRecord )),
; 8932 :                                 1, 0, iViewCsr );
; 8933 :    lpViewCsr = zGETPTR( hViewCsr );

	mov	eax, DWORD PTR _hViewCsr$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8934 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $LN10@fnActivate

; 8935 :    {
; 8936 :       fnFreeDataspace( lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 8937 :    // fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 8938 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnActivate
$LN10@fnActivate:

; 8939 :    }
; 8940 : 
; 8941 :    // Set up View OI record
; 8942 :    lpViewOI->hViewOD            = zGETHNDL( lpViewOD );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 8943 :    lpViewOI->hFirstViewCsr      = hViewCsr;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [edx+10], eax

; 8944 :    lpViewOI->hTask              = hInstanceOwningTask;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _hInstanceOwningTask$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 8945 :    lpViewOI->hAllocTask         = hInstanceOwningTask;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _hInstanceOwningTask$[ebp]
	mov	DWORD PTR [eax+18], ecx

; 8946 : 
; 8947 :    // Put date time stamp into View OI record.
; 8948 :    SysGetDateTime( szDateTime );

	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	call	_SysGetDateTime@4

; 8949 :    UfStringToDateTime( szDateTime, (LPDATETIME) &(lpViewOI->DateTime) );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 30					; 0000001eH
	push	eax
	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	call	_UfStringToDateTime@8

; 8950 :    zstrcpy( lpViewOI->szRelease, szlReleaseCompatible );  // initialize release for compatiblity

	mov	edx, DWORD PTR _szlReleaseCompatible
	push	edx
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	call	_strcpy
	add	esp, 8

; 8951 : 
; 8952 :    // Mark View OI as read only if requested, and the View also ...
; 8953 :    if ( lControl & zREADONLY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN11@fnActivate

; 8954 :    {
; 8955 :       lpViewOI->bReadOnly = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 4
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN11@fnActivate:

; 8956 :    }
; 8957 : 
; 8958 :    if ( lControl & zMULTIPLE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN12@fnActivate

; 8959 :       lpViewOI->bMultipleRootLevels = TRUE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 1
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
	jmp	SHORT $LN13@fnActivate
$LN12@fnActivate:

; 8960 :    else
; 8961 :       lpViewOI->bMultipleRootLevels = FALSE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN13@fnActivate:

; 8962 : 
; 8963 :    // Set up View Cursor Record
; 8964 :    lpViewCsr->hView             = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 8965 :    lpViewCsr->hViewOI           = hViewOI;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _hViewOI$[ebp]
	mov	DWORD PTR [edx+10], eax

; 8966 :    lpViewCsr->uEntities         = uEntities;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	dx, WORD PTR _uEntities$[ebp]
	mov	WORD PTR [ecx+34], dx

; 8967 :    lpViewCsr->nCurrentSelectSet = 0x0001;

	mov	eax, 1
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	WORD PTR [ecx+36], ax

; 8968 : 
; 8969 :    // Set the View Csr in the View
; 8970 :    lpView->hViewCsr             = hViewCsr;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [edx+10], eax

; 8971 : 
; 8972 :    // Initialize ViewEntityCsr records
; 8973 :    lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 8974 :    lpViewEntityCsr = (LPVIEWENTITYCSR) (lpViewCsr + 1);

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	add	eax, 46					; 0000002eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 8975 : 
; 8976 :    // Double assignment ...
; 8977 :    lpViewCsr->hRootViewEntityCsr  =         // continued ...

	push	0
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnCreateEntityCsrHandle@12
	mov	DWORD PTR tv171[ebp], eax
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR tv171[ebp]
	mov	DWORD PTR [eax+14], ecx
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR tv171[ebp]
	mov	DWORD PTR [edx+18], eax

; 8978 :    lpViewCsr->hFirstOD_EntityCsr =
; 8979 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 0 );
; 8980 :    nHierNbr = 1;

	mov	ecx, 1
	mov	WORD PTR _nHierNbr$[ebp], cx
$LN4@fnActivate:

; 8981 :    for ( ; ; )
; 8982 :    {
; 8983 :       lpViewEntityCsr->nTableID    = iViewEntityCsr;

	mov	edx, 10023				; 00002727H
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	WORD PTR [eax], dx

; 8984 :       lpViewEntityCsr->hViewCsr    = hViewCsr;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR _hViewCsr$[ebp]
	mov	DWORD PTR [ecx+18], edx

; 8985 :       lpViewEntityCsr->hNextHier   =

	push	1
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+2], eax

; 8986 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 1 );
; 8987 :       lpViewEntityCsr->hViewEntity = zGETHNDL( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 8988 :       lpViewEntityCsr->nLevel      = lpViewEntity->nLevel;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	cx, WORD PTR [eax+215]
	mov	WORD PTR [edx+22], cx

; 8989 :       lpViewEntityCsr->nHierNbr    = nHierNbr;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ax, WORD PTR _nHierNbr$[ebp]
	mov	WORD PTR [edx+24], ax

; 8990 :       nHierNbr++;

	mov	cx, WORD PTR _nHierNbr$[ebp]
	add	cx, 1
	mov	WORD PTR _nHierNbr$[ebp], cx

; 8991 : 
; 8992 :       if ( lpViewEntity->hPrevHier )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+6], 0
	je	SHORT $LN14@fnActivate

; 8993 :       {
; 8994 :          LPVIEWENTITYCSR lpParentViewEntityCsr;
; 8995 : 
; 8996 :          lpViewEntityCsr->hPrevHier =

	push	-1
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+6], eax

; 8997 :                   fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, -1 );
; 8998 :          lpParentViewEntityCsr = zGETPTR( lpViewEntityCsr->hPrevHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$1[ebp], eax
$LN5@fnActivate:

; 8999 :          while ( lpParentViewEntityCsr->nLevel >= lpViewEntityCsr->nLevel )

	mov	edx, DWORD PTR _lpParentViewEntityCsr$1[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	cmp	eax, edx
	jl	SHORT $LN6@fnActivate

; 9000 :          {
; 9001 :             lpParentViewEntityCsr = zGETPTR( lpParentViewEntityCsr->hPrevHier );

	mov	eax, DWORD PTR _lpParentViewEntityCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntityCsr$1[ebp], eax

; 9002 :          }

	jmp	SHORT $LN5@fnActivate
$LN6@fnActivate:

; 9003 : 
; 9004 :          lpViewEntityCsr->hParent =

	push	0
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpParentViewEntityCsr$1[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+10], eax
$LN14@fnActivate:

; 9005 :                fnCreateEntityCsrHandle( lpParentViewEntityCsr, lpViewCsr, 0 );
; 9006 :       // if ( lpViewEntityCsr->hParent == (LPVIEWENTITYCSR) 1 )
; 9007 :       //    SysMessageBox( 0, "fnActivateEmptyObjectInstance", "1", -1 );
; 9008 :       }
; 9009 : 
; 9010 :       lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 9011 : 
; 9012 :       if ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN15@fnActivate

; 9013 :          lpViewEntityCsr++;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx
	jmp	SHORT $LN16@fnActivate
$LN15@fnActivate:

; 9014 :       else
; 9015 :       {
; 9016 :          lpViewEntityCsr->hNextHier = 0;  // end ViewEntityCsr chain

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+2], 0

; 9017 :          break;

	jmp	SHORT $LN3@fnActivate
$LN16@fnActivate:

; 9018 :       }
; 9019 :    }

	jmp	$LN4@fnActivate
$LN3@fnActivate:

; 9020 : 
; 9021 :    // Chain ViewOI to the application task
; 9022 :    lpViewOI->hNextViewOI = lpInstanceOwningTask->hFirstViewOI;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _lpInstanceOwningTask$[ebp]
	mov	edx, DWORD PTR [ecx+98]
	mov	DWORD PTR [eax+2], edx

; 9023 :    lpInstanceOwningTask->hFirstViewOI = hViewOI;

	mov	eax, DWORD PTR _lpInstanceOwningTask$[ebp]
	mov	ecx, DWORD PTR _hViewOI$[ebp]
	mov	DWORD PTR [eax+98], ecx

; 9024 : 
; 9025 :    return( 0 );

	xor	eax, eax
$LN1@fnActivate:

; 9026 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnActivateEmptyObjectInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lTickCount$ = -196					; size = 4
_lpViewCsr$ = -192					; size = 4
tv672 = -188						; size = 4
tv429 = -184						; size = 4
tv428 = -180						; size = 4
_lpRootEntityInstance$1 = -176				; size = 4
_lTempControl$2 = -172					; size = 4
tv232 = -168						; size = 4
tv231 = -164						; size = 4
_nSaveRC$3 = -160					; size = 2
_k$4 = -156						; size = 2
_nEOF$ = -152						; size = 2
_lpOwningTask$ = -148					; size = 4
_lpCurrentTask$ = -144					; size = 4
_lpViewOD$ = -140					; size = 4
_nState$5 = -136					; size = 2
_bContainsOptimisticOIs$ = -129				; size = 1
_vOrigView$ = -128					; size = 4
_vQualView$ = -124					; size = 4
_lpView$ = -120						; size = 4
_lpViewOI$ = -116					; size = 4
_pchLine$ = -112					; size = 4
_nRC$ = -108						; size = 2
_sz$6 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_pvReturnView$ = 8					; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_lpAppQualView$ = 16					; size = 4
_lControl$ = 20						; size = 4
_lpfnStreamFunc$ = 24					; size = 4
_lpvData$ = 28						; size = 4
_SfActivateOI_FromStream@24 PROC

; 11750: {

	push	ebp
	mov	ebp, esp
	sub	esp, 196				; 000000c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 11751:    LPTASK            lpCurrentTask;
; 11752:    LPTASK            lpOwningTask;
; 11753:    LPVIEWCSR         lpViewCsr;
; 11754:    LPVIEWOI          lpViewOI;
; 11755:    LPVIEWOD          lpViewOD;
; 11756:    zVIEW             lpView;
; 11757:    zVIEW             vOrigView = 0;

	mov	DWORD PTR _vOrigView$[ebp], 0

; 11758:    zVIEW             vQualView = 0;

	mov	DWORD PTR _vQualView$[ebp], 0

; 11759:    zPCHAR            pchLine;
; 11760:    zLONG             lTickCount;
; 11761:    zBOOL             bContainsOptimisticOIs = FALSE;

	mov	BYTE PTR _bContainsOptimisticOIs$[ebp], 0

; 11762:    zSHORT            nEOF;
; 11763:    zSHORT            nRC;
; 11764: 
; 11765:    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	je	SHORT $LN2@SfActivate

; 11766:       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$LN2@SfActivate:

; 11767: 
; 11768:    // Init in case of error.
; 11769:    *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0

; 11770: 
; 11771:    // If task not active or disabled, return zCALL_ERROR.
; 11772:    lpCurrentTask = zGETPTR( lpAppQualView->hTask );

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 11773:    if ( lpCurrentTask == 0 )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN3@SfActivate

; 11774:    {
; 11775:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfActivate
$LN3@SfActivate:

; 11776:    }
; 11777: 
; 11778:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 12					; 0000000cH
	je	SHORT $LN4@SfActivate

; 11779:       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax
	jmp	SHORT $LN5@SfActivate
$LN4@SfActivate:

; 11780:    else
; 11781:       lpOwningTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], edx
$LN5@SfActivate:

; 11782: 
; 11783:    if ( lControl & zACTIVATE_SYSTEM )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	je	SHORT $LN6@SfActivate

; 11784:    {
; 11785:       if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 11786:                                  lpAppQualView, cpcViewOD_Name, 1 )) != 0 )

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN8@SfActivate

; 11787:       {
; 11788:       // fnOperationReturn( iSfActivateSysOI_FromFile, lpCurrentTask, 0 );
; 11789:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SfActivate
$LN8@SfActivate:

; 11790:       }
; 11791: 
; 11792: #if 0
; 11793:       if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 11794:       {
; 11795:          zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 11796:                                      zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 11797:          if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView,
; 11798:                                      nScope )) != 0 )
; 11799:          {
; 11800:             return( nRC );
; 11801:          }
; 11802:       }
; 11803: #endif
; 11804:    }

	jmp	SHORT $LN9@SfActivate
$LN6@SfActivate:

; 11805:    else
; 11806:    {
; 11807:       if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 11808:                                  lpAppQualView, cpcViewOD_Name, 0 )) != 0 )

	push	0
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@SfActivate

; 11809:       {
; 11810:          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SfActivate
$LN9@SfActivate:

; 11811:       }
; 11812: 
; 11813: #if 0
; 11814:       if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 11815:       {
; 11816:          zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 11817:                                      zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 11818:          if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView, nScope )) != 0 )
; 11819:             return( nRC );
; 11820:       }
; 11821: #endif
; 11822:    }
; 11823: 
; 11824:    lpView   = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 11825:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 11826: 
; 11827:    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11828:    if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN10@SfActivate

; 11829:       goto EndOfFunction;

	jmp	$EndOfFunction$68
$LN10@SfActivate:

; 11830: 
; 11831:    //======================================================================
; 11832:    // Retrieve the first line from the stream and determine if the stream
; 11833:    // is a binary or ASCII stream.
; 11834:    //======================================================================
; 11835: 
; 11836:    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 11837:    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 11838: 
; 11839:    nEOF = (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	mov	WORD PTR _nEOF$[ebp], ax

; 11840:    if ( nEOF == 0 || nEOF == zCALL_ERROR )

	movsx	edx, WORD PTR _nEOF$[ebp]
	test	edx, edx
	je	SHORT $LN12@SfActivate
	movsx	eax, WORD PTR _nEOF$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN11@SfActivate
$LN12@SfActivate:

; 11841:    {
; 11842:       //  "KZOEE072 - Error reading instance file "
; 11843:    // fnIssueCoreError( lpCurrentTask, lpView, 16, 72, 0, szOpenFileName, 0 );
; 11844:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfActivate
$LN11@SfActivate:

; 11845:    }
; 11846: 
; 11847: #if 0    // sample header
; 11848: rZeidon    SPARDA01 TZEREMDO 03/01/96   09:03:16 1.0a
; 11849: 
; 11850:       // sample new header
; 11851: z0100-Zeidon    SPARDA01 TZEREMDO 03/01/96   09:03:16 1.0a
; 11852: z1000-Zeidon    ACCOUNT  TZWDLGSO 04/18/07   09:18:42 1.0a2
; 11853: #endif
; 11854: 
; 11855:    // DGC 10/23/96  New header style where binary, incremental, and compressed
; 11856:    // information is stored as bit-flags.
; 11857:    if ( *pchLine == 'z' )

	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 122				; 0000007aH
	jne	$LN13@SfActivate

; 11858:    {
; 11859:       // New header style.
; 11860:       if ( zstrncmp( pchLine + 6, szlmZeidon, 6 ) != 0 )

	push	6
	mov	eax, DWORD PTR _szlmZeidon
	push	eax
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 6
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN15@SfActivate

; 11861:       {
; 11862:          //  "KZOEE073 - Invalid instance file header in "
; 11863:       // fnIssueCoreError( lpCurrentTask, lpView, 16, 73, 0, szOpenFileName, 0 );
; 11864:          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfActivate
$LN15@SfActivate:

; 11865:       }
; 11866: 
; 11867:       // Just got the header ... set the release value from the file
; 11868:       // header into the view (object instance) release value. (dks 3/5/96)
; 11869:       if ( zstrlen( pchLine ) > 55 )

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 55					; 00000037H
	jbe	SHORT $LN16@SfActivate

; 11870:       {
; 11871:          zstrncpy( lpViewOI->szRelease, pchLine + 54, 8 );

	push	8
	mov	eax, DWORD PTR _pchLine$[ebp]
	add	eax, 54					; 00000036H
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 11872:          lpViewOI->szRelease[ 8 ] = 0;

	mov	edx, 1
	shl	edx, 3
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	BYTE PTR [eax+edx+56], 0
$LN16@SfActivate:

; 11873:       }
; 11874: 
; 11875:       if ( pchLine[ 2 ] == '1' )

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 49					; 00000031H
	jne	SHORT $LN17@SfActivate

; 11876:          lControl |= zINCREMENTAL;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 65536				; 00010000H
	mov	DWORD PTR _lControl$[ebp], ecx
	jmp	SHORT $LN18@SfActivate
$LN17@SfActivate:

; 11877:       else
; 11878:          lControl &= ~zINCREMENTAL;

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, -65537				; fffeffffH
	mov	DWORD PTR _lControl$[ebp], edx
$LN18@SfActivate:

; 11879: 
; 11880:       if ( pchLine[ 3 ] == '1' )

	mov	eax, 1
	imul	ecx, eax, 3
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 49					; 00000031H
	jne	SHORT $LN19@SfActivate

; 11881:          lControl |= zCOMPRESSED;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 131072				; 00020000H
	mov	DWORD PTR _lControl$[ebp], ecx
	jmp	SHORT $LN20@SfActivate
$LN19@SfActivate:

; 11882:       else
; 11883:          lControl &= ~zCOMPRESSED;

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, -131073				; fffdffffH
	mov	DWORD PTR _lControl$[ebp], edx
$LN20@SfActivate:

; 11884: 
; 11885:       if ( pchLine[ 4 ] == '1' )

	mov	eax, 1
	shl	eax, 2
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 49					; 00000031H
	jne	SHORT $LN21@SfActivate

; 11886:          bContainsOptimisticOIs = TRUE;

	mov	BYTE PTR _bContainsOptimisticOIs$[ebp], 1
$LN21@SfActivate:

; 11887: 
; 11888:       // Attrib flags have been written if the 5th flag is set or if the OI is
; 11889:       // written in incremental/compressed form.
; 11890:       if ( pchLine[ 5 ] == '1' ||

	mov	eax, 1
	imul	ecx, eax, 5
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 49					; 00000031H
	je	SHORT $LN23@SfActivate
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN22@SfActivate
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	je	SHORT $LN22@SfActivate
$LN23@SfActivate:

; 11891:            ((lControl & zCOMPRESSED) && (lControl & zINCREMENTAL)) )
; 11892:       {
; 11893:          lControl |= zATTRIBFLAGS;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 33554432				; 02000000H
	mov	DWORD PTR _lControl$[ebp], eax
$LN22@SfActivate:

; 11894:       }
; 11895: 
; 11896:       // This used to be the binary flag.  For now it tells us whether the
; 11897:       // ER_Date is stored with the LOD.
; 11898:       if ( pchLine[ 1 ] == '1' && (lControl & zINCREMENTAL) != 0 )

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 49					; 00000031H
	jne	$LN25@SfActivate
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 65536				; 00010000H
	je	$LN25@SfActivate

; 11899:       {
; 11900:          // Get the ER date.
; 11901:          (*lpfnStreamFunc)( lpView, lpvData, &pchLine, 0, 0 );

	push	0
	push	0
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]

; 11902: 
; 11903:          // Check to see if the ER dates match.  We only worry about this if
; 11904:          // the OI is compressed.  If it's not compressed then we can probably
; 11905:          // handle any differences.
; 11906:          if ( (lControl & zCOMPRESSED) &&
; 11907:               pchLine[ 0 ] && lpViewOD->szER_Date[ 0 ] &&

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 131072				; 00020000H
	je	$LN25@SfActivate
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLine$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN25@SfActivate
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+248]
	test	ecx, ecx
	je	$LN25@SfActivate
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN62@SfActivate
	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv232[ebp], eax
	jmp	SHORT $LN63@SfActivate
$LN62@SfActivate:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN60@SfActivate
	mov	DWORD PTR tv231[ebp], 1
	jmp	SHORT $LN61@SfActivate
$LN60@SfActivate:
	mov	DWORD PTR tv231[ebp], -1
$LN61@SfActivate:
	mov	eax, DWORD PTR tv231[ebp]
	mov	DWORD PTR tv232[ebp], eax
$LN63@SfActivate:
	cmp	DWORD PTR tv232[ebp], 0
	je	SHORT $LN25@SfActivate

; 11908:               zstrcmp( lpViewOD->szER_Date, pchLine ) != 0 )
; 11909:          {
; 11910:             // "KZOEE088 - Compressed OI is out of sync with LOD/XOD"
; 11911:             fnIssueCoreError( lpCurrentTask, lpView, 16, 88, 0, lpViewOD->szName, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	0
	push	88					; 00000058H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 11912:             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfActivate
$LN25@SfActivate:

; 11913:          }
; 11914:       }
; 11915:    }

	jmp	$LN29@SfActivate
$LN13@SfActivate:

; 11916:    else
; 11917:    {
; 11918:       // Old header style.
; 11919:       if ( zstrncmp( pchLine + 1, szlmZeidon, 6 ) )

	push	6
	mov	ecx, DWORD PTR _szlmZeidon
	push	ecx
	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN26@SfActivate

; 11920:       {
; 11921:          //  "KZOEE073 - Invalid instance file header in "
; 11922:       // fnIssueCoreError( lpCurrentTask, lpView, 16, 73, 0, szOpenFileName, 0 );
; 11923:          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfActivate
$LN26@SfActivate:

; 11924:       }
; 11925: 
; 11926:       // just got the header ... set the release value from the file
; 11927:       // header into the view (object instance) release value. (dks 3/5/96)
; 11928:       if ( zstrlen( pchLine ) > 50 )

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 50					; 00000032H
	jbe	SHORT $LN27@SfActivate

; 11929:       {
; 11930:          zstrncpy( lpViewOI->szRelease, pchLine + 49, 8 );

	push	8
	mov	ecx, DWORD PTR _pchLine$[ebp]
	add	ecx, 49					; 00000031H
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 11931:          lpViewOI->szRelease[ 8 ] = 0;

	mov	eax, 1
	shl	eax, 3
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	BYTE PTR [ecx+eax+56], 0
$LN27@SfActivate:

; 11932:       }
; 11933: 
; 11934:       // Set Incremental.
; 11935:       if ( pchLine[ 0 ] == 'r' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 114				; 00000072H
	jne	SHORT $LN28@SfActivate

; 11936:          lControl |= zINCREMENTAL;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 65536				; 00010000H
	mov	DWORD PTR _lControl$[ebp], eax
	jmp	SHORT $LN29@SfActivate
$LN28@SfActivate:

; 11937:       else
; 11938:          lControl &= ~zINCREMENTAL;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, -65537				; fffeffffH
	mov	DWORD PTR _lControl$[ebp], ecx
$LN29@SfActivate:

; 11939:    }
; 11940: 
; 11941:    // Set Root only indicator.
; 11942:    if ( lControl & zACTIVATE_ROOTONLY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 268435456				; 10000000H
	je	SHORT $LN30@SfActivate

; 11943:       lpViewOI->bRootOnly = TRUE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 2
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN30@SfActivate:

; 11944: 
; 11945:    nRC = fnActivateOI_FromTextStream( lpView, lpfnStreamFunc,

	lea	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11946:                                       lpvData, &lControl );
; 11947:    if ( nRC < -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jge	SHORT $LN31@SfActivate

; 11948:       goto EndOfFunction;

	jmp	$EndOfFunction$68
$LN31@SfActivate:

; 11949: 
; 11950:    // If the stream has optimistic locking information try to activate
; 11951:    // the "original view" and the qualification view.  These should appear
; 11952:    // in the stream after the main view.
; 11953:    if ( bContainsOptimisticOIs )

	movzx	edx, BYTE PTR _bContainsOptimisticOIs$[ebp]
	test	edx, edx
	je	$LN32@SfActivate

; 11954:    {
; 11955:       zLONG  lTempControl;
; 11956:       zSHORT nSaveRC = nRC;

	mov	ax, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nSaveRC$3[ebp], ax

; 11957: 
; 11958:       // lTempControl is what we use to activate the original OI and the
; 11959:       // qualification OI.  Since no OI is OK, add it to the flag.
; 11960:       lTempControl = lControl | zNOI_OKAY;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 512				; 00000200H
	mov	DWORD PTR _lTempControl$2[ebp], ecx

; 11961: 
; 11962:       if ( lControl & zACTIVATE_SYSTEM )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 536870912				; 20000000H
	je	SHORT $LN33@SfActivate

; 11963:       {
; 11964:          nRC = fnDeclareView( &vOrigView, lpOwningTask,

	push	1
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vOrigView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 11965:                               lpAppQualView, cpcViewOD_Name, 1 );
; 11966:       }

	jmp	SHORT $LN34@SfActivate
$LN33@SfActivate:

; 11967:       else
; 11968:       {
; 11969:          nRC = fnDeclareView( &vOrigView, lpOwningTask,

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
$LN34@SfActivate:

; 11970:                               lpAppQualView, cpcViewOD_Name, 0 );
; 11971:       }
; 11972: 
; 11973:       if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN35@SfActivate

; 11974:          goto EndOfFunction;

	jmp	$EndOfFunction$68
$LN35@SfActivate:

; 11975: 
; 11976:       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, vOrigView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11977: 
; 11978:       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN36@SfActivate

; 11979:          goto EndOfFunction;

	jmp	$EndOfFunction$68
$LN36@SfActivate:

; 11980: 
; 11981:       nRC = fnActivateOI_FromTextStream( vOrigView, lpfnStreamFunc,

	lea	ecx, DWORD PTR _lTempControl$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11982:                                          lpvData, &lTempControl );
; 11983: 
; 11984:       if ( nRC < -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jge	SHORT $LN37@SfActivate

; 11985:          goto EndOfFunction;

	jmp	$EndOfFunction$68
$LN37@SfActivate:

; 11986: 
; 11987:       nRC = fnDeclareView( &vQualView, lpOwningTask,

	push	1
	push	OFFSET $SG17525
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vQualView$[ebp]
	push	edx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 11988:                            lpAppQualView, "KZDBHQUA", 1 );
; 11989: 
; 11990:       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN38@SfActivate

; 11991:          goto EndOfFunction;

	jmp	$EndOfFunction$68
$LN38@SfActivate:

; 11992: 
; 11993:       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, vQualView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 11994: 
; 11995:       if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN39@SfActivate

; 11996:          goto EndOfFunction;

	jmp	$EndOfFunction$68
$LN39@SfActivate:

; 11997: 
; 11998:       nRC = fnActivateOI_FromTextStream( vQualView, lpfnStreamFunc,

	lea	edx, DWORD PTR _lTempControl$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vQualView$[ebp]
	push	edx
	call	_fnActivateOI_FromTextStream
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 11999:                                          lpvData, &lTempControl );
; 12000: 
; 12001:       if ( nRC < -1 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -1
	jge	SHORT $LN40@SfActivate

; 12002:          goto EndOfFunction;

	jmp	$EndOfFunction$68
	jmp	SHORT $LN42@SfActivate
$LN40@SfActivate:

; 12003:       else
; 12004:       if ( nRC == -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jne	SHORT $LN42@SfActivate

; 12005:       {
; 12006:          // Qual view is empty so we really don't need it.
; 12007:          fnDropView( vQualView );

	mov	edx, DWORD PTR _vQualView$[ebp]
	push	edx
	call	_fnDropView@4

; 12008:          vQualView = 0;

	mov	DWORD PTR _vQualView$[ebp], 0
$LN42@SfActivate:

; 12009:       }
; 12010: 
; 12011:       nRC = nSaveRC;

	mov	ax, WORD PTR _nSaveRC$3[ebp]
	mov	WORD PTR _nRC$[ebp], ax

; 12012: 
; 12013:       vOrigView->bOrigView   = TRUE;

	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 12014:       vOrigView->bViewLocked = TRUE;

	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 12015:       vOrigView->hMainOI     = zGETHNDL( lpViewOI );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [edx+26], eax

; 12016:       lpViewOI->vOriginalOI  = zGETHNDL( vOrigView );

	mov	eax, DWORD PTR _vOrigView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 12017: 
; 12018:       vQualView->bQualView   = TRUE;

	mov	edx, DWORD PTR _vQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12019:       vQualView->bViewLocked = TRUE;

	mov	edx, DWORD PTR _vQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 12020:       vQualView->hMainOI     = zGETHNDL( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vQualView$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 12021:       lpViewOI->vQualOI      = zGETHNDL( vQualView );

	mov	edx, DWORD PTR _vQualView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+44], eax
$LN32@SfActivate:

; 12022:    }
; 12023: 
; 12024:    // Reset the view if successful.
; 12025:    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN45@SfActivate

; 12026:    {
; 12027:       if ( (lControl & zSAVE_CURSORS) == 0 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 262144				; 00040000H
	jne	SHORT $LN44@SfActivate

; 12028:          fnResetView( lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$LN44@SfActivate:

; 12029: 
; 12030:       if ( lControl & zREADONLY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN45@SfActivate

; 12031:          lpView->bReadOnly = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 64					; 00000040H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx
$LN45@SfActivate:

; 12032:    }
; 12033: 
; 12034:    // Now that we are finished activating, check the root instance
; 12035:    // to determine if multiple roots were loaded.
; 12036:    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN47@SfActivate

; 12037:    {
; 12038:       LPENTITYINSTANCE lpRootEntityInstance =

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$1[ebp], eax

; 12039:                                  zGETPTR( lpViewOI->hRootEntityInstance );
; 12040: 
; 12041:       if ( lpRootEntityInstance && lpRootEntityInstance->hNextTwin )

	cmp	DWORD PTR _lpRootEntityInstance$1[ebp], 0
	je	SHORT $LN47@SfActivate
	mov	eax, DWORD PTR _lpRootEntityInstance$1[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN47@SfActivate

; 12042:       {
; 12043:          nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx
$LN47@SfActivate:

; 12044:       }
; 12045:    }
; 12046: 
; 12047: #ifdef __ACTIVATE_CONSTRAINTS__
; 12048:    if ( (lControl & zACTIVATE_NOCONSTRAINTS) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 16777216				; 01000000H
	jne	$EndOfFunction$68

; 12049:    {
; 12050:       if ( lpViewOD->bActivateConstraint && nRC >= -1 )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 3
	and	ecx, 1
	je	$EndOfFunction$68
	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	$EndOfFunction$68

; 12051:       {
; 12052:          zSHORT   k;
; 12053:          zSHORT   nState = zOCE_STATE_FILE;

	mov	eax, 1
	mov	WORD PTR _nState$5[ebp], ax

; 12054: 
; 12055:          if ( lControl & zLEVEL_SYSTEM )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 8
	je	SHORT $LN50@SfActivate

; 12056:             nState += zOCE_STATE_SYSTEM;

	movsx	edx, WORD PTR _nState$5[ebp]
	add	edx, 4
	mov	WORD PTR _nState$5[ebp], dx
$LN50@SfActivate:

; 12057: 
; 12058:          if ( nRC == -2 )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN51@SfActivate

; 12059:             nState += zOCE_STATE_NOI;

	movsx	ecx, WORD PTR _nState$5[ebp]
	add	ecx, 8
	mov	WORD PTR _nState$5[ebp], cx
$LN51@SfActivate:

; 12060: 
; 12061:          k = fnInvokeOCEOperation( lpView, lpCurrentTask,

	movzx	edx, WORD PTR _nState$5[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _k$4[ebp], ax

; 12062:                                    zOCE_ACTIVATE, nState );
; 12063:          if ( k )

	movsx	edx, WORD PTR _k$4[ebp]
	test	edx, edx
	je	SHORT $EndOfFunction$68

; 12064:          {
; 12065:             fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 12066:             *pvReturnView = 0;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], 0

; 12067:          // fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );
; 12068:             return( k );

	mov	ax, WORD PTR _k$4[ebp]
	jmp	$LN1@SfActivate
$EndOfFunction$68:

; 12069:          }
; 12070:       }
; 12071:    }
; 12072: #endif
; 12073: 
; 12074: EndOfFunction:
; 12075: 
; 12076:    // Based on the return code, see if we have to reset the view to the
; 12077:    // prior instance or clean up the prior instance.
; 12078:    // note: rc = indicates multiple level1 roots present
; 12079:    if ( nRC >= -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $LN53@SfActivate

; 12080:    {
; 12081:       lpViewOI->bUpdatedFile = FALSE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -33				; ffffffdfH
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 12082:    }

	jmp	SHORT $LN56@SfActivate
$LN53@SfActivate:

; 12083:    else
; 12084:    {
; 12085:       fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 12086:       *pvReturnView = 0;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], 0

; 12087: 
; 12088:       if ( vOrigView )

	cmp	DWORD PTR _vOrigView$[ebp], 0
	je	SHORT $LN55@SfActivate

; 12089:          fnDropView( vOrigView );

	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	_fnDropView@4
$LN55@SfActivate:

; 12090: 
; 12091:       if ( vQualView )

	cmp	DWORD PTR _vQualView$[ebp], 0
	je	SHORT $LN56@SfActivate

; 12092:          fnDropView( vQualView );

	mov	eax, DWORD PTR _vQualView$[ebp]
	push	eax
	call	_fnDropView@4
$LN56@SfActivate:

; 12093:    }
; 12094: 
; 12095:    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	and	edx, 1
	je	$LN58@SfActivate

; 12096:    {
; 12097:       zCHAR sz[ 100 ];
; 12098: 
; 12099:       if ( zstrcmp( lpViewOD->szName, "TZCMULWO" ) != 0 )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	movsx	edx, BYTE PTR $SG17547
	cmp	ecx, edx
	jne	SHORT $LN66@SfActivate
	push	OFFSET $SG17548
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv429[ebp], eax
	jmp	SHORT $LN67@SfActivate
$LN66@SfActivate:
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	movsx	eax, BYTE PTR $SG17549
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN64@SfActivate
	mov	DWORD PTR tv428[ebp], 1
	jmp	SHORT $LN65@SfActivate
$LN64@SfActivate:
	mov	DWORD PTR tv428[ebp], -1
$LN65@SfActivate:
	mov	ecx, DWORD PTR tv428[ebp]
	mov	DWORD PTR tv429[ebp], ecx
$LN67@SfActivate:
	cmp	DWORD PTR tv429[ebp], 0
	je	SHORT $LN58@SfActivate

; 12100:       {
; 12101:          zsprintf( sz, "(%s) = %lf seconds", lpViewOD->szName,

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR tv672[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv672[ebp]
	mov	edx, DWORD PTR tv672[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG17550
	lea	ecx, DWORD PTR _sz$6[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 12102:                    (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND );
; 12103:          TraceLineS( "(oi) Total time for SfActivateOI_FromStream ", sz );

	lea	edx, DWORD PTR _sz$6[ebp]
	push	edx
	push	OFFSET $SG17551
	call	_TraceLineS@8
$LN58@SfActivate:

; 12104:       }
; 12105:    }
; 12106: 
; 12107:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfActivate:

; 12108: 
; 12109: } // SfActivateOI_FromStream

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_SfActivateOI_FromStream@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lTickCount$ = -296					; size = 4
_lpViewCsr$ = -292					; size = 4
_lpCurrentTask$ = -288					; size = 4
tv461 = -284						; size = 4
_pchFileNmp$ = -280					; size = 4
_lpViewOD$ = -276					; size = 4
_lpViewOI$ = -272					; size = 4
_k$ = -268						; size = 2
_pchLine$ = -264					; size = 4
_nRC$ = -260						; size = 2
_bOptimistic$ = -254					; size = 1
_bIncremental$ = -253					; size = 1
_FileHeader$ = -252					; size = 73
_sz$1 = -176						; size = 100
_szTemp$ = -76						; size = 50
_szDateTime$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcHeaderName$ = 12					; size = 4
_lControl$ = 16						; size = 4
_lpfnStreamFunc$ = 20					; size = 4
_lpvData$ = 24						; size = 4
_SfWriteOI_ToStream@20 PROC

; 7933 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7934 :    LPTASK               lpCurrentTask;
; 7935 :    LPVIEWOD             lpViewOD;
; 7936 :    LPVIEWOI             lpViewOI;
; 7937 :    LPVIEWCSR            lpViewCsr;
; 7938 :    FileHeaderRecord     FileHeader;
; 7939 :    zPCHAR               pchLine;
; 7940 :    zPCHAR               pchFileNmp;
; 7941 :    zCHAR                szDateTime[ 20 ];
; 7942 :    zCHAR                szTemp[ 50 ];
; 7943 :    zLONG                lTickCount;
; 7944 :    zBOOL                bOptimistic;
; 7945 :    zBOOL                bIncremental;
; 7946 :    zSHORT               k;
; 7947 :    zSHORT               nRC;
; 7948 : 
; 7949 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	and	ecx, 1
	je	SHORT $LN7@SfWriteOI_

; 7950 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$LN7@SfWriteOI_:

; 7951 : 
; 7952 :    // If task not active or disabled, return zCALL_ERROR.
; 7953 :    lpCurrentTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 7954 : 
; 7955 :    // Validate that the view passed is valid
; 7956 :    if ( fnValidViewCsr( lpCurrentTask, lpView ) == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidViewCsr
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN8@SfWriteOI_

; 7957 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfWriteOI_
$LN8@SfWriteOI_:

; 7958 : 
; 7959 :    lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 7960 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 7961 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 7962 : 
; 7963 :    // Make sure OI does not contain versioned instances
; 7964 :    if ( lpViewOI->nVersionedInstances )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	SHORT $LN9@SfWriteOI_

; 7965 : #if 0  // DGC 1999.06.04  No longer an error?  It seems like we should be able
; 7966 :        // to pass OIs even if they have versions.  We will, however, only
; 7967 :        // perform Reclaim if there are no versions (we wouldn't want to get
; 7968 :        // rid of something we want).
; 7969 :    {
; 7970 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 7971 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 76, 0, 0, 0 );
; 7972 :       return( zCALL_ERROR );
; 7973 :    }
; 7974 : 
; 7975 :    // Get rid of all deadwood instances (e.g. entities that have been created
; 7976 :    // AND deleted).
; 7977 :    fnReclaimHiddenInstances( lpViewOI );
; 7978 : 
; 7979 : #else
; 7980 :       ;

	jmp	SHORT $LN10@SfWriteOI_
$LN9@SfWriteOI_:

; 7981 :    else
; 7982 :       // Get rid of all deadwood instances (e.g. entities that have been created
; 7983 :       // AND deleted).
; 7984 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$LN10@SfWriteOI_:

; 7985 : #endif
; 7986 : 
; 7987 :    // build header record
; 7988 :    zmemset( &FileHeader.chTypeIndicator, ' ', sizeof( FileHeaderRecord ) );

	push	73					; 00000049H
	push	32					; 00000020H
	lea	ecx, DWORD PTR _FileHeader$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 7989 : 
; 7990 :    // Set bIncremental and bBinary
; 7991 :    if ( lControl & zINCREMENTAL )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 65536				; 00010000H
	je	SHORT $LN11@SfWriteOI_

; 7992 :       bIncremental = TRUE;

	mov	BYTE PTR _bIncremental$[ebp], 1
	jmp	SHORT $LN12@SfWriteOI_
$LN11@SfWriteOI_:

; 7993 :    else
; 7994 :       bIncremental = FALSE;

	mov	BYTE PTR _bIncremental$[ebp], 0
$LN12@SfWriteOI_:

; 7995 : 
; 7996 :    // If the view has an "original OI" then the view was activated with
; 7997 :    // optimistic locking and we need to send the original OI as well.
; 7998 :    if ( lpViewOI->vOriginalOI )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN13@SfWriteOI_

; 7999 :       bOptimistic = TRUE;

	mov	BYTE PTR _bOptimistic$[ebp], 1
	jmp	SHORT $LN14@SfWriteOI_
$LN13@SfWriteOI_:

; 8000 :    else
; 8001 :       bOptimistic = FALSE;

	mov	BYTE PTR _bOptimistic$[ebp], 0
$LN14@SfWriteOI_:

; 8002 : 
; 8003 :    // We store information now as bit-flags.
; 8004 :    FileHeader.chTypeIndicator[ 0 ] = szlNewPortableHeader[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	eax, DWORD PTR _szlNewPortableHeader
	mov	dl, BYTE PTR [eax+edx]
	mov	BYTE PTR _FileHeader$[ebp+ecx], dl

; 8005 : 
; 8006 :    // DGC 1999.05.07
; 8007 :    // Used to be binary indicator.  Now it determines if the ER date is store
; 8008 :    // with with a compressed OI.  This flag can be re-used for something else
; 8009 :    // when all customers are using post-9j core.
; 8010 :    FileHeader.chTypeIndicator[ 1 ] = '1'; // This release always store date.

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _FileHeader$[ebp+eax], 49	; 00000031H

; 8011 : 
; 8012 :    if ( bIncremental )

	movzx	ecx, BYTE PTR _bIncremental$[ebp]
	test	ecx, ecx
	je	SHORT $LN15@SfWriteOI_

; 8013 :       FileHeader.chTypeIndicator[ 2 ] = '1';

	mov	edx, 1
	shl	edx, 1
	mov	BYTE PTR _FileHeader$[ebp+edx], 49	; 00000031H
	jmp	SHORT $LN16@SfWriteOI_
$LN15@SfWriteOI_:

; 8014 :    else
; 8015 :       FileHeader.chTypeIndicator[ 2 ] = '0';

	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _FileHeader$[ebp+eax], 48	; 00000030H
$LN16@SfWriteOI_:

; 8016 : 
; 8017 :    if ( lControl & zCOMPRESSED )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 131072				; 00020000H
	je	SHORT $LN17@SfWriteOI_

; 8018 :       FileHeader.chTypeIndicator[ 3 ] = '1';

	mov	edx, 1
	imul	eax, edx, 3
	mov	BYTE PTR _FileHeader$[ebp+eax], 49	; 00000031H
	jmp	SHORT $LN18@SfWriteOI_
$LN17@SfWriteOI_:

; 8019 :    else
; 8020 :       FileHeader.chTypeIndicator[ 3 ] = '0';

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	BYTE PTR _FileHeader$[ebp+edx], 48	; 00000030H
$LN18@SfWriteOI_:

; 8021 : 
; 8022 :    if ( bOptimistic )

	movzx	eax, BYTE PTR _bOptimistic$[ebp]
	test	eax, eax
	je	SHORT $LN19@SfWriteOI_

; 8023 :       FileHeader.chTypeIndicator[ 4 ] = '1';

	mov	ecx, 1
	shl	ecx, 2
	mov	BYTE PTR _FileHeader$[ebp+ecx], 49	; 00000031H
	jmp	SHORT $LN20@SfWriteOI_
$LN19@SfWriteOI_:

; 8024 :    else
; 8025 :       FileHeader.chTypeIndicator[ 4 ] = '0';

	mov	edx, 1
	shl	edx, 2
	mov	BYTE PTR _FileHeader$[ebp+edx], 48	; 00000030H
$LN20@SfWriteOI_:

; 8026 : 
; 8027 : #ifdef USE_ATTRIBFLAGS
; 8028 :    // Using attribute flags logic.
; 8029 :    if ( bIncremental )
; 8030 :       FileHeader.chTypeIndicator[ 5 ] = '1';
; 8031 :    else
; 8032 :       FileHeader.chTypeIndicator[ 5 ] = '0';
; 8033 : #else
; 8034 :    // Reserved for later use...
; 8035 :    FileHeader.chTypeIndicator[ 5 ] = '-';

	mov	eax, 1
	imul	ecx, eax, 5
	mov	BYTE PTR _FileHeader$[ebp+ecx], 45	; 0000002dH

; 8036 : #endif
; 8037 : 
; 8038 :    zstrcpy( FileHeader.szZeidon, szlmZeidon );

	mov	edx, DWORD PTR _szlmZeidon
	push	edx
	lea	eax, DWORD PTR _FileHeader$[ebp+6]
	push	eax
	call	_strcpy
	add	esp, 8

; 8039 : 
; 8040 :    pchFileNmp = (zPCHAR) cpcHeaderName;

	mov	ecx, DWORD PTR _cpcHeaderName$[ebp]
	mov	DWORD PTR _pchFileNmp$[ebp], ecx

; 8041 :    pchLine    = (zPCHAR) cpcHeaderName;

	mov	edx, DWORD PTR _cpcHeaderName$[ebp]
	mov	DWORD PTR _pchLine$[ebp], edx
$LN2@SfWriteOI_:

; 8042 :    while ( (pchLine = zstrchr( pchLine, cDirSep )) != 0 )

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchLine$[ebp], eax
	cmp	DWORD PTR _pchLine$[ebp], 0
	je	SHORT $LN3@SfWriteOI_

; 8043 :    {
; 8044 :       pchLine++;

	mov	edx, DWORD PTR _pchLine$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchLine$[ebp], edx

; 8045 :       pchFileNmp = pchLine;

	mov	eax, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchFileNmp$[ebp], eax

; 8046 :    }

	jmp	SHORT $LN2@SfWriteOI_
$LN3@SfWriteOI_:

; 8047 : 
; 8048 :    // we are building the header record for this file and realize that the
; 8049 :    // file name we are copying to FileHeader.szFileName may be longer than
; 8050 :    // sizeof( FileHeader.szFileName ).  This is OK since the FileHeader
; 8051 :    // structure is large enough to accomodate an overwrite.
; 8052 :    zstrcpy( FileHeader.szFileName, pchFileNmp );

	mov	ecx, DWORD PTR _pchFileNmp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _FileHeader$[ebp+16]
	push	edx
	call	_strcpy
	add	esp, 8

; 8053 :    pchLine = zstrchr( FileHeader.szFileName, '.' );

	push	46					; 0000002eH
	lea	eax, DWORD PTR _FileHeader$[ebp+16]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchLine$[ebp], eax

; 8054 :    if ( pchLine )

	cmp	DWORD PTR _pchLine$[ebp], 0
	je	SHORT $LN21@SfWriteOI_

; 8055 :    {
; 8056 :       zstrcpy( pchLine, "        " );

	push	OFFSET $SG16137
	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8057 :       pchLine[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [ecx+eax], 0
$LN21@SfWriteOI_:

; 8058 :    }
; 8059 : 
; 8060 :    SysTranslateString( FileHeader.szFileName, 'U' );

	push	85					; 00000055H
	lea	edx, DWORD PTR _FileHeader$[ebp+16]
	push	edx
	call	_SysTranslateString@8

; 8061 :    zstrcpy( FileHeader.szObjectType, lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _FileHeader$[ebp+25]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8062 :    SysGetDateTime( szDateTime );

	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	call	_SysGetDateTime@4

; 8063 :    fnDateTimeFormat( szDateTime, FileHeader.szDate, FileHeader.szTime );

	lea	eax, DWORD PTR _FileHeader$[ebp+45]
	push	eax
	lea	ecx, DWORD PTR _FileHeader$[ebp+34]
	push	ecx
	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	call	_fnDateTimeFormat
	add	esp, 12					; 0000000cH

; 8064 :    // Even if this is not a MetaOI, we should force the release level for
; 8065 :    // all files to be at the minimal level of the software.
; 8066 :    if ( MiCompareOI_ToRelease( lpView, szlReleaseCompatible ) < 0 )

	mov	eax, DWORD PTR _szlReleaseCompatible
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MiCompareOI_ToRelease@8
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN22@SfWriteOI_

; 8067 :    {
; 8068 :       MiSetOI_ReleaseForView( lpView, szlReleaseCompatible );

	mov	eax, DWORD PTR _szlReleaseCompatible
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_MiSetOI_ReleaseForView@8
$LN22@SfWriteOI_:

; 8069 :    }
; 8070 : 
; 8071 :    // if we are using new features, force to current Release
; 8072 :    if ( (lControl & zENCODE_BLOBS) || (lControl & zNO_NULL_STRING_TERM) )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 4194304				; 00400000H
	jne	SHORT $LN24@SfWriteOI_
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 8388608				; 00800000H
	je	SHORT $LN23@SfWriteOI_
$LN24@SfWriteOI_:

; 8073 :    {
; 8074 :       MiSetOI_ReleaseForView( lpView, szlReleaseCurrent );

	mov	ecx, DWORD PTR _szlReleaseCurrent
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_MiSetOI_ReleaseForView@8
$LN23@SfWriteOI_:

; 8075 :    }
; 8076 : 
; 8077 :    zstrcpy( FileHeader.szRelease, lpViewOI->szRelease );  // dks 3/5/96

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	add	eax, 56					; 00000038H
	push	eax
	lea	ecx, DWORD PTR _FileHeader$[ebp+54]
	push	ecx
	call	_strcpy
	add	esp, 8

; 8078 :    pchLine = FileHeader.chTypeIndicator;

	lea	edx, DWORD PTR _FileHeader$[ebp]
	mov	DWORD PTR _pchLine$[ebp], edx

; 8079 :    for ( k = 0; k < sizeof( FileHeaderRecord ); k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN6@SfWriteOI_
$LN4@SfWriteOI_:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN6@SfWriteOI_:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 73					; 00000049H
	jae	SHORT $LN5@SfWriteOI_

; 8080 :    {
; 8081 :       if ( pchLine[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN25@SfWriteOI_

; 8082 :          pchLine[ k ] = ' ';

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pchLine$[ebp]
	mov	BYTE PTR [ecx+eax], 32			; 00000020H
$LN25@SfWriteOI_:

; 8083 :    }

	jmp	SHORT $LN4@SfWriteOI_
$LN5@SfWriteOI_:

; 8084 : 
; 8085 :    FileHeader.nEntityInstanceRecordSize = 0;

	xor	edx, edx
	mov	WORD PTR _FileHeader$[ebp+63], dx

; 8086 : 
; 8087 :    if ( (*lpfnStreamFunc)( lpView, lpvData, (zPCHAR) &FileHeader,
; 8088 :                            0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	lea	eax, DWORD PTR _FileHeader$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN26@SfWriteOI_

; 8089 :    {
; 8090 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfWriteOI_
$LN26@SfWriteOI_:

; 8091 :    }
; 8092 : 
; 8093 :    // Write the ER date from the OD if we have incrementals.
; 8094 :    if ( bIncremental &&

	movzx	ecx, BYTE PTR _bIncremental$[ebp]
	test	ecx, ecx
	je	SHORT $LN27@SfWriteOI_
	push	83					; 00000053H
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN27@SfWriteOI_

; 8095 :         (*lpfnStreamFunc)( lpView, lpvData, lpViewOD->szER_Date,
; 8096 :                            0, zTYPE_STRING ) == zCALL_ERROR )
; 8097 :    {
; 8098 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfWriteOI_
$LN27@SfWriteOI_:

; 8099 :    }
; 8100 : 
; 8101 :    // Write the flags used to activate the OI.
; 8102 :    if ( lpViewOI->lActivateControl )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN29@SfWriteOI_

; 8103 :    {
; 8104 :       zsprintf( szTemp, "mCONTROL %lx", lpViewOI->lActivateControl );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	push	OFFSET $SG16145
	lea	eax, DWORD PTR _szTemp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8105 :       if ( (*lpfnStreamFunc)( lpView, lpvData, szTemp, 0,
; 8106 :                               zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN29@SfWriteOI_

; 8107 :       {
; 8108 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfWriteOI_
$LN29@SfWriteOI_:

; 8109 :       }
; 8110 :    }
; 8111 : 
; 8112 :    nRC = fnWriteOI_ToTextStream( lpView, lpfnStreamFunc, lpvData,

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	movzx	eax, BYTE PTR _bIncremental$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpvData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpfnStreamFunc$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 8113 :                                  bIncremental, lControl );
; 8114 : 
; 8115 :    // Write the original OI for optimistic locking.
; 8116 :    if ( nRC == 0 && bOptimistic )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN30@SfWriteOI_
	movzx	edx, BYTE PTR _bOptimistic$[ebp]
	test	edx, edx
	je	SHORT $LN30@SfWriteOI_

; 8117 :    {
; 8118 :       if ( (*lpfnStreamFunc)( lpView, lpvData, "ZEND",
; 8119 :                               0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	push	OFFSET $SG16149
	mov	eax, DWORD PTR _lpvData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN31@SfWriteOI_

; 8120 :       {
; 8121 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfWriteOI_
$LN31@SfWriteOI_:

; 8122 :       }
; 8123 : 
; 8124 :       // Write the OI to the text stream but don't save the cursors.
; 8125 :       nRC = fnWriteOI_ToTextStream( zGETPTR( lpViewOI->vOriginalOI ),

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -262145				; fffbffffH
	push	eax
	movzx	ecx, BYTE PTR _bIncremental$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN30@SfWriteOI_:

; 8126 :                                     lpfnStreamFunc,
; 8127 :                                     lpvData, bIncremental,
; 8128 :                                     ( lControl & ~zSAVE_CURSORS ) );
; 8129 :    }
; 8130 : 
; 8131 :    // Write the qualification OI for optimistic locking.
; 8132 :    if ( nRC == 0 && bOptimistic )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN34@SfWriteOI_
	movzx	ecx, BYTE PTR _bOptimistic$[ebp]
	test	ecx, ecx
	je	SHORT $LN34@SfWriteOI_

; 8133 :    {
; 8134 :       if ( (*lpfnStreamFunc)( lpView, lpvData, "ZEND",
; 8135 :                               0, zTYPE_STRING ) == zCALL_ERROR )

	push	83					; 00000053H
	push	0
	push	OFFSET $SG16152
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _lpfnStreamFunc$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN33@SfWriteOI_

; 8136 :       {
; 8137 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfWriteOI_
$LN33@SfWriteOI_:

; 8138 :       }
; 8139 : 
; 8140 :       // Write the OI to the text stream but don't save the cursors.
; 8141 :       if ( lpViewOI->vQualOI )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [edx+44], 0
	je	SHORT $LN34@SfWriteOI_

; 8142 :          nRC = fnWriteOI_ToTextStream( zGETPTR( lpViewOI->vQualOI ),

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, -262145				; fffbffffH
	push	eax
	movzx	ecx, BYTE PTR _bIncremental$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpvData$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpfnStreamFunc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnWriteOI_ToTextStream
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$LN34@SfWriteOI_:

; 8143 :                                        lpfnStreamFunc,
; 8144 :                                        lpvData, bIncremental,
; 8145 :                                        ( lControl & ~zSAVE_CURSORS ) );
; 8146 :    }
; 8147 : 
; 8148 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN35@SfWriteOI_

; 8149 :       lpViewOI->bUpdatedFile = 0;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN35@SfWriteOI_:

; 8150 : 
; 8151 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	and	edx, 1
	je	SHORT $LN36@SfWriteOI_

; 8152 :    {
; 8153 :       zCHAR sz[ 100 ];
; 8154 : 
; 8155 :       zsprintf( sz, "(%s) = %lf seconds", lpViewOD->szName,

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR tv461[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv461[ebp]
	mov	eax, DWORD PTR tv461[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG16156
	lea	edx, DWORD PTR _sz$1[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 8156 :                 (double) ( SysGetTickCount( ) - lTickCount ) / zTICKS_PER_SECOND );
; 8157 :       TraceLineS( "(oi) Total time for SfWriteOI_ToStream ", sz );

	lea	eax, DWORD PTR _sz$1[ebp]
	push	eax
	push	OFFSET $SG16157
	call	_TraceLineS@8
$LN36@SfWriteOI_:

; 8158 :    }
; 8159 : 
; 8160 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfWriteOI_:

; 8161 : 
; 8162 : } // SfWriteOI_ToStream

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SfWriteOI_ToStream@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewOD$ = -24					; size = 4
_lpOwningTask$ = -20					; size = 4
_lpView$ = -16						; size = 4
_lpCurrentTask$ = -12					; size = 4
_nState$1 = -8						; size = 2
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_lpAppQualView$ = 16					; size = 4
_lControl$ = 20						; size = 4
_SfActivateSysEmptyOI@16 PROC

; 12239: {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 12240:    LPTASK      lpCurrentTask;
; 12241:    LPTASK      lpOwningTask;
; 12242:    LPVIEWOD    lpViewOD;
; 12243:    zVIEW       lpView;
; 12244:    zSHORT      nRC;
; 12245: 
; 12246:    // init in case of error
; 12247:    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 12248: 
; 12249: #ifdef DEBUG
; 12250:    if ( lpAppQualView == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $LN2@SfActivate

; 12251:    {
; 12252:       TraceLine( "SfActivateSysEmptyOI now REQUIRES a non-zero "

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	push	OFFSET $SG17588
	call	_TraceLine
	add	esp, 8

; 12253:                    "qualification view for Object Definition: %s.", cpcViewOD_Name );
; 12254:       SysMessageBox( 0, "Zeidon OE", "SfActivateSysEmptyOI now REQUIRES a "

	push	0
	push	OFFSET $SG17589
	push	OFFSET $SG17590
	push	0
	call	_SysMessageBox@16
$LN2@SfActivate:

; 12255:                      "non-zero qualification view.  System will now crash", 0 );
; 12256:    }
; 12257: #endif
; 12258: 
; 12259:    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 12260:    if ( (lpCurrentTask = fnOperationCall( iSfActivateSysEmptyOI,
; 12261:                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	216					; 000000d8H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN3@SfActivate

; 12262:    {
; 12263:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfActivate
$LN3@SfActivate:

; 12264:    }
; 12265: 
; 12266:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 12					; 0000000cH
	je	SHORT $LN4@SfActivate

; 12267:       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax
	jmp	SHORT $LN5@SfActivate
$LN4@SfActivate:

; 12268:    else
; 12269:       lpOwningTask = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$LN5@SfActivate:

; 12270: 
; 12271:    if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 12272:                               lpAppQualView, cpcViewOD_Name, 1 )) != 0 )

	push	1
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN6@SfActivate

; 12273:    {
; 12274:       fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	216					; 000000d8H
	call	_fnOperationReturn
	add	esp, 8

; 12275:       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SfActivate
$LN6@SfActivate:

; 12276:    }
; 12277: 
; 12278: #if 0
; 12279:    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 12280:    {
; 12281:       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 12282:                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 12283:       if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView,
; 12284:                                   nScope )) != 0 )
; 12285:       {
; 12286:          fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );
; 12287:          return( nRC );
; 12288:       }
; 12289:    }
; 12290: #endif
; 12291: 
; 12292:    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, *pvReturnView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 12293:    lpView = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 12294:    if ( lControl & zREADONLY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN7@SfActivate

; 12295:       lpView->bReadOnly = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$LN7@SfActivate:

; 12296: 
; 12297: #ifdef __ACTIVATE_CONSTRAINTS__
; 12298:    // If object has activate constraint active, check for objections.
; 12299:    // If any drop view and exit...
; 12300:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 12301:    if ( lpViewOD->bActivateEmptyConstraint && nRC == 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN8@SfActivate
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN8@SfActivate

; 12302:    {
; 12303:       zSHORT nState = zOCE_STATE_SYSTEM;

	mov	ecx, 4
	mov	WORD PTR _nState$1[ebp], cx

; 12304: 
; 12305:       nRC = fnInvokeOCEOperation( lpView, lpCurrentTask,

	movzx	edx, WORD PTR _nState$1[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 12306:                                   zOCE_ACTIVATE_EMPTY, nState );
; 12307:       if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN8@SfActivate

; 12308:       {
; 12309:          fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 12310:          *pvReturnView = 0;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], 0
$LN8@SfActivate:

; 12311:       }
; 12312:    }
; 12313: #endif
; 12314: 
; 12315:    fnOperationReturn( iSfActivateSysEmptyOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	216					; 000000d8H
	call	_fnOperationReturn
	add	esp, 8

; 12316:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfActivate:

; 12317: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SfActivateSysEmptyOI@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_lpAppQualView$ = 16					; size = 4
_cpcFileName$ = 20					; size = 4
_lControl$ = 24						; size = 4
_SfActivateSysOI_FromFile@20 PROC

; 12165: {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12166:    LPTASK      lpCurrentTask;
; 12167:    zSHORT      nRC;
; 12168: 
; 12169:    // init in case of error
; 12170:    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 12171: 
; 12172: #ifdef DEBUG
; 12173:    if ( lpAppQualView == 0 )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $LN2@SfActivate

; 12174:    {
; 12175:       TraceLine( "SfActivateSysOI_FromFile now REQUIRES a non-zero "

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	push	OFFSET $SG17566
	call	_TraceLine
	add	esp, 8

; 12176:                    "qualification view for Object Definition: %s", cpcViewOD_Name );
; 12177:       SysMessageBox( 0, "Zeidon OE", "SfActivateSysOI_FromFile now REQUIRES a "

	push	0
	push	OFFSET $SG17567
	push	OFFSET $SG17568
	push	0
	call	_SysMessageBox@16
$LN2@SfActivate:

; 12178:                      "non-zero qualification view.  System will now crash", 0 );
; 12179:    }
; 12180: #endif
; 12181: 
; 12182:    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 12183:    if ( (lpCurrentTask = fnOperationCall( iSfActivateSysOI_FromFile,
; 12184:                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	215					; 000000d7H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN3@SfActivate

; 12185:    {
; 12186:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfActivate
$LN3@SfActivate:

; 12187:    }
; 12188: 
; 12189:    nRC = ActivateOI_FromFile( pvReturnView, cpcViewOD_Name, lpAppQualView,

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 536870912				; 20000000H
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_ActivateOI_FromFile@20
	mov	WORD PTR _nRC$[ebp], ax

; 12190:                               cpcFileName, lControl | zACTIVATE_SYSTEM );
; 12191: 
; 12192:    fnOperationReturn( iSfActivateSysOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	215					; 000000d7H
	call	_fnOperationReturn
	add	esp, 8

; 12193:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfActivate:

; 12194: 
; 12195: } // SfActivateSysOI_FromFile

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SfActivateSysOI_FromFile@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewOD$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_OrderOI_ByDefaultAttribs@4 PROC

; 13740: {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 13741:    LPTASK            lpCurrentTask;
; 13742:    LPVIEWOD          lpViewOD;
; 13743:    zSHORT            nRC;
; 13744: 
; 13745:    // validate some stuff
; 13746: 
; 13747:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13748:    if ( (lpCurrentTask = fnOperationCall( iOrderOI_ByDefaultAttribs,
; 13749:                                            lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	125					; 0000007dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@OrderOI_By

; 13750:    {
; 13751:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@OrderOI_By
$LN2@OrderOI_By:

; 13752:    }
; 13753: 
; 13754:    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 13755:    if ( lpViewOD->bAutoSeq == FALSE )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN3@OrderOI_By

; 13756:       nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
	jmp	SHORT $LN4@OrderOI_By
$LN3@OrderOI_By:

; 13757:    else
; 13758:       nRC = fnOrderOI_ByDefaultAttribs( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnOrderOI_ByDefaultAttribs
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax
$LN4@OrderOI_By:

; 13759: 
; 13760:    fnOperationReturn( iOrderOI_ByDefaultAttribs, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	125					; 0000007dH
	call	_fnOperationReturn
	add	esp, 8

; 13761:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@OrderOI_By:

; 13762: 
; 13763: } // OrderOI_ByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	4
_OrderOI_ByDefaultAttribs@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_pchEntityName$ = 12					; size = 4
_OrderEntitiesByDefaultAttribs@8 PROC

; 13880: {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 13881:    LPTASK            lpCurrentTask;
; 13882:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 13883:    LPENTITYINSTANCE  lpEntityInstance;
; 13884:    LPVIEWENTITY      lpViewEntity;
; 13885:    zSHORT            nRC;
; 13886: 
; 13887:    // validate some stuff
; 13888: 
; 13889:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13890:    if ( (lpCurrentTask = fnOperationCall( iOrderEntitiesByDefaultAttribs,
; 13891:                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	124					; 0000007cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@OrderEntit

; 13892:    {
; 13893:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@OrderEntit
$LN2@OrderEntit:

; 13894:    }
; 13895: 
; 13896:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13897:    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@OrderEntit

; 13898:    {
; 13899:       fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13900:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@OrderEntit
$LN3@OrderEntit:

; 13901:    }
; 13902: 
; 13903:    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13904:    if ( (zLONG) lpEntityInstance == 1 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	$LN4@OrderEntit

; 13905:    {
; 13906:       TraceLineS( "Ordering attributes -- resetting entity cursor.", "" );

	push	OFFSET $SG18216
	push	OFFSET $SG18217
	call	_TraceLineS@8

; 13907:       fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4

; 13908:       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView, pchEntityName, 0 );

	push	0
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13909:       if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN6@OrderEntit

; 13910:       {
; 13911:          fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13912:          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@OrderEntit
$LN6@OrderEntit:

; 13913:       }
; 13914: 
; 13915:       lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13916:       if ( lpEntityInstance == UNSET_CSR || lpEntityInstance == NULL_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	je	SHORT $LN9@OrderEntit
	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN7@OrderEntit
$LN9@OrderEntit:

; 13917:       {
; 13918:          // "KZOEE013 - Internal operation call error"
; 13919:          TraceLineS( "KZOEE013 - Internal operation call error: ",

	push	OFFSET $SG18222
	push	OFFSET $SG18223
	call	_TraceLineS@8

; 13920:                      "Unset or Null Cursor" );
; 13921:          fnIssueCoreError( lpCurrentTask, lpView, 8, 13, 0, "OrderEntities", 0 );

	push	0
	push	OFFSET $SG18224
	push	0
	push	13					; 0000000dH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 13922:          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 13923:       }

	jmp	SHORT $LN8@OrderEntit
$LN7@OrderEntit:

; 13924:       else
; 13925:          nRC = fnOrderEntitiesByDefaultAttribs( lpView, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnOrderEntitiesByDefaultAttribs
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN8@OrderEntit:

; 13926:    }

	jmp	SHORT $LN5@OrderEntit
$LN4@OrderEntit:

; 13927:    else
; 13928:    if ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN10@OrderEntit

; 13929:       nRC = fnOrderEntitiesByDefaultAttribs( lpView, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnOrderEntitiesByDefaultAttribs
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN5@OrderEntit
$LN10@OrderEntit:

; 13930:    else
; 13931:    {
; 13932:       TraceLineS( "Ordering attributes -- Entity cursor is null!", "" );

	push	OFFSET $SG18227
	push	OFFSET $SG18228
	call	_TraceLineS@8

; 13933:       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$LN5@OrderEntit:

; 13934:    }
; 13935: 
; 13936:    fnOperationReturn( iOrderEntitiesByDefaultAttribs, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	124					; 0000007cH
	call	_fnOperationReturn
	add	esp, 8

; 13937:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@OrderEntit:

; 13938: 
; 13939: } // OrderEntitiesByDefaultAttribs

	mov	esp, ebp
	pop	ebp
	ret	8
_OrderEntitiesByDefaultAttribs@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_idx$1 = -17472						; size = 2
_lTemp$ = -17468					; size = 4
_lpTempViewEntity$ = -17464				; size = 4
_lpViewEntity$ = -17460					; size = 4
_pchEntityName$ = -17456				; size = 4
_lpViewEntityCsr$ = -17452				; size = 4
_lpCurrentTask$ = -17448				; size = 4
_pchWSPtr$ = -17444					; size = 4
_lpEntityInstance$ = -17440				; size = 4
_pchAttrName$ = -17436					; size = 4
_pchWSBuffer$ = -17432					; size = 4
_lpViewAttrListPtr$ = -17428				; size = 4
_nRC$ = -17424						; size = 2
_bAutoSeq$ = -17419					; size = 1
_bBubbleSort$ = -17418					; size = 1
_chOrder$ = -17417					; size = 1
_pchScan$ = -17416					; size = 4
_lpViewAttrList$ = -17412				; size = 13312
_szWorkString$ = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_zView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_cpcOrderKeys$ = 16					; size = 4
_OrderEntityForView@12 PROC

; 13237: {

	push	ebp
	mov	ebp, esp
	mov	eax, 17472				; 00004440H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 13238:    LPVIEWENTITY       lpViewEntity;
; 13239:    LPVIEWENTITY       lpTempViewEntity;
; 13240:    LPVIEWENTITYCSR    lpViewEntityCsr;
; 13241:    LPENTITYINSTANCE   lpEntityInstance;
; 13242:    LPTASK             lpCurrentTask;
; 13243:    ViewAttrListRecord lpViewAttrList[ 1024 ] = {0};

	mov	DWORD PTR _lpViewAttrList$[ebp], 0
	push	13308					; 000033fcH
	push	0
	lea	eax, DWORD PTR _lpViewAttrList$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 13244:    LPVIEWATTRLIST     lpViewAttrListPtr = 0;

	mov	DWORD PTR _lpViewAttrListPtr$[ebp], 0

; 13245:    zCHAR              szWorkString[ 4096 ];
; 13246:    zCHAR              chOrder;
; 13247:    zPCHAR             pchWSPtr = 0;

	mov	DWORD PTR _pchWSPtr$[ebp], 0

; 13248:    zPCHAR             pchWSBuffer = 0;

	mov	DWORD PTR _pchWSBuffer$[ebp], 0

; 13249:    zPCHAR             pchEntityName;
; 13250:    zPCHAR             pchAttrName;
; 13251:    zPCHAR             pchScan;
; 13252:    zBOOL              bBubbleSort;
; 13253:    zBOOL              bAutoSeq = FALSE;

	mov	BYTE PTR _bAutoSeq$[ebp], 0

; 13254:    zLONG              lTemp;
; 13255:    zSHORT             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 13256: 
; 13257:    // Validate task and entity ... ensure entity cursor is established.
; 13258: 
; 13259:    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 13260:    if ( (lpCurrentTask = fnOperationCall( iOrderEntityForView,
; 13261:                                           zView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	push	122					; 0000007aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN17@OrderEntit

; 13262:    {
; 13263:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@OrderEntit
$LN17@OrderEntit:

; 13264:    }
; 13265: 
; 13266: // TraceLine( "OrderEntityForView Entity: %s   OrderKeys: %s",
; 13267: //            cpcEntityName, cpcOrderKeys );
; 13268: 
; 13269: // SetEntityCursor( zView, cpcEntityName, 0, zPOS_FIRST, 0, 0, 0, 0, 0, 0 ); does nothing
; 13270: 
; 13271:    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView, cpcEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 13272:    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN18@OrderEntit

; 13273:    {
; 13274:       fnOperationReturn( iOrderEntityForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	122					; 0000007aH
	call	_fnOperationReturn
	add	esp, 8

; 13275:       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@OrderEntit
$LN18@OrderEntit:

; 13276:    }
; 13277: 
; 13278:    if ( lpViewEntity->bAutoSeq )  // added dks 2006.07.31 because this entity may be the

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 20					; 00000014H
	and	edx, 1
	je	SHORT $LN19@OrderEntit

; 13279:       bAutoSeq = TRUE;            // only AutoSeq entity

	mov	BYTE PTR _bAutoSeq$[ebp], 1
$LN19@OrderEntit:

; 13280: 
; 13281:    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 13282:    if ( lpEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 1
	jne	SHORT $LN20@OrderEntit

; 13283:       lpEntityInstance = fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN20@OrderEntit:

; 13284: 
; 13285:    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN21@OrderEntit

; 13286:       goto EndOfFunction;

	jmp	$EndOfFunction$47
$LN21@OrderEntit:

; 13287: 
; 13288: #if 0
; 13289:    lpTempViewEntity = zGETPTR( lpEntityInstance->hViewEntity );
; 13290:    if ( lpTempViewEntity && lpTempViewEntity != lpViewEntity &&
; 13291:         lpTempViewEntity->bRecursive )
; 13292:    {
; 13293:       LPVIEWENTITY lpTempViewEntityParent = lpTempViewEntity;
; 13294: 
; 13295:       while ( lpTempViewEntityParent->hParent )
; 13296:       {
; 13297:          lpTempViewEntityParent = zGETPTR( lpTempViewEntity->hParent );
; 13298:          if ( lpTempViewEntityParent->lEREntTok == lpTempViewEntity->lEREntTok &&
; 13299:               lpTempViewEntityParent == lpViewEntity )
; 13300:          {
; 13301: #if 0
; 13302:             // Found same entity at another level.
; 13303:             fnResetCursorForViewChildren( lpViewEntityCsr );
; 13304:             lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13305:                                               cpcEntityName, 0 );
; 13306:             lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );
; 13307: #endif
; 13308:          // lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,
; 13309:          //                                   lpTempViewEntity->szName, 0 );
; 13310:             break;
; 13311:          }
; 13312:       }
; 13313:    }
; 13314: #endif
; 13315: 
; 13316:    // Check to see if user wants a bubble sort instead of the (default)
; 13317:    // quicksort.  Note that the only reason to use a bubble sort instead of
; 13318:    // quicksort is to maintain sort order on previously sorted items.
; 13319:    // Quicksort will switch items that compare equal, bubble sort will not.
; 13320:    if ( zstrncmpi( cpcOrderKeys, ".bubblesort ", 12 ) == 0 )

	push	12					; 0000000cH
	push	OFFSET $SG18015
	mov	eax, DWORD PTR _cpcOrderKeys$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN22@OrderEntit

; 13321:    {
; 13322:       bBubbleSort = TRUE;

	mov	BYTE PTR _bBubbleSort$[ebp], 1

; 13323:       cpcOrderKeys += 12;

	mov	ecx, DWORD PTR _cpcOrderKeys$[ebp]
	add	ecx, 12					; 0000000cH
	mov	DWORD PTR _cpcOrderKeys$[ebp], ecx

; 13324:    }

	jmp	SHORT $LN23@OrderEntit
$LN22@OrderEntit:

; 13325:    else
; 13326:       bBubbleSort = FALSE;

	mov	BYTE PTR _bBubbleSort$[ebp], 0
$LN23@OrderEntit:

; 13327: 
; 13328:    lpViewAttrListPtr = lpViewAttrList;

	lea	edx, DWORD PTR _lpViewAttrList$[ebp]
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], edx

; 13329: 
; 13330:    lTemp = zstrlen( cpcOrderKeys );

	mov	eax, DWORD PTR _cpcOrderKeys$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lTemp$[ebp], eax

; 13331:    if ( lTemp > 4094 )

	cmp	DWORD PTR _lTemp$[ebp], 4094		; 00000ffeH
	jle	SHORT $LN24@OrderEntit

; 13332:    {
; 13333:       pchWSBuffer = (zPCHAR) fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10105					; 00002779H
	push	0
	push	0
	mov	ecx, DWORD PTR _lTemp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _pchWSBuffer$[ebp], eax

; 13334:                                                lTemp, 0, 0, iBuffer );
; 13335:       pchWSBuffer = zGETPTR( pchWSBuffer );

	mov	ecx, DWORD PTR _pchWSBuffer$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchWSBuffer$[ebp], eax

; 13336:       pchWSPtr = pchWSBuffer;

	mov	edx, DWORD PTR _pchWSBuffer$[ebp]
	mov	DWORD PTR _pchWSPtr$[ebp], edx

; 13337:    }

	jmp	SHORT $LN25@OrderEntit
$LN24@OrderEntit:

; 13338:    else
; 13339:       pchWSPtr = szWorkString;

	lea	eax, DWORD PTR _szWorkString$[ebp]
	mov	DWORD PTR _pchWSPtr$[ebp], eax
$LN25@OrderEntit:

; 13340: 
; 13341:    zstrcpy( pchWSPtr, cpcOrderKeys );

	mov	ecx, DWORD PTR _cpcOrderKeys$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchWSPtr$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 13342: 
; 13343:    // Validate each of the attributes in the sort list.
; 13344:    for ( pchScan = pchWSPtr; *pchScan; )

	mov	eax, DWORD PTR _pchWSPtr$[ebp]
	mov	DWORD PTR _pchScan$[ebp], eax
$LN4@OrderEntit:
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN3@OrderEntit
$LN5@OrderEntit:

; 13345:    {
; 13346:       // Initialize current AttrList entry ... done above at instantiation
; 13347:    // lpViewAttrListPtr->bOrder = FALSE; // order ascending by default
; 13348:    // lpViewAttrListPtr->pfObjectOper = 0;
; 13349:    // lpViewAttrListPtr->pszContextName = 0;
; 13350:    // lpViewAttrListPtr->lpViewAttrib = 0;  // this gets set for sure
; 13351: 
; 13352:       while ( *pchScan == ' ' || *pchScan == ',' )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN26@OrderEntit
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN6@OrderEntit
$LN26@OrderEntit:

; 13353:          pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
	jmp	SHORT $LN5@OrderEntit
$LN6@OrderEntit:

; 13354: 
; 13355:       pchAttrName = pchScan;  // save pointer to attr name

	mov	edx, DWORD PTR _pchScan$[ebp]
	mov	DWORD PTR _pchAttrName$[ebp], edx
$LN7@OrderEntit:

; 13356:       while ( *pchScan != ' ' && *pchScan != 0 )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN8@OrderEntit
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN8@OrderEntit

; 13357:          pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
	jmp	SHORT $LN7@OrderEntit
$LN8@OrderEntit:

; 13358: 
; 13359:       if ( *pchScan )     // if space is found,

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN27@OrderEntit

; 13360:          *pchScan++ = 0;  // null terminate

	mov	ecx, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _pchScan$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchScan$[ebp], edx
$LN27@OrderEntit:

; 13361: 
; 13362:       if ( *pchAttrName == 0 )

	mov	eax, DWORD PTR _pchAttrName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN28@OrderEntit

; 13363:          break;

	jmp	$LN3@OrderEntit
$LN28@OrderEntit:

; 13364: 
; 13365:       // Check to see if the attribute name also has an entity name.  It
; 13366:       // should be seperated from the attr name by a '.'.
; 13367:       pchEntityName = zstrchr( pchAttrName, '.' );

	push	46					; 0000002eH
	mov	edx, DWORD PTR _pchAttrName$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchEntityName$[ebp], eax

; 13368:       if ( pchEntityName )

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	SHORT $LN29@OrderEntit

; 13369:       {
; 13370:          // We have an entity name.
; 13371:          *pchEntityName = 0;       // change '.' to null

	mov	eax, DWORD PTR _pchEntityName$[ebp]
	mov	BYTE PTR [eax], 0

; 13372:          lpTempViewEntity = fnValidViewEntity( &lpViewEntityCsr, zView,

	push	0
	mov	ecx, DWORD PTR _pchAttrName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpTempViewEntity$[ebp], eax

; 13373:                                                pchAttrName, 0 );
; 13374:          if ( lpTempViewEntity == 0 )

	cmp	DWORD PTR _lpTempViewEntity$[ebp], 0
	jne	SHORT $LN31@OrderEntit

; 13375:             goto EndOfFunction;

	jmp	$EndOfFunction$47
$LN31@OrderEntit:

; 13376: 
; 13377:          // Change attr pointer to point to beginning of attr name.
; 13378:          pchAttrName = pchEntityName + 1;

	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchAttrName$[ebp], ecx

; 13379:       }

	jmp	SHORT $LN30@OrderEntit
$LN29@OrderEntit:

; 13380:       else
; 13381:       {
; 13382:          // No entity name specified so use default entity.
; 13383:          lpTempViewEntity = lpViewEntity;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR _lpTempViewEntity$[ebp], edx
$LN30@OrderEntit:

; 13384:       }
; 13385: 
; 13386:    // if ( lpTempViewEntity->bAutoSeq ) // dropped dks/don 2006.07.31 since we
; 13387:    //    bAutoSeq = TRUE;               // believe only sort entity should be considered
; 13388: 
; 13389:       lpViewAttrListPtr->lpViewAttrib =

	push	0
	mov	eax, DWORD PTR _pchAttrName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTempViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _zView$[ebp]
	push	edx
	call	_fnValidViewAttrib
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	DWORD PTR [ecx], eax

; 13390:                 fnValidViewAttrib( zView, lpTempViewEntity, pchAttrName, 0 );
; 13391:       if ( lpViewAttrListPtr->lpViewAttrib == 0 )

	mov	edx, DWORD PTR _lpViewAttrListPtr$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN9@OrderEntit

; 13392:          goto EndOfFunction;

	jmp	$EndOfFunction$47
$LN9@OrderEntit:

; 13393: 
; 13394:       while ( *pchScan == ' ' || *pchScan == ',' )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN33@OrderEntit
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 44					; 0000002cH
	jne	SHORT $LN10@OrderEntit
$LN33@OrderEntit:

; 13395:          pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
	jmp	SHORT $LN9@OrderEntit
$LN10@OrderEntit:

; 13396: 
; 13397:       // Is there an order character present?
; 13398:       if ( pchScan && *pchScan )

	cmp	DWORD PTR _pchScan$[ebp], 0
	je	$LN34@OrderEntit
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN34@OrderEntit

; 13399:       {
; 13400:          chOrder = ztoupper( *pchScan );

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	BYTE PTR _chOrder$[ebp], al

; 13401:          if ( (chOrder == 'A' || chOrder == 'D') &&

	movsx	eax, BYTE PTR _chOrder$[ebp]
	cmp	eax, 65					; 00000041H
	je	SHORT $LN36@OrderEntit
	movsx	ecx, BYTE PTR _chOrder$[ebp]
	cmp	ecx, 68					; 00000044H
	jne	$LN34@OrderEntit
$LN36@OrderEntit:
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN37@OrderEntit
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN37@OrderEntit
	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 44					; 0000002cH
	jne	SHORT $LN34@OrderEntit
$LN37@OrderEntit:

; 13402:               (pchScan[ 1 ] == 0 || pchScan[ 1 ] == ' ' || pchScan[ 1 ] == ',') )
; 13403:          {
; 13404:             if ( chOrder == 'D' )

	movsx	edx, BYTE PTR _chOrder$[ebp]
	cmp	edx, 68					; 00000044H
	jne	SHORT $LN38@OrderEntit

; 13405:                lpViewAttrListPtr->bOrder = TRUE; // order descending

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	BYTE PTR [eax+8], 1
$LN38@OrderEntit:

; 13406: 
; 13407:             pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
$LN11@OrderEntit:

; 13408:             while ( *pchScan == ' ' || *pchScan == ',' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN39@OrderEntit
	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 44					; 0000002cH
	jne	SHORT $LN34@OrderEntit
$LN39@OrderEntit:

; 13409:                pchScan++;

	mov	eax, DWORD PTR _pchScan$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchScan$[ebp], eax
	jmp	SHORT $LN11@OrderEntit
$LN34@OrderEntit:

; 13410:          }
; 13411:       }
; 13412: 
; 13413:       // Check for a Context Name.  It should be surrounded by brackets.
; 13414:       if ( *pchScan == '[' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 91					; 0000005bH
	jne	$LN40@OrderEntit

; 13415:       {
; 13416:          zSHORT idx = 0;

	xor	eax, eax
	mov	WORD PTR _idx$1[ebp], ax

; 13417: 
; 13418:          pchScan++;   // Skip over bracket.

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
$LN13@OrderEntit:

; 13419:          while ( *pchScan == ' ' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN14@OrderEntit

; 13420:             pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx
	jmp	SHORT $LN13@OrderEntit
$LN14@OrderEntit:

; 13421: 
; 13422:          if ( *pchScan != ']' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN15@OrderEntit

; 13423:             lpViewAttrListPtr->pszContextName = pchScan;

	mov	ecx, DWORD PTR _lpViewAttrListPtr$[ebp]
	mov	edx, DWORD PTR _pchScan$[ebp]
	mov	DWORD PTR [ecx+9], edx
$LN15@OrderEntit:

; 13424: 
; 13425:          while ( *pchScan && *pchScan != ']' )

	mov	eax, DWORD PTR _pchScan$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN16@OrderEntit
	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	je	SHORT $LN16@OrderEntit

; 13426:          {
; 13427:             // If we find a space we'll convert it into a null-terminator.
; 13428:             // This will cause us to ignore trailing spaces.
; 13429:             if ( *pchScan == ' ' )

	mov	ecx, DWORD PTR _pchScan$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN42@OrderEntit

; 13430:                *pchScan = 0;

	mov	eax, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [eax], 0
$LN42@OrderEntit:

; 13431: 
; 13432:             pchScan++;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchScan$[ebp], ecx

; 13433:          }

	jmp	SHORT $LN15@OrderEntit
$LN16@OrderEntit:

; 13434: 
; 13435:          // If we found a closing bracket (only other possiblity is a 0) then
; 13436:          // change it to a null-terminator and skip to next char.
; 13437:          if ( *pchScan == ']' )

	mov	edx, DWORD PTR _pchScan$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 93					; 0000005dH
	jne	SHORT $LN40@OrderEntit

; 13438:             *pchScan++ = 0;

	mov	ecx, DWORD PTR _pchScan$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _pchScan$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchScan$[ebp], edx
$LN40@OrderEntit:

; 13439:       }
; 13440: 
; 13441:       lpViewAttrListPtr++;

	mov	eax, DWORD PTR _lpViewAttrListPtr$[ebp]
	add	eax, 13					; 0000000dH
	mov	DWORD PTR _lpViewAttrListPtr$[ebp], eax

; 13442: 
; 13443:    } // for ( pchScan = pchWSPtr; *pchScan; )

	jmp	$LN4@OrderEntit
$LN3@OrderEntit:

; 13444: 
; 13445:    // Initialize last AttrList entry ... done above at instantiation
; 13446: // lpViewAttrListPtr->lpViewAttrib = 0;
; 13447: 
; 13448:    // Call the actual sort routine.
; 13449:    nRC = fnOrderEntityForView( zView, lpEntityInstance,

	movzx	ecx, BYTE PTR _bBubbleSort$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewAttrList$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _zView$[ebp]
	push	ecx
	call	_fnOrderEntityForView@16
	mov	WORD PTR _nRC$[ebp], ax

; 13450:                                lpViewAttrList, bBubbleSort );
; 13451: 
; 13452:    if ( nRC != zCALL_ERROR && bAutoSeq )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -16				; fffffff0H
	je	SHORT $EndOfFunction$47
	movzx	eax, BYTE PTR _bAutoSeq$[ebp]
	test	eax, eax
	je	SHORT $EndOfFunction$47

; 13453:    {  // >>> RAD54278-1 BEGIN
; 13454:       fnSetUpdateIndicator( 0, lpEntityInstance, 0, TRUE, TRUE, TRUE );

	push	1
	push	1
	push	1
	push	0
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	0
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$EndOfFunction$47:

; 13455:    }  // >>> RAD54278-1 END
; 13456: 
; 13457: EndOfFunction:
; 13458: 
; 13459:    if ( pchWSBuffer )

	cmp	DWORD PTR _pchWSBuffer$[ebp], 0
	je	SHORT $LN45@OrderEntit

; 13460:       fnFreeDataspace( pchWSBuffer );   // free work area

	mov	edx, DWORD PTR _pchWSBuffer$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$LN45@OrderEntit:

; 13461: 
; 13462:    fnOperationReturn( iOrderEntityForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	122					; 0000007aH
	call	_fnOperationReturn
	add	esp, 8

; 13463:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@OrderEntit:

; 13464: }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_OrderEntityForView@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -16					; size = 4
_lpViewCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_ObjectInstanceUpdatedFromFile@4 PROC

; 8361 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 8362 :    LPTASK            lpCurrentTask;
; 8363 :    LPVIEWCSR         lpViewCsr;
; 8364 :    LPVIEWOI          lpViewOI;
; 8365 :    zSHORT            nRC;
; 8366 : 
; 8367 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8368 :    if ( (lpCurrentTask = fnOperationCall( iObjectInstanceUpdatedFromFile,
; 8369 :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	130					; 00000082H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@ObjectInst

; 8370 :    {
; 8371 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@ObjectInst
$LN2@ObjectInst:

; 8372 :    }
; 8373 : 
; 8374 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8375 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8376 :    nRC       = lpViewOI->bUpdatedFile;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 5
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 8377 : 
; 8378 :    fnOperationReturn( iObjectInstanceUpdatedFromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	130					; 00000082H
	call	_fnOperationReturn
	add	esp, 8

; 8379 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ObjectInst:

; 8380 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ObjectInstanceUpdatedFromFile@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewOI$ = -16					; size = 4
_lpViewCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_ObjectInstanceUpdated@4 PROC

; 8321 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 8322 :    LPTASK            lpCurrentTask;
; 8323 :    LPVIEWCSR         lpViewCsr;
; 8324 :    LPVIEWOI          lpViewOI;
; 8325 :    zSHORT            nRC;
; 8326 : 
; 8327 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8328 :    if ( (lpCurrentTask = fnOperationCall( iObjectInstanceUpdated, lpView,
; 8329 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	118					; 00000076H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@ObjectInst

; 8330 :    {
; 8331 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@ObjectInst
$LN2@ObjectInst:

; 8332 :    }
; 8333 : 
; 8334 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 8335 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 8336 :    nRC = lpViewOI->bUpdated;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	shr	eax, 4
	and	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 8337 : 
; 8338 :    fnOperationReturn( iObjectInstanceUpdated, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	118					; 00000076H
	call	_fnOperationReturn
	add	esp, 8

; 8339 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ObjectInst:

; 8340 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ObjectInstanceUpdated@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_DropObjectInstance@4 PROC

; 8285 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8286 :    LPTASK            lpCurrentTask;
; 8287 :    zSHORT            nRC;
; 8288 : 
; 8289 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 8290 :    if ( (lpCurrentTask = fnOperationCall( iDropObjectInstance, lpView,
; 8291 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	70					; 00000046H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@DropObject

; 8292 :    {
; 8293 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@DropObject
$LN2@DropObject:

; 8294 :    }
; 8295 : 
; 8296 :    // Call fnDropObjectInstance with current view
; 8297 :    nRC = fnDropObjectInstance( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropObjectInstance
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax

; 8298 : 
; 8299 :    fnOperationReturn( iDropObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	70					; 00000046H
	call	_fnOperationReturn
	add	esp, 8

; 8300 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DropObject:

; 8301 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropObjectInstance@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpScopingViewEntity$ = -32				; size = 4
_lpViewEntityCsr$ = -28					; size = 4
_lpScopingViewEntityCsr$ = -24				; size = 4
_lpCurrentTask$ = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpKey$ = -12						; size = 4
_vQual$ = -8						; size = 4
_nRC$ = -4						; size = 2
_pvQual$ = 8						; size = 4
_vEntityList$ = 12					; size = 4
_pchEntityName$ = 16					; size = 4
_pchScoping$ = 20					; size = 4
_lControl$ = 24						; size = 4
_GenerateQualFromEntityList@20 PROC

; 14518: {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 14519:    LPTASK            lpCurrentTask;
; 14520:    LPVIEWENTITY      lpViewEntity;
; 14521:    LPVIEWENTITY      lpScopingViewEntity;
; 14522:    LPVIEWENTITYCSR   lpViewEntityCsr;
; 14523:    LPVIEWENTITYCSR   lpScopingViewEntityCsr;
; 14524:    LPVIEWATTRIB      lpKey;
; 14525:    zVIEW             vQual;
; 14526:    zSHORT            nRC;
; 14527: 
; 14528:    // Validate parameters
; 14529:    if ( (nRC = fnValidateCursorParameters( &lpCurrentTask,
; 14530:                                            &lpViewEntity,
; 14531:                                            &lpScopingViewEntity,
; 14532:                                            &lpViewEntityCsr,
; 14533:                                            &lpScopingViewEntityCsr,
; 14534:                                            iGenerateQualFromEntityList,
; 14535:                                            vEntityList,
; 14536:                                            pchEntityName,
; 14537:                                            pchScoping )) != 0 )

	mov	eax, DWORD PTR _pchScoping$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	push	65					; 00000041H
	lea	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpScopingViewEntity$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateCursorParameters
	add	esp, 36					; 00000024H
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN8@GenerateQu

; 14538:    {
; 14539:       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@GenerateQu
$LN8@GenerateQu:

; 14540:    }
; 14541: 
; 14542:    // Find the key attribute.
; 14543:    for ( lpKey = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpKey$[ebp], eax
	jmp	SHORT $LN4@GenerateQu
$LN2@GenerateQu:

; 14545:          lpKey = zGETPTR( lpKey->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpKey$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpKey$[ebp], eax
$LN4@GenerateQu:

; 14544:          lpKey->bKey == FALSE;

	mov	ecx, DWORD PTR _lpKey$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN3@GenerateQu

; 14546:    {
; 14547:       // nothing needs to be done here
; 14548:    }

	jmp	SHORT $LN2@GenerateQu
$LN3@GenerateQu:

; 14549: 
; 14550:    SfActivateSysEmptyOI( &vQual, "KZDBHQUA", vEntityList, zMULTIPLE );

	push	256					; 00000100H
	mov	eax, DWORD PTR _vEntityList$[ebp]
	push	eax
	push	OFFSET $SG18455
	lea	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 14551:    CreateEntity( vQual, "EntitySpec", zPOS_LAST );

	push	2
	push	OFFSET $SG18456
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_CreateEntity@12

; 14552:    SetAttributeFromString( vQual, "EntitySpec", "EntityName", "*root*" );

	push	OFFSET $SG18457
	push	OFFSET $SG18458
	push	OFFSET $SG18459
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 14553: 
; 14554:    CreateEntity( vQual, "QualAttrib", zPOS_LAST );

	push	2
	push	OFFSET $SG18460
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_CreateEntity@12

; 14555:    SetAttributeFromString( vQual, "QualAttrib", "EntityName", "*root*" );

	push	OFFSET $SG18461
	push	OFFSET $SG18462
	push	OFFSET $SG18463
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14556:    SetAttributeFromString( vQual, "QualAttrib", "AttributeName", lpKey->szName );

	mov	eax, DWORD PTR _lpKey$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG18464
	push	OFFSET $SG18465
	mov	ecx, DWORD PTR _vQual$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 14557:    SetAttributeFromString( vQual, "QualAttrib", "Oper", "=" );

	push	OFFSET $SG18466
	push	OFFSET $SG18467
	push	OFFSET $SG18468
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 14558: 
; 14559:    // Loop through the entities and copy the key values to the qual OI.
; 14560:    for ( nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vEntityList$[ebp]
	push	ecx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN7@GenerateQu
$LN5@GenerateQu:

; 14565:          nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	3
	push	0
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vEntityList$[ebp]
	push	eax
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax
$LN7@GenerateQu:

; 14561:                                   0, (zLONG) zPOS_FIRST,
; 14562:                                   0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14563:                                   lpCurrentTask );
; 14564:          nRC >= zCURSOR_SET;

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	SHORT $LN6@GenerateQu

; 14566:                                   0, (zLONG) zPOS_NEXT,
; 14567:                                   0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14568:                                   lpCurrentTask ) )
; 14569:    {
; 14570:       CreateEntity( vQual, "KeyList", zPOS_LAST );

	push	2
	push	OFFSET $SG18469
	mov	edx, DWORD PTR _vQual$[ebp]
	push	edx
	call	_CreateEntity@12

; 14571:       SetAttributeFromAttribute( vQual, "KeyList", "IntegerValue",

	mov	eax, DWORD PTR _lpKey$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	push	OFFSET $SG18470
	push	OFFSET $SG18471
	mov	eax, DWORD PTR _vQual$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24

; 14572:                                  vEntityList, pchEntityName, lpKey->szName );
; 14573:    }

	jmp	SHORT $LN5@GenerateQu
$LN6@GenerateQu:

; 14574: 
; 14575:    // Reset the cursor back to the first entity.
; 14576:    nRC = fnSetEntityCursor( vEntityList, lpViewEntity, lpViewEntityCsr,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpScopingViewEntityCsr$[ebp]
	push	edx
	push	0
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vEntityList$[ebp]
	push	edx
	call	_fnSetEntityCursor
	add	esp, 48					; 00000030H
	mov	WORD PTR _nRC$[ebp], ax

; 14577:                             0, (zLONG) zPOS_FIRST,
; 14578:                             0, 0, 0, 0, lpScopingViewEntityCsr, 0,
; 14579:                             lpCurrentTask );
; 14580: 
; 14581:    *pvQual = vQual;

	mov	eax, DWORD PTR _pvQual$[ebp]
	mov	ecx, DWORD PTR _vQual$[ebp]
	mov	DWORD PTR [eax], ecx

; 14582: 
; 14583:    fnOperationReturn( iGenerateQualFromEntityList, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	65					; 00000041H
	call	_fnOperationReturn
	add	esp, 8

; 14584:    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GenerateQu:

; 14585: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_GenerateQualFromEntityList@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_FileData$ = -2100					; size = 12
tv130 = -2088						; size = 4
$T1 = -2084						; size = 4
_lpCurrentTask$ = -2080					; size = 4
_lpApp$2 = -2076					; size = 4
_hFile$ = -2072						; size = 4
_nRC$ = -2068						; size = 2
_nTrys$ = -2064						; size = 2
_szOpenFileName$ = -2060				; size = 1025
_szWork$ = -1032					; size = 1025
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcFileName$ = 12					; size = 4
_lControl$ = 16						; size = 4
_CommitOI_ToFile@12 PROC

; 8187 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2100				; 00000834H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8188 :    LPTASK         lpCurrentTask;
; 8189 :    FileDataRecord FileData;
; 8190 :    zCHAR          szOpenFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 8191 :    zCHAR          szWork[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 8192 :    zLONG          hFile;
; 8193 :    zSHORT         nTrys;
; 8194 :    zSHORT         nRC;
; 8195 : 
; 8196 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 8197 :    if ( (lpCurrentTask = fnOperationCall( iCommitOI_ToFile, lpView,
; 8198 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	61					; 0000003dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@CommitOI_T

; 8199 :    {
; 8200 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN13@CommitOI_T
$LN4@CommitOI_T:

; 8201 :    }
; 8202 : 
; 8203 : // DGC 9/23/96
; 8204 : // I changed the logic: if the file name is not qualfied, use the object dir
; 8205 : // for the application. I repeated this change in CommitOI_ToFile.
; 8206 :    if ( zstrchr( cpcFileName, cDirSep ) == 0 )

	movsx	ecx, BYTE PTR _cDirSep
	push	ecx
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@CommitOI_T

; 8207 :    {
; 8208 :       LPAPP lpApp;
; 8209 : 
; 8210 :       fnGetApplicationForSubtask( &lpApp, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$2[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8

; 8211 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$2[ebp], 0
	je	SHORT $LN7@CommitOI_T

; 8212 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	edx, DWORD PTR _lpApp$2[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN8@CommitOI_T
$LN7@CommitOI_T:

; 8213 :       else
; 8214 :       {
; 8215 :          lpApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$2[ebp], eax

; 8216 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	eax, DWORD PTR _lpApp$2[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN8@CommitOI_T:

; 8217 :       }
; 8218 : 
; 8219 :       SysAppendcDirSep( szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 8220 :    }

	jmp	SHORT $LN6@CommitOI_T
$LN5@CommitOI_T:

; 8221 :    else
; 8222 :       szWork[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 1025		; 00000401H
	jae	SHORT $LN14@CommitOI_T
	jmp	SHORT $LN15@CommitOI_T
$LN14@CommitOI_T:
	call	___report_rangecheckfailure
$LN15@CommitOI_T:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szWork$[ebp+edx], 0
$LN6@CommitOI_T:

; 8223 : 
; 8224 :    zstrcat( szWork, cpcFileName );

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 8225 :    SysConvertEnvironmentString( szOpenFileName, szWork );

	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 8226 : 
; 8227 :    // Open the file for the object instance data ... this file really should
; 8228 :    // exist, but it may already be open.  So we will try more than once to
; 8229 :    // open it before giving up.
; 8230 :    hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 8231 :    nTrys = 0;

	xor	ecx, ecx
	mov	WORD PTR _nTrys$[ebp], cx
$LN2@CommitOI_T:

; 8232 :    while ( hFile == -1 && nTrys++ < 10 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN3@CommitOI_T
	movsx	edx, WORD PTR _nTrys$[ebp]
	mov	DWORD PTR tv130[ebp], edx
	mov	ax, WORD PTR _nTrys$[ebp]
	add	ax, 1
	mov	WORD PTR _nTrys$[ebp], ax
	cmp	DWORD PTR tv130[ebp], 10		; 0000000aH
	jge	SHORT $LN3@CommitOI_T

; 8233 :    {
; 8234 :       hFile = SysOpenFile( lpView, szOpenFileName,

	push	4129					; 00001021H
	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 8235 :                 COREFILE_CREATE | COREFILE_WRITELINE_BUFFERED | COREFILE_BACKUP );
; 8236 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN9@CommitOI_T

; 8237 :          SysWait( 500 );

	push	500					; 000001f4H
	call	_SysWait@4
$LN9@CommitOI_T:

; 8238 :    }

	jmp	SHORT $LN2@CommitOI_T
$LN3@CommitOI_T:

; 8239 : 
; 8240 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN10@CommitOI_T

; 8241 :    {
; 8242 :       //  "KZOEE071 - Error opening instance file "
; 8243 :       fnIssueCoreError( lpCurrentTask, lpView, 16, 71, 0, cpcFileName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 8244 :       fnOperationReturn( iCommitOI_ToFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	61					; 0000003dH
	call	_fnOperationReturn
	add	esp, 8

; 8245 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN13@CommitOI_T
$LN10@CommitOI_T:

; 8246 :    }
; 8247 : 
; 8248 :    FileData.pchFileName = (zPCHAR) cpcFileName;

	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	mov	DWORD PTR _FileData$[ebp], ecx

; 8249 :    FileData.hFile       = hFile;

	mov	edx, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR _FileData$[ebp+4], edx

; 8250 :    FileData.lLine       = 0;

	mov	DWORD PTR _FileData$[ebp+8], 0

; 8251 : 
; 8252 :    nRC = SfWriteOI_ToStream( lpView, cpcFileName, lControl,

	lea	eax, DWORD PTR _FileData$[ebp]
	push	eax
	push	OFFSET _fnPutDataToFile@20
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SfWriteOI_ToStream@20
	mov	WORD PTR _nRC$[ebp], ax

; 8253 :                              fnPutDataToFile, (zPVOID) &FileData );
; 8254 : 
; 8255 :    if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN11@CommitOI_T

; 8256 :       SysCloseFileWithControl( lpView, hFile, 0, CLOSEFILE_ABORT_BACKUP );

	push	1
	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysCloseFileWithControl@16
	jmp	SHORT $LN12@CommitOI_T
$LN11@CommitOI_T:

; 8257 :    else
; 8258 :       nRC = SysCloseFileWithControl( lpView, hFile, 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysCloseFileWithControl@16
	mov	WORD PTR _nRC$[ebp], ax
$LN12@CommitOI_T:

; 8259 : 
; 8260 :    fnOperationReturn( iCommitOI_ToFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	61					; 0000003dH
	call	_fnOperationReturn
	add	esp, 8

; 8261 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN13@CommitOI_T:

; 8262 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CommitOI_ToFile@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_nRC$ = -8						; size = 2
_nIndex$ = -4						; size = 2
_lpArray$ = 8						; size = 4
_lpErrorIndex$ = 12					; size = 4
_CommitMultipleObjectInstances@8 PROC

; 4541 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4542 :    zSHORT nIndex;
; 4543 :    zSHORT nRC;
; 4544 : 
; 4545 :    nRC = CommitMultipleOIs( (LPVIEWCLUSTER) lpArray, 0, &nIndex, 0 );

	push	0
	lea	eax, DWORD PTR _nIndex$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpArray$[ebp]
	push	ecx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 4546 :    *lpErrorIndex = (zLONG) nIndex;

	movsx	edx, WORD PTR _nIndex$[ebp]
	mov	eax, DWORD PTR _lpErrorIndex$[ebp]
	mov	DWORD PTR [eax], edx

; 4547 : 
; 4548 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 4549 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CommitMultipleObjectInstances@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lArray$ = 8						; size = 4
_lpView$ = 12						; size = 4
_AddViewToViewCluster@8 PROC

; 3974 : {

	push	ebp
	mov	ebp, esp

; 3975 :    return( AddToViewCluster( lArray, lpView, 0 ) );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lArray$[ebp]
	push	ecx
	call	_AddToViewCluster@12

; 3976 : }

	pop	ebp
	ret	8
_AddViewToViewCluster@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pvTarget$ = -20					; size = 4
_pvSource$ = -16					; size = 4
_k$ = -12						; size = 4
_nRC$ = -8						; size = 2
_n$ = -4						; size = 2
_lTargetArray$ = 8					; size = 4
_lSourceArray$ = 12					; size = 4
_AppendViewCluster@8 PROC

; 3930 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3931 :    LPVIEWCLUSTER pvTarget = (LPVIEWCLUSTER) lTargetArray;

	mov	eax, DWORD PTR _lTargetArray$[ebp]
	mov	DWORD PTR _pvTarget$[ebp], eax

; 3932 :    LPVIEWCLUSTER pvSource = (LPVIEWCLUSTER) lSourceArray;

	mov	ecx, DWORD PTR _lSourceArray$[ebp]
	mov	DWORD PTR _pvSource$[ebp], ecx

; 3933 :    zLONG  k;
; 3934 :    zSHORT n;
; 3935 :    zSHORT nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 3936 : 
; 3937 :    for ( k = 0; pvSource[ k ].vOI; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@AppendView
$LN2@AppendView:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@AppendView:
	mov	ecx, DWORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pvSource$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $LN3@AppendView

; 3938 :    {
; 3939 :       if ( pvSource[ k ].vOI == (zVIEW) -1 )

	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _pvSource$[ebp]
	cmp	DWORD PTR [ecx+eax*8], -1
	jne	SHORT $LN5@AppendView

; 3940 :          break; // this is the end of the array

	jmp	SHORT $LN3@AppendView
$LN5@AppendView:

; 3941 : 
; 3942 :       n = AddToViewCluster( lTargetArray,

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pvSource$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	push	ecx
	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _pvSource$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	mov	edx, DWORD PTR _lTargetArray$[ebp]
	push	edx
	call	_AddToViewCluster@12
	mov	WORD PTR _n$[ebp], ax

; 3943 :                             pvSource[ k ].vOI, pvSource[ k ].lControl );
; 3944 :       if ( n < 0 )

	movsx	eax, WORD PTR _n$[ebp]
	test	eax, eax
	jge	SHORT $LN6@AppendView

; 3945 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@AppendView
$LN6@AppendView:

; 3946 : 
; 3947 :       if ( k == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $LN7@AppendView

; 3948 :          nRC = n; // first index is the Offset of appended cluster

	mov	cx, WORD PTR _n$[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN7@AppendView:

; 3949 :    }

	jmp	SHORT $LN2@AppendView
$LN3@AppendView:

; 3950 : 
; 3951 :    fnFreeDataspace( pvSource );

	mov	edx, DWORD PTR _pvSource$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3952 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@AppendView:

; 3953 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_AppendViewCluster@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_hViewOI$ = -20						; size = 4
_lpViewCsr$ = -16					; size = 4
_pv$ = -12						; size = 4
_lpCurrentTask$ = -8					; size = 4
_nIdx$ = -4						; size = 2
_lArray$ = 8						; size = 4
_lpView$ = 12						; size = 4
_lControl$ = 16						; size = 4
_AddToViewCluster@12 PROC

; 3864 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 3865 :    LPTASK        lpCurrentTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 3866 :    LPVIEWCLUSTER pv = (LPVIEWCLUSTER) lArray;

	mov	edx, DWORD PTR _lArray$[ebp]
	mov	DWORD PTR _pv$[ebp], edx

; 3867 :    LPVIEWCSR     lpViewCsr;
; 3868 :    LPVIEWOI      hViewOI;
; 3869 :    zSHORT        nIdx;
; 3870 : 
; 3871 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3872 :    if ( (lpCurrentTask = fnOperationCall( iAddToViewCluster, lpView,
; 3873 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	64					; 00000040H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN5@AddToViewC

; 3874 :    {
; 3875 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@AddToViewC
$LN5@AddToViewC:

; 3876 :    }
; 3877 : 
; 3878 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3879 :    if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	jne	SHORT $LN6@AddToViewC

; 3880 :    {
; 3881 :       SysMessageBox( lpView, szlOE_SystemError, "View doesn't have an OI", 0 );

	push	0
	push	OFFSET $SG14586
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 3882 :       fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3883 :       return( -1 );

	or	eax, -1
	jmp	$LN1@AddToViewC
$LN6@AddToViewC:

; 3884 :    }
; 3885 : 
; 3886 :    hViewOI = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hViewOI$[ebp], ecx

; 3887 : 
; 3888 :    // Look for the first 0 (e.g. empty) cell in the array. If we find one
; 3889 :    // that is -1, then we've reached the end of the list so end with error.
; 3890 :    for ( nIdx = 0; pv[ nIdx ].vOI; nIdx++ )

	xor	edx, edx
	mov	WORD PTR _nIdx$[ebp], dx
	jmp	SHORT $LN4@AddToViewC
$LN2@AddToViewC:
	mov	ax, WORD PTR _nIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nIdx$[ebp], ax
$LN4@AddToViewC:
	movsx	ecx, WORD PTR _nIdx$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $LN3@AddToViewC

; 3891 :    {
; 3892 :       if ( pv[ nIdx ].vOI == (zVIEW) -1 )

	movsx	eax, WORD PTR _nIdx$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	cmp	DWORD PTR [ecx+eax*8], -1
	jne	SHORT $LN7@AddToViewC

; 3893 :       {
; 3894 :          // "KZOEE087 - Too many views in View array"
; 3895 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 87, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	87					; 00000057H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3896 :          fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3897 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@AddToViewC
$LN7@AddToViewC:

; 3898 :       }
; 3899 :    }

	jmp	SHORT $LN2@AddToViewC
$LN3@AddToViewC:

; 3900 : 
; 3901 :    pv[ nIdx ].vOI      = lpView;

	movsx	edx, WORD PTR _nIdx$[ebp]
	mov	eax, DWORD PTR _pv$[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+edx*8], ecx

; 3902 :    pv[ nIdx ].lControl = lControl;

	movsx	edx, WORD PTR _nIdx$[ebp]
	mov	eax, DWORD PTR _pv$[ebp]
	mov	ecx, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR [eax+edx*8+4], ecx

; 3903 : 
; 3904 :    fnOperationReturn( iAddToViewCluster, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	64					; 00000040H
	call	_fnOperationReturn
	add	esp, 8

; 3905 :    return( nIdx );

	mov	ax, WORD PTR _nIdx$[ebp]
$LN1@AddToViewC:

; 3906 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_AddToViewCluster@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -12					; size = 4
_lpViewCluster$ = -8					; size = 4
_idx$ = -4						; size = 2
_lArray$ = 8						; size = 4
_DropViewCluster@4 PROC

; 3995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3996 :    LPTASK        lpCurrentTask = 0;

	mov	DWORD PTR _lpCurrentTask$[ebp], 0

; 3997 :    LPVIEWCLUSTER lpViewCluster = (LPVIEWCLUSTER) lArray;

	mov	eax, DWORD PTR _lArray$[ebp]
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 3998 :    zSHORT        idx;
; 3999 : 
; 4000 :    // Loop through each of the OI's in the cluster.  If the vOI value is
; 4001 :    // -1 then we've reached the end of the view cluster.
; 4002 :    for ( idx = 0; lpViewCluster[ idx ].vOI != (zVIEW) -1; idx++ )

	xor	ecx, ecx
	mov	WORD PTR _idx$[ebp], cx
	jmp	SHORT $LN4@DropViewCl
$LN2@DropViewCl:
	mov	dx, WORD PTR _idx$[ebp]
	add	dx, 1
	mov	WORD PTR _idx$[ebp], dx
$LN4@DropViewCl:
	movsx	eax, WORD PTR _idx$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], -1
	je	$LN3@DropViewCl

; 4003 :    {
; 4004 :       if ( lpViewCluster[ idx ].vOI == 0 )

	movsx	edx, WORD PTR _idx$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $LN5@DropViewCl

; 4005 :          continue;

	jmp	SHORT $LN2@DropViewCl
$LN5@DropViewCl:

; 4006 : 
; 4007 :       // Retrieve the task if we haven't done it already.
; 4008 :       if ( lpCurrentTask == 0 &&

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN6@DropViewCl
	push	0
	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	push	63					; 0000003fH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN6@DropViewCl

; 4009 :            (lpCurrentTask = fnOperationCall( iDropViewCluster,
; 4010 :                                              lpViewCluster[ idx ].vOI, 0 )) == 0 )
; 4011 :       {
; 4012 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@DropViewCl
$LN6@DropViewCl:

; 4013 :       }
; 4014 : 
; 4015 :       if ( lpViewCluster[ idx ].lControl & zCOMMIT_DROPOBJECTINSTANCE )

	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 16384				; 00004000H
	je	SHORT $LN7@DropViewCl

; 4016 :          DropObjectInstance( lpViewCluster[ idx ].vOI );

	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_DropObjectInstance@4
	jmp	SHORT $LN8@DropViewCl
$LN7@DropViewCl:

; 4017 :       else
; 4018 :       if ( lpViewCluster[ idx ].lControl & zCOMMIT_DROPVIEW )

	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 8192				; 00002000H
	je	SHORT $LN8@DropViewCl

; 4019 :          DropView( lpViewCluster[ idx ].vOI );

	movsx	ecx, WORD PTR _idx$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	call	_DropView@4
$LN8@DropViewCl:

; 4020 :    }

	jmp	$LN2@DropViewCl
$LN3@DropViewCl:

; 4021 : 
; 4022 :    fnFreeDataspace( lpViewCluster );

	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 4023 : 
; 4024 :    if ( lpCurrentTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN10@DropViewCl

; 4025 :       fnOperationReturn( iDropViewCluster, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	63					; 0000003fH
	call	_fnOperationReturn
	add	esp, 8
$LN10@DropViewCl:

; 4026 : 
; 4027 :    return( 0 );

	xor	eax, eax
$LN1@DropViewCl:

; 4028 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropViewCluster@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_h$ = -16						; size = 4
_lCnt$ = -12						; size = 4
_lpTask$ = -8						; size = 4
_pv$ = -4						; size = 4
_vTaskView$ = 8						; size = 4
_lpArray$ = 12						; size = 4
_CreateViewCluster@8 PROC

; 3815 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3816 :    LPVIEWCLUSTER pv;
; 3817 :    LPTASK        lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 3818 :    zPVOID        h;
; 3819 :    zLONG         lCnt;
; 3820 : 
; 3821 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@CreateView

; 3822 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CreateView
$LN2@CreateView:

; 3823 : 
; 3824 :    lCnt = zCLUSTER_VIEW_COUNT;

	mov	DWORD PTR _lCnt$[ebp], 2000		; 000007d0H

; 3825 : 
; 3826 :    // Allocate space and set it to all 0s.  Allocate enough space for all the
; 3827 :    // views + 1.  This will allow AddViewToViewArray( ) to know when it's
; 3828 :    // reached the end of the list.
; 3829 :    h = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10104					; 00002778H
	push	0
	push	1
	mov	edx, DWORD PTR _lCnt$[ebp]
	lea	eax, DWORD PTR [edx*8+8]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _h$[ebp], eax

; 3830 :                          sizeof( ViewClusterRecord ) * (zULONG) (lCnt + 1),
; 3831 :                          TRUE, 0, iCluster );
; 3832 :    pv = (LPVIEWCLUSTER) zGETPTR( h );

	mov	eax, DWORD PTR _h$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pv$[ebp], eax

; 3833 : 
; 3834 :    if ( pv )

	cmp	DWORD PTR _pv$[ebp], 0
	je	SHORT $LN3@CreateView

; 3835 :    {
; 3836 :       // At the end of the array set the last view to -1.
; 3837 :       pv[ lCnt ].vOI = (zVIEW) -1;

	mov	ecx, DWORD PTR _lCnt$[ebp]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [edx+ecx*8], -1
$LN3@CreateView:

; 3838 :    }
; 3839 : 
; 3840 :    *lpArray = (zLONG) pv;

	mov	eax, DWORD PTR _lpArray$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax], ecx

; 3841 : 
; 3842 :    return( 0 );

	xor	eax, eax
$LN1@CreateView:

; 3843 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateViewCluster@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_tViewArrayBlock$ = -1220				; size = 64
_lTickCount$ = -1156					; size = 4
_lpTask$1 = -1152					; size = 4
_lpTask$2 = -1148					; size = 4
tv942 = -1144						; size = 4
_lpViewCsr$ = -1140					; size = 4
_hViewOI$3 = -1136					; size = 4
_bNetworkCommit$ = -1129				; size = 1
_vReferenceView$ = -1128				; size = 4
_lpViewCsr$4 = -1124					; size = 4
_j$5 = -1120						; size = 4
_lpViewEntity$6 = -1116					; size = 4
_nState$7 = -1112					; size = 2
_lpViewOD$ = -1108					; size = 4
_lpViewOI$ = -1104					; size = 4
_pchNetworkName$ = -1100				; size = 4
_nReturn$ = -1096					; size = 2
_bLockingSemaphoreCreatedHere$ = -1090			; size = 1
_bDropPessimisticLocks$ = -1089				; size = 1
_lpCurrentTask$ = -1088					; size = 4
_iOpID$ = -1084						; size = 2
_lpEntityInstance$8 = -1080				; size = 4
_nRC$ = -1076						; size = 2
_lpViewCluster$ = -1072					; size = 4
_lpViewArray$ = -1068					; size = 4
_k$ = -1064						; size = 2
_szMsg$9 = -1060					; size = 1024
_sz$10 = -36						; size = 30
__$ArrayPad$ = -4					; size = 4
_lpOrigViewCluster$ = 8					; size = 4
_nViewCount$ = 12					; size = 2
_pnViewErrorIdx$ = 16					; size = 4
_lControl$ = 20						; size = 4
_CommitMultipleOIs@16 PROC

; 4078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1220				; 000004c4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 4079 :    LPVIEWCLUSTER     lpViewCluster = 0;

	mov	DWORD PTR _lpViewCluster$[ebp], 0

; 4080 :    VIEWARRAYBLOCK    tViewArrayBlock = { 0 };

	mov	DWORD PTR _tViewArrayBlock$[ebp], 0
	push	60					; 0000003cH
	push	0
	lea	eax, DWORD PTR _tViewArrayBlock$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 4081 :    LPTASK            lpCurrentTask;
; 4082 :    LPVIEWCSR         lpViewCsr;
; 4083 :    LPVIEWOI          lpViewOI;
; 4084 :    LPVIEWOD          lpViewOD;
; 4085 :    zPCHAR            pchNetworkName = 0;

	mov	DWORD PTR _pchNetworkName$[ebp], 0

; 4086 :    zVIEW             vReferenceView;
; 4087 :    zVIEW             *lpViewArray = 0;

	mov	DWORD PTR _lpViewArray$[ebp], 0

; 4088 :    zLONG             lTickCount;
; 4089 :    zBOOL             bNetworkCommit = FALSE;

	mov	BYTE PTR _bNetworkCommit$[ebp], 0

; 4090 :    zBOOL             bLockingSemaphoreCreatedHere = FALSE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 0

; 4091 :    zBOOL             bDropPessimisticLocks = FALSE;

	mov	BYTE PTR _bDropPessimisticLocks$[ebp], 0

; 4092 :    zSHORT            iOpID;
; 4093 :    zSHORT            k;
; 4094 :    zSHORT            nRC;
; 4095 :    zSHORT            nReturn = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nReturn$[ebp], cx

; 4096 : 
; 4097 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	and	eax, 1
	je	SHORT $LN31@CommitMult

; 4098 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$LN31@CommitMult:

; 4099 : 
; 4100 :    // If nViewCount is 0 then determine number of views by counting non-zero
; 4101 :    // views.
; 4102 :    if ( nViewCount == 0 )

	movsx	ecx, WORD PTR _nViewCount$[ebp]
	test	ecx, ecx
	jne	SHORT $LN35@CommitMult
$LN2@CommitMult:

; 4103 :    {
; 4104 :       // The list can be terminated by either a 0 or -1.  The -1 might be
; 4105 :       // set by CreateEmptyViewCluster( ) above.
; 4106 :       while ( TRUE )

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@CommitMult

; 4107 :       {
; 4108 :          if ( lpOrigViewCluster[ nViewCount ].vOI == 0 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN33@CommitMult

; 4109 :             break;

	jmp	SHORT $LN3@CommitMult
$LN33@CommitMult:

; 4110 : 
; 4111 :          if ( lpOrigViewCluster[ nViewCount ].vOI == (zVIEW) -1 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	mov	eax, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], -1
	jne	SHORT $LN34@CommitMult

; 4112 :             break;

	jmp	SHORT $LN3@CommitMult
$LN34@CommitMult:

; 4113 : 
; 4114 :          nViewCount++;

	mov	cx, WORD PTR _nViewCount$[ebp]
	add	cx, 1
	mov	WORD PTR _nViewCount$[ebp], cx

; 4115 :       }

	jmp	SHORT $LN2@CommitMult
$LN3@CommitMult:

; 4116 : 
; 4117 :       // If nViewCount is *still* 0 then just get out.
; 4118 :       if ( nViewCount == 0 )

	movsx	edx, WORD PTR _nViewCount$[ebp]
	test	edx, edx
	jne	SHORT $LN35@CommitMult

; 4119 :       {
; 4120 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN36@CommitMult

; 4121 :             *pnViewErrorIdx = -1;

	or	eax, -1
	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	WORD PTR [ecx], ax
$LN36@CommitMult:

; 4122 : 
; 4123 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@CommitMult
$LN35@CommitMult:

; 4124 :       }
; 4125 :    }
; 4126 : 
; 4127 :    if ( pnViewErrorIdx == (zPSHORT) -1 )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], -1
	jne	SHORT $LN37@CommitMult

; 4128 :    {
; 4129 :       iOpID = iCommitObjectInstance;

	mov	edx, 60					; 0000003cH
	mov	WORD PTR _iOpID$[ebp], dx

; 4130 :       pnViewErrorIdx = 0;

	mov	DWORD PTR _pnViewErrorIdx$[ebp], 0

; 4131 :       lpCurrentTask = zGETPTR( lpOrigViewCluster[ 0 ].vOI->hTask );

	mov	eax, 8
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 4132 :    }

	jmp	$LN40@CommitMult
$LN37@CommitMult:

; 4133 :    else
; 4134 :    {
; 4135 :       iOpID = iCommitMultipleOIs;

	mov	edx, 62					; 0000003eH
	mov	WORD PTR _iOpID$[ebp], dx

; 4136 : 
; 4137 :       // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 4138 :       for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN6@CommitMult
$LN4@CommitMult:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN6@CommitMult:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN5@CommitMult

; 4139 :       {
; 4140 :          if ( lpOrigViewCluster[ k ].vOI )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	je	SHORT $LN39@CommitMult

; 4141 :             break;

	jmp	SHORT $LN5@CommitMult
$LN39@CommitMult:

; 4142 :       }

	jmp	SHORT $LN4@CommitMult
$LN5@CommitMult:

; 4143 : 
; 4144 :       if ( (lpCurrentTask = fnOperationCall( iOpID,
; 4145 :                                              lpOrigViewCluster[ k ].vOI, 0 )) == 0 )

	push	0
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	movzx	eax, WORD PTR _iOpID$[ebp]
	push	eax
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN40@CommitMult

; 4146 :       {
; 4147 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CommitMult
$LN40@CommitMult:

; 4148 :       }
; 4149 :    }
; 4150 : 
; 4151 : // TraceLineI( "CommitMultipleOIs: ENTRY OperationID: ", iOpID );
; 4152 : 
; 4153 :    lpViewCluster = fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10104					; 00002778H
	push	0
	push	1
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	shl	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 4154 :                                      sizeof( ViewClusterRecord ) * (zULONG) nViewCount,
; 4155 :                                      TRUE, 0, iCluster );
; 4156 :    lpViewCluster = zGETPTR( lpViewCluster );

	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCluster$[ebp], eax

; 4157 : 
; 4158 :    // Create temporary views so core can muck with the cursors.
; 4159 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN9@CommitMult
$LN7@CommitMult:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN9@CommitMult:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN8@CommitMult

; 4160 :    {
; 4161 :       LPVIEWCSR  lpViewCsr;
; 4162 :       LPVIEWOI   hViewOI;
; 4163 :       zLONG      j;
; 4164 : 
; 4165 :       if ( lpOrigViewCluster[ k ].vOI == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	jne	SHORT $LN41@CommitMult

; 4166 :          continue;

	jmp	SHORT $LN7@CommitMult
$LN41@CommitMult:

; 4167 : 
; 4168 :       lpViewCsr = zGETPTR( lpOrigViewCluster[ k ].vOI->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$4[ebp], eax

; 4169 :       if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$4[ebp], 0
	jne	SHORT $LN42@CommitMult

; 4170 :          continue; // should never occur

	jmp	SHORT $LN7@CommitMult
$LN42@CommitMult:

; 4171 : 
; 4172 :       hViewOI = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$4[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hViewOI$3[ebp], ecx

; 4173 : 
; 4174 :       // Make sure the OI isn't already part of the cluster.
; 4175 :       for ( j = 0; j < k; j++ )

	mov	DWORD PTR _j$5[ebp], 0
	jmp	SHORT $LN12@CommitMult
$LN10@CommitMult:
	mov	edx, DWORD PTR _j$5[ebp]
	add	edx, 1
	mov	DWORD PTR _j$5[ebp], edx
$LN12@CommitMult:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	DWORD PTR _j$5[ebp], eax
	jge	SHORT $LN11@CommitMult

; 4176 :       {
; 4177 :          if ( lpOrigViewCluster[ j ].vOI == 0 )

	mov	ecx, DWORD PTR _j$5[ebp]
	mov	edx, DWORD PTR _lpOrigViewCluster$[ebp]
	cmp	DWORD PTR [edx+ecx*8], 0
	jne	SHORT $LN43@CommitMult

; 4178 :             continue;

	jmp	SHORT $LN10@CommitMult
$LN43@CommitMult:

; 4179 : 
; 4180 :          lpViewCsr = zGETPTR( lpOrigViewCluster[ j ].vOI->hViewCsr );

	mov	eax, DWORD PTR _j$5[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$4[ebp], eax

; 4181 :          if ( lpViewCsr == 0 )

	cmp	DWORD PTR _lpViewCsr$4[ebp], 0
	jne	SHORT $LN44@CommitMult

; 4182 :             continue; // should never occur

	jmp	SHORT $LN10@CommitMult
$LN44@CommitMult:

; 4183 : 
; 4184 :          if ( lpViewCsr->hViewOI == hViewOI )

	mov	ecx, DWORD PTR _lpViewCsr$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	cmp	edx, DWORD PTR _hViewOI$3[ebp]
	jne	SHORT $LN45@CommitMult

; 4185 :          {
; 4186 :             // it is already in cluster, so skip it for commit
; 4187 :             hViewOI = 0; // just to indicate skipping

	mov	DWORD PTR _hViewOI$3[ebp], 0

; 4188 :             break;

	jmp	SHORT $LN11@CommitMult
$LN45@CommitMult:

; 4189 :          }
; 4190 :       }

	jmp	SHORT $LN10@CommitMult
$LN11@CommitMult:

; 4191 : 
; 4192 :       if ( hViewOI == 0 )

	cmp	DWORD PTR _hViewOI$3[ebp], 0
	jne	SHORT $LN46@CommitMult

; 4193 :          continue; // skip, because OI already found in cluster

	jmp	$LN7@CommitMult
$LN46@CommitMult:

; 4194 : 
; 4195 :       CreateViewFromViewForTask( &lpViewCluster[ k ].vOI,

	push	0
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpOrigViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	call	_CreateViewFromViewForTask@12

; 4196 :                                  lpOrigViewCluster[ k ].vOI, 0 );
; 4197 :    }

	jmp	$LN7@CommitMult
$LN8@CommitMult:

; 4198 : 
; 4199 :    if ( fnInitViewArrayBlock( &tViewArrayBlock, nViewCount ) != 0 )

	movsx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tViewArrayBlock$[ebp]
	push	ecx
	call	_fnInitViewArrayBlock
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN47@CommitMult

; 4200 :    {
; 4201 :       if ( iOpID == iCommitMultipleOIs )

	movsx	eax, WORD PTR _iOpID$[ebp]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN48@CommitMult

; 4202 :          fnOperationReturn( iOpID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOpID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8
$LN48@CommitMult:

; 4203 : 
; 4204 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CommitMult
$LN47@CommitMult:

; 4205 :    }
; 4206 : 
; 4207 :    lpViewArray = tViewArrayBlock.pvArray;

	mov	eax, DWORD PTR _tViewArrayBlock$[ebp+4]
	mov	DWORD PTR _lpViewArray$[ebp], eax

; 4208 : 
; 4209 :    // Verify that all the views are OK.
; 4210 :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN15@CommitMult
$LN13@CommitMult:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN15@CommitMult:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN14@CommitMult

; 4211 :    {
; 4212 :       // We allow NULL views.  This is mostly because fnNetProcessCommit might
; 4213 :       // send us an array containing null views.
; 4214 :       if ( lpViewCluster[ k ].vOI == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [eax+edx*8], 0
	jne	SHORT $LN49@CommitMult

; 4215 :          continue;

	jmp	SHORT $LN13@CommitMult
$LN49@CommitMult:

; 4216 : 
; 4217 :       if ( fnValidViewCsr( lpCurrentTask, lpViewCluster[ k ].vOI ) == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN50@CommitMult

; 4218 :       {
; 4219 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN51@CommitMult

; 4220 :             *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$LN51@CommitMult:

; 4221 : 
; 4222 :          goto EndOfFunction;

	jmp	$EndOfFunction$95
$LN50@CommitMult:

; 4223 :       }
; 4224 : 
; 4225 :       lpViewArray[ k ] = lpViewCluster[ k ].vOI;

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	esi, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [esi+edx*8]
	mov	DWORD PTR [ecx+eax*4], edx

; 4226 : 
; 4227 :       lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4228 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4229 :       lpViewOD  = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4230 : 
; 4231 :       // Check to see if this is a network commit.
; 4232 :       if ( lpViewOD->szNetwork &&

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 109				; 0000006dH
	je	SHORT $LN52@CommitMult
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+48]
	and	eax, 1073741824				; 40000000H
	jne	SHORT $LN52@CommitMult

; 4233 :            (lpViewOI->lActivateControl & zACTIVATE_LOCAL) == 0 )
; 4234 :       {
; 4235 :          pchNetworkName = lpViewOD->szNetwork;

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 109				; 0000006dH
	mov	DWORD PTR _pchNetworkName$[ebp], ecx
$LN52@CommitMult:

; 4236 :       }
; 4237 : 
; 4238 :       // If lControl for commit is zCOMMIT_DROPLOCKSONLY then turn on the flag
; 4239 :       // for each of the views.
; 4240 :       if ( lControl & zCOMMIT_DROPLOCKSONLY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN53@CommitMult

; 4241 :          lpViewCluster[ k ].lControl |= zCOMMIT_DROPLOCKSONLY;

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	edx, DWORD PTR [ecx+eax*8+4]
	or	edx, 2048				; 00000800H
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	mov	DWORD PTR [ecx+eax*8+4], edx
$LN53@CommitMult:

; 4242 : 
; 4243 :       // If we're only committing the objects to drop the locks then we don't
; 4244 :       // want to commit this OI so set lpViewArray to 0.
; 4245 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN54@CommitMult

; 4246 :       {
; 4247 :          // If a network has been specified for this cluster then we *don't*
; 4248 :          // want to zero out the view because we want to send it the server.
; 4249 :          if ( pchNetworkName == 0 || *pchNetworkName == 0 )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	je	SHORT $LN57@CommitMult
	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN55@CommitMult
$LN57@CommitMult:

; 4250 :             lpViewArray[ k ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [edx+ecx*4], 0
	jmp	SHORT $LN56@CommitMult
$LN55@CommitMult:

; 4251 :          else
; 4252 :             vReferenceView = lpViewArray[ k ];  // dks donc jb  2004.11.02

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _vReferenceView$[ebp], edx
$LN56@CommitMult:

; 4253 : 
; 4254 :          continue;

	jmp	$LN13@CommitMult
$LN54@CommitMult:

; 4255 :       }
; 4256 : 
; 4257 :       // If OI is read-only then forget it.
; 4258 :       if ( lpViewOI->bReadOnly )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN58@CommitMult

; 4259 :       {
; 4260 :          LPTASK lpTask = zGETPTR( lpViewArray[ k ]->hTask );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 4261 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN59@CommitMult

; 4262 :             *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$LN59@CommitMult:

; 4263 : 
; 4264 :          // "KZOEE079 - Trying to commit a read-only view".
; 4265 :          fnIssueCoreError( lpTask, lpViewArray[ k ], 8, 79, 0,

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14747
	push	0
	push	79					; 0000004fH
	push	8
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4266 :                            "Object Name = ", lpViewOD->szName );
; 4267 :          goto EndOfFunction;

	jmp	$EndOfFunction$95
$LN58@CommitMult:

; 4268 :       }
; 4269 : 
; 4270 :       // Make sure OI does not contain versioned instances
; 4271 :       if ( lpViewOI->nVersionedInstances )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	SHORT $LN60@CommitMult

; 4272 :       {
; 4273 :          LPTASK lpTask = zGETPTR( lpViewArray[ k ]->hTask );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 4274 :          if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN61@CommitMult

; 4275 :             *pnViewErrorIdx = k;

	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR [ecx], dx
$LN61@CommitMult:

; 4276 : 
; 4277 :          //  "KZOEE076 - Object instance contains versioned entity instances"
; 4278 :          fnIssueCoreError( lpTask, lpViewArray[ k ], 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4279 :          goto EndOfFunction;

	jmp	$EndOfFunction$95
$LN60@CommitMult:

; 4280 :       }
; 4281 : 
; 4282 :       // Make sure that the view has an object instance.
; 4283 :       if ( lpViewOI->hRootEntityInstance == 0 )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $LN62@CommitMult

; 4284 :       {
; 4285 :          // Set array value to 0 to indicate that we don't need to commit
; 4286 :          // this view.
; 4287 :          lpViewArray[ k ] = 0;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [eax+edx*4], 0

; 4288 :          continue;

	jmp	$LN13@CommitMult
$LN62@CommitMult:

; 4289 :       }
; 4290 : 
; 4291 :       // If OI hasn't been updated then forget about it UNLESS...
; 4292 :       // there is pessimistic locking.  Then we need to continue so that any
; 4293 :       // pessimistic locks are dropped.
; 4294 :       if ( lpViewOI->bUpdated == FALSE &&

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN63@CommitMult
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	and	ecx, 67108864				; 04000000H
	jne	SHORT $LN63@CommitMult

; 4295 :            (lpViewOI->lActivateControl & zACTIVATE_WITH_LOCKING) == 0 )
; 4296 :       {
; 4297 :          // Set array value to 0 to indicate that we don't need to commit
; 4298 :          // this view.
; 4299 :          lpViewArray[ k ] = 0;

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	DWORD PTR [eax+edx*4], 0

; 4300 :          continue;

	jmp	$LN13@CommitMult
$LN63@CommitMult:

; 4301 :       }
; 4302 : 
; 4303 :       // Check to see if we need pessimistic locks on this view.
; 4304 :       if ( lpViewOI->bIsLocked && (lControl & zCOMMIT_KEEPLOCKS) == 0 )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 7
	and	edx, 1
	je	SHORT $LN64@CommitMult
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 4096				; 00001000H
	jne	SHORT $LN64@CommitMult

; 4305 :          bDropPessimisticLocks = TRUE;

	mov	BYTE PTR _bDropPessimisticLocks$[ebp], 1
$LN64@CommitMult:

; 4306 : 
; 4307 :       vReferenceView = lpViewArray[ k ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR _vReferenceView$[ebp], eax

; 4308 :    }

	jmp	$LN13@CommitMult
$LN14@CommitMult:

; 4309 : 
; 4310 :    // Make sure that at least one view is being committed.
; 4311 :    for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN18@CommitMult
$LN16@CommitMult:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN18@CommitMult:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN17@CommitMult

; 4312 :    {
; 4313 :       if ( lpViewArray[ k ] )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	je	SHORT $LN65@CommitMult

; 4314 :          break;

	jmp	SHORT $LN17@CommitMult
$LN65@CommitMult:

; 4315 : 
; 4316 :       if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	mov	eax, DWORD PTR [edx+ecx*8+4]
	and	eax, 2048				; 00000800H
	je	SHORT $LN66@CommitMult

; 4317 :          break;

	jmp	SHORT $LN17@CommitMult
$LN66@CommitMult:

; 4318 :    }

	jmp	SHORT $LN16@CommitMult
$LN17@CommitMult:

; 4319 : 
; 4320 :    if ( k == nViewCount )

	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN67@CommitMult

; 4321 :    {
; 4322 :       // No non-zero views found so forget it.
; 4323 :       nReturn = 0;

	xor	eax, eax
	mov	WORD PTR _nReturn$[ebp], ax

; 4324 :       goto EndOfFunction;

	jmp	$EndOfFunction$95
$LN67@CommitMult:

; 4325 :    }
; 4326 : 
; 4327 : #ifdef __ACTIVATE_CONSTRAINTS__
; 4328 :    if ( (lControl & zCOMMIT_NOCONSTRAINTS) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 16777216				; 01000000H
	jne	$LN20@CommitMult

; 4329 :    {
; 4330 :       for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN21@CommitMult
$LN19@CommitMult:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN21@CommitMult:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN20@CommitMult

; 4331 :       {
; 4332 :          zSHORT nState;
; 4333 : 
; 4334 :          // Don't worry about null views.
; 4335 :          if ( lpViewArray[ k ] == 0 )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	jne	SHORT $LN69@CommitMult

; 4336 :             continue;

	jmp	SHORT $LN19@CommitMult
$LN69@CommitMult:

; 4337 : 
; 4338 :          // If this view is only dropping the pessimistic locks then don't
; 4339 :          // call the constraint.
; 4340 :          if ( lpViewCluster[ k ].lControl & zCOMMIT_DROPLOCKSONLY )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8+4]
	and	ecx, 2048				; 00000800H
	je	SHORT $LN70@CommitMult

; 4341 :             continue;

	jmp	SHORT $LN19@CommitMult
$LN70@CommitMult:

; 4342 : 
; 4343 :          lpViewOD = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4344 : 
; 4345 :          // If object has commit constraint active, check for objections.
; 4346 :          // If any exit...
; 4347 :          if ( lpViewOD->bCommitConstraint == FALSE )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN71@CommitMult

; 4348 :             continue;

	jmp	$LN19@CommitMult
$LN71@CommitMult:

; 4349 : 
; 4350 :          nState = 0;

	xor	edx, edx
	mov	WORD PTR _nState$7[ebp], dx

; 4351 :          if ( lpCurrentTask->bShutdown )

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN72@CommitMult

; 4352 :             nState += zOCE_STATE_SHUTDOWN;

	movsx	edx, WORD PTR _nState$7[ebp]
	add	edx, 2
	mov	WORD PTR _nState$7[ebp], dx
$LN72@CommitMult:

; 4353 : 
; 4354 :          nRC = fnInvokeOCEOperation( lpViewArray[ k ], lpCurrentTask,

	movzx	eax, WORD PTR _nState$7[ebp]
	push	eax
	push	3
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 4355 :                                      zOCE_COMMIT, nState );
; 4356 :          if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN73@CommitMult

; 4357 :          {
; 4358 :             if ( pnViewErrorIdx )

	cmp	DWORD PTR _pnViewErrorIdx$[ebp], 0
	je	SHORT $LN74@CommitMult

; 4359 :                *pnViewErrorIdx = k;

	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR [eax], cx
$LN74@CommitMult:

; 4360 : 
; 4361 :             nReturn = nRC;

	mov	dx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturn$[ebp], dx

; 4362 :             goto EndOfFunction;

	jmp	$EndOfFunction$95
$LN73@CommitMult:

; 4363 :          }
; 4364 :       }

	jmp	$LN19@CommitMult
$LN20@CommitMult:

; 4365 :    }
; 4366 : #endif
; 4367 : 
; 4368 :    if ( pchNetworkName && *pchNetworkName )

	cmp	DWORD PTR _pchNetworkName$[ebp], 0
	je	$LN75@CommitMult
	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN75@CommitMult

; 4369 :    {
; 4370 :       // Network Commit
; 4371 : 
; 4372 :       // First make sure the network is active.
; 4373 :       if ( NetStatus( vReferenceView, pchNetworkName ) == 0 )

	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _vReferenceView$[ebp]
	push	eax
	call	_NetStatus@8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN77@CommitMult

; 4374 :       {
; 4375 :          if ( NetStartup( vReferenceView, pchNetworkName, pchNetworkName ) != 0 )

	mov	edx, DWORD PTR _pchNetworkName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vReferenceView$[ebp]
	push	ecx
	call	_NetStartup@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN77@CommitMult

; 4376 :          {
; 4377 :             TraceLineS( "(oi) Can't start network = ", pchNetworkName );

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	push	OFFSET $SG14766
	call	_TraceLineS@8

; 4378 :             MessageSend( vReferenceView, "xx", "KZOEOIAA",

	push	1
	push	300					; 0000012cH
	push	OFFSET $SG14767
	push	OFFSET $SG14768
	push	OFFSET $SG14769
	mov	ecx, DWORD PTR _vReferenceView$[ebp]
	push	ecx
	call	_MessageSend@24

; 4379 :                         "Network cannot be started.",
; 4380 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 1 );
; 4381 : 
; 4382 :             goto EndOfFunction;

	jmp	$EndOfFunction$95
$LN77@CommitMult:

; 4383 :          }
; 4384 :       }
; 4385 : 
; 4386 :       nRC = NetCommitOI( pchNetworkName, 0, lpViewCluster,

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _pnViewErrorIdx$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nViewCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	call	_NetCommitOI@28
	mov	WORD PTR _nRC$[ebp], ax

; 4387 :                          lpViewArray, nViewCount, pnViewErrorIdx, lControl );
; 4388 : 
; 4389 : #ifdef DEBUG
; 4390 :       if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN23@CommitMult

; 4391 :       {
; 4392 :          for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN24@CommitMult
$LN22@CommitMult:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN24@CommitMult:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	$LN23@CommitMult

; 4393 :          {
; 4394 :             LPENTITYINSTANCE lpEntityInstance;
; 4395 :             LPVIEWENTITY     lpViewEntity;
; 4396 : 
; 4397 :             if ( lpViewArray[ k ] == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _lpViewArray$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	jne	SHORT $LN79@CommitMult

; 4398 :                continue;

	jmp	SHORT $LN22@CommitMult
$LN79@CommitMult:

; 4399 : 
; 4400 :             lpViewCsr = zGETPTR( lpViewArray[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4401 :             lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4402 : 
; 4403 :             for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8[ebp], eax
	jmp	SHORT $LN27@CommitMult
$LN25@CommitMult:

; 4405 :                   lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8[ebp], eax
$LN27@CommitMult:

; 4404 :                   lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$8[ebp], 0
	je	$LN26@CommitMult

; 4406 :             {
; 4407 :                lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$6[ebp], eax

; 4408 : 
; 4409 :                if ( lpViewEntity->bDerivedPath == FALSE &&

	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	jne	$LN85@CommitMult
	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN82@CommitMult
	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN82@CommitMult
	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+235]
	and	ecx, 1
	jne	SHORT $LN81@CommitMult
$LN82@CommitMult:
	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN83@CommitMult
	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN83@CommitMult
	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 2
	and	ecx, 1
	jne	SHORT $LN81@CommitMult
$LN83@CommitMult:
	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 3
	and	eax, 1
	je	$LN85@CommitMult
	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	jne	$LN85@CommitMult
	mov	eax, DWORD PTR _lpViewEntity$6[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 1
	and	ecx, 1
	je	$LN85@CommitMult
$LN81@CommitMult:

; 4410 :                     ((lpEntityInstance->u.nInd.bCreated  &&
; 4411 :                       lpEntityInstance->u.nInd.bDeleted == FALSE &&
; 4412 :                       lpViewEntity->bCreate)                  ||
; 4413 :                      (lpEntityInstance->u.nInd.bUpdated  &&
; 4414 :                       lpEntityInstance->u.nInd.bDeleted == FALSE &&
; 4415 :                       lpViewEntity->bUpdate)                  ||
; 4416 :                      (lpEntityInstance->u.nInd.bDeleted  &&
; 4417 :                       lpEntityInstance->u.nInd.bCreated == FALSE &&
; 4418 :                       lpViewEntity->bDelete))
; 4419 : /*
; 4420 :                ||   (lpEntityInstance->u.nInd.bIncluded &&
; 4421 :                      lpViewEntity->bInclude)                 ||
; 4422 :                     (lpEntityInstance->u.nInd.bExcluded &&
; 4423 :                      lpViewEntity->bExclude)
; 4424 : */
; 4425 :                    )
; 4426 :                {
; 4427 :                   if ( (lControl & zCOMMIT_DROPLOCKSONLY) == 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2048				; 00000800H
	jne	$LN84@CommitMult

; 4428 :                   {
; 4429 :                      zCHAR szMsg[ 1024 ];
; 4430 : 
; 4431 :                      lpViewOD = zGETPTR( lpViewArray[ k ]->hViewOD );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4432 : 
; 4433 :                      TraceLineS( "(oi) Warning ============================", "" );

	push	OFFSET $SG14777
	push	OFFSET $SG14778
	call	_TraceLineS@8

; 4434 :                      TraceLineS( "(oi) Object definition = ", lpViewOD->szName );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14779
	call	_TraceLineS@8

; 4435 :                      TraceLineS( "(oi) Entity name = ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$6[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG14780
	call	_TraceLineS@8

; 4436 :                      TraceLineX( "(oi) EI Flags    = ", lpEntityInstance->u.nIndicators );

	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	push	OFFSET $SG14781
	call	_TraceLineX@8

; 4437 :                      zsprintf( szMsg, "%s  %s   Object Definition: %s   "

	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$6[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14782
	push	OFFSET $SG14783
	push	OFFSET $SG14784
	lea	eax, DWORD PTR _szMsg$9[ebp]
	push	eax
	call	_sprintf
	add	esp, 28					; 0000001cH

; 4438 :                                  "EntityName: %s   EI Flags 0x%08x",
; 4439 :                                "OE Warning", "Return code indicates that "
; 4440 :                                  "Commit was successful but OI still has "
; 4441 :                                  "instances marked as changed.",
; 4442 :                                lpViewOD->szName,
; 4443 :                                lpViewEntity->szName,
; 4444 :                                lpEntityInstance->u.nIndicators );
; 4445 :                      SysDiagnosticMessage( lpViewArray[ k ], "OE Warning",

	push	1
	lea	ecx, DWORD PTR _szMsg$9[ebp]
	push	ecx
	push	OFFSET $SG14785
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewArray$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	call	_SysDiagnosticMessage@16
$LN84@CommitMult:

; 4446 :                                            szMsg, 1 );
; 4447 :                   }
; 4448 : 
; 4449 :                   if ( lpViewEntity->bCreate )

	mov	edx, DWORD PTR _lpViewEntity$6[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	je	SHORT $LN85@CommitMult

; 4450 :                      lpEntityInstance->u.nInd.bCreated = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	mov	DWORD PTR [eax+6], edx
$LN85@CommitMult:

; 4451 : 
; 4452 :                   // break; Hi DG, was this the bug ??? **HH**
; 4453 :                }
; 4454 :             } // for...

	jmp	$LN25@CommitMult
$LN26@CommitMult:

; 4455 : 
; 4456 :          } // for k...

	jmp	$LN22@CommitMult
$LN23@CommitMult:

; 4457 :       }
; 4458 : #endif
; 4459 : 
; 4460 :       nReturn = nRC;

	mov	cx, WORD PTR _nRC$[ebp]
	mov	WORD PTR _nReturn$[ebp], cx

; 4461 :       goto EndOfFunction;

	jmp	$EndOfFunction$95
$LN75@CommitMult:

; 4462 :    }
; 4463 : 
; 4464 :    // Check to see if any OIs where activated using pessimistic locking.  If
; 4465 :    // so then we need to create the pessimistic lock semaphore record for the
; 4466 :    // current task (unless it's already been created).
; 4467 :    if ( bDropPessimisticLocks &&

	movzx	edx, BYTE PTR _bDropPessimisticLocks$[ebp]
	test	edx, edx
	je	SHORT $LN88@CommitMult
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 8
	and	ecx, 1
	jne	SHORT $LN88@CommitMult

; 4468 :         lpCurrentTask->bPessimisticLockingSet == FALSE )
; 4469 :    {
; 4470 :       // Returns: 0 - everything OK;  1 - Semaphore not needed.
; 4471 :       nRC = fnCreatePessimisticSemaphore( lpCurrentTask,

	push	0
	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	edx
	movzx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreatePessimisticSemaphore@20
	mov	WORD PTR _nRC$[ebp], ax

; 4472 :                                           (zPVOID) lpViewCluster,
; 4473 :                                           nViewCount, pnViewErrorIdx, 0 );
; 4474 :       if ( nRC < 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN87@CommitMult

; 4475 :          goto EndOfFunction;  // oops...error.

	jmp	SHORT $EndOfFunction$95
$LN87@CommitMult:

; 4476 : 
; 4477 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN88@CommitMult

; 4478 :          bLockingSemaphoreCreatedHere = TRUE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 1
$LN88@CommitMult:

; 4479 :    }
; 4480 : 
; 4481 :    // Commit all the object instances in the array.
; 4482 :    nReturn = fnCommitObjectInstance( lpViewCluster, lpViewArray, nViewCount,

	lea	edx, DWORD PTR _tViewArrayBlock$[ebp]
	push	edx
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	edx
	movzx	eax, WORD PTR _nViewCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewArray$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	call	_fnCommitObjectInstance@28
	mov	WORD PTR _nReturn$[ebp], ax

; 4483 :                                      pnViewErrorIdx, lpCurrentTask,
; 4484 :                                      lControl, &tViewArrayBlock );
; 4485 : 
; 4486 :    if ( bLockingSemaphoreCreatedHere )

	movzx	eax, BYTE PTR _bLockingSemaphoreCreatedHere$[ebp]
	test	eax, eax
	je	SHORT $EndOfFunction$95

; 4487 :       fnDeletePessimisticSemaphore( lpCurrentTask, (zPVOID) lpViewCluster,

	push	0
	mov	ecx, DWORD PTR _pnViewErrorIdx$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nViewCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeletePessimisticSemaphore@20
$EndOfFunction$95:

; 4488 :                                     nViewCount, pnViewErrorIdx, 0 );
; 4489 : 
; 4490 : EndOfFunction:
; 4491 :    if ( lpViewCluster )

	cmp	DWORD PTR _lpViewCluster$[ebp], 0
	je	SHORT $LN90@CommitMult

; 4492 :    {
; 4493 :       // Drop the temporary views.
; 4494 :       for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN30@CommitMult
$LN28@CommitMult:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN30@CommitMult:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN29@CommitMult

; 4495 :       {
; 4496 :          if ( lpViewCluster[ k ].vOI )

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _lpViewCluster$[ebp]
	cmp	DWORD PTR [ecx+eax*8], 0
	je	SHORT $LN91@CommitMult

; 4497 :             fnDropView( lpViewCluster[ k ].vOI );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _lpViewCluster$[ebp]
	mov	ecx, DWORD PTR [eax+edx*8]
	push	ecx
	call	_fnDropView@4
$LN91@CommitMult:

; 4498 :       }

	jmp	SHORT $LN28@CommitMult
$LN29@CommitMult:

; 4499 : 
; 4500 :       fnFreeDataspace( lpViewCluster );

	mov	edx, DWORD PTR _lpViewCluster$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$LN90@CommitMult:

; 4501 :    }
; 4502 : 
; 4503 :    // free the VIEWARRAYBLOCK areas
; 4504 :    fnFreeViewArrayBlock( &tViewArrayBlock );

	lea	eax, DWORD PTR _tViewArrayBlock$[ebp]
	push	eax
	call	_fnFreeViewArrayBlock
	add	esp, 4

; 4505 : 
; 4506 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	and	edx, 1
	je	SHORT $LN92@CommitMult

; 4507 :    {
; 4508 :       zCHAR sz[ 30 ];
; 4509 : 
; 4510 :       zsprintf( sz, "%lf seconds",

	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR tv942[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv942[ebp]
	mov	eax, DWORD PTR tv942[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG14794
	lea	ecx, DWORD PTR _sz$10[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4511 :                 (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND );
; 4512 :       TraceLineS( "(oi) Total time for CommitMultipleOIs = ", sz );

	lea	edx, DWORD PTR _sz$10[ebp]
	push	edx
	push	OFFSET $SG14795
	call	_TraceLineS@8
$LN92@CommitMult:

; 4513 :    }
; 4514 : 
; 4515 :    if ( iOpID == iCommitMultipleOIs )

	movsx	eax, WORD PTR _iOpID$[ebp]
	cmp	eax, 62					; 0000003eH
	jne	SHORT $LN93@CommitMult

; 4516 :       fnOperationReturn( iOpID, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _iOpID$[ebp]
	push	edx
	call	_fnOperationReturn
	add	esp, 8
$LN93@CommitMult:

; 4517 : 
; 4518 : // TraceLineI( "CommitMultipleOIs: EXIT OperationID: ", iOpID );
; 4519 :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$LN1@CommitMult:

; 4520 : 
; 4521 : } // CommitMultipleOIs

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CommitMultipleOIs@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_ViewCluster$ = -16					; size = 8
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_CommitObjectInstance@4 PROC

; 3774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3775 :    ViewClusterRecord ViewCluster;
; 3776 :    LPTASK            lpCurrentTask;
; 3777 :    zSHORT            nRC;
; 3778 : 
; 3779 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3780 :    if ( (lpCurrentTask = fnOperationCall( iCommitObjectInstance, lpView,
; 3781 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	60					; 0000003cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@CommitObje

; 3782 :    {
; 3783 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CommitObje
$LN2@CommitObje:

; 3784 :    }
; 3785 : 
; 3786 :    ViewCluster.vOI      = lpView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _ViewCluster$[ebp], ecx

; 3787 :    ViewCluster.lControl = 0;

	mov	DWORD PTR _ViewCluster$[ebp+4], 0

; 3788 : 
; 3789 :    // Call commit multiple.  We use "-1" to tell commit multiple that it is
; 3790 :    // being called from CommitObjectInstance.
; 3791 :    nRC = CommitMultipleOIs( &ViewCluster, 1, (zPSHORT) -1, 0 );

	push	0
	push	-1
	push	1
	lea	edx, DWORD PTR _ViewCluster$[ebp]
	push	edx
	call	_CommitMultipleOIs@16
	mov	WORD PTR _nRC$[ebp], ax

; 3792 :    fnOperationReturn( iCommitObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	60					; 0000003cH
	call	_fnOperationReturn
	add	esp, 8

; 3793 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CommitObje:

; 3794 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_CommitObjectInstance@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewEntity$1 = -88					; size = 4
_lpRootViewEntityCsr$2 = -84				; size = 4
_lpOwningTask$ = -80					; size = 4
_hTgtViewOI$3 = -76					; size = 4
_lpSrcViewOI$ = -72					; size = 4
_lpInstanceOwningTask$4 = -68				; size = 4
_hWkInstance1$5 = -64					; size = 4
_l$ = -60						; size = 4
_lpTgtParent$6 = -56					; size = 4
_lpTgtView$ = -52					; size = 4
_lpTgtViewOI$ = -48					; size = 4
_lpLastTgtEntityInstance$7 = -44			; size = 4
_lpCurrentTask$ = -40					; size = 4
_lpWkInstance2$8 = -36					; size = 4
_lpViewCsr$ = -32					; size = 4
_hTgtEntityInstance$9 = -28				; size = 4
_lpSrcEntityInstance$10 = -24				; size = 4
_lpWkInstance1$11 = -20					; size = 4
_lpTgtEntityInstance$12 = -16				; size = 4
_nLastLvl$13 = -12					; size = 2
_nRC$ = -8						; size = 2
_bMultiple$ = -1					; size = 1
_pvReturnView$ = 8					; size = 4
_lpSrcView$ = 12					; size = 4
_lpTaskView$ = 16					; size = 4
_lControl$ = 20						; size = 4
_ActivateOI_FromOI_ForTask@16 PROC

; 2714 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 2715 :    LPTASK      lpCurrentTask;
; 2716 :    LPTASK      lpOwningTask;
; 2717 :    LPVIEWOI    lpSrcViewOI;
; 2718 :    LPVIEWOI    lpTgtViewOI;
; 2719 :    LPVIEWCSR   lpViewCsr;
; 2720 :    zVIEW       lpTgtView;
; 2721 :    zLONG       l;
; 2722 :    zBOOL       bMultiple;
; 2723 :    zSHORT      nRC;
; 2724 : 
; 2725 :    *pvReturnView = 0;  // init in case of error

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2726 : 
; 2727 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2728 :    if ( (lpCurrentTask = fnOperationCall( iActivateOI_FromOI, lpSrcView,
; 2729 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	55					; 00000037H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN23@ActivateOI

; 2730 :    {
; 2731 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN23@ActivateOI:

; 2732 :    }
; 2733 : 
; 2734 :    // Get the view oi and ensure that it has no outstanding temporal
; 2735 :    // entities or subobjects.
; 2736 :    lpViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2737 : 
; 2738 :    lpSrcViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 2739 :    if ( lpSrcViewOI->nVersionedInstances )

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	SHORT $LN24@ActivateOI

; 2740 :    {
; 2741 :       //  "KZOEE076 - Object instance contains versioned entity instances"
; 2742 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 76, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	76					; 0000004cH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2743 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2744 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN24@ActivateOI:

; 2745 :    }
; 2746 : 
; 2747 :    // Verify only one zLEVEL_ option requested.
; 2748 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 2749 :    if ( l && (-l & l) != l )

	je	SHORT $LN25@ActivateOI
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $LN25@ActivateOI

; 2750 :    {
; 2751 :       // error, More than one zLEVEL_ option requested
; 2752 :       // "KZOEE023 - Invalid parameter, "
; 2753 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 23, 0,

	push	0
	push	OFFSET $SG14351
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2754 :                         "More than one zLEVEL_ option requested", 0 );
; 2755 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2756 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN25@ActivateOI:

; 2757 :    }
; 2758 : 
; 2759 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 12					; 0000000cH
	je	SHORT $LN26@ActivateOI

; 2760 :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax
	jmp	SHORT $LN27@ActivateOI
$LN26@ActivateOI:

; 2761 :    else
; 2762 :       lpOwningTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], ecx
$LN27@ActivateOI:

; 2763 : 
; 2764 :    // Get multiple root indicator.
; 2765 :    bMultiple = 0;

	mov	BYTE PTR _bMultiple$[ebp], 0

; 2766 :    if ( lControl & zMULTIPLE )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN28@ActivateOI

; 2767 :       bMultiple = TRUE;

	mov	BYTE PTR _bMultiple$[ebp], 1
$LN28@ActivateOI:

; 2768 : 
; 2769 :    // If zLEVEL_SAME is requested.
; 2770 :    if ( lControl & zLEVEL_SAME )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN29@ActivateOI

; 2771 :    {
; 2772 :       // Turn off the 'same' indicator.
; 2773 :       lControl ^= zLEVEL_SAME;

	mov	ecx, DWORD PTR _lControl$[ebp]
	xor	ecx, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], ecx

; 2774 :       // To determine what the level is of the qualifying view
; 2775 :       //   1. Change lpSrcView to point to the initial
; 2776 :       //      view created for the object instance
; 2777 :       //   2. Check for application level, if there use
; 2778 :       //      zLEVEL_APPLICATION.
; 2779 :       //   3. Check if the view task is the main task, if so use
; 2780 :       //      zLEVEL_SYSTEM.
; 2781 :       //   4. Use the task level...
; 2782 :       lpViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$LN2@ActivateOI:

; 2783 :       while ( lpViewCsr->hNextViewCsr )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+2], 0
	je	SHORT $LN3@ActivateOI

; 2784 :          lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $LN2@ActivateOI
$LN3@ActivateOI:

; 2785 : 
; 2786 :       lpSrcView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcView$[ebp], eax

; 2787 :       if ( lpSrcView->bApplicationView )

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN30@ActivateOI

; 2788 :          lControl |= zLEVEL_APPLICATION;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 4
	mov	DWORD PTR _lControl$[ebp], edx
	jmp	SHORT $LN29@ActivateOI
$LN30@ActivateOI:

; 2789 :       else
; 2790 :       if ( lpSrcView->hTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN29@ActivateOI

; 2791 :          lControl |= zLEVEL_SYSTEM;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 8
	mov	DWORD PTR _lControl$[ebp], eax
$LN29@ActivateOI:

; 2792 :    }
; 2793 : 
; 2794 :    if ( (nRC = fnDeclareView( &lpTgtView, lpOwningTask,
; 2795 :                               lpSrcView, 0, 0 )) != 0 )

	push	0
	push	0
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN33@ActivateOI

; 2796 :    {
; 2797 :       fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 2798 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@ActivateOI
$LN33@ActivateOI:

; 2799 :    }
; 2800 : 
; 2801 : #if 0
; 2802 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 2803 :    {
; 2804 :       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 2805 :                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 2806 :       if ( (nRC = SfTransferView( lpTgtView, lpSrcView,
; 2807 :                                   nScope )) != 0 )
; 2808 :       {
; 2809 :          fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );
; 2810 :          return( nRC );
; 2811 :       }
; 2812 :    }
; 2813 : #endif
; 2814 : 
; 2815 :    // Create an empty object instance in which to copy the object instance.
; 2816 :    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpTgtView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2817 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN34@ActivateOI

; 2818 :    {
; 2819 :       LPTASK           lpInstanceOwningTask;
; 2820 :       LPVIEWENTITY     lpViewEntity;
; 2821 :       LPENTITYINSTANCE lpSrcEntityInstance;
; 2822 :       LPENTITYINSTANCE lpTgtEntityInstance;
; 2823 :       LPENTITYINSTANCE lpLastTgtEntityInstance;
; 2824 :       LPENTITYINSTANCE lpTgtParent;
; 2825 :       LPENTITYINSTANCE lpWkInstance1;
; 2826 :       LPENTITYINSTANCE lpWkInstance2;
; 2827 :       LPVIEWOI         hTgtViewOI;
; 2828 :       zPVOID           hTgtEntityInstance;
; 2829 :       zSHORT           nLastLvl;
; 2830 : 
; 2831 :       // Here we copy the instance in memory.
; 2832 :       lpViewCsr   = zGETPTR( lpTgtView->hViewCsr );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2833 :       hTgtViewOI  = lpViewCsr->hViewOI;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR _hTgtViewOI$3[ebp], ecx

; 2834 :       lpTgtViewOI = zGETPTR( hTgtViewOI );

	mov	edx, DWORD PTR _hTgtViewOI$3[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 2835 :       lpInstanceOwningTask = zGETPTR( lpTgtViewOI->hAllocTask );

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstanceOwningTask$4[ebp], eax

; 2836 :       lpTgtEntityInstance = 0;

	mov	DWORD PTR _lpTgtEntityInstance$12[ebp], 0

; 2837 :       lpLastTgtEntityInstance = 0;

	mov	DWORD PTR _lpLastTgtEntityInstance$7[ebp], 0

; 2838 :       lpTgtParent = 0;

	mov	DWORD PTR _lpTgtParent$6[ebp], 0

; 2839 : 
; 2840 :       // Set the first source entity instance.  If zSINGLE was set, then the
; 2841 :       // first entity instance should be the selected root for the view.
; 2842 :       lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$10[ebp], 0

; 2843 : 
; 2844 :       if ( bMultiple == FALSE )

	movzx	edx, BYTE PTR _bMultiple$[ebp]
	test	edx, edx
	jne	SHORT $LN35@ActivateOI

; 2845 :       {
; 2846 :          LPVIEWENTITYCSR lpRootViewEntityCsr;
; 2847 : 
; 2848 :          lpViewCsr= zGETPTR( lpSrcView->hViewCsr );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2849 :          lpRootViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$2[ebp], eax

; 2850 :          lpSrcEntityInstance = zGETPTR( lpRootViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpRootViewEntityCsr$2[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$10[ebp], eax
$LN35@ActivateOI:

; 2851 :       }
; 2852 : 
; 2853 :       if ( lpSrcEntityInstance == 0 || lpSrcEntityInstance == UNSET_CSR )

	cmp	DWORD PTR _lpSrcEntityInstance$10[ebp], 0
	je	SHORT $LN37@ActivateOI
	cmp	DWORD PTR _lpSrcEntityInstance$10[ebp], 1
	jne	SHORT $LN4@ActivateOI
$LN37@ActivateOI:

; 2854 :          lpSrcEntityInstance = zGETPTR( lpSrcViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$10[ebp], eax
$LN4@ActivateOI:

; 2855 : 
; 2856 :       // For each instance in the source, copy the instance and
; 2857 :       // link the new instance to the source instance. This link will
; 2858 :       // be removed later on after the initial copy is complete.
; 2859 :       while ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$10[ebp], 0
	je	$LN5@ActivateOI

; 2860 :       {
; 2861 :          nLastLvl = lpSrcEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLastLvl$13[ebp], ax

; 2862 :          lpViewEntity = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 2863 : 
; 2864 :          hTgtEntityInstance =

	push	10024					; 00002728H
	push	0
	push	0
	push	68					; 00000044H
	mov	eax, DWORD PTR _lpInstanceOwningTask$4[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTgtEntityInstance$9[ebp], eax

; 2865 :                      fnAllocDataspace( lpInstanceOwningTask->hFirstDataHeader,
; 2866 :                                        sizeof( EntityInstanceRecord ), 0, 0,
; 2867 :                                        iEntityInstance );
; 2868 :          lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$9[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$12[ebp], eax

; 2869 :          if ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$12[ebp], 0
	je	$LN38@ActivateOI

; 2870 :          {
; 2871 :             zmemcpy( (zPVOID) lpTgtEntityInstance,

	push	68					; 00000044H
	mov	eax, DWORD PTR _lpSrcEntityInstance$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2872 :                      (zPVOID) lpSrcEntityInstance,
; 2873 :                      sizeof( EntityInstanceRecord ) );
; 2874 :             lpTgtEntityInstance->hViewOI   = hTgtViewOI;

	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	eax, DWORD PTR _hTgtViewOI$3[ebp]
	mov	DWORD PTR [edx+10], eax

; 2875 :             lpTgtEntityInstance->hPrevHier = zGETHNDL( lpLastTgtEntityInstance );

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$7[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [edx+18], eax

; 2876 :             lpTgtEntityInstance->hNextHier = 0;

	mov	eax, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [eax+14], 0

; 2877 :             lpTgtEntityInstance->hNextTwin = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [ecx+22], 0

; 2878 :             fnSetEntityKey( lpInstanceOwningTask, 0, lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpInstanceOwningTask$4[ebp]
	push	eax
	call	_fnSetEntityKey@12

; 2879 :             if ( lpLastTgtEntityInstance )

	cmp	DWORD PTR _lpLastTgtEntityInstance$7[ebp], 0
	je	$LN40@ActivateOI

; 2880 :             {
; 2881 :                lpLastTgtEntityInstance->hNextHier = hTgtEntityInstance;

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$7[ebp]
	mov	edx, DWORD PTR _hTgtEntityInstance$9[ebp]
	mov	DWORD PTR [ecx+14], edx

; 2882 :                if ( lpSrcEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpSrcEntityInstance$10[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN42@ActivateOI

; 2883 :                {
; 2884 :                   LPENTITYINSTANCE hWkInstance1;
; 2885 : 
; 2886 :                   hWkInstance1  = lpSrcEntityInstance->hPrevHier;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR _hWkInstance1$5[ebp], edx

; 2887 :                   lpWkInstance1 = zGETPTR( hWkInstance1 );

	mov	eax, DWORD PTR _hWkInstance1$5[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax

; 2888 :                   lpWkInstance2 = zGETPTR( lpTgtEntityInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8[ebp], eax
$LN6@ActivateOI:

; 2889 :                   while ( hWkInstance1 != lpSrcEntityInstance->hPrevTwin )

	mov	eax, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	ecx, DWORD PTR _hWkInstance1$5[ebp]
	cmp	ecx, DWORD PTR [eax+26]
	je	SHORT $LN7@ActivateOI

; 2890 :                   {
; 2891 :                      hWkInstance1  = lpWkInstance1->hPrevHier;

	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _hWkInstance1$5[ebp], eax

; 2892 :                      lpWkInstance1 = zGETPTR( hWkInstance1 );

	mov	ecx, DWORD PTR _hWkInstance1$5[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax

; 2893 :                      lpWkInstance2 = zGETPTR( lpWkInstance2->hPrevHier );

	mov	edx, DWORD PTR _lpWkInstance2$8[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8[ebp], eax

; 2894 :                   }

	jmp	SHORT $LN6@ActivateOI
$LN7@ActivateOI:

; 2895 : 
; 2896 :                   lpTgtEntityInstance->hPrevTwin = zGETHNDL( lpWkInstance2 );

	mov	ecx, DWORD PTR _lpWkInstance2$8[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [edx+26], eax

; 2897 :                   lpWkInstance2->hNextTwin = hTgtEntityInstance;

	mov	eax, DWORD PTR _lpWkInstance2$8[ebp]
	mov	ecx, DWORD PTR _hTgtEntityInstance$9[ebp]
	mov	DWORD PTR [eax+22], ecx
$LN42@ActivateOI:

; 2898 :                }
; 2899 :             }

	jmp	SHORT $LN41@ActivateOI
$LN40@ActivateOI:

; 2900 :             else
; 2901 :             {
; 2902 :                lpTgtViewOI->hRootEntityInstance = hTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR _hTgtEntityInstance$9[ebp]
	mov	DWORD PTR [edx+26], eax

; 2903 :                lpTgtEntityInstance->hPrevTwin = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [ecx+26], 0
$LN41@ActivateOI:

; 2904 :             }
; 2905 : 
; 2906 :             lpTgtEntityInstance->hParent = zGETHNDL( lpTgtParent );

	mov	edx, DWORD PTR _lpTgtParent$6[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2907 :          // if ( lpTgtEntityInstance->hParent == UNSET_CSR )
; 2908 :          //    SysMessageBox( 0, "ActivateOI_FromOI", "UNSET_CSR", -1 );
; 2909 : 
; 2910 :             if ( lpSrcEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN43@ActivateOI

; 2911 :                lpSrcEntityInstance->hNextLinked = hTgtEntityInstance;

	mov	eax, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	ecx, DWORD PTR _hTgtEntityInstance$9[ebp]
	mov	DWORD PTR [eax+42], ecx
$LN43@ActivateOI:

; 2912 : 
; 2913 :             fnAddEntityToDebugChange( lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	push	edx
	call	_fnAddEntityToDebugChange@4

; 2914 :          }

	jmp	SHORT $LN39@ActivateOI
$LN38@ActivateOI:

; 2915 :          else
; 2916 :          if ( lpLastTgtEntityInstance )

	cmp	DWORD PTR _lpLastTgtEntityInstance$7[ebp], 0
	je	SHORT $LN39@ActivateOI

; 2917 :          {
; 2918 :             lpLastTgtEntityInstance->hNextHier = 0;

	mov	eax, DWORD PTR _lpLastTgtEntityInstance$7[ebp]
	mov	DWORD PTR [eax+14], 0

; 2919 :             lpLastTgtEntityInstance->hNextTwin = 0;

	mov	ecx, DWORD PTR _lpLastTgtEntityInstance$7[ebp]
	mov	DWORD PTR [ecx+22], 0

; 2920 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 2921 :             break;

	jmp	$LN5@ActivateOI
$LN39@ActivateOI:

; 2922 :          }
; 2923 : 
; 2924 :          // Get the next entity instance in memory to copy.
; 2925 :          lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$10[ebp], eax

; 2926 :          if ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$10[ebp], 0
	je	SHORT $LN45@ActivateOI

; 2927 :          {
; 2928 :             if ( lpSrcEntityInstance->nLevel == 1 && bMultiple == FALSE )

	mov	edx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	eax, 1
	jne	SHORT $LN47@ActivateOI
	movzx	ecx, BYTE PTR _bMultiple$[ebp]
	test	ecx, ecx
	jne	SHORT $LN47@ActivateOI

; 2929 :             {
; 2930 :                nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx

; 2931 :                lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$10[ebp], 0

; 2932 :             }

	jmp	SHORT $LN48@ActivateOI
$LN47@ActivateOI:

; 2933 :             else
; 2934 :             if ( lpSrcEntityInstance->nLevel > nLastLvl )

	mov	eax, DWORD PTR _lpSrcEntityInstance$10[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nLastLvl$13[ebp]
	cmp	ecx, edx
	jle	SHORT $LN8@ActivateOI

; 2935 :                lpTgtParent = lpTgtEntityInstance;

	mov	eax, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR _lpTgtParent$6[ebp], eax
	jmp	SHORT $LN48@ActivateOI
$LN8@ActivateOI:

; 2936 :             else
; 2937 :             {
; 2938 :                while ( lpTgtParent &&

	cmp	DWORD PTR _lpTgtParent$6[ebp], 0
	je	SHORT $LN48@ActivateOI
	mov	ecx, DWORD PTR _lpTgtParent$6[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpSrcEntityInstance$10[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jl	SHORT $LN48@ActivateOI

; 2939 :                        lpTgtParent->nLevel >= lpSrcEntityInstance->nLevel )
; 2940 :                {
; 2941 :                   lpTgtParent = zGETPTR( lpTgtParent->hParent );

	mov	edx, DWORD PTR _lpTgtParent$6[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$6[ebp], eax

; 2942 :                }

	jmp	SHORT $LN8@ActivateOI
$LN48@ActivateOI:

; 2943 :             }
; 2944 :          }

	jmp	SHORT $LN46@ActivateOI
$LN45@ActivateOI:

; 2945 :          else
; 2946 :             nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN46@ActivateOI:

; 2947 : 
; 2948 :          lpLastTgtEntityInstance = lpTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR _lpLastTgtEntityInstance$7[ebp], edx

; 2949 :       }

	jmp	$LN4@ActivateOI
$LN5@ActivateOI:

; 2950 : 
; 2951 :       // We've copied the entity instance chain and linked all the
; 2952 :       // new instance information with the source being copied, now
; 2953 :       // isolate the copied instance by de-linking it from all
; 2954 :       // instances in other ViewOI's and copying the data-record
; 2955 :       // for each instance.
; 2956 :       hTgtEntityInstance  = lpTgtViewOI->hRootEntityInstance;

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR _hTgtEntityInstance$9[ebp], ecx

; 2957 :       lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$9[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$12[ebp], eax
$LN10@ActivateOI:

; 2958 :       while ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$12[ebp], 0
	je	$LN34@ActivateOI

; 2959 :       {
; 2960 :          // First, see if the attribute record information needs
; 2961 :          // to be copied, if so, copy it now.
; 2962 :          lpWkInstance1 = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax
$LN12@ActivateOI:

; 2963 :          while ( lpWkInstance1 && lpWkInstance1 != lpTgtEntityInstance )

	cmp	DWORD PTR _lpWkInstance1$11[ebp], 0
	je	SHORT $LN13@ActivateOI
	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	je	SHORT $LN13@ActivateOI

; 2964 :          {
; 2965 :             if ( lpWkInstance1->hViewOI != hTgtViewOI )

	mov	eax, DWORD PTR _lpWkInstance1$11[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hTgtViewOI$3[ebp]
	je	SHORT $LN51@ActivateOI

; 2966 :                break;

	jmp	SHORT $LN13@ActivateOI
$LN51@ActivateOI:

; 2967 : 
; 2968 :             lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax

; 2969 :          }

	jmp	SHORT $LN12@ActivateOI
$LN13@ActivateOI:

; 2970 : 
; 2971 :          // Copy the non-persistent record regardless
; 2972 :          lpTgtEntityInstance->hNonPersistRecord =

	push	0
	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpInstanceOwningTask$4[ebp]
	push	edx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [ecx+64], eax

; 2973 :              fnCopyAttributeRecord( lpInstanceOwningTask,
; 2974 :                 zGETPTR( lpTgtEntityInstance->hViewEntity ),
; 2975 :                 (zPCHAR) zGETPTR( lpTgtEntityInstance->hNonPersistRecord ), 0 );
; 2976 : 
; 2977 :          // Copy the persistent record unless the instance is linked
; 2978 :          // only to instances in the same ViewOI (which means that
; 2979 :          // the persistent record has already been copied).
; 2980 :          if ( lpWkInstance1 != lpTgtEntityInstance )

	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	je	$LN52@ActivateOI

; 2981 :          {
; 2982 :             lpTgtEntityInstance->hPersistRecord =

	push	1
	mov	eax, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpInstanceOwningTask$4[ebp]
	push	ecx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [edx+60], eax

; 2983 :                      fnCopyAttributeRecord( lpInstanceOwningTask,
; 2984 :                          zGETPTR( lpTgtEntityInstance->hViewEntity ),
; 2985 :                          (zPCHAR) zGETPTR( lpTgtEntityInstance->hPersistRecord ), 1 );
; 2986 : 
; 2987 :             if ( lpWkInstance1 )

	cmp	DWORD PTR _lpWkInstance1$11[ebp], 0
	je	$LN52@ActivateOI

; 2988 :             {
; 2989 :                // The instance is linked to another instance in a different
; 2990 :                // ViewOI, create two chains out of the single chain to isolate
; 2991 :                // this object instance from the other one being copied.
; 2992 :                lpSrcEntityInstance = lpWkInstance1;

	mov	eax, DWORD PTR _lpWkInstance1$11[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$10[ebp], eax

; 2993 :                lpWkInstance1 = zGETPTR( lpTgtEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax
$LN14@ActivateOI:

; 2994 :                while ( lpWkInstance1->hNextLinked != hTgtEntityInstance )

	mov	eax, DWORD PTR _lpWkInstance1$11[ebp]
	mov	ecx, DWORD PTR [eax+42]
	cmp	ecx, DWORD PTR _hTgtEntityInstance$9[ebp]
	je	SHORT $LN15@ActivateOI

; 2995 :                   lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax
	jmp	SHORT $LN14@ActivateOI
$LN15@ActivateOI:

; 2996 : 
; 2997 :                lpWkInstance1->hNextLinked = lpTgtEntityInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax

; 2998 :                lpTgtEntityInstance->hNextLinked = 0;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [ecx+42], 0
$LN18@ActivateOI:

; 2999 :                for ( ; ; )
; 3000 :                {
; 3001 :                   lpWkInstance1 = zGETPTR( lpSrcEntityInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax
$LN19@ActivateOI:

; 3002 :                   while ( lpWkInstance1 != lpSrcEntityInstance &&

	mov	ecx, DWORD PTR _lpWkInstance1$11[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	je	SHORT $LN20@ActivateOI
	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	eax, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	ecx, DWORD PTR [edx+10]
	cmp	ecx, DWORD PTR [eax+10]
	je	SHORT $LN20@ActivateOI

; 3003 :                           lpWkInstance1->hViewOI != lpTgtEntityInstance->hViewOI )
; 3004 :                   {
; 3005 :                      lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$11[ebp], eax

; 3006 :                   }

	jmp	SHORT $LN19@ActivateOI
$LN20@ActivateOI:

; 3007 : 
; 3008 :                   if ( lpWkInstance1 == lpSrcEntityInstance )

	mov	ecx, DWORD PTR _lpWkInstance1$11[ebp]
	cmp	ecx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	jne	SHORT $LN54@ActivateOI

; 3009 :                      break;

	jmp	SHORT $LN52@ActivateOI
$LN54@ActivateOI:

; 3010 : 
; 3011 :                   // We've found another instance in the source chain which
; 3012 :                   // needs to be moved to the target chain, add the instance
; 3013 :                   // to the target chain and update its record pointer to
; 3014 :                   // be the same as the target instance.
; 3015 :                   lpWkInstance2 = lpSrcEntityInstance;

	mov	edx, DWORD PTR _lpSrcEntityInstance$10[ebp]
	mov	DWORD PTR _lpWkInstance2$8[ebp], edx
$LN21@ActivateOI:

; 3016 :                   while ( lpWkInstance2->hNextLinked != zGETHNDL( lpWkInstance1 ) )

	mov	eax, DWORD PTR _lpWkInstance1$11[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWkInstance2$8[ebp]
	cmp	DWORD PTR [ecx+42], eax
	je	SHORT $LN22@ActivateOI

; 3017 :                      lpWkInstance2 = zGETPTR( lpWkInstance2->hNextLinked );

	mov	edx, DWORD PTR _lpWkInstance2$8[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$8[ebp], eax
	jmp	SHORT $LN21@ActivateOI
$LN22@ActivateOI:

; 3018 : 
; 3019 :                   lpWkInstance2->hNextLinked = lpWkInstance1->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance2$8[ebp]
	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax

; 3020 :                   lpWkInstance1->hPersistRecord = lpTgtEntityInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 3021 :                   if ( lpTgtEntityInstance->hNextLinked == 0 )

	mov	ecx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	cmp	DWORD PTR [ecx+42], 0
	jne	SHORT $LN55@ActivateOI

; 3022 :                      lpWkInstance1->hNextLinked = hTgtEntityInstance;

	mov	edx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	eax, DWORD PTR _hTgtEntityInstance$9[ebp]
	mov	DWORD PTR [edx+42], eax
	jmp	SHORT $LN56@ActivateOI
$LN55@ActivateOI:

; 3023 :                   else
; 3024 :                      lpWkInstance1->hNextLinked = lpTgtEntityInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpWkInstance1$11[ebp]
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax
$LN56@ActivateOI:

; 3025 : 
; 3026 :                   lpTgtEntityInstance->hNextLinked = zGETHNDL( lpWkInstance1 );

	mov	ecx, DWORD PTR _lpWkInstance1$11[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	DWORD PTR [edx+42], eax

; 3027 :                }

	jmp	$LN18@ActivateOI
$LN52@ActivateOI:

; 3028 :             }
; 3029 :          }
; 3030 : 
; 3031 :          hTgtEntityInstance  = lpTgtEntityInstance->hNextHier;

	mov	eax, DWORD PTR _lpTgtEntityInstance$12[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hTgtEntityInstance$9[ebp], ecx

; 3032 :          lpTgtEntityInstance = zGETPTR( hTgtEntityInstance );

	mov	edx, DWORD PTR _hTgtEntityInstance$9[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$12[ebp], eax

; 3033 :       }

	jmp	$LN10@ActivateOI
$LN34@ActivateOI:

; 3034 :    }
; 3035 : 
; 3036 :    if ( nRC >= 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jl	SHORT $LN57@ActivateOI

; 3037 :       fnResetView( lpTgtView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
$LN57@ActivateOI:

; 3038 : 
; 3039 :    // Based on the return code, see if we have to reset the view to the
; 3040 :    // prior instance or clean up the prior instance.
; 3041 :    // Note: rc = indicates multiple level1 roots are present.
; 3042 :    if ( nRC >= -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $LN58@ActivateOI

; 3043 :    {
; 3044 :       if ( lControl & zREADONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2048				; 00000800H
	je	SHORT $LN60@ActivateOI

; 3045 :          lpTgtView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	DWORD PTR [eax+30], edx
$LN60@ActivateOI:

; 3046 : 
; 3047 :       lpTgtViewOI->bUpdated     = lpSrcViewOI->bUpdated;

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 4
	and	edx, 1
	and	edx, 1
	shl	edx, 4
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, -17				; ffffffefH
	or	ecx, edx
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 3048 :       lpTgtViewOI->bUpdatedFile = lpSrcViewOI->bUpdatedFile;

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 5
	and	ecx, 1
	and	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -33				; ffffffdfH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 3049 : 
; 3050 :       *pvReturnView = lpTgtView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	DWORD PTR [edx], eax

; 3051 :    // TraceLine( "CreateViewFromView: 0x%08x", *pvReturnView );
; 3052 :    }

	jmp	SHORT $LN59@ActivateOI
$LN58@ActivateOI:

; 3053 :    else
; 3054 :    {
; 3055 :       fnDropView( lpTgtView );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnDropView@4

; 3056 :       *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0
$LN59@ActivateOI:

; 3057 :    }
; 3058 : 
; 3059 :    fnOperationReturn( iActivateOI_FromOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	55					; 00000037H
	call	_fnOperationReturn
	add	esp, 8

; 3060 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ActivateOI:

; 3061 : 
; 3062 : } // ActivateOI_FromOI_ForTask

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ActivateOI_FromOI_ForTask@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_pvReturnView$ = 8					; size = 4
_lpSrcView$ = 12					; size = 4
_lControl$ = 16						; size = 4
_ActivateOI_FromOI@12 PROC

; 2705 : {

	push	ebp
	mov	ebp, esp

; 2706 :    return( ActivateOI_FromOI_ForTask( pvReturnView, lpSrcView, 0, lControl ) );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	push	edx
	call	_ActivateOI_FromOI_ForTask@16

; 2707 : }

	pop	ebp
	ret	12					; 0000000cH
_ActivateOI_FromOI@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_ActFileData$ = -2124					; size = 12
_lpSystemApp$1 = -2112					; size = 4
_lpViewOD$ = -2108					; size = 4
$T2 = -2104						; size = 4
_lpApp$ = -2100						; size = 4
tv66 = -2096						; size = 4
_hFile$ = -2092						; size = 4
_vTask$ = -2088						; size = 4
_nRC$ = -2084						; size = 2
_lpTask$ = -2080					; size = 4
_lpViewCsr$3 = -2076					; size = 4
_l$ = -2072						; size = 4
_bSystemObj$ = -2065					; size = 1
_lpCurrentTask$ = -2064					; size = 4
_szOpenFileName$ = -2060				; size = 1025
_szWork$ = -1032					; size = 1025
__$ArrayPad$ = -4					; size = 4
_pvReturnView$ = 8					; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_lpAppQualView$ = 16					; size = 4
_cpcFileName$ = 20					; size = 4
_lControl$ = 24						; size = 4
_ActivateOI_FromFile@20 PROC

; 2469 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2124				; 0000084cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2470 :    LPTASK          lpCurrentTask;
; 2471 :    LPTASK          lpTask;
; 2472 :    LPVIEWOD        lpViewOD;
; 2473 :    LPAPP           lpApp;
; 2474 :    FileDataRecord  ActFileData;
; 2475 :    zVIEW           vTask;
; 2476 :    zLONG           l;
; 2477 :    zLONG           hFile;
; 2478 :    zCHAR           szOpenFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 2479 :    zCHAR           szWork[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 2480 :    zBOOL           bSystemObj;
; 2481 :    zSHORT          nRC;
; 2482 : 
; 2483 :    // Init in case of error.
; 2484 :    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2485 :    bSystemObj = (lControl & zACTIVATE_SYSTEM) ? TRUE : FALSE;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 536870912				; 20000000H
	je	SHORT $LN30@ActivateOI
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN31@ActivateOI
$LN30@ActivateOI:
	mov	DWORD PTR tv66[ebp], 0
$LN31@ActivateOI:
	mov	dl, BYTE PTR tv66[ebp]
	mov	BYTE PTR _bSystemObj$[ebp], dl

; 2486 : 
; 2487 :    // If task not active or disabled, return zCALL_ERROR.
; 2488 :    if ( (lpCurrentTask = fnOperationCall( iActivateOI_FromFile,
; 2489 :                                           lpAppQualView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@ActivateOI

; 2490 :    {
; 2491 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN29@ActivateOI
$LN4@ActivateOI:

; 2492 :    }
; 2493 : 
; 2494 :    // Unless we're activating a system object, ensure that the app qual
; 2495 :    // view is valid.
; 2496 :    if ( (lpAppQualView || !(lControl & zACTIVATE_SYSTEM)) &&

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $LN6@ActivateOI
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 536870912				; 20000000H
	jne	SHORT $LN5@ActivateOI
$LN6@ActivateOI:
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN5@ActivateOI

; 2497 :         fnValidView( lpCurrentTask, lpAppQualView ) == 0 )
; 2498 :    {
; 2499 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2500 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN29@ActivateOI
$LN5@ActivateOI:

; 2501 :    }
; 2502 : 
; 2503 :    // Verify only one zLEVEL_ option requested.
; 2504 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], eax

; 2505 :    if ( l && (-l & l) != l )

	je	SHORT $LN7@ActivateOI
	mov	ecx, DWORD PTR _l$[ebp]
	neg	ecx
	and	ecx, DWORD PTR _l$[ebp]
	cmp	ecx, DWORD PTR _l$[ebp]
	je	SHORT $LN7@ActivateOI

; 2506 :    {
; 2507 :       // error, More than one zLEVEL_ option requested
; 2508 :       // "KZOEE023 - Invalid parameter, "
; 2509 :       fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 23, 0,

	push	0
	push	OFFSET $SG14217
	push	0
	push	23					; 00000017H
	push	8
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2510 :                         "More than one zLEVEL_ option requested", 0 );
; 2511 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2512 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN29@ActivateOI
$LN7@ActivateOI:

; 2513 :    }
; 2514 : 
; 2515 :    // If zLEVEL_SAME is requested.
; 2516 :    if ( lControl & zLEVEL_SAME )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1024				; 00000400H
	je	$LN8@ActivateOI

; 2517 :    {
; 2518 :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $LN11@ActivateOI
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN9@ActivateOI
$LN11@ActivateOI:

; 2519 :       {
; 2520 :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 2521 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 100, 0,

	push	OFFSET $SG14222
	push	OFFSET $SG14223
	push	0
	push	100					; 00000064H
	push	8
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2522 :                            "lpAppQualView", "with zLEVEL_SAME" );
; 2523 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2524 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN29@ActivateOI

; 2525 :       }

	jmp	$LN8@ActivateOI
$LN9@ActivateOI:

; 2526 :       else
; 2527 :       {
; 2528 :          LPVIEWCSR lpViewCsr;
; 2529 : 
; 2530 :          // Turn off the 'same' indicator
; 2531 :          lControl ^= zLEVEL_SAME;

	mov	ecx, DWORD PTR _lControl$[ebp]
	xor	ecx, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], ecx

; 2532 :          // To determine what the level is of the qualifying view
; 2533 :          //   1. Change lpAppQualView to point to the initial
; 2534 :          //      view created for the object instance
; 2535 :          //   2. Check for application level, if there use
; 2536 :          //      zLEVEL_APPLICATION.
; 2537 :          //   3. Check if the view task is the main task, if so use
; 2538 :          //      zLEVEL_SYSTEM.
; 2539 :          //   4. Use the task level...
; 2540 :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$3[ebp], eax
$LN2@ActivateOI:

; 2541 :          while ( lpViewCsr->hNextViewCsr )

	mov	ecx, DWORD PTR _lpViewCsr$3[ebp]
	cmp	DWORD PTR [ecx+2], 0
	je	SHORT $LN3@ActivateOI

; 2542 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpViewCsr$3[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$3[ebp], eax
	jmp	SHORT $LN2@ActivateOI
$LN3@ActivateOI:

; 2543 : 
; 2544 :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$3[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 2545 :          if ( lpAppQualView->bApplicationView )

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN12@ActivateOI

; 2546 :             lControl |= zLEVEL_APPLICATION;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 4
	mov	DWORD PTR _lControl$[ebp], edx
	jmp	SHORT $LN8@ActivateOI
$LN12@ActivateOI:

; 2547 :          else
; 2548 :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN8@ActivateOI

; 2549 :             lControl |= zLEVEL_SYSTEM;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 8
	mov	DWORD PTR _lControl$[ebp], eax
$LN8@ActivateOI:

; 2550 :       }
; 2551 :    }
; 2552 : 
; 2553 :    // Make sure request is for valid OD.
; 2554 :    lpViewOD = ActivateViewObject( lpAppQualView, cpcViewOD_Name, bSystemObj );

	movzx	ecx, BYTE PTR _bSystemObj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2555 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN15@ActivateOI

; 2556 :    {
; 2557 :       fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2558 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN29@ActivateOI
$LN15@ActivateOI:

; 2559 :    }
; 2560 : 
; 2561 :    // First off, see if we can open the filename requested,
; 2562 :    // go through characters in name and see if they need either
; 2563 :    // a directory qualification prefix or an object file suffix.
; 2564 : 
; 2565 : // Change DGC 5/27/96 -- In an attempt to make all code retrieve the
; 2566 : // application in the same way from a view, I have changed the following code.
; 2567 :    fnGetApplicationForSubtask( &lpApp, lpAppQualView );

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8

; 2568 : 
; 2569 : // DGC 9/23/96
; 2570 : // I changed the logic: if the file name is not qualfied, use the object dir
; 2571 : // for the application. I repeated this change in CommitOI_ToFile.
; 2572 :    if ( zstrchr( cpcFileName, cDirSep ) == 0 )

	movsx	ecx, BYTE PTR _cDirSep
	push	ecx
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@ActivateOI

; 2573 :    {
; 2574 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN18@ActivateOI

; 2575 :          zstrcpy( szWork, lpApp->szObjectDir );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szWork$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN19@ActivateOI
$LN18@ActivateOI:

; 2576 :       else
; 2577 :       {
; 2578 :          LPAPP lpSystemApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+110]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemApp$1[ebp], eax

; 2579 : 
; 2580 :          zstrcpy( szWork, lpSystemApp->szObjectDir );

	mov	ecx, DWORD PTR _lpSystemApp$1[ebp]
	add	ecx, 347				; 0000015bH
	push	ecx
	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN19@ActivateOI:

; 2581 :       }
; 2582 : 
; 2583 :       SysAppendcDirSep( szWork );

	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2584 :    }

	jmp	SHORT $LN17@ActivateOI
$LN16@ActivateOI:

; 2585 :    else
; 2586 :       szWork[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 1025		; 00000401H
	jae	SHORT $LN32@ActivateOI
	jmp	SHORT $LN33@ActivateOI
$LN32@ActivateOI:
	call	___report_rangecheckfailure
$LN33@ActivateOI:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szWork$[ebp+eax], 0
$LN17@ActivateOI:

; 2587 : 
; 2588 :    zstrcat( szWork, cpcFileName ); // w\bin\sys\tzrpsrco.lod

	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWork$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2589 :    SysConvertEnvironmentString( szOpenFileName, szWork );

	lea	eax, DWORD PTR _szWork$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	call	_SysConvertEnvironmentString@8

; 2590 : 
; 2591 :    if ( AnchorBlock->TraceFlags.bOpenFile )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 2
	and	eax, 1
	je	SHORT $LN20@ActivateOI

; 2592 :    {
; 2593 :       if ( zstrstr( cpcFileName, "TZCMULWO.POR" ) == 0 )

	push	OFFSET $SG14234
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN20@ActivateOI

; 2594 :          TraceLineS( "(oi) opening ", szOpenFileName );

	lea	edx, DWORD PTR _szOpenFileName$[ebp]
	push	edx
	push	OFFSET $SG14235
	call	_TraceLineS@8
$LN20@ActivateOI:

; 2595 :    }
; 2596 : 
; 2597 :    // Open the file for the object instance data.
; 2598 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 12					; 0000000cH
	je	SHORT $LN22@ActivateOI

; 2599 :    {
; 2600 :       lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 2601 :    // hFile = fnSysOpenFile( lpTask, szOpenFileName, COREFILE_READ );
; 2602 :    }

	jmp	SHORT $LN23@ActivateOI
$LN22@ActivateOI:

; 2603 :    else
; 2604 :    {
; 2605 :       lpTask = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpTask$[ebp], eax
$LN23@ActivateOI:

; 2606 :    // hFile = SysOpenFile( lpAppQualView, szOpenFileName, COREFILE_READ );
; 2607 :    }
; 2608 : 
; 2609 :    if ( lpAppQualView && zGETPTR( lpAppQualView->hTask ) == lpTask ) // added dks 2006.09.15 to prevent looking

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $LN24@ActivateOI
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpTask$[ebp]
	jne	SHORT $LN24@ActivateOI

; 2610 :       vTask = lpAppQualView;                                         // at incorrect app when we just pick vTask

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	DWORD PTR _vTask$[ebp], eax
	jmp	SHORT $LN25@ActivateOI
$LN24@ActivateOI:

; 2611 :    else                                                              // willy-nilly (as is done on the next line)
; 2612 :       vTask = zGETPTR( lpTask->hFirstView );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$[ebp], eax
$LN25@ActivateOI:

; 2613 : 
; 2614 :    hFile = SysOpenFile( vTask, szOpenFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTask$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 2615 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN26@ActivateOI

; 2616 :    {
; 2617 :       if ( lControl & zNOI_OKAY )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 512				; 00000200H
	je	SHORT $LN27@ActivateOI

; 2618 :       {
; 2619 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2620 :          return( -1 );

	or	eax, -1
	jmp	$LN29@ActivateOI

; 2621 :       }

	jmp	SHORT $LN26@ActivateOI
$LN27@ActivateOI:

; 2622 :       else
; 2623 :       {
; 2624 :          //  "KZOEE071 - Error opening instance file "
; 2625 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 16, 71, 0,

	push	0
	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2626 :                            szOpenFileName, 0 );
; 2627 :          fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2628 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN29@ActivateOI
$LN26@ActivateOI:

; 2629 :       }
; 2630 :    }
; 2631 : 
; 2632 :    ActFileData.pchFileName = szOpenFileName;

	lea	edx, DWORD PTR _szOpenFileName$[ebp]
	mov	DWORD PTR _ActFileData$[ebp], edx

; 2633 :    ActFileData.hFile = hFile;

	mov	eax, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR _ActFileData$[ebp+4], eax

; 2634 :    ActFileData.lLine = 1;

	mov	DWORD PTR _ActFileData$[ebp+8], 1

; 2635 : 
; 2636 :    nRC = SfActivateOI_FromStream( pvReturnView, cpcViewOD_Name,

	lea	ecx, DWORD PTR _ActFileData$[ebp]
	push	ecx
	push	OFFSET _fnReadDataFromFileStream@20
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	push	edx
	call	_SfActivateOI_FromStream@24
	mov	WORD PTR _nRC$[ebp], ax

; 2637 :                                // lpAppQualView, lControl,
; 2638 :                                   vTask, lControl,
; 2639 :                                   fnReadDataFromFileStream,
; 2640 :                                   (zPVOID) &ActFileData );
; 2641 : 
; 2642 : // TraceLine( "ActivateOI_FromFile: 0x%08x", *pvReturnView );
; 2643 : 
; 2644 :    // Close the file
; 2645 :    fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 2646 : 
; 2647 :    fnOperationReturn( iActivateOI_FromFile, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	54					; 00000036H
	call	_fnOperationReturn
	add	esp, 8

; 2648 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN29@ActivateOI:

; 2649 : 
; 2650 : } // ActivateOI_FromFile

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ActivateOI_FromFile@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpOrigViewEntityCsr$ = -844				; size = 4
_lTickCount$ = -840					; size = 4
_lpOrigViewCsr$1 = -836					; size = 4
_lpNewEI$2 = -832					; size = 4
_lpPtr$3 = -828						; size = 4
_uLth$4 = -824						; size = 4
_lNetControl$5 = -820					; size = 4
tv1294 = -816						; size = 4
tv807 = -812						; size = 4
_lpViewEntityCsr$6 = -808				; size = 4
_lpOrigViewOI$7 = -804					; size = 4
_lpOwningTask$ = -800					; size = 4
_l$ = -796						; size = 4
_lpOrigInstance$ = -792					; size = 4
_k$8 = -788						; size = 2
_vTempQual$ = -784					; size = 4
_lpViewAttrib$9 = -780					; size = 4
_lpEntityInstance$10 = -776				; size = 4
_vOriginalOI$11 = -772					; size = 4
_nState$12 = -768					; size = 2
_vOrigView$ = -764					; size = 4
_lpViewCsr$ = -760					; size = 4
_vQualOI$13 = -756					; size = 4
_lpViewAttrib$14 = -752					; size = 4
_bDropQual$ = -747					; size = 1
_bLockingSemaphoreCreatedHere$ = -746			; size = 1
_bNewRoot$15 = -745					; size = 1
_lpViewEntity$ = -744					; size = 4
_lpViewOI$ = -740					; size = 4
_nActivateCount$16 = -736				; size = 2
_k$17 = -732						; size = 2
_chMaxAttrNbr$18 = -725					; size = 1
_lpViewOD$ = -724					; size = 4
_lpCurrentTask$ = -720					; size = 4
_chFirstAttrNbr$19 = -713				; size = 1
_lpView$ = -712						; size = 4
_nRC$ = -708						; size = 2
_chCurrentAttrNbr$20 = -701				; size = 1
_lpSeqViewAttrib$21 = -700				; size = 84
_sz$22 = -616						; size = 256
_szMsg$23 = -360					; size = 256
_sz$24 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_pvReturnView$ = 8					; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_lpAppQualView$ = 16					; size = 4
_lpQualView$ = 20					; size = 4
_lControl$ = 24						; size = 4
_ActivateObjectInstance@20 PROC

; 1619 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 844				; 0000034cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1620 :    LPTASK            lpCurrentTask;
; 1621 :    LPTASK            lpOwningTask;
; 1622 :    LPVIEWOD          lpViewOD;
; 1623 :    LPVIEWOI          lpViewOI = 0;

	mov	DWORD PTR _lpViewOI$[ebp], 0

; 1624 :    LPVIEWENTITY      lpViewEntity;
; 1625 :    LPVIEWCSR         lpViewCsr;
; 1626 :    LPENTITYINSTANCE  lpOrigInstance;
; 1627 :    LPVIEWENTITYCSR   lpOrigViewEntityCsr;
; 1628 :    zVIEW             lpView = 0;

	mov	DWORD PTR _lpView$[ebp], 0

; 1629 :    zVIEW             vTempQual = 0;

	mov	DWORD PTR _vTempQual$[ebp], 0

; 1630 :    zVIEW             vOrigView = *pvReturnView;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _vOrigView$[ebp], ecx

; 1631 :    zLONG             lTickCount;
; 1632 :    zLONG             l;
; 1633 :    zBOOL             bDropQual = FALSE;   // used when continuing an activate

	mov	BYTE PTR _bDropQual$[ebp], 0

; 1634 :    zBOOL             bLockingSemaphoreCreatedHere = FALSE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 0

; 1635 :    zSHORT            nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 1636 : 
; 1637 :    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 1638 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	and	edx, 1
	je	SHORT $LN27@ActivateOb

; 1639 :       lTickCount = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTickCount$[ebp], eax
$LN27@ActivateOb:

; 1640 : 
; 1641 :    // If task not active or disabled, return zCALL_ERROR.
; 1642 :    if ( lpAppQualView )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $LN28@ActivateOb

; 1643 :       lpView = lpAppQualView;

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	DWORD PTR _lpView$[ebp], eax
$LN28@ActivateOb:

; 1644 : 
; 1645 :    if ( (lpCurrentTask = fnOperationCall( iActivateObjectInstance,
; 1646 :                                           lpView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	52					; 00000034H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN29@ActivateOb

; 1647 :    {
; 1648 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOb
$LN29@ActivateOb:

; 1649 :    }
; 1650 : 
; 1651 :    lpCurrentTask->bLoadAllocLimit = FALSE;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -16385				; ffffbfffH
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 1652 :    if ( lpQualView && fnValidViewObject( lpCurrentTask, lpQualView ) == 0 )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $LN30@ActivateOb
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidViewObject
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN30@ActivateOb

; 1653 :       goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN30@ActivateOb:

; 1654 : 
; 1655 :    if ( fnValidView( lpCurrentTask, lpAppQualView ) == 0 )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN31@ActivateOb

; 1656 :       goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN31@ActivateOb:

; 1657 : 
; 1658 :    lpViewOD = ActivateViewObject( lpAppQualView, cpcViewOD_Name, FALSE );

	push	0
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1659 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN32@ActivateOb

; 1660 :       goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN32@ActivateOb:

; 1661 : 
; 1662 :    // Verify only one zLEVEL_ option requested.
; 1663 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], ecx

; 1664 :    if ( l && (-l & l) != l )

	je	SHORT $LN33@ActivateOb
	mov	edx, DWORD PTR _l$[ebp]
	neg	edx
	and	edx, DWORD PTR _l$[ebp]
	cmp	edx, DWORD PTR _l$[ebp]
	je	SHORT $LN33@ActivateOb

; 1665 :    {
; 1666 :       // error, More than one zLEVEL_ option requested
; 1667 :       // "KZOEE023 - Invalid parameter, "
; 1668 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 23, 0,

	push	0
	push	OFFSET $SG14015
	push	0
	push	23					; 00000017H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1669 :                         "More than one zLEVEL_ option requested", 0 );
; 1670 :       goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN33@ActivateOb:

; 1671 :    }
; 1672 : 
; 1673 :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 12					; 0000000cH
	je	SHORT $LN34@ActivateOb

; 1674 :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax
	jmp	SHORT $LN35@ActivateOb
$LN34@ActivateOb:

; 1675 :    else
; 1676 :       lpOwningTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], edx
$LN35@ActivateOb:

; 1677 : 
; 1678 :    // If zLEVEL_SAME is requested.
; 1679 :    if ( lControl & zLEVEL_SAME )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1024				; 00000400H
	je	$LN42@ActivateOb

; 1680 :    {
; 1681 :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $LN39@ActivateOb
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN37@ActivateOb
$LN39@ActivateOb:

; 1682 :       {
; 1683 :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 1684 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 100, 0, "lpAppQualView",

	push	OFFSET $SG14022
	push	OFFSET $SG14023
	push	0
	push	100					; 00000064H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1685 :                            "with zLEVEL_SAME" );
; 1686 :          goto EndOfFunction;

	jmp	$EndOfFunction$127

; 1687 :       }

	jmp	$LN42@ActivateOb
$LN37@ActivateOb:

; 1688 :       else
; 1689 :       {
; 1690 :          // LPVIEWCSR lpViewCsr;
; 1691 : 
; 1692 :          // Turn off the 'same' indicator
; 1693 :          lControl ^= zLEVEL_SAME;

	mov	ecx, DWORD PTR _lControl$[ebp]
	xor	ecx, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], ecx

; 1694 :          // To determine what the level is of the qualifying view
; 1695 :          //   1. Change lpAppQualView to point to the initial
; 1696 :          //      view created for the object instance
; 1697 :          //   2. Check for application level, if there use
; 1698 :          //      zLEVEL_APPLICATION.
; 1699 :          //   3. Check if the view task is the main task, if so use
; 1700 :          //      zLEVEL_SYSTEM.
; 1701 :          //   4. Use the task level...
; 1702 :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$LN2@ActivateOb:

; 1703 :          while ( lpViewCsr->hNextViewCsr )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+2], 0
	je	SHORT $LN3@ActivateOb

; 1704 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
	jmp	SHORT $LN2@ActivateOb
$LN3@ActivateOb:

; 1705 : 
; 1706 :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 1707 :          if ( lpAppQualView->bApplicationView )

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN40@ActivateOb

; 1708 :             lControl |= zLEVEL_APPLICATION;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 4
	mov	DWORD PTR _lControl$[ebp], edx
	jmp	SHORT $LN42@ActivateOb
$LN40@ActivateOb:

; 1709 :          else
; 1710 :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN42@ActivateOb

; 1711 :             lControl |= zLEVEL_SYSTEM;

	mov	eax, DWORD PTR _lControl$[ebp]
	or	eax, 8
	mov	DWORD PTR _lControl$[ebp], eax
$LN42@ActivateOb:

; 1712 :       }
; 1713 :    }
; 1714 : 
; 1715 :    // Check to see if we are continuing a previous activate.  If we are, then
; 1716 :    // we need to activate the next group of entities from the database.  To
; 1717 :    // do this we need to add to the current qualification view information to
; 1718 :    // load only entities that come after the last entity in the current OI.
; 1719 :    // The new qualification will then logically look like:
; 1720 :    //       ACTIVATE view
; 1721 :    //       WHERE (original-qual) AND
; 1722 :    //             (view.ent.seq-attr1 > lastent.ent.seq-attr1 OR
; 1723 :    //              (view.ent.seq-attr1 = lastent.ent.seq-attr1 AND
; 1724 :    //               view.ent.seq-attr2 > lastent.ent.seq-attr2))
; 1725 :    if ( lControl & zACTIVATE_CONTINUE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 134217728				; 08000000H
	je	$LN14@ActivateOb

; 1726 :    {
; 1727 :       LPVIEWATTRIB     lpViewAttrib;
; 1728 :       LPVIEWATTRIB     lpSeqViewAttrib[ MAX_SEQ_ATTS + 1 ];
; 1729 :       LPVIEWCSR        lpOrigViewCsr;
; 1730 :       LPVIEWOI         lpOrigViewOI;
; 1731 :       zCHAR            chCurrentAttrNbr;
; 1732 :       zCHAR            chMaxAttrNbr;
; 1733 :       zCHAR            chFirstAttrNbr;
; 1734 : 
; 1735 :       // Since we are continuing a previous activate, they had better pass
; 1736 :       // us the old view.
; 1737 :       if ( fnValidView( lpCurrentTask, vOrigView ) == 0 )

	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN44@ActivateOb

; 1738 :          goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN44@ActivateOb:

; 1739 : 
; 1740 :       *pvReturnView = vOrigView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR [edx], eax

; 1741 :       lpOrigViewCsr = zGETPTR( vOrigView->hViewCsr );

	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigViewCsr$1[ebp], eax

; 1742 :       lpOrigViewOI  = zGETPTR( lpOrigViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpOrigViewCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigViewOI$7[ebp], eax

; 1743 :       if ( lpOrigViewOI == 0 || lpOrigViewOI->hRootEntityInstance == 0  )

	cmp	DWORD PTR _lpOrigViewOI$7[ebp], 0
	je	SHORT $LN46@ActivateOb
	mov	edx, DWORD PTR _lpOrigViewOI$7[ebp]
	cmp	DWORD PTR [edx+26], 0
	jne	SHORT $LN45@ActivateOb
$LN46@ActivateOb:

; 1744 :       {
; 1745 :          fnSysMessageBox( lpCurrentTask, szlOE_SystemError,

	push	1
	push	OFFSET $SG14031
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 1746 :                           "Expecting valid OI for zACTIVATE_CONTINUE", 1 );
; 1747 :          goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN45@ActivateOb:

; 1748 :       }
; 1749 : 
; 1750 :       // Get the root view entity.
; 1751 :       lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+224]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1752 : 
; 1753 :       // Null out table for now.
; 1754 :       for ( chCurrentAttrNbr = 0;

	mov	BYTE PTR _chCurrentAttrNbr$20[ebp], 0
	jmp	SHORT $LN6@ActivateOb
$LN4@ActivateOb:

; 1756 :             chCurrentAttrNbr++ )

	mov	cl, BYTE PTR _chCurrentAttrNbr$20[ebp]
	add	cl, 1
	mov	BYTE PTR _chCurrentAttrNbr$20[ebp], cl
$LN6@ActivateOb:

; 1755 :             chCurrentAttrNbr <= MAX_SEQ_ATTS;

	movsx	edx, BYTE PTR _chCurrentAttrNbr$20[ebp]
	cmp	edx, 20					; 00000014H
	jg	SHORT $LN5@ActivateOb

; 1757 :       {
; 1758 :          lpSeqViewAttrib[ chCurrentAttrNbr ] = 0;

	movsx	eax, BYTE PTR _chCurrentAttrNbr$20[ebp]
	mov	DWORD PTR _lpSeqViewAttrib$21[ebp+eax*4], 0

; 1759 :       }

	jmp	SHORT $LN4@ActivateOb
$LN5@ActivateOb:

; 1760 : 
; 1761 :       // First find the max cSequencing numbers for persistent attributes.
; 1762 :       chMaxAttrNbr = 0;

	mov	BYTE PTR _chMaxAttrNbr$18[ebp], 0

; 1763 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$14[ebp], eax
	jmp	SHORT $LN9@ActivateOb
$LN7@ActivateOb:

; 1765 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$14[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$14[ebp], eax
$LN9@ActivateOb:

; 1764 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$14[ebp], 0
	je	SHORT $LN8@ActivateOb

; 1766 :       {
; 1767 :          if ( lpViewAttrib->cSequencing == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$14[ebp]
	movzx	eax, BYTE PTR [edx+197]
	test	eax, eax
	jne	SHORT $LN47@ActivateOb

; 1768 :             continue;

	jmp	SHORT $LN7@ActivateOb
$LN47@ActivateOb:

; 1769 : 
; 1770 :          lpSeqViewAttrib[ lpViewAttrib->cSequencing ] = lpViewAttrib;

	mov	ecx, DWORD PTR _lpViewAttrib$14[ebp]
	movzx	edx, BYTE PTR [ecx+197]
	mov	eax, DWORD PTR _lpViewAttrib$14[ebp]
	mov	DWORD PTR _lpSeqViewAttrib$21[ebp+edx*4], eax

; 1771 : 
; 1772 :          if ( lpViewAttrib->cSequencing > chMaxAttrNbr )

	mov	ecx, DWORD PTR _lpViewAttrib$14[ebp]
	movzx	edx, BYTE PTR [ecx+197]
	movsx	eax, BYTE PTR _chMaxAttrNbr$18[ebp]
	cmp	edx, eax
	jle	SHORT $LN48@ActivateOb

; 1773 :             chMaxAttrNbr = lpViewAttrib->cSequencing;

	mov	ecx, DWORD PTR _lpViewAttrib$14[ebp]
	mov	dl, BYTE PTR [ecx+197]
	mov	BYTE PTR _chMaxAttrNbr$18[ebp], dl
$LN48@ActivateOb:

; 1774 :       }

	jmp	SHORT $LN7@ActivateOb
$LN8@ActivateOb:

; 1775 : 
; 1776 :       if ( chMaxAttrNbr == 0 )

	movsx	eax, BYTE PTR _chMaxAttrNbr$18[ebp]
	test	eax, eax
	jne	SHORT $LN49@ActivateOb

; 1777 :       {
; 1778 :          fnSysMessageBox( lpCurrentTask, szlOE_SystemError,

	push	1
	push	OFFSET $SG14035
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 1779 :                           "Root entity has no default sequencing attributes",
; 1780 :                           1 );
; 1781 :          goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN49@ActivateOb:

; 1782 :       }
; 1783 : 
; 1784 :       // We need to add information to the qualification object.  If they
; 1785 :       // didn't give us one, then we need to create one.  We also need to set
; 1786 :       // the flag that indcates we will need to drop the qualification object
; 1787 :       // later.
; 1788 :       bDropQual = TRUE;

	mov	BYTE PTR _bDropQual$[ebp], 1

; 1789 :       if ( lpQualView == 0 )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	jne	SHORT $LN50@ActivateOb

; 1790 :       {
; 1791 :          SfActivateSysEmptyOI( &lpQualView, "kzdbhqua",

	push	256					; 00000100H
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	push	OFFSET $SG14038
	lea	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 1792 :                                lpAppQualView, zMULTIPLE );
; 1793 :       }

	jmp	SHORT $LN51@ActivateOb
$LN50@ActivateOb:

; 1794 :       else
; 1795 :          ActivateOI_FromOI_ForTask( &lpQualView, lpQualView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_ActivateOI_FromOI_ForTask@16
$LN51@ActivateOb:

; 1796 : 
; 1797 :       // We need to find the last root instance of the original OI.
; 1798 :       for ( lpOrigInstance = zGETPTR( lpOrigViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpOrigViewOI$7[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigInstance$[ebp], eax
	jmp	SHORT $LN12@ActivateOb
$LN10@ActivateOb:

; 1800 :             lpOrigInstance = zGETPTR( lpOrigInstance->hNextTwin ) )

	mov	eax, DWORD PTR _lpOrigInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOrigInstance$[ebp], eax
$LN12@ActivateOb:

; 1799 :             lpOrigInstance->hNextTwin;

	mov	edx, DWORD PTR _lpOrigInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN11@ActivateOb

; 1801 :       {
; 1802 :          ;  // nothing needs to be done here
; 1803 :       }

	jmp	SHORT $LN10@ActivateOb
$LN11@ActivateOb:

; 1804 : 
; 1805 :       lpOrigViewEntityCsr = fnEstablishViewForInstance( vOrigView, 0,

	mov	eax, DWORD PTR _lpOrigInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vOrigView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpOrigViewEntityCsr$[ebp], eax

; 1806 :                                                         lpOrigInstance );
; 1807 : 
; 1808 :       // Make sure that EntitySpec for the root entity exists.
; 1809 :       if ( SetCursorFirstEntityByString( lpQualView, szlEntitySpec,
; 1810 :                                          szlEntityName,
; 1811 :                                          lpViewEntity->szName,
; 1812 :                                          0 ) < zCURSOR_SET )

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _szlEntityName
	push	eax
	mov	ecx, DWORD PTR _szlEntitySpec
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetCursorFirstEntityByString@20
	cwde
	test	eax, eax
	jge	SHORT $LN52@ActivateOb

; 1813 :       {
; 1814 :          CreateEntity( lpQualView, szlEntitySpec, zPOS_LAST );

	push	2
	mov	ecx, DWORD PTR _szlEntitySpec
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1815 :          SetAttributeFromString( lpQualView, szlEntitySpec, szlEntityName,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _szlEntityName
	push	ecx
	mov	edx, DWORD PTR _szlEntitySpec
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1816 :                                  lpViewEntity->szName );
; 1817 :       }

	jmp	$LN53@ActivateOb
$LN52@ActivateOb:

; 1818 :       else
; 1819 :       {
; 1820 :          // Qual view already has qualification on the root entity, so add
; 1821 :          // QualAttrib entities to surround qualification with parens.
; 1822 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_FIRST );

	push	1
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1823 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET $SG14041
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1824 : 
; 1825 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1826 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET $SG14042
	mov	edx, DWORD PTR _szlOper
	push	edx
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1827 : 
; 1828 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1829 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "AND" );

	push	OFFSET $SG14043
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1830 : 
; 1831 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1832 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET $SG14044
	mov	eax, DWORD PTR _szlOper
	push	eax
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1833 : 
; 1834 :          CreateEntity( lpQualView, szlQualAttrib, zPOS_LAST );

	push	2
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1835 :          SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET $SG14045
	mov	edx, DWORD PTR _szlOper
	push	edx
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1836 : 
; 1837 :          SetCursorPrevEntity( lpQualView, szlQualAttrib, 0 );

	push	0
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetCursorPrevEntity@12
$LN53@ActivateOb:

; 1838 :       }
; 1839 : 
; 1840 :       chFirstAttrNbr = 0;

	mov	BYTE PTR _chFirstAttrNbr$19[ebp], 0

; 1841 : 
; 1842 :       for ( chCurrentAttrNbr = 1;

	mov	BYTE PTR _chCurrentAttrNbr$20[ebp], 1
	jmp	SHORT $LN15@ActivateOb
$LN13@ActivateOb:

; 1844 :             chCurrentAttrNbr++ )

	mov	cl, BYTE PTR _chCurrentAttrNbr$20[ebp]
	add	cl, 1
	mov	BYTE PTR _chCurrentAttrNbr$20[ebp], cl
$LN15@ActivateOb:

; 1843 :             chCurrentAttrNbr <= chMaxAttrNbr;

	movsx	edx, BYTE PTR _chCurrentAttrNbr$20[ebp]
	movsx	eax, BYTE PTR _chMaxAttrNbr$18[ebp]
	cmp	edx, eax
	jg	$LN14@ActivateOb

; 1845 :       {
; 1846 :          zSHORT k;
; 1847 : 
; 1848 :          if ( lpSeqViewAttrib[ chCurrentAttrNbr ] == 0 )

	movsx	ecx, BYTE PTR _chCurrentAttrNbr$20[ebp]
	cmp	DWORD PTR _lpSeqViewAttrib$21[ebp+ecx*4], 0
	jne	SHORT $LN54@ActivateOb

; 1849 :             continue;

	jmp	SHORT $LN13@ActivateOb
$LN54@ActivateOb:

; 1850 : 
; 1851 :          if ( chFirstAttrNbr == 0 )

	movsx	edx, BYTE PTR _chFirstAttrNbr$19[ebp]
	test	edx, edx
	jne	SHORT $LN55@ActivateOb

; 1852 :             chFirstAttrNbr = chCurrentAttrNbr;

	mov	al, BYTE PTR _chCurrentAttrNbr$20[ebp]
	mov	BYTE PTR _chFirstAttrNbr$19[ebp], al
$LN55@ActivateOb:

; 1853 : 
; 1854 :          // If chCurrentAttrNbr > chFirstAttrNbr, then we have multiple seq
; 1855 :          // attrs in the entity and we need to stick in an "OR".
; 1856 :          if ( chCurrentAttrNbr > chFirstAttrNbr )

	movsx	ecx, BYTE PTR _chCurrentAttrNbr$20[ebp]
	movsx	edx, BYTE PTR _chFirstAttrNbr$19[ebp]
	cmp	ecx, edx
	jle	SHORT $LN56@ActivateOb

; 1857 :          {
; 1858 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1859 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "OR" );

	push	OFFSET $SG14049
	mov	edx, DWORD PTR _szlOper
	push	edx
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1860 : 
; 1861 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1862 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, "(" );

	push	OFFSET $SG14050
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN56@ActivateOb:

; 1863 :          }
; 1864 : 
; 1865 :          for ( k = chFirstAttrNbr; k <= chCurrentAttrNbr; k++ )

	movsx	cx, BYTE PTR _chFirstAttrNbr$19[ebp]
	mov	WORD PTR _k$17[ebp], cx
	jmp	SHORT $LN18@ActivateOb
$LN16@ActivateOb:
	mov	dx, WORD PTR _k$17[ebp]
	add	dx, 1
	mov	WORD PTR _k$17[ebp], dx
$LN18@ActivateOb:
	movsx	eax, WORD PTR _k$17[ebp]
	movsx	ecx, BYTE PTR _chCurrentAttrNbr$20[ebp]
	cmp	eax, ecx
	jg	$LN17@ActivateOb

; 1866 :          {
; 1867 :             zCHAR sz[ 256 ];
; 1868 : 
; 1869 :             if ( lpSeqViewAttrib[ k ] == 0 )

	movsx	edx, WORD PTR _k$17[ebp]
	cmp	DWORD PTR _lpSeqViewAttrib$21[ebp+edx*4], 0
	jne	SHORT $LN57@ActivateOb

; 1870 :                continue;

	jmp	SHORT $LN16@ActivateOb
$LN57@ActivateOb:

; 1871 : 
; 1872 :             if ( k > chFirstAttrNbr )

	movsx	eax, WORD PTR _k$17[ebp]
	movsx	ecx, BYTE PTR _chFirstAttrNbr$19[ebp]
	cmp	eax, ecx
	jle	SHORT $LN58@ActivateOb

; 1873 :             {
; 1874 :                CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1875 :                SetAttributeFromString( lpQualView, szlQualAttrib,

	push	OFFSET $SG14053
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN58@ActivateOb:

; 1876 :                                        szlOper, "AND" );
; 1877 :             }
; 1878 : 
; 1879 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_CreateEntity@12

; 1880 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlEntityName,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _szlEntityName
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1881 :                                     lpViewEntity->szName );
; 1882 :             SetAttributeFromString( lpQualView, szlQualAttrib, "AttributeName",

	movsx	ecx, WORD PTR _k$17[ebp]
	mov	edx, DWORD PTR _lpSeqViewAttrib$21[ebp+ecx*4]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14054
	mov	eax, DWORD PTR _szlQualAttrib
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 1883 :                                     lpSeqViewAttrib[ k ]->szName );
; 1884 : 
; 1885 :             if ( k == chCurrentAttrNbr )

	movsx	edx, WORD PTR _k$17[ebp]
	movsx	eax, BYTE PTR _chCurrentAttrNbr$20[ebp]
	cmp	edx, eax
	jne	SHORT $LN59@ActivateOb

; 1886 :             {
; 1887 :                if ( lpSeqViewAttrib[ k ]->bSequencingD )

	movsx	ecx, WORD PTR _k$17[ebp]
	mov	edx, DWORD PTR _lpSeqViewAttrib$21[ebp+ecx*4]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN61@ActivateOb

; 1888 :                   SetAttributeFromString( lpQualView, szlQualAttrib,

	push	OFFSET $SG14059
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
	jmp	SHORT $LN62@ActivateOb
$LN61@ActivateOb:

; 1889 :                                           szlOper, "<" );
; 1890 :                else
; 1891 :                   SetAttributeFromString( lpQualView, szlQualAttrib,

	push	OFFSET $SG14060
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN62@ActivateOb:

; 1892 :                                           szlOper, ">" );
; 1893 :             }

	jmp	SHORT $LN60@ActivateOb
$LN59@ActivateOb:

; 1894 :             else
; 1895 :                SetAttributeFromString( lpQualView, szlQualAttrib,

	push	OFFSET $SG14061
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN60@ActivateOb:

; 1896 :                                        szlOper, "=" );
; 1897 : 
; 1898 :             GetStringFromRecord( vOrigView, lpViewEntity,

	push	256					; 00000100H
	lea	ecx, DWORD PTR _sz$22[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$17[ebp]
	mov	eax, DWORD PTR _lpSeqViewAttrib$21[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	call	_GetStringFromRecord@20

; 1899 :                                  lpSeqViewAttrib[ k ], sz, 256 );
; 1900 :             SetAttributeFromString( lpQualView, szlQualAttrib, "Value", sz );

	lea	eax, DWORD PTR _sz$22[ebp]
	push	eax
	push	OFFSET $SG14062
	mov	ecx, DWORD PTR _szlQualAttrib
	push	ecx
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 1901 :          }

	jmp	$LN16@ActivateOb
$LN17@ActivateOb:

; 1902 : 
; 1903 :          if ( chCurrentAttrNbr > chFirstAttrNbr )

	movsx	eax, BYTE PTR _chCurrentAttrNbr$20[ebp]
	movsx	ecx, BYTE PTR _chFirstAttrNbr$19[ebp]
	cmp	eax, ecx
	jle	SHORT $LN63@ActivateOb

; 1904 :          {
; 1905 :             CreateEntity( lpQualView, szlQualAttrib, zPOS_NEXT );

	push	3
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_CreateEntity@12

; 1906 :             SetAttributeFromString( lpQualView, szlQualAttrib, szlOper, ")" );

	push	OFFSET $SG14064
	mov	ecx, DWORD PTR _szlOper
	push	ecx
	mov	edx, DWORD PTR _szlQualAttrib
	push	edx
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	call	_SetAttributeFromString@16
$LN63@ActivateOb:

; 1907 :          }
; 1908 : 
; 1909 :       } // for...

	jmp	$LN13@ActivateOb
$LN14@ActivateOb:

; 1910 : 
; 1911 :    } // if ( lControl & zACTIVATE_CONTINUE )...
; 1912 : 
; 1913 :    lpView = 0;

	mov	DWORD PTR _lpView$[ebp], 0

; 1914 :    if ( lpViewOD->szNetwork[ 0 ] == 0 || lControl & zACTIVATE_LOCAL )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+109]
	test	ecx, ecx
	je	SHORT $LN66@ActivateOb
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1073741824				; 40000000H
	je	$LN64@ActivateOb
$LN66@ActivateOb:

; 1915 :    {
; 1916 :       zSHORT nActivateCount;
; 1917 : 
; 1918 :       // Make sure the LOD has data records.
; 1919 :       lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1920 :       if ( lpViewEntity->hFirstDataRecord == 0 )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+191], 0
	jne	SHORT $LN67@ActivateOb

; 1921 :       {
; 1922 :          // "KZOEE083 - LOD does not have physical information"
; 1923 :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 16, 83, 0, lpViewOD->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	0
	push	83					; 00000053H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1924 :          goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN67@ActivateOb:

; 1925 :       }
; 1926 : 
; 1927 :       // Check to see if we have pessimistic locking defined for the LOD.
; 1928 :       if ( lpViewOD->nLock       >= zLL_PESSIMISTIC ||

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movzx	ecx, BYTE PTR [eax+236]
	cmp	ecx, 3
	jge	SHORT $LN69@ActivateOb
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+237]
	cmp	eax, 3
	jl	SHORT $LN73@ActivateOb
$LN69@ActivateOb:

; 1929 :            lpViewOD->nEntityLock >= zLL_PESSIMISTIC )
; 1930 :       {
; 1931 :          // Check to make sure we can load objects needed for pessimistic
; 1932 :          // locking.
; 1933 :          if ( ActivateViewObject( lpAppQualView, "ZPLOCKO", FALSE ) == 0 )

	push	0
	push	OFFSET $SG14072
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $LN70@ActivateOb

; 1934 :             goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN70@ActivateOb:

; 1935 : 
; 1936 :          // Look for the qualification object.
; 1937 :          if ( ActivateViewObject( lpAppQualView, "KZDBHQUA", TRUE ) == 0 )

	push	1
	push	OFFSET $SG14074
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $LN71@ActivateOb

; 1938 :             goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN71@ActivateOb:

; 1939 : 
; 1940 :          // If user requests locking, then we need to create the locking
; 1941 :          // semaphore so that only one user changes locking at the same time.
; 1942 :          if ( lControl & zSINGLE_FOR_UPDATE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 67108864				; 04000000H
	je	SHORT $LN73@ActivateOb

; 1943 :          {
; 1944 :             if ( lpCurrentTask->bPessimisticLockingSet == FALSE )

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 8
	and	edx, 1
	jne	SHORT $LN73@ActivateOb

; 1945 :             {
; 1946 :                if ( fnCreatePessimisticSemaphore( lpCurrentTask,
; 1947 :                                                   (zPVOID) &lpViewOD, 1, 0,
; 1948 :                                                   lpAppQualView ) < 0 )

	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	push	0
	push	1
	lea	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCreatePessimisticSemaphore@20
	cwde
	test	eax, eax
	jge	SHORT $LN74@ActivateOb

; 1949 :                {
; 1950 :                   goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN74@ActivateOb:

; 1951 :                }
; 1952 : 
; 1953 :                bLockingSemaphoreCreatedHere = TRUE;

	mov	BYTE PTR _bLockingSemaphoreCreatedHere$[ebp], 1
$LN73@ActivateOb:

; 1954 :             }
; 1955 :          }
; 1956 :       }
; 1957 : 
; 1958 :       if ( (nRC = fnDeclareView( &lpView, lpOwningTask, lpAppQualView,
; 1959 :                                  cpcViewOD_Name, FALSE )) != 0 )

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN75@ActivateOb

; 1960 :       {
; 1961 :          goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN75@ActivateOb:

; 1962 :       }
; 1963 : 
; 1964 : #if 0
; 1965 :       if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 1966 :       {
; 1967 :          zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 1968 :                                      zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 1969 : 
; 1970 :          // Must be done prior to activation.
; 1971 :          SfTransferView( lpView, lpAppQualView, nScope );
; 1972 :       }
; 1973 : #endif
; 1974 : 
; 1975 :       nRC = fnActivateEmptyObjectInstance( lpCurrentTask, lpView, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 1976 :       if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN76@ActivateOb

; 1977 :       {
; 1978 :          // fnActivateEmptyObjectInstance didn't work for some reason.
; 1979 :          // Restore the view cursor to the way is was before the call.
; 1980 :          goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN76@ActivateOb:

; 1981 :       }
; 1982 : 
; 1983 :       nActivateCount = 1;

	mov	ecx, 1
	mov	WORD PTR _nActivateCount$16[ebp], cx

; 1984 : 
; 1985 :       SetNameForView( lpView, "__Load-in-progress", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET $SG14080
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SetNameForView@16

; 1986 : 
; 1987 :       // Call fnActivateObjectInstance until activate was achieved. It is
; 1988 :       // possible that there are locks in place that keep the activate from
; 1989 :       // working.
; 1990 :       // Activate object instance.  If database is in use, wait two seconds
; 1991 :       // and try again.
; 1992 :       // Create a temp qualification so the original doesn't get changed.
; 1993 :       if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	SHORT $LN77@ActivateOb

; 1994 :       {
; 1995 :          fnDeclareView( &vTempQual, lpOwningTask, lpQualView, 0, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vTempQual$[ebp]
	push	edx
	call	_fnDeclareView@20

; 1996 :          fnSetViewFromView( vTempQual, lpQualView );

	mov	eax, DWORD PTR _lpQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTempQual$[ebp]
	push	ecx
	call	_fnSetViewFromView
	add	esp, 8

; 1997 :       }

	jmp	SHORT $LN78@ActivateOb
$LN77@ActivateOb:

; 1998 :       else
; 1999 :          vTempQual = 0;

	mov	DWORD PTR _vTempQual$[ebp], 0
$LN78@ActivateOb:

; 2000 : 
; 2001 :       while ( TRUE )

	mov	edx, 1
	test	edx, edx
	je	$LN20@ActivateOb

; 2002 :       {
; 2003 :          nRC = fnActivateObjectInstance( lpCurrentTask, lpView,

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTempQual$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnActivateObjectInstance
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 2004 :                                          vTempQual, lControl );
; 2005 : 
; 2006 :          // If fnActivateObjectInstance worked OK, drop old ViewCsr,
; 2007 :          // otherwise restore the view cursor.
; 2008 :          if ( nRC >= -1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -1
	jl	SHORT $LN79@ActivateOb

; 2009 :          {
; 2010 :             // Try to relink entity instances.
; 2011 :             fnRelinkObjectInstance( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnRelinkObjectInstance@4

; 2012 :             break;

	jmp	$LN20@ActivateOb

; 2013 :          }

	jmp	$LN85@ActivateOb
$LN79@ActivateOb:

; 2014 :          else
; 2015 :          if ( nRC == zDB_UNAVAIL )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	jne	SHORT $LN81@ActivateOb

; 2016 :          {
; 2017 :             // Database was unavailable (in use by another user).
; 2018 :             nActivateCount++;

	mov	cx, WORD PTR _nActivateCount$16[ebp]
	add	cx, 1
	mov	WORD PTR _nActivateCount$16[ebp], cx

; 2019 : 
; 2020 :             // If we've tried 8 times, exit anyway.
; 2021 :             if ( nActivateCount > 8 )

	movsx	edx, WORD PTR _nActivateCount$16[ebp]
	cmp	edx, 8
	jle	SHORT $LN83@ActivateOb

; 2022 :             {
; 2023 :                fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 2024 :                lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2025 :                goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN83@ActivateOb:

; 2026 :             }
; 2027 : 
; 2028 :             SysWait( 2000 );  // Wait for 2 seconds then try again.

	push	2000					; 000007d0H
	call	_SysWait@4

; 2029 :             TraceLineS( "(oi) -------------------------------", "" );

	push	OFFSET $SG14088
	push	OFFSET $SG14089
	call	_TraceLineS@8

; 2030 :             TraceLineS( "(oi) Database unavailable--try again", "" );

	push	OFFSET $SG14090
	push	OFFSET $SG14091
	call	_TraceLineS@8

; 2031 :             TraceLineS( "(oi) -------------------------------", "" );

	push	OFFSET $SG14092
	push	OFFSET $SG14093
	call	_TraceLineS@8

; 2032 :          }

	jmp	$LN85@ActivateOb
$LN81@ActivateOb:

; 2033 :          else
; 2034 :          if ( nRC == zDB_DEADLOCK )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -3					; fffffffdH
	jne	$LN84@ActivateOb

; 2035 :          {
; 2036 :             // Transaction backed out because of deadlock.
; 2037 :             zCHAR  szMsg[ 256 ];
; 2038 : 
; 2039 :             zstrcpy( szMsg, "(oi) Database Deadlock - Object=" );

	push	OFFSET $SG14096
	lea	edx, DWORD PTR _szMsg$23[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 2040 :             zstrcat( szMsg, cpcViewOD_Name );

	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$23[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2041 :             zstrcat( szMsg, " Activate Retry Count=" );

	push	OFFSET $SG14097
	lea	edx, DWORD PTR _szMsg$23[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2042 :             TraceLineI( szMsg, nActivateCount );

	movsx	eax, WORD PTR _nActivateCount$16[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMsg$23[ebp]
	push	ecx
	call	_TraceLineI@8

; 2043 : 
; 2044 :             nActivateCount++;

	mov	dx, WORD PTR _nActivateCount$16[ebp]
	add	dx, 1
	mov	WORD PTR _nActivateCount$16[ebp], dx

; 2045 : 
; 2046 :             // If we've tried 3 times, exit anyway.
; 2047 :             if ( nActivateCount > 3 )

	movsx	eax, WORD PTR _nActivateCount$16[ebp]
	cmp	eax, 3
	jle	SHORT $LN86@ActivateOb

; 2048 :             {
; 2049 :                fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 2050 :                lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2051 :                TraceLineS( "(oi) Deadlock Crash - Retry Count exceeded", "" );

	push	OFFSET $SG14099
	push	OFFSET $SG14100
	call	_TraceLineS@8

; 2052 : 
; 2053 :                goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN86@ActivateOb:

; 2054 :             }
; 2055 : 
; 2056 :             DropObjectInstance( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DropObjectInstance@4

; 2057 : 
; 2058 :             nRC = fnDeclareView( &lpView, lpOwningTask, lpAppQualView,

	push	0
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 2059 :                                  cpcViewOD_Name, FALSE );
; 2060 :             if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN87@ActivateOb

; 2061 :                goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN87@ActivateOb:

; 2062 : 
; 2063 : #if 0
; 2064 :             if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 2065 :             {
; 2066 :                zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 2067 :                                            zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 2068 :                SfTransferView( lpView, lpAppQualView, nScope );
; 2069 :             }
; 2070 : #endif
; 2071 : 
; 2072 :             if ( fnActivateEmptyObjectInstance( lpCurrentTask, lpView,
; 2073 :                                                 lControl ) != 0 )

	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN88@ActivateOb

; 2074 :             {
; 2075 :                goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN88@ActivateOb:

; 2076 :             }
; 2077 : 
; 2078 :             SetNameForView( lpView, "__Load-in-progress", 0, zLEVEL_TASK );

	push	2
	push	0
	push	OFFSET $SG14103
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SetNameForView@16

; 2079 :          }

	jmp	SHORT $LN85@ActivateOb
$LN84@ActivateOb:

; 2080 :          else
; 2081 :          {
; 2082 :             if ( nRC == zMEMORY_LIMIT )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -7					; fffffff9H
	jne	SHORT $LN89@ActivateOb

; 2083 :             {
; 2084 :                // Transaction backed out because of memory error.
; 2085 :                TraceLine( "(oi) Database Memory Limit Reached (Task: 0x%08x) - Object: %s",

	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG14105
	call	_TraceLine
	add	esp, 12					; 0000000cH
$LN89@ActivateOb:

; 2086 :                           zGETHNDL( lpCurrentTask), cpcViewOD_Name );
; 2087 :             }
; 2088 : 
; 2089 :             // Some error occurred.  Bomb out.
; 2090 :             fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 2091 :             lpView = 0;   // Null out lpView so it won't be dropped again.

	mov	DWORD PTR _lpView$[ebp], 0

; 2092 :             goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN85@ActivateOb:

; 2093 :          }
; 2094 :       } // while ( TRUE )...

	jmp	$LN78@ActivateOb
$LN20@ActivateOb:

; 2095 : 
; 2096 :       if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN90@ActivateOb

; 2097 :       {
; 2098 :          lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2099 :          lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax
$LN90@ActivateOb:

; 2100 :       }
; 2101 : 
; 2102 :       // If nRC is 0 or greater, then we've retrieved a valid object.  If
; 2103 :       // the Object instance has any optmistic locking, then some
; 2104 :       // processing needs to be performed.
; 2105 :       if ( nRC >= 0 && (lControl & zSINGLE_FOR_UPDATE) &&

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jl	$LN96@ActivateOb
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 67108864				; 04000000H
	je	$LN96@ActivateOb
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movzx	ecx, BYTE PTR [eax+236]
	cmp	ecx, 1
	je	SHORT $LN92@ActivateOb
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+236]
	cmp	eax, 2
	jne	$LN96@ActivateOb
$LN92@ActivateOb:

; 2106 :            (lpViewOD->nLock == zLL_OPTIMISTIC_NOINC ||
; 2107 :             lpViewOD->nLock == zLL_OPTIMISTIC_CMPRALL) )
; 2108 :       {
; 2109 :          zVIEW vOriginalOI;
; 2110 : 
; 2111 :          // The user wants optimistic locking.  All we need to do right
; 2112 :          // now is save the current OI and the qualification OI.  First
; 2113 :          // make sure we don't have any old ones lying around.
; 2114 :          if ( lpViewOI->vOriginalOI )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [ecx+40], 0
	je	SHORT $LN93@ActivateOb

; 2115 :             fnDropView( zGETPTR( lpViewOI->vOriginalOI ) );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$LN93@ActivateOb:

; 2116 : 
; 2117 :          if ( lpViewOI->vQualOI )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN94@ActivateOb

; 2118 :             fnDropView( zGETPTR( lpViewOI->vQualOI ) );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4
$LN94@ActivateOb:

; 2119 : 
; 2120 :          // Copy the current OI to a safe place so that we can reference
; 2121 :          // it later.  We need to flag the original view so that if
; 2122 :          // vOriginalOI gets dropped before the main OI gets dropped we
; 2123 :          // will know about it.
; 2124 :          ActivateOI_FromOI_ForTask( &vOriginalOI, lpView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vOriginalOI$11[ebp]
	push	edx
	call	_ActivateOI_FromOI_ForTask@16

; 2125 :          vOriginalOI->bOrigView   = TRUE;

	mov	eax, DWORD PTR _vOriginalOI$11[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _vOriginalOI$11[ebp]
	mov	DWORD PTR [edx+30], ecx

; 2126 :          vOriginalOI->bViewLocked = TRUE;

	mov	eax, DWORD PTR _vOriginalOI$11[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _vOriginalOI$11[ebp]
	mov	DWORD PTR [edx+30], ecx

; 2127 :          vOriginalOI->hMainOI     = zGETHNDL( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _vOriginalOI$11[ebp]
	mov	DWORD PTR [ecx+26], eax

; 2128 :          lpViewOI->vOriginalOI    = zGETHNDL( vOriginalOI );

	mov	edx, DWORD PTR _vOriginalOI$11[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 2129 : 
; 2130 :          if ( lpQualView )

	cmp	DWORD PTR _lpQualView$[ebp], 0
	je	$LN95@ActivateOb

; 2131 :          {
; 2132 :             zVIEW vQualOI;
; 2133 : 
; 2134 :             ActivateOI_FromOI_ForTask( &vQualOI, lpQualView, 0, zMULTIPLE );

	push	256					; 00000100H
	push	0
	mov	edx, DWORD PTR _lpQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vQualOI$13[ebp]
	push	eax
	call	_ActivateOI_FromOI_ForTask@16

; 2135 :             vQualOI->bQualView   = TRUE;

	mov	ecx, DWORD PTR _vQualOI$13[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _vQualOI$13[ebp]
	mov	DWORD PTR [eax+30], edx

; 2136 :             vQualOI->bViewLocked = TRUE;

	mov	ecx, DWORD PTR _vQualOI$13[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _vQualOI$13[ebp]
	mov	DWORD PTR [eax+30], edx

; 2137 :             vQualOI->hMainOI     = vOriginalOI->hMainOI; // = zGETHNDL( lpViewOI );

	mov	ecx, DWORD PTR _vQualOI$13[ebp]
	mov	edx, DWORD PTR _vOriginalOI$11[ebp]
	mov	eax, DWORD PTR [edx+26]
	mov	DWORD PTR [ecx+26], eax

; 2138 : 
; 2139 :             // It is possible that the qual OI contains references to
; 2140 :             // another view.  These views might not be around (or they
; 2141 :             // might change) when we use the qual OI again.  To avoid
; 2142 :             // these errors, resolve all references to other views.
; 2143 :             fnResolveQualOI( vQualOI, "QualAttrib" );

	push	OFFSET $SG14113
	mov	ecx, DWORD PTR _vQualOI$13[ebp]
	push	ecx
	call	_fnResolveQualOI
	add	esp, 8

; 2144 :             fnResolveQualOI( vQualOI, "SubQualAttrib" );

	push	OFFSET $SG14114
	mov	edx, DWORD PTR _vQualOI$13[ebp]
	push	edx
	call	_fnResolveQualOI
	add	esp, 8

; 2145 : 
; 2146 :             lpViewOI->vQualOI = zGETHNDL( vQualOI );

	mov	eax, DWORD PTR _vQualOI$13[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 2147 :          }

	jmp	SHORT $LN96@ActivateOb
$LN95@ActivateOb:

; 2148 :          else
; 2149 :             lpViewOI->vQualOI = 0;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+44], 0
$LN96@ActivateOb:

; 2150 : 
; 2151 :       } // if ( nRC >= 0 && OPTIMISTIC LOCKING )...
; 2152 : 
; 2153 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN97@ActivateOb

; 2154 :          DropNameForView( lpView, "__Load-in-progress", lpView, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET $SG14116
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_DropNameForView@16
$LN97@ActivateOb:

; 2155 : 
; 2156 :    } // if ( lpViewOD->hszNetwork == 0 || lControl & zACTIVATE_LOCAL )...

	jmp	$LN65@ActivateOb
$LN64@ActivateOb:

; 2157 :    else
; 2158 :    {
; 2159 :       zLONG lNetControl;
; 2160 : 
; 2161 :       // We need to activate from the network, sooo ...
; 2162 : 
; 2163 :       // First make sure the network is active.
; 2164 :       nRC = NetStatus( lpAppQualView, lpViewOD->szNetwork );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_NetStatus@8
	mov	WORD PTR _nRC$[ebp], ax

; 2165 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN99@ActivateOb

; 2166 :       {
; 2167 :          nRC = NetStartup( lpAppQualView, lpViewOD->szNetwork,

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	push	eax
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	call	_NetStartup@12
	mov	WORD PTR _nRC$[ebp], ax

; 2168 :                            lpViewOD->szNetwork );
; 2169 :          if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN99@ActivateOb

; 2170 :          {
; 2171 :             MessageSend( lpAppQualView, "xx", "KZOEOIAA",

	push	1
	push	300					; 0000012cH
	push	OFFSET $SG14119
	push	OFFSET $SG14120
	push	OFFSET $SG14121
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	call	_MessageSend@24

; 2172 :                         "Network cannot be started.",
; 2173 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 1 );
; 2174 :             nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 2175 :             goto EndOfFunction;

	jmp	$EndOfFunction$127
$LN99@ActivateOb:

; 2176 :          }
; 2177 :       }
; 2178 : 
; 2179 :       // Since we are handling the CONTINUE logic on the client side, turn
; 2180 :       // off the CONTINUE flag (if it's on).
; 2181 :       lNetControl = lControl & ~zACTIVATE_CONTINUE;

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, -134217729				; f7ffffffH
	mov	DWORD PTR _lNetControl$5[ebp], edx

; 2182 : 
; 2183 :       nRC = NetActivateOI( lpViewOD->szNetwork, 0, &lpView,

	mov	eax, DWORD PTR _lNetControl$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcViewOD_Name$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 109				; 0000006dH
	push	edx
	call	_NetActivateOI@28
	mov	WORD PTR _nRC$[ebp], ax
$LN65@ActivateOb:

; 2184 :                            (zPCHAR) cpcViewOD_Name, lpAppQualView,
; 2185 :                            lpQualView, lNetControl );
; 2186 :    }
; 2187 : 
; 2188 :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN100@ActivateOb

; 2189 :    {
; 2190 :       lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2191 :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2192 :       lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2193 :       lpViewOI->lActivateControl = lControl;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR [eax+48], ecx
$LN100@ActivateOb:

; 2194 :    }
; 2195 : 
; 2196 :    if ( nRC >= 0 && lControl & zREADONLY )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN101@ActivateOb
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2048				; 00000800H
	je	SHORT $LN101@ActivateOb

; 2197 :       lpView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx
$LN101@ActivateOb:

; 2198 : 
; 2199 :    // If we are doing a CONTINUE activate then we need to add the entities
; 2200 :    // just loaded to the original instance.
; 2201 :    if ( lControl & zACTIVATE_CONTINUE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 134217728				; 08000000H
	je	$LN102@ActivateOb

; 2202 :    {
; 2203 :       LPENTITYINSTANCE lpEntityInstance;
; 2204 : 
; 2205 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$10[ebp], eax
	jmp	SHORT $LN23@ActivateOb
$LN21@ActivateOb:

; 2207 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$10[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$10[ebp], eax
$LN23@ActivateOb:

; 2206 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$10[ebp], 0
	je	$LN22@ActivateOb

; 2208 :       {
; 2209 :       // LPDATARECORD     lpFirstDataRecord;
; 2210 :       // LPDATAFIELD      lpDataField;
; 2211 :          LPVIEWATTRIB     lpViewAttrib;
; 2212 :          LPVIEWENTITYCSR  lpViewEntityCsr;
; 2213 :          LPENTITYINSTANCE lpNewEI;
; 2214 :          zBOOL            bNewRoot;
; 2215 : 
; 2216 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$10[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2217 :          fnEstablishViewForInstance( lpView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$10[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 2218 : 
; 2219 :          fnValidViewEntity( &lpViewEntityCsr, vOrigView,

	push	0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _vOrigView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$6[ebp]
	push	eax
	call	_fnValidViewEntity@16

; 2220 :                             lpViewEntity->szName, 0 );
; 2221 :          if ( lpViewEntity->hParent )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN103@ActivateOb

; 2222 :             bNewRoot = FALSE;

	mov	BYTE PTR _bNewRoot$15[ebp], 0
	jmp	SHORT $LN104@ActivateOb
$LN103@ActivateOb:

; 2223 :          else
; 2224 :             bNewRoot = FALSE; // TRUE;

	mov	BYTE PTR _bNewRoot$15[ebp], 0
$LN104@ActivateOb:

; 2225 : 
; 2226 :          fnCreateEntity( vOrigView, lpViewEntity, lpViewEntityCsr, zPOS_LAST,

	movzx	dx, BYTE PTR _bNewRoot$15[ebp]
	movzx	eax, dx
	push	eax
	push	2
	mov	ecx, DWORD PTR _lpViewEntityCsr$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _vOrigView$[ebp]
	push	eax
	call	_fnCreateEntity@20

; 2227 :                          (zSHORT) bNewRoot );
; 2228 :          lpNewEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$6[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewEI$2[ebp], eax

; 2229 : 
; 2230 :          // Loop through all persistent entities and store values in object.
; 2231 :          for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9[ebp], eax
	jmp	SHORT $LN26@ActivateOb
$LN24@ActivateOb:

; 2233 :                lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$9[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$9[ebp], eax
$LN26@ActivateOb:

; 2232 :                lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$9[ebp], 0
	je	SHORT $LN25@ActivateOb

; 2234 :          {
; 2235 :             zPCHAR  lpPtr;
; 2236 :             zULONG  uLth;
; 2237 : 
; 2238 :             if ( lpViewAttrib->bPersist )

	mov	ecx, DWORD PTR _lpViewAttrib$9[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	je	SHORT $LN105@ActivateOb

; 2239 :             {
; 2240 :                fnGetAttrAddrFromEntityInstance( &lpPtr, &uLth,

	mov	eax, DWORD PTR _lpViewAttrib$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _uLth$4[ebp]
	push	edx
	lea	eax, DWORD PTR _lpPtr$3[ebp]
	push	eax
	call	_fnGetAttrAddrFromEntityInstance
	add	esp, 16					; 00000010H

; 2241 :                                                 lpEntityInstance,
; 2242 :                                                 lpViewAttrib );
; 2243 :                fnStoreValueInEntityInstance( lpNewEI, lpViewEntity,

	mov	ecx, DWORD PTR _uLth$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpPtr$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewEI$2[ebp]
	push	edx
	call	_fnStoreValueInEntityInstance
	add	esp, 20					; 00000014H
$LN105@ActivateOb:

; 2244 :                                              lpViewAttrib, lpPtr, uLth );
; 2245 :             }
; 2246 : 
; 2247 :          } // for ( lpDataField... )...

	jmp	$LN24@ActivateOb
$LN25@ActivateOb:

; 2248 : 
; 2249 :       } // for ( lpEntityInstance... )...

	jmp	$LN21@ActivateOb
$LN22@ActivateOb:

; 2250 : 
; 2251 :       fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 2252 :       lpView = vOrigView;

	mov	ecx, DWORD PTR _vOrigView$[ebp]
	mov	DWORD PTR _lpView$[ebp], ecx
$LN102@ActivateOb:

; 2253 : 
; 2254 :    } // if ( lControl & zACTIVATE_CONTINUE )...
; 2255 : 
; 2256 :    if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN108@ActivateOb

; 2257 :    {
; 2258 :       // Reset the view to its initial state.
; 2259 :       if ( lControl & zACTIVATE_CONTINUE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 134217728				; 08000000H
	je	SHORT $LN107@ActivateOb

; 2260 :          fnEstablishViewForInstance( lpView, 0, lpOrigInstance );

	mov	ecx, DWORD PTR _lpOrigInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN108@ActivateOb
$LN107@ActivateOb:

; 2261 :       else
; 2262 :          fnResetView( lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnResetView
	add	esp, 8
$LN108@ActivateOb:

; 2263 : 
; 2264 :    } // if ( nRC >= 0 )...
; 2265 : 
; 2266 : #ifdef __ACTIVATE_CONSTRAINTS__
; 2267 : 
; 2268 :    if ( (lControl & zACTIVATE_NOCONSTRAINTS) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 16777216				; 01000000H
	jne	$LN112@ActivateOb

; 2269 :    {
; 2270 :       // If there is an Object Constraint for activate, see if it has
; 2271 :       // any objections about continuing.
; 2272 :       if ( nRC >= 0 && lpViewOD->bActivateConstraint )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN112@ActivateOb
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 3
	and	ecx, 1
	je	$LN112@ActivateOb

; 2273 :       {
; 2274 :          zSHORT   nState;
; 2275 :          zSHORT   k;
; 2276 : 
; 2277 :          nState = (lControl & zLEVEL_SYSTEM) ? zOCE_STATE_SYSTEM : 0;

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 8
	je	SHORT $LN125@ActivateOb
	mov	DWORD PTR tv807[ebp], 4
	jmp	SHORT $LN126@ActivateOb
$LN125@ActivateOb:
	mov	DWORD PTR tv807[ebp], 0
$LN126@ActivateOb:
	mov	ax, WORD PTR tv807[ebp]
	mov	WORD PTR _nState$12[ebp], ax

; 2278 :          if ( lControl & zMULTIPLE )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 256				; 00000100H
	je	SHORT $LN111@ActivateOb

; 2279 :             nState |= zOCE_STATE_MULTIPLE;

	movsx	edx, WORD PTR _nState$12[ebp]
	or	edx, 16					; 00000010H
	mov	WORD PTR _nState$12[ebp], dx
$LN111@ActivateOb:

; 2280 : 
; 2281 :          k = fnInvokeOCEOperation( lpView, lpCurrentTask,

	movzx	eax, WORD PTR _nState$12[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _k$8[ebp], ax

; 2282 :                                    zOCE_ACTIVATE, nState );
; 2283 :          // If object constraint says no go, drop the view and exit
; 2284 :          if ( k )

	movsx	eax, WORD PTR _k$8[ebp]
	test	eax, eax
	je	SHORT $LN112@ActivateOb

; 2285 :          {
; 2286 :             nRC = k;

	mov	cx, WORD PTR _k$8[ebp]
	mov	WORD PTR _nRC$[ebp], cx

; 2287 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$127
$LN112@ActivateOb:

; 2288 :          }
; 2289 :       }
; 2290 :    }
; 2291 : #endif
; 2292 : 
; 2293 :    // If the view has pessimistic locking and if the zSINGLE_FOR_UPDATE flag
; 2294 :    // has not been set or if the locking level is zLL_PESSIMISTIC then the
; 2295 :    // view is read-only.
; 2296 :    if ( nRC >= -1 && lpView &&

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jl	SHORT $EndOfFunction$127
	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $EndOfFunction$127
	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 67108864				; 04000000H
	jne	SHORT $LN115@ActivateOb
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movzx	edx, BYTE PTR [ecx+236]
	test	edx, edx
	jg	SHORT $LN114@ActivateOb
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movzx	ecx, BYTE PTR [eax+237]
	cmp	ecx, 3
	jg	SHORT $LN114@ActivateOb
$LN115@ActivateOb:
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+236]
	cmp	eax, 3
	jne	SHORT $EndOfFunction$127
$LN114@ActivateOb:

; 2297 :         (((lControl & zSINGLE_FOR_UPDATE) == 0 &&
; 2298 :           (lpViewOD->nLock > 0 ||
; 2299 :            lpViewOD->nEntityLock > zLL_PESSIMISTIC)) ||
; 2300 :          lpViewOD->nLock == zLL_PESSIMISTIC) )
; 2301 :    {
; 2302 :       lpView->bReadOnly   = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 2303 :       lpViewOI->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 4
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$EndOfFunction$127:

; 2304 :    }
; 2305 : 
; 2306 : EndOfFunction:
; 2307 : 
; 2308 :    if ( bLockingSemaphoreCreatedHere )

	movzx	ecx, BYTE PTR _bLockingSemaphoreCreatedHere$[ebp]
	test	ecx, ecx
	je	SHORT $LN116@ActivateOb

; 2309 :       fnDeletePessimisticSemaphore( lpCurrentTask,

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	push	0
	push	1
	lea	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnDeletePessimisticSemaphore@20
$LN116@ActivateOb:

; 2310 :                                     (zPVOID) &lpViewOD, 1, 0, lpAppQualView );
; 2311 : 
; 2312 :    if ( AnchorBlock->TraceFlags.bOI_Times )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	and	eax, 1
	je	SHORT $LN117@ActivateOb

; 2313 :    {
; 2314 :       zCHAR sz[ 100 ];
; 2315 : 
; 2316 :       zsprintf( sz, "%lf seconds for object %s ",

	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	call	_SysGetTickCount@0
	sub	eax, DWORD PTR _lTickCount$[ebp]
	mov	DWORD PTR tv1294[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv1294[ebp]
	mov	edx, DWORD PTR tv1294[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG14140
	lea	eax, DWORD PTR _sz$24[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 2317 :                 (double) (SysGetTickCount( ) - lTickCount) / zTICKS_PER_SECOND,
; 2318 :                 cpcViewOD_Name );
; 2319 :       TraceLineS( "(oi) Total time for ActivateObjectInstance = ", sz );

	lea	ecx, DWORD PTR _sz$24[ebp]
	push	ecx
	push	OFFSET $SG14141
	call	_TraceLineS@8
$LN117@ActivateOb:

; 2320 :    }
; 2321 : 
; 2322 :    if ( nRC < -1 )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -1
	jge	SHORT $LN118@ActivateOb

; 2323 :    {
; 2324 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN120@ActivateOb

; 2325 :          fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4
$LN120@ActivateOb:

; 2326 : 
; 2327 :       if ( (lControl & zACTIVATE_CONTINUE) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 134217728				; 08000000H
	jne	SHORT $LN121@ActivateOb

; 2328 :          *pvReturnView = 0;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [edx], 0
$LN121@ActivateOb:

; 2329 :    }

	jmp	SHORT $LN119@ActivateOb
$LN118@ActivateOb:

; 2330 :    else
; 2331 :       *pvReturnView = lpView;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax], ecx
$LN119@ActivateOb:

; 2332 : 
; 2333 :    if ( vTempQual )

	cmp	DWORD PTR _vTempQual$[ebp], 0
	je	SHORT $LN122@ActivateOb

; 2334 :       fnDropView( vTempQual );

	mov	edx, DWORD PTR _vTempQual$[ebp]
	push	edx
	call	_fnDropView@4
$LN122@ActivateOb:

; 2335 : 
; 2336 :    if ( bDropQual )

	movzx	eax, BYTE PTR _bDropQual$[ebp]
	test	eax, eax
	je	SHORT $LN123@ActivateOb

; 2337 :       fnDropView( lpQualView );

	mov	ecx, DWORD PTR _lpQualView$[ebp]
	push	ecx
	call	_fnDropView@4
$LN123@ActivateOb:

; 2338 : 
; 2339 :    fnOperationReturn( iActivateObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	52					; 00000034H
	call	_fnOperationReturn
	add	esp, 8

; 2340 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ActivateOb:

; 2341 : 
; 2342 : }  // ActivateObjectInstance

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ActivateObjectInstance@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeoiaa.c
_TEXT	SEGMENT
_lpViewOD$ = -36					; size = 4
tv185 = -32						; size = 4
_lpOwningTask$ = -28					; size = 4
_lpViewCsr$1 = -24					; size = 4
_l$ = -20						; size = 4
_lpView$ = -16						; size = 4
_lpCurrentTask$ = -12					; size = 4
_nState$2 = -8						; size = 2
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_cpcViewOD_Name$ = 12					; size = 4
_lpAppQualView$ = 16					; size = 4
_lControl$ = 20						; size = 4
_ActivateEmptyObjectInstance@16 PROC

; 556  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 557  :    LPTASK         lpCurrentTask;
; 558  :    LPTASK         lpOwningTask;
; 559  :    LPVIEWOD       lpViewOD;
; 560  :    zVIEW          lpView;
; 561  :    zLONG          l;
; 562  :    zSHORT         nRC;
; 563  : 
; 564  :    // Init in case of early error
; 565  :    *pvReturnView = 0;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 566  : 
; 567  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 568  :    if ( (lpCurrentTask = fnOperationCall( iActivateEmptyObjectInstance,
; 569  :                                           lpAppQualView, zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	push	50					; 00000032H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@ActivateEm

; 570  :    {
; 571  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateEm
$LN4@ActivateEm:

; 572  :    }
; 573  : 
; 574  :    // Verify only one zLEVEL_ option requested
; 575  :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 576  :    if ( l && (-l & l) != l )

	je	SHORT $LN5@ActivateEm
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $LN5@ActivateEm

; 577  :    {
; 578  :       // error, More than one zLEVEL_ option requested
; 579  :       // "KZOEE023 - Invalid parameter, "
; 580  :       fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 23, 0,

	push	0
	push	OFFSET $SG13494
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 581  :                         "More than one zLEVEL_ option requested", 0 );
; 582  :       fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 583  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateEm
$LN5@ActivateEm:

; 584  :    }
; 585  : 
; 586  :    // If zLEVEL_SAME is requested
; 587  :    if ( lControl & zLEVEL_SAME )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1024				; 00000400H
	je	$LN6@ActivateEm

; 588  :    {
; 589  :       if ( lpAppQualView == 0 || lpAppQualView->hSubtask )

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $LN9@ActivateEm
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN7@ActivateEm
$LN9@ActivateEm:

; 590  :       {
; 591  :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 592  :          fnIssueCoreError( lpCurrentTask, lpAppQualView, 8, 100, 0,

	push	OFFSET $SG13499
	push	OFFSET $SG13500
	push	0
	push	100					; 00000064H
	push	8
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 593  :                            "lpAppQualView", "with zLEVEL_SAME" );
; 594  :          fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 595  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateEm

; 596  :       }

	jmp	SHORT $LN6@ActivateEm
$LN7@ActivateEm:

; 597  :       else
; 598  :       {
; 599  :          LPVIEWCSR lpViewCsr;
; 600  : 
; 601  :          // Turn off the 'same' indicator
; 602  :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 603  :          // To determine what the level is of the qualifying view
; 604  :          //   1. Change lpAppQualView to point to the initial
; 605  :          //      view created for the object instance
; 606  :          //   2. Check for application level, if there use
; 607  :          //      zLEVEL_APPLICATION.
; 608  :          //   3. Check if the view task is the main task, if so use
; 609  :          //      zLEVEL_SYSTEM.
; 610  :          //   4. Use the task level...
; 611  :          lpViewCsr = zGETPTR( lpAppQualView->hViewCsr );

	mov	ecx, DWORD PTR _lpAppQualView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax
$LN2@ActivateEm:

; 612  :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$1[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $LN3@ActivateEm

; 613  :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax
	jmp	SHORT $LN2@ActivateEm
$LN3@ActivateEm:

; 614  : 
; 615  :          lpAppQualView = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAppQualView$[ebp], eax

; 616  :          if ( lpAppQualView->bApplicationView )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN10@ActivateEm

; 617  :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx
	jmp	SHORT $LN6@ActivateEm
$LN10@ActivateEm:

; 618  :          else
; 619  :          if ( lpAppQualView->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN6@ActivateEm

; 620  :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$LN6@ActivateEm:

; 621  :       }
; 622  :    }
; 623  : 
; 624  :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 12					; 0000000cH
	je	SHORT $LN13@ActivateEm

; 625  :       lpOwningTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax
	jmp	SHORT $LN14@ActivateEm
$LN13@ActivateEm:

; 626  :    else
; 627  :       lpOwningTask = lpCurrentTask;

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], eax
$LN14@ActivateEm:

; 628  : 
; 629  :    if ( (nRC = fnDeclareView( pvReturnView, lpOwningTask,
; 630  :                               lpAppQualView, cpcViewOD_Name, 0 )) != 0 )

	push	0
	mov	ecx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN15@ActivateEm

; 631  :    {
; 632  :       fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 633  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@ActivateEm
$LN15@ActivateEm:

; 634  :    }
; 635  : 
; 636  : #if 0
; 637  :    if ( lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM) )
; 638  :    {
; 639  :       zSHORT nScope = (lControl & zLEVEL_APPLICATION) ?
; 640  :                                   zLEVEL_APPLICATION : zLEVEL_SYSTEM;
; 641  :       if ( (nRC = SfTransferView( *pvReturnView, lpAppQualView,
; 642  :                                   nScope )) != 0 )
; 643  :       {
; 644  :          fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );
; 645  :          return( nRC );
; 646  :       }
; 647  :    }
; 648  : #endif
; 649  : 
; 650  :    nRC = fnActivateEmptyObjectInstance( lpCurrentTask, *pvReturnView, lControl );

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnActivateEmptyObjectInstance
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 651  :    lpView = *pvReturnView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpView$[ebp], eax

; 652  :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 653  :    if ( lControl & zREADONLY )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2048				; 00000800H
	je	SHORT $LN16@ActivateEm

; 654  :       lpView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx
$LN16@ActivateEm:

; 655  : 
; 656  : // TraceLine( "ActivateEmptyObjectInstance: 0x%08x   LOD: %s",
; 657  : //            lpView, lpViewOD->szName );
; 658  : 
; 659  : #ifdef __ACTIVATE_CONSTRAINTS__
; 660  :    if ( lpViewOD->bActivateEmptyConstraint && nRC == 0 )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN17@ActivateEm
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN17@ActivateEm

; 661  :    {
; 662  :       zSHORT   nState;
; 663  : 
; 664  :       nState = (lControl & zLEVEL_SYSTEM) ? zOCE_STATE_SYSTEM : 0;

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 8
	je	SHORT $LN21@ActivateEm
	mov	DWORD PTR tv185[ebp], 4
	jmp	SHORT $LN22@ActivateEm
$LN21@ActivateEm:
	mov	DWORD PTR tv185[ebp], 0
$LN22@ActivateEm:
	mov	dx, WORD PTR tv185[ebp]
	mov	WORD PTR _nState$2[ebp], dx

; 665  :          if ( lControl & zMULTIPLE )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 256				; 00000100H
	je	SHORT $LN18@ActivateEm

; 666  :             nState |= zOCE_STATE_MULTIPLE;

	movsx	ecx, WORD PTR _nState$2[ebp]
	or	ecx, 16					; 00000010H
	mov	WORD PTR _nState$2[ebp], cx
$LN18@ActivateEm:

; 667  : 
; 668  :       nRC = fnInvokeOCEOperation( lpView, lpCurrentTask,

	movzx	edx, WORD PTR _nState$2[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H
	mov	WORD PTR _nRC$[ebp], ax

; 669  :                                   zOCE_ACTIVATE_EMPTY, nState );
; 670  :       if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN17@ActivateEm

; 671  :       {
; 672  :          fnDropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnDropView@4

; 673  :          *pvReturnView = 0;

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], 0
$LN17@ActivateEm:

; 674  :       }
; 675  :    }
; 676  : #endif
; 677  : 
; 678  :    fnOperationReturn( iActivateEmptyObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	50					; 00000032H
	call	_fnOperationReturn
	add	esp, 8

; 679  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ActivateEm:

; 680  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ActivateEmptyObjectInstance@16 ENDP
_TEXT	ENDS
END
