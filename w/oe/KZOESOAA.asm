; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOESOAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG15052 DB	01H DUP (?)
	ALIGN	4

$SG15054 DB	01H DUP (?)
	ALIGN	4

$SG15060 DB	01H DUP (?)
	ALIGN	4

$SG15061 DB	01H DUP (?)
	ALIGN	4

$SG15066 DB	01H DUP (?)
	ALIGN	4

$SG15068 DB	01H DUP (?)
	ALIGN	4

$SG15074 DB	01H DUP (?)
	ALIGN	4

$SG15075 DB	01H DUP (?)
	ALIGN	4

?k@?M@??IncludeSubobjectFromSubobject@@9@9 DW 01H DUP (?) ; `IncludeSubobjectFromSubobject'::`12'::k
	ALIGN	4

$SG14295 DB	01H DUP (?)
	ALIGN	4

$SG14323 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG15513 DB	'Call DG (#102)', 00H
	ORG $+1
$SG15514 DB	'QuinSoft Info', 00H
	ORG $+2
$SG14494 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG14495 DB	'Source Entity not excludable', 00H
	ORG $+3
$SG14497 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG14498 DB	'Entity creation not allowed', 00H
$SG13665 DB	'KZOEE106', 00H
	ORG $+3
$SG13666 DB	'Browse view named ''KZOEE106'' to see what entity instan'
	DB	'ce has the error.  Entity name = ', 00H
$SG13667 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG13668 DB	'number of entities less than minimum cardinality', 00H
	ORG $+3
$SG13669 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG13670 DB	'KZOEE106', 00H
	ORG $+3
$SG13671 DB	'Browse view named ''KZOEE106'' to see what entity instan'
	DB	'ce has the error.  Entity name = ', 00H
$SG13672 DB	'Marked as having a required child, but none found...', 00H
	ORG $+3
$SG13714 DB	0aH, 'Relationship: ', 09H, 00H
	ORG $+3
$SG13715 DB	' <--> ', 00H
	ORG $+1
$SG13716 DB	'number of entities less than minimum cardinality', 00H
	ORG $+3
$SG13721 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG13722 DB	'number of entities less than minimum cardinality', 00H
	ORG $+3
$SG13723 DB	'maximum cardinality exceeded', 00H
	ORG $+3
$SG13730 DB	0aH, 'Relationship: ', 09H, 00H
	ORG $+3
$SG13731 DB	' <--> ', 00H
	ORG $+1
$SG13732 DB	'number of entities less than minimum cardinality', 00H
	ORG $+3
$SG14889 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG14890 DB	'Source Entity not includeble', 00H
	ORG $+3
$SG14893 DB	' and should be re-built', 00H
$SG14894 DB	'ERROR: The following LODs are out of sync', 00H
	ORG $+2
$SG14895 DB	'Out-of-sync error. Target LOD = %s, date = %s', 00H
	ORG $+2
$SG14896 DB	'ERROR: ', 00H
$SG14897 DB	'Out-of-sync error. Source LOD = %s, date = %s', 00H
	ORG $+2
$SG14898 DB	'ERROR: ', 00H
$SG14899 DB	'LODs are potentially out of sync.  See trace for more.', 00H
	ORG $+1
$SG14900 DB	'Zeidon RLK', 00H
	ORG $+1
$SG14902 DB	'Zeidon RLK', 00H
	ORG $+1
$SG14908 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG14909 DB	'Entity inclusion not allowed', 00H
	ORG $+3
$SG14910 DB	'Zeidon RLK', 00H
	ORG $+1
$SG14950 DB	'Zeidon RLK', 00H
	ORG $+1
$SG15053 DB	'--- Error ---', 00H
	ORG $+2
$SG15055 DB	'The relationship already exists between two entities:', 00H
	ORG $+2
$SG15056 DB	'Object Instance ID = ', 00H
	ORG $+2
$SG15057 DB	'Parent Name = ', 00H
	ORG $+1
$SG15058 DB	'       EI   = ', 00H
	ORG $+1
$SG15059 DB	'       Key  = ', 00H
	ORG $+1
$SG15062 DB	'Child Name = ', 00H
	ORG $+2
$SG15063 DB	'      EI   = ', 00H
	ORG $+2
$SG15064 DB	'      Key  = ', 00H
	ORG $+2
$SG15067 DB	'--- Error ---', 00H
	ORG $+2
$SG15069 DB	'The relationship already exists between two entities:', 00H
	ORG $+2
$SG15070 DB	'Object Instance ID = ', 00H
	ORG $+2
$SG15071 DB	'Parent Name = ', 00H
	ORG $+1
$SG15072 DB	'       EI   = ', 00H
	ORG $+1
$SG15073 DB	'       Key  = ', 00H
	ORG $+1
$SG15076 DB	'Child Name = ', 00H
	ORG $+2
$SG15077 DB	'      EI   = ', 00H
	ORG $+2
$SG15078 DB	'      Key  = ', 00H
	ORG $+2
$SG15293 DB	'Source view entity = %s, Target view entity = %s', 00H
	ORG $+3
$SG14281 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG14282 DB	'Source Entity not includeble', 00H
	ORG $+3
$SG14284 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG14285 DB	'Entity inclusion not allowed', 00H
	ORG $+3
$SG14287 DB	'The following LODs are out of sync and should be re-buil'
	DB	't', 00H
	ORG $+2
$SG14288 DB	'ERROR: ', 00H
$SG14289 DB	'Out-of-sync error. Target LOD = %s, date = %s', 00H
	ORG $+2
$SG14290 DB	'ERROR: ', 00H
$SG14291 DB	'Out-of-sync error. Source LOD = %s, date = %s', 00H
	ORG $+2
$SG14292 DB	'ERROR: ', 00H
$SG14293 DB	'LODs are potentially out of sync.  See trace for more.', 00H
	ORG $+1
$SG14296 DB	'Rules violation: physical mapping mismatch', 00H
	ORG $+1
$SG14297 DB	'%s.%s', 00H
	ORG $+2
$SG14298 DB	'   Target entity = ', 00H
$SG14299 DB	'%s.%s', 00H
	ORG $+2
$SG14300 DB	'   Source entity = ', 00H
$SG14301 DB	'Target entity has physical mapping but source entity doe'
	DB	's not.  Rebuild source LOD with TE.', 0aH, 'See trace for mor'
	DB	'e.', 00H
$SG14304 DB	'BombZDr', 00H
$SG14305 DB	'[Debug]', 00H
$SG14310 DB	'IncludeSubobjectFromSubobject Include source task (0x%08'
	DB	'x) does not match target task (0x%08x), but target task is th'
	DB	'e application task - Source Entity: %s  Target Entity: %s', 00H
	ORG $+1
$SG14313 DB	'IncludeSubobjectFromSubobject Include source task (0x%08'
	DB	'x) does not match target task (0x%08x), but target task is th'
	DB	'e application taskSource Entity: %s   Target Entity: %s', 00H
	ORG $+3
$SG14314 DB	'IncludeSubobjectFromSubobject Include source task (0x%08'
	DB	'x) does not match target task (0x%08x) Source Entity: %s   Ta'
	DB	'rget Entity: %s', 00H
	ORG $+3
$SG14321 DB	'%s.%s.%s Offset = %d', 00H
	ORG $+3
$SG14322 DB	'(so) IncludeSubobject Src ', 00H
	ORG $+1
$SG14324 DB	'(so) No matching Src Attrib', 00H
$SG14325 DB	'%s.%s.%s Offset = %d', 00H
	ORG $+3
$SG14326 DB	'(so) IncludeSubobject Tgt ', 00H
	ORG $+1
$SG14327 DB	0aH, 'Entity: ', 09H, 00H
	ORG $+1
$SG14328 DB	'Source entity was built with TE but the target entity wa'
	DB	's not and attributes do not match. Rebuild target LOD with TE'
	DB	'.', 0aH, 'Target entity name', 00H
_DATA	ENDS
PUBLIC	_CreateTemporalSubobjectVersion@8
PUBLIC	_AcceptSubobject@8
PUBLIC	_AcceptAllTemporalSubobjects@4
PUBLIC	_CancelSubobject@8
PUBLIC	_CancelAllTemporalSubobjects@4
PUBLIC	_IncludeSubobjectFromSubobject@20
PUBLIC	_IncludeSubobjectFromSubobjectEx@24
PUBLIC	_MoveSubobject@24
PUBLIC	_RelinkAllSubobjectsForOI@16
PUBLIC	_SubobjectVersionUpdated@12
PUBLIC	_fnValidSubobjectStructureMatch
PUBLIC	_fnIncludeSubobjectFromSubobject
PUBLIC	_fnSpawnIncludeSubobject
PUBLIC	_fnRelinkVsnSubobjectToSubobject
PUBLIC	_fnOEAcceptConstraints
PUBLIC	_fnCheckChildEntities
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnVersionedForUpdate
PUBLIC	_fnUpdateNextVsnRecordPointers
PUBLIC	_fnGetRecurseParentEntity
PUBLIC	_fnCountEntities
PUBLIC	_fnValidateCardinality
PUBLIC	_fnFindLastEntityUnderParent@8
PUBLIC	_fnMoveSubobjectUnderNewParent@32
PUBLIC	_fnMoveSubobjectAmongTwins@24
PUBLIC	_fnUpdateRelinkCursors
PUBLIC	_fnValidStructureEntity@20
PUBLIC	_fnInstanceChildOfInstanceForRel
PUBLIC	_fnIncludeEntityAndChildren@20
EXTRN	_memcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_IssueOE_Error@28:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_SetViewToSubobject@8:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorPrevEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorLastEntity@12:PROC
EXTRN	_SetAttributeFromAttribute@24:PROC
EXTRN	_SysMutexLock@16:PROC
EXTRN	_SysMutexUnlock@12:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_fnCopyAttributeRecord:PROC
EXTRN	_fnDeleteAttributeRecord:PROC
EXTRN	_fnSetUpdateIndicator:PROC
EXTRN	_fnResetCursorForViewChildren:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnCreateEntity@20:PROC
EXTRN	_fnDeleteEntity:PROC
EXTRN	_fnExcludeEntity:PROC
EXTRN	_fnEstablishViewForInstance:PROC
EXTRN	_fnValidateInsertPosition:PROC
EXTRN	_fnValidateInstanceParameters:PROC
EXTRN	_fnSpawnCreateEntity:PROC
EXTRN	_fnReclaimHiddenInstances@4:PROC
EXTRN	_fnInstanceLinkedToInstance:PROC
EXTRN	_fnInstanceVersioned:PROC
EXTRN	_fnInstanceVersionRootMatch:PROC
EXTRN	_fnInstanceKeysMatch:PROC
EXTRN	_fnRelinkInstanceToInstance:PROC
EXTRN	_fnInvokeECEOperation:PROC
EXTRN	_fnRemoveAllChildTemporalVsns:PROC
EXTRN	_fnRemoveOtherOI_LinkedInstances:PROC
EXTRN	_fnEntityInRecursivePath:PROC
EXTRN	_fnFirstLevel2_ForViewEntity:PROC
EXTRN	_fnStillPrevVersion:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidViewCsr:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnAddEntityToDebugChange@4:PROC
EXTRN	_fnSetViewFromView:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	_fnSetViewToSubobject:PROC
EXTRN	_fnResetViewFromSubobject:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_fnValidateInstanceAttributes:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_hAllocTask$ = -76					; size = 4
_lpAllocTask$ = -72					; size = 4
_lpChildEntityInstance$ = -68				; size = 4
_lpSrcChildViewEntity$ = -64				; size = 4
tv296 = -60						; size = 4
tv295 = -56						; size = 4
_lpChildTgtByToken$1 = -52				; size = 4
tv189 = -48						; size = 4
_lpSrcViewEntityCsr$ = -44				; size = 4
_lpWrkEntityInstance$2 = -40				; size = 4
_lpSrcViewEntity$ = -36					; size = 4
_lpTgtEntityInstance$ = -32				; size = 4
_lpChildTgtViewEntity$ = -28				; size = 4
_lpChildTgtViewEntityCsr$ = -24				; size = 4
_lpSrcEntityInstance$ = -20				; size = 4
_nRC$ = -16						; size = 2
_nTargetLevel$ = -12					; size = 2
_nSourceLevel$ = -8					; size = 2
_nSkipType$ = -4					; size = 2
_lpTgtViewEntity$ = 8					; size = 4
_lpTgtViewEntityCsr$ = 12				; size = 4
_lpOrigSrcEntityInstance$ = 16				; size = 4
_bIncludeParent$ = 20					; size = 1
_lpIncludeInfo$ = 24					; size = 4
_fnIncludeEntityAndChildren@20 PROC

; 5041 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 5042 :    LPVIEWENTITYCSR   lpChildTgtViewEntityCsr;
; 5043 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 5044 :    LPENTITYINSTANCE  lpSrcEntityInstance;
; 5045 :    LPENTITYINSTANCE  lpTgtEntityInstance;
; 5046 :    LPENTITYINSTANCE  lpChildEntityInstance;
; 5047 :    LPVIEWENTITY      lpChildTgtViewEntity;
; 5048 :    LPVIEWENTITY      lpSrcViewEntity;
; 5049 :    LPVIEWENTITY      lpSrcChildViewEntity;
; 5050 :    LPTASK            lpAllocTask = 0;

	mov	DWORD PTR _lpAllocTask$[ebp], 0

; 5051 :    LPTASK            hAllocTask = 0;

	mov	DWORD PTR _hAllocTask$[ebp], 0

; 5052 :    zSHORT            nSourceLevel;
; 5053 :    zSHORT            nTargetLevel;
; 5054 :    zSHORT            nSkipType;
; 5055 :    zSHORT            nRC;
; 5056 : 
; 5057 : #ifdef DEBUG
; 5058 :    lpSrcViewEntity = zGETPTR( lpOrigSrcEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$[ebp], eax

; 5059 : #endif
; 5060 : 
; 5061 :    // Get the OLDEST source instance for updating the target instance
; 5062 :    // information.
; 5063 :    lpSrcEntityInstance = lpOrigSrcEntityInstance;

	mov	edx, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], edx
$LN2@fnIncludeE:

; 5064 :    while ( lpSrcEntityInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN3@fnIncludeE

; 5065 :       lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
	jmp	SHORT $LN2@fnIncludeE
$LN3@fnIncludeE:

; 5066 : 
; 5067 :    // Call fnCreateEntity to create the entity for the target object.
; 5068 :    nRC = fnCreateEntity( lpIncludeInfo->lpTgtView,

	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	movzx	ecx, WORD PTR [eax+31]
	push	ecx
	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	movzx	eax, WORD PTR [edx+35]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 5069 :                          lpTgtViewEntity, lpTgtViewEntityCsr,
; 5070 :                          lpIncludeInfo->nPosition, lpIncludeInfo->bNewRoot );
; 5071 :    if ( nRC )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN21@fnIncludeE

; 5072 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnIncludeE
$LN21@fnIncludeE:

; 5073 : 
; 5074 :    // Get the target instance just created and point its record to the source
; 5075 :    // instance record.
; 5076 :    lpTgtEntityInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 5077 :    lpTgtEntityInstance->hPersistRecord = lpSrcEntityInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 5078 :    lpTgtEntityInstance->u.nInd  = lpSrcEntityInstance->u.nInd;

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 5079 : 
; 5080 :    // If the new entity is updated then set flag indicated that target OI
; 5081 :    // has been changed.  We check to see if updated is TRUE so that we can
; 5082 :    // avoid calling fnInstanceVersioned( ) whenever possible.
; 5083 :    if ( lpTgtViewEntity->bDerived == FALSE                &&
; 5084 :         lpTgtViewEntity->bDerivedPath == FALSE            &&
; 5085 :         (lpTgtEntityInstance->u.nInd.bIncluded ||
; 5086 :          lpTgtEntityInstance->u.nInd.bCreated  ||
; 5087 :          lpTgtEntityInstance->u.nInd.bUpdated)            &&
; 5088 :         lpIncludeInfo->lpTgtViewOI->bUpdatedFile == FALSE &&

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	jne	$LN22@fnIncludeE
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	SHORT $LN22@fnIncludeE
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN23@fnIncludeE
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN23@fnIncludeE
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN22@fnIncludeE
$LN23@fnIncludeE:
	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN22@fnIncludeE
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	call	_fnInstanceVersioned
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN22@fnIncludeE

; 5089 :         fnInstanceVersioned( lpTgtEntityInstance ) == FALSE )
; 5090 :    {
; 5091 :       lpIncludeInfo->lpTgtViewOI->bUpdated =

	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+36], ecx
	mov	ecx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+36], eax
$LN22@fnIncludeE:

; 5092 :          lpIncludeInfo->lpTgtViewOI->bUpdatedFile = TRUE;
; 5093 :    }
; 5094 : 
; 5095 :    // Set the include flag only if:
; 5096 :    // o  This is the first EI we've created.  We only flag the first EI as
; 5097 :    //    being included.
; 5098 :    //    All the other EIs added by "spawning" the include have their
; 5099 :    //    flags left alone.
; 5100 :    // o  The call wants the entity flagged as included; i.e. bMarkedIncluded
; 5101 :    //    is TRUE.
; 5102 :    // o  The target instance has a parent.  If it has no parent then it is
; 5103 :    //    a root EI and therefore won't be included into anything.
; 5104 :    if ( lpIncludeInfo->bFirstEntity )

	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+30]
	test	ecx, ecx
	je	SHORT $LN24@fnIncludeE

; 5105 :    {
; 5106 :       if ( lpIncludeInfo->bMarkIncluded && lpTgtEntityInstance->hParent )

	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	movsx	eax, WORD PTR [edx+33]
	test	eax, eax
	je	SHORT $LN25@fnIncludeE
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN25@fnIncludeE

; 5107 :          lpTgtEntityInstance->u.nInd.bIncluded = TRUE;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN25@fnIncludeE:

; 5108 : 
; 5109 :       // Set flag to indicate we've created the first entity.
; 5110 :       lpIncludeInfo->bFirstEntity = FALSE;

	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	BYTE PTR [edx+30], 0

; 5111 : 
; 5112 :       // Turn off flags.
; 5113 :       lpIncludeInfo->bNewRoot  = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	WORD PTR [ecx+31], ax

; 5114 :       lpIncludeInfo->nPosition = zPOS_NEXT;

	mov	edx, 3
	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	mov	WORD PTR [eax+35], dx
$LN24@fnIncludeE:

; 5115 :    }
; 5116 : 
; 5117 :    // Add the created entity into the link chain.
; 5118 :    if ( lpSrcEntityInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN26@fnIncludeE

; 5119 :       lpTgtEntityInstance->hNextLinked = lpSrcEntityInstance->hNextLinked;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
	jmp	SHORT $LN27@fnIncludeE
$LN26@fnIncludeE:

; 5120 :    else
; 5121 :       lpTgtEntityInstance->hNextLinked = zGETHNDL( lpSrcEntityInstance );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$LN27@fnIncludeE:

; 5122 : 
; 5123 :    lpSrcEntityInstance->hNextLinked = zGETHNDL( lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 5124 : 
; 5125 : #if 0
; 5126 :    // DGC 6-23-2006
; 5127 :    // We thought we would allow cross-task includes by moving the OIs to the
; 5128 :    // system task.  Unfortunately this opens tons of race-condition holes.
; 5129 :    // The views really need to be locked but we don't know all the OIs that
; 5130 :    // are linked together until we get here.  Until we figure something out,
; 5131 :    // we will not allow cross-task linking.
; 5132 :    // DGC 6-23-2006
; 5133 : 
; 5134 :    // Check to see if either the views or the OIs belong to different tasks.
; 5135 :    // If they do, we need to move the attribute record to the system or
; 5136 :    // application task.
; 5137 :    if ( lpIncludeInfo->lpTgtView->hTask != lpIncludeInfo->lpSrcView->hTask ||
; 5138 :         lpIncludeInfo->lpTgtAllocTask != lpIncludeInfo->lpSrcAllocTask )
; 5139 :    {
; 5140 :       // We know that either the source or target task is an application or
; 5141 :       // system task.  Find out which.
; 5142 :       if ( lpIncludeInfo->lpSrcAllocTask == zGETPTR( AnchorBlock->hMainTask ) )
; 5143 :          lpAllocTask = lpIncludeInfo->lpSrcAllocTask;
; 5144 :       else
; 5145 :       if ( lpIncludeInfo->lpTgtAllocTask == zGETPTR( AnchorBlock->hMainTask ) )
; 5146 :          lpAllocTask = lpIncludeInfo->lpTgtAllocTask;
; 5147 :       else
; 5148 :       if ( lpIncludeInfo->lpSrcAllocTask->bApplicationTask )
; 5149 :          lpAllocTask = lpIncludeInfo->lpSrcAllocTask;
; 5150 :       else
; 5151 :       if ( lpIncludeInfo->lpTgtAllocTask->bApplicationTask )
; 5152 :          lpAllocTask = lpIncludeInfo->lpTgtAllocTask;
; 5153 :       else
; 5154 :          // We should never get here.  If we do, then we didn't correctly
; 5155 :          // verify the views at the beginning.  Cause a crash.
; 5156 :          lpAllocTask = lpAllocTask->hNextTask;
; 5157 : 
; 5158 :       // Set the alloc task for both OIs.  One of these assignments will be
; 5159 :       // redundant.
; 5160 :       hAllocTask = zGETHNDL( lpAllocTask );
; 5161 :       lpIncludeInfo->lpTgtViewOI->hAllocTask = hAllocTask;
; 5162 :       lpIncludeInfo->lpSrcViewOI->hAllocTask = hAllocTask;
; 5163 : 
; 5164 :       // Now that we know the alloc task, move the record pointer to the
; 5165 :       // new task.
; 5166 :       lpTgtEntityInstance->hPersistRecord =
; 5167 :          fnCopyAttributeRecord( lpAllocTask,
; 5168 :                                 zGETPTR( lpSrcEntityInstance->lpViewEntity ),
; 5169 :                                 lpSrcEntityInstance->hPersistRecord), TRUE );
; 5170 :       fnDeleteAttributeRecord( zGETPTR( lpSrcEntityInstance->hViewEntity ),
; 5171 :                                lpSrcEntityInstance, TRUE );
; 5172 : 
; 5173 :       // Go through each of the linked instances and point them to the new
; 5174 :       // attribute record.
; 5175 :       for ( lpEI = zGETPTR( lpTgtEntityInstance->hNextLinked );
; 5176 :             lpEI != lpTgtEntityInstance;
; 5177 :             lpEI = zGETPTR( lpEI->hNextLinked ) )
; 5178 :       {
; 5179 :          // All ViewOIs that are contained in this linked chain need to have
; 5180 :          // to have the same hAllocTask.
; 5181 :          LPVIEWOI lpViewOI = zGETPTR( lpEI->hViewOI );
; 5182 :          lpViewOI->hAllocTask = hAllocTask;
; 5183 : 
; 5184 :          lpEI->hPersistRecord = lpTgtEntityInstance->hPersistRecord;
; 5185 :       }
; 5186 : 
; 5187 :    }
; 5188 : #endif
; 5189 : 
; 5190 :    // Go back to the newest src EI.
; 5191 :    lpSrcEntityInstance = lpOrigSrcEntityInstance;

	mov	edx, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], edx

; 5192 : 
; 5193 :    // Now loop through all the direct children of lpSrcEntityInstance and see
; 5194 :    // if they need to be copied over to the Tgt OI.  At the end of this loop,
; 5195 :    // we will call this function recursively to copy more entities.
; 5196 :    nSourceLevel = lpSrcEntityInstance->nLevel;

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nSourceLevel$[ebp], cx

; 5197 :    nSkipType = 1;  // this means to start with the next hier from the src EI

	mov	edx, 1
	mov	WORD PTR _nSkipType$[ebp], dx
$LN4@fnIncludeE:

; 5198 :    while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$LN5@fnIncludeE

; 5199 :    {
; 5200 :       LPVIEWENTITYCSR lpChildTgtByToken;
; 5201 : 
; 5202 :       switch ( nSkipType )

	movsx	ecx, WORD PTR _nSkipType$[ebp]
	mov	DWORD PTR tv189[ebp], ecx
	cmp	DWORD PTR tv189[ebp], 0
	je	SHORT $LN28@fnIncludeE
	cmp	DWORD PTR tv189[ebp], 1
	je	SHORT $LN31@fnIncludeE
	cmp	DWORD PTR tv189[ebp], 2
	je	SHORT $LN8@fnIncludeE
	jmp	SHORT $LN6@fnIncludeE
$LN28@fnIncludeE:

; 5203 :       {
; 5204 :          case 0:  // Normal case.  Just go to the next twin.
; 5205 :             if ( lpSrcEntityInstance->hNextTwin )

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN29@fnIncludeE

; 5206 :                lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
	jmp	SHORT $LN30@fnIncludeE
$LN29@fnIncludeE:

; 5207 :             else
; 5208 :                lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
$LN30@fnIncludeE:

; 5209 : 
; 5210 :             break;

	jmp	SHORT $LN6@fnIncludeE
$LN31@fnIncludeE:

; 5211 : 
; 5212 :          case 1:  // Skip to the next hier.
; 5213 :             lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 5214 :             break;

	jmp	SHORT $LN6@fnIncludeE
$LN8@fnIncludeE:

; 5215 : 
; 5216 :          case 2:  // Skip current EI and all it's twins.
; 5217 :             while ( lpSrcEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN9@fnIncludeE

; 5218 :                lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
	jmp	SHORT $LN8@fnIncludeE
$LN9@fnIncludeE:

; 5219 : 
; 5220 :             // Now go to the next hier.
; 5221 :             lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
$LN6@fnIncludeE:

; 5222 :             break;
; 5223 :       }
; 5224 : 
; 5225 :       if ( lpSrcEntityInstance == 0 )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	jne	SHORT $LN33@fnIncludeE

; 5226 :          break;

	jmp	$LN5@fnIncludeE
$LN33@fnIncludeE:

; 5227 : 
; 5228 :       // Unless told otherwise we will always skip to the next twin.
; 5229 :       nSkipType = 0;

	xor	edx, edx
	mov	WORD PTR _nSkipType$[ebp], dx

; 5230 : 
; 5231 :       // Skip all hidden entities.
; 5232 :       if ( lpSrcEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN34@fnIncludeE

; 5233 :          continue;

	jmp	$LN4@fnIncludeE
$LN34@fnIncludeE:

; 5234 : 
; 5235 :       // We are only interested in EI's that are direct children of the
; 5236 :       // original source EI.
; 5237 :       if ( lpSrcEntityInstance->nLevel > nSourceLevel + 1 )

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nSourceLevel$[ebp]
	add	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN35@fnIncludeE

; 5238 :       {
; 5239 :          nSkipType = 2;    // Skip this EI and all it's twins.

	mov	edx, 2
	mov	WORD PTR _nSkipType$[ebp], dx

; 5240 :          continue;

	jmp	$LN4@fnIncludeE
$LN35@fnIncludeE:

; 5241 :       }
; 5242 : 
; 5243 :       // If the level is <= to the original source EI then we are no longer
; 5244 :       // underneath (i.e. a child/descendent) of the original EI so we're done
; 5245 :       // looking for children.
; 5246 :       if ( lpSrcEntityInstance->nLevel <= nSourceLevel )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nSourceLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN36@fnIncludeE

; 5247 :          break;

	jmp	$LN5@fnIncludeE
$LN36@fnIncludeE:

; 5248 : 
; 5249 :       // We have a new source instance.  Make sure the new source instance is
; 5250 :       // actually in the source view (i.e. not out of view).  It will not be
; 5251 :       // in the source view ONLY IF it is a recursive instance or a child of
; 5252 :       // a recursive instance.  NOTE: Versioning DOES NOT support including
; 5253 :       // into a target with a recursive structure!!!!
; 5254 :       lpSrcViewEntityCsr =

	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax
$LN10@fnIncludeE:

; 5255 :                   zGETPTR( lpIncludeInfo->lpSrcViewCsr->hRootViewEntityCsr );
; 5256 :       while ( lpSrcViewEntityCsr &&

	cmp	DWORD PTR _lpSrcViewEntityCsr$[ebp], 0
	je	SHORT $LN11@fnIncludeE
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+2]
	je	SHORT $LN11@fnIncludeE

; 5257 :               lpSrcViewEntityCsr->hViewEntity !=
; 5258 :                                           lpSrcEntityInstance->hViewEntity )
; 5259 :       {
; 5260 :          lpSrcViewEntityCsr = zGETPTR( lpSrcViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 5261 :       }

	jmp	SHORT $LN10@fnIncludeE
$LN11@fnIncludeE:

; 5262 : 
; 5263 :       if ( lpSrcViewEntityCsr == 0 ||

	cmp	DWORD PTR _lpSrcViewEntityCsr$[ebp], 0
	je	SHORT $LN38@fnIncludeE
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	je	SHORT $LN37@fnIncludeE
$LN38@fnIncludeE:

; 5264 :            lpSrcViewEntityCsr->nLevel != lpSrcEntityInstance->nLevel )
; 5265 :       {
; 5266 :          // lpSrcEntityInstance does not belong to the current source
; 5267 :          // view (it is out of view).  Go on to the next one.
; 5268 :          nSkipType = 2;    // skip this EI and all its twins

	mov	eax, 2
	mov	WORD PTR _nSkipType$[ebp], ax

; 5269 :          continue;

	jmp	$LN4@fnIncludeE
$LN37@fnIncludeE:

; 5270 :       }
; 5271 : 
; 5272 :       lpSrcViewEntity = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$[ebp], eax

; 5273 : 
; 5274 :       // Finally, see if the current entity instance belongs in the target
; 5275 :       // Object Instance.  To do this we loop through all the view entities
; 5276 :       // starting with the root of the include (not the root of the OI).
; 5277 :       // When we find an entity that has the same:
; 5278 :       //    o entity name as the source entity
; 5279 :       //    o ER token as the source entity
; 5280 :       //    o ER relationship as the source entity
; 5281 :       //    o RelLink1 flag
; 5282 :       // then we know that the source entity should be copied (included) into
; 5283 :       // the target entity.  If we don't find an entity with the same name
; 5284 :       // then we'll use the entity that matches the other criteria (if any).
; 5285 :       lpChildTgtByToken = 0;

	mov	DWORD PTR _lpChildTgtByToken$1[ebp], 0

; 5286 :       nTargetLevel = lpTgtViewEntityCsr->nLevel;

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	cx, WORD PTR [eax+22]
	mov	WORD PTR _nTargetLevel$[ebp], cx

; 5287 :       for ( lpChildTgtViewEntityCsr = zGETPTR( lpTgtViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], eax
	jmp	SHORT $LN14@fnIncludeE
$LN12@fnIncludeE:

; 5289 :             lpChildTgtViewEntityCsr = zGETPTR( lpChildTgtViewEntityCsr->hNextHier ) )

	mov	ecx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], eax
$LN14@fnIncludeE:

; 5288 :             lpChildTgtViewEntityCsr;

	cmp	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], 0
	je	$LN13@fnIncludeE

; 5290 :       {
; 5291 :          // We're only interested in direct children of lpTgtViewEntityCsr.
; 5292 :          if ( lpChildTgtViewEntityCsr->nLevel > nTargetLevel + 1 )

	mov	eax, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nTargetLevel$[ebp]
	add	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN39@fnIncludeE

; 5293 :             continue;

	jmp	SHORT $LN12@fnIncludeE
$LN39@fnIncludeE:

; 5294 : 
; 5295 :          if ( lpChildTgtViewEntityCsr->nLevel <= nTargetLevel )

	mov	eax, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nTargetLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN40@fnIncludeE

; 5296 :          {
; 5297 :             lpChildTgtViewEntityCsr = 0;

	mov	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], 0

; 5298 :             break;  // No more child csrs to check.

	jmp	$LN13@fnIncludeE
$LN40@fnIncludeE:

; 5299 :          }
; 5300 : 
; 5301 :          lpChildTgtViewEntity = zGETPTR( lpChildTgtViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntity$[ebp], eax

; 5302 : 
; 5303 :          if ( lpSrcViewEntity->lEREntTok == lpChildTgtViewEntity->lEREntTok &&
; 5304 :               lpSrcViewEntity->lERRelTok == lpChildTgtViewEntity->lERRelTok &&

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	$LN41@fnIncludeE
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+199]
	cmp	ecx, DWORD PTR [eax+199]
	jne	$LN41@fnIncludeE
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	ecx, DWORD PTR _lpChildTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 28					; 0000001cH
	and	edx, 1
	cmp	eax, edx
	jne	SHORT $LN41@fnIncludeE

; 5305 :               lpSrcViewEntity->bRelLink1 == lpChildTgtViewEntity->bRelLink1 )
; 5306 :          {
; 5307 :             // Check to see if the entities match by name also. If they do
; 5308 :             // then we've found our man.  If not we'll save the current view
; 5309 :             // cursor in case we never find a match by name.
; 5310 :             if ( zstrcmp( lpSrcViewEntity->szName,
; 5311 :                           lpChildTgtViewEntity->szName ) == 0 )

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	mov	edx, DWORD PTR _lpChildTgtViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	cmp	ecx, eax
	jne	SHORT $LN68@fnIncludeE
	mov	ecx, DWORD PTR _lpChildTgtViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv296[ebp], eax
	jmp	SHORT $LN69@fnIncludeE
$LN68@fnIncludeE:
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	mov	edx, DWORD PTR _lpChildTgtViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN66@fnIncludeE
	mov	DWORD PTR tv295[ebp], 1
	jmp	SHORT $LN67@fnIncludeE
$LN66@fnIncludeE:
	mov	DWORD PTR tv295[ebp], -1
$LN67@fnIncludeE:
	mov	ecx, DWORD PTR tv295[ebp]
	mov	DWORD PTR tv296[ebp], ecx
$LN69@fnIncludeE:
	cmp	DWORD PTR tv296[ebp], 0
	jne	SHORT $LN42@fnIncludeE

; 5312 :             {
; 5313 :                break; // they match, so break

	jmp	SHORT $LN13@fnIncludeE

; 5314 :             }

	jmp	SHORT $LN41@fnIncludeE
$LN42@fnIncludeE:

; 5315 :             else
; 5316 :             {
; 5317 :                // If we haven't already saved the cursor then do it.
; 5318 :                if ( lpChildTgtByToken == 0 )

	cmp	DWORD PTR _lpChildTgtByToken$1[ebp], 0
	jne	SHORT $LN41@fnIncludeE

; 5319 :                   lpChildTgtByToken = lpChildTgtViewEntityCsr;

	mov	edx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	mov	DWORD PTR _lpChildTgtByToken$1[ebp], edx
$LN41@fnIncludeE:

; 5320 :             }
; 5321 :          }
; 5322 :       }

	jmp	$LN12@fnIncludeE
$LN13@fnIncludeE:

; 5323 : 
; 5324 :       // If we didn't find a csr by name maybe we found one by token.
; 5325 :       if ( lpChildTgtViewEntityCsr == 0 )

	cmp	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], 0
	jne	SHORT $LN45@fnIncludeE

; 5326 :          lpChildTgtViewEntityCsr = lpChildTgtByToken;

	mov	eax, DWORD PTR _lpChildTgtByToken$1[ebp]
	mov	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], eax
$LN45@fnIncludeE:

; 5327 : 
; 5328 :       if ( lpChildTgtViewEntityCsr != 0 )

	cmp	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], 0
	je	SHORT $LN46@fnIncludeE

; 5329 :          lpChildTgtViewEntity = zGETPTR( lpChildTgtViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntity$[ebp], eax
$LN46@fnIncludeE:

; 5330 : 
; 5331 :       // If we didn't find a csr then go on to the next EI.  Also ...
; 5332 :       // Gig, patch 9/4/92, if we find a cursor which is
; 5333 :       // derived, skip this entity instance and all children of
; 5334 :       // the current entity instance.
; 5335 :       if ( lpChildTgtViewEntityCsr == 0 || lpChildTgtViewEntity->bDerived )

	cmp	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], 0
	je	SHORT $LN48@fnIncludeE
	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	je	SHORT $LN47@fnIncludeE
$LN48@fnIncludeE:

; 5336 :       {
; 5337 :          // We can skip the current source EI and all it's twins because we know
; 5338 :          // that there is no match in the target view for the current source
; 5339 :          // entity type.
; 5340 :          nSkipType = 2;

	mov	edx, 2
	mov	WORD PTR _nSkipType$[ebp], dx

; 5341 :          continue;

	jmp	$LN4@fnIncludeE
$LN47@fnIncludeE:

; 5342 :       }
; 5343 : 
; 5344 :       // Finally check to see if the source instance has a previous version
; 5345 :       // which cannot disappear in an CancelSubobject call.
; 5346 :       if ( lpIncludeInfo->nVsnLevel != 0 ||

	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	movsx	ecx, WORD PTR [eax+28]
	test	ecx, ecx
	jne	SHORT $LN50@fnIncludeE
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	$LN49@fnIncludeE
$LN50@fnIncludeE:

; 5347 :            lpSrcEntityInstance->hPrevVsn != 0 )
; 5348 :       {
; 5349 :          // Establish the new nPrevVsn if necessary
; 5350 :          if ( lpIncludeInfo->nVsnLevel &&

	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	movsx	ecx, WORD PTR [eax+28]
	test	ecx, ecx
	je	SHORT $LN51@fnIncludeE
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpIncludeInfo$[ebp]
	movsx	edx, WORD PTR [ecx+28]
	cmp	eax, edx
	jg	SHORT $LN51@fnIncludeE

; 5351 :               lpSrcEntityInstance->nLevel <= lpIncludeInfo->nVsnLevel )
; 5352 :          {
; 5353 :             lpIncludeInfo->nVsnLevel = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	WORD PTR [ecx+28], ax
$LN51@fnIncludeE:

; 5354 :          }
; 5355 : 
; 5356 :          if ( lpIncludeInfo->nVsnLevel == 0 && lpSrcEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	movsx	eax, WORD PTR [edx+28]
	test	eax, eax
	jne	SHORT $LN52@fnIncludeE
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN52@fnIncludeE

; 5357 :             lpIncludeInfo->nVsnLevel = lpSrcEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR [edx+28], cx
$LN52@fnIncludeE:

; 5358 : 
; 5359 :          // If nVsnLevel is set, then the current source instance is part of
; 5360 :          // a source version chain, make sure this instance cannot disappear
; 5361 :          // by a CancelSubobject call at ANY LEVEL.
; 5362 :          if ( lpIncludeInfo->nVsnLevel != 0 )

	mov	edx, DWORD PTR _lpIncludeInfo$[ebp]
	movsx	eax, WORD PTR [edx+28]
	test	eax, eax
	je	SHORT $LN49@fnIncludeE

; 5363 :          {
; 5364 :             LPENTITYINSTANCE lpWrkEntityInstance = lpSrcEntityInstance;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR _lpWrkEntityInstance$2[ebp], ecx
$LN15@fnIncludeE:

; 5365 : 
; 5366 :             while ( lpWrkEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpWrkEntityInstance$2[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN17@fnIncludeE

; 5367 :                lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpWrkEntityInstance$2[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$2[ebp], eax
	jmp	SHORT $LN15@fnIncludeE
$LN17@fnIncludeE:

; 5368 : 
; 5369 :             while ( lpWrkEntityInstance )

	cmp	DWORD PTR _lpWrkEntityInstance$2[ebp], 0
	je	SHORT $LN18@fnIncludeE

; 5370 :             {
; 5371 :                if ( lpWrkEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpWrkEntityInstance$2[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN54@fnIncludeE

; 5372 :                   break;

	jmp	SHORT $LN18@fnIncludeE
$LN54@fnIncludeE:

; 5373 : 
; 5374 :                lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hParent );

	mov	eax, DWORD PTR _lpWrkEntityInstance$2[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$2[ebp], eax

; 5375 :             }

	jmp	SHORT $LN17@fnIncludeE
$LN18@fnIncludeE:

; 5376 : 
; 5377 :             // If we found an instance then we need to skip this guy and his
; 5378 :             // twins because a parent has a previous version.
; 5379 :             if ( lpWrkEntityInstance )

	cmp	DWORD PTR _lpWrkEntityInstance$2[ebp], 0
	je	SHORT $LN49@fnIncludeE

; 5380 :             {
; 5381 :                nSkipType = 2;  // Skip all twins.

	mov	edx, 2
	mov	WORD PTR _nSkipType$[ebp], dx

; 5382 :                continue;

	jmp	$LN4@fnIncludeE
$LN49@fnIncludeE:

; 5383 :             }
; 5384 :          }
; 5385 : 
; 5386 :       } // Checking version level...
; 5387 : 
; 5388 :       // Whew...if we get here then it's OK to copy the src EI to the target
; 5389 :       // OI.  We call ourselves recursively so that we do this all over again.
; 5390 :       if ( fnIncludeEntityAndChildren( lpChildTgtViewEntity,
; 5391 :                                        lpChildTgtViewEntityCsr,
; 5392 :                                        lpSrcEntityInstance,
; 5393 :                                        FALSE,  // don't try to include parent
; 5394 :                                        lpIncludeInfo ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpIncludeInfo$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	push	eax
	call	_fnIncludeEntityAndChildren@20
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN56@fnIncludeE

; 5395 :       {
; 5396 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnIncludeE
$LN56@fnIncludeE:

; 5397 :       }
; 5398 : 
; 5399 :    } // while ( TRUE )...

	jmp	$LN4@fnIncludeE
$LN5@fnIncludeE:

; 5400 : 
; 5401 :    // If we don't need to try to include the parent then return OK.
; 5402 :    if ( bIncludeParent == FALSE )

	movzx	edx, BYTE PTR _bIncludeParent$[ebp]
	test	edx, edx
	jne	SHORT $LN57@fnIncludeE

; 5403 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnIncludeE
$LN57@fnIncludeE:

; 5404 : 
; 5405 :    // If the current target view entity doesn't have a next hier then it has
; 5406 :    // no child so there's nothing to include.
; 5407 :    if ( lpTgtViewEntityCsr->hNextHier == 0 )

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+2], 0
	jne	SHORT $LN58@fnIncludeE

; 5408 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnIncludeE
$LN58@fnIncludeE:

; 5409 : 
; 5410 :    // If the source entity instance doesn't have a parent then we're done.
; 5411 :    lpSrcEntityInstance = lpOrigSrcEntityInstance;

	mov	ecx, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], ecx

; 5412 :    if ( lpSrcEntityInstance->hParent == 0 )

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	jne	SHORT $LN59@fnIncludeE

; 5413 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnIncludeE
$LN59@fnIncludeE:

; 5414 : 
; 5415 :    lpChildTgtViewEntityCsr = zGETPTR( lpTgtViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], eax

; 5416 :    lpChildTgtViewEntity    = zGETPTR( lpChildTgtViewEntityCsr->hViewEntity );

	mov	edx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntity$[ebp], eax

; 5417 : 
; 5418 :    // If the level of the child is <= the level of the TgtViewEntity then
; 5419 :    // it really isn't a child.
; 5420 :    if ( lpChildTgtViewEntity->nLevel <= lpTgtViewEntity->nLevel )

	mov	ecx, DWORD PTR _lpChildTgtViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	edx, ecx
	jg	SHORT $LN60@fnIncludeE

; 5421 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnIncludeE
$LN60@fnIncludeE:

; 5422 : 
; 5423 :    lpChildEntityInstance = lpSrcEntityInstance;

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR _lpChildEntityInstance$[ebp], edx

; 5424 :    lpSrcEntityInstance   = zGETPTR( lpSrcEntityInstance->hParent );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 5425 :    lpSrcViewEntity       = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$[ebp], eax

; 5426 :    lpSrcChildViewEntity  = zGETPTR( lpChildEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpChildEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcChildViewEntity$[ebp], eax
$LN19@fnIncludeE:

; 5427 : 
; 5428 :    while ( lpChildTgtViewEntity->lEREntTok != lpSrcViewEntity->lEREntTok      ||
; 5429 :            lpChildTgtViewEntity->lERRelTok != lpSrcChildViewEntity->lERRelTok ||
; 5430 :            lpChildTgtViewEntity->bRelLink1 == lpSrcChildViewEntity->bRelLink1 ||

	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	jne	SHORT $LN61@fnIncludeE
	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpSrcChildViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $LN61@fnIncludeE
	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	edx, DWORD PTR _lpSrcChildViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	cmp	ecx, eax
	je	SHORT $LN61@fnIncludeE
	mov	ecx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	add	ecx, 1
	cmp	edx, ecx
	je	SHORT $LN20@fnIncludeE
$LN61@fnIncludeE:

; 5431 :            lpChildTgtViewEntityCsr->nLevel != lpTgtViewEntityCsr->nLevel + 1 )
; 5432 :    {
; 5433 :       lpChildTgtViewEntityCsr = zGETPTR( lpChildTgtViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], eax

; 5434 : 
; 5435 :       // If csr is 0 then there is no match for the parent so just return.
; 5436 :       if ( lpChildTgtViewEntityCsr == 0 )

	cmp	DWORD PTR _lpChildTgtViewEntityCsr$[ebp], 0
	jne	SHORT $LN62@fnIncludeE

; 5437 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnIncludeE
$LN62@fnIncludeE:

; 5438 : 
; 5439 :       lpChildTgtViewEntity = zGETPTR( lpChildTgtViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildTgtViewEntity$[ebp], eax

; 5440 : 
; 5441 :       // If the level of the child is <= the level of the TgtViewEntity then
; 5442 :       // we have reached the end of the children and there's no match.
; 5443 :       if ( lpChildTgtViewEntity->nLevel <= lpTgtViewEntity->nLevel )

	mov	eax, DWORD PTR _lpChildTgtViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jg	SHORT $LN63@fnIncludeE

; 5444 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnIncludeE
$LN63@fnIncludeE:

; 5445 :    }

	jmp	$LN19@fnIncludeE
$LN20@fnIncludeE:

; 5446 : 
; 5447 :    // Copy the parent src EI to the target OI.
; 5448 :    if ( fnIncludeEntityAndChildren( lpChildTgtViewEntity,
; 5449 :                                     lpChildTgtViewEntityCsr,
; 5450 :                                     lpSrcEntityInstance,
; 5451 :                                     TRUE,  // try including the parent as well
; 5452 :                                     lpIncludeInfo ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpIncludeInfo$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpChildTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpChildTgtViewEntity$[ebp]
	push	ecx
	call	_fnIncludeEntityAndChildren@20
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN64@fnIncludeE

; 5453 :    {
; 5454 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnIncludeE
$LN64@fnIncludeE:

; 5455 :    }
; 5456 : 
; 5457 :    return( 0 );

	xor	eax, eax
$LN1@fnIncludeE:

; 5458 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnIncludeEntityAndChildren@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_hViewEntity$ = -24					; size = 4
_hParentEntityInstance$ = -20				; size = 4
_lpViewEntity$ = -16					; size = 4
_lpParentViewEntity$ = -12				; size = 4
_lpWkInstance2$ = -8					; size = 4
_lpWkInstance1$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_lpParentEntityInstance$ = 12				; size = 4
_lERRelTok$ = 16					; size = 4
_fnInstanceChildOfInstanceForRel PROC

; 4933 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4934 :    LPVIEWENTITY     lpViewEntity;
; 4935 :    LPENTITYINSTANCE lpWkInstance1;
; 4936 :    LPENTITYINSTANCE lpWkInstance2;
; 4937 :    LPVIEWENTITY     hViewEntity;
; 4938 :    LPVIEWENTITY     lpParentViewEntity;
; 4939 :    zPVOID           hParentEntityInstance = zGETHNDL( lpParentEntityInstance );

	mov	eax, DWORD PTR _lpParentEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hParentEntityInstance$[ebp], eax
$LN2@fnInstance:

; 4940 : 
; 4941 :    while ( lpEntityInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN3@fnInstance

; 4942 :       lpEntityInstance = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN2@fnInstance
$LN3@fnInstance:

; 4943 : 
; 4944 :    lpWkInstance1 = lpEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpWkInstance1$[ebp], ecx
$LN4@fnInstance:

; 4945 :    while ( lpWkInstance1 )

	cmp	DWORD PTR _lpWkInstance1$[ebp], 0
	je	$LN5@fnInstance

; 4946 :    {
; 4947 :       lpViewEntity= zGETPTR( lpWkInstance1->hViewEntity );

	mov	edx, DWORD PTR _lpWkInstance1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4948 :       if ( lpWkInstance1->u.nInd.bHidden == FALSE && // Gig, 9/13/92
; 4949 :            lpWkInstance1->hParent == hParentEntityInstance &&

	mov	ecx, DWORD PTR _lpWkInstance1$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	$LN8@fnInstance
	mov	eax, DWORD PTR _lpWkInstance1$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	cmp	ecx, DWORD PTR _hParentEntityInstance$[ebp]
	jne	$LN8@fnInstance
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+199]
	cmp	eax, DWORD PTR _lERRelTok$[ebp]
	jne	$LN8@fnInstance

; 4950 :            lpViewEntity->lERRelTok == lERRelTok )
; 4951 :       {
; 4952 :          lpParentViewEntity = zGETPTR( lpParentEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$[ebp], eax

; 4953 : 
; 4954 :          TraceLineS( "--- Error ---", "" );

	push	OFFSET $SG15052
	push	OFFSET $SG15053
	call	_TraceLineS@8

; 4955 :          TraceLineS( "The relationship already exists between two entities:", "" );

	push	OFFSET $SG15054
	push	OFFSET $SG15055
	call	_TraceLineS@8

; 4956 :          TraceLineX( "Object Instance ID = ", (zLONG) lpWkInstance1->hViewOI );

	mov	eax, DWORD PTR _lpWkInstance1$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	push	OFFSET $SG15056
	call	_TraceLineX@8

; 4957 :          TraceLineS( "Parent Name = ", lpParentViewEntity->szName );

	mov	edx, DWORD PTR _lpParentViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG15057
	call	_TraceLineS@8

; 4958 :          TraceLineX( "       EI   = ", (zLONG) lpParentEntityInstance );

	mov	eax, DWORD PTR _lpParentEntityInstance$[ebp]
	push	eax
	push	OFFSET $SG15058
	call	_TraceLineX@8

; 4959 :          TraceLineI( "       Key  = ", (zLONG) lpParentEntityInstance->ulKey );

	mov	ecx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+50]
	push	edx
	push	OFFSET $SG15059
	call	_TraceLineI@8

; 4960 :          TraceLineS( "", "" );

	push	OFFSET $SG15060
	push	OFFSET $SG15061
	call	_TraceLineS@8

; 4961 :          TraceLineS( "Child Name = ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG15062
	call	_TraceLineS@8

; 4962 :          TraceLineX( "      EI   = ", (zLONG) lpWkInstance1 );

	mov	ecx, DWORD PTR _lpWkInstance1$[ebp]
	push	ecx
	push	OFFSET $SG15063
	call	_TraceLineX@8

; 4963 :          TraceLineI( "      Key  = ", (zLONG) lpWkInstance1->ulKey );

	mov	edx, DWORD PTR _lpWkInstance1$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET $SG15064
	call	_TraceLineI@8

; 4964 :          return( TRUE );

	mov	eax, 1
	jmp	$LN1@fnInstance
$LN8@fnInstance:

; 4965 :       }
; 4966 : 
; 4967 :       lpWkInstance2 = zGETPTR( lpWkInstance1->hNextVsn );

	mov	ecx, DWORD PTR _lpWkInstance1$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$[ebp], eax
$LN6@fnInstance:

; 4968 :       while ( lpWkInstance2 )

	cmp	DWORD PTR _lpWkInstance2$[ebp], 0
	je	$LN7@fnInstance

; 4969 :       {
; 4970 :          hViewEntity = zGETPTR( lpWkInstance2->hViewEntity );

	mov	eax, DWORD PTR _lpWkInstance2$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _hViewEntity$[ebp], eax

; 4971 :          if ( lpWkInstance2->u.nInd.bHidden == FALSE && // Gig, 9/13/92
; 4972 :               lpWkInstance2->hParent == hParentEntityInstance &&

	mov	edx, DWORD PTR _lpWkInstance2$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	$LN9@fnInstance
	mov	ecx, DWORD PTR _lpWkInstance2$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	cmp	edx, DWORD PTR _hParentEntityInstance$[ebp]
	jne	$LN9@fnInstance
	mov	eax, DWORD PTR _hViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+199]
	cmp	ecx, DWORD PTR _lERRelTok$[ebp]
	jne	$LN9@fnInstance

; 4973 :               hViewEntity->lERRelTok == lERRelTok )
; 4974 :          {
; 4975 :             lpParentViewEntity = zGETPTR( lpParentEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$[ebp], eax

; 4976 : 
; 4977 :             TraceLineS( "--- Error ---", "" );

	push	OFFSET $SG15066
	push	OFFSET $SG15067
	call	_TraceLineS@8

; 4978 :             TraceLineS( "The relationship already exists between two entities:", "" );

	push	OFFSET $SG15068
	push	OFFSET $SG15069
	call	_TraceLineS@8

; 4979 :             TraceLineX( "Object Instance ID = ", (zLONG) lpWkInstance2->hViewOI );

	mov	ecx, DWORD PTR _lpWkInstance2$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	push	OFFSET $SG15070
	call	_TraceLineX@8

; 4980 :             TraceLineS( "Parent Name = ", lpParentViewEntity->szName );

	mov	eax, DWORD PTR _lpParentViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG15071
	call	_TraceLineS@8

; 4981 :             TraceLineX( "       EI   = ", (zLONG) lpParentEntityInstance );

	mov	ecx, DWORD PTR _lpParentEntityInstance$[ebp]
	push	ecx
	push	OFFSET $SG15072
	call	_TraceLineX@8

; 4982 :             TraceLineI( "       Key  = ", (zLONG) lpParentEntityInstance->ulKey );

	mov	edx, DWORD PTR _lpParentEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET $SG15073
	call	_TraceLineI@8

; 4983 :             TraceLineS( "", "" );

	push	OFFSET $SG15074
	push	OFFSET $SG15075
	call	_TraceLineS@8

; 4984 :             TraceLineS( "Child Name = ", lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG15076
	call	_TraceLineS@8

; 4985 :             TraceLineX( "      EI   = ", (zLONG) lpWkInstance2 );

	mov	edx, DWORD PTR _lpWkInstance2$[ebp]
	push	edx
	push	OFFSET $SG15077
	call	_TraceLineX@8

; 4986 :             TraceLineI( "      Key  = ", (zLONG) lpWkInstance2->ulKey );

	mov	eax, DWORD PTR _lpWkInstance2$[ebp]
	mov	ecx, DWORD PTR [eax+50]
	push	ecx
	push	OFFSET $SG15078
	call	_TraceLineI@8

; 4987 :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@fnInstance
$LN9@fnInstance:

; 4988 :          }
; 4989 : 
; 4990 :          lpWkInstance2 = zGETPTR( lpWkInstance2->hNextVsn );

	mov	edx, DWORD PTR _lpWkInstance2$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance2$[ebp], eax

; 4991 :       }

	jmp	$LN6@fnInstance
$LN7@fnInstance:

; 4992 : 
; 4993 :       lpWkInstance1 = zGETPTR( lpWkInstance1->hNextLinked );

	mov	ecx, DWORD PTR _lpWkInstance1$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$[ebp], eax

; 4994 :       if ( lpWkInstance1 == 0 || lpWkInstance1 == lpEntityInstance )

	cmp	DWORD PTR _lpWkInstance1$[ebp], 0
	je	SHORT $LN11@fnInstance
	mov	eax, DWORD PTR _lpWkInstance1$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	jne	SHORT $LN10@fnInstance
$LN11@fnInstance:

; 4995 :       {
; 4996 :          lpWkInstance1 = zGETPTR( lpEntityInstance->hNextVsn );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkInstance1$[ebp], eax

; 4997 :          if ( lpWkInstance1 )

	cmp	DWORD PTR _lpWkInstance1$[ebp], 0
	je	SHORT $LN10@fnInstance

; 4998 :             lpEntityInstance = lpWkInstance1;

	mov	eax, DWORD PTR _lpWkInstance1$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN10@fnInstance:

; 4999 :       }
; 5000 :    }

	jmp	$LN4@fnInstance
$LN5@fnInstance:

; 5001 : 
; 5002 :    return( FALSE );

	xor	eax, eax
$LN1@fnInstance:

; 5003 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnInstanceChildOfInstanceForRel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpParent$1 = -24					; size = 4
_lpTask$2 = -20						; size = 4
_lpWrkSrcViewEntity$ = -16				; size = 4
_lpWrkTgtViewEntity$ = -12				; size = 4
_nRC$ = -8						; size = 2
_nInvertedParents$ = -4					; size = 2
_lpTgtView$ = 8						; size = 4
_lpTgtViewEntity$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_lpSrcViewEntity$ = 20					; size = 4
_bInclude$ = 24						; size = 1
_fnValidStructureEntity@20 PROC

; 4755 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 4756 :    LPVIEWENTITY lpWrkSrcViewEntity;
; 4757 :    LPVIEWENTITY lpWrkTgtViewEntity;
; 4758 :    zSHORT       nRC;
; 4759 :    zSHORT       nInvertedParents = 0;

	xor	eax, eax
	mov	WORD PTR _nInvertedParents$[ebp], ax

; 4760 : 
; 4761 :    // Forget it if the entity is derived.
; 4762 :    if ( lpTgtViewEntity->bDerived )

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	je	SHORT $LN8@fnValidStr

; 4763 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnValidStr
$LN8@fnValidStr:

; 4764 : 
; 4765 :    if ( bInclude )

	movzx	eax, BYTE PTR _bInclude$[ebp]
	test	eax, eax
	je	SHORT $LN9@fnValidStr

; 4766 :    {
; 4767 :       if ( lpTgtViewEntity->bRecursive  )

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN9@fnValidStr

; 4768 :       {
; 4769 :          LPTASK lpTask = zGETPTR( lpSrcView->hTask );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 4770 :          // "KZOEE138 - Attempt to include target entity with "
; 4771 :          // "           recursive behavior"
; 4772 :          fnIssueCoreError( lpTask, lpSrcView, 8, 138, 0,

	push	0
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	138					; 0000008aH
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4773 :                            lpTgtViewEntity->szName, 0 );
; 4774 :          return( zCALL_ERROR ); // Target Entity is recursive

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidStr
$LN9@fnValidStr:

; 4775 :       }
; 4776 :    }
; 4777 : 
; 4778 :    for ( lpWrkTgtViewEntity = zGETPTR( lpTgtViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkTgtViewEntity$[ebp], eax
	jmp	SHORT $LN4@fnValidStr
$LN2@fnValidStr:

; 4780 :             lpWrkTgtViewEntity->nLevel > lpTgtViewEntity->nLevel;
; 4781 :          lpWrkTgtViewEntity = zGETPTR( lpWrkTgtViewEntity->hNextHier ) )

	mov	ecx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkTgtViewEntity$[ebp], eax
$LN4@fnValidStr:

; 4779 :          lpWrkTgtViewEntity &&

	cmp	DWORD PTR _lpWrkTgtViewEntity$[ebp], 0
	je	$LN3@fnValidStr
	mov	eax, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jle	$LN3@fnValidStr

; 4782 :    {
; 4783 :       // We only care about the direct children of lpTgtViewEntity.
; 4784 :       if ( lpWrkTgtViewEntity->nLevel != lpTgtViewEntity->nLevel + 1 )

	mov	ecx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	add	ecx, 1
	cmp	edx, ecx
	je	SHORT $LN11@fnValidStr

; 4785 :          continue;

	jmp	SHORT $LN2@fnValidStr
$LN11@fnValidStr:

; 4786 : 
; 4787 :       // Forget it if the entity is derived.
; 4788 :       if ( lpWrkTgtViewEntity->bDerived )

	mov	edx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	je	SHORT $LN12@fnValidStr

; 4789 :          continue;

	jmp	SHORT $LN2@fnValidStr
$LN12@fnValidStr:

; 4790 : 
; 4791 :       // Check to see if one of the children of lpSrcViewEntity matches
; 4792 :       // lpWrkTgtViewEntity.
; 4793 :       for ( lpWrkSrcViewEntity = zGETPTR( lpSrcViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkSrcViewEntity$[ebp], eax
	jmp	SHORT $LN7@fnValidStr
$LN5@fnValidStr:

; 4795 :               lpWrkSrcViewEntity->nLevel > lpSrcViewEntity->nLevel;
; 4796 :             lpWrkSrcViewEntity = zGETPTR( lpWrkSrcViewEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpWrkSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkSrcViewEntity$[ebp], eax
$LN7@fnValidStr:

; 4794 :             lpWrkSrcViewEntity &&

	cmp	DWORD PTR _lpWrkSrcViewEntity$[ebp], 0
	je	$LN6@fnValidStr
	mov	edx, DWORD PTR _lpWrkSrcViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jle	$LN6@fnValidStr

; 4797 :       {
; 4798 :          // We only care about the direct children of lpSrcViewEntity.
; 4799 :          if ( lpWrkSrcViewEntity->nLevel != lpSrcViewEntity->nLevel + 1 )

	mov	eax, DWORD PTR _lpWrkSrcViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	add	eax, 1
	cmp	ecx, eax
	je	SHORT $LN13@fnValidStr

; 4800 :             continue;

	jmp	SHORT $LN5@fnValidStr
$LN13@fnValidStr:

; 4801 : 
; 4802 :          // Src and Tgt must have the same relationship.
; 4803 :          if ( lpWrkSrcViewEntity->lERRelTok != lpWrkTgtViewEntity->lERRelTok )

	mov	ecx, DWORD PTR _lpWrkSrcViewEntity$[ebp]
	mov	edx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+199]
	cmp	eax, DWORD PTR [edx+199]
	je	SHORT $LN14@fnValidStr

; 4804 :             continue;

	jmp	SHORT $LN5@fnValidStr
$LN14@fnValidStr:

; 4805 : 
; 4806 :          // Make sure relationship is the same direction.
; 4807 :          if ( lpWrkSrcViewEntity->bRelLink1 != lpWrkTgtViewEntity->bRelLink1 )

	mov	ecx, DWORD PTR _lpWrkSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	eax, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	cmp	edx, ecx
	je	SHORT $LN15@fnValidStr

; 4808 :             continue;

	jmp	$LN5@fnValidStr
$LN15@fnValidStr:

; 4809 : 
; 4810 :          // If we get here then the previous two checks are OK and this
; 4811 :          // implies that the EREntTok values are the same.  This means that
; 4812 :          // the current lpWrkTgtViewEntity checks out OK so let's make sure that
; 4813 :          // it's children check out.
; 4814 :          nRC = fnValidStructureEntity( lpTgtView, lpWrkTgtViewEntity,

	movzx	edx, BYTE PTR _bInclude$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWrkSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnValidStructureEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 4815 :                                        lpSrcView,
; 4816 :                                        lpWrkSrcViewEntity, bInclude );
; 4817 :          if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN16@fnValidStr

; 4818 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnValidStr
$LN16@fnValidStr:

; 4819 : 
; 4820 :          nInvertedParents += nRC;

	movsx	edx, WORD PTR _nRC$[ebp]
	movsx	eax, WORD PTR _nInvertedParents$[ebp]
	add	eax, edx
	mov	WORD PTR _nInvertedParents$[ebp], ax

; 4821 : 
; 4822 :          // We found what we wanted so break loop.
; 4823 :          break;

	jmp	SHORT $LN6@fnValidStr

; 4824 :       }

	jmp	$LN5@fnValidStr
$LN6@fnValidStr:

; 4825 : 
; 4826 :       // If lpWrkSrcViewEntity is 0 then we didn't find a child of
; 4827 :       // lpSrcViewEntity that matched so let's check the parent.
; 4828 :       if ( lpWrkSrcViewEntity == 0 ||

	cmp	DWORD PTR _lpWrkSrcViewEntity$[ebp], 0
	je	SHORT $LN18@fnValidStr
	mov	ecx, DWORD PTR _lpWrkSrcViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	edx, ecx
	jg	$LN17@fnValidStr
$LN18@fnValidStr:

; 4829 :            lpWrkSrcViewEntity->nLevel <= lpSrcViewEntity->nLevel )
; 4830 :       {
; 4831 :          if ( lpSrcViewEntity->hParent )

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	$LN17@fnValidStr

; 4832 :          {
; 4833 :             LPVIEWENTITY lpParent;
; 4834 : 
; 4835 :             // Src and Tgt must have the same relationship but it must be
; 4836 :             // reversed.
; 4837 :             if ( lpSrcViewEntity->lERRelTok == lpWrkTgtViewEntity->lERRelTok &&

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	$LN17@fnValidStr
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	edx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	cmp	ecx, eax
	je	SHORT $LN17@fnValidStr

; 4838 :                  lpSrcViewEntity->bRelLink1 != lpWrkTgtViewEntity->bRelLink1 )
; 4839 :             {
; 4840 :                // We have an inverted parent.
; 4841 :                nInvertedParents++;

	mov	cx, WORD PTR _nInvertedParents$[ebp]
	add	cx, 1
	mov	WORD PTR _nInvertedParents$[ebp], cx

; 4842 : 
; 4843 :                lpParent = zGETPTR( lpSrcViewEntity->hParent );

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$1[ebp], eax

; 4844 :                nRC = fnValidStructureEntity( lpTgtView, lpWrkTgtViewEntity,

	movzx	ecx, BYTE PTR _bInclude$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpParent$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWrkTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnValidStructureEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 4845 :                                              lpSrcView, lpParent, bInclude );
; 4846 :                if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN21@fnValidStr

; 4847 :                   return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnValidStr
$LN21@fnValidStr:

; 4848 : 
; 4849 :                nInvertedParents += nRC;

	movsx	ecx, WORD PTR _nRC$[ebp]
	movsx	edx, WORD PTR _nInvertedParents$[ebp]
	add	edx, ecx
	mov	WORD PTR _nInvertedParents$[ebp], dx

; 4850 : 
; 4851 :                // To keep from getting an error lets set lpWrkSrcViewEntity.
; 4852 :                lpWrkSrcViewEntity = lpSrcViewEntity;

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	DWORD PTR _lpWrkSrcViewEntity$[ebp], eax
$LN17@fnValidStr:

; 4853 :             }
; 4854 :          }
; 4855 :       }
; 4856 : 
; 4857 :    } // for each lpWrkTgtViewEntity...

	jmp	$LN2@fnValidStr
$LN3@fnValidStr:

; 4858 : 
; 4859 :    return( nInvertedParents );

	mov	ax, WORD PTR _nInvertedParents$[ebp]
$LN1@fnValidStr:

; 4860 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnValidStructureEntity@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lEREntTok$ = -32					; size = 4
_lpViewOI$ = -28					; size = 4
_lpViewCsr$ = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpViewEntityCsr$ = -16					; size = 4
_lpWkEntityInstance$ = -12				; size = 4
_nOffset2$ = -8						; size = 2
_nOffset1$ = -4						; size = 2
_lpEntityInstance$ = 8					; size = 4
_fnUpdateRelinkCursors PROC

; 4056 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 4057 :    zSHORT            nOffset1, nOffset2;
; 4058 :    zLONG             lEREntTok;
; 4059 :    LPVIEWCSR         lpViewCsr;
; 4060 :    LPVIEWOI          lpViewOI;
; 4061 :    LPVIEWENTITY      lpViewEntity;
; 4062 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 4063 :    LPENTITYINSTANCE  lpWkEntityInstance;
; 4064 : 
; 4065 :    lpWkEntityInstance = lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax
$LN4@fnUpdateRe:

; 4066 :    do
; 4067 :    {
; 4068 :       if ( lpWkEntityInstance->u.nInd.bHidden &&

	mov	ecx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	$LN9@fnUpdateRe
	mov	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	$LN9@fnUpdateRe

; 4069 :                                        lpWkEntityInstance->hNextTwin )
; 4070 :       {
; 4071 :          lpViewOI     = zGETPTR( lpWkEntityInstance->hViewOI );

	mov	ecx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4072 :          lpViewCsr    = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4073 :          lpViewEntity = zGETPTR( lpWkEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4074 :          nOffset1 = lpViewEntity->nHierNbr - 1;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	sub	edx, 1
	mov	WORD PTR _nOffset1$[ebp], dx

; 4075 :          if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN10@fnUpdateRe

; 4076 :          {
; 4077 :             nOffset2 = nOffset1;

	mov	dx, WORD PTR _nOffset1$[ebp]
	mov	WORD PTR _nOffset2$[ebp], dx

; 4078 :             lEREntTok = lpViewEntity->lEREntTok;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+195]
	mov	DWORD PTR _lEREntTok$[ebp], ecx

; 4079 : 
; 4080 :             lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN5@fnUpdateRe:

; 4081 :             while ( lpViewEntity->lEREntTok != lEREntTok )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+195]
	cmp	edx, DWORD PTR _lEREntTok$[ebp]
	je	SHORT $LN6@fnUpdateRe

; 4082 :                lpViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	jmp	SHORT $LN5@fnUpdateRe
$LN6@fnUpdateRe:

; 4083 : 
; 4084 :             nOffset1 = lpViewEntity->nHierNbr - 1;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	mov	WORD PTR _nOffset1$[ebp], ax

; 4085 :          }

	jmp	SHORT $LN7@fnUpdateRe
$LN10@fnUpdateRe:

; 4086 :          else
; 4087 :             nOffset2 = 0;

	xor	ecx, ecx
	mov	WORD PTR _nOffset2$[ebp], cx
$LN7@fnUpdateRe:

; 4088 : 
; 4089 :          while ( lpViewCsr )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	je	$LN9@fnUpdateRe

; 4090 :          {
; 4091 :             lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4092 :             lpViewEntityCsr += nOffset1;

	movsx	ecx, WORD PTR _nOffset1$[ebp]
	imul	edx, ecx, 30
	add	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 4093 :             if ( zGETPTR( lpViewEntityCsr->hEntityInstance ) == lpWkEntityInstance )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	jne	SHORT $LN12@fnUpdateRe

; 4094 :             {
; 4095 :                lpViewEntityCsr->hEntityInstance = lpWkEntityInstance->hNextTwin;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR [edx+26], ecx

; 4096 :             // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 4097 :             //    SysMessageBox( 0, "fnUpdateRelinkCursors1", "UNSET_CSR", -1 );
; 4098 : 
; 4099 :                fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 4100 :             }

	jmp	SHORT $LN13@fnUpdateRe
$LN12@fnUpdateRe:

; 4101 :             else
; 4102 :             if ( nOffset2 )

	movsx	eax, WORD PTR _nOffset2$[ebp]
	test	eax, eax
	je	SHORT $LN13@fnUpdateRe

; 4103 :             {
; 4104 :                lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4105 :                lpViewEntityCsr += nOffset2;

	movsx	eax, WORD PTR _nOffset2$[ebp]
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx

; 4106 :                if ( zGETPTR( lpViewEntityCsr->hEntityInstance ) == lpWkEntityInstance )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	jne	SHORT $LN13@fnUpdateRe

; 4107 :                {
; 4108 :                   lpViewEntityCsr->hEntityInstance = lpWkEntityInstance->hNextTwin;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	mov	DWORD PTR [ecx+26], eax

; 4109 :                // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 4110 :                //    SysMessageBox( 0, "fnUpdateRelinkCursors2", "UNSET_CSR", -1 );
; 4111 : 
; 4112 :                   fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN13@fnUpdateRe:

; 4113 :                }
; 4114 :             }
; 4115 : 
; 4116 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4117 :          }

	jmp	$LN7@fnUpdateRe
$LN9@fnUpdateRe:

; 4118 :       }
; 4119 : 
; 4120 :       lpWkEntityInstance = zGETPTR( lpWkEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax

; 4121 : 
; 4122 :    }  while ( lpWkEntityInstance &&

	cmp	DWORD PTR _lpWkEntityInstance$[ebp], 0
	je	SHORT $LN3@fnUpdateRe
	mov	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	jne	$LN4@fnUpdateRe
$LN3@fnUpdateRe:

; 4123 :               lpWkEntityInstance != lpEntityInstance );
; 4124 : 
; 4125 :    return( 0 );

	xor	eax, eax

; 4126 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnUpdateRelinkCursors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -44					; size = 4
_lpFirstRoot$1 = -40					; size = 4
_lpFirstRoot$2 = -36					; size = 4
tv286 = -32						; size = 4
tv255 = -28						; size = 4
tv68 = -24						; size = 4
_lpTgtLastHier$ = -20					; size = 4
_lpViewOI$ = -16					; size = 4
_lpSrcLastHier$ = -12					; size = 4
_lpEI$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpTgtEI$ = 12						; size = 4
_lpSrcViewEntityCsr$ = 16				; size = 4
_lpSrcEI$ = 20						; size = 4
_nPosition$ = 24					; size = 2
_nSrcPosition$ = 28					; size = 2
_fnMoveSubobjectAmongTwins@24 PROC

; 3591 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 3592 :    zSHORT               nRC;
; 3593 :    LPENTITYINSTANCE     lpEI;
; 3594 :    LPENTITYINSTANCE     lpTgtLastHier;
; 3595 :    LPENTITYINSTANCE     lpSrcLastHier;
; 3596 :    LPVIEWENTITY         lpViewEntity;
; 3597 :    LPVIEWOI             lpViewOI = zGETPTR( lpTgtEI->hViewOI );

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 3598 : 
; 3599 :    switch ( nPosition )

	movsx	edx, WORD PTR _nPosition$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 1
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 3
	ja	$LN2@fnMoveSubo
	mov	ecx, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN63@fnMoveSubo[ecx*4]
$LN4@fnMoveSubo:

; 3600 :    {
; 3601 :       case zPOS_FIRST:
; 3602 :          // If we're moving the src entity to the beginning this is the same
; 3603 :          // as moving src before the first entity so change lpTgtEI to be
; 3604 :          // the first twin.
; 3605 :          while ( lpTgtEI->hPrevTwin )

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN5@fnMoveSubo

; 3606 :             lpTgtEI = zGETPTR( lpTgtEI->hPrevTwin );

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEI$[ebp], eax
	jmp	SHORT $LN4@fnMoveSubo
$LN5@fnMoveSubo:

; 3607 : 
; 3608 :          // Check to make sure tgt and src aren't the same.
; 3609 :          if ( lpSrcEI == lpTgtEI )

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	cmp	edx, DWORD PTR _lpTgtEI$[ebp]
	jne	SHORT $LN28@fnMoveSubo

; 3610 :             break;

	jmp	$LN2@fnMoveSubo
$LN28@fnMoveSubo:

; 3611 : 
; 3612 :          // FALL THROUGH to perform the move.
; 3613 : 
; 3614 :       case zPOS_BEFORE:
; 3615 :          // Make sure we actually need to move something.
; 3616 :          if ( zGETPTR( lpTgtEI->hPrevTwin ) == lpSrcEI )

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSrcEI$[ebp]
	jne	SHORT $LN29@fnMoveSubo

; 3617 :             break;  // lpSrcEI is already before lpTgtEI.

	jmp	$LN2@fnMoveSubo
$LN29@fnMoveSubo:

; 3618 : 
; 3619 :          // We don't move something before/after itself.
; 3620 :          if ( lpTgtEI == lpSrcEI )

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	cmp	edx, DWORD PTR _lpSrcEI$[ebp]
	jne	SHORT $LN30@fnMoveSubo

; 3621 :             break;

	jmp	$LN2@fnMoveSubo
$LN30@fnMoveSubo:

; 3622 : 
; 3623 :          // Change hier pointers.
; 3624 :          lpSrcLastHier = fnFindLastEntityUnderParent( lpSrcEI, TRUE );

	push	1
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpSrcLastHier$[ebp], eax

; 3625 :          if ( lpSrcEI->hPrevHier )

	mov	ecx, DWORD PTR _lpSrcEI$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN31@fnMoveSubo

; 3626 :          {
; 3627 :             lpEI = zGETPTR( lpSrcEI->hPrevHier );

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3628 :             lpEI->hNextHier = lpSrcLastHier->hNextHier;

	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _lpSrcLastHier$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+14], eax
$LN31@fnMoveSubo:

; 3629 :          }
; 3630 : 
; 3631 :          if ( lpSrcLastHier->hNextHier )

	mov	ecx, DWORD PTR _lpSrcLastHier$[ebp]
	cmp	DWORD PTR [ecx+14], 0
	je	SHORT $LN32@fnMoveSubo

; 3632 :          {
; 3633 :             lpEI = zGETPTR( lpSrcLastHier->hNextHier );

	mov	edx, DWORD PTR _lpSrcLastHier$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3634 :             lpEI->hPrevHier = lpSrcEI->hPrevHier;

	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR [ecx+18], eax
$LN32@fnMoveSubo:

; 3635 :          }
; 3636 : 
; 3637 :          if ( lpTgtEI->hPrevHier )

	mov	ecx, DWORD PTR _lpTgtEI$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN33@fnMoveSubo

; 3638 :          {
; 3639 :             lpEI = zGETPTR( lpTgtEI->hPrevHier );

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3640 :             lpEI->hNextHier = zGETHNDL( lpSrcEI );

	mov	ecx, DWORD PTR _lpSrcEI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	DWORD PTR [edx+14], eax
$LN33@fnMoveSubo:

; 3641 :          }
; 3642 : 
; 3643 :          lpSrcEI->hPrevHier       = lpTgtEI->hPrevHier;

	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR _lpTgtEI$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR [eax+18], edx

; 3644 :          lpTgtEI->hPrevHier       = zGETHNDL( lpSrcLastHier );

	mov	eax, DWORD PTR _lpSrcLastHier$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR [ecx+18], eax

; 3645 :          lpSrcLastHier->hNextHier = zGETHNDL( lpTgtEI );

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcLastHier$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 3646 : 
; 3647 :          //
; 3648 :          // Change twin pointers.
; 3649 :          //
; 3650 :          if ( lpSrcEI->hPrevTwin )

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN34@fnMoveSubo

; 3651 :          {
; 3652 :             lpEI = zGETPTR( lpSrcEI->hPrevTwin );

	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3653 :             lpEI->hNextTwin = lpSrcEI->hNextTwin;

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR [edx+22], ecx
$LN34@fnMoveSubo:

; 3654 :          }
; 3655 : 
; 3656 :          if ( lpSrcEI->hNextTwin )

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN35@fnMoveSubo

; 3657 :          {
; 3658 :             lpEI = zGETPTR( lpSrcEI->hNextTwin );

	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3659 :             lpEI->hPrevTwin = lpSrcEI->hPrevTwin;

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx
$LN35@fnMoveSubo:

; 3660 :          }
; 3661 : 
; 3662 :          if ( lpTgtEI->hPrevTwin )

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN36@fnMoveSubo

; 3663 :          {
; 3664 :             lpEI = zGETPTR( lpTgtEI->hPrevTwin );

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3665 :             lpEI->hNextTwin = zGETHNDL( lpSrcEI );

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	DWORD PTR [ecx+22], eax
$LN36@fnMoveSubo:

; 3666 :          }
; 3667 : 
; 3668 :          lpSrcEI->hPrevTwin = lpTgtEI->hPrevTwin;

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 3669 :          lpTgtEI->hPrevTwin = zGETHNDL( lpSrcEI );

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 3670 :          lpSrcEI->hNextTwin = zGETHNDL( lpTgtEI );

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcEI$[ebp]
	mov	DWORD PTR [ecx+22], eax

; 3671 : 
; 3672 :          break;

	jmp	$LN2@fnMoveSubo
$LN6@fnMoveSubo:

; 3673 : 
; 3674 :       case zPOS_LAST:
; 3675 :          // If we're moving the src entity to the end this is the same
; 3676 :          // as moving src after the last entity so change lpTgtEI to be
; 3677 :          // the last twin.
; 3678 :          while ( lpTgtEI->hNextTwin )

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN7@fnMoveSubo

; 3679 :             lpTgtEI = zGETPTR( lpTgtEI->hNextTwin );

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEI$[ebp], eax
	jmp	SHORT $LN6@fnMoveSubo
$LN7@fnMoveSubo:

; 3680 : 
; 3681 :          // Check to make sure tgt and src aren't the same.
; 3682 :          if ( lpSrcEI == lpTgtEI )

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	cmp	edx, DWORD PTR _lpTgtEI$[ebp]
	jne	SHORT $LN39@fnMoveSubo

; 3683 :             break;

	jmp	$LN2@fnMoveSubo
$LN39@fnMoveSubo:

; 3684 : 
; 3685 :          // FALL THROUGH to perform the move.
; 3686 : 
; 3687 :       case zPOS_AFTER:
; 3688 :          // Make sure we actually need to move something.
; 3689 :          if ( zGETPTR( lpTgtEI->hNextTwin ) == lpSrcEI )

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSrcEI$[ebp]
	jne	SHORT $LN40@fnMoveSubo

; 3690 :             break;  // lpSrcEI is already next after lpTgtEI.

	jmp	$LN2@fnMoveSubo
$LN40@fnMoveSubo:

; 3691 : 
; 3692 :          // We don't move something before/after itself.
; 3693 :          if ( lpTgtEI == lpSrcEI )

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	cmp	edx, DWORD PTR _lpSrcEI$[ebp]
	jne	SHORT $LN41@fnMoveSubo

; 3694 :             break;

	jmp	$LN2@fnMoveSubo
$LN41@fnMoveSubo:

; 3695 : 
; 3696 :          //
; 3697 :          // Change hier pointers.
; 3698 :          //
; 3699 : 
; 3700 :          lpSrcLastHier = fnFindLastEntityUnderParent( lpSrcEI, TRUE );

	push	1
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpSrcLastHier$[ebp], eax

; 3701 :          lpTgtLastHier = fnFindLastEntityUnderParent( lpTgtEI, TRUE );

	push	1
	mov	ecx, DWORD PTR _lpTgtEI$[ebp]
	push	ecx
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpTgtLastHier$[ebp], eax

; 3702 : 
; 3703 :          if ( lpSrcEI->hPrevHier )

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN42@fnMoveSubo

; 3704 :          {
; 3705 :             lpEI = zGETPTR( lpSrcEI->hPrevHier );

	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3706 :             lpEI->hNextHier = lpSrcLastHier->hNextHier;

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _lpSrcLastHier$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+14], ecx
$LN42@fnMoveSubo:

; 3707 :          }
; 3708 : 
; 3709 :          if ( lpSrcLastHier->hNextHier )

	mov	edx, DWORD PTR _lpSrcLastHier$[ebp]
	cmp	DWORD PTR [edx+14], 0
	je	SHORT $LN43@fnMoveSubo

; 3710 :          {
; 3711 :             lpEI = zGETPTR( lpSrcLastHier->hNextHier );

	mov	eax, DWORD PTR _lpSrcLastHier$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3712 :             lpEI->hPrevHier = lpSrcEI->hPrevHier;

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	mov	DWORD PTR [edx+18], ecx
$LN43@fnMoveSubo:

; 3713 :          }
; 3714 : 
; 3715 :          if ( lpTgtLastHier->hNextHier )

	mov	edx, DWORD PTR _lpTgtLastHier$[ebp]
	cmp	DWORD PTR [edx+14], 0
	je	SHORT $LN44@fnMoveSubo

; 3716 :          {
; 3717 :             lpEI = zGETPTR( lpTgtLastHier->hNextHier );

	mov	eax, DWORD PTR _lpTgtLastHier$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3718 :             lpEI->hPrevHier = zGETHNDL( lpSrcLastHier );

	mov	edx, DWORD PTR _lpSrcLastHier$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	DWORD PTR [ecx+18], eax
$LN44@fnMoveSubo:

; 3719 :          }
; 3720 : 
; 3721 :          lpSrcEI->hPrevHier       = zGETHNDL( lpTgtLastHier );

	mov	edx, DWORD PTR _lpTgtLastHier$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcEI$[ebp]
	mov	DWORD PTR [ecx+18], eax

; 3722 :          lpSrcLastHier->hNextHier = lpTgtLastHier->hNextHier;

	mov	edx, DWORD PTR _lpSrcLastHier$[ebp]
	mov	eax, DWORD PTR _lpTgtLastHier$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+14], ecx

; 3723 :          lpTgtLastHier->hNextHier = zGETHNDL( lpSrcEI );

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtLastHier$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 3724 : 
; 3725 :          //
; 3726 :          // Change twin pointers.
; 3727 :          //
; 3728 :          if ( lpSrcEI->hPrevTwin )

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN45@fnMoveSubo

; 3729 :          {
; 3730 :             lpEI = zGETPTR( lpSrcEI->hPrevTwin );

	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3731 :             lpEI->hNextTwin = lpSrcEI->hNextTwin;

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR [edx+22], ecx
$LN45@fnMoveSubo:

; 3732 :          }
; 3733 : 
; 3734 :          if ( lpSrcEI->hNextTwin )

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN46@fnMoveSubo

; 3735 :          {
; 3736 :             lpEI = zGETPTR( lpSrcEI->hNextTwin );

	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3737 :             lpEI->hPrevTwin = lpSrcEI->hPrevTwin;

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx
$LN46@fnMoveSubo:

; 3738 :          }
; 3739 : 
; 3740 :          if ( lpTgtEI->hNextTwin )

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN47@fnMoveSubo

; 3741 :          {
; 3742 :             lpEI = zGETPTR( lpTgtEI->hNextTwin );

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 3743 :             lpEI->hPrevTwin = zGETHNDL( lpSrcEI );

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	DWORD PTR [ecx+26], eax
$LN47@fnMoveSubo:

; 3744 :          }
; 3745 : 
; 3746 :          lpSrcEI->hPrevTwin = zGETHNDL( lpTgtEI );

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcEI$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 3747 :          lpSrcEI->hNextTwin = lpTgtEI->hNextTwin;

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR [edx+22], ecx

; 3748 :          lpTgtEI->hNextTwin = zGETHNDL( lpSrcEI );

	mov	edx, DWORD PTR _lpSrcEI$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR [ecx+22], eax
$LN2@fnMoveSubo:

; 3749 : 
; 3750 :          break;
; 3751 :    }
; 3752 : 
; 3753 :    // Change cursor position of the source view.
; 3754 :    switch ( nSrcPosition )

	movsx	edx, WORD PTR _nSrcPosition$[ebp]
	mov	DWORD PTR tv255[ebp], edx
	mov	eax, DWORD PTR tv255[ebp]
	sub	eax, 1
	mov	DWORD PTR tv255[ebp], eax
	cmp	DWORD PTR tv255[ebp], 3
	ja	$LN8@fnMoveSubo
	mov	ecx, DWORD PTR tv255[ebp]
	jmp	DWORD PTR $LN64@fnMoveSubo[ecx*4]
$LN48@fnMoveSubo:

; 3755 :    {
; 3756 :       case zREPOS_FIRST:
; 3757 :          lpEI = lpTgtEI;

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR _lpEI$[ebp], edx
$LN10@fnMoveSubo:

; 3758 :          while ( lpEI->hPrevTwin )

	mov	eax, DWORD PTR _lpEI$[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN11@fnMoveSubo

; 3759 :             lpEI = zGETPTR( lpEI->hPrevTwin );

	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax
	jmp	SHORT $LN10@fnMoveSubo
$LN11@fnMoveSubo:

; 3760 : 
; 3761 :          lpSrcViewEntityCsr->hEntityInstance = zGETHNDL( lpEI );

	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 3762 :          break;

	jmp	SHORT $LN8@fnMoveSubo
$LN49@fnMoveSubo:

; 3763 : 
; 3764 :       case zREPOS_LAST:
; 3765 :          lpEI = lpTgtEI;

	mov	edx, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR _lpEI$[ebp], edx
$LN12@fnMoveSubo:

; 3766 :          while ( lpEI->hNextTwin )

	mov	eax, DWORD PTR _lpEI$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN13@fnMoveSubo

; 3767 :             lpEI = zGETPTR( lpEI->hNextTwin );

	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax
	jmp	SHORT $LN12@fnMoveSubo
$LN13@fnMoveSubo:

; 3768 : 
; 3769 :          lpSrcViewEntityCsr->hEntityInstance = zGETHNDL( lpEI );

	mov	eax, DWORD PTR _lpEI$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 3770 :          break;

	jmp	SHORT $LN8@fnMoveSubo
$LN50@fnMoveSubo:

; 3771 : 
; 3772 :       case zREPOS_BEFORE:
; 3773 :          lpSrcViewEntityCsr->hEntityInstance = lpSrcEI->hPrevTwin;

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 3774 :          break;

	jmp	SHORT $LN8@fnMoveSubo
$LN51@fnMoveSubo:

; 3775 : 
; 3776 :       case zREPOS_AFTER:
; 3777 :          lpSrcViewEntityCsr->hEntityInstance = lpSrcEI->hNextTwin;

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR [edx+26], ecx
$LN8@fnMoveSubo:

; 3778 :          break;
; 3779 : 
; 3780 :       case zREPOS_NONE:
; 3781 :          // Leave lpSrcViewEntityCsr as it is.
; 3782 :          break;
; 3783 :    }
; 3784 : 
; 3785 :    if ( lpSrcViewEntityCsr->hEntityInstance == NULL_CSR )

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 0
	jne	SHORT $LN53@fnMoveSubo

; 3786 :       lpSrcViewEntityCsr->hEntityInstance = UNSET_CSR;

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+26], 1
$LN53@fnMoveSubo:

; 3787 : 
; 3788 :    if ( lpSrcViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	$LN54@fnMoveSubo

; 3789 :    {
; 3790 :    // if ( lpSrcViewEntityCsr->hEntityInstance == UNSET_CSR )
; 3791 :    //    SysMessageBox( 0, "fnMoveSubobjectAmongTwins", "UNSET_CSR", -1 );
; 3792 : 
; 3793 :        // We can't allow the root entity to be null so reset it.
; 3794 :       if ( lpSrcViewEntityCsr->hParent == 0 )

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	$LN56@fnMoveSubo

; 3795 :       {
; 3796 :          LPENTITYINSTANCE lpFirstRoot;
; 3797 : 
; 3798 :          switch ( nSrcPosition )

	movsx	eax, WORD PTR _nSrcPosition$[ebp]
	mov	DWORD PTR tv286[ebp], eax
	mov	ecx, DWORD PTR tv286[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv286[ebp], ecx
	cmp	DWORD PTR tv286[ebp], 3
	ja	SHORT $LN14@fnMoveSubo
	mov	edx, DWORD PTR tv286[ebp]
	jmp	DWORD PTR $LN65@fnMoveSubo[edx*4]
$LN58@fnMoveSubo:

; 3799 :          {
; 3800 :             case zREPOS_BEFORE:
; 3801 :             case zREPOS_FIRST:
; 3802 :                lpEI = lpTgtEI;

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR _lpEI$[ebp], eax
$LN16@fnMoveSubo:

; 3803 :                while ( lpEI->hPrevTwin )

	mov	ecx, DWORD PTR _lpEI$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN17@fnMoveSubo

; 3804 :                   lpEI = zGETPTR( lpEI->hPrevTwin );

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax
	jmp	SHORT $LN16@fnMoveSubo
$LN17@fnMoveSubo:

; 3805 : 
; 3806 :                lpSrcViewEntityCsr->hEntityInstance = zGETHNDL( lpEI );

	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 3807 :             // if ( lpSrcViewEntityCsr->hEntityInstance == UNSET_CSR )
; 3808 :             //    SysMessageBox( 0, "fnMoveSubobjectAmongTwins1", "UNSET_CSR", -1 );
; 3809 : 
; 3810 :                break;

	jmp	SHORT $LN14@fnMoveSubo
$LN59@fnMoveSubo:

; 3811 : 
; 3812 :             case zREPOS_AFTER:
; 3813 :             case zREPOS_LAST:
; 3814 :                lpEI = lpTgtEI;

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR _lpEI$[ebp], eax
$LN18@fnMoveSubo:

; 3815 :                while ( lpEI->hNextTwin )

	mov	ecx, DWORD PTR _lpEI$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN19@fnMoveSubo

; 3816 :                   lpEI = zGETPTR( lpEI->hNextTwin );

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax
	jmp	SHORT $LN18@fnMoveSubo
$LN19@fnMoveSubo:

; 3817 : 
; 3818 :                lpSrcViewEntityCsr->hEntityInstance = zGETHNDL( lpEI );

	mov	ecx, DWORD PTR _lpEI$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax
$LN14@fnMoveSubo:

; 3819 :             // if ( lpSrcViewEntityCsr->hEntityInstance == UNSET_CSR )
; 3820 :             //    SysMessageBox( 0, "fnMoveSubobjectAmongTwins2", "UNSET_CSR", -1 );
; 3821 : 
; 3822 :                break;
; 3823 :          }
; 3824 : 
; 3825 :          // Make sure ViewOI is pointing to the first EI.
; 3826 :          for ( lpFirstRoot = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstRoot$2[ebp], eax
	jmp	SHORT $LN22@fnMoveSubo
$LN20@fnMoveSubo:

; 3828 :                lpFirstRoot = zGETPTR( lpFirstRoot->hPrevTwin ) )

	mov	edx, DWORD PTR _lpFirstRoot$2[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstRoot$2[ebp], eax
$LN22@fnMoveSubo:

; 3827 :                lpFirstRoot->hPrevTwin;

	mov	ecx, DWORD PTR _lpFirstRoot$2[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN21@fnMoveSubo

; 3829 :          {
; 3830 :             // Nothing needs to be done here.
; 3831 :          }

	jmp	SHORT $LN20@fnMoveSubo
$LN21@fnMoveSubo:

; 3832 : 
; 3833 :          lpViewOI->hRootEntityInstance = zGETHNDL( lpFirstRoot );

	mov	edx, DWORD PTR _lpFirstRoot$2[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 3834 : 
; 3835 :          nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 3836 :       }

	jmp	SHORT $LN57@fnMoveSubo
$LN56@fnMoveSubo:

; 3837 :       else
; 3838 :          nRC = zCURSOR_UNDEFINED;

	mov	eax, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], ax
$LN57@fnMoveSubo:

; 3839 :    }

	jmp	SHORT $LN55@fnMoveSubo
$LN54@fnMoveSubo:

; 3840 :    else
; 3841 :       nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx
$LN55@fnMoveSubo:

; 3842 : 
; 3843 :    // Make sure ViewOI is pointing to the first EI.
; 3844 :    if ( lpSrcViewEntityCsr->hParent == 0 )

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+10], 0
	jne	SHORT $LN60@fnMoveSubo

; 3845 :    {
; 3846 :       LPENTITYINSTANCE lpFirstRoot;
; 3847 : 
; 3848 :       for ( lpFirstRoot = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstRoot$1[ebp], eax
	jmp	SHORT $LN25@fnMoveSubo
$LN23@fnMoveSubo:

; 3850 :             lpFirstRoot = zGETPTR( lpFirstRoot->hPrevTwin ) )

	mov	edx, DWORD PTR _lpFirstRoot$1[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstRoot$1[ebp], eax
$LN25@fnMoveSubo:

; 3849 :             lpFirstRoot->hPrevTwin;

	mov	ecx, DWORD PTR _lpFirstRoot$1[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN24@fnMoveSubo

; 3851 :       {
; 3852 :          // Nothing needs to be done here.
; 3853 :       }

	jmp	SHORT $LN23@fnMoveSubo
$LN24@fnMoveSubo:

; 3854 : 
; 3855 :       lpViewOI->hRootEntityInstance = zGETHNDL( lpFirstRoot );

	mov	edx, DWORD PTR _lpFirstRoot$1[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 3856 : 
; 3857 :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN60@fnMoveSubo:

; 3858 :    }
; 3859 : 
; 3860 :    // If the entity has autosequencing then we need to set the update flags.
; 3861 :    lpViewEntity = zGETPTR( lpTgtEI->hViewEntity );

	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 3862 :    if ( lpViewEntity->bAutoSeq )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	je	SHORT $LN61@fnMoveSubo

; 3863 :    {
; 3864 :       lpSrcEI->u.nInd.bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpSrcEI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4
	mov	eax, DWORD PTR _lpSrcEI$[ebp]
	mov	DWORD PTR [eax+6], edx

; 3865 :       lpTgtEI->u.nInd.bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpTgtEI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 4
	mov	eax, DWORD PTR _lpTgtEI$[ebp]
	mov	DWORD PTR [eax+6], edx

; 3866 : 
; 3867 :       // Set target instance as updated.
; 3868 :       lpViewOI->bUpdatedFile = lpViewOI->bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN61@fnMoveSubo:

; 3869 :    }
; 3870 : 
; 3871 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 3872 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN63@fnMoveSubo:
	DD	$LN4@fnMoveSubo
	DD	$LN6@fnMoveSubo
	DD	$LN39@fnMoveSubo
	DD	$LN28@fnMoveSubo
$LN64@fnMoveSubo:
	DD	$LN48@fnMoveSubo
	DD	$LN49@fnMoveSubo
	DD	$LN51@fnMoveSubo
	DD	$LN50@fnMoveSubo
$LN65@fnMoveSubo:
	DD	$LN58@fnMoveSubo
	DD	$LN59@fnMoveSubo
	DD	$LN59@fnMoveSubo
	DD	$LN58@fnMoveSubo
_fnMoveSubobjectAmongTwins@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpTgtViewCsr$ = -292					; size = 4
tv174 = -288						; size = 4
_lpWkTgtViewEntity$1 = -284				; size = 4
_lpViewCsr$ = -280					; size = 4
_bSameInstance$ = -276					; size = 2
_bNewRoot$ = -272					; size = 2
_nPositionOK$ = -268					; size = 2
tv385 = -264						; size = 4
_lpTgtViewOI$ = -260					; size = 4
_nLevelDifference$ = -256				; size = 2
_lpTgtViewEntity$ = -252				; size = 4
_nHiddenCount$ = -248					; size = 2
_nStartLevel$ = -244					; size = 2
_lpSrcViewEntity$ = -240				; size = 4
_lpSrchParentViewEntity$2 = -236			; size = 4
_lpSrcViewOI$ = -232					; size = 4
_lpSrchChildViewEntity$3 = -228				; size = 4
_lpNewEntityInstance$ = -224				; size = 4
_lpWkTgtViewEntityCsr$ = -220				; size = 4
_nResetCount$ = -216					; size = 2
_nRC$ = -212						; size = 2
_lpSrcEntityInstance$ = -208				; size = 4
_cpcEntityName$4 = -204					; size = 100
_cpcEntityName$5 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_lpWkEntityInstance$ = 8				; size = 4
_lpTgtView$ = 12					; size = 4
_lpTgtViewEntityCsr$ = 16				; size = 4
_lpSrcView$ = 20					; size = 4
_lpSrcViewEntityCsr$ = 24				; size = 4
_nPosition$ = 28					; size = 2
_nSrcPosition$ = 32					; size = 2
_lpCurrentTask$ = 36					; size = 4
_fnMoveSubobjectUnderNewParent@32 PROC

; 3258 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3259 :    LPVIEWOI          lpSrcViewOI;
; 3260 :    LPVIEWOI          lpTgtViewOI;
; 3261 :    LPVIEWCSR         lpViewCsr;
; 3262 :    LPVIEWCSR         lpTgtViewCsr = zGETPTR( lpTgtView->hViewCsr );

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewCsr$[ebp], eax

; 3263 :    LPVIEWENTITYCSR   lpWkTgtViewEntityCsr;
; 3264 :    LPENTITYINSTANCE  lpNewEntityInstance = 0;

	mov	DWORD PTR _lpNewEntityInstance$[ebp], 0

; 3265 :    LPENTITYINSTANCE  lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$[ebp], 0

; 3266 :    LPVIEWENTITY      lpSrcViewEntity = zGETPTR( lpSrcViewEntityCsr->hViewEntity );

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$[ebp], eax

; 3267 :    LPVIEWENTITY      lpTgtViewEntity = zGETPTR( lpTgtViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewEntity$[ebp], eax

; 3268 :    zSHORT            bNewRoot;
; 3269 :    zSHORT            bSameInstance;
; 3270 :    zSHORT            nStartLevel;
; 3271 :    zSHORT            nLevelDifference;
; 3272 :    zSHORT            nHiddenCount;
; 3273 :    zSHORT            nPositionOK;
; 3274 :    zSHORT            nResetCount;
; 3275 :    zSHORT            nRC;
; 3276 : 
; 3277 :    // Validate that an insert of this entity in this instance at
; 3278 :    // the specified position is valid.
; 3279 :    nPositionOK = fnValidateInsertPosition( &bNewRoot,

	movzx	eax, WORD PTR _nPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	push	110					; 0000006eH
	lea	eax, DWORD PTR _bNewRoot$[ebp]
	push	eax
	call	_fnValidateInsertPosition
	add	esp, 20					; 00000014H
	mov	WORD PTR _nPositionOK$[ebp], ax

; 3280 :                                            iMoveSubobject,
; 3281 :                                            lpTgtView,
; 3282 :                                            lpTgtViewEntityCsr,
; 3283 :                                            nPosition );
; 3284 :    if ( nPositionOK < 0 )

	movsx	ecx, WORD PTR _nPositionOK$[ebp]
	test	ecx, ecx
	jge	SHORT $LN25@fnMoveSubo

; 3285 :    {
; 3286 :    // fnOperationReturn( iMoveSubobject, lpCurrentTask );
; 3287 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnMoveSubo
$LN25@fnMoveSubo:

; 3288 :    }
; 3289 : 
; 3290 :    // Since we are not moving within the same parent, do rules checking
; 3291 :    // now to ensure that the move is OK.
; 3292 : 
; 3293 :    // Make sure entity can be included.
; 3294 :    if ( lpSrcViewEntity->bExclude == FALSE )

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN26@fnMoveSubo

; 3295 :    {
; 3296 :       zCHAR cpcEntityName[ 100 ];
; 3297 : 
; 3298 :       strcpy( cpcEntityName, "\nEntity: \t" );

	push	OFFSET $SG14494
	lea	ecx, DWORD PTR _cpcEntityName$5[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3299 :       strcat( cpcEntityName, lpSrcViewEntity->szName );

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _cpcEntityName$5[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3300 : 
; 3301 :       // "KZOEE106 - Rules violation"
; 3302 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	lea	ecx, DWORD PTR _cpcEntityName$5[ebp]
	push	ecx
	push	OFFSET $SG14495
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3303 :                         "Source Entity not excludable",
; 3304 :                         cpcEntityName );
; 3305 :    // fnOperationReturn( iMoveSubobject, lpCurrentTask );
; 3306 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnMoveSubo
$LN26@fnMoveSubo:

; 3307 :    }
; 3308 : 
; 3309 :    // Make sure entity can be included.
; 3310 :    if ( lpTgtViewEntity->bCreate == FALSE )

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	and	edx, 1
	jne	SHORT $LN27@fnMoveSubo

; 3311 :    {
; 3312 :       zCHAR cpcEntityName[ 100 ];
; 3313 : 
; 3314 :       strcpy( cpcEntityName, "\nEntity: \t" );

	push	OFFSET $SG14497
	lea	eax, DWORD PTR _cpcEntityName$4[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 3315 :       strcat( cpcEntityName, lpTgtViewEntity->szName );

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _cpcEntityName$4[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3316 : 
; 3317 :       // "KZOEE106 - Rules violation"
; 3318 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	lea	eax, DWORD PTR _cpcEntityName$4[ebp]
	push	eax
	push	OFFSET $SG14498
	push	0
	push	106					; 0000006aH
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3319 :                         "Entity creation not allowed",
; 3320 :                         cpcEntityName );
; 3321 :    // fnOperationReturn( iMoveSubobject, lpCurrentTask );
; 3322 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnMoveSubo
$LN27@fnMoveSubo:

; 3323 :    }
; 3324 : 
; 3325 :    lpSrcEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 3326 : 
; 3327 :    nHiddenCount = 0;

	xor	edx, edx
	mov	WORD PTR _nHiddenCount$[ebp], dx
$LN2@fnMoveSubo:

; 3328 :    while ( lpWkEntityInstance )

	cmp	DWORD PTR _lpWkEntityInstance$[ebp], 0
	je	SHORT $LN3@fnMoveSubo

; 3329 :    {
; 3330 :       if ( lpWkEntityInstance == lpSrcEntityInstance )

	mov	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	jne	SHORT $LN28@fnMoveSubo

; 3331 :       {
; 3332 :          // "KZOEE115 - Attempt to move an instance under one of its children"
; 3333 :          fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 115, 0,

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	115					; 00000073H
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3334 :                            lpSrcViewEntity->szName,
; 3335 :                            lpTgtViewEntity->szName );
; 3336 :       // fnOperationReturn( iMoveSubobject, lpCurrentTask );
; 3337 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnMoveSubo
$LN28@fnMoveSubo:

; 3338 :       }
; 3339 : 
; 3340 :       lpWkEntityInstance = zGETPTR( lpWkEntityInstance->hParent );

	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax

; 3341 :    }

	jmp	SHORT $LN2@fnMoveSubo
$LN3@fnMoveSubo:

; 3342 : 
; 3343 :    lpViewCsr   = zGETPTR( lpSrcView->hViewCsr );

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3344 :    lpSrcViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 3345 :    lpViewCsr   = zGETPTR( lpTgtView->hViewCsr );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3346 :    lpTgtViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 3347 : 
; 3348 :    bSameInstance = (lpSrcViewOI == lpTgtViewOI);

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	cmp	eax, DWORD PTR _lpTgtViewOI$[ebp]
	jne	SHORT $LN60@fnMoveSubo
	mov	DWORD PTR tv174[ebp], 1
	jmp	SHORT $LN61@fnMoveSubo
$LN60@fnMoveSubo:
	mov	DWORD PTR tv174[ebp], 0
$LN61@fnMoveSubo:
	mov	cx, WORD PTR tv174[ebp]
	mov	WORD PTR _bSameInstance$[ebp], cx

; 3349 : 
; 3350 :    nStartLevel = lpSrcViewEntityCsr->nLevel;

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ax, WORD PTR [edx+22]
	mov	WORD PTR _nStartLevel$[ebp], ax

; 3351 :    nLevelDifference = lpTgtViewEntityCsr->nLevel - nStartLevel;

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	sub	edx, eax
	mov	WORD PTR _nLevelDifference$[ebp], dx

; 3352 :    nRC = fnCreateEntity( lpTgtView, lpTgtViewEntity, lpTgtViewEntityCsr,

	movzx	ecx, WORD PTR _bNewRoot$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nPosition$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 3353 :                          nPosition, bNewRoot );
; 3354 :    if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN29@fnMoveSubo

; 3355 :    {
; 3356 :    // fnOperationReturn( iMoveSubobject, lpCurrentTask );
; 3357 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnMoveSubo
$LN29@fnMoveSubo:

; 3358 :    }
; 3359 : 
; 3360 :    lpWkTgtViewEntityCsr = lpTgtViewEntityCsr;

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	DWORD PTR _lpWkTgtViewEntityCsr$[ebp], ecx

; 3361 :    lpNewEntityInstance = zGETPTR( lpWkTgtViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewEntityInstance$[ebp], eax

; 3362 :    lpNewEntityInstance->u.nInd = lpSrcEntityInstance->u.nInd;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	eax, DWORD PTR _lpNewEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 3363 :    if ( lpSrcEntityInstance->hParent )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN30@fnMoveSubo

; 3364 :       lpSrcEntityInstance->u.nInd.bExcluded = TRUE;

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN30@fnMoveSubo:

; 3365 : 
; 3366 :    if ( lpNewEntityInstance->hParent )

	mov	edx, DWORD PTR _lpNewEntityInstance$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $LN31@fnMoveSubo

; 3367 :       lpNewEntityInstance->u.nInd.bIncluded = TRUE;

	mov	eax, DWORD PTR _lpNewEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpNewEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN31@fnMoveSubo:

; 3368 : 
; 3369 :    // Set target instance as updated.
; 3370 :    lpTgtViewOI->bUpdatedFile = lpTgtViewOI->bUpdated = TRUE;

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx

; 3371 : 
; 3372 :    // If source instance is different from target instance then flag source
; 3373 :    // instance as updated.
; 3374 :    if ( bSameInstance == FALSE )

	movsx	eax, WORD PTR _bSameInstance$[ebp]
	test	eax, eax
	jne	SHORT $LN32@fnMoveSubo

; 3375 :       lpSrcViewOI->bUpdatedFile = lpSrcViewOI->bUpdated = TRUE;

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN32@fnMoveSubo:

; 3376 : 
; 3377 :    if ( lpTgtViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN33@fnMoveSubo

; 3378 :    {
; 3379 :       SetViewToSubobject( lpTgtView, lpTgtViewEntity->szName );

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_SetViewToSubobject@8

; 3380 :       nResetCount = 1;

	mov	edx, 1
	mov	WORD PTR _nResetCount$[ebp], dx

; 3381 :    }

	jmp	SHORT $LN6@fnMoveSubo
$LN33@fnMoveSubo:

; 3382 :    else
; 3383 :       nResetCount = 0;

	xor	eax, eax
	mov	WORD PTR _nResetCount$[ebp], ax
$LN6@fnMoveSubo:

; 3384 : 
; 3385 :    for ( ; ; )
; 3386 :    {
; 3387 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN35@fnMoveSubo

; 3388 :       {
; 3389 :          // link the new instance to the old instance
; 3390 :          if ( lpSrcEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN36@fnMoveSubo

; 3391 :          {
; 3392 :             lpWkEntityInstance = zGETPTR( lpSrcEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax
$LN7@fnMoveSubo:

; 3393 :             while ( zGETPTR( lpWkEntityInstance->hNextLinked ) !=

	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	je	SHORT $LN8@fnMoveSubo

; 3394 :                                                         lpSrcEntityInstance )
; 3395 :             {
; 3396 :                lpWkEntityInstance = zGETPTR( lpWkEntityInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax

; 3397 :             }

	jmp	SHORT $LN7@fnMoveSubo
$LN8@fnMoveSubo:

; 3398 : 
; 3399 :             lpWkEntityInstance->hNextLinked = zGETHNDL( lpNewEntityInstance );

	mov	eax, DWORD PTR _lpNewEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 3400 :          }

	jmp	SHORT $LN37@fnMoveSubo
$LN36@fnMoveSubo:

; 3401 :          else
; 3402 :             lpSrcEntityInstance->hNextLinked = zGETHNDL( lpNewEntityInstance );

	mov	edx, DWORD PTR _lpNewEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$LN37@fnMoveSubo:

; 3403 : 
; 3404 :          lpNewEntityInstance->hNextLinked = zGETHNDL( lpSrcEntityInstance );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNewEntityInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax

; 3405 : 
; 3406 :          // Set Record and Rel Record.
; 3407 :          lpNewEntityInstance->hPersistRecord = lpSrcEntityInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpNewEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 3408 : 
; 3409 :          // Transfer Rel record UNLESS this is the first time and the
; 3410 :          // source entity and target entities are not the same.
; 3411 :          if ( lpSrcViewEntity == lpTgtViewEntity ||

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	cmp	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	je	SHORT $LN39@fnMoveSubo
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN35@fnMoveSubo
$LN39@fnMoveSubo:

; 3412 :               lpSrcEntityInstance->nLevel > nStartLevel )
; 3413 :          {
; 3414 :             lpNewEntityInstance->hNonPersistRecord =

	mov	eax, DWORD PTR _lpNewEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx

; 3415 :                                  lpSrcEntityInstance->hNonPersistRecord;
; 3416 :             lpSrcEntityInstance->hNonPersistRecord = 0;

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [eax+64], 0
$LN35@fnMoveSubo:

; 3417 :          }
; 3418 :       }
; 3419 : 
; 3420 :       // Mark Source entity instance is hidden.
; 3421 :       lpSrcEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 3422 :       nHiddenCount++;

	mov	cx, WORD PTR _nHiddenCount$[ebp]
	add	cx, 1
	mov	WORD PTR _nHiddenCount$[ebp], cx
$LN11@fnMoveSubo:

; 3423 : 
; 3424 :       do
; 3425 :       {
; 3426 :          lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 3427 : 
; 3428 :       } while ( lpSrcEntityInstance && lpSrcEntityInstance->u.nInd.bHidden );

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN10@fnMoveSubo
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN11@fnMoveSubo
$LN10@fnMoveSubo:

; 3429 : 
; 3430 :       if ( lpSrcEntityInstance == 0 ||

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN42@fnMoveSubo
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN41@fnMoveSubo
$LN42@fnMoveSubo:

; 3431 :            lpSrcEntityInstance->nLevel <= nStartLevel )
; 3432 :       {
; 3433 :          break;

	jmp	$LN5@fnMoveSubo
$LN41@fnMoveSubo:

; 3434 :       }
; 3435 : 
; 3436 :       if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN43@fnMoveSubo
$LN14@fnMoveSubo:

; 3437 :       {
; 3438 :          // We have a new entity instance, find the appropriate target
; 3439 :          // cursor for creating the new entity and do any subobject
; 3440 :          // processing to get the appropriate level.
; 3441 :          for ( ; ; )
; 3442 :          {
; 3443 :             lpWkTgtViewEntityCsr =

	mov	ecx, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkTgtViewEntityCsr$[ebp], eax
$LN15@fnMoveSubo:

; 3444 :                            zGETPTR( lpTgtViewCsr->hRootViewEntityCsr );
; 3445 :             while ( lpWkTgtViewEntityCsr &&

	cmp	DWORD PTR _lpWkTgtViewEntityCsr$[ebp], 0
	je	SHORT $LN16@fnMoveSubo
	mov	eax, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+2]
	je	SHORT $LN16@fnMoveSubo

; 3446 :                     lpWkTgtViewEntityCsr->hViewEntity !=
; 3447 :                                       lpSrcEntityInstance->hViewEntity )
; 3448 :             {
; 3449 :                lpWkTgtViewEntityCsr =

	mov	eax, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkTgtViewEntityCsr$[ebp], eax

; 3450 :                            zGETPTR( lpWkTgtViewEntityCsr->hNextHier );
; 3451 :             }

	jmp	SHORT $LN15@fnMoveSubo
$LN16@fnMoveSubo:

; 3452 : 
; 3453 :             // If a target cursor not found, the entity is out of view
; 3454 :             // and 1 or more resets are necessary.
; 3455 :             if ( lpWkTgtViewEntityCsr == 0 ||

	cmp	DWORD PTR _lpWkTgtViewEntityCsr$[ebp], 0
	je	SHORT $LN45@fnMoveSubo
	mov	edx, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	ecx, WORD PTR _nLevelDifference$[ebp]
	add	edx, ecx
	cmp	eax, edx
	jle	SHORT $LN44@fnMoveSubo
$LN45@fnMoveSubo:

; 3456 :                  lpWkTgtViewEntityCsr->nLevel >
; 3457 :                         lpSrcEntityInstance->nLevel + nLevelDifference )
; 3458 :             {
; 3459 :                fnResetViewFromSubobject( lpTgtView );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 3460 :                nResetCount--;

	mov	ax, WORD PTR _nResetCount$[ebp]
	sub	ax, 1
	mov	WORD PTR _nResetCount$[ebp], ax

; 3461 :                continue;

	jmp	$LN14@fnMoveSubo
$LN44@fnMoveSubo:

; 3462 :             }
; 3463 : 
; 3464 :             if ( lpWkTgtViewEntityCsr->nLevel <

	mov	ecx, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	eax, WORD PTR _nLevelDifference$[ebp]
	add	ecx, eax
	cmp	edx, ecx
	jge	$LN46@fnMoveSubo

; 3465 :                      lpSrcEntityInstance->nLevel + nLevelDifference )
; 3466 :             {
; 3467 :                LPVIEWENTITY lpSrchParentViewEntity;
; 3468 :                LPVIEWENTITY lpSrchChildViewEntity;
; 3469 :                LPVIEWENTITY lpWkTgtViewEntity =

	mov	ecx, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkTgtViewEntity$1[ebp], eax

; 3470 :                            zGETPTR( lpWkTgtViewEntityCsr->hViewEntity );
; 3471 : 
; 3472 :                if ( lpWkTgtViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpWkTgtViewEntity$1[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN47@fnMoveSubo

; 3473 :                {
; 3474 :                   SetViewToSubobject( lpTgtView, lpWkTgtViewEntity->szName );

	mov	edx, DWORD PTR _lpWkTgtViewEntity$1[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_SetViewToSubobject@8

; 3475 :                   nResetCount++;

	mov	cx, WORD PTR _nResetCount$[ebp]
	add	cx, 1
	mov	WORD PTR _nResetCount$[ebp], cx

; 3476 :                   break;

	jmp	$LN13@fnMoveSubo
$LN47@fnMoveSubo:

; 3477 :                }
; 3478 : 
; 3479 :                // If the entity is at a lower level and the entity does not
; 3480 :                // have recursive behavior, then another child of one of the
; 3481 :                // entity's parents must have recursive behavior, FIND IT and
; 3482 :                // set view to subobject for that entity type.
; 3483 :                lpSrchParentViewEntity = zGETPTR( lpWkTgtViewEntity->hParent );

	mov	edx, DWORD PTR _lpWkTgtViewEntity$1[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchParentViewEntity$2[ebp], eax
$LN17@fnMoveSubo:

; 3484 :                while ( lpSrchParentViewEntity )

	cmp	DWORD PTR _lpSrchParentViewEntity$2[ebp], 0
	je	$LN18@fnMoveSubo

; 3485 :                {
; 3486 :                   lpSrchChildViewEntity = zGETPTR( lpSrchParentViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpSrchParentViewEntity$2[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchChildViewEntity$3[ebp], eax
$LN19@fnMoveSubo:

; 3487 :                   while ( lpSrchChildViewEntity &&
; 3488 :                           lpSrchChildViewEntity->nLevel >
; 3489 :                                        lpSrchParentViewEntity->nLevel &&

	cmp	DWORD PTR _lpSrchChildViewEntity$3[ebp], 0
	je	SHORT $LN20@fnMoveSubo
	mov	eax, DWORD PTR _lpSrchChildViewEntity$3[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpSrchParentViewEntity$2[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jle	SHORT $LN20@fnMoveSubo
	mov	ecx, DWORD PTR _lpSrchChildViewEntity$3[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN48@fnMoveSubo
	mov	eax, DWORD PTR _lpSrchChildViewEntity$3[ebp]
	mov	ecx, DWORD PTR _lpSrchParentViewEntity$2[ebp]
	mov	edx, DWORD PTR [eax+195]
	cmp	edx, DWORD PTR [ecx+195]
	je	SHORT $LN20@fnMoveSubo
$LN48@fnMoveSubo:

; 3490 :                           (lpSrchChildViewEntity->bRecursive == FALSE ||
; 3491 :                            lpSrchChildViewEntity->lEREntTok !=
; 3492 :                                        lpSrchParentViewEntity->lEREntTok ) )
; 3493 :                   {
; 3494 :                      lpSrchChildViewEntity = zGETPTR( lpSrchChildViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpSrchChildViewEntity$3[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchChildViewEntity$3[ebp], eax

; 3495 :                   }

	jmp	SHORT $LN19@fnMoveSubo
$LN20@fnMoveSubo:

; 3496 : 
; 3497 :                   if ( lpSrchChildViewEntity &&

	cmp	DWORD PTR _lpSrchChildViewEntity$3[ebp], 0
	je	SHORT $LN49@fnMoveSubo
	mov	edx, DWORD PTR _lpSrchChildViewEntity$3[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpSrchParentViewEntity$2[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jle	SHORT $LN49@fnMoveSubo

; 3498 :                        lpSrchChildViewEntity->nLevel > lpSrchParentViewEntity->nLevel )
; 3499 :                   {
; 3500 :                      break;

	jmp	SHORT $LN18@fnMoveSubo
$LN49@fnMoveSubo:

; 3501 :                   }
; 3502 : 
; 3503 :                   lpSrchParentViewEntity = zGETPTR( lpSrchParentViewEntity->hParent );

	mov	eax, DWORD PTR _lpSrchParentViewEntity$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchParentViewEntity$2[ebp], eax

; 3504 :                }

	jmp	$LN17@fnMoveSubo
$LN18@fnMoveSubo:

; 3505 : 
; 3506 :                if ( lpSrchParentViewEntity )

	cmp	DWORD PTR _lpSrchParentViewEntity$2[ebp], 0
	je	SHORT $LN46@fnMoveSubo

; 3507 :                {
; 3508 :                   SetViewToSubobject( lpTgtView, lpSrchChildViewEntity->szName );

	mov	edx, DWORD PTR _lpSrchChildViewEntity$3[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_SetViewToSubobject@8

; 3509 :                   nResetCount++;

	mov	cx, WORD PTR _nResetCount$[ebp]
	add	cx, 1
	mov	WORD PTR _nResetCount$[ebp], cx
$LN46@fnMoveSubo:

; 3510 :                }
; 3511 :             }
; 3512 : 
; 3513 :             break;

	jmp	SHORT $LN13@fnMoveSubo

; 3514 :          }

	jmp	$LN14@fnMoveSubo
$LN13@fnMoveSubo:

; 3515 : 
; 3516 :          // We have a new target entity cursor, create an entity in
; 3517 :          // the target.
; 3518 :          nRC = fnCreateEntity( lpTgtView,

	push	0
	push	3
	mov	edx, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnCreateEntity@20
	mov	WORD PTR _nRC$[ebp], ax

; 3519 :                                zGETPTR( lpSrcEntityInstance->hViewEntity ),
; 3520 :                                lpWkTgtViewEntityCsr, zPOS_AFTER, 0 );
; 3521 :          if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN43@fnMoveSubo

; 3522 :          {
; 3523 :             lpNewEntityInstance = zGETPTR( lpWkTgtViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpWkTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewEntityInstance$[ebp], eax

; 3524 :             lpNewEntityInstance->u.nInd = lpSrcEntityInstance->u.nInd;

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	edx, DWORD PTR _lpNewEntityInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN43@fnMoveSubo:

; 3525 :          }
; 3526 :       }  // END if ( RC == 0 ) for subsequent create entity call
; 3527 :    }     // END for ( ; ; ) looping through child entities

	jmp	$LN6@fnMoveSubo
$LN5@fnMoveSubo:

; 3528 : 
; 3529 :    // We've created all the entities from the source, now do any subobject
; 3530 :    // resets necessary and reset the target entity's subordinate cursors.
; 3531 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN52@fnMoveSubo
$LN21@fnMoveSubo:

; 3532 :    {
; 3533 :       while ( nResetCount > 0 )

	movsx	ecx, WORD PTR _nResetCount$[ebp]
	test	ecx, ecx
	jle	SHORT $LN22@fnMoveSubo

; 3534 :       {
; 3535 :          fnResetViewFromSubobject( lpTgtView );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 3536 :          nResetCount--;

	mov	ax, WORD PTR _nResetCount$[ebp]
	sub	ax, 1
	mov	WORD PTR _nResetCount$[ebp], ax

; 3537 :       }

	jmp	SHORT $LN21@fnMoveSubo
$LN22@fnMoveSubo:

; 3538 : 
; 3539 :       fnResetCursorForViewChildren( lpTgtViewEntityCsr );

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN52@fnMoveSubo:

; 3540 :    }
; 3541 : 
; 3542 :    // Update the hidden count in the View OI and call fnReclaimHiddenInstance
; 3543 :    // if it is greater than the preset limit.
; 3544 :    lpSrcViewOI->nHiddenCount += nHiddenCount;

	movsx	edx, WORD PTR _nHiddenCount$[ebp]
	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	add	ecx, edx
	mov	edx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	WORD PTR [edx+24], cx

; 3545 : 
; 3546 :    // Now see if the user requested the cursor to be repositioned for the
; 3547 :    // src entity.
; 3548 :    switch ( nSrcPosition )

	movsx	eax, WORD PTR _nSrcPosition$[ebp]
	mov	DWORD PTR tv385[ebp], eax
	mov	ecx, DWORD PTR tv385[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv385[ebp], ecx
	cmp	DWORD PTR tv385[ebp], 3
	ja	$LN57@fnMoveSubo
	mov	edx, DWORD PTR tv385[ebp]
	jmp	DWORD PTR $LN62@fnMoveSubo[edx*4]
$LN53@fnMoveSubo:

; 3549 :    {
; 3550 :       case zREPOS_FIRST:
; 3551 :          nRC = SetCursorFirstEntity( lpSrcView, lpSrcViewEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3552 :          break;

	jmp	SHORT $LN23@fnMoveSubo
$LN54@fnMoveSubo:

; 3553 : 
; 3554 :       case zREPOS_LAST:
; 3555 :          nRC = SetCursorLastEntity( lpSrcView, lpSrcViewEntity->szName, 0 );

	push	0
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_SetCursorLastEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3556 :          break;

	jmp	SHORT $LN23@fnMoveSubo
$LN55@fnMoveSubo:

; 3557 : 
; 3558 :       case zREPOS_NEXT:
; 3559 :          nRC = SetCursorNextEntity( lpSrcView, lpSrcViewEntity->szName, 0 );

	push	0
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3560 :          break;

	jmp	SHORT $LN23@fnMoveSubo
$LN56@fnMoveSubo:

; 3561 : 
; 3562 :       case zREPOS_PREV:
; 3563 :          nRC = SetCursorPrevEntity( lpSrcView, lpSrcViewEntity->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_SetCursorPrevEntity@12
	mov	WORD PTR _nRC$[ebp], ax

; 3564 :          break;

	jmp	SHORT $LN23@fnMoveSubo
$LN57@fnMoveSubo:

; 3565 : 
; 3566 :       default:
; 3567 :          nRC = zCURSOR_UNDEFINED;

	mov	edx, -2					; fffffffeH
	mov	WORD PTR _nRC$[ebp], dx
$LN23@fnMoveSubo:

; 3568 :    }
; 3569 : 
; 3570 : #ifdef __RECLAIM__
; 3571 :    if ( nRC != zCURSOR_UNDEFINED && lpSrcViewOI->nHiddenCount > __RECLAIM_LIMIT__ )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -2					; fffffffeH
	je	SHORT $LN58@fnMoveSubo
	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	cmp	edx, 20					; 00000014H
	jle	SHORT $LN58@fnMoveSubo

; 3572 :       fnReclaimHiddenInstances( lpSrcViewOI );

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$LN58@fnMoveSubo:

; 3573 : #endif
; 3574 : 
; 3575 : // fnOperationReturn( iMoveSubobject, lpCurrentTask );
; 3576 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnMoveSubo:

; 3577 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
	npad	1
$LN62@fnMoveSubo:
	DD	$LN53@fnMoveSubo
	DD	$LN54@fnMoveSubo
	DD	$LN55@fnMoveSubo
	DD	$LN56@fnMoveSubo
_fnMoveSubobjectUnderNewParent@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpReturnEI$ = -8					; size = 4
_lpEI$ = -4						; size = 4
_lpParent$ = 8						; size = 4
_bUseTwin$ = 12						; size = 1
_fnFindLastEntityUnderParent@8 PROC

; 2089 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2090 :    LPENTITYINSTANCE lpReturnEI;
; 2091 :    LPENTITYINSTANCE lpEI;
; 2092 : 
; 2093 :    // Find the last entity under lpParent hierarchically.
; 2094 :    if ( bUseTwin && lpParent->hNextTwin )

	movzx	eax, BYTE PTR _bUseTwin$[ebp]
	test	eax, eax
	je	SHORT $LN7@fnFindLast
	mov	ecx, DWORD PTR _lpParent$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN7@fnFindLast

; 2095 :    {
; 2096 :       // lpParent has a twin.  That makes it easy.
; 2097 :       lpEI = zGETPTR( lpParent->hNextTwin );

	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax

; 2098 :       return( zGETPTR( lpEI->hPrevHier ) );

	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $LN1@fnFindLast
$LN7@fnFindLast:

; 2099 :    }
; 2100 : 
; 2101 :    // lpParent doesn't have a twin.  That means we have to loop through the
; 2102 :    // children of lpParent looking for the last entity hierarchically.
; 2103 :    lpReturnEI = lpParent;

	mov	eax, DWORD PTR _lpParent$[ebp]
	mov	DWORD PTR _lpReturnEI$[ebp], eax

; 2104 :    for ( lpEI = zGETPTR( lpParent->hNextHier );

	mov	ecx, DWORD PTR _lpParent$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax
	jmp	SHORT $LN4@fnFindLast
$LN2@fnFindLast:

; 2106 :          lpEI = zGETPTR( lpEI->hNextHier ) )

	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax
$LN4@fnFindLast:

; 2105 :          lpEI && lpEI->nLevel > lpParent->nLevel;

	cmp	DWORD PTR _lpEI$[ebp], 0
	je	SHORT $LN3@fnFindLast
	mov	edx, DWORD PTR _lpEI$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpParent$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jle	SHORT $LN3@fnFindLast
$LN5@fnFindLast:

; 2107 :    {
; 2108 :       // To try to make things faster we'll skip all twins.
; 2109 :       while ( lpEI->hNextTwin )

	mov	eax, DWORD PTR _lpEI$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN6@fnFindLast

; 2110 :          lpEI = zGETPTR( lpEI->hNextTwin );

	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$[ebp], eax
	jmp	SHORT $LN5@fnFindLast
$LN6@fnFindLast:

; 2111 : 
; 2112 :       lpReturnEI = lpEI;

	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	DWORD PTR _lpReturnEI$[ebp], eax

; 2113 :    }

	jmp	SHORT $LN2@fnFindLast
$LN3@fnFindLast:

; 2114 : 
; 2115 :    return( lpReturnEI );

	mov	eax, DWORD PTR _lpReturnEI$[ebp]
$LN1@fnFindLast:

; 2116 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnFindLastEntityUnderParent@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpNextHier$ = -296					; size = 4
_lpRPViewEntity$1 = -292				; size = 4
_nVELevel$2 = -288					; size = 2
_nVEStopLevel$3 = -284					; size = 2
_un$4 = -280						; size = 2
_vErrView$5 = -276					; size = 4
_lpScanViewEntity$6 = -272				; size = 4
_uMax$ = -268						; size = 2
_uMin$ = -264						; size = 2
_szRel$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_bCount$ = 20						; size = 1
_fnValidateCardinality PROC

; 934  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 935  :    LPENTITYINSTANCE lpNextHier;
; 936  :    // If Created or Temporal Entity Instance, ensure that it and its twins
; 937  :    // do not exceed max cardinality.
; 938  :    //
; 939  :    // If Deleted or Excluded, make sure its twins >= Min cardinality.
; 940  :    //
; 941  :    zUSHORT        uMax, uMin;
; 942  :    zCHAR          szRel[ 255 ];
; 943  : 
; 944  :    uMax = lpViewEntity->uCardMax;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	cx, WORD PTR [eax+221]
	mov	WORD PTR _uMax$[ebp], cx

; 945  :    uMin = lpViewEntity->uCardMin;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	ax, WORD PTR [edx+219]
	mov	WORD PTR _uMin$[ebp], ax

; 946  : 
; 947  :    if ( bCount && (uMax || uMin) )

	movzx	ecx, BYTE PTR _bCount$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@fnValidate
	movzx	edx, WORD PTR _uMax$[ebp]
	test	edx, edx
	jne	SHORT $LN5@fnValidate
	movzx	eax, WORD PTR _uMin$[ebp]
	test	eax, eax
	je	SHORT $LN4@fnValidate
$LN5@fnValidate:

; 948  :    {
; 949  :       zUSHORT  un = fnCountEntities( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	_fnCountEntities
	add	esp, 4
	mov	WORD PTR _un$4[ebp], ax

; 950  : 
; 951  :       if ( uMin && un < uMin )

	movzx	edx, WORD PTR _uMin$[ebp]
	test	edx, edx
	je	SHORT $LN6@fnValidate
	movzx	eax, WORD PTR _un$4[ebp]
	movzx	ecx, WORD PTR _uMin$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN6@fnValidate

; 952  :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnValidate
	jmp	SHORT $LN4@fnValidate
$LN6@fnValidate:

; 953  :       else
; 954  :       if ( uMax && un > uMax )

	movzx	edx, WORD PTR _uMax$[ebp]
	test	edx, edx
	je	SHORT $LN4@fnValidate
	movzx	eax, WORD PTR _un$4[ebp]
	movzx	ecx, WORD PTR _uMax$[ebp]
	cmp	eax, ecx
	jle	SHORT $LN4@fnValidate

; 955  :          return( 1 );

	mov	eax, 1
	jmp	$LN1@fnValidate
$LN4@fnValidate:

; 956  :    }
; 957  : 
; 958  : #if 1
; 959  :    // If there are no children for this entity instance, but the
; 960  :    // the view entity indicates there is at least one required
; 961  :    // child at the next level, scan the view entities for the
; 962  :    // immediate children of this entity and display error for
; 963  :    // the first missing required entity.
; 964  :    lpNextHier = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$[ebp], eax

; 965  :    if ( lpNextHier == 0 ||

	cmp	DWORD PTR _lpNextHier$[ebp], 0
	je	SHORT $LN10@fnValidate
	mov	ecx, DWORD PTR _lpNextHier$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	$LN9@fnValidate
$LN10@fnValidate:

; 966  :         lpNextHier->nLevel <= lpEntityInstance->nLevel )
; 967  :    {
; 968  :       LPVIEWENTITY   lpRPViewEntity;
; 969  :       zVIEW          vErrView;
; 970  : 
; 971  :       lpRPViewEntity = fnGetRecurseParentEntity( lpViewEntity );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	call	_fnGetRecurseParentEntity
	add	esp, 4
	mov	DWORD PTR _lpRPViewEntity$1[ebp], eax

; 972  :       if ( lpRPViewEntity->bRequiredChild )

	mov	eax, DWORD PTR _lpRPViewEntity$1[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 9
	and	ecx, 1
	je	$LN11@fnValidate

; 973  :       {
; 974  :          LPVIEWENTITY   lpScanViewEntity;
; 975  :          zSHORT         nVEStopLevel = lpRPViewEntity->nLevel;

	mov	edx, DWORD PTR _lpRPViewEntity$1[ebp]
	mov	ax, WORD PTR [edx+215]
	mov	WORD PTR _nVEStopLevel$3[ebp], ax

; 976  :          zSHORT         nVELevel = nVEStopLevel + 1;

	movsx	ecx, WORD PTR _nVEStopLevel$3[ebp]
	add	ecx, 1
	mov	WORD PTR _nVELevel$2[ebp], cx

; 977  : 
; 978  :          lpScanViewEntity = zGETPTR( lpRPViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpRPViewEntity$1[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanViewEntity$6[ebp], eax
$LN2@fnValidate:

; 979  :          while ( lpScanViewEntity &&

	cmp	DWORD PTR _lpScanViewEntity$6[ebp], 0
	je	$LN3@fnValidate
	mov	ecx, DWORD PTR _lpScanViewEntity$6[ebp]
	movsx	edx, WORD PTR [ecx+215]
	movsx	eax, WORD PTR _nVEStopLevel$3[ebp]
	cmp	edx, eax
	jle	$LN3@fnValidate

; 980  :                  lpScanViewEntity->nLevel > nVEStopLevel )
; 981  :          {
; 982  :             if ( lpScanViewEntity->nLevel == nVELevel &&

	mov	ecx, DWORD PTR _lpScanViewEntity$6[ebp]
	movsx	edx, WORD PTR [ecx+215]
	movsx	eax, WORD PTR _nVELevel$2[ebp]
	cmp	edx, eax
	jne	$LN12@fnValidate
	mov	ecx, DWORD PTR _lpScanViewEntity$6[ebp]
	movzx	edx, WORD PTR [ecx+219]
	test	edx, edx
	je	$LN12@fnValidate

; 983  :                  lpScanViewEntity->uCardMin )
; 984  :             {
; 985  :                CreateViewFromViewForTask( &vErrView, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vErrView$5[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 986  :                fnEstablishViewForInstance( vErrView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vErrView$5[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 987  :                SetNameForView( vErrView, "KZOEE106", lpView, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG13665
	mov	edx, DWORD PTR _vErrView$5[ebp]
	push	edx
	call	_SetNameForView@16

; 988  :                TraceLineS( "Browse view named 'KZOEE106' to see what entity "

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG13666
	call	_TraceLineS@8

; 989  :                            "instance has the error.  Entity name = ",
; 990  :                            lpViewEntity->szName );
; 991  : 
; 992  :                strcpy( szRel, "\nEntity: \t" );

	push	OFFSET $SG13667
	lea	ecx, DWORD PTR _szRel$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 993  :                strcat( szRel, lpScanViewEntity->szName );

	mov	edx, DWORD PTR _lpScanViewEntity$6[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _szRel$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 994  : 
; 995  :                // "KZOEE106 - Rules violation"
; 996  :                IssueOE_Error( lpView, 8, 106,

	lea	ecx, DWORD PTR _szRel$[ebp]
	push	ecx
	push	OFFSET $SG13668
	push	0
	push	300					; 0000012cH
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_IssueOE_Error@28

; 997  :                               zMSGQ_OBJECT_CONSTRAINT_ERROR,
; 998  :                               0,
; 999  :                               "number of entities less than minimum cardinality",
; 1000 :                               szRel );
; 1001 : 
; 1002 :                fnDropView( vErrView );

	mov	eax, DWORD PTR _vErrView$5[ebp]
	push	eax
	call	_fnDropView@4

; 1003 : 
; 1004 :                return( -2 );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@fnValidate
$LN12@fnValidate:

; 1005 :             }
; 1006 : 
; 1007 :             lpScanViewEntity = zGETPTR( lpScanViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpScanViewEntity$6[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanViewEntity$6[ebp], eax

; 1008 :          }

	jmp	$LN2@fnValidate
$LN3@fnValidate:

; 1009 : 
; 1010 :          strcpy( szRel, "\nEntity: \t" );

	push	OFFSET $SG13669
	lea	eax, DWORD PTR _szRel$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1011 :          strcat( szRel, lpViewEntity->szName );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _szRel$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1012 : 
; 1013 :          CreateViewFromViewForTask( &vErrView, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vErrView$5[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 1014 :          fnEstablishViewForInstance( vErrView, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vErrView$5[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1015 :          SetNameForView( vErrView, "KZOEE106", lpView, zLEVEL_TASK );

	push	2
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG13670
	mov	edx, DWORD PTR _vErrView$5[ebp]
	push	edx
	call	_SetNameForView@16

; 1016 :          TraceLineS( "Browse view named 'KZOEE106' to see what entity "

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG13671
	call	_TraceLineS@8

; 1017 :                      "instance has the error.  Entity name = ",
; 1018 :                      lpViewEntity->szName );
; 1019 : 
; 1020 :          // "KZOEE106 - Rules violation"
; 1021 :          IssueOE_Error( lpView, 8, 106, 0,

	lea	ecx, DWORD PTR _szRel$[ebp]
	push	ecx
	push	OFFSET $SG13672
	push	300					; 0000012cH
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_IssueOE_Error@28

; 1022 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR,
; 1023 :                         "Marked as having a required child, but none found...",
; 1024 :                         szRel );
; 1025 :          return( -2 );

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@fnValidate
$LN11@fnValidate:

; 1026 :       }
; 1027 : 
; 1028 :       return( 0 ); // no required children, all done...

	xor	eax, eax
	jmp	SHORT $LN1@fnValidate
$LN9@fnValidate:

; 1029 :    }
; 1030 : #endif
; 1031 : 
; 1032 :    return( 0 );

	xor	eax, eax
$LN1@fnValidate:

; 1033 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidateCardinality ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpScanEI$ = -8						; size = 4
_uEICount$ = -4						; size = 2
_lpEntityInstance$ = 8					; size = 4
_fnCountEntities PROC

; 874  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 875  :    LPENTITYINSTANCE  lpScanEI;
; 876  :    zUSHORT           uEICount = 0;

	xor	eax, eax
	mov	WORD PTR _uEICount$[ebp], ax

; 877  : 
; 878  :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN6@fnCountEnt

; 879  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCountEnt
$LN6@fnCountEnt:

; 880  : 
; 881  :    if ( lpEntityInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN7@fnCountEnt

; 882  :       uEICount++; // count the current instance

	mov	ax, WORD PTR _uEICount$[ebp]
	add	ax, 1
	mov	WORD PTR _uEICount$[ebp], ax
$LN7@fnCountEnt:

; 883  : 
; 884  :    // Scan to the head of the EI chain.
; 885  :    lpScanEI = zGETPTR( lpEntityInstance->hPrevTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEI$[ebp], eax
$LN2@fnCountEnt:

; 886  :    while ( lpScanEI )

	cmp	DWORD PTR _lpScanEI$[ebp], 0
	je	SHORT $LN3@fnCountEnt

; 887  :    {
; 888  :       if ( lpScanEI->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpScanEI$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN8@fnCountEnt

; 889  :          uEICount++;

	mov	dx, WORD PTR _uEICount$[ebp]
	add	dx, 1
	mov	WORD PTR _uEICount$[ebp], dx
$LN8@fnCountEnt:

; 890  : 
; 891  :       lpScanEI = zGETPTR( lpScanEI->hPrevTwin );

	mov	eax, DWORD PTR _lpScanEI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEI$[ebp], eax

; 892  :    }

	jmp	SHORT $LN2@fnCountEnt
$LN3@fnCountEnt:

; 893  : 
; 894  :    // Scan to the tail of the chain.
; 895  :    lpScanEI = zGETPTR( lpEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEI$[ebp], eax
$LN4@fnCountEnt:

; 896  :    while ( lpScanEI )

	cmp	DWORD PTR _lpScanEI$[ebp], 0
	je	SHORT $LN5@fnCountEnt

; 897  :    {
; 898  :       if ( lpScanEI->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpScanEI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN9@fnCountEnt

; 899  :          uEICount++;

	mov	ax, WORD PTR _uEICount$[ebp]
	add	ax, 1
	mov	WORD PTR _uEICount$[ebp], ax
$LN9@fnCountEnt:

; 900  : 
; 901  :       lpScanEI = zGETPTR( lpScanEI->hNextTwin );

	mov	ecx, DWORD PTR _lpScanEI$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanEI$[ebp], eax

; 902  :    }

	jmp	SHORT $LN4@fnCountEnt
$LN5@fnCountEnt:

; 903  : 
; 904  :    return( uEICount );

	mov	ax, WORD PTR _uEICount$[ebp]
$LN1@fnCountEnt:

; 905  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCountEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpScanViewEntity$ = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_fnGetRecurseParentEntity PROC

; 844  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 845  :    LPVIEWENTITY   lpScanViewEntity;
; 846  : 
; 847  :    if ( lpViewEntity->bRecursive == FALSE )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN4@fnGetRecur

; 848  :       return( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	jmp	SHORT $LN1@fnGetRecur
$LN4@fnGetRecur:

; 849  : 
; 850  :    lpScanViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanViewEntity$[ebp], eax
$LN2@fnGetRecur:

; 851  :    while ( lpScanViewEntity->lEREntTok != lpViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpScanViewEntity$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $LN3@fnGetRecur

; 852  :       lpScanViewEntity = zGETPTR( lpScanViewEntity->hParent );

	mov	ecx, DWORD PTR _lpScanViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpScanViewEntity$[ebp], eax
	jmp	SHORT $LN2@fnGetRecur
$LN3@fnGetRecur:

; 853  : 
; 854  :    return( lpScanViewEntity );

	mov	eax, DWORD PTR _lpScanViewEntity$[ebp]
$LN1@fnGetRecur:

; 855  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetRecurseParentEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -12					; size = 4
_lpNextVsn$ = -8					; size = 4
_lpDupInstance$ = -4					; size = 4
_lpNextVsnInstance$ = 8					; size = 4
_lpNewInstance$ = 12					; size = 4
_lpOldRecord$ = 16					; size = 4
_bStillPrevVsn$ = 20					; size = 1
_fnUpdateNextVsnRecordPointers PROC

; 800  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 801  :    LPENTITYINSTANCE  lpDupInstance;
; 802  :    LPENTITYINSTANCE  lpNextVsn;
; 803  :    LPVIEWENTITY      lpViewEntity = zGETPTR( lpNewInstance->hViewEntity );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 804  : 
; 805  :    lpDupInstance = lpNextVsnInstance;

	mov	edx, DWORD PTR _lpNextVsnInstance$[ebp]
	mov	DWORD PTR _lpDupInstance$[ebp], edx
$LN4@fnUpdateNe:

; 806  :    do
; 807  :    {
; 808  :       lpDupInstance->hPersistRecord = lpNewInstance->hPersistRecord;

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx

; 809  :       if ( lpNewInstance->u.nInd.bUpdated )

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN5@fnUpdateNe

; 810  :          lpDupInstance->u.nInd.bUpdated = TRUE;

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4
	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN5@fnUpdateNe:

; 811  : 
; 812  :       lpDupInstance->u.nInd.bPrevVersion = bStillPrevVsn;

	movzx	edx, BYTE PTR _bStillPrevVsn$[ebp]
	and	edx, 1
	shl	edx, 8
	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -257				; fffffeffH
	or	ecx, edx
	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 813  : 
; 814  :       // If the duplicate instance has newer version(s) with the old record,
; 815  :       // update the newer version(s) and it linked instances.
; 816  :       lpNextVsn = zGETPTR( lpDupInstance->hNextVsn );

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$[ebp], eax

; 817  :       if ( lpNextVsn &&

	cmp	DWORD PTR _lpNextVsn$[ebp], 0
	je	SHORT $LN6@fnUpdateNe
	mov	edx, DWORD PTR _lpNextVsn$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpOldRecord$[ebp]
	jne	SHORT $LN6@fnUpdateNe

; 818  :            zGETPTR( lpNextVsn->hPersistRecord ) == lpOldRecord )
; 819  :       {
; 820  :          fnUpdateNextVsnRecordPointers( lpNextVsn,

	movzx	ecx, BYTE PTR _bStillPrevVsn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOldRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNextVsn$[ebp]
	push	ecx
	call	_fnUpdateNextVsnRecordPointers
	add	esp, 16					; 00000010H
$LN6@fnUpdateNe:

; 821  :                                         lpNewInstance, lpOldRecord,
; 822  :                                         bStillPrevVsn );
; 823  :       }
; 824  : 
; 825  :       lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax

; 826  : 
; 827  :    } while ( lpDupInstance && lpDupInstance != lpNextVsnInstance );

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	SHORT $LN1@fnUpdateNe
	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	cmp	ecx, DWORD PTR _lpNextVsnInstance$[ebp]
	jne	$LN4@fnUpdateNe
$LN1@fnUpdateNe:

; 828  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnUpdateNextVsnRecordPointers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpEI1$ = -4						; size = 4
_lpEI$ = 8						; size = 4
_lpRecord$ = 12						; size = 4
_nDirection$ = 16					; size = 2
_fnVersionedForUpdate PROC

; 183  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 184  :    LPENTITYINSTANCE  lpEI1;
; 185  : 
; 186  :    if ( lpRecord != zGETPTR( lpEI->hPersistRecord ) )

	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpRecord$[ebp], eax
	je	SHORT $LN6@fnVersione

; 187  :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnVersione
$LN6@fnVersione:

; 188  : 
; 189  :    if ( nDirection )

	movsx	edx, WORD PTR _nDirection$[ebp]
	test	edx, edx
	je	$LN7@fnVersione

; 190  :    {
; 191  :       if ( lpEI->u.nInd.bPrevVersion && lpEI->hNextVsn )

	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 8
	and	ecx, 1
	je	$LN8@fnVersione
	mov	edx, DWORD PTR _lpEI$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	$LN8@fnVersione

; 192  :       {
; 193  :          if ( fnVersionedForUpdate( zGETPTR( lpEI->hNextVsn ),

	movzx	eax, WORD PTR _nDirection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnVersionedForUpdate
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN9@fnVersione

; 194  :                                     lpRecord, nDirection ))
; 195  :          {
; 196  :             return( 1 );

	mov	eax, 1
	jmp	$LN1@fnVersione
$LN9@fnVersione:

; 197  :          }
; 198  : 
; 199  :          lpEI1 = zGETPTR( lpEI->hNextLinked );

	mov	edx, DWORD PTR _lpEI$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$LN2@fnVersione:

; 200  :          while ( lpEI1 && lpEI1 != lpEI )

	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	SHORT $LN8@fnVersione
	mov	ecx, DWORD PTR _lpEI1$[ebp]
	cmp	ecx, DWORD PTR _lpEI$[ebp]
	je	SHORT $LN8@fnVersione

; 201  :          {
; 202  :             if ( lpEI1->hNextVsn &&

	mov	edx, DWORD PTR _lpEI1$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN10@fnVersione
	movzx	eax, WORD PTR _nDirection$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRecord$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnVersionedForUpdate
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN10@fnVersione

; 203  :                  fnVersionedForUpdate( zGETPTR( lpEI1->hNextVsn ),
; 204  :                                        lpRecord, nDirection ) )
; 205  :             {
; 206  :                return( 1 );

	mov	eax, 1
	jmp	$LN1@fnVersione
$LN10@fnVersione:

; 207  :             }
; 208  : 
; 209  :             lpEI1 = zGETPTR( lpEI1->hNextLinked );

	mov	edx, DWORD PTR _lpEI1$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax

; 210  :          }

	jmp	SHORT $LN2@fnVersione
$LN8@fnVersione:

; 211  :       }
; 212  : 
; 213  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnVersione
$LN7@fnVersione:

; 214  :    }
; 215  : 
; 216  :    if ( lpEI->u.nInd.bPrevVersion && lpEI->hPrevVsn )

	mov	ecx, DWORD PTR _lpEI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 8
	and	edx, 1
	je	$LN11@fnVersione
	mov	eax, DWORD PTR _lpEI$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	$LN11@fnVersione

; 217  :    {
; 218  :       if ( fnVersionedForUpdate( zGETPTR( lpEI->hPrevVsn ),

	movzx	ecx, WORD PTR _nDirection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnVersionedForUpdate
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@fnVersione

; 219  :                                  lpRecord, nDirection ) )
; 220  :       {
; 221  :          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnVersione
$LN12@fnVersione:

; 222  :       }
; 223  : 
; 224  :       lpEI1 = zGETPTR( lpEI->hNextLinked );

	mov	eax, DWORD PTR _lpEI$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax
$LN4@fnVersione:

; 225  :       while ( lpEI1 && lpEI1 != lpEI )

	cmp	DWORD PTR _lpEI1$[ebp], 0
	je	SHORT $LN11@fnVersione
	mov	edx, DWORD PTR _lpEI1$[ebp]
	cmp	edx, DWORD PTR _lpEI$[ebp]
	je	SHORT $LN11@fnVersione

; 226  :       {
; 227  :          if ( lpEI1->hPrevVsn &&

	mov	eax, DWORD PTR _lpEI1$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN13@fnVersione
	movzx	ecx, WORD PTR _nDirection$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpRecord$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnVersionedForUpdate
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN13@fnVersione

; 228  :               fnVersionedForUpdate( zGETPTR( lpEI1->hPrevVsn ),
; 229  :                                     lpRecord, nDirection ) )
; 230  :          {
; 231  :             return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnVersione
$LN13@fnVersione:

; 232  :          }
; 233  : 
; 234  :          lpEI1 = zGETPTR( lpEI1->hNextLinked );

	mov	eax, DWORD PTR _lpEI1$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI1$[ebp], eax

; 235  :       }

	jmp	SHORT $LN4@fnVersione
$LN11@fnVersione:

; 236  :    }
; 237  : 
; 238  :    return( 0 );

	xor	eax, eax
$LN1@fnVersione:

; 239  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnVersionedForUpdate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpInstance$ = -8					; size = 4
_nStartLevel$ = -4					; size = 2
_lpStartInstance$ = 8					; size = 4
_pUpdated$ = 12						; size = 4
_pUpdatedFile$ = 16					; size = 4
_nDoReset$ = 20						; size = 2
_fnGetResetUpdFlags PROC

; 6316 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6317 : 
; 6318 :    LPENTITYINSTANCE lpInstance = lpStartInstance;

	mov	eax, DWORD PTR _lpStartInstance$[ebp]
	mov	DWORD PTR _lpInstance$[ebp], eax

; 6319 :    zSHORT nStartLevel = lpStartInstance->nLevel;

	mov	ecx, DWORD PTR _lpStartInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nStartLevel$[ebp], dx
$LN4@fnGetReset:

; 6320 : 
; 6321 :    do
; 6322 :    {
; 6323 :       if ( lpInstance->u.nInd.bVersionUpdFile )

	mov	eax, DWORD PTR _lpInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 25					; 00000019H
	and	ecx, 1
	je	SHORT $LN5@fnGetReset

; 6324 :          *pUpdatedFile = 1;

	mov	edx, 1
	mov	eax, DWORD PTR _pUpdatedFile$[ebp]
	mov	WORD PTR [eax], dx
$LN5@fnGetReset:

; 6325 : 
; 6326 :       if ( lpInstance->u.nInd.bVersionUpdated )

	mov	ecx, DWORD PTR _lpInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 24					; 00000018H
	and	edx, 1
	je	SHORT $LN6@fnGetReset

; 6327 :          *pUpdated = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _pUpdated$[ebp]
	mov	WORD PTR [ecx], ax
$LN6@fnGetReset:

; 6328 : 
; 6329 :       if ( nDoReset )

	movsx	edx, WORD PTR _nDoReset$[ebp]
	test	edx, edx
	je	SHORT $LN7@fnGetReset

; 6330 :       {
; 6331 :          lpInstance->u.nInd.bVersionUpdated = 0;

	mov	eax, DWORD PTR _lpInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -16777217				; feffffffH
	mov	edx, DWORD PTR _lpInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 6332 :          lpInstance->u.nInd.bVersionUpdFile = 0;

	mov	eax, DWORD PTR _lpInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -33554433				; fdffffffH
	mov	edx, DWORD PTR _lpInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN7@fnGetReset:

; 6333 :       }
; 6334 : 
; 6335 :       lpInstance = zGETPTR( lpInstance->hNextHier );

	mov	eax, DWORD PTR _lpInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstance$[ebp], eax

; 6336 : 
; 6337 :    } while ( lpInstance && lpInstance->nLevel > nStartLevel );

	cmp	DWORD PTR _lpInstance$[ebp], 0
	je	SHORT $LN3@fnGetReset
	mov	edx, DWORD PTR _lpInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nStartLevel$[ebp]
	cmp	eax, ecx
	jg	$LN4@fnGetReset
$LN3@fnGetReset:

; 6338 : 
; 6339 :    return( 0 );

	xor	eax, eax

; 6340 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGetResetUpdFlags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpRPViewEntity$1 = -316				; size = 4
tv192 = -312						; size = 4
_nCurrLevel$ = -308					; size = 2
_lpWrkViewEntity1$ = -304				; size = 4
_lpNextHier$2 = -300					; size = 4
_nEntityLevel$ = -296					; size = 2
_nEntityStopLevel$ = -292				; size = 2
_nRC$3 = -288						; size = 2
_nStopLevel$ = -284					; size = 2
_lpViewEntity$4 = -280					; size = 4
_nCardinalityViolation$ = -276				; size = 2
_lpWrkEI1$ = -272					; size = 4
_bCount$ = -265						; size = 1
_lpWrkViewEntity2$ = -264				; size = 4
_szRel$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpEntityInstance$ = 12					; size = 4
_bChkAllEntitiesAtChildLvl$ = 16			; size = 1
_fnCheckChildEntities PROC

; 1061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 316				; 0000013cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1062 :    zSHORT            nStopLevel;
; 1063 :    zSHORT            nCurrLevel;
; 1064 :    zSHORT            nEntityStopLevel;
; 1065 :    zSHORT            nEntityLevel;
; 1066 :    zSHORT            nCardinalityViolation;
; 1067 :    LPVIEWENTITY      lpWrkViewEntity1;
; 1068 :    LPVIEWENTITY      lpWrkViewEntity2;
; 1069 :    LPENTITYINSTANCE  lpWrkEI1;
; 1070 : // LPENTITYINSTANCE  lpWrkEI2;
; 1071 :    zBOOL             bCount = TRUE;

	mov	BYTE PTR _bCount$[ebp], 1

; 1072 :    zCHAR             szRel[ 255 ];
; 1073 : 
; 1074 : 
; 1075 :    // Scan through all the child instances, looking for attributes,
; 1076 :    // marked required and not marked hidden, that have a 'NULL' value.
; 1077 :    lpWrkEI1         = *lpEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpWrkEI1$[ebp], ecx

; 1078 :    lpWrkViewEntity1 = zGETPTR( lpWrkEI1->hViewEntity );

	mov	edx, DWORD PTR _lpWrkEI1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity1$[ebp], eax

; 1079 :    nEntityStopLevel = lpWrkViewEntity1->nLevel;

	mov	ecx, DWORD PTR _lpWrkViewEntity1$[ebp]
	mov	dx, WORD PTR [ecx+215]
	mov	WORD PTR _nEntityStopLevel$[ebp], dx

; 1080 :    nStopLevel       = lpWrkEI1->nLevel;

	mov	eax, DWORD PTR _lpWrkEI1$[ebp]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nStopLevel$[ebp], cx

; 1081 :    nCurrLevel       = nStopLevel + 1;

	movsx	edx, WORD PTR _nStopLevel$[ebp]
	add	edx, 1
	mov	WORD PTR _nCurrLevel$[ebp], dx

; 1082 :    lpWrkEI1         = zGETPTR( lpWrkEI1->hNextHier );

	mov	eax, DWORD PTR _lpWrkEI1$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEI1$[ebp], eax

; 1083 : 
; 1084 :    // First child ViewEntity
; 1085 :    lpWrkViewEntity2 = zGETPTR( lpWrkViewEntity1->hNextHier );

	mov	edx, DWORD PTR _lpWrkViewEntity1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity2$[ebp], eax

; 1086 :    nEntityLevel = lpWrkViewEntity2->nLevel;

	mov	ecx, DWORD PTR _lpWrkViewEntity2$[ebp]
	mov	dx, WORD PTR [ecx+215]
	mov	WORD PTR _nEntityLevel$[ebp], dx
$LN2@fnCheckChi:

; 1087 : 
; 1088 :    while ( lpWrkEI1 && lpWrkEI1->nLevel > nStopLevel )

	cmp	DWORD PTR _lpWrkEI1$[ebp], 0
	je	$LN3@fnCheckChi
	mov	eax, DWORD PTR _lpWrkEI1$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStopLevel$[ebp]
	cmp	ecx, edx
	jle	$LN3@fnCheckChi

; 1089 :    {
; 1090 :       LPVIEWENTITY lpRPViewEntity;
; 1091 :       LPVIEWENTITY lpViewEntity;
; 1092 : 
; 1093 :       if ( lpWrkEI1->u.nInd.bHidden == FALSE )

	mov	eax, DWORD PTR _lpWrkEI1$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	$LN8@fnCheckChi

; 1094 :       {
; 1095 :          LPENTITYINSTANCE lpNextHier;
; 1096 : 
; 1097 :          lpViewEntity = zGETPTR( lpWrkEI1->hViewEntity );

	mov	edx, DWORD PTR _lpWrkEI1$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$4[ebp], eax

; 1098 : 
; 1099 :          // Look for possible missing entities that maybe required.
; 1100 :          // Only check one level down ...
; 1101 :          if ( bChkAllEntitiesAtChildLvl &&

	movzx	ecx, BYTE PTR _bChkAllEntitiesAtChildLvl$[ebp]
	test	ecx, ecx
	je	$LN10@fnCheckChi
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	cmp	edx, DWORD PTR _lpWrkViewEntity2$[ebp]
	je	$LN10@fnCheckChi
$LN4@fnCheckChi:

; 1102 :               lpViewEntity != lpWrkViewEntity2 )
; 1103 :          {
; 1104 :             while ( lpWrkViewEntity2 &&

	cmp	DWORD PTR _lpWrkViewEntity2$[ebp], 0
	je	$LN10@fnCheckChi
	mov	eax, DWORD PTR _lpWrkViewEntity2$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	movsx	eax, WORD PTR [edx+217]
	cmp	ecx, eax
	jge	$LN10@fnCheckChi

; 1105 :                     lpWrkViewEntity2->nHierNbr < lpViewEntity->nHierNbr )
; 1106 :             {
; 1107 :                if ( lpWrkViewEntity2->nLevel == nEntityLevel &&

	mov	ecx, DWORD PTR _lpWrkViewEntity2$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	movsx	eax, WORD PTR _nEntityLevel$[ebp]
	cmp	edx, eax
	jne	$LN11@fnCheckChi
	mov	ecx, DWORD PTR _lpWrkViewEntity2$[ebp]
	movzx	edx, WORD PTR [ecx+219]
	test	edx, edx
	je	$LN11@fnCheckChi

; 1108 :                     lpWrkViewEntity2->uCardMin )
; 1109 :                {
; 1110 :                   // create a string which describes the relationship:
; 1111 :                   strcpy( szRel, "\nRelationship: \t" );

	push	OFFSET $SG13714
	lea	eax, DWORD PTR _szRel$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1112 :                   strcat( szRel, lpWrkViewEntity1->szName );

	mov	ecx, DWORD PTR _lpWrkViewEntity1$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _szRel$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1113 :                   strcat( szRel, " <--> " );

	push	OFFSET $SG13715
	lea	eax, DWORD PTR _szRel$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1114 :                   strcat( szRel, lpWrkViewEntity2->szName );

	mov	ecx, DWORD PTR _lpWrkViewEntity2$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _szRel$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1115 : 
; 1116 :                   // "KZOEE106 - Rules violation"
; 1117 : 
; 1118 :                   IssueOE_Error( lpView, 8, 106, 0,

	lea	eax, DWORD PTR _szRel$[ebp]
	push	eax
	push	OFFSET $SG13716
	push	300					; 0000012cH
	push	0
	push	106					; 0000006aH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_IssueOE_Error@28

; 1119 :                                  zMSGQ_OBJECT_CONSTRAINT_ERROR,
; 1120 :                                  "number of entities less than minimum cardinality",
; 1121 :                                  szRel );
; 1122 :                   return( zCONSTRAINT_VIOLATION );

	mov	eax, -12				; fffffff4H
	jmp	$LN1@fnCheckChi
$LN11@fnCheckChi:

; 1123 :                }
; 1124 : 
; 1125 :                lpWrkViewEntity2 = zGETPTR( lpWrkViewEntity2->hNextHier );

	mov	edx, DWORD PTR _lpWrkViewEntity2$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity2$[ebp], eax

; 1126 :             }

	jmp	$LN4@fnCheckChi
$LN10@fnCheckChi:

; 1127 :          }
; 1128 : 
; 1129 :          if ( lpWrkViewEntity2 &&

	cmp	DWORD PTR _lpWrkViewEntity2$[ebp], 0
	je	SHORT $LN12@fnCheckChi
	mov	ecx, DWORD PTR _lpWrkViewEntity2$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	movsx	ecx, WORD PTR [eax+217]
	cmp	edx, ecx
	jne	SHORT $LN12@fnCheckChi

; 1130 :               lpWrkViewEntity2->nHierNbr == lpViewEntity->nHierNbr )
; 1131 :          {
; 1132 :             lpWrkViewEntity2 = zGETPTR( lpWrkViewEntity2->hNextHier );

	mov	edx, DWORD PTR _lpWrkViewEntity2$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity2$[ebp], eax
$LN12@fnCheckChi:

; 1133 :          }
; 1134 : 
; 1135 :          if ( fnValidateInstanceAttributes( lpView, lpViewEntity, lpWrkEI1 ) )

	mov	ecx, DWORD PTR _lpWrkEI1$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnValidateInstanceAttributes
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN13@fnCheckChi

; 1136 :             return( zCONSTRAINT_VIOLATION );

	mov	eax, -12				; fffffff4H
	jmp	$LN1@fnCheckChi
$LN13@fnCheckChi:

; 1137 : 
; 1138 :          // Even though we have passed the cardinality check at the
; 1139 :          // 'twin' level, we need to call this again for possible
; 1140 :          // missing children of the current instance ...
; 1141 :          nCardinalityViolation = fnValidateCardinality( lpView,

	movzx	edx, BYTE PTR _bCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWrkEI1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidateCardinality
	add	esp, 16					; 00000010H
	mov	WORD PTR _nCardinalityViolation$[ebp], ax

; 1142 :                                                         lpViewEntity,
; 1143 :                                                         lpWrkEI1, bCount );
; 1144 :          bCount = 0;

	mov	BYTE PTR _bCount$[ebp], 0

; 1145 :          if ( nCardinalityViolation )

	movsx	eax, WORD PTR _nCardinalityViolation$[ebp]
	test	eax, eax
	je	$LN14@fnCheckChi

; 1146 :          {
; 1147 :             // "KZOEE106 - Rules violation"
; 1148 :             if ( nCardinalityViolation != -2 )

	movsx	ecx, WORD PTR _nCardinalityViolation$[ebp]
	cmp	ecx, -2					; fffffffeH
	je	SHORT $LN15@fnCheckChi

; 1149 :             {
; 1150 : 
; 1151 :                strcpy( szRel, "\nEntity: \t" );

	push	OFFSET $SG13721
	lea	edx, DWORD PTR _szRel$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1152 :                strcat( szRel, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szRel$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1153 : 
; 1154 :                IssueOE_Error( lpView, 8, 106, 0,

	movsx	edx, WORD PTR _nCardinalityViolation$[ebp]
	test	edx, edx
	jge	SHORT $LN23@fnCheckChi
	mov	DWORD PTR tv192[ebp], OFFSET $SG13722
	jmp	SHORT $LN24@fnCheckChi
$LN23@fnCheckChi:
	mov	DWORD PTR tv192[ebp], OFFSET $SG13723
$LN24@fnCheckChi:
	lea	eax, DWORD PTR _szRel$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv192[ebp]
	push	ecx
	push	300					; 0000012cH
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_IssueOE_Error@28
$LN15@fnCheckChi:

; 1155 :                               zMSGQ_OBJECT_CONSTRAINT_ERROR,
; 1156 :                               (nCardinalityViolation < 0 ?
; 1157 :                                 "number of entities less than minimum cardinality" :
; 1158 :                                 "maximum cardinality exceeded"),
; 1159 :                               szRel );
; 1160 :             }
; 1161 : 
; 1162 :             return( zCONSTRAINT_VIOLATION );

	mov	eax, -12				; fffffff4H
	jmp	$LN1@fnCheckChi
$LN14@fnCheckChi:

; 1163 :          }
; 1164 : 
; 1165 :          // Recursive Parent entity only used to determine if there are any
; 1166 :          // Required children ...
; 1167 :          lpRPViewEntity = fnGetRecurseParentEntity( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	push	eax
	call	_fnGetRecurseParentEntity
	add	esp, 4
	mov	DWORD PTR _lpRPViewEntity$1[ebp], eax

; 1168 :          lpNextHier = zGETPTR( lpWrkEI1->hNextHier );

	mov	ecx, DWORD PTR _lpWrkEI1$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$2[ebp], eax

; 1169 :          if ( lpNextHier && lpNextHier->nLevel > nCurrLevel )

	cmp	DWORD PTR _lpNextHier$2[ebp], 0
	je	SHORT $LN16@fnCheckChi
	mov	eax, DWORD PTR _lpNextHier$2[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nCurrLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN16@fnCheckChi

; 1170 :          {
; 1171 :             zSHORT nRC;
; 1172 : 
; 1173 :             nRC = fnCheckChildEntities( lpView, &lpWrkEI1,

	mov	eax, DWORD PTR _lpRPViewEntity$1[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 9
	and	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _lpWrkEI1$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCheckChildEntities
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$3[ebp], ax

; 1174 :                                         (zBOOL) lpRPViewEntity->bRequiredChild );
; 1175 :             bCount = TRUE;

	mov	BYTE PTR _bCount$[ebp], 1

; 1176 :             if ( nRC )

	movsx	ecx, WORD PTR _nRC$3[ebp]
	test	ecx, ecx
	je	SHORT $LN18@fnCheckChi

; 1177 :                return( nRC );

	mov	ax, WORD PTR _nRC$3[ebp]
	jmp	$LN1@fnCheckChi
$LN18@fnCheckChi:

; 1178 : 
; 1179 :             continue;

	jmp	$LN2@fnCheckChi

; 1180 :          }

	jmp	SHORT $LN17@fnCheckChi
$LN16@fnCheckChi:

; 1181 :          else
; 1182 :          {
; 1183 :             // If different entity type, turn on the count flag ...
; 1184 :             if ( lpNextHier && lpWrkEI1->hViewEntity != lpNextHier->hViewEntity )

	cmp	DWORD PTR _lpNextHier$2[ebp], 0
	je	SHORT $LN19@fnCheckChi
	mov	edx, DWORD PTR _lpWrkEI1$[ebp]
	mov	eax, DWORD PTR _lpNextHier$2[ebp]
	mov	ecx, DWORD PTR [edx+2]
	cmp	ecx, DWORD PTR [eax+2]
	je	SHORT $LN19@fnCheckChi

; 1185 :                bCount = TRUE;

	mov	BYTE PTR _bCount$[ebp], 1
$LN19@fnCheckChi:

; 1186 : 
; 1187 :             lpWrkEI1 = lpNextHier;

	mov	edx, DWORD PTR _lpNextHier$2[ebp]
	mov	DWORD PTR _lpWrkEI1$[ebp], edx
$LN17@fnCheckChi:

; 1188 :          }
; 1189 :       }

	jmp	SHORT $LN9@fnCheckChi
$LN8@fnCheckChi:

; 1190 :       else
; 1191 :          lpWrkEI1 = zGETPTR( lpWrkEI1->hNextHier );

	mov	eax, DWORD PTR _lpWrkEI1$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEI1$[ebp], eax
$LN9@fnCheckChi:

; 1192 :    }

	jmp	$LN2@fnCheckChi
$LN3@fnCheckChi:

; 1193 : 
; 1194 :    // Look for possible missing entities that maybe required.
; 1195 :    if ( bChkAllEntitiesAtChildLvl && lpWrkViewEntity2 &&

	movzx	edx, BYTE PTR _bChkAllEntitiesAtChildLvl$[ebp]
	test	edx, edx
	je	$LN20@fnCheckChi
	cmp	DWORD PTR _lpWrkViewEntity2$[ebp], 0
	je	$LN20@fnCheckChi
	mov	eax, DWORD PTR _lpWrkViewEntity2$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	movsx	edx, WORD PTR _nEntityStopLevel$[ebp]
	cmp	ecx, edx
	jle	$LN20@fnCheckChi
$LN6@fnCheckChi:

; 1196 :         lpWrkViewEntity2->nLevel > nEntityStopLevel  )
; 1197 :    {
; 1198 :       while ( lpWrkViewEntity2 &&

	cmp	DWORD PTR _lpWrkViewEntity2$[ebp], 0
	je	$LN20@fnCheckChi
	mov	eax, DWORD PTR _lpWrkViewEntity2$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	movsx	edx, WORD PTR _nEntityStopLevel$[ebp]
	cmp	ecx, edx
	jle	$LN20@fnCheckChi

; 1199 :               lpWrkViewEntity2->nLevel > nEntityStopLevel )
; 1200 :       {
; 1201 :          if ( lpWrkViewEntity2->nLevel == nEntityLevel &&

	mov	eax, DWORD PTR _lpWrkViewEntity2$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	movsx	edx, WORD PTR _nEntityLevel$[ebp]
	cmp	ecx, edx
	jne	$LN21@fnCheckChi
	mov	eax, DWORD PTR _lpWrkViewEntity2$[ebp]
	movzx	ecx, WORD PTR [eax+219]
	test	ecx, ecx
	je	$LN21@fnCheckChi

; 1202 :               lpWrkViewEntity2->uCardMin )
; 1203 :          {
; 1204 :             // Create a string which describes the relationship.
; 1205 :             strcpy( szRel, "\nRelationship: \t" );

	push	OFFSET $SG13730
	lea	edx, DWORD PTR _szRel$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1206 :             strcat( szRel, lpWrkViewEntity1->szName);

	mov	eax, DWORD PTR _lpWrkViewEntity1$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szRel$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1207 :             strcat( szRel, " <--> " );

	push	OFFSET $SG13731
	lea	edx, DWORD PTR _szRel$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1208 :             strcat( szRel, lpWrkViewEntity2->szName);

	mov	eax, DWORD PTR _lpWrkViewEntity2$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szRel$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1209 : 
; 1210 :             // "KZOEE106 - Rules violation"
; 1211 :             IssueOE_Error( lpView, 8, 106, 0,

	lea	edx, DWORD PTR _szRel$[ebp]
	push	edx
	push	OFFSET $SG13732
	push	300					; 0000012cH
	push	0
	push	106					; 0000006aH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_IssueOE_Error@28

; 1212 :                            zMSGQ_OBJECT_CONSTRAINT_ERROR,
; 1213 :                            "number of entities less than minimum cardinality",
; 1214 :                            szRel );
; 1215 :             return( zCONSTRAINT_VIOLATION );

	mov	eax, -12				; fffffff4H
	jmp	SHORT $LN1@fnCheckChi
$LN21@fnCheckChi:

; 1216 :          }
; 1217 : 
; 1218 :          lpWrkViewEntity2 = zGETPTR( lpWrkViewEntity2->hNextHier );

	mov	ecx, DWORD PTR _lpWrkViewEntity2$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity2$[ebp], eax

; 1219 :       }

	jmp	$LN6@fnCheckChi
$LN20@fnCheckChi:

; 1220 :    }
; 1221 : 
; 1222 :    *lpEntityInstance = lpWrkEI1;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR _lpWrkEI1$[ebp]
	mov	DWORD PTR [eax], ecx

; 1223 :    return( 0 );

	xor	eax, eax
$LN1@fnCheckChi:

; 1224 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnCheckChildEntities ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewCsr$ = -36					; size = 4
_lpNextHier$ = -32					; size = 4
tv132 = -28						; size = 4
_lpViewEntity$ = -24					; size = 4
_lpRecursViewEntity$ = -20				; size = 4
_lpEntityInstance$ = -16				; size = 4
_lpViewSubobject$ = -12					; size = 4
_nCardinalityViolation$ = -8				; size = 2
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_bCheckChildEntities$ = 16				; size = 1
_fnOEAcceptConstraints PROC

; 1254 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1255 :    LPENTITYINSTANCE  lpEntityInstance;
; 1256 :    LPENTITYINSTANCE  lpNextHier;
; 1257 :    LPVIEWSUBOBJECT   lpViewSubobject;
; 1258 :    LPVIEWENTITY      lpViewEntity;
; 1259 :    LPVIEWENTITY      lpRecursViewEntity = 0;

	mov	DWORD PTR _lpRecursViewEntity$[ebp], 0

; 1260 :    LPVIEWCSR         lpViewCsr;
; 1261 :    zSHORT            nCardinalityViolation;
; 1262 :    zSHORT            nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1263 : 
; 1264 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1265 :    lpViewEntity     = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1266 :    lpViewCsr        = zGETPTR( lpViewEntityCsr->hViewCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1267 :    lpViewSubobject  = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 1268 : 
; 1269 :    if ( fnValidateInstanceAttributes( lpView, lpViewEntity,

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnValidateInstanceAttributes
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN4@fnOEAccept

; 1270 :                                       lpEntityInstance ) )
; 1271 :    {
; 1272 :       return( zCONSTRAINT_VIOLATION );

	mov	eax, -12				; fffffff4H
	jmp	$LN1@fnOEAccept
$LN4@fnOEAccept:

; 1273 :    }
; 1274 : 
; 1275 :    // If the lpViewEntityCsr is the Root cursor of a subobject view, then
; 1276 :    // use the RecursiveViewEntity when validating min/max cardinality.
; 1277 :    if ( lpViewSubobject )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	je	SHORT $LN5@fnOEAccept
$LN2@fnOEAccept:

; 1278 :    {
; 1279 :       while ( lpViewSubobject )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	je	SHORT $LN5@fnOEAccept

; 1280 :       {
; 1281 :          if ( zGETPTR( lpViewSubobject->hRootCsr ) == lpViewEntityCsr &&

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	jne	SHORT $LN6@fnOEAccept
	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN6@fnOEAccept

; 1282 :               lpViewSubobject->hRecursViewEntity )
; 1283 :          {
; 1284 :             lpRecursViewEntity = zGETPTR( lpViewSubobject->hRecursViewEntity );

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursViewEntity$[ebp], eax

; 1285 :             break;

	jmp	SHORT $LN5@fnOEAccept
$LN6@fnOEAccept:

; 1286 :          }
; 1287 : 
; 1288 :          lpViewSubobject = zGETPTR( lpViewSubobject->hNextViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 1289 :       }

	jmp	SHORT $LN2@fnOEAccept
$LN5@fnOEAccept:

; 1290 :    }
; 1291 : 
; 1292 :    if ( (nCardinalityViolation =
; 1293 :                fnValidateCardinality( lpView,
; 1294 :                                       ( lpRecursViewEntity ?
; 1295 :                                           lpRecursViewEntity : lpViewEntity ),
; 1296 :                                        lpEntityInstance, 1 ) ) != 0 )

	cmp	DWORD PTR _lpRecursViewEntity$[ebp], 0
	je	SHORT $LN10@fnOEAccept
	mov	edx, DWORD PTR _lpRecursViewEntity$[ebp]
	mov	DWORD PTR tv132[ebp], edx
	jmp	SHORT $LN11@fnOEAccept
$LN10@fnOEAccept:
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR tv132[ebp], eax
$LN11@fnOEAccept:
	push	1
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv132[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnValidateCardinality
	add	esp, 16					; 00000010H
	mov	WORD PTR _nCardinalityViolation$[ebp], ax
	movsx	ecx, WORD PTR _nCardinalityViolation$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@fnOEAccept

; 1297 :    {
; 1298 : #if 0
; 1299 :       zCHAR szRel[ 255 ];
; 1300 : 
; 1301 :       // "KZOEE106 - Rules violation"
; 1302 :       if ( nCardinalityViolation != -2 )
; 1303 : 
; 1304 :          strcpy( szRel, "\nEntity: \t" );
; 1305 :          strcat( szRel, lpViewEntity->szName );
; 1306 : 
; 1307 :          IssueOE_Error( lpView, 8, 106, 0,
; 1308 :                         zMSGQ_OBJECT_CONSTRAINT_ERROR,
; 1309 :                         (nCardinalityViolation < 0 ?
; 1310 :                            "number of entities less than minimum cardinality" :
; 1311 :                            "maximum cardinality exceeded"),
; 1312 :                         szRel );
; 1313 : #endif
; 1314 : 
; 1315 :       return( zCONSTRAINT_VIOLATION );

	mov	eax, -12				; fffffff4H
	jmp	SHORT $LN1@fnOEAccept
$LN7@fnOEAccept:

; 1316 :    }
; 1317 : 
; 1318 : #if 1
; 1319 :    lpNextHier = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHier$[ebp], eax

; 1320 :    if ( bCheckChildEntities &&
; 1321 :         lpNextHier &&

	movzx	ecx, BYTE PTR _bCheckChildEntities$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@fnOEAccept
	cmp	DWORD PTR _lpNextHier$[ebp], 0
	je	SHORT $LN8@fnOEAccept
	mov	edx, DWORD PTR _lpNextHier$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	add	edx, 1
	cmp	eax, edx
	jne	SHORT $LN8@fnOEAccept

; 1322 :         lpNextHier->nLevel == ( lpEntityInstance->nLevel + 1 ) )
; 1323 :    {
; 1324 :       nRC = fnCheckChildEntities( lpView, &lpEntityInstance,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 9
	and	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCheckChildEntities
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax
$LN8@fnOEAccept:

; 1325 :                                   (zBOOL) lpViewEntity->bRequiredChild );
; 1326 :    }
; 1327 : #endif
; 1328 : 
; 1329 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnOEAccept:

; 1330 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnOEAcceptConstraints ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_hInvertedSrcEntity$1 = -88				; size = 4
_lpOrigTgtEntityInstance$ = -84				; size = 4
_lpWk2$2 = -80						; size = 4
_lpWk1$3 = -76						; size = 4
_lpWk2$4 = -72						; size = 4
_lpParent$5 = -68					; size = 4
_lpAllocTask$ = -64					; size = 4
_hOldRecord$ = -60					; size = 4
_lpTask$6 = -56						; size = 4
_lpTgtViewEntity$ = -52					; size = 4
_lpTgtViewOI$ = -48					; size = 4
_hNewRecord$ = -44					; size = 4
_lpSrcViewEntity$ = -40					; size = 4
_lpWk1$7 = -36						; size = 4
_lpOrigSrcEntityInstance$ = -32				; size = 4
_lpLnkEntityInstance$ = -28				; size = 4
_lpWrkEntityInstance$ = -24				; size = 4
_lpVsnEntityInstance$ = -20				; size = 4
_nWkLevel$ = -16					; size = 2
_nStartLevel$ = -12					; size = 2
_nWkInvertedParents$ = -8				; size = 2
_bProcessParentsNow$ = -1				; size = 1
_lpTgtView$ = 8						; size = 4
_lpTgtEntityInstance$ = 12				; size = 4
_lpSrcView$ = 16					; size = 4
_lpSrcEntityInstance$ = 20				; size = 4
_nInvertedParents$ = 24					; size = 2
_lpInvertedSrcEntity$ = 28				; size = 4
_fnRelinkVsnSubobjectToSubobject PROC

; 5990 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H

; 5991 :    LPTASK           lpAllocTask;
; 5992 :    zSHORT           nStartLevel;
; 5993 :    zSHORT           nWkLevel;
; 5994 :    zSHORT           nWkInvertedParents;
; 5995 :    zBOOL            bProcessParentsNow;
; 5996 :    LPVIEWENTITY     lpTgtViewEntity;
; 5997 :    LPVIEWENTITY     lpSrcViewEntity;
; 5998 :    LPENTITYINSTANCE lpOrigSrcEntityInstance;
; 5999 :    LPENTITYINSTANCE lpOrigTgtEntityInstance;
; 6000 :    LPENTITYINSTANCE lpVsnEntityInstance;
; 6001 :    LPENTITYINSTANCE lpWrkEntityInstance;
; 6002 :    LPENTITYINSTANCE lpLnkEntityInstance;
; 6003 :    zPVOID           hOldRecord;
; 6004 :    zPVOID           hNewRecord;
; 6005 :    LPVIEWOI         lpTgtViewOI;
; 6006 : 
; 6007 :    SysMessageBox( lpSrcView, "QuinSoft Info", "Call DG (#102)", 0 );

	push	0
	push	OFFSET $SG15513
	push	OFFSET $SG15514
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 6008 : 
; 6009 :    nStartLevel = lpTgtEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nStartLevel$[ebp], dx

; 6010 :    nWkInvertedParents = nInvertedParents;

	mov	ax, WORD PTR _nInvertedParents$[ebp]
	mov	WORD PTR _nWkInvertedParents$[ebp], ax

; 6011 :    lpOrigSrcEntityInstance = lpSrcEntityInstance;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR _lpOrigSrcEntityInstance$[ebp], ecx

; 6012 :    lpOrigTgtEntityInstance = lpTgtEntityInstance;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR _lpOrigTgtEntityInstance$[ebp], edx

; 6013 :    lpTgtViewEntity = zGETPTR( lpTgtEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewEntity$[ebp], eax

; 6014 :    lpSrcViewEntity = zGETPTR( lpSrcEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntity$[ebp], eax

; 6015 :    bProcessParentsNow = 0;

	mov	BYTE PTR _bProcessParentsNow$[ebp], 0

; 6016 :    lpTgtViewOI = zGETPTR( lpTgtEntityInstance->hViewOI );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 6017 :    lpAllocTask = zGETPTR( lpTgtViewOI->hAllocTask );

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax
$LN5@fnRelinkVs:

; 6018 :    for ( ; ; )
; 6019 :    {
; 6020 :       while ( lpSrcEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN6@fnRelinkVs

; 6021 :          lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
	jmp	SHORT $LN5@fnRelinkVs
$LN6@fnRelinkVs:

; 6022 : 
; 6023 :       if ( lpSrcEntityInstance == 0 ||

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN30@fnRelinkVs
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN29@fnRelinkVs
$LN30@fnRelinkVs:

; 6024 :            fnInstanceKeysMatch( lpSrcEntityInstance, lpTgtEntityInstance ) == 0 )
; 6025 :       {
; 6026 :          LPTASK lpTask = zGETPTR( lpTgtView->hTask );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$6[ebp], eax

; 6027 :          //  "KZOEE118 - Internal Key error relinking versioned Subobject"
; 6028 :          fnIssueCoreError( lpTask, lpSrcView, 16, 118, 0,

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	118					; 00000076H
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$6[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 6029 :                            lpTgtViewEntity->szName,
; 6030 :                            lpSrcViewEntity->szName );
; 6031 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnRelinkVs
$LN29@fnRelinkVs:

; 6032 :       }
; 6033 : 
; 6034 :       if ( fnInstanceLinkedToInstance( lpSrcEntityInstance,
; 6035 :                                        lpTgtEntityInstance ) == 0 )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	$LN31@fnRelinkVs

; 6036 :       {
; 6037 :          hOldRecord = lpTgtEntityInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _hOldRecord$[ebp], eax

; 6038 :          fnRemoveOtherOI_LinkedInstances( lpTgtEntityInstance,

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	call	_fnRemoveOtherOI_LinkedInstances
	add	esp, 8

; 6039 :                                           lpSrcEntityInstance );
; 6040 :          fnRelinkInstanceToInstance( lpTgtEntityInstance,

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	call	_fnRelinkInstanceToInstance
	add	esp, 8

; 6041 :                                      lpSrcEntityInstance );
; 6042 :          hNewRecord = lpTgtEntityInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR _hNewRecord$[ebp], eax

; 6043 :          lpSrcEntityInstance->u.nInd.bPrevVersion = TRUE;

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 6044 :          lpWrkEntityInstance = lpTgtEntityInstance;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], ecx
$LN9@fnRelinkVs:

; 6045 :          do
; 6046 :          {
; 6047 :             lpVsnEntityInstance = zGETPTR( lpWrkEntityInstance->hNextVsn );

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVsnEntityInstance$[ebp], eax
$LN10@fnRelinkVs:

; 6048 : 
; 6049 :             // Create a new copy of the record for each later version
; 6050 :             // of the target instance.
; 6051 :             while ( lpVsnEntityInstance )

	cmp	DWORD PTR _lpVsnEntityInstance$[ebp], 0
	je	$LN11@fnRelinkVs

; 6052 :             {
; 6053 :                if ( lpVsnEntityInstance->hPersistRecord == hOldRecord )

	mov	ecx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	cmp	edx, DWORD PTR _hOldRecord$[ebp]
	jne	SHORT $LN32@fnRelinkVs

; 6054 :                   lpVsnEntityInstance->hPersistRecord = hNewRecord;

	mov	eax, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	ecx, DWORD PTR _hNewRecord$[ebp]
	mov	DWORD PTR [eax+60], ecx
	jmp	SHORT $LN33@fnRelinkVs
$LN32@fnRelinkVs:

; 6055 :                else
; 6056 :                if ( lpVsnEntityInstance->hPersistRecord != hNewRecord )

	mov	edx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	cmp	eax, DWORD PTR _hNewRecord$[ebp]
	je	SHORT $LN33@fnRelinkVs

; 6057 :                {
; 6058 :                   fnDeleteAttributeRecord(

	push	1
	mov	ecx, DWORD PTR _lpVsnEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 6059 :                         zGETPTR( lpVsnEntityInstance->hViewEntity ),
; 6060 :                         lpVsnEntityInstance, TRUE );
; 6061 :                   lpVsnEntityInstance->hPersistRecord =

	push	1
	mov	ecx, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpAllocTask$[ebp]
	push	edx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	DWORD PTR [ecx+60], eax
$LN33@fnRelinkVs:

; 6062 :                       fnCopyAttributeRecord( lpAllocTask,
; 6063 :                         zGETPTR( lpWrkEntityInstance->hViewEntity ),
; 6064 :                         (zPCHAR) zGETPTR( lpWrkEntityInstance->hPersistRecord ), 1 );
; 6065 :                }
; 6066 : 
; 6067 :                lpLnkEntityInstance =

	mov	edx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax
$LN12@fnRelinkVs:

; 6068 :                                  zGETPTR( lpVsnEntityInstance->hNextLinked );
; 6069 :                while ( lpLnkEntityInstance &&

	cmp	DWORD PTR _lpLnkEntityInstance$[ebp], 0
	je	SHORT $LN13@fnRelinkVs
	mov	ecx, DWORD PTR _lpLnkEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpVsnEntityInstance$[ebp]
	je	SHORT $LN13@fnRelinkVs

; 6070 :                        lpLnkEntityInstance != lpVsnEntityInstance )
; 6071 :                {
; 6072 :                   lpLnkEntityInstance->hPersistRecord = lpVsnEntityInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 6073 :                   lpLnkEntityInstance =

	mov	edx, DWORD PTR _lpLnkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLnkEntityInstance$[ebp], eax

; 6074 :                                  zGETPTR( lpLnkEntityInstance->hNextLinked );
; 6075 :                }

	jmp	SHORT $LN12@fnRelinkVs
$LN13@fnRelinkVs:

; 6076 : 
; 6077 :                lpVsnEntityInstance = zGETPTR( lpVsnEntityInstance->hNextVsn );

	mov	ecx, DWORD PTR _lpVsnEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVsnEntityInstance$[ebp], eax

; 6078 :             }

	jmp	$LN10@fnRelinkVs
$LN11@fnRelinkVs:

; 6079 : 
; 6080 :             lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax

; 6081 :          }  while ( lpWrkEntityInstance &&

	cmp	DWORD PTR _lpWrkEntityInstance$[ebp], 0
	je	SHORT $LN31@fnRelinkVs
	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	jne	$LN9@fnRelinkVs
$LN31@fnRelinkVs:

; 6082 :                     lpWrkEntityInstance != lpTgtEntityInstance );
; 6083 :       }
; 6084 : 
; 6085 :       lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 6086 :       if ( lpTgtEntityInstance == 0 ||

	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN38@fnRelinkVs
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nStartLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN14@fnRelinkVs
$LN38@fnRelinkVs:

; 6087 :            lpTgtEntityInstance->nLevel <= nStartLevel )
; 6088 :       {
; 6089 :          break;

	jmp	$LN3@fnRelinkVs

; 6090 :       }

	jmp	$LN37@fnRelinkVs
$LN14@fnRelinkVs:

; 6091 :       else
; 6092 :       {
; 6093 :          while ( lpTgtEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN15@fnRelinkVs

; 6094 :             lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
	jmp	SHORT $LN14@fnRelinkVs
$LN15@fnRelinkVs:

; 6095 : 
; 6096 :          if ( lpTgtEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN37@fnRelinkVs

; 6097 :          {
; 6098 :             nWkLevel = lpTgtEntityInstance->nLevel;

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	dx, WORD PTR [ecx+58]
	mov	WORD PTR _nWkLevel$[ebp], dx
$LN18@fnRelinkVs:

; 6099 :             do
; 6100 :             {
; 6101 :                lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 6102 :             }  while ( lpTgtEntityInstance &&

	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN17@fnRelinkVs
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nWkLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN18@fnRelinkVs
$LN17@fnRelinkVs:

; 6103 :                        lpTgtEntityInstance->nLevel > nWkLevel );
; 6104 : 
; 6105 :             if ( lpTgtEntityInstance == 0 ||

	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN42@fnRelinkVs
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nStartLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN19@fnRelinkVs
$LN42@fnRelinkVs:

; 6106 :                  lpTgtEntityInstance->nLevel <= nStartLevel )
; 6107 :             {
; 6108 :                break;

	jmp	$LN3@fnRelinkVs
$LN19@fnRelinkVs:

; 6109 :             }
; 6110 : 
; 6111 :             while ( lpTgtEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN37@fnRelinkVs

; 6112 :                lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
	jmp	SHORT $LN19@fnRelinkVs
$LN37@fnRelinkVs:

; 6113 :          }
; 6114 :       }
; 6115 : 
; 6116 :       if ( nWkInvertedParents && bProcessParentsNow == FALSE )

	movsx	edx, WORD PTR _nWkInvertedParents$[ebp]
	test	edx, edx
	je	$LN43@fnRelinkVs
	movzx	eax, BYTE PTR _bProcessParentsNow$[ebp]
	test	eax, eax
	jne	$LN43@fnRelinkVs

; 6117 :       {
; 6118 :          LPVIEWENTITY     lpWk1, lpWk2;
; 6119 :          LPENTITYINSTANCE lpParent;
; 6120 : 
; 6121 :          // Determine if it is time to process the parents by checking the
; 6122 :          // Target Entity instance to see if the target instance is
; 6123 :          // an instance of the original sources parent
; 6124 :          lpWk1    = zGETPTR( lpTgtEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk1$7[ebp], eax

; 6125 :          lpParent = zGETPTR( lpOrigSrcEntityInstance->hParent );

	mov	eax, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$5[ebp], eax

; 6126 :          lpWk2    = zGETPTR( lpParent->hViewEntity );

	mov	edx, DWORD PTR _lpParent$5[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk2$4[ebp], eax

; 6127 :          if ( lpTgtEntityInstance->nLevel == ( nStartLevel + 1 ) &&
; 6128 :               lpWk1->lEREntTok == lpWk2->lEREntTok &&
; 6129 :               lpWk1->lERRelTok == lpSrcViewEntity->lERRelTok &&

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	add	eax, 1
	cmp	edx, eax
	jne	SHORT $LN43@fnRelinkVs
	mov	ecx, DWORD PTR _lpWk1$7[ebp]
	mov	edx, DWORD PTR _lpWk2$4[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $LN43@fnRelinkVs
	mov	ecx, DWORD PTR _lpWk1$7[ebp]
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+199]
	cmp	eax, DWORD PTR [edx+199]
	jne	SHORT $LN43@fnRelinkVs
	mov	ecx, DWORD PTR _lpWk1$7[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	cmp	edx, ecx
	je	SHORT $LN43@fnRelinkVs

; 6130 :               lpWk1->bRelLink1 != lpSrcViewEntity->bRelLink1 )
; 6131 :          {
; 6132 :             bProcessParentsNow = TRUE;

	mov	BYTE PTR _bProcessParentsNow$[ebp], 1
$LN43@fnRelinkVs:

; 6133 :          }
; 6134 :       }
; 6135 : 
; 6136 :       if ( nWkInvertedParents && bProcessParentsNow )

	movsx	edx, WORD PTR _nWkInvertedParents$[ebp]
	test	edx, edx
	je	SHORT $LN23@fnRelinkVs
	movzx	eax, BYTE PTR _bProcessParentsNow$[ebp]
	test	eax, eax
	je	SHORT $LN23@fnRelinkVs

; 6137 :       {
; 6138 :          lpSrcEntityInstance = zGETPTR( lpOrigSrcEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 6139 :          nWkInvertedParents--;

	mov	ax, WORD PTR _nWkInvertedParents$[ebp]
	sub	ax, 1
	mov	WORD PTR _nWkInvertedParents$[ebp], ax

; 6140 :       }

	jmp	$LN46@fnRelinkVs
$LN23@fnRelinkVs:

; 6141 :       else
; 6142 :       {
; 6143 :          for ( ; ; )
; 6144 :          {
; 6145 :             lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 6146 :             if ( lpSrcEntityInstance == 0 )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	jne	SHORT $LN47@fnRelinkVs

; 6147 :                break;

	jmp	SHORT $LN46@fnRelinkVs
$LN47@fnRelinkVs:

; 6148 : 
; 6149 :             if ( lpSrcEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN48@fnRelinkVs

; 6150 :             {
; 6151 :                nWkLevel = lpSrcEntityInstance->nLevel;

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nWkLevel$[ebp], ax
$LN26@fnRelinkVs:

; 6152 :                do
; 6153 :                {
; 6154 :                   lpSrcEntityInstance =

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 6155 :                                  zGETPTR( lpSrcEntityInstance->hNextHier );
; 6156 :                }  while ( lpSrcEntityInstance &&

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN25@fnRelinkVs
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nWkLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN26@fnRelinkVs
$LN25@fnRelinkVs:

; 6157 :                           lpSrcEntityInstance->nLevel > nWkLevel );
; 6158 :             }

	jmp	SHORT $LN49@fnRelinkVs
$LN48@fnRelinkVs:

; 6159 :             else
; 6160 :             {
; 6161 :                LPVIEWENTITY lpWk1 =

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk1$3[ebp], eax

; 6162 :                               zGETPTR( lpSrcEntityInstance->hViewEntity );
; 6163 :                LPVIEWENTITY lpWk2 =

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWk2$2[ebp], eax

; 6164 :                               zGETPTR( lpTgtEntityInstance->hViewEntity );
; 6165 : 
; 6166 :                if ( lpWk1->lEREntTok == lpWk2->lEREntTok )

	mov	ecx, DWORD PTR _lpWk1$3[ebp]
	mov	edx, DWORD PTR _lpWk2$2[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $LN49@fnRelinkVs

; 6167 :                {
; 6168 :                   break;

	jmp	SHORT $LN46@fnRelinkVs
$LN49@fnRelinkVs:

; 6169 :                }
; 6170 :             }
; 6171 :          }

	jmp	$LN23@fnRelinkVs
$LN46@fnRelinkVs:

; 6172 :       }
; 6173 :    }

	jmp	$LN5@fnRelinkVs
$LN3@fnRelinkVs:

; 6174 : 
; 6175 :    if ( lpInvertedSrcEntity )

	cmp	DWORD PTR _lpInvertedSrcEntity$[ebp], 0
	je	$LN52@fnRelinkVs

; 6176 :    {
; 6177 :       // If the source structure inverts the target then we need to find the
; 6178 :       // instance in the source and drop it.
; 6179 :       lpSrcEntityInstance = zGETPTR( lpOrigSrcEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 6180 :       lpTgtEntityInstance = zGETPTR( lpOrigTgtEntityInstance->hParent );

	mov	eax, DWORD PTR _lpOrigTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax

; 6181 :       if ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	$LN52@fnRelinkVs

; 6182 :       {
; 6183 :          LPVIEWENTITY hInvertedSrcEntity = zGETHNDL( lpInvertedSrcEntity );

	mov	edx, DWORD PTR _lpInvertedSrcEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hInvertedSrcEntity$1[ebp], eax
$LN27@fnRelinkVs:

; 6184 : 
; 6185 :          while ( lpSrcEntityInstance &&

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	$LN52@fnRelinkVs
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpOrigSrcEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jle	$LN52@fnRelinkVs

; 6186 :                  lpSrcEntityInstance->nLevel > lpOrigSrcEntityInstance->nLevel )
; 6187 :          {
; 6188 :             if ( lpSrcEntityInstance->hViewEntity == hInvertedSrcEntity &&
; 6189 :                  lpSrcEntityInstance->u.nInd.bHidden == FALSE &&

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hInvertedSrcEntity$1[ebp]
	jne	SHORT $LN54@fnRelinkVs
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN54@fnRelinkVs
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN54@fnRelinkVs

; 6190 :                  fnInstanceKeysMatch( lpTgtEntityInstance,
; 6191 :                                       lpSrcEntityInstance ) )
; 6192 :             {
; 6193 :                nInvertedParents =

	push	0
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInvertedSrcEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_fnValidSubobjectStructureMatch
	add	esp, 20					; 00000014H
	mov	WORD PTR _nInvertedParents$[ebp], ax

; 6194 :                    fnValidSubobjectStructureMatch( lpSrcView,
; 6195 :                             lpInvertedSrcEntity, lpTgtView,
; 6196 :                             zGETPTR( lpTgtEntityInstance->hViewEntity ), 0 );
; 6197 :                fnRelinkVsnSubobjectToSubobject( lpSrcView,

	push	0
	movzx	ecx, WORD PTR _nInvertedParents$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	call	_fnRelinkVsnSubobjectToSubobject
	add	esp, 24					; 00000018H

; 6198 :                                                 lpSrcEntityInstance,
; 6199 :                                                 lpTgtView,
; 6200 :                                                 lpTgtEntityInstance,
; 6201 :                                                 nInvertedParents, 0 );
; 6202 :                break;

	jmp	SHORT $LN52@fnRelinkVs
$LN54@fnRelinkVs:

; 6203 :             }
; 6204 : 
; 6205 :             lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 6206 :          }

	jmp	$LN27@fnRelinkVs
$LN52@fnRelinkVs:

; 6207 :       }
; 6208 :    }
; 6209 : 
; 6210 :    return( 0 );  // SUCCESS

	xor	eax, eax
$LN1@fnRelinkVs:

; 6211 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnRelinkVsnSubobjectToSubobject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewCsr$1 = -56					; size = 4
_lpViewOI$2 = -52					; size = 4
_lpViewCsr$3 = -48					; size = 4
_lpViewOI$4 = -44					; size = 4
_lpRecursViewEntity$ = -40				; size = 4
_lpTgtInstance$ = -36					; size = 4
_lpTgtParent$ = -32					; size = 4
_lpSpawnView$ = -28					; size = 4
_lpSpawnCsr$ = -24					; size = 4
_lpSrchChild$ = -20					; size = 4
_lpSrchInstance$ = -16					; size = 4
_lpSrchViewEntity$ = -12				; size = 4
_lpWkViewEntity$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTgtView$ = 8						; size = 4
_lpTgtViewOI$ = 12					; size = 4
_lpTgtViewEntity$ = 16					; size = 4
_lpTgtViewEntityCsr$ = 20				; size = 4
_bMarkIncluded$ = 24					; size = 2
_fnSpawnIncludeSubobject PROC

; 5734 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 5735 :    LPVIEWENTITY      lpSrchViewEntity;
; 5736 :    LPVIEWENTITY      lpRecursViewEntity;
; 5737 :    LPVIEWENTITY      lpWkViewEntity;
; 5738 :    LPVIEWENTITYCSR   lpSpawnCsr;
; 5739 :    LPENTITYINSTANCE  lpTgtInstance;
; 5740 :    LPENTITYINSTANCE  lpSrchInstance;
; 5741 :    LPENTITYINSTANCE  lpSrchChild;
; 5742 :    LPENTITYINSTANCE  lpTgtParent;
; 5743 :    zVIEW             lpSpawnView;
; 5744 :    zSHORT            nRC;
; 5745 : 
; 5746 :    lpTgtInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtInstance$[ebp], eax

; 5747 :    lpTgtParent   = zGETPTR( lpTgtInstance->hParent );

	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$[ebp], eax

; 5748 : 
; 5749 :    // Can't spawn a ROOT or a derived relationship.
; 5750 :    if ( lpTgtParent == 0 || lpTgtViewEntity->bDerived )

	cmp	DWORD PTR _lpTgtParent$[ebp], 0
	je	SHORT $LN29@fnSpawnInc
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	je	SHORT $LN28@fnSpawnInc
$LN29@fnSpawnInc:

; 5751 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSpawnInc
$LN28@fnSpawnInc:

; 5752 : 
; 5753 :    // Spawning pass 1, for every visible linked instance of the entity
; 5754 :    // instance, see if the structure is inverted anywhere and needs
; 5755 :    // to be spawned.
; 5756 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 5757 :    lpSrchInstance = zGETPTR( lpTgtInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$[ebp], eax
$LN2@fnSpawnInc:

; 5758 : 
; 5759 :    // Do pass 1 looking for inverted relationships of the target.
; 5760 :    while ( nRC == 0 && lpSrchInstance && lpSrchInstance != lpTgtInstance )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN3@fnSpawnInc
	cmp	DWORD PTR _lpSrchInstance$[ebp], 0
	je	$LN3@fnSpawnInc
	mov	ecx, DWORD PTR _lpSrchInstance$[ebp]
	cmp	ecx, DWORD PTR _lpTgtInstance$[ebp]
	je	$LN3@fnSpawnInc

; 5761 :    {
; 5762 :       if ( lpSrchInstance->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpSrchInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	$LN30@fnSpawnInc

; 5763 :       {
; 5764 :          lpSrchViewEntity = zGETPTR( lpSrchInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrchInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$[ebp], eax

; 5765 :          lpRecursViewEntity = lpSrchViewEntity;

	mov	eax, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	DWORD PTR _lpRecursViewEntity$[ebp], eax

; 5766 :          if ( lpSrchViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN31@fnSpawnInc
$LN6@fnSpawnInc:

; 5767 :          {
; 5768 :             do
; 5769 :             {
; 5770 :                lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hParent );

	mov	eax, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$[ebp], eax

; 5771 : 
; 5772 :             } while ( lpSrchViewEntity->lEREntTok != lpRecursViewEntity->lEREntTok );

	mov	edx, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	eax, DWORD PTR _lpRecursViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	jne	SHORT $LN6@fnSpawnInc
$LN31@fnSpawnInc:

; 5773 :          }
; 5774 : 
; 5775 :          // See if the linked entity instance has a child entity type
; 5776 :          // which is a non-derived inversion of the target entity type.
; 5777 :          lpWkViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
$LN7@fnSpawnInc:

; 5778 :          while ( lpWkViewEntity )

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	$LN30@fnSpawnInc

; 5779 :          {
; 5780 :             if ( lpWkViewEntity->nLevel <= lpSrchViewEntity->nLevel )

	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	mov	eax, DWORD PTR _lpSrchViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	edx, ecx
	jg	SHORT $LN32@fnSpawnInc

; 5781 :             {
; 5782 :                lpWkViewEntity = 0;

	mov	DWORD PTR _lpWkViewEntity$[ebp], 0

; 5783 :                break;

	jmp	$LN30@fnSpawnInc
$LN32@fnSpawnInc:

; 5784 :             }
; 5785 : 
; 5786 :             if ( zGETPTR( lpWkViewEntity->hParent ) == lpSrchViewEntity &&
; 5787 :                  lpWkViewEntity->lERRelTok == lpTgtViewEntity->lERRelTok &&
; 5788 :                  lpWkViewEntity->bRelLink1 != lpTgtViewEntity->bRelLink1 &&
; 5789 :                  fnInstanceVersionRootMatch( lpSrchInstance,
; 5790 :                                              lpTgtInstance ) &&

	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSrchViewEntity$[ebp]
	jne	$LN33@fnSpawnInc
	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+199]
	cmp	eax, DWORD PTR [edx+199]
	jne	$LN33@fnSpawnInc
	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 28					; 0000001cH
	and	edx, 1
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	cmp	edx, ecx
	je	$LN33@fnSpawnInc
	mov	edx, DWORD PTR _lpTgtInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrchInstance$[ebp]
	push	eax
	call	_fnInstanceVersionRootMatch
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	$LN33@fnSpawnInc
	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	jne	$LN33@fnSpawnInc

; 5791 :                  lpWkViewEntity->bDerived == FALSE )
; 5792 :             {
; 5793 :                // Here we have found an instance which has a child
; 5794 :                // entity type for spawning. Make sure this include
; 5795 :                // has not already been spawned.
; 5796 :                lpSrchChild = zGETPTR( lpTgtParent->hNextLinked );

	mov	ecx, DWORD PTR _lpTgtParent$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchChild$[ebp], eax
$LN9@fnSpawnInc:

; 5797 :                while ( lpSrchChild && lpSrchChild != lpTgtParent )

	cmp	DWORD PTR _lpSrchChild$[ebp], 0
	je	SHORT $LN10@fnSpawnInc
	mov	eax, DWORD PTR _lpSrchChild$[ebp]
	cmp	eax, DWORD PTR _lpTgtParent$[ebp]
	je	SHORT $LN10@fnSpawnInc

; 5798 :                {
; 5799 :                   if ( zGETPTR( lpSrchChild->hParent ) == lpSrchInstance &&
; 5800 :                        zGETPTR( lpSrchChild->hViewEntity ) == lpWkViewEntity &&

	mov	ecx, DWORD PTR _lpSrchChild$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSrchInstance$[ebp]
	jne	SHORT $LN34@fnSpawnInc
	mov	eax, DWORD PTR _lpSrchChild$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWkViewEntity$[ebp]
	jne	SHORT $LN34@fnSpawnInc
	mov	edx, DWORD PTR _lpSrchChild$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN34@fnSpawnInc

; 5801 :                        lpSrchChild->u.nInd.bHidden == FALSE )
; 5802 :                   {
; 5803 :                      break;

	jmp	SHORT $LN10@fnSpawnInc
$LN34@fnSpawnInc:

; 5804 :                   }
; 5805 : 
; 5806 :                   lpSrchChild = zGETPTR( lpSrchChild->hNextLinked );

	mov	ecx, DWORD PTR _lpSrchChild$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchChild$[ebp], eax

; 5807 :                }

	jmp	SHORT $LN9@fnSpawnInc
$LN10@fnSpawnInc:

; 5808 : 
; 5809 :                // If the spawn has not been done for this inversion, do it now.
; 5810 :                if ( lpSrchChild == 0 || lpSrchChild == lpTgtParent )

	cmp	DWORD PTR _lpSrchChild$[ebp], 0
	je	SHORT $LN36@fnSpawnInc
	mov	eax, DWORD PTR _lpSrchChild$[ebp]
	cmp	eax, DWORD PTR _lpTgtParent$[ebp]
	jne	$LN33@fnSpawnInc
$LN36@fnSpawnInc:

; 5811 :                {
; 5812 :                   LPVIEWOI  lpViewOI;
; 5813 :                   LPVIEWCSR lpViewCsr;
; 5814 : 
; 5815 :                   // Get a view to the entity instance which is the
; 5816 :                   // parent for the new spawn
; 5817 :                   lpViewOI    = zGETPTR( lpSrchInstance->hViewOI );

	mov	ecx, DWORD PTR _lpSrchInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$4[ebp], eax

; 5818 :                   lpViewCsr   = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$4[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$3[ebp], eax

; 5819 :                   lpSpawnView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$3[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSpawnView$[ebp], eax

; 5820 :                   CreateViewFromViewForTask( &lpSpawnView, lpSpawnView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpSpawnView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSpawnView$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 5821 :                   lpSpawnCsr = fnEstablishViewForInstance( lpSpawnView, 0,

	mov	eax, DWORD PTR _lpSrchInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSpawnView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpSpawnCsr$[ebp], eax

; 5822 :                                                            lpSrchInstance );
; 5823 :                   if ( lpRecursViewEntity != lpSrchViewEntity )

	mov	edx, DWORD PTR _lpRecursViewEntity$[ebp]
	cmp	edx, DWORD PTR _lpSrchViewEntity$[ebp]
	je	SHORT $LN13@fnSpawnInc

; 5824 :                   {
; 5825 :                      fnSetViewToSubobject( lpSpawnView, lpRecursViewEntity,

	mov	eax, DWORD PTR _lpSpawnCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRecursViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSpawnView$[ebp]
	push	edx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
$LN11@fnSpawnInc:

; 5826 :                                            lpSpawnCsr );
; 5827 :                      while ( zGETPTR( lpSpawnCsr->hViewEntity ) !=

	mov	eax, DWORD PTR _lpSpawnCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpSrchViewEntity$[ebp]
	je	SHORT $LN13@fnSpawnInc

; 5828 :                                                             lpSrchViewEntity )
; 5829 :                      {
; 5830 :                         lpSpawnCsr = zGETPTR( lpSpawnCsr->hParent );

	mov	edx, DWORD PTR _lpSpawnCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSpawnCsr$[ebp], eax

; 5831 :                      }

	jmp	SHORT $LN11@fnSpawnInc
$LN13@fnSpawnInc:

; 5832 :                   }
; 5833 : 
; 5834 :                   while ( zGETPTR( lpSpawnCsr->hViewEntity ) !=

	mov	ecx, DWORD PTR _lpSpawnCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWkViewEntity$[ebp]
	je	SHORT $LN14@fnSpawnInc

; 5835 :                                                             lpWkViewEntity )
; 5836 :                   {
; 5837 :                      lpSpawnCsr = zGETPTR( lpSpawnCsr->hNextHier );

	mov	eax, DWORD PTR _lpSpawnCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSpawnCsr$[ebp], eax

; 5838 :                   }

	jmp	SHORT $LN13@fnSpawnInc
$LN14@fnSpawnInc:

; 5839 : 
; 5840 :                   fnEstablishCursorForView( lpSpawnCsr );

	mov	edx, DWORD PTR _lpSpawnCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4

; 5841 :                   nRC = fnIncludeSubobjectFromSubobject( lpSpawnView,

	movzx	eax, WORD PTR _bMarkIncluded$[ebp]
	push	eax
	push	0
	push	2
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSpawnView$[ebp]
	push	edx
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	mov	WORD PTR _nRC$[ebp], ax

; 5842 :                                        lpWkViewEntity, lpTgtView,
; 5843 :                                        zGETPTR( lpTgtViewEntity->hParent ),
; 5844 :                                        zPOS_LAST, 0, bMarkIncluded );
; 5845 :                   DropView( lpSpawnView );

	mov	eax, DWORD PTR _lpSpawnView$[ebp]
	push	eax
	call	_DropView@4
$LN33@fnSpawnInc:

; 5846 :                }
; 5847 :             }
; 5848 : 
; 5849 :             lpWkViewEntity = zGETPTR( lpWkViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax

; 5850 :          }

	jmp	$LN7@fnSpawnInc
$LN30@fnSpawnInc:

; 5851 :       }
; 5852 : 
; 5853 :       // Now travel to next linked instance and try again.
; 5854 :       lpSrchInstance = zGETPTR( lpSrchInstance->hNextLinked );

	mov	eax, DWORD PTR _lpSrchInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$[ebp], eax

; 5855 :    }

	jmp	$LN2@fnSpawnInc
$LN3@fnSpawnInc:

; 5856 : 
; 5857 :    // Spawning pass 2, for every visible linked instance of the entity parent,
; 5858 :    // see if the same structure exists anywhere and needs to be spawned.
; 5859 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 5860 :    lpSrchInstance = zGETPTR( lpTgtParent->hNextLinked );

	mov	eax, DWORD PTR _lpTgtParent$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$[ebp], eax
$LN15@fnSpawnInc:

; 5861 : 
; 5862 :    while ( nRC == 0 && lpSrchInstance && lpSrchInstance != lpTgtParent )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	$LN16@fnSpawnInc
	cmp	DWORD PTR _lpSrchInstance$[ebp], 0
	je	$LN16@fnSpawnInc
	mov	eax, DWORD PTR _lpSrchInstance$[ebp]
	cmp	eax, DWORD PTR _lpTgtParent$[ebp]
	je	$LN16@fnSpawnInc

; 5863 :    {
; 5864 :       if ( lpSrchInstance->u.nInd.bHidden == FALSE )

	mov	ecx, DWORD PTR _lpSrchInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	$LN38@fnSpawnInc

; 5865 :       {
; 5866 :          lpSrchViewEntity = zGETPTR( lpSrchInstance->hViewEntity );

	mov	eax, DWORD PTR _lpSrchInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$[ebp], eax

; 5867 :          lpRecursViewEntity = lpSrchViewEntity;

	mov	edx, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	DWORD PTR _lpRecursViewEntity$[ebp], edx

; 5868 :          if ( lpSrchViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN39@fnSpawnInc
$LN19@fnSpawnInc:

; 5869 :          {
; 5870 :             do
; 5871 :             {
; 5872 :                lpSrchViewEntity = zGETPTR( lpSrchViewEntity->hParent );

	mov	edx, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchViewEntity$[ebp], eax

; 5873 : 
; 5874 :             } while ( lpSrchViewEntity->lEREntTok != lpRecursViewEntity->lEREntTok );

	mov	ecx, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	edx, DWORD PTR _lpRecursViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $LN19@fnSpawnInc
$LN39@fnSpawnInc:

; 5875 :          }
; 5876 : 
; 5877 :          // See if the linked entity instance has a child entity type
; 5878 :          // which is a non derived inversion of the target entity type.
; 5879 :          lpWkViewEntity = zGETPTR( lpSrchViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpSrchViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
$LN20@fnSpawnInc:

; 5880 :          while ( lpWkViewEntity )

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	$LN38@fnSpawnInc

; 5881 :          {
; 5882 :             if ( lpWkViewEntity->nLevel <= lpSrchViewEntity->nLevel )

	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	mov	edx, DWORD PTR _lpSrchViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	cmp	ecx, eax
	jg	SHORT $LN40@fnSpawnInc

; 5883 :             {
; 5884 :                lpWkViewEntity = 0;

	mov	DWORD PTR _lpWkViewEntity$[ebp], 0

; 5885 :                break;

	jmp	$LN38@fnSpawnInc
$LN40@fnSpawnInc:

; 5886 :             }
; 5887 : 
; 5888 :             if ( lpWkViewEntity->hParent == zGETHNDL( lpSrchViewEntity ) &&
; 5889 :                  lpWkViewEntity->lERRelTok == lpTgtViewEntity->lERRelTok &&
; 5890 :                  lpWkViewEntity->bRelLink1 == lpTgtViewEntity->bRelLink1 &&
; 5891 :                  fnInstanceVersionRootMatch( lpSrchInstance,
; 5892 :                                              lpTgtParent ) &&

	mov	ecx, DWORD PTR _lpSrchViewEntity$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], eax
	jne	$LN41@fnSpawnInc
	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	$LN41@fnSpawnInc
	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	cmp	ecx, eax
	jne	$LN41@fnSpawnInc
	mov	ecx, DWORD PTR _lpTgtParent$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrchInstance$[ebp]
	push	edx
	call	_fnInstanceVersionRootMatch
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	je	$LN41@fnSpawnInc
	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	jne	$LN41@fnSpawnInc

; 5893 :                  lpWkViewEntity->bDerived == FALSE )
; 5894 :             {
; 5895 :                // Here we have found an instance which has a child entity
; 5896 :                // type for spawning. Make sure this include has not already
; 5897 :                // been spawned.
; 5898 :                lpSrchChild = zGETPTR( lpTgtInstance->hNextLinked );

	mov	eax, DWORD PTR _lpTgtInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchChild$[ebp], eax
$LN22@fnSpawnInc:

; 5899 :                while ( lpSrchChild && lpSrchChild != lpTgtInstance )

	cmp	DWORD PTR _lpSrchChild$[ebp], 0
	je	SHORT $LN23@fnSpawnInc
	mov	edx, DWORD PTR _lpSrchChild$[ebp]
	cmp	edx, DWORD PTR _lpTgtInstance$[ebp]
	je	SHORT $LN23@fnSpawnInc

; 5900 :                {
; 5901 :                   if ( lpSrchChild->hParent == zGETHNDL( lpSrchInstance ) &&
; 5902 :                        lpSrchChild->hViewEntity == zGETHNDL( lpWkViewEntity ) &&

	mov	eax, DWORD PTR _lpSrchInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrchChild$[ebp]
	cmp	DWORD PTR [ecx+30], eax
	jne	SHORT $LN42@fnSpawnInc
	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSrchChild$[ebp]
	cmp	DWORD PTR [ecx+2], eax
	jne	SHORT $LN42@fnSpawnInc
	mov	edx, DWORD PTR _lpSrchChild$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN42@fnSpawnInc

; 5903 :                        lpSrchChild->u.nInd.bHidden == FALSE )
; 5904 :                   {
; 5905 :                      break;

	jmp	SHORT $LN23@fnSpawnInc
$LN42@fnSpawnInc:

; 5906 :                   }
; 5907 : 
; 5908 :                   lpSrchChild = zGETPTR( lpSrchChild->hNextLinked );

	mov	ecx, DWORD PTR _lpSrchChild$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchChild$[ebp], eax

; 5909 :                }

	jmp	SHORT $LN22@fnSpawnInc
$LN23@fnSpawnInc:

; 5910 : 
; 5911 :                // If the spawn has not been done for this structure match,
; 5912 :                // do it now.
; 5913 :                if ( lpSrchChild == 0 || lpSrchChild == lpTgtInstance )

	cmp	DWORD PTR _lpSrchChild$[ebp], 0
	je	SHORT $LN44@fnSpawnInc
	mov	eax, DWORD PTR _lpSrchChild$[ebp]
	cmp	eax, DWORD PTR _lpTgtInstance$[ebp]
	jne	$LN41@fnSpawnInc
$LN44@fnSpawnInc:

; 5914 :                {
; 5915 :                   LPVIEWOI  lpViewOI;
; 5916 :                   LPVIEWCSR lpViewCsr;
; 5917 : 
; 5918 :                   lpViewOI    = zGETPTR( lpSrchInstance->hViewOI );

	mov	ecx, DWORD PTR _lpSrchInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$2[ebp], eax

; 5919 :                   lpViewCsr   = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax

; 5920 : 
; 5921 :                   // Get a view to the entity instance which is the parent
; 5922 :                   // for the new spawn.
; 5923 :                   lpSpawnView = zGETPTR( lpViewCsr->hView );

	mov	edx, DWORD PTR _lpViewCsr$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSpawnView$[ebp], eax

; 5924 :                   CreateViewFromViewForTask( &lpSpawnView, lpSpawnView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpSpawnView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSpawnView$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 5925 :                   lpSpawnCsr = fnEstablishViewForInstance( lpSpawnView, 0,

	mov	eax, DWORD PTR _lpSrchInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpSpawnView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpSpawnCsr$[ebp], eax

; 5926 :                                                            lpSrchInstance );
; 5927 :                   if ( lpRecursViewEntity != lpSrchViewEntity )

	mov	edx, DWORD PTR _lpRecursViewEntity$[ebp]
	cmp	edx, DWORD PTR _lpSrchViewEntity$[ebp]
	je	SHORT $LN26@fnSpawnInc

; 5928 :                   {
; 5929 :                      fnSetViewToSubobject( lpSpawnView, lpRecursViewEntity, lpSpawnCsr );

	mov	eax, DWORD PTR _lpSpawnCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRecursViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSpawnView$[ebp]
	push	edx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
$LN24@fnSpawnInc:

; 5930 :                      while ( lpSpawnCsr->hViewEntity != zGETHNDL( lpSrchViewEntity ) )

	mov	eax, DWORD PTR _lpSrchViewEntity$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSpawnCsr$[ebp]
	cmp	DWORD PTR [ecx+14], eax
	je	SHORT $LN26@fnSpawnInc

; 5931 :                         lpSpawnCsr = zGETPTR( lpSpawnCsr->hParent );

	mov	edx, DWORD PTR _lpSpawnCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSpawnCsr$[ebp], eax
	jmp	SHORT $LN24@fnSpawnInc
$LN26@fnSpawnInc:

; 5932 :                   }
; 5933 : 
; 5934 :                   while ( lpSpawnCsr->hViewEntity != zGETHNDL( lpWkViewEntity ) )

	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpSpawnCsr$[ebp]
	cmp	DWORD PTR [edx+14], eax
	je	SHORT $LN27@fnSpawnInc

; 5935 :                      lpSpawnCsr = zGETPTR( lpSpawnCsr->hNextHier );

	mov	eax, DWORD PTR _lpSpawnCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSpawnCsr$[ebp], eax
	jmp	SHORT $LN26@fnSpawnInc
$LN27@fnSpawnInc:

; 5936 : 
; 5937 :                   fnEstablishCursorForView( lpSpawnCsr );

	mov	edx, DWORD PTR _lpSpawnCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4

; 5938 :                   nRC = fnIncludeSubobjectFromSubobject( lpSpawnView,

	movzx	eax, WORD PTR _bMarkIncluded$[ebp]
	push	eax
	push	0
	push	2
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSpawnView$[ebp]
	push	ecx
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	mov	WORD PTR _nRC$[ebp], ax

; 5939 :                                                          lpWkViewEntity,
; 5940 :                                                          lpTgtView,
; 5941 :                                                          lpTgtViewEntity,
; 5942 :                                                          zPOS_LAST, 0,
; 5943 :                                                          bMarkIncluded );
; 5944 :                   DropView( lpSpawnView );

	mov	edx, DWORD PTR _lpSpawnView$[ebp]
	push	edx
	call	_DropView@4
$LN41@fnSpawnInc:

; 5945 :                }
; 5946 :             }
; 5947 : 
; 5948 :             lpWkViewEntity = zGETPTR( lpWkViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax

; 5949 :          }

	jmp	$LN20@fnSpawnInc
$LN38@fnSpawnInc:

; 5950 :       }
; 5951 : 
; 5952 :       // Now travel to next linked instance and try again
; 5953 :       lpSrchInstance = zGETPTR( lpSrchInstance->hNextLinked );

	mov	edx, DWORD PTR _lpSrchInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchInstance$[ebp], eax

; 5954 :    }

	jmp	$LN15@fnSpawnInc
$LN16@fnSpawnInc:

; 5955 : 
; 5956 :    // We think we're done, return the results
; 5957 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSpawnInc:

; 5958 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSpawnIncludeSubobject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_IncludeInfo$ = -516					; size = 37
_lpEI$1 = -476						; size = 4
_lpTask$2 = -472					; size = 4
_lpTask$3 = -468					; size = 4
_lpEntityInstance$4 = -464				; size = 4
_lpSrcViewOI$ = -460					; size = 4
_lpPrevVsn$5 = -456					; size = 4
_lpPrevVsn$6 = -452					; size = 4
_lpParentEntityInstance$ = -448				; size = 4
_lpTgtViewCsr$ = -444					; size = 4
_lpSrcViewCsr$ = -440					; size = 4
_lpWorkParentCsr$7 = -436				; size = 4
_lpTgtViewOI$ = -432					; size = 4
_nRC$ = -428						; size = 2
_lpTgtParent$8 = -424					; size = 4
_lpWrkEntityInstance$ = -420				; size = 4
_lpSrcViewEntityCsr$ = -416				; size = 4
_lpTgtViewEntityCsr$ = -412				; size = 4
_lpSrcInstance$9 = -408					; size = 4
_szMsg$10 = -404					; size = 400
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_lpTgtViewEntity$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_lpSrcViewEntity$ = 20					; size = 4
_nPosition$ = 24					; size = 2
_bNewRoot$ = 28						; size = 2
_bMarkIncluded$ = 32					; size = 2
_fnIncludeSubobjectFromSubobject PROC

; 5491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 516				; 00000204H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5492 :    LPVIEWOI          lpSrcViewOI;
; 5493 :    LPVIEWOI          lpTgtViewOI;
; 5494 :    LPVIEWCSR         lpSrcViewCsr;
; 5495 :    LPVIEWCSR         lpTgtViewCsr;
; 5496 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 5497 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 5498 :    LPENTITYINSTANCE  lpParentEntityInstance;
; 5499 :    LPENTITYINSTANCE  lpWrkEntityInstance;
; 5500 :    IncludeInfoRecord IncludeInfo;
; 5501 :    zSHORT            nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 5502 : 
; 5503 :    // Get the view cursors for the source and target views.
; 5504 :    lpSrcViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewCsr$[ebp], eax

; 5505 :    lpTgtViewCsr = zGETPTR( lpTgtView->hViewCsr );

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewCsr$[ebp], eax

; 5506 : 
; 5507 :    // Get the view Object Instances for the source and target views.
; 5508 :    lpSrcViewOI = zGETPTR( lpSrcViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 5509 :    lpTgtViewOI = zGETPTR( lpTgtViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 5510 : 
; 5511 :    lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax
$LN2@fnIncludeS:

; 5512 :    while ( lpSrcViewEntityCsr->nHierNbr != lpSrcViewEntity->nHierNbr )

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+24]
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	cmp	eax, edx
	je	SHORT $LN3@fnIncludeS

; 5513 :       lpSrcViewEntityCsr++;

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax
	jmp	SHORT $LN2@fnIncludeS
$LN3@fnIncludeS:

; 5514 : 
; 5515 :    lpTgtViewEntityCsr = zGETPTR( lpTgtViewCsr->hRootViewEntityCsr );

	mov	ecx, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewEntityCsr$[ebp], eax
$LN4@fnIncludeS:

; 5516 :    while ( lpTgtViewEntityCsr->nHierNbr != lpTgtViewEntity->nHierNbr )

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	cmp	ecx, eax
	je	SHORT $LN5@fnIncludeS

; 5517 :       lpTgtViewEntityCsr++;

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpTgtViewEntityCsr$[ebp], ecx
	jmp	SHORT $LN4@fnIncludeS
$LN5@fnIncludeS:

; 5518 : 
; 5519 :    // Now that we know we can safely insert the target entity in the
; 5520 :    // target object, check that the source and target objects are
; 5521 :    // compatible for inclusion from one subobject to the other.
; 5522 :    if ( fnValidSubobjectStructureMatch( lpTgtView, lpTgtViewEntity,
; 5523 :                                         lpSrcView,
; 5524 :                                         lpSrcViewEntity, 1 ) < 0 )

	push	1
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnValidSubobjectStructureMatch
	add	esp, 20					; 00000014H
	cwde
	test	eax, eax
	jge	SHORT $LN18@fnIncludeS

; 5525 :    {
; 5526 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnIncludeS
$LN18@fnIncludeS:

; 5527 :    }
; 5528 : 
; 5529 :    // Next, check to make sure that the source entity or any of its
; 5530 :    // linked instances is not already a child of the target's parent.
; 5531 :    // To do this, compare the parents of the source instance and all
; 5532 :    // its linked instances to the parent of the target instance.  If
; 5533 :    // a match is found, issue an error.
; 5534 :    if ( lpTgtViewEntityCsr->hEntityInstance &&

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	$LN19@fnIncludeS
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 1
	je	$LN19@fnIncludeS

; 5535 :         lpTgtViewEntityCsr->hEntityInstance != UNSET_CSR )
; 5536 :    {
; 5537 :       LPENTITYINSTANCE lpEntityInstance = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$4[ebp], eax

; 5538 : 
; 5539 :       lpParentEntityInstance = zGETPTR( lpEntityInstance->hParent );

	mov	edx, DWORD PTR _lpEntityInstance$4[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentEntityInstance$[ebp], eax

; 5540 :       if ( lpParentEntityInstance )

	cmp	DWORD PTR _lpParentEntityInstance$[ebp], 0
	je	$LN19@fnIncludeS

; 5541 :       {
; 5542 :          if ( fnInstanceChildOfInstanceForRel( zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+199]
	push	edx
	mov	eax, DWORD PTR _lpParentEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceChildOfInstanceForRel
	add	esp, 12					; 0000000cH
	cwde
	test	eax, eax
	je	SHORT $LN19@fnIncludeS

; 5543 :                                                lpParentEntityInstance,
; 5544 :                                                lpTgtViewEntity->lERRelTok ) )
; 5545 :          {
; 5546 :             LPTASK lpTask = zGETPTR( lpSrcView->hTask );

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$3[ebp], eax

; 5547 :             zCHAR szMsg[ 400 ];
; 5548 : 
; 5549 :             // "KZOEE129 - "KZOEE129 - Trying to create a relationship (via "
; 5550 :             //             Include, possibly as part of a spawn) that already "
; 5551 :             //             exists.  See trace for more."
; 5552 :             zsprintf( szMsg, "Source view entity = %s, Target view entity = %s",

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG15293
	lea	edx, DWORD PTR _szMsg$10[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 5553 :                       lpSrcViewEntity->szName, lpTgtViewEntity->szName );
; 5554 :             fnIssueCoreError( lpTask, lpSrcView, 8, 129, 0, szMsg, 0 );

	push	0
	lea	eax, DWORD PTR _szMsg$10[ebp]
	push	eax
	push	0
	push	129					; 00000081H
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$3[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5555 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnIncludeS
$LN19@fnIncludeS:

; 5556 :          }
; 5557 :       }
; 5558 :    }
; 5559 : 
; 5560 :    // Ensure that neither the source instance nor the target
; 5561 :    // position are a previous version or have a parent which is a
; 5562 :    // previous version.  A previous versioned parent may exist in the
; 5563 :    // case where a structure is inverted.
; 5564 :    lpWrkEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
$LN6@fnIncludeS:

; 5565 : 
; 5566 :    // 3/4/93 - Error changed so it is issued only when the instance
; 5567 :    // has been created under a versioned parent.
; 5568 :    while ( lpWrkEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN8@fnIncludeS

; 5569 :       lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax
	jmp	SHORT $LN6@fnIncludeS
$LN8@fnIncludeS:

; 5570 : 
; 5571 :    while ( lpWrkEntityInstance )

	cmp	DWORD PTR _lpWrkEntityInstance$[ebp], 0
	je	SHORT $LN9@fnIncludeS

; 5572 :    {
; 5573 :       if ( lpWrkEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpWrkEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN22@fnIncludeS

; 5574 :          break;

	jmp	SHORT $LN9@fnIncludeS
$LN22@fnIncludeS:

; 5575 : 
; 5576 :       lpWrkEntityInstance = zGETPTR( lpWrkEntityInstance->hParent );

	mov	eax, DWORD PTR _lpWrkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkEntityInstance$[ebp], eax

; 5577 :    }

	jmp	SHORT $LN8@fnIncludeS
$LN9@fnIncludeS:

; 5578 : 
; 5579 :    // If a versioned entity instance was found, issue a logic error.
; 5580 :    if ( lpWrkEntityInstance )

	cmp	DWORD PTR _lpWrkEntityInstance$[ebp], 0
	je	$LN23@fnIncludeS

; 5581 :    {
; 5582 :       LPENTITYINSTANCE lpSrcInstance;
; 5583 :       LPENTITYINSTANCE lpTgtParent;
; 5584 : 
; 5585 :       // We have a source instance which may go away as the result of
; 5586 :       // a cancel, make sure the target parent is in the same version.
; 5587 :       lpSrcInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$9[ebp], eax
$LN10@fnIncludeS:

; 5588 :       while ( lpSrcInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpSrcInstance$9[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN12@fnIncludeS

; 5589 :          lpSrcInstance = zGETPTR( lpSrcInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpSrcInstance$9[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$9[ebp], eax
	jmp	SHORT $LN10@fnIncludeS
$LN12@fnIncludeS:

; 5590 : 
; 5591 :       while ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$9[ebp], 0
	je	SHORT $LN13@fnIncludeS

; 5592 :       {
; 5593 :          if ( lpSrcInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpSrcInstance$9[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN24@fnIncludeS

; 5594 :             break;

	jmp	SHORT $LN13@fnIncludeS
$LN24@fnIncludeS:

; 5595 : 
; 5596 :          lpSrcInstance = zGETPTR( lpSrcInstance->hParent );

	mov	edx, DWORD PTR _lpSrcInstance$9[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$9[ebp], eax

; 5597 :       }

	jmp	SHORT $LN12@fnIncludeS
$LN13@fnIncludeS:

; 5598 : 
; 5599 :       // The source instance is versioned, now it is pointing to
; 5600 :       // the root of sources previous version, see if the parent
; 5601 :       // target entity instance is part of the same version, if so
; 5602 :       // then the include can happen, otherwise the include must fail
; 5603 :       // because it may disappear as the result of a cancel call.
; 5604 :       if ( lpSrcInstance && lpTgtViewEntityCsr->hParent )

	cmp	DWORD PTR _lpSrcInstance$9[ebp], 0
	je	$LN25@fnIncludeS
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	$LN25@fnIncludeS

; 5605 :       {
; 5606 :          LPVIEWENTITYCSR lpWorkParentCsr;
; 5607 : 
; 5608 :          lpSrcInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$9[ebp], eax
$LN14@fnIncludeS:

; 5609 :          while ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$9[ebp], 0
	je	SHORT $LN15@fnIncludeS

; 5610 :          {
; 5611 :             LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpSrcInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpSrcInstance$9[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$6[ebp], eax

; 5612 : 
; 5613 :             if ( lpSrcInstance->u.nInd.bTemporal ||

	mov	eax, DWORD PTR _lpSrcInstance$9[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN27@fnIncludeS
	cmp	DWORD PTR _lpPrevVsn$6[ebp], 0
	je	SHORT $LN26@fnIncludeS
	mov	edx, DWORD PTR _lpPrevVsn$6[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN26@fnIncludeS
$LN27@fnIncludeS:

; 5614 :                  (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 5615 :             {
; 5616 :                break;

	jmp	SHORT $LN15@fnIncludeS
$LN26@fnIncludeS:

; 5617 :             }
; 5618 : 
; 5619 :             lpSrcInstance = zGETPTR( lpSrcInstance->hParent );

	mov	ecx, DWORD PTR _lpSrcInstance$9[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$9[ebp], eax

; 5620 :          }

	jmp	SHORT $LN14@fnIncludeS
$LN15@fnIncludeS:

; 5621 : 
; 5622 :          lpWorkParentCsr = zGETPTR( lpTgtViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkParentCsr$7[ebp], eax

; 5623 :          if ( lpWorkParentCsr->hEntityInstance == UNSET_CSR )

	mov	edx, DWORD PTR _lpWorkParentCsr$7[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	SHORT $LN28@fnIncludeS

; 5624 :             fnEstablishCursorForView( lpWorkParentCsr );

	mov	eax, DWORD PTR _lpWorkParentCsr$7[ebp]
	push	eax
	call	_fnEstablishCursorForView
	add	esp, 4
$LN28@fnIncludeS:

; 5625 : 
; 5626 :          lpTgtParent = zGETPTR( lpWorkParentCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpWorkParentCsr$7[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$8[ebp], eax
$LN16@fnIncludeS:

; 5627 :          while ( lpTgtParent )

	cmp	DWORD PTR _lpTgtParent$8[ebp], 0
	je	SHORT $LN17@fnIncludeS

; 5628 :          {
; 5629 :             LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpTgtParent->hPrevVsn );

	mov	eax, DWORD PTR _lpTgtParent$8[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$5[ebp], eax

; 5630 : 
; 5631 :             if ( lpTgtParent->u.nInd.bTemporal ||

	mov	edx, DWORD PTR _lpTgtParent$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	jne	SHORT $LN30@fnIncludeS
	cmp	DWORD PTR _lpPrevVsn$5[ebp], 0
	je	SHORT $LN29@fnIncludeS
	mov	ecx, DWORD PTR _lpPrevVsn$5[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	je	SHORT $LN29@fnIncludeS
$LN30@fnIncludeS:

; 5632 :                  (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 5633 :             {
; 5634 :                break;

	jmp	SHORT $LN17@fnIncludeS
$LN29@fnIncludeS:

; 5635 :             }
; 5636 : 
; 5637 :             lpTgtParent = zGETPTR( lpTgtParent->hParent );

	mov	eax, DWORD PTR _lpTgtParent$8[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$8[ebp], eax

; 5638 :          }

	jmp	SHORT $LN16@fnIncludeS
$LN17@fnIncludeS:

; 5639 : 
; 5640 :          if ( lpTgtParent == 0 || lpTgtParent != lpSrcInstance )

	cmp	DWORD PTR _lpTgtParent$8[ebp], 0
	je	SHORT $LN33@fnIncludeS
	mov	edx, DWORD PTR _lpTgtParent$8[ebp]
	cmp	edx, DWORD PTR _lpSrcInstance$9[ebp]
	je	SHORT $LN31@fnIncludeS
$LN33@fnIncludeS:

; 5641 :             lpSrcInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$9[ebp], eax
	jmp	SHORT $LN25@fnIncludeS
$LN31@fnIncludeS:

; 5642 :          else
; 5643 :             lpSrcInstance = 0;

	mov	DWORD PTR _lpSrcInstance$9[ebp], 0
$LN25@fnIncludeS:

; 5644 :       }
; 5645 : 
; 5646 :       if ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$9[ebp], 0
	je	SHORT $LN23@fnIncludeS

; 5647 :       {
; 5648 :          LPTASK lpTask = zGETPTR( lpSrcView->hTask );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 5649 :          // "KZOEE133 - Attempt to include an Entity Instance with "
; 5650 :          //             versioned parent"
; 5651 :          //
; 5652 :          //  NOTE!! Message has been changed to
; 5653 :          //
; 5654 :          //  "KZOEE116 - Attempt to include an instance created under
; 5655 :          //  "           a versioned parent"
; 5656 :          //
; 5657 :          fnIssueCoreError( lpTask, lpSrcView, 8, 116, 0,

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	116					; 00000074H
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$2[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 5658 :                            lpSrcViewEntity->szName,
; 5659 :                            lpTgtViewEntity->szName );
; 5660 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnIncludeS
$LN23@fnIncludeS:

; 5661 :       }
; 5662 :    }
; 5663 : 
; 5664 :    // Set up include info.
; 5665 :    IncludeInfo.lpTgtView      = lpTgtView;

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	DWORD PTR _IncludeInfo$[ebp], edx

; 5666 :    IncludeInfo.lpTgtViewOI    = lpTgtViewOI;

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR _IncludeInfo$[ebp+4], eax

; 5667 :    IncludeInfo.lpTgtAllocTask = zGETPTR( lpTgtViewOI->hAllocTask );

	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _IncludeInfo$[ebp+8], eax

; 5668 :    IncludeInfo.lpSrcView      = lpSrcView;

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	DWORD PTR _IncludeInfo$[ebp+12], eax

; 5669 :    IncludeInfo.lpSrcViewOI    = lpSrcViewOI;

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	DWORD PTR _IncludeInfo$[ebp+16], ecx

; 5670 :    IncludeInfo.lpSrcViewCsr   = lpSrcViewCsr;

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	DWORD PTR _IncludeInfo$[ebp+24], edx

; 5671 :    IncludeInfo.lpSrcAllocTask = zGETPTR( lpSrcViewOI->hAllocTask );

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _IncludeInfo$[ebp+20], eax

; 5672 :    IncludeInfo.nVsnLevel      = 0;

	xor	edx, edx
	mov	WORD PTR _IncludeInfo$[ebp+28], dx

; 5673 :    IncludeInfo.bFirstEntity   = TRUE;

	mov	BYTE PTR _IncludeInfo$[ebp+30], 1

; 5674 :    IncludeInfo.bNewRoot       = bNewRoot;

	mov	ax, WORD PTR _bNewRoot$[ebp]
	mov	WORD PTR _IncludeInfo$[ebp+31], ax

; 5675 :    IncludeInfo.nPosition      = nPosition;

	mov	cx, WORD PTR _nPosition$[ebp]
	mov	WORD PTR _IncludeInfo$[ebp+35], cx

; 5676 :    IncludeInfo.bMarkIncluded  = bMarkIncluded;

	mov	dx, WORD PTR _bMarkIncluded$[ebp]
	mov	WORD PTR _IncludeInfo$[ebp+33], dx

; 5677 : 
; 5678 :    if ( fnIncludeEntityAndChildren( lpTgtViewEntity,
; 5679 :                                     lpTgtViewEntityCsr,
; 5680 :                                     zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),
; 5681 :                                     TRUE, &IncludeInfo ) == zCALL_ERROR )

	lea	eax, DWORD PTR _IncludeInfo$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	call	_fnIncludeEntityAndChildren@20
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN35@fnIncludeS

; 5682 :    {
; 5683 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$38
$LN35@fnIncludeS:

; 5684 :    }
; 5685 : 
; 5686 :    // R056357
; 5687 :    // bDerived is checked inside fnSetUpdateIndicator, so don't check it here.
; 5688 :    if ( bMarkIncluded &&
; 5689 :         lpTgtViewEntityCsr->hParent && lpTgtViewEntityCsr->hEntityInstance )

	movsx	eax, WORD PTR _bMarkIncluded$[ebp]
	test	eax, eax
	je	SHORT $LN36@fnIncludeS
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN36@fnIncludeS
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN36@fnIncludeS

; 5690 :    {
; 5691 :       // HH 2001.08.03 use fnSetUpdateIndicator.
; 5692 :       LPENTITYINSTANCE lpEI = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEI$1[ebp], eax

; 5693 :       fnSetUpdateIndicator( lpTgtViewOI, lpEI, 0, TRUE, FALSE, FALSE );

	push	0
	push	0
	push	1
	push	0
	mov	edx, DWORD PTR _lpEI$1[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	push	eax
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$LN36@fnIncludeS:

; 5694 :    }
; 5695 : 
; 5696 :    // Now that we have included the source subobject in the target
; 5697 :    // instance, see if we need to spawn a new include because the
; 5698 :    // target instance contains the same structure a second time at
; 5699 :    // the definition level either inverted or not.
; 5700 :    nRC = fnSpawnIncludeSubobject( lpTgtView, lpTgtViewOI,

	movzx	ecx, WORD PTR _bMarkIncluded$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnSpawnIncludeSubobject
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$38:

; 5701 :                                   lpTgtViewEntity, lpTgtViewEntityCsr,
; 5702 :                                   bMarkIncluded );
; 5703 : 
; 5704 : EndOfFunction:
; 5705 : 
; 5706 :    // Reset the cursor for the target entity view children.
; 5707 :    fnResetCursorForViewChildren( lpTgtViewEntityCsr );

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 5708 : 
; 5709 :    // Simple enough, let's return to caller.
; 5710 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnIncludeS:

; 5711 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnIncludeSubobjectFromSubobject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpTask$1 = -8						; size = 4
_nInvertedParents$ = -4					; size = 2
_lpTgtView$ = 8						; size = 4
_lpTgtViewEntity$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_lpSrcViewEntity$ = 20					; size = 4
_bInclude$ = 24						; size = 1
_fnValidSubobjectStructureMatch PROC

; 4899 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4900 :    zSHORT nInvertedParents;
; 4901 : 
; 4902 :    nInvertedParents = 0;

	xor	eax, eax
	mov	WORD PTR _nInvertedParents$[ebp], ax

; 4903 :    if ( lpSrcViewEntity->lEREntTok != lpTgtViewEntity->lEREntTok )

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	je	SHORT $LN2@fnValidSub

; 4904 :    {
; 4905 :       LPTASK lpTask = zGETPTR( lpSrcView->hTask );

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 4906 : 
; 4907 :       //  "KZOEE125 - Target and Source Entities are not the same E/R Entity"
; 4908 :       fnIssueCoreError( lpTask, lpSrcView, 8, 125, 0,

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	125					; 0000007dH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$1[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4909 :                         lpTgtViewEntity->szName,
; 4910 :                         lpSrcViewEntity->szName );
; 4911 :       return( zCALL_ERROR );  // entities do not match

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnValidSub
$LN2@fnValidSub:

; 4912 :    }
; 4913 : 
; 4914 :    nInvertedParents = fnValidStructureEntity( lpTgtView, lpTgtViewEntity,

	movzx	ecx, BYTE PTR _bInclude$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnValidStructureEntity@20
	mov	WORD PTR _nInvertedParents$[ebp], ax

; 4915 :                                               lpSrcView,
; 4916 :                                               lpSrcViewEntity, bInclude );
; 4917 : 
; 4918 :    // Return the number of inverted parents found.
; 4919 :    return( nInvertedParents );

	mov	ax, WORD PTR _nInvertedParents$[ebp]
$LN1@fnValidSub:

; 4920 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidSubobjectStructureMatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewEntity$ = -36					; size = 4
_lpPrevVsn$ = -32					; size = 4
_lpViewEntityCsr$ = -28					; size = 4
_lpCurrentTask$ = -24					; size = 4
_lpParent$1 = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_nRC$ = -12						; size = 2
_nUpdatedFile$ = -8					; size = 2
_nUpdated$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_bRootOnly$ = 16					; size = 2
_SubobjectVersionUpdated@12 PROC

; 6236 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 6237 :    LPTASK           lpCurrentTask;
; 6238 :    LPVIEWENTITY     lpViewEntity;
; 6239 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 6240 :    LPENTITYINSTANCE lpEntityInstance;
; 6241 :    LPENTITYINSTANCE lpPrevVsn;
; 6242 :    zSHORT           nUpdated = 0;

	xor	eax, eax
	mov	WORD PTR _nUpdated$[ebp], ax

; 6243 :    zSHORT           nUpdatedFile = 0;

	xor	ecx, ecx
	mov	WORD PTR _nUpdatedFile$[ebp], cx

; 6244 :    zSHORT           nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 6245 : 
; 6246 :    // Validate parameters
; 6247 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	134					; 00000086H
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN4@SubobjectV

; 6248 :                                       &lpViewEntity,
; 6249 :                                       &lpViewEntityCsr,
; 6250 :                                       iSubobjectVersionUpdated,
; 6251 :                                       lpView,
; 6252 :                                       cpcEntityName, 0 ) )
; 6253 :    {
; 6254 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SubobjectV
$LN4@SubobjectV:

; 6255 :    }
; 6256 : 
; 6257 :    // Get instance on which to start.
; 6258 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN2@SubobjectV:

; 6259 : 
; 6260 :    // Go to the latest version.
; 6261 :    while ( lpEntityInstance->hNextVsn )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN3@SubobjectV

; 6262 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextVsn );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN2@SubobjectV
$LN3@SubobjectV:

; 6263 : 
; 6264 :    // If the entity instance is not versioned, return unless it's not
; 6265 :    // created under a parent which IS versioned.
; 6266 :    lpPrevVsn = zGETPTR( lpEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 6267 :    if ( lpEntityInstance->u.nInd.bTemporal == FALSE && lpPrevVsn == 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN5@SubobjectV
	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	jne	SHORT $LN5@SubobjectV

; 6268 :    {
; 6269 :       // Entity instance is NOT versioned.
; 6270 :       LPENTITYINSTANCE lpParent = zGETPTR( lpEntityInstance->hParent );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$1[ebp], eax

; 6271 :       if ( lpEntityInstance->u.nInd.bCreated && lpParent &&

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN6@SubobjectV
	cmp	DWORD PTR _lpParent$1[ebp], 0
	je	SHORT $LN6@SubobjectV
	mov	ecx, DWORD PTR _lpParent$1[ebp]
	cmp	DWORD PTR [ecx+38], 0
	jne	SHORT $LN8@SubobjectV
	mov	edx, DWORD PTR _lpParent$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN6@SubobjectV
$LN8@SubobjectV:

; 6272 :            (lpParent->hPrevVsn || lpParent->u.nInd.bTemporal) )
; 6273 :       {
; 6274 :          // This is the exception!  Do NOT return because the EI is
; 6275 :          // created under a versioned parent.
; 6276 :       }

	jmp	SHORT $LN5@SubobjectV
$LN6@SubobjectV:

; 6277 :       else
; 6278 :       {
; 6279 :          // Not versioned, and the exception does not apply ... return.
; 6280 :          fnOperationReturn( iSubobjectVersionUpdated, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	134					; 00000086H
	call	_fnOperationReturn
	add	esp, 8

; 6281 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@SubobjectV
$LN5@SubobjectV:

; 6282 :       }
; 6283 :    }
; 6284 : 
; 6285 :    if ( bRootOnly )

	movsx	edx, WORD PTR _bRootOnly$[ebp]
	test	edx, edx
	je	SHORT $LN9@SubobjectV

; 6286 :    {
; 6287 :       if ( lpEntityInstance->u.nInd.bVersionUpdFile )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 25					; 00000019H
	and	ecx, 1
	je	SHORT $LN11@SubobjectV

; 6288 :          nUpdatedFile = 1;

	mov	edx, 1
	mov	WORD PTR _nUpdatedFile$[ebp], dx
$LN11@SubobjectV:

; 6289 : 
; 6290 :       if ( lpEntityInstance->u.nInd.bVersionUpdated )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 24					; 00000018H
	and	ecx, 1
	je	SHORT $LN12@SubobjectV

; 6291 :          nUpdated = 1;

	mov	edx, 1
	mov	WORD PTR _nUpdated$[ebp], dx
$LN12@SubobjectV:

; 6292 :    }

	jmp	SHORT $LN10@SubobjectV
$LN9@SubobjectV:

; 6293 :    else
; 6294 :    {
; 6295 :       fnGetResetUpdFlags( lpEntityInstance, &nUpdated, &nUpdatedFile, 0 );

	push	0
	lea	eax, DWORD PTR _nUpdatedFile$[ebp]
	push	eax
	lea	ecx, DWORD PTR _nUpdated$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnGetResetUpdFlags
	add	esp, 16					; 00000010H
$LN10@SubobjectV:

; 6296 :    }
; 6297 : 
; 6298 : 
; 6299 :    if ( nUpdated )

	movsx	eax, WORD PTR _nUpdated$[ebp]
	test	eax, eax
	je	SHORT $LN13@SubobjectV

; 6300 :       nRC = 2;

	mov	ecx, 2
	mov	WORD PTR _nRC$[ebp], cx
	jmp	SHORT $LN14@SubobjectV
$LN13@SubobjectV:

; 6301 :    else
; 6302 :    if ( nUpdatedFile )

	movsx	edx, WORD PTR _nUpdatedFile$[ebp]
	test	edx, edx
	je	SHORT $LN14@SubobjectV

; 6303 :       nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN14@SubobjectV:

; 6304 : 
; 6305 :    fnOperationReturn( iSubobjectVersionUpdated, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	134					; 00000086H
	call	_fnOperationReturn
	add	esp, 8

; 6306 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SubobjectV:

; 6307 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SubobjectVersionUpdated@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpTgtOwningTask$ = -620				; size = 4
_lpSrcOwningTask$ = -616				; size = 4
_lpLastSource$ = -612					; size = 4
_lpWrkViewEntity$1 = -608				; size = 4
_lpTgtViewCsr$ = -604					; size = 4
_lpSrcViewCsr$ = -600					; size = 4
tv200 = -596						; size = 4
tv359 = -592						; size = 4
tv353 = -588						; size = 4
tv199 = -584						; size = 4
_bIncluded$ = -580					; size = 2
_hTgtViewEntity$ = -576					; size = 4
_lpSrcViewEntityCsr$ = -572				; size = 4
_lpInvertedSrcCsr$ = -568				; size = 4
_lpFirstSourceViewEntity$2 = -564			; size = 4
_vTask$ = -560						; size = 4
_lpTgtViewEntityCsr$ = -556				; size = 4
_lpSrcViewOI$ = -552					; size = 4
_nNotFound$ = -548					; size = 2
_hSrcViewEntity$ = -544					; size = 4
_nInvertedParents$ = -540				; size = 2
_lpSrcViewOD$ = -536					; size = 4
_lpSrcRootEntityInstance$ = -532			; size = 4
_lpTgtViewOD$ = -528					; size = 4
_nStopTgtHier$ = -524					; size = 2
_bLeafNode$ = -520					; size = 2
_nStopSrcHier$ = -516					; size = 2
_bDoTgtTwin$ = -511					; size = 1
_bUpdatedFile$ = -510					; size = 1
_bUpdated$ = -509					; size = 1
_lpWkEntityInstance$ = -508				; size = 4
_lpTgtViewOI$ = -504					; size = 4
_bDoSrcTwin$ = -497					; size = 1
_lpSrcViewEntity$ = -496				; size = 4
_lpFirstSource$ = -492					; size = 4
_lpCurrentTask$ = -488					; size = 4
_lpInvertedSrcEntity$ = -484				; size = 4
_lpTgtViewEntity$ = -480				; size = 4
_lpWkViewEntity$ = -476					; size = 4
_nRC$ = -472						; size = 2
_lpTgtEntityInstance$ = -468				; size = 4
_lpSrcEntityInstance$ = -464				; size = 4
_szMsg$3 = -460						; size = 200
_cpcEntityName$ = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_RelinkAllSubobjectsForOI@16 PROC

; 4157 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 620				; 0000026cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4158 :    LPTASK            lpCurrentTask;
; 4159 :    LPTASK            lpSrcOwningTask;
; 4160 :    LPTASK            lpTgtOwningTask;
; 4161 :    zVIEW             vTask;
; 4162 :    LPVIEWCSR         lpSrcViewCsr;
; 4163 :    LPVIEWCSR         lpTgtViewCsr;
; 4164 :    LPVIEWOI          lpSrcViewOI;
; 4165 :    LPVIEWOI          lpTgtViewOI;
; 4166 :    LPVIEWOD          lpSrcViewOD;
; 4167 :    LPVIEWOD          lpTgtViewOD;
; 4168 :    LPVIEWENTITY      hSrcViewEntity;
; 4169 :    LPVIEWENTITY      hTgtViewEntity;
; 4170 :    LPVIEWENTITY      lpSrcViewEntity;
; 4171 :    LPVIEWENTITY      lpTgtViewEntity;
; 4172 :    LPVIEWENTITY      lpWkViewEntity;
; 4173 :    LPVIEWENTITY      lpInvertedSrcEntity;
; 4174 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 4175 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 4176 :    LPVIEWENTITYCSR   lpInvertedSrcCsr;
; 4177 :    LPENTITYINSTANCE  lpSrcEntityInstance;
; 4178 :    LPENTITYINSTANCE  lpSrcRootEntityInstance;
; 4179 :    LPENTITYINSTANCE  lpTgtEntityInstance;
; 4180 :    LPENTITYINSTANCE  lpWkEntityInstance;
; 4181 :    zCHAR             cpcEntityName[ 255 ];
; 4182 :    zSHORT            bLeafNode;
; 4183 :    zSHORT            bIncluded;
; 4184 :    zBOOL             bUpdated;
; 4185 :    zBOOL             bUpdatedFile;
; 4186 :    zSHORT            nInvertedParents;
; 4187 :    zSHORT            nNotFound;
; 4188 :    zSHORT            nRC;
; 4189 : 
; 4190 : #ifdef            __RELINK_PERFORMANCE__
; 4191 :    zBOOL             bDoSrcTwin;
; 4192 :    zBOOL             bDoTgtTwin;
; 4193 :    zSHORT            nStopSrcHier;
; 4194 :    zSHORT            nStopTgtHier;
; 4195 :    LPENTITYINSTANCE  lpFirstSource;
; 4196 :    LPENTITYINSTANCE  lpLastSource;
; 4197 : #endif
; 4198 : 
; 4199 :    // Validate that the source view entity exists and has a cursor
; 4200 :    // value for copying, we call fnValidateInstanceParameters for the
; 4201 :    // source since it requires the same editing as an attribute retrieval.
; 4202 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	121					; 00000079H
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN36@RelinkAllS

; 4203 :                                       &lpSrcViewEntity,
; 4204 :                                       &lpSrcViewEntityCsr,
; 4205 :                                       iRelinkAllSubobjectsForOI,
; 4206 :                                       lpSrcView,
; 4207 :                                       cpcSrcEntityName, 0 ) )
; 4208 :    {
; 4209 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN36@RelinkAllS:

; 4210 :    }
; 4211 : 
; 4212 :    // Validate that the view passed is valid
; 4213 :    if ( fnValidViewCsr( lpCurrentTask, lpTgtView ) == 0 )

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN37@RelinkAllS

; 4214 :    {
; 4215 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4216 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN37@RelinkAllS:

; 4217 :    }
; 4218 : 
; 4219 :    if ( (lpTgtViewEntity = fnValidViewEntity( &lpTgtViewEntityCsr,
; 4220 :                                               lpTgtView,
; 4221 :                                               cpcTgtEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpTgtViewEntity$[ebp], eax
	cmp	DWORD PTR _lpTgtViewEntity$[ebp], 0
	jne	SHORT $LN38@RelinkAllS

; 4222 :    {
; 4223 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4224 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN38@RelinkAllS:

; 4225 :    }
; 4226 : 
; 4227 :    hSrcViewEntity = zGETHNDL( lpSrcViewEntity );

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hSrcViewEntity$[ebp], eax

; 4228 :    hTgtViewEntity = zGETHNDL( lpTgtViewEntity );

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hTgtViewEntity$[ebp], eax

; 4229 : 
; 4230 :    // Make sure entity can be included.
; 4231 :    if ( lpSrcViewEntity->bInclSrc == FALSE )

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN39@RelinkAllS

; 4232 :    {
; 4233 :       strcpy( cpcEntityName, "\nEntity: \t" );

	push	OFFSET $SG14889
	lea	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4234 :       strcat( cpcEntityName, lpSrcViewEntity->szName );

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4235 : 
; 4236 :       // "KZOEE106 - Rules violation"
; 4237 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	lea	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	OFFSET $SG14890
	push	0
	push	106					; 0000006aH
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4238 :                         "Source Entity not includeble",
; 4239 :                         cpcEntityName );
; 4240 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4241 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN39@RelinkAllS:

; 4242 :    }
; 4243 : 
; 4244 :    // Get the viewOI for the source and the target.
; 4245 :    lpSrcViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewCsr$[ebp], eax

; 4246 :    lpSrcViewOI  = zGETPTR( lpSrcViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 4247 :    lpTgtViewCsr = zGETPTR( lpTgtView->hViewCsr );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewCsr$[ebp], eax

; 4248 :    lpTgtViewOI =  zGETPTR( lpTgtViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 4249 : 
; 4250 :    // If the source view oi is the target view oi, then it is an error.
; 4251 :    if ( lpSrcViewOI == lpTgtViewOI )

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	cmp	eax, DWORD PTR _lpTgtViewOI$[ebp]
	jne	SHORT $LN40@RelinkAllS

; 4252 :    {
; 4253 :       // "KZOEE140 - Target and source Object instance are the same instance"
; 4254 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 140, 0,

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	140					; 0000008cH
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4255 :                         lpSrcViewEntity->szName,
; 4256 :                         lpTgtViewEntity->szName );
; 4257 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4258 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN40@RelinkAllS:

; 4259 :    }
; 4260 : 
; 4261 :    // Make sure that the LODs are in sync.  They are out of sync if the LODs
; 4262 :    // were built with different dates for the ER.  We won't bother performing
; 4263 :    // the check if either LOD doesn't have the ER date.  This allows old LODs
; 4264 :    // to work.
; 4265 :    lpSrcViewOD = zGETPTR( lpSrcView->hViewOD );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOD$[ebp], eax

; 4266 :    lpTgtViewOD = zGETPTR( lpTgtView->hViewOD );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOD$[ebp], eax

; 4267 :    if ( lpSrcViewOD->szER_Date[ 0 ] && lpTgtViewOD->szER_Date[ 0 ] &&

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+248]
	test	ecx, ecx
	je	$LN41@RelinkAllS
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+248]
	test	edx, edx
	je	$LN41@RelinkAllS
	mov	eax, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+248]
	mov	edx, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	cmp	ecx, eax
	jne	SHORT $LN91@RelinkAllS
	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv200[ebp], eax
	jmp	SHORT $LN92@RelinkAllS
$LN91@RelinkAllS:
	mov	eax, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+248]
	mov	edx, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN89@RelinkAllS
	mov	DWORD PTR tv199[ebp], 1
	jmp	SHORT $LN90@RelinkAllS
$LN89@RelinkAllS:
	mov	DWORD PTR tv199[ebp], -1
$LN90@RelinkAllS:
	mov	ecx, DWORD PTR tv199[ebp]
	mov	DWORD PTR tv200[ebp], ecx
$LN92@RelinkAllS:
	cmp	DWORD PTR tv200[ebp], 0
	je	$LN41@RelinkAllS

; 4268 :         zstrcmp( lpSrcViewOD->szER_Date, lpTgtViewOD->szER_Date ) != 0 )
; 4269 :    {
; 4270 :       zCHAR szMsg[ 200 ];
; 4271 : 
; 4272 :       TraceLineS( "ERROR: The following LODs are out of sync",

	push	OFFSET $SG14893
	push	OFFSET $SG14894
	call	_TraceLineS@8

; 4273 :                   " and should be re-built" );
; 4274 : 
; 4275 :       zsprintf( szMsg, "Out-of-sync error. Target LOD = %s, date = %s",

	mov	edx, DWORD PTR _lpTgtViewOD$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	eax, DWORD PTR _lpTgtViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14895
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4276 :                 lpTgtViewOD->szName, lpTgtViewOD->szER_Date );
; 4277 :       TraceLineS( "ERROR: ", szMsg );

	lea	edx, DWORD PTR _szMsg$3[ebp]
	push	edx
	push	OFFSET $SG14896
	call	_TraceLineS@8

; 4278 : 
; 4279 :       zsprintf( szMsg, "Out-of-sync error. Source LOD = %s, date = %s",

	mov	eax, DWORD PTR _lpSrcViewOD$[ebp]
	add	eax, 248				; 000000f8H
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14897
	lea	edx, DWORD PTR _szMsg$3[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4280 :                 lpSrcViewOD->szName, lpSrcViewOD->szER_Date );
; 4281 :       TraceLineS( "ERROR: ", szMsg );

	lea	eax, DWORD PTR _szMsg$3[ebp]
	push	eax
	push	OFFSET $SG14898
	call	_TraceLineS@8

; 4282 : 
; 4283 :       // "KZOEE106 - Rules violation"
; 4284 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14899
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4285 :                         "LODs are potentially out of sync.  See trace for more.",
; 4286 :                         lpTgtViewOD->szName );
; 4287 : 
; 4288 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4289 :    // fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );
; 4290 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN41@RelinkAllS:

; 4291 :    }
; 4292 : 
; 4293 :    // We will attempt relinking with either the source OR
; 4294 :    // the target versioned, If the source is versioned, the relinking
; 4295 :    // will take place with the OLDEST version of the source chain.
; 4296 :    // If the target is versioned, we will relink to the OLDEST version
; 4297 :    // instances of the target chain and then propogate the records to
; 4298 :    // the newer versions in the chain.. If the keys have changed in ANY
; 4299 :    // of the target instances of the link of an older version, then error
; 4300 :    // will be issued and the relinking will STOP midstream!!!. The instance
; 4301 :    // itself will be in a clean-upable mode, but its data will be
; 4302 :    // not be 100% in sync!!
; 4303 : #if 0
; 4304 :    // Make sure that none of the source instances to be included are
; 4305 :    // versioned.
; 4306 :    if ( lpSrcViewOI->nVersionedInstances )
; 4307 :    {
; 4308 :       //  "KZOEE116 - Attempt to include subobject with "
; 4309 :       //  " versioned instances"
; 4310 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 116, 0,
; 4311 :                         lpSrcViewEntity->hName, 0 );
; 4312 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );
; 4313 :    // fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );
; 4314 :       return( zCALL_ERROR );
; 4315 :    }
; 4316 : 
; 4317 :    if ( lpTgtViewOI->nVersionedInstances )
; 4318 :    {
; 4319 :       //  "KZOEE116 - Attempt to include subobject with "
; 4320 :       //  " versioned instances"
; 4321 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 116, 0,
; 4322 :                         lpSrcViewEntity->hName, 0 );
; 4323 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );
; 4324 :       return( zCALL_ERROR );
; 4325 :    }
; 4326 : #endif
; 4327 : 
; 4328 :    // Get source and target owning tasks
; 4329 :    lpSrcOwningTask = zGETPTR( lpSrcViewOI->hTask );

	mov	edx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcOwningTask$[ebp], eax

; 4330 :    lpTgtOwningTask = zGETPTR( lpTgtViewOI->hTask );

	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtOwningTask$[ebp], eax

; 4331 : 
; 4332 :    // Validate that the Source and Target ViewOI belong to the
; 4333 :    // Same task
; 4334 : #if 0
; 4335 :    if ( lpSrcOwningTask != lpTgtOwningTask )
; 4336 :    {
; 4337 :       zSHORT       nError;
; 4338 : 
; 4339 :       // if we have a task mismatch, make sure the source task is the
; 4340 :       // system task AND that all the target entities of the include
; 4341 :       // are READ ONLY.
; 4342 :       nError = 1;
; 4343 :       if ( lpSrcOwningTask == zGETPTR( AnchorBlock->hMainTask ) )
; 4344 :       {
; 4345 :          nError = 0;
; 4346 :          lpTgtViewOI->hAllocTask = lpSrcViewOI->hTask;
; 4347 :       }
; 4348 : 
; 4349 :       if ( nError )
; 4350 :       {
; 4351 :          // "KZOEE131 - Attempt to include Subobject from another "
; 4352 :          // "           Application Task"
; 4353 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 131, 0, 0, 0 );
; 4354 :          fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );
; 4355 :          return( zCALL_ERROR );
; 4356 :       }
; 4357 :    }
; 4358 : #endif
; 4359 : 
; 4360 :    vTask = zGETPTR( lpCurrentTask->hFirstView );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$[ebp], eax

; 4361 :    SysMutexLock( vTask, "Zeidon RLK", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG14900
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysMutexLock@16

; 4362 : 
; 4363 :    // If the source and target structures do not match, error out here!
; 4364 :    if ( (nInvertedParents =
; 4365 :                 fnValidSubobjectStructureMatch( lpTgtView, lpTgtViewEntity,
; 4366 :                                                 lpSrcView,
; 4367 :                                                 lpSrcViewEntity, 1 )) < 0 )

	push	1
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnValidSubobjectStructureMatch
	add	esp, 20					; 00000014H
	mov	WORD PTR _nInvertedParents$[ebp], ax
	movsx	ecx, WORD PTR _nInvertedParents$[ebp]
	test	ecx, ecx
	jge	SHORT $LN42@RelinkAllS

; 4368 :    {
; 4369 :       SysMutexUnlock( vTask, "Zeidon RLK", 0 );

	push	0
	push	OFFSET $SG14902
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysMutexUnlock@12

; 4370 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4371 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN42@RelinkAllS:

; 4372 :    }
; 4373 : 
; 4374 :    bLeafNode = TRUE;

	mov	ecx, 1
	mov	WORD PTR _bLeafNode$[ebp], cx

; 4375 :    lpWkViewEntity = zGETPTR( lpTgtViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
$LN2@RelinkAllS:

; 4376 :    while ( lpWkViewEntity &&

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	SHORT $LN3@RelinkAllS
	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	edx, ecx
	jle	SHORT $LN3@RelinkAllS

; 4377 :            lpWkViewEntity->nLevel > lpTgtViewEntity->nLevel )
; 4378 :    {
; 4379 :       if ( lpWkViewEntity->hParent == hTgtViewEntity &&

	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	cmp	eax, DWORD PTR _hTgtViewEntity$[ebp]
	jne	SHORT $LN43@RelinkAllS
	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	jne	SHORT $LN43@RelinkAllS

; 4380 :            lpWkViewEntity->bDerived == FALSE )
; 4381 :       {
; 4382 :          bLeafNode = 0;

	xor	eax, eax
	mov	WORD PTR _bLeafNode$[ebp], ax

; 4383 :          break;

	jmp	SHORT $LN3@RelinkAllS
$LN43@RelinkAllS:

; 4384 :       }
; 4385 : 
; 4386 :       lpWkViewEntity = zGETPTR( lpWkViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax

; 4387 :    }

	jmp	SHORT $LN2@RelinkAllS
$LN3@RelinkAllS:

; 4388 : 
; 4389 :    // Next, see if the target parent is inverted in the source structure,
; 4390 :    // if so we need to do the re-include processing and drop the target
; 4391 :    // parent from the source structure before each re-include.
; 4392 :    lpInvertedSrcEntity = 0;

	mov	DWORD PTR _lpInvertedSrcEntity$[ebp], 0

; 4393 :    lpInvertedSrcCsr    = 0;

	mov	DWORD PTR _lpInvertedSrcCsr$[ebp], 0

; 4394 :    if ( lpTgtViewEntity->bDerived == FALSE && lpTgtViewEntity->hParent )

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	$LN44@RelinkAllS
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	$LN44@RelinkAllS

; 4395 :    {
; 4396 :       lpInvertedSrcEntity = zGETPTR( lpSrcViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInvertedSrcEntity$[ebp], eax
$LN4@RelinkAllS:

; 4397 :       while ( lpInvertedSrcEntity )

	cmp	DWORD PTR _lpInvertedSrcEntity$[ebp], 0
	je	$LN44@RelinkAllS

; 4398 :       {
; 4399 :          if ( lpInvertedSrcEntity->nLevel <= lpSrcViewEntity->nLevel )

	mov	edx, DWORD PTR _lpInvertedSrcEntity$[ebp]
	movsx	eax, WORD PTR [edx+215]
	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	eax, edx
	jg	SHORT $LN45@RelinkAllS

; 4400 :          {
; 4401 :             lpInvertedSrcEntity = 0;

	mov	DWORD PTR _lpInvertedSrcEntity$[ebp], 0

; 4402 :             break;

	jmp	$LN44@RelinkAllS
$LN45@RelinkAllS:

; 4403 :          }
; 4404 : 
; 4405 :          if ( lpInvertedSrcEntity->lERRelTok == lpTgtViewEntity->lERRelTok &&
; 4406 :               lpInvertedSrcEntity->hParent  == hSrcViewEntity  &&
; 4407 :               lpInvertedSrcEntity->bRelLink1 != lpTgtViewEntity->bRelLink1 &&

	mov	eax, DWORD PTR _lpInvertedSrcEntity$[ebp]
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [eax+199]
	cmp	edx, DWORD PTR [ecx+199]
	jne	SHORT $LN46@RelinkAllS
	mov	eax, DWORD PTR _lpInvertedSrcEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	cmp	ecx, DWORD PTR _hSrcViewEntity$[ebp]
	jne	SHORT $LN46@RelinkAllS
	mov	edx, DWORD PTR _lpInvertedSrcEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 28					; 0000001cH
	and	eax, 1
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 28					; 0000001cH
	and	edx, 1
	cmp	eax, edx
	je	SHORT $LN46@RelinkAllS
	mov	eax, DWORD PTR _lpInvertedSrcEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	SHORT $LN46@RelinkAllS

; 4408 :               lpInvertedSrcEntity->bDerived == FALSE )
; 4409 :          {
; 4410 :             break;

	jmp	SHORT $LN44@RelinkAllS
$LN46@RelinkAllS:

; 4411 :          }
; 4412 : 
; 4413 :          lpInvertedSrcEntity = zGETPTR( lpInvertedSrcEntity->hNextHier );

	mov	edx, DWORD PTR _lpInvertedSrcEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInvertedSrcEntity$[ebp], eax

; 4414 :       }

	jmp	$LN4@RelinkAllS
$LN44@RelinkAllS:

; 4415 :    }
; 4416 : 
; 4417 :    // Make sure entity can be included UNLESS it is a leaf node.
; 4418 :    if ( lpTgtViewEntity->hParent && lpTgtViewEntity->bInclude == FALSE &&

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	$LN47@RelinkAllS
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	jne	$LN47@RelinkAllS
	movsx	ecx, WORD PTR _bLeafNode$[ebp]
	test	ecx, ecx
	jne	$LN47@RelinkAllS

; 4419 :         bLeafNode == FALSE )
; 4420 :    {
; 4421 :       strcpy( cpcEntityName, "\nEntity: \t" );

	push	OFFSET $SG14908
	lea	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4422 :       strcat( cpcEntityName, lpTgtViewEntity->szName );

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 4423 : 
; 4424 :       // "KZOEE106 - Rules violation"
; 4425 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	lea	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	push	OFFSET $SG14909
	push	0
	push	106					; 0000006aH
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 4426 :                         "Entity inclusion not allowed",
; 4427 :                         cpcEntityName );
; 4428 :       SysMutexUnlock( vTask, "Zeidon RLK", 0 );

	push	0
	push	OFFSET $SG14910
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysMutexUnlock@12

; 4429 :       fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4430 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@RelinkAllS
$LN47@RelinkAllS:

; 4431 :    }
; 4432 : 
; 4433 :    // OK, Finally we can get down to business, get a work view to the source
; 4434 :    // and target instance for doing the relinks
; 4435 :    lpSrcRootEntityInstance = zGETPTR( lpSrcViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcRootEntityInstance$[ebp], eax
$LN6@RelinkAllS:

; 4436 :    while ( lpSrcRootEntityInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpSrcRootEntityInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN7@RelinkAllS

; 4437 :       lpSrcRootEntityInstance = zGETPTR( lpSrcRootEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpSrcRootEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcRootEntityInstance$[ebp], eax
	jmp	SHORT $LN6@RelinkAllS
$LN7@RelinkAllS:

; 4438 : 
; 4439 :    lpTgtEntityInstance = zGETPTR( lpTgtViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
$LN8@RelinkAllS:

; 4440 :    while ( lpTgtEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN9@RelinkAllS

; 4441 :       lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
	jmp	SHORT $LN8@RelinkAllS
$LN9@RelinkAllS:

; 4442 : 
; 4443 : #ifdef            __RELINK_PERFORMANCE__
; 4444 :    // PERFORMANCE CODE???
; 4445 :    bDoSrcTwin = !fnEntityInRecursivePath( lpSrcViewEntity );

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	call	_fnEntityInRecursivePath
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN93@RelinkAllS
	mov	DWORD PTR tv353[ebp], 1
	jmp	SHORT $LN94@RelinkAllS
$LN93@RelinkAllS:
	mov	DWORD PTR tv353[ebp], 0
$LN94@RelinkAllS:
	mov	cl, BYTE PTR tv353[ebp]
	mov	BYTE PTR _bDoSrcTwin$[ebp], cl

; 4446 :    bDoTgtTwin = !fnEntityInRecursivePath( lpTgtViewEntity );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	call	_fnEntityInRecursivePath
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN95@RelinkAllS
	mov	DWORD PTR tv359[ebp], 1
	jmp	SHORT $LN96@RelinkAllS
$LN95@RelinkAllS:
	mov	DWORD PTR tv359[ebp], 0
$LN96@RelinkAllS:
	mov	cl, BYTE PTR tv359[ebp]
	mov	BYTE PTR _bDoTgtTwin$[ebp], cl

; 4447 :    nStopSrcHier = 0;

	xor	edx, edx
	mov	WORD PTR _nStopSrcHier$[ebp], dx

; 4448 :    if ( lpSrcViewOI->bMultipleRootLevels == FALSE )

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 1
	jne	SHORT $LN48@RelinkAllS

; 4449 :    {
; 4450 :       lpWkViewEntity = zGETPTR( lpSrcViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
$LN10@RelinkAllS:

; 4451 :       while ( lpWkViewEntity && lpWkViewEntity->nLevel != 2 )

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	SHORT $LN11@RelinkAllS
	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	cmp	edx, 2
	je	SHORT $LN11@RelinkAllS

; 4452 :          lpWkViewEntity = zGETPTR( lpWkViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
	jmp	SHORT $LN10@RelinkAllS
$LN11@RelinkAllS:

; 4453 : 
; 4454 :       if ( lpWkViewEntity )

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	SHORT $LN48@RelinkAllS

; 4455 :          nStopSrcHier = lpWkViewEntity->nHierNbr;

	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	ax, WORD PTR [edx+217]
	mov	WORD PTR _nStopSrcHier$[ebp], ax
$LN48@RelinkAllS:

; 4456 :    }
; 4457 : 
; 4458 :    nStopTgtHier = 0;

	xor	ecx, ecx
	mov	WORD PTR _nStopTgtHier$[ebp], cx

; 4459 :    if ( lpTgtViewOI->bMultipleRootLevels == FALSE )

	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 1
	jne	SHORT $LN50@RelinkAllS

; 4460 :    {
; 4461 :       lpWkViewEntity = zGETPTR( lpTgtViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
$LN12@RelinkAllS:

; 4462 :       while ( lpWkViewEntity && lpWkViewEntity->nLevel != 2 )

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	SHORT $LN13@RelinkAllS
	mov	eax, DWORD PTR _lpWkViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+215]
	cmp	ecx, 2
	je	SHORT $LN13@RelinkAllS

; 4463 :          lpWkViewEntity = zGETPTR( lpWkViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$[ebp], eax
	jmp	SHORT $LN12@RelinkAllS
$LN13@RelinkAllS:

; 4464 : 
; 4465 :       if ( lpWkViewEntity )

	cmp	DWORD PTR _lpWkViewEntity$[ebp], 0
	je	SHORT $LN50@RelinkAllS

; 4466 :          nStopTgtHier = lpWkViewEntity->nHierNbr;

	mov	ecx, DWORD PTR _lpWkViewEntity$[ebp]
	mov	dx, WORD PTR [ecx+217]
	mov	WORD PTR _nStopTgtHier$[ebp], dx
$LN50@RelinkAllS:

; 4467 :    }
; 4468 : 
; 4469 :    if ( lpSrcRootEntityInstance )

	cmp	DWORD PTR _lpSrcRootEntityInstance$[ebp], 0
	je	$LN52@RelinkAllS

; 4470 :    {
; 4471 :       lpFirstSource = fnFirstLevel2_ForViewEntity( lpSrcRootEntityInstance,

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcRootEntityInstance$[ebp]
	push	ecx
	call	_fnFirstLevel2_ForViewEntity
	add	esp, 8
	mov	DWORD PTR _lpFirstSource$[ebp], eax

; 4472 :                                                    lpSrcViewEntity );
; 4473 :       if ( lpFirstSource )

	cmp	DWORD PTR _lpFirstSource$[ebp], 0
	je	$LN52@RelinkAllS

; 4474 :       {
; 4475 :          LPVIEWENTITY lpFirstSourceViewEntity;
; 4476 : 
; 4477 :          lpFirstSourceViewEntity = zGETPTR( lpFirstSource->hViewEntity );

	mov	edx, DWORD PTR _lpFirstSource$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSourceViewEntity$2[ebp], eax
$LN14@RelinkAllS:

; 4478 :          while ( lpFirstSourceViewEntity != lpSrcViewEntity ||

	mov	ecx, DWORD PTR _lpFirstSourceViewEntity$2[ebp]
	cmp	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	jne	SHORT $LN54@RelinkAllS
	mov	edx, DWORD PTR _lpFirstSource$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN15@RelinkAllS
$LN54@RelinkAllS:

; 4479 :                  lpFirstSource->u.nInd.bHidden )
; 4480 :          {
; 4481 :             lpFirstSource = zGETPTR( lpFirstSource->hNextHier );

	mov	ecx, DWORD PTR _lpFirstSource$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSource$[ebp], eax

; 4482 :             if ( lpFirstSource == 0 )

	cmp	DWORD PTR _lpFirstSource$[ebp], 0
	jne	SHORT $LN55@RelinkAllS

; 4483 :                break;

	jmp	SHORT $LN15@RelinkAllS
$LN55@RelinkAllS:

; 4484 : 
; 4485 :             lpFirstSourceViewEntity = zGETPTR( lpFirstSource->hViewEntity );

	mov	eax, DWORD PTR _lpFirstSource$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSourceViewEntity$2[ebp], eax

; 4486 :             if ( nStopSrcHier &&

	movsx	edx, WORD PTR _nStopSrcHier$[ebp]
	test	edx, edx
	je	SHORT $LN56@RelinkAllS
	mov	eax, DWORD PTR _lpFirstSourceViewEntity$2[ebp]
	movsx	ecx, WORD PTR [eax+217]
	movsx	edx, WORD PTR _nStopSrcHier$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN56@RelinkAllS

; 4487 :                  lpFirstSourceViewEntity->nHierNbr >= nStopSrcHier )
; 4488 :             {
; 4489 :                lpFirstSource = 0;

	mov	DWORD PTR _lpFirstSource$[ebp], 0

; 4490 :                break;

	jmp	SHORT $LN15@RelinkAllS
$LN56@RelinkAllS:

; 4491 :             }
; 4492 :          }

	jmp	$LN14@RelinkAllS
$LN15@RelinkAllS:

; 4493 : 
; 4494 :          if ( lpFirstSource )

	cmp	DWORD PTR _lpFirstSource$[ebp], 0
	je	$LN52@RelinkAllS

; 4495 :          {
; 4496 :             lpSrcEntityInstance = lpFirstSource;

	mov	eax, DWORD PTR _lpFirstSource$[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
$LN16@RelinkAllS:

; 4497 :             while ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	$LN52@RelinkAllS

; 4498 :             {
; 4499 :                if ( lpSrcEntityInstance->hViewEntity == hSrcViewEntity &&

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hSrcViewEntity$[ebp]
	jne	SHORT $LN58@RelinkAllS
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN58@RelinkAllS

; 4500 :                     lpSrcEntityInstance->u.nInd.bHidden == FALSE )
; 4501 :                {
; 4502 :                   lpLastSource = lpSrcEntityInstance;

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	DWORD PTR _lpLastSource$[ebp], edx
$LN58@RelinkAllS:

; 4503 :                }
; 4504 : 
; 4505 :                if ( bDoSrcTwin &&

	movzx	eax, BYTE PTR _bDoSrcTwin$[ebp]
	test	eax, eax
	je	SHORT $LN59@RelinkAllS
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hSrcViewEntity$[ebp]
	jne	SHORT $LN59@RelinkAllS
$LN18@RelinkAllS:

; 4506 :                     lpSrcEntityInstance->hViewEntity == hSrcViewEntity )
; 4507 :                {
; 4508 :                   while ( lpSrcEntityInstance &&

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN19@RelinkAllS
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	jne	SHORT $LN19@RelinkAllS

; 4509 :                           lpSrcEntityInstance->hNextTwin == 0 )
; 4510 :                   {
; 4511 :                      lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 4512 :                   }

	jmp	SHORT $LN18@RelinkAllS
$LN19@RelinkAllS:

; 4513 : 
; 4514 :                   if ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN61@RelinkAllS

; 4515 :                      lpSrcEntityInstance =

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
$LN61@RelinkAllS:

; 4516 :                                     zGETPTR( lpSrcEntityInstance->hNextTwin );
; 4517 :                }

	jmp	SHORT $LN60@RelinkAllS
$LN59@RelinkAllS:

; 4518 :                else
; 4519 :                   lpSrcEntityInstance =

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
$LN60@RelinkAllS:

; 4520 :                                     zGETPTR( lpSrcEntityInstance->hNextHier );
; 4521 :             }

	jmp	$LN16@RelinkAllS
$LN52@RelinkAllS:

; 4522 :          }
; 4523 :       }
; 4524 :    }
; 4525 : 
; 4526 :    if ( lpSrcRootEntityInstance && lpTgtEntityInstance )

	cmp	DWORD PTR _lpSrcRootEntityInstance$[ebp], 0
	je	SHORT $LN62@RelinkAllS
	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN62@RelinkAllS

; 4527 :    {
; 4528 :       lpTgtEntityInstance = fnFirstLevel2_ForViewEntity( lpTgtEntityInstance,

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	call	_fnFirstLevel2_ForViewEntity
	add	esp, 8
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
$LN62@RelinkAllS:

; 4529 :                                                          lpTgtViewEntity );
; 4530 :    }
; 4531 :    // PERFORMANCE CODE???
; 4532 : #endif
; 4533 : 
; 4534 :    nNotFound = 0;

	xor	eax, eax
	mov	WORD PTR _nNotFound$[ebp], ax

; 4535 : 
; 4536 : #ifdef __RELINK_PERFORMANCE__
; 4537 :    if ( lpFirstSource && lpTgtEntityInstance )

	cmp	DWORD PTR _lpFirstSource$[ebp], 0
	je	$LN63@RelinkAllS
	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	$LN63@RelinkAllS

; 4538 : #else
; 4539 :    if ( lpSrcRootEntityInstance && lpTgtEntityInstance )
; 4540 : #endif
; 4541 :    {
; 4542 :       // Change lpTgtView and lpSrcView to work views
; 4543 :       nRC = CreateViewFromViewForTask( &lpTgtView, lpTgtView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax

; 4544 :       if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN64@RelinkAllS

; 4545 :          nRC = CreateViewFromViewForTask( &lpSrcView, lpSrcView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax
$LN64@RelinkAllS:

; 4546 : 
; 4547 :       lpSrcViewEntityCsr = 0;

	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], 0

; 4548 :       lpTgtViewEntityCsr = 0;

	mov	DWORD PTR _lpTgtViewEntityCsr$[ebp], 0
$LN20@RelinkAllS:

; 4549 :       while ( nRC == 0 && lpTgtEntityInstance )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	$LN21@RelinkAllS
	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	$LN21@RelinkAllS
$LN22@RelinkAllS:

; 4550 :       {
; 4551 :          while ( lpTgtEntityInstance->hPrevVsn )

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN23@RelinkAllS

; 4552 :             lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
	jmp	SHORT $LN22@RelinkAllS
$LN23@RelinkAllS:

; 4553 : 
; 4554 :          if ( lpTgtEntityInstance->hViewEntity == hTgtViewEntity &&

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hTgtViewEntity$[ebp]
	jne	$LN32@RelinkAllS
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	$LN32@RelinkAllS

; 4555 :               lpTgtEntityInstance->u.nInd.bHidden == FALSE )
; 4556 :          {
; 4557 : #ifdef            __RELINK_PERFORMANCE__
; 4558 :             lpSrcEntityInstance = lpFirstSource;

	mov	edx, DWORD PTR _lpFirstSource$[ebp]
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], edx
$LN24@RelinkAllS:

; 4559 : #else
; 4560 :             lpSrcEntityInstance = lpSrcRootEntityInstance;
; 4561 : #endif
; 4562 :             while ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	$LN25@RelinkAllS
$LN26@RelinkAllS:

; 4563 :             {
; 4564 :                while ( lpSrcEntityInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN27@RelinkAllS

; 4565 :                   lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
	jmp	SHORT $LN26@RelinkAllS
$LN27@RelinkAllS:

; 4566 : 
; 4567 :                if ( lpSrcEntityInstance->hViewEntity == hSrcViewEntity &&
; 4568 :                     lpSrcEntityInstance->u.nInd.bHidden == FALSE &&

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hSrcViewEntity$[ebp]
	jne	$LN66@RelinkAllS
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	$LN66@RelinkAllS
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	call	_fnInstanceKeysMatch
	add	esp, 8
	cwde
	test	eax, eax
	je	$LN66@RelinkAllS

; 4569 :                     fnInstanceKeysMatch( lpSrcEntityInstance,
; 4570 :                                          lpTgtEntityInstance ) )
; 4571 :                {
; 4572 :                   if ( !fnInstanceLinkedToInstance( lpSrcEntityInstance,

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	call	_fnInstanceLinkedToInstance
	add	esp, 8
	movzx	eax, al
	test	eax, eax
	jne	$LN67@RelinkAllS

; 4573 :                                                     lpTgtEntityInstance ) )
; 4574 :                   {
; 4575 :                      if ( bLeafNode && lpInvertedSrcEntity == 0 &&

	movsx	ecx, WORD PTR _bLeafNode$[ebp]
	test	ecx, ecx
	je	SHORT $LN68@RelinkAllS
	cmp	DWORD PTR _lpInvertedSrcEntity$[ebp], 0
	jne	SHORT $LN68@RelinkAllS
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 8
	and	eax, 1
	jne	SHORT $LN68@RelinkAllS

; 4576 :                           lpTgtEntityInstance->u.nInd.bPrevVersion == FALSE )
; 4577 :                      {
; 4578 :                         fnRemoveOtherOI_LinkedInstances( lpTgtEntityInstance,

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	call	_fnRemoveOtherOI_LinkedInstances
	add	esp, 8

; 4579 :                                                          lpSrcEntityInstance );
; 4580 :                         fnRelinkInstanceToInstance( lpTgtEntityInstance,

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	call	_fnRelinkInstanceToInstance
	add	esp, 8

; 4581 :                                                     lpSrcEntityInstance );
; 4582 :                      }

	jmp	$LN67@RelinkAllS
$LN68@RelinkAllS:

; 4583 :                      else
; 4584 :                      {
; 4585 :                         // Here we have a re-include situation, if the
; 4586 :                         // source target entity instance has a next
; 4587 :                         // version, then propagate the source subobject
; 4588 :                         // structure across the target instance and all
; 4589 :                         // its versions ensuring that neither structural
; 4590 :                         // changes NOR key changes have occurred between the
; 4591 :                         // source subobject and the target subobject
; 4592 : 
; 4593 :                         if ( lpTgtEntityInstance->u.nInd.bPrevVersion &&

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 8
	and	eax, 1
	je	SHORT $LN70@RelinkAllS
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	call	_fnStillPrevVersion
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN70@RelinkAllS

; 4594 :                              fnStillPrevVersion( lpTgtEntityInstance ) )
; 4595 :                         {
; 4596 :                            nRC = fnRelinkVsnSubobjectToSubobject( lpTgtView,

	mov	eax, DWORD PTR _lpInvertedSrcEntity$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nInvertedParents$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnRelinkVsnSubobjectToSubobject
	add	esp, 24					; 00000018H
	mov	WORD PTR _nRC$[ebp], ax

; 4597 :                                                       lpTgtEntityInstance,
; 4598 :                                                       lpSrcView,
; 4599 :                                                       lpSrcEntityInstance,
; 4600 :                                                       nInvertedParents,
; 4601 :                                                       lpInvertedSrcEntity );
; 4602 :                         }

	jmp	$LN67@RelinkAllS
$LN70@RelinkAllS:

; 4603 :                         else
; 4604 :                         {
; 4605 :                            // if the source structure inverts the target
; 4606 :                            // then we need to find the instance in the
; 4607 :                            // source and drop it
; 4608 :                            if ( lpInvertedSrcEntity )

	cmp	DWORD PTR _lpInvertedSrcEntity$[ebp], 0
	je	$LN72@RelinkAllS

; 4609 :                            {
; 4610 :                               lpWkEntityInstance =

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax
$LN28@RelinkAllS:

; 4611 :                                    zGETPTR( lpSrcEntityInstance->hNextHier );
; 4612 :                               while ( lpWkEntityInstance &&

	cmp	DWORD PTR _lpWkEntityInstance$[ebp], 0
	je	$LN72@RelinkAllS
	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jle	$LN72@RelinkAllS

; 4613 :                                       lpWkEntityInstance->nLevel > lpSrcEntityInstance->nLevel )
; 4614 :                               {
; 4615 :                                  if ( zGETPTR( lpWkEntityInstance->hViewEntity ) ==
; 4616 :                                                        lpInvertedSrcEntity &&
; 4617 :                                       lpWkEntityInstance->u.nInd.bHidden == FALSE &&

	mov	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpInvertedSrcEntity$[ebp]
	jne	SHORT $LN73@RelinkAllS
	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN73@RelinkAllS
	mov	ecx, DWORD PTR _lpWkEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInstanceKeysMatch
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN73@RelinkAllS

; 4618 :                                       fnInstanceKeysMatch(
; 4619 :                                              zGETPTR( lpTgtEntityInstance->hParent ),
; 4620 :                                                       lpWkEntityInstance ) )
; 4621 :                                  {
; 4622 :                                     lpInvertedSrcCsr =

	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInvertedSrcCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpInvertedSrcCsr$[ebp], eax

; 4623 :                                        fnEstablishViewForInstance( lpSrcView, lpInvertedSrcCsr,
; 4624 :                                                          lpWkEntityInstance );
; 4625 : 
; 4626 :                                     nRC = fnExcludeEntity( lpSrcView,

	push	0
	push	0
	mov	edx, DWORD PTR _lpInvertedSrcCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInvertedSrcEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	call	_fnExcludeEntity
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 4627 :                                                            lpInvertedSrcEntity,
; 4628 :                                                            lpInvertedSrcCsr,
; 4629 :                                                            zREPOS_NONE, 0 );
; 4630 :                                     break;

	jmp	SHORT $LN72@RelinkAllS
$LN73@RelinkAllS:

; 4631 :                                  }
; 4632 : 
; 4633 :                                  lpWkEntityInstance = zGETPTR( lpWkEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax

; 4634 :                               }

	jmp	$LN28@RelinkAllS
$LN72@RelinkAllS:

; 4635 :                            }
; 4636 : 
; 4637 :                            lpSrcViewEntityCsr =

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 4638 :                                  fnEstablishViewForInstance( lpSrcView,
; 4639 :                                                        lpSrcViewEntityCsr,
; 4640 :                                                        lpSrcEntityInstance );
; 4641 :                            lpTgtViewEntityCsr =

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTgtViewEntityCsr$[ebp], eax

; 4642 :                                  fnEstablishViewForInstance( lpTgtView,
; 4643 :                                                        lpTgtViewEntityCsr,
; 4644 :                                                        lpTgtEntityInstance );
; 4645 : 
; 4646 :                            // First, let's save the included incremental flag
; 4647 :                            // for the target instance, so we can do the
; 4648 :                            // appropriate re-include marking.
; 4649 :                            bUpdated  = lpTgtViewOI->bUpdated;

	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 4
	and	edx, 1
	mov	BYTE PTR _bUpdated$[ebp], dl

; 4650 :                            bUpdatedFile = lpTgtViewOI->bUpdatedFile;

	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	shr	ecx, 5
	and	ecx, 1
	mov	BYTE PTR _bUpdatedFile$[ebp], cl

; 4651 :                            bIncluded = lpTgtEntityInstance->u.nInd.bIncluded;

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	mov	WORD PTR _bIncluded$[ebp], ax

; 4652 :                            nRC = fnExcludeEntity( lpTgtView, lpTgtViewEntity,

	push	0
	push	0
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnExcludeEntity
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 4653 :                                                   lpTgtViewEntityCsr,
; 4654 :                                                   zREPOS_NONE, 0 );
; 4655 :                            if ( nRC != zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	je	SHORT $LN74@RelinkAllS

; 4656 :                            {
; 4657 :                               nRC = fnIncludeSubobjectFromSubobject(

	movzx	edx, WORD PTR _bIncluded$[ebp]
	push	edx
	push	0
	push	3
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	mov	WORD PTR _nRC$[ebp], ax

; 4658 :                                                 lpTgtView, lpTgtViewEntity,
; 4659 :                                                 lpSrcView, lpSrcViewEntity,
; 4660 :                                                 zPOS_AFTER, 0, bIncluded );
; 4661 : 
; 4662 :                               // If the re-include worked, re-establish any
; 4663 :                               // cursors pointing to the excluded instance.
; 4664 :                               if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN74@RelinkAllS

; 4665 :                                  fnUpdateRelinkCursors( lpTgtEntityInstance );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	call	_fnUpdateRelinkCursors
	add	esp, 4
$LN74@RelinkAllS:

; 4666 :                            }
; 4667 : 
; 4668 :                            lpTgtViewOI->bUpdated = bUpdated;

	movzx	eax, BYTE PTR _bUpdated$[ebp]
	and	eax, 1
	shl	eax, 4
	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	and	edx, -17				; ffffffefH
	or	edx, eax
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 4669 :                            lpTgtViewOI->bUpdatedFile = bUpdatedFile;

	movzx	ecx, BYTE PTR _bUpdatedFile$[ebp]
	and	ecx, 1
	shl	ecx, 5
	mov	edx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, -33				; ffffffdfH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN67@RelinkAllS:

; 4670 :                         }
; 4671 :                      }
; 4672 :                   }
; 4673 : 
; 4674 :                   break;

	jmp	$LN25@RelinkAllS
$LN66@RelinkAllS:

; 4675 :                }
; 4676 : #ifdef            __RELINK_PERFORMANCE__
; 4677 :                if ( lpSrcEntityInstance == lpLastSource )

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	edx, DWORD PTR _lpLastSource$[ebp]
	jne	SHORT $LN76@RelinkAllS

; 4678 :                   lpSrcEntityInstance = 0;

	mov	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	jmp	$LN77@RelinkAllS
$LN76@RelinkAllS:

; 4679 :                else
; 4680 :                if ( bDoSrcTwin &&

	movzx	eax, BYTE PTR _bDoSrcTwin$[ebp]
	test	eax, eax
	je	SHORT $LN78@RelinkAllS
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hSrcViewEntity$[ebp]
	jne	SHORT $LN78@RelinkAllS
$LN30@RelinkAllS:

; 4681 :                     lpSrcEntityInstance->hViewEntity == hSrcViewEntity )
; 4682 :                {
; 4683 :                   while ( lpSrcEntityInstance &&

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN31@RelinkAllS
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	jne	SHORT $LN31@RelinkAllS

; 4684 :                           lpSrcEntityInstance->hNextTwin == 0 )
; 4685 :                   {
; 4686 :                      lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 4687 :                   }

	jmp	SHORT $LN30@RelinkAllS
$LN31@RelinkAllS:

; 4688 : 
; 4689 :                   if ( lpSrcEntityInstance )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	je	SHORT $LN80@RelinkAllS

; 4690 :                      lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
$LN80@RelinkAllS:

; 4691 :                }

	jmp	SHORT $LN77@RelinkAllS
$LN78@RelinkAllS:

; 4692 :                else
; 4693 :                   lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax
$LN77@RelinkAllS:

; 4694 : #else
; 4695 :                lpSrcEntityInstance = zGETPTR( lpSrcEntityInstance->hNextHier );
; 4696 : #endif
; 4697 :             }

	jmp	$LN24@RelinkAllS
$LN25@RelinkAllS:

; 4698 : 
; 4699 :             if ( lpSrcEntityInstance == 0 )

	cmp	DWORD PTR _lpSrcEntityInstance$[ebp], 0
	jne	SHORT $LN32@RelinkAllS

; 4700 :                nNotFound = 1;  // Flag that one was not found

	mov	ecx, 1
	mov	WORD PTR _nNotFound$[ebp], cx
$LN32@RelinkAllS:

; 4701 :          }
; 4702 : 
; 4703 :          while ( lpTgtEntityInstance->hNextVsn )

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN33@RelinkAllS

; 4704 :             lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hNextVsn );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
	jmp	SHORT $LN32@RelinkAllS
$LN33@RelinkAllS:

; 4705 : 
; 4706 : #ifdef            __RELINK_PERFORMANCE__
; 4707 :          if ( bDoTgtTwin &&

	movzx	edx, BYTE PTR _bDoTgtTwin$[ebp]
	test	edx, edx
	je	SHORT $LN82@RelinkAllS
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hTgtViewEntity$[ebp]
	jne	SHORT $LN82@RelinkAllS
$LN34@RelinkAllS:

; 4708 :               lpTgtEntityInstance->hViewEntity == hTgtViewEntity )
; 4709 :          {
; 4710 :             while ( lpTgtEntityInstance && lpTgtEntityInstance->hNextTwin == 0 )

	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN35@RelinkAllS
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	jne	SHORT $LN35@RelinkAllS

; 4711 :                lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hParent );

	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
	jmp	SHORT $LN34@RelinkAllS
$LN35@RelinkAllS:

; 4712 : 
; 4713 :             if ( lpTgtEntityInstance )

	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN84@RelinkAllS

; 4714 :                lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
$LN84@RelinkAllS:

; 4715 :          }

	jmp	SHORT $LN83@RelinkAllS
$LN82@RelinkAllS:

; 4716 :          else
; 4717 :             lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntityInstance$[ebp], eax
$LN83@RelinkAllS:

; 4718 : 
; 4719 :          if ( nStopTgtHier && lpTgtEntityInstance )

	movsx	eax, WORD PTR _nStopTgtHier$[ebp]
	test	eax, eax
	je	SHORT $LN85@RelinkAllS
	cmp	DWORD PTR _lpTgtEntityInstance$[ebp], 0
	je	SHORT $LN85@RelinkAllS

; 4720 :          {
; 4721 :             LPVIEWENTITY lpWrkViewEntity =

	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntity$1[ebp], eax

; 4722 :                               zGETPTR( lpTgtEntityInstance->hViewEntity );
; 4723 : 
; 4724 :             if ( lpWrkViewEntity->nHierNbr >= nStopTgtHier )

	mov	eax, DWORD PTR _lpWrkViewEntity$1[ebp]
	movsx	ecx, WORD PTR [eax+217]
	movsx	edx, WORD PTR _nStopTgtHier$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN85@RelinkAllS

; 4725 :                lpTgtEntityInstance = 0;

	mov	DWORD PTR _lpTgtEntityInstance$[ebp], 0
$LN85@RelinkAllS:

; 4726 :          }
; 4727 : #else
; 4728 :          lpTgtEntityInstance = zGETPTR( lpTgtEntityInstance->hNextHier );
; 4729 : #endif
; 4730 :       }

	jmp	$LN20@RelinkAllS
$LN21@RelinkAllS:

; 4731 : 
; 4732 :       DropView( lpSrcView );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	call	_DropView@4

; 4733 :       DropView( lpTgtView );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_DropView@4
$LN63@RelinkAllS:

; 4734 :    }
; 4735 : 
; 4736 :    SysMutexUnlock( vTask, "Zeidon RLK", 0 );

	push	0
	push	OFFSET $SG14950
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysMutexUnlock@12

; 4737 : 
; 4738 :    // Return the results.
; 4739 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN87@RelinkAllS

; 4740 :       nRC = nNotFound;  // Change 0 return code to not found state

	mov	cx, WORD PTR _nNotFound$[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN87@RelinkAllS:

; 4741 : 
; 4742 :    fnOperationReturn( iRelinkAllSubobjectsForOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	121					; 00000079H
	call	_fnOperationReturn
	add	esp, 8

; 4743 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@RelinkAllS:

; 4744 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_RelinkAllSubobjectsForOI@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpTgtViewCsr$ = -48					; size = 4
_lpTempCsr$1 = -44					; size = 4
_lpSrcEntityInstance$ = -40				; size = 4
_lpWkEntityInstance$ = -36				; size = 4
_lpSrcViewEntityCsr$ = -32				; size = 4
_lpTgtViewEntityCsr$ = -28				; size = 4
_lpSTgtViewEntity$2 = -24				; size = 4
_lpSrcViewEntity$ = -20					; size = 4
_lpTgtViewEntity$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpSSrcViewEntity$3 = -8				; size = 4
_nRC$ = -4						; size = 2
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_nPosition$ = 24					; size = 2
_nSrcPosition$ = 28					; size = 2
_MoveSubobject@24 PROC

; 3928 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 3929 :    LPTASK            lpCurrentTask;
; 3930 :    LPVIEWENTITY      lpSrcViewEntity;
; 3931 :    LPVIEWENTITY      lpTgtViewEntity;
; 3932 :    LPVIEWCSR         lpTgtViewCsr;
; 3933 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 3934 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 3935 :    LPENTITYINSTANCE  lpSrcEntityInstance;
; 3936 :    LPENTITYINSTANCE  lpWkEntityInstance;
; 3937 :    zSHORT            nRC;
; 3938 : 
; 3939 :    // Validate that the source view entity exists and has a cursor
; 3940 :    // value for copying, we call fnValidateInstanceParameters for the
; 3941 :    // source since it requires the same editing as an attribute retrieval.
; 3942 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	1
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	110					; 0000006eH
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN6@MoveSubobj

; 3943 :                                       &lpSrcViewEntity,
; 3944 :                                       &lpSrcViewEntityCsr,
; 3945 :                                       iMoveSubobject,
; 3946 :                                       lpSrcView,
; 3947 :                                       cpcSrcEntityName, 1 ) )
; 3948 :    {
; 3949 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MoveSubobj
$LN6@MoveSubobj:

; 3950 :    }
; 3951 : 
; 3952 :    // Validate that the view passed is valid.
; 3953 :    if ( fnValidViewCsr( lpCurrentTask, lpTgtView ) == 0 )

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN7@MoveSubobj

; 3954 :    {
; 3955 :       fnOperationReturn( iMoveSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	110					; 0000006eH
	call	_fnOperationReturn
	add	esp, 8

; 3956 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MoveSubobj
$LN7@MoveSubobj:

; 3957 :    }
; 3958 : 
; 3959 :    lpTgtViewCsr = zGETPTR( lpTgtView->hViewCsr );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewCsr$[ebp], eax

; 3960 : 
; 3961 :    if ( (lpTgtViewEntity = fnValidViewEntity( &lpTgtViewEntityCsr,
; 3962 :                                               lpTgtView,
; 3963 :                                               cpcTgtEntityName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpTgtViewEntity$[ebp], eax
	cmp	DWORD PTR _lpTgtViewEntity$[ebp], 0
	jne	SHORT $LN8@MoveSubobj

; 3964 :    {
; 3965 :       fnOperationReturn( iMoveSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	110					; 0000006eH
	call	_fnOperationReturn
	add	esp, 8

; 3966 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MoveSubobj
$LN8@MoveSubobj:

; 3967 :    }
; 3968 : 
; 3969 :    // Make sure the source entity type and target entity type are either the
; 3970 :    // same view entity type or a recursive parent child entity pair.
; 3971 :    if ( lpSrcViewEntity != lpTgtViewEntity )

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	cmp	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	je	$LN9@MoveSubobj

; 3972 :    {
; 3973 :       LPVIEWENTITY lpSSrcViewEntity;
; 3974 :       LPVIEWENTITY lpSTgtViewEntity;
; 3975 : 
; 3976 :       lpSSrcViewEntity = lpSrcViewEntity;

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	DWORD PTR _lpSSrcViewEntity$3[ebp], edx

; 3977 :       lpSTgtViewEntity = lpTgtViewEntity;

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	DWORD PTR _lpSTgtViewEntity$2[ebp], eax

; 3978 :       if ( lpSSrcViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpSSrcViewEntity$3[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN10@MoveSubobj

; 3979 :       {
; 3980 :          lpSSrcViewEntity = zGETPTR( lpSrcViewEntity->hParent );

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSSrcViewEntity$3[ebp], eax
$LN2@MoveSubobj:

; 3981 :          while ( lpSSrcViewEntity->lEREntTok != lpSrcViewEntity->lEREntTok )

	mov	edx, DWORD PTR _lpSSrcViewEntity$3[ebp]
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $LN3@MoveSubobj

; 3982 :             lpSSrcViewEntity = zGETPTR( lpSSrcViewEntity->hParent );

	mov	edx, DWORD PTR _lpSSrcViewEntity$3[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSSrcViewEntity$3[ebp], eax
	jmp	SHORT $LN2@MoveSubobj
$LN3@MoveSubobj:

; 3983 :       }

	jmp	SHORT $LN11@MoveSubobj
$LN10@MoveSubobj:

; 3984 :       else
; 3985 :       if ( lpSTgtViewEntity->bRecursive )

	mov	ecx, DWORD PTR _lpSTgtViewEntity$2[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN11@MoveSubobj

; 3986 :       {
; 3987 :          lpSTgtViewEntity = zGETPTR( lpTgtViewEntity->hParent );

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSTgtViewEntity$2[ebp], eax
$LN4@MoveSubobj:

; 3988 :          while ( lpSTgtViewEntity->lEREntTok != lpTgtViewEntity->lEREntTok )

	mov	edx, DWORD PTR _lpSTgtViewEntity$2[ebp]
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [edx+195]
	cmp	ecx, DWORD PTR [eax+195]
	je	SHORT $LN11@MoveSubobj

; 3989 :             lpSSrcViewEntity = zGETPTR( lpSSrcViewEntity->hParent );

	mov	edx, DWORD PTR _lpSSrcViewEntity$3[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSSrcViewEntity$3[ebp], eax
	jmp	SHORT $LN4@MoveSubobj
$LN11@MoveSubobj:

; 3990 :       }
; 3991 : 
; 3992 :       if ( lpSSrcViewEntity != lpSTgtViewEntity )

	mov	ecx, DWORD PTR _lpSSrcViewEntity$3[ebp]
	cmp	ecx, DWORD PTR _lpSTgtViewEntity$2[ebp]
	je	SHORT $LN9@MoveSubobj

; 3993 :       {
; 3994 :          // "KZOEE114 - Source and Target entities do not match"
; 3995 :          fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 114, 0,

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	114					; 00000072H
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3996 :                            lpSrcViewEntity->szName,
; 3997 :                            lpTgtViewEntity->szName );
; 3998 :          fnOperationReturn( iMoveSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	110					; 0000006eH
	call	_fnOperationReturn
	add	esp, 8

; 3999 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@MoveSubobj
$LN9@MoveSubobj:

; 4000 :       }
; 4001 :    }
; 4002 : 
; 4003 :    // Next get the source entity instance and ensure that we are
; 4004 :    // not attempting to move it under one of its children.
; 4005 :    lpSrcEntityInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntityInstance$[ebp], eax

; 4006 :    if ( lpTgtViewEntityCsr->hParent )

	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN14@MoveSubobj

; 4007 :    {
; 4008 :       LPVIEWENTITYCSR lpTempCsr;
; 4009 : 
; 4010 :       lpTempCsr = zGETPTR( lpTgtViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempCsr$1[ebp], eax

; 4011 :       lpWkEntityInstance = zGETPTR( lpTempCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpTempCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax

; 4012 :    }

	jmp	SHORT $LN15@MoveSubobj
$LN14@MoveSubobj:

; 4013 :    else
; 4014 :       lpWkEntityInstance = zGETPTR( lpTgtViewCsr->hViewParentEntityInstance );

	mov	edx, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkEntityInstance$[ebp], eax
$LN15@MoveSubobj:

; 4015 : 
; 4016 :    // Set parent match indicator
; 4017 :    if ( zGETPTR( lpSrcEntityInstance->hParent ) == lpWkEntityInstance )

	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWkEntityInstance$[ebp]
	jne	SHORT $LN16@MoveSubobj

; 4018 :    {
; 4019 :       nRC = fnMoveSubobjectAmongTwins( lpTgtView,

	movzx	eax, WORD PTR _nSrcPosition$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnMoveSubobjectAmongTwins@24
	mov	WORD PTR _nRC$[ebp], ax

; 4020 :                                        zGETPTR( lpTgtViewEntityCsr->hEntityInstance ),
; 4021 :                                        lpSrcViewEntityCsr, lpSrcEntityInstance,
; 4022 :                                        nPosition, nSrcPosition );
; 4023 :    }

	jmp	SHORT $LN17@MoveSubobj
$LN16@MoveSubobj:

; 4024 :    else
; 4025 :    {
; 4026 :       nRC = fnMoveSubobjectUnderNewParent( lpWkEntityInstance,

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nSrcPosition$[ebp]
	push	edx
	movzx	eax, WORD PTR _nPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWkEntityInstance$[ebp]
	push	edx
	call	_fnMoveSubobjectUnderNewParent@32
	mov	WORD PTR _nRC$[ebp], ax
$LN17@MoveSubobj:

; 4027 :                                            lpTgtView,
; 4028 :                                            lpTgtViewEntityCsr,
; 4029 :                                            lpSrcView,
; 4030 :                                            lpSrcViewEntityCsr,
; 4031 :                                            nPosition, nSrcPosition,
; 4032 :                                            lpCurrentTask );
; 4033 :    }
; 4034 : 
; 4035 :    // Whew, I think we've done it, return to caller.
; 4036 :    fnOperationReturn( iMoveSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	110					; 0000006eH
	call	_fnOperationReturn
	add	esp, 8

; 4037 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@MoveSubobj:

; 4038 : 
; 4039 : }  // END of MoveSubobject

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_MoveSubobject@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpTgtEI$1 = -48					; size = 4
_lpSrcEI$2 = -44					; size = 4
_lpTgtViewEntityCsr$ = -40				; size = 4
_lpSrcViewEntityCsr$ = -36				; size = 4
_lpSrcViewEntity$ = -32					; size = 4
tv171 = -28						; size = 4
tv170 = -24						; size = 4
_lpTgtViewEntity$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpTgtViewAttrib$3 = -12				; size = 4
_lpViewAttrib$4 = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_nPosition$ = 24					; size = 2
_lControl$ = 28						; size = 4
_IncludeSubobjectFromSubobjectEx@24 PROC

; 3151 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 3152 :    LPTASK            lpCurrentTask;
; 3153 :    LPVIEWENTITY      lpSrcViewEntity;
; 3154 :    LPVIEWENTITY      lpTgtViewEntity;
; 3155 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 3156 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 3157 :    zSHORT            nRC;
; 3158 : 
; 3159 :    // Validate that the source view entity exists and has a cursor
; 3160 :    // value for copying, we call fnValidateInstanceParameters for the
; 3161 :    // source since it requires the same editing as an attribute retrieval.
; 3162 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	105					; 00000069H
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN8@IncludeSub

; 3163 :                                       &lpSrcViewEntity,
; 3164 :                                       &lpSrcViewEntityCsr,
; 3165 :                                       iIncludeSubobjectFromSubobject,
; 3166 :                                       lpSrcView,
; 3167 :                                       cpcSrcEntityName, 0 ) )
; 3168 :    {
; 3169 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN8@IncludeSub:

; 3170 :    }
; 3171 : 
; 3172 :    // Validate that the view passed is valid.
; 3173 :    if ( fnValidViewCsr( lpCurrentTask, lpTgtView ) == 0 )

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN9@IncludeSub

; 3174 :    {
; 3175 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 3176 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN9@IncludeSub:

; 3177 :    }
; 3178 : 
; 3179 :    if ( (lpTgtViewEntity = fnValidViewEntity( &lpTgtViewEntityCsr,
; 3180 :                                               lpTgtView,
; 3181 :                                               cpcTgtEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpTgtViewEntity$[ebp], eax
	cmp	DWORD PTR _lpTgtViewEntity$[ebp], 0
	jne	SHORT $LN10@IncludeSub

; 3182 :    {
; 3183 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 3184 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN10@IncludeSub:

; 3185 :    }
; 3186 : 
; 3187 :    nRC = IncludeSubobjectFromSubobject( lpTgtView, cpcTgtEntityName,

	movzx	edx, WORD PTR _nPosition$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_IncludeSubobjectFromSubobject@20
	mov	WORD PTR _nRC$[ebp], ax

; 3188 :                                         lpSrcView, cpcSrcEntityName,
; 3189 :                                         nPosition );
; 3190 : 
; 3191 :    if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN11@IncludeSub

; 3192 :       goto EndOfFunction;

	jmp	$EndOfFunction$22
$LN11@IncludeSub:

; 3193 : 
; 3194 :    if ( lControl | zINCLUDE_WITHCOPY )

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 1
	je	$EndOfFunction$22

; 3195 :    {
; 3196 :       LPENTITYINSTANCE lpSrcEI = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEI$2[ebp], eax

; 3197 :       LPENTITYINSTANCE lpTgtEI = zGETPTR( lpTgtViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEI$1[ebp], eax

; 3198 :       LPVIEWATTRIB     lpViewAttrib;
; 3199 : 
; 3200 :       // Copy non-persistent attributes.
; 3201 :       for ( lpViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$4[ebp], eax
	jmp	SHORT $LN4@IncludeSub
$LN2@IncludeSub:

; 3203 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$4[ebp], eax
$LN4@IncludeSub:

; 3202 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$4[ebp], 0
	je	$EndOfFunction$22

; 3204 :       {
; 3205 :          LPVIEWATTRIB lpTgtViewAttrib;
; 3206 : 
; 3207 :          if ( lpViewAttrib->bPersist )

	mov	edx, DWORD PTR _lpViewAttrib$4[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	je	SHORT $LN13@IncludeSub

; 3208 :             continue;

	jmp	SHORT $LN2@IncludeSub
$LN13@IncludeSub:

; 3209 : 
; 3210 :          // Look for an attribute with the same name.
; 3211 :          for ( lpTgtViewAttrib = zGETPTR( lpTgtViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewAttrib$3[ebp], eax
	jmp	SHORT $LN7@IncludeSub
$LN5@IncludeSub:

; 3213 :                lpTgtViewAttrib = zGETPTR( lpTgtViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpTgtViewAttrib$3[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewAttrib$3[ebp], eax
$LN7@IncludeSub:

; 3212 :                lpTgtViewAttrib;

	cmp	DWORD PTR _lpTgtViewAttrib$3[ebp], 0
	je	SHORT $LN6@IncludeSub

; 3214 :          {
; 3215 :             if ( zstrcmp( lpTgtViewAttrib->szName,
; 3216 :                           lpViewAttrib->szName ) == 0 )

	mov	edx, DWORD PTR _lpTgtViewAttrib$3[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	eax, edx
	jne	SHORT $LN20@IncludeSub
	mov	eax, DWORD PTR _lpViewAttrib$4[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewAttrib$3[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv171[ebp], eax
	jmp	SHORT $LN21@IncludeSub
$LN20@IncludeSub:
	mov	edx, DWORD PTR _lpTgtViewAttrib$3[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN18@IncludeSub
	mov	DWORD PTR tv170[ebp], 1
	jmp	SHORT $LN19@IncludeSub
$LN18@IncludeSub:
	mov	DWORD PTR tv170[ebp], -1
$LN19@IncludeSub:
	mov	eax, DWORD PTR tv170[ebp]
	mov	DWORD PTR tv171[ebp], eax
$LN21@IncludeSub:
	cmp	DWORD PTR tv171[ebp], 0
	jne	SHORT $LN14@IncludeSub

; 3217 :             {
; 3218 :                // Found a matching attribute by name so break.
; 3219 :                break;

	jmp	SHORT $LN6@IncludeSub
$LN14@IncludeSub:

; 3220 :             }
; 3221 :          }

	jmp	SHORT $LN5@IncludeSub
$LN6@IncludeSub:

; 3222 : 
; 3223 :          // If lpTgtViewAttrib is 0 then we didn't find a matching attr by
; 3224 :          // name so try again with the next attrib.
; 3225 :          if ( lpTgtViewAttrib == 0 )

	cmp	DWORD PTR _lpTgtViewAttrib$3[ebp], 0
	jne	SHORT $LN15@IncludeSub

; 3226 :             continue;

	jmp	$LN2@IncludeSub
$LN15@IncludeSub:

; 3227 : 
; 3228 :          if ( SetAttributeFromAttribute( lpTgtView,
; 3229 :                                          lpTgtViewEntity->szName,
; 3230 :                                          lpTgtViewAttrib->szName,
; 3231 :                                          lpSrcView,
; 3232 :                                          lpSrcViewEntity->szName,
; 3233 :                                          lpViewAttrib->szName ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpViewAttrib$4[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewAttrib$3[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_SetAttributeFromAttribute@24
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN16@IncludeSub

; 3234 :          {
; 3235 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 3236 :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$22
$LN16@IncludeSub:

; 3237 :          }
; 3238 : 
; 3239 :       }

	jmp	$LN2@IncludeSub
$EndOfFunction$22:

; 3240 : 
; 3241 :    } // if ( lControl | zINCLUDE_WITHCOPY )...
; 3242 : 
; 3243 : EndOfFunction:
; 3244 :    // Simple enough, let's return to caller.
; 3245 :    fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 3246 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@IncludeSub:

; 3247 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_IncludeSubobjectFromSubobjectEx@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpWorkViewEntity$1 = -1036				; size = 4
_lpWorkViewEntityCsr$2 = -1032				; size = 4
_lpTemp$3 = -1028					; size = 4
_lpTgtViewOI$ = -1024					; size = 4
_lpSrcOwningTask$ = -1020				; size = 4
tv209 = -1016						; size = 4
tv208 = -1012						; size = 4
_lpSrcViewOI$ = -1008					; size = 4
_lpSrcViewEntityCsr$ = -1004				; size = 4
_lpParentCsr$4 = -1000					; size = 4
_lpViewCsr$ = -996					; size = 4
_lpViewOD$5 = -992					; size = 4
_lpViewOD$6 = -988					; size = 4
_nPositionOK$ = -984					; size = 2
_szDebug$7 = -980					; size = 2
_lpTgtViewEntityCsr$ = -976				; size = 4
_lpPrevVsn$8 = -972					; size = 4
_lpWorkView$9 = -968					; size = 4
_bNewRoot$ = -964					; size = 2
_n$10 = -960						; size = 2
_lpTgtOwningTask$ = -956				; size = 4
_lpSrcViewOD$ = -952					; size = 4
_lpTgtParent$11 = -948					; size = 4
_lpTgtViewOD$ = -944					; size = 4
_nRC$ = -940						; size = 2
_lpTgtAttrib$12 = -936					; size = 4
_lpSrcAttrib$13 = -932					; size = 4
_lpSrcViewEntity$ = -928				; size = 4
_lpTgtViewEntity$ = -924				; size = 4
_lpSrcInstance$14 = -920				; size = 4
_lpCurrentTask$ = -916					; size = 4
_szMsg$15 = -912					; size = 250
_szMsg$16 = -660					; size = 200
_szMsg$17 = -460					; size = 200
_cpcEntityName$ = -260					; size = 255
__$ArrayPad$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_nPosition$ = 24					; size = 2
_IncludeSubobjectFromSubobject@20 PROC

; 2644 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1036				; 0000040cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2645 :    LPTASK            lpCurrentTask;
; 2646 :    LPTASK            lpSrcOwningTask;
; 2647 :    LPTASK            lpTgtOwningTask;
; 2648 :    LPVIEWOD          lpSrcViewOD;
; 2649 :    LPVIEWOD          lpTgtViewOD;
; 2650 :    LPVIEWENTITY      lpSrcViewEntity;
; 2651 :    LPVIEWENTITY      lpTgtViewEntity;
; 2652 :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 2653 :    LPVIEWENTITYCSR   lpTgtViewEntityCsr;
; 2654 :    LPVIEWOI          lpSrcViewOI;
; 2655 :    LPVIEWOI          lpTgtViewOI;
; 2656 :    LPVIEWCSR         lpViewCsr;
; 2657 :    zCHAR             cpcEntityName[ 255 ];
; 2658 :    zSHORT            bNewRoot;
; 2659 :    zSHORT            nPositionOK;
; 2660 :    zSHORT            nRC;
; 2661 : 
; 2662 :    // Validate that the source view entity exists and has a cursor
; 2663 :    // value for copying, we call fnValidateInstanceParameters for the
; 2664 :    // source since it requires the same editing as an attribute retrieval.
; 2665 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	105					; 00000069H
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN16@IncludeSub

; 2666 :                                       &lpSrcViewEntity,
; 2667 :                                       &lpSrcViewEntityCsr,
; 2668 :                                       iIncludeSubobjectFromSubobject,
; 2669 :                                       lpSrcView,
; 2670 :                                       cpcSrcEntityName, 0 ) )
; 2671 :    {
; 2672 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN16@IncludeSub:

; 2673 :    }
; 2674 : 
; 2675 :    // Validate that the view passed is valid.
; 2676 :    if ( fnValidViewCsr( lpCurrentTask, lpTgtView ) == 0 )

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidViewCsr
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN17@IncludeSub

; 2677 :    {
; 2678 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2679 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN17@IncludeSub:

; 2680 :    }
; 2681 : 
; 2682 :    if ( (lpTgtViewEntity = fnValidViewEntity( &lpTgtViewEntityCsr,
; 2683 :                                               lpTgtView,
; 2684 :                                               cpcTgtEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpTgtViewEntity$[ebp], eax
	cmp	DWORD PTR _lpTgtViewEntity$[ebp], 0
	jne	SHORT $LN18@IncludeSub

; 2685 :    {
; 2686 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2687 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN18@IncludeSub:

; 2688 :    }
; 2689 : 
; 2690 :    // If intent is update and the target view is read-only, fail the call.
; 2691 :    if ( lpTgtView->bReadOnly )

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN19@IncludeSub

; 2692 :    {
; 2693 :       // We'll only fail the call if the entity isn't down a derived path.
; 2694 :       if ( lpTgtViewEntity->bDerivedPath == FALSE )

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	jne	SHORT $LN19@IncludeSub

; 2695 :       {
; 2696 :          // "KZOEE119 - Invalid View, View is Read Only"
; 2697 :          fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 119, 0, cpcTgtEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	push	0
	push	119					; 00000077H
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2698 :          fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2699 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN19@IncludeSub:

; 2700 :       }
; 2701 :    }
; 2702 : 
; 2703 :    // Make sure entity can be included.
; 2704 :    if ( lpSrcViewEntity->bInclSrc == FALSE )

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 5
	and	edx, 1
	jne	SHORT $LN21@IncludeSub

; 2705 :    {
; 2706 :       strcpy( cpcEntityName, "\nEntity: \t" );

	push	OFFSET $SG14281
	lea	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2707 :       strcat( cpcEntityName, lpSrcViewEntity->szName );

	mov	ecx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	lea	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2708 : 
; 2709 :       // "KZOEE106 - Rules violation"
; 2710 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	lea	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	OFFSET $SG14282
	push	0
	push	106					; 0000006aH
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2711 :                         "Source Entity not includeble",
; 2712 :                         cpcEntityName );
; 2713 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2714 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN21@IncludeSub:

; 2715 :    }
; 2716 : 
; 2717 :    // Make sure entity can be included.
; 2718 :    if ( lpTgtViewEntity->hParent && lpTgtViewEntity->bInclude == FALSE )

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	$LN22@IncludeSub
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN22@IncludeSub

; 2719 :    {
; 2720 :       strcpy( cpcEntityName, "\nEntity: \t" );

	push	OFFSET $SG14284
	lea	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2721 :       strcat( cpcEntityName, lpTgtViewEntity->szName );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2722 : 
; 2723 :       // "KZOEE106 - Rules violation"
; 2724 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	lea	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	push	OFFSET $SG14285
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2725 :                         "Entity inclusion not allowed",
; 2726 :                         cpcEntityName );
; 2727 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2728 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN22@IncludeSub:

; 2729 :    }
; 2730 : 
; 2731 :    // Make sure that the LODs are in sync.  They are out of sync if the LODs
; 2732 :    // were built with different dates for the ER.  We won't bother performing
; 2733 :    // the check if either LOD doesn't have the ER date.  This allows old LODs
; 2734 :    // to work.
; 2735 :    lpSrcViewOD = zGETPTR( lpSrcView->hViewOD );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOD$[ebp], eax

; 2736 :    lpTgtViewOD = zGETPTR( lpTgtView->hViewOD );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOD$[ebp], eax

; 2737 :    if ( lpSrcViewOD->szER_Date[ 0 ] && lpTgtViewOD->szER_Date[ 0 ] &&

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+248]
	test	eax, eax
	je	$LN23@IncludeSub
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+248]
	test	ecx, ecx
	je	$LN23@IncludeSub
	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+248]
	cmp	eax, edx
	jne	SHORT $LN64@IncludeSub
	mov	eax, DWORD PTR _lpTgtViewOD$[ebp]
	add	eax, 248				; 000000f8H
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv209[ebp], eax
	jmp	SHORT $LN65@IncludeSub
$LN64@IncludeSub:
	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+248]
	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+248]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN62@IncludeSub
	mov	DWORD PTR tv208[ebp], 1
	jmp	SHORT $LN63@IncludeSub
$LN62@IncludeSub:
	mov	DWORD PTR tv208[ebp], -1
$LN63@IncludeSub:
	mov	eax, DWORD PTR tv208[ebp]
	mov	DWORD PTR tv209[ebp], eax
$LN65@IncludeSub:
	cmp	DWORD PTR tv209[ebp], 0
	je	$LN23@IncludeSub

; 2738 :         zstrcmp( lpSrcViewOD->szER_Date, lpTgtViewOD->szER_Date ) != 0 )
; 2739 :    {
; 2740 :       zCHAR szMsg[ 200 ];
; 2741 : 
; 2742 :       TraceLineS( "ERROR: ", "The following LODs are out of sync and should be re-built" );

	push	OFFSET $SG14287
	push	OFFSET $SG14288
	call	_TraceLineS@8

; 2743 : 
; 2744 :       zsprintf( szMsg, "Out-of-sync error. Target LOD = %s, date = %s",

	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	add	ecx, 248				; 000000f8H
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14289
	lea	eax, DWORD PTR _szMsg$16[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2745 :                 lpTgtViewOD->szName, lpTgtViewOD->szER_Date );
; 2746 :       TraceLineS( "ERROR: ", szMsg );

	lea	ecx, DWORD PTR _szMsg$16[ebp]
	push	ecx
	push	OFFSET $SG14290
	call	_TraceLineS@8

; 2747 : 
; 2748 :       zsprintf( szMsg, "Out-of-sync error. Source LOD = %s, date = %s",

	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	add	edx, 248				; 000000f8H
	push	edx
	mov	eax, DWORD PTR _lpSrcViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14291
	lea	ecx, DWORD PTR _szMsg$16[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2749 :                 lpSrcViewOD->szName, lpSrcViewOD->szER_Date );
; 2750 :       TraceLineS( "ERROR: ", szMsg );

	lea	edx, DWORD PTR _szMsg$16[ebp]
	push	edx
	push	OFFSET $SG14292
	call	_TraceLineS@8

; 2751 : 
; 2752 :       // "KZOEE106 - Rules violation"
; 2753 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	mov	eax, DWORD PTR _lpTgtViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14293
	push	0
	push	106					; 0000006aH
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2754 :                         "LODs are potentially out of sync.  See trace for more.",
; 2755 :                         lpTgtViewOD->szName );
; 2756 : 
; 2757 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2758 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN23@IncludeSub:

; 2759 :    }
; 2760 : 
; 2761 :    // DGC 97/03/19 Added following checks.
; 2762 : 
; 2763 :    // If the target entity has physical information then the source view had
; 2764 :    // better have physical information.
; 2765 :    if ( lpTgtViewEntity->hFirstDataRecord &&

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	cmp	DWORD PTR [ecx+191], 0
	je	$LN24@IncludeSub
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	cmp	DWORD PTR [edx+191], 0
	jne	$LN24@IncludeSub

; 2766 :         lpSrcViewEntity->hFirstDataRecord == 0 )
; 2767 :    {
; 2768 :       zCHAR    szMsg[ 200 ];
; 2769 :       LPVIEWOD lpViewOD;
; 2770 : 
; 2771 :       TraceLineS( "Rules violation: physical mapping mismatch", "" );

	push	OFFSET $SG14295
	push	OFFSET $SG14296
	call	_TraceLineS@8

; 2772 : 
; 2773 :       lpViewOD = zGETPTR( lpTgtView->hViewOD );

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$6[ebp], eax

; 2774 :       zsprintf( szMsg, "%s.%s", lpViewOD->szName, lpTgtViewEntity->szName );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$6[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14297
	lea	ecx, DWORD PTR _szMsg$17[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2775 :       TraceLineS( "   Target entity = ", szMsg );

	lea	edx, DWORD PTR _szMsg$17[ebp]
	push	edx
	push	OFFSET $SG14298
	call	_TraceLineS@8

; 2776 : 
; 2777 :       lpViewOD = zGETPTR( lpSrcView->hViewOD );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$6[ebp], eax

; 2778 :       zsprintf( szMsg, "%s.%s", lpViewOD->szName, lpSrcViewEntity->szName );

	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$6[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14299
	lea	ecx, DWORD PTR _szMsg$17[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2779 :       TraceLineS( "   Source entity = ", szMsg );

	lea	edx, DWORD PTR _szMsg$17[ebp]
	push	edx
	push	OFFSET $SG14300
	call	_TraceLineS@8

; 2780 : 
; 2781 :       // "KZOEE106 - Rules violation"
; 2782 :       fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	push	0
	push	OFFSET $SG14301
	push	0
	push	106					; 0000006aH
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2783 :                         "Target entity has physical mapping but source "
; 2784 :                         "entity does not.  Rebuild source LOD with TE.\n"
; 2785 :                         "See trace for more.", 0 );
; 2786 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2787 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN24@IncludeSub:

; 2788 :    }
; 2789 : 
; 2790 :    // Get source and target tasks ... steal the owning variables for a second
; 2791 :    // so we can do the test immediately following.
; 2792 :    lpSrcOwningTask = zGETPTR( lpSrcView->hTask );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcOwningTask$[ebp], eax

; 2793 :    lpTgtOwningTask = zGETPTR( lpTgtView->hTask );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtOwningTask$[ebp], eax

; 2794 : 
; 2795 :    // If the task of the source view is not equal to the task of the target
; 2796 :    // view, we will have a problem if the source task is destroyed before the
; 2797 :    // target task.  So we will error out of here unless perhaps the source
; 2798 :    // task is the application or main (anchor) task.
; 2799 : #if 0
; 2800 :    if ( lpTgtView->hTask != lpSrcView->hTask )
; 2801 :       SysMessageBox( 0, "OE Error",
; 2802 :                      "IncludeSubobjectFromSubobject source and target views task conflict",
; 2803 :                      -1 );
; 2804 : #else
; 2805 :    if ( lpTgtView->hTask != lpSrcView->hTask &&
; 2806 :         lpSrcView->bApplicationView == FALSE &&
; 2807 :         lpSrcOwningTask->bApplicationTask == FALSE &&
; 2808 :         lpTgtOwningTask->bApplicationTask == FALSE &&

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+14]
	je	$LN25@IncludeSub
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 3
	and	edx, 1
	jne	$LN25@IncludeSub
	mov	eax, DWORD PTR _lpSrcOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	jne	$LN25@IncludeSub
	mov	edx, DWORD PTR _lpTgtOwningTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	jne	$LN25@IncludeSub
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+106]
	je	$LN25@IncludeSub

; 2809 :         lpSrcView->hTask != AnchorBlock->hMainTask )
; 2810 :    {
; 2811 :       static zSHORT k = 0;
; 2812 :       zCHAR szDebug[ 2 ];
; 2813 : 
; 2814 :       if ( k == 0 )

	movsx	ecx, WORD PTR ?k@?M@??IncludeSubobjectFromSubobject@@9@9
	test	ecx, ecx
	jne	SHORT $LN26@IncludeSub

; 2815 :          SysReadZeidonIni( -1, "[Debug]", "BombZDr", szDebug );

	lea	edx, DWORD PTR _szDebug$7[ebp]
	push	edx
	push	OFFSET $SG14304
	push	OFFSET $SG14305
	push	-1
	call	_SysReadZeidonIni@16
$LN26@IncludeSub:

; 2816 : 
; 2817 :       if ( k == 0 && szDebug[ 0 ] == 'Y' )

	movsx	eax, WORD PTR ?k@?M@??IncludeSubobjectFromSubobject@@9@9
	test	eax, eax
	jne	$LN27@IncludeSub
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szDebug$7[ebp+edx]
	cmp	eax, 89					; 00000059H
	jne	$LN27@IncludeSub

; 2818 :       {
; 2819 :          lpTgtOwningTask = zGETPTR( lpTgtView->hTask );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtOwningTask$[ebp], eax

; 2820 :          if ( lpTgtOwningTask->bApplicationTask )

	mov	eax, DWORD PTR _lpTgtOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 13					; 0000000dH
	and	ecx, 1
	je	SHORT $LN29@IncludeSub

; 2821 :          {
; 2822 :             TraceLine( "IncludeSubobjectFromSubobject Include source task (0x%08x) "

	mov	edx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	push	OFFSET $SG14310
	call	_TraceLine
	add	esp, 20					; 00000014H

; 2823 :                          "does not match target task (0x%08x), but target task is the "
; 2824 :                          "application task - Source Entity: %s  Target Entity: %s",
; 2825 :                        lpSrcView->hTask, lpTgtView->hTask,
; 2826 :                        cpcSrcEntityName, cpcTgtEntityName );
; 2827 :          }

	jmp	SHORT $LN30@IncludeSub
$LN29@IncludeSub:

; 2828 :          else
; 2829 :          {
; 2830 :             k /= k;

	movsx	ecx, WORD PTR ?k@?M@??IncludeSubobjectFromSubobject@@9@9
	movsx	eax, WORD PTR ?k@?M@??IncludeSubobjectFromSubobject@@9@9
	cdq
	idiv	ecx
	mov	WORD PTR ?k@?M@??IncludeSubobjectFromSubobject@@9@9, ax

; 2831 :             k++;

	mov	dx, WORD PTR ?k@?M@??IncludeSubobjectFromSubobject@@9@9
	add	dx, 1
	mov	WORD PTR ?k@?M@??IncludeSubobjectFromSubobject@@9@9, dx

; 2832 : 
; 2833 :             // "KZOEE451 - Include source task does not match target task"
; 2834 :             fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 451, 0, cpcTgtEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	push	0
	push	451					; 000001c3H
	push	8
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN30@IncludeSub:

; 2835 :          // fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );
; 2836 : 
; 2837 :          // return( zCALL_ERROR );
; 2838 :          }
; 2839 :       }

	jmp	SHORT $LN25@IncludeSub
$LN27@IncludeSub:

; 2840 :       else
; 2841 :       {
; 2842 :          lpTgtOwningTask = zGETPTR( lpTgtView->hTask );

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtOwningTask$[ebp], eax

; 2843 :          if ( lpTgtOwningTask->bApplicationTask )

	mov	edx, DWORD PTR _lpTgtOwningTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	je	SHORT $LN31@IncludeSub

; 2844 :          {
; 2845 :             TraceLine( "IncludeSubobjectFromSubobject Include source task (0x%08x) does not match target task (0x%08x),"

	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET $SG14313
	call	_TraceLine
	add	esp, 20					; 00000014H

; 2846 :                          " but target task is the application task"
; 2847 :                          "Source Entity: %s   Target Entity: %s",
; 2848 :                        lpSrcView->hTask, lpTgtView->hTask,
; 2849 :                        cpcSrcEntityName, cpcTgtEntityName );
; 2850 :          }

	jmp	SHORT $LN25@IncludeSub
$LN31@IncludeSub:

; 2851 :          else
; 2852 :          {
; 2853 :             TraceLine( "IncludeSubobjectFromSubobject Include source task (0x%08x) does not match target task (0x%08x) "

	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSrcEntityName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET $SG14314
	call	_TraceLine
	add	esp, 20					; 00000014H
$LN25@IncludeSub:

; 2854 :                          "Source Entity: %s   Target Entity: %s",
; 2855 :                        lpSrcView->hTask, lpTgtView->hTask,
; 2856 :                        cpcSrcEntityName, cpcTgtEntityName );
; 2857 :          }
; 2858 :       }
; 2859 :    }
; 2860 : #endif
; 2861 : 
; 2862 :    // If the source entity has physical mapping but the target entity does
; 2863 :    // not, then it's possible that the attributes in each entity don't match.
; 2864 :    // Make sure that each attribute in the target has a matching attribute in
; 2865 :    // the source.
; 2866 :    if ( lpTgtViewEntity->hFirstDataRecord == 0 &&

	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	cmp	DWORD PTR [ecx+191], 0
	jne	$LN33@IncludeSub
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	cmp	DWORD PTR [edx+191], 0
	je	$LN33@IncludeSub

; 2867 :         lpSrcViewEntity->hFirstDataRecord )
; 2868 :    {
; 2869 :       LPVIEWATTRIB lpTgtAttrib;
; 2870 :       LPVIEWATTRIB lpSrcAttrib;
; 2871 : 
; 2872 :       // Loop through each of the target attributes.
; 2873 :       for ( lpTgtAttrib = zGETPTR( lpTgtViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtAttrib$12[ebp], eax
	jmp	SHORT $LN4@IncludeSub
$LN2@IncludeSub:

; 2875 :             lpTgtAttrib = zGETPTR( lpTgtAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpTgtAttrib$12[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtAttrib$12[ebp], eax
$LN4@IncludeSub:

; 2874 :             lpTgtAttrib;

	cmp	DWORD PTR _lpTgtAttrib$12[ebp], 0
	je	$LN33@IncludeSub

; 2876 :       {
; 2877 :          // We only care about persistent attributes.
; 2878 :          if ( lpTgtAttrib->bPersist == FALSE )

	mov	ecx, DWORD PTR _lpTgtAttrib$12[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN34@IncludeSub

; 2879 :             continue;

	jmp	SHORT $LN2@IncludeSub
$LN34@IncludeSub:

; 2880 : 
; 2881 :          // Look for a matching source attribute.
; 2882 :          for ( lpSrcAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcAttrib$13[ebp], eax
	jmp	SHORT $LN7@IncludeSub
$LN5@IncludeSub:

; 2884 :                lpSrcAttrib = zGETPTR( lpSrcAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpSrcAttrib$13[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcAttrib$13[ebp], eax
$LN7@IncludeSub:

; 2883 :                lpSrcAttrib && lpSrcAttrib->lERAttTok != lpTgtAttrib->lERAttTok;

	cmp	DWORD PTR _lpSrcAttrib$13[ebp], 0
	je	SHORT $LN6@IncludeSub
	mov	ecx, DWORD PTR _lpSrcAttrib$13[ebp]
	mov	edx, DWORD PTR _lpTgtAttrib$12[ebp]
	mov	eax, DWORD PTR [ecx+177]
	cmp	eax, DWORD PTR [edx+177]
	je	SHORT $LN6@IncludeSub

; 2885 :          {
; 2886 :             // Nothing needs to be done here.
; 2887 :          }

	jmp	SHORT $LN5@IncludeSub
$LN6@IncludeSub:

; 2888 : 
; 2889 :          // If lpSrcAttrib is 0 then we didn't find a matching source attrib.
; 2890 :          // If the offsets don't match then we also have an error.
; 2891 :          if ( lpSrcAttrib == 0 ||

	cmp	DWORD PTR _lpSrcAttrib$13[ebp], 0
	je	SHORT $LN36@IncludeSub
	mov	ecx, DWORD PTR _lpSrcAttrib$13[ebp]
	mov	edx, DWORD PTR _lpTgtAttrib$12[ebp]
	mov	eax, DWORD PTR [ecx+250]
	cmp	eax, DWORD PTR [edx+250]
	je	$LN35@IncludeSub
$LN36@IncludeSub:

; 2892 :               lpSrcAttrib->ulRecordOffset != lpTgtAttrib->ulRecordOffset )
; 2893 :          {
; 2894 :             zCHAR szMsg[ 250 ];
; 2895 :             LPVIEWOD lpViewOD;
; 2896 : 
; 2897 :             if ( lpSrcAttrib )

	cmp	DWORD PTR _lpSrcAttrib$13[ebp], 0
	je	SHORT $LN37@IncludeSub

; 2898 :             {
; 2899 :                lpViewOD = (LPVIEWOD) zGETPTR( lpSrcView->hViewOD );

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$5[ebp], eax

; 2900 : 
; 2901 :                zsprintf( szMsg, "%s.%s.%s Offset = %d",

	mov	eax, DWORD PTR _lpSrcAttrib$13[ebp]
	mov	ecx, DWORD PTR [eax+250]
	push	ecx
	mov	edx, DWORD PTR _lpSrcAttrib$13[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$5[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14321
	lea	edx, DWORD PTR _szMsg$15[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 2902 :                          lpViewOD->szName,
; 2903 :                          lpSrcViewEntity->szName,
; 2904 :                          lpSrcAttrib->szName,
; 2905 :                          lpSrcAttrib->ulRecordOffset );
; 2906 :                TraceLineS( "(so) IncludeSubobject Src ", szMsg );

	lea	eax, DWORD PTR _szMsg$15[ebp]
	push	eax
	push	OFFSET $SG14322
	call	_TraceLineS@8

; 2907 :             }

	jmp	SHORT $LN38@IncludeSub
$LN37@IncludeSub:

; 2908 :             else
; 2909 :                TraceLineS( "(so) No matching Src Attrib", "" );

	push	OFFSET $SG14323
	push	OFFSET $SG14324
	call	_TraceLineS@8
$LN38@IncludeSub:

; 2910 : 
; 2911 :             lpViewOD = (LPVIEWOD) zGETPTR( lpTgtView->hViewOD );

	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$5[ebp], eax

; 2912 :             zsprintf( szMsg, "%s.%s.%s Offset = %d",

	mov	eax, DWORD PTR _lpTgtAttrib$12[ebp]
	mov	ecx, DWORD PTR [eax+250]
	push	ecx
	mov	edx, DWORD PTR _lpTgtAttrib$12[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$5[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14325
	lea	edx, DWORD PTR _szMsg$15[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 2913 :                       lpViewOD->szName,
; 2914 :                       lpTgtViewEntity->szName,
; 2915 :                       lpTgtAttrib->szName,
; 2916 :                       lpTgtAttrib->ulRecordOffset );
; 2917 :             TraceLineS( "(so) IncludeSubobject Tgt ", szMsg );

	lea	eax, DWORD PTR _szMsg$15[ebp]
	push	eax
	push	OFFSET $SG14326
	call	_TraceLineS@8

; 2918 : 
; 2919 :             strcpy( cpcEntityName, "\nEntity: \t" );

	push	OFFSET $SG14327
	lea	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2920 :             strcat( cpcEntityName, lpTgtViewEntity->szName );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2921 : 
; 2922 :             // "KZOEE106 - Rules violation"
; 2923 :             fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 106, 0,

	lea	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	push	OFFSET $SG14328
	push	0
	push	106					; 0000006aH
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2924 :                               "Source entity was built with TE but the target "
; 2925 :                               "entity was not and attributes do not match. "
; 2926 :                               "Rebuild target LOD with TE.\n"
; 2927 :                               "Target entity name",
; 2928 :                               cpcEntityName );
; 2929 :             fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2930 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN35@IncludeSub:

; 2931 :          }
; 2932 : 
; 2933 :       } // For each lpTgtAttrib...

	jmp	$LN2@IncludeSub
$LN33@IncludeSub:

; 2934 : 
; 2935 :    } // if ( lpTgtViewEntity->hFirstDataRecord == 0 &&
; 2936 :      //      lpSrcViewEntity->hFirstDataRecord )...
; 2937 : 
; 2938 :    // DGC 97/03/19 End.
; 2939 : 
; 2940 :    lpViewCsr   = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2941 :    lpSrcViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 2942 :    lpViewCsr   = zGETPTR( lpTgtView->hViewCsr );

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2943 :    lpTgtViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 2944 : 
; 2945 :    // Versioning rule, the source instance can be versioned, but the
; 2946 :    // include will actually take place from the OLDEST version of the
; 2947 :    // source. If the source instances OLDEST version is under a version
; 2948 :    // root with a previous version, then we must fail the include
; 2949 :    // request since the cancel of the version root will cause the
; 2950 :    // included instance to totally disappear.
; 2951 :    if ( lpSrcViewOI->nVersionedInstances )

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	$LN39@IncludeSub

; 2952 :    {
; 2953 :       LPENTITYINSTANCE lpSrcInstance;
; 2954 :       LPENTITYINSTANCE lpTgtParent;
; 2955 : 
; 2956 :       lpSrcInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$14[ebp], eax

; 2957 : 
; 2958 :       // If the source of the include is a temporal entity, issue an
; 2959 :       // error because a cancel could UNDO the include and this
; 2960 :       // would be confusing to the application developer!
; 2961 :       if ( lpSrcInstance->u.nInd.bTemporal &&

	mov	edx, DWORD PTR _lpSrcInstance$14[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN8@IncludeSub
	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	cmp	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	je	SHORT $LN8@IncludeSub

; 2962 :            lpSrcViewOI != lpTgtViewOI )
; 2963 :       {
; 2964 :          //  "KZOEE141 - Attempt to include a subobject whose root is a "
; 2965 :          //  "           Temporal Entity"
; 2966 :          fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 141, 0,

	push	0
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	0
	push	141					; 0000008dH
	push	8
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2967 :                            lpSrcViewEntity->szName, 0 );
; 2968 :          fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 2969 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN8@IncludeSub:

; 2970 :       }
; 2971 : 
; 2972 :       while ( lpSrcInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpSrcInstance$14[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN10@IncludeSub

; 2973 :          lpSrcInstance = zGETPTR( lpSrcInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpSrcInstance$14[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$14[ebp], eax
	jmp	SHORT $LN8@IncludeSub
$LN10@IncludeSub:

; 2974 : 
; 2975 :       while ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$14[ebp], 0
	je	SHORT $LN11@IncludeSub

; 2976 :       {
; 2977 :          if ( lpSrcInstance->hPrevVsn )

	mov	eax, DWORD PTR _lpSrcInstance$14[ebp]
	cmp	DWORD PTR [eax+38], 0
	je	SHORT $LN41@IncludeSub

; 2978 :             break;

	jmp	SHORT $LN11@IncludeSub
$LN41@IncludeSub:

; 2979 : 
; 2980 :          lpSrcInstance = zGETPTR( lpSrcInstance->hParent );

	mov	ecx, DWORD PTR _lpSrcInstance$14[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$14[ebp], eax

; 2981 :       }

	jmp	SHORT $LN10@IncludeSub
$LN11@IncludeSub:

; 2982 : 
; 2983 :       // The source instance is versioned, now it is pointing to
; 2984 :       // the root of sources previous version, see if the parent
; 2985 :       // target entity instance is part of the same version, if so
; 2986 :       // then the include can happen, otherwise the include must fail
; 2987 :       // because it may disappear as the result of a cancel call.
; 2988 :       if ( lpSrcInstance && lpTgtViewEntityCsr->hParent )

	cmp	DWORD PTR _lpSrcInstance$14[ebp], 0
	je	$LN42@IncludeSub
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	$LN42@IncludeSub

; 2989 :       {
; 2990 :          LPENTITYINSTANCE lpPrevVsn;
; 2991 :          LPVIEWENTITYCSR  lpParentCsr;
; 2992 : 
; 2993 :          lpSrcInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$14[ebp], eax
$LN12@IncludeSub:

; 2994 :          while ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$14[ebp], 0
	je	SHORT $LN13@IncludeSub

; 2995 :          {
; 2996 :             lpPrevVsn = zGETPTR( lpSrcInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpSrcInstance$14[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$8[ebp], eax

; 2997 :             if ( (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) ||

	cmp	DWORD PTR _lpPrevVsn$8[ebp], 0
	je	SHORT $LN45@IncludeSub
	mov	edx, DWORD PTR _lpPrevVsn$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	jne	SHORT $LN44@IncludeSub
$LN45@IncludeSub:
	mov	ecx, DWORD PTR _lpSrcInstance$14[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN43@IncludeSub
$LN44@IncludeSub:

; 2998 :                  lpSrcInstance->u.nInd.bTemporal )
; 2999 :             {
; 3000 :                break;

	jmp	SHORT $LN13@IncludeSub
$LN43@IncludeSub:

; 3001 :             }
; 3002 : 
; 3003 :             lpSrcInstance = zGETPTR( lpSrcInstance->hParent );

	mov	eax, DWORD PTR _lpSrcInstance$14[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$14[ebp], eax

; 3004 :          }

	jmp	SHORT $LN12@IncludeSub
$LN13@IncludeSub:

; 3005 : 
; 3006 :          lpParentCsr = zGETPTR( lpTgtViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentCsr$4[ebp], eax

; 3007 :          if ( lpParentCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpParentCsr$4[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN46@IncludeSub

; 3008 :             fnEstablishCursorForView( lpParentCsr );

	mov	edx, DWORD PTR _lpParentCsr$4[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN46@IncludeSub:

; 3009 : 
; 3010 :          lpTgtParent = zGETPTR( lpParentCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpParentCsr$4[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$11[ebp], eax
$LN14@IncludeSub:

; 3011 :          while ( lpTgtParent )

	cmp	DWORD PTR _lpTgtParent$11[ebp], 0
	je	SHORT $LN15@IncludeSub

; 3012 :          {
; 3013 :             lpPrevVsn = zGETPTR( lpTgtParent->hPrevVsn );

	mov	edx, DWORD PTR _lpTgtParent$11[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$8[ebp], eax

; 3014 :             if ( (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) ||

	cmp	DWORD PTR _lpPrevVsn$8[ebp], 0
	je	SHORT $LN49@IncludeSub
	mov	ecx, DWORD PTR _lpPrevVsn$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 9
	and	edx, 1
	jne	SHORT $LN48@IncludeSub
$LN49@IncludeSub:
	mov	eax, DWORD PTR _lpTgtParent$11[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN47@IncludeSub
$LN48@IncludeSub:

; 3015 :                  lpTgtParent->u.nInd.bTemporal )
; 3016 :             {
; 3017 :                break;

	jmp	SHORT $LN15@IncludeSub
$LN47@IncludeSub:

; 3018 :             }
; 3019 : 
; 3020 :             lpTgtParent = zGETPTR( lpTgtParent->hParent );

	mov	edx, DWORD PTR _lpTgtParent$11[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtParent$11[ebp], eax

; 3021 :          }

	jmp	SHORT $LN14@IncludeSub
$LN15@IncludeSub:

; 3022 : 
; 3023 :          if ( lpTgtParent == 0 || lpTgtParent != lpSrcInstance )

	cmp	DWORD PTR _lpTgtParent$11[ebp], 0
	je	SHORT $LN52@IncludeSub
	mov	ecx, DWORD PTR _lpTgtParent$11[ebp]
	cmp	ecx, DWORD PTR _lpSrcInstance$14[ebp]
	je	SHORT $LN50@IncludeSub
$LN52@IncludeSub:

; 3024 :             lpSrcInstance = zGETPTR( lpSrcViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$14[ebp], eax
	jmp	SHORT $LN42@IncludeSub
$LN50@IncludeSub:

; 3025 :          else
; 3026 :             lpSrcInstance = 0;

	mov	DWORD PTR _lpSrcInstance$14[ebp], 0
$LN42@IncludeSub:

; 3027 :       }
; 3028 : 
; 3029 :       if ( lpSrcInstance )

	cmp	DWORD PTR _lpSrcInstance$14[ebp], 0
	je	SHORT $LN39@IncludeSub

; 3030 :       {
; 3031 :          LPVIEWENTITY lpTemp = zGETPTR( lpSrcInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpSrcInstance$14[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTemp$3[ebp], eax

; 3032 : 
; 3033 :          //  "KZOEE116 - Attempt to include an instance created under
; 3034 :          //  "           a versioned parent"
; 3035 :          fnIssueCoreError( lpCurrentTask, lpSrcView, 8, 116, 0,

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpTemp$3[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	116					; 00000074H
	push	8
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3036 :                            lpTemp->szName,
; 3037 :                            lpSrcViewEntity->szName );
; 3038 :          fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 3039 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN39@IncludeSub:

; 3040 :       }
; 3041 :    }
; 3042 : 
; 3043 :    // Validate that an insert of this entity in this instance at
; 3044 :    // the specified position is valid.
; 3045 :    nPositionOK = fnValidateInsertPosition( &bNewRoot,

	movzx	edx, WORD PTR _nPosition$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	push	105					; 00000069H
	lea	edx, DWORD PTR _bNewRoot$[ebp]
	push	edx
	call	_fnValidateInsertPosition
	add	esp, 20					; 00000014H
	mov	WORD PTR _nPositionOK$[ebp], ax

; 3046 :                                            iIncludeSubobjectFromSubobject,
; 3047 :                                            lpTgtView,
; 3048 :                                            lpTgtViewEntityCsr,
; 3049 :                                            nPosition );
; 3050 :    if ( nPositionOK < 0 )

	movsx	eax, WORD PTR _nPositionOK$[ebp]
	test	eax, eax
	jge	SHORT $LN54@IncludeSub

; 3051 :    {
; 3052 :       fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 3053 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@IncludeSub
$LN54@IncludeSub:

; 3054 :    }
; 3055 : 
; 3056 :    // Get source and target owning tasks
; 3057 :    lpSrcOwningTask = zGETPTR( lpSrcViewOI->hTask );

	mov	edx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcOwningTask$[ebp], eax

; 3058 :    lpTgtOwningTask = zGETPTR( lpTgtViewOI->hTask );

	mov	ecx, DWORD PTR _lpTgtViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtOwningTask$[ebp], eax

; 3059 : 
; 3060 : #if 0
; 3061 :    // Validate that the Source and Target ViewOI belong to the
; 3062 :    // Same task!!!
; 3063 :    if ( lpSrcOwningTask != lpTgtOwningTask )
; 3064 :    {
; 3065 :       // If we have a task mismatch, make sure the source task is the
; 3066 :       // system task AND that all the target entities of the include
; 3067 :       // are READ ONLY.
; 3068 :       if ( lpSrcOwningTask != zGETPTR( AnchorBlock->hMainTask ) )
; 3069 :       {
; 3070 :          // "KZOEE131 - Attempt to include Subobject from another "
; 3071 :          // "           Application Task"
; 3072 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 131, 0, 0, 0 );
; 3073 :          fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );
; 3074 :          return( zCALL_ERROR );
; 3075 :       }
; 3076 : 
; 3077 :       lpTgtViewOI->hAllocTask = zGETHNDL( lpSrcOwningTask );
; 3078 :    }
; 3079 : #endif
; 3080 : 
; 3081 : #ifdef __ACTIVATE_CONSTRAINTS__
; 3082 :    // If there is an Entity Constraint for include, see if it has
; 3083 :    // any objections about continuing.
; 3084 :    if ( lpTgtViewEntity->bIncludeConstraint )

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 3
	and	ecx, 1
	je	$LN55@IncludeSub

; 3085 :    {
; 3086 :       zVIEW             lpWorkView;
; 3087 :       LPVIEWENTITY      lpWorkViewEntity;
; 3088 :       LPVIEWENTITYCSR   lpWorkViewEntityCsr;
; 3089 :       zSHORT            n;
; 3090 : 
; 3091 :       // Create a work view to save all the cursors just in case the
; 3092 :       // constraint handler says it's a no go situation.
; 3093 :       CreateViewFromViewForTask( &lpWorkView, lpTgtView, 0 );

	push	0
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpWorkView$9[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12

; 3094 :       lpWorkViewEntity = fnValidViewEntity( &lpWorkViewEntityCsr,

	push	0
	mov	ecx, DWORD PTR _cpcTgtEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWorkView$9[ebp]
	push	edx
	lea	eax, DWORD PTR _lpWorkViewEntityCsr$2[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpWorkViewEntity$1[ebp], eax

; 3095 :                                             lpWorkView, cpcTgtEntityName, 0 );
; 3096 : 
; 3097 :       // Call fnIncludeSubobjectFromSubobject to do the rest.
; 3098 :       nRC = fnIncludeSubobjectFromSubobject( lpTgtView, lpTgtViewEntity,

	push	1
	movzx	ecx, WORD PTR _bNewRoot$[ebp]
	push	ecx
	movzx	edx, WORD PTR _nPosition$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	mov	WORD PTR _nRC$[ebp], ax

; 3099 :                                              lpSrcView, lpSrcViewEntity,
; 3100 :                                              nPosition, bNewRoot, 1 );
; 3101 : 
; 3102 :       if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN57@IncludeSub

; 3103 :       {
; 3104 :          n = fnInvokeECEOperation( lpTgtView, lpTgtViewEntity, lpCurrentTask,

	push	0
	push	6
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnInvokeECEOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _n$10[ebp], ax

; 3105 :                                    zECE_INCLUDE, 0 );
; 3106 :          // If constraint handler doesn't like something, get out.
; 3107 :          if ( n )

	movsx	edx, WORD PTR _n$10[ebp]
	test	edx, edx
	je	SHORT $LN59@IncludeSub

; 3108 :          {
; 3109 :             // We must back out the include ... but how????
; 3110 :             fnExcludeEntity( lpTgtView, lpTgtViewEntity, lpTgtViewEntityCsr,

	push	1
	push	0
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnExcludeEntity
	add	esp, 20					; 00000014H

; 3111 :                              zREPOS_NONE, 1 );
; 3112 : 
; 3113 :             // and reset the cursors before exiting...
; 3114 :             fnSetViewFromView( lpTgtView, lpWorkView );

	mov	eax, DWORD PTR _lpWorkView$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	call	_fnSetViewFromView
	add	esp, 8

; 3115 :             fnDropView( lpWorkView );

	mov	edx, DWORD PTR _lpWorkView$9[ebp]
	push	edx
	call	_fnDropView@4

; 3116 :             fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 3117 :             return( n );

	mov	ax, WORD PTR _n$10[ebp]
	jmp	SHORT $LN1@IncludeSub

; 3118 :          }

	jmp	SHORT $LN60@IncludeSub
$LN59@IncludeSub:

; 3119 :          else
; 3120 :          {
; 3121 :             // Everything looks okey dokey...
; 3122 :             fnDropView( lpWorkView );

	mov	ecx, DWORD PTR _lpWorkView$9[ebp]
	push	ecx
	call	_fnDropView@4
$LN60@IncludeSub:

; 3123 :          }
; 3124 :       }

	jmp	SHORT $LN58@IncludeSub
$LN57@IncludeSub:

; 3125 :       else
; 3126 :       {
; 3127 :          // Clean up work view if error from fnIncludeSubobjectFromSubobject.
; 3128 :          fnDropView( lpWorkView );

	mov	edx, DWORD PTR _lpWorkView$9[ebp]
	push	edx
	call	_fnDropView@4
$LN58@IncludeSub:

; 3129 :       }
; 3130 :    }

	jmp	SHORT $LN56@IncludeSub
$LN55@IncludeSub:

; 3131 :    else
; 3132 : #endif
; 3133 : 
; 3134 :    // Call fnIncludeSubobjectFromSubobject to do the rest.
; 3135 :    nRC = fnIncludeSubobjectFromSubobject( lpTgtView, lpTgtViewEntity,

	push	1
	movzx	eax, WORD PTR _bNewRoot$[ebp]
	push	eax
	movzx	ecx, WORD PTR _nPosition$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtView$[ebp]
	push	edx
	call	_fnIncludeSubobjectFromSubobject
	add	esp, 28					; 0000001cH
	mov	WORD PTR _nRC$[ebp], ax
$LN56@IncludeSub:

; 3136 :                                           lpSrcView, lpSrcViewEntity,
; 3137 :                                           nPosition, bNewRoot, 1 );
; 3138 : 
; 3139 :    // Simple enough, let's return to caller.
; 3140 :    fnOperationReturn( iIncludeSubobjectFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	105					; 00000069H
	call	_fnOperationReturn
	add	esp, 8

; 3141 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@IncludeSub:

; 3142 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_IncludeSubobjectFromSubobject@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -36					; size = 4
_lpViewEntity$ = -32					; size = 4
_lpViewCsr$ = -28					; size = 4
_lpPrevVsn$ = -24					; size = 4
_lpViewOI$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_vWork$ = -12						; size = 4
_lpRoot$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_CancelAllTemporalSubobjects@4 PROC

; 2520 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2521 :    LPTASK           lpCurrentTask;
; 2522 :    LPVIEWOI         lpViewOI;
; 2523 :    LPVIEWCSR        lpViewCsr;
; 2524 :    LPVIEWENTITY     lpViewEntity;
; 2525 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 2526 :    LPENTITYINSTANCE lpRoot;
; 2527 :    LPENTITYINSTANCE lpPrevVsn;
; 2528 :    zVIEW            vWork;
; 2529 :    zSHORT           nRC;
; 2530 : 
; 2531 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2532 :    if ( (lpCurrentTask = fnOperationCall( iCancelAllTemporalSubobjects,
; 2533 :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	128					; 00000080H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@CancelAllT

; 2534 :    {
; 2535 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CancelAllT
$LN4@CancelAllT:

; 2536 :    }
; 2537 : 
; 2538 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2539 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2540 : 
; 2541 :    if ( lpViewOI->nVersionedInstances == 0 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	jne	SHORT $LN5@CancelAllT

; 2542 :    {
; 2543 :       fnOperationReturn( iCancelAllTemporalSubobjects, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	128					; 00000080H
	call	_fnOperationReturn
	add	esp, 8

; 2544 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@CancelAllT
$LN5@CancelAllT:

; 2545 :    }
; 2546 : 
; 2547 :    lpRoot       = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRoot$[ebp], eax

; 2548 :    lpViewEntity = zGETPTR( lpRoot->hViewEntity );

	mov	ecx, DWORD PTR _lpRoot$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2549 :    vWork = 0;

	mov	DWORD PTR _vWork$[ebp], 0
$LN2@CancelAllT:

; 2550 :    while ( lpRoot )

	cmp	DWORD PTR _lpRoot$[ebp], 0
	je	$LN3@CancelAllT

; 2551 :    {
; 2552 :       nRC = fnRemoveAllChildTemporalVsns( lpView, lpRoot, 0 );

	push	0
	mov	eax, DWORD PTR _lpRoot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnRemoveAllChildTemporalVsns
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2553 :       if ( nRC < zCURSOR_UNDEFINED )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -2					; fffffffeH
	jge	SHORT $LN6@CancelAllT

; 2554 :       {
; 2555 :          if ( vWork )

	cmp	DWORD PTR _vWork$[ebp], 0
	je	SHORT $LN7@CancelAllT

; 2556 :             DropView( vWork );

	mov	eax, DWORD PTR _vWork$[ebp]
	push	eax
	call	_DropView@4
$LN7@CancelAllT:

; 2557 : 
; 2558 :          fnOperationReturn( iCancelAllTemporalSubobjects, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	128					; 00000080H
	call	_fnOperationReturn
	add	esp, 8

; 2559 :          return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@CancelAllT
$LN6@CancelAllT:

; 2560 :       }
; 2561 : 
; 2562 :       lpPrevVsn = zGETPTR( lpRoot->hPrevVsn );

	mov	edx, DWORD PTR _lpRoot$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 2563 :       if ( lpRoot->u.nInd.bTemporal ||

	mov	ecx, DWORD PTR _lpRoot$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN9@CancelAllT
	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	je	$LN8@CancelAllT
	mov	eax, DWORD PTR _lpPrevVsn$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 9
	and	ecx, 1
	je	SHORT $LN8@CancelAllT
$LN9@CancelAllT:

; 2564 :            (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 2565 :       {
; 2566 :          if ( vWork == 0 )

	cmp	DWORD PTR _vWork$[ebp], 0
	jne	SHORT $LN10@CancelAllT

; 2567 :             CreateViewFromViewForTask( &vWork, lpView, 0 );

	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _vWork$[ebp]
	push	eax
	call	_CreateViewFromViewForTask@12
$LN10@CancelAllT:

; 2568 : 
; 2569 :          lpViewEntityCsr = fnEstablishViewForInstance( vWork, 0, lpRoot );

	mov	ecx, DWORD PTR _lpRoot$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vWork$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 2570 :          nRC = CancelSubobject( vWork, lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _vWork$[ebp]
	push	ecx
	call	_CancelSubobject@8
	mov	WORD PTR _nRC$[ebp], ax

; 2571 :          if ( nRC < zCURSOR_UNDEFINED )

	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	edx, -2					; fffffffeH
	jge	SHORT $LN11@CancelAllT

; 2572 :          {
; 2573 :             if ( vWork )

	cmp	DWORD PTR _vWork$[ebp], 0
	je	SHORT $LN12@CancelAllT

; 2574 :                DropView( vWork );

	mov	eax, DWORD PTR _vWork$[ebp]
	push	eax
	call	_DropView@4
$LN12@CancelAllT:

; 2575 : 
; 2576 :             fnOperationReturn( iCancelAllTemporalSubobjects, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	128					; 00000080H
	call	_fnOperationReturn
	add	esp, 8

; 2577 :             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@CancelAllT
$LN11@CancelAllT:

; 2578 :          }
; 2579 : 
; 2580 :          lpRoot = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRoot$[ebp], eax
$LN8@CancelAllT:

; 2581 :       }
; 2582 : 
; 2583 :       if ( lpRoot )

	cmp	DWORD PTR _lpRoot$[ebp], 0
	je	SHORT $LN13@CancelAllT

; 2584 :          lpRoot = zGETPTR( lpRoot->hNextTwin );

	mov	ecx, DWORD PTR _lpRoot$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRoot$[ebp], eax
$LN13@CancelAllT:

; 2585 :    }

	jmp	$LN2@CancelAllT
$LN3@CancelAllT:

; 2586 : 
; 2587 :    if ( vWork )

	cmp	DWORD PTR _vWork$[ebp], 0
	je	SHORT $LN14@CancelAllT

; 2588 :       DropView( vWork );

	mov	eax, DWORD PTR _vWork$[ebp]
	push	eax
	call	_DropView@4
$LN14@CancelAllT:

; 2589 : 
; 2590 :    fnOperationReturn( iCancelAllTemporalSubobjects, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	128					; 00000080H
	call	_fnOperationReturn
	add	esp, 8

; 2591 :    return( 0 );

	xor	eax, eax
$LN1@CancelAllT:

; 2592 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_CancelAllTemporalSubobjects@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpWrkInstance2$1 = -116				; size = 4
_lpNewViewEntity$2 = -112				; size = 4
_lpViewCsr$ = -108					; size = 4
_hStartNewInstance$ = -104				; size = 4
_lpLastOldInstance$ = -100				; size = 4
_lpViewEntityCsr$ = -96					; size = 4
_lpPrevVsn$ = -92					; size = 4
_lpNextLinked$3 = -88					; size = 4
_lpWrkViewCsr$ = -84					; size = 4
_lpViewEntity$ = -80					; size = 4
_lpWrkViewEntityCsr$ = -76				; size = 4
_hStartOldInstance$ = -72				; size = 4
_lpLastNewInstance$ = -68				; size = 4
_lpLinked$4 = -64					; size = 4
_lpDupInstance$ = -60					; size = 4
_lpCurrentTask$ = -56					; size = 4
_lpOldInstance$ = -52					; size = 4
_lpLinkedChild$5 = -48					; size = 4
_lpViewOI$ = -44					; size = 4
_lpStartNewInstance$ = -40				; size = 4
_lpStartOldInstance$ = -36				; size = 4
_lpWrkInstance$ = -32					; size = 4
_lpNewInstance$ = -28					; size = 4
_nLevel$6 = -24						; size = 2
_n$7 = -20						; size = 2
_nRC$8 = -16						; size = 2
_nStartLevel$ = -12					; size = 2
_nHiddenCount$ = -8					; size = 2
_bStillPrevVsn$ = -1					; size = 1
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_CancelSubobject@8 PROC

; 2139 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 2140 :    LPTASK           lpCurrentTask;
; 2141 :    LPVIEWOI         lpViewOI;
; 2142 :    LPVIEWCSR        lpViewCsr;
; 2143 :    LPVIEWCSR        lpWrkViewCsr;
; 2144 :    LPVIEWENTITY     lpViewEntity;
; 2145 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 2146 :    LPVIEWENTITYCSR  lpWrkViewEntityCsr;
; 2147 :    LPENTITYINSTANCE lpOldInstance;
; 2148 :    LPENTITYINSTANCE lpStartOldInstance;
; 2149 :    LPENTITYINSTANCE lpStartNewInstance;
; 2150 :    LPENTITYINSTANCE lpLastNewInstance;
; 2151 :    LPENTITYINSTANCE lpLastOldInstance;
; 2152 :    LPENTITYINSTANCE lpNewInstance;
; 2153 :    LPENTITYINSTANCE lpWrkInstance;
; 2154 :    LPENTITYINSTANCE lpDupInstance;
; 2155 :    LPENTITYINSTANCE lpPrevVsn;
; 2156 :    zPVOID           hStartOldInstance;
; 2157 :    zPVOID           hStartNewInstance;
; 2158 :    zSHORT           nStartLevel;
; 2159 :    zSHORT           nHiddenCount;
; 2160 :    zBOOL            bStillPrevVsn;
; 2161 : 
; 2162 :    // Validate parameters
; 2163 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	104					; 00000068H
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN29@CancelSubo

; 2164 :                                       &lpViewEntity,
; 2165 :                                       &lpViewEntityCsr,
; 2166 :                                       iCancelSubobject,
; 2167 :                                       lpView,
; 2168 :                                       cpcEntityName, 0 ) )
; 2169 :    {
; 2170 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CancelSubo
$LN29@CancelSubo:

; 2171 :    }
; 2172 : 
; 2173 :    // Get view csr and view OI.
; 2174 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2175 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2176 : 
; 2177 :    // If the view is ReadOnly, return with an error if any versioned
; 2178 :    // instances exist, else return success.
; 2179 :    if ( lpView->bReadOnly )

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN30@CancelSubo

; 2180 :    {
; 2181 :       zSHORT  nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$8[ebp], ax

; 2182 :       if ( lpViewOI->nVersionedInstances )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	SHORT $LN31@CancelSubo

; 2183 :       {
; 2184 :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$8[ebp], ax

; 2185 :          // "KZOEE119 - Invalid View, View is Read Only"
; 2186 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 119, 0, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	push	0
	push	119					; 00000077H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN31@CancelSubo:

; 2187 :       }
; 2188 : 
; 2189 :       fnOperationReturn( iCancelSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	104					; 00000068H
	call	_fnOperationReturn
	add	esp, 8

; 2190 :       return( nRC );

	mov	ax, WORD PTR _nRC$8[ebp]
	jmp	$LN1@CancelSubo
$LN30@CancelSubo:

; 2191 :    }
; 2192 : 
; 2193 : #ifdef __ACTIVATE_CONSTRAINTS__
; 2194 :    // If there is an Entity Constraint for cancel, see if it has
; 2195 :    // any objections about continuing.
; 2196 :    if ( lpViewEntity->bCancelConstraint )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN32@CancelSubo

; 2197 :    {
; 2198 :       zSHORT   n;
; 2199 : 
; 2200 :       n = fnInvokeECEOperation( lpView, lpViewEntity, lpCurrentTask,

	push	0
	push	2
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInvokeECEOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _n$7[ebp], ax

; 2201 :                                 zECE_CANCEL, 0 );
; 2202 :       // If constraint handler doesn't like something, get out.
; 2203 :       if ( n )

	movsx	ecx, WORD PTR _n$7[ebp]
	test	ecx, ecx
	je	SHORT $LN32@CancelSubo

; 2204 :       {
; 2205 :          fnOperationReturn( iCancelSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	104					; 00000068H
	call	_fnOperationReturn
	add	esp, 8

; 2206 :          return( n );

	mov	ax, WORD PTR _n$7[ebp]
	jmp	$LN1@CancelSubo
$LN32@CancelSubo:

; 2207 :       }
; 2208 :    }
; 2209 : #endif
; 2210 : 
; 2211 :    // Get instance on which to start.
; 2212 :    lpStartNewInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartNewInstance$[ebp], eax
$LN2@CancelSubo:

; 2213 :    while ( lpStartNewInstance->hNextVsn )

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN3@CancelSubo

; 2214 :       lpStartNewInstance = zGETPTR( lpStartNewInstance->hNextVsn );

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartNewInstance$[ebp], eax
	jmp	SHORT $LN2@CancelSubo
$LN3@CancelSubo:

; 2215 : 
; 2216 :    lpStartOldInstance = zGETPTR( lpStartNewInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartOldInstance$[ebp], eax

; 2217 : 
; 2218 :    // If the entity instance is not versioned, return a logic error.
; 2219 :    if ( lpStartNewInstance->u.nInd.bTemporal == FALSE &&

	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN34@CancelSubo
	cmp	DWORD PTR _lpStartOldInstance$[ebp], 0
	je	SHORT $LN35@CancelSubo
	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 9
	and	ecx, 1
	jne	SHORT $LN34@CancelSubo
$LN35@CancelSubo:

; 2220 :         (lpStartOldInstance == 0 ||
; 2221 :          lpStartOldInstance->u.nInd.bPrevVsnRoot == FALSE) )
; 2222 :    {
; 2223 :       fnOperationReturn( iCancelSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	104					; 00000068H
	call	_fnOperationReturn
	add	esp, 8

; 2224 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@CancelSubo
$LN34@CancelSubo:

; 2225 :    }
; 2226 : 
; 2227 :    // Get starting level for Cancel
; 2228 :    nStartLevel = lpViewEntityCsr->nLevel;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	cx, WORD PTR [eax+22]
	mov	WORD PTR _nStartLevel$[ebp], cx

; 2229 : 
; 2230 :    // Check to make sure none of this instances descendents are
; 2231 :    // already versioned. This is true when lpPrevVsn points to a
; 2232 :    // versioned root instance.
; 2233 :    lpNewInstance   = zGETPTR( lpStartNewInstance->hNextHier );

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax
$LN4@CancelSubo:

; 2234 :    while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel )

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	$LN5@CancelSubo
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jle	$LN5@CancelSubo

; 2235 :    {
; 2236 :       lpPrevVsn = zGETPTR( lpNewInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 2237 : 
; 2238 :       if ( lpNewInstance->u.nInd.bTemporal ||

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN37@CancelSubo
	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	je	SHORT $LN36@CancelSubo
	mov	edx, DWORD PTR _lpPrevVsn$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN36@CancelSubo
$LN37@CancelSubo:

; 2239 :            (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 2240 :       {
; 2241 :          LPVIEWENTITY lpNewViewEntity = zGETPTR( lpNewInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntity$2[ebp], eax

; 2242 : 
; 2243 :          // "KZOEE137 - Entity Instance descendent versioned"
; 2244 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 137, 0,

	mov	eax, DWORD PTR _lpNewViewEntity$2[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	137					; 00000089H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2245 :                            lpViewEntity->szName,
; 2246 :                            lpNewViewEntity->szName );
; 2247 :          fnOperationReturn( iCancelSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	104					; 00000068H
	call	_fnOperationReturn
	add	esp, 8

; 2248 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CancelSubo
$LN36@CancelSubo:

; 2249 :       }
; 2250 : 
; 2251 :       lpNewInstance   = zGETPTR( lpNewInstance->hNextHier );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 2252 :    }

	jmp	$LN4@CancelSubo
$LN5@CancelSubo:

; 2253 : 
; 2254 :    // If we arrive here, then we must have a previous version of this
; 2255 :    // entity. Re-implement the previous version amongst the linked
; 2256 :    // instances of the previous version and clean up the current
; 2257 :    // version instances.
; 2258 : 
; 2259 :    // Get instance on which to start
; 2260 :    lpNewInstance = lpStartNewInstance;

	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	DWORD PTR _lpNewInstance$[ebp], ecx

; 2261 : 
; 2262 :    // If the starting instance is a temporal entity, mark the instance
; 2263 :    // as hidden as well as any children created by either CreateEntity
; 2264 :    // OR IncludeSubobjectFromSubobject.
; 2265 :    if ( lpNewInstance->u.nInd.bTemporal )

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	$LN38@CancelSubo

; 2266 :    {
; 2267 :       LPENTITYINSTANCE  lpLinked;
; 2268 : 
; 2269 :       nHiddenCount = 0;

	xor	ecx, ecx
	mov	WORD PTR _nHiddenCount$[ebp], cx

; 2270 : 
; 2271 :       lpLinked = zGETPTR( lpNewInstance->hNextLinked );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$4[ebp], eax

; 2272 : 
; 2273 :       // if any linked instances for this temporal entity, mark them
; 2274 :       // and their children as hidden.
; 2275 :       if ( lpLinked )

	cmp	DWORD PTR _lpLinked$4[ebp], 0
	je	$LN13@CancelSubo
$LN6@CancelSubo:

; 2276 :       {
; 2277 :          while ( lpLinked != lpNewInstance )

	mov	ecx, DWORD PTR _lpLinked$4[ebp]
	cmp	ecx, DWORD PTR _lpNewInstance$[ebp]
	je	$LN13@CancelSubo

; 2278 :          {
; 2279 :             zSHORT            nLevel;
; 2280 :             LPENTITYINSTANCE  lpLinkedChild;
; 2281 : 
; 2282 :             nLevel = lpLinked->nLevel;

	mov	edx, DWORD PTR _lpLinked$4[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nLevel$6[ebp], ax

; 2283 :             lpLinkedChild = lpLinked;

	mov	ecx, DWORD PTR _lpLinked$4[ebp]
	mov	DWORD PTR _lpLinkedChild$5[ebp], ecx
$LN10@CancelSubo:

; 2284 :             do
; 2285 :             {
; 2286 :                if ( lpLinkedChild->u.nInd.bHidden == FALSE )

	mov	edx, DWORD PTR _lpLinkedChild$5[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN40@CancelSubo

; 2287 :                {
; 2288 :                   lpLinkedChild->u.nIndicators = 0;

	mov	ecx, DWORD PTR _lpLinkedChild$5[ebp]
	mov	DWORD PTR [ecx+6], 0

; 2289 :                   lpLinkedChild->u.nInd.bCreated = TRUE;

	mov	edx, DWORD PTR _lpLinkedChild$5[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2
	mov	ecx, DWORD PTR _lpLinkedChild$5[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2290 :                   lpLinkedChild->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpLinkedChild$5[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpLinkedChild$5[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2291 :                   nHiddenCount++;

	mov	dx, WORD PTR _nHiddenCount$[ebp]
	add	dx, 1
	mov	WORD PTR _nHiddenCount$[ebp], dx
$LN40@CancelSubo:

; 2292 :                }
; 2293 : 
; 2294 :                lpLinkedChild = zGETPTR( lpLinkedChild->hNextHier );

	mov	eax, DWORD PTR _lpLinkedChild$5[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinkedChild$5[ebp], eax

; 2295 : 
; 2296 :             }  while ( lpLinkedChild && lpLinkedChild->nLevel > nLevel );

	cmp	DWORD PTR _lpLinkedChild$5[ebp], 0
	je	SHORT $LN9@CancelSubo
	mov	edx, DWORD PTR _lpLinkedChild$5[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$6[ebp]
	cmp	eax, ecx
	jg	SHORT $LN10@CancelSubo
$LN9@CancelSubo:

; 2297 : 
; 2298 :             lpLinked = zGETPTR( lpLinked->hNextLinked );

	mov	edx, DWORD PTR _lpLinked$4[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$4[ebp], eax

; 2299 :          }

	jmp	$LN6@CancelSubo
$LN13@CancelSubo:

; 2300 :       }
; 2301 : 
; 2302 :       do
; 2303 :       {
; 2304 :          // Mark all subordinate entities for removal from memory.
; 2305 :          lpNewInstance->u.nIndicators = 0;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], 0

; 2306 :          lpNewInstance->u.nInd.bCreated = TRUE;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 2
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2307 :          lpNewInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2308 :          nHiddenCount++;

	mov	dx, WORD PTR _nHiddenCount$[ebp]
	add	dx, 1
	mov	WORD PTR _nHiddenCount$[ebp], dx

; 2309 :          lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 2310 : 
; 2311 :       }  while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel );

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	SHORT $LN12@CancelSubo
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nStartLevel$[ebp]
	cmp	eax, ecx
	jg	SHORT $LN13@CancelSubo
$LN12@CancelSubo:

; 2312 : 
; 2313 :       lpViewOI->nHiddenCount += nHiddenCount;

	movsx	edx, WORD PTR _nHiddenCount$[ebp]
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	add	ecx, edx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [edx+24], cx

; 2314 : 
; 2315 :       // Decrement versioned instance count in viewOI.
; 2316 :       lpViewOI->nVersionedInstances--;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	cx, WORD PTR [eax+22]
	sub	cx, 1
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [edx+22], cx

; 2317 : 
; 2318 :       // We're all done here, return success.
; 2319 :       fnOperationReturn( iCancelSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	104					; 00000068H
	call	_fnOperationReturn
	add	esp, 8

; 2320 :       return( zCURSOR_UNDEFINED );  // Assume everythings AOK

	mov	eax, -2					; fffffffeH
	jmp	$LN1@CancelSubo
$LN38@CancelSubo:

; 2321 :    }
; 2322 : 
; 2323 :    // For all old versions of the instance in question, unset the
; 2324 :    // previous version indicator if the instance is no longer a previous
; 2325 :    // version.
; 2326 :    lpStartOldInstance->u.nInd.bPrevVsnRoot = 0;

	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -513				; fffffdffH
	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN16@CancelSubo:

; 2327 :    do
; 2328 :    {
; 2329 :       LPENTITYINSTANCE lpNextLinked = zGETPTR( lpNewInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextLinked$3[ebp], eax

; 2330 : 
; 2331 :       // First, if the new instance in linked, remove the new instance
; 2332 :       // from the linked chain and zero out its record pointer
; 2333 :       lpDupInstance = 0;

	mov	DWORD PTR _lpDupInstance$[ebp], 0

; 2334 :       if ( lpNextLinked )

	cmp	DWORD PTR _lpNextLinked$3[ebp], 0
	je	SHORT $LN43@CancelSubo

; 2335 :       {
; 2336 :          lpDupInstance = lpNextLinked;

	mov	eax, DWORD PTR _lpNextLinked$3[ebp]
	mov	DWORD PTR _lpDupInstance$[ebp], eax
$LN17@CancelSubo:

; 2337 :          while ( zGETPTR( lpDupInstance->hNextLinked ) != lpNewInstance )

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpNewInstance$[ebp]
	je	SHORT $LN18@CancelSubo

; 2338 :             lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
	jmp	SHORT $LN17@CancelSubo
$LN18@CancelSubo:

; 2339 : 
; 2340 :          if ( lpDupInstance == lpNextLinked )

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	cmp	edx, DWORD PTR _lpNextLinked$3[ebp]
	jne	SHORT $LN44@CancelSubo

; 2341 :             lpDupInstance->hNextLinked = 0;

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [eax+42], 0
	jmp	SHORT $LN45@CancelSubo
$LN44@CancelSubo:

; 2342 :          else
; 2343 :             lpDupInstance->hNextLinked = lpNewInstance->hNextLinked;

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	mov	DWORD PTR [ecx+42], eax
$LN45@CancelSubo:

; 2344 : 
; 2345 :          lpNewInstance->hPersistRecord = 0;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+60], 0

; 2346 :          lpNewInstance->hNextLinked = 0;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [edx+42], 0
$LN43@CancelSubo:

; 2347 :       }
; 2348 : 
; 2349 :       // Get the previous version pointer from the new instance
; 2350 :       lpOldInstance = zGETPTR( lpNewInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldInstance$[ebp], eax

; 2351 : 
; 2352 :       // If the new instance had a previous version, reset the
; 2353 :       // previous version indicators if necessary.
; 2354 :       if ( lpOldInstance )

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	$LN46@CancelSubo

; 2355 :       {
; 2356 :          bStillPrevVsn = 0;

	mov	BYTE PTR _bStillPrevVsn$[ebp], 0

; 2357 :          if ( lpOldInstance->hNextLinked )

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	SHORT $LN47@CancelSubo

; 2358 :          {
; 2359 :             lpWrkInstance = zGETPTR( lpOldInstance->hNextLinked );

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN19@CancelSubo:

; 2360 :             while ( lpWrkInstance != lpOldInstance )

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	edx, DWORD PTR _lpOldInstance$[ebp]
	je	SHORT $LN47@CancelSubo

; 2361 :             {
; 2362 :                if ( lpWrkInstance->hNextVsn )

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	cmp	DWORD PTR [eax+34], 0
	je	SHORT $LN48@CancelSubo

; 2363 :                {
; 2364 :                   bStillPrevVsn = TRUE;

	mov	BYTE PTR _bStillPrevVsn$[ebp], 1

; 2365 :                   break;

	jmp	SHORT $LN47@CancelSubo
$LN48@CancelSubo:

; 2366 :                }
; 2367 : 
; 2368 :                lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 2369 :             }

	jmp	SHORT $LN19@CancelSubo
$LN47@CancelSubo:

; 2370 :          }
; 2371 : 
; 2372 :          if ( lpOldInstance->hPersistRecord == lpNewInstance->hPersistRecord )

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [eax+60]
	cmp	edx, DWORD PTR [ecx+60]
	jne	SHORT $LN49@CancelSubo

; 2373 :             lpNewInstance->hPersistRecord = 0;

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [eax+60], 0
$LN49@CancelSubo:

; 2374 : 
; 2375 :          lpOldInstance->hNextVsn = lpNewInstance->hNextVsn;

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+34]
	mov	DWORD PTR [ecx+34], eax

; 2376 : 
; 2377 :          // Reset the prev version flags in all linked instances to
; 2378 :          // the original instance.
; 2379 :          if ( bStillPrevVsn == FALSE )

	movzx	ecx, BYTE PTR _bStillPrevVsn$[ebp]
	test	ecx, ecx
	jne	SHORT $LN46@CancelSubo

; 2380 :          {
; 2381 :             lpOldInstance->u.nInd.bPrevVersion = FALSE;

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -257				; fffffeffH
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2382 :             lpWrkInstance = zGETPTR( lpOldInstance->hNextLinked );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN21@CancelSubo:

; 2383 :             while ( lpWrkInstance && lpWrkInstance != lpOldInstance )

	cmp	DWORD PTR _lpWrkInstance$[ebp], 0
	je	SHORT $LN46@CancelSubo
	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	ecx, DWORD PTR _lpOldInstance$[ebp]
	je	SHORT $LN46@CancelSubo

; 2384 :             {
; 2385 :                lpWrkInstance->u.nInd.bPrevVersion = FALSE;

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -257				; fffffeffH
	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2386 :                lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 2387 :             }

	jmp	SHORT $LN21@CancelSubo
$LN46@CancelSubo:

; 2388 :          }
; 2389 :       }
; 2390 : 
; 2391 :       lpLastNewInstance = lpNewInstance;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpLastNewInstance$[ebp], ecx

; 2392 :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 2393 : 
; 2394 :    }  while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel );

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	SHORT $LN15@CancelSubo
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jg	$LN16@CancelSubo
$LN15@CancelSubo:

; 2395 : 
; 2396 :    // Reset the hierarchical, parent and twin pointers for the root
; 2397 :    // of the old version and the last instance in the new version
; 2398 :    hStartOldInstance = zGETHNDL( lpStartOldInstance );

	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hStartOldInstance$[ebp], eax

; 2399 :    hStartNewInstance = zGETHNDL( lpStartNewInstance );

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hStartNewInstance$[ebp], eax

; 2400 :    lpStartOldInstance->hPrevHier = lpStartNewInstance->hPrevHier;

	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR [eax+18], edx

; 2401 :    if ( lpStartOldInstance->hPrevHier )

	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN52@CancelSubo

; 2402 :    {
; 2403 :       lpWrkInstance = zGETPTR( lpStartOldInstance->hPrevHier );

	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 2404 :       lpWrkInstance->hNextHier = hStartOldInstance;

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR _hStartOldInstance$[ebp]
	mov	DWORD PTR [eax+14], ecx
$LN52@CancelSubo:

; 2405 :    }
; 2406 : 
; 2407 :    lpStartOldInstance->hParent = lpStartNewInstance->hParent;

	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	mov	DWORD PTR [edx+30], ecx

; 2408 : // if ( lpStartOldInstance->hParent == UNSET_CSR )
; 2409 : //    SysMessageBox( 0, "CancelSubobject", "UNSET_CSR", -1 );
; 2410 : 
; 2411 :    lpStartOldInstance->hPrevTwin = lpStartNewInstance->hPrevTwin;

	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 2412 :    if ( lpStartOldInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN53@CancelSubo

; 2413 :    {
; 2414 :       lpWrkInstance = zGETPTR( lpStartOldInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 2415 :       lpWrkInstance->hNextTwin = hStartOldInstance;

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR _hStartOldInstance$[ebp]
	mov	DWORD PTR [edx+22], eax
$LN53@CancelSubo:

; 2416 :    }
; 2417 : 
; 2418 :    lpStartOldInstance->hNextTwin = lpStartNewInstance->hNextTwin;

	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	mov	DWORD PTR [ecx+22], eax

; 2419 :    if ( lpStartOldInstance->hNextTwin )

	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN54@CancelSubo

; 2420 :    {
; 2421 :       lpWrkInstance = zGETPTR( lpStartOldInstance->hNextTwin );

	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 2422 :       lpWrkInstance->hPrevTwin = hStartOldInstance;

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	edx, DWORD PTR _hStartOldInstance$[ebp]
	mov	DWORD PTR [ecx+26], edx
$LN54@CancelSubo:

; 2423 :    }
; 2424 : 
; 2425 :    lpLastOldInstance = fnFindLastEntityUnderParent( lpStartOldInstance, FALSE );

	push	0
	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	push	eax
	call	_fnFindLastEntityUnderParent@8
	mov	DWORD PTR _lpLastOldInstance$[ebp], eax

; 2426 :    lpPrevVsn = zGETPTR( lpLastNewInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpLastNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 2427 :    lpLastOldInstance->hNextHier = lpLastNewInstance->hNextHier;

	mov	eax, DWORD PTR _lpLastOldInstance$[ebp]
	mov	ecx, DWORD PTR _lpLastNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR [eax+14], edx

; 2428 :    if ( lpLastNewInstance->hNextHier )

	mov	eax, DWORD PTR _lpLastNewInstance$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $LN55@CancelSubo

; 2429 :    {
; 2430 :       LPENTITYINSTANCE lpWrkInstance2;
; 2431 : 
; 2432 :       lpWrkInstance2 = zGETPTR( lpLastNewInstance->hNextHier );

	mov	ecx, DWORD PTR _lpLastNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance2$1[ebp], eax

; 2433 :       lpWrkInstance2->hPrevHier = zGETHNDL( lpLastOldInstance );

	mov	eax, DWORD PTR _lpLastOldInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpWrkInstance2$1[ebp]
	mov	DWORD PTR [ecx+18], eax

; 2434 :       lpLastNewInstance->hNextHier = 0;

	mov	edx, DWORD PTR _lpLastNewInstance$[ebp]
	mov	DWORD PTR [edx+14], 0
$LN55@CancelSubo:

; 2435 :    }
; 2436 : 
; 2437 :    // If the root of the instance was versioned, set the
; 2438 :    // root entity instance pointer in the ViewOI
; 2439 :    if ( lpViewOI->hRootEntityInstance == hStartNewInstance )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	cmp	ecx, DWORD PTR _hStartNewInstance$[ebp]
	jne	SHORT $LN56@CancelSubo

; 2440 :       lpViewOI->hRootEntityInstance = hStartOldInstance;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR _hStartOldInstance$[ebp]
	mov	DWORD PTR [edx+26], eax
$LN56@CancelSubo:

; 2441 : 
; 2442 :    // Now go through all views for the old object and update any cursors
; 2443 :    // positioned on the current version to point to the old version
; 2444 :    lpWrkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
$LN23@CancelSubo:

; 2445 :    while ( lpWrkViewCsr )

	cmp	DWORD PTR _lpWrkViewCsr$[ebp], 0
	je	SHORT $LN24@CancelSubo

; 2446 :    {
; 2447 :       lpWrkViewEntityCsr = zGETPTR( lpWrkViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntityCsr$[ebp], eax

; 2448 :       lpWrkViewEntityCsr += ( lpViewEntity->nHierNbr - 1 );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	DWORD PTR _lpWrkViewEntityCsr$[ebp], ecx

; 2449 :       if ( lpWrkViewEntityCsr->hEntityInstance == hStartNewInstance )

	mov	edx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	cmp	eax, DWORD PTR _hStartNewInstance$[ebp]
	jne	SHORT $LN57@CancelSubo

; 2450 :       {
; 2451 :          lpWrkViewEntityCsr->hEntityInstance = hStartOldInstance;

	mov	ecx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	edx, DWORD PTR _hStartOldInstance$[ebp]
	mov	DWORD PTR [ecx+26], edx

; 2452 :       // if ( lpWrkViewEntityCsr->hEntityInstance == UNSET_CSR )
; 2453 :       //    SysMessageBox( 0, "CancelSubobject", "UNSET_CSR", -1 );
; 2454 : 
; 2455 :          fnResetCursorForViewChildren( lpWrkViewEntityCsr );

	mov	eax, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN57@CancelSubo:

; 2456 :       }
; 2457 : 
; 2458 :       lpWrkViewCsr = zGETPTR( lpWrkViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax

; 2459 :    }

	jmp	SHORT $LN23@CancelSubo
$LN24@CancelSubo:

; 2460 : 
; 2461 :    // Finally, clean up the new version instance chain
; 2462 :    lpNewInstance = lpStartNewInstance;

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	DWORD PTR _lpNewInstance$[ebp], eax
$LN25@CancelSubo:

; 2463 :    while ( lpNewInstance )

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	$LN26@CancelSubo

; 2464 :    {
; 2465 :       if ( lpNewInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN58@CancelSubo

; 2466 :       {
; 2467 :          lpWrkInstance = zGETPTR( lpNewInstance->hNextLinked );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN27@CancelSubo:

; 2468 :          while ( lpWrkInstance->hNextLinked != zGETHNDL( lpNewInstance ) )

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	DWORD PTR [edx+42], eax
	je	SHORT $LN28@CancelSubo

; 2469 :             lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
	jmp	SHORT $LN27@CancelSubo
$LN28@CancelSubo:

; 2470 : 
; 2471 :          if ( zGETPTR( lpNewInstance->hNextLinked ) == lpWrkInstance )

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpWrkInstance$[ebp]
	jne	SHORT $LN60@CancelSubo

; 2472 :             lpWrkInstance->hNextLinked = 0;

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	DWORD PTR [ecx+42], 0
	jmp	SHORT $LN61@CancelSubo
$LN60@CancelSubo:

; 2473 :          else
; 2474 :             lpWrkInstance->hNextLinked = lpNewInstance->hNextLinked;

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$LN61@CancelSubo:

; 2475 :       }

	jmp	SHORT $LN59@CancelSubo
$LN58@CancelSubo:

; 2476 :       else
; 2477 :       {
; 2478 :          fnDeleteAttributeRecord( zGETPTR( lpNewInstance->hViewEntity ),

	push	1
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH
$LN59@CancelSubo:

; 2479 :                                   lpNewInstance, TRUE );
; 2480 :       }
; 2481 : 
; 2482 :       fnDeleteAttributeRecord( zGETPTR( lpNewInstance->hViewEntity ),

	push	0
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 2483 :                                lpNewInstance, FALSE );
; 2484 :       lpWrkInstance = lpNewInstance;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpWrkInstance$[ebp], edx

; 2485 :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 2486 :       fnFreeDataspace( lpWrkInstance );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 2487 :    }

	jmp	$LN25@CancelSubo
$LN26@CancelSubo:

; 2488 : 
; 2489 :    // Decrement versioned instance count in viewOI
; 2490 :    lpViewOI->nVersionedInstances--;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	cx, WORD PTR [eax+22]
	sub	cx, 1
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [edx+22], cx

; 2491 : 
; 2492 : #ifdef __RECLAIM__
; 2493 :    if ( lpViewOI->nHiddenCount > __RECLAIM_LIMIT__ )

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	cmp	ecx, 20					; 00000014H
	jle	SHORT $LN62@CancelSubo

; 2494 :       fnReclaimHiddenInstances( lpViewOI );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnReclaimHiddenInstances@4
$LN62@CancelSubo:

; 2495 : #endif
; 2496 : 
; 2497 :    fnOperationReturn( iCancelSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	104					; 00000068H
	call	_fnOperationReturn
	add	esp, 8

; 2498 :    return( zCURSOR_SET );  // Assume everythings AOK if we get here

	xor	eax, eax
$LN1@CancelSubo:

; 2499 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CancelSubobject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewEntityCsr$ = -36					; size = 4
_lpRootViewEntity$ = -32				; size = 4
_lpViewCsr$ = -28					; size = 4
_lpPrevVsn$1 = -24					; size = 4
_lpViewOI$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_vWork$ = -12						; size = 4
_lpRoot$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_AcceptAllTemporalSubobjects@4 PROC

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 713  :    LPTASK           lpCurrentTask;
; 714  :    LPVIEWOI         lpViewOI;
; 715  :    LPVIEWCSR        lpViewCsr;
; 716  :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 717  :    LPENTITYINSTANCE lpRoot;
; 718  :    LPVIEWENTITY     lpRootViewEntity;
; 719  :    zVIEW            vWork;
; 720  :    zSHORT           nRC;
; 721  : 
; 722  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 723  :    if ( (lpCurrentTask = fnOperationCall( iAcceptAllTemporalSubobjects,
; 724  :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	127					; 0000007fH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@AcceptAllT

; 725  :    {
; 726  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@AcceptAllT
$LN4@AcceptAllT:

; 727  :    }
; 728  : 
; 729  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 730  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 731  : 
; 732  :    if ( lpViewOI->nVersionedInstances )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	$LN5@AcceptAllT

; 733  :    {
; 734  :       lpRoot = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRoot$[ebp], eax

; 735  :       lpRootViewEntity = zGETPTR( lpRoot->hViewEntity );

	mov	eax, DWORD PTR _lpRoot$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntity$[ebp], eax

; 736  :       vWork = 0;

	mov	DWORD PTR _vWork$[ebp], 0
$LN2@AcceptAllT:

; 737  :       while ( lpRoot )

	cmp	DWORD PTR _lpRoot$[ebp], 0
	je	$LN3@AcceptAllT

; 738  :       {
; 739  :          LPENTITYINSTANCE lpPrevVsn;
; 740  : 
; 741  :          nRC = fnRemoveAllChildTemporalVsns( lpView, lpRoot, 1 );

	push	1
	mov	edx, DWORD PTR _lpRoot$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnRemoveAllChildTemporalVsns
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 742  :          if ( nRC < zCURSOR_UNDEFINED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -2					; fffffffeH
	jge	SHORT $LN6@AcceptAllT

; 743  :          {
; 744  :             if ( vWork )

	cmp	DWORD PTR _vWork$[ebp], 0
	je	SHORT $LN7@AcceptAllT

; 745  :                DropView( vWork );

	mov	edx, DWORD PTR _vWork$[ebp]
	push	edx
	call	_DropView@4
$LN7@AcceptAllT:

; 746  : 
; 747  :             fnOperationReturn( iAcceptAllTemporalSubobjects, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	127					; 0000007fH
	call	_fnOperationReturn
	add	esp, 8

; 748  :             return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@AcceptAllT
$LN6@AcceptAllT:

; 749  :          }
; 750  : 
; 751  :          lpPrevVsn = zGETPTR( lpRoot->hPrevVsn );

	mov	ecx, DWORD PTR _lpRoot$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$1[ebp], eax

; 752  :          if ( lpRoot->u.nInd.bTemporal ||

	mov	eax, DWORD PTR _lpRoot$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN9@AcceptAllT
	cmp	DWORD PTR _lpPrevVsn$1[ebp], 0
	je	$LN8@AcceptAllT
	mov	edx, DWORD PTR _lpPrevVsn$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN8@AcceptAllT
$LN9@AcceptAllT:

; 753  :               (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 754  :          {
; 755  :             if ( vWork == 0 )

	cmp	DWORD PTR _vWork$[ebp], 0
	jne	SHORT $LN10@AcceptAllT

; 756  :                CreateViewFromViewForTask( &vWork, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vWork$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12
$LN10@AcceptAllT:

; 757  : 
; 758  :             lpViewEntityCsr = fnEstablishViewForInstance( vWork, 0, lpRoot );

	mov	eax, DWORD PTR _lpRoot$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vWork$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 759  :             nRC = AcceptSubobject( vWork, lpRootViewEntity->szName );

	mov	edx, DWORD PTR _lpRootViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _vWork$[ebp]
	push	eax
	call	_AcceptSubobject@8
	mov	WORD PTR _nRC$[ebp], ax

; 760  :             if ( nRC < zCURSOR_UNDEFINED )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -2					; fffffffeH
	jge	SHORT $LN11@AcceptAllT

; 761  :             {
; 762  :                if ( vWork )

	cmp	DWORD PTR _vWork$[ebp], 0
	je	SHORT $LN12@AcceptAllT

; 763  :                   DropView( vWork );

	mov	edx, DWORD PTR _vWork$[ebp]
	push	edx
	call	_DropView@4
$LN12@AcceptAllT:

; 764  : 
; 765  :                fnOperationReturn( iAcceptAllTemporalSubobjects, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	127					; 0000007fH
	call	_fnOperationReturn
	add	esp, 8

; 766  :                return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@AcceptAllT
$LN11@AcceptAllT:

; 767  :             }
; 768  : 
; 769  :             lpRoot = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRoot$[ebp], eax
$LN8@AcceptAllT:

; 770  :          }
; 771  : 
; 772  :          if ( lpRoot )

	cmp	DWORD PTR _lpRoot$[ebp], 0
	je	SHORT $LN13@AcceptAllT

; 773  :             lpRoot = zGETPTR( lpRoot->hNextTwin );

	mov	eax, DWORD PTR _lpRoot$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRoot$[ebp], eax
$LN13@AcceptAllT:

; 774  :       }

	jmp	$LN2@AcceptAllT
$LN3@AcceptAllT:

; 775  : 
; 776  :       if ( vWork )

	cmp	DWORD PTR _vWork$[ebp], 0
	je	SHORT $LN5@AcceptAllT

; 777  :          DropView( vWork );

	mov	edx, DWORD PTR _vWork$[ebp]
	push	edx
	call	_DropView@4
$LN5@AcceptAllT:

; 778  :    }
; 779  : 
; 780  :    fnOperationReturn( iAcceptAllTemporalSubobjects, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	127					; 0000007fH
	call	_fnOperationReturn
	add	esp, 8

; 781  :    return( 0 );

	xor	eax, eax
$LN1@AcceptAllT:

; 782  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_AcceptAllTemporalSubobjects@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpLastNewInstance$ = -164				; size = 4
_lpNewViewEntity$1 = -160				; size = 4
_lpViewOD$ = -156					; size = 4
_lpWorkViewCsr$2 = -152					; size = 4
_lpLastIncluded$ = -148					; size = 4
_lpPrevVsn$3 = -144					; size = 4
_lpWork$4 = -140					; size = 4
_lpViewCsr$ = -136					; size = 4
_lpViewEntity$5 = -132					; size = 4
_lpOldRecord$ = -128					; size = 4
_lpNextVsn$6 = -124					; size = 4
_hOldInstance$7 = -120					; size = 4
_lpLastIncluded_NextHier$8 = -116			; size = 4
_lpPrevLinked$9 = -112					; size = 4
_nUpdated$10 = -108					; size = 2
_nUpdatedFile$11 = -104					; size = 2
_lpViewEntityCsr$12 = -100				; size = 4
_lpFirstIncluded$ = -96					; size = 4
_lpViewEntity$ = -92					; size = 4
_lpWrkViewCsr$ = -88					; size = 4
_lpParent$13 = -84					; size = 4
_lpViewEntityCsr$ = -80					; size = 4
_lpPrevVsn$ = -76					; size = 4
_lpLinked$14 = -72					; size = 4
_lpStartOldInstance$ = -68				; size = 4
_nUpdatedFile$15 = -64					; size = 2
_nUpdated$16 = -60					; size = 2
_n$17 = -56						; size = 2
_hNewInstance$18 = -52					; size = 4
_lpWrkViewEntityCsr$ = -48				; size = 4
_lpCurrentTask$ = -44					; size = 4
_vWorkView$ = -40					; size = 4
_nStartLevel$ = -36					; size = 2
_lpStartNewInstance$ = -32				; size = 4
_nRC$ = -28						; size = 2
_lpViewOI$ = -24					; size = 4
_lpWrkInstance$ = -20					; size = 4
_bStillPrevVsn$ = -13					; size = 1
_lpDupInstance$ = -12					; size = 4
_lpOldInstance$ = -8					; size = 4
_lpNewInstance$ = -4					; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_AcceptSubobject@8 PROC

; 1351 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H

; 1352 :    LPTASK           lpCurrentTask;
; 1353 :    LPVIEWOI         lpViewOI;
; 1354 :    LPVIEWOD         lpViewOD;
; 1355 :    LPVIEWCSR        lpViewCsr;
; 1356 :    LPVIEWCSR        lpWrkViewCsr;
; 1357 :    LPVIEWENTITY     lpViewEntity;
; 1358 :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 1359 :    LPVIEWENTITYCSR  lpWrkViewEntityCsr;
; 1360 :    LPENTITYINSTANCE lpPrevVsn;
; 1361 :    LPENTITYINSTANCE lpOldInstance;
; 1362 :    LPENTITYINSTANCE lpStartOldInstance;
; 1363 :    LPENTITYINSTANCE lpStartNewInstance;
; 1364 :    LPENTITYINSTANCE lpLastNewInstance;
; 1365 :    LPENTITYINSTANCE lpFirstIncluded;
; 1366 :    LPENTITYINSTANCE lpLastIncluded;
; 1367 :    LPENTITYINSTANCE lpNewInstance;
; 1368 :    LPENTITYINSTANCE lpWrkInstance;
; 1369 :    LPENTITYINSTANCE lpDupInstance;
; 1370 :    zPVOID           lpOldRecord;
; 1371 :    zVIEW            vWorkView;
; 1372 :    zBOOL            bStillPrevVsn;
; 1373 :    zSHORT           nStartLevel;
; 1374 :    zSHORT           nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1375 : 
; 1376 :    // Validate parameters.
; 1377 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	103					; 00000067H
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	cwde
	test	eax, eax
	je	SHORT $LN50@AcceptSubo

; 1378 :                                       &lpViewEntity,
; 1379 :                                       &lpViewEntityCsr,
; 1380 :                                       iAcceptSubobject,
; 1381 :                                       lpView,
; 1382 :                                       cpcEntityName, 0 ) )
; 1383 :    {
; 1384 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@AcceptSubo
$LN50@AcceptSubo:

; 1385 :    }
; 1386 : 
; 1387 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1388 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1389 :    lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1390 : 
; 1391 :    // If the view is ReadOnly, return with an error if any versioned
; 1392 :    // instances exist, else return success.
; 1393 :    if ( lpView->bReadOnly )

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 6
	and	edx, 1
	je	SHORT $LN51@AcceptSubo

; 1394 :    {
; 1395 :       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1396 :       if ( lpViewOI->nVersionedInstances )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	SHORT $LN52@AcceptSubo

; 1397 :       {
; 1398 :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 1399 :          // "KZOEE119 - Invalid View, View is Read Only"
; 1400 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 119, 0, cpcEntityName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	push	0
	push	119					; 00000077H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN52@AcceptSubo:

; 1401 :       }
; 1402 : 
; 1403 :       fnOperationReturn( iAcceptSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	103					; 00000067H
	call	_fnOperationReturn
	add	esp, 8

; 1404 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@AcceptSubo
$LN51@AcceptSubo:

; 1405 :    }
; 1406 : 
; 1407 : #ifdef __ACTIVATE_CONSTRAINTS__
; 1408 :    // If there is an Entity Constraint for accept, see if it has
; 1409 :    // any objections about continuing.
; 1410 :    if ( lpViewEntity->bAcceptConstraint )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN53@AcceptSubo

; 1411 :    {
; 1412 :       zSHORT n;
; 1413 : 
; 1414 :       n = fnInvokeECEOperation( lpView, lpViewEntity, lpCurrentTask,

	push	0
	push	1
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnInvokeECEOperation
	add	esp, 20					; 00000014H
	mov	WORD PTR _n$17[ebp], ax

; 1415 :                                 zECE_ACCEPT, 0 );
; 1416 :       // If constraint handler doesn't like something, get out.
; 1417 :       if ( n )

	movsx	ecx, WORD PTR _n$17[ebp]
	test	ecx, ecx
	je	SHORT $LN53@AcceptSubo

; 1418 :       {
; 1419 :          fnOperationReturn( iAcceptSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	103					; 00000067H
	call	_fnOperationReturn
	add	esp, 8

; 1420 :          return( n );

	mov	ax, WORD PTR _n$17[ebp]
	jmp	$LN1@AcceptSubo
$LN53@AcceptSubo:

; 1421 :       }
; 1422 :    }
; 1423 : 
; 1424 :    if ( fnOEAcceptConstraints( lpView, lpViewEntityCsr, 1 ) )

	push	1
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnOEAcceptConstraints
	add	esp, 12					; 0000000cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN55@AcceptSubo

; 1425 :    {
; 1426 :       fnOperationReturn( iAcceptSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	103					; 00000067H
	call	_fnOperationReturn
	add	esp, 8

; 1427 :       return( zCONSTRAINT_VIOLATION );

	mov	eax, -12				; fffffff4H
	jmp	$LN1@AcceptSubo
$LN55@AcceptSubo:

; 1428 :    }
; 1429 : #endif
; 1430 : 
; 1431 :    // Get instance on which to start.
; 1432 :    lpStartNewInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartNewInstance$[ebp], eax

; 1433 : 
; 1434 :    // Get starting level for Accept.
; 1435 :    nStartLevel = lpViewEntityCsr->nLevel;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	cx, WORD PTR [eax+22]
	mov	WORD PTR _nStartLevel$[ebp], cx
$LN2@AcceptSubo:

; 1436 : 
; 1437 : #if 0   // Gig, debugging, for all new instances, see if a record
; 1438 :         // match can be found which is not linked!!!!
; 1439 :    lpNewInstance = lpStartNewInstance;
; 1440 :    do
; 1441 :    {
; 1442 :       lpWrkInstance = zGETPTR( lpNewInstance->hNextHier );
; 1443 :       while ( lpWrkInstance && lpWrkInstance->nLevel > nStartLevel )
; 1444 :       {
; 1445 :          if ( lpWrkInstance->hPersistRecord == lpNewInstance->hPersistRecord )
; 1446 :          {
; 1447 :             LPENTITYINSTANCE lpPrevVsn;
; 1448 : 
; 1449 :             for ( lpPrevVsn = lpNewInstance;
; 1450 :                   lpPrevVsn;
; 1451 :                   lpPrevVsn = zGETPTR( lpPrevVsn->hPrevVsn ) )
; 1452 :             {
; 1453 :                lpDupInstance = zGETPTR( lpPrevVsn->hNextLinked );
; 1454 :                while ( lpDupInstance && lpDupInstance != lpPrevVsn )
; 1455 :                {
; 1456 :                   if ( lpDupInstance == lpWrkInstance )
; 1457 :                      break;
; 1458 : 
; 1459 :                   lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );
; 1460 :                }
; 1461 : 
; 1462 :                if ( lpDupInstance != lpWrkInstance )
; 1463 :                {
; 1464 :                   SysMessageBox( "ERROR BEFORE ACCEPT",
; 1465 :                                  "Record match found in non-linked instance", 1 );
; 1466 :                }
; 1467 :             }
; 1468 :          }
; 1469 : 
; 1470 :          lpWrkInstance = zGETPTR( lpWrkInstance->hNextHier );
; 1471 :       }
; 1472 : 
; 1473 :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );
; 1474 : 
; 1475 :    } while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel );
; 1476 : 
; 1477 : #endif
; 1478 : 
; 1479 :    while ( lpStartNewInstance->hNextVsn )

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN3@AcceptSubo

; 1480 :       lpStartNewInstance = zGETPTR( lpStartNewInstance->hNextVsn );

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartNewInstance$[ebp], eax
	jmp	SHORT $LN2@AcceptSubo
$LN3@AcceptSubo:

; 1481 : 
; 1482 :    // If the entity instance is not versioned, return a logic error.
; 1483 :    lpPrevVsn = zGETPTR( lpStartNewInstance->hPrevVsn );

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 1484 :    if ( lpStartNewInstance->u.nInd.bTemporal == FALSE &&

	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN56@AcceptSubo
	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	je	SHORT $LN57@AcceptSubo
	mov	eax, DWORD PTR _lpPrevVsn$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 9
	and	ecx, 1
	jne	SHORT $LN56@AcceptSubo
$LN57@AcceptSubo:

; 1485 :         (lpPrevVsn == 0 || lpPrevVsn->u.nInd.bPrevVsnRoot == FALSE) )
; 1486 :    {
; 1487 :       fnOperationReturn( iAcceptSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	103					; 00000067H
	call	_fnOperationReturn
	add	esp, 8

; 1488 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@AcceptSubo
$LN56@AcceptSubo:

; 1489 :    }
; 1490 : 
; 1491 :    // Check to make sure none of this instance's descendents are
; 1492 :    // already versioned. This is true when lpPrevVsn points to a
; 1493 :    // versioned root instance.
; 1494 :    lpNewInstance = zGETPTR( lpStartNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 1495 :    if ( lpViewOI->nVersionedInstances > 1 )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx+22]
	cmp	eax, 1
	jle	$LN58@AcceptSubo
$LN4@AcceptSubo:

; 1496 :       while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel )

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	$LN58@AcceptSubo
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jle	$LN58@AcceptSubo

; 1497 :       {
; 1498 :          lpPrevVsn = zGETPTR( lpNewInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$[ebp], eax

; 1499 : 
; 1500 :          if ( lpNewInstance->u.nInd.bTemporal ||

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN60@AcceptSubo
	cmp	DWORD PTR _lpPrevVsn$[ebp], 0
	je	SHORT $LN59@AcceptSubo
	mov	edx, DWORD PTR _lpPrevVsn$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN59@AcceptSubo
$LN60@AcceptSubo:

; 1501 :               (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 1502 :          {
; 1503 :             LPVIEWENTITY lpWork = zGETPTR( lpNewInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWork$4[ebp], eax

; 1504 : 
; 1505 :             // "KZOEE137 - Entity Instance descendent versioned"
; 1506 :             fnIssueCoreError( lpCurrentTask, lpView, 8, 137, 0,

	mov	eax, DWORD PTR _lpWork$4[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	137					; 00000089H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1507 :                               lpViewEntity->szName,
; 1508 :                               lpWork->szName );
; 1509 :             fnOperationReturn( iAcceptSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	103					; 00000067H
	call	_fnOperationReturn
	add	esp, 8

; 1510 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@AcceptSubo
$LN59@AcceptSubo:

; 1511 :          }
; 1512 : 
; 1513 :          lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 1514 :       }

	jmp	$LN4@AcceptSubo
$LN58@AcceptSubo:

; 1515 : 
; 1516 : 
; 1517 :    // If we arrive here, then we must have a previous version of this
; 1518 :    // entity. Implement the current version amongst the linked
; 1519 :    // instances of the previous version and clean up the previous
; 1520 :    // version instances.
; 1521 : 
; 1522 :    // Get instance on which to start
; 1523 :    lpStartOldInstance = zGETPTR( lpStartNewInstance->hPrevVsn );

	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartOldInstance$[ebp], eax

; 1524 :    lpNewInstance = lpStartNewInstance;

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 1525 : 
; 1526 :    // Initialize first instance found which was included OR created
; 1527 :    // in the versioned subobject.
; 1528 :    lpFirstIncluded = 0;

	mov	DWORD PTR _lpFirstIncluded$[ebp], 0

; 1529 : 
; 1530 :    // Create a work view.
; 1531 :    CreateViewFromViewForTask( &vWorkView, lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _vWorkView$[ebp]
	push	edx
	call	_CreateViewFromViewForTask@12

; 1532 : 
; 1533 :    // For all new versions of the instance in question, put the new
; 1534 :    // version in the linked instance chain and copy the incremental
; 1535 :    // indicators across all linked versions of the indicators.
; 1536 :    if ( lpNewInstance->u.nInd.bTemporal )

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	$LN61@AcceptSubo

; 1537 :    {
; 1538 :       // Turn off the temporal indicator
; 1539 :       lpNewInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2049				; fffff7ffH
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 1540 :       lpDupInstance = zGETPTR( lpNewInstance->hNextLinked );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
$LN6@AcceptSubo:

; 1541 :       while ( lpDupInstance && lpDupInstance != lpNewInstance )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	SHORT $LN7@AcceptSubo
	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	cmp	ecx, DWORD PTR _lpNewInstance$[ebp]
	je	SHORT $LN7@AcceptSubo

; 1542 :       {
; 1543 :          lpDupInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2049				; fffff7ffH
	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 1544 :          lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax

; 1545 :       }

	jmp	SHORT $LN6@AcceptSubo
$LN7@AcceptSubo:

; 1546 : 
; 1547 :       // Spawn the entity create if necessary
; 1548 :       fnSpawnCreateEntity( lpView, lpNewInstance );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnSpawnCreateEntity
	add	esp, 8

; 1549 : 
; 1550 :       // Now that we have spawned the create, spawn all creates and
; 1551 :       // includes which have taken place beneath the created temporal
; 1552 :       // entity.
; 1553 :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax
$LN8@AcceptSubo:

; 1554 :       while ( lpNewInstance &&

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	$LN9@AcceptSubo
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jle	$LN9@AcceptSubo

; 1555 :               lpNewInstance->nLevel > lpStartNewInstance->nLevel )
; 1556 :       {
; 1557 :          if ( lpNewInstance->u.nInd.bIncluded )

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	je	$LN62@AcceptSubo

; 1558 :          {
; 1559 :             // This next if blocks spawning for the case where an entity
; 1560 :             // has been created and included and then excluded.
; 1561 :             if ( lpNewInstance->u.nInd.bExcluded == FALSE ) // DKS 7/22/96

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	jne	SHORT $LN64@AcceptSubo

; 1562 :             {
; 1563 :                lpViewEntityCsr = fnEstablishViewForInstance( vWorkView, 0,

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _vWorkView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 1564 :                                                              lpNewInstance );
; 1565 :                fnSpawnIncludeSubobject( vWorkView, lpViewOI,

	push	1
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vWorkView$[ebp]
	push	ecx
	call	_fnSpawnIncludeSubobject
	add	esp, 20					; 00000014H
$LN64@AcceptSubo:

; 1566 :                                         zGETPTR( lpNewInstance->hViewEntity ),
; 1567 :                                         lpViewEntityCsr, 1 );
; 1568 :             }
; 1569 : 
; 1570 :             nRC = lpNewInstance->nLevel;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	ax, WORD PTR [edx+58]
	mov	WORD PTR _nRC$[ebp], ax

; 1571 :             lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax
$LN10@AcceptSubo:

; 1572 :             while ( lpNewInstance && lpNewInstance->nLevel > nRC )

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	SHORT $LN11@AcceptSubo
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nRC$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN11@AcceptSubo

; 1573 :                lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax
	jmp	SHORT $LN10@AcceptSubo
$LN11@AcceptSubo:

; 1574 :          }

	jmp	SHORT $LN63@AcceptSubo
$LN62@AcceptSubo:

; 1575 :          else
; 1576 :          {
; 1577 :             fnSpawnCreateEntity( lpView, lpNewInstance );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnSpawnCreateEntity
	add	esp, 8

; 1578 :             lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax
$LN63@AcceptSubo:

; 1579 :          }
; 1580 :       }

	jmp	$LN8@AcceptSubo
$LN9@AcceptSubo:

; 1581 : 
; 1582 :       // Decrement versioned instance count in viewoi.
; 1583 :       lpViewOI->nVersionedInstances--;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	cx, WORD PTR [eax+22]
	sub	cx, 1
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [edx+22], cx

; 1584 : 
; 1585 :       if ( !fnInstanceVersioned( lpStartNewInstance ) )

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	push	eax
	call	_fnInstanceVersioned
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN65@AcceptSubo

; 1586 :       {
; 1587 :          zSHORT nUpdated = 0;

	xor	edx, edx
	mov	WORD PTR _nUpdated$10[ebp], dx

; 1588 :          zSHORT nUpdatedFile = 0;

	xor	eax, eax
	mov	WORD PTR _nUpdatedFile$11[ebp], ax

; 1589 : 
; 1590 :          // Reset the version update flags.
; 1591 :          fnGetResetUpdFlags( lpStartNewInstance, &nUpdated, &nUpdatedFile, 1 );

	push	1
	lea	ecx, DWORD PTR _nUpdatedFile$11[ebp]
	push	ecx
	lea	edx, DWORD PTR _nUpdated$10[ebp]
	push	edx
	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	push	eax
	call	_fnGetResetUpdFlags
	add	esp, 16					; 00000010H

; 1592 : 
; 1593 :          // Not versioned after accept.
; 1594 :          lpViewOI->bUpdated = lpViewOI->bUpdatedFile = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx

; 1595 :       }

	jmp	SHORT $LN66@AcceptSubo
$LN65@AcceptSubo:

; 1596 :       else
; 1597 :       {
; 1598 :          // Still versioned after accept.
; 1599 :          // We set the version updated flag to the entity which was
; 1600 :          // just accepted.
; 1601 :          fnSetUpdateIndicator( lpViewOI, lpStartNewInstance,

	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	call	_fnSetUpdateIndicator
	add	esp, 24					; 00000018H
$LN66@AcceptSubo:

; 1602 :                                0, TRUE, FALSE, FALSE );
; 1603 :       }
; 1604 : 
; 1605 :       DropView( vWorkView );

	mov	eax, DWORD PTR _vWorkView$[ebp]
	push	eax
	call	_DropView@4

; 1606 :       fnOperationReturn( iAcceptSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	103					; 00000067H
	call	_fnOperationReturn
	add	esp, 8

; 1607 :       return( 0 );  // assume everythings AOK if we get here

	xor	eax, eax
	jmp	$LN1@AcceptSubo
$LN61@AcceptSubo:

; 1608 :    }
; 1609 : 
; 1610 :    // If we're not accepting a temporal entity, then the accept process
; 1611 :    // is more involved - PASS Number 1.
; 1612 :    lpNewInstance = lpStartNewInstance;

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	DWORD PTR _lpNewInstance$[ebp], edx
$LN14@AcceptSubo:

; 1613 :    do
; 1614 :    {
; 1615 :       // In the first pass, we issue deletes and excludes on the old
; 1616 :       // version so hiding of instances takes place across all
; 1617 :       // appropriate linked instances of the old version, this is
; 1618 :       // done in a separate loop because the propagation did not
; 1619 :       // work across inverted relationships when done in the loop
; 1620 :       // below - Gig 5/8/93.
; 1621 :       lpOldInstance = zGETPTR( lpNewInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldInstance$[ebp], eax

; 1622 : 
; 1623 :       // if the new instance was deleted OR Excluded and the
; 1624 :       // old instance is not currently marked as hidden, issue
; 1625 :       // a Delete OR Exclude on the old instance so all
; 1626 :       // linked versions of the old instance are correctly marked.
; 1627 :       if ( lpOldInstance &&
; 1628 :            lpOldInstance->u.nInd.bHidden == FALSE &&

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	$LN67@AcceptSubo
	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	$LN67@AcceptSubo
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN68@AcceptSubo
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	je	SHORT $LN67@AcceptSubo
$LN68@AcceptSubo:

; 1629 :            (lpNewInstance->u.nInd.bDeleted ||
; 1630 :             lpNewInstance->u.nInd.bExcluded) )
; 1631 :       {
; 1632 :          lpWrkViewEntityCsr = fnEstablishViewForInstance( vWorkView, 0,

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vWorkView$[ebp]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpWrkViewEntityCsr$[ebp], eax

; 1633 :                                                           lpOldInstance );
; 1634 :          if ( lpNewInstance->u.nInd.bDeleted )

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	je	SHORT $LN69@AcceptSubo

; 1635 :          {
; 1636 :             fnDeleteEntity( vWorkView,

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _vWorkView$[ebp]
	push	ecx
	call	_fnDeleteEntity
	add	esp, 20					; 00000014H

; 1637 :                             zGETPTR( lpOldInstance->hViewEntity ),
; 1638 :                             lpWrkViewEntityCsr, zREPOS_NONE,
; 1639 :                             lpCurrentTask );
; 1640 :          }

	jmp	SHORT $LN67@AcceptSubo
$LN69@AcceptSubo:

; 1641 :          else
; 1642 :          {
; 1643 :             fnExcludeEntity( vWorkView, zGETPTR( lpOldInstance->hViewEntity ),

	push	1
	push	0
	mov	edx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _vWorkView$[ebp]
	push	edx
	call	_fnExcludeEntity
	add	esp, 20					; 00000014H
$LN67@AcceptSubo:

; 1644 :                              lpWrkViewEntityCsr, zREPOS_NONE, 1 );
; 1645 :          }
; 1646 :       }
; 1647 : 
; 1648 :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 1649 : 
; 1650 :    }  while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel );

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	SHORT $LN13@AcceptSubo
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nStartLevel$[ebp]
	cmp	eax, ecx
	jg	$LN14@AcceptSubo
$LN13@AcceptSubo:

; 1651 : 
; 1652 :    // If we're not accepting a temporal entity, then the accept process
; 1653 :    // is more involved - PASS Number 2.
; 1654 :    lpNewInstance = lpStartNewInstance;

	mov	edx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	DWORD PTR _lpNewInstance$[ebp], edx
$LN17@AcceptSubo:

; 1655 :    do
; 1656 :    {
; 1657 :       // Since we support includes and creates within a new version,
; 1658 :       // see if the current instance represents this situation, if
; 1659 :       // so, we need to re-do the include or create after this
; 1660 :       // accepting process is complete.
; 1661 :       if ( lpNewInstance->hPrevVsn == 0 )

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	cmp	DWORD PTR [eax+38], 0
	jne	SHORT $LN72@AcceptSubo

; 1662 :       {
; 1663 :          // If the new instance has appeared on the chain without a previous
; 1664 :          // version, mark it and all of its descendents as temporal entities
; 1665 :          // for re-creating or re-including later on!
; 1666 :          if ( lpFirstIncluded == 0 )

	cmp	DWORD PTR _lpFirstIncluded$[ebp], 0
	jne	SHORT $LN18@AcceptSubo

; 1667 :             lpFirstIncluded = lpNewInstance;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpFirstIncluded$[ebp], ecx
$LN18@AcceptSubo:

; 1668 : 
; 1669 :          while ( lpNewInstance && lpNewInstance->hPrevVsn == 0 &&

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	SHORT $LN19@AcceptSubo
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	jne	SHORT $LN19@AcceptSubo
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN19@AcceptSubo

; 1670 :                  lpNewInstance->nLevel > nStartLevel )
; 1671 :          {
; 1672 :            lpNewInstance->u.nInd.bTemporal = TRUE;

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 2048				; 00000800H
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1673 :            lpLastIncluded = lpNewInstance;

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpLastIncluded$[ebp], eax

; 1674 :            lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 1675 :          }

	jmp	SHORT $LN18@AcceptSubo
$LN19@AcceptSubo:

; 1676 : 
; 1677 :          // End out of outer do loop if we've passed all the new
; 1678 :          // version instances.
; 1679 :          if ( lpNewInstance == 0 || lpNewInstance->nLevel <= nStartLevel )

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	SHORT $LN75@AcceptSubo
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jg	SHORT $LN72@AcceptSubo
$LN75@AcceptSubo:

; 1680 :             break;

	jmp	$LN16@AcceptSubo
$LN72@AcceptSubo:

; 1681 :       }
; 1682 : 
; 1683 :       // Position on the previous version of this instance.
; 1684 :       lpOldInstance = zGETPTR( lpNewInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldInstance$[ebp], eax

; 1685 :       lpNewInstance->hPrevVsn = lpOldInstance->hPrevVsn;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	mov	DWORD PTR [edx+38], ecx

; 1686 :       if ( lpNewInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN76@AcceptSubo

; 1687 :       {
; 1688 :          LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpNewInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$3[ebp], eax

; 1689 : 
; 1690 :          lpPrevVsn->hNextVsn = zGETHNDL( lpNewInstance );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevVsn$3[ebp]
	mov	DWORD PTR [ecx+34], eax
$LN76@AcceptSubo:

; 1691 :       }
; 1692 : 
; 1693 :       // If the old instance was linked, replace the old instance
; 1694 :       // in the link chain with the new instance.
; 1695 :       lpDupInstance = 0;

	mov	DWORD PTR _lpDupInstance$[ebp], 0

; 1696 :       bStillPrevVsn = 0;

	mov	BYTE PTR _bStillPrevVsn$[ebp], 0

; 1697 :       if ( lpOldInstance && lpOldInstance->hNextLinked )

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	$LN77@AcceptSubo
	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	$LN77@AcceptSubo

; 1698 :       {
; 1699 :          zPVOID hOldInstance = zGETHNDL( lpOldInstance );

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hOldInstance$7[ebp], eax

; 1700 :          zPVOID hNewInstance = zGETHNDL( lpNewInstance );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hNewInstance$18[ebp], eax

; 1701 : 
; 1702 :          // Find the instance in the link chain that points to lpOldInstance.
; 1703 :          // Also, find out if any of the instances in the link chain still
; 1704 :          // have a previous version.
; 1705 :          lpWrkInstance = zGETPTR( lpOldInstance->hNextLinked );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN22@AcceptSubo:

; 1706 :          for ( ; ; )
; 1707 :          {
; 1708 :             // Check to see if the linked instance is also versioned.  If it
; 1709 :             // is then we will flag the accepted instance as still versioned.
; 1710 :             if ( lpWrkInstance->hNextVsn )

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	DWORD PTR [ecx+34], 0
	je	SHORT $LN78@AcceptSubo

; 1711 :             {
; 1712 :                LPENTITYINSTANCE lpParent;
; 1713 : 
; 1714 :                // OK...a linked instance to the accepted instance is still
; 1715 :                // versioned.  But wait!  This linked instance could be part
; 1716 :                // of the current version.  An example could be:
; 1717 :                //
; 1718 :                //    (A)
; 1719 :                //    / \
; 1720 :                //  (B) (B')
; 1721 :                //
; 1722 :                // Entity 'A' is the parent of the new version and B and B'
; 1723 :                // are linked.  lpOldInstance is the original version of B.
; 1724 :                // Make sure lpWrkInstance isn't a case of B'.  To so this
; 1725 :                // check to see if a parent of B' is the versioned parent.
; 1726 : 
; 1727 :                for ( lpParent = zGETPTR( lpWrkInstance->hParent );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$13[ebp], eax
	jmp	SHORT $LN25@AcceptSubo
$LN23@AcceptSubo:

; 1729 :                      lpParent = zGETPTR( lpParent->hParent ) )

	mov	ecx, DWORD PTR _lpParent$13[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$13[ebp], eax
$LN25@AcceptSubo:

; 1728 :                      lpParent;

	cmp	DWORD PTR _lpParent$13[ebp], 0
	je	SHORT $LN24@AcceptSubo

; 1730 :                {
; 1731 :                   if ( lpParent == lpStartOldInstance )

	mov	eax, DWORD PTR _lpParent$13[ebp]
	cmp	eax, DWORD PTR _lpStartOldInstance$[ebp]
	jne	SHORT $LN79@AcceptSubo

; 1732 :                      break;

	jmp	SHORT $LN24@AcceptSubo
$LN79@AcceptSubo:

; 1733 :                }

	jmp	SHORT $LN23@AcceptSubo
$LN24@AcceptSubo:

; 1734 : 
; 1735 :                if ( lpParent == 0 )

	cmp	DWORD PTR _lpParent$13[ebp], 0
	jne	SHORT $LN78@AcceptSubo

; 1736 :                   bStillPrevVsn = TRUE;

	mov	BYTE PTR _bStillPrevVsn$[ebp], 1
$LN78@AcceptSubo:

; 1737 :             }
; 1738 : 
; 1739 :             // Check to see if we have found the instance that points to
; 1740 :             // lpOldInstance.
; 1741 :             if ( lpWrkInstance->hNextLinked == hOldInstance )

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	cmp	edx, DWORD PTR _hOldInstance$7[ebp]
	jne	SHORT $LN81@AcceptSubo

; 1742 :                break;

	jmp	SHORT $LN21@AcceptSubo
$LN81@AcceptSubo:

; 1743 : 
; 1744 :             lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 1745 :          }

	jmp	SHORT $LN22@AcceptSubo
$LN21@AcceptSubo:

; 1746 : 
; 1747 :          // Set the previous version indicator of the new instance.
; 1748 :          lpNewInstance->u.nInd.bPrevVersion = bStillPrevVsn;

	movzx	edx, BYTE PTR _bStillPrevVsn$[ebp]
	and	edx, 1
	shl	edx, 8
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -257				; fffffeffH
	or	ecx, edx
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1749 :          if ( lpNewInstance->hNextLinked )

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	SHORT $LN82@AcceptSubo

; 1750 :          {
; 1751 :             lpDupInstance = lpNewInstance;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpDupInstance$[ebp], ecx
$LN26@AcceptSubo:

; 1752 :             while ( lpDupInstance->hNextLinked != hNewInstance &&

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	cmp	eax, DWORD PTR _hNewInstance$18[ebp]
	je	SHORT $LN82@AcceptSubo
	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	cmp	edx, DWORD PTR _hOldInstance$7[ebp]
	je	SHORT $LN82@AcceptSubo

; 1753 :                     lpDupInstance->hNextLinked != hOldInstance )
; 1754 :             {
; 1755 :                lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax

; 1756 :                lpDupInstance->u.nInd.bPrevVersion = bStillPrevVsn;

	movzx	edx, BYTE PTR _bStillPrevVsn$[ebp]
	and	edx, 1
	shl	edx, 8
	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -257				; fffffeffH
	or	ecx, edx
	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1757 :             }

	jmp	SHORT $LN26@AcceptSubo
$LN82@AcceptSubo:

; 1758 :          }
; 1759 : 
; 1760 :          // if the new instance was linked, update the linked instance
; 1761 :          // pointing to the new instance to point to the
; 1762 :          // first linked instance off the old instance. Otherwise ...
; 1763 :          if ( lpDupInstance )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	SHORT $LN83@AcceptSubo

; 1764 :          {
; 1765 :             // Add the new instance into the link chain ONLY if it is
; 1766 :             // not already there, Otherwise, simply remove the
; 1767 :             // old instance from the link chain.
; 1768 :             if ( lpDupInstance->hNextLinked != hNewInstance )

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	cmp	ecx, DWORD PTR _hNewInstance$18[ebp]
	je	SHORT $LN85@AcceptSubo

; 1769 :             {
; 1770 :                // lpDupInstance is pointing to the old instance, update it
; 1771 :                // to point to ine instance past the old instance to
; 1772 :                // remove the old instance from the link chain.
; 1773 :                lpDupInstance->hNextLinked = lpOldInstance->hNextLinked;

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
$LN28@AcceptSubo:

; 1774 :                while ( lpDupInstance->hNextLinked != hNewInstance )

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	cmp	eax, DWORD PTR _hNewInstance$18[ebp]
	je	SHORT $LN29@AcceptSubo

; 1775 :                   lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
	jmp	SHORT $LN28@AcceptSubo
$LN29@AcceptSubo:

; 1776 :             }

	jmp	SHORT $LN86@AcceptSubo
$LN85@AcceptSubo:

; 1777 :             else
; 1778 :             {
; 1779 :                // lpDupInstance is pointing to the new instance in the new
; 1780 :                // chain and lpWrkInstance is pointing to the old instance
; 1781 :                // in the old chain, point lpDupInstance to the first instance
; 1782 :                // past the old instance in the old chain and lpWrkInstance to
; 1783 :                // the new instance to combine the 2 link chains and remove
; 1784 :                // the old instance from the combined chains at the same time.
; 1785 :                lpDupInstance->hNextLinked = lpOldInstance->hNextLinked;

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR [eax+42], edx

; 1786 :                lpWrkInstance->hNextLinked = hNewInstance;

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR _hNewInstance$18[ebp]
	mov	DWORD PTR [eax+42], ecx
$LN86@AcceptSubo:

; 1787 :             }
; 1788 :          }

	jmp	SHORT $LN84@AcceptSubo
$LN83@AcceptSubo:

; 1789 :          else
; 1790 :          {
; 1791 :             // The new instance is not on any link chain, simply replace
; 1792 :             // the old instance in the old chain with the new instance.
; 1793 :             lpNewInstance->hNextLinked = lpOldInstance->hNextLinked;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx

; 1794 :             lpWrkInstance->hNextLinked = hNewInstance;

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR _hNewInstance$18[ebp]
	mov	DWORD PTR [edx+42], eax
$LN84@AcceptSubo:

; 1795 :          }
; 1796 : 
; 1797 :          lpOldInstance->hNextLinked = 0;

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	DWORD PTR [ecx+42], 0

; 1798 : 
; 1799 :          // If in removing old instances from the link chain we circle
; 1800 :          // back on the new instance itself, zero out the next linked
; 1801 :          // pointer.
; 1802 :          if ( lpNewInstance->hNextLinked == hNewInstance )

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	cmp	eax, DWORD PTR _hNewInstance$18[ebp]
	jne	SHORT $LN77@AcceptSubo

; 1803 :             lpNewInstance->hNextLinked = 0;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+42], 0
$LN77@AcceptSubo:

; 1804 :       }
; 1805 : 
; 1806 :       // If the old instances record has already been updated to point
; 1807 :       // to the new record as a result or the copy operation below on
; 1808 :       // a previously linked old record, OR the old instances record
; 1809 :       // and the new instances record were the same record because
; 1810 :       // the entity is not updateable, simply zero out the
; 1811 :       // record pointer so we don't kill it in clean up later on.
; 1812 :       if ( lpOldInstance->hPersistRecord == lpNewInstance->hPersistRecord )

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	cmp	ecx, DWORD PTR [eax+60]
	jne	SHORT $LN88@AcceptSubo

; 1813 :          lpOldInstance->hPersistRecord = 0;

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	DWORD PTR [edx+60], 0
$LN88@AcceptSubo:

; 1814 : 
; 1815 :       // Copy the data record and incremental update information from
; 1816 :       // the new version to all occurrences of the old version.
; 1817 :       if ( lpNewInstance->hNextLinked )

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	$LN89@AcceptSubo

; 1818 :       {
; 1819 :          if ( lpDupInstance )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	SHORT $LN90@AcceptSubo

; 1820 :             lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
	jmp	SHORT $LN91@AcceptSubo
$LN90@AcceptSubo:

; 1821 :          else
; 1822 :             lpDupInstance = zGETPTR( lpNewInstance->hNextLinked );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
$LN91@AcceptSubo:

; 1823 : 
; 1824 :          // If the records and indicators have not been copied to all
; 1825 :          // occurrences of the old link chain, copy them now.
; 1826 :          if ( lpDupInstance->hPersistRecord != lpNewInstance->hPersistRecord )

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	cmp	ecx, DWORD PTR [eax+60]
	je	$LN89@AcceptSubo

; 1827 :          {
; 1828 :             lpOldRecord = zGETPTR( lpDupInstance->hPersistRecord );

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldRecord$[ebp], eax
$LN30@AcceptSubo:

; 1829 :             while ( lpDupInstance != lpNewInstance )

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	cmp	ecx, DWORD PTR _lpNewInstance$[ebp]
	je	$LN89@AcceptSubo

; 1830 :             {
; 1831 :                LPENTITYINSTANCE lpNextVsn;
; 1832 :                LPVIEWENTITY     lpNewViewEntity =

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntity$1[ebp], eax

; 1833 :                                     zGETPTR( lpNewInstance->hViewEntity );
; 1834 : 
; 1835 :                lpDupInstance->hPersistRecord = lpNewInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 1836 :                if ( lpNewInstance->u.nInd.bUpdated )

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN93@AcceptSubo

; 1837 :                   lpDupInstance->u.nInd.bUpdated = TRUE;

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, 4
	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN93@AcceptSubo:

; 1838 : 
; 1839 :                lpDupInstance->u.nInd.bPrevVersion = bStillPrevVsn;

	movzx	eax, BYTE PTR _bStillPrevVsn$[ebp]
	and	eax, 1
	shl	eax, 8
	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -257				; fffffeffH
	or	edx, eax
	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 1840 : 
; 1841 :                // If the duplicate instance has newer version(s)
; 1842 :                // with the old record, update the newer version(s) and
; 1843 :                // it linked instances.
; 1844 :                lpNextVsn = zGETPTR( lpDupInstance->hNextVsn );

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$6[ebp], eax

; 1845 :                if ( lpNextVsn &&

	cmp	DWORD PTR _lpNextVsn$6[ebp], 0
	je	SHORT $LN94@AcceptSubo
	mov	eax, DWORD PTR _lpNextVsn$6[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpOldRecord$[ebp]
	jne	SHORT $LN94@AcceptSubo

; 1846 :                     zGETPTR( lpNextVsn->hPersistRecord ) == lpOldRecord )
; 1847 :                {
; 1848 :                   fnUpdateNextVsnRecordPointers( zGETPTR( lpDupInstance->hNextVsn ),

	movzx	edx, BYTE PTR _bStillPrevVsn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOldRecord$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnUpdateNextVsnRecordPointers
	add	esp, 16					; 00000010H
$LN94@AcceptSubo:

; 1849 :                                                  lpNewInstance,
; 1850 :                                                  lpOldRecord,
; 1851 :                                                  bStillPrevVsn );
; 1852 :                }
; 1853 : 
; 1854 :                lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax

; 1855 :             }

	jmp	$LN30@AcceptSubo
$LN89@AcceptSubo:

; 1856 :          }
; 1857 :       }
; 1858 : 
; 1859 :       lpLastNewInstance = lpNewInstance;

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpLastNewInstance$[ebp], eax

; 1860 :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 1861 : 
; 1862 :    }  while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel );

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	je	SHORT $LN16@AcceptSubo
	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	cmp	ecx, edx
	jg	$LN17@AcceptSubo
$LN16@AcceptSubo:

; 1863 : 
; 1864 :    // Go through the EIs we are about to remove and set a flag so we can
; 1865 :    // determine if a cursor is pointing to one of them.
; 1866 :    for ( lpOldInstance = lpStartOldInstance;

	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR _lpOldInstance$[ebp], eax
	jmp	SHORT $LN34@AcceptSubo
$LN32@AcceptSubo:

; 1868 :          lpOldInstance = zGETPTR( lpOldInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldInstance$[ebp], eax
$LN34@AcceptSubo:

; 1867 :          lpOldInstance;

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	SHORT $LN33@AcceptSubo

; 1869 :    {
; 1870 :       if ( lpOldInstance->nLevel <= lpStartOldInstance->nLevel &&

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jg	SHORT $LN96@AcceptSubo
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	cmp	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	je	SHORT $LN96@AcceptSubo

; 1871 :            lpOldInstance != lpStartOldInstance )
; 1872 :       {
; 1873 :          break;

	jmp	SHORT $LN33@AcceptSubo
$LN96@AcceptSubo:

; 1874 :       }
; 1875 : 
; 1876 :       lpOldInstance->u.nInd.bDelByAccept = TRUE;

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 8388608				; 00800000H
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 1877 :    }

	jmp	SHORT $LN32@AcceptSubo
$LN33@AcceptSubo:

; 1878 : 
; 1879 :    // Now go through all views for the old object and update any cursors
; 1880 :    // positioned on the previous version to point to the new version.
; 1881 :    for ( lpWrkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
	jmp	SHORT $LN37@AcceptSubo
$LN35@AcceptSubo:

; 1883 :          lpWrkViewCsr = zGETPTR( lpWrkViewCsr->hNextViewCsr ) )

	mov	ecx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
$LN37@AcceptSubo:

; 1882 :          lpWrkViewCsr;

	cmp	DWORD PTR _lpWrkViewCsr$[ebp], 0
	je	SHORT $LN36@AcceptSubo

; 1884 :    {
; 1885 :       lpWrkViewEntityCsr = zGETPTR( lpWrkViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntityCsr$[ebp], eax

; 1886 :       lpWrkViewEntityCsr += (lpViewEntity->nHierNbr - 1);

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	DWORD PTR _lpWrkViewEntityCsr$[ebp], ecx

; 1887 : 
; 1888 :       if ( lpWrkViewEntityCsr->hEntityInstance == 0 ||

	mov	edx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN98@AcceptSubo
	mov	eax, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	jne	SHORT $LN97@AcceptSubo
$LN98@AcceptSubo:

; 1889 :            lpWrkViewEntityCsr->hEntityInstance == UNSET_CSR )
; 1890 :       {
; 1891 :          // Don't have to worry about a null or unset cursor.
; 1892 :          continue;

	jmp	SHORT $LN35@AcceptSubo
$LN97@AcceptSubo:

; 1893 :       }
; 1894 : 
; 1895 :       lpWrkInstance = zGETPTR( lpWrkViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 1896 :       if ( lpWrkInstance->u.nInd.bDelByAccept )

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 23					; 00000017H
	and	ecx, 1
	je	SHORT $LN99@AcceptSubo

; 1897 :       {
; 1898 :          lpWrkViewEntityCsr->hEntityInstance = lpWrkInstance->hNextVsn;

	mov	edx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	mov	DWORD PTR [edx+26], ecx

; 1899 :       // if ( lpWrkViewEntityCsr->hEntityInstance == UNSET_CSR )
; 1900 :       //    SysMessageBox( 0, "AcceptSubobject", "UNSET_CSR", -1 );
; 1901 : 
; 1902 :          fnResetCursorForViewChildren( lpWrkViewEntityCsr );

	mov	edx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN99@AcceptSubo:

; 1903 :       }
; 1904 :    }

	jmp	$LN35@AcceptSubo
$LN36@AcceptSubo:

; 1905 : 
; 1906 :    // Finally, clean up the previous version instance chain.
; 1907 :    lpOldInstance = lpStartOldInstance;

	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR _lpOldInstance$[ebp], eax
$LN38@AcceptSubo:

; 1908 :    while ( lpOldInstance )

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	$LN39@AcceptSubo

; 1909 :    {
; 1910 :       fnDeleteAttributeRecord( zGETPTR( lpOldInstance->hViewEntity ),

	push	1
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 1911 :                                lpOldInstance, TRUE );
; 1912 :       fnDeleteAttributeRecord( zGETPTR( lpOldInstance->hViewEntity ),

	push	0
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 1913 :                                lpOldInstance, FALSE );
; 1914 : 
; 1915 :       // Null out the hRecord for all linked EI's.  This will keep us from
; 1916 :       // trying to free the hRecord twice.
; 1917 :       if ( lpOldInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN100@AcceptSubo

; 1918 :       {
; 1919 :          LPENTITYINSTANCE lpLinked;
; 1920 :          LPENTITYINSTANCE lpPrevLinked;
; 1921 : 
; 1922 :          for ( lpLinked = zGETPTR( lpOldInstance->hNextLinked );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$14[ebp], eax
	jmp	SHORT $LN42@AcceptSubo
$LN40@AcceptSubo:

; 1924 :                lpLinked = zGETPTR( lpLinked->hNextLinked ) )

	mov	ecx, DWORD PTR _lpLinked$14[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$14[ebp], eax
$LN42@AcceptSubo:

; 1923 :                lpLinked != lpOldInstance;

	mov	eax, DWORD PTR _lpLinked$14[ebp]
	cmp	eax, DWORD PTR _lpOldInstance$[ebp]
	je	SHORT $LN41@AcceptSubo

; 1925 :          {
; 1926 :             lpLinked->hPersistRecord = 0;

	mov	ecx, DWORD PTR _lpLinked$14[ebp]
	mov	DWORD PTR [ecx+60], 0

; 1927 :             lpPrevLinked = lpLinked;

	mov	edx, DWORD PTR _lpLinked$14[ebp]
	mov	DWORD PTR _lpPrevLinked$9[ebp], edx

; 1928 :          }

	jmp	SHORT $LN40@AcceptSubo
$LN41@AcceptSubo:

; 1929 : 
; 1930 :          // Now remove lpOldInstance from the link chain.
; 1931 :          if ( zGETPTR( lpOldInstance->hNextLinked ) == lpPrevLinked )

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpPrevLinked$9[ebp]
	jne	SHORT $LN101@AcceptSubo

; 1932 :          {
; 1933 :             // Only two entities were in the link chain so now there is no
; 1934 :             // longer a chain.
; 1935 :             lpPrevLinked->hNextLinked = 0;

	mov	edx, DWORD PTR _lpPrevLinked$9[ebp]
	mov	DWORD PTR [edx+42], 0

; 1936 :          }

	jmp	SHORT $LN100@AcceptSubo
$LN101@AcceptSubo:

; 1937 :          else
; 1938 :             lpPrevLinked->hNextLinked = lpOldInstance->hNextLinked;

	mov	eax, DWORD PTR _lpPrevLinked$9[ebp]
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	mov	DWORD PTR [eax+42], edx
$LN100@AcceptSubo:

; 1939 :       }
; 1940 : 
; 1941 :       lpWrkInstance = lpOldInstance;

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 1942 :       lpOldInstance = zGETPTR( lpOldInstance->hNextHier );

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldInstance$[ebp], eax

; 1943 :       fnFreeDataspace( lpWrkInstance );

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1944 :    }

	jmp	$LN38@AcceptSubo
$LN39@AcceptSubo:

; 1945 : 
; 1946 :    // Decrement versioned instance count in viewoi.
; 1947 :    lpViewOI->nVersionedInstances--;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	dx, WORD PTR [ecx+22]
	sub	dx, 1
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [eax+22], dx

; 1948 :    if ( !fnInstanceVersioned( lpStartNewInstance ) )

	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	push	ecx
	call	_fnInstanceVersioned
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN103@AcceptSubo

; 1949 :    {
; 1950 :       zSHORT nUpdated = 0;

	xor	eax, eax
	mov	WORD PTR _nUpdated$16[ebp], ax

; 1951 :       zSHORT nUpdatedFile = 0;

	xor	ecx, ecx
	mov	WORD PTR _nUpdatedFile$15[ebp], cx

; 1952 : 
; 1953 :       fnGetResetUpdFlags( lpStartNewInstance, &nUpdated, &nUpdatedFile, 1 );

	push	1
	lea	edx, DWORD PTR _nUpdatedFile$15[ebp]
	push	edx
	lea	eax, DWORD PTR _nUpdated$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	push	ecx
	call	_fnGetResetUpdFlags
	add	esp, 16					; 00000010H

; 1954 : 
; 1955 :       if ( nUpdated )

	movsx	edx, WORD PTR _nUpdated$16[ebp]
	test	edx, edx
	je	SHORT $LN104@AcceptSubo

; 1956 :          lpViewOI->bUpdated = TRUE;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [edx+36], ecx
$LN104@AcceptSubo:

; 1957 : 
; 1958 :       if ( nUpdatedFile )

	movsx	eax, WORD PTR _nUpdatedFile$15[ebp]
	test	eax, eax
	je	SHORT $LN103@AcceptSubo

; 1959 :          lpViewOI->bUpdatedFile = TRUE;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [eax+36], edx
$LN103@AcceptSubo:

; 1960 :    }
; 1961 : 
; 1962 :    // Now that we've cleaned up the old versioned information, we need
; 1963 :    // to re-create the created entity instances and re-include the included
; 1964 :    // instances so any appropriate spawning takes place in the new object
; 1965 :    // instance.
; 1966 :    if ( lpFirstIncluded )

	cmp	DWORD PTR _lpFirstIncluded$[ebp], 0
	je	$LN106@AcceptSubo

; 1967 :    {
; 1968 :       LPVIEWENTITY      lpViewEntity;
; 1969 :       LPVIEWENTITYCSR   lpViewEntityCsr;
; 1970 :       LPENTITYINSTANCE  lpLastIncluded_NextHier;
; 1971 : 
; 1972 :       lpNewInstance = lpFirstIncluded;

	mov	ecx, DWORD PTR _lpFirstIncluded$[ebp]
	mov	DWORD PTR _lpNewInstance$[ebp], ecx

; 1973 : 
; 1974 :       lpLastIncluded_NextHier = zGETPTR( lpLastIncluded->hNextHier );

	mov	edx, DWORD PTR _lpLastIncluded$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastIncluded_NextHier$8[ebp], eax
$LN43@AcceptSubo:

; 1975 :       while ( lpNewInstance != lpLastIncluded_NextHier )

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	cmp	ecx, DWORD PTR _lpLastIncluded_NextHier$8[ebp]
	je	$LN106@AcceptSubo

; 1976 :       {
; 1977 :          if ( lpNewInstance->u.nInd.bTemporal )

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	$LN107@AcceptSubo

; 1978 :          {
; 1979 :             if ( lpNewInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN109@AcceptSubo

; 1980 :             {
; 1981 :                lpNewInstance->u.nInd.bTemporal = 0;

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -2049				; fffff7ffH
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 1982 :                lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 1983 :             }

	jmp	$LN110@AcceptSubo
$LN109@AcceptSubo:

; 1984 :             else
; 1985 :             {
; 1986 :                LPVIEWCSR lpWorkViewCsr = zGETPTR( vWorkView->hViewCsr );

	mov	edx, DWORD PTR _vWorkView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewCsr$2[ebp], eax

; 1987 : 
; 1988 :                // if the instance in question was included, UNDO the include
; 1989 :                // and re-do it so spawning will take place
; 1990 :                lpViewEntity = zGETPTR( lpNewInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$5[ebp], eax

; 1991 :                lpViewEntityCsr = zGETPTR( lpWorkViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpWorkViewCsr$2[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$12[ebp], eax

; 1992 :                lpViewEntityCsr += ( lpViewEntity->nHierNbr - 1 );

	mov	edx, DWORD PTR _lpViewEntity$5[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpViewEntityCsr$12[ebp]
	mov	DWORD PTR _lpViewEntityCsr$12[ebp], ecx

; 1993 :                fnEstablishViewForInstance( vWorkView, lpViewEntityCsr,

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _vWorkView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1994 :                                           lpNewInstance );
; 1995 : 
; 1996 :                if ( lpNewInstance->u.nInd.bIncluded )

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN111@AcceptSubo

; 1997 :                {
; 1998 :                   lpWrkInstance = lpNewInstance;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpWrkInstance$[ebp], ecx
$LN47@AcceptSubo:

; 1999 :                   do
; 2000 :                   {
; 2001 :                      lpWrkInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2049				; fffff7ffH
	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2002 :                      lpWrkInstance = zGETPTR( lpWrkInstance->hNextHier );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 2003 : 
; 2004 :                   }  while ( lpWrkInstance != lpLastIncluded_NextHier &&

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	ecx, DWORD PTR _lpLastIncluded_NextHier$8[ebp]
	je	SHORT $LN46@AcceptSubo
	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jg	SHORT $LN47@AcceptSubo
$LN46@AcceptSubo:

; 2005 :                              lpWrkInstance->nLevel > lpNewInstance->nLevel );
; 2006 : 
; 2007 :                   // Now, spawn the include done on the new version
; 2008 :                   nRC = fnSpawnIncludeSubobject( vWorkView, lpViewOI,

	push	1
	mov	eax, DWORD PTR _lpViewEntityCsr$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	push	edx
	mov	eax, DWORD PTR _vWorkView$[ebp]
	push	eax
	call	_fnSpawnIncludeSubobject
	add	esp, 20					; 00000014H
	mov	WORD PTR _nRC$[ebp], ax

; 2009 :                                                 lpViewEntity, lpViewEntityCsr,
; 2010 :                                                 1 );
; 2011 :                   lpNewInstance = lpWrkInstance;

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	DWORD PTR _lpNewInstance$[ebp], ecx

; 2012 :                }

	jmp	SHORT $LN112@AcceptSubo
$LN111@AcceptSubo:

; 2013 :                else
; 2014 :                {
; 2015 :                   lpNewInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2049				; fffff7ffH
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2016 :                   nRC = fnSpawnCreateEntity( vWorkView, lpNewInstance );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _vWorkView$[ebp]
	push	eax
	call	_fnSpawnCreateEntity
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2017 :                   lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax
$LN112@AcceptSubo:

; 2018 :                }
; 2019 : 
; 2020 :                // If something terrible happened, go through and at least
; 2021 :                // clean up the temporal markings in the included/created
; 2022 :                // entities
; 2023 :                if ( nRC )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	je	SHORT $LN110@AcceptSubo
$LN48@AcceptSubo:

; 2024 :                {
; 2025 :                   while ( lpNewInstance != lpLastIncluded_NextHier )

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	cmp	ecx, DWORD PTR _lpLastIncluded_NextHier$8[ebp]
	je	SHORT $LN49@AcceptSubo

; 2026 :                   {
; 2027 :                      lpNewInstance->u.nInd.bTemporal = 0;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -2049				; fffff7ffH
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2028 :                      lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 2029 :                   }

	jmp	SHORT $LN48@AcceptSubo
$LN49@AcceptSubo:

; 2030 : 
; 2031 :                   break;   // Get out with bad return code

	jmp	SHORT $LN106@AcceptSubo
$LN110@AcceptSubo:

; 2032 :                }
; 2033 :             }
; 2034 :          }

	jmp	SHORT $LN108@AcceptSubo
$LN107@AcceptSubo:

; 2035 :          else
; 2036 :             lpNewInstance = zGETPTR( lpNewInstance->hNextHier );

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax
$LN108@AcceptSubo:

; 2037 :       }

	jmp	$LN43@AcceptSubo
$LN106@AcceptSubo:

; 2038 :    }
; 2039 : 
; 2040 :    // Drop the work view
; 2041 :    DropView( vWorkView );

	mov	eax, DWORD PTR _vWorkView$[ebp]
	push	eax
	call	_DropView@4

; 2042 : 
; 2043 : #if 0   // Gig, debugging, for all new instances, see if a record
; 2044 :         // match can be found which is not linked!!!!
; 2045 :    lpNewInstance      = lpStartNewInstance;
; 2046 :    do
; 2047 :    {
; 2048 :       lpWrkInstance = zGETPTR( lpNewInstance->hNextHier );
; 2049 :       while ( lpWrkInstance && lpWrkInstance->nLevel > nStartLevel )
; 2050 :       {
; 2051 :          if ( lpWrkInstance->hPersistRecord == lpNewInstance->hPersistRecord )
; 2052 :          {
; 2053 :             lpDupInstance = zGETPTR( lpNewInstance->hNextLinked );
; 2054 :             while ( lpDupInstance && lpDupInstance != lpNewInstance )
; 2055 :             {
; 2056 :                if ( lpDupInstance == lpWrkInstance )
; 2057 :                   break;
; 2058 : 
; 2059 :                lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );
; 2060 :             }
; 2061 : 
; 2062 :             if ( lpDupInstance != lpWrkInstance )
; 2063 :             {
; 2064 :                SysMessageBox( "ERROR AFTER ACCEPT",
; 2065 :                               "Record match found in non-linked instance", 1 );
; 2066 :             }
; 2067 :          }
; 2068 : 
; 2069 :          lpWrkInstance = zGETPTR( lpWrkInstance->hNextHier );
; 2070 :       }
; 2071 : 
; 2072 :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );
; 2073 : 
; 2074 :    } while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel );
; 2075 : #endif
; 2076 : 
; 2077 : #ifdef __RECLAIM__
; 2078 :    if ( lpViewOI->nHiddenCount > __RECLAIM_LIMIT__ )

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	movsx	edx, WORD PTR [ecx+24]
	cmp	edx, 20					; 00000014H
	jle	SHORT $LN115@AcceptSubo

; 2079 :       fnReclaimHiddenInstances( lpViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	push	eax
	call	_fnReclaimHiddenInstances@4
$LN115@AcceptSubo:

; 2080 : #endif
; 2081 : 
; 2082 :    fnOperationReturn( iAcceptSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	103					; 00000067H
	call	_fnOperationReturn
	add	esp, 8

; 2083 :    return( nRC );  // Return results

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@AcceptSubo:

; 2084 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_AcceptSubobject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoesoaa.c
_TEXT	SEGMENT
_lpViewOD$ = -116					; size = 4
_lpLastOldInstance$ = -112				; size = 4
_lpOldParent$1 = -108					; size = 4
_lpInstAllocTask$ = -104				; size = 4
_lpViewCsr$ = -100					; size = 4
_lpNewViewEntity$2 = -96				; size = 4
_lpNextVsn$3 = -92					; size = 4
_lpOldViewEntity$4 = -88				; size = 4
_lpPrevVsn$5 = -84					; size = 4
_lpLastNewInstance$ = -80				; size = 4
_lpAllocTask$ = -76					; size = 4
_lpOldViewEntity$6 = -72				; size = 4
_lpPrevTwin$7 = -68					; size = 4
_lpViewEntityCsr$ = -64					; size = 4
_lpWrkViewEntityCsr$ = -60				; size = 4
_hStartNewInstance$ = -56				; size = 4
_lpViewEntity$ = -52					; size = 4
_lpWrkViewCsr$ = -48					; size = 4
_lpWork$8 = -44						; size = 4
_lpViewOI$ = -40					; size = 4
_lpCurrentTask$ = -36					; size = 4
_lpStartOldInstance$ = -32				; size = 4
_hInstance$ = -28					; size = 4
_lpStartNewInstance$ = -24				; size = 4
_lpNewInstance$ = -20					; size = 4
_lpDupInstance$ = -16					; size = 4
_lpWrkInstance$ = -12					; size = 4
_lpOldInstance$ = -8					; size = 4
_nStartLevel$ = -4					; size = 2
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_CreateTemporalSubobjectVersion@8 PROC

; 277  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 278  :    LPTASK           lpCurrentTask;
; 279  :    LPTASK           lpAllocTask;
; 280  :    LPTASK           lpInstAllocTask;
; 281  :    LPVIEWOI         lpViewOI;
; 282  :    LPVIEWOD         lpViewOD;
; 283  :    LPVIEWCSR        lpViewCsr;
; 284  :    LPVIEWCSR        lpWrkViewCsr;
; 285  :    LPVIEWENTITY     lpViewEntity;
; 286  :    LPVIEWENTITYCSR  lpViewEntityCsr;
; 287  :    LPVIEWENTITYCSR  lpWrkViewEntityCsr;
; 288  :    LPENTITYINSTANCE lpStartOldInstance;
; 289  :    LPENTITYINSTANCE lpOldInstance;
; 290  :    LPENTITYINSTANCE lpStartNewInstance;
; 291  :    zPVOID           hStartNewInstance;
; 292  :    LPENTITYINSTANCE lpLastOldInstance;
; 293  :    LPENTITYINSTANCE lpLastNewInstance;
; 294  :    LPENTITYINSTANCE lpNewInstance;
; 295  :    zPVOID           hInstance;
; 296  :    LPENTITYINSTANCE lpWrkInstance;
; 297  :    LPENTITYINSTANCE lpDupInstance;
; 298  :    zSHORT           nStartLevel;
; 299  : 
; 300  :    // Validate parameters.
; 301  :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	102					; 00000066H
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN24@CreateTemp

; 302  :                                       &lpViewEntity,
; 303  :                                       &lpViewEntityCsr,
; 304  :                                       iCreateTemporalSubobjectVersion,
; 305  :                                       lpView,
; 306  :                                       cpcEntityName, 0 ) )
; 307  :    {
; 308  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN24@CreateTemp:

; 309  :    }
; 310  : 
; 311  :    // If the view is ReadOnly, return.
; 312  :    if ( lpView->bReadOnly )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN25@CreateTemp

; 313  :    {
; 314  :       fnOperationReturn( iCreateTemporalSubobjectVersion, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	102					; 00000066H
	call	_fnOperationReturn
	add	esp, 8

; 315  :       return( 0 );  // We think everything was OK

	xor	eax, eax
	jmp	$LN1@CreateTemp
$LN25@CreateTemp:

; 316  :    }
; 317  : 
; 318  :    // Get starting level for create.
; 319  :    nStartLevel = lpViewEntityCsr->nLevel;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	cx, WORD PTR [eax+22]
	mov	WORD PTR _nStartLevel$[ebp], cx

; 320  : 
; 321  :    // Get view csr and view oi.
; 322  :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 323  :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 324  :    lpViewOD  = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 325  : 
; 326  :    // Get task which owns the object instance.
; 327  :    lpAllocTask     = zGETPTR( lpViewOI->hAllocTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAllocTask$[ebp], eax

; 328  :    lpInstAllocTask = zGETPTR( lpViewOI->hTask );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInstAllocTask$[ebp], eax

; 329  : 
; 330  :    // Get instance on which to start.
; 331  :    lpStartOldInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartOldInstance$[ebp], eax

; 332  : 
; 333  :    // Check to ensure neither this instance nor any of its descendents is already
; 334  :    // versioned. This is true when lpPrevVsn points to a versioned root instance.
; 335  :    lpOldInstance = lpStartOldInstance;

	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR _lpOldInstance$[ebp], edx
$LN4@CreateTemp:

; 336  :    do
; 337  :    {
; 338  :       LPENTITYINSTANCE lpPrevVsn = zGETPTR( lpOldInstance->hPrevVsn );

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevVsn$5[ebp], eax

; 339  :       LPVIEWENTITY     lpOldViewEntity = zGETPTR( lpOldInstance->hViewEntity );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldViewEntity$4[ebp], eax

; 340  : 
; 341  :       if ( lpOldInstance->u.nInd.bTemporal ||

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	jne	SHORT $LN27@CreateTemp
	cmp	DWORD PTR _lpPrevVsn$5[ebp], 0
	je	SHORT $LN26@CreateTemp
	mov	eax, DWORD PTR _lpPrevVsn$5[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 9
	and	ecx, 1
	je	SHORT $LN26@CreateTemp
$LN27@CreateTemp:

; 342  :            (lpPrevVsn && lpPrevVsn->u.nInd.bPrevVsnRoot) )
; 343  :       {
; 344  :          if ( lpOldInstance == lpStartOldInstance )

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	cmp	edx, DWORD PTR _lpStartOldInstance$[ebp]
	jne	SHORT $LN28@CreateTemp

; 345  :          {
; 346  :             // "KZOEE136 - Entity Instance already versioned"
; 347  :             fnIssueCoreError( lpCurrentTask, lpView, 8, 136, 0,

	push	0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	0
	push	136					; 00000088H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 348  :                               lpViewEntity->szName, 0 );
; 349  :          }

	jmp	SHORT $LN29@CreateTemp
$LN28@CreateTemp:

; 350  :          else
; 351  :          {
; 352  :             // "KZOEE137 - Entity Instance descendent versioned"
; 353  :             fnIssueCoreError( lpCurrentTask, lpView, 8, 137, 0,

	mov	eax, DWORD PTR _lpOldViewEntity$4[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	137					; 00000089H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN29@CreateTemp:

; 354  :                               lpViewEntity->szName,
; 355  :                               lpOldViewEntity->szName );
; 356  :          }
; 357  : 
; 358  :          fnOperationReturn( iCreateTemporalSubobjectVersion, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	102					; 00000066H
	call	_fnOperationReturn
	add	esp, 8

; 359  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN26@CreateTemp:

; 360  :       }
; 361  : 
; 362  :       // If the instance to be versioned is already versioned, make sure
; 363  :       // it is not versioned down a different path or through a different
; 364  :       // object than the current object and path we are on. If this is
; 365  :       // true, the the instance will be marked as a previous version yet
; 366  :       // it will not have a previous version entity instance pointer.
; 367  :       //
; 368  :       // We only care about this if the instance being versioned may be
; 369  :       // updated and there is already a versioned instance down a
; 370  :       // different path that may be updated.
; 371  : 
; 372  :       if ( lpOldInstance->u.nInd.bPrevVersion &&
; 373  :            lpOldViewEntity->bUpdate &&

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 8
	and	eax, 1
	je	$LN30@CreateTemp
	mov	ecx, DWORD PTR _lpOldViewEntity$4[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 2
	and	edx, 1
	je	$LN30@CreateTemp
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	$LN30@CreateTemp

; 374  :            lpOldInstance->hNextLinked )
; 375  :       {
; 376  :          // We have found an instance marked as a previous version
; 377  :          // which does not have a previous version itself, this means
; 378  :          // that the instance is versioned down a linked path, go
; 379  :          // through the linked versions to see if the record itself
; 380  :          // was versioned for updating. If NOT, then we can still version
; 381  :          // this instance.
; 382  :          lpWrkInstance = zGETPTR( lpOldInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN5@CreateTemp:

; 383  :          while ( lpWrkInstance && lpWrkInstance != lpOldInstance )

	cmp	DWORD PTR _lpWrkInstance$[ebp], 0
	je	SHORT $LN6@CreateTemp
	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	cmp	eax, DWORD PTR _lpOldInstance$[ebp]
	je	SHORT $LN6@CreateTemp

; 384  :          {
; 385  :             LPENTITYINSTANCE lpNextVsn = zGETPTR( lpWrkInstance->hNextVsn );

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextVsn$3[ebp], eax

; 386  : 
; 387  :             if ( lpNextVsn &&

	cmp	DWORD PTR _lpNextVsn$3[ebp], 0
	je	SHORT $LN31@CreateTemp
	mov	eax, DWORD PTR _lpNextVsn$3[ebp]
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [eax+60]
	cmp	edx, DWORD PTR [ecx+60]
	je	SHORT $LN31@CreateTemp

; 388  :                  lpNextVsn->hPersistRecord != lpOldInstance->hPersistRecord )
; 389  :             {
; 390  :                break;

	jmp	SHORT $LN6@CreateTemp
$LN31@CreateTemp:

; 391  :             }
; 392  : 
; 393  :             lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 394  :          }

	jmp	SHORT $LN5@CreateTemp
$LN6@CreateTemp:

; 395  : 
; 396  :          if ( lpWrkInstance != lpOldInstance )

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	edx, DWORD PTR _lpOldInstance$[ebp]
	je	SHORT $LN30@CreateTemp

; 397  :          {
; 398  :             // TB742
; 399  :             // to avoid a crash within zGETPTR we can either check
; 400  :             // lpWrkInstance against NULL or remove this obsolete code.
; 401  : //          LPVIEWENTITY lpWrkViewEntity =
; 402  : //                                 zGETPTR( lpWrkInstance->hViewEntity );
; 403  : 
; 404  :             // "KZOEE134 - Attempt to version an Entity Instance "
; 405  :             // "           versioned via a different path"
; 406  :             fnIssueCoreError( lpCurrentTask, lpView, 8, 134, 0,

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	0
	push	134					; 00000086H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 407  :                               lpViewEntity->szName,
; 408  :                               lpViewEntity->szName );
; 409  :             fnOperationReturn( iCreateTemporalSubobjectVersion, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	102					; 00000066H
	call	_fnOperationReturn
	add	esp, 8

; 410  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN30@CreateTemp:

; 411  :          }
; 412  :       }
; 413  : 
; 414  :       lpOldInstance = zGETPTR( lpOldInstance->hNextHier );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldInstance$[ebp], eax

; 415  : 
; 416  :    } while ( lpOldInstance && lpOldInstance->nLevel > nStartLevel );

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	SHORT $LN3@CreateTemp
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jg	$LN4@CreateTemp
$LN3@CreateTemp:

; 417  : 
; 418  :    // All error checking is complete, Version the source instances and
; 419  :    // all of its dependents.
; 420  :    lpOldInstance      = lpStartOldInstance;

	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR _lpOldInstance$[ebp], ecx

; 421  :    lpStartNewInstance = 0;

	mov	DWORD PTR _lpStartNewInstance$[ebp], 0

; 422  :    hStartNewInstance  = 0;

	mov	DWORD PTR _hStartNewInstance$[ebp], 0
$LN9@CreateTemp:

; 423  :    do
; 424  :    {
; 425  :       LPVIEWENTITY lpOldViewEntity = zGETPTR( lpOldInstance->hViewEntity );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldViewEntity$6[ebp], eax

; 426  :       LPVIEWENTITY lpNewViewEntity;
; 427  : 
; 428  :       hInstance = fnAllocDataspace( lpInstAllocTask->hFirstDataHeader,

	push	10024					; 00002728H
	push	0
	push	1
	push	68					; 00000044H
	mov	ecx, DWORD PTR _lpInstAllocTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hInstance$[ebp], eax

; 429  :                                     sizeof( EntityInstanceRecord ), 1, 0,
; 430  :                                     iEntityInstance );
; 431  :       lpNewInstance = zGETPTR( hInstance );

	mov	eax, DWORD PTR _hInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewInstance$[ebp], eax

; 432  :       if ( lpNewInstance == 0 )

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	jne	SHORT $LN34@CreateTemp

; 433  :       {
; 434  :          // "KZOEE012 - Error allocating memory"
; 435  :          fnIssueCoreError( lpCurrentTask, lpView, 12, 20, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	20					; 00000014H
	push	12					; 0000000cH
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 436  :          break;

	jmp	$LN8@CreateTemp
$LN34@CreateTemp:

; 437  :       }
; 438  : 
; 439  :       // Copy old instance information to new instance.
; 440  :       zmemcpy( lpNewInstance, lpOldInstance,

	push	68					; 00000044H
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 441  :                sizeof( EntityInstanceRecord ) );
; 442  : 
; 443  :       // If this is not the first instance versioned.
; 444  :       if ( lpStartNewInstance )

	cmp	DWORD PTR _lpStartNewInstance$[ebp], 0
	je	SHORT $LN35@CreateTemp

; 445  :       {
; 446  :          LPENTITYINSTANCE lpOldParent = zGETPTR( lpOldInstance->hParent );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldParent$1[ebp], eax

; 447  : 
; 448  :          lpLastNewInstance->hNextHier = hInstance;

	mov	ecx, DWORD PTR _lpLastNewInstance$[ebp]
	mov	edx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 449  :          lpNewInstance->hPrevHier = zGETHNDL( lpLastNewInstance );

	mov	eax, DWORD PTR _lpLastNewInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+18], eax

; 450  :          lpNewInstance->hParent   = lpOldParent->hNextVsn;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR _lpOldParent$1[ebp]
	mov	ecx, DWORD PTR [eax+34]
	mov	DWORD PTR [edx+30], ecx

; 451  :       // if ( lpNewInstance->hParent == UNSET_CSR )
; 452  :       //    SysMessageBox( 0, "CreateTemporalSubobjectVersion", "UNSET_CSR", -1 );
; 453  : 
; 454  :          if ( lpOldInstance->hPrevTwin )

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	SHORT $LN37@CreateTemp

; 455  :          {
; 456  :             LPENTITYINSTANCE lpPrevTwin;
; 457  : 
; 458  :             lpPrevTwin = zGETPTR( lpOldInstance->hPrevTwin );

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTwin$7[ebp], eax

; 459  :             lpNewInstance->hPrevTwin = lpPrevTwin->hNextVsn;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR _lpPrevTwin$7[ebp]
	mov	ecx, DWORD PTR [eax+34]
	mov	DWORD PTR [edx+26], ecx

; 460  : 
; 461  :             lpPrevTwin = zGETPTR( lpNewInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTwin$7[ebp], eax

; 462  :             lpPrevTwin->hNextTwin = hInstance;

	mov	ecx, DWORD PTR _lpPrevTwin$7[ebp]
	mov	edx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [ecx+22], edx
$LN37@CreateTemp:

; 463  :          }
; 464  :       }

	jmp	SHORT $LN36@CreateTemp
$LN35@CreateTemp:

; 465  :       else
; 466  :       {
; 467  :          LPENTITYINSTANCE lpWork;
; 468  : 
; 469  :          hStartNewInstance  = hInstance;

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _hStartNewInstance$[ebp], eax

; 470  :          lpStartNewInstance = lpNewInstance;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpStartNewInstance$[ebp], ecx

; 471  : 
; 472  :          if ( lpOldInstance->hPrevHier )

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN38@CreateTemp

; 473  :          {
; 474  :             lpWork = zGETPTR( lpOldInstance->hPrevHier );

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWork$8[ebp], eax

; 475  :             lpWork->hNextHier = hInstance;

	mov	edx, DWORD PTR _lpWork$8[ebp]
	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [edx+14], eax
$LN38@CreateTemp:

; 476  :          }
; 477  : 
; 478  :          if ( lpOldInstance->hPrevTwin )

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN39@CreateTemp

; 479  :          {
; 480  :             lpWork = zGETPTR( lpOldInstance->hPrevTwin );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWork$8[ebp], eax

; 481  :             lpWork->hNextTwin = hInstance;

	mov	ecx, DWORD PTR _lpWork$8[ebp]
	mov	edx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [ecx+22], edx
$LN39@CreateTemp:

; 482  :          }
; 483  : 
; 484  :          if ( lpOldInstance->hNextTwin )

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN36@CreateTemp

; 485  :          {
; 486  :             lpWork = zGETPTR( lpOldInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWork$8[ebp], eax

; 487  :             lpWork->hPrevTwin = hInstance;

	mov	eax, DWORD PTR _lpWork$8[ebp]
	mov	ecx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [eax+26], ecx
$LN36@CreateTemp:

; 488  :          }
; 489  :       }
; 490  : 
; 491  :       lpNewInstance->hPrevVsn = zGETHNDL( lpOldInstance );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+38], eax

; 492  :       lpOldInstance->hNextVsn = hInstance;

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [edx+34], eax

; 493  :       lpNewInstance->hNextLinked  = 0;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+42], 0

; 494  : 
; 495  :       // Set the previous version indicators for both the old and new versions.
; 496  :       // If the old version is linked, mark all of its linked instances as a
; 497  :       // previous version.
; 498  :       lpNewInstance->u.nInd.bPrevVersion = FALSE;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -257				; fffffeffH
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 499  :       lpNewInstance->u.nInd.bPrevVsnRoot = FALSE;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -513				; fffffdffH
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 500  :       lpOldInstance->u.nInd.bPrevVersion = TRUE;

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 256				; 00000100H
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 501  :       lpWrkInstance = zGETPTR( lpOldInstance->hNextLinked );

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 502  :       lpDupInstance = 0;

	mov	DWORD PTR _lpDupInstance$[ebp], 0
$LN10@CreateTemp:

; 503  :       while ( lpWrkInstance && lpWrkInstance != lpOldInstance )

	cmp	DWORD PTR _lpWrkInstance$[ebp], 0
	je	SHORT $LN11@CreateTemp
	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	ecx, DWORD PTR _lpOldInstance$[ebp]
	je	SHORT $LN11@CreateTemp

; 504  :       {
; 505  :          // If the linked instance has a next version, see if that instances next
; 506  :          // version is a child of the starting parent of this version being created.
; 507  :          if ( lpWrkInstance->hNextVsn )

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN41@CreateTemp

; 508  :          {
; 509  :             lpDupInstance = zGETPTR( lpWrkInstance->hNextVsn );

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
$LN12@CreateTemp:

; 510  :             while ( lpDupInstance && lpDupInstance != lpStartNewInstance )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	SHORT $LN13@CreateTemp
	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	cmp	edx, DWORD PTR _lpStartNewInstance$[ebp]
	je	SHORT $LN13@CreateTemp

; 511  :                lpDupInstance = zGETPTR( lpDupInstance->hParent );

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
	jmp	SHORT $LN12@CreateTemp
$LN13@CreateTemp:

; 512  : 
; 513  :             if ( lpDupInstance )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	SHORT $LN41@CreateTemp

; 514  :                lpDupInstance = zGETPTR( lpWrkInstance->hNextVsn );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax
$LN41@CreateTemp:

; 515  :          }
; 516  : 
; 517  :          lpWrkInstance->u.nInd.bPrevVersion = TRUE;

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 256				; 00000100H
	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 518  :          lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 519  :       }

	jmp	$LN10@CreateTemp
$LN11@CreateTemp:

; 520  : 
; 521  :       // Copy the attribute record UNLESS this instance is a duplicate of another
; 522  :       // instance in the same Subobject OR the view entity is not updateable.
; 523  :       lpNewViewEntity = zGETPTR( lpNewInstance->hViewEntity );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntity$2[ebp], eax

; 524  :       if ( lpDupInstance || lpNewViewEntity->bUpdate == FALSE )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	jne	SHORT $LN45@CreateTemp
	mov	edx, DWORD PTR _lpNewViewEntity$2[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 2
	and	eax, 1
	jne	$LN43@CreateTemp
$LN45@CreateTemp:

; 525  :       {
; 526  :          if ( lpDupInstance )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	$LN46@CreateTemp

; 527  :          {
; 528  :             if ( lpDupInstance->hPersistRecord == lpOldInstance->hPersistRecord &&

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	eax, DWORD PTR [ecx+60]
	cmp	eax, DWORD PTR [edx+60]
	jne	SHORT $LN47@CreateTemp
	mov	ecx, DWORD PTR _lpNewViewEntity$2[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN47@CreateTemp

; 529  :                  lpNewViewEntity->bUpdate )
; 530  :             {
; 531  :                lpDupInstance->hPersistRecord =

	push	1
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpOldViewEntity$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	push	eax
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [ecx+60], eax

; 532  :                  fnCopyAttributeRecord( lpAllocTask, lpOldViewEntity,
; 533  :                                         (zPCHAR) zGETPTR( lpOldInstance->hPersistRecord ), 1 );
; 534  : 
; 535  :                lpWrkInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax
$LN14@CreateTemp:

; 536  :                while ( lpWrkInstance && lpWrkInstance != lpDupInstance )

	cmp	DWORD PTR _lpWrkInstance$[ebp], 0
	je	SHORT $LN47@CreateTemp
	mov	ecx, DWORD PTR _lpWrkInstance$[ebp]
	cmp	ecx, DWORD PTR _lpDupInstance$[ebp]
	je	SHORT $LN47@CreateTemp

; 537  :                {
; 538  :                   lpWrkInstance->hPersistRecord = lpDupInstance->hPersistRecord;

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	mov	DWORD PTR [edx+60], ecx

; 539  :                   lpWrkInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 540  :                }

	jmp	SHORT $LN14@CreateTemp
$LN47@CreateTemp:

; 541  :             }
; 542  : 
; 543  :             lpNewInstance->hPersistRecord = lpDupInstance->hPersistRecord;

	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax

; 544  :             if ( lpDupInstance->hNextLinked )

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	cmp	DWORD PTR [ecx+42], 0
	je	SHORT $LN48@CreateTemp

; 545  :                lpNewInstance->hNextLinked = lpDupInstance->hNextLinked;

	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	mov	DWORD PTR [edx+42], ecx
	jmp	SHORT $LN49@CreateTemp
$LN48@CreateTemp:

; 546  :             else
; 547  :                lpNewInstance->hNextLinked = zGETHNDL ( lpDupInstance );

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+42], eax
$LN49@CreateTemp:

; 548  : 
; 549  :             lpDupInstance->hNextLinked = hInstance;

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [edx+42], eax
$LN46@CreateTemp:

; 550  :          }
; 551  :       }

	jmp	SHORT $LN44@CreateTemp
$LN43@CreateTemp:

; 552  :       else
; 553  :       {
; 554  :          lpNewInstance->hPersistRecord =

	push	1
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpOldViewEntity$6[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAllocTask$[ebp]
	push	ecx
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	edx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [edx+60], eax
$LN44@CreateTemp:

; 555  :            fnCopyAttributeRecord( lpAllocTask, lpOldViewEntity,
; 556  :                                   (zPCHAR) zGETPTR( lpOldInstance->hPersistRecord ), 1 );
; 557  :       }
; 558  : 
; 559  :       lpNewInstance->hNonPersistRecord =

	push	0
	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR [eax+64]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpOldViewEntity$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpAllocTask$[ebp]
	push	eax
	call	_fnCopyAttributeRecord
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR [ecx+64], eax

; 560  :         fnCopyAttributeRecord( lpAllocTask, lpOldViewEntity,
; 561  :                                (zPCHAR) zGETPTR( lpOldInstance->
; 562  :                                                     hNonPersistRecord ), 0 );
; 563  :       lpLastOldInstance = lpOldInstance;

	mov	edx, DWORD PTR _lpOldInstance$[ebp]
	mov	DWORD PTR _lpLastOldInstance$[ebp], edx

; 564  :       lpLastNewInstance = lpNewInstance;

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	mov	DWORD PTR _lpLastNewInstance$[ebp], eax

; 565  :       lpOldInstance = zGETPTR( lpOldInstance->hNextHier );

	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOldInstance$[ebp], eax

; 566  : 
; 567  :       fnAddEntityToDebugChange( lpNewInstance );

	mov	eax, DWORD PTR _lpNewInstance$[ebp]
	push	eax
	call	_fnAddEntityToDebugChange@4

; 568  : 
; 569  :    } while ( lpOldInstance && lpOldInstance->nLevel > nStartLevel );

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	SHORT $LN8@CreateTemp
	mov	ecx, DWORD PTR _lpOldInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jg	$LN9@CreateTemp
$LN8@CreateTemp:

; 570  : 
; 571  :    if ( lpNewInstance == 0 ) // if any alloc failed, we're in trouble

	cmp	DWORD PTR _lpNewInstance$[ebp], 0
	jne	$LN51@CreateTemp

; 572  :    {
; 573  :       // We will clean up here and undo the damage we've done to
; 574  :       // the old instances.
; 575  :       if ( lpStartNewInstance )

	cmp	DWORD PTR _lpStartNewInstance$[ebp], 0
	je	$LN52@CreateTemp
$LN18@CreateTemp:

; 576  :       for ( ; ; )
; 577  :       {
; 578  :          lpWrkInstance = zGETPTR( lpStartNewInstance->hNextVsn );

	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+34]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 579  :          lpWrkInstance->hPrevVsn = lpStartNewInstance->hPrevVsn;

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	mov	DWORD PTR [eax+38], edx

; 580  :          lpWrkInstance->u.nInd.bPrevVersion = FALSE;

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, -257				; fffffeffH
	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	DWORD PTR [edx+6], ecx

; 581  :          lpWrkInstance = lpStartNewInstance;

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	DWORD PTR _lpWrkInstance$[ebp], eax

; 582  :          hStartNewInstance  = lpStartNewInstance->hNextHier;

	mov	ecx, DWORD PTR _lpStartNewInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hStartNewInstance$[ebp], edx

; 583  :          lpStartNewInstance = zGETPTR( lpStartNewInstance->hNextHier );

	mov	eax, DWORD PTR _lpStartNewInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartNewInstance$[ebp], eax

; 584  :          fnDeleteAttributeRecord( zGETPTR( lpWrkInstance->hViewEntity ),

	push	1
	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDeleteAttributeRecord
	add	esp, 12					; 0000000cH

; 585  :                                   lpWrkInstance, TRUE );
; 586  : 
; 587  :          lpDupInstance = zGETPTR( lpWrkInstance->hNextLinked );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax

; 588  :          if ( lpDupInstance )

	cmp	DWORD PTR _lpDupInstance$[ebp], 0
	je	SHORT $LN53@CreateTemp
$LN19@CreateTemp:

; 589  :          {
; 590  :             while ( lpDupInstance != lpWrkInstance )

	mov	ecx, DWORD PTR _lpDupInstance$[ebp]
	cmp	ecx, DWORD PTR _lpWrkInstance$[ebp]
	je	SHORT $LN53@CreateTemp

; 591  :             {
; 592  :                lpDupInstance->hPersistRecord = 0;

	mov	edx, DWORD PTR _lpDupInstance$[ebp]
	mov	DWORD PTR [edx+60], 0

; 593  :                lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );

	mov	eax, DWORD PTR _lpDupInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDupInstance$[ebp], eax

; 594  :             }

	jmp	SHORT $LN19@CreateTemp
$LN53@CreateTemp:

; 595  :          }
; 596  : 
; 597  :          fnFreeDataspace( lpWrkInstance );

	mov	edx, DWORD PTR _lpWrkInstance$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 598  :          if ( lpWrkInstance == lpLastNewInstance )

	mov	eax, DWORD PTR _lpWrkInstance$[ebp]
	cmp	eax, DWORD PTR _lpLastNewInstance$[ebp]
	jne	SHORT $LN54@CreateTemp

; 599  :             break;

	jmp	SHORT $LN52@CreateTemp
$LN54@CreateTemp:

; 600  :       }

	jmp	$LN18@CreateTemp
$LN52@CreateTemp:

; 601  : 
; 602  :       fnOperationReturn( iCreateTemporalSubobjectVersion, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	102					; 00000066H
	call	_fnOperationReturn
	add	esp, 8

; 603  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateTemp
$LN51@CreateTemp:

; 604  :    }
; 605  : 
; 606  :    // Mark the starting initial instance as a previous version root.
; 607  :    lpStartOldInstance->u.nInd.bPrevVsnRoot = TRUE;

	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 512				; 00000200H
	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 608  :    lpStartOldInstance->hPrevHier = 0;

	mov	edx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR [edx+18], 0

; 609  :    lpStartOldInstance->hNextTwin = 0;

	mov	eax, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR [eax+22], 0

; 610  :    lpStartOldInstance->hPrevTwin = 0;

	mov	ecx, DWORD PTR _lpStartOldInstance$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 611  : 
; 612  :    lpLastOldInstance->hNextHier = 0;

	mov	edx, DWORD PTR _lpLastOldInstance$[ebp]
	mov	DWORD PTR [edx+14], 0

; 613  : 
; 614  :    // If lpOldInstance exists set its previous hierarchical pointer.
; 615  :    if ( lpOldInstance )

	cmp	DWORD PTR _lpOldInstance$[ebp], 0
	je	SHORT $LN55@CreateTemp

; 616  :       lpOldInstance->hPrevHier = hInstance;

	mov	eax, DWORD PTR _lpOldInstance$[ebp]
	mov	ecx, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR [eax+18], ecx
$LN55@CreateTemp:

; 617  : 
; 618  :    // If the root of the instance is being versioned, set the
; 619  :    // root entity instance pointer in the ViewOI.
; 620  :    if ( zGETPTR( lpViewOI->hRootEntityInstance ) == lpStartOldInstance )

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpStartOldInstance$[ebp]
	jne	SHORT $LN56@CreateTemp

; 621  :       lpViewOI->hRootEntityInstance = hStartNewInstance;

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR _hStartNewInstance$[ebp]
	mov	DWORD PTR [ecx+26], edx
$LN56@CreateTemp:

; 622  : 
; 623  :    // Set the cursor to the new instance
; 624  :    lpViewEntityCsr->hEntityInstance = hStartNewInstance;

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _hStartNewInstance$[ebp]
	mov	DWORD PTR [eax+26], ecx

; 625  : // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 626  : //    SysMessageBox( 0, "CreateTemporalSubobjectVersion", "UNSET_CSR", -1 );
; 627  : 
; 628  :    fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 629  : 
; 630  :    // Now go through all views for the old object and update any cursors
; 631  :    // positioned on the previous instance to point to the new version.
; 632  :    for ( lpWrkViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
	jmp	SHORT $LN23@CreateTemp
$LN21@CreateTemp:

; 634  :          lpWrkViewCsr = zGETPTR( lpWrkViewCsr->hNextViewCsr ) )

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewCsr$[ebp], eax
$LN23@CreateTemp:

; 633  :          lpWrkViewCsr;

	cmp	DWORD PTR _lpWrkViewCsr$[ebp], 0
	je	SHORT $LN22@CreateTemp

; 635  :    {
; 636  :       if ( lpWrkViewCsr == lpViewCsr )

	mov	ecx, DWORD PTR _lpWrkViewCsr$[ebp]
	cmp	ecx, DWORD PTR _lpViewCsr$[ebp]
	jne	SHORT $LN57@CreateTemp

; 637  :          continue;

	jmp	SHORT $LN21@CreateTemp
$LN57@CreateTemp:

; 638  : 
; 639  :       lpWrkViewEntityCsr = zGETPTR( lpWrkViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpWrkViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWrkViewEntityCsr$[ebp], eax

; 640  :       lpWrkViewEntityCsr += (lpViewEntity->nHierNbr - 1);

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	sub	edx, 1
	imul	eax, edx, 30
	add	eax, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	DWORD PTR _lpWrkViewEntityCsr$[ebp], eax

; 641  : 
; 642  :       if ( zGETPTR( lpWrkViewEntityCsr->hEntityInstance ) == lpStartOldInstance )

	mov	ecx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpStartOldInstance$[ebp]
	jne	SHORT $LN58@CreateTemp

; 643  :       {
; 644  :          lpWrkViewEntityCsr->hEntityInstance = hStartNewInstance;

	mov	eax, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _hStartNewInstance$[ebp]
	mov	DWORD PTR [eax+26], ecx

; 645  :       // if ( lpWrkViewEntityCsr->hEntityInstance == UNSET_CSR )
; 646  :       //    SysMessageBox( 0, "CreateTemporalSubobjectVersion2", "UNSET_CSR", -1 );
; 647  : 
; 648  :          fnResetCursorForViewChildren( lpWrkViewEntityCsr );

	mov	edx, DWORD PTR _lpWrkViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN58@CreateTemp:

; 649  :       }
; 650  :    }

	jmp	SHORT $LN21@CreateTemp
$LN22@CreateTemp:

; 651  : 
; 652  :    // Increment versioned instance count in viewoi.
; 653  :    lpViewOI->nVersionedInstances++;

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	cx, WORD PTR [eax+22]
	add	cx, 1
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	WORD PTR [edx+22], cx

; 654  : 
; 655  : #if 0   // Gig, debugging, for all new instances, see if a record
; 656  :         // match can be found which is not linked!!!!
; 657  :    lpNewInstance      = lpStartNewInstance;
; 658  :    do
; 659  :    {
; 660  :       lpWrkInstance = zGETPTR( lpNewInstance->hNextHier );
; 661  :       while ( lpWrkInstance && lpWrkInstance->nLevel > nStartLevel )
; 662  :       {
; 663  :          if ( lpWrkInstance->hPersistRecord == lpNewInstance->hPersistRecord )
; 664  :          {
; 665  :             lpDupInstance = zGETPTR( lpNewInstance->hNextLinked );
; 666  :             while ( lpDupInstance && lpDupInstance != lpNewInstance )
; 667  :             {
; 668  :                if ( lpDupInstance == lpWrkInstance )
; 669  :                   break;
; 670  : 
; 671  :                lpDupInstance = zGETPTR( lpDupInstance->hNextLinked );
; 672  :             }
; 673  : 
; 674  :             if ( lpDupInstance != lpWrkInstance )
; 675  :             {
; 676  :                SysMessageBox( "ERROR AFTER CREATE",
; 677  :                               "Record match found in non-linked instance", 1 );
; 678  :             }
; 679  :          }
; 680  : 
; 681  :          lpWrkInstance = zGETPTR( lpWrkInstance->hNextHier );
; 682  :       }
; 683  : 
; 684  :       lpNewInstance = zGETPTR( lpNewInstance->hNextHier );
; 685  : 
; 686  :    } while ( lpNewInstance && lpNewInstance->nLevel > nStartLevel );
; 687  : #endif
; 688  : 
; 689  :    // return to sender
; 690  :    fnOperationReturn( iCreateTemporalSubobjectVersion, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	102					; 00000066H
	call	_fnOperationReturn
	add	esp, 8

; 691  :    return( 0 );  // We think everything was OK

	xor	eax, eax
$LN1@CreateTemp:

; 692  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CreateTemporalSubobjectVersion@8 ENDP
_TEXT	ENDS
END
