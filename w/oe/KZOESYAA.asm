; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\w\oe\KZOESYAA.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_ZeidonPageTable
PUBLIC	_g_FileMappingHandles
PUBLIC	_g_hAnchorBlock
PUBLIC	_AnchorBlock
PUBLIC	_g_bServerMode
PUBLIC	_szlReleaseCompatible
PUBLIC	_szlReleaseCurrent
PUBLIC	_szlShareSeg
PUBLIC	_g_nOE_TraceWarning
PUBLIC	_g_vRealTaskView
PUBLIC	_g_ulMaxRecordStringLth
PUBLIC	_g_vDefaultTaskView
PUBLIC	_cDirSep
PUBLIC	_g_lProcessID
PUBLIC	_szObjectEngineName
PUBLIC	_szObjectEngineDll
PUBLIC	_szObjectSuffix
PUBLIC	_szDllSuffix
PUBLIC	_lpNullP
PUBLIC	_szNullS
PUBLIC	_lNullInteger
PUBLIC	_stNullDateTime
PUBLIC	_g_ZeidonMutexTable
PUBLIC	_pHab
PUBLIC	_hModule
PUBLIC	_g_ZeidonMutexName
PUBLIC	_szlZEIDON
PUBLIC	_szlAppFile
PUBLIC	_szlDomainFile
PUBLIC	_szlSystemDomainFile
PUBLIC	_szlMessageObject
PUBLIC	_szlNewPortableHeader
PUBLIC	_szlmZeidon
PUBLIC	_szlAPPLICATION
PUBLIC	_szlOBJECT
PUBLIC	_szlENTITY
PUBLIC	_szlCHILDENTITY
PUBLIC	_szlATTRIB
PUBLIC	_szlDOMAIN
PUBLIC	_szlMODEL
PUBLIC	_szlCONTEXT
PUBLIC	_szlNLS_TABLEENTRY
PUBLIC	_szlTABLEENTRY
PUBLIC	_szlREGULAREXPRESSION
PUBLIC	_szlZEIDON_BIN
PUBLIC	_szlZEIDON_SYS
PUBLIC	_szlZEIDON_LOC
PUBLIC	_szlZEIDON_SHR
PUBLIC	_szlAPP_NAME
PUBLIC	_szlAPP_DFLT_Dialog
PUBLIC	_szlAPP_DLL
PUBLIC	_szlAPP_ADOBIN
PUBLIC	_g_wOENG_Message
PUBLIC	_g_wClientMessage
PUBLIC	_szlAPP_LOCAL
PUBLIC	_szlAPP_SHARED
PUBLIC	_g_bWin95
PUBLIC	_g_ZeidonMutexLockCnt
PUBLIC	_szlAPP_QLPLR
PUBLIC	_szlAPP_QXODS
PUBLIC	_szlAPP_SOURCE
PUBLIC	_szlAPDM_TOK
PUBLIC	_szlATTRIBUTETYPE
PUBLIC	_szlATTRIBUTEDECIMAL
PUBLIC	_szlAUTOCREATE
PUBLIC	_szlAUTOLOADFROMPARENT
PUBLIC	_szlAUTO_SEQ
PUBLIC	_g_hInstance
PUBLIC	_szlXVAATT_TOK
PUBLIC	_g_bProcessRegistered
PUBLIC	_szlNT_ThreadClassName
PUBLIC	_szlCARDMAX
PUBLIC	_g_lProcessIdx
PUBLIC	_szlCARDMIN
PUBLIC	_szlCASESENS
PUBLIC	_szlCONTEXTRESTRICTION
PUBLIC	_szlCREATE
PUBLIC	_szlCR_DATE
PUBLIC	_szlDATAFIELD
PUBLIC	_szlDATARECORD
PUBLIC	_szlDATATYPE
PUBLIC	_szlDBNAME
PUBLIC	_szlDECIMAL
PUBLIC	_szlDECIMALFORMAT
PUBLIC	_szlDELETE
PUBLIC	_szlDERIVED
PUBLIC	_szlDERIVEDF
PUBLIC	_szlDFT_DBNAME
PUBLIC	_szlDFT_SERVER
PUBLIC	_szlDLL_NAME
PUBLIC	_szlDOMAINTYPE
PUBLIC	_szlDUPENTIN
PUBLIC	_szlDUPRELIN
PUBLIC	_szlECACC
PUBLIC	_szlECCAN
PUBLIC	_szlECCR
PUBLIC	_szlECDEL
PUBLIC	_szlECEOPER
PUBLIC	_szlECEXC
PUBLIC	_szlECINC
PUBLIC	_szlEDITSTRING
PUBLIC	_szlERATT_TOK
PUBLIC	_szlEntityName
PUBLIC	_szlEntitySpec
PUBLIC	_szlERENT_TOK
PUBLIC	_szlERREL_LINK
PUBLIC	_szlERREL_TOK
PUBLIC	_szlEXCLUDE
PUBLIC	_szlEXTERNALVALUE
PUBLIC	_szlFLDID
PUBLIC	_szlFLDLTH
PUBLIC	_szlFLDNAME
PUBLIC	_szlFLDOFFSET
PUBLIC	_szlFLDTYPE
PUBLIC	_szlFULLPERSIST
PUBLIC	_szlGENKEY
PUBLIC	_szlGKHANDLER
PUBLIC	_szlHANDLER
PUBLIC	_szlHIDDEN
PUBLIC	_szlId
PUBLIC	_szlINCLSRC
PUBLIC	_szlINCLUDE
PUBLIC	_szlINCRLOAD
PUBLIC	_szlINIT
PUBLIC	_szlINTERNALVALUE
PUBLIC	_szlISDEFAULT
PUBLIC	_szlKEY
PUBLIC	_szlLanguageIndex
PUBLIC	_szlLNAME
PUBLIC	_szlLOCK
PUBLIC	_szlLTH
PUBLIC	_szlMAXSTRINGLTH
PUBLIC	_szlMR_LIMIT
PUBLIC	_szl__MSGQ
PUBLIC	_szlNAME
PUBLIC	_szlNETCOMPRESS
PUBLIC	_szlNETWORK
PUBLIC	_szlNumAtts
PUBLIC	_szlNumEnts
PUBLIC	_szlNumRels
PUBLIC	_szlOCACT
PUBLIC	_szlOCACTE
PUBLIC	_szlOCCOM
PUBLIC	_szlOCDROP
PUBLIC	_szlOCEOPER
PUBLIC	_szlOFRECID
PUBLIC	_szlOFBUFSZ
PUBLIC	_szlOPER_LIBNM
PUBLIC	_szlOper
PUBLIC	_szlOWNER_MEMB
PUBLIC	_szlPDELETE
PUBLIC	_szlPERSIST
PUBLIC	_szlPNAME
PUBLIC	_szlQualAttrib
PUBLIC	_szlRECID
PUBLIC	_szlRECNAME
PUBLIC	_szlRECURSIVE
PUBLIC	_szlREL
PUBLIC	_szlRELFIELD
PUBLIC	_szlRELRECORD
PUBLIC	_szlRELXVAATT_TOK
PUBLIC	_szlREQUIRED
PUBLIC	_szlRESTRICTED
PUBLIC	_szlSERVER
PUBLIC	_szlSEQUENCING
PUBLIC	_szlSEQ_AD
PUBLIC	_szlSETID1
PUBLIC	_szlSETID2
PUBLIC	_szlSETNAME1
PUBLIC	_szlSETNAME2
PUBLIC	_szlSRCXVAATT_TOK
PUBLIC	_szlTask
PUBLIC	_szlText
PUBLIC	_szlTYPE
PUBLIC	_szlUP_DATE
PUBLIC	_szlUSERID
PUBLIC	_szlUPDATE
PUBLIC	_szlZKEY
PUBLIC	_szlApplicationLogicError
PUBLIC	_szlDataValidationError
PUBLIC	_szlOE_SystemError
PUBLIC	_szlAFTER
PUBLIC	_szlBEFORE
PUBLIC	_g_pchMQI
PUBLIC	_szGAFANullS
PUBLIC	_g_pchMon
PUBLIC	_g_pchDOW
PUBLIC	_szlINTL
PUBLIC	_szlICOUNTRY
PUBLIC	_szlSCOUNTRY
PUBLIC	_szlSLANGUAGE
PUBLIC	_szlSLIST
PUBLIC	_szlIMEASURE
PUBLIC	_szlITIME
PUBLIC	_szlSTIME
PUBLIC	_szlS1159
PUBLIC	_szlS2359
PUBLIC	_szlITLZERO
PUBLIC	_szlSSHORTDATE
PUBLIC	_szlSLONGDATE
PUBLIC	_szlSCURRENCY
PUBLIC	_szlICURRENCY
PUBLIC	_szlICURRDIGITS
PUBLIC	_szlINEGCURR
PUBLIC	_szlSTHOUSAND
PUBLIC	_szlSDECIMAL
PUBLIC	_szlIDIGITS
PUBLIC	_szlILZERO
_BSS	SEGMENT
$SG100441 DB	01H DUP (?)
	ALIGN	4

$SG93341 DB	01H DUP (?)
	ALIGN	4

$SG100683 DB	01H DUP (?)
	ALIGN	4

$SG93527 DB	01H DUP (?)
	ALIGN	4

$SG100728 DB	01H DUP (?)
	ALIGN	4

$SG98710 DB	01H DUP (?)
	ALIGN	4

$SG100770 DB	01H DUP (?)
	ALIGN	4

$SG100787 DB	01H DUP (?)
	ALIGN	4

$SG98792 DB	01H DUP (?)
	ALIGN	4

$SG100841 DB	01H DUP (?)
	ALIGN	4

$SG99842 DB	01H DUP (?)
	ALIGN	4

_g_ZeidonPageTable DD 0100H DUP (?)
_g_FileMappingHandles DD 0100H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_pfnGetPtr:DWORD
COMM	_g_pfnGetHndl:DWORD
_DATA	ENDS
_BSS	SEGMENT
_g_hAnchorBlock DD 01H DUP (?)
_AnchorBlock DD	01H DUP (?)
_g_bServerMode DB 01H DUP (?)
	ALIGN	4

_g_nOE_TraceWarning DW 01H DUP (?)
	ALIGN	4

_g_vRealTaskView DD 01H DUP (?)
_g_vDefaultTaskView DD 01H DUP (?)
_g_lProcessID DD 01H DUP (?)
_lpNullP DD	01H DUP (?)
$SG92782 DB	09H DUP (?)
	ALIGN	4

_g_ZeidonMutexTable DD 010H DUP (?)
_pHab	DD	01H DUP (?)
_hModule DD	01H DUP (?)
_g_wOENG_Message DD 01H DUP (?)
_g_wClientMessage DD 01H DUP (?)
_g_ZeidonMutexLockCnt DD 010H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_ZeidonCritTable:BYTE:0180H
COMM	_g_csSysLoadLibrary:BYTE:018H
COMM	_g_csReuseEntity:BYTE:018H
_DATA	ENDS
_BSS	SEGMENT
$SG98993 DB	01H DUP (?)
	ALIGN	4

$SG98997 DB	01H DUP (?)
	ALIGN	4

_g_hInstance DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_hThreadInfo:DWORD
_DATA	ENDS
_BSS	SEGMENT
_g_bProcessRegistered DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_lCurrentProcessID:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

$SG98129 DB	01H DUP (?)
	ALIGN	4

$SG98136 DB	01H DUP (?)
	ALIGN	4

?szLastDateTime@?2??SysMessageList@@9@9 DB 014H DUP (?)	; `SysMessageList'::`3'::szLastDateTime
$SG98158 DB	01H DUP (?)
	ALIGN	4

$SG100220 DB	01H DUP (?)
	ALIGN	4

$SG100222 DB	01H DUP (?)
	ALIGN	4

$SG100224 DB	01H DUP (?)
	ALIGN	4

$SG98177 DB	01H DUP (?)
	ALIGN	4

$SG100226 DB	01H DUP (?)
	ALIGN	4

$SG100231 DB	01H DUP (?)
	ALIGN	4

$SG100235 DB	01H DUP (?)
	ALIGN	4

$SG93092 DB	09H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	_g_lTable:DWORD:0aH
_DATA	ENDS
CONST	SEGMENT
_OperationMsgTable DW 0aH
	DD	FLAT:$SG93343
	DW	0bH
	DD	FLAT:$SG93344
	DW	0cH
	DD	FLAT:$SG93345
	DW	0dH
	DD	FLAT:$SG93346
	DW	014H
	DD	FLAT:$SG93347
	DW	015H
	DD	FLAT:$SG93348
	DW	018H
	DD	FLAT:$SG93349
	DW	0d7H
	DD	FLAT:$SG93350
	DW	0d8H
	DD	FLAT:$SG93351
	DW	032H
	DD	FLAT:$SG93352
	DW	034H
	DD	FLAT:$SG93353
	DW	036H
	DD	FLAT:$SG93354
	DW	0227H
	DD	FLAT:$SG93355
	DW	0228H
	DD	FLAT:$SG93356
	DW	037H
	DD	FLAT:$SG93357
	DW	03cH
	DD	FLAT:$SG93358
	DW	03eH
	DD	FLAT:$SG93359
	DW	03fH
	DD	FLAT:$SG93360
	DW	040H
	DD	FLAT:$SG93361
	DW	03dH
	DD	FLAT:$SG93362
	DW	046H
	DD	FLAT:$SG93363
	DW	064H
	DD	FLAT:$SG93364
	DW	0196H
	DD	FLAT:$SG93365
	DW	065H
	DD	FLAT:$SG93366
	DW	06cH
	DD	FLAT:$SG93367
	DW	073H
	DD	FLAT:$SG93368
	DW	066H
	DD	FLAT:$SG93369
	DW	067H
	DD	FLAT:$SG93370
	DW	07fH
	DD	FLAT:$SG93371
	DW	068H
	DD	FLAT:$SG93372
	DW	080H
	DD	FLAT:$SG93373
	DW	069H
	DD	FLAT:$SG93374
	DW	085H
	DD	FLAT:$SG93375
	DW	086H
	DD	FLAT:$SG93376
	DW	06aH
	DD	FLAT:$SG93377
	DW	06bH
	DD	FLAT:$SG93378
	DW	07eH
	DD	FLAT:$SG93379
	DW	06eH
	DD	FLAT:$SG93380
	DW	096H
	DD	FLAT:$SG93381
	DW	097H
	DD	FLAT:$SG93382
	DW	098H
	DD	FLAT:$SG93383
	DW	099H
	DD	FLAT:$SG93384
	DW	0aaH
	DD	FLAT:$SG93385
	DW	0abH
	DD	FLAT:$SG93386
	DW	0acH
	DD	FLAT:$SG93387
	DW	0adH
	DD	FLAT:$SG93388
	DW	0aeH
	DD	FLAT:$SG93389
	DW	0afH
	DD	FLAT:$SG93390
	DW	0b0H
	DD	FLAT:$SG93391
	DW	0b1H
	DD	FLAT:$SG93392
	DW	0b2H
	DD	FLAT:$SG93393
	DW	0b3H
	DD	FLAT:$SG93394
	DW	0b4H
	DD	FLAT:$SG93395
	DW	0b5H
	DD	FLAT:$SG93396
	DW	0b6H
	DD	FLAT:$SG93397
	DW	0b7H
	DD	FLAT:$SG93398
	DW	0beH
	DD	FLAT:$SG93399
	DW	0bfH
	DD	FLAT:$SG93400
	DW	0c0H
	DD	FLAT:$SG93401
	DW	0c8H
	DD	FLAT:$SG93402
	DW	0c9H
	DD	FLAT:$SG93403
	DW	0caH
	DD	FLAT:$SG93404
	DW	0cbH
	DD	FLAT:$SG93405
	DW	0ccH
	DD	FLAT:$SG93406
	DW	0cdH
	DD	FLAT:$SG93407
	DW	0ceH
	DD	FLAT:$SG93408
	DW	0cfH
	DD	FLAT:$SG93409
	DW	0d0H
	DD	FLAT:$SG93410
	DW	0d1H
	DD	FLAT:$SG93411
	DW	0d2H
	DD	FLAT:$SG93412
	DW	0d5H
	DD	FLAT:$SG93413
	DW	0d6H
	DD	FLAT:$SG93414
	DW	0d3H
	DD	FLAT:$SG93415
	DW	0d4H
	DD	FLAT:$SG93416
	DW	0d9H
	DD	FLAT:$SG93417
	DW	0deH
	DD	FLAT:$SG93418
	DW	0e0H
	DD	FLAT:$SG93419
	DW	0dfH
	DD	FLAT:$SG93420
	DW	0feH
	DD	FLAT:$SG93421
	DW	0ffH
	DD	FLAT:$SG93422
	DW	0faH
	DD	FLAT:$SG93423
	DW	0fbH
	DD	FLAT:$SG93424
	DW	0fcH
	DD	FLAT:$SG93425
	DW	0fdH
	DD	FLAT:$SG93426
	DW	0102H
	DD	FLAT:$SG93427
	DW	0103H
	DD	FLAT:$SG93428
	DW	0117H
	DD	FLAT:$SG93429
	DW	0104H
	DD	FLAT:$SG93430
	DW	0105H
	DD	FLAT:$SG93431
	DW	0106H
	DD	FLAT:$SG93432
	DW	0107H
	DD	FLAT:$SG93433
	DW	0108H
	DD	FLAT:$SG93434
	DW	0109H
	DD	FLAT:$SG93435
	DW	0115H
	DD	FLAT:$SG93436
	DW	011aH
	DD	FLAT:$SG93437
	DW	011bH
	DD	FLAT:$SG93438
	DW	0114H
	DD	FLAT:$SG93439
	DW	0124H
	DD	FLAT:$SG93440
	DW	0123H
	DD	FLAT:$SG93441
	DW	010aH
	DD	FLAT:$SG93442
	DW	010bH
	DD	FLAT:$SG93443
	DW	010cH
	DD	FLAT:$SG93444
	DW	011dH
	DD	FLAT:$SG93445
	DW	010eH
	DD	FLAT:$SG93446
	DW	010fH
	DD	FLAT:$SG93447
	DW	0110H
	DD	FLAT:$SG93448
	DW	0111H
	DD	FLAT:$SG93449
	DW	0116H
	DD	FLAT:$SG93450
	DW	0112H
	DD	FLAT:$SG93451
	DW	0113H
	DD	FLAT:$SG93452
	DW	0118H
	DD	FLAT:$SG93453
	DW	0119H
	DD	FLAT:$SG93454
	DW	0190H
	DD	FLAT:$SG93455
	DW	0191H
	DD	FLAT:$SG93456
	DW	0192H
	DD	FLAT:$SG93457
	DW	011cH
	DD	FLAT:$SG93458
	DW	012aH
	DD	FLAT:$SG93459
	DW	012aH
	DD	FLAT:$SG93460
	DW	015eH
	DD	FLAT:$SG93461
	DW	015fH
	DD	FLAT:$SG93462
	DW	0160H
	DD	FLAT:$SG93463
	DW	081H
	DD	FLAT:$SG93464
	DW	070H
	DD	FLAT:$SG93465
	DW	071H
	DD	FLAT:$SG93466
	DW	072H
	DD	FLAT:$SG93467
	DW	074H
	DD	FLAT:$SG93468
	DW	079H
	DD	FLAT:$SG93469
	DW	075H
	DD	FLAT:$SG93470
	DW	076H
	DD	FLAT:$SG93471
	DW	082H
	DD	FLAT:$SG93472
	DW	011eH
	DD	FLAT:$SG93473
	DW	011fH
	DD	FLAT:$SG93474
	DW	0120H
	DD	FLAT:$SG93475
	DW	0b8H
	DD	FLAT:$SG93476
	DW	0122H
	DD	FLAT:$SG93477
	DW	01c2H
	DD	FLAT:$SG93478
	DW	0193H
	DD	FLAT:$SG93479
	DW	0194H
	DD	FLAT:$SG93480
	DW	0baH
	DD	FLAT:$SG93481
	DW	0c1H
	DD	FLAT:$SG93482
	DW	0bbH
	DD	FLAT:$SG93483
	DW	07aH
	DD	FLAT:$SG93484
	DW	07bH
	DD	FLAT:$SG93485
	DW	07dH
	DD	FLAT:$SG93486
	DW	07cH
	DD	FLAT:$SG93487
	DW	01c5H
	DD	FLAT:$SG93488
	DW	0168H
	DD	FLAT:$SG93489
	DW	0169H
	DD	FLAT:$SG93490
	DW	016aH
	DD	FLAT:$SG93491
	DW	016bH
	DD	FLAT:$SG93492
	DW	01c6H
	DD	FLAT:$SG93493
	DW	01c4H
	DD	FLAT:$SG93494
	DW	01c3H
	DD	FLAT:$SG93495
	DW	01c7H
	DD	FLAT:$SG93496
	DW	01c8H
	DD	FLAT:$SG93497
	DW	01caH
	DD	FLAT:$SG93498
	DW	0172H
	DD	FLAT:$SG93499
	DW	0125H
	DD	FLAT:$SG93500
	DW	01cbH
	DD	FLAT:$SG93501
	DW	01f4H
	DD	FLAT:$SG93502
	DW	01f6H
	DD	FLAT:$SG93503
	DW	01f5H
	DD	FLAT:$SG93504
	DW	01f7H
	DD	FLAT:$SG93505
	DW	01f8H
	DD	FLAT:$SG93506
	DW	01fdH
	DD	FLAT:$SG93507
	DW	01faH
	DD	FLAT:$SG93508
	DW	01fbH
	DD	FLAT:$SG93509
	DW	01fcH
	DD	FLAT:$SG93510
	DW	01f9H
	DD	FLAT:$SG93511
	DW	01feH
	DD	FLAT:$SG93512
	DW	01ffH
	DD	FLAT:$SG93513
	DW	0200H
	DD	FLAT:$SG93514
	DW	0201H
	DD	FLAT:$SG93515
	DW	0202H
	DD	FLAT:$SG93516
	DW	0203H
	DD	FLAT:$SG93517
	DW	077H
	DD	FLAT:$SG93518
	DW	078H
	DD	FLAT:$SG93519
	DW	0128H
	DD	FLAT:$SG93520
	DW	0129H
	DD	FLAT:$SG93521
	DW	01cH
	DD	FLAT:$SG93522
	DW	041H
	DD	FLAT:$SG93523
	DW	0226H
	DD	FLAT:$SG93524
	DW	0229H
	DD	FLAT:$SG93525
	DW	022aH
	DD	FLAT:$SG93526
	DW	0270fH
	DD	FLAT:$SG93527
	ORG $+2
_BaseMsgTable DW 01H
	DD	FLAT:$SG93161
	DW	02H
	DD	FLAT:$SG93162
	DW	03H
	DD	FLAT:$SG93163
	DW	04H
	DD	FLAT:$SG93164
	DW	05H
	DD	FLAT:$SG93165
	DW	06H
	DD	FLAT:$SG93166
	DW	07H
	DD	FLAT:$SG93167
	DW	08H
	DD	FLAT:$SG93168
	DW	09H
	DD	FLAT:$SG93169
	DW	0aH
	DD	FLAT:$SG93170
	DW	0bH
	DD	FLAT:$SG93171
	DW	0cH
	DD	FLAT:$SG93172
	DW	0dH
	DD	FLAT:$SG93173
	DW	0eH
	DD	FLAT:$SG93174
	DW	0fH
	DD	FLAT:$SG93175
	DW	010H
	DD	FLAT:$SG93176
	DW	011H
	DD	FLAT:$SG93177
	DW	012H
	DD	FLAT:$SG93178
	DW	013H
	DD	FLAT:$SG93179
	DW	014H
	DD	FLAT:$SG93180
	DW	015H
	DD	FLAT:$SG93181
	DW	016H
	DD	FLAT:$SG93182
	DW	017H
	DD	FLAT:$SG93183
	DW	018H
	DD	FLAT:$SG93184
	DW	019H
	DD	FLAT:$SG93185
	DW	01aH
	DD	FLAT:$SG93186
	DW	01eH
	DD	FLAT:$SG93187
	DW	01fH
	DD	FLAT:$SG93188
	DW	020H
	DD	FLAT:$SG93189
	DW	032H
	DD	FLAT:$SG93190
	DW	033H
	DD	FLAT:$SG93191
	DW	034H
	DD	FLAT:$SG93192
	DW	035H
	DD	FLAT:$SG93193
	DW	036H
	DD	FLAT:$SG93194
	DW	037H
	DD	FLAT:$SG93195
	DW	038H
	DD	FLAT:$SG93196
	DW	039H
	DD	FLAT:$SG93197
	DW	03aH
	DD	FLAT:$SG93198
	DW	03bH
	DD	FLAT:$SG93199
	DW	03cH
	DD	FLAT:$SG93200
	DW	03dH
	DD	FLAT:$SG93201
	DW	03eH
	DD	FLAT:$SG93202
	DW	03fH
	DD	FLAT:$SG93203
	DW	040H
	DD	FLAT:$SG93204
	DW	041H
	DD	FLAT:$SG93205
	DW	042H
	DD	FLAT:$SG93206
	DW	043H
	DD	FLAT:$SG93207
	DW	046H
	DD	FLAT:$SG93208
	DW	047H
	DD	FLAT:$SG93209
	DW	048H
	DD	FLAT:$SG93210
	DW	049H
	DD	FLAT:$SG93211
	DW	04aH
	DD	FLAT:$SG93212
	DW	04bH
	DD	FLAT:$SG93213
	DW	04cH
	DD	FLAT:$SG93214
	DW	04dH
	DD	FLAT:$SG93215
	DW	04eH
	DD	FLAT:$SG93216
	DW	04fH
	DD	FLAT:$SG93217
	DW	050H
	DD	FLAT:$SG93218
	DW	051H
	DD	FLAT:$SG93219
	DW	052H
	DD	FLAT:$SG93220
	DW	053H
	DD	FLAT:$SG93221
	DW	054H
	DD	FLAT:$SG93222
	DW	055H
	DD	FLAT:$SG93223
	DW	056H
	DD	FLAT:$SG93224
	DW	057H
	DD	FLAT:$SG93225
	DW	058H
	DD	FLAT:$SG93226
	DW	05aH
	DD	FLAT:$SG93227
	DW	05bH
	DD	FLAT:$SG93228
	DW	05cH
	DD	FLAT:$SG93229
	DW	05dH
	DD	FLAT:$SG93230
	DW	05eH
	DD	FLAT:$SG93231
	DW	05fH
	DD	FLAT:$SG93232
	DW	060H
	DD	FLAT:$SG93233
	DW	064H
	DD	FLAT:$SG93234
	DW	065H
	DD	FLAT:$SG93235
	DW	066H
	DD	FLAT:$SG93236
	DW	067H
	DD	FLAT:$SG93237
	DW	068H
	DD	FLAT:$SG93238
	DW	069H
	DD	FLAT:$SG93239
	DW	06aH
	DD	FLAT:$SG93240
	DW	06bH
	DD	FLAT:$SG93241
	DW	06cH
	DD	FLAT:$SG93242
	DW	06dH
	DD	FLAT:$SG93243
	DW	06eH
	DD	FLAT:$SG93244
	DW	06fH
	DD	FLAT:$SG93245
	DW	070H
	DD	FLAT:$SG93246
	DW	071H
	DD	FLAT:$SG93247
	DW	072H
	DD	FLAT:$SG93248
	DW	073H
	DD	FLAT:$SG93249
	DW	074H
	DD	FLAT:$SG93250
	DW	075H
	DD	FLAT:$SG93251
	DW	076H
	DD	FLAT:$SG93252
	DW	077H
	DD	FLAT:$SG93253
	DW	078H
	DD	FLAT:$SG93254
	DW	079H
	DD	FLAT:$SG93255
	DW	07aH
	DD	FLAT:$SG93256
	DW	07cH
	DD	FLAT:$SG93257
	DW	07dH
	DD	FLAT:$SG93258
	DW	07eH
	DD	FLAT:$SG93259
	DW	07fH
	DD	FLAT:$SG93260
	DW	080H
	DD	FLAT:$SG93261
	DW	081H
	DD	FLAT:$SG93262
	DW	083H
	DD	FLAT:$SG93263
	DW	084H
	DD	FLAT:$SG93264
	DW	086H
	DD	FLAT:$SG93265
	DW	087H
	DD	FLAT:$SG93266
	DW	088H
	DD	FLAT:$SG93267
	DW	089H
	DD	FLAT:$SG93268
	DW	08aH
	DD	FLAT:$SG93269
	DW	08bH
	DD	FLAT:$SG93270
	DW	08cH
	DD	FLAT:$SG93271
	DW	08dH
	DD	FLAT:$SG93272
	DW	0beH
	DD	FLAT:$SG93273
	DW	0bfH
	DD	FLAT:$SG93274
	DW	0e7H
	DD	FLAT:$SG93275
	DW	0e8H
	DD	FLAT:$SG93276
	DW	0e9H
	DD	FLAT:$SG93277
	DW	0eaH
	DD	FLAT:$SG93278
	DW	0ebH
	DD	FLAT:$SG93279
	DW	0ecH
	DD	FLAT:$SG93280
	DW	0edH
	DD	FLAT:$SG93281
	DW	0eeH
	DD	FLAT:$SG93282
	DW	0efH
	DD	FLAT:$SG93283
	DW	0f0H
	DD	FLAT:$SG93284
	DW	0f1H
	DD	FLAT:$SG93285
	DW	0f2H
	DD	FLAT:$SG93286
	DW	0f3H
	DD	FLAT:$SG93287
	DW	0f4H
	DD	FLAT:$SG93288
	DW	0f5H
	DD	FLAT:$SG93289
	DW	0f6H
	DD	FLAT:$SG93290
	DW	0f7H
	DD	FLAT:$SG93291
	DW	0f8H
	DD	FLAT:$SG93292
	DW	0faH
	DD	FLAT:$SG93293
	DW	0fcH
	DD	FLAT:$SG93294
	DW	0fdH
	DD	FLAT:$SG93295
	DW	0feH
	DD	FLAT:$SG93296
	DW	0ffH
	DD	FLAT:$SG93297
	DW	0100H
	DD	FLAT:$SG93298
	DW	0101H
	DD	FLAT:$SG93299
	DW	0102H
	DD	FLAT:$SG93300
	DW	0103H
	DD	FLAT:$SG93301
	DW	0107H
	DD	FLAT:$SG93302
	DW	0108H
	DD	FLAT:$SG93303
	DW	0109H
	DD	FLAT:$SG93304
	DW	010aH
	DD	FLAT:$SG93305
	DW	010bH
	DD	FLAT:$SG93306
	DW	010cH
	DD	FLAT:$SG93307
	DW	010dH
	DD	FLAT:$SG93308
	DW	010eH
	DD	FLAT:$SG93309
	DW	010fH
	DD	FLAT:$SG93310
	DW	0110H
	DD	FLAT:$SG93311
	DW	0111H
	DD	FLAT:$SG93312
	DW	0112H
	DD	FLAT:$SG93313
	DW	012cH
	DD	FLAT:$SG93314
	DW	012dH
	DD	FLAT:$SG93315
	DW	012eH
	DD	FLAT:$SG93316
	DW	014aH
	DD	FLAT:$SG93317
	DW	015eH
	DD	FLAT:$SG93318
	DW	015fH
	DD	FLAT:$SG93319
	DW	0160H
	DD	FLAT:$SG93320
	DW	0161H
	DD	FLAT:$SG93321
	DW	0162H
	DD	FLAT:$SG93322
	DW	0163H
	DD	FLAT:$SG93323
	DW	0164H
	DD	FLAT:$SG93324
	DW	0165H
	DD	FLAT:$SG93325
	DW	0166H
	DD	FLAT:$SG93326
	DW	0167H
	DD	FLAT:$SG93327
	DW	0168H
	DD	FLAT:$SG93328
	DW	0169H
	DD	FLAT:$SG93329
	DW	016aH
	DD	FLAT:$SG93330
	DW	016bH
	DD	FLAT:$SG93331
	DW	016cH
	DD	FLAT:$SG93332
	DW	0190H
	DD	FLAT:$SG93333
	DW	0191H
	DD	FLAT:$SG93334
	DW	0192H
	DD	FLAT:$SG93335
	DW	0193H
	DD	FLAT:$SG93336
	DW	0194H
	DD	FLAT:$SG93337
	DW	0195H
	DD	FLAT:$SG93338
	DW	01c2H
	DD	FLAT:$SG93339
	DW	01c3H
	DD	FLAT:$SG93340
	DW	0270fH
	DD	FLAT:$SG93341
CONST	ENDS
_DATA	SEGMENT
$SG99328 DB	'Zeidon MoveFile Error', 00H
_cDirSep DB	05cH
_g_bWin95 DB	01H
$SG93184 DB	'KZOEE024 - Error opening file', 00H
?cShowPopup@?1??fnSysMessageBox@@9@9 DB 020H		; `fnSysMessageBox'::`2'::cShowPopup
	ORG $+1
$SG93185 DB	'KZOEE025 - Error in directory specification', 00H
$SG93186 DB	'KZOEE026 - Error creating directory', 00H
$SG93187 DB	'KZOEE030 - Error loading library rc=', 00H
	ORG $+3
$SG93188 DB	'KZOEE031 - Error locating Operation rc=', 00H
$SG93189 DB	'KZOEE032 - Mutex name is invalid', 00H
	ORG $+3
$SG98310 DB	'DDD', 00H
$SG93190 DB	'KZOEE050 - Error opening View Object file ', 00H
	ORG $+1
$SG98311 DB	'ddd', 00H
$SG93191 DB	'KZOEE051 - Invalid View Object file header', 00H
	ORG $+1
$SG98314 DB	'DD', 00H
	ORG $+1
$SG93192 DB	'KZOEE052 - Invalid Object file, Attrib w/o lth in defin '
	DB	'prev to line ', 00H
	ORG $+2
$SG93193 DB	'KZOEE053 - Invalid Entity level found on line ', 00H
	ORG $+1
$SG93194 DB	'KZOEE054 - Invalid record found on line ', 00H
	ORG $+3
$SG93195 DB	'KZOEE055 - Invalid file, LTH or TYPE before DOMAIN on li'
	DB	'ne ', 00H
$SG93196 DB	'KZOEE056 - Domain not found on line ', 00H
	ORG $+3
$SG93197 DB	'KZOEE057 - Invalid file, LTH before type and DOMAIN on l'
	DB	'ine ', 00H
	ORG $+3
$SG93198 DB	'KZOEE058 - Invalid file, PERSIST after DOMAIN, TYPE or L'
	DB	'TH on line ', 00H
$SG93200 DB	'KZOEE060 - Invalid maximum root qualifier ', 00H
	ORG $+1
$SG93199 DB	'KZOEE059 - Invalid file, Invalid Attribute Token located'
	DB	' on line ', 00H
	ORG $+2
$SG93201 DB	'KZOEE061 - Persistent Attribute mismatch on Token ', 00H
	ORG $+1
$SG98322 DB	'MMM', 00H
$SG98323 DB	'mmm', 00H
$SG93202 DB	'KZOEE062 - Conflict between E/R Attribute Type and TE Fi'
	DB	'eld Type for: ', 00H
	ORG $+1
$SG93203 DB	'KZOEE063 - Entity attrib RECURSIVE Y, but not structural'
	DB	'ly recursive ', 00H
	ORG $+2
?g_dNull@?1??fnDecimalOperation@@9@9 DQ 0c2d6bcc41e8ffffar ; -1e+14 ; `fnDecimalOperation'::`2'::g_dNull
$SG93204 DB	'KZOEE064 - TYPE obsolete, use APDM_TOK ', 00H
$SG93205 DB	'KZOEE065 - LTH only valid for Attribute w/type string li'
	DB	'ne ', 00H
$SG98326 DB	'MM', 00H
	ORG $+1
$SG93206 DB	'KZOEE066 - Attribute length zero ', 00H
	ORG $+2
$SG98327 DB	'mm', 00H
	ORG $+1
$SG93207 DB	'KZOEE067 - Could not initialize the Core-MQ interface ', 00H
	ORG $+1
$SG93208 DB	'KZOEE070 - Object instance is empty', 00H
$SG93209 DB	'KZOEE071 - Error opening instance file ', 00H
$SG93210 DB	'KZOEE072 - Error reading instance file ', 00H
$SG93211 DB	'KZOEE073 - Invalid instance file header', 00H
$SG93212 DB	'KZOEE074 - Invalid Entity name on line ', 00H
$SG93213 DB	'KZOEE075 - Invalid Entity level on line ', 00H
	ORG $+3
$SG98334 DB	'YYY', 00H
$SG93214 DB	'KZOEE076 - Object instance contains versioned entity ins'
	DB	'tances', 00H
	ORG $+1
$SG93215 DB	'KZOEE077 - Invalid record size in binary object instance'
	DB	00H
	ORG $+3
$SG98336 DB	'YYYY', 00H
	ORG $+3
$SG93216 DB	'KZOEE078 - Internal error, linked instance has no visibl'
	DB	'e owner', 00H
$SG93217 DB	'KZOEE079 - Trying to commit a read-only view', 00H
	ORG $+3
$SG93218 DB	'KZOEE080 - Object Definition does not have a Database ha'
	DB	'ndler specified', 00H
$SG93219 DB	'KZOEE081 - Object Definition does not have a Genkey hand'
	DB	'ler specified', 00H
	ORG $+2
$SG93220 DB	'KZOEE082 - Error starting Genkey handler', 00H
	ORG $+3
$SG93224 DB	'KZOEE086 - Trying to commit 0 views', 00H
$SG93221 DB	'KZOEE083 - LOD does not have physical information.  Poss'
	DB	'ibly the LOD was saved without DB information or the entities'
	DB	' are work entities.', 00H
	ORG $+3
$SG93225 DB	'KZOEE087 - Too many views in View array', 00H
$SG98352 DB	'Missing ending delimiter', 00H
	ORG $+3
$SG93222 DB	'KZOEE084 - Entity in Object Definition does not have Dat'
	DB	'a Fields', 00H
	ORG $+3
$SG93228 DB	'KZOEE091 - Maximum number of entities in binary file exc'
	DB	'eeded', 00H
	ORG $+2
$SG93233 DB	'KZOEE096 - Error retrieving OI from blob.', 00H
	ORG $+2
$SG93223 DB	'KZOEE085 - Entity in Object Definition does not have Rel'
	DB	'ationship Records', 00H
	ORG $+2
$SG93226 DB	'KZOEE088 - Compressed OI is out of sync with LOD/XOD', 00H
	ORG $+3
$SG93234 DB	'KZOEE100 - Invalid View, view is a Subtask View', 00H
$SG93238 DB	'KZOEE104 - Invalid Attribute name for LOD/Entity/Attribu'
	DB	'te', 00H
	ORG $+1
$SG93227 DB	'KZOEE090 - Maximum number of entities in portable file e'
	DB	'xceeded: ', 00H
	ORG $+2
$SG93229 DB	'KZOEE092 - Couldn''t re-activate OI for optimistic lock '
	DB	'check', 00H
	ORG $+3
$SG93235 DB	'KZOEE101 - Invalid View', 00H
$SG93240 DB	'KZOEE106 - Rules violation ', 00H
$SG93230 DB	'KZOEE093 - Optimistic locking error -- OI has changed si'
	DB	'nce it was activated', 00H
	ORG $+3
$SG93231 DB	'KZOEE094 - Locking violation', 00H
	ORG $+3
$SG93232 DB	'KZOEE095 - A recursive child was found that matches a pa'
	DB	'rent.  This will cause an infinite loop in the recursive subo'
	DB	'bject.  See Trace for more.', 00H
	ORG $+3
$SG98353 DB	'Zeidon Error', 00H
	ORG $+3
$SG93236 DB	'KZOEE102 - Invalid View, view is hidden', 00H
$SG93237 DB	'KZOEE103 - Invalid Entity name for View', 00H
$SG93239 DB	'KZOEE105 - Invalid scoping Entity name for View', 00H
$SG93241 DB	'KZOEE107 - Invalid Subtask View', 00H
$SG98362 DB	'ENU', 00H
$SG93242 DB	'KZOEE108 - Attempt to drop Subtask View', 00H
$SG93243 DB	'KZOEE109 - Invalid View, view contains no instance', 00H
	ORG $+1
$SG93244 DB	'KZOEE110 - Invalid level for View name', 00H
	ORG $+1
$SG98365 DB	'ENU', 00H
$SG93245 DB	'KZOEE111 - Attempt to set subtask view with a view from '
	DB	'another task', 00H
	ORG $+3
$SG93246 DB	'KZOEE112 - Attempt to set subtask view attached to an ap'
	DB	'plication', 00H
	ORG $+2
$SG93247 DB	'KZOEE113 - Invalid View, view contains an instance', 00H
	ORG $+1
$SG98368 DB	'DEU', 00H
$SG93248 DB	'KZOEE114 - Source and Target entities do not match', 00H
	ORG $+1
$SG93249 DB	'KZOEE115 - Attempt to move an instance under one of its '
	DB	'children', 00H
	ORG $+3
$SG98371 DB	'FRC', 00H
$SG99394 DB	'SysOpenFile for file: %s failed due to invalid view (nul'
	DB	'l task)', 00H
$SG93250 DB	'KZOEE116 - Attempt to include an instance created under '
	DB	'a versioned parent', 00H
	ORG $+1
$SG93251 DB	'KZOEE117 - Entity Instance Keys do not match', 00H
	ORG $+3
$SG93252 DB	'KZOEE118 - Internal Key error relinking versioned Subobj'
	DB	'ect', 00H
$SG93253 DB	'KZOEE119 - Invalid View, View is Read Only', 00H
	ORG $+1
$SG99398 DB	'0x%08x%s', 00H
	ORG $+3
$SG98374 DB	'POR', 00H
$SG93254 DB	'KZOEE120 - Invalid position parameter', 00H
	ORG $+2
$SG93255 DB	'KZOEE121 - Attempt to insert twin to root of Instance', 00H
	ORG $+2
$SG93256 DB	'KZOEE122 - Attempt to create an Entity without a parent', 00H
$SG98377 DB	'SPA', 00H
$SG93257 DB	'KZOEE124 - Entity parent is included in another path con'
	DB	'taining same entity type', 00H
	ORG $+3
$SG98378 DB	',', 00H
	ORG $+2
$SG93258 DB	'KZOEE125 - Target and Source Entities are not the same E'
	DB	'/R Entity', 00H
	ORG $+2
$SG98379 DB	':', 00H
	ORG $+2
$SG93259 DB	'KZOEE126 - Target or Source Entity is not Includeable', 00H
	ORG $+2
$SG98380 DB	'AM', 00H
	ORG $+1
$SG98381 DB	'PM', 00H
	ORG $+1
$SG93260 DB	'KZOEE127 - Source & target do not match on both Entity &'
	DB	' Relationship.', 00H
	ORG $+1
$SG93261 DB	'KZOEE128 - Target Entity cardinality max not 1 for inver'
	DB	'ted Subobject', 00H
	ORG $+2
$SG98382 DB	'mm/dd/yy', 00H
	ORG $+3
$SG98384 DB	'$', 00H
	ORG $+2
$SG93262 DB	'KZOEE129 - Trying to create a relationship (via Include,'
	DB	' possibly as part of a spawn) that already exists.  See trace'
	DB	' for more.', 00H
$SG98383 DB	'mmm dd, yyyy', 00H
	ORG $+3
$SG93263 DB	'KZOEE131 - Attempt to include Subobject from another App'
	DB	'lication Task', 00H
	ORG $+2
$SG93264 DB	'KZOEE132 - Error establishing cursor for Subobject inclu'
	DB	'de', 00H
	ORG $+1
$SG98385 DB	',', 00H
	ORG $+2
$SG93265 DB	'KZOEE134 - Attempt to version an Entity Instance version'
	DB	'ed via a differen, path', 00H
$SG98386 DB	'.', 00H
	ORG $+2
$SG93266 DB	'KZOEE135 - Entity Instance not versioned', 00H
	ORG $+3
$SG93267 DB	'KZOEE136 - Entity Instance already versioned', 00H
	ORG $+3
$SG93268 DB	'KZOEE137 - Entity Instance descendent versioned', 00H
$SG98389 DB	'HH', 00H
	ORG $+1
$SG98390 DB	'H', 00H
	ORG $+2
$SG93269 DB	'KZOEE138 - Attempt to include target entity with recursi'
	DB	've behavior', 00H
$SG93270 DB	'KZOEE139 - Error establishing cursor for CreateEntity sp'
	DB	'awn', 00H
$SG98391 DB	'"', 00H
	ORG $+2
$SG98392 DB	'"', 00H
	ORG $+2
$SG93271 DB	'KZOEE140 - Target and source Object instance are the sam'
	DB	'e instance', 00H
	ORG $+1
$SG98393 DB	'MI', 00H
	ORG $+1
$SG93272 DB	'KZOEE141 - Attempt to include a subobject whose root is '
	DB	'a Temporal Entity', 00H
	ORG $+2
$SG93273 DB	'KZOEE190 - Error opening temporary file', 00H
$SG100442 DB	'(ZDecimal) Using default zDecimalOperation( )', 00H
	ORG $+2
$SG100443 DB	'(ZDecimal) Precision (in bits) = ', 00H
	ORG $+2
$SG93274 DB	'KZOEE191 - Attribute must be a Blob or String for this o'
	DB	'peration.', 00H
	ORG $+2
$SG99419 DB	'SysDeleteFile Error: %s   File: %s   RC: %d', 00H
$SG98395 DB	' AM', 00H
$SG93275 DB	'KZOEE231 - Decimal attribute overflow (garbage)', 00H
$SG93276 DB	'KZOEE232 - Operation indicates use default context, none'
	DB	' found', 00H
	ORG $+1
$SG93277 DB	'KZOEE233 - Could not locate derived library/operation', 00H
	ORG $+2
$SG99422 DB	'(sy) Could not open file: ', 00H
	ORG $+1
$SG93278 DB	'KZOEE234 - Attempt to add integer or decimal to invalid '
	DB	'attribute type', 00H
	ORG $+1
$SG99423 DB	'(sy) Reason code = ', 00H
$SG93279 DB	'KZOEE235 - Integer overflow', 00H
$SG93280 DB	'KZOEE236 - Integer underflow', 00H
	ORG $+3
$SG93281 DB	'KZOEE237 - Attempt to update a non-updateable attribute', 00H
$SG93282 DB	'KZOEE238 - Attempt to update a non-updateable persistent'
	DB	' attribute', 00H
	ORG $+1
$SG93283 DB	'KZOEE239 - Invalid Operation for attribute type', 00H
$SG93284 DB	'KZOEE240 - Binary large object (Blob) exceeds passed len'
	DB	'gth', 00H
$SG93285 DB	'KZOEE241 - Invalid Variable Type ', 00H
	ORG $+2
$SG93286 DB	'KZOEE242 - Invalid Domain Entry Type', 00H
	ORG $+3
$SG93287 DB	'KZOEE243 - Context invalid for Domain', 00H
	ORG $+2
$SG93288 DB	'KZOEE244 - Attribute has no Domain', 00H
	ORG $+1
$SG93289 DB	'KZOEE245 - Null string not allowed for a required attrib'
	DB	'ute', 00H
$SG93290 DB	'KZOEE246 - Invalid Attribute type ', 00H
	ORG $+1
$SG93291 DB	'KZOEE247 - Blob Attribute does not match Target Entity T'
	DB	'ype', 00H
$SG93292 DB	'KZOEE248 - Required attribute is null', 00H
	ORG $+2
$SG93293 DB	'KZOEE250 - Object instance is empty', 00H
$SG93294 DB	'KZOEE252 - Root of view has been deleted', 00H
	ORG $+3
$SG100463 DB	'%.*f', 00H
	ORG $+3
$SG93295 DB	'KZOEE253 - Entity cursor is NULL', 00H
	ORG $+3
$SG100464 DB	'%f', 00H
	ORG $+1
$SG93296 DB	'KZOEE254 - Entity cursor is undefined', 00H
	ORG $+2
$SG93297 DB	'KZOEE255 - Attempt to update a previous entity version', 00H
	ORG $+1
$SG100466 DB	'0.0', 00H
$SG93298 DB	'KZOEE256 - Entity is root of view', 00H
	ORG $+2
$SG93301 DB	'KZOEE259 - Scoping Entity cursor is NULL', 00H
	ORG $+3
$SG93299 DB	'KZOEE257 - Version mismatch between scoping and target E'
	DB	'ntities', 00H
$SG93300 DB	'KZOEE258 - Scoping Entity cursor is undefined', 00H
	ORG $+2
$SG93302 DB	'KZOEE263 - Input Qualifier cannot be converted to intern'
	DB	'al attribute data type', 00H
	ORG $+1
$SG93303 DB	'KZOEE264 - Invalid Operation for Hierarchical processing'
	DB	00H
	ORG $+3
$SG93304 DB	'KZOEE265 - Invalid Operation for non-Hierarchical proces'
	DB	'sing', 00H
	ORG $+3
$SG93305 DB	'KZOEE266 - Invalid Operation for Hierarchical cursor pos'
	DB	'ition', 00H
	ORG $+2
$SG93306 DB	'KZOEE267 - Hierarchical cursor is undefined', 00H
$SG93307 DB	'KZOEE268 - Source and target entity types do not match', 00H
	ORG $+1
$SG93308 DB	'KZOEE269 - Invalid Select Set ID, ID=', 00H
	ORG $+2
$SG93309 DB	'KZOEE270 - View name is already in use', 00H
	ORG $+1
$SG93310 DB	'KZOEE271 - Subobject Entity is root of View Object Defin'
	DB	'ition', 00H
	ORG $+2
$SG93311 DB	'KZOEE272 - Subobject Parent Cursor is NULL', 00H
	ORG $+1
$SG93312 DB	'KZOEE273 - Parent Entity instance for View deleted', 00H
	ORG $+1
$SG93313 DB	'KZOEE274 - Target and Source views are different View Ob'
	DB	'ject types', 00H
	ORG $+1
$SG93314 DB	'KZOEE300 - Problems finding a parent ', 00H
	ORG $+2
$SG93316 DB	'KZOEE302 - Invalid option', 00H
	ORG $+2
$SG93315 DB	'KZOEE301 - Return buffer not large enough to contain con'
	DB	'catenated keys', 00H
	ORG $+1
$SG93317 DB	'KZOEE330 - Message Object Definition not loaded for Appl'
	DB	'ication', 00H
$SG93318 DB	'KZOEE350 - Context Not Valid for Domain', 00H
$SG93319 DB	'KZOEE351 - Invalid Input Data Type', 00H
	ORG $+1
$SG93320 DB	'KZOEE352 - Text String exceeds attribute length ', 00H
	ORG $+3
$SG93321 DB	'KZOEE353 - Attribute Type invalid for this Domain', 00H
	ORG $+2
$SG100490 DB	'Mutex ''%s'' already created', 00H
	ORG $+1
$SG93322 DB	'KZOEE354 - Invalid Domain Entry Type ', 00H
	ORG $+2
$SG93323 DB	'KZOEE355 - Table_Handler invalid for this Domain Type ', 00H
	ORG $+1
$SG100492 DB	'Error creating mutex %s', 00H
$SG93324 DB	'KZOEE356 - Domain has an unnamed Context ', 00H
	ORG $+2
$SG93325 DB	'KZOEE357 - Invalid Input Data', 00H
	ORG $+2
$SG93326 DB	'KZOEE358 - Value not in Context for Domain ', 00H
$SG93327 DB	'KZOEE359 - Invalid Input Data Type for Domain Entry Type'
	DB	00H
	ORG $+3
$SG93328 DB	'KZOEE360 - Missing ending delimiter ', 00H
	ORG $+3
$SG93329 DB	'KZOEE361 - Invalid data Format ', 00H
$SG93330 DB	'KZOEE362 - Variable Type not allowed for this Domain Typ'
	DB	'e ', 00H
	ORG $+1
$SG93331 DB	'KZOEE363 - Context Edit string is invalid ', 00H
	ORG $+1
$SG93332 DB	'KZOEE364 - Picture length exceeds input length ', 00H
$SG100501 DB	'Trying to destroy NULL Mutex %s', 00H
$SG93333 DB	'KZOEE400 - Error transmitting OI -- some lines lost.', 00H
	ORG $+3
$SG93334 DB	'KZOEE401 - Invalid User Name.', 00H
	ORG $+2
$SG100503 DB	'Error destroying mutex %s', 00H
	ORG $+2
$SG93335 DB	'KZOEE402 - Invalid Password.', 00H
	ORG $+3
$SG93336 DB	'KZOEE403 - Application not supported by Security Object.'
	DB	00H
	ORG $+3
$SG98457 DB	'No terminating ''%'' in ZEIDON.APP', 00H
	ORG $+3
$SG93337 DB	'KZOEE404 - Can''t find UserGroup.', 00H
	ORG $+3
$SG93338 DB	'KZOEE405 - UserGroup doesn''t have authority for operati'
	DB	'on.', 00H
	ORG $+1
$SG93339 DB	'KZOEE450 - Name for view is too long', 00H
	ORG $+3
$SG93340 DB	'KZOEE451 - Include source task does not match target tas'
	DB	'k', 00H
	ORG $+2
$SG100511 DB	'Trying to lock NULL Mutex %s', 00H
	ORG $+3
$SG93343 DB	'SfCreateSubtask', 00H
$SG93344 DB	'SfDropSubtask', 00H
	ORG $+2
$SG93345 DB	'DisableTask', 00H
$SG93346 DB	'EnableTask', 00H
	ORG $+1
$SG93347 DB	'GetApplDirectoryFromView', 00H
	ORG $+3
$SG93348 DB	'SfGetApplicationForSubtask', 00H
	ORG $+1
$SG93349 DB	'SfGetTaskInfo', 00H
	ORG $+2
$SG93350 DB	'SfActivateSysOI_FromFile', 00H
	ORG $+3
$SG93351 DB	'SfActivateSysEmptyOI', 00H
	ORG $+3
$SG98472 DB	'zeidon.ini', 00H
	ORG $+1
$SG93352 DB	'ActivateEmptyObjectInstance', 00H
$SG100521 DB	'Trying to unlock NULL Mutex %s', 00H
	ORG $+1
$SG93353 DB	'ActivateObjectInstance', 00H
	ORG $+1
$SG93354 DB	'ActivateOI_FromFile', 00H
$SG100523 DB	'Error releasing mutex %s', 00H
	ORG $+3
$SG99499 DB	'SysReadLine null OpenFile', 00H
	ORG $+2
$SG93355 DB	'ActivateOI_FromXML_File', 00H
$SG99500 DB	'SysReadLine ... no open files', 00H
	ORG $+2
$SG93356 DB	'CommitOI_ToXML_File', 00H
$SG93357 DB	'ActivateOI_FromOI', 00H
	ORG $+2
$SG93358 DB	'CommitObjectInstance', 00H
	ORG $+3
$SG93359 DB	'CommitMultipleOIs', 00H
	ORG $+2
$SG93360 DB	'DropViewCluster', 00H
$SG93361 DB	'AddToViewCluster', 00H
	ORG $+3
$SG99506 DB	'SysReadLine ... buffer acquisition failure', 00H
	ORG $+1
$SG93362 DB	'CommitOI_ToFile', 00H
$SG93363 DB	'DropObjectInstance', 00H
	ORG $+1
$SG93364 DB	'CheckExistenceOfEntity', 00H
	ORG $+1
$SG93365 DB	'CompareEntityToEntity', 00H
	ORG $+2
$SG93366 DB	'CreateEntity', 00H
	ORG $+3
$SG93367 DB	'GetEntityKey', 00H
	ORG $+3
$SG93368 DB	'CreateTemporalEntity', 00H
	ORG $+3
$SG93369 DB	'CreateTemporalSubobjectVersion', 00H
	ORG $+1
$SG93370 DB	'AcceptSubobject', 00H
$SG93371 DB	'AcceptAllTemporalSubobjects', 00H
$SG93372 DB	'CancelSubobject', 00H
$SG93373 DB	'CancelAllTemporalSubobjects', 00H
$SG93374 DB	'IncludeSubobjectFromSubobject', 00H
	ORG $+2
$SG93375 DB	'IncludeSubobjectFromSubobjectEx', 00H
$SG93376 DB	'SubobjectVersionUpdated', 00H
$SG93377 DB	'DeleteEntity', 00H
	ORG $+3
$SG93378 DB	'ExcludeEntity', 00H
	ORG $+2
$SG93379 DB	'DropEntity', 00H
	ORG $+1
$SG93380 DB	'MoveSubobject', 00H
	ORG $+2
$SG93381 DB	'SetCursorNextEntity', 00H
$SG93382 DB	'SetCursorPrevEntity', 00H
$SG93383 DB	'SetCursorFirstEntity', 00H
	ORG $+3
$SG93384 DB	'SetCursorLastEntity', 00H
$SG93385 DB	'SetCursorFirstEntityByString', 00H
	ORG $+3
$SG93386 DB	'SetCursorNextEntityByString', 00H
$SG93387 DB	'SetCursorFirstEntityByInteger', 00H
	ORG $+2
$SG93388 DB	'SetCursorNextEntityByInteger', 00H
	ORG $+3
$SG93389 DB	'SetCursorFirstEntityByDecimal', 00H
	ORG $+2
$SG93390 DB	'SetCursorNextEntityByDecimal', 00H
	ORG $+3
$SG93391 DB	'SetCursorFirstEntityByAttr', 00H
	ORG $+1
$SG93392 DB	'SetCursorNextEntityByAttr', 00H
	ORG $+2
$SG93393 DB	'SetCursorFirstEntityByEntityCsr', 00H
$SG93394 DB	'SetCursorNextEntityByEntityCsr', 00H
	ORG $+1
$SG93395 DB	'SetCursorFirstSelectedEntity', 00H
	ORG $+3
$SG93396 DB	'SetCursorNextSelectedEntity', 00H
$SG93397 DB	'SetCursorRelativeEntity', 00H
$SG100566 DB	'Null task', 00H
	ORG $+2
$SG93398 DB	'GetRelativeEntityNumber', 00H
$SG100567 DB	'MutexFind', 00H
	ORG $+2
$SG93399 DB	'DefineHierarchicalCursor', 00H
	ORG $+3
$SG93400 DB	'DropHierarchicalCursor', 00H
	ORG $+1
$SG93401 DB	'SetCursorNextEntityHierarchical', 00H
$SG93402 DB	'CreateViewFromView', 00H
	ORG $+1
$SG93403 DB	'SetViewFromView', 00H
$SG93404 DB	'SetViewToSubobject', 00H
	ORG $+1
$SG93405 DB	'ResetViewFromSubobject', 00H
	ORG $+1
$SG93406 DB	'SetNameForView', 00H
	ORG $+1
$SG93407 DB	'DropNameForView', 00H
$SG93408 DB	'GetViewByName', 00H
	ORG $+2
$SG93409 DB	'SetSubtaskView', 00H
	ORG $+1
$SG93410 DB	'GetNameForView', 00H
	ORG $+1
$SG93411 DB	'SfGetFirstSubtaskView', 00H
	ORG $+2
$SG93412 DB	'SfGetNextSubtaskView', 00H
	ORG $+3
$SG93413 DB	'SfTransferView', 00H
	ORG $+1
$SG93414 DB	'SfLockView', 00H
	ORG $+1
$SG93415 DB	'ResetView', 00H
	ORG $+2
$SG93416 DB	'DropView', 00H
	ORG $+3
$SG93417 DB	'SetViewReadOnly', 00H
$SG93418 DB	'SetViewFlags', 00H
	ORG $+3
$SG93419 DB	'GetViewFlags', 00H
	ORG $+3
$SG93420 DB	'DropViewObject', 00H
	ORG $+1
$SG93421 DB	'GetAttributeFlags', 00H
	ORG $+2
$SG93422 DB	'AttributeUpdated', 00H
	ORG $+3
$SG93423 DB	'GetStringFromAttribute', 00H
	ORG $+1
$SG93424 DB	'GetIntegerFromAttribute', 00H
$SG93425 DB	'GetDecimalFromAttribute', 00H
$SG93426 DB	'GetBlobFromAttribute', 00H
	ORG $+3
$SG98547 DB	'AllocSize', 00H
	ORG $+2
$SG93427 DB	'GetStructFromEntityAttrs', 00H
	ORG $+3
$SG100596 DB	'fnMutexCreate Invalid mutex name: ', 00H
	ORG $+1
$SG98548 DB	'Zeidon', 00H
	ORG $+1
$SG93428 DB	'GetAddrForAttribute', 00H
$SG93429 DB	'GetVariableFromAttribute', 00H
	ORG $+3
$SG98550 DB	'OE Anchor', 00H
	ORG $+2
$SG93430 DB	'SetAttributeFromString', 00H
	ORG $+1
$SG93431 DB	'SetAttributeFromInteger', 00H
$SG93432 DB	'SetAttributeFromDecimal', 00H
$SG98553 DB	'InitAnchor', 00H
	ORG $+1
$SG93433 DB	'SetAttributeFromBlob', 00H
	ORG $+3
$SG93434 DB	'SetAttributeFromAttribute', 00H
	ORG $+2
$SG98555 DB	' ''', 00H
	ORG $+1
$SG93435 DB	'SetAttributeFromCurrentDate', 00H
$SG98556 DB	'''', 00H
	ORG $+2
$SG93436 DB	'SetAttributeFromVariable', 00H
	ORG $+3
$SG93437 DB	'SetAttributeValueNext', 00H
	ORG $+2
$SG93438 DB	'SetAttributeValuePrev', 00H
	ORG $+2
$SG93439 DB	'SetBlobAttributeFromAttribute', 00H
	ORG $+2
$SG93440 DB	'SetEntityAttributesFromBlob', 00H
$SG93441 DB	'SetBlobFromEntityAttributes', 00H
$SG93442 DB	'AddToAttributeFromInteger', 00H
	ORG $+2
$SG93443 DB	'AddToAttributeFromDecimal', 00H
	ORG $+2
$SG93444 DB	'AddToAttributeFromAttribute', 00H
$SG93445 DB	'AddToAttributeFromVariable', 00H
	ORG $+1
$SG93446 DB	'CompareAttributeToString', 00H
	ORG $+3
$SG93447 DB	'CompareAttributeToInteger', 00H
	ORG $+2
$SG100616 DB	'Error creating mutex %s', 00H
$SG98568 DB	', ', 00H
	ORG $+1
$SG93448 DB	'CompareAttributeToDecimal', 00H
	ORG $+2
$SG93449 DB	'CompareAttributeToAttribute', 00H
$SG98570 DB	'TEMP', 00H
	ORG $+3
$SG93450 DB	'CompareAttributeToVariable', 00H
	ORG $+1
$SG93451 DB	'GetAttributeLength', 00H
	ORG $+1
$SG98572 DB	'TMP', 00H
$SG93452 DB	'SetMatchingAttributesByName', 00H
$SG93453 DB	'GetFirstTableEntryForAttribute', 00H
	ORG $+1
$SG93454 DB	'GetNextTableEntryForAttribute', 00H
	ORG $+2
$SG93455 DB	'DisplayEntityInstance', 00H
	ORG $+2
$SG98576 DB	'MemoryTraceThreshold', 00H
	ORG $+3
$SG93456 DB	'DisplayObjectInstance', 00H
	ORG $+2
$SG98577 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG93457 DB	'DisplayCursorInfo', 00H
	ORG $+2
$SG98578 DB	'MemoryCeiling', 00H
	ORG $+2
$SG93458 DB	'StoreValueInRecord', 00H
	ORG $+1
$SG98579 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG93459 DB	'StoreValueInDerivedAttribute', 00H
	ORG $+3
$SG98580 DB	'Object Services Initialization complete...', 00H
	ORG $+1
$SG93460 DB	'StoreValueInDerivedAttribute', 00H
	ORG $+3
$SG93461 DB	'TableEntryExtToInt', 00H
	ORG $+1
$SG93462 DB	'TableEntryIntToExt', 00H
	ORG $+1
$SG98583 DB	'Object Services Running in Server Mode...', 00H
	ORG $+2
$SG93463 DB	'TableEntryForInternalValue', 00H
	ORG $+1
$SG98584 DB	'Object Services Running in Shared Mode...', 00H
	ORG $+2
$SG93464 DB	'SetSelectSetForView', 00H
$SG93465 DB	'GetSelectStateOfEntity', 00H
	ORG $+1
$SG93466 DB	'SetAllSelectStatesForEntity', 00H
$SG93467 DB	'SetSelectStateOfEntity', 00H
	ORG $+1
$SG93468 DB	'RelinkInstanceToInstance', 00H
	ORG $+3
$SG93469 DB	'RelinkAllSubobjectsForOI', 00H
	ORG $+3
$SG93470 DB	'LoadEntity', 00H
	ORG $+1
$SG93471 DB	'ObjectInstanceUpdated', 00H
	ORG $+2
$SG93472 DB	'ObjectInstanceUpdatedFromFile', 00H
	ORG $+2
$SG93473 DB	'GetValueFromRecord', 00H
	ORG $+1
$SG93474 DB	'StoreStringInRecord', 00H
$SG93475 DB	'GetStringFromRecord', 00H
$SG98595 DB	'fnFreeLocalAnchorBlock Page Table UNmapping at Index: %x'
	DB	'   0x%08x   Process: 0x%08x', 00H
$SG93476 DB	'SetEntityCursor', 00H
$SG93477 DB	'GetAddrFromRecord', 00H
	ORG $+2
$SG93478 DB	'MiGetParentEntityNameForView', 00H
	ORG $+3
$SG93479 DB	'GetTaskDBHandlerTraceLevel', 00H
	ORG $+1
$SG93480 DB	'SetTaskDBHandlerTraceLevel', 00H
	ORG $+1
$SG93481 DB	'GetAbsolutePositionForEntity', 00H
	ORG $+3
$SG93482 DB	'GetEntityNameForHierarchicalCsr', 00H
$SG93483 DB	'SetCursorAbsolutePosition', 00H
	ORG $+2
$SG93484 DB	'OrderEntityForView', 00H
	ORG $+1
$SG93485 DB	'CountEntitiesForView', 00H
	ORG $+3
$SG93486 DB	'OrderOI_ByDefaultAttribs', 00H
	ORG $+3
$SG93487 DB	'OrderEntitiesByDefaultAttribs', 00H
	ORG $+2
$SG93488 DB	'MiGetUpdateForViewEntityAttr', 00H
	ORG $+3
$SG93489 DB	'MessageSend', 00H
$SG93490 DB	'MessagePrompt', 00H
	ORG $+2
$SG93491 DB	'MessagePromptForInput', 00H
	ORG $+2
$SG93492 DB	'MessagePresent', 00H
	ORG $+1
$SG93493 DB	'MiGetTemporalStateOfEntity', 00H
	ORG $+1
$SG93494 DB	'MiGetUpdateForView', 00H
	ORG $+1
$SG93495 DB	'MiGetInstanceID_ForView', 00H
$SG93496 DB	'MiGetDateTimeForOI', 00H
	ORG $+1
$SG93497 DB	'MiGetERTokenForEntity', 00H
	ORG $+2
$SG99642 DB	0dH, 0aH, 00H
	ORG $+1
$SG93498 DB	'MiGetViewEntityForView', 00H
	ORG $+1
$SG93499 DB	'UfAddToDateTime', 00H
$SG93500 DB	'GetAttributeDisplayLength', 00H
	ORG $+2
$SG93501 DB	'MiGetCardinalityForEntity', 00H
	ORG $+2
$SG93502 DB	'NetActivateOI', 00H
	ORG $+2
$SG100671 DB	'(tm) Error trying to lock mutex ', 00H
	ORG $+3
$SG99647 DB	0dH, 0aH, 00H
	ORG $+1
$SG93503 DB	'NetClose', 00H
	ORG $+3
$SG100672 DB	'Error locking mutex', 00H
$SG93504 DB	'NetCommitOI', 00H
$SG100673 DB	'Error', 00H
	ORG $+2
$SG93505 DB	'NetGetTraceLevel', 00H
	ORG $+3
$SG93506 DB	'NetListen', 00H
	ORG $+2
$SG93507 DB	'NetStopListen', 00H
	ORG $+2
$SG93508 DB	'NetSetTraceLevel', 00H
	ORG $+3
$SG93509 DB	'NetStartup', 00H
	ORG $+1
$SG93510 DB	'NetStatus', 00H
	ORG $+2
$SG93511 DB	'NetProcessMessage', 00H
	ORG $+2
$SG93512 DB	'NetCommitOI_ToFile', 00H
	ORG $+1
$SG93513 DB	'NetActivateOI_FromFile', 00H
	ORG $+1
$SG100682 DB	'Error releasing mutex %s', 00H
	ORG $+3
$SG93514 DB	'NetSendBootstrapFile', 00H
	ORG $+3
$SG93515 DB	'NetCallOperation', 00H
	ORG $+3
$SG93516 DB	'NetGetLocalHostAddress', 00H
	ORG $+1
$SG93517 DB	'NetSendFile', 00H
$SG93518 DB	'SetIncrementalUpdateFlags', 00H
	ORG $+2
$SG93519 DB	'GetIncrementalUpdateFlags', 00H
	ORG $+2
$SG93520 DB	'SetBlobFromFile', 00H
$SG93521 DB	'WriteBlobToFile', 00H
$SG93522 DB	'SfCheckOI_Integrity', 00H
$SG93523 DB	'GenerateQualFromEntityList', 00H
	ORG $+1
$SG93524 DB	'WriteOI_ToXML', 00H
	ORG $+2
$SG93525 DB	'WriteSubobjectToXML', 00H
$SG93526 DB	'CommitSubobjectToXML_File', 00H
	ORG $+2
$SG99687 DB	0dH, 0aH, 00H
	ORG $+1
$SG99695 DB	0dH, 0aH, 00H
	ORG $+1
$SG98677 DB	'Received a message while in Server Mode', 00H
$SG100727 DB	'Error destroying mutex: %s', 00H
	ORG $+1
$SG98682 DB	'Internal Error - lpRequestProcess is null', 00H
	ORG $+2
$SG98683 DB	'Zeidon Object Engine', 00H
	ORG $+3
$SG98691 DB	'(sy) DuplicateHandle RC = ', 00H
	ORG $+1
$SG98692 DB	'(sy) DuplicateHandle Failed: ', 00H
	ORG $+2
$SG98693 DB	'Internal error -- DuplicateHandle failed!', 00H
	ORG $+2
$SG98709 DB	'Error destroying mutex: %s', 00H
	ORG $+1
$SG98712 DB	'Unknown message', 00H
$SG98713 DB	'Zeidon Object Engine', 00H
	ORG $+3
$SG99742 DB	'fnSysCloseFileWithControl %s   Handle: 0x%08x   Task: 0x'
	DB	'%08x   Process: 0x%08x:0x%08x', 00H
	ORG $+2
$SG100771 DB	' ---- MUTEX LIST ---- ', 00H
	ORG $+1
$SG100772 DB	'MutexQueryStatus %s -- Checking ...', 00H
$SG100780 DB	'MutexQueryStatus %s -- FAILED (%d)', 00H
	ORG $+1
$SG100781 DB	'MutexQueryStatus %s -- OK', 00H
	ORG $+2
$SG100785 DB	'Mutex ''%s'' locked by Task: %d  ProcessID: %d', 00H
	ORG $+3
$SG100786 DB	'Mutex ''%s'' is unlocked   ProcessID: %d', 00H
	ORG $+1
$SG98740 DB	'AllocShared', 00H
$SG100789 DB	'Task 0x%08x (process id:%d) is waiting on mutex ''%s''  '
	DB	' Lock Count: %d', 00H
	ORG $+2
$SG98744 DB	'Zeidon Internal Error', 00H
	ORG $+2
$SG98745 DB	'Error Calling SendMsg( )', 00H
	ORG $+3
$SG100796 DB	'KZOESYAA', 00H
	ORG $+3
$SG100811 DB	'SysMainWndProc for Tomcat session Wnd: ', 00H
$SG98763 DB	'No view', 00H
$SG98764 DB	'Check Pointer Error for TableIndex: %d   ViewOD Name: %s'
	DB	00H
	ORG $+3
$SG98765 DB	'Check Pointer Error for TableIndex!', 00H
$SG98766 DB	'Zeidon Core', 00H
$SG100815 DB	'SysMainWndProc for Tomcat session Wnd: ', 00H
$SG99792 DB	'SysSetFileTime: Couldn''t open file ', 00H
$SG98791 DB	'Invalid pointer handle for free: hi-bit not set: 0x%08x', 00H
$SG100840 DB	'SysInitApplicationWindow Class: %s  Title: %s  hWnd: 0x%'
	DB	'08x=%d', 00H
	ORG $+1
$SG98824 DB	'KZOE0012 - Error allocating memory for length ', 00H
	ORG $+1
$SG100909 DB	'KZOESRVC', 00H
	ORG $+3
$SG100911 DB	'N', 00H
	ORG $+2
$SG100912 DB	'ServerMode', 00H
	ORG $+1
$SG100913 DB	'ObjectEngine', 00H
	ORG $+3
$SG98877 DB	'g_lProcessIdx != -1', 00H
$SG98875 DB	'fnGetAnchorBlock Page Table mapping at Index: %x   0x%08'
	DB	'x   Process: 0x%08x', 00H
$SG98878 DB	'DGC', 00H
$SG98879 DB	'GetAnchor', 00H
	ORG $+2
$SG99910 DB	'%4d%02d%02d%02d%02d%02d%03d', 00H
$SG99911 DB	'???????????????', 00H
$SG99923 DB	'%4d%02d%02d%02d%02d%02d%03d', 00H
_szlReleaseCompatible DD FLAT:$SG92764
$SG99931 DB	'ReturnValue', 00H
$SG99932 DB	'Operation', 00H
	ORG $+2
$SG92764 DB	'1.0a2   ', 00H
	ORG $+3
_szlReleaseCurrent DD FLAT:$SG92766
$SG92766 DB	'1.0b0   ', 00H
	ORG $+3
_szlShareSeg DD	FLAT:$SG92768
$SG92768 DB	'/SHAREMEM/KZOENGAA.SEG', 00H
	ORG $+1
_g_ulMaxRecordStringLth DD 09H
_szObjectEngineName DD FLAT:$SG92773
$SG92773 DB	'kzoengwa.exe', 00H
	ORG $+3
_szObjectEngineDll DD FLAT:$SG92775
$SG92775 DB	'kzoengaa.dll', 00H
	ORG $+3
_szObjectSuffix DD FLAT:$SG92777
$SG99944 DB	'Zeidon System', 00H
	ORG $+2
$SG99945 DB	'T', 00H
	ORG $+2
$SG92777 DB	'.xod', 00H
	ORG $+3
_szDllSuffix DD	FLAT:$SG92779
$SG99946 DB	'GetDateTime', 00H
$SG99947 DB	'kzoengaa', 00H
	ORG $+3
$SG92779 DB	'.dll', 00H
	ORG $+3
$SG99948 DB	'zWinSock', 00H
	ORG $+3
_szNullS DD	FLAT:$SG92782
_lNullInteger DD 080000000H
_stNullDateTime DD 080000000H
	DW	00H
	ORG $+2
_szlZEIDON DD	FLAT:$SG92789
_g_ZeidonMutexName DD FLAT:$SG90740
	DD	FLAT:$SG90741
	DD	FLAT:$SG90742
	DD	FLAT:$SG90743
	DD	FLAT:$SG90744
	DD	FLAT:$SG90745
	DD	FLAT:$SG90746
	DD	FLAT:$SG90747
	DD	FLAT:$SG90748
	DD	FLAT:$SG90749
	DD	FLAT:$SG90750
	DD	FLAT:$SG90751
	DD	FLAT:$SG90752
	DD	FLAT:$SG90753
	DD	FLAT:$SG90754
	DD	FLAT:$SG90755
$SG90740 DB	'ZEIDON MUTEX -- INITTERM', 00H
	ORG $+3
$SG92789 DB	'ZEIDON', 00H
	ORG $+1
$SG90741 DB	'ZEIDON MUTEX -- MEMORY ALLOCATION', 00H
	ORG $+2
_szlAppFile DD	FLAT:$SG92791
$SG90742 DB	'ZEIDON MUTEX -- ANCHOR BLOCK', 00H
	ORG $+3
$SG92791 DB	'zeidon.app', 00H
	ORG $+1
$SG90743 DB	'ZEIDON MUTEX -- ANCHOR INIT', 00H
_szlDomainFile DD FLAT:$SG92793
$SG90744 DB	'ZEIDON MUTEX -- SHARED MEM', 00H
	ORG $+1
$SG92793 DB	'zeidon.xdm', 00H
	ORG $+1
$SG90745 DB	'ZEIDON MUTEX -- TASK CHAIN', 00H
	ORG $+1
_szlSystemDomainFile DD FLAT:$SG92795
$SG99962 DB	'Invalid type for Early Date', 00H
$SG90746 DB	'ZEIDON MUTEX -- TASK CHAIN WRITE', 00H
	ORG $+3
$SG99963 DB	'SysGetDateTimeDifference: ', 00H
	ORG $+1
$SG92795 DB	'kzomdmoi.xdm', 00H
	ORG $+3
$SG90747 DB	'ZEIDON MUTEX -- MUTEX', 00H
	ORG $+2
_szlMessageObject DD FLAT:$SG92797
$SG90748 DB	'ZEIDON MUTEX -- DEBUGCHANGE', 00H
$SG99965 DB	'Invalid type for Later Date', 00H
$SG92797 DB	'KZMSGQOO', 00H
	ORG $+3
$SG90749 DB	'ZEIDON MUTEX -- PESSIMISTIC LOCK', 00H
	ORG $+3
_szlNewPortableHeader DD FLAT:$SG92799
$SG99966 DB	'SysGetDateTimeDifference: ', 00H
	ORG $+1
$SG90750 DB	'ZEIDON MUTEX -- APPLA', 00H
	ORG $+2
$SG92799 DB	'z', 00H
	ORG $+2
$SG90751 DB	'ZEIDON MUTEX -- ENTITY KEY', 00H
	ORG $+1
_szlmZeidon DD	FLAT:$SG92801
$SG90752 DB	'ZEIDON MUTEX -- TASKPROCESS', 00H
$SG92801 DB	'Zeidon', 00H
	ORG $+1
$SG90753 DB	'ZEIDON MUTEX -- PROC CHAIN', 00H
	ORG $+1
_szlAPPLICATION DD FLAT:$SG92803
$SG90754 DB	'ZEIDON MUTEX -- PROC CHAIN WRITE', 00H
	ORG $+3
$SG92803 DB	'APPLICATION', 00H
$SG90755 DB	'ZEIDON MUTEX -- NETWORK CHAIN', 00H
	ORG $+2
_szlOBJECT DD	FLAT:$SG92805
$SG98948 DB	' ''', 00H
	ORG $+1
$SG98949 DB	'''', 00H
	ORG $+2
$SG92805 DB	'OBJECT', 00H
	ORG $+1
_szlENTITY DD	FLAT:$SG92807
$SG98951 DB	'Couldn''t find ZEIDON_BIN specification.', 00H
$SG92807 DB	'ENTITY', 00H
	ORG $+1
_szlCHILDENTITY DD FLAT:$SG92809
$SG98952 DB	'Zeidon - Object Services Init', 00H
	ORG $+2
$SG92809 DB	'CHILDENTITY', 00H
_szlATTRIB DD	FLAT:$SG92811
$SG98954 DB	' - ', 00H
$SG92811 DB	'ATTRIB', 00H
	ORG $+1
_szlDOMAIN DD	FLAT:$SG92813
$SG92813 DB	'DOMAIN', 00H
	ORG $+1
_szlMODEL DD	FLAT:$SG92815
$SG92815 DB	'MODEL', 00H
	ORG $+2
_szlCONTEXT DD	FLAT:$SG92817
$SG98961 DB	'MS Windows 3.x', 00H
	ORG $+1
$SG92817 DB	'CONTEXT', 00H
_szlNLS_TABLEENTRY DD FLAT:$SG92819
$SG98963 DB	'MS Windows 95/98', 00H
	ORG $+3
$SG92819 DB	'NLS_TABLEENTRY', 00H
	ORG $+1
_szlTABLEENTRY DD FLAT:$SG92821
$SG98965 DB	'MS Windows NT/XP', 00H
	ORG $+3
$SG92821 DB	'TABLEENTRY', 00H
	ORG $+1
_szlREGULAREXPRESSION DD FLAT:$SG92823
$SG98967 DB	'IBM OS/2', 00H
	ORG $+3
$SG92823 DB	'REGULAREXPRESSION', 00H
	ORG $+2
_szlZEIDON_BIN DD FLAT:$SG92825
$SG98968 DB	'(sy) SysStartObjectServices started for ', 00H
	ORG $+3
$SG92825 DB	'ZEIDON_BIN', 00H
	ORG $+1
_szlZEIDON_SYS DD FLAT:$SG92827
$SG92827 DB	'ZEIDON_SYS', 00H
	ORG $+1
_szlZEIDON_LOC DD FLAT:$SG92829
$SG92829 DB	'ZEIDON_LOC', 00H
	ORG $+1
_szlZEIDON_SHR DD FLAT:$SG92831
$SG92831 DB	'ZEIDON_SHR', 00H
	ORG $+1
_szlAPP_NAME DD	FLAT:$SG92833
$SG92833 DB	'APP_NAME', 00H
	ORG $+3
_szlAPP_DFLT_Dialog DD FLAT:$SG92835
$SG92835 DB	'APP_DFLT_WDOD', 00H
	ORG $+2
_szlAPP_DLL DD	FLAT:$SG92837
$SG92837 DB	'APP_DLL', 00H
_szlAPP_ADOBIN DD FLAT:$SG92839
$SG92839 DB	'APP_ADOBIN', 00H
	ORG $+1
_szlAPP_LOCAL DD FLAT:$SG92841
$SG92841 DB	'APP_LOCAL', 00H
	ORG $+2
_szlAPP_SHARED DD FLAT:$SG92843
$SG92843 DB	'APP_SHARED', 00H
	ORG $+1
_szlAPP_QLPLR DD FLAT:$SG92845
$SG92845 DB	'APP_QLPLR', 00H
	ORG $+2
_szlAPP_QXODS DD FLAT:$SG92847
$SG92847 DB	'APP_QXODS', 00H
	ORG $+2
_szlAPP_SOURCE DD FLAT:$SG92849
$SG98992 DB	'Invalid pointer handle (get) : hi-bit not set: 0x%08x', 00H
	ORG $+2
$SG92849 DB	'APP_SOURCE', 00H
	ORG $+1
_szlAPDM_TOK DD	FLAT:$SG92851
$SG92851 DB	'APDM_TOK', 00H
	ORG $+3
_szlATTRIBUTETYPE DD FLAT:$SG92853
$SG98996 DB	'Invalid pointer handle (null) at Index: %x for pointer 0'
	DB	'x%08x', 00H
	ORG $+2
$SG92853 DB	'ATTRIBUTETYPE', 00H
	ORG $+2
_szlATTRIBUTEDECIMAL DD FLAT:$SG92855
$SG92855 DB	'ATTRIBUTEDECIMAL', 00H
	ORG $+3
_szlAUTOCREATE DD FLAT:$SG92857
$SG100025 DB	'.dll', 00H
	ORG $+3
$SG92857 DB	'AUTOCREATE', 00H
	ORG $+1
_szlAUTOLOADFROMPARENT DD FLAT:$SG92859
$SG92859 DB	'AUTOLOADFROMPARENT', 00H
	ORG $+1
_szlAUTO_SEQ DD	FLAT:$SG92861
$SG100029 DB	'(sy) SysLoadLibrary failed to load file: "%s"  with erro'
	DB	'r code = %d  using Current directory: %s', 00H
	ORG $+3
$SG92861 DB	'AUTO_SEQ', 00H
	ORG $+3
_szlXVAATT_TOK DD FLAT:$SG92863
$SG100031 DB	'Load failed for: %s (%s)', 00H
	ORG $+3
$SG92863 DB	'XVAATT_TOK', 00H
	ORG $+1
_szlNT_ThreadClassName DB 'ZeidonNT_ThreadClass', 00H
	ORG $+3
_szlCARDMAX DD	FLAT:$SG92865
$SG100032 DB	'System Services', 00H
_g_lProcessIdx DD 0ffffffffH
$SG100033 DB	'SY00101', 00H
$SG92865 DB	'CARDMAX', 00H
_szlCARDMIN DD	FLAT:$SG92867
$SG100034 DB	'Load failed for: %s (%s)', 00H
	ORG $+3
$SG92867 DB	'CARDMIN', 00H
_szlCASESENS DD	FLAT:$SG92869
$SG92869 DB	'CASESENS', 00H
	ORG $+3
_szlCONTEXTRESTRICTION DD FLAT:$SG92871
$SG99015 DB	'Invalid pointer: hi-bit set!!', 00H
	ORG $+2
$SG92871 DB	'CONTEXTRESTRICTION', 00H
	ORG $+1
_szlCREATE DD	FLAT:$SG92873
$SG92873 DB	'CREATE', 00H
	ORG $+1
_szlCR_DATE DD	FLAT:$SG92875
$SG92875 DB	'CR_DATE', 00H
_szlDATAFIELD DD FLAT:$SG92877
$SG92877 DB	'DATAFIELD', 00H
	ORG $+2
_szlDATARECORD DD FLAT:$SG92879
$SG92879 DB	'DATARECORD', 00H
	ORG $+1
_szlDATATYPE DD	FLAT:$SG92881
$SG92881 DB	'DATATYPE', 00H
	ORG $+3
_szlDBNAME DD	FLAT:$SG92883
$SG92883 DB	'DBNAME', 00H
	ORG $+1
_szlDECIMAL DD	FLAT:$SG92885
$SG92885 DB	'DECIMAL', 00H
_szlDECIMALFORMAT DD FLAT:$SG92887
$SG92887 DB	'DECIMALFORMAT', 00H
	ORG $+2
_szlDELETE DD	FLAT:$SG92889
$SG98009 DB	'Exceeded Process Limit ... Contact Zeidon Support', 00H
	ORG $+2
$SG92889 DB	'DELETE', 00H
	ORG $+1
_szlDERIVED DD	FLAT:$SG92891
$SG99034 DB	'Invalid pointer: hi-bit not set!!', 00H
	ORG $+2
$SG100058 DB	'(sy) SysGetProc failed with error code: %d   DLL: %s   F'
	DB	'unction: %s xx:%s', 00H
	ORG $+2
$SG92891 DB	'DERIVED', 00H
_szlDERIVEDF DD	FLAT:$SG92893
$SG92893 DB	'DERIVEDF', 00H
	ORG $+3
_szlDFT_DBNAME DD FLAT:$SG92895
$SG92895 DB	'DFT_DBNAME', 00H
	ORG $+1
_szlDFT_SERVER DD FLAT:$SG92897
$SG92897 DB	'DFT_SERVER', 00H
	ORG $+1
_szlDLL_NAME DD	FLAT:$SG92899
$SG92899 DB	'DLL_NAME', 00H
	ORG $+3
_szlDOMAINTYPE DD FLAT:$SG92901
$SG92901 DB	'DOMAINTYPE', 00H
	ORG $+1
_szlDUPENTIN DD	FLAT:$SG92903
$SG92903 DB	'DUPENTIN', 00H
	ORG $+3
_szlDUPRELIN DD	FLAT:$SG92905
$SG92905 DB	'DUPRELIN', 00H
	ORG $+3
_szlECACC DD	FLAT:$SG92907
$SG92907 DB	'ECACC', 00H
	ORG $+2
_szlECCAN DD	FLAT:$SG92909
$SG92909 DB	'ECCAN', 00H
	ORG $+2
_szlECCR DD	FLAT:$SG92911
$SG92911 DB	'ECCR', 00H
	ORG $+3
_szlECDEL DD	FLAT:$SG92913
$SG92913 DB	'ECDEL', 00H
	ORG $+2
_szlECEOPER DD	FLAT:$SG92915
$SG92915 DB	'ECEOPER', 00H
_szlECEXC DD	FLAT:$SG92917
$SG92917 DB	'ECEXC', 00H
	ORG $+2
_szlECINC DD	FLAT:$SG92919
$SG92919 DB	'ECINC', 00H
	ORG $+2
_szlEDITSTRING DD FLAT:$SG92921
$SG99065 DB	'Out of memory pages!', 00H
	ORG $+3
$SG92921 DB	'EDITSTRING', 00H
	ORG $+1
_szlERATT_TOK DD FLAT:$SG92923
$SG92923 DB	'ERATT_TOK', 00H
	ORG $+2
_szlEntityName DD FLAT:$SG92925
$SG92925 DB	'EntityName', 00H
	ORG $+1
$SG99069 DB	'fnMapFile Page Table conflict at Index: %x   0x%08x   Pr'
	DB	'ocess: %d', 00H
	ORG $+2
$SG98045 DB	'SysSetDefaultTaskForProcess Deprecated', 00H
	ORG $+1
_szlEntitySpec DD FLAT:$SG92927
$SG98046 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG92927 DB	'EntitySpec', 00H
	ORG $+1
_szlERENT_TOK DD FLAT:$SG92929
$SG98048 DB	'Process already has a default task view', 00H
$SG98049 DB	'Zeidon Object Services', 00H
	ORG $+1
$SG92929 DB	'ERENT_TOK', 00H
	ORG $+2
_szlERREL_LINK DD FLAT:$SG92931
$SG92931 DB	'ERREL_LINK', 00H
	ORG $+1
_szlERREL_TOK DD FLAT:$SG92933
$SG92933 DB	'ERREL_TOK', 00H
	ORG $+2
_szlEXCLUDE DD	FLAT:$SG92935
$SG92935 DB	'EXCLUDE', 00H
_szlEXTERNALVALUE DD FLAT:$SG92937
$SG92937 DB	'EXTERNALVALUE', 00H
	ORG $+2
_szlFLDID DD	FLAT:$SG92939
$SG92939 DB	'FLDID', 00H
	ORG $+2
_szlFLDLTH DD	FLAT:$SG92941
_szlFLDNAME DD	FLAT:$SG92943
$SG100109 DB	'FreeLibrary sent message (0x%08x) for Module: %s - Task:'
	DB	' 0x%08x', 00H
$SG92941 DB	'FLDLTH', 00H
	ORG $+1
$SG100110 DB	'FreeLibrary did not free (0x%08x) Module: %s - Task: 0x%'
	DB	'08x', 00H
$SG92943 DB	'FLDNAME', 00H
_szlFLDOFFSET DD FLAT:$SG92945
$SG92945 DB	'FLDOFFSET', 00H
	ORG $+2
_szlFLDTYPE DD	FLAT:$SG92947
$SG92947 DB	'FLDTYPE', 00H
_szlFULLPERSIST DD FLAT:$SG92949
$SG92949 DB	'FULLPERSIST', 00H
_szlGENKEY DD	FLAT:$SG92951
$SG92951 DB	'GENKEY', 00H
	ORG $+1
_szlGKHANDLER DD FLAT:$SG92953
$SG98072 DB	'ON ', 00H
$SG99097 DB	'Diagnostic', 00H
	ORG $+1
$SG98073 DB	'OFF', 00H
$SG92953 DB	'GKHANDLER', 00H
	ORG $+2
_szlHANDLER DD	FLAT:$SG92955
$SG99098 DB	'[Debug]', 00H
$SG98074 DB	'Session Id: %s  ==> %s (%s)  Thread: %d ... null Subtask'
	DB	00H
	ORG $+3
$SG92955 DB	'HANDLER', 00H
_szlHIDDEN DD	FLAT:$SG92957
$SG98076 DB	'ON ', 00H
$SG98077 DB	'OFF', 00H
$SG92957 DB	'HIDDEN', 00H
	ORG $+1
_szlId	DD	FLAT:$SG92959
$SG98078 DB	'STP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d', 00H
	ORG $+3
$SG92959 DB	'Id', 00H
	ORG $+1
_szlINCLSRC DD	FLAT:$SG92961
$SG98080 DB	'STP S/V/T: %s/0x%08x/0x%08x  ==> Conflict with Task Sess'
	DB	'ion Id: %s  (%s)  Thread: %d', 00H
	ORG $+3
$SG92961 DB	'INCLSRC', 00H
_szlINCLUDE DD	FLAT:$SG92963
$SG92963 DB	'INCLUDE', 00H
_szlINCRLOAD DD	FLAT:$SG92965
$SG92965 DB	'INCRLOAD', 00H
	ORG $+3
_szlINIT DD	FLAT:$SG92967
$SG92967 DB	'INIT', 00H
	ORG $+3
_szlINTERNALVALUE DD FLAT:$SG92969
$SG92969 DB	'INTERNALVALUE', 00H
	ORG $+2
_szlISDEFAULT DD FLAT:$SG92971
$SG92971 DB	'ISDEFAULT', 00H
	ORG $+2
_szlKEY	DD	FLAT:$SG92973
$SG92973 DB	'KEY', 00H
_szlLanguageIndex DD FLAT:$SG92975
$SG92975 DB	'LanguageIndex', 00H
	ORG $+2
_szlLNAME DD	FLAT:$SG92977
$SG92977 DB	'LNAME', 00H
	ORG $+2
_szlLOCK DD	FLAT:$SG92979
$SG99122 DB	'ServerDebug', 00H
$SG99123 DB	'[Debug]', 00H
$SG98099 DB	'[App.', 00H
	ORG $+2
$SG92979 DB	'LOCK', 00H
	ORG $+3
_szlLTH	DD	FLAT:$SG92981
$SG98100 DB	']', 00H
	ORG $+2
$SG98101 DB	'WebDirectory', 00H
	ORG $+3
$SG92981 DB	'LTH', 00H
_szlMAXSTRINGLTH DD FLAT:$SG92983
$SG98103 DB	'WebDirectory', 00H
	ORG $+3
$SG92983 DB	'MAXSTRINGLTH', 00H
	ORG $+3
_szlMR_LIMIT DD	FLAT:$SG92985
$SG98104 DB	'[Workstation]', 00H
	ORG $+2
$SG92985 DB	'MR_LIMIT', 00H
	ORG $+3
_szl__MSGQ DD	FLAT:$SG92987
$SG99131 DB	'Message Handler Error opening log file (%s) for message:'
	DB	' %s', 00H
$SG92987 DB	'__MSGQ', 00H
	ORG $+1
_szlNAME DD	FLAT:$SG92989
$SG98108 DB	'0x%08x', 00H
	ORG $+1
$SG92989 DB	'NAME', 00H
	ORG $+3
_szlNETCOMPRESS DD FLAT:$SG92991
$SG92991 DB	'NETCOMPRESS', 00H
_szlNETWORK DD	FLAT:$SG92993
$SG92993 DB	'NETWORK', 00H
_szlNumAtts DD	FLAT:$SG92995
$SG92995 DB	'NumAtts', 00H
_szlNumEnts DD	FLAT:$SG92997
$SG92997 DB	'NumEnts', 00H
_szlNumRels DD	FLAT:$SG92999
$SG92999 DB	'NumRels', 00H
_szlOCACT DD	FLAT:$SG93001
$SG100169 DB	'[%s]', 00H
	ORG $+3
$SG93001 DB	'OCACT', 00H
	ORG $+2
_szlOCACTE DD	FLAT:$SG93003
$SG93003 DB	'OCACTE', 00H
	ORG $+1
_szlOCCOM DD	FLAT:$SG93005
$SG99149 DB	'WebUserErrorMessages', 00H
	ORG $+3
$SG93005 DB	'OCCOM', 00H
	ORG $+2
_szlOCDROP DD	FLAT:$SG93007
$SG99150 DB	'[ObjectEngine]', 00H
	ORG $+1
$SG98126 DB	'KZXMLPGO', 00H
	ORG $+3
$SG93007 DB	'OCDROP', 00H
	ORG $+1
_szlOCEOPER DD	FLAT:$SG93009
$SG93009 DB	'OCEOPER', 00H
_szlOFRECID DD	FLAT:$SG93011
$SG99154 DB	'SysMessageBox Title: %s   Error: %s', 00H
$SG98130 DB	'DialogName', 00H
	ORG $+1
$SG98131 DB	'Dialog', 00H
	ORG $+1
$SG93011 DB	'OFRECID', 00H
_szlOFBUFSZ DD	FLAT:$SG93013
$SG98132 DB	'Dialog', 00H
	ORG $+1
$SG98133 DB	'DialogName', 00H
	ORG $+1
$SG93013 DB	'OFBUFSZ', 00H
_szlOPER_LIBNM DD FLAT:$SG93015
$SG98134 DB	'Dialog', 00H
	ORG $+1
$SG93015 DB	'OPER_LIBNM', 00H
	ORG $+1
_szlOper DD	FLAT:$SG93017
$SG98137 DB	'WindowName', 00H
	ORG $+1
$SG93017 DB	'Oper', 00H
	ORG $+3
_szlOWNER_MEMB DD FLAT:$SG93019
$SG98138 DB	'Window', 00H
	ORG $+1
$SG98139 DB	'Window', 00H
	ORG $+1
$SG93019 DB	'OWNER_MEMB', 00H
	ORG $+1
_szlPDELETE DD	FLAT:$SG93021
$SG98140 DB	'WindowName', 00H
	ORG $+1
$SG98141 DB	'Window', 00H
	ORG $+1
$SG93021 DB	'PDELETE', 00H
_szlPERSIST DD	FLAT:$SG93023
$SG93023 DB	'PERSIST', 00H
_szlPNAME DD	FLAT:$SG93025
$SG98144 DB	'FocusCtrl', 00H
	ORG $+2
$SG98145 DB	'Window', 00H
	ORG $+1
$SG93025 DB	'PNAME', 00H
	ORG $+2
_szlQualAttrib DD FLAT:$SG93027
$SG93027 DB	'QualAttrib', 00H
	ORG $+1
_szlRECID DD	FLAT:$SG93029
$SG93029 DB	'RECID', 00H
	ORG $+2
_szlRECNAME DD	FLAT:$SG93031
$SG93031 DB	'RECNAME', 00H
_szlRECURSIVE DD FLAT:$SG93033
$SG93033 DB	'RECURSIVE', 00H
	ORG $+2
_szlREL	DD	FLAT:$SG93035
$SG98155 DB	'KZXMLPGO', 00H
	ORG $+3
$SG93035 DB	'REL', 00H
_szlRELFIELD DD	FLAT:$SG93037
$SG93037 DB	'RELFIELD', 00H
	ORG $+3
_szlRELRECORD DD FLAT:$SG93039
$SG99183 DB	'HH:MI:SS.999', 00H
	ORG $+3
$SG98159 DB	'DialogName', 00H
	ORG $+1
$SG93039 DB	'RELRECORD', 00H
	ORG $+2
_szlRELXVAATT_TOK DD FLAT:$SG93041
$SG99184 DB	'YYYY-MM-DD HH:MI:SS.999', 00H
$SG98160 DB	'DynamicBannerName', 00H
	ORG $+2
$SG99185 DB	'%s Task(%x) : ', 00H
	ORG $+1
$SG98161 DB	'DynamicBannerName', 00H
	ORG $+2
$SG93041 DB	'RELXVAATT_TOK', 00H
	ORG $+2
_szlREQUIRED DD	FLAT:$SG93043
$SG98162 DB	'DialogName', 00H
	ORG $+1
$SG98163 DB	'DynamicBannerName', 00H
	ORG $+2
$SG93043 DB	'REQUIRED', 00H
	ORG $+3
_szlRESTRICTED DD FLAT:$SG93045
$SG98164 DB	'BannerName', 00H
	ORG $+1
$SG100213 DB	'%s=%s', 00H
	ORG $+2
$SG99189 DB	'OE Trace Unavailable', 00H
	ORG $+3
$SG98165 DB	'DynamicBannerName', 00H
	ORG $+2
$SG93045 DB	'RESTRICTED', 00H
	ORG $+1
_szlSERVER DD	FLAT:$SG93047
$SG100214 DB	'zeidon.in~', 00H
	ORG $+1
$SG93047 DB	'SERVER', 00H
	ORG $+1
_szlSEQUENCING DD FLAT:$SG93049
$SG100217 DB	'[%s]', 00H
	ORG $+3
$SG93049 DB	'SEQUENCING', 00H
	ORG $+1
_szlSEQ_AD DD	FLAT:$SG93051
$SG100219 DB	'[Zeidon]', 00H
	ORG $+3
$SG93051 DB	'SEQ_AD', 00H
	ORG $+1
_szlSETID1 DD	FLAT:$SG93053
$SG100221 DB	'[Encyclopedia]', 00H
	ORG $+1
$SG93053 DB	'SETID1', 00H
	ORG $+1
_szlSETID2 DD	FLAT:$SG93055
$SG98174 DB	'KZXMLPGO', 00H
	ORG $+3
$SG100223 DB	'[Workstation]', 00H
	ORG $+2
$SG93055 DB	'SETID2', 00H
	ORG $+1
_szlSETNAME1 DD	FLAT:$SG93057
$SG100225 DB	'[Object Services]', 00H
	ORG $+2
$SG93057 DB	'SETNAME1', 00H
	ORG $+3
_szlSETNAME2 DD	FLAT:$SG93059
$SG98178 DB	'DialogName', 00H
	ORG $+1
$SG98179 DB	'DynamicBannerName', 00H
	ORG $+2
$SG93059 DB	'SETNAME2', 00H
	ORG $+3
_szlSRCXVAATT_TOK DD FLAT:$SG93061
$SG98180 DB	'DialogName', 00H
	ORG $+1
$SG98181 DB	'DynamicBannerName', 00H
	ORG $+2
$SG93061 DB	'SRCXVAATT_TOK', 00H
	ORG $+2
_szlTask DD	FLAT:$SG93063
$SG93063 DB	'Task', 00H
	ORG $+3
_szlText DD	FLAT:$SG93065
$SG93065 DB	'Text', 00H
	ORG $+3
_szlTYPE DD	FLAT:$SG93067
$SG99211 DB	'(sy) Logon Userid=', 00H
	ORG $+1
$SG93067 DB	'TYPE', 00H
	ORG $+3
_szlUP_DATE DD	FLAT:$SG93069
$SG93069 DB	'UP_DATE', 00H
_szlUSERID DD	FLAT:$SG93071
$SG93071 DB	'USERID', 00H
	ORG $+1
_szlUPDATE DD	FLAT:$SG93073
$SG93073 DB	'UPDATE', 00H
	ORG $+1
_szlZKEY DD	FLAT:$SG93075
$SG93075 DB	'ZKEY', 00H
	ORG $+3
_szlApplicationLogicError DD FLAT:$SG93077
$SG93077 DB	'Object Services - Application Logic Error', 00H
	ORG $+2
_szlDataValidationError DD FLAT:$SG93079
$SG93079 DB	'Data Validation Error', 00H
	ORG $+2
_szlOE_SystemError DD FLAT:$SG93081
$SG93081 DB	'OE System Error', 00H
_szlAFTER DD	FLAT:$SG93083
$SG93083 DB	'AFTER', 00H
	ORG $+2
_szlBEFORE DD	FLAT:$SG93085
$SG93085 DB	'BEFORE', 00H
	ORG $+1
_g_pchMQI DD	FLAT:$SG93087
	DD	FLAT:$SG93088
	DD	FLAT:$SG93089
	DD	FLAT:$SG93090
$SG93087 DB	'MQ_MessageSend', 00H
	ORG $+1
$SG93088 DB	'MQ_MessagePrompt', 00H
	ORG $+3
$SG93089 DB	'MQ_MessagePromptForInput', 00H
	ORG $+3
$SG93090 DB	'MQ_MessagePresent', 00H
	ORG $+2
_szGAFANullS DD	FLAT:$SG93092
_g_pchMon DD	FLAT:$SG93094
	DD	FLAT:$SG93095
	DD	FLAT:$SG93096
	DD	FLAT:$SG93097
	DD	FLAT:$SG93098
	DD	FLAT:$SG93099
	DD	FLAT:$SG93100
	DD	FLAT:$SG93101
	DD	FLAT:$SG93102
	DD	FLAT:$SG93103
	DD	FLAT:$SG93104
	DD	FLAT:$SG93105
$SG93094 DB	'January', 00H
$SG93095 DB	'February', 00H
	ORG $+3
$SG93096 DB	'March', 00H
	ORG $+2
$SG93097 DB	'April', 00H
	ORG $+2
$SG100266 DB	'Error in directory specification', 00H
	ORG $+3
$SG93098 DB	'May', 00H
$SG100267 DB	'Zeidon Error', 00H
	ORG $+3
$SG93099 DB	'June', 00H
	ORG $+3
$SG93100 DB	'July', 00H
	ORG $+3
$SG93101 DB	'August', 00H
	ORG $+1
$SG93102 DB	'September', 00H
	ORG $+2
$SG93103 DB	'October', 00H
$SG93104 DB	'November', 00H
	ORG $+3
$SG93105 DB	'December', 00H
	ORG $+3
_g_pchDOW DD	FLAT:$SG93107
	DD	FLAT:$SG93108
	DD	FLAT:$SG93109
	DD	FLAT:$SG93110
	DD	FLAT:$SG93111
	DD	FLAT:$SG93112
	DD	FLAT:$SG93113
$SG100274 DB	'Error creating directory', 00H
	ORG $+3
$SG98226 DB	'KZOENGWA - Termination', 00H
	ORG $+1
$SG100275 DB	'Zeidon Error', 00H
	ORG $+3
$SG98227 DB	'The Zeidon Object Engine hasn''t finished shutting down.'
	DB	' Please wait for the engine to shut down and restart.', 00H
	ORG $+3
$SG93107 DB	'Sunday', 00H
	ORG $+1
$SG93108 DB	'Monday', 00H
	ORG $+1
$SG93109 DB	'Tuesday', 00H
$SG93110 DB	'Wednesday', 00H
	ORG $+2
$SG93111 DB	'Thursday', 00H
	ORG $+3
$SG93112 DB	'Friday', 00H
	ORG $+1
$SG93113 DB	'Saturday', 00H
	ORG $+3
_szlINTL DD	FLAT:$SG93115
$SG93115 DB	'Intl', 00H
	ORG $+3
_szlICOUNTRY DD	FLAT:$SG93117
$SG93117 DB	'iCountry', 00H
	ORG $+3
_szlSCOUNTRY DD	FLAT:$SG93119
$SG98239 DB	'InitCriticalSection: ', 00H
	ORG $+2
$SG93119 DB	'sCountry', 00H
	ORG $+3
_szlSLANGUAGE DD FLAT:$SG93121
$SG93121 DB	'sLanguage', 00H
	ORG $+2
_szlSLIST DD	FLAT:$SG93123
$SG93123 DB	'sList', 00H
	ORG $+2
_szlIMEASURE DD	FLAT:$SG93125
$SG93125 DB	'iMeasure', 00H
	ORG $+3
_szlITIME DD	FLAT:$SG93127
$SG93127 DB	'iTime', 00H
	ORG $+2
_szlSTIME DD	FLAT:$SG93129
$SG100297 DB	'SYSTEM HELP', 00H
$SG99273 DB	'%sZTF_%lx_%lx.TMP', 00H
	ORG $+2
_szlS1159 DD	FLAT:$SG93131
$SG98249 DB	'RegisterZeidonApplication ===============> %s   V/Task: '
	DB	'0x%08x / 0x%08x  Process: %d   Thread: %d', 00H
	ORG $+2
$SG93129 DB	'sTime', 00H
	ORG $+2
$SG100298 DB	'SYSTEM HELP', 00H
$SG98250 DB	'RegisterZeidonApplication ===============> %s   Process:'
	DB	' %d   Thread: %d   Memory: %s   Wnd: 0x%08x=%d', 00H
	ORG $+1
$SG100299 DB	'SYSTEM HELP', 00H
$SG93131 DB	's1159', 00H
	ORG $+2
_szlS2359 DD	FLAT:$SG93133
$SG100300 DB	'winhelp.hlp', 00H
$SG93133 DB	's2359', 00H
	ORG $+2
_szlITLZERO DD	FLAT:$SG93135
$SG93135 DB	'iTLZero', 00H
_szlSSHORTDATE DD FLAT:$SG93137
$SG93137 DB	'sShortDate', 00H
	ORG $+1
_szlSLONGDATE DD FLAT:$SG93139
$SG100306 DB	'.CHM', 00H
	ORG $+3
$SG100307 DB	'.CHM', 00H
	ORG $+3
$SG93139 DB	'sLongDate', 00H
	ORG $+2
_szlSCURRENCY DD FLAT:$SG93141
$SG100308 DB	'>mainwin', 00H
	ORG $+3
$SG93141 DB	'sCurrency', 00H
	ORG $+2
_szlICURRENCY DD FLAT:$SG93143
$SG100311 DB	'(sy) Starting help with: ', 00H
	ORG $+2
$SG93143 DB	'iCurrency', 00H
	ORG $+2
_szlICURRDIGITS DD FLAT:$SG93145
$SG100313 DB	'(sy) Starting context-sensitive help with: ', 00H
$SG93145 DB	'iCurrDigits', 00H
_szlINEGCURR DD	FLAT:$SG93147
$SG100314 DB	'MyWindowType', 00H
	ORG $+3
$SG93147 DB	'iNegCurr', 00H
	ORG $+3
_szlSTHOUSAND DD FLAT:$SG93149
$SG93149 DB	'sThousand', 00H
	ORG $+2
_szlSDECIMAL DD	FLAT:$SG93151
$SG93151 DB	'sDecimal', 00H
	ORG $+3
_szlIDIGITS DD	FLAT:$SG93153
$SG98273 DB	'(Unr) Cleaning up Registered S/Task: 0x%08x / 0x%08x (%d'
	DB	')   Process: %d   Thread: %d  %s', 00H
	ORG $+3
$SG93153 DB	'iDigits', 00H
_szlILZERO DD	FLAT:$SG93155
$SG93155 DB	'iLzero', 00H
	ORG $+1
$SG93161 DB	'KZOEE001 - Error communicating with client window', 00H
	ORG $+2
$SG93162 DB	'KZOEE002 - ZEIDON environment variable not set', 00H
	ORG $+1
$SG93163 DB	'KZOEE003 - Error starting Object Services', 00H
	ORG $+2
$SG93164 DB	'KZOEE004 - Error communicating with Object Services', 00H
$SG93165 DB	'KZOEE005 - Error communicating with Object Services', 00H
$SG100334 DB	' = %lf seconds', 00H
	ORG $+1
$SG93166 DB	'KZOEE006 - Internal error freeing Anchor Block', 00H
	ORG $+1
$SG93167 DB	'KZOEE007 - Internal Anchor block error, system restart r'
	DB	'ecommended', 00H
	ORG $+1
$SG93170 DB	'KZOEE010 - Requested application not found', 00H
	ORG $+1
$SG93168 DB	'KZOEE008 - Application definition file missing ZEIDON_BI'
	DB	'N or ZEIDON_SYS', 00H
$SG93169 DB	'KZOEE009 - Error opening application definition file', 00H
	ORG $+3
$SG93171 DB	'KZOEE011 - Error opening application domains file', 00H
	ORG $+2
$SG93172 DB	'KZOEE012 - Error allocating memory', 00H
	ORG $+1
$SG93173 DB	'KZOEE013 - Internal operation call error', 00H
	ORG $+3
$SG93174 DB	'KZOEE014 - Invalid suballoc memory free - ID=', 00H
	ORG $+2
$SG93175 DB	'KZOEE015 - Invalid suballoc memory free', 00H
$SG93176 DB	'KZOEE016 - Invalid Task', 00H
$SG93177 DB	'KZOEE017 - Task is Disabled', 00H
$SG93178 DB	'KZOEE018 - Error in Domain file, line: ', 00H
$SG93179 DB	'KZOEE019 - Invalid GetTaskInfo request: ', 00H
	ORG $+3
$SG93180 DB	'KZOEE020 - Invalid Operation call ', 00H
	ORG $+1
$SG93181 DB	'KZOEE021 - Internal error, TaskOperation block has no Ob'
	DB	'ject/Entity/Attr', 00H
	ORG $+3
$SG93182 DB	'KZOEE022 - Error writing file', 00H
	ORG $+2
$SG93183 DB	'KZOEE023 - Invalid parameter, ', 00H
	ORG $+5
$SG99327 DB	'SysRenameFile MoveFile RC: %ld   FileSpecFrom: %s   File'
	DB	'SpecTo: %s   Error: %s', 00H
_DATA	ENDS
PUBLIC	_SysDescribeZeidonPageTable@4
PUBLIC	_SysMutexClose@4
PUBLIC	_SysMutexCreate@12
PUBLIC	_SysMutexLock@16
PUBLIC	_SysMutexUnlock@12
PUBLIC	_SysMutexQueryLock@4
PUBLIC	_SysMutexQueryStatus@0
PUBLIC	_RegisterZeidonApplication@28
PUBLIC	_ProcessZeidonMessage@8
PUBLIC	_UnregisterZeidonApplication@4
PUBLIC	_fnReuseEntity@4
PUBLIC	_SysAddressMemory@4
PUBLIC	_SysAllocMemory@20
PUBLIC	_SysAppendcDirSep@4
PUBLIC	_SysSetFocusToWebCtrl@20
PUBLIC	_SysMakeWebFileName@12
PUBLIC	_SysSetWebBannerName@12
PUBLIC	_SysGetWebBannerName@12
PUBLIC	_SysCheckTaskMemory@0
PUBLIC	_fnSysCloseFile@12
PUBLIC	_SysCloseFile@12
PUBLIC	_fnSysCloseFileWithControl@16
PUBLIC	_SysCloseFileWithControl@16
PUBLIC	_SysConvertANSI_String@4
PUBLIC	_SysConvertEnvironmentString@8
PUBLIC	_fnSysCopyFile@16
PUBLIC	_SysCopyFile@16
PUBLIC	_SysCreateTempFileName@4
PUBLIC	_SysDiagnosticMessage@16
PUBLIC	_SysElapsedTimer@8
PUBLIC	_SysFree@4
PUBLIC	_fnSysFreeLibrary@12
PUBLIC	_SysFreeLibrary@8
PUBLIC	_SysFreeMemory@4
PUBLIC	_SysGetDateTime@4
PUBLIC	_SysGetServerDateTime@8
PUBLIC	_SysGetDateTimeDifference@16
PUBLIC	_SysGetDB_UserID@12
PUBLIC	_SysGetEnvVar@12
PUBLIC	_SysGetFileDateTime@8
PUBLIC	_SysGetFilePosition@4
PUBLIC	_SysGetFileSize@4
PUBLIC	_SysGetHandleFromPointer@4
PUBLIC	_SysGetLanguageCode@4
PUBLIC	_SysGetLocalDirectory@4
PUBLIC	_SysGetLocalSysDirectory@4
PUBLIC	_SysGetLongDateFormat@4
PUBLIC	_SysGetNumberFormat@12
PUBLIC	_SysGetOS_Info@4
PUBLIC	_SysGetPointerFromHandle@4
PUBLIC	_SysGetInstance@4
PUBLIC	_SysGetProc@8
PUBLIC	_SysGetProcessID@4
PUBLIC	_SysGetTaskFromView@4
PUBLIC	_SetTransientTaskProcess@16
PUBLIC	_SysGetShortDateFormat@4
PUBLIC	_SysGetTickCount@0
PUBLIC	_SysGetTimeFormat@4
PUBLIC	_SysGetUserID@12
PUBLIC	_SysLoadLibrary@8
PUBLIC	_SysLoadLibraryWithErrFlag@12
PUBLIC	_SysMalloc@4
PUBLIC	_SysMemSize@4
PUBLIC	_SysMessageBeep@0
PUBLIC	_fnSysMessageBox@16
PUBLIC	_SysMessageBox@16
PUBLIC	_SysMessageList@4
PUBLIC	_fnSysOpenFile@12
PUBLIC	_SysOpenFile@12
PUBLIC	_SysParseLine@12
PUBLIC	_SysPositionFile@8
PUBLIC	_fnSysReadFile@16
PUBLIC	_SysReadFile@16
PUBLIC	_fnSysReadLine@16
PUBLIC	_SysReadLine@12
PUBLIC	_fnSysReadLineLth@20
PUBLIC	_SysReadLineLth@16
PUBLIC	_SysReadZeidonIni@16
PUBLIC	_fnSysRenameFile@16
PUBLIC	_SysRenameFile@16
PUBLIC	_SysSendOE_Message@8
PUBLIC	_SysSetFileTime@12
PUBLIC	_SysSetDB_UserID@12
PUBLIC	_SysSetDefaultTaskForProcess@4
PUBLIC	_SysSetLanguageCode@4
PUBLIC	_SysSetUserID@12
PUBLIC	_SysStartHelp@8
PUBLIC	_SysStartTimer@4
PUBLIC	_SysTranslateString@8
PUBLIC	_fnSysTruncateFile@8
PUBLIC	_SysTruncateFile@8
PUBLIC	_SysUpdateZeidonIni@12
PUBLIC	_SysValidAddress@12
PUBLIC	_SysValidDirOrFile@16
PUBLIC	_SysWait@4
PUBLIC	_fnSysWriteFile@16
PUBLIC	_SysWriteFile@16
PUBLIC	_fnSysWriteLine@16
PUBLIC	_SysWriteLine@12
PUBLIC	_fnSysWriteLineLth@24
PUBLIC	_SysWriteLineLth@20
PUBLIC	_SysStartBrowseOfTaskList@4
PUBLIC	_SysEndBrowseOfTaskList@0
PUBLIC	_SysGetClientMessage@0
PUBLIC	_SysInitApplicationWindow@12
PUBLIC	_fnSysCreateCoreMutex@4
PUBLIC	_fnSysDestroyCoreMutex@4
PUBLIC	_fnSysLockCoreMutex@4
PUBLIC	_fnSysUnlockCoreMutex@4
PUBLIC	_fnConvertEnvironmentString@8
PUBLIC	_InitializeAnchorBlock@16
PUBLIC	_FreeAnchorBlock@4
PUBLIC	_SysGetAnchorBlock@0
PUBLIC	_SysGetAnchorBlockData@4
PUBLIC	_SysGetBaseMessage@12
PUBLIC	_SysGetOperationMessage@12
PUBLIC	_SysStartObjectServices
PUBLIC	_SfListTasks
PUBLIC	_SysCreateInternational@0
PUBLIC	_SysFreeInternational@4
PUBLIC	_fnAllocSharedMemory@16
PUBLIC	_fnFreeSharedMemory@8
PUBLIC	_fnSysCreateHandle@8
PUBLIC	_fnFreeLocalAnchorBlock@4
PUBLIC	_fnSysMutexUnlock@8
PUBLIC	_fnSysMutexLock@16
PUBLIC	_fnSysMutexDestroy@8
PUBLIC	_fnMutexCreateOS@12
PUBLIC	_FindWebSubtask@4
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnMutexFind@8
PUBLIC	_fnMutexCreate@16
PUBLIC	_fnMapFile@16
PUBLIC	_fnSetProcessIdx
PUBLIC	_fnConvertToZeidonFormat
PUBLIC	_fnBuildZeidonIni
PUBLIC	_CheckPointer
PUBLIC	_fnGetAnchorBlock@8
PUBLIC	_fnSysGetPointerFromHandleServerMode@4
PUBLIC	_fnSysGetPointerFromHandleShared@4
PUBLIC	_fnSysGetHandleFromPointerServerMode@4
PUBLIC	_fnSysGetHandleFromPointerShared@4
PUBLIC	__zCall_GetDateTime@8
PUBLIC	_SysSetAnchorBlock@4
PUBLIC	_fnDecimalOperation@16
PUBLIC	_fnHashName@4
PUBLIC	_SysMainWndProc@16
PUBLIC	_DllMain@12
PUBLIC	__real@0000000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@4024000000000000
PUBLIC	__real@408f400000000000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__toupper:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strrchr:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncat:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp___strnicmp:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp___strupr:PROC
EXTRN	__imp__GetEnvironmentVariableA@12:PROC
EXTRN	__imp__SetCurrentDirectoryA@4:PROC
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	__imp__SearchPathA@24:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__GetFileAttributesA@4:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__GetFileTime@16:PROC
EXTRN	__imp__GetFullPathNameA@16:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__SetFileTime@16:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__DuplicateHandle@28:PROC
EXTRN	__imp__GetHandleInformation@8:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__DeleteCriticalSection@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetCurrentProcess@0:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__GetCurrentThreadId@0:PROC
EXTRN	__imp__CreateProcessA@40:PROC
EXTRN	__imp__OpenProcess@12:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__MapViewOfFile@20:PROC
EXTRN	__imp__UnmapViewOfFile@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
EXTRN	__imp__LocalFree@4:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__OpenMutexA@12:PROC
EXTRN	__imp__CreateFileMappingA@24:PROC
EXTRN	__imp__OpenFileMappingA@12:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GetProfileIntA@12:PROC
EXTRN	__imp__GetProfileStringA@20:PROC
EXTRN	__imp__GetPrivateProfileIntA@16:PROC
EXTRN	__imp__GetPrivateProfileStringA@24:PROC
EXTRN	__imp__MoveFileA@8:PROC
EXTRN	__imp__IsBadReadPtr@8:PROC
EXTRN	__imp__IsBadWritePtr@8:PROC
EXTRN	__imp__FileTimeToSystemTime@8:PROC
EXTRN	__imp__SystemTimeToFileTime@8:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__SendMessageA@16:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__IsWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__CharUpperA@4:PROC
EXTRN	__imp__CharLowerA@4:PROC
EXTRN	__imp__GetActiveWindow@0:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__MessageBeep@4:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__WinHelpA@16:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp___msize:PROC
EXTRN	__imp__atof:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	__imp__floor:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_DisplayOpenFiles@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_IssueError@16:PROC
EXTRN	_SetViewFlags@8:PROC
EXTRN	_GetDefaultViewForActiveTask@0:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_GetEntityKey@8:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_MiListOE_Memory@8:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_UfFormatDateTime@12:PROC
EXTRN	_MessageSend@24:PROC
EXTRN	_NetClose@8:PROC
EXTRN	_NetCallOperation:PROC
EXTRN	_NetStatus@8:PROC
EXTRN	_SfStartNetworks@8:PROC
EXTRN	_ActivateViewObject@12:PROC
EXTRN	_SfCreateSystemSubtask@12:PROC
EXTRN	_SfDropSubtask@8:PROC
EXTRN	_UfStringToDateTime@8:PROC
EXTRN	_UfDateTimeDiff@16:PROC
EXTRN	_SfGetApplicationForSubtask@8:PROC
EXTRN	_fnParseAppString:PROC
EXTRN	_fnCreateApp:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnStoreStringInDataspace:PROC
EXTRN	_fnInitializeDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_DeleteTask@4:PROC
EXTRN	_fnDropTaskDomains@4:PROC
EXTRN	_fnCreateTask:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnStartBrowseOfTaskList@8:PROC
EXTRN	_fnEndBrowseOfTaskList@4:PROC
EXTRN	_fnValidView:PROC
EXTRN	_fnDropTaskOperation@8:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_HtmlHelpA@16:PROC
EXTRN	_fnTraceCompileTime@0:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_g_pProbeArea:DWORD
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hNextLibrary$1 = -756					; size = 4
_lpNextTaskOperation$2 = -752				; size = 4
_lpSystemTask$3 = -748					; size = 4
_lpProcessList$4 = -744					; size = 4
_lpLibrary$5 = -740					; size = 4
_vSystemView$6 = -736					; size = 4
_lpNextNetwork$7 = -732					; size = 4
tv64 = -728						; size = 4
_hMutex$8 = -724					; size = 4
_hNextMutex$9 = -720					; size = 4
_lpPrevMutex$10 = -716					; size = 4
_lProcessID$11 = -712					; size = 4
_hLibrary$12 = -708					; size = 4
_lpTaskOperation$13 = -704				; size = 4
_lpNetwork$14 = -700					; size = 4
_lpMutex$15 = -696					; size = 4
_k$16 = -692						; size = 4
_lpTask$17 = -688					; size = 4
_k$18 = -684						; size = 2
_os$19 = -680						; size = 148
_szFileName$20 = -532					; size = 257
_szMessage$21 = -272					; size = 256
_szServerMode$22 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_hDLL$ = 8						; size = 4
_dwReason$ = 12						; size = 4
_lpReserved$ = 16					; size = 4
_DllMain@12 PROC

; 10307: {

	push	ebp
	mov	ebp, esp
	sub	esp, 756				; 000002f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 10308:   switch ( dwReason )

	mov	eax, DWORD PTR _dwReason$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 0
	je	$LN31@DllMain
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN26@DllMain
	jmp	$LN2@DllMain
$LN26@DllMain:

; 10309:   {
; 10310:       case DLL_PROCESS_ATTACH:
; 10311:       {
; 10312:          zSHORT        k;
; 10313:          OSVERSIONINFO os;
; 10314:          zCHAR         szFileName[ zMAX_FILENAME_LTH + 1 ];
; 10315:          zCHAR         szServerMode[ 10 ];
; 10316: 
; 10317:          g_lCurrentProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _g_lCurrentProcessID, eax

; 10318:          g_hInstance = hDLL;

	mov	ecx, DWORD PTR _hDLL$[ebp]
	mov	DWORD PTR _g_hInstance, ecx

; 10319: 
; 10320: #ifdef DEBUG_MALLOC
; 10321:          SysMalloc( -2 );
; 10322: #endif
; 10323:          // Register message of Object Services.
; 10324:          g_wOENG_Message = RegisterWindowMessage( "KZOESRVC" );

	push	OFFSET $SG100909
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	DWORD PTR _g_wOENG_Message, eax

; 10325: 
; 10326:          // Figure out the OS version.
; 10327:          zmemset( &os, 0, sizeof( os ) );

	push	148					; 00000094H
	push	0
	lea	edx, DWORD PTR _os$19[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 10328:          os.dwOSVersionInfoSize = sizeof( os );

	mov	DWORD PTR _os$19[ebp], 148		; 00000094H

; 10329:          GetVersionEx( &os );

	lea	eax, DWORD PTR _os$19[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4

; 10330: 
; 10331:          // Check the ServerMode flag in Zeidon.ini.  Since the OE is not running
; 10332:          // yet, we have to use GetPrivateProfileString( ).
; 10333:          k = fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	ecx, DWORD PTR _szFileName$20[ebp]
	push	ecx
	call	_fnBuildZeidonIni
	add	esp, 8
	mov	WORD PTR _k$18[ebp], ax

; 10334:          if ( k == 0 )

	movsx	edx, WORD PTR _k$18[ebp]
	test	edx, edx
	jne	SHORT $LN27@DllMain

; 10335:          {
; 10336:             char szMessage[ 256 ];
; 10337: 
; 10338:             // {2,"KZOEE002 - ZEIDON environment variable not set"},
; 10339:             SysGetBaseMessage( szMessage, KZOEE002, sizeof( szMessage ) );

	push	256					; 00000100H
	push	2
	lea	eax, DWORD PTR _szMessage$21[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 10340:             SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMessage$21[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 10341: 
; 10342:             return( 1 );

	mov	eax, 1
	jmp	$LN1@DllMain
$LN27@DllMain:

; 10343:          }
; 10344: 
; 10345:          GetPrivateProfileString( "ObjectEngine", "ServerMode", "N", szServerMode,

	lea	eax, DWORD PTR _szFileName$20[ebp]
	push	eax
	push	10					; 0000000aH
	lea	ecx, DWORD PTR _szServerMode$22[ebp]
	push	ecx
	push	OFFSET $SG100911
	push	OFFSET $SG100912
	push	OFFSET $SG100913
	call	DWORD PTR __imp__GetPrivateProfileStringA@24

; 10346:                                   sizeof( szServerMode ), szFileName );
; 10347:          if ( toupper( szServerMode[ 0 ] ) == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szServerMode$22[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN28@DllMain

; 10348:             g_bServerMode = TRUE;

	mov	BYTE PTR _g_bServerMode, 1
$LN28@DllMain:

; 10349: 
; 10350:          // We need to set up the handle/pointer conversion function.  In
; 10351:          // Win95, handle and pointers are the same thing.  Note that in
; 10352:          // server mode, handles and pointers are the same as well, so we'll
; 10353:          // use the same conversion functions.
; 10354:          if ( os.dwPlatformId == VER_PLATFORM_WIN32_NT && g_bServerMode == FALSE )

	cmp	DWORD PTR _os$19[ebp+16], 2
	jne	SHORT $LN29@DllMain
	movzx	edx, BYTE PTR _g_bServerMode
	test	edx, edx
	jne	SHORT $LN29@DllMain

; 10355:          {
; 10356:             g_bWin95 = FALSE;

	mov	BYTE PTR _g_bWin95, 0

; 10357:             g_pfnGetPtr = fnSysGetPointerFromHandleShared;

	mov	DWORD PTR _g_pfnGetPtr, OFFSET _fnSysGetPointerFromHandleShared@4

; 10358:             g_pfnGetHndl = fnSysGetHandleFromPointerShared;

	mov	DWORD PTR _g_pfnGetHndl, OFFSET _fnSysGetHandleFromPointerShared@4

; 10359:          }

	jmp	SHORT $LN30@DllMain
$LN29@DllMain:

; 10360:          else
; 10361:          {
; 10362:             g_pfnGetPtr = fnSysGetPointerFromHandleServerMode;

	mov	DWORD PTR _g_pfnGetPtr, OFFSET _fnSysGetPointerFromHandleServerMode@4

; 10363:             g_pfnGetHndl = fnSysGetHandleFromPointerServerMode;

	mov	DWORD PTR _g_pfnGetHndl, OFFSET _fnSysGetHandleFromPointerServerMode@4
$LN30@DllMain:

; 10364:          }
; 10365: 
; 10366: #ifdef __MUTEX_DEBUG__
; 10367:          g_hMutexDbg = CreateMutex( NULL, FALSE, MUTEXDBG_NAME );
; 10368: #endif
; 10369: 
; 10370:          for ( k = 0; k < zMUTEX_COUNT; k++ )

	xor	eax, eax
	mov	WORD PTR _k$18[ebp], ax
	jmp	SHORT $LN6@DllMain
$LN4@DllMain:
	mov	cx, WORD PTR _k$18[ebp]
	add	cx, 1
	mov	WORD PTR _k$18[ebp], cx
$LN6@DllMain:
	movsx	edx, WORD PTR _k$18[ebp]
	cmp	edx, 16					; 00000010H
	jge	SHORT $LN5@DllMain

; 10371:             zCREATE_MUTEX( k );

	movsx	eax, WORD PTR _k$18[ebp]
	push	eax
	call	_fnSysCreateCoreMutex@4
	jmp	SHORT $LN4@DllMain
$LN5@DllMain:

; 10372: 
; 10373:          // Initialize critical sections used in this file.
; 10374:          InitializeCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET _g_csSysLoadLibrary
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 10375:          InitializeCriticalSection( &g_csReuseEntity );

	push	OFFSET _g_csReuseEntity
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 10376: 
; 10377:          break;

	jmp	$LN2@DllMain
$LN31@DllMain:

; 10378:       }
; 10379: 
; 10380:       case DLL_PROCESS_DETACH:
; 10381:       {
; 10382:          zLONG     k;
; 10383: 
; 10384:          if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN32@DllMain

; 10385:          {
; 10386:             LPPROCESSLIST lpProcessList;
; 10387:             LPTASK     lpSystemTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSystemTask$3[ebp], eax

; 10388:             zVIEW      vSystemView = zGETPTR( lpSystemTask->hFirstView );

	mov	eax, DWORD PTR _lpSystemTask$3[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vSystemView$6[ebp], eax

; 10389:             LPTASK     lpTask;
; 10390:             LPNETWORK  lpNetwork;
; 10391:             LPNETWORK  lpNextNetwork;
; 10392:             LPTASKOPER lpTaskOperation;
; 10393:             LPTASKOPER lpNextTaskOperation;
; 10394:             LPLIBRARY  hLibrary;
; 10395:             LPLIBRARY  lpLibrary;
; 10396:             LPLIBRARY  hNextLibrary;
; 10397:             LPMUTEX    hMutex;
; 10398:             LPMUTEX    lpMutex;
; 10399:             LPMUTEX    lpPrevMutex;
; 10400:             LPMUTEX    hNextMutex;
; 10401:             zLONG      lProcessID = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _lProcessID$11[ebp], eax

; 10402: 
; 10403:             if ( vSystemView )

	cmp	DWORD PTR _vSystemView$6[ebp], 0
	je	$LN33@DllMain

; 10404:             {
; 10405:                zLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysLockCoreMutex@4

; 10406: 
; 10407:                lpNextNetwork = 0;

	mov	DWORD PTR _lpNextNetwork$7[ebp], 0

; 10408:                for ( lpNetwork = zGETPTR( AnchorBlock->hFirstNetwork );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+122]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNetwork$14[ebp], eax
	jmp	SHORT $LN9@DllMain
$LN7@DllMain:

; 10410:                      lpNetwork = lpNextNetwork )

	mov	ecx, DWORD PTR _lpNextNetwork$7[ebp]
	mov	DWORD PTR _lpNetwork$14[ebp], ecx
$LN9@DllMain:

; 10409:                      lpNetwork;

	cmp	DWORD PTR _lpNetwork$14[ebp], 0
	je	SHORT $LN8@DllMain

; 10411:                {
; 10412:                   lpNextNetwork = zGETPTR( lpNetwork->hNextNetwork );

	mov	edx, DWORD PTR _lpNetwork$14[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextNetwork$7[ebp], eax

; 10413: 
; 10414:                   if ( lpNetwork->lProcessID != lProcessID )

	mov	ecx, DWORD PTR _lpNetwork$14[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR _lProcessID$11[ebp]
	je	SHORT $LN34@DllMain

; 10415:                      continue;

	jmp	SHORT $LN7@DllMain
$LN34@DllMain:

; 10416: 
; 10417:                   NetClose( vSystemView, lpNetwork->szNetworkName );

	mov	eax, DWORD PTR _lpNetwork$14[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _vSystemView$6[ebp]
	push	ecx
	call	_NetClose@8

; 10418:                }

	jmp	SHORT $LN7@DllMain
$LN8@DllMain:

; 10419: 
; 10420:                zUNLOCK_MUTEX( zMUTEX_NETWORKCHAIN );

	push	15					; 0000000fH
	call	_fnSysUnlockCoreMutex@4
$LN33@DllMain:

; 10421:             }
; 10422: 
; 10423:             zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 10424: 
; 10425:             // Get a 'write' lock on the task list.  We pass in -1 for the
; 10426:             // task to indicate that we have no task.  It is used by Browse
; 10427:             // for information only.
; 10428:             fnStartBrowseOfTaskList( (LPTASK) -1, FALSE );

	push	0
	push	-1
	call	_fnStartBrowseOfTaskList@8

; 10429: 
; 10430:             for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$17[ebp], eax
	jmp	SHORT $LN12@DllMain
$LN10@DllMain:

; 10432:                   lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	ecx, DWORD PTR _lpTask$17[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$17[ebp], eax
$LN12@DllMain:

; 10431:                   lpTask;

	cmp	DWORD PTR _lpTask$17[ebp], 0
	je	$LN11@DllMain

; 10433:             {
; 10434:                for ( lpTaskOperation = zGETPTR( lpTask->hFirstTaskOperation );

	mov	eax, DWORD PTR _lpTask$17[ebp]
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskOperation$13[ebp], eax
	jmp	SHORT $LN15@DllMain
$LN13@DllMain:

; 10436:                      lpTaskOperation = lpNextTaskOperation )

	mov	edx, DWORD PTR _lpNextTaskOperation$2[ebp]
	mov	DWORD PTR _lpTaskOperation$13[ebp], edx
$LN15@DllMain:

; 10435:                      lpTaskOperation;

	cmp	DWORD PTR _lpTaskOperation$13[ebp], 0
	je	SHORT $LN14@DllMain

; 10437:                {
; 10438:                   lpNextTaskOperation =

	mov	eax, DWORD PTR _lpTaskOperation$13[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskOperation$2[ebp], eax

; 10439:                         zGETPTR( lpTaskOperation->hNextTaskOperationForTask );
; 10440: 
; 10441:                   if ( lpTaskOperation->lProcessID == g_lCurrentProcessID )

	mov	edx, DWORD PTR _lpTaskOperation$13[ebp]
	mov	eax, DWORD PTR [edx+34]
	cmp	eax, DWORD PTR _g_lCurrentProcessID
	jne	SHORT $LN35@DllMain

; 10442:                   {
; 10443:                      fnDropTaskOperation( lpTask, lpTaskOperation );

	mov	ecx, DWORD PTR _lpTaskOperation$13[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$17[ebp]
	push	edx
	call	_fnDropTaskOperation@8
$LN35@DllMain:

; 10444:                   }
; 10445:                }

	jmp	SHORT $LN13@DllMain
$LN14@DllMain:

; 10446: 
; 10447:                hLibrary = lpTask->hFirstLibrary;

	mov	eax, DWORD PTR _lpTask$17[ebp]
	mov	ecx, DWORD PTR [eax+122]
	mov	DWORD PTR _hLibrary$12[ebp], ecx
$LN16@DllMain:

; 10448:                while ( hLibrary )

	cmp	DWORD PTR _hLibrary$12[ebp], 0
	je	SHORT $LN17@DllMain

; 10449:                {
; 10450:                   lpLibrary = zGETPTR( hLibrary );

	mov	edx, DWORD PTR _hLibrary$12[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$5[ebp], eax

; 10451:                   hNextLibrary = lpLibrary->hNextLibrary;

	mov	eax, DWORD PTR _lpLibrary$5[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _hNextLibrary$1[ebp], ecx

; 10452:                   if ( lProcessID == lpLibrary->lProcessID )

	mov	edx, DWORD PTR _lpLibrary$5[ebp]
	mov	eax, DWORD PTR _lProcessID$11[ebp]
	cmp	eax, DWORD PTR [edx+271]
	jne	SHORT $LN36@DllMain

; 10453:                      fnSysFreeLibrary( lpTask, hLibrary, TRUE );

	push	1
	mov	ecx, DWORD PTR _hLibrary$12[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$17[ebp]
	push	edx
	call	_fnSysFreeLibrary@12
$LN36@DllMain:

; 10454: 
; 10455:                   hLibrary = hNextLibrary;

	mov	eax, DWORD PTR _hNextLibrary$1[ebp]
	mov	DWORD PTR _hLibrary$12[ebp], eax

; 10456:                }

	jmp	SHORT $LN16@DllMain
$LN17@DllMain:

; 10457: 
; 10458:                fnDropTaskDomains( lpTask );

	mov	ecx, DWORD PTR _lpTask$17[ebp]
	push	ecx
	call	_fnDropTaskDomains@4

; 10459: 
; 10460:             // zLOCK_MUTEX( zMUTEX_MUTEX );    // protected by zMUTEX_ANCHORBLOCK
; 10461:                lpPrevMutex = 0;

	mov	DWORD PTR _lpPrevMutex$10[ebp], 0

; 10462:                hMutex = lpTask->hFirstMutex;

	mov	edx, DWORD PTR _lpTask$17[ebp]
	mov	eax, DWORD PTR [edx+150]
	mov	DWORD PTR _hMutex$8[ebp], eax
$LN18@DllMain:

; 10463:                while ( hMutex )

	cmp	DWORD PTR _hMutex$8[ebp], 0
	je	$LN19@DllMain

; 10464:                {
; 10465:                   lpMutex = zGETPTR( hMutex );

	mov	ecx, DWORD PTR _hMutex$8[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$15[ebp], eax

; 10466:                   hNextMutex = lpMutex->hNextMutex;

	mov	edx, DWORD PTR _lpMutex$15[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR _hNextMutex$9[ebp], eax

; 10467:                   if ( lProcessID == lpMutex->lProcessID )

	mov	ecx, DWORD PTR _lpMutex$15[ebp]
	mov	edx, DWORD PTR _lProcessID$11[ebp]
	cmp	edx, DWORD PTR [ecx+89]
	jne	$LN37@DllMain

; 10468:                   {
; 10469:                      if ( lpMutex->nLockCount )

	mov	eax, DWORD PTR _lpMutex$15[ebp]
	movsx	ecx, WORD PTR [eax+75]
	test	ecx, ecx
	je	SHORT $LN39@DllMain

; 10470:                      {
; 10471:                         // First set nLockCount to 1 so that the next call to
; 10472:                         // fnSysMutexUnlock actually unlocks the mutex.
; 10473:                         lpMutex->nLockCount = 1;

	mov	edx, 1
	mov	eax, DWORD PTR _lpMutex$15[ebp]
	mov	WORD PTR [eax+75], dx

; 10474:                         fnSysMutexUnlock( lpTask, lpMutex );

	mov	ecx, DWORD PTR _lpMutex$15[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$17[ebp]
	push	edx
	call	_fnSysMutexUnlock@8
$LN39@DllMain:

; 10475:                      }
; 10476: 
; 10477:                      fnSysMutexDestroy( lpTask, lpMutex );

	mov	eax, DWORD PTR _lpMutex$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$17[ebp]
	push	ecx
	call	_fnSysMutexDestroy@8

; 10478:                      if ( lpPrevMutex )

	cmp	DWORD PTR _lpPrevMutex$10[ebp], 0
	je	SHORT $LN40@DllMain

; 10479:                         lpPrevMutex->hNextMutex = hNextMutex;

	mov	edx, DWORD PTR _lpPrevMutex$10[ebp]
	mov	eax, DWORD PTR _hNextMutex$9[ebp]
	mov	DWORD PTR [edx+2], eax
	jmp	SHORT $LN41@DllMain
$LN40@DllMain:

; 10480:                      else
; 10481:                         lpTask->hFirstMutex = hNextMutex;

	mov	ecx, DWORD PTR _lpTask$17[ebp]
	mov	edx, DWORD PTR _hNextMutex$9[ebp]
	mov	DWORD PTR [ecx+150], edx
$LN41@DllMain:

; 10482: 
; 10483:                      fnFreeDataspace( lpMutex );

	mov	eax, DWORD PTR _lpMutex$15[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 10484:                   }

	jmp	SHORT $LN38@DllMain
$LN37@DllMain:

; 10485:                   else
; 10486:                      lpPrevMutex = lpMutex;

	mov	ecx, DWORD PTR _lpMutex$15[ebp]
	mov	DWORD PTR _lpPrevMutex$10[ebp], ecx
$LN38@DllMain:

; 10487: 
; 10488:                   hMutex = hNextMutex;

	mov	edx, DWORD PTR _hNextMutex$9[ebp]
	mov	DWORD PTR _hMutex$8[ebp], edx

; 10489:                }

	jmp	$LN18@DllMain
$LN19@DllMain:

; 10490: 
; 10491:             // zUNLOCK_MUTEX( zMUTEX_MUTEX );
; 10492:             }

	jmp	$LN10@DllMain
$LN11@DllMain:

; 10493: 
; 10494:             fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 10495:             zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 10496: 
; 10497:             for ( k = 0; k < AnchorBlock->OS_Data.lProcessCount; k++ )

	mov	DWORD PTR _k$16[ebp], 0
	jmp	SHORT $LN22@DllMain
$LN20@DllMain:
	mov	eax, DWORD PTR _k$16[ebp]
	add	eax, 1
	mov	DWORD PTR _k$16[ebp], eax
$LN22@DllMain:
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _k$16[ebp]
	cmp	edx, DWORD PTR [ecx+1507]
	jge	SHORT $LN32@DllMain

; 10498:             {
; 10499:                lpProcessList = &AnchorBlock->OS_Data.ProcessList[ k ];

	imul	eax, DWORD PTR _k$16[ebp], 20
	mov	ecx, DWORD PTR _AnchorBlock
	lea	edx, DWORD PTR [ecx+eax+1511]
	mov	DWORD PTR _lpProcessList$4[ebp], edx

; 10500:                if ( lpProcessList->lProcessID == lProcessID )

	mov	eax, DWORD PTR _lpProcessList$4[ebp]
	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR _lProcessID$11[ebp]
	jne	SHORT $LN42@DllMain

; 10501:                {
; 10502:                   lpProcessList->lProcessID = 0;

	mov	edx, DWORD PTR _lpProcessList$4[ebp]
	mov	DWORD PTR [edx+16], 0

; 10503:                   break;

	jmp	SHORT $LN32@DllMain
$LN42@DllMain:

; 10504:                }
; 10505:             }

	jmp	SHORT $LN20@DllMain
$LN32@DllMain:

; 10506:          }
; 10507: 
; 10508:          for ( k = 0; k < zMUTEX_COUNT; k++ )

	mov	DWORD PTR _k$16[ebp], 0
	jmp	SHORT $LN25@DllMain
$LN23@DllMain:
	mov	eax, DWORD PTR _k$16[ebp]
	add	eax, 1
	mov	DWORD PTR _k$16[ebp], eax
$LN25@DllMain:
	cmp	DWORD PTR _k$16[ebp], 16		; 00000010H
	jge	SHORT $LN24@DllMain

; 10509:             zDESTROY_MUTEX( k );

	mov	ecx, DWORD PTR _k$16[ebp]
	push	ecx
	call	_fnSysDestroyCoreMutex@4
	jmp	SHORT $LN23@DllMain
$LN24@DllMain:

; 10510: 
; 10511: #ifdef __MUTEX_DEBUG__
; 10512:          if ( g_hMutexDbg )
; 10513:             CloseHandle( g_hMutexDbg );
; 10514: 
; 10515:          if ( g_hMutexMemFile )
; 10516:             CloseHandle( g_hMutexMemFile );
; 10517: #endif
; 10518: 
; 10519:          // Delete critical sections used in this file.
; 10520:          DeleteCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET _g_csSysLoadLibrary
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 10521:          DeleteCriticalSection( &g_csReuseEntity );

	push	OFFSET _g_csReuseEntity
	call	DWORD PTR __imp__DeleteCriticalSection@4
$LN2@DllMain:

; 10522: 
; 10523:          break;
; 10524:       }
; 10525:    }
; 10526: 
; 10527:    return( TRUE );

	mov	eax, 1
$LN1@DllMain:

; 10528: }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_DllMain@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_SysMainWndProc@16 PROC

; 10174: {

	push	ebp
	mov	ebp, esp
	push	ecx

; 10175:    TraceLineI( "SysMainWndProc for Tomcat session Wnd: ", (zLONG) hWnd );

	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	OFFSET $SG100811
	call	_TraceLineI@8

; 10176:    switch ( uMsg )

	mov	ecx, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 2
	je	SHORT $LN4@SysMainWnd
	jmp	SHORT $LN5@SysMainWnd
$LN4@SysMainWnd:

; 10177:    {
; 10178:       case WM_DESTROY:        // message: window being destroyed
; 10179:          PostQuitMessage( 0 );

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 10180:          break;

	jmp	SHORT $LN2@SysMainWnd
$LN5@SysMainWnd:

; 10181: 
; 10182:       default:
; 10183:          if ( uMsg == g_wClientMessage )

	mov	edx, DWORD PTR _uMsg$[ebp]
	cmp	edx, DWORD PTR _g_wClientMessage
	jne	SHORT $LN2@SysMainWnd

; 10184:          {
; 10185:             TraceLineI( "SysMainWndProc for Tomcat session Wnd: ", (zLONG) hWnd );

	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	push	OFFSET $SG100815
	call	_TraceLineI@8

; 10186:             ProcessZeidonMessage( wParam, lParam );

	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	call	_ProcessZeidonMessage@8
$LN2@SysMainWnd:

; 10187:          }
; 10188: 
; 10189:          break;
; 10190:    }
; 10191: 
; 10192:    return( DefWindowProc( hWnd, uMsg, wParam, lParam ));

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _uMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__DefWindowProcA@16

; 10193: }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysMainWndProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lHash$ = -8						; size = 4
_nLth$ = -4						; size = 4
_cpcName$ = 8						; size = 4
_fnHashName@4 PROC

; 8693 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8694 :    zLONG  nLth = zstrlen( cpcName );

	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nLth$[ebp], eax

; 8695 :    zLONG  lHash;
; 8696 : 
; 8697 :    // If the string is long enough we'll skip the first 2 bytes of the string
; 8698 :    // and create a hash value from two long variables.
; 8699 :    if ( nLth >= 2 + 2 * sizeof( zLONG ) )

	cmp	DWORD PTR _nLth$[ebp], 10		; 0000000aH
	jb	SHORT $LN4@fnHashName

; 8700 :    {
; 8701 :       lHash = *(zPLONG) &cpcName[ 2 ] +

	mov	ecx, 1
	shl	ecx, 1
	mov	edx, 1
	imul	eax, edx, 6
	mov	edx, DWORD PTR _cpcName$[ebp]
	mov	eax, DWORD PTR [edx+eax]
	mov	edx, DWORD PTR _cpcName$[ebp]
	mov	ecx, DWORD PTR [edx+ecx]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _lHash$[ebp], edx

; 8702 :               // Since all the chars are < 128 (in ASCII anyway) we'll shift
; 8703 :               // the the second long value over 1 bit.
; 8704 :               (*(zPLONG) &cpcName[ 2 + sizeof( zLONG ) ] << 1);
; 8705 : 
; 8706 :       return( lHash );

	mov	eax, DWORD PTR _lHash$[ebp]
	jmp	SHORT $LN1@fnHashName
$LN4@fnHashName:

; 8707 :    }
; 8708 : 
; 8709 :    lHash = nLth << (8 * (sizeof( zLONG ) - sizeof( zSHORT )));

	mov	eax, DWORD PTR _nLth$[ebp]
	shl	eax, 16					; 00000010H
	mov	DWORD PTR _lHash$[ebp], eax

; 8710 : 
; 8711 :    if ( nLth >= sizeof( zLONG ) )

	cmp	DWORD PTR _nLth$[ebp], 4
	jb	SHORT $LN2@fnHashName

; 8712 :    {
; 8713 :       lHash += *(zPLONG) cpcName;

	mov	ecx, DWORD PTR _cpcName$[ebp]
	mov	edx, DWORD PTR _lHash$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lHash$[ebp], edx

; 8714 :       return( lHash );

	mov	eax, DWORD PTR _lHash$[ebp]
	jmp	SHORT $LN1@fnHashName
$LN2@fnHashName:

; 8715 :    }
; 8716 : 
; 8717 :    while ( nLth > 0 )

	cmp	DWORD PTR _nLth$[ebp], 0
	jle	SHORT $LN3@fnHashName

; 8718 :    {
; 8719 :       ((zPCHAR) &lHash)[ nLth ] += cpcName[ nLth - 1 ];

	mov	eax, DWORD PTR _cpcName$[ebp]
	add	eax, DWORD PTR _nLth$[ebp]
	movsx	ecx, BYTE PTR [eax-1]
	mov	edx, DWORD PTR _nLth$[ebp]
	movsx	eax, BYTE PTR _lHash$[ebp+edx]
	add	eax, ecx
	mov	ecx, DWORD PTR _nLth$[ebp]
	mov	BYTE PTR _lHash$[ebp+ecx], al

; 8720 :       nLth--;

	mov	edx, DWORD PTR _nLth$[ebp]
	sub	edx, 1
	mov	DWORD PTR _nLth$[ebp], edx

; 8721 :    }

	jmp	SHORT $LN2@fnHashName
$LN3@fnHashName:

; 8722 : 
; 8723 :    return( lHash );

	mov	eax, DWORD PTR _lHash$[ebp]
$LN1@fnHashName:

; 8724 : 
; 8725 : } // fnHashName

	mov	esp, ebp
	pop	ebp
	ret	4
_fnHashName@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_d2$1 = -40						; size = 8
_d$2 = -32						; size = 8
_lCommand$ = -24					; size = 4
_iSign$3 = -20						; size = 4
tv65 = -16						; size = 4
_nPrecision$4 = -12					; size = 2
_nPrecision$5 = -8					; size = 2
_n$6 = -4						; size = 2
_pvReturn$ = 8						; size = 4
_pvDecimal$ = 12					; size = 4
_pvInfo$ = 16						; size = 4
_lControl$ = 20						; size = 4
_fnDecimalOperation@16 PROC

; 8199 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 8200 :    static double g_dNull = -99999999999999.9;
; 8201 : 
; 8202 :    zLONG  lCommand = lControl & zDEC_CMD;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 255				; 000000ffH
	mov	DWORD PTR _lCommand$[ebp], eax

; 8203 : 
; 8204 :    switch ( lCommand )

	mov	ecx, DWORD PTR _lCommand$[ebp]
	mov	DWORD PTR tv65[ebp], ecx
	mov	edx, DWORD PTR tv65[ebp]
	sub	edx, 1
	mov	DWORD PTR tv65[ebp], edx
	cmp	DWORD PTR tv65[ebp], 52			; 00000034H
	ja	$LN2@fnDecimalO
	mov	eax, DWORD PTR tv65[ebp]
	movzx	ecx, BYTE PTR $LN45@fnDecimalO[eax]
	jmp	DWORD PTR $LN46@fnDecimalO[ecx*4]
$LN10@fnDecimalO:

; 8205 :    {
; 8206 :       case zDEC_CMD_INIT:
; 8207 :          TraceLineS( "(ZDecimal) Using default zDecimalOperation( )", "" );

	push	OFFSET $SG100441
	push	OFFSET $SG100442
	call	_TraceLineS@8

; 8208 :          TraceLineI( "(ZDecimal) Precision (in bits) = ",

	push	64					; 00000040H
	push	OFFSET $SG100443
	call	_TraceLineI@8

; 8209 :                      (zLONG) (sizeof( double ) * 8) );
; 8210 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN11@fnDecimalO:

; 8211 : 
; 8212 :       case zDEC_CMD_ASSIGNDEC:
; 8213 :          // Copy from 1 decimal to another.
; 8214 :          *((double *) pvReturn) = *(double *) pvDecimal;

	mov	edx, DWORD PTR _pvReturn$[ebp]
	mov	eax, DWORD PTR _pvDecimal$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR [edx], xmm0

; 8215 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN12@fnDecimalO:

; 8216 : 
; 8217 :       case zDEC_CMD_ASSIGNNULL:
; 8218 :          // Assign NULL to a decimal.
; 8219 :          *((double *) pvReturn) = g_dNull;

	mov	ecx, DWORD PTR _pvReturn$[ebp]
	movsd	xmm0, QWORD PTR ?g_dNull@?1??fnDecimalOperation@@9@9
	movsd	QWORD PTR [ecx], xmm0

; 8220 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN13@fnDecimalO:

; 8221 : 
; 8222 :       case zDEC_CMD_COMPAREDEC:
; 8223 :          if ( *((double *) pvDecimal) < *(double *) pvInfo )

	mov	edx, DWORD PTR _pvInfo$[ebp]
	mov	eax, DWORD PTR _pvDecimal$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	comisd	xmm0, QWORD PTR [eax]
	jbe	SHORT $LN14@fnDecimalO

; 8224 :             return( -1 );

	or	eax, -1
	jmp	$LN1@fnDecimalO
	jmp	SHORT $LN17@fnDecimalO
$LN14@fnDecimalO:

; 8225 :          else
; 8226 :          if ( *((double *) pvDecimal) > *(double *) pvInfo )

	mov	ecx, DWORD PTR _pvDecimal$[ebp]
	mov	edx, DWORD PTR _pvInfo$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR [edx]
	jbe	SHORT $LN16@fnDecimalO

; 8227 :             return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDecimalO
	jmp	SHORT $LN17@fnDecimalO
$LN16@fnDecimalO:

; 8228 :          else
; 8229 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN17@fnDecimalO:

; 8230 : 
; 8231 :       case zDEC_CMD_COMPARENULL:
; 8232 :          if ( *((double *) pvDecimal) == g_dNull )

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR ?g_dNull@?1??fnDecimalOperation@@9@9
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN19@fnDecimalO

; 8233 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
	jmp	SHORT $LN20@fnDecimalO
$LN19@fnDecimalO:

; 8234 :          else
; 8235 :             return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDecimalO
$LN20@fnDecimalO:

; 8236 : 
; 8237 :       case zDEC_CMD_COMPAREDOUBLE:
; 8238 :          if ( *((double *) pvDecimal) < (long double) *((double *) pvInfo) )

	mov	ecx, DWORD PTR _pvInfo$[ebp]
	mov	edx, DWORD PTR _pvDecimal$[ebp]
	movsd	xmm0, QWORD PTR [ecx]
	comisd	xmm0, QWORD PTR [edx]
	jbe	SHORT $LN22@fnDecimalO

; 8239 :             return( -1 );

	or	eax, -1
	jmp	$LN1@fnDecimalO
	jmp	SHORT $LN25@fnDecimalO
$LN22@fnDecimalO:

; 8240 :          else
; 8241 :          if ( *((double *) pvDecimal) > (long double) *((double *) pvInfo) )

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	comisd	xmm0, QWORD PTR [ecx]
	jbe	SHORT $LN24@fnDecimalO

; 8242 :             return( 1 );

	mov	eax, 1
	jmp	$LN1@fnDecimalO
	jmp	SHORT $LN25@fnDecimalO
$LN24@fnDecimalO:

; 8243 :          else
; 8244 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN25@fnDecimalO:

; 8245 : 
; 8246 :       case zDEC_CMD_STRINGTODEC:
; 8247 :          // Convert string to double.
; 8248 :          *(double *) pvReturn = atof( (char *) pvInfo );

	mov	edx, DWORD PTR _pvInfo$[ebp]
	push	edx
	call	DWORD PTR __imp__atof
	add	esp, 4
	mov	eax, DWORD PTR _pvReturn$[ebp]
	fstp	QWORD PTR [eax]

; 8249 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN27@fnDecimalO:

; 8250 : 
; 8251 :       case zDEC_CMD_DECTOSTRING:
; 8252 :       {
; 8253 :          short nPrecision = *((short *) pvInfo);

	mov	ecx, DWORD PTR _pvInfo$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _nPrecision$4[ebp], dx

; 8254 : 
; 8255 :          // Convert double to string.
; 8256 : 
; 8257 :          if ( nPrecision > 0 )

	movsx	eax, WORD PTR _nPrecision$4[ebp]
	test	eax, eax
	jle	SHORT $LN28@fnDecimalO

; 8258 :             sprintf( (char *) pvReturn, "%.*f", nPrecision, *((double *) pvDecimal) );

	mov	ecx, DWORD PTR _pvDecimal$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	movsx	edx, WORD PTR _nPrecision$4[ebp]
	push	edx
	push	OFFSET $SG100463
	mov	eax, DWORD PTR _pvReturn$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H
	jmp	SHORT $LN29@fnDecimalO
$LN28@fnDecimalO:

; 8259 :          else
; 8260 :             sprintf( (char *) pvReturn, "%f", *((double *) pvDecimal) );

	mov	ecx, DWORD PTR _pvDecimal$[ebp]
	sub	esp, 8
	movsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG100464
	mov	edx, DWORD PTR _pvReturn$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN29@fnDecimalO:

; 8261 : 
; 8262 :          // sprintf is defined to return a empty string if dDecimal is 0.0.
; 8263 :          if ( *((char *) pvReturn) == 0 )

	mov	eax, DWORD PTR _pvReturn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN30@fnDecimalO

; 8264 :             strcpy( (char *) pvReturn, "0.0" );

	push	OFFSET $SG100466
	mov	edx, DWORD PTR _pvReturn$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN30@fnDecimalO:

; 8265 : 
; 8266 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN31@fnDecimalO:

; 8267 :       }
; 8268 : 
; 8269 :       case zDEC_CMD_DECTOLONG:
; 8270 :          // Convert double to long.
; 8271 :          *((long *) pvReturn) = (zLONG) *((double *) pvDecimal);

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	cvttsd2si ecx, QWORD PTR [eax]
	mov	edx, DWORD PTR _pvReturn$[ebp]
	mov	DWORD PTR [edx], ecx

; 8272 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN32@fnDecimalO:

; 8273 : 
; 8274 :       case zDEC_CMD_LONGTODEC:
; 8275 :          *((double *) pvReturn) = (double) *((long *) pvInfo);

	mov	eax, DWORD PTR _pvInfo$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax]
	mov	ecx, DWORD PTR _pvReturn$[ebp]
	movsd	QWORD PTR [ecx], xmm0

; 8276 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN33@fnDecimalO:

; 8277 : 
; 8278 :       case zDEC_CMD_DECTODOUBLE:
; 8279 :          // Convert long double to double.
; 8280 :          *((double *) pvReturn) = (double) *((double *) pvDecimal);

	mov	edx, DWORD PTR _pvReturn$[ebp]
	mov	eax, DWORD PTR _pvDecimal$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR [edx], xmm0

; 8281 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN34@fnDecimalO:

; 8282 : 
; 8283 :       case zDEC_CMD_DOUBLETODEC:
; 8284 :          // Convert double to decimal.
; 8285 :          *((double *) pvReturn) = (double) *((double *) pvInfo);

	mov	ecx, DWORD PTR _pvReturn$[ebp]
	mov	edx, DWORD PTR _pvInfo$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	movsd	QWORD PTR [ecx], xmm0

; 8286 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN35@fnDecimalO:

; 8287 : 
; 8288 :       case zDEC_CMD_MULTDEC:
; 8289 :          *((double *) pvReturn) = *((double *) pvDecimal) * *((double *) pvInfo);

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	mulsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _pvReturn$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 8290 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN36@fnDecimalO:

; 8291 : 
; 8292 :       case zDEC_CMD_DIVDEC:
; 8293 :          *((double *) pvReturn) = *((double *) pvDecimal) / *((double *) pvInfo);

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	divsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _pvReturn$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 8294 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN37@fnDecimalO:

; 8295 : 
; 8296 :       case zDEC_CMD_SUBDEC:
; 8297 :          *((double *) pvReturn) = *((double *) pvDecimal) - *((double *) pvInfo);

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	subsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _pvReturn$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 8298 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN38@fnDecimalO:

; 8299 : 
; 8300 :       case zDEC_CMD_ADDDEC:
; 8301 :          *((double *) pvReturn) = *((double *) pvDecimal) + *((double *) pvInfo);

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	mov	ecx, DWORD PTR _pvInfo$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	addsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _pvReturn$[ebp]
	movsd	QWORD PTR [edx], xmm0

; 8302 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN39@fnDecimalO:

; 8303 : 
; 8304 :       case zDEC_CMD_ROUND:
; 8305 :       {
; 8306 :          zSHORT nPrecision = *((zSHORT *) pvInfo);

	mov	eax, DWORD PTR _pvInfo$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR _nPrecision$5[ebp], cx

; 8307 :          int    iSign = 1;

	mov	DWORD PTR _iSign$3[ebp], 1

; 8308 :          zSHORT n;
; 8309 :          double d, d2;
; 8310 : 
; 8311 :          if ( nPrecision < 0 )

	movsx	edx, WORD PTR _nPrecision$5[ebp]
	test	edx, edx
	jge	SHORT $LN40@fnDecimalO

; 8312 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN40@fnDecimalO:

; 8313 : 
; 8314 :          d = *((double *) pvDecimal);

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	movsd	QWORD PTR _d$2[ebp], xmm0

; 8315 :          if ( d == 0.0 )

	movsd	xmm0, QWORD PTR _d$2[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN41@fnDecimalO

; 8316 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDecimalO
$LN41@fnDecimalO:

; 8317 : 
; 8318 :          if ( d < 0.0 )

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _d$2[ebp]
	jbe	SHORT $LN42@fnDecimalO

; 8319 :          {
; 8320 :             d = -d;

	movsd	xmm0, QWORD PTR _d$2[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _d$2[ebp], xmm0

; 8321 :             iSign = -1;

	mov	DWORD PTR _iSign$3[ebp], -1
$LN42@fnDecimalO:

; 8322 :          }
; 8323 : 
; 8324 :          for ( n = 0; n < nPrecision; n++ )

	xor	ecx, ecx
	mov	WORD PTR _n$6[ebp], cx
	jmp	SHORT $LN6@fnDecimalO
$LN4@fnDecimalO:
	mov	dx, WORD PTR _n$6[ebp]
	add	dx, 1
	mov	WORD PTR _n$6[ebp], dx
$LN6@fnDecimalO:
	movsx	eax, WORD PTR _n$6[ebp]
	movsx	ecx, WORD PTR _nPrecision$5[ebp]
	cmp	eax, ecx
	jge	SHORT $LN5@fnDecimalO

; 8325 :             d += 10;

	movsd	xmm0, QWORD PTR _d$2[ebp]
	addsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _d$2[ebp], xmm0
	jmp	SHORT $LN4@fnDecimalO
$LN5@fnDecimalO:

; 8326 : 
; 8327 :          d2 = floor( d );

	sub	esp, 8
	movsd	xmm0, QWORD PTR _d$2[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	DWORD PTR __imp__floor
	add	esp, 8
	fstp	QWORD PTR _d2$1[ebp]

; 8328 :          if ( d - d2 >= 0.5 )

	movsd	xmm0, QWORD PTR _d$2[ebp]
	subsd	xmm0, QWORD PTR _d2$1[ebp]
	comisd	xmm0, QWORD PTR __real@3fe0000000000000
	jb	SHORT $LN43@fnDecimalO

; 8329 :             d2 += 1.0;

	movsd	xmm0, QWORD PTR _d2$1[ebp]
	addsd	xmm0, QWORD PTR __real@3ff0000000000000
	movsd	QWORD PTR _d2$1[ebp], xmm0
$LN43@fnDecimalO:

; 8330 : 
; 8331 :          for ( n = 0; n < nPrecision; n++ )

	xor	edx, edx
	mov	WORD PTR _n$6[ebp], dx
	jmp	SHORT $LN9@fnDecimalO
$LN7@fnDecimalO:
	mov	ax, WORD PTR _n$6[ebp]
	add	ax, 1
	mov	WORD PTR _n$6[ebp], ax
$LN9@fnDecimalO:
	movsx	ecx, WORD PTR _n$6[ebp]
	movsx	edx, WORD PTR _nPrecision$5[ebp]
	cmp	ecx, edx
	jge	SHORT $LN8@fnDecimalO

; 8332 :             d2 /= 10;

	movsd	xmm0, QWORD PTR _d2$1[ebp]
	divsd	xmm0, QWORD PTR __real@4024000000000000
	movsd	QWORD PTR _d2$1[ebp], xmm0
	jmp	SHORT $LN7@fnDecimalO
$LN8@fnDecimalO:

; 8333 : 
; 8334 :          d2 = d2 * iSign;

	cvtsi2sd xmm0, DWORD PTR _iSign$3[ebp]
	mulsd	xmm0, QWORD PTR _d2$1[ebp]
	movsd	QWORD PTR _d2$1[ebp], xmm0

; 8335 :          *((double *) pvDecimal) = d2;

	mov	eax, DWORD PTR _pvDecimal$[ebp]
	movsd	xmm0, QWORD PTR _d2$1[ebp]
	movsd	QWORD PTR [eax], xmm0

; 8336 : 
; 8337 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnDecimalO
$LN2@fnDecimalO:

; 8338 :       }
; 8339 :    }
; 8340 : 
; 8341 :    return( -1 );

	or	eax, -1
$LN1@fnDecimalO:

; 8342 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	1
$LN46@fnDecimalO:
	DD	$LN11@fnDecimalO
	DD	$LN13@fnDecimalO
	DD	$LN12@fnDecimalO
	DD	$LN17@fnDecimalO
	DD	$LN20@fnDecimalO
	DD	$LN10@fnDecimalO
	DD	$LN38@fnDecimalO
	DD	$LN37@fnDecimalO
	DD	$LN35@fnDecimalO
	DD	$LN36@fnDecimalO
	DD	$LN39@fnDecimalO
	DD	$LN27@fnDecimalO
	DD	$LN25@fnDecimalO
	DD	$LN31@fnDecimalO
	DD	$LN32@fnDecimalO
	DD	$LN33@fnDecimalO
	DD	$LN34@fnDecimalO
	DD	$LN2@fnDecimalO
$LN45@fnDecimalO:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	6
	DB	7
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	17					; 00000011H
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
_fnDecimalOperation@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pvAnchorBlock$ = 8					; size = 4
_SysSetAnchorBlock@4 PROC

; 8031 : {

	push	ebp
	mov	ebp, esp

; 8032 :    // Windows does not require any Anchor Block in RegisterZeidonApplication
; 8033 : }

	pop	ebp
	ret	4
_SysSetAnchorBlock@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szDateTime$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_vArgs$ = 8						; size = 4
_pvViewList$ = 12					; size = 4
__zCall_GetDateTime@8 PROC

; 6775 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6776 :    zCHAR szDateTime[ 32 ];
; 6777 : 
; 6778 :    SysGetDateTime( szDateTime );

	lea	eax, DWORD PTR _szDateTime$[ebp]
	push	eax
	call	_SysGetDateTime@4

; 6779 :    SetAttributeFromString( vArgs, "Operation", "ReturnValue", szDateTime );

	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	push	OFFSET $SG99931
	push	OFFSET $SG99932
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 6780 :    return( 0 );

	xor	eax, eax

; 6781 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
__zCall_GetDateTime@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpFreespace$ = -4					; size = 4
_pPointer$ = 8						; size = 4
_fnSysGetHandleFromPointerShared@4 PROC

; 4141 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4142 :    LPFREESPACE lpFreespace;
; 4143 : 
; 4144 :    if ( pPointer == 0 )

	cmp	DWORD PTR _pPointer$[ebp], 0
	jne	SHORT $LN2@fnSysGetHa

; 4145 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSysGetHa
$LN2@fnSysGetHa:

; 4146 : 
; 4147 : #ifdef DEBUG_PAGETABLE
; 4148 :    // Make sure that the highest bit is NOT set (this means it's a handle).
; 4149 :    if ( ((zLONG) pPointer & 0x80000000) != 0 )

	mov	eax, DWORD PTR _pPointer$[ebp]
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN3@fnSysGetHa

; 4150 :    {
; 4151 :    // char szMessage[ 16 ];
; 4152 :    // int k = 0;
; 4153 :       MessageBox( GetActiveWindow( ), "Invalid pointer: hi-bit set!!",

	push	8208					; 00002010H
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	OFFSET $SG99015
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 4154 :                   szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );
; 4155 : #if 0
; 4156 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4157 :       if ( szMessage[ 0 ] == 'Y' )
; 4158 :          k /= k;
; 4159 : #endif
; 4160 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSysGetHa
$LN3@fnSysGetHa:

; 4161 :    }
; 4162 : #endif
; 4163 : 
; 4164 :    lpFreespace = (LPFREESPACE) pPointer;

	mov	edx, DWORD PTR _pPointer$[ebp]
	mov	DWORD PTR _lpFreespace$[ebp], edx

; 4165 :    lpFreespace--;

	mov	eax, DWORD PTR _lpFreespace$[ebp]
	sub	eax, 18					; 00000012H
	mov	DWORD PTR _lpFreespace$[ebp], eax

; 4166 : 
; 4167 :    return( lpFreespace->hFreespace );

	mov	ecx, DWORD PTR _lpFreespace$[ebp]
	mov	eax, DWORD PTR [ecx+10]
$LN1@fnSysGetHa:

; 4168 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysGetHandleFromPointerShared@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pPointer$ = 8						; size = 4
_fnSysGetHandleFromPointerServerMode@4 PROC

; 4135 : {

	push	ebp
	mov	ebp, esp

; 4136 :    return( pPointer );

	mov	eax, DWORD PTR _pPointer$[ebp]

; 4137 : }

	pop	ebp
	ret	4
_fnSysGetHandleFromPointerServerMode@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lOffset$ = -524					; size = 4
_k$ = -517						; size = 1
_szMessage$1 = -516					; size = 256
_szMessage$2 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_pHandle$ = 8						; size = 4
_fnSysGetPointerFromHandleShared@4 PROC

; 4058 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4059 :    zBYTE  k;
; 4060 :    zLONG  lOffset;
; 4061 : 
; 4062 :    if ( pHandle == 0 )

	cmp	DWORD PTR _pHandle$[ebp], 0
	jne	SHORT $LN2@fnSysGetPo

; 4063 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSysGetPo
$LN2@fnSysGetPo:

; 4064 : 
; 4065 :    // Following is for Instance handles.  Instance handles can be:
; 4066 :    // zero (no instance), one (unset cursor), or a valid handle.
; 4067 :    if ( pHandle == (zPVOID) 1 )

	cmp	DWORD PTR _pHandle$[ebp], 1
	jne	SHORT $LN3@fnSysGetPo

; 4068 :       return( (zPVOID) 1 );

	mov	eax, 1
	jmp	$LN1@fnSysGetPo
$LN3@fnSysGetPo:

; 4069 : 
; 4070 : #ifdef DEBUG_PAGETABLE
; 4071 :    // Make sure that the highest bit is set.
; 4072 :    if ( ((zLONG) pHandle & 0x80000000) == 0 )

	mov	eax, DWORD PTR _pHandle$[ebp]
	and	eax, -2147483648			; 80000000H
	jne	SHORT $LN4@fnSysGetPo

; 4073 :    {
; 4074 :       char szMessage[ 256 ];
; 4075 : 
; 4076 :       zsprintf( szMessage, "Invalid pointer handle (get) : hi-bit not set: 0x%08x", pHandle );

	mov	ecx, DWORD PTR _pHandle$[ebp]
	push	ecx
	push	OFFSET $SG98992
	lea	edx, DWORD PTR _szMessage$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 4077 :       TraceLineS( szMessage, "" );

	push	OFFSET $SG98993
	lea	eax, DWORD PTR _szMessage$2[ebp]
	push	eax
	call	_TraceLineS@8

; 4078 :       if ( AnchorBlock->bDebugLeak == FALSE )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1495]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN5@fnSysGetPo

; 4079 :       {
; 4080 :          MessageBox( GetActiveWindow( ), szMessage,

	push	8208					; 00002010H
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	lea	ecx, DWORD PTR _szMessage$2[ebp]
	push	ecx
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
$LN5@fnSysGetPo:

; 4081 :                      szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );
; 4082 :       }
; 4083 : #if 0
; 4084 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4085 :       if ( szMessage[ 0 ] == 'Y' )
; 4086 :       {
; 4087 :          k = 0;
; 4088 :          k /= k;
; 4089 :       }
; 4090 : #endif
; 4091 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSysGetPo
$LN4@fnSysGetPo:

; 4092 :    }
; 4093 : #endif
; 4094 : 
; 4095 :    // Get high order byte from handle.
; 4096 :    k = (zBYTE) ((zULONG) pHandle >> 24);

	mov	edx, DWORD PTR _pHandle$[ebp]
	shr	edx, 24					; 00000018H
	mov	BYTE PTR _k$[ebp], dl

; 4097 : 
; 4098 :    if ( g_ZeidonPageTable[ k ] == 0 )

	movzx	eax, BYTE PTR _k$[ebp]
	cmp	DWORD PTR _g_ZeidonPageTable[eax*4], 0
	jne	SHORT $LN6@fnSysGetPo

; 4099 :    {
; 4100 :       char szMessage[ 256 ];  // dks 2006.09.18 error while cleaning up client OE (k=134)
; 4101 : 
; 4102 :       zsprintf( szMessage, "Invalid pointer handle (null) at Index: %x for pointer 0x%08x", k, pHandle );

	mov	ecx, DWORD PTR _pHandle$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _k$[ebp]
	push	edx
	push	OFFSET $SG98996
	lea	eax, DWORD PTR _szMessage$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 4103 :       TraceLineS( szMessage, "" );

	push	OFFSET $SG98997
	lea	ecx, DWORD PTR _szMessage$1[ebp]
	push	ecx
	call	_TraceLineS@8

; 4104 :       if ( AnchorBlock->bDebugLeak == FALSE )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN7@fnSysGetPo

; 4105 :       {
; 4106 :          MessageBox( GetActiveWindow( ), szMessage,

	push	8208					; 00002010H
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	lea	edx, DWORD PTR _szMessage$1[ebp]
	push	edx
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
$LN7@fnSysGetPo:

; 4107 :                      szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );
; 4108 :       }
; 4109 : #if 0
; 4110 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4111 :       if ( szMessage[ 0 ] == 'Y' )
; 4112 :       {
; 4113 :          k /= k - k;
; 4114 :       }
; 4115 : #endif
; 4116 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSysGetPo
$LN6@fnSysGetPo:

; 4117 :    }
; 4118 : 
; 4119 :    // Get page offset from 3 low-order bytes.
; 4120 :    lOffset = (zLONG) pHandle & 0x00FFFFFF;

	mov	eax, DWORD PTR _pHandle$[ebp]
	and	eax, 16777215				; 00ffffffH
	mov	DWORD PTR _lOffset$[ebp], eax

; 4121 : 
; 4122 :    // Get pointer value by adding offset to page table address.
; 4123 :    pHandle = (zPVOID) ((zLONG) g_ZeidonPageTable[ k ] + lOffset);

	movzx	ecx, BYTE PTR _k$[ebp]
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	add	edx, DWORD PTR _lOffset$[ebp]
	mov	DWORD PTR _pHandle$[ebp], edx

; 4124 :    return( pHandle );

	mov	eax, DWORD PTR _pHandle$[ebp]
$LN1@fnSysGetPo:

; 4125 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysGetPointerFromHandleShared@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pHandle$ = 8						; size = 4
_fnSysGetPointerFromHandleServerMode@4 PROC

; 4052 : {

	push	ebp
	mov	ebp, esp

; 4053 :    return( pHandle );

	mov	eax, DWORD PTR _pHandle$[ebp]

; 4054 : }

	pop	ebp
	ret	4
_fnSysGetPointerFromHandleServerMode@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hSaveAnchorBlock$ = -16				; size = 4
_lpProcessList$ = -12					; size = 4
_lPageTableIndex$ = -8					; size = 4
_bValidWindow$ = -1					; size = 1
_lAppOE_Msg$ = 8					; size = 4
_hWndAppOE$ = 12					; size = 4
_fnGetAnchorBlock@8 PROC

; 3508 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3509 :    LPPROCESSLIST lpProcessList;
; 3510 :    zLONG  lPageTableIndex;
; 3511 :    zLONG  hSaveAnchorBlock;
; 3512 :    zBOOL  bValidWindow;
; 3513 : 
; 3514 :    // In server mode, the anchor block has been allocated using local memory
; 3515 :    // so we don't need to do anything.
; 3516 :    if ( g_bServerMode || AnchorBlock )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	jne	SHORT $LN5@fnGetAncho
	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN4@fnGetAncho
$LN5@fnGetAncho:

; 3517 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAncho
$LN4@fnGetAncho:

; 3518 : 
; 3519 :    if ( g_bWin95 )

	movzx	ecx, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $LN6@fnGetAncho

; 3520 :       lPageTableIndex = 1;

	mov	DWORD PTR _lPageTableIndex$[ebp], 1
	jmp	SHORT $LN7@fnGetAncho
$LN6@fnGetAncho:

; 3521 :    else
; 3522 : #ifdef DEBUG_PAGETABLE
; 3523 :       // When we are debugging we start with page 128 so that the high bit in
; 3524 :       // the resulting handle will always be set.
; 3525 :       lPageTableIndex = 128;

	mov	DWORD PTR _lPageTableIndex$[ebp], 128	; 00000080H
$LN7@fnGetAncho:

; 3526 : #else
; 3527 :       // We start with page one (instead of zero) so that a handle will always
; 3528 :       // be non-zero.
; 3529 :       lPageTableIndex = 1;
; 3530 : #endif
; 3531 : 
; 3532 :    // Here is where the current task gets addressability to the AnchorBlock
; 3533 :    // by opening a view to the (named) shared memory mapping file.
; 3534 :    g_hAnchorBlock = (zLONG) OpenFileMapping( FILE_MAP_ALL_ACCESS,

	mov	edx, DWORD PTR _szlShareSeg
	push	edx
	push	0
	push	983071					; 000f001fH
	call	DWORD PTR __imp__OpenFileMappingA@12
	mov	DWORD PTR _g_hAnchorBlock, eax

; 3535 :                                              FALSE, szlShareSeg );
; 3536 :    if ( g_hAnchorBlock == 0 )

	cmp	DWORD PTR _g_hAnchorBlock, 0
	jne	SHORT $LN8@fnGetAncho

; 3537 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAncho
$LN8@fnGetAncho:

; 3538 : 
; 3539 :    // We found the anchor block!  Now map it.
; 3540 : #ifdef SHARED_MEM_TRACE
; 3541 :    fnTraceSharedMemory( "Mapping view of anchor block" );
; 3542 : #endif
; 3543 :    AnchorBlock = MapViewOfFile( (HANDLE) g_hAnchorBlock,

	push	0
	push	0
	push	0
	push	983071					; 000f001fH
	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	call	DWORD PTR __imp__MapViewOfFile@20
	mov	DWORD PTR _AnchorBlock, eax

; 3544 :                                 FILE_MAP_ALL_ACCESS, 0, 0, 0 );
; 3545 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN9@fnGetAncho

; 3546 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnGetAncho
$LN9@fnGetAncho:

; 3547 : 
; 3548 :    // We successfully gained addressability to the AnchorBlock!
; 3549 : 
; 3550 :    // Lock the anchor init mutex.  Once we get it we know that the anchor
; 3551 :    // has finished initializing so we can unlock it and go on our merry way.
; 3552 :    zLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysLockCoreMutex@4

; 3553 :    zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 3554 : 
; 3555 :    // We now have the anchor block but we still need to set the global
; 3556 :    // paging table values.  Note that the page table index had better
; 3557 :    // be the first one.
; 3558 :    g_ZeidonPageTable[ lPageTableIndex ] = AnchorBlock;

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], edx

; 3559 :    g_FileMappingHandles[ lPageTableIndex ] = (zLONG) g_hAnchorBlock;

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	ecx, DWORD PTR _g_hAnchorBlock
	mov	DWORD PTR _g_FileMappingHandles[eax*4], ecx

; 3560 : 
; 3561 :    TraceLine( "fnGetAnchorBlock Page Table mapping at Index: %x   0x%08x   Process: 0x%08x",

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[edx*4]
	push	eax
	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	push	ecx
	push	OFFSET $SG98875
	call	_TraceLine
	add	esp, 16					; 00000010H

; 3562 :               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3563 : 
; 3564 : //#ifdef DEBUG
; 3565 :    if ( g_lProcessIdx != -1 )

	cmp	DWORD PTR _g_lProcessIdx, -1
	je	SHORT $LN10@fnGetAncho

; 3566 :    {
; 3567 :       SysMessageBox( 0, "DGC", "g_lProcessIdx != -1", -1 );

	push	-1
	push	OFFSET $SG98877
	push	OFFSET $SG98878
	push	0
	call	_SysMessageBox@16

; 3568 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnGetAncho
$LN10@fnGetAncho:

; 3569 :    }
; 3570 : //#endif
; 3571 : 
; 3572 :    // Point to the correct structure in the AnchorBlock's ProcessList and set
; 3573 :    // g_lProcessIdx and the CurrentProcessId data element at the same time.
; 3574 :    fnSetProcessIdx( "GetAnchor", &lpProcessList );

	lea	edx, DWORD PTR _lpProcessList$[ebp]
	push	edx
	push	OFFSET $SG98879
	call	_fnSetProcessIdx
	add	esp, 8

; 3575 :    lpProcessList->uAppOE_Msg = (zUSHORT) lAppOE_Msg;

	mov	eax, DWORD PTR _lpProcessList$[ebp]
	mov	cx, WORD PTR _lAppOE_Msg$[ebp]
	mov	WORD PTR [eax+2], cx

; 3576 :    lpProcessList->hWndAppOE_Msg = hWndAppOE;

	mov	edx, DWORD PTR _lpProcessList$[ebp]
	mov	eax, DWORD PTR _hWndAppOE$[ebp]
	mov	DWORD PTR [edx+4], eax

; 3577 : 
; 3578 :    if ( g_bWin95 )

	movzx	ecx, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $LN11@fnGetAncho

; 3579 :    {
; 3580 :       // To mirror what happens in fnAllocSharedMemory we have to store the
; 3581 :       // index of g_hAnchorBlock in the first few bytes of the memory.
; 3582 :       *((zPLONG) AnchorBlock)++ = lPageTableIndex;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 4
	mov	DWORD PTR _AnchorBlock, ecx

; 3583 :       hSaveAnchorBlock = (zLONG) AnchorBlock;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR _hSaveAnchorBlock$[ebp], edx

; 3584 :    }

	jmp	SHORT $LN12@fnGetAncho
$LN11@fnGetAncho:

; 3585 :    else
; 3586 :       hSaveAnchorBlock = (zLONG) ((zULONG) lPageTableIndex << 24);

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	shl	eax, 24					; 00000018H
	mov	DWORD PTR _hSaveAnchorBlock$[ebp], eax
$LN12@fnGetAncho:

; 3587 : 
; 3588 :    // For the moment we'll change g_hAnchorBlock to be zero.  This will keep
; 3589 :    // some things (for example TraceLineX) from doing something it shouldn't.
; 3590 :    g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 3591 : 
; 3592 : // TraceLineI( "Register AnchorBlock = ", (zLONG) AnchorBlock );
; 3593 : 
; 3594 :    // We now have to open views to all shared mapping files created by other
; 3595 :    // tasks.  To do this we will send a message to the main task and ask for
; 3596 :    // the handle of each shared mapping file.  When the returned handle is
; 3597 :    // zero, then there are no more mapping files.
; 3598 : 
; 3599 :    // Init to first PageTable entry ... used in inter-process communication
; 3600 :    // to permit each shared mapping handle to be processed.
; 3601 :    lpProcessList->lPageTableIndex = lPageTableIndex;

	mov	ecx, DWORD PTR _lpProcessList$[ebp]
	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 3602 : 
; 3603 :    if ( IsWindow( (HWND) AnchorBlock->OS_Data.hMainWindow ) )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1503]
	push	ecx
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	je	SHORT $LN13@fnGetAncho

; 3604 :       bValidWindow = TRUE;

	mov	BYTE PTR _bValidWindow$[ebp], 1
	jmp	SHORT $LN2@fnGetAncho
$LN13@fnGetAncho:

; 3605 :    else
; 3606 :       bValidWindow = FALSE;

	mov	BYTE PTR _bValidWindow$[ebp], 0
$LN2@fnGetAncho:

; 3607 : 
; 3608 :    while ( bValidWindow )

	movzx	edx, BYTE PTR _bValidWindow$[ebp]
	test	edx, edx
	je	SHORT $LN3@fnGetAncho

; 3609 :    {
; 3610 :       lpProcessList->nOE_Request = TASKREQ_SHARE;  // we want to share handles

	mov	eax, 2
	mov	ecx, DWORD PTR _lpProcessList$[ebp]
	mov	WORD PTR [ecx], ax

; 3611 : 
; 3612 : #ifdef __MUTEX_DEBUG__
; 3613 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 3614 :       fnPrintMutexInfo( 's', zMUTEX_COUNT, __FILE__, __LINE__ );
; 3615 : #endif
; 3616 : 
; 3617 :       SendMessage( (HWND) AnchorBlock->OS_Data.hMainWindow,

	mov	edx, DWORD PTR _g_lProcessIdx
	push	edx
	push	0
	mov	eax, DWORD PTR _g_wOENG_Message
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1503]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 3618 :                    g_wOENG_Message, 0, g_lProcessIdx );
; 3619 : 
; 3620 : #ifdef __MUTEX_DEBUG__
; 3621 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 3622 :       fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 3623 : #endif
; 3624 : 
; 3625 :       // Check the returned handle.  If it's zero, then there are no more file mappings.
; 3626 :       if ( lpProcessList->hMemHandle == 0 )

	mov	eax, DWORD PTR _lpProcessList$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN15@fnGetAncho

; 3627 :          break;

	jmp	SHORT $LN3@fnGetAncho
$LN15@fnGetAncho:

; 3628 : 
; 3629 :       // Now call ProcessZeidonMessage to take the handle returned from the
; 3630 :       // system task and open it for the current task.
; 3631 :       lpProcessList->nOE_Request = TASKREQ_ALLOC; // we want to open a file mapping

	mov	ecx, 1
	mov	edx, DWORD PTR _lpProcessList$[ebp]
	mov	WORD PTR [edx], cx

; 3632 :       ProcessZeidonMessage( 0, g_lProcessIdx );

	mov	eax, DWORD PTR _g_lProcessIdx
	push	eax
	push	0
	call	_ProcessZeidonMessage@8

; 3633 :    }

	jmp	SHORT $LN2@fnGetAncho
$LN3@fnGetAncho:

; 3634 : 
; 3635 :    // Last thing is to change g_hAnchorBlock from zero to a Zeidon handle.
; 3636 :    g_hAnchorBlock = hSaveAnchorBlock;

	mov	ecx, DWORD PTR _hSaveAnchorBlock$[ebp]
	mov	DWORD PTR _g_hAnchorBlock, ecx

; 3637 :    return( 0 );

	xor	eax, eax
$LN1@fnGetAncho:

; 3638 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnGetAnchorBlock@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_k$ = -12						; size = 4
tv72 = -8						; size = 4
_lpViewOD$1 = -4					; size = 4
_lpView$ = 8						; size = 4
_lPageTableIndex$ = 12					; size = 4
_pHandle$ = 16						; size = 4
_CheckPointer PROC

; 2936 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2937 :    // Get high order byte from handle.
; 2938 :    zLONG  k = (zLONG) ((zULONG) pHandle >> 24);

	mov	eax, DWORD PTR _pHandle$[ebp]
	shr	eax, 24					; 00000018H
	mov	DWORD PTR _k$[ebp], eax

; 2939 :    if ( k == lPageTableIndex )

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	ecx, DWORD PTR _lPageTableIndex$[ebp]
	jne	SHORT $LN2@CheckPoint

; 2940 :    {
; 2941 :       LPVIEWOD lpViewOD;
; 2942 : 
; 2943 :       if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN3@CheckPoint

; 2944 :          lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax
	jmp	SHORT $LN4@CheckPoint
$LN3@CheckPoint:

; 2945 :       else
; 2946 :          lpViewOD = 0;

	mov	DWORD PTR _lpViewOD$1[ebp], 0
$LN4@CheckPoint:

; 2947 : 
; 2948 :       TraceLine( "Check Pointer Error for TableIndex: %d   ViewOD Name: %s",

	cmp	DWORD PTR _lpViewOD$1[ebp], 0
	je	SHORT $LN6@CheckPoint
	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR tv72[ebp], ecx
	jmp	SHORT $LN7@CheckPoint
$LN6@CheckPoint:
	mov	DWORD PTR tv72[ebp], OFFSET $SG98763
$LN7@CheckPoint:
	mov	edx, DWORD PTR tv72[ebp]
	push	edx
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	push	eax
	push	OFFSET $SG98764
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 2949 :                  lPageTableIndex, lpViewOD ? lpViewOD->szName : "No view" );
; 2950 :       SysMessageBox( 0, "Zeidon Core",

	push	-1
	push	OFFSET $SG98765
	push	OFFSET $SG98766
	push	0
	call	_SysMessageBox@16
$LN2@CheckPoint:

; 2951 :                      "Check Pointer Error for TableIndex!", -1 );
; 2952 :    }
; 2953 : 
; 2954 :    return( zGETPTR( pHandle ) );

	mov	ecx, DWORD PTR _pHandle$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr

; 2955 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CheckPointer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_nLth$ = -4						; size = 2
_pchFileName$ = 8					; size = 4
_nMaxLth$ = 12						; size = 2
_fnBuildZeidonIni PROC

; 1975 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1976 :    zSHORT nLth;
; 1977 : 
; 1978 :    SysGetEnvVar( pchFileName, szlZEIDON, nMaxLth );

	movsx	eax, WORD PTR _nMaxLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlZEIDON
	push	ecx
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_SysGetEnvVar@12

; 1979 :    if ( pchFileName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchFileName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN2@fnBuildZei

; 1980 :    {
; 1981 :       SysAppendcDirSep( pchFileName );

	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 1982 :       nLth = zstrlen( pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 1983 :       zstrcpy( pchFileName + nLth, "zeidon.ini" );

	push	OFFSET $SG98472
	movsx	eax, WORD PTR _nLth$[ebp]
	add	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1984 :    }

	jmp	SHORT $LN3@fnBuildZei
$LN2@fnBuildZei:

; 1985 :    else
; 1986 :       nLth = 0;

	xor	ecx, ecx
	mov	WORD PTR _nLth$[ebp], cx
$LN3@fnBuildZei:

; 1987 : 
; 1988 :    return( nLth );

	mov	ax, WORD PTR _nLth$[ebp]

; 1989 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnBuildZeidonIni ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
$T1 = -284						; size = 4
_sz$2 = -280						; size = 2
tv76 = -276						; size = 4
_bError$ = -271						; size = 1
_cDelimiter$ = -270					; size = 1
_bImbedding$ = -269					; size = 1
_pch1$ = -268						; size = 4
_pch2$ = -264						; size = 4
_sz$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pchFormat$ = 8						; size = 4
_fnConvertToZeidonFormat PROC

; 1255 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1256 :    zPCHAR   pch1;
; 1257 :    zPCHAR   pch2;
; 1258 :    zCHAR    sz[ 256 ];
; 1259 :    zBOOL    bError = 0;

	mov	BYTE PTR _bError$[ebp], 0

; 1260 :    zBOOL    bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0

; 1261 :    zCHAR    cDelimiter = 0;

	mov	BYTE PTR _cDelimiter$[ebp], 0

; 1262 : 
; 1263 :    pch1 = pchFormat;

	mov	eax, DWORD PTR _pchFormat$[ebp]
	mov	DWORD PTR _pch1$[ebp], eax

; 1264 :    pch2 = sz;

	lea	ecx, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _pch2$[ebp], ecx
$LN2@fnConvertT:

; 1265 : 
; 1266 :    while ( *pch1 )

	mov	edx, DWORD PTR _pch1$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@fnConvertT

; 1267 :    {
; 1268 :       if ( cDelimiter )

	movsx	ecx, BYTE PTR _cDelimiter$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@fnConvertT

; 1269 :       {
; 1270 :          if ( *pch1 == cDelimiter )

	mov	edx, DWORD PTR _pch1$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _cDelimiter$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN8@fnConvertT

; 1271 :          {
; 1272 :             cDelimiter = 0;

	mov	BYTE PTR _cDelimiter$[ebp], 0

; 1273 :             *pch2++ = *pch1++;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx
	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax

; 1274 :          }

	jmp	SHORT $LN9@fnConvertT
$LN8@fnConvertT:

; 1275 :          else
; 1276 :             *pch2++ = *pch1++;

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	edx, DWORD PTR _pch1$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx
$LN9@fnConvertT:

; 1277 :       }

	jmp	$LN7@fnConvertT
$LN6@fnConvertT:

; 1278 :       else
; 1279 :       switch ( *pch1 )

	mov	eax, DWORD PTR _pch1$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv76[ebp], ecx
	mov	edx, DWORD PTR tv76[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR tv76[ebp], edx
	cmp	DWORD PTR tv76[ebp], 89			; 00000059H
	ja	$LN42@fnConvertT
	mov	eax, DWORD PTR tv76[ebp]
	movzx	ecx, BYTE PTR $LN50@fnConvertT[eax]
	jmp	DWORD PTR $LN51@fnConvertT[ecx*4]
$LN10@fnConvertT:

; 1280 :       {
; 1281 :        case 'd':
; 1282 :        case 'D':
; 1283 :          if ( bImbedding )

	movzx	edx, BYTE PTR _bImbedding$[ebp]
	test	edx, edx
	je	SHORT $LN11@fnConvertT

; 1284 :          {
; 1285 :             *pch2++ = '\"';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1286 :             bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$LN11@fnConvertT:

; 1287 :          }
; 1288 : 
; 1289 :          if ( zstrncmpi( (pch1 + 1), "DDD", 3 ) == 0 )

	push	3
	push	OFFSET $SG98310
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN12@fnConvertT

; 1290 :          {
; 1291 :             *pch2++ = 'D';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 68			; 00000044H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1292 :             zmemcpy( pch2, "ddd", 3 );

	push	3
	push	OFFSET $SG98311
	mov	edx, DWORD PTR _pch2$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1293 :             pch1 += 4;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 4
	mov	DWORD PTR _pch1$[ebp], eax

; 1294 :             pch2 += 3;

	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 3
	mov	DWORD PTR _pch2$[ebp], ecx

; 1295 :          }

	jmp	$LN13@fnConvertT
$LN12@fnConvertT:

; 1296 :          else
; 1297 :          if ( zstrncmpi( (pch1 + 1), "DD", 2 ) == 0 )

	push	2
	push	OFFSET $SG98314
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN14@fnConvertT

; 1298 :          {
; 1299 :             *pch2++ = 'D';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 68			; 00000044H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1300 :             *pch2++ = 'd';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 100			; 00000064H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1301 :             *pch2++ = 'd';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 100			; 00000064H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1302 :             pch1 += 3;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 3
	mov	DWORD PTR _pch1$[ebp], eax

; 1303 :          }

	jmp	$LN13@fnConvertT
$LN14@fnConvertT:

; 1304 :          else
; 1305 :          if ( *(pch1 + 1) == 'D' ||

	mov	ecx, DWORD PTR _pch1$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 68					; 00000044H
	je	SHORT $LN18@fnConvertT
	mov	eax, DWORD PTR _pch1$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 100				; 00000064H
	jne	SHORT $LN16@fnConvertT
$LN18@fnConvertT:

; 1306 :               *(pch1 + 1) == 'd' )
; 1307 :          {
; 1308 :             *pch2++ = 'D';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 68			; 00000044H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1309 :             *pch2++ = 'd';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 100			; 00000064H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1310 :             pch1 += 2;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 2
	mov	DWORD PTR _pch1$[ebp], eax

; 1311 :          }

	jmp	SHORT $LN13@fnConvertT
$LN16@fnConvertT:

; 1312 :          else
; 1313 :          {
; 1314 :             *pch2++ = 'D';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 68			; 00000044H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1315 :             pch1++;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax
$LN13@fnConvertT:

; 1316 :          }
; 1317 : 
; 1318 :          break;

	jmp	$LN7@fnConvertT
$LN19@fnConvertT:

; 1319 : 
; 1320 :        case 'm':
; 1321 :        case 'M':
; 1322 :          if ( bImbedding )

	movzx	ecx, BYTE PTR _bImbedding$[ebp]
	test	ecx, ecx
	je	SHORT $LN20@fnConvertT

; 1323 :          {
; 1324 :             *pch2++ = '\"';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 34			; 00000022H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1325 :             bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$LN20@fnConvertT:

; 1326 :          }
; 1327 : 
; 1328 :          if ( zstrncmpi( (pch1 + 1), "MMM", 3 ) == 0 )

	push	3
	push	OFFSET $SG98322
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN21@fnConvertT

; 1329 :          {
; 1330 :             *pch2++ = 'M';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 77			; 0000004dH
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1331 :             zmemcpy( pch2, "mmm", 3 );

	push	3
	push	OFFSET $SG98323
	mov	ecx, DWORD PTR _pch2$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1332 :             pch2 += 3;

	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 3
	mov	DWORD PTR _pch2$[ebp], edx

; 1333 :             pch1 += 4;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 4
	mov	DWORD PTR _pch1$[ebp], eax

; 1334 :          }

	jmp	$LN22@fnConvertT
$LN21@fnConvertT:

; 1335 :          else
; 1336 :          if ( zstrncmpi( (pch1 + 1), "MM", 2 ) == 0 )

	push	2
	push	OFFSET $SG98326
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN23@fnConvertT

; 1337 :          {
; 1338 :             *pch2++ = 'M';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 77			; 0000004dH
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1339 :             zmemcpy( pch2, "mm", 2 );

	push	2
	push	OFFSET $SG98327
	mov	ecx, DWORD PTR _pch2$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1340 :             pch2 += 2;

	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 2
	mov	DWORD PTR _pch2$[ebp], edx

; 1341 :             pch1 += 3;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 3
	mov	DWORD PTR _pch1$[ebp], eax

; 1342 :          }

	jmp	$LN22@fnConvertT
$LN23@fnConvertT:

; 1343 :          else
; 1344 :          if ( *(pch1 + 1) == 'M' ||

	mov	ecx, DWORD PTR _pch1$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 77					; 0000004dH
	je	SHORT $LN27@fnConvertT
	mov	eax, DWORD PTR _pch1$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 109				; 0000006dH
	jne	SHORT $LN25@fnConvertT
$LN27@fnConvertT:

; 1345 :               *(pch1 + 1) == 'm' )
; 1346 :          {
; 1347 :             *pch2++ = 'M';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 77			; 0000004dH
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1348 :             *pch2++ = 'm';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 109			; 0000006dH
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1349 :             pch1 +=2;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 2
	mov	DWORD PTR _pch1$[ebp], eax

; 1350 :          }

	jmp	SHORT $LN22@fnConvertT
$LN25@fnConvertT:

; 1351 :          else
; 1352 :          {
; 1353 :             *pch2++ = 'M';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 77			; 0000004dH
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1354 :             pch1++;

	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax
$LN22@fnConvertT:

; 1355 :          }
; 1356 : 
; 1357 :          break;

	jmp	$LN7@fnConvertT
$LN28@fnConvertT:

; 1358 : 
; 1359 :        case 'y':
; 1360 :        case 'Y':
; 1361 :          if ( zstrncmpi( (pch1 + 1), "YYY", 3 ) == 0 )

	push	3
	push	OFFSET $SG98334
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN29@fnConvertT

; 1362 :          {
; 1363 :             if ( bImbedding )

	movzx	edx, BYTE PTR _bImbedding$[ebp]
	test	edx, edx
	je	SHORT $LN31@fnConvertT

; 1364 :             {
; 1365 :                *pch2++ = '\"';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 34			; 00000022H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1366 :                bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$LN31@fnConvertT:

; 1367 :             }
; 1368 : 
; 1369 :             zmemcpy( pch2, "YYYY", 4 );

	push	4
	push	OFFSET $SG98336
	mov	edx, DWORD PTR _pch2$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1370 :             pch2 += 4;

	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 4
	mov	DWORD PTR _pch2$[ebp], eax

; 1371 :             pch1 += 4;

	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pch1$[ebp], ecx

; 1372 :          }

	jmp	$LN30@fnConvertT
$LN29@fnConvertT:

; 1373 :          else
; 1374 :          if ( *(pch1 + 1) == 'Y' || *(pch1 + 1) == 'y' )

	mov	edx, DWORD PTR _pch1$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 89					; 00000059H
	je	SHORT $LN34@fnConvertT
	mov	ecx, DWORD PTR _pch1$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 121				; 00000079H
	jne	SHORT $LN32@fnConvertT
$LN34@fnConvertT:

; 1375 :          {
; 1376 :             if ( bImbedding )

	movzx	eax, BYTE PTR _bImbedding$[ebp]
	test	eax, eax
	je	SHORT $LN35@fnConvertT

; 1377 :             {
; 1378 :                *pch2++ = '\"';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 34			; 00000022H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 1379 :                bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0
$LN35@fnConvertT:

; 1380 :             }
; 1381 : 
; 1382 :             *pch2++ = 'Y';

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 89			; 00000059H
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 1383 :             *pch2++ = 'Y';

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 89			; 00000059H
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 1384 :             pch1 += 2;

	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pch1$[ebp], ecx

; 1385 :          }

	jmp	SHORT $LN30@fnConvertT
$LN32@fnConvertT:

; 1386 :          else
; 1387 :          if ( bImbedding )

	movzx	edx, BYTE PTR _bImbedding$[ebp]
	test	edx, edx
	je	SHORT $LN36@fnConvertT

; 1388 :             *pch2++ = *pch1++;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	ecx, DWORD PTR _pch1$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch1$[ebp], ecx
	jmp	SHORT $LN30@fnConvertT
$LN36@fnConvertT:

; 1389 :          else
; 1390 :             bError = 1;

	mov	BYTE PTR _bError$[ebp], 1
$LN30@fnConvertT:

; 1391 : 
; 1392 :          break;

	jmp	$LN7@fnConvertT
$LN38@fnConvertT:

; 1393 : 
; 1394 :        case '\"':  // quote
; 1395 :          if ( bImbedding )

	movzx	edx, BYTE PTR _bImbedding$[ebp]
	test	edx, edx
	je	SHORT $LN40@fnConvertT

; 1396 :          {
; 1397 :             bImbedding = 0;

	mov	BYTE PTR _bImbedding$[ebp], 0

; 1398 :             cDelimiter = *pch1++;

	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cDelimiter$[ebp], cl
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx

; 1399 :             break;

	jmp	$LN7@fnConvertT
$LN40@fnConvertT:

; 1400 :          }
; 1401 : 
; 1402 :        case '\'':  // apostrophe
; 1403 :          cDelimiter = *pch1;

	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _cDelimiter$[ebp], cl

; 1404 :          *pch2++ = *pch1++;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	eax, DWORD PTR _pch1$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx
	mov	eax, DWORD PTR _pch1$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch1$[ebp], eax

; 1405 :          break;

	jmp	$LN7@fnConvertT
$LN41@fnConvertT:

; 1406 : 
; 1407 :        case '(':   // left paren
; 1408 :        case ')':   // right paren
; 1409 :        case ':':   // colon
; 1410 :        case ',':   // comma
; 1411 :        case '-':   // dash
; 1412 :        case '/':   // slash
; 1413 :        case '.':   // period
; 1414 :        case ' ':   // space
; 1415 :          *pch2++ = *pch1++;

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	edx, DWORD PTR _pch1$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch1$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch1$[ebp], edx

; 1416 :          break;

	jmp	SHORT $LN7@fnConvertT
$LN42@fnConvertT:

; 1417 : 
; 1418 :        default:
; 1419 :          if ( !bImbedding )

	movzx	eax, BYTE PTR _bImbedding$[ebp]
	test	eax, eax
	jne	SHORT $LN43@fnConvertT

; 1420 :          {
; 1421 :             bImbedding = 1;

	mov	BYTE PTR _bImbedding$[ebp], 1

; 1422 :             *pch2++ = '\"';

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [ecx], 34			; 00000022H
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx
$LN43@fnConvertT:

; 1423 :          }
; 1424 : 
; 1425 :          *pch2++ = *pch1++;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	ecx, DWORD PTR _pch1$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
	mov	ecx, DWORD PTR _pch1$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch1$[ebp], ecx
$LN7@fnConvertT:

; 1426 :       }
; 1427 : 
; 1428 :       if ( bError )

	movzx	edx, BYTE PTR _bError$[ebp]
	test	edx, edx
	je	SHORT $LN44@fnConvertT

; 1429 :          break;

	jmp	SHORT $LN3@fnConvertT
$LN44@fnConvertT:

; 1430 :    }

	jmp	$LN2@fnConvertT
$LN3@fnConvertT:

; 1431 : 
; 1432 :    *pch2 = 0; // terminate the string.

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 0

; 1433 : 
; 1434 :    if ( bError == FALSE )

	movzx	ecx, BYTE PTR _bError$[ebp]
	test	ecx, ecx
	jne	SHORT $LN45@fnConvertT

; 1435 :       zstrcpy( pchFormat, sz );   // return the zeidon format

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchFormat$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN45@fnConvertT:

; 1436 : 
; 1437 :    if ( cDelimiter && bError == FALSE )

	movsx	ecx, BYTE PTR _cDelimiter$[ebp]
	test	ecx, ecx
	je	SHORT $LN46@fnConvertT
	movzx	edx, BYTE PTR _bError$[ebp]
	test	edx, edx
	jne	SHORT $LN46@fnConvertT

; 1438 :    {
; 1439 :       zCHAR sz[ 2 ];
; 1440 : 
; 1441 :       sz[ 0 ] = cDelimiter;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _cDelimiter$[ebp]
	mov	BYTE PTR _sz$2[ebp+ecx], dl

; 1442 :       sz[ 1 ] = 0;

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 2
	jae	SHORT $LN48@fnConvertT
	jmp	SHORT $LN49@fnConvertT
$LN48@fnConvertT:
	call	___report_rangecheckfailure
$LN49@fnConvertT:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _sz$2[ebp+eax], 0

; 1443 : 
; 1444 :       // "KZOEE360 - Missing ending delimiter "
; 1445 :       fnSysMessageBox( 0, "Zeidon Error", "Missing ending delimiter", 0 );

	push	0
	push	OFFSET $SG98352
	push	OFFSET $SG98353
	push	0
	call	_fnSysMessageBox@16
$LN46@fnConvertT:

; 1446 :    // fnIssueCoreError( 0, lpView, 16, 360, 0, sz, "from WIN.INI" );
; 1447 :    }
; 1448 : 
; 1449 :    return( bError );

	mov	al, BYTE PTR _bError$[ebp]
$LN47@fnConvertT:

; 1450 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@fnConvertT:
	DD	$LN41@fnConvertT
	DD	$LN38@fnConvertT
	DD	$LN40@fnConvertT
	DD	$LN10@fnConvertT
	DD	$LN19@fnConvertT
	DD	$LN28@fnConvertT
	DD	$LN42@fnConvertT
$LN50@fnConvertT:
	DB	0
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	6
	DB	2
	DB	0
	DB	0
	DB	6
	DB	6
	DB	0
	DB	0
	DB	0
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	5
_fnConvertToZeidonFormat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pOS_Record$ = -4					; size = 4
_cpcText$ = 8						; size = 4
_ppProcessList$ = 12					; size = 4
_fnSetProcessIdx PROC

; 415  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 416  :    LPANCHOROS_RECORD pOS_Record = &AnchorBlock->OS_Data;

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1503				; 000005dfH
	mov	DWORD PTR _pOS_Record$[ebp], eax

; 417  : 
; 418  :    if ( g_lProcessIdx == -1 )

	cmp	DWORD PTR _g_lProcessIdx, -1
	jne	SHORT $LN5@fnSetProce

; 419  :    {
; 420  :       // Find an open cell in the Process record.
; 421  :       for ( g_lProcessIdx = 0;

	mov	DWORD PTR _g_lProcessIdx, 0
	jmp	SHORT $LN4@fnSetProce
$LN2@fnSetProce:

; 423  :             g_lProcessIdx++ )

	mov	ecx, DWORD PTR _g_lProcessIdx
	add	ecx, 1
	mov	DWORD PTR _g_lProcessIdx, ecx
$LN4@fnSetProce:

; 422  :             pOS_Record->ProcessList[ g_lProcessIdx ].lProcessID != 0;

	imul	edx, DWORD PTR _g_lProcessIdx, 20
	mov	eax, DWORD PTR _pOS_Record$[ebp]
	cmp	DWORD PTR [eax+edx+24], 0
	je	SHORT $LN3@fnSetProce

; 424  :       {
; 425  :          if ( g_lProcessIdx >= zMAX_PROCESSES )

	cmp	DWORD PTR _g_lProcessIdx, 50		; 00000032H
	jl	SHORT $LN6@fnSetProce

; 426  :          {
; 427  :             SysMessageBox( 0, szlOE_SystemError, "Exceeded Process Limit ... Contact Zeidon Support", -1 );

	push	-1
	push	OFFSET $SG98009
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 428  :             break;

	jmp	SHORT $LN3@fnSetProce
$LN6@fnSetProce:

; 429  :          }
; 430  :       }

	jmp	SHORT $LN2@fnSetProce
$LN3@fnSetProce:

; 431  : 
; 432  :       // pOS_Record->lProcessCount keeps track of the highest process idx.
; 433  :       if ( g_lProcessIdx >= pOS_Record->lProcessCount )

	mov	edx, DWORD PTR _pOS_Record$[ebp]
	mov	eax, DWORD PTR _g_lProcessIdx
	cmp	eax, DWORD PTR [edx+4]
	jl	SHORT $LN5@fnSetProce

; 434  :          pOS_Record->lProcessCount = g_lProcessIdx + 1;

	mov	ecx, DWORD PTR _g_lProcessIdx
	add	ecx, 1
	mov	edx, DWORD PTR _pOS_Record$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN5@fnSetProce:

; 435  :    }
; 436  : 
; 437  :    *ppProcessList = &pOS_Record->ProcessList[ g_lProcessIdx ];

	imul	eax, DWORD PTR _g_lProcessIdx, 20
	mov	ecx, DWORD PTR _pOS_Record$[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	eax, DWORD PTR _ppProcessList$[ebp]
	mov	DWORD PTR [eax], edx

; 438  :    (*ppProcessList)->lProcessID = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	ecx, DWORD PTR _ppProcessList$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [edx+16], eax

; 439  : 
; 440  : // TraceLine( "%s:  fnSetProcessIdx =======================>>>>> ProcessIdx: %d   CurrentProcess: %d",
; 441  : //            cpcText, g_lProcessIdx, (*ppProcessList)->lProcessID );
; 442  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetProcessIdx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lStartIdx$1 = -12					; size = 4
_pv$ = -8						; size = 4
_k$2 = -4						; size = 4
_phHandle$ = 8						; size = 4
_lBytes$ = 12						; size = 4
_plPageTableIndex$ = 16					; size = 4
_cpcShareName$ = 20					; size = 4
_fnMapFile@16 PROC

; 4221 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4222 :    zPVOID pv;
; 4223 : 
; 4224 :    // If the handle is zero then we need to create one.
; 4225 :    if ( *phHandle == 0 )

	mov	eax, DWORD PTR _phHandle$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	$LN5@fnMapFile

; 4226 :    {
; 4227 :       zLONG  k;
; 4228 :       zLONG  lStartIdx;
; 4229 : 
; 4230 :       // Start off by finding an empty (or open) page table entry.
; 4231 : 
; 4232 :       if ( g_bWin95 )

	movzx	ecx, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $LN7@fnMapFile

; 4233 :          lStartIdx = 1;

	mov	DWORD PTR _lStartIdx$1[ebp], 1
	jmp	SHORT $LN8@fnMapFile
$LN7@fnMapFile:

; 4234 :       else
; 4235 :       {
; 4236 : #ifdef DEBUG_PAGETABLE
; 4237 :          // When we are debugging we start with page 128 so that the high bit
; 4238 :          // in the resulting handle will always be set.
; 4239 :          lStartIdx = 128;

	mov	DWORD PTR _lStartIdx$1[ebp], 128	; 00000080H
$LN8@fnMapFile:

; 4240 : #else
; 4241 :          // We start with page one (instead of zero) so that a handle will always
; 4242 :          // be non-zero.
; 4243 :          lStartIdx = 1;
; 4244 : #endif
; 4245 :       }
; 4246 : 
; 4247 :       for ( k = lStartIdx; k < zSHR_MAX_PAGES; k++ )

	mov	edx, DWORD PTR _lStartIdx$1[ebp]
	mov	DWORD PTR _k$2[ebp], edx
	jmp	SHORT $LN4@fnMapFile
$LN2@fnMapFile:
	mov	eax, DWORD PTR _k$2[ebp]
	add	eax, 1
	mov	DWORD PTR _k$2[ebp], eax
$LN4@fnMapFile:
	cmp	DWORD PTR _k$2[ebp], 256		; 00000100H
	jge	SHORT $LN3@fnMapFile

; 4248 :       {
; 4249 :          // If we find an empty page break loop.
; 4250 :          if ( g_ZeidonPageTable[ k ] == 0 )

	mov	ecx, DWORD PTR _k$2[ebp]
	cmp	DWORD PTR _g_ZeidonPageTable[ecx*4], 0
	jne	SHORT $LN9@fnMapFile

; 4251 :             break;

	jmp	SHORT $LN3@fnMapFile
$LN9@fnMapFile:

; 4252 :       }

	jmp	SHORT $LN2@fnMapFile
$LN3@fnMapFile:

; 4253 : 
; 4254 :       if ( k >= zSHR_MAX_PAGES )

	cmp	DWORD PTR _k$2[ebp], 256		; 00000100H
	jl	SHORT $LN10@fnMapFile

; 4255 :       {
; 4256 :          SysMessageBox( 0, szlOE_SystemError, "Out of memory pages!", -1 );

	push	-1
	push	OFFSET $SG99065
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 4257 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnMapFile
$LN10@fnMapFile:

; 4258 :       }
; 4259 : 
; 4260 :       if ( g_bWin95 )

	movzx	eax, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $LN11@fnMapFile

; 4261 :       {
; 4262 :          // Take into account that we have to store the index of the currently
; 4263 :          // allocated block of memory in the first few bytes of the memory.
; 4264 :          lBytes += sizeof( zLONG );

	mov	ecx, DWORD PTR _lBytes$[ebp]
	add	ecx, 4
	mov	DWORD PTR _lBytes$[ebp], ecx
$LN11@fnMapFile:

; 4265 :       }
; 4266 : 
; 4267 :       *plPageTableIndex = k;

	mov	edx, DWORD PTR _plPageTableIndex$[ebp]
	mov	eax, DWORD PTR _k$2[ebp]
	mov	DWORD PTR [edx], eax

; 4268 : 
; 4269 :    // TraceLine( "fnMapFile Page Table mapped at Index: %x   0x%08x   Process: %d",
; 4270 :    //            *plPageTableIndex, g_ZeidonPageTable[ *plPageTableIndex ], SysGetProcessID( 0 ) );
; 4271 : 
; 4272 :       *phHandle = CreateFileMapping( (HANDLE) -1, NULL, PAGE_READWRITE,

	mov	ecx, DWORD PTR _cpcShareName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	push	0
	push	4
	push	0
	push	-1
	call	DWORD PTR __imp__CreateFileMappingA@24
	mov	ecx, DWORD PTR _phHandle$[ebp]
	mov	DWORD PTR [ecx], eax

; 4273 :                                      0, lBytes, cpcShareName );
; 4274 :       if ( *phHandle == 0 )

	mov	edx, DWORD PTR _phHandle$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN12@fnMapFile

; 4275 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnMapFile
$LN12@fnMapFile:

; 4276 :    }

	jmp	SHORT $LN6@fnMapFile
$LN5@fnMapFile:

; 4277 :    else
; 4278 :    {
; 4279 :       if ( g_ZeidonPageTable[ *plPageTableIndex ] )

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR _g_ZeidonPageTable[ecx*4], 0
	je	SHORT $LN6@fnMapFile

; 4280 :       {
; 4281 :          TraceLine( "fnMapFile Page Table conflict at Index: %x   0x%08x   Process: %d",

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	edx, DWORD PTR _plPageTableIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _g_ZeidonPageTable[eax*4]
	push	ecx
	mov	edx, DWORD PTR _plPageTableIndex$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET $SG99069
	call	_TraceLine
	add	esp, 16					; 00000010H

; 4282 :                     *plPageTableIndex, g_ZeidonPageTable[ *plPageTableIndex ], SysGetProcessID( 0 ) );
; 4283 :       // SysMessageBox( 0, szlOE_SystemError, "Page Table conflict!", -1 );
; 4284 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnMapFile
$LN6@fnMapFile:

; 4285 :       }
; 4286 :    }
; 4287 : 
; 4288 : #ifdef SHARED_MEM_TRACE
; 4289 :    fnTraceSharedMemory( "fnMapFile" );
; 4290 : #endif
; 4291 :    pv = MapViewOfFile( *phHandle, FILE_MAP_WRITE, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _phHandle$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__MapViewOfFile@20
	mov	DWORD PTR _pv$[ebp], eax

; 4292 : 
; 4293 :    g_ZeidonPageTable[ *plPageTableIndex ] = pv;

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], edx

; 4294 :    g_FileMappingHandles[ *plPageTableIndex ] = (zLONG) *phHandle;

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _phHandle$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _g_FileMappingHandles[ecx*4], eax

; 4295 : 
; 4296 : #ifdef SHARED_MEM_TRACE
; 4297 :    TraceLine( "fnMapFile Page Table mapped at Index: %x   0x%08x   Process: %d",
; 4298 :               *plPageTableIndex, g_ZeidonPageTable[ *plPageTableIndex ], SysGetProcessID( 0 ) );
; 4299 : #endif
; 4300 : 
; 4301 :    // Create a handle.
; 4302 :    if ( g_bWin95 )

	movzx	ecx, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $LN14@fnMapFile

; 4303 :    {
; 4304 :       // Store the index of the shared memory in the first couple of bytes of
; 4305 :       // the shared memory.
; 4306 :       *((zPLONG) pv)++ = *plPageTableIndex;

	mov	edx, DWORD PTR _pv$[ebp]
	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR _pv$[ebp]
	add	edx, 4
	mov	DWORD PTR _pv$[ebp], edx

; 4307 :       *phHandle = (HANDLE) pv;

	mov	eax, DWORD PTR _phHandle$[ebp]
	mov	ecx, DWORD PTR _pv$[ebp]
	mov	DWORD PTR [eax], ecx

; 4308 :    }

	jmp	SHORT $LN15@fnMapFile
$LN14@fnMapFile:

; 4309 :    else
; 4310 :    {
; 4311 :       if ( g_bWin95 )

	movzx	edx, BYTE PTR _g_bWin95
	test	edx, edx
	je	SHORT $LN16@fnMapFile

; 4312 :          *phHandle = (HANDLE) g_ZeidonPageTable[ *plPageTableIndex ];

	mov	eax, DWORD PTR _plPageTableIndex$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _phHandle$[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[ecx*4]
	mov	DWORD PTR [edx], eax
	jmp	SHORT $LN15@fnMapFile
$LN16@fnMapFile:

; 4313 :       else
; 4314 :          *phHandle = (HANDLE) ((zULONG) *plPageTableIndex << 24);

	mov	ecx, DWORD PTR _plPageTableIndex$[ebp]
	mov	edx, DWORD PTR [ecx]
	shl	edx, 24					; 00000018H
	mov	eax, DWORD PTR _phHandle$[ebp]
	mov	DWORD PTR [eax], edx
$LN15@fnMapFile:

; 4315 :    }
; 4316 : 
; 4317 :    return( pv );

	mov	eax, DWORD PTR _pv$[ebp]
$LN1@fnMapFile:

; 4318 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnMapFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lProcessID$ = -20					; size = 4
_hMutex$ = -16						; size = 4
_hSysMutex$ = -12					; size = 4
_lpSysMutex$ = -8					; size = 4
_lpMutex$ = -4						; size = 4
_lpTask$ = 8						; size = 4
_cpcMutexName$ = 12					; size = 4
_lControl$ = 16						; size = 4
_bSkipSettingMutex$ = 20				; size = 1
_fnMutexCreate@16 PROC

; 8804 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8805 :    LPMUTEX lpMutex;
; 8806 :    LPMUTEX hMutex;
; 8807 :    LPMUTEX lpSysMutex;
; 8808 :    LPMUTEX hSysMutex;
; 8809 :    zLONG   lProcessID;
; 8810 : 
; 8811 :    if ( zstrlen( cpcMutexName ) > zZEIDON_NAME_LTH * 2 )

	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 64					; 00000040H
	jbe	SHORT $LN2@fnMutexCre

; 8812 :    {
; 8813 :       // "KZOEE032 - Invalid mutex name"
; 8814 :    // fnIssueCoreError( lpTask, lpView, 16, 32, 0, 0, 0 );
; 8815 :       TraceLineS( "fnMutexCreate Invalid mutex name: ", cpcMutexName );

	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	push	ecx
	push	OFFSET $SG100596
	call	_TraceLineS@8

; 8816 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnMutexCre
$LN2@fnMutexCre:

; 8817 :    }
; 8818 : 
; 8819 :    // Look for the mutex. If it is found just return it.
; 8820 :    lpMutex = fnMutexFind( lpTask, cpcMutexName );

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnMutexFind@8
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8821 :    if ( lpMutex )

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $LN3@fnMutexCre

; 8822 :       return( lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	jmp	$LN1@fnMutexCre
$LN3@fnMutexCre:

; 8823 : 
; 8824 :    lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 8825 : 
; 8826 :    // If the mutex wasn't found in the task list then try looking for it
; 8827 :    // in the system list.  We put a mutex around it so we only create the
; 8828 :    // system mutex once.
; 8829 :    if ( bSkipSettingMutex == FALSE )

	movzx	ecx, BYTE PTR _bSkipSettingMutex$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@fnMutexCre

; 8830 :       zLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysLockCoreMutex@4
$LN4@fnMutexCre:

; 8831 : 
; 8832 :    lpSysMutex = fnMutexFind( (LPTASK) -1, cpcMutexName );

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	push	-1
	call	_fnMutexFind@8
	mov	DWORD PTR _lpSysMutex$[ebp], eax

; 8833 :    if ( lpSysMutex == 0 )

	cmp	DWORD PTR _lpSysMutex$[ebp], 0
	jne	SHORT $LN5@fnMutexCre

; 8834 :    {
; 8835 :       // We need to create the system mutex.
; 8836 :       hSysMutex = fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,

	push	10045					; 0000273dH
	push	0
	push	1
	push	602					; 0000025aH
	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hSysMutex$[ebp], eax

; 8837 :                                     sizeof( MutexRecord ), 1, 0, iMutex );
; 8838 :       lpSysMutex = zGETPTR( hSysMutex );

	mov	ecx, DWORD PTR _hSysMutex$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSysMutex$[ebp], eax

; 8839 :       zstrcpy( lpSysMutex->szName, cpcMutexName );

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	add	eax, 6
	push	eax
	call	_strcpy
	add	esp, 8

; 8840 :       lpSysMutex->lNameHash = fnHashName( cpcMutexName );

	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	push	ecx
	call	_fnHashName@4
	mov	edx, DWORD PTR _lpSysMutex$[ebp]
	mov	DWORD PTR [edx+71], eax

; 8841 :    // lpSysMutex->lProcessID = lProcessID; we don't care what process created the system mutex
; 8842 :       lpSysMutex->lProcessID = 0;

	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	mov	DWORD PTR [eax+89], 0

; 8843 : 
; 8844 :       // Right now, I don't know why we want to create the OS mutex for
; 8845 :       // a "system" mutex ... so let's disable it.  // dks  2006.02.24
; 8846 :    // if ( fnMutexCreateOS( 0, lpSysMutex, lControl ) != 0 )
; 8847 :    // {
; 8848 :    //    if ( bSkipSettingMutex == FALSE )
; 8849 :    //       zUNLOCK_MUTEX( zMUTEX_MUTEX );
; 8850 :    //
; 8851 :    //    fnFreeDataspace( hSysMutex );
; 8852 :    //    return( 0 );
; 8853 :    // }
; 8854 : 
; 8855 :       lpSysMutex->hNextMutex = AnchorBlock->hFirstSysMutex;

	mov	ecx, DWORD PTR _lpSysMutex$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2519]
	mov	DWORD PTR [ecx+2], eax

; 8856 :       AnchorBlock->hFirstSysMutex = hSysMutex;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hSysMutex$[ebp]
	mov	DWORD PTR [ecx+2519], edx

; 8857 :    }

	jmp	SHORT $LN6@fnMutexCre
$LN5@fnMutexCre:

; 8858 :    else
; 8859 :       hSysMutex = zGETHNDL( lpSysMutex );

	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hSysMutex$[ebp], eax
$LN6@fnMutexCre:

; 8860 : 
; 8861 :    // lpMutex must be null, or else we'd be out of here.
; 8862 :    // Create the task mutex.
; 8863 :    hMutex = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10045					; 0000273dH
	push	0
	push	1
	push	602					; 0000025aH
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hMutex$[ebp], eax

; 8864 :                               sizeof( MutexRecord ), 1, 0, iMutex );
; 8865 :    lpMutex = zGETPTR( hMutex );

	mov	eax, DWORD PTR _hMutex$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8866 :    zstrcpy( lpMutex->szName, cpcMutexName );

	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	add	edx, 6
	push	edx
	call	_strcpy
	add	esp, 8

; 8867 :    lpMutex->hSysMutex = hSysMutex;

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR _hSysMutex$[ebp]
	mov	DWORD PTR [eax+77], ecx

; 8868 :    lpMutex->lNameHash = lpSysMutex->lNameHash;

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR _lpSysMutex$[ebp]
	mov	ecx, DWORD PTR [eax+71]
	mov	DWORD PTR [edx+71], ecx

; 8869 :    lpMutex->lProcessID = lProcessID;

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [edx+89], eax

; 8870 : 
; 8871 :    if ( fnMutexCreateOS( lpTask, lpMutex, lControl ) != 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnMutexCreateOS@12
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN7@fnMutexCre

; 8872 :    {
; 8873 :       if ( bSkipSettingMutex == FALSE )

	movzx	edx, BYTE PTR _bSkipSettingMutex$[ebp]
	test	edx, edx
	jne	SHORT $LN8@fnMutexCre

; 8874 :          zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4
$LN8@fnMutexCre:

; 8875 : 
; 8876 :       fnFreeDataspace( hMutex );

	mov	eax, DWORD PTR _hMutex$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 8877 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnMutexCre
$LN7@fnMutexCre:

; 8878 :    }
; 8879 : 
; 8880 :    lpMutex->hNextMutex = lpTask->hFirstMutex;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+150]
	mov	DWORD PTR [ecx+2], eax

; 8881 :    lpTask->hFirstMutex = hMutex;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hMutex$[ebp]
	mov	DWORD PTR [ecx+150], edx

; 8882 : 
; 8883 :    if ( bSkipSettingMutex == FALSE )

	movzx	eax, BYTE PTR _bSkipSettingMutex$[ebp]
	test	eax, eax
	jne	SHORT $LN9@fnMutexCre

; 8884 :       zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4
$LN9@fnMutexCre:

; 8885 : 
; 8886 : #ifdef TRACE_MUTEX
; 8887 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 8888 :    TraceLine( "fnMutexCreate  (Created:) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x  SysMutex: 0x%08x",
; 8889 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 8890 :               lpMutex->szName, SysGetProcessID( 0 ), lpMutex->hSysMutex );
; 8891 : #endif
; 8892 : 
; 8893 :    return( lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
$LN1@fnMutexCre:

; 8894 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnMutexCreate@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lHash$ = -20						; size = 4
tv136 = -16						; size = 4
tv135 = -12						; size = 4
_lProcessID$ = -8					; size = 4
_lpMutex$ = -4						; size = 4
_lpTask$ = 8						; size = 4
_cpcMutexName$ = 12					; size = 4
_fnMutexFind@8 PROC

; 8729 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 8730 :    zLONG   lHash = fnHashName( cpcMutexName );

	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	call	_fnHashName@4
	mov	DWORD PTR _lHash$[ebp], eax

; 8731 :    LPMUTEX lpMutex;
; 8732 :    zLONG   lProcessID;
; 8733 : 
; 8734 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN5@fnMutexFin

; 8735 :    {
; 8736 :       SysMessageBox( 0, "MutexFind", "Null task", -1 );

	push	-1
	push	OFFSET $SG100566
	push	OFFSET $SG100567
	push	0
	call	_SysMessageBox@16

; 8737 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnMutexFin
$LN5@fnMutexFin:

; 8738 :    }
; 8739 : 
; 8740 :    if ( lpTask == (LPTASK) -1 )  // processing system mutex list

	cmp	DWORD PTR _lpTask$[ebp], -1
	jne	SHORT $LN6@fnMutexFin

; 8741 :    {
; 8742 :       zLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysLockCoreMutex@4

; 8743 :       lpMutex = zGETPTR( AnchorBlock->hFirstSysMutex );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2519]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8744 :       lProcessID = 0;  // system mutexes are "process ignorant"

	mov	DWORD PTR _lProcessID$[ebp], 0

; 8745 :    }

	jmp	SHORT $LN7@fnMutexFin
$LN6@fnMutexFin:

; 8746 :    else
; 8747 :    {
; 8748 :       lpMutex = zGETPTR( lpTask->hFirstMutex );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+150]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax

; 8749 :       lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax
$LN7@fnMutexFin:

; 8750 :    }
; 8751 : 
; 8752 :    // Try finding the mutex.
; 8753 :    for ( ;

	jmp	SHORT $LN4@fnMutexFin
$LN2@fnMutexFin:

; 8755 :          lpMutex = zGETPTR( lpMutex->hNextMutex ) )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
$LN4@fnMutexFin:

; 8754 :          lpMutex;

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	$LN3@fnMutexFin

; 8756 :    {
; 8757 :       if ( lpMutex->lNameHash != lHash )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+71]
	cmp	edx, DWORD PTR _lHash$[ebp]
	je	SHORT $LN8@fnMutexFin

; 8758 :          continue;

	jmp	SHORT $LN2@fnMutexFin
$LN8@fnMutexFin:

; 8759 : 
; 8760 :       // Don't qualify on ProcessID if it is a system mutex.
; 8761 : #if 0
; 8762 :       if ( lProcessID == 0 )  // processing system mutex list
; 8763 :       {
; 8764 :          // We don't care about process ID match.
; 8765 :       }
; 8766 :       else
; 8767 :       {
; 8768 :          // We do care about process ID match.
; 8769 :          if ( lpMutex->lProcessID != lProcessID )
; 8770 :             continue;
; 8771 :       }
; 8772 : #else
; 8773 :       if ( lProcessID && lpMutex->lProcessID != lProcessID )

	cmp	DWORD PTR _lProcessID$[ebp], 0
	je	SHORT $LN9@fnMutexFin
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+89]
	cmp	ecx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN9@fnMutexFin

; 8774 :          continue;

	jmp	SHORT $LN2@fnMutexFin
$LN9@fnMutexFin:

; 8775 : #endif
; 8776 : 
; 8777 :       if ( zstrcmp( lpMutex->szName, cpcMutexName ) != 0 )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN15@fnMutexFin
	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN16@fnMutexFin
$LN15@fnMutexFin:
	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	mov	ecx, DWORD PTR _cpcMutexName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN13@fnMutexFin
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN14@fnMutexFin
$LN13@fnMutexFin:
	mov	DWORD PTR tv135[ebp], -1
$LN14@fnMutexFin:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv136[ebp], eax
$LN16@fnMutexFin:
	cmp	DWORD PTR tv136[ebp], 0
	je	SHORT $LN10@fnMutexFin

; 8778 :          continue;

	jmp	$LN2@fnMutexFin
$LN10@fnMutexFin:

; 8779 : 
; 8780 :       // If we get here we found the right mutex.
; 8781 :       break;

	jmp	SHORT $LN3@fnMutexFin

; 8782 :    }

	jmp	$LN2@fnMutexFin
$LN3@fnMutexFin:

; 8783 : 
; 8784 :    if ( lpTask == (LPTASK) -1 )

	cmp	DWORD PTR _lpTask$[ebp], -1
	jne	SHORT $LN11@fnMutexFin

; 8785 :       zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4
$LN11@fnMutexFin:

; 8786 : 
; 8787 :    return( lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
$LN1@fnMutexFin:

; 8788 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnMutexFind@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv94 = -12						; size = 4
tv93 = -8						; size = 4
_lpTask$ = -4						; size = 4
_cpcSessionId$ = 8					; size = 4
_FindWebSubtask@4 PROC

; 461  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 462  :    LPTASK lpTask;
; 463  : 
; 464  :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN4@FindWebSub

; 465  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@FindWebSub
$LN4@FindWebSub:

; 466  : 
; 467  :    // Make sure nobody else is creating/deleting a task.
; 468  :    fnStartBrowseOfTaskList( AnchorBlock->hFirstTask, FALSE );

	push	0
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	_fnStartBrowseOfTaskList@8

; 469  : 
; 470  :    lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN2@FindWebSub:

; 471  :    while ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN3@FindWebSub

; 472  :    {
; 473  :       if ( lpTask->bTransientTask && lpTask->bShutdown == FALSE &&

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN5@FindWebSub
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN5@FindWebSub
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	mov	ecx, DWORD PTR _cpcSessionId$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN11@FindWebSub
	mov	eax, DWORD PTR _cpcSessionId$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN12@FindWebSub
$LN11@FindWebSub:
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	mov	ecx, DWORD PTR _cpcSessionId$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN9@FindWebSub
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN10@FindWebSub
$LN9@FindWebSub:
	mov	DWORD PTR tv93[ebp], -1
$LN10@FindWebSub:
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR tv94[ebp], eax
$LN12@FindWebSub:
	cmp	DWORD PTR tv94[ebp], 0
	jne	SHORT $LN5@FindWebSub

; 474  :            zstrcmp( lpTask->szSessionId, cpcSessionId ) == 0 )
; 475  :       {
; 476  :          break;

	jmp	SHORT $LN3@FindWebSub
$LN5@FindWebSub:

; 477  :       }
; 478  : 
; 479  :       lpTask = zGETPTR( lpTask->hNextTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 480  :    }

	jmp	$LN2@FindWebSub
$LN3@FindWebSub:

; 481  : 
; 482  :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 483  : 
; 484  :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN6@FindWebSub

; 485  :       return( lpTask->vWebSubtask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [eax+28]
	jmp	SHORT $LN1@FindWebSub
	jmp	SHORT $LN1@FindWebSub
$LN6@FindWebSub:

; 486  :    else
; 487  :       return( 0 );

	xor	eax, eax
$LN1@FindWebSub:

; 488  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_FindWebSubtask@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_dw$1 = -108						; size = 4
_szMsg$2 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpMutex$ = 12						; size = 4
_lControl$ = 16						; size = 4
_fnMutexCreateOS@12 PROC

; 8898 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8899 :    lpMutex->Info.bCriticalSection = FALSE;

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	BYTE PTR [eax+93], 0

; 8900 : 
; 8901 :    lpMutex->Info.hMutexOS = (zLONG) CreateMutex( NULL, FALSE, lpMutex->szName );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [edx+94], eax

; 8902 :    if ( lpMutex->Info.hMutexOS == 0 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	cmp	DWORD PTR [eax+94], 0
	jne	SHORT $LN2@fnMutexCre

; 8903 :    {
; 8904 :       zCHAR szMsg[ 100 ];
; 8905 :       DWORD dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$1[ebp], eax

; 8906 :       zsprintf( szMsg, "Error creating mutex %s", lpMutex->szName );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET $SG100616
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8907 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8908 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnMutexCre
$LN2@fnMutexCre:

; 8909 :    }
; 8910 : 
; 8911 :    return( 0 );

	xor	eax, eax
$LN1@fnMutexCre:

; 8912 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnMutexCreateOS@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pOS_Record$1 = -120					; size = 4
_lProcessID$ = -116					; size = 4
_lpProcessList$2 = -112					; size = 4
_nProcessIdx$3 = -108					; size = 2
_szMsg$4 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpMutex$ = 12						; size = 4
_fnSysMutexDestroy@8 PROC

; 9141 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9142 :    zLONG lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 9143 : #ifdef TRACE_MUTEX
; 9144 :    TraceLine( "fnSysMutexDestroy Task: 0x%08x  Handle: %d  %s  Mutex ProcessID %d   ProcessID %d",
; 9145 :               zGETHNDL( lpTask ), lpMutex ? lpMutex->Info.hMutexOS : 0, lpMutex ? lpMutex->szName : "",
; 9146 :               lpMutex->lProcessID, lProcessID );
; 9147 : #endif
; 9148 : 
; 9149 : // if ( lpTask == 0 || lpMutex == 0 || lpMutex->Info.hMutexOS == 0 )
; 9150 : //    return( 0 );
; 9151 : 
; 9152 : 
; 9153 :    // If lpTask is zero, we are destroying a system mutex ... which does
; 9154 :    // not have a valid mutex handle, so skip this part of the destroy.
; 9155 :    if ( lpTask && lpMutex->lProcessID != lProcessID )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN5@fnSysMutex
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+89]
	cmp	ecx, DWORD PTR _lProcessID$[ebp]
	je	$LN5@fnSysMutex

; 9156 :    {
; 9157 :       // Send a message to the other process specified by
; 9158 :       // lpMutex->lProcessID to free the mutex.
; 9159 :       zSHORT nProcessIdx;
; 9160 :       LPANCHOROS_RECORD pOS_Record = &AnchorBlock->OS_Data;

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1503				; 000005dfH
	mov	DWORD PTR _pOS_Record$1[ebp], edx

; 9161 :       LPPROCESSLIST lpProcessList;
; 9162 : 
; 9163 :       // Find the process that created the mutex.
; 9164 :       for ( nProcessIdx = AnchorBlock->OS_Data.lProcessCount - 1;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1507]
	sub	ecx, 1
	mov	WORD PTR _nProcessIdx$3[ebp], cx
	jmp	SHORT $LN4@fnSysMutex
$LN2@fnSysMutex:

; 9166 :             nProcessIdx-- )

	mov	dx, WORD PTR _nProcessIdx$3[ebp]
	sub	dx, 1
	mov	WORD PTR _nProcessIdx$3[ebp], dx
$LN4@fnSysMutex:

; 9165 :             pOS_Record->ProcessList[ nProcessIdx ].lProcessID != lProcessID;

	movsx	eax, WORD PTR _nProcessIdx$3[ebp]
	imul	ecx, eax, 20
	mov	edx, DWORD PTR _pOS_Record$1[ebp]
	mov	eax, DWORD PTR [edx+ecx+24]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN3@fnSysMutex

; 9167 :       {
; 9168 :          // Nothing needs to be done here.
; 9169 :       }

	jmp	SHORT $LN2@fnSysMutex
$LN3@fnSysMutex:

; 9170 : 
; 9171 :       if ( nProcessIdx > 0 )

	movsx	ecx, WORD PTR _nProcessIdx$3[ebp]
	test	ecx, ecx
	jle	SHORT $LN6@fnSysMutex

; 9172 :       {
; 9173 :          lpProcessList = &pOS_Record->ProcessList[ nProcessIdx ];

	movsx	edx, WORD PTR _nProcessIdx$3[ebp]
	imul	eax, edx, 20
	mov	ecx, DWORD PTR _pOS_Record$1[ebp]
	lea	edx, DWORD PTR [ecx+eax+8]
	mov	DWORD PTR _lpProcessList$2[ebp], edx

; 9174 :          lpProcessList->nOE_Request  = TASKREQ_FREEMUTEX;

	mov	eax, 7
	mov	ecx, DWORD PTR _lpProcessList$2[ebp]
	mov	WORD PTR [ecx], ax

; 9175 :          lpProcessList->hMemHandle   = (zULONG) zGETHNDL( lpMutex );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpProcessList$2[ebp]
	mov	DWORD PTR [ecx+12], eax

; 9176 : 
; 9177 :          // Send the message.
; 9178 :          SendMessage( (HWND) lpProcessList->hWndAppOE_Msg,

	movsx	edx, WORD PTR _nProcessIdx$3[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpProcessList$2[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _lpProcessList$2[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN6@fnSysMutex:

; 9179 :                       lpProcessList->uAppOE_Msg, 0, nProcessIdx );
; 9180 :       }
; 9181 : 
; 9182 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSysMutex
$LN5@fnSysMutex:

; 9183 :    }
; 9184 : 
; 9185 :    if ( lpMutex->Info.hMutexOS )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	cmp	DWORD PTR [ecx+94], 0
	je	SHORT $LN7@fnSysMutex

; 9186 :    {
; 9187 :       // We don't need to do the following code since the "System Mutex" is
; 9188 :       // only used to track the lLockedTaskID.  The Info.hMutexOS should not
; 9189 :       // be set for the system mutexes.
; 9190 :    // if ( lpTask )
; 9191 :    // {
; 9192 :    //    LPMUTEX lpSysMutex = fnMutexFind( (LPTASK) -1, lpMutex->szName );
; 9193 :    //    if ( lpSysMutex && lpSysMutex->Info.hMutexOS == lpMutex->Info.hMutexOS )
; 9194 :    //       lpSysMutex->Info.hMutexOS = 0;
; 9195 :    // }
; 9196 : 
; 9197 :       if ( CloseHandle( (HANDLE) lpMutex->Info.hMutexOS ) == 0 )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $LN8@fnSysMutex

; 9198 :       {
; 9199 :          char szMsg[ 100 ];
; 9200 : 
; 9201 :          zsprintf( szMsg, "Error destroying mutex: %s", lpMutex->szName );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET $SG100727
	lea	edx, DWORD PTR _szMsg$4[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 9202 :          TraceLineS( szMsg, "" );

	push	OFFSET $SG100728
	lea	eax, DWORD PTR _szMsg$4[ebp]
	push	eax
	call	_TraceLineS@8

; 9203 :          fnSysMessageBox( lpTask, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 9204 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSysMutex
$LN8@fnSysMutex:

; 9205 :       }
; 9206 : 
; 9207 :       lpMutex->Info.hMutexOS = 0;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [ecx+94], 0
$LN7@fnSysMutex:

; 9208 :    }
; 9209 : 
; 9210 :    return( 0 );

	xor	eax, eax
$LN1@fnSysMutex:

; 9211 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnSysMutexDestroy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv71 = -8						; size = 4
_nRC$ = -4						; size = 2
_lpTask$ = 8						; size = 4
_lpMutex$ = 12						; size = 4
_ulTimeout$ = 16					; size = 4
_lControl$ = 20						; size = 4
_fnSysMutexLock@16 PROC

; 8950 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 8951 :    zSHORT nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 8952 : 
; 8953 : #ifdef TRACE_MUTEX
; 8954 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 8955 :    TraceLine( "fnSysMutexLock (WaitLock) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x",
; 8956 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 8957 :               lpMutex->szName, SysGetProcessID( 0 ) );
; 8958 : #endif
; 8959 :    if ( ulTimeout == 0 )

	cmp	DWORD PTR _ulTimeout$[ebp], 0
	jne	SHORT $LN4@fnSysMutex

; 8960 :       ulTimeout = INFINITE;

	mov	DWORD PTR _ulTimeout$[ebp], -1
$LN4@fnSysMutex:

; 8961 : 
; 8962 :    if ( WaitForSingleObject( (HANDLE) lpMutex->Info.hMutexOS,
; 8963 :                              ulTimeout ) == WAIT_FAILED )

	mov	ecx, DWORD PTR _ulTimeout$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	eax, -1
	jne	SHORT $LN5@fnSysMutex

; 8964 :    {
; 8965 :       switch ( GetLastError( ) )

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR tv71[ebp], eax
	cmp	DWORD PTR tv71[ebp], 128		; 00000080H
	je	SHORT $LN6@fnSysMutex
	cmp	DWORD PTR tv71[ebp], 258		; 00000102H
	je	SHORT $LN7@fnSysMutex
	jmp	SHORT $LN8@fnSysMutex
$LN6@fnSysMutex:

; 8966 :       {
; 8967 :          case WAIT_ABANDONED:
; 8968 :             // This means that another thread terminated without unlocking
; 8969 :             // its mutex.  We'll consider this OK.
; 8970 :             nRC = 1;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 8971 :             break;

	jmp	SHORT $LN5@fnSysMutex
$LN7@fnSysMutex:

; 8972 : 
; 8973 :          case WAIT_TIMEOUT:
; 8974 :             nRC = -1;

	or	edx, -1
	mov	WORD PTR _nRC$[ebp], dx

; 8975 :             break;

	jmp	SHORT $LN5@fnSysMutex
$LN8@fnSysMutex:

; 8976 : 
; 8977 :          default:
; 8978 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN5@fnSysMutex:

; 8979 :             break;
; 8980 :       }
; 8981 :    }
; 8982 : 
; 8983 : #ifdef TRACE_MUTEX
; 8984 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 8985 :    TraceLine( "fnSysMutexLock (Acquired) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x   RC: %d",
; 8986 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 8987 :               lpMutex->szName, SysGetProcessID( 0 ), nRC );
; 8988 : #endif
; 8989 : 
; 8990 :    if ( nRC == 1 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN9@fnSysMutex

; 8991 :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$LN9@fnSysMutex:

; 8992 : 
; 8993 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 8994 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysMutexLock@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szMsg$1 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpMutex$ = 12						; size = 4
_fnSysMutexUnlock@8 PROC

; 9061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9062 : #if 0
; 9063 :    if ( lpMutex->Info.bCriticalSection )
; 9064 :    {
; 9065 :       // If the current mutex is for a thread task, then lpParentMutex will
; 9066 :       // point to the mutex structure for the parent task.  We want to use
; 9067 :       // the parent mutex to leave the critical section.
; 9068 :       if ( lpMutex->Info.hParentMutex )
; 9069 :          lpMutex = zGETPTR( lpMutex->Info.hParentMutex );
; 9070 : 
; 9071 :       LeaveCriticalSection( (LPCRITICAL_SECTION) lpMutex->Info.CritSection );
; 9072 :    }
; 9073 :    else
; 9074 : #endif
; 9075 :    {
; 9076 :       if ( ReleaseMutex( (HANDLE) lpMutex->Info.hMutexOS ) == 0 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN2@fnSysMutex

; 9077 :       {
; 9078 :          zCHAR szMsg[ 100 ];
; 9079 : 
; 9080 :          zsprintf( szMsg, "Error releasing mutex %s", lpMutex->szName );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	add	edx, 6
	push	edx
	push	OFFSET $SG100682
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 9081 :          TraceLineS( szMsg, "" );

	push	OFFSET $SG100683
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	call	_TraceLineS@8

; 9082 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 9083 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSysMutex
$LN2@fnSysMutex:

; 9084 :       }
; 9085 :    }
; 9086 : 
; 9087 : #ifdef TRACE_MUTEX
; 9088 : // if ( zstrcmp( lpMutex->szName, "ZDrSS" ) != 0 )
; 9089 :    TraceLine( "fnSysMutexUnlock (Unlock) Task: 0x%08x   Mutex: 0x%08x  Handle: %d  %s  Process: 0x%08x",
; 9090 :               zGETHNDL( lpTask ), lpMutex, lpMutex->Info.hMutexOS,
; 9091 :               lpMutex->szName, SysGetProcessID( 0 ) );
; 9092 : #endif
; 9093 : 
; 9094 :    return( 0 );

	xor	eax, eax
$LN1@fnSysMutex:

; 9095 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnSysMutexUnlock@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lPageTableIndex$ = -4					; size = 4
_bWebTask$ = 8						; size = 1
_fnFreeLocalAnchorBlock@4 PROC

; 2337 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2338 :    zLONG lPageTableIndex;
; 2339 : 
; 2340 :    // If we're in Server Mode or a Web Task, then there's no anchor block
; 2341 :    // to free.
; 2342 :    if ( g_bServerMode || bWebTask )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	jne	SHORT $LN4@fnFreeLoca
	movzx	ecx, BYTE PTR _bWebTask$[ebp]
	test	ecx, ecx
	je	SHORT $LN2@fnFreeLoca
$LN4@fnFreeLoca:

; 2343 :    {
; 2344 :       SysFree( AnchorBlock );

	mov	edx, DWORD PTR _AnchorBlock
	push	edx
	call	_SysFree@4

; 2345 :       return;

	jmp	$LN1@fnFreeLoca

; 2346 :    }

	jmp	SHORT $LN3@fnFreeLoca
$LN2@fnFreeLoca:

; 2347 :    else
; 2348 :    {
; 2349 :       if ( g_bWin95 )

	movzx	eax, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $LN5@fnFreeLoca

; 2350 :          lPageTableIndex = 1;

	mov	DWORD PTR _lPageTableIndex$[ebp], 1
	jmp	SHORT $LN6@fnFreeLoca
$LN5@fnFreeLoca:

; 2351 :       else
; 2352 : #ifdef DEBUG_PAGETABLE
; 2353 :          lPageTableIndex = 128;

	mov	DWORD PTR _lPageTableIndex$[ebp], 128	; 00000080H
$LN6@fnFreeLoca:

; 2354 : #else
; 2355 :          lPageTableIndex = 1;
; 2356 : #endif
; 2357 : 
; 2358 : #ifdef SHARED_MEM_TRACE
; 2359 :       fnTraceSharedMemory( "Unmapping anchor block" );
; 2360 : #endif
; 2361 : 
; 2362 :       TraceLine( "fnFreeLocalAnchorBlock Page Table UNmapping at Index: %x   0x%08x   Process: 0x%08x",

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	push	edx
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	push	eax
	push	OFFSET $SG98595
	call	_TraceLine
	add	esp, 16					; 00000010H

; 2363 :                  lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2364 : 
; 2365 :       UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonPageTable[ecx*4]
	push	edx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2366 :       CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	ecx, DWORD PTR _g_FileMappingHandles[eax*4]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 2367 :       g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[edx*4], 0

; 2368 :       g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_FileMappingHandles[eax*4], 0
$LN3@fnFreeLoca:

; 2369 :    }
; 2370 : 
; 2371 :    g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2372 :    AnchorBlock    = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2373 :    g_lProcessIdx  = -1;

	mov	DWORD PTR _g_lProcessIdx, -1
$LN1@fnFreeLoca:

; 2374 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnFreeLocalAnchorBlock@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lOffset$ = -8						; size = 4
_pbBase$ = -4						; size = 4
_lpDataHeader$ = 8					; size = 4
_pPointer$ = 12						; size = 4
_fnSysCreateHandle@8 PROC

; 4179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4180 :    zPBYTE pbBase;
; 4181 :    zLONG  lOffset;
; 4182 : 
; 4183 :    // For Win95 apps we just return the pointer back.
; 4184 :    if ( g_bWin95 )

	movzx	eax, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $LN2@fnSysCreat

; 4185 :       return( pPointer );

	mov	eax, DWORD PTR _pPointer$[ebp]
	jmp	SHORT $LN1@fnSysCreat
$LN2@fnSysCreat:

; 4186 : 
; 4187 : #ifdef DEBUG_PAGETABLE
; 4188 :    // Make sure that the highest bit is NOT set (this means it's a handle).
; 4189 :    if ( ((zLONG) pPointer & 0x80000000) != 0 )

	mov	ecx, DWORD PTR _pPointer$[ebp]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN3@fnSysCreat

; 4190 :    {
; 4191 :    // char szMessage[ 16 ];
; 4192 :    // int k = 0;
; 4193 :       MessageBox( GetActiveWindow( ), "Invalid pointer: hi-bit not set!!",

	push	8208					; 00002010H
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	OFFSET $SG99034
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 4194 :                   szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );
; 4195 : #if 0
; 4196 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 4197 :       if ( szMessage[ 0 ] == 'Y' )
; 4198 :          k /= k;
; 4199 : #endif
; 4200 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSysCreat
$LN3@fnSysCreat:

; 4201 :    }
; 4202 : #endif
; 4203 : 
; 4204 :    // Get base address of dataspace.
; 4205 :    pbBase = zGETPTR( (zPVOID) lpDataHeader->hDataHandle );

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pbBase$[ebp], eax

; 4206 : 
; 4207 :    // Compute the offset of the pointer from the base address.
; 4208 :    lOffset = (zLONG) pPointer - (zLONG) pbBase;

	mov	edx, DWORD PTR _pPointer$[ebp]
	sub	edx, DWORD PTR _pbBase$[ebp]
	mov	DWORD PTR _lOffset$[ebp], edx

; 4209 : 
; 4210 :    // New handle consists of the handle of the dataspace (first byte of lHandle)
; 4211 :    // and the offset in the last three bytes.
; 4212 :    pPointer = (zPVOID) (lpDataHeader->hDataHandle | lOffset);

	mov	eax, DWORD PTR _lpDataHeader$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	or	ecx, DWORD PTR _lOffset$[ebp]
	mov	DWORD PTR _pPointer$[ebp], ecx

; 4213 :    return( pPointer );

	mov	eax, DWORD PTR _pPointer$[ebp]
$LN1@fnSysCreat:

; 4214 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnSysCreateHandle@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpProcessList$ = -276					; size = 4
_lpTgtProcess$ = -272					; size = 4
_k$ = -268						; size = 4
_lPageTableIndex$ = -264				; size = 4
_szMessage$1 = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_hMemory$ = 12						; size = 4
_fnFreeSharedMemory@8 PROC

; 3032 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3033 :    LPPROCESSLIST lpProcessList;
; 3034 :    LPPROCESSLIST lpTgtProcess;
; 3035 :    zLONG         lPageTableIndex;
; 3036 :    zLONG         k;
; 3037 : 
; 3038 :    if ( g_bServerMode )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $LN4@fnFreeShar

; 3039 :    {
; 3040 :       SysFree( (zPVOID) hMemory );

	mov	ecx, DWORD PTR _hMemory$[ebp]
	push	ecx
	call	_SysFree@4

; 3041 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnFreeShar
$LN4@fnFreeShar:

; 3042 :    }
; 3043 : 
; 3044 : #ifdef DEBUG_PAGETABLE
; 3045 :    // Make sure that the highest bit is set.
; 3046 :    if ( ((zLONG) hMemory & 0x80000000) == 0 )

	mov	edx, DWORD PTR _hMemory$[ebp]
	and	edx, -2147483648			; 80000000H
	jne	SHORT $LN5@fnFreeShar

; 3047 :    {
; 3048 :       char szMessage[ 256 ];
; 3049 :    // k = 0;
; 3050 :       zsprintf( szMessage, "Invalid pointer handle for free: hi-bit not set: 0x%08x", hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
	push	eax
	push	OFFSET $SG98791
	lea	ecx, DWORD PTR _szMessage$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3051 :       TraceLineS( szMessage, "" );

	push	OFFSET $SG98792
	lea	edx, DWORD PTR _szMessage$1[ebp]
	push	edx
	call	_TraceLineS@8

; 3052 :       SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	eax, DWORD PTR _szMessage$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 3053 : #if 0
; 3054 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 3055 :       if ( szMessage[ 0 ] == 'Y' )
; 3056 :          k /= k;
; 3057 : #endif
; 3058 :       return( hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
	jmp	$LN1@fnFreeShar
$LN5@fnFreeShar:

; 3059 :    }
; 3060 : #endif
; 3061 : 
; 3062 :    if ( g_bWin95 )

	movzx	edx, BYTE PTR _g_bWin95
	test	edx, edx
	je	SHORT $LN6@fnFreeShar

; 3063 :       lPageTableIndex = (zLONG) *((zPLONG) hMemory - 1);

	mov	eax, DWORD PTR _hMemory$[ebp]
	mov	ecx, DWORD PTR [eax-4]
	mov	DWORD PTR _lPageTableIndex$[ebp], ecx
	jmp	SHORT $LN7@fnFreeShar
$LN6@fnFreeShar:

; 3064 :    else
; 3065 :       lPageTableIndex = (zLONG) ((zULONG) hMemory >> 24);

	mov	edx, DWORD PTR _hMemory$[ebp]
	shr	edx, 24					; 00000018H
	mov	DWORD PTR _lPageTableIndex$[ebp], edx
$LN7@fnFreeShar:

; 3066 : 
; 3067 : // TraceLine( "fnFreeSharedMemory at Index: %x   0x%08x   Process: 0x%08x",
; 3068 : //            lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3069 : 
; 3070 :    // Make sure we have a valid task.  If not then we should be freeing the
; 3071 :    // anchor block so do it.
; 3072 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN8@fnFreeShar

; 3073 :    {
; 3074 : #if defined SHARED_MEM_TRACE
; 3075 :       fnTraceSharedMemory( "fnFreeSharedMemory" );
; 3076 : #endif
; 3077 : 
; 3078 :    // if ( lPageTableIndex == 134 )
; 3079 :    // {
; 3080 :    //    TraceLine( "fnFreeSharedMemory1 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 3081 :    //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3082 :    // }
; 3083 : 
; 3084 :       UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonPageTable[eax*4]
	push	ecx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 3085 :       CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	eax, DWORD PTR _g_FileMappingHandles[edx*4]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 3086 :       g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], 0

; 3087 :       g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_FileMappingHandles[edx*4], 0

; 3088 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnFreeShar
$LN8@fnFreeShar:

; 3089 :    }
; 3090 : 
; 3091 :    zLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysLockCoreMutex@4

; 3092 : 
; 3093 : #ifdef CHECK_MEMORY // check for memory references that will soon become invalid
; 3094 :    CheckMemory( lPageTableIndex );
; 3095 : #endif
; 3096 : 
; 3097 :    lpProcessList = &AnchorBlock->OS_Data.ProcessList[ g_lProcessIdx ];

	imul	eax, DWORD PTR _g_lProcessIdx, 20
	mov	ecx, DWORD PTR _AnchorBlock
	lea	edx, DWORD PTR [ecx+eax+1511]
	mov	DWORD PTR _lpProcessList$[ebp], edx

; 3098 :    lpProcessList->nOE_Request     = TASKREQ_FREE;  // tell OE to do free

	mov	eax, 4
	mov	ecx, DWORD PTR _lpProcessList$[ebp]
	mov	WORD PTR [ecx], ax

; 3099 :    lpProcessList->lPageTableIndex = lPageTableIndex;

	mov	edx, DWORD PTR _lpProcessList$[ebp]
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [edx+8], eax

; 3100 : 
; 3101 :    // Make sure nobody is currently deleting a task.
; 3102 :    fnStartBrowseOfTaskList( lpTask, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnStartBrowseOfTaskList@8

; 3103 : 
; 3104 :    // Use SysSendTaskMsg to send a message to all tasks to free the memory.
; 3105 :    // We do this in reverse order so as not to blow out the anchor block ???
; 3106 :    // before we're finished with it.                                     ???
; 3107 :    k = AnchorBlock->OS_Data.lProcessCount;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1507]
	mov	DWORD PTR _k$[ebp], eax
$LN2@fnFreeShar:

; 3108 : // TraceLineI( "fnFreeSharedMemory should SendMessage to process count: ", k );
; 3109 :    while ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN3@fnFreeShar

; 3110 :    {
; 3111 :       k--;

	mov	ecx, DWORD PTR _k$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx

; 3112 :       lpTgtProcess = &AnchorBlock->OS_Data.ProcessList[ k ];

	imul	edx, DWORD PTR _k$[ebp], 20
	mov	eax, DWORD PTR _AnchorBlock
	lea	ecx, DWORD PTR [eax+edx+1511]
	mov	DWORD PTR _lpTgtProcess$[ebp], ecx

; 3113 : 
; 3114 :       if ( lpTgtProcess->hWndAppOE_Msg &&

	mov	edx, DWORD PTR _lpTgtProcess$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN9@fnFreeShar
	mov	eax, DWORD PTR _lpTgtProcess$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	je	SHORT $LN9@fnFreeShar

; 3115 :            IsWindow( (HWND) lpTgtProcess->hWndAppOE_Msg ) )
; 3116 :       {
; 3117 :          SendMessage( (HWND) lpTgtProcess->hWndAppOE_Msg,

	mov	edx, DWORD PTR _g_lProcessIdx
	push	edx
	push	0
	mov	eax, DWORD PTR _lpTgtProcess$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _lpTgtProcess$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16
$LN9@fnFreeShar:

; 3118 :                       lpTgtProcess->uAppOE_Msg, 0, g_lProcessIdx );
; 3119 :       }
; 3120 :    // SysSendTaskMsg( lpCurrentTask, lpTask );
; 3121 :    }

	jmp	SHORT $LN2@fnFreeShar
$LN3@fnFreeShar:

; 3122 : 
; 3123 :    if ( hMemory != g_hAnchorBlock )

	mov	ecx, DWORD PTR _hMemory$[ebp]
	cmp	ecx, DWORD PTR _g_hAnchorBlock
	je	SHORT $LN10@fnFreeShar

; 3124 :    {
; 3125 :    // if ( lPageTableIndex == 134 )
; 3126 :    // {
; 3127 :    //    TraceLine( "fnFreeSharedMemory2 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 3128 :    //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3129 :    // }
; 3130 : 
; 3131 :       UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[edx*4]
	push	eax
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 3132 :       CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	edx, DWORD PTR _g_FileMappingHandles[ecx*4]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 3133 :       g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[eax*4], 0

; 3134 :       g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR _g_FileMappingHandles[ecx*4], 0
$LN10@fnFreeShar:

; 3135 : 
; 3136 :    // TraceLine( "fnFreeSharedMemory2 at Index: %x   0x%08x   Process: 0x%08x",
; 3137 :    //            lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 3138 :    }
; 3139 : 
; 3140 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 3141 : 
; 3142 :    zUNLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysUnlockCoreMutex@4

; 3143 : 
; 3144 :    return( 0 );

	xor	eax, eax
$LN1@fnFreeShar:

; 3145 : 
; 3146 : } // end of:  fnFreeSharedMemory.

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnFreeSharedMemory@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lRC$1 = -20						; size = 4
_hMemory$ = -16						; size = 4
_lPageTableIndex$ = -12					; size = 4
_k$2 = -8						; size = 4
_lpProcessList$3 = -4					; size = 4
_ppvMemory$ = 8						; size = 4
_lpTask$ = 12						; size = 4
_lBytes$ = 16						; size = 4
_cpcShareName$ = 20					; size = 4
_fnAllocSharedMemory@16 PROC

; 2844 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2845 :    HANDLE hMemory = 0;

	mov	DWORD PTR _hMemory$[ebp], 0

; 2846 :    zLONG  lPageTableIndex = 0;

	mov	DWORD PTR _lPageTableIndex$[ebp], 0

; 2847 : 
; 2848 :    *ppvMemory = 0;

	mov	eax, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [eax], 0

; 2849 : 
; 2850 :    // If more space is requested than is available, return error.
; 2851 :    if ( lBytes <= 0 )

	cmp	DWORD PTR _lBytes$[ebp], 0
	jg	SHORT $LN4@fnAllocSha

; 2852 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnAllocSha
$LN4@fnAllocSha:

; 2853 : 
; 2854 :    if ( g_bServerMode )

	movzx	ecx, BYTE PTR _g_bServerMode
	test	ecx, ecx
	je	SHORT $LN5@fnAllocSha

; 2855 :    {
; 2856 :       *ppvMemory = SysMalloc( lBytes );

	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	call	_SysMalloc@4
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax

; 2857 :       return (zLONG) *ppvMemory;

	mov	edx, DWORD PTR _ppvMemory$[ebp]
	mov	eax, DWORD PTR [edx]
	jmp	$LN1@fnAllocSha
$LN5@fnAllocSha:

; 2858 :    }
; 2859 : 
; 2860 : // TraceLine( "fnAllocSharedMemory1   Process: 0x%08x", SysGetProcessID( 0 ) );
; 2861 : 
; 2862 :    zLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysLockCoreMutex@4

; 2863 : 
; 2864 :    // If the memory is shared, then we must send a message to each
; 2865 :    // registered zeidon application.
; 2866 :    //
; 2867 :    // If AnchorBlock is zero then we haven't finished initialization yet so
; 2868 :    // there are no messages to send.
; 2869 : 
; 2870 :    if ( AnchorBlock && AnchorBlock->hMainTask )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN6@fnAllocSha
	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+106], 0
	je	$LN6@fnAllocSha

; 2871 :    {
; 2872 :       LPPROCESSLIST lpProcessList;
; 2873 :       zLONG     k;
; 2874 :       zLONG     lRC;
; 2875 : 
; 2876 :       // Create a new file mapping.
; 2877 :       *ppvMemory = fnMapFile( &hMemory, lBytes, &lPageTableIndex, 0 );

	push	0
	lea	ecx, DWORD PTR _lPageTableIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	lea	eax, DWORD PTR _hMemory$[ebp]
	push	eax
	call	_fnMapFile@16
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax

; 2878 :       if ( hMemory == 0 )

	cmp	DWORD PTR _hMemory$[ebp], 0
	jne	SHORT $LN8@fnAllocSha

; 2879 :       {
; 2880 :          zUNLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysUnlockCoreMutex@4

; 2881 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnAllocSha
$LN8@fnAllocSha:

; 2882 :       }
; 2883 : 
; 2884 :       fnSetProcessIdx( "AllocShared", &lpProcessList );

	lea	edx, DWORD PTR _lpProcessList$3[ebp]
	push	edx
	push	OFFSET $SG98740
	call	_fnSetProcessIdx
	add	esp, 8

; 2885 :       lpProcessList->nOE_Request     = TASKREQ_ALLOC; // tell OE to share Memory

	mov	eax, 1
	mov	ecx, DWORD PTR _lpProcessList$3[ebp]
	mov	WORD PTR [ecx], ax

; 2886 :       lpProcessList->lPageTableIndex = lPageTableIndex;

	mov	edx, DWORD PTR _lpProcessList$3[ebp]
	mov	eax, DWORD PTR _lPageTableIndex$[ebp]
	mov	DWORD PTR [edx+8], eax

; 2887 :       lpProcessList->hMemHandle      = (zLONG) g_FileMappingHandles[ lPageTableIndex ];

	mov	ecx, DWORD PTR _lpProcessList$3[ebp]
	mov	edx, DWORD PTR _lPageTableIndex$[ebp]
	mov	eax, DWORD PTR _g_FileMappingHandles[edx*4]
	mov	DWORD PTR [ecx+12], eax

; 2888 : 
; 2889 :       // Send each task a message to open the same file mapping.
; 2890 :       k = AnchorBlock->OS_Data.lProcessCount;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1507]
	mov	DWORD PTR _k$2[ebp], edx
$LN2@fnAllocSha:

; 2891 :    // TraceLine( "fnAllocSharedMemory should SendMessage from ProcessIndex: %d  to %d processes", g_lProcessIdx, k );
; 2892 :       while ( k > 0 )

	cmp	DWORD PTR _k$2[ebp], 0
	jle	$LN3@fnAllocSha

; 2893 :       {
; 2894 :          k--;

	mov	eax, DWORD PTR _k$2[ebp]
	sub	eax, 1
	mov	DWORD PTR _k$2[ebp], eax

; 2895 :          lpProcessList = &AnchorBlock->OS_Data.ProcessList[ k ];

	imul	ecx, DWORD PTR _k$2[ebp], 20
	mov	edx, DWORD PTR _AnchorBlock
	lea	eax, DWORD PTR [edx+ecx+1511]
	mov	DWORD PTR _lpProcessList$3[ebp], eax

; 2896 :       // TraceLine( "fnAllocSharedMemory SendMessage ALLOC %x Wnd: 0x%08x  Handle: 0x%08x  ProcessIdx: %d  Process: %d",
; 2897 :       //            lPageTableIndex, lpProcessList->hWndAppOE_Msg, lpProcessList->hMemHandle, k, lpProcessList->lProcessID );
; 2898 : 
; 2899 :          if ( k == g_lProcessIdx )

	mov	ecx, DWORD PTR _k$2[ebp]
	cmp	ecx, DWORD PTR _g_lProcessIdx
	jne	SHORT $LN9@fnAllocSha

; 2900 :             continue;  // don't bother sending a message to ourselves

	jmp	SHORT $LN2@fnAllocSha
$LN9@fnAllocSha:

; 2901 : 
; 2902 :          if ( IsWindow( (HWND) lpProcessList->hWndAppOE_Msg ) == 0 )

	mov	edx, DWORD PTR _lpProcessList$3[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	jne	SHORT $LN10@fnAllocSha

; 2903 :             continue;

	jmp	SHORT $LN2@fnAllocSha
$LN10@fnAllocSha:

; 2904 : 
; 2905 :          lRC = SendMessage( (HWND) lpProcessList->hWndAppOE_Msg,

	mov	ecx, DWORD PTR _g_lProcessIdx
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpProcessList$3[ebp]
	movzx	eax, WORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _lpProcessList$3[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16
	mov	DWORD PTR _lRC$1[ebp], eax

; 2906 :                             lpProcessList->uAppOE_Msg, 0, g_lProcessIdx );
; 2907 :       // TraceLine( "fnAllocSharedMemory SendMessage ****** %s ****** Wnd: 0x%08x  ProcessIdx: %d",
; 2908 :       //            lRC ? "Failure" : "Success" , lpProcessList->hWndAppOE_Msg, g_lProcessIdx );
; 2909 :          if ( lRC )

	cmp	DWORD PTR _lRC$1[ebp], 0
	je	SHORT $LN11@fnAllocSha

; 2910 :          {
; 2911 :             MessageBox( GetActiveWindow( ), "Error Calling SendMsg( )",

	push	8208					; 00002010H
	push	OFFSET $SG98744
	push	OFFSET $SG98745
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
$LN11@fnAllocSha:

; 2912 :                         "Zeidon Internal Error",
; 2913 :                         MB_ICONSTOP | MB_OK | MB_TASKMODAL );
; 2914 :          }
; 2915 :       }

	jmp	$LN2@fnAllocSha
$LN3@fnAllocSha:

; 2916 :    }

	jmp	SHORT $LN7@fnAllocSha
$LN6@fnAllocSha:

; 2917 :    else
; 2918 :    {
; 2919 :       // Create a new file mapping.
; 2920 :       *ppvMemory = fnMapFile( &hMemory, lBytes, &lPageTableIndex, cpcShareName );

	mov	eax, DWORD PTR _cpcShareName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lPageTableIndex$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	lea	eax, DWORD PTR _hMemory$[ebp]
	push	eax
	call	_fnMapFile@16
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@fnAllocSha:

; 2921 :    }
; 2922 : 
; 2923 :    zUNLOCK_MUTEX( zMUTEX_SHAREDMEM );

	push	4
	call	_fnSysUnlockCoreMutex@4

; 2924 : 
; 2925 : #ifdef SHARED_MEM_TRACE
; 2926 :    TraceLine( "fnAllocSharedMemory (Task: 0x%08x) at Index: %x   0x%08x   Process: 0x%08x",
; 2927 :               zGETHNDL( lpTask ), lPageTableIndex,
; 2928 :               g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2929 : #endif
; 2930 : 
; 2931 :    return( (zLONG) hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
$LN1@fnAllocSha:

; 2932 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnAllocSharedMemory@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpInternational$ = 8					; size = 4
_SysFreeInternational@4 PROC

; 1232 : {

	push	ebp
	mov	ebp, esp

; 1233 :    if ( lpInternational &&

	cmp	DWORD PTR _lpInternational$[ebp], 0
	je	SHORT $LN1@SysFreeInt
	mov	eax, DWORD PTR _lpInternational$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10042				; 0000273aH
	jne	SHORT $LN1@SysFreeInt

; 1234 :         lpInternational->nTableID == iInternational )
; 1235 :    {
; 1236 :       fnFreeDataspace( zGETPTR( lpInternational->hShortDate ) );

	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	eax, DWORD PTR [edx+98]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1237 :       fnFreeDataspace( zGETPTR( lpInternational->hLongDate ) );

	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	edx, DWORD PTR [ecx+102]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1238 :       fnFreeDataspace( zGETPTR( lpInternational->hTimeFmt ) );

	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1239 :       fnFreeDataspace( lpInternational );

	mov	edx, DWORD PTR _lpInternational$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$LN1@SysFreeInt:

; 1240 :    }
; 1241 : }

	pop	ebp
	ret	4
_SysFreeInternational@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hInternational$ = -524					; size = 4
_lpInternational$ = -520				; size = 4
_sz$ = -516						; size = 512
__$ArrayPad$ = -4					; size = 4
_SysCreateInternational@0 PROC

; 1643 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1644 :    LPINTERNATIONAL   lpInternational;
; 1645 :    zPVOID            hInternational;
; 1646 :    zCHAR             sz[ 512 ];
; 1647 : 
; 1648 :    hInternational =

	push	10042					; 0000273aH
	push	0
	push	1
	push	140					; 0000008cH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+114]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hInternational$[ebp], eax

; 1649 :       fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,
; 1650 :                         sizeof( InternationalRecord ), 1, 0, iInternational );
; 1651 :    if ( hInternational == 0 )

	cmp	DWORD PTR _hInternational$[ebp], 0
	jne	SHORT $LN2@SysCreateI

; 1652 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SysCreateI
$LN2@SysCreateI:

; 1653 : 
; 1654 :    lpInternational = zGETPTR( hInternational );

	mov	edx, DWORD PTR _hInternational$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$[ebp], eax

; 1655 : 
; 1656 :    // Get country code, default to US
; 1657 :    lpInternational->nCountry = GetProfileInt( szlINTL, szlICOUNTRY, 1 );

	push	1
	mov	eax, DWORD PTR _szlICOUNTRY
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+2], ax

; 1658 : 
; 1659 :    // Selected country name, no default
; 1660 :    GetProfileString( szlINTL, szlSCOUNTRY, szNullS, sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _szNullS
	push	ecx
	mov	edx, DWORD PTR _szlSCOUNTRY
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1661 : 
; 1662 :    zstrcpy( lpInternational->szCountry, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 4
	push	edx
	call	_strcpy
	add	esp, 8

; 1663 : 
; 1664 :    // Get selected language code, default U.S. English
; 1665 :    GetProfileString( szlINTL, szlSLANGUAGE, "ENU", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET $SG98362
	mov	ecx, DWORD PTR _szlSLANGUAGE
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1666 : 
; 1667 :    zstrcpy( lpInternational->szLanguage, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	add	ecx, 37					; 00000025H
	push	ecx
	call	_strcpy
	add	esp, 8

; 1668 : 
; 1669 :    // DGC: ????????????????? OS/2 ?????????? DKS 2/21/96 ?????????
; 1670 :    // Hard code the language code from the language string.
; 1671 :    // 0 - No default defined.
; 1672 :    if ( zstrcmpi( sz, "ENU" ) == 0 )

	push	OFFSET $SG98365
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@SysCreateI

; 1673 :       lpInternational->nLanguage = 1;

	mov	eax, 1
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+70], ax
	jmp	$LN4@SysCreateI
$LN3@SysCreateI:

; 1674 :    else
; 1675 :    if ( zstrcmpi( sz, "DEU" ) == 0 )

	push	OFFSET $SG98368
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN5@SysCreateI

; 1676 :       lpInternational->nLanguage = 49;

	mov	eax, 49					; 00000031H
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+70], ax
	jmp	$LN4@SysCreateI
$LN5@SysCreateI:

; 1677 :    else
; 1678 :    if ( zstrcmpi( sz, "FRC" ) == 0 )

	push	OFFSET $SG98371
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@SysCreateI

; 1679 :       lpInternational->nLanguage = 2;

	mov	eax, 2
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+70], ax
	jmp	SHORT $LN4@SysCreateI
$LN7@SysCreateI:

; 1680 :    else
; 1681 :    if ( zstrcmpi( sz, "POR" ) == 0 ) // Portuguese 351

	push	OFFSET $SG98374
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN9@SysCreateI

; 1682 :       lpInternational->nLanguage = 351;

	mov	eax, 351				; 0000015fH
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+70], ax
	jmp	SHORT $LN4@SysCreateI
$LN9@SysCreateI:

; 1683 :    else
; 1684 :    if ( zstrcmpi( sz, "SPA" ) == 0 ) // Spanish 34

	push	OFFSET $SG98377
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN11@SysCreateI

; 1685 :       lpInternational->nLanguage = 34;

	mov	eax, 34					; 00000022H
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+70], ax
	jmp	SHORT $LN4@SysCreateI
$LN11@SysCreateI:

; 1686 :    else
; 1687 :       lpInternational->nLanguage = 1; // lpInternational->nLanguage = 0;

	mov	edx, 1
	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [eax+70], dx
$LN4@SysCreateI:

; 1688 : 
; 1689 :    // List separator, default comma
; 1690 :    GetProfileString( szlINTL, szlSLIST, ",", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET $SG98378
	mov	edx, DWORD PTR _szlSLIST
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1691 : 
; 1692 :    zstrcpy( lpInternational->szList, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 72					; 00000048H
	push	edx
	call	_strcpy
	add	esp, 8

; 1693 : 
; 1694 :    // Measurement system, default English
; 1695 :    // Time format, default 12 hour
; 1696 :    // Time Separator, default ":"
; 1697 :    lpInternational->nMeasure = GetProfileInt( szlINTL, szlIMEASURE, 1 );

	push	1
	mov	eax, DWORD PTR _szlIMEASURE
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+77], ax

; 1698 :    lpInternational->nTime = GetProfileInt( szlINTL, szlITIME, 0 );

	push	0
	mov	eax, DWORD PTR _szlITIME
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+79], ax

; 1699 :    GetProfileString( szlINTL, szlSTIME, ":", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET $SG98379
	mov	ecx, DWORD PTR _szlSTIME
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1700 : 
; 1701 :    zstrcpy( lpInternational->szTime, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	add	ecx, 81					; 00000051H
	push	ecx
	call	_strcpy
	add	esp, 8

; 1702 : 
; 1703 :    // Trailing string for AM, default "AM"
; 1704 :    GetProfileString( szlINTL, szlS1159, "AM", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET $SG98380
	mov	eax, DWORD PTR _szlS1159
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1705 : 
; 1706 :    zstrcpy( lpInternational->sz1159, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInternational$[ebp]
	add	eax, 86					; 00000056H
	push	eax
	call	_strcpy
	add	esp, 8

; 1707 : 
; 1708 :    // Trailing string for PM, default "PM"
; 1709 :    GetProfileString( szlINTL, szlS2359, "PM", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET $SG98381
	mov	edx, DWORD PTR _szlS2359
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1710 : 
; 1711 :    zstrcpy( lpInternational->sz2359, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 91					; 0000005bH
	push	edx
	call	_strcpy
	add	esp, 8

; 1712 : 
; 1713 :    // Time leading zeros for hours, default yes
; 1714 :    // Picture for short date, default "mm/dd/yy"
; 1715 :    lpInternational->nTLZero = GetProfileInt( szlINTL, szlITLZERO, 1 );

	push	1
	mov	eax, DWORD PTR _szlITLZERO
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+96], ax

; 1716 :    GetProfileString( szlINTL, szlSSHORTDATE, "mm/dd/yy",

	push	511					; 000001ffH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET $SG98382
	mov	ecx, DWORD PTR _szlSSHORTDATE
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1717 :                      sz, sizeof( sz ) - 1 );
; 1718 : 
; 1719 :    fnConvertToZeidonFormat( sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_fnConvertToZeidonFormat
	add	esp, 4

; 1720 :    lpInternational->hShortDate =

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	DWORD PTR [ecx+98], eax

; 1721 :       fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader, sz );
; 1722 : 
; 1723 :    // Picture for long date, default "mmm dd, yyyy"
; 1724 :    GetProfileString( szlINTL, szlSLONGDATE, "mmm dd, yyyy",

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET $SG98383
	mov	eax, DWORD PTR _szlSLONGDATE
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1725 :                      sz, sizeof( sz ) - 1 );
; 1726 : 
; 1727 :    fnConvertToZeidonFormat( sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_fnConvertToZeidonFormat
	add	esp, 4

; 1728 :    lpInternational->hLongDate =

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	DWORD PTR [ecx+102], eax

; 1729 :       fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader, sz );
; 1730 : 
; 1731 :    // Currency symbol, default "$"
; 1732 :    GetProfileString( szlINTL, szlSCURRENCY, "$", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET $SG98384
	mov	eax, DWORD PTR _szlSCURRENCY
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1733 : 
; 1734 :    zstrcpy( lpInternational->szCurrency, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInternational$[ebp]
	add	eax, 110				; 0000006eH
	push	eax
	call	_strcpy
	add	esp, 8

; 1735 : 
; 1736 :    // Current code format, default 0
; 1737 :    //
; 1738 :    // 0 - Currency symbol prefix with no separation ( $1 )
; 1739 :    // 1 - Currency symbol suffix with no separation ( 1$ )
; 1740 :    // 2 - Currency symbol prefix with one character separation ( $ 1 )
; 1741 :    // 3 - Currency symbol suffix with one character separation ( 1 $ )
; 1742 :    //
; 1743 : 
; 1744 :    // Number of digits used for the fractional part of a currency amount,
; 1745 :    // default 2.
; 1746 : 
; 1747 :    // Negative currency format code default 0
; 1748 :    //
; 1749 :    // 0  ($1)
; 1750 :    // 1  -$1
; 1751 :    // 2  $-1
; 1752 :    // 3  $1-
; 1753 :    // 4  (1$)
; 1754 :    // 5  -1$
; 1755 :    // 6  1-$
; 1756 :    // 7  1$-
; 1757 :    // 8  -1 $
; 1758 :    // 9  -$ 1
; 1759 :    // 10 $ 1-
; 1760 :    //
; 1761 : 
; 1762 :    // Symbol used to separate thousands in numbers with more than 3 digits,
; 1763 :    // default ","
; 1764 :    lpInternational->nCurrency = GetProfileInt( szlINTL, szlICURRENCY, 0 );

	push	0
	mov	ecx, DWORD PTR _szlICURRENCY
	push	ecx
	mov	edx, DWORD PTR _szlINTL
	push	edx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+120], ax

; 1765 :    lpInternational->nCurrDigits = GetProfileInt( szlINTL, szlICURRDIGITS, 2 );

	push	2
	mov	edx, DWORD PTR _szlICURRDIGITS
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+122], ax

; 1766 :    lpInternational->nNegCurr = GetProfileInt( szlINTL, szlINEGCURR, 0 );

	push	0
	mov	edx, DWORD PTR _szlINEGCURR
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [ecx+124], ax

; 1767 :    GetProfileString( szlINTL, szlSTHOUSAND, ",", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET $SG98385
	mov	eax, DWORD PTR _szlSTHOUSAND
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileStringA@20

; 1768 : 
; 1769 :    zstrcpy( lpInternational->szThousand, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInternational$[ebp]
	add	eax, 126				; 0000007eH
	push	eax
	call	_strcpy
	add	esp, 8

; 1770 : 
; 1771 :    // Symbol used to separate the integer part from the fractional part
; 1772 :    // of a number, default "."
; 1773 :    GetProfileString( szlINTL, szlSDECIMAL, ".", sz, sizeof( sz ) - 1 );

	push	511					; 000001ffH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET $SG98386
	mov	edx, DWORD PTR _szlSDECIMAL
	push	edx
	mov	eax, DWORD PTR _szlINTL
	push	eax
	call	DWORD PTR __imp__GetProfileStringA@20

; 1774 : 
; 1775 :    zstrcpy( lpInternational->szDecimal, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 131				; 00000083H
	push	edx
	call	_strcpy
	add	esp, 8

; 1776 : 
; 1777 :    // Value defining the number of decimal digits that should be used in a
; 1778 :    // number, default 2
; 1779 : 
; 1780 :    // Value specifying whether a decimal value less than 1.0 (and greater
; 1781 :    // than -1.0) should contain a leading zero, as follows:
; 1782 :    //
; 1783 :    //  0    Do not use a leading zero (.7)
; 1784 :    //  1    Use a leading zero (0.7)
; 1785 :    //
; 1786 :    // Default is 1.
; 1787 :    lpInternational->nDigits = GetProfileInt( szlINTL, szlIDIGITS, 2 );

	push	2
	mov	eax, DWORD PTR _szlIDIGITS
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+136], ax

; 1788 :    lpInternational->nLZero = GetProfileInt( szlINTL, szlILZERO, 1 );

	push	1
	mov	eax, DWORD PTR _szlILZERO
	push	eax
	mov	ecx, DWORD PTR _szlINTL
	push	ecx
	call	DWORD PTR __imp__GetProfileIntA@12
	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	WORD PTR [edx+138], ax

; 1789 : 
; 1790 :    // construct zeidon intl time format from the other indicators
; 1791 :    if ( lpInternational->nTLZero )

	mov	eax, DWORD PTR _lpInternational$[ebp]
	movsx	ecx, WORD PTR [eax+96]
	test	ecx, ecx
	je	SHORT $LN13@SysCreateI

; 1792 :       zstrcpy( sz, "HH" );

	push	OFFSET $SG98389
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN14@SysCreateI
$LN13@SysCreateI:

; 1793 :    else
; 1794 :       zstrcpy( sz, "H" );

	push	OFFSET $SG98390
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN14@SysCreateI:

; 1795 : 
; 1796 :    zstrcat( sz, "\"" );

	push	OFFSET $SG98391
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1797 :    zstrcat( sz, lpInternational->szTime );

	mov	edx, DWORD PTR _lpInternational$[ebp]
	add	edx, 81					; 00000051H
	push	edx
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1798 :    zstrcat( sz, "\"" );

	push	OFFSET $SG98392
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1799 :    zstrcat( sz, "MI" );

	push	OFFSET $SG98393
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1800 :    if ( lpInternational->nTime == 0 )

	mov	eax, DWORD PTR _lpInternational$[ebp]
	movsx	ecx, WORD PTR [eax+79]
	test	ecx, ecx
	jne	SHORT $LN15@SysCreateI

; 1801 :       zstrcat( sz, " AM" );

	push	OFFSET $SG98395
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN15@SysCreateI:

; 1802 : 
; 1803 :    lpInternational->hTimeFmt =

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	DWORD PTR [ecx+106], eax

; 1804 :       fnStoreStringInDataspace( AnchorBlock->hMainFirstDataHeader, sz );
; 1805 : 
; 1806 :    return( hInternational );

	mov	eax, DWORD PTR _hInternational$[ebp]
$LN1@SysCreateI:

; 1807 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SysCreateInternational@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_SfListTasks PROC

; 7793 : {

	push	ebp
	mov	ebp, esp

; 7794 :    PostMessage( (HWND) AnchorBlock->lOE_hMainWnd,

	push	10000					; 00002710H
	push	112					; 00000070H
	push	273					; 00000111H
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	DWORD PTR __imp__PostMessageA@16

; 7795 :                 WM_COMMAND, (WPARAM) IDM_LISTTASKS, (LPARAM) 10000L );
; 7796 : }

	pop	ebp
	ret	0
_SfListTasks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_Startup$1 = -3184					; size = 68
_PInfo$2 = -3116					; size = 16
_l$3 = -3100						; size = 4
_ulBytes$4 = -3096					; size = 4
_hServicesStarted$5 = -3092				; size = 4
$T6 = -3088						; size = 4
$T7 = -3084						; size = 4
_hFile$8 = -3080					; size = 4
_pchOS_Name$ = -3076					; size = 4
tv252 = -3072						; size = 4
_k$9 = -3068						; size = 4
_pchPtr$10 = -3064					; size = 4
_szLine$11 = -3060					; size = 1000
_szTemp$ = -2060					; size = 513
_szMessage$12 = -1544					; size = 256
_szMessage$13 = -1288					; size = 256
_szMessage$14 = -1032					; size = 256
_szMessage$15 = -776					; size = 256
_szProgramName$ = -520					; size = 513
__$ArrayPad$ = -4					; size = 4
_lAppOE_Msg$ = 8					; size = 4
_hWndAppOE$ = 12					; size = 4
_SysStartObjectServices PROC

; 3719 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3184				; 00000c70H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3720 :    char szProgramName[ zMAX_FILESPEC_LTH + 1 ];  // prevent overflow in
; 3721 :    char szTemp[ zMAX_FILESPEC_LTH + 1 ];         // fnConvertEnvironnentString
; 3722 :    zPCHAR pchOS_Name;
; 3723 : 
; 3724 :    // Validate that environment variable ZEIDON set
; 3725 :    SysGetEnvVar( szProgramName, szlZEIDON, sizeof( szProgramName ) - 1 );

	push	512					; 00000200H
	mov	eax, DWORD PTR _szlZEIDON
	push	eax
	lea	ecx, DWORD PTR _szProgramName$[ebp]
	push	ecx
	call	_SysGetEnvVar@12

; 3726 :    if ( szProgramName[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szProgramName$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN8@SysStartOb

; 3727 :    {
; 3728 :       char szMessage[ 256 ];
; 3729 : 
; 3730 :       // {2,"KZOEE002 - ZEIDON environment variable not set"},
; 3731 :       SysGetBaseMessage( szMessage, KZOEE002, 255 );

	push	255					; 000000ffH
	push	2
	lea	edx, DWORD PTR _szMessage$13[ebp]
	push	edx
	call	_SysGetBaseMessage@12

; 3732 :       SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	eax, DWORD PTR _szMessage$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 3733 :       return( -1 );

	or	eax, -1
	jmp	$LN24@SysStartOb
$LN8@SysStartOb:

; 3734 :    }
; 3735 : 
; 3736 :    // Let's see if the anchor block is already initialized.  If it is then
; 3737 :    // some other process has created shared memory and named it.  Look for it.
; 3738 :    if ( g_hAnchorBlock == 0 && fnGetAnchorBlock( lAppOE_Msg, hWndAppOE ) == -1 )

	cmp	DWORD PTR _g_hAnchorBlock, 0
	jne	SHORT $LN9@SysStartOb
	mov	edx, DWORD PTR _hWndAppOE$[ebp]
	push	edx
	mov	eax, DWORD PTR _lAppOE_Msg$[ebp]
	push	eax
	call	_fnGetAnchorBlock@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $LN9@SysStartOb

; 3739 :       return( -1 );

	or	eax, -1
	jmp	$LN24@SysStartOb
$LN9@SysStartOb:

; 3740 : 
; 3741 :    // Build qualified program name.
; 3742 :    // The ZEIDON environment variable must point to a directory
; 3743 :    // containing the ZEIDON.APP file.  From there we retrieve the
; 3744 :    // name of the Zeidon executable directory.
; 3745 :    if ( AnchorBlock == 0 && g_bServerMode == FALSE )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	$LN10@SysStartOb
	movzx	edx, BYTE PTR _g_bServerMode
	test	edx, edx
	jne	$LN10@SysStartOb

; 3746 :    {
; 3747 :       zLONG               hFile;
; 3748 :       zCHAR               szLine[ 1000 ];
; 3749 :       zPCHAR              pchPtr;
; 3750 :       int                 k;
; 3751 :       HANDLE              hServicesStarted;
; 3752 :       STARTUPINFO         Startup;
; 3753 :       PROCESS_INFORMATION PInfo;
; 3754 : 
; 3755 :       // See if we can open the zeidon applications file.
; 3756 :       SysAppendcDirSep( szProgramName );

	lea	eax, DWORD PTR _szProgramName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 3757 :       zstrcat( szProgramName, szlAppFile );

	mov	ecx, DWORD PTR _szlAppFile
	push	ecx
	lea	edx, DWORD PTR _szProgramName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3758 : 
; 3759 :       hFile = (zLONG) CreateFile( szProgramName, GENERIC_READ,

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	eax, DWORD PTR _szProgramName$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$8[ebp], eax

; 3760 :                                   FILE_SHARE_READ, 0,
; 3761 :                                   OPEN_EXISTING,
; 3762 :                                   FILE_ATTRIBUTE_NORMAL, 0 );
; 3763 : 
; 3764 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$8[ebp], -1
	jne	SHORT $LN12@SysStartOb

; 3765 :       {
; 3766 :          char szMessage[ 256 ];
; 3767 : 
; 3768 :          // {9,"KZOEE009 - Error opening application definition file"},
; 3769 :          SysGetBaseMessage( szMessage, KZOEE009, 255 );

	push	255					; 000000ffH
	push	9
	lea	ecx, DWORD PTR _szMessage$15[ebp]
	push	ecx
	call	_SysGetBaseMessage@12

; 3770 :          zstrcat( szMessage, " '" );

	push	OFFSET $SG98948
	lea	edx, DWORD PTR _szMessage$15[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3771 :          zstrcat( szMessage, szProgramName );

	lea	eax, DWORD PTR _szProgramName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMessage$15[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3772 :          zstrcat( szMessage, "'" );

	push	OFFSET $SG98949
	lea	edx, DWORD PTR _szMessage$15[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3773 :       // SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );  causes bomb if called
; 3774 :          fnSysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	eax, DWORD PTR _szMessage$15[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_fnSysMessageBox@16

; 3775 : 
; 3776 :          return( -1 );

	or	eax, -1
	jmp	$LN24@SysStartOb
$LN12@SysStartOb:

; 3777 :       }
; 3778 : 
; 3779 :       // Read the first 1000 bytes of the file.  We are going to assume that
; 3780 :       // the specification of the zeidon bin dir is in that first 1000 chars.
; 3781 :       {
; 3782 :          ULONG ulBytes;
; 3783 : 
; 3784 :          ReadFile( (HANDLE) hFile, szLine, sizeof( szLine ), &ulBytes, 0 );

	push	0
	lea	edx, DWORD PTR _ulBytes$4[ebp]
	push	edx
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _szLine$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$8[ebp]
	push	ecx
	call	DWORD PTR __imp__ReadFile@20

; 3785 :          CloseHandle( (HANDLE) hFile );

	mov	edx, DWORD PTR _hFile$8[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 3786 :       }
; 3787 : 
; 3788 :       szLine[ sizeof( szLine ) - 1 ] = 0;    // ensure buffer is terminated

	mov	eax, 1
	imul	ecx, eax, 999
	mov	DWORD PTR $T7[ebp], ecx
	cmp	DWORD PTR $T7[ebp], 1000		; 000003e8H
	jae	SHORT $LN25@SysStartOb
	jmp	SHORT $LN26@SysStartOb
$LN25@SysStartOb:
	call	___report_rangecheckfailure
$LN26@SysStartOb:
	mov	edx, DWORD PTR $T7[ebp]
	mov	BYTE PTR _szLine$11[ebp+edx], 0

; 3789 :       pchPtr = zstrstr( szLine, szlZEIDON_BIN );

	mov	eax, DWORD PTR _szlZEIDON_BIN
	push	eax
	lea	ecx, DWORD PTR _szLine$11[ebp]
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	mov	DWORD PTR _pchPtr$10[ebp], eax

; 3790 :       if ( !pchPtr )

	cmp	DWORD PTR _pchPtr$10[ebp], 0
	jne	SHORT $LN13@SysStartOb

; 3791 :       {
; 3792 :          fnSysMessageBox( 0, szlOE_SystemError,

	push	-1
	push	OFFSET $SG98951
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_fnSysMessageBox@16

; 3793 :                           "Couldn't find ZEIDON_BIN specification.", -1 );
; 3794 :          return( -1 );

	or	eax, -1
	jmp	$LN24@SysStartOb
$LN13@SysStartOb:

; 3795 :       }
; 3796 : 
; 3797 :       // We found the zeidon bin specification.  Now bump up pchPtr to point
; 3798 :       // to the first non-blank char after zeidon bin.
; 3799 :       pchPtr += strlen( szlZEIDON_BIN );

	mov	eax, DWORD PTR _szlZEIDON_BIN
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchPtr$10[ebp]
	mov	DWORD PTR _pchPtr$10[ebp], eax
$LN2@SysStartOb:

; 3800 :       while ( *pchPtr == ' ' )

	mov	ecx, DWORD PTR _pchPtr$10[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN3@SysStartOb

; 3801 :          pchPtr++;

	mov	eax, DWORD PTR _pchPtr$10[ebp]
	add	eax, 1
	mov	DWORD PTR _pchPtr$10[ebp], eax
	jmp	SHORT $LN2@SysStartOb
$LN3@SysStartOb:

; 3802 : 
; 3803 :       // Copy directory to szProgramName up to the line terminator.
; 3804 :       k = 0;

	mov	DWORD PTR _k$9[ebp], 0
$LN4@SysStartOb:

; 3805 :       while ( *pchPtr >= ' ' )

	mov	ecx, DWORD PTR _pchPtr$10[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN5@SysStartOb

; 3806 :          szTemp[ k++ ] = *pchPtr++;

	mov	eax, DWORD PTR _k$9[ebp]
	mov	ecx, DWORD PTR _pchPtr$10[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _szTemp$[ebp+eax], dl
	mov	eax, DWORD PTR _k$9[ebp]
	add	eax, 1
	mov	DWORD PTR _k$9[ebp], eax
	mov	ecx, DWORD PTR _pchPtr$10[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchPtr$10[ebp], ecx
	jmp	SHORT $LN4@SysStartOb
$LN5@SysStartOb:

; 3807 : 
; 3808 :       szTemp[ k ] = 0;

	mov	edx, DWORD PTR _k$9[ebp]
	mov	DWORD PTR $T6[ebp], edx
	cmp	DWORD PTR $T6[ebp], 513			; 00000201H
	jae	SHORT $LN27@SysStartOb
	jmp	SHORT $LN28@SysStartOb
$LN27@SysStartOb:
	call	___report_rangecheckfailure
$LN28@SysStartOb:
	mov	eax, DWORD PTR $T6[ebp]
	mov	BYTE PTR _szTemp$[ebp+eax], 0

; 3809 : 
; 3810 :       // Convert name using environment vars.
; 3811 :       fnConvertEnvironmentString( szProgramName, szTemp );

	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szProgramName$[ebp]
	push	edx
	call	_fnConvertEnvironmentString@8

; 3812 : 
; 3813 :       // Create a Win32 event so we'll know when OE is up.
; 3814 :       hServicesStarted = CreateEvent( NULL, TRUE, FALSE,

	push	OFFSET $SG98952
	push	0
	push	1
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	DWORD PTR _hServicesStarted$5[ebp], eax

; 3815 :                                       "Zeidon - Object Services Init" );
; 3816 : 
; 3817 :       // Start Object Services program asynchronously
; 3818 :       SysAppendcDirSep( szProgramName );

	lea	eax, DWORD PTR _szProgramName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 3819 :       zstrcat( szProgramName, szObjectEngineName );

	mov	ecx, DWORD PTR _szObjectEngineName
	push	ecx
	lea	edx, DWORD PTR _szProgramName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3820 : 
; 3821 :       zmemset( &PInfo, 0, sizeof( PInfo ) );

	push	16					; 00000010H
	push	0
	lea	eax, DWORD PTR _PInfo$2[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 3822 :       zmemset( &Startup, 0, sizeof( Startup ) );

	push	68					; 00000044H
	push	0
	lea	ecx, DWORD PTR _Startup$1[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 3823 :       Startup.cb          = sizeof( Startup );

	mov	DWORD PTR _Startup$1[ebp], 68		; 00000044H

; 3824 :       Startup.dwFlags     = STARTF_USESHOWWINDOW;

	mov	DWORD PTR _Startup$1[ebp+44], 1

; 3825 :       Startup.wShowWindow = SW_MINIMIZE;

	mov	edx, 6
	mov	WORD PTR _Startup$1[ebp+48], dx

; 3826 :       if ( CreateProcess( szProgramName, 0, 0, 0, 0, 0, 0,
; 3827 :                           0, &Startup, &PInfo ) == 0 )

	lea	eax, DWORD PTR _PInfo$2[ebp]
	push	eax
	lea	ecx, DWORD PTR _Startup$1[ebp]
	push	ecx
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	lea	edx, DWORD PTR _szProgramName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateProcessA@40
	test	eax, eax
	jne	SHORT $LN14@SysStartOb

; 3828 :       {
; 3829 :          char  szMessage[ 256 ];
; 3830 :          DWORD l = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _l$3[ebp], eax

; 3831 : 
; 3832 :          // {3,"KZOEE003 - Error starting Object Services"},
; 3833 :          SysGetBaseMessage( szMessage, KZOEE003, 255 );

	push	255					; 000000ffH
	push	3
	lea	eax, DWORD PTR _szMessage$14[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 3834 :          zstrcat( szMessage, " - " );

	push	OFFSET $SG98954
	lea	ecx, DWORD PTR _szMessage$14[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 3835 :          zstrcat( szMessage, szProgramName );

	lea	edx, DWORD PTR _szProgramName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMessage$14[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 3836 :          fnSysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMessage$14[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_fnSysMessageBox@16

; 3837 :          return( -1 );

	or	eax, -1
	jmp	$LN24@SysStartOb
$LN14@SysStartOb:

; 3838 :       }
; 3839 : 
; 3840 :       // Wait for the services to start.
; 3841 :       WaitForSingleObject( hServicesStarted, INFINITE );

	push	-1
	mov	eax, DWORD PTR _hServicesStarted$5[ebp]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8

; 3842 :       CloseHandle( hServicesStarted );

	mov	ecx, DWORD PTR _hServicesStarted$5[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 3843 :       if ( fnGetAnchorBlock( lAppOE_Msg, hWndAppOE ) == -1 )

	mov	edx, DWORD PTR _hWndAppOE$[ebp]
	push	edx
	mov	eax, DWORD PTR _lAppOE_Msg$[ebp]
	push	eax
	call	_fnGetAnchorBlock@8
	movsx	ecx, ax
	cmp	ecx, -1
	jne	SHORT $LN15@SysStartOb

; 3844 :          return( -1 );

	or	eax, -1
	jmp	$LN24@SysStartOb
$LN15@SysStartOb:

; 3845 :    }

	jmp	$LN11@SysStartOb
$LN10@SysStartOb:

; 3846 :    else
; 3847 :    if ( AnchorBlock == 0 && g_bServerMode )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN16@SysStartOb
	movzx	edx, BYTE PTR _g_bServerMode
	test	edx, edx
	je	SHORT $LN16@SysStartOb

; 3848 :    {
; 3849 :       AnchorBlock = InitializeAnchorBlock( (zLONG) g_hInstance,

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _g_hInstance
	push	eax
	call	_InitializeAnchorBlock@16
	mov	DWORD PTR _AnchorBlock, eax

; 3850 :                                            (zLONG) 0,
; 3851 :                                            (zLONG) 0,
; 3852 :                                            (zLONG) 0 );
; 3853 :    }

	jmp	$LN11@SysStartOb
$LN16@SysStartOb:

; 3854 :    else
; 3855 :    {
; 3856 :       // If AnchorBlock is corrupt, free it and issue a bad RC
; 3857 :       if ( AnchorBlock->nStatus  == AnchorCorrupt ||
; 3858 :            AnchorBlock->nTableID != iAnchor ||

	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, WORD PTR [ecx+84]
	cmp	edx, 20					; 00000014H
	je	SHORT $LN19@SysStartOb
	mov	eax, DWORD PTR _AnchorBlock
	movsx	ecx, WORD PTR [eax+82]
	cmp	ecx, 10001				; 00002711H
	jne	SHORT $LN19@SysStartOb
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__IsWindow@4
	test	eax, eax
	jne	SHORT $LN11@SysStartOb
$LN19@SysStartOb:

; 3859 :            !IsWindow( (HWND) AnchorBlock->lOE_hMainWnd ) )
; 3860 :       {
; 3861 :          char szMessage[ 256 ];
; 3862 : 
; 3863 :          // {7,"KZOEE007 - Internal Anchor block error, system restart recommended"},
; 3864 :          SysGetBaseMessage( szMessage, KZOEE007, 255 );

	push	255					; 000000ffH
	push	7
	lea	ecx, DWORD PTR _szMessage$12[ebp]
	push	ecx
	call	_SysGetBaseMessage@12

; 3865 :          fnSysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	edx, DWORD PTR _szMessage$12[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_fnSysMessageBox@16

; 3866 : 
; 3867 :          fnFreeSharedMemory( 0, g_hAnchorBlock );

	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	push	0
	call	_fnFreeSharedMemory@8

; 3868 :          g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 3869 :          AnchorBlock  = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 3870 :          g_lProcessIdx = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 3871 :          return( -1 );

	or	eax, -1
	jmp	SHORT $LN24@SysStartOb
$LN11@SysStartOb:

; 3872 :       }
; 3873 :    }
; 3874 : 
; 3875 :    switch ( SysGetOS_Info( 0 ) )

	push	0
	call	_SysGetOS_Info@4
	mov	DWORD PTR tv252[ebp], eax
	mov	edx, DWORD PTR tv252[ebp]
	sub	edx, 1
	mov	DWORD PTR tv252[ebp], edx
	cmp	DWORD PTR tv252[ebp], 3
	ja	SHORT $LN6@SysStartOb
	mov	eax, DWORD PTR tv252[ebp]
	jmp	DWORD PTR $LN29@SysStartOb[eax*4]
$LN20@SysStartOb:

; 3876 :    {
; 3877 :       case zOS_WINDOWS:
; 3878 :          pchOS_Name = "MS Windows 3.x";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET $SG98961

; 3879 :          break;

	jmp	SHORT $LN6@SysStartOb
$LN21@SysStartOb:

; 3880 : 
; 3881 :       case zOS_WINDOWS95:
; 3882 :          pchOS_Name = "MS Windows 95/98";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET $SG98963

; 3883 :          break;

	jmp	SHORT $LN6@SysStartOb
$LN22@SysStartOb:

; 3884 : 
; 3885 :       case zOS_WINDOWSNT:
; 3886 :          pchOS_Name = "MS Windows NT/XP";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET $SG98965

; 3887 :          break;

	jmp	SHORT $LN6@SysStartOb
$LN23@SysStartOb:

; 3888 : 
; 3889 :       case zOS_OS2:
; 3890 :          pchOS_Name = "IBM OS/2";

	mov	DWORD PTR _pchOS_Name$[ebp], OFFSET $SG98967
$LN6@SysStartOb:

; 3891 :          break;
; 3892 :    }
; 3893 : 
; 3894 :    // If we get here, we must have been successful.
; 3895 :    TraceLineS( "(sy) SysStartObjectServices started for ", pchOS_Name );

	mov	ecx, DWORD PTR _pchOS_Name$[ebp]
	push	ecx
	push	OFFSET $SG98968
	call	_TraceLineS@8

; 3896 :    return( 0 );

	xor	eax, eax
$LN24@SysStartOb:

; 3897 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN29@SysStartOb:
	DD	$LN20@SysStartOb
	DD	$LN21@SysStartOb
	DD	$LN22@SysStartOb
	DD	$LN23@SysStartOb
_SysStartObjectServices ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_nLth$ = -8						; size = 2
_k$ = -4						; size = 2
_pchReturnString$ = 8					; size = 4
_lID$ = 12						; size = 4
_nMaxLth$ = 16						; size = 2
_SysGetOperationMessage@12 PROC

; 6432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6433 :    zSHORT k;
; 6434 :    zSHORT nLth;
; 6435 : 
; 6436 :    for ( k = 0;

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@SysGetOper
$LN2@SysGetOper:

; 6438 :             OperationMsgTable[ k ].nID != 9999;
; 6439 :          k++ )

	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@SysGetOper:

; 6437 :          OperationMsgTable[ k ].nID != lID &&

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	movsx	ecx, WORD PTR _OperationMsgTable[eax]
	cmp	ecx, DWORD PTR _lID$[ebp]
	je	SHORT $LN3@SysGetOper
	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	movsx	ecx, WORD PTR _OperationMsgTable[eax]
	cmp	ecx, 9999				; 0000270fH
	je	SHORT $LN3@SysGetOper

; 6440 :    {
; 6441 :    }

	jmp	SHORT $LN2@SysGetOper
$LN3@SysGetOper:

; 6442 : 
; 6443 :    nLth = zstrlen( OperationMsgTable[ k ].szMsg );

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _OperationMsgTable[eax+2]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 6444 : 
; 6445 :    if ( OperationMsgTable[ k ].nID == lID )

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	movsx	ecx, WORD PTR _OperationMsgTable[eax]
	cmp	ecx, DWORD PTR _lID$[ebp]
	jne	SHORT $LN5@SysGetOper

; 6446 :    {
; 6447 :       if ( nLth > nMaxLth )

	movsx	edx, WORD PTR _nLth$[ebp]
	movsx	eax, WORD PTR _nMaxLth$[ebp]
	cmp	edx, eax
	jle	SHORT $LN7@SysGetOper

; 6448 :          nLth = nMaxLth;

	mov	cx, WORD PTR _nMaxLth$[ebp]
	mov	WORD PTR _nLth$[ebp], cx
$LN7@SysGetOper:

; 6449 : 
; 6450 :       zstrncpy( pchReturnString, OperationMsgTable[ k ].szMsg, nLth );

	movsx	edx, WORD PTR _nLth$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _OperationMsgTable[ecx+2]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6451 :       pchReturnString[ nLth ] = 0;

	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6452 :       return( nLth );

	mov	ax, WORD PTR _nLth$[ebp]
	jmp	SHORT $LN1@SysGetOper

; 6453 :    }

	jmp	SHORT $LN1@SysGetOper
$LN5@SysGetOper:

; 6454 :    else
; 6455 :    {
; 6456 :       pchReturnString[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6457 :       return( 0 );

	xor	eax, eax
$LN1@SysGetOper:

; 6458 :    }
; 6459 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetOperationMessage@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_nLth$ = -8						; size = 2
_k$ = -4						; size = 2
_pchReturnString$ = 8					; size = 4
_lID$ = 12						; size = 4
_nMaxLth$ = 16						; size = 2
_SysGetBaseMessage@12 PROC

; 6387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6388 :    zSHORT k;
; 6389 :    zSHORT nLth;
; 6390 : 
; 6391 :    for ( k = 0;

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@SysGetBase
$LN2@SysGetBase:

; 6393 :          k++ )

	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@SysGetBase:

; 6392 :          BaseMsgTable[ k ].nID != lID && BaseMsgTable[ k ].nID != 9999;

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	movsx	ecx, WORD PTR _BaseMsgTable[eax]
	cmp	ecx, DWORD PTR _lID$[ebp]
	je	SHORT $LN3@SysGetBase
	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	movsx	ecx, WORD PTR _BaseMsgTable[eax]
	cmp	ecx, 9999				; 0000270fH
	je	SHORT $LN3@SysGetBase

; 6394 :    {
; 6395 :    }

	jmp	SHORT $LN2@SysGetBase
$LN3@SysGetBase:

; 6396 : 
; 6397 :    nLth = zstrlen( BaseMsgTable[ k ].szMsg );

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	mov	ecx, DWORD PTR _BaseMsgTable[eax+2]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 6398 : 
; 6399 :    if ( BaseMsgTable[ k ].nID == lID )

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 6
	movsx	ecx, WORD PTR _BaseMsgTable[eax]
	cmp	ecx, DWORD PTR _lID$[ebp]
	jne	SHORT $LN5@SysGetBase

; 6400 :    {
; 6401 :       if ( nLth > nMaxLth )

	movsx	edx, WORD PTR _nLth$[ebp]
	movsx	eax, WORD PTR _nMaxLth$[ebp]
	cmp	edx, eax
	jle	SHORT $LN7@SysGetBase

; 6402 :          nLth = nMaxLth;

	mov	cx, WORD PTR _nMaxLth$[ebp]
	mov	WORD PTR _nLth$[ebp], cx
$LN7@SysGetBase:

; 6403 : 
; 6404 :       zstrncpy( pchReturnString, BaseMsgTable[ k ].szMsg, nLth );

	movsx	edx, WORD PTR _nLth$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 6
	mov	edx, DWORD PTR _BaseMsgTable[ecx+2]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6405 :       pchReturnString[ nLth ] = 0;

	movsx	ecx, WORD PTR _nLth$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6406 :       return( nLth );

	mov	ax, WORD PTR _nLth$[ebp]
	jmp	SHORT $LN1@SysGetBase

; 6407 :    }

	jmp	SHORT $LN1@SysGetBase
$LN5@SysGetBase:

; 6408 :    else
; 6409 :    {
; 6410 :       pchReturnString[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6411 :       return( 0 );

	xor	eax, eax
$LN1@SysGetBase:

; 6412 :    }
; 6413 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetBaseMessage@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv66 = -4						; size = 4
_lFlag$ = 8						; size = 4
_SysGetAnchorBlockData@4 PROC

; 3673 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3674 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN4@SysGetAnch

; 3675 :    {
; 3676 :       switch ( lFlag & 0x0FFFFFFF )

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 268435455				; 0fffffffH
	mov	DWORD PTR tv66[ebp], eax
	mov	ecx, DWORD PTR tv66[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv66[ebp], ecx
	cmp	DWORD PTR tv66[ebp], 3
	ja	SHORT $LN4@SysGetAnch
	mov	edx, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN14@SysGetAnch[edx*4]
$LN5@SysGetAnch:

; 3677 :       {
; 3678 :          case 1:
; 3679 :             if ( lFlag & 0x80000000 )

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, -2147483648			; 80000000H
	je	SHORT $LN6@SysGetAnch

; 3680 :                return( zGETPTR( AnchorBlock->hSystemApp ) );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $LN1@SysGetAnch
	jmp	SHORT $LN8@SysGetAnch
$LN6@SysGetAnch:

; 3681 :             else
; 3682 :                return( AnchorBlock->hSystemApp );

	mov	eax, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [eax+110]
	jmp	SHORT $LN1@SysGetAnch
$LN8@SysGetAnch:

; 3683 : 
; 3684 :          case 2:
; 3685 :             if ( lFlag & 0x80000000 )

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, -2147483648			; 80000000H
	je	SHORT $LN9@SysGetAnch

; 3686 :                return( zGETPTR( AnchorBlock->hMainTask ) );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	jmp	SHORT $LN1@SysGetAnch
	jmp	SHORT $LN11@SysGetAnch
$LN9@SysGetAnch:

; 3687 :             else
; 3688 :                return( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [ecx+106]
	jmp	SHORT $LN1@SysGetAnch
$LN11@SysGetAnch:

; 3689 : 
; 3690 :          case 3:
; 3691 :             return( (zPVOID) AnchorBlock->lOE_hMainWnd );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+94]
	jmp	SHORT $LN1@SysGetAnch
$LN12@SysGetAnch:

; 3692 : 
; 3693 :          case 4:
; 3694 :             return( (zPVOID) AnchorBlock->lOE_hListWnd );

	mov	eax, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [eax+98]
	jmp	SHORT $LN1@SysGetAnch
$LN4@SysGetAnch:

; 3695 :       }
; 3696 :    }
; 3697 : 
; 3698 :    return( 0 );

	xor	eax, eax
$LN1@SysGetAnch:

; 3699 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN14@SysGetAnch:
	DD	$LN5@SysGetAnch
	DD	$LN8@SysGetAnch
	DD	$LN11@SysGetAnch
	DD	$LN12@SysGetAnch
_SysGetAnchorBlockData@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_SysGetAnchorBlock@0 PROC

; 3653 : {

	push	ebp
	mov	ebp, esp

; 3654 :    return( AnchorBlock );

	mov	eax, DWORD PTR _AnchorBlock

; 3655 : }

	pop	ebp
	ret	0
_SysGetAnchorBlock@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_FreeAnchorBlock@4 PROC

; 2392 : {

	push	ebp
	mov	ebp, esp

; 2393 :    // free Probe Area
; 2394 :    if ( g_pProbeArea )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $LN2@FreeAnchor

; 2395 :       SysFree( g_pProbeArea );

	mov	eax, DWORD PTR _g_pProbeArea
	push	eax
	call	_SysFree@4
$LN2@FreeAnchor:

; 2396 : 
; 2397 : // TraceLineX( "FreeAnchorBlock AnchorBlock ", g_hAnchorBlock );
; 2398 :    // if AnchorBlock not initialized, return zCALL_ERROR.
; 2399 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN3@FreeAnchor

; 2400 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@FreeAnchor
$LN3@FreeAnchor:

; 2401 : 
; 2402 :    // If the caller is not the main task, return zCALL_ERROR.
; 2403 :    if ( lpTask == 0 ||

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN5@FreeAnchor
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [edx+106]
	je	SHORT $LN4@FreeAnchor
$LN5@FreeAnchor:

; 2404 :         zGETHNDL( lpTask ) != AnchorBlock->hMainTask )
; 2405 :    {
; 2406 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@FreeAnchor
$LN4@FreeAnchor:

; 2407 :    }
; 2408 : 
; 2409 :    // Delete the main Task.
; 2410 :    if ( lpTask->bOE_TaskShutdown == FALSE )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 15					; 0000000fH
	and	ecx, 1
	jne	SHORT $LN6@FreeAnchor

; 2411 :       DeleteTask( lpTask );  // dks 2006.09.18 error while cleaning up client OE

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_DeleteTask@4
$LN6@FreeAnchor:

; 2412 : 
; 2413 :    // Current process has performed RegisterZeidonApp( ) so ...
; 2414 :    g_bProcessRegistered = FALSE;

	mov	BYTE PTR _g_bProcessRegistered, 0

; 2415 : // g_lpCurrentTask = 0;
; 2416 : 
; 2417 :    // Free the shared segment for KZOENGWA
; 2418 :    AnchorBlock->nStatus = AnchorCorrupt;     // mark AnchorBlock as no good

	mov	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+84], ax

; 2419 :    if ( g_bServerMode )

	movzx	edx, BYTE PTR _g_bServerMode
	test	edx, edx
	je	SHORT $LN7@FreeAnchor

; 2420 :    {
; 2421 :       SysFree( AnchorBlock );

	mov	eax, DWORD PTR _AnchorBlock
	push	eax
	call	_SysFree@4
$LN7@FreeAnchor:

; 2422 :    }
; 2423 : // else
; 2424 : //    fnFreeSharedMemory( lpTask, g_hAnchorBlock ); // free for KZOENGAA.DLL
; 2425 : 
; 2426 :    // NULL AnchorBlock handle and pointer
; 2427 :    g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2428 :    AnchorBlock = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2429 :    g_lProcessIdx = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 2430 : 
; 2431 :    return( 0 );

	xor	eax, eax
$LN1@FreeAnchor:

; 2432 : 
; 2433 : }   // End of FreeAnchorBlock

	pop	ebp
	ret	4
_FreeAnchorBlock@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpFirstSubtask$1 = -2144				; size = 4
_lpApp$2 = -2140					; size = 4
_lSize$ = -2136						; size = 4
_nEOF$3 = -2132						; size = 4
_pvFile$ = -2128					; size = 4
tv316 = -2124						; size = 4
tv315 = -2120						; size = 4
tv297 = -2116						; size = 4
tv296 = -2112						; size = 4
tv278 = -2108						; size = 4
tv277 = -2104						; size = 4
tv259 = -2100						; size = 4
tv258 = -2096						; size = 4
_lpProcessList$4 = -2092				; size = 4
_cd$5 = -2088						; size = 12
_hFile$6 = -2076					; size = 4
_lTaskAllocSize$ = -2072				; size = 4
_pchLine$7 = -2068					; size = 4
_lpMainTask$ = -2064					; size = 4
_szFileName$8 = -2060					; size = 257
_szTaskTitle$ = -1800					; size = 256
_szMessage$9 = -1544					; size = 256
_sz$10 = -1288						; size = 257
_szSize$ = -1028					; size = 256
_szMessage$11 = -772					; size = 256
_szMessage$12 = -516					; size = 256
_szZeidonEnv$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_OE_AnchorBlock$ = 8					; size = 4
_lOE_hMainWnd$ = 12					; size = 4
_lOE_hListWnd$ = 16					; size = 4
_lOE_Msg$ = 20						; size = 4
_InitializeAnchorBlock@16 PROC

; 2014 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2144				; 00000860H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2015 :    zPVOID pvFile;
; 2016 :    char   szTaskTitle[ 256 ];
; 2017 :    char   szZeidonEnv[ 256 ];
; 2018 :    char   szSize[ 256 ];
; 2019 :    LPTASK lpMainTask;
; 2020 :    zLONG  lTaskAllocSize = zSHARED_ALLOC;

	mov	DWORD PTR _lTaskAllocSize$[ebp], 4000000 ; 003d0900H

; 2021 :    zLONG  lSize = 16384;

	mov	DWORD PTR _lSize$[ebp], 16384		; 00004000H

; 2022 : 
; 2023 :    zmemset( szZeidonEnv, 0, sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	push	0
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2024 : 
; 2025 :    // Validate that environment variable ZEIDON set, NOTE: This
; 2026 :    // is done both here and in SysStartObjectServices on purpose
; 2027 :    // because ObjectServices can be started either alone or by
; 2028 :    // a client's RegisterZeidonApplication call.
; 2029 : 
; 2030 :    // Validate that environment variable ZEIDON set, NOTE: This
; 2031 :    // is done both here and in SysStartObjectServices on purpose
; 2032 :    // because ObjectServices can be started either alone or by
; 2033 :    // a client's RegisterZeidonApplication call.
; 2034 :    SysGetEnvVar( szZeidonEnv, szlZEIDON, sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	mov	ecx, DWORD PTR _szlZEIDON
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_SysGetEnvVar@12

; 2035 :    if ( szZeidonEnv[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szZeidonEnv$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN4@Initialize

; 2036 :    {
; 2037 :       char szMessage[ 256 ];
; 2038 : 
; 2039 :       // {2,"KZOEE002 - ZEIDON environment variable not set"},
; 2040 :       SysGetBaseMessage( szMessage, KZOEE002, sizeof( szMessage ) );

	push	256					; 00000100H
	push	2
	lea	eax, DWORD PTR _szMessage$9[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 2041 :       SysMessageBox( 0, szlOE_SystemError, szMessage, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMessage$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 2042 : 
; 2043 :       return( (LPANCHOR) zCALL_ERROR );   // Error initializing anchor

	mov	eax, -16				; fffffff0H
	jmp	$LN1@Initialize
$LN4@Initialize:

; 2044 :    }
; 2045 : 
; 2046 :    {
; 2047 :       zCHAR szFileName[ zMAX_FILENAME_LTH + 1 ];
; 2048 : 
; 2049 :       fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	eax, DWORD PTR _szFileName$8[ebp]
	push	eax
	call	_fnBuildZeidonIni
	add	esp, 8

; 2050 :       lTaskAllocSize = GetPrivateProfileInt( "Zeidon", "AllocSize",

	lea	ecx, DWORD PTR _szFileName$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _lTaskAllocSize$[ebp]
	push	edx
	push	OFFSET $SG98547
	push	OFFSET $SG98548
	call	DWORD PTR __imp__GetPrivateProfileIntA@16
	mov	DWORD PTR _lTaskAllocSize$[ebp], eax

; 2051 :                                              lTaskAllocSize, szFileName );
; 2052 : 
; 2053 :       // Make sure size is at leask 64K
; 2054 :       if ( lTaskAllocSize < 64000 )

	cmp	DWORD PTR _lTaskAllocSize$[ebp], 64000	; 0000fa00H
	jge	SHORT $LN5@Initialize

; 2055 :          lTaskAllocSize = zSHARED_ALLOC; // 4000000L or old one 262000L

	mov	DWORD PTR _lTaskAllocSize$[ebp], 4000000 ; 003d0900H
$LN5@Initialize:

; 2056 :    }
; 2057 : 
; 2058 :    // Edit the zeidon environment and make sure it ends with a
; 2059 :    // directory separator.
; 2060 :    SysAppendcDirSep( szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2061 : 
; 2062 :    zLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysLockCoreMutex@4

; 2063 : 
; 2064 :    // Allocate the main shared table space for the Anchor Block
; 2065 : #ifdef ALLOC_FREE_TRACE
; 2066 :    lSize += 3 * ALLOC_FREE_TRACE * sizeof( zPVOID );
; 2067 : #endif
; 2068 : 
; 2069 :    g_hAnchorBlock = fnInitializeDataspace( 0, (zCOREMEM) &AnchorBlock,

	mov	ecx, DWORD PTR _szlShareSeg
	push	ecx
	mov	edx, DWORD PTR _lSize$[ebp]
	sub	edx, 64					; 00000040H
	push	edx
	push	OFFSET $SG98550
	push	10001					; 00002711H
	push	OFFSET _AnchorBlock
	push	0
	call	_fnInitializeDataspace
	add	esp, 24					; 00000018H
	mov	DWORD PTR _g_hAnchorBlock, eax

; 2070 :                                            iAnchor, "OE Anchor",
; 2071 :                                            lSize - sizeof( DataHeaderRecord ),
; 2072 :                                            szlShareSeg );
; 2073 : 
; 2074 : // TraceLineX( "Initialize AnchorBlock = ", (zLONG) AnchorBlock );
; 2075 : 
; 2076 :    // Reserve space for Anchor Block Information which occurs after the
; 2077 :    // Table Header and the Freespace record in the first Dataspace
; 2078 :    // suballocation.
; 2079 : // if ( g_bServerMode == FALSE )
; 2080 :    {
; 2081 :       fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,

	push	10001					; 00002711H
	push	0
	push	1
	push	2449					; 00000991H
	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H

; 2082 :                         sizeof( AnchorRecord ) - (sizeof( DataHeaderRecord ) +
; 2083 :                                   sizeof( FreespaceRecord )),
; 2084 :                         1, 0, iAnchor );
; 2085 :    }
; 2086 : 
; 2087 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN6@Initialize

; 2088 :    {
; 2089 :       zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2090 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@Initialize
$LN6@Initialize:

; 2091 :    }
; 2092 : 
; 2093 :    AnchorBlock->nStatus          = AnchorUninitialized;  // Init is pending

	xor	ecx, ecx
	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+84], cx

; 2094 : // AnchorBlock->lMainTaskID      = 0; // SysGetTaskID( );
; 2095 : 
; 2096 : #ifdef ALLOC_FREE_TRACE
; 2097 :    AnchorBlock->bTraceMem = (zBOOL) SysSendOE_Message( IDM_GETMEMORYTRACE, 0 );
; 2098 : #endif
; 2099 : 
; 2100 :    AnchorBlock->lTaskAllocSize   = lTaskAllocSize - sizeof( DataHeaderRecord );

	mov	eax, DWORD PTR _lTaskAllocSize$[ebp]
	sub	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+86], eax

; 2101 :    AnchorBlock->lHab             = OE_AnchorBlock;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _OE_AnchorBlock$[ebp]
	mov	DWORD PTR [edx+90], eax

; 2102 :    AnchorBlock->lOE_hMainWnd     = lOE_hMainWnd;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _lOE_hMainWnd$[ebp]
	mov	DWORD PTR [ecx+94], edx

; 2103 :    AnchorBlock->lOE_hListWnd     = lOE_hListWnd;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _lOE_hListWnd$[ebp]
	mov	DWORD PTR [eax+98], ecx

; 2104 :    AnchorBlock->lOE_Msg          = lOE_Msg;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lOE_Msg$[ebp]
	mov	DWORD PTR [edx+102], eax

; 2105 :    AnchorBlock->hFirstTask       = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+130], 0

; 2106 :    AnchorBlock->hMainTask        = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+106], 0

; 2107 :    AnchorBlock->hSystemApp       = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+110], 0

; 2108 :    AnchorBlock->hMainFirstDataHeader = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+114], 0

; 2109 :    AnchorBlock->hFirstApp        = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+126], 0

; 2110 :    AnchorBlock->hFirstTask       = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+130], 0

; 2111 : // AnchorBlock->hFirstOpenFile   = 0; moved to Task
; 2112 : // AnchorBlock->hFirstProcLib    = 0; moved to Task
; 2113 :    zstrcpy( AnchorBlock->szZeidonLocal, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 138				; 0000008aH
	push	edx
	call	_strcpy
	add	esp, 8

; 2114 :    AnchorBlock->szZeidonBin[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+ecx+395], 0

; 2115 :    AnchorBlock->szZeidonSys[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+ecx+652], 0

; 2116 :    AnchorBlock->szZeidonLoc[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+ecx+909], 0

; 2117 :    AnchorBlock->szZeidonShr[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+ecx+1166], 0

; 2118 :    AnchorBlock->szUserID[ 0 ]    = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+ecx+1423], 0

; 2119 :    AnchorBlock->szPassword[ 0 ]  = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	mov	BYTE PTR [edx+ecx+1456], 0

; 2120 :    AnchorBlock->hFirstViewName   = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+1489], 0

; 2121 :    AnchorBlock->nBrowseTaskListCounter = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+1493], cx

; 2122 :    AnchorBlock->bShowTaskID      = FALSE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2123 :    AnchorBlock->bTraceCnt        = TRUE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	or	ecx, 2
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2124 :    AnchorBlock->bDropEngineIfNoTasks = FALSE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, -5					; fffffffbH
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2125 :    AnchorBlock->bDeleteTaskInProgress = FALSE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2126 :    AnchorBlock->lpParentTask     = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+2511], 0

; 2127 :    AnchorBlock->hInternational   = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+2515], 0

; 2128 :    AnchorBlock->hFirstSysMutex   = 0;

	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+2519], 0

; 2129 :    AnchorBlock->hFirstDebugChange = 0;

	mov	eax, DWORD PTR _AnchorBlock
	mov	DWORD PTR [eax+2523], 0

; 2130 : // AnchorBlock->TraceFlags       = 0;
; 2131 :    AnchorBlock->nMemoryTraceThreshold = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _AnchorBlock
	mov	WORD PTR [edx+134], cx

; 2132 :    AnchorBlock->nMemoryCeiling   = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+136], ax

; 2133 : 
; 2134 :    // Get Title of Main Task.
; 2135 :    GetWindowText( (HWND) lOE_hMainWnd, szTaskTitle, sizeof( szTaskTitle ) - 1 );

	push	255					; 000000ffH
	lea	edx, DWORD PTR _szTaskTitle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lOE_hMainWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowTextA@12

; 2136 : 
; 2137 :    lpMainTask = fnCreateTask( OE_AnchorBlock, lOE_hMainWnd,

	lea	ecx, DWORD PTR _szTaskTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lOE_Msg$[ebp]
	push	edx
	mov	eax, DWORD PTR _lOE_hMainWnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _OE_AnchorBlock$[ebp]
	push	ecx
	call	_fnCreateTask
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpMainTask$[ebp], eax

; 2138 :                               lOE_Msg, szTaskTitle );
; 2139 : 
; 2140 :    // Task is now ready to go.
; 2141 :    lpMainTask->bDisable = FALSE;

	mov	edx, DWORD PTR _lpMainTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 2142 : 
; 2143 : // g_lpCurrentTask = lpMainTask;
; 2144 : 
; 2145 :    AnchorBlock->hMainFirstDataHeader = lpMainTask->hFirstDataHeader;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lpMainTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	mov	DWORD PTR [edx+114], ecx

; 2146 :    AnchorBlock->hMainTask = zGETHNDL( lpMainTask );

	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+106], eax

; 2147 :    if ( AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+106], 0
	je	$LN7@Initialize

; 2148 :    {
; 2149 :       LPPROCESSLIST lpProcessList;
; 2150 :       LPSUBTASK lpFirstSubtask;
; 2151 :       zPCHAR    pchLine;
; 2152 :       zLONG     hFile;
; 2153 :       int       nEOF;
; 2154 : 
; 2155 :       // Now that we have allocated the AnchorBlock's memory, we can
; 2156 :       // set the process index for the main task.
; 2157 :       fnSetProcessIdx( "InitAnchor", &lpProcessList );

	lea	eax, DWORD PTR _lpProcessList$4[ebp]
	push	eax
	push	OFFSET $SG98553
	call	_fnSetProcessIdx
	add	esp, 8

; 2158 :       lpProcessList->uAppOE_Msg = (zUSHORT) lOE_Msg;

	mov	ecx, DWORD PTR _lpProcessList$4[ebp]
	mov	dx, WORD PTR _lOE_Msg$[ebp]
	mov	WORD PTR [ecx+2], dx

; 2159 :       lpProcessList->hWndAppOE_Msg = lOE_hMainWnd;

	mov	eax, DWORD PTR _lpProcessList$4[ebp]
	mov	ecx, DWORD PTR _lOE_hMainWnd$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 2160 : 
; 2161 :       // Now that we have created the main task, see if we can open
; 2162 :       // the zeidon applications file and get the directory pointers
; 2163 :       // for the zeidon exe directory and the zeidon system directory.
; 2164 :       zstrcat( szZeidonEnv, szlAppFile );

	mov	edx, DWORD PTR _szlAppFile
	push	edx
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2165 :       hFile = fnSysOpenFile( lpMainTask, szZeidonEnv, COREFILE_READ );

	push	128					; 00000080H
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFile$6[ebp], eax

; 2166 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$6[ebp], -1
	jne	$LN8@Initialize

; 2167 :       {
; 2168 :          char szMessage[ 256 ];
; 2169 : 
; 2170 :          // {9,"KZOEE009 - Error opening application definition file"},
; 2171 :          SysGetBaseMessage( szMessage, KZOEE009, 255 );

	push	255					; 000000ffH
	push	9
	lea	eax, DWORD PTR _szMessage$12[ebp]
	push	eax
	call	_SysGetBaseMessage@12

; 2172 :          zstrcat( szMessage, " '" );

	push	OFFSET $SG98555
	lea	ecx, DWORD PTR _szMessage$12[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2173 :          zstrcat( szMessage, szZeidonEnv );

	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMessage$12[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2174 :          zstrcat( szMessage, "'" );

	push	OFFSET $SG98556
	lea	ecx, DWORD PTR _szMessage$12[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2175 : 
; 2176 :          // Free the shared segment for KZOENGWA
; 2177 :          AnchorBlock->nStatus = AnchorCorrupt; // mark AnchorBlock as no good

	mov	edx, 20					; 00000014H
	mov	eax, DWORD PTR _AnchorBlock
	mov	WORD PTR [eax+84], dx

; 2178 :          fnFreeSharedMemory( lpMainTask, g_hAnchorBlock ); // free for KZOENGAA.DLL

	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnFreeSharedMemory@8

; 2179 : 
; 2180 :          // NULL AnchorBlock handle and pointer
; 2181 :          g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2182 :          AnchorBlock  = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2183 :          g_lProcessIdx = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 2184 : 
; 2185 :          fnSysMessageBox( lpMainTask, szlOE_SystemError, szMessage, 1 );

	push	1
	lea	eax, DWORD PTR _szMessage$12[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16

; 2186 :          zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2187 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@Initialize
$LN8@Initialize:

; 2188 :       }
; 2189 : 
; 2190 :       pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 2191 :       nEOF = fnSysReadLine( lpMainTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$7[ebp]
	push	edx
	mov	eax, DWORD PTR _lpMainTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$3[ebp], eax
$LN2@Initialize:

; 2192 :       while ( nEOF > 0 )

	cmp	DWORD PTR _nEOF$3[ebp], 0
	jle	$LN3@Initialize

; 2193 :       {
; 2194 :          SysParseLine( szZeidonEnv, &pchLine, pchLine + 1 );

	mov	ecx, DWORD PTR _pchLine$7[ebp]
	add	ecx, 1
	push	ecx
	lea	edx, DWORD PTR _pchLine$7[ebp]
	push	edx
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysParseLine@12

; 2195 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_BIN ) == 0 )

	movsx	ecx, BYTE PTR _szZeidonEnv$[ebp]
	mov	edx, DWORD PTR _szlZEIDON_BIN
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN30@Initialize
	mov	ecx, DWORD PTR _szlZEIDON_BIN
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv259[ebp], eax
	jmp	SHORT $LN31@Initialize
$LN30@Initialize:
	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	mov	ecx, DWORD PTR _szlZEIDON_BIN
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN28@Initialize
	mov	DWORD PTR tv258[ebp], 1
	jmp	SHORT $LN29@Initialize
$LN28@Initialize:
	mov	DWORD PTR tv258[ebp], -1
$LN29@Initialize:
	mov	eax, DWORD PTR tv258[ebp]
	mov	DWORD PTR tv259[ebp], eax
$LN31@Initialize:
	cmp	DWORD PTR tv259[ebp], 0
	jne	SHORT $LN9@Initialize

; 2196 :          {
; 2197 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	ecx, DWORD PTR _pchLine$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_fnConvertEnvironmentString@8

; 2198 :             SysAppendcDirSep( szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2199 :             zstrcpy( AnchorBlock->szZeidonBin, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 395				; 0000018bH
	push	edx
	call	_strcpy
	add	esp, 8

; 2200 :          }

	jmp	$LN10@Initialize
$LN9@Initialize:

; 2201 :          else
; 2202 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_SYS ) == 0 )

	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	mov	ecx, DWORD PTR _szlZEIDON_SYS
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN34@Initialize
	mov	eax, DWORD PTR _szlZEIDON_SYS
	push	eax
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv278[ebp], eax
	jmp	SHORT $LN35@Initialize
$LN34@Initialize:
	movsx	edx, BYTE PTR _szZeidonEnv$[ebp]
	mov	eax, DWORD PTR _szlZEIDON_SYS
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN32@Initialize
	mov	DWORD PTR tv277[ebp], 1
	jmp	SHORT $LN33@Initialize
$LN32@Initialize:
	mov	DWORD PTR tv277[ebp], -1
$LN33@Initialize:
	mov	edx, DWORD PTR tv277[ebp]
	mov	DWORD PTR tv278[ebp], edx
$LN35@Initialize:
	cmp	DWORD PTR tv278[ebp], 0
	jne	SHORT $LN11@Initialize

; 2203 :          {
; 2204 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	eax, DWORD PTR _pchLine$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_fnConvertEnvironmentString@8

; 2205 :             SysAppendcDirSep( szZeidonEnv );

	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 2206 :             zstrcpy( AnchorBlock->szZeidonSys, szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 652				; 0000028cH
	push	ecx
	call	_strcpy
	add	esp, 8

; 2207 :          }

	jmp	$LN10@Initialize
$LN11@Initialize:

; 2208 :          else
; 2209 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_LOC ) == 0 )

	movsx	edx, BYTE PTR _szZeidonEnv$[ebp]
	mov	eax, DWORD PTR _szlZEIDON_LOC
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN38@Initialize
	mov	edx, DWORD PTR _szlZEIDON_LOC
	push	edx
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv297[ebp], eax
	jmp	SHORT $LN39@Initialize
$LN38@Initialize:
	movsx	ecx, BYTE PTR _szZeidonEnv$[ebp]
	mov	edx, DWORD PTR _szlZEIDON_LOC
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN36@Initialize
	mov	DWORD PTR tv296[ebp], 1
	jmp	SHORT $LN37@Initialize
$LN36@Initialize:
	mov	DWORD PTR tv296[ebp], -1
$LN37@Initialize:
	mov	ecx, DWORD PTR tv296[ebp]
	mov	DWORD PTR tv297[ebp], ecx
$LN39@Initialize:
	cmp	DWORD PTR tv297[ebp], 0
	jne	SHORT $LN13@Initialize

; 2210 :          {
; 2211 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	edx, DWORD PTR _pchLine$7[ebp]
	push	edx
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 2212 :             SysAppendcDirSep( szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 2213 :             zstrcpy( AnchorBlock->szZeidonLoc, szZeidonEnv );

	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 909				; 0000038dH
	push	eax
	call	_strcpy
	add	esp, 8

; 2214 :          }

	jmp	$LN10@Initialize
$LN13@Initialize:

; 2215 :          else
; 2216 :          if ( zstrcmp( szZeidonEnv, szlZEIDON_SHR ) == 0 )

	movsx	ecx, BYTE PTR _szZeidonEnv$[ebp]
	mov	edx, DWORD PTR _szlZEIDON_SHR
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN42@Initialize
	mov	ecx, DWORD PTR _szlZEIDON_SHR
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv316[ebp], eax
	jmp	SHORT $LN43@Initialize
$LN42@Initialize:
	movsx	eax, BYTE PTR _szZeidonEnv$[ebp]
	mov	ecx, DWORD PTR _szlZEIDON_SHR
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN40@Initialize
	mov	DWORD PTR tv315[ebp], 1
	jmp	SHORT $LN41@Initialize
$LN40@Initialize:
	mov	DWORD PTR tv315[ebp], -1
$LN41@Initialize:
	mov	eax, DWORD PTR tv315[ebp]
	mov	DWORD PTR tv316[ebp], eax
$LN43@Initialize:
	cmp	DWORD PTR tv316[ebp], 0
	jne	SHORT $LN10@Initialize

; 2217 :          {
; 2218 :             fnConvertEnvironmentString( szZeidonEnv, pchLine );

	mov	ecx, DWORD PTR _pchLine$7[ebp]
	push	ecx
	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	call	_fnConvertEnvironmentString@8

; 2219 :             SysAppendcDirSep( szZeidonEnv );

	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2220 :             zstrcpy( AnchorBlock->szZeidonShr, szZeidonEnv );

	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1166				; 0000048eH
	push	edx
	call	_strcpy
	add	esp, 8
$LN10@Initialize:

; 2221 :          }
; 2222 : 
; 2223 :          nEOF = fnSysReadLine( lpMainTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$6[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$7[ebp]
	push	edx
	mov	eax, DWORD PTR _lpMainTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _nEOF$3[ebp], eax

; 2224 :          if ( zstrncmp( pchLine + 1, szlAPPLICATION,
; 2225 :                         zstrlen( szlAPPLICATION ) ) == 0 )

	mov	ecx, DWORD PTR _szlAPPLICATION
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _szlAPPLICATION
	push	edx
	mov	eax, DWORD PTR _pchLine$7[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN16@Initialize

; 2226 :          {
; 2227 :             break;

	jmp	SHORT $LN3@Initialize
$LN16@Initialize:

; 2228 :          }
; 2229 :       }

	jmp	$LN2@Initialize
$LN3@Initialize:

; 2230 : 
; 2231 :       fnSysCloseFile( lpMainTask, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 2232 :       if ( AnchorBlock->szZeidonBin[ 0 ] == 0 || AnchorBlock->szZeidonSys[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _AnchorBlock
	movsx	eax, BYTE PTR [edx+ecx+395]
	test	eax, eax
	je	SHORT $LN19@Initialize
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _AnchorBlock
	movsx	ecx, BYTE PTR [eax+edx+652]
	test	ecx, ecx
	jne	SHORT $LN17@Initialize
$LN19@Initialize:

; 2233 :       {
; 2234 :          char szMessage[ 256 ];
; 2235 : 
; 2236 :          // {8,"KZOEE008 - Application definition file missing ZEIDON_BIN or ZEIDON_SYS"},
; 2237 :          SysGetBaseMessage( szMessage, KZOEE008, 255 );

	push	255					; 000000ffH
	push	8
	lea	edx, DWORD PTR _szMessage$11[ebp]
	push	edx
	call	_SysGetBaseMessage@12

; 2238 :          zstrcat( szMessage, ", " );

	push	OFFSET $SG98568
	lea	eax, DWORD PTR _szMessage$11[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2239 :          zstrcat( szMessage, AnchorBlock->szZeidonLocal );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 138				; 0000008aH
	push	ecx
	lea	edx, DWORD PTR _szMessage$11[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2240 :          zstrcat( szMessage, szlAppFile );

	mov	eax, DWORD PTR _szlAppFile
	push	eax
	lea	ecx, DWORD PTR _szMessage$11[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 2241 :          fnSysMessageBox( lpMainTask, szlOE_SystemError, szMessage, 1 );

	push	1
	lea	edx, DWORD PTR _szMessage$11[ebp]
	push	edx
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 2242 :       }

	jmp	SHORT $LN18@Initialize
$LN17@Initialize:

; 2243 :       else
; 2244 :       {
; 2245 :          LPAPP lpApp = fnCreateApp( lpMainTask, 0 );  // Create sys app

	push	0
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnCreateApp
	add	esp, 8
	mov	DWORD PTR _lpApp$2[ebp], eax

; 2246 :          AnchorBlock->hSystemApp = zGETHNDL( lpApp );

	mov	eax, DWORD PTR _lpApp$2[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+110], eax
$LN18@Initialize:

; 2247 :       }
; 2248 : 
; 2249 :       if ( AnchorBlock->szZeidonLoc[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, BYTE PTR [ecx+eax+909]
	test	edx, edx
	jne	$LN20@Initialize

; 2250 :       {
; 2251 :          SysGetEnvVar( szZeidonEnv, "TEMP", sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	push	OFFSET $SG98570
	lea	eax, DWORD PTR _szZeidonEnv$[ebp]
	push	eax
	call	_SysGetEnvVar@12

; 2252 :          if ( szZeidonEnv[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szZeidonEnv$[ebp+edx]
	test	eax, eax
	jne	SHORT $LN21@Initialize

; 2253 :             SysGetEnvVar( szZeidonEnv, "TMP", sizeof( szZeidonEnv ) );

	push	256					; 00000100H
	push	OFFSET $SG98572
	lea	ecx, DWORD PTR _szZeidonEnv$[ebp]
	push	ecx
	call	_SysGetEnvVar@12
$LN21@Initialize:

; 2254 : 
; 2255 :          if ( szZeidonEnv[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szZeidonEnv$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN20@Initialize

; 2256 :          {
; 2257 :             zCHAR sz[ zMAX_FILENAME_LTH + 1 ];
; 2258 : 
; 2259 :             fnConvertEnvironmentString( sz, szZeidonEnv );

	lea	edx, DWORD PTR _szZeidonEnv$[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$10[ebp]
	push	eax
	call	_fnConvertEnvironmentString@8

; 2260 :             SysAppendcDirSep( sz );

	lea	ecx, DWORD PTR _sz$10[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 2261 :             zstrcpy( AnchorBlock->szZeidonLoc, sz );

	lea	edx, DWORD PTR _sz$10[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 909				; 0000038dH
	push	eax
	call	_strcpy
	add	esp, 8
$LN20@Initialize:

; 2262 :          }
; 2263 :       }
; 2264 : 
; 2265 :       lpMainTask->hApp = AnchorBlock->hSystemApp;

	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+110]
	mov	DWORD PTR [ecx+10], eax

; 2266 :       lpFirstSubtask = zGETPTR( lpMainTask->hFirstSubtask );

	mov	ecx, DWORD PTR _lpMainTask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSubtask$1[ebp], eax

; 2267 :       lpFirstSubtask->hApp = AnchorBlock->hSystemApp;

	mov	eax, DWORD PTR _lpFirstSubtask$1[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	mov	DWORD PTR [eax+10], edx
$LN7@Initialize:

; 2268 :    }
; 2269 : 
; 2270 :    // If First task initialization failed, issue error and leave
; 2271 :    if ( !AnchorBlock->hMainTask || !AnchorBlock->hSystemApp )

	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+106], 0
	je	SHORT $LN24@Initialize
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+110], 0
	jne	SHORT $LN23@Initialize
$LN24@Initialize:

; 2272 :    {
; 2273 :       // Free the shared segment for KZOENGWA
; 2274 :       AnchorBlock->nStatus = AnchorCorrupt;  // mark AnchorBlock as no good

	mov	edx, 20					; 00000014H
	mov	eax, DWORD PTR _AnchorBlock
	mov	WORD PTR [eax+84], dx

; 2275 :       fnFreeSharedMemory( lpMainTask, g_hAnchorBlock ); // free for KZOENGAA.DLL

	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$[ebp]
	push	edx
	call	_fnFreeSharedMemory@8

; 2276 : 
; 2277 :       // NULL AnchorBlock handle and pointer
; 2278 :       g_hAnchorBlock = 0;

	mov	DWORD PTR _g_hAnchorBlock, 0

; 2279 :       AnchorBlock    = 0;

	mov	DWORD PTR _AnchorBlock, 0

; 2280 :       g_lProcessIdx  = -1;

	mov	DWORD PTR _g_lProcessIdx, -1

; 2281 : 
; 2282 :       zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2283 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@Initialize
$LN23@Initialize:

; 2284 :    }
; 2285 : 
; 2286 :    // create international info from win.ini
; 2287 :    AnchorBlock->hInternational = SysCreateInternational( );

	call	_SysCreateInternational@0
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+2515], eax

; 2288 : 
; 2289 :    SysReadZeidonIni( -1, "[ObjectEngine]", "MemoryTraceThreshold", szSize );

	lea	edx, DWORD PTR _szSize$[ebp]
	push	edx
	push	OFFSET $SG98576
	push	OFFSET $SG98577
	push	-1
	call	_SysReadZeidonIni@16

; 2290 :    AnchorBlock->nMemoryTraceThreshold = atoi( szSize );

	lea	eax, DWORD PTR _szSize$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+134], ax

; 2291 :    SysReadZeidonIni( -1, "[ObjectEngine]", "MemoryCeiling", szSize );

	lea	edx, DWORD PTR _szSize$[ebp]
	push	edx
	push	OFFSET $SG98578
	push	OFFSET $SG98579
	push	-1
	call	_SysReadZeidonIni@16

; 2292 :    AnchorBlock->nMemoryCeiling = atoi( szSize );

	lea	eax, DWORD PTR _szSize$[ebp]
	push	eax
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+136], ax

; 2293 : 
; 2294 :    zUNLOCK_MUTEX( zMUTEX_ANCHORINIT );

	push	3
	call	_fnSysUnlockCoreMutex@4

; 2295 : 
; 2296 : #ifdef __MUTEX_DEBUG__
; 2297 :    // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 2298 :    fnPrintMutexInfo( 's', zMUTEX_COUNT, __FILE__, __LINE__ );
; 2299 : #endif
; 2300 : 
; 2301 :    {
; 2302 : 
; 2303 :    COPYDATASTRUCT cd;
; 2304 : 
; 2305 :    cd.dwData = LB_ADDSTRING;

	mov	DWORD PTR _cd$5[ebp], 384		; 00000180H

; 2306 :    cd.lpData = "Object Services Initialization complete...";

	mov	DWORD PTR _cd$5[ebp+8], OFFSET $SG98580

; 2307 :    cd.cbData = zstrlen( (zPCHAR) cd.lpData ) + 1;

	mov	edx, DWORD PTR _cd$5[ebp+8]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cd$5[ebp+4], eax

; 2308 : 
; 2309 :    // Use WM_COPYDATA to send the message so we don't have any memory leaks.
; 2310 :    SendMessage( (HWND) AnchorBlock->lOE_hListWnd,

	lea	eax, DWORD PTR _cd$5[ebp]
	push	eax
	push	0
	push	74					; 0000004aH
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+98]
	push	edx
	call	DWORD PTR __imp__SendMessageA@16

; 2311 :                 WM_COPYDATA, 0, (LPARAM) &cd );
; 2312 :    if ( g_bServerMode )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $LN25@Initialize

; 2313 :       cd.lpData = "Object Services Running in Server Mode...";

	mov	DWORD PTR _cd$5[ebp+8], OFFSET $SG98583
	jmp	SHORT $LN26@Initialize
$LN25@Initialize:

; 2314 :    else
; 2315 :       cd.lpData = "Object Services Running in Shared Mode...";

	mov	DWORD PTR _cd$5[ebp+8], OFFSET $SG98584
$LN26@Initialize:

; 2316 : 
; 2317 :    cd.cbData = zstrlen( (zPCHAR) cd.lpData ) + 1;

	mov	ecx, DWORD PTR _cd$5[ebp+8]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cd$5[ebp+4], eax

; 2318 :    SendMessage( (HWND) AnchorBlock->lOE_hListWnd,

	lea	edx, DWORD PTR _cd$5[ebp]
	push	edx
	push	0
	push	74					; 0000004aH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 2319 :                 WM_COPYDATA, 0, (LPARAM) &cd );
; 2320 :    }
; 2321 : 
; 2322 : #ifdef __MUTEX_DEBUG__
; 2323 :    // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 2324 :    fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 2325 : #endif
; 2326 : 
; 2327 :    fnTraceCompileTime( );

	call	_fnTraceCompileTime@0

; 2328 :    MiListOE_Memory( 0, -1 );

	push	-1
	push	0
	call	_MiListOE_Memory@8

; 2329 :    return( AnchorBlock );

	mov	eax, DWORD PTR _AnchorBlock
$LN1@Initialize:

; 2330 : 
; 2331 : }   // End of InitializeAnchorBlock

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_InitializeAnchorBlock@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pch$ = -4						; size = 4
_pchTarget$ = 8						; size = 4
_pchSource$ = 12					; size = 4
_fnConvertEnvironmentString@8 PROC

; 1914 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@fnConvertE:

; 1915 :    zPCHAR pch;
; 1916 : 
; 1917 :    while ( *pchSource )

	mov	eax, DWORD PTR _pchSource$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@fnConvertE

; 1918 :    {
; 1919 :       // If char is not % then just copy it to target string and continue.
; 1920 :       if ( *pchSource != '%' )

	mov	edx, DWORD PTR _pchSource$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN9@fnConvertE

; 1921 :       {
; 1922 :          *pchTarget++ = *pchSource++;

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	edx, DWORD PTR _pchSource$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTarget$[ebp], ecx
	mov	edx, DWORD PTR _pchSource$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSource$[ebp], edx

; 1923 :          continue;

	jmp	SHORT $LN2@fnConvertE
$LN9@fnConvertE:

; 1924 :       }
; 1925 : 
; 1926 :       // Bump up pchSource to skip past %.
; 1927 :       pchSource++;

	mov	eax, DWORD PTR _pchSource$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSource$[ebp], eax

; 1928 : 
; 1929 :       // Look for final %.
; 1930 :       for ( pch = pchSource; *pch && *pch != '%'; pch++ )

	mov	ecx, DWORD PTR _pchSource$[ebp]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $LN6@fnConvertE
$LN4@fnConvertE:
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$LN6@fnConvertE:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN5@fnConvertE
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 37					; 00000025H
	je	SHORT $LN5@fnConvertE

; 1931 :          ; // Nothing needs to be done here.

	jmp	SHORT $LN4@fnConvertE
$LN5@fnConvertE:

; 1932 : 
; 1933 :       if ( *pch == 0 )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN10@fnConvertE

; 1934 :       {
; 1935 :          // Error -- no terminating %.
; 1936 :          SysMessageBox( 0, szlOE_SystemError,

	push	-1
	push	OFFSET $SG98457
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 1937 :                         "No terminating '%' in ZEIDON.APP", -1 );
; 1938 : 
; 1939 :          // Try to get out as gracefully as possible.
; 1940 :          *pchTarget++ = '%';

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx], 37			; 00000025H
	mov	edx, DWORD PTR _pchTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTarget$[ebp], edx

; 1941 :          zstrcpy( pchTarget, pchSource );

	mov	eax, DWORD PTR _pchSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1942 :          return;

	jmp	SHORT $LN1@fnConvertE
$LN10@fnConvertE:

; 1943 :       }
; 1944 : 
; 1945 :       // Temporarily change '%' to null-terminator.
; 1946 :       *pch = 0;

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 0

; 1947 : 
; 1948 :       // Expand env var in the target string.
; 1949 :       SysGetEnvVar( pchTarget, pchSource, zMAX_FILENAME_LTH );

	push	256					; 00000100H
	mov	eax, DWORD PTR _pchSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_SysGetEnvVar@12

; 1950 : 
; 1951 :       // Change null-terminator back to '%'.
; 1952 :       *pch = '%';

	mov	edx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [edx], 37			; 00000025H
$LN7@fnConvertE:

; 1953 : 
; 1954 :       // Move pchTarget to point to null-terminator.
; 1955 :       while ( *pchTarget )

	mov	eax, DWORD PTR _pchTarget$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@fnConvertE

; 1956 :          pchTarget++;

	mov	edx, DWORD PTR _pchTarget$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTarget$[ebp], edx
	jmp	SHORT $LN7@fnConvertE
$LN8@fnConvertE:

; 1957 : 
; 1958 :       pchSource = pch + 1;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSource$[ebp], eax

; 1959 : 
; 1960 :    } // while ( *pchSource )...

	jmp	$LN2@fnConvertE
$LN3@fnConvertE:

; 1961 : 
; 1962 :    // Terminate result.
; 1963 :    *pchTarget = 0;

	mov	ecx, DWORD PTR _pchTarget$[ebp]
	mov	BYTE PTR [ecx], 0
$LN1@fnConvertE:

; 1964 : 
; 1965 : } // fnConvertEnvironmentString

	mov	esp, ebp
	pop	ebp
	ret	8
_fnConvertEnvironmentString@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szMsg$1 = -204						; size = 100
_szMsg$2 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lMutex$ = 8						; size = 4
_fnSysUnlockCoreMutex@4 PROC

; 8618 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8619 : #ifdef __MUTEX_DEBUG__
; 8620 :    fnPrintMutexInfo( 'u', lMutex, pchFile, lLine );
; 8621 : #endif
; 8622 : 
; 8623 :    if ( g_bServerMode )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $LN2@fnSysUnloc

; 8624 :    {
; 8625 :       LeaveCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	imul	ecx, DWORD PTR _lMutex$[ebp], 24
	add	ecx, OFFSET _g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 8626 :    }

	jmp	$LN1@fnSysUnloc
$LN2@fnSysUnloc:

; 8627 :    else
; 8628 :    if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $LN4@fnSysUnloc

; 8629 :    {
; 8630 :       zCHAR szMsg[ 100 ];
; 8631 : 
; 8632 :       zsprintf( szMsg, "Trying to unlock NULL Mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET $SG100521
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8633 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8634 :    }

	jmp	SHORT $LN1@fnSysUnloc
$LN4@fnSysUnloc:

; 8635 :    else
; 8636 :    if ( ReleaseMutex( g_ZeidonMutexTable[ lMutex ] ) == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexTable[edx*4]
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	test	eax, eax
	jne	SHORT $LN1@fnSysUnloc

; 8637 :    {
; 8638 :       zCHAR szMsg[ 100 ];
; 8639 : 
; 8640 :       zsprintf( szMsg, "Error releasing mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexName[ecx*4]
	push	edx
	push	OFFSET $SG100523
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8641 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16
$LN1@fnSysUnloc:

; 8642 :    }
; 8643 : 
; 8644 : #ifdef __MUTEX_DEBUG__
; 8645 :    fnPrintMutexInfo( 'U', lMutex, pchFile, lLine );
; 8646 : #endif
; 8647 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysUnlockCoreMutex@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szMsg$1 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lMutex$ = 8						; size = 4
_fnSysLockCoreMutex@4 PROC

; 8560 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8561 : #ifdef __MUTEX_DEBUG__
; 8562 :    fnPrintMutexInfo( 'l', lMutex, pchFile, lLine );
; 8563 : #endif
; 8564 : 
; 8565 :    if ( g_bServerMode )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $LN2@fnSysLockC

; 8566 :    {
; 8567 :       EnterCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	imul	ecx, DWORD PTR _lMutex$[ebp], 24
	add	ecx, OFFSET _g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 8568 :    }

	jmp	SHORT $LN1@fnSysLockC
$LN2@fnSysLockC:

; 8569 :    else
; 8570 :    {
; 8571 : #ifdef __MUTEX_DEBUG__
; 8572 :       DWORD dwRC;
; 8573 : #endif
; 8574 :       if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $LN4@fnSysLockC

; 8575 :       {
; 8576 :          zCHAR szMsg[ 100 ];
; 8577 : 
; 8578 :          zsprintf( szMsg, "Trying to lock NULL Mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET $SG100511
	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8579 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8580 :          return;

	jmp	SHORT $LN1@fnSysLockC
$LN4@fnSysLockC:

; 8581 :       }
; 8582 : 
; 8583 : #ifdef __MUTEX_DEBUG__
; 8584 :       dwRC = WaitForSingleObject( g_ZeidonMutexTable[ lMutex ], 30000 );
; 8585 :       if ( dwRC == WAIT_FAILED )
; 8586 :       {
; 8587 :          switch ( GetLastError( ) )
; 8588 :          {
; 8589 :             case WAIT_ABANDONED:
; 8590 :                // This means that another thread terminated without unlocking
; 8591 :                // its mutex.  We'll consider this OK.
; 8592 :                break;
; 8593 : 
; 8594 :             case WAIT_TIMEOUT:
; 8595 :                dwRC /= dwRC - dwRC;
; 8596 :                break;
; 8597 : 
; 8598 :             default:
; 8599 :                break;
; 8600 :          }
; 8601 :       }
; 8602 : #else
; 8603 :       WaitForSingleObject( g_ZeidonMutexTable[ lMutex ], INFINITE );

	push	-1
	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexTable[edx*4]
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN1@fnSysLockC:

; 8604 : #endif
; 8605 :    }
; 8606 : 
; 8607 : #ifdef __MUTEX_DEBUG__
; 8608 :    fnPrintMutexInfo( 'L', lMutex, pchFile, lLine );
; 8609 : #endif
; 8610 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysLockCoreMutex@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szMsg$1 = -204						; size = 100
_szMsg$2 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lMutex$ = 8						; size = 4
_fnSysDestroyCoreMutex@4 PROC

; 8525 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8526 :    if ( g_bServerMode )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $LN2@fnSysDestr

; 8527 :    {
; 8528 :       DeleteCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	imul	ecx, DWORD PTR _lMutex$[ebp], 24
	add	ecx, OFFSET _g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 8529 :    }

	jmp	$LN1@fnSysDestr
$LN2@fnSysDestr:

; 8530 :    else
; 8531 :    {
; 8532 :       if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $LN4@fnSysDestr

; 8533 :       {
; 8534 :          zCHAR szMsg[ 100 ];
; 8535 : 
; 8536 :          zsprintf( szMsg, "Trying to destroy NULL Mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET $SG100501
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8537 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8538 :          return;

	jmp	SHORT $LN1@fnSysDestr
$LN4@fnSysDestr:

; 8539 :       }
; 8540 : 
; 8541 :       if ( !CloseHandle( g_ZeidonMutexTable[ lMutex ] ) )

	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexTable[edx*4]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $LN5@fnSysDestr

; 8542 :       {
; 8543 :          zCHAR szMsg[ 100 ];
; 8544 : 
; 8545 :          zsprintf( szMsg, "Error destroying mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	ecx, DWORD PTR _lMutex$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexName[ecx*4]
	push	edx
	push	OFFSET $SG100503
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8546 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 8547 :          return;

	jmp	SHORT $LN1@fnSysDestr
$LN5@fnSysDestr:

; 8548 :       }
; 8549 : 
; 8550 :       g_ZeidonMutexTable[ lMutex ] = 0;

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	DWORD PTR _g_ZeidonMutexTable[eax*4], 0
$LN1@fnSysDestr:

; 8551 :    }
; 8552 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysDestroyCoreMutex@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szMsg$1 = -204						; size = 100
_szMsg$2 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lMutex$ = 8						; size = 4
_fnSysCreateCoreMutex@4 PROC

; 8493 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8494 :    if ( g_bServerMode )

	movzx	eax, BYTE PTR _g_bServerMode
	test	eax, eax
	je	SHORT $LN2@fnSysCreat

; 8495 :    {
; 8496 :       InitializeCriticalSection( &g_ZeidonCritTable[ lMutex ] );

	imul	ecx, DWORD PTR _lMutex$[ebp], 24
	add	ecx, OFFSET _g_ZeidonCritTable
	push	ecx
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 8497 :    }

	jmp	$LN1@fnSysCreat
$LN2@fnSysCreat:

; 8498 :    else
; 8499 :    {
; 8500 :       if ( g_ZeidonMutexTable[ lMutex ] )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	je	SHORT $LN4@fnSysCreat

; 8501 :       {
; 8502 :          zCHAR szMsg[ 100 ];
; 8503 : 
; 8504 :          zsprintf( szMsg, "Mutex '%s' already created", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET $SG100490
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8505 :          SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 8506 :       }

	jmp	SHORT $LN1@fnSysCreat
$LN4@fnSysCreat:

; 8507 :       else
; 8508 :       {
; 8509 :          g_ZeidonMutexTable[ lMutex ] =

	mov	edx, DWORD PTR _lMutex$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexName[edx*4]
	push	eax
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	ecx, DWORD PTR _lMutex$[ebp]
	mov	DWORD PTR _g_ZeidonMutexTable[ecx*4], eax

; 8510 :                       CreateMutex( NULL, FALSE, g_ZeidonMutexName[ lMutex ] );
; 8511 : 
; 8512 :          if ( g_ZeidonMutexTable[ lMutex ] == 0 )

	mov	edx, DWORD PTR _lMutex$[ebp]
	cmp	DWORD PTR _g_ZeidonMutexTable[edx*4], 0
	jne	SHORT $LN1@fnSysCreat

; 8513 :          {
; 8514 :             zCHAR szMsg[ 100 ];
; 8515 : 
; 8516 :             zsprintf( szMsg, "Error creating mutex %s", g_ZeidonMutexName[ lMutex ] );

	mov	eax, DWORD PTR _lMutex$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexName[eax*4]
	push	ecx
	push	OFFSET $SG100492
	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 8517 :             SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16
$LN1@fnSysCreat:

; 8518 :          }
; 8519 :       }
; 8520 :    }
; 8521 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnSysCreateCoreMutex@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_wc$ = -320						; size = 40
_nPosX$1 = -280						; size = 4
_nPosY$2 = -276						; size = 4
_hMainWnd$3 = -272					; size = 4
_nWidth$4 = -268					; size = 4
_nHeight$5 = -264					; size = 4
_szMsg$6 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_hInstance$ = 8						; size = 4
_cpcClassName$ = 12					; size = 4
_cpcWindowTitle$ = 16					; size = 4
_SysInitApplicationWindow@12 PROC

; 10212: {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 10213:    WNDCLASS  wc;
; 10214: 
; 10215:    // Fill in window class structure with parameters that describe the main window.
; 10216:    wc.style = 0;                       // class style(s)

	mov	DWORD PTR _wc$[ebp], 0

; 10217:    wc.lpfnWndProc = SysMainWndProc;    // function to retrieve messages for

	mov	DWORD PTR _wc$[ebp+4], OFFSET _SysMainWndProc@16

; 10218:                                        //   windows of this class
; 10219:    wc.cbClsExtra = 0;                  // no per-class extra data

	mov	DWORD PTR _wc$[ebp+8], 0

; 10220:    wc.cbWndExtra = 0;                  // no per-window extra data

	mov	DWORD PTR _wc$[ebp+12], 0

; 10221:    wc.hInstance = (HANDLE) hInstance;  // application that owns the class

	mov	eax, DWORD PTR _hInstance$[ebp]
	mov	DWORD PTR _wc$[ebp+16], eax

; 10222:    wc.hIcon = LoadIcon( 0, IDI_APPLICATION );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wc$[ebp+20], eax

; 10223:    wc.hCursor = LoadCursor( 0, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 10224:    wc.hbrBackground = GetStockObject( WHITE_BRUSH );

	push	0
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 10225:    wc.lpszMenuName = 0;                // name of menu resource in .RC file

	mov	DWORD PTR _wc$[ebp+32], 0

; 10226:    wc.lpszClassName = cpcClassName;    // name used in call to CreateWindow

	mov	ecx, DWORD PTR _cpcClassName$[ebp]
	mov	DWORD PTR _wc$[ebp+36], ecx

; 10227: 
; 10228:    // Register the window class and return success/failure code.
; 10229:    if ( RegisterClass( &wc ) )

	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	eax, ax
	test	eax, eax
	je	$LN2@SysInitApp

; 10230:    {
; 10231:       HWND   hMainWnd;
; 10232:       int    nHeight, nPosY;
; 10233:       int    nWidth, nPosX;
; 10234: 
; 10235:       // Get the dimensions of the screen ... we don't really care since this
; 10236:       // window is hidden anyway.
; 10237:       nWidth = GetSystemMetrics( SM_CXSCREEN );

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nWidth$4[ebp], eax

; 10238:       nHeight = GetSystemMetrics( SM_CYSCREEN );

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nHeight$5[ebp], eax

; 10239:       nWidth /= 2;

	mov	eax, DWORD PTR _nWidth$4[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nWidth$4[ebp], eax

; 10240:       nHeight /= 2;

	mov	eax, DWORD PTR _nHeight$5[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nHeight$5[ebp], eax

; 10241:       nWidth -= 40;

	mov	ecx, DWORD PTR _nWidth$4[ebp]
	sub	ecx, 40					; 00000028H
	mov	DWORD PTR _nWidth$4[ebp], ecx

; 10242:       nHeight -= 20;

	mov	edx, DWORD PTR _nHeight$5[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR _nHeight$5[ebp], edx

; 10243:       nPosX = nWidth / 2;

	mov	eax, DWORD PTR _nWidth$4[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosX$1[ebp], eax

; 10244:       nPosY = nHeight / 2;

	mov	eax, DWORD PTR _nHeight$5[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosY$2[ebp], eax

; 10245:       nPosX -= 8; // so it doesn't occupy same space as object services

	mov	eax, DWORD PTR _nPosX$1[ebp]
	sub	eax, 8
	mov	DWORD PTR _nPosX$1[ebp], eax

; 10246:       nPosY -= 8;

	mov	ecx, DWORD PTR _nPosY$2[ebp]
	sub	ecx, 8
	mov	DWORD PTR _nPosY$2[ebp], ecx

; 10247: 
; 10248:       // Create a main window for this application instance.
; 10249:       hMainWnd = CreateWindow( cpcClassName,        // see RegisterClass( ) call

	push	0
	mov	edx, DWORD PTR _hInstance$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _nHeight$5[ebp]
	push	eax
	mov	ecx, DWORD PTR _nWidth$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _nPosY$2[ebp]
	push	edx
	mov	eax, DWORD PTR _nPosX$1[ebp]
	push	eax
	push	13565952				; 00cf0000H
	mov	ecx, DWORD PTR _cpcWindowTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcClassName$[ebp]
	push	edx
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _hMainWnd$3[ebp], eax

; 10250:                                cpcWindowTitle,      // text for window title bar
; 10251:                                WS_OVERLAPPEDWINDOW, // window style
; 10252:                                nPosX,               // default horizontal position
; 10253:                                nPosY,               // default vertical position
; 10254:                                nWidth,              // default width
; 10255:                                nHeight,             // default height
; 10256:                                0,                   // overlapped windows have no parent
; 10257:                                0,                   // menu for trace window
; 10258:                             // 0,                   // use default menu
; 10259:                                (HANDLE) hInstance,  // this instance owns this window
; 10260:                                0 );                 // pointer not needed
; 10261:       {
; 10262:          char szMsg[ 256 ];
; 10263: 
; 10264:          zsprintf( szMsg, "SysInitApplicationWindow Class: %s  Title: %s  hWnd: 0x%08x=%d",

	mov	eax, DWORD PTR _hMainWnd$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _hMainWnd$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcWindowTitle$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcClassName$[ebp]
	push	eax
	push	OFFSET $SG100840
	lea	ecx, DWORD PTR _szMsg$6[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H

; 10265:                    cpcClassName, cpcWindowTitle, hMainWnd, hMainWnd );
; 10266:          TraceLineS( szMsg, "" );

	push	OFFSET $SG100841
	lea	edx, DWORD PTR _szMsg$6[ebp]
	push	edx
	call	_TraceLineS@8

; 10267:       // SysMessageBox( 0, "CreateWindow", szMsg, -1 );
; 10268:       }
; 10269: 
; 10270:       // If window is created, return "success".
; 10271:       if ( hMainWnd )

	cmp	DWORD PTR _hMainWnd$3[ebp], 0
	je	SHORT $LN2@SysInitApp

; 10272:       {
; 10273:          ShowWindow( hMainWnd, SW_HIDE ); // hide the window

	push	0
	mov	eax, DWORD PTR _hMainWnd$3[ebp]
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 10274:          return( (zLONG) hMainWnd );      // return "success"

	mov	eax, DWORD PTR _hMainWnd$3[ebp]
	jmp	SHORT $LN1@SysInitApp
$LN2@SysInitApp:

; 10275:       }
; 10276:    }
; 10277: 
; 10278:    return( 0 ); // return "failure"

	xor	eax, eax
$LN1@SysInitApp:

; 10279: }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysInitApplicationWindow@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_SysGetClientMessage@0 PROC

; 9378 : {

	push	ebp
	mov	ebp, esp

; 9379 :    if ( g_wClientMessage == 0 )

	cmp	DWORD PTR _g_wClientMessage, 0
	jne	SHORT $LN2@SysGetClie

; 9380 :       g_wClientMessage = RegisterWindowMessage( "KZOESYAA" );

	push	OFFSET $SG100796
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	DWORD PTR _g_wClientMessage, eax
$LN2@SysGetClie:

; 9381 : 
; 9382 :    return( g_wClientMessage );

	mov	ax, WORD PTR _g_wClientMessage

; 9383 : }

	pop	ebp
	ret	0
_SysGetClientMessage@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_SysEndBrowseOfTaskList@0 PROC

; 9372 : {

	push	ebp
	mov	ebp, esp

; 9373 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 9374 : }

	pop	ebp
	ret	0
_SysEndBrowseOfTaskList@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTaskView$ = 8					; size = 4
_SysStartBrowseOfTaskList@4 PROC

; 9366 : {

	push	ebp
	mov	ebp, esp

; 9367 :    return( fnStartBrowseOfTaskList( lpTaskView->hTask, FALSE ) );

	push	0
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	_fnStartBrowseOfTaskList@8

; 9368 : }

	pop	ebp
	ret	4
_SysStartBrowseOfTaskList@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lFileHandle$ = 12					; size = 4
_cpcLine$ = 16						; size = 4
_ulLth$ = 20						; size = 4
_bAppend$ = 24						; size = 1
_SysWriteLineLth@20 PROC

; 6136 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6137 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysWriteLi
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysWriteLi
$LN3@SysWriteLi:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysWriteLi:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6138 : 
; 6139 :    return( fnSysWriteLineLth( lpTask, lFileHandle, 0,

	movzx	eax, BYTE PTR _bAppend$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLineLth@24

; 6140 :                               cpcLine, ulLth, bAppend ) );
; 6141 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SysWriteLineLth@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpWriteBuffer$ = -8					; size = 4
_lpOpenFile$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lFileHandle$ = 12					; size = 4
_ppvFile$ = 16						; size = 4
_cpcLine$ = 20						; size = 4
_ulLth$ = 24						; size = 4
_bAppend$ = 28						; size = 1
_fnSysWriteLineLth@24 PROC

; 6036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6037 :    zPCHAR        lpWriteBuffer;
; 6038 :    LPOPENFILE    lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 6039 : 
; 6040 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $LN6@fnSysWrite
	mov	eax, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN6@fnSysWrite

; 6041 :    {
; 6042 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	ecx, DWORD PTR _ppvFile$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpOpenFile$[ebp], edx

; 6043 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $LN6@fnSysWrite

; 6044 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$LN6@fnSysWrite:

; 6045 :    }
; 6046 : 
; 6047 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN8@fnSysWrite

; 6048 :    {
; 6049 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+118]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$LN2@fnSysWrite:

; 6050 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $LN8@fnSysWrite

; 6051 :       {
; 6052 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $LN9@fnSysWrite

; 6053 :             break;

	jmp	SHORT $LN8@fnSysWrite
$LN9@fnSysWrite:

; 6054 : 
; 6055 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 6056 :       }

	jmp	SHORT $LN2@fnSysWrite
$LN8@fnSysWrite:

; 6057 :    }
; 6058 : 
; 6059 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN10@fnSysWrite

; 6060 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysWrite
$LN10@fnSysWrite:

; 6061 : 
; 6062 :    // Check to see if buffered WriteLines desired, if not, write it.
; 6063 :    if ( (lpOpenFile->nFlags & COREFILE_WRITELINE_BUFFERED) == 0 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 1
	jne	SHORT $LN11@fnSysWrite

; 6064 :    {
; 6065 :       fnSysWriteFile( lpTask, lFileHandle, cpcLine, ulLth );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16

; 6066 :       if ( bAppend )

	movzx	edx, BYTE PTR _bAppend$[ebp]
	test	edx, edx
	je	SHORT $LN12@fnSysWrite

; 6067 :          fnSysWriteFile( lpTask, lFileHandle, "\r\n", 2 );

	push	2
	push	OFFSET $SG99687
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16
$LN12@fnSysWrite:

; 6068 : 
; 6069 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSysWrite
$LN11@fnSysWrite:

; 6070 :    }
; 6071 : 
; 6072 :    // File found, get a file read buffer is necessary.
; 6073 :    if ( lpOpenFile->uWriteBufferSize == 0 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+546], 0
	jne	$LN13@fnSysWrite

; 6074 :    {
; 6075 :       lpOpenFile->uWriteBufferSize = 8192;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+546], 8192		; 00002000H
$LN4@fnSysWrite:

; 6076 :       while ( lpOpenFile->uWriteBufferSize > 2040 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+546], 2040		; 000007f8H
	jbe	SHORT $LN5@fnSysWrite

; 6077 :       {
; 6078 :          lpOpenFile->hWriteBuffer =

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+546]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+554], eax

; 6079 :             fnAllocDataspace( lpTask->hFirstDataHeader,
; 6080 :                               lpOpenFile->uWriteBufferSize, 0, 0, 0 );
; 6081 :          if ( lpOpenFile->hWriteBuffer )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+554], 0
	je	SHORT $LN14@fnSysWrite

; 6082 :             break;

	jmp	SHORT $LN5@fnSysWrite
$LN14@fnSysWrite:

; 6083 : 
; 6084 :          lpOpenFile->uWriteBufferSize /= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+546]
	shr	ecx, 1
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], ecx

; 6085 :       }

	jmp	SHORT $LN4@fnSysWrite
$LN5@fnSysWrite:

; 6086 : 
; 6087 :       if ( lpOpenFile->hWriteBuffer == 0 )  // if buffer acquisition failed

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+554], 0
	jne	SHORT $LN15@fnSysWrite

; 6088 :       {
; 6089 :          lpOpenFile->uWriteBufferSize = 0;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+546], 0

; 6090 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysWrite
$LN15@fnSysWrite:

; 6091 :       }
; 6092 : 
; 6093 :       // Bump size down by 2 for safety.
; 6094 :       lpOpenFile->uWriteBufferSize -= 2;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+546]
	sub	eax, 2
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+546], eax
$LN13@fnSysWrite:

; 6095 :    }
; 6096 : 
; 6097 :    lpWriteBuffer = zGETPTR( lpOpenFile->hWriteBuffer );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+554]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWriteBuffer$[ebp], eax

; 6098 : 
; 6099 :    // If there is not buffer room to write this line, write out buffer and
; 6100 :    // reset position.
; 6101 :    if ( (lpOpenFile->uWriteBufferSize -
; 6102 :                                    lpOpenFile->uWriteBufferPos) < ulLth + 2 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [ecx+546]
	sub	eax, DWORD PTR [edx+550]
	mov	ecx, DWORD PTR _ulLth$[ebp]
	add	ecx, 2
	cmp	eax, ecx
	jae	SHORT $LN16@fnSysWrite

; 6103 :    {
; 6104 :       fnSysWriteFile( lpTask, lFileHandle, lpWriteBuffer, lpOpenFile->uWriteBufferPos );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+550]
	push	eax
	mov	ecx, DWORD PTR _lpWriteBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16

; 6105 :       lpOpenFile->uWriteBufferPos = 0;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+550], 0
$LN16@fnSysWrite:

; 6106 :    }
; 6107 : 
; 6108 :    // If the write to be done is bigger than the buffer, simply write
; 6109 :    // the line passed and put a crlf in the buffer.
; 6110 :    if ( lpOpenFile->uWriteBufferSize < ulLth + 2 )

	mov	edx, DWORD PTR _ulLth$[ebp]
	add	edx, 2
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+546], edx
	jae	SHORT $LN17@fnSysWrite

; 6111 :    {
; 6112 :       fnSysWriteFile( lpTask, lFileHandle, cpcLine, ulLth );

	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16

; 6113 :    }

	jmp	SHORT $LN18@fnSysWrite
$LN17@fnSysWrite:

; 6114 :    else
; 6115 :    {
; 6116 :       // Copy the new line into the Buffer.
; 6117 :       zmemcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], cpcLine, ulLth );

	mov	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpWriteBuffer$[ebp]
	add	edx, DWORD PTR [ecx+550]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 6118 :       lpOpenFile->uWriteBufferPos += ulLth;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+550]
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+550], ecx
$LN18@fnSysWrite:

; 6119 :    }
; 6120 : 
; 6121 :    if ( bAppend )

	movzx	eax, BYTE PTR _bAppend$[ebp]
	test	eax, eax
	je	SHORT $LN19@fnSysWrite

; 6122 :    {
; 6123 :       zstrcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], "\r\n" );

	push	OFFSET $SG99695
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpWriteBuffer$[ebp]
	add	edx, DWORD PTR [ecx+550]
	push	edx
	call	_strcpy
	add	esp, 8

; 6124 :       lpOpenFile->uWriteBufferPos += 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+550]
	add	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+550], ecx
$LN19@fnSysWrite:

; 6125 :    }
; 6126 : 
; 6127 :    return( 0 );

	xor	eax, eax
$LN1@fnSysWrite:

; 6128 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnSysWriteLineLth@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lFileHandle$ = 12					; size = 4
_cpcLine$ = 16						; size = 4
_SysWriteLine@12 PROC

; 6003 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6004 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysWriteLi
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysWriteLi
$LN3@SysWriteLi:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysWriteLi:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6005 : 
; 6006 :    return( fnSysWriteLine( lpTask, lFileHandle, 0, cpcLine ) );

	mov	eax, DWORD PTR _cpcLine$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 6007 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysWriteLine@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lLth$ = -12						; size = 4
_lpWriteBuffer$ = -8					; size = 4
_lpOpenFile$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lFileHandle$ = 12					; size = 4
_ppvFile$ = 16						; size = 4
_cpcLine$ = 20						; size = 4
_fnSysWriteLine@16 PROC

; 5911 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 5912 :    zLONG      lLth;
; 5913 :    zPCHAR     lpWriteBuffer;
; 5914 :    LPOPENFILE lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 5915 : 
; 5916 :    // Get the task an match up the file handle passed with an
; 5917 :    // OpenFile record. If the record is not found, return a zCALL_ERROR;
; 5918 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN6@fnSysWrite

; 5919 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysWrite
$LN6@fnSysWrite:

; 5920 : 
; 5921 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $LN7@fnSysWrite
	mov	eax, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@fnSysWrite

; 5922 :    {
; 5923 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	ecx, DWORD PTR _ppvFile$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpOpenFile$[ebp], edx

; 5924 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $LN7@fnSysWrite

; 5925 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$LN7@fnSysWrite:

; 5926 :    }
; 5927 : 
; 5928 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN9@fnSysWrite

; 5929 :    {
; 5930 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+118]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$LN2@fnSysWrite:

; 5931 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $LN9@fnSysWrite

; 5932 :       {
; 5933 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $LN10@fnSysWrite

; 5934 :             break;

	jmp	SHORT $LN9@fnSysWrite
$LN10@fnSysWrite:

; 5935 : 
; 5936 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5937 :       }

	jmp	SHORT $LN2@fnSysWrite
$LN9@fnSysWrite:

; 5938 :    }
; 5939 : 
; 5940 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN11@fnSysWrite

; 5941 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysWrite
$LN11@fnSysWrite:

; 5942 : 
; 5943 :    // Check to see if buffered WriteLines desired, if not, write it.
; 5944 :    if ( (lpOpenFile->nFlags & COREFILE_WRITELINE_BUFFERED) == 0 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 1
	jne	SHORT $LN12@fnSysWrite

; 5945 :    {
; 5946 :       fnSysWriteFile( lpTask, lFileHandle, cpcLine, zstrlen( cpcLine ) );

	mov	ecx, DWORD PTR _cpcLine$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteFile@16

; 5947 :       fnSysWriteFile( lpTask, lFileHandle, "\r\n", 2 );

	push	2
	push	OFFSET $SG99642
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16

; 5948 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSysWrite
$LN12@fnSysWrite:

; 5949 :    }
; 5950 : 
; 5951 :    // File found, get a file read buffer is necessary.
; 5952 :    if ( lpOpenFile->uWriteBufferSize == 0 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+546], 0
	jne	$LN13@fnSysWrite

; 5953 :    {
; 5954 :       lpOpenFile->uWriteBufferSize = 8192;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], 8192		; 00002000H
$LN4@fnSysWrite:

; 5955 :       while ( lpOpenFile->uWriteBufferSize > 2040 )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+546], 2040		; 000007f8H
	jbe	SHORT $LN5@fnSysWrite

; 5956 :       {
; 5957 :          lpOpenFile->hWriteBuffer =

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+546]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+554], eax

; 5958 :             fnAllocDataspace( lpTask->hFirstDataHeader,
; 5959 :                               lpOpenFile->uWriteBufferSize, 0, 0, 0 );
; 5960 :          if ( lpOpenFile->hWriteBuffer )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+554], 0
	je	SHORT $LN14@fnSysWrite

; 5961 :             break;

	jmp	SHORT $LN5@fnSysWrite
$LN14@fnSysWrite:

; 5962 : 
; 5963 :          lpOpenFile->uWriteBufferSize /= 2;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+546]
	shr	edx, 1
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+546], edx

; 5964 :       }

	jmp	SHORT $LN4@fnSysWrite
$LN5@fnSysWrite:

; 5965 : 
; 5966 :       if ( lpOpenFile->hWriteBuffer == 0 )  // if buffer acquisition failed

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+554], 0
	jne	SHORT $LN15@fnSysWrite

; 5967 :       {
; 5968 :          lpOpenFile->uWriteBufferSize = 0;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], 0

; 5969 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysWrite
$LN15@fnSysWrite:

; 5970 :       }
; 5971 : 
; 5972 :       // Bump size down by 2 for safety.
; 5973 :       lpOpenFile->uWriteBufferSize -= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+546]
	sub	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+546], ecx
$LN13@fnSysWrite:

; 5974 :    }
; 5975 : 
; 5976 :    lpWriteBuffer = zGETPTR( lpOpenFile->hWriteBuffer );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+554]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWriteBuffer$[ebp], eax

; 5977 : 
; 5978 :    // Get the length of the line to be written.
; 5979 :    lLth = zstrlen( cpcLine );

	mov	edx, DWORD PTR _cpcLine$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lLth$[ebp], eax

; 5980 : 
; 5981 :    // If there is not buffer room to write this line, write out the buffer
; 5982 :    // and reset position.
; 5983 :    if ( (zULONG) (lpOpenFile->uWriteBufferSize -
; 5984 :                   lpOpenFile->uWriteBufferPos) < (zULONG) (lLth + 2) )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+546]
	sub	edx, DWORD PTR [ecx+550]
	mov	eax, DWORD PTR _lLth$[ebp]
	add	eax, 2
	cmp	edx, eax
	jae	SHORT $LN16@fnSysWrite

; 5985 :    {
; 5986 :       fnSysWriteFile( lpTask, lFileHandle, lpWriteBuffer, lpOpenFile->uWriteBufferPos );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+550]
	push	edx
	mov	eax, DWORD PTR _lpWriteBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteFile@16

; 5987 :       lpOpenFile->uWriteBufferPos = 0;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+550], 0
$LN16@fnSysWrite:

; 5988 :    }
; 5989 : 
; 5990 :    // Copy the new line into the Buffer.
; 5991 :    zstrcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], cpcLine );

	mov	ecx, DWORD PTR _cpcLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpWriteBuffer$[ebp]
	add	eax, DWORD PTR [edx+550]
	push	eax
	call	_strcpy
	add	esp, 8

; 5992 :    lpOpenFile->uWriteBufferPos += lLth;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+550]
	add	edx, DWORD PTR _lLth$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+550], edx

; 5993 :    zstrcpy( &lpWriteBuffer[ lpOpenFile->uWriteBufferPos ], "\r\n" );

	push	OFFSET $SG99647
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpWriteBuffer$[ebp]
	add	edx, DWORD PTR [ecx+550]
	push	edx
	call	_strcpy
	add	esp, 8

; 5994 :    lpOpenFile->uWriteBufferPos += 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+550]
	add	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+550], ecx

; 5995 : 
; 5996 :    return( 0 );

	xor	eax, eax
$LN1@fnSysWrite:

; 5997 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysWriteLine@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lFileHandle$ = 12					; size = 4
_cpcBuffer$ = 16					; size = 4
_ulLth$ = 20						; size = 4
_SysWriteFile@16 PROC

; 5882 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5883 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysWriteFi
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysWriteFi
$LN3@SysWriteFi:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysWriteFi:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5884 : 
; 5885 :    return( fnSysWriteFile( lpTask, lFileHandle, cpcBuffer, ulLth ) );

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16

; 5886 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysWriteFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_ulWritten$ = -8					; size = 4
_lpOpenFile$1 = -4					; size = 4
_lpTask$ = 8						; size = 4
_lFileHandle$ = 12					; size = 4
_cpcBuffer$ = 16					; size = 4
_ulLth$ = 20						; size = 4
_fnSysWriteFile@16 PROC

; 5848 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5849 :    zULONG ulWritten;
; 5850 : 
; 5851 :    WriteFile( (HANDLE) lFileHandle, cpcBuffer, ulLth, &ulWritten, 0 );

	push	0
	lea	eax, DWORD PTR _ulWritten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__WriteFile@20

; 5852 : 
; 5853 :    if ( ulWritten != ulLth )

	mov	ecx, DWORD PTR _ulWritten$[ebp]
	cmp	ecx, DWORD PTR _ulLth$[ebp]
	je	SHORT $LN4@fnSysWrite

; 5854 :    {
; 5855 :       LPOPENFILE  lpOpenFile;
; 5856 : 
; 5857 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+118]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$1[ebp], eax
$LN2@fnSysWrite:

; 5858 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$1[ebp], 0
	je	SHORT $LN3@fnSysWrite

; 5859 :       {
; 5860 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$1[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $LN5@fnSysWrite

; 5861 :             break;

	jmp	SHORT $LN3@fnSysWrite
$LN5@fnSysWrite:

; 5862 : 
; 5863 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	eax, DWORD PTR _lpOpenFile$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$1[ebp], eax

; 5864 :       }

	jmp	SHORT $LN2@fnSysWrite
$LN3@fnSysWrite:

; 5865 : 
; 5866 :       if ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$1[ebp], 0
	je	SHORT $LN4@fnSysWrite

; 5867 :       {
; 5868 :          // "KZOEE022 - Error writing file"
; 5869 :          fnIssueCoreError( lpTask, 0, 8, 22, 0,

	push	0
	mov	edx, DWORD PTR _lpOpenFile$1[ebp]
	add	edx, 16					; 00000010H
	push	edx
	push	0
	push	22					; 00000016H
	push	8
	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN4@fnSysWrite:

; 5870 :                            lpOpenFile->szFileName, 0 );
; 5871 :       }
; 5872 :    }
; 5873 : 
; 5874 :    return( ulWritten );

	mov	eax, DWORD PTR _ulWritten$[ebp]

; 5875 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysWriteFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_uMilliseconds$ = 8					; size = 2
_SysWait@4 PROC

; 4367 : {

	push	ebp
	mov	ebp, esp

; 4368 :    Sleep( (DWORD) uMilliseconds );

	movzx	eax, WORD PTR _uMilliseconds$[ebp]
	push	eax
	call	DWORD PTR __imp__Sleep@4

; 4369 : }

	pop	ebp
	ret	4
_SysWait@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pch$ = -536						; size = 4
tv129 = -532						; size = 4
tv93 = -528						; size = 4
_dwAttr$ = -524						; size = 4
_szFullPath$ = -520					; size = 513
__$ArrayPad$ = -4					; size = 4
_pchPath$ = 8						; size = 4
_bDirectory$ = 12					; size = 2
_bCheckCreate$ = 16					; size = 2
_nMaxPathLth$ = 20					; size = 2
_SysValidDirOrFile@16 PROC

; 7860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 536				; 00000218H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7861 :    zPCHAR pch;
; 7862 :    zCHAR  szFullPath[ zMAX_FILESPEC_LTH + 1 ];
; 7863 :    DWORD  dwAttr;
; 7864 : 
; 7865 : // TraceLineS( "Checking dir = ", pchPath );
; 7866 : 
; 7867 :    if ( pchPath == 0 || *pchPath == 0 )

	cmp	DWORD PTR _pchPath$[ebp], 0
	je	SHORT $LN3@SysValidDi
	mov	eax, DWORD PTR _pchPath$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@SysValidDi
$LN3@SysValidDi:

; 7868 :       return( FALSE );     // no directory was specified

	xor	eax, eax
	jmp	$LN1@SysValidDi
$LN2@SysValidDi:

; 7869 : 
; 7870 :    if ( GetFullPathName( pchPath, nMaxPathLth, szFullPath, &pch ) == 0 )

	lea	edx, DWORD PTR _pch$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFullPath$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nMaxPathLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPath$[ebp]
	push	edx
	call	DWORD PTR __imp__GetFullPathNameA@16
	test	eax, eax
	jne	SHORT $LN4@SysValidDi

; 7871 :    {
; 7872 :       // "KZOEE025 - Error in directory specification"
; 7873 :       fnSysMessageBox( 0, "Zeidon Error",

	push	0
	push	OFFSET $SG100266
	push	OFFSET $SG100267
	push	0
	call	_fnSysMessageBox@16

; 7874 :                        "Error in directory specification", 0 );
; 7875 :    // fnIssueCoreError( 0, lpView, 16, 25, 0, pchPath, 0 );
; 7876 :       return( FALSE );

	xor	eax, eax
	jmp	$LN1@SysValidDi
$LN4@SysValidDi:

; 7877 :    }
; 7878 : 
; 7879 :    zstrncpy( pchPath, szFullPath, nMaxPathLth );

	movsx	eax, WORD PTR _nMaxPathLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFullPath$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPath$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 7880 :    pchPath[ nMaxPathLth - 1 ] = 0;              // Make sure null-term is there.

	movsx	eax, WORD PTR _nMaxPathLth$[ebp]
	mov	ecx, DWORD PTR _pchPath$[ebp]
	mov	BYTE PTR [ecx+eax-1], 0

; 7881 : 
; 7882 :    dwAttr = GetFileAttributes( szFullPath );

	lea	edx, DWORD PTR _szFullPath$[ebp]
	push	edx
	call	DWORD PTR __imp__GetFileAttributesA@4
	mov	DWORD PTR _dwAttr$[ebp], eax

; 7883 :    if ( dwAttr != -1 )

	cmp	DWORD PTR _dwAttr$[ebp], -1
	je	SHORT $LN5@SysValidDi

; 7884 :    {
; 7885 :       // Found a file or directory.  Is this what the user wants?
; 7886 :       if ( bDirectory )

	movsx	eax, WORD PTR _bDirectory$[ebp]
	test	eax, eax
	je	SHORT $LN6@SysValidDi

; 7887 :          return( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) != 0;

	mov	ecx, DWORD PTR _dwAttr$[ebp]
	and	ecx, 16					; 00000010H
	je	SHORT $LN12@SysValidDi
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN13@SysValidDi
$LN12@SysValidDi:
	mov	DWORD PTR tv93[ebp], 0
$LN13@SysValidDi:
	mov	ax, WORD PTR tv93[ebp]
	jmp	SHORT $LN1@SysValidDi
	jmp	SHORT $LN5@SysValidDi
$LN6@SysValidDi:

; 7888 :       else
; 7889 :          return( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) == 0;

	mov	edx, DWORD PTR _dwAttr$[ebp]
	and	edx, 16					; 00000010H
	jne	SHORT $LN14@SysValidDi
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN15@SysValidDi
$LN14@SysValidDi:
	mov	DWORD PTR tv129[ebp], 0
$LN15@SysValidDi:
	mov	ax, WORD PTR tv129[ebp]
	jmp	SHORT $LN1@SysValidDi
$LN5@SysValidDi:

; 7890 :    }
; 7891 : 
; 7892 :    // If we get here then the file/dir doesn't exist.  If the user is looking
; 7893 :    // for a file then just return.
; 7894 :    if ( bDirectory == FALSE )

	movsx	eax, WORD PTR _bDirectory$[ebp]
	test	eax, eax
	jne	SHORT $LN8@SysValidDi

; 7895 :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@SysValidDi
$LN8@SysValidDi:

; 7896 : 
; 7897 :    // We looked for a directory and it doesn't exist.  If user doesn't want us
; 7898 :    // to create it, return FALSE.
; 7899 :    if ( bCheckCreate == FALSE )

	movsx	ecx, WORD PTR _bCheckCreate$[ebp]
	test	ecx, ecx
	jne	SHORT $LN9@SysValidDi

; 7900 :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@SysValidDi
$LN9@SysValidDi:

; 7901 : 
; 7902 :    if ( CreateDirectory( szFullPath, 0 ) ) // created it so let's get out

	push	0
	lea	edx, DWORD PTR _szFullPath$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateDirectoryA@8
	test	eax, eax
	je	SHORT $LN10@SysValidDi

; 7903 :       return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@SysValidDi
$LN10@SysValidDi:

; 7904 : 
; 7905 :    // If we get here then there was an error trying to create the directory.
; 7906 :    // Pop up a message.
; 7907 :    // "KZOEE026 - Error creating directory "
; 7908 :    fnSysMessageBox( 0, "Zeidon Error", "Error creating directory", 0 );

	push	0
	push	OFFSET $SG100274
	push	OFFSET $SG100275
	push	0
	call	_fnSysMessageBox@16

; 7909 : // fnIssueCoreError( 0, lpView, 16, 26, 0, szFullPath, 0 );
; 7910 :    return( FALSE );

	xor	eax, eax
$LN1@SysValidDi:

; 7911 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysValidDirOrFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv77 = -8						; size = 4
tv71 = -4						; size = 4
_lpAddress$ = 8						; size = 4
_lLth$ = 12						; size = 4
_bWrite$ = 16						; size = 1
_SysValidAddress@12 PROC

; 3474 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3475 :    if ( bWrite )

	movzx	eax, BYTE PTR _bWrite$[ebp]
	test	eax, eax
	je	SHORT $LN2@SysValidAd

; 3476 :       return( !(IsBadWritePtr( lpAddress, (zUSHORT) lLth )) );

	movzx	ecx, WORD PTR _lLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpAddress$[ebp]
	push	edx
	call	DWORD PTR __imp__IsBadWritePtr@8
	test	eax, eax
	jne	SHORT $LN5@SysValidAd
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN6@SysValidAd
$LN5@SysValidAd:
	mov	DWORD PTR tv71[ebp], 0
$LN6@SysValidAd:
	mov	eax, DWORD PTR tv71[ebp]
	jmp	SHORT $LN1@SysValidAd
	jmp	SHORT $LN1@SysValidAd
$LN2@SysValidAd:

; 3477 :    else
; 3478 :       return( !(IsBadReadPtr( lpAddress, (zUSHORT) lLth )) );

	movzx	eax, WORD PTR _lLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpAddress$[ebp]
	push	ecx
	call	DWORD PTR __imp__IsBadReadPtr@8
	test	eax, eax
	jne	SHORT $LN7@SysValidAd
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN8@SysValidAd
$LN7@SysValidAd:
	mov	DWORD PTR tv77[ebp], 0
$LN8@SysValidAd:
	mov	eax, DWORD PTR tv77[ebp]
$LN1@SysValidAd:

; 3479 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysValidAddress@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pchParseValue$ = -1284					; size = 4
$T1 = -1280						; size = 4
_pvFileIn$ = -1276					; size = 4
_hFIn$ = -1272						; size = 4
_pchLine$ = -1268					; size = 4
_k$ = -1264						; size = 4
_pvFileOut$ = -1260					; size = 4
_hFOut$ = -1256						; size = 4
_lpTask$ = -1252					; size = 4
_szParmString$ = -1248					; size = 514
_szFileNameTmp$ = -732					; size = 257
_szFileName$ = -472					; size = 257
_szGroup$ = -212					; size = 80
_szParseName$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_cpcGroup$ = 8						; size = 4
_cpcParameter$ = 12					; size = 4
_cpcValue$ = 16						; size = 4
_SysUpdateZeidonIni@12 PROC

; 7664 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1284				; 00000504H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7665 :    LPTASK lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 7666 :    zPVOID pvFileIn;
; 7667 :    zPVOID pvFileOut;
; 7668 :    char   szParmString[ 2 * (zMAX_FILENAME_LTH  + 1) ];
; 7669 :    char   szFileName[ zMAX_FILENAME_LTH + 1 ];
; 7670 :    char   szFileNameTmp[ zMAX_FILENAME_LTH  + 1 ];
; 7671 :    char   szParseName[ 128 ];
; 7672 :    char   szGroup[ 80 ];
; 7673 :    zPCHAR pchLine;
; 7674 :    zPCHAR pchParseValue;
; 7675 :    zLONG  hFIn;
; 7676 :    zLONG  hFOut;
; 7677 :    int    k;
; 7678 : 
; 7679 :    // build the parameter to be written into ZEIDON.INI
; 7680 :    zsprintf( szParmString, "%s=%s", cpcParameter, cpcValue );

	mov	edx, DWORD PTR _cpcValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcParameter$[ebp]
	push	eax
	push	OFFSET $SG100213
	lea	ecx, DWORD PTR _szParmString$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 7681 : 
; 7682 :    k = fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_fnBuildZeidonIni
	add	esp, 8
	cwde
	mov	DWORD PTR _k$[ebp], eax

; 7683 :    zstrcpy( szFileNameTmp, szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileNameTmp$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7684 :    zstrcpy( szFileNameTmp + k, "zeidon.in~" );

	push	OFFSET $SG100214
	mov	eax, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szFileNameTmp$[ebp+eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 7685 :    hFIn = fnSysOpenFile( lpTask, szFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFIn$[ebp], eax

; 7686 : 
; 7687 :    // Add [] if not supplied.
; 7688 :    if ( cpcGroup[ 0 ] != '[' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcGroup$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 91					; 0000005bH
	je	SHORT $LN8@SysUpdateZ

; 7689 :       zsprintf( szGroup, "[%s]", cpcGroup );

	mov	edx, DWORD PTR _cpcGroup$[ebp]
	push	edx
	push	OFFSET $SG100217
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN9@SysUpdateZ
$LN8@SysUpdateZ:

; 7690 :    else
; 7691 :       zstrcpy( szGroup, cpcGroup );

	mov	ecx, DWORD PTR _cpcGroup$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szGroup$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN9@SysUpdateZ:

; 7692 : 
; 7693 :    // If the file does not exist, create one
; 7694 :    if ( hFIn == -1 )

	cmp	DWORD PTR _hFIn$[ebp], -1
	jne	$LN10@SysUpdateZ

; 7695 :    {
; 7696 :       pvFileOut = 0;

	mov	DWORD PTR _pvFileOut$[ebp], 0

; 7697 : 
; 7698 :       hFOut = fnSysOpenFile( lpTask, szFileName,

	push	33					; 00000021H
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFOut$[ebp], eax

; 7699 :                              COREFILE_CREATE | COREFILE_WRITELINE_BUFFERED );
; 7700 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Zeidon]" );

	push	OFFSET $SG100219
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7701 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET $SG100220
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7702 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Encyclopedia]" );

	push	OFFSET $SG100221
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7703 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET $SG100222
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7704 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Workstation]" );

	push	OFFSET $SG100223
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7705 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET $SG100224
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7706 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "[Object Services]" );

	push	OFFSET $SG100225
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7707 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );

	push	OFFSET $SG100226
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7708 :       fnSysCloseFile( lpTask, hFOut, 0 );

	push	0
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 7709 : 
; 7710 :       hFIn = fnSysOpenFile( lpTask, szFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFIn$[ebp], eax
$LN10@SysUpdateZ:

; 7711 :    }
; 7712 : 
; 7713 :    // Perform the Update to the temp file
; 7714 :    if ( hFIn != -1 )

	cmp	DWORD PTR _hFIn$[ebp], -1
	je	$LN11@SysUpdateZ

; 7715 :    {
; 7716 :       hFOut = fnSysOpenFile( lpTask, szFileNameTmp,

	push	33					; 00000021H
	lea	eax, DWORD PTR _szFileNameTmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFOut$[ebp], eax

; 7717 :                              COREFILE_CREATE | COREFILE_WRITELINE_BUFFERED );
; 7718 : 
; 7719 :       if ( hFOut == -1 )

	cmp	DWORD PTR _hFOut$[ebp], -1
	jne	SHORT $LN12@SysUpdateZ

; 7720 :       {
; 7721 :          fnSysCloseFile( lpTask, hFIn, 0 );

	push	0
	mov	edx, DWORD PTR _hFIn$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 7722 :          return;

	jmp	$LN20@SysUpdateZ
$LN12@SysUpdateZ:

; 7723 :       }
; 7724 : 
; 7725 :       pvFileIn = 0;

	mov	DWORD PTR _pvFileIn$[ebp], 0

; 7726 :       pvFileOut = 0;

	mov	DWORD PTR _pvFileOut$[ebp], 0

; 7727 :       szParseName[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 128			; 00000080H
	jae	SHORT $LN21@SysUpdateZ
	jmp	SHORT $LN22@SysUpdateZ
$LN21@SysUpdateZ:
	call	___report_rangecheckfailure
$LN22@SysUpdateZ:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szParseName$[ebp+eax], 0

; 7728 :       k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	ecx, DWORD PTR _pvFileIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFIn$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax
$LN2@SysUpdateZ:

; 7729 : 
; 7730 :       while ( k && zstrcmpi( szParseName, szGroup ) != 0 )

	cmp	DWORD PTR _k$[ebp], 0
	je	$LN3@SysUpdateZ
	lea	edx, DWORD PTR _szGroup$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParseName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN3@SysUpdateZ

; 7731 :       {
; 7732 :          SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchParseValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParseName$[ebp]
	push	eax
	call	_SysParseLine@12

; 7733 :          fnSysWriteLine( lpTask, hFOut, &pvFileOut, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16

; 7734 :          k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	edx, DWORD PTR _pvFileIn$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFIn$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7735 :       }

	jmp	$LN2@SysUpdateZ
$LN3@SysUpdateZ:

; 7736 : 
; 7737 :       // If the Group was not found, create it.
; 7738 :       if ( k == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $LN4@SysUpdateZ

; 7739 :       {
; 7740 :          fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" ); // write blank line

	push	OFFSET $SG100231
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 7741 :          fnSysWriteLine( lpTask, hFOut, &pvFileOut, szGroup );

	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvFileOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteLine@16

; 7742 :       }

	jmp	$LN14@SysUpdateZ
$LN4@SysUpdateZ:

; 7743 :       else
; 7744 :       while ( k )

	cmp	DWORD PTR _k$[ebp], 0
	je	$LN14@SysUpdateZ

; 7745 :       {
; 7746 :          // Group line has been found and rewritten, search for parameter
; 7747 :          // in the group.
; 7748 :          SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchParseValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParseName$[ebp]
	push	eax
	call	_SysParseLine@12

; 7749 :          if ( zstrcmpi( szParseName, cpcParameter ) == 0 )

	mov	ecx, DWORD PTR _cpcParameter$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szParseName$[ebp]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN15@SysUpdateZ

; 7750 :             break;

	jmp	$LN14@SysUpdateZ
	jmp	SHORT $LN16@SysUpdateZ
$LN15@SysUpdateZ:

; 7751 :          else
; 7752 :          if ( szParseName[ 0 ] == '[' )  // keep an eye out for another group

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szParseName$[ebp+ecx]
	cmp	edx, 91					; 0000005bH
	jne	SHORT $LN16@SysUpdateZ

; 7753 :          {
; 7754 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, szParmString );  // create new parm

	lea	eax, DWORD PTR _szParmString$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvFileOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteLine@16

; 7755 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, "" );            // write blank after parm

	push	OFFSET $SG100235
	lea	ecx, DWORD PTR _pvFileOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteLine@16

; 7756 :             zstrcpy( szParmString, pchLine );     // set string to nxt grp

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szParmString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7757 :             break;

	jmp	SHORT $LN14@SysUpdateZ
$LN16@SysUpdateZ:

; 7758 :          }
; 7759 : 
; 7760 :          // Don't rewrite blank lines while searching for parameter
; 7761 :          if ( szParseName[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szParseName$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN18@SysUpdateZ

; 7762 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, pchLine );

	mov	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pvFileOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteLine@16
$LN18@SysUpdateZ:

; 7763 : 
; 7764 :          k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	ecx, DWORD PTR _pvFileIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFIn$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7765 : 
; 7766 :       } // while ( k )...

	jmp	$LN4@SysUpdateZ
$LN14@SysUpdateZ:

; 7767 : 
; 7768 :       // Add parameter or rewrite next group line depending on the
; 7769 :       // outcome of parameter search above
; 7770 :       fnSysWriteLine( lpTask, hFOut, &pvFileOut, szParmString );

	lea	edx, DWORD PTR _szParmString$[ebp]
	push	edx
	lea	eax, DWORD PTR _pvFileOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFOut$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16
$LN6@SysUpdateZ:

; 7771 :       while ( k > 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jle	SHORT $LN7@SysUpdateZ

; 7772 :       {
; 7773 :          k = fnSysReadLine( lpTask, &pchLine, hFIn, &pvFileIn );

	lea	eax, DWORD PTR _pvFileIn$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFIn$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7774 :          if ( k )

	cmp	DWORD PTR _k$[ebp], 0
	je	SHORT $LN19@SysUpdateZ

; 7775 :             fnSysWriteLine( lpTask, hFOut, &pvFileOut, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pvFileOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFOut$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysWriteLine@16
$LN19@SysUpdateZ:

; 7776 :       }

	jmp	SHORT $LN6@SysUpdateZ
$LN7@SysUpdateZ:

; 7777 : 
; 7778 :       // Close Zeidon ini file
; 7779 :       fnSysCloseFile( lpTask, hFOut, 0 );

	push	0
	mov	edx, DWORD PTR _hFOut$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 7780 :       fnSysCloseFile( lpTask, hFIn, 0 );

	push	0
	mov	ecx, DWORD PTR _hFIn$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12
$LN11@SysUpdateZ:

; 7781 :    }
; 7782 : 
; 7783 :    // replace old ZEIDON.INI with updated temp ZEIDON.IN~
; 7784 :    fnSysOpenFile( lpTask, szFileName, COREFILE_DELETE );

	push	8
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12

; 7785 :    zstrcpy( szParmString, szFileNameTmp );

	lea	edx, DWORD PTR _szFileNameTmp$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParmString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7786 :    zstrcpy( &szParmString[ zstrlen( szParmString ) + 1 ], szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szParmString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szParmString$[ebp+eax+1]
	push	eax
	call	_strcpy
	add	esp, 8

; 7787 :    fnSysOpenFile( lpTask, szParmString, COREFILE_RENAME );

	push	16					; 00000010H
	lea	ecx, DWORD PTR _szParmString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
$LN20@SysUpdateZ:

; 7788 : 
; 7789 : } // SysUpdateZeidonIni

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysUpdateZeidonIni@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_hFile$ = 12						; size = 4
_SysTruncateFile@8 PROC

; 6536 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6537 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysTruncat
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysTruncat
$LN3@SysTruncat:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysTruncat:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6538 : 
; 6539 :    return( fnSysTruncateFile( lpTask, hFile ) );

	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysTruncateFile@8

; 6540 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysTruncateFile@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_hFile$ = 12						; size = 4
_fnSysTruncateFile@8 PROC

; 6529 : {

	push	ebp
	mov	ebp, esp

; 6530 :    SysPositionFile( hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	_SysPositionFile@8

; 6531 :    return( fnSysWriteFile( lpTask, hFile, "", 0 ) );

	push	0
	push	OFFSET $SG99842
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteFile@16

; 6532 : }

	pop	ebp
	ret	8
_fnSysTruncateFile@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pchString$ = 8						; size = 4
_cUpperLower$ = 12					; size = 1
_SysTranslateString@8 PROC

; 6876 : {

	push	ebp
	mov	ebp, esp

; 6877 :    if ( cUpperLower == 'L' )

	movsx	eax, BYTE PTR _cUpperLower$[ebp]
	cmp	eax, 76					; 0000004cH
	jne	SHORT $LN2@SysTransla

; 6878 :       CharLower( pchString );

	mov	ecx, DWORD PTR _pchString$[ebp]
	push	ecx
	call	DWORD PTR __imp__CharLowerA@4
	jmp	SHORT $LN1@SysTransla
$LN2@SysTransla:

; 6879 :    else
; 6880 :       CharUpper( pchString );

	mov	edx, DWORD PTR _pchString$[ebp]
	push	edx
	call	DWORD PTR __imp__CharUpperA@4
$LN1@SysTransla:

; 6881 : }

	pop	ebp
	ret	8
_SysTranslateString@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_idx$ = 8						; size = 2
_SysStartTimer@4 PROC

; 8055 : {

	push	ebp
	mov	ebp, esp

; 8056 :    g_lTable[ idx ] = GetTickCount( );

	call	DWORD PTR __imp__GetTickCount@0
	movzx	ecx, WORD PTR _idx$[ebp]
	mov	DWORD PTR _g_lTable[ecx*4], eax

; 8057 : }

	pop	ebp
	ret	4
_SysStartTimer@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv75 = -320						; size = 4
tv74 = -316						; size = 4
_hwnd$ = -312						; size = 4
_lContextID$ = -308					; size = 4
_szFileName$ = -304					; size = 300
__$ArrayPad$ = -4					; size = 4
_pchHelpFile$ = 8					; size = 4
_pchContextID$ = 12					; size = 4
_SysStartHelp@8 PROC

; 7934 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7935 :    char  szFileName[ 300 ];
; 7936 :    zLONG lContextID;
; 7937 :    HWND  hwnd;
; 7938 : 
; 7939 :    if ( zstrcmp( pchHelpFile, "SYSTEM HELP" ) == 0 )

	mov	eax, DWORD PTR _pchHelpFile$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG100297
	cmp	ecx, edx
	jne	SHORT $LN16@SysStartHe
	push	OFFSET $SG100298
	mov	eax, DWORD PTR _pchHelpFile$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN17@SysStartHe
$LN16@SysStartHe:
	mov	ecx, DWORD PTR _pchHelpFile$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG100299
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN14@SysStartHe
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN15@SysStartHe
$LN14@SysStartHe:
	mov	DWORD PTR tv74[ebp], -1
$LN15@SysStartHe:
	mov	ecx, DWORD PTR tv74[ebp]
	mov	DWORD PTR tv75[ebp], ecx
$LN17@SysStartHe:
	cmp	DWORD PTR tv75[ebp], 0
	jne	SHORT $LN2@SysStartHe

; 7940 :    {
; 7941 :       // Build the file name for the help file.
; 7942 :       zstrcpy( szFileName, "winhelp.hlp" );

	push	OFFSET $SG100300
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7943 : 
; 7944 :       // For calling HelpOnHelp use function Winhelp because there is
; 7945 :       // no compressed Helpfile for this available.
; 7946 :       if ( pchContextID == 0  )

	cmp	DWORD PTR _pchContextID$[ebp], 0
	jne	SHORT $LN4@SysStartHe

; 7947 :       {
; 7948 :          if ( WinHelp( 0, szFileName, HELP_CONTENTS, 0  ) == 0 )

	push	0
	push	3
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__WinHelpA@16
	test	eax, eax
	jne	SHORT $LN6@SysStartHe

; 7949 :          {
; 7950 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysStartHe
$LN6@SysStartHe:

; 7951 :          }
; 7952 :       }

	jmp	SHORT $LN5@SysStartHe
$LN4@SysStartHe:

; 7953 :       else
; 7954 :       {
; 7955 :          lContextID = zatol( pchContextID );

	mov	ecx, DWORD PTR _pchContextID$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lContextID$[ebp], eax

; 7956 :          if ( WinHelp( 0, szFileName, HELP_CONTEXT, lContextID  ) == 0 )

	mov	edx, DWORD PTR _lContextID$[ebp]
	push	edx
	push	1
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__WinHelpA@16
	test	eax, eax
	jne	SHORT $LN5@SysStartHe

; 7957 :          {
; 7958 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysStartHe
$LN5@SysStartHe:

; 7959 :          }
; 7960 :       }
; 7961 :    }

	jmp	$LN3@SysStartHe
$LN2@SysStartHe:

; 7962 :    else
; 7963 :    {
; 7964 :       // Build the file name for the help file.
; 7965 :       zstrcpy( szFileName, pchHelpFile );

	mov	ecx, DWORD PTR _pchHelpFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 7966 :       zstrupper( szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp___strupr
	add	esp, 4

; 7967 :       if ( zstrstr( szFileName, ".CHM" ) == 0 )

	push	OFFSET $SG100306
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN8@SysStartHe

; 7968 :          zstrcat( szFileName, ".CHM" );

	push	OFFSET $SG100307
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN8@SysStartHe:

; 7969 : 
; 7970 :       zstrcat( szFileName, ">mainwin");

	push	OFFSET $SG100308
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 7971 : 
; 7972 :       // If entering help at the table of contents ...
; 7973 :       if ( pchContextID == 0  )

	cmp	DWORD PTR _pchContextID$[ebp], 0
	jne	SHORT $LN9@SysStartHe

; 7974 :       {
; 7975 :          TraceLineS( "(sy) Starting help with: ", szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET $SG100311
	call	_TraceLineS@8

; 7976 :          hwnd = HtmlHelp( GetDesktopWindow( ),

	push	0
	push	0
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	_HtmlHelpA@16
	mov	DWORD PTR _hwnd$[ebp], eax

; 7977 :                           (LPCSTR) szFileName,
; 7978 :                           HH_DISPLAY_TOPIC, (DWORD) 0 );
; 7979 :          if ( hwnd == NULL )

	cmp	DWORD PTR _hwnd$[ebp], 0
	jne	SHORT $LN11@SysStartHe

; 7980 :          {
; 7981 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysStartHe
$LN11@SysStartHe:

; 7982 :          }
; 7983 :       }

	jmp	SHORT $LN3@SysStartHe
$LN9@SysStartHe:

; 7984 :       // ... otherwise, start context-sensitive help.
; 7985 :       else
; 7986 :       {
; 7987 :          TraceLineS( "(sy) Starting context-sensitive help with: ",

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	OFFSET $SG100313
	call	_TraceLineS@8

; 7988 :                      szFileName );
; 7989 :          lContextID = zatol( pchContextID );

	mov	ecx, DWORD PTR _pchContextID$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lContextID$[ebp], eax

; 7990 : 
; 7991 :          HtmlHelp( GetDesktopWindow( ), szFileName,

	mov	edx, DWORD PTR _lContextID$[ebp]
	push	edx
	push	15					; 0000000fH
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	_HtmlHelpA@16

; 7992 :                    HH_HELP_CONTEXT, lContextID);
; 7993 :          hwnd = HtmlHelp( GetDesktopWindow( ), szFileName,

	push	OFFSET $SG100314
	push	6
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	_HtmlHelpA@16
	mov	DWORD PTR _hwnd$[ebp], eax

; 7994 :                           HH_GET_WIN_HANDLE, (DWORD) "MyWindowType" );
; 7995 :          if ( hwnd == NULL )

	cmp	DWORD PTR _hwnd$[ebp], 0
	jne	SHORT $LN3@SysStartHe

; 7996 :          {
; 7997 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysStartHe
$LN3@SysStartHe:

; 7998 :          }
; 7999 :       }
; 8000 :    }
; 8001 : 
; 8002 :    return( 0 );

	xor	eax, eax
$LN1@SysStartHe:

; 8003 : } // SysStartHelp

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_SysStartHelp@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szMsg$ = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_cpcUserID$ = 12					; size = 4
_cpcPassword$ = 16					; size = 4
_SysSetUserID@12 PROC

; 4651 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4652 :    char szMsg[ 60 ];
; 4653 : 
; 4654 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN2@SysSetUser

; 4655 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysSetUser
$LN2@SysSetUser:

; 4656 : 
; 4657 :    if ( lpTask && zGETHNDL( lpTask ) != AnchorBlock->hMainTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN3@SysSetUser
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [ecx+106]
	je	$LN3@SysSetUser

; 4658 :    {
; 4659 :       lpTask->hUserID = fnFreeDataspace( zGETPTR( lpTask->hUserID ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 4660 :       lpTask->hPassword = fnFreeDataspace( zGETPTR( lpTask->hPassword ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 4661 :       if ( cpcUserID[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcUserID$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN5@SysSetUser

; 4662 :       {
; 4663 :          lpTask->hUserID =

	mov	eax, DWORD PTR _cpcUserID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+32], eax
$LN5@SysSetUser:

; 4664 :           fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcUserID );
; 4665 :       }
; 4666 : 
; 4667 :       if ( cpcPassword[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcPassword$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN6@SysSetUser

; 4668 :       {
; 4669 :          lpTask->hPassword =

	mov	ecx, DWORD PTR _cpcPassword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN6@SysSetUser:

; 4670 :          fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcPassword );
; 4671 :       }
; 4672 :    }

	jmp	$LN4@SysSetUser
$LN3@SysSetUser:

; 4673 :    else
; 4674 :    {
; 4675 :       zstrcpy( AnchorBlock->szUserID, AnchorBlock->szUserID );

	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1423				; 0000058fH
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1423				; 0000058fH
	push	eax
	call	_strcpy
	add	esp, 8

; 4676 :       zstrcpy( AnchorBlock->szPassword, AnchorBlock->szPassword );

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 1456				; 000005b0H
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1456				; 000005b0H
	push	edx
	call	_strcpy
	add	esp, 8

; 4677 :       if ( cpcUserID[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcUserID$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN7@SysSetUser

; 4678 :          zstrcpy( AnchorBlock->szUserID, cpcUserID );

	mov	ecx, DWORD PTR _cpcUserID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1423				; 0000058fH
	push	edx
	call	_strcpy
	add	esp, 8
$LN7@SysSetUser:

; 4679 : 
; 4680 :       if ( cpcPassword[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcPassword$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN4@SysSetUser

; 4681 :          zstrcpy( AnchorBlock->szPassword, cpcPassword );

	mov	ecx, DWORD PTR _cpcPassword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AnchorBlock
	add	edx, 1456				; 000005b0H
	push	edx
	call	_strcpy
	add	esp, 8
$LN4@SysSetUser:

; 4682 :    }
; 4683 : 
; 4684 :    // Send UserID to list box
; 4685 :    zstrcpy( szMsg, "(sy) Logon Userid=" );

	push	OFFSET $SG99211
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4686 :    zstrcat( szMsg, (zPCHAR) cpcUserID );

	mov	ecx, DWORD PTR _cpcUserID$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 4687 :    SysMessageList( szMsg );

	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_SysMessageList@4

; 4688 :    return( 0 );

	xor	eax, eax
$LN1@SysSetUser:

; 4689 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetUserID@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpInternational$ = -4					; size = 4
_nLanguageCode$ = 8					; size = 2
_SysSetLanguageCode@4 PROC

; 1839 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1840 :    LPINTERNATIONAL lpInternational;
; 1841 : 
; 1842 :    lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2515]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$[ebp], eax

; 1843 :    lpInternational->nLanguage = nLanguageCode;

	mov	edx, DWORD PTR _lpInternational$[ebp]
	mov	ax, WORD PTR _nLanguageCode$[ebp]
	mov	WORD PTR [edx+70], ax

; 1844 : 
; 1845 :    return( 0 );

	xor	eax, eax

; 1846 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysSetLanguageCode@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_vTaskView$ = 8						; size = 4
_SysSetDefaultTaskForProcess@4 PROC

; 539  : {

	push	ebp
	mov	ebp, esp

; 540  :    SysMessageBox( vTaskView, "Zeidon Object Services",

	push	0
	push	OFFSET $SG98045
	push	OFFSET $SG98046
	mov	eax, DWORD PTR _vTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 541  :                   "SysSetDefaultTaskForProcess Deprecated", 0 );
; 542  :    return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysSetDefa

; 543  : 
; 544  :    if ( g_vDefaultTaskView && vTaskView )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	SHORT $LN2@SysSetDefa
	cmp	DWORD PTR _vTaskView$[ebp], 0
	je	SHORT $LN2@SysSetDefa

; 545  :    {
; 546  :       SysMessageBox( vTaskView, "Zeidon Object Services",

	push	0
	push	OFFSET $SG98048
	push	OFFSET $SG98049
	mov	ecx, DWORD PTR _vTaskView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 547  :                      "Process already has a default task view", 0 );
; 548  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysSetDefa
$LN2@SysSetDefa:

; 549  :    }
; 550  : 
; 551  :    g_vDefaultTaskView = vTaskView;

	mov	edx, DWORD PTR _vTaskView$[ebp]
	mov	DWORD PTR _g_vDefaultTaskView, edx

; 552  :    return( 0 );

	xor	eax, eax
$LN1@SysSetDefa:

; 553  : }

	pop	ebp
	ret	4
_SysSetDefaultTaskForProcess@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_lpView$ = 8						; size = 4
_cpcUserID$ = 12					; size = 4
_cpcPassword$ = 16					; size = 4
_SysSetDB_UserID@12 PROC

; 4710 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4711 :    LPTASK lpTask;
; 4712 : 
; 4713 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN2@SysSetDB_U

; 4714 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysSetDB_U
$LN2@SysSetDB_U:

; 4715 : 
; 4716 :    lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4717 :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN3@SysSetDB_U

; 4718 :    {
; 4719 :       lpTask->hDBUserID = fnFreeDataspace( zGETPTR( lpTask->hDBUserID ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+40], eax

; 4720 :       lpTask->hDBPassword = fnFreeDataspace( zGETPTR( lpTask->hDBPassword ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+44], eax

; 4721 :       if ( cpcUserID[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcUserID$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN4@SysSetDB_U

; 4722 :       {
; 4723 :          lpTask->hDBUserID =

	mov	eax, DWORD PTR _cpcUserID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+40], eax
$LN4@SysSetDB_U:

; 4724 :            fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcUserID );
; 4725 :       }
; 4726 : 
; 4727 :       if ( cpcPassword[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcPassword$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN3@SysSetDB_U

; 4728 :       {
; 4729 :          lpTask->hDBPassword =

	mov	ecx, DWORD PTR _cpcPassword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+44], eax
$LN3@SysSetDB_U:

; 4730 :          fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock, cpcPassword );
; 4731 :       }
; 4732 :    }
; 4733 : 
; 4734 :    return( 0 );

	xor	eax, eax
$LN1@SysSetDB_U:

; 4735 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetDB_UserID@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_ftTime$ = -564						; size = 8
$T1 = -556						; size = 4
_hFile$ = -552						; size = 4
_SysTime$ = -548					; size = 16
_szFileName$ = -532					; size = 513
_szTemp$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_cpcFileName$ = 8					; size = 4
_cpcDateTime$ = 12					; size = 4
_lControl$ = 16						; size = 4
_SysSetFileTime@12 PROC

; 6338 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 564				; 00000234H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6339 :    FILETIME   ftTime;
; 6340 :    SYSTEMTIME SysTime;
; 6341 :    HANDLE     hFile;
; 6342 :    zCHAR      szTemp[ 10 ];
; 6343 :    zCHAR      szFileName[ zMAX_FILESPEC_LTH + 1 ];
; 6344 : 
; 6345 :    zstrncpy( szTemp, cpcDateTime, 4 );

	push	4
	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6346 :    szTemp[ 4 ] = 0;

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 10			; 0000000aH
	jae	SHORT $LN4@SysSetFile
	jmp	SHORT $LN5@SysSetFile
$LN4@SysSetFile:
	call	___report_rangecheckfailure
$LN5@SysSetFile:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szTemp$[ebp+eax], 0

; 6347 :    SysTime.wYear         = (WORD) atoi( szTemp );

	lea	ecx, DWORD PTR _szTemp$[ebp]
	push	ecx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	WORD PTR _SysTime$[ebp], ax

; 6348 :    SysTime.wMonth        = CONVERT_2_DIGITS( cpcDateTime + 4 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+5]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	WORD PTR _SysTime$[ebp+2], cx

; 6349 :    SysTime.wDay          = CONVERT_2_DIGITS( cpcDateTime + 6 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+7]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	WORD PTR _SysTime$[ebp+6], cx

; 6350 :    SysTime.wHour         = CONVERT_2_DIGITS( cpcDateTime + 8 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+8]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+9]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	WORD PTR _SysTime$[ebp+8], cx

; 6351 :    SysTime.wMinute       = CONVERT_2_DIGITS( cpcDateTime + 10 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+11]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	WORD PTR _SysTime$[ebp+10], cx

; 6352 :    SysTime.wSecond       = CONVERT_2_DIGITS( cpcDateTime + 12 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+12]
	sub	eax, 48					; 00000030H
	imul	ecx, eax, 10
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	movsx	eax, BYTE PTR [edx+13]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	WORD PTR _SysTime$[ebp+12], cx

; 6353 :    SysTime.wMilliseconds = (WORD) atoi( cpcDateTime + 14 );

	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	WORD PTR _SysTime$[ebp+14], ax

; 6354 :    SystemTimeToFileTime( &SysTime, &ftTime );

	lea	eax, DWORD PTR _ftTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _SysTime$[ebp]
	push	ecx
	call	DWORD PTR __imp__SystemTimeToFileTime@8

; 6355 : 
; 6356 :    SysConvertEnvironmentString( szFileName, cpcFileName );

	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 6357 :    hFile = CreateFile( szFileName, GENERIC_WRITE, FILE_SHARE_READ, 0,

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax

; 6358 :                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0 );
; 6359 :    if ( hFile == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN2@SysSetFile

; 6360 :    {
; 6361 :       TraceLineS( "SysSetFileTime: Couldn't open file ", szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	OFFSET $SG99792
	call	_TraceLineS@8

; 6362 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN3@SysSetFile
$LN2@SysSetFile:

; 6363 :    }
; 6364 : 
; 6365 :    SetFileTime( hFile, 0, 0, &ftTime );

	lea	eax, DWORD PTR _ftTime$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetFileTime@16

; 6366 :    CloseHandle( hFile );

	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 6367 :    return( 0 );

	xor	eax, eax
$LN3@SysSetFile:

; 6368 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetFileTime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_wParam$ = 8						; size = 4
_lParam$ = 12						; size = 4
_SysSendOE_Message@8 PROC

; 8144 : {

	push	ebp
	mov	ebp, esp

; 8145 : #ifdef __MUTEX_DEBUG__
; 8146 :    // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 8147 :    fnPrintMutexInfo( 's', zMUTEX_COUNT, __FILE__, __LINE__ );
; 8148 : #endif
; 8149 : 
; 8150 :    return( SendMessage( (HWND) AnchorBlock->lOE_hMainWnd,

	mov	eax, DWORD PTR _lParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	push	273					; 00000111H
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__SendMessageA@16

; 8151 :                         WM_COMMAND, wParam, lParam ) );
; 8152 : 
; 8153 : #ifdef __MUTEX_DEBUG__
; 8154 :    // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 8155 :    fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 8156 : #endif
; 8157 : }

	pop	ebp
	ret	8
_SysSendOE_Message@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_pchFileSpecFrom$ = 12					; size = 4
_pchFileSpecTo$ = 16					; size = 4
_bOverwrite$ = 20					; size = 1
_SysRenameFile@16 PROC

; 5045 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5046 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysRenameF
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysRenameF
$LN3@SysRenameF:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysRenameF:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5047 : 
; 5048 :    return( fnSysRenameFile( lpTask, pchFileSpecFrom,

	movzx	eax, BYTE PTR _bOverwrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchFileSpecFrom$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysRenameFile@16

; 5049 :                             pchFileSpecTo, bOverwrite ) );
; 5050 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysRenameFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_dw$1 = -8						; size = 4
_pchMsg$2 = -4						; size = 4
_lpTask$ = 8						; size = 4
_pchFileSpecFrom$ = 12					; size = 4
_pchFileSpecTo$ = 16					; size = 4
_bOverwrite$ = 20					; size = 1
_fnSysRenameFile@16 PROC

; 5005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5006 :    if ( fnSysOpenFile( lpTask, pchFileSpecFrom, COREFILE_EXIST ) < 0 )

	push	4
	mov	eax, DWORD PTR _pchFileSpecFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12
	test	eax, eax
	jge	SHORT $LN2@fnSysRenam

; 5007 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnSysRenam
$LN2@fnSysRenam:

; 5008 : 
; 5009 :    if ( fnSysOpenFile( lpTask, pchFileSpecTo, COREFILE_EXIST ) >= 0 )

	push	4
	mov	edx, DWORD PTR _pchFileSpecTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	test	eax, eax
	jl	SHORT $LN3@fnSysRenam

; 5010 :    {
; 5011 :       if ( bOverwrite == FALSE )

	movzx	ecx, BYTE PTR _bOverwrite$[ebp]
	test	ecx, ecx
	jne	SHORT $LN4@fnSysRenam

; 5012 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnSysRenam
$LN4@fnSysRenam:

; 5013 : 
; 5014 :       // Delete the new name if it already exists.
; 5015 :    // if ( fnSysOpenFile( lpTask, pchFileSpecTo, COREFILE_DELETE ) == -1 )
; 5016 :       if ( fnSysOpenFile( lpTask, pchFileSpecTo, COREFILE_DELETE ) == zCALL_ERROR )

	push	8
	mov	edx, DWORD PTR _pchFileSpecTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN3@fnSysRenam

; 5017 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysRenam
$LN3@fnSysRenam:

; 5018 :    }
; 5019 : 
; 5020 :    if ( !MoveFile( pchFileSpecFrom, pchFileSpecTo ) )

	mov	ecx, DWORD PTR _pchFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchFileSpecFrom$[ebp]
	push	edx
	call	DWORD PTR __imp__MoveFileA@8
	test	eax, eax
	jne	SHORT $LN6@fnSysRenam

; 5021 :    {
; 5022 :       zPCHAR pchMsg;
; 5023 :       DWORD dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$1[ebp], eax

; 5024 : 
; 5025 :       FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,

	push	0
	push	0
	lea	eax, DWORD PTR _pchMsg$2[ebp]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _dw$1[ebp]
	push	ecx
	push	0
	push	4352					; 00001100H
	call	DWORD PTR __imp__FormatMessageA@28

; 5026 :                      0, dw, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
; 5027 :                      (zPCHAR) &pchMsg, 0, 0 );
; 5028 :       TraceLine( "SysRenameFile MoveFile RC: %ld   FileSpecFrom: %s   "

	mov	edx, DWORD PTR _pchMsg$2[ebp]
	push	edx
	mov	eax, DWORD PTR _pchFileSpecTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchFileSpecFrom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dw$1[ebp]
	push	edx
	push	OFFSET $SG99327
	call	_TraceLine
	add	esp, 20					; 00000014H

; 5029 :                    "FileSpecTo: %s   Error: %s",
; 5030 :                  dw, pchFileSpecFrom, pchFileSpecTo, pchMsg );
; 5031 :       fnSysMessageBox( lpTask, "Zeidon MoveFile Error", pchMsg, 1 );

	push	1
	mov	eax, DWORD PTR _pchMsg$2[ebp]
	push	eax
	push	OFFSET $SG99328
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 5032 : 
; 5033 :       LocalFree( pchMsg ); // free the buffer

	mov	edx, DWORD PTR _pchMsg$2[ebp]
	push	edx
	call	DWORD PTR __imp__LocalFree@4

; 5034 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSysRenam
$LN6@fnSysRenam:

; 5035 :    }
; 5036 : 
; 5037 :    return( 1 );

	mov	eax, 1
$LN1@fnSysRenam:

; 5038 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysRenameFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
$T1 = -552						; size = 4
_nTrys$2 = -548						; size = 4
_pvFile$ = -544						; size = 4
_k$ = -540						; size = 4
_pchLine$ = -536					; size = 4
_pchLineValue$ = -532					; size = 4
_lpTask$ = -528						; size = 4
_pchParseValue$ = -524					; size = 4
_szFileName$3 = -520					; size = 257
_szGroup$ = -260					; size = 128
_szParseName$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_hFile$ = 8						; size = 4
_cpcGroup$ = 12						; size = 4
_pchParameter$ = 16					; size = 4
_pchValue$ = 20						; size = 4
_SysReadZeidonIni@16 PROC

; 7491 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 552				; 00000228H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 7492 :    LPTASK lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 7493 :    zPVOID pvFile;
; 7494 :    char   szParseName[ 128 ];
; 7495 :    char   szGroup[ 128 ];
; 7496 :    zPCHAR pchLine;   // SysReadLine will allocate the buffer
; 7497 :    zPCHAR pchParseValue;
; 7498 :    zPCHAR pchLineValue;
; 7499 :    int    k;
; 7500 : 
; 7501 :    // Initialize output value to null.
; 7502 :    pchValue[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchValue$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 7503 : 
; 7504 :    // If Anchor block doesn't exist, abandon.
; 7505 :    if ( AnchorBlock == 0 || lpTask == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN17@SysReadZei
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN16@SysReadZei
$LN17@SysReadZei:

; 7506 :       return( -1 );

	or	eax, -1
	jmp	$LN35@SysReadZei
$LN16@SysReadZei:

; 7507 : 
; 7508 :    // Add [] if not supplied.
; 7509 :    if ( cpcGroup[ 0 ] != '[' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcGroup$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 91					; 0000005bH
	je	SHORT $LN18@SysReadZei

; 7510 :       zsprintf( szGroup, "[%s]", cpcGroup );

	mov	eax, DWORD PTR _cpcGroup$[ebp]
	push	eax
	push	OFFSET $SG100169
	lea	ecx, DWORD PTR _szGroup$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN19@SysReadZei
$LN18@SysReadZei:

; 7511 :    else
; 7512 :       zstrcpy( szGroup, cpcGroup );

	mov	edx, DWORD PTR _cpcGroup$[ebp]
	push	edx
	lea	eax, DWORD PTR _szGroup$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN19@SysReadZei:

; 7513 : 
; 7514 :    // If this is not a repeated read, open the file.
; 7515 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	$LN20@SysReadZei

; 7516 :    {
; 7517 :       char szFileName[ zMAX_FILENAME_LTH + 1 ];
; 7518 :       int nTrys = 0;

	mov	DWORD PTR _nTrys$2[ebp], 0

; 7519 : 
; 7520 :       fnBuildZeidonIni( szFileName, sizeof( szFileName ) );

	push	257					; 00000101H
	lea	ecx, DWORD PTR _szFileName$3[ebp]
	push	ecx
	call	_fnBuildZeidonIni
	add	esp, 8

; 7521 :       hFile = fnSysOpenFile( lpTask, szFileName, COREFILE_READ );

	push	128					; 00000080H
	lea	edx, DWORD PTR _szFileName$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 7522 :       if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN22@SysReadZei

; 7523 :          return( hFile );

	mov	eax, DWORD PTR _hFile$[ebp]
	jmp	$LN35@SysReadZei
$LN22@SysReadZei:

; 7524 : 
; 7525 :       // Find the group to be processed.
; 7526 :       pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 7527 :       szParseName[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 128			; 00000080H
	jae	SHORT $LN36@SysReadZei
	jmp	SHORT $LN37@SysReadZei
$LN36@SysReadZei:
	call	___report_rangecheckfailure
$LN37@SysReadZei:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szParseName$[ebp+eax], 0
$LN2@SysReadZei:

; 7528 :       while ( ((k = fnSysReadLine( lpTask, &pchLine,
; 7529 :                                    hFile, &pvFile )) == zCALL_ERROR ||
; 7530 :                pchLine == 0) && nTrys < 5 )

	lea	ecx, DWORD PTR _pvFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax
	cmp	DWORD PTR _k$[ebp], -16			; fffffff0H
	je	SHORT $LN23@SysReadZei
	cmp	DWORD PTR _pchLine$[ebp], 0
	jne	SHORT $LN3@SysReadZei
$LN23@SysReadZei:
	cmp	DWORD PTR _nTrys$2[ebp], 5
	jge	SHORT $LN3@SysReadZei

; 7531 :       {
; 7532 :          nTrys++;

	mov	edx, DWORD PTR _nTrys$2[ebp]
	add	edx, 1
	mov	DWORD PTR _nTrys$2[ebp], edx

; 7533 :       }

	jmp	SHORT $LN2@SysReadZei
$LN3@SysReadZei:

; 7534 : 
; 7535 :       if ( k == zCALL_ERROR || pchLine == 0 )

	cmp	DWORD PTR _k$[ebp], -16			; fffffff0H
	je	SHORT $LN25@SysReadZei
	cmp	DWORD PTR _pchLine$[ebp], 0
	jne	SHORT $LN4@SysReadZei
$LN25@SysReadZei:

; 7536 :       {
; 7537 :          // Some kind of error ... maybe task not "alive" yet.
; 7538 :          fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 7539 :          return( -1 );

	or	eax, -1
	jmp	$LN35@SysReadZei
$LN4@SysReadZei:

; 7540 :       }
; 7541 : 
; 7542 :       while ( k && zstrcmpi( szParseName, szGroup ) != 0 )

	cmp	DWORD PTR _k$[ebp], 0
	je	SHORT $LN5@SysReadZei
	lea	edx, DWORD PTR _szGroup$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParseName$[ebp]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN5@SysReadZei

; 7543 :       {
; 7544 :          SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	ecx, DWORD PTR _pchLine$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchParseValue$[ebp]
	push	edx
	lea	eax, DWORD PTR _szParseName$[ebp]
	push	eax
	call	_SysParseLine@12

; 7545 :          k = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	ecx, DWORD PTR _pvFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7546 :       }

	jmp	SHORT $LN4@SysReadZei
$LN5@SysReadZei:

; 7547 : 
; 7548 :       // If the Group was not found, close the file and return.
; 7549 :       if ( k == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	jne	SHORT $LN26@SysReadZei

; 7550 :       {
; 7551 :          fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 7552 :          pvFile = 0;

	mov	DWORD PTR _pvFile$[ebp], 0

; 7553 :          return( -1 );

	or	eax, -1
	jmp	$LN35@SysReadZei
$LN26@SysReadZei:

; 7554 :       }
; 7555 :    }

	jmp	SHORT $LN6@SysReadZei
$LN20@SysReadZei:

; 7556 :    else
; 7557 :    {
; 7558 :       // Read the next line if processing an already opened file.
; 7559 :       k = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	ecx, DWORD PTR _pvFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFile$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchLine$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax
$LN6@SysReadZei:

; 7560 :    }
; 7561 : 
; 7562 :    // The Group has been located and we have read the first line
; 7563 :    // following the Group identifier, look for the specified parameter.
; 7564 :    while ( k )

	cmp	DWORD PTR _k$[ebp], 0
	je	$LN7@SysReadZei

; 7565 :    {
; 7566 :       SysParseLine( szParseName, &pchParseValue, pchLine );

	mov	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchParseValue$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szParseName$[ebp]
	push	ecx
	call	_SysParseLine@12
$LN8@SysReadZei:

; 7567 : 
; 7568 :       // Remove blanks before Parse Value.
; 7569 :       while ( pchParseValue[ 0 ] == ' ' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParseValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN9@SysReadZei

; 7570 :          pchParseValue++;

	mov	eax, DWORD PTR _pchParseValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchParseValue$[ebp], eax
	jmp	SHORT $LN8@SysReadZei
$LN9@SysReadZei:

; 7571 : 
; 7572 :       // If the parameter name was not delimited by an equal sign '=',
; 7573 :       // search for an equal and bump past it.
; 7574 :       if ( pchParseValue[ 0 ] == '=' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParseValue$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 61					; 0000003dH
	jne	$LN27@SysReadZei

; 7575 :       {
; 7576 :          pchLineValue = pchLine;

	mov	edx, DWORD PTR _pchLine$[ebp]
	mov	DWORD PTR _pchLineValue$[ebp], edx
$LN10@SysReadZei:

; 7577 : 
; 7578 :          // Find first non-blank in line.
; 7579 :          while ( pchLineValue[ 0 ] == ' ' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLineValue$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN12@SysReadZei

; 7580 :             pchLineValue++;

	mov	ecx, DWORD PTR _pchLineValue$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLineValue$[ebp], ecx
	jmp	SHORT $LN10@SysReadZei
$LN12@SysReadZei:

; 7581 : 
; 7582 :          // Find first blank or '=' in line after first non-blank.
; 7583 :          while ( pchLineValue[ 0 ] != ' ' && pchLineValue[ 0 ] != '=' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLineValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN13@SysReadZei
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLineValue$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 61					; 0000003dH
	je	SHORT $LN13@SysReadZei

; 7584 :             pchLineValue++;

	mov	ecx, DWORD PTR _pchLineValue$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchLineValue$[ebp], ecx
	jmp	SHORT $LN12@SysReadZei
$LN13@SysReadZei:

; 7585 : 
; 7586 :          // If a space occurred after the parameter name and before the
; 7587 :          // '=' sign, then increment pchParseValue after the equal sign.
; 7588 :          if ( pchLineValue[ 0 ] != '=' )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLineValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 61					; 0000003dH
	je	SHORT $LN27@SysReadZei

; 7589 :          {
; 7590 :             pchParseValue++;

	mov	eax, DWORD PTR _pchParseValue$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchParseValue$[ebp], eax
$LN14@SysReadZei:

; 7591 : 
; 7592 :             // Remove blanks before Parse Value.
; 7593 :             while ( pchParseValue[ 0 ] == ' ' )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParseValue$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN27@SysReadZei

; 7594 :                pchParseValue++;

	mov	edx, DWORD PTR _pchParseValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchParseValue$[ebp], edx
	jmp	SHORT $LN14@SysReadZei
$LN27@SysReadZei:

; 7595 :          }
; 7596 :       }
; 7597 : 
; 7598 :       // If a new group was found, close file and return invalid file.
; 7599 :       if ( szParseName[ 0 ] == '[' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szParseName$[ebp+ecx]
	cmp	edx, 91					; 0000005bH
	jne	SHORT $LN29@SysReadZei

; 7600 :       {
; 7601 :          fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 7602 :          return( -1 );

	or	eax, -1
	jmp	$LN35@SysReadZei
$LN29@SysReadZei:

; 7603 :       }
; 7604 : 
; 7605 :       // If no parameter was passed and a parameter was found or
; 7606 :       // a parameter was passed and it matches the name found
; 7607 :       // select this parameter to return to the caller.
; 7608 :       if ( (pchParameter[ 0 ] == 0 && szParseName[ 0 ]) ||

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchParameter$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN32@SysReadZei
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szParseName$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN31@SysReadZei
$LN32@SysReadZei:
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szParseName$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN30@SysReadZei
	mov	eax, DWORD PTR _pchParameter$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szParseName$[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN30@SysReadZei
$LN31@SysReadZei:

; 7609 :            (szParseName[ 0 ] &&
; 7610 :             zstrcmpi( szParseName, pchParameter ) == 0) )
; 7611 :       {
; 7612 :          zstrcpy( pchValue, pchParseValue );

	mov	edx, DWORD PTR _pchParseValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchValue$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 7613 :          if ( pchParameter[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchParameter$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN33@SysReadZei

; 7614 :             zstrcpy( pchParameter, szParseName );

	lea	edx, DWORD PTR _szParseName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchParameter$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN34@SysReadZei
$LN33@SysReadZei:

; 7615 :          else
; 7616 :          {
; 7617 :             fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 7618 :             hFile = -1;

	mov	DWORD PTR _hFile$[ebp], -1
$LN34@SysReadZei:

; 7619 :          }
; 7620 : 
; 7621 :          return( hFile );

	mov	eax, DWORD PTR _hFile$[ebp]
	jmp	SHORT $LN35@SysReadZei
$LN30@SysReadZei:

; 7622 :       }
; 7623 : 
; 7624 :       // Get the next line from the zeidon.ini file.
; 7625 :       k = fnSysReadLine( lpTask, &pchLine, hFile, &pvFile );

	lea	eax, DWORD PTR _pvFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLine@16
	mov	DWORD PTR _k$[ebp], eax

; 7626 :    }

	jmp	$LN6@SysReadZei
$LN7@SysReadZei:

; 7627 : 
; 7628 :    // No luck finding the parameter, quit.
; 7629 :    fnSysCloseFile( lpTask, hFile, 0 );

	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 7630 :    return( -1 );

	or	eax, -1
$LN35@SysReadZei:

; 7631 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysReadZeidonIni@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lpReturnLine$ = 12					; size = 4
_lFileHandle$ = 16					; size = 4
_ulLth$ = 20						; size = 4
_SysReadLineLth@16 PROC

; 5819 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5820 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysReadLin
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysReadLin
$LN3@SysReadLin:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysReadLin:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5821 : 
; 5822 :    return( fnSysReadLineLth( lpTask, lpReturnLine, lFileHandle, 0, ulLth ) );

	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpReturnLine$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadLineLth@20

; 5823 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysReadLineLth@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpNewBuffer$ = -16					; size = 4
_hNewBuffer$1 = -12					; size = 4
_lpReadBuffer$ = -8					; size = 4
_lpOpenFile$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpReturnLine$ = 12					; size = 4
_lFileHandle$ = 16					; size = 4
_ppvFile$ = 20						; size = 4
_ulLth$ = 24						; size = 4
_fnSysReadLineLth@20 PROC

; 5692 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 5693 :    LPOPENFILE    lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 5694 :    zPCHAR        lpNewBuffer;
; 5695 :    zPCHAR        lpReadBuffer;
; 5696 : 
; 5697 :    *lpReturnLine = 0;

	mov	eax, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [eax], 0

; 5698 : 
; 5699 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $LN6@fnSysReadL
	mov	ecx, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@fnSysReadL

; 5700 :    {
; 5701 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	edx, DWORD PTR _ppvFile$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5702 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $LN6@fnSysReadL

; 5703 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$LN6@fnSysReadL:

; 5704 :    }
; 5705 : 
; 5706 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN8@fnSysReadL

; 5707 :    {
; 5708 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+118]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$LN2@fnSysReadL:

; 5709 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $LN8@fnSysReadL

; 5710 :       {
; 5711 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $LN9@fnSysReadL

; 5712 :             break;

	jmp	SHORT $LN8@fnSysReadL
$LN9@fnSysReadL:

; 5713 : 
; 5714 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5715 :       }

	jmp	SHORT $LN2@fnSysReadL
$LN8@fnSysReadL:

; 5716 :    }
; 5717 : 
; 5718 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN10@fnSysReadL

; 5719 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysReadL
$LN10@fnSysReadL:

; 5720 : 
; 5721 :    // File found, get a file read buffer if necessary.
; 5722 :    if ( lpOpenFile->uReadBufferSize == 0 )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+530], 0
	jne	$LN11@fnSysReadL

; 5723 :    {
; 5724 :       lpOpenFile->uReadBufferSize = 8192;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+530], 8192		; 00002000H
$LN4@fnSysReadL:

; 5725 :       while ( lpOpenFile->uReadBufferSize > 2040 )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+530], 2040		; 000007f8H
	jbe	SHORT $LN5@fnSysReadL

; 5726 :       {
; 5727 :          lpOpenFile->hReadBuffer =

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+530]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+542], eax

; 5728 :             fnAllocDataspace( lpTask->hFirstDataHeader,
; 5729 :                               lpOpenFile->uReadBufferSize, 0, 0, 0 );
; 5730 : 
; 5731 :          if ( lpOpenFile->hReadBuffer )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+542], 0
	je	SHORT $LN13@fnSysReadL

; 5732 :             break;

	jmp	SHORT $LN5@fnSysReadL
$LN13@fnSysReadL:

; 5733 : 
; 5734 :          lpOpenFile->uReadBufferSize /= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+530]
	shr	ecx, 1
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], ecx

; 5735 :       }

	jmp	SHORT $LN4@fnSysReadL
$LN5@fnSysReadL:

; 5736 : 
; 5737 :       if ( lpOpenFile->hReadBuffer == 0 )  // if buffer acquisition failed

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+542], 0
	jne	SHORT $LN14@fnSysReadL

; 5738 :       {
; 5739 :          lpOpenFile->uReadBufferSize = 0;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+530], 0

; 5740 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysReadL
$LN14@fnSysReadL:

; 5741 :       }
; 5742 : 
; 5743 :       lpReadBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+542]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpReadBuffer$[ebp], eax

; 5744 : 
; 5745 :       // Bump size down by 2 so we can safely null terminate lines
; 5746 :       lpOpenFile->uReadBufferSize -= 2;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	sub	edx, 2
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+530], edx

; 5747 : 
; 5748 :       // Read the first block of information into the buffer
; 5749 :       lpOpenFile->uReadBufferUsed = fnSysReadFile( lpTask,

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	push	edx
	mov	eax, DWORD PTR _lpReadBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadFile@16
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+534], eax

; 5750 :                                                    lpOpenFile->lFileHandle,
; 5751 :                                                    lpReadBuffer,
; 5752 :                                                    lpOpenFile->uReadBufferSize );
; 5753 :    }

	jmp	SHORT $LN12@fnSysReadL
$LN11@fnSysReadL:

; 5754 :    else
; 5755 :    {
; 5756 :       lpReadBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+542]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpReadBuffer$[ebp], eax
$LN12@fnSysReadL:

; 5757 :    }
; 5758 : 
; 5759 :    // See if buffer we are using is big enough to hold the blob we want to
; 5760 :    // read, if not, we're in big trouble.
; 5761 :    if ( lpOpenFile->uReadBufferSize < ulLth )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	cmp	edx, DWORD PTR _ulLth$[ebp]
	jae	$LN15@fnSysReadL

; 5762 :    {
; 5763 :       zPVOID hNewBuffer;
; 5764 : 
; 5765 :       hNewBuffer = fnAllocDataspace( lpTask->hFirstDataHeader, ulLth, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNewBuffer$1[ebp], eax

; 5766 :       if ( hNewBuffer == 0 )

	cmp	DWORD PTR _hNewBuffer$1[ebp], 0
	jne	SHORT $LN16@fnSysReadL

; 5767 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysReadL
$LN16@fnSysReadL:

; 5768 : 
; 5769 :       lpNewBuffer = zGETPTR( hNewBuffer );

	mov	eax, DWORD PTR _hNewBuffer$1[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewBuffer$[ebp], eax

; 5770 : 
; 5771 :       zmemcpy( lpNewBuffer, lpReadBuffer, lpOpenFile->uReadBufferSize );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	push	edx
	mov	eax, DWORD PTR _lpReadBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewBuffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 5772 :       fnFreeDataspace( zGETPTR( lpOpenFile->hReadBuffer ) );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+542]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 5773 :       lpReadBuffer = lpNewBuffer;

	mov	ecx, DWORD PTR _lpNewBuffer$[ebp]
	mov	DWORD PTR _lpReadBuffer$[ebp], ecx

; 5774 :       lpOpenFile->hReadBuffer = hNewBuffer;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _hNewBuffer$1[ebp]
	mov	DWORD PTR [edx+542], eax

; 5775 :       lpOpenFile->uReadBufferSize = ulLth;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR [ecx+530], edx

; 5776 :       lpOpenFile->uReadBufferUsed +=

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+530]
	sub	edx, DWORD PTR [ecx+534]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpReadBuffer$[ebp]
	add	ecx, DWORD PTR [eax+534]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	add	eax, DWORD PTR [edx+534]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+534], eax
$LN15@fnSysReadL:

; 5777 :             fnSysReadFile( lpTask, lpOpenFile->lFileHandle,
; 5778 :                            (zPCHAR) (lpReadBuffer + lpOpenFile->uReadBufferUsed),
; 5779 :                            (zULONG) (lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferUsed) );
; 5780 :    }
; 5781 : 
; 5782 :    // See if it is time to read more of the file in before continuing.
; 5783 :    if ( lpOpenFile->uReadBufferUsed == lpOpenFile->uReadBufferSize &&

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+534]
	cmp	ecx, DWORD PTR [eax+530]
	jne	$LN17@fnSysReadL
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+530]
	sub	ecx, DWORD PTR [eax+538]
	cmp	ecx, DWORD PTR _ulLth$[ebp]
	jae	$LN17@fnSysReadL

; 5784 :         (lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferPos) < ulLth )
; 5785 :    {
; 5786 :       // Copy remaining unprocessed buffer to beginning of buffer.
; 5787 :       if ( lpOpenFile->uReadBufferPos < lpOpenFile->uReadBufferSize )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+538]
	cmp	ecx, DWORD PTR [eax+530]
	jae	SHORT $LN18@fnSysReadL

; 5788 :       {
; 5789 :          zmemcpy( lpReadBuffer,

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+530]
	sub	ecx, DWORD PTR [eax+538]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpReadBuffer$[ebp]
	add	eax, DWORD PTR [edx+538]
	push	eax
	mov	ecx, DWORD PTR _lpReadBuffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN18@fnSysReadL:

; 5790 :                   &lpReadBuffer[ lpOpenFile->uReadBufferPos ],
; 5791 :                   lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferPos );
; 5792 :       }
; 5793 : 
; 5794 :       // Adjust the position and used values.
; 5795 :       lpOpenFile->uReadBufferUsed -= lpOpenFile->uReadBufferPos;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+534]
	sub	ecx, DWORD PTR [eax+538]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], ecx

; 5796 :       lpOpenFile->uReadBufferPos = 0;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+538], 0

; 5797 : 
; 5798 :       // Read another chunk of the file data.
; 5799 :       lpOpenFile->uReadBufferUsed +=

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [ecx+530]
	sub	eax, DWORD PTR [edx+534]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+542]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	add	eax, DWORD PTR [ecx+534]
	push	eax
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	add	eax, DWORD PTR [edx+534]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+534], eax
$LN17@fnSysReadL:

; 5800 :          fnSysReadFile( lpTask, lpOpenFile->lFileHandle,
; 5801 :                         (zPCHAR) ((zPCHAR) zGETPTR( lpOpenFile->hReadBuffer ) +
; 5802 :                                   lpOpenFile->uReadBufferUsed),
; 5803 :                         (zULONG) (lpOpenFile->uReadBufferSize -
; 5804 :                                   lpOpenFile->uReadBufferUsed) );
; 5805 :    }
; 5806 : 
; 5807 :    // Now that beginning of line is found, search for end and
; 5808 :    // put a null character there.
; 5809 :    *lpReturnLine = &lpReadBuffer[ lpOpenFile->uReadBufferPos ];

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpReadBuffer$[ebp]
	add	eax, DWORD PTR [edx+538]
	mov	ecx, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [ecx], eax

; 5810 :    lpOpenFile->uReadBufferPos += ulLth; // set new uPos

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+538]
	add	eax, DWORD PTR _ulLth$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [ecx+538], eax

; 5811 :    return( 1 );                         // everything is AOK

	mov	eax, 1
$LN1@fnSysReadL:

; 5812 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnSysReadLineLth@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lpReturnLine$ = 12					; size = 4
_lFileHandle$ = 16					; size = 4
_SysReadLine@12 PROC

; 5659 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5660 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysReadLin
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysReadLin
$LN3@SysReadLin:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysReadLin:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5661 : 
; 5662 :    return( fnSysReadLine( lpTask, lpReturnLine, lFileHandle, 0 ) );

	push	0
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpReturnLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadLine@16

; 5663 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysReadLine@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_vTask$1 = -24						; size = 4
_vTask$2 = -20						; size = 4
_uEnd$ = -16						; size = 4
_lpBuffer$ = -12					; size = 4
_uPos$ = -8						; size = 4
_lpOpenFile$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpReturnLine$ = 12					; size = 4
_lFileHandle$ = 16					; size = 4
_ppvFile$ = 20						; size = 4
_fnSysReadLine@16 PROC

; 5496 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 5497 :    unsigned int  uPos;
; 5498 :    unsigned int  uEnd;
; 5499 :    LPOPENFILE lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0

; 5500 :    zPCHAR   lpBuffer;
; 5501 : 
; 5502 :    *lpReturnLine = 0;

	mov	eax, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [eax], 0

; 5503 :    if ( ppvFile && *ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $LN8@fnSysReadL
	mov	ecx, DWORD PTR _ppvFile$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN8@fnSysReadL

; 5504 :    {
; 5505 :       lpOpenFile = (LPOPENFILE) *ppvFile;

	mov	edx, DWORD PTR _ppvFile$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5506 :       if ( lpOpenFile->lFileHandle != lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	je	SHORT $LN8@fnSysReadL

; 5507 :       {
; 5508 :          lpOpenFile = 0;

	mov	DWORD PTR _lpOpenFile$[ebp], 0
$LN8@fnSysReadL:

; 5509 :       }
; 5510 :    }
; 5511 : 
; 5512 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN10@fnSysReadL

; 5513 :    {
; 5514 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+118]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$LN2@fnSysReadL:

; 5515 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $LN10@fnSysReadL

; 5516 :       {
; 5517 :          if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	cmp	eax, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $LN11@fnSysReadL

; 5518 :             break;

	jmp	SHORT $LN10@fnSysReadL
$LN11@fnSysReadL:

; 5519 : 
; 5520 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5521 :       }

	jmp	SHORT $LN2@fnSysReadL
$LN10@fnSysReadL:

; 5522 :    }
; 5523 : 
; 5524 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN12@fnSysReadL

; 5525 :    {
; 5526 :       zVIEW vTask = zGETPTR( lpTask->hFirstView );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$2[ebp], eax

; 5527 : 
; 5528 :       fnStartBrowseOfTaskList( zGETHNDL( lpTask ), FALSE );

	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 5529 :       DisplayOpenFiles( "SysReadLine null OpenFile", zGETHNDL( lpTask ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG99499
	call	_DisplayOpenFiles@8

; 5530 :       fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 5531 :       IssueError( vTask, 0, 0, "SysReadLine ... no open files" );

	push	OFFSET $SG99500
	push	0
	push	0
	mov	ecx, DWORD PTR _vTask$2[ebp]
	push	ecx
	call	_IssueError@16

; 5532 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysReadL
$LN12@fnSysReadL:

; 5533 :    }
; 5534 : 
; 5535 :    // File found ... get a file read buffer if necessary.
; 5536 :    if ( ppvFile )

	cmp	DWORD PTR _ppvFile$[ebp], 0
	je	SHORT $LN13@fnSysReadL

; 5537 :       *ppvFile = lpOpenFile;

	mov	edx, DWORD PTR _ppvFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx], eax
$LN13@fnSysReadL:

; 5538 : 
; 5539 :    if ( lpOpenFile->uReadBufferSize == 0 )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+530], 0
	jne	$LN14@fnSysReadL

; 5540 :    {
; 5541 :       lpOpenFile->uReadBufferSize = 32770;   // 32768 + 2;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], 32770		; 00008002H
$LN4@fnSysReadL:

; 5542 :       while ( lpOpenFile->uReadBufferSize > 1026 )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+530], 1026		; 00000402H
	jbe	SHORT $LN5@fnSysReadL

; 5543 :       {
; 5544 :          lpOpenFile->hReadBuffer = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+542], eax

; 5545 :                                                      lpOpenFile->uReadBufferSize, 0, 0, 0 );
; 5546 :          if ( lpOpenFile->hReadBuffer )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+542], 0
	je	SHORT $LN16@fnSysReadL

; 5547 :             break;

	jmp	SHORT $LN5@fnSysReadL
$LN16@fnSysReadL:

; 5548 : 
; 5549 :          lpOpenFile->uReadBufferSize -= 1024;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+530]
	sub	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+530], edx

; 5550 :       }

	jmp	SHORT $LN4@fnSysReadL
$LN5@fnSysReadL:

; 5551 : 
; 5552 :       if ( lpOpenFile->hReadBuffer == 0 )  // if buffer acquisition failed

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+542], 0
	jne	SHORT $LN17@fnSysReadL

; 5553 :       {
; 5554 :          zVIEW vTask = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$1[ebp], eax

; 5555 : 
; 5556 :          IssueError( vTask, 0, 0, "SysReadLine ... buffer acquisition failure" );

	push	OFFSET $SG99506
	push	0
	push	0
	mov	ecx, DWORD PTR _vTask$1[ebp]
	push	ecx
	call	_IssueError@16

; 5557 :          lpOpenFile->uReadBufferSize = 0;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], 0

; 5558 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysReadL
$LN17@fnSysReadL:

; 5559 :       }
; 5560 : 
; 5561 :       // Bump size down by 2 so we can safely null terminate lines.
; 5562 :       lpOpenFile->uReadBufferSize -= 2;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+530]
	sub	ecx, 2
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+530], ecx

; 5563 : 
; 5564 :       lpBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+542]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBuffer$[ebp], eax

; 5565 : 
; 5566 :       // Read the first block of information into the buffer.
; 5567 :       lpOpenFile->uReadBufferUsed = fnSysReadFile( lpTask,

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+530]
	push	eax
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], eax

; 5568 :                                                    lpOpenFile->lFileHandle,
; 5569 :                                                    lpBuffer,
; 5570 :                                                    lpOpenFile->uReadBufferSize );
; 5571 :    }

	jmp	$LN15@fnSysReadL
$LN14@fnSysReadL:

; 5572 :    else
; 5573 :    // See if it is time to read more of the file in before continuing.
; 5574 :    if ( lpOpenFile->uReadBufferUsed == lpOpenFile->uReadBufferSize &&

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [eax+534]
	cmp	edx, DWORD PTR [ecx+530]
	jne	$LN18@fnSysReadL
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [eax+530]
	xor	edx, edx
	mov	ecx, 10					; 0000000aH
	div	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+530]
	sub	ecx, eax
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [edx+538], ecx
	jbe	$LN18@fnSysReadL

; 5575 :         lpOpenFile->uReadBufferPos > (lpOpenFile->uReadBufferSize -
; 5576 :                                       (lpOpenFile->uReadBufferSize / 10)) )
; 5577 :    {
; 5578 :       lpBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+542]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBuffer$[ebp], eax

; 5579 : 
; 5580 :       // Copy remaining unprocessed buffer to beginning of buffer.
; 5581 :       if ( lpOpenFile->uReadBufferPos < lpOpenFile->uReadBufferSize )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+538]
	cmp	ecx, DWORD PTR [eax+530]
	jae	SHORT $LN20@fnSysReadL

; 5582 :       {
; 5583 :          zmemcpy( lpBuffer,

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+530]
	sub	ecx, DWORD PTR [eax+538]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR [edx+538]
	push	eax
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN20@fnSysReadL:

; 5584 :                   &lpBuffer[ lpOpenFile->uReadBufferPos ],
; 5585 :                   lpOpenFile->uReadBufferSize - lpOpenFile->uReadBufferPos );
; 5586 :       }
; 5587 : 
; 5588 :       // Adjust the position and used values.
; 5589 :       lpOpenFile->uReadBufferUsed -= lpOpenFile->uReadBufferPos;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [edx+534]
	sub	ecx, DWORD PTR [eax+538]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], ecx

; 5590 :       lpOpenFile->uReadBufferPos  = 0;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [eax+538], 0

; 5591 : 
; 5592 :       // Read another chunk of the file data.
; 5593 :       lpOpenFile->uReadBufferUsed +=

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [ecx+530]
	sub	eax, DWORD PTR [edx+534]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR [ecx+534]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysReadFile@16
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	add	eax, DWORD PTR [ecx+534]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR [edx+534], eax

; 5594 :        fnSysReadFile( lpTask,
; 5595 :                       lpOpenFile->lFileHandle,
; 5596 :                       (zPCHAR) (lpBuffer + lpOpenFile->uReadBufferUsed),
; 5597 :                       (zULONG) (lpOpenFile->uReadBufferSize -
; 5598 :                                             lpOpenFile->uReadBufferUsed) );
; 5599 :    }

	jmp	SHORT $LN15@fnSysReadL
$LN18@fnSysReadL:

; 5600 :    else
; 5601 :    {
; 5602 :       lpBuffer = zGETPTR( lpOpenFile->hReadBuffer );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+542]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBuffer$[ebp], eax
$LN15@fnSysReadL:

; 5603 :    }
; 5604 : 
; 5605 :    // If we get here, we're ready to proceed ahead in getting
; 5606 :    // a line to return.
; 5607 :    uPos = lpOpenFile->uReadBufferPos;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+538]
	mov	DWORD PTR _uPos$[ebp], eax

; 5608 :    uEnd = lpOpenFile->uReadBufferUsed;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+534]
	mov	DWORD PTR _uEnd$[ebp], edx

; 5609 : 
; 5610 :    // If current pos is end of file, and we're at the end of file,
; 5611 :    // skip the rest of the data.
; 5612 :    if ( lpBuffer[ uPos ] == '\x1a' )

	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 26					; 0000001aH
	jne	SHORT $LN21@fnSysReadL

; 5613 :    {
; 5614 :       // If followed by a crlf or new-line, also skip that.
; 5615 :       if ( (uPos + 1) >= uEnd ||
; 5616 :            (lpBuffer[ uPos + 1 ] == '\n' &&
; 5617 :             uPos + 2 >= uEnd) ||

	mov	edx, DWORD PTR _uPos$[ebp]
	add	edx, 1
	cmp	edx, DWORD PTR _uEnd$[ebp]
	jae	SHORT $LN23@fnSysReadL
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN24@fnSysReadL
	mov	edx, DWORD PTR _uPos$[ebp]
	add	edx, 2
	cmp	edx, DWORD PTR _uEnd$[ebp]
	jae	SHORT $LN23@fnSysReadL
$LN24@fnSysReadL:
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN21@fnSysReadL
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN21@fnSysReadL
	mov	ecx, DWORD PTR _uPos$[ebp]
	add	ecx, 3
	cmp	ecx, DWORD PTR _uEnd$[ebp]
	jb	SHORT $LN21@fnSysReadL
$LN23@fnSysReadL:

; 5618 :            (lpBuffer[ uPos + 1 ] == '\r' &&
; 5619 :             lpBuffer[ uPos + 2 ] == '\n' &&
; 5620 :             uPos + 3 >= uEnd) )
; 5621 :       {
; 5622 :          uPos = uEnd;

	mov	edx, DWORD PTR _uEnd$[ebp]
	mov	DWORD PTR _uPos$[ebp], edx
$LN21@fnSysReadL:

; 5623 :       }
; 5624 :    }
; 5625 : 
; 5626 :    // If nothing to return to the user, set position to end.
; 5627 :    if ( uPos >= uEnd )

	mov	eax, DWORD PTR _uPos$[ebp]
	cmp	eax, DWORD PTR _uEnd$[ebp]
	jb	SHORT $LN25@fnSysReadL

; 5628 :    {
; 5629 :       lpOpenFile->uReadBufferPos = lpOpenFile->uReadBufferUsed;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+534]
	mov	DWORD PTR [ecx+538], eax

; 5630 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSysReadL
$LN25@fnSysReadL:

; 5631 :    }
; 5632 : 
; 5633 :    // Now that beginning of line is found, search for end and
; 5634 :    // put a null character there.
; 5635 :    *lpReturnLine = &lpBuffer[ uPos ];

	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	mov	edx, DWORD PTR _lpReturnLine$[ebp]
	mov	DWORD PTR [edx], ecx
$LN6@fnSysReadL:

; 5636 :    while( uPos < uEnd &&
; 5637 :           lpBuffer[ uPos ] != '\r' &&
; 5638 :           lpBuffer[ uPos ] != '\n' &&

	mov	eax, DWORD PTR _uPos$[ebp]
	cmp	eax, DWORD PTR _uEnd$[ebp]
	jae	SHORT $LN7@fnSysReadL
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN7@fnSysReadL
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN7@fnSysReadL
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 26					; 0000001aH
	je	SHORT $LN7@fnSysReadL

; 5639 :           lpBuffer[ uPos ] != '\x1a' )
; 5640 :    {
; 5641 :       uPos++;

	mov	ecx, DWORD PTR _uPos$[ebp]
	add	ecx, 1
	mov	DWORD PTR _uPos$[ebp], ecx

; 5642 :    }

	jmp	SHORT $LN6@fnSysReadL
$LN7@fnSysReadL:

; 5643 : 
; 5644 :    if ( (lpBuffer[ uPos ] == '\r' && lpBuffer[ uPos + 1 ] == '\n') ||

	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN28@fnSysReadL
	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 10					; 0000000aH
	je	SHORT $LN27@fnSysReadL
$LN28@fnSysReadL:
	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN26@fnSysReadL
	mov	edx, DWORD PTR _lpBuffer$[ebp]
	add	edx, DWORD PTR _uPos$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 13					; 0000000dH
	jne	SHORT $LN26@fnSysReadL
$LN27@fnSysReadL:

; 5645 :         (lpBuffer[ uPos ] == '\n' && lpBuffer[ uPos + 1 ] == '\r') )
; 5646 :    {
; 5647 :       lpBuffer[ uPos++ ] = 0;  // null end of line and skip \r or \n

	mov	ecx, DWORD PTR _lpBuffer$[ebp]
	add	ecx, DWORD PTR _uPos$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _uPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _uPos$[ebp], edx
$LN26@fnSysReadL:

; 5648 :    }
; 5649 : 
; 5650 :    lpBuffer[ uPos++ ] = 0;            // null end of line

	mov	eax, DWORD PTR _lpBuffer$[ebp]
	add	eax, DWORD PTR _uPos$[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _uPos$[ebp]
	add	ecx, 1
	mov	DWORD PTR _uPos$[ebp], ecx

; 5651 :    lpOpenFile->uReadBufferPos = uPos; // set new uPos

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _uPos$[ebp]
	mov	DWORD PTR [edx+538], eax

; 5652 :    return( 1 );                       // everything is AOK

	mov	eax, 1
$LN1@fnSysReadL:

; 5653 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysReadLine@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lFileHandle$ = 12					; size = 4
_pchBuffer$ = 16					; size = 4
_ulMaxLth$ = 20						; size = 4
_SysReadFile@16 PROC

; 5467 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5468 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysReadFil
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysReadFil
$LN3@SysReadFil:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysReadFil:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5469 : 
; 5470 :    return( fnSysReadFile( lpTask, lFileHandle, pchBuffer, ulMaxLth ) );

	mov	eax, DWORD PTR _ulMaxLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysReadFile@16

; 5471 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysReadFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_ulBytes$ = -4						; size = 4
_lpTask$ = 8						; size = 4
_lFileHandle$ = 12					; size = 4
_pchBuffer$ = 16					; size = 4
_ulMaxLth$ = 20						; size = 4
_fnSysReadFile@16 PROC

; 5453 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5454 :    ULONG ulBytes;
; 5455 : 
; 5456 :    if ( ReadFile( (HANDLE) lFileHandle, pchBuffer, ulMaxLth, &ulBytes, 0 ) )

	push	0
	lea	eax, DWORD PTR _ulBytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulMaxLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20
	test	eax, eax
	je	SHORT $LN2@fnSysReadF

; 5457 :       return( ulBytes );

	mov	eax, DWORD PTR _ulBytes$[ebp]
	jmp	SHORT $LN1@fnSysReadF
	jmp	SHORT $LN1@fnSysReadF
$LN2@fnSysReadF:

; 5458 :    else
; 5459 :       return( 0 );

	xor	eax, eax
$LN1@fnSysReadF:

; 5460 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysReadFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hFile$ = 8						; size = 4
_lPosition$ = 12					; size = 4
_SysPositionFile@8 PROC

; 6475 : {

	push	ebp
	mov	ebp, esp

; 6476 :    return( SetFilePointer( (HANDLE) hFile, lPosition, 0, FILE_BEGIN ) );

	push	0
	push	0
	mov	eax, DWORD PTR _lPosition$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetFilePointer@16

; 6477 : }

	pop	ebp
	ret	8
_SysPositionFile@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_iInputLth$1 = -12					; size = 4
_iStartPos$2 = -8					; size = 4
_k$3 = -4						; size = 4
_pchPortName$ = 8					; size = 4
_PortValue$ = 12					; size = 4
_pchInputString$ = 16					; size = 4
_SysParseLine@12 PROC

; 6561 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6562 :    if ( pchInputString )

	cmp	DWORD PTR _pchInputString$[ebp], 0
	je	$LN1@SysParseLi

; 6563 :    {
; 6564 :       int  k;
; 6565 :       int  iInputLth;
; 6566 :       int  iStartPos;
; 6567 : 
; 6568 :       k = -1;

	mov	DWORD PTR _k$3[ebp], -1

; 6569 :       iInputLth = zstrlen( pchInputString );

	mov	eax, DWORD PTR _pchInputString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _iInputLth$1[ebp], eax
$LN4@SysParseLi:

; 6570 : 
; 6571 :       // look for begining of first parm
; 6572 :       do
; 6573 :          k++;

	mov	ecx, DWORD PTR _k$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$3[ebp], ecx

; 6574 :       while ( (pchInputString[ k ] == ' ') && (k < iInputLth) );

	mov	edx, DWORD PTR _pchInputString$[ebp]
	add	edx, DWORD PTR _k$3[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN3@SysParseLi
	mov	ecx, DWORD PTR _k$3[ebp]
	cmp	ecx, DWORD PTR _iInputLth$1[ebp]
	jl	SHORT $LN4@SysParseLi
$LN3@SysParseLi:

; 6575 :       iStartPos = k;

	mov	edx, DWORD PTR _k$3[ebp]
	mov	DWORD PTR _iStartPos$2[ebp], edx

; 6576 : 
; 6577 :       // if no parms
; 6578 :       if ( iStartPos >= iInputLth )

	mov	eax, DWORD PTR _iStartPos$2[ebp]
	cmp	eax, DWORD PTR _iInputLth$1[ebp]
	jl	SHORT $LN7@SysParseLi

; 6579 :       {
; 6580 :          pchPortName[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchPortName$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 6581 :          *PortValue = szNullS;

	mov	ecx, DWORD PTR _PortValue$[ebp]
	mov	edx, DWORD PTR _szNullS
	mov	DWORD PTR [ecx], edx

; 6582 :       }

	jmp	$LN1@SysParseLi
$LN7@SysParseLi:

; 6583 :       else  // at least one parm
; 6584 :       {
; 6585 :          // look for end of first parm
; 6586 :          do
; 6587 :             k++;

	mov	eax, DWORD PTR _k$3[ebp]
	add	eax, 1
	mov	DWORD PTR _k$3[ebp], eax

; 6588 :          while ( pchInputString[ k ] != ' ' &&
; 6589 :                  pchInputString[ k ] != '=' &&

	mov	ecx, DWORD PTR _pchInputString$[ebp]
	add	ecx, DWORD PTR _k$3[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	je	SHORT $LN6@SysParseLi
	mov	eax, DWORD PTR _pchInputString$[ebp]
	add	eax, DWORD PTR _k$3[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 61					; 0000003dH
	je	SHORT $LN6@SysParseLi
	mov	edx, DWORD PTR _k$3[ebp]
	cmp	edx, DWORD PTR _iInputLth$1[ebp]
	jl	SHORT $LN7@SysParseLi
$LN6@SysParseLi:

; 6590 :                  k < iInputLth );
; 6591 : 
; 6592 :          zstrncpy( pchPortName, pchInputString + iStartPos, k - iStartPos );

	mov	eax, DWORD PTR _k$3[ebp]
	sub	eax, DWORD PTR _iStartPos$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchInputString$[ebp]
	add	ecx, DWORD PTR _iStartPos$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchPortName$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 6593 :          pchPortName[ k - iStartPos ] = 0;

	mov	eax, DWORD PTR _k$3[ebp]
	sub	eax, DWORD PTR _iStartPos$2[ebp]
	mov	ecx, DWORD PTR _pchPortName$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 6594 : 
; 6595 :          // if Only one parm created set Portvalue to null and return
; 6596 :          if ( k > iInputLth )

	mov	edx, DWORD PTR _k$3[ebp]
	cmp	edx, DWORD PTR _iInputLth$1[ebp]
	jle	SHORT $LN17@SysParseLi

; 6597 :          {
; 6598 :             *PortValue = szNullS;

	mov	eax, DWORD PTR _PortValue$[ebp]
	mov	ecx, DWORD PTR _szNullS
	mov	DWORD PTR [eax], ecx

; 6599 :             return;

	jmp	$LN1@SysParseLi
$LN17@SysParseLi:

; 6600 :          }
; 6601 : 
; 6602 :          // Set StartPos to the greater of k + 1 or 11
; 6603 :          k++;

	mov	edx, DWORD PTR _k$3[ebp]
	add	edx, 1
	mov	DWORD PTR _k$3[ebp], edx

; 6604 :          if ( k > 10 || pchInputString[ k ] != ' ' )

	cmp	DWORD PTR _k$3[ebp], 10			; 0000000aH
	jg	SHORT $LN20@SysParseLi
	mov	eax, DWORD PTR _pchInputString$[ebp]
	add	eax, DWORD PTR _k$3[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	je	SHORT $LN18@SysParseLi
$LN20@SysParseLi:

; 6605 :             iStartPos = k;

	mov	edx, DWORD PTR _k$3[ebp]
	mov	DWORD PTR _iStartPos$2[ebp], edx
	jmp	SHORT $LN8@SysParseLi
$LN18@SysParseLi:

; 6606 :          else
; 6607 :             iStartPos = 10;

	mov	DWORD PTR _iStartPos$2[ebp], 10		; 0000000aH
$LN8@SysParseLi:

; 6608 : 
; 6609 :          // look for begining of second parm
; 6610 :          while ( (pchInputString[ k ] == ' ') && (k <= iInputLth) )

	mov	eax, DWORD PTR _pchInputString$[ebp]
	add	eax, DWORD PTR _k$3[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jne	SHORT $LN9@SysParseLi
	mov	edx, DWORD PTR _k$3[ebp]
	cmp	edx, DWORD PTR _iInputLth$1[ebp]
	jg	SHORT $LN9@SysParseLi

; 6611 :             k++;

	mov	eax, DWORD PTR _k$3[ebp]
	add	eax, 1
	mov	DWORD PTR _k$3[ebp], eax
	jmp	SHORT $LN8@SysParseLi
$LN9@SysParseLi:

; 6612 : 
; 6613 :          // if only one parm
; 6614 :          if ( k >= iInputLth )

	mov	ecx, DWORD PTR _k$3[ebp]
	cmp	ecx, DWORD PTR _iInputLth$1[ebp]
	jl	SHORT $LN21@SysParseLi

; 6615 :          {
; 6616 :             *PortValue = szNullS;

	mov	edx, DWORD PTR _PortValue$[ebp]
	mov	eax, DWORD PTR _szNullS
	mov	DWORD PTR [edx], eax

; 6617 :          }

	jmp	SHORT $LN1@SysParseLi
$LN21@SysParseLi:

; 6618 :          else     // there is a second parm
; 6619 :          {
; 6620 :             if ( k < 11 )

	cmp	DWORD PTR _k$3[ebp], 11			; 0000000bH
	jge	SHORT $LN23@SysParseLi

; 6621 :                iStartPos = k;

	mov	ecx, DWORD PTR _k$3[ebp]
	mov	DWORD PTR _iStartPos$2[ebp], ecx
$LN23@SysParseLi:

; 6622 : 
; 6623 :             *PortValue = (zPCHAR) (pchInputString + iStartPos);

	mov	edx, DWORD PTR _pchInputString$[ebp]
	add	edx, DWORD PTR _iStartPos$2[ebp]
	mov	eax, DWORD PTR _PortValue$[ebp]
	mov	DWORD PTR [eax], edx

; 6624 : 
; 6625 :             // if needed, get rid of trailing blanks
; 6626 :             k = zstrlen( *PortValue ) - 1;

	mov	ecx, DWORD PTR _PortValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strlen
	add	esp, 4
	sub	eax, 1
	mov	DWORD PTR _k$3[ebp], eax
$LN10@SysParseLi:

; 6627 :             while ( k > 0 )

	cmp	DWORD PTR _k$3[ebp], 0
	jle	SHORT $LN1@SysParseLi

; 6628 :             {
; 6629 :                if ( (*PortValue)[ k ] == ' ' )

	mov	eax, DWORD PTR _PortValue$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _k$3[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN24@SysParseLi

; 6630 :                   (*PortValue)[ k-- ] = 0;

	mov	ecx, DWORD PTR _PortValue$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _k$3[ebp]
	mov	BYTE PTR [edx+eax], 0
	mov	ecx, DWORD PTR _k$3[ebp]
	sub	ecx, 1
	mov	DWORD PTR _k$3[ebp], ecx
	jmp	SHORT $LN25@SysParseLi
$LN24@SysParseLi:

; 6631 :                else
; 6632 :                   break;

	jmp	SHORT $LN1@SysParseLi
$LN25@SysParseLi:

; 6633 :             }

	jmp	SHORT $LN10@SysParseLi
$LN1@SysParseLi:

; 6634 :          }
; 6635 :       }
; 6636 :    }
; 6637 : }  // End of SysParseLine

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysParseLine@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_cpcFileName$ = 12					; size = 4
_nFlags$ = 16						; size = 4
_SysOpenFile@12 PROC

; 5294 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 5295 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysOpenFil
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysOpenFil
$LN3@SysOpenFil:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysOpenFil:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 5296 : 
; 5297 :    return( fnSysOpenFile( lpTask, cpcFileName, nFlags ) );

	mov	eax, DWORD PTR _nFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12

; 5298 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysOpenFile@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lProcessID$1 = -3164					; size = 4
_pchNew$2 = -3160					; size = 4
_lRC$3 = -3156						; size = 4
_pchMsg$4 = -3152					; size = 4
_dw$5 = -3148						; size = 4
_lpMainTask$ = -3144					; size = 4
_hOpenFile$6 = -3140					; size = 4
_lpOpenFile$ = -3136					; size = 4
_nTrys$ = -3132						; size = 2
_pch$7 = -3128						; size = 4
_hFile$ = -3124						; size = 4
_bMutexLocked$8 = -3117					; size = 1
_pch$9 = -3116						; size = 4
_szFN$10 = -3112					; size = 1025
_szPath$11 = -2084					; size = 1025
_szTempFileName$ = -1056				; size = 1025
_szResult$12 = -28					; size = 10
_szExtension$13 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_cpcFileName$ = 12					; size = 4
_nFlags$ = 16						; size = 4
_fnSysOpenFile@12 PROC

; 5090 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 3164				; 00000c5cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 5091 :    zCHAR      szTempFileName[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 5092 :    HANDLE     hFile = (HANDLE) -1;

	mov	DWORD PTR _hFile$[ebp], -1

; 5093 :    LPOPENFILE lpOpenFile;
; 5094 :    LPTASK     lpMainTask;
; 5095 :    zSHORT     nTrys = 0;

	xor	eax, eax
	mov	WORD PTR _nTrys$[ebp], ax
$LN2@fnSysOpenF:

; 5096 : 
; 5097 : // TraceLine( "fnSysOpenFile %s  Task: 0x%08x   Process: 0x%08x",
; 5098 : //            cpcFileName, lpTask, lProcessID );
; 5099 : 
; 5100 :    while ( (lpMainTask = zGETPTR( AnchorBlock->hMainTask )) == 0 && nTrys < 100 )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$[ebp], eax
	cmp	DWORD PTR _lpMainTask$[ebp], 0
	jne	SHORT $LN3@fnSysOpenF
	movsx	eax, WORD PTR _nTrys$[ebp]
	cmp	eax, 100				; 00000064H
	jge	SHORT $LN3@fnSysOpenF

; 5101 :    {
; 5102 :       SysWait( 100 );

	push	100					; 00000064H
	call	_SysWait@4

; 5103 :       nTrys++;

	mov	cx, WORD PTR _nTrys$[ebp]
	add	cx, 1
	mov	WORD PTR _nTrys$[ebp], cx

; 5104 :    }

	jmp	SHORT $LN2@fnSysOpenF
$LN3@fnSysOpenF:

; 5105 : 
; 5106 :    if ( lpMainTask == 0 || lpTask == 0 )

	cmp	DWORD PTR _lpMainTask$[ebp], 0
	je	SHORT $LN11@fnSysOpenF
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN10@fnSysOpenF
$LN11@fnSysOpenF:

; 5107 :    {
; 5108 :       if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN12@fnSysOpenF

; 5109 :       {
; 5110 :          TraceLine( "SysOpenFile for file: %s failed due to invalid view (null task)",

	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	push	OFFSET $SG99394
	call	_TraceLine
	add	esp, 8
$LN12@fnSysOpenF:

; 5111 :                     cpcFileName );
; 5112 :       }
; 5113 : 
; 5114 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnSysOpenF
$LN10@fnSysOpenF:

; 5115 :    }
; 5116 : 
; 5117 :    zstrcpy( szTempFileName, cpcFileName );

	mov	eax, DWORD PTR _cpcFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5118 : 
; 5119 :    // Check to see if we are going to write the file to a backup file first.
; 5120 :    if ( nFlags & COREFILE_BACKUP )

	mov	edx, DWORD PTR _nFlags$[ebp]
	and	edx, 4096				; 00001000H
	je	$LN13@fnSysOpenF

; 5121 :    {
; 5122 :       zCHAR  szExtension[ 10 ];
; 5123 :       zPCHAR pch = &szTempFileName[ zstrlen( szTempFileName ) - 1 ];

	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _szTempFileName$[ebp+eax-1]
	mov	DWORD PTR _pch$9[ebp], ecx
$LN4@fnSysOpenF:

; 5124 : 
; 5125 :       // Backup until we find the period.
; 5126 :       while ( pch > szTempFileName && *pch != '.' )

	lea	edx, DWORD PTR _szTempFileName$[ebp]
	cmp	DWORD PTR _pch$9[ebp], edx
	jbe	SHORT $LN5@fnSysOpenF
	mov	eax, DWORD PTR _pch$9[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 46					; 0000002eH
	je	SHORT $LN5@fnSysOpenF

; 5127 :          pch--;

	mov	edx, DWORD PTR _pch$9[ebp]
	sub	edx, 1
	mov	DWORD PTR _pch$9[ebp], edx
	jmp	SHORT $LN4@fnSysOpenF
$LN5@fnSysOpenF:

; 5128 : 
; 5129 :       // Save the extension for later use.
; 5130 :       if ( pch > szTempFileName )

	lea	eax, DWORD PTR _szTempFileName$[ebp]
	cmp	DWORD PTR _pch$9[ebp], eax
	jbe	SHORT $LN6@fnSysOpenF

; 5131 :          zstrcpy( szExtension, pch );

	mov	ecx, DWORD PTR _pch$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _szExtension$13[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN6@fnSysOpenF:

; 5132 : 
; 5133 :       // Backup until we find the first directory separator.
; 5134 :       while ( pch > szTempFileName && *pch != cDirSep )

	lea	eax, DWORD PTR _szTempFileName$[ebp]
	cmp	DWORD PTR _pch$9[ebp], eax
	jbe	SHORT $LN7@fnSysOpenF
	mov	ecx, DWORD PTR _pch$9[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR _cDirSep
	cmp	edx, eax
	je	SHORT $LN7@fnSysOpenF

; 5135 :          pch--;

	mov	ecx, DWORD PTR _pch$9[ebp]
	sub	ecx, 1
	mov	DWORD PTR _pch$9[ebp], ecx
	jmp	SHORT $LN6@fnSysOpenF
$LN7@fnSysOpenF:

; 5136 : 
; 5137 :       // Make sure we don't lose the dir separator.
; 5138 :       if ( *pch == cDirSep )

	mov	edx, DWORD PTR _pch$9[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _cDirSep
	cmp	eax, ecx
	jne	SHORT $LN15@fnSysOpenF

; 5139 :          pch++;

	mov	edx, DWORD PTR _pch$9[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$9[ebp], edx
$LN15@fnSysOpenF:

; 5140 : 
; 5141 :       // Create a temp file name using the current task ID.
; 5142 :       zsprintf( pch, "0x%08x%s", zGETHNDL( lpTask ), szExtension );

	lea	eax, DWORD PTR _szExtension$13[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG99398
	mov	edx, DWORD PTR _pch$9[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN13@fnSysOpenF:

; 5143 :    }
; 5144 : 
; 5145 :    if ( nFlags & COREFILE_READ )

	mov	eax, DWORD PTR _nFlags$[ebp]
	and	eax, 128				; 00000080H
	je	$LN16@fnSysOpenF

; 5146 :    {
; 5147 :       if ( nFlags & COREFILE_WRITE )

	mov	ecx, DWORD PTR _nFlags$[ebp]
	and	ecx, 64					; 00000040H
	je	SHORT $LN18@fnSysOpenF

; 5148 :       {
; 5149 :          hFile = CreateFile( szTempFileName, GENERIC_WRITE | GENERIC_READ,

	push	0
	push	128					; 00000080H
	push	4
	push	0
	push	1
	push	-1073741824				; c0000000H
	lea	edx, DWORD PTR _szTempFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax

; 5150 :                              FILE_SHARE_READ, 0, OPEN_ALWAYS,
; 5151 :                              FILE_ATTRIBUTE_NORMAL, 0 );
; 5152 :          if ( hFile == INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN20@fnSysOpenF

; 5153 :             hFile = (HANDLE) -1;

	mov	DWORD PTR _hFile$[ebp], -1
$LN20@fnSysOpenF:

; 5154 : 
; 5155 :          if ( (zLONG) hFile != -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	je	SHORT $LN21@fnSysOpenF

; 5156 :          {
; 5157 :             if ( (nFlags & COREFILE_APPEND) == COREFILE_APPEND )

	mov	eax, DWORD PTR _nFlags$[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 448				; 000001c0H
	jne	SHORT $LN21@fnSysOpenF

; 5158 :             {
; 5159 :                SetFilePointer( hFile, 0, 0, FILE_END );

	push	2
	push	0
	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__SetFilePointer@16
$LN21@fnSysOpenF:

; 5160 :             }
; 5161 :          }
; 5162 :       }

	jmp	SHORT $LN19@fnSysOpenF
$LN18@fnSysOpenF:

; 5163 :       else
; 5164 :       {
; 5165 :          hFile = CreateFile( szTempFileName, GENERIC_READ,

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	1
	push	-2147483648				; 80000000H
	lea	edx, DWORD PTR _szTempFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax
$LN19@fnSysOpenF:

; 5166 :                              FILE_SHARE_READ, 0, OPEN_EXISTING,
; 5167 :                              FILE_ATTRIBUTE_NORMAL, 0 );
; 5168 :       }
; 5169 :    }

	jmp	$LN17@fnSysOpenF
$LN16@fnSysOpenF:

; 5170 :    else
; 5171 :    if ( (nFlags & COREFILE_WRITE) || (nFlags & COREFILE_CREATE) )

	mov	eax, DWORD PTR _nFlags$[ebp]
	and	eax, 64					; 00000040H
	jne	SHORT $LN25@fnSysOpenF
	mov	ecx, DWORD PTR _nFlags$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN23@fnSysOpenF
$LN25@fnSysOpenF:

; 5172 :    {
; 5173 :       if ( (nFlags & COREFILE_CREATE_NEW) == COREFILE_CREATE_NEW )

	mov	edx, DWORD PTR _nFlags$[ebp]
	and	edx, 544				; 00000220H
	cmp	edx, 544				; 00000220H
	jne	SHORT $LN26@fnSysOpenF

; 5174 :          hFile = CreateFile( szTempFileName, GENERIC_WRITE,

	push	0
	push	128					; 00000080H
	push	1
	push	0
	push	1
	push	1073741824				; 40000000H
	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax
	jmp	SHORT $LN27@fnSysOpenF
$LN26@fnSysOpenF:

; 5175 :                              FILE_SHARE_READ, 0, CREATE_NEW,
; 5176 :                              FILE_ATTRIBUTE_NORMAL, 0 );
; 5177 :       else
; 5178 :          hFile = CreateFile( szTempFileName, GENERIC_WRITE,

	push	0
	push	128					; 00000080H
	push	2
	push	0
	push	1
	push	1073741824				; 40000000H
	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__CreateFileA@28
	mov	DWORD PTR _hFile$[ebp], eax
$LN27@fnSysOpenF:

; 5179 :                              FILE_SHARE_READ, 0, CREATE_ALWAYS,
; 5180 :                              FILE_ATTRIBUTE_NORMAL, 0 );
; 5181 :    }

	jmp	$LN17@fnSysOpenF
$LN23@fnSysOpenF:

; 5182 :    else
; 5183 :    if ( nFlags & COREFILE_EXIST )

	mov	edx, DWORD PTR _nFlags$[ebp]
	and	edx, 4
	je	$LN28@fnSysOpenF

; 5184 :    {
; 5185 :       zCHAR  szPath[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 5186 :       zCHAR  szFN[ 2 * zMAX_FILESPEC_LTH + 1 ];
; 5187 :       zCHAR  szResult[ 10 ];
; 5188 :       zPCHAR pch;
; 5189 : 
; 5190 :       // Find the last directory separator.
; 5191 :       zstrcpy( szPath, szTempFileName );

	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szPath$11[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 5192 :       pch = &szPath[ zstrlen( szPath ) - 1 ];

	lea	edx, DWORD PTR _szPath$11[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szPath$11[ebp+eax-1]
	mov	DWORD PTR _pch$7[ebp], eax
$LN8@fnSysOpenF:

; 5193 :       while ( pch >= szPath && *pch != cDirSep && *pch != ':' )

	lea	ecx, DWORD PTR _szPath$11[ebp]
	cmp	DWORD PTR _pch$7[ebp], ecx
	jb	SHORT $LN9@fnSysOpenF
	mov	edx, DWORD PTR _pch$7[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _cDirSep
	cmp	eax, ecx
	je	SHORT $LN9@fnSysOpenF
	mov	edx, DWORD PTR _pch$7[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN9@fnSysOpenF

; 5194 :          pch--;

	mov	ecx, DWORD PTR _pch$7[ebp]
	sub	ecx, 1
	mov	DWORD PTR _pch$7[ebp], ecx
	jmp	SHORT $LN8@fnSysOpenF
$LN9@fnSysOpenF:

; 5195 : 
; 5196 :       // Copy the filename and extension.
; 5197 :       zstrcpy( szFN, pch + 1 );

	mov	edx, DWORD PTR _pch$7[ebp]
	add	edx, 1
	push	edx
	lea	eax, DWORD PTR _szFN$10[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 5198 : 
; 5199 :       // Set null terminator in szPath to remove filename and extension.
; 5200 :       pch[ 1 ] = 0;

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _pch$7[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 5201 : 
; 5202 :       // Note that the " 9, szResult, &pch" arguments are really dummy args.
; 5203 :       if ( SearchPath( szPath, szFN, 0, 9, szResult, &pch ) > 0 )

	lea	eax, DWORD PTR _pch$7[ebp]
	push	eax
	lea	ecx, DWORD PTR _szResult$12[ebp]
	push	ecx
	push	9
	push	0
	lea	edx, DWORD PTR _szFN$10[ebp]
	push	edx
	lea	eax, DWORD PTR _szPath$11[ebp]
	push	eax
	call	DWORD PTR __imp__SearchPathA@24
	test	eax, eax
	jbe	SHORT $LN30@fnSysOpenF

; 5204 :          return( 1 ); // File exists.

	mov	eax, 1
	jmp	$LN1@fnSysOpenF
	jmp	SHORT $LN31@fnSysOpenF
$LN30@fnSysOpenF:

; 5205 :       else
; 5206 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnSysOpenF
$LN31@fnSysOpenF:

; 5207 :    }

	jmp	$LN17@fnSysOpenF
$LN28@fnSysOpenF:

; 5208 :    else
; 5209 :    if ( nFlags & COREFILE_DELETE )

	mov	ecx, DWORD PTR _nFlags$[ebp]
	and	ecx, 8
	je	$LN32@fnSysOpenF

; 5210 :    {
; 5211 :       zLONG lRC = DeleteFile( szTempFileName );

	lea	edx, DWORD PTR _szTempFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__DeleteFileA@4
	mov	DWORD PTR _lRC$3[ebp], eax

; 5212 :       if ( lRC == 0 )

	cmp	DWORD PTR _lRC$3[ebp], 0
	jne	SHORT $LN34@fnSysOpenF

; 5213 :       {
; 5214 :          zPCHAR pchMsg;
; 5215 :          DWORD  dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$5[ebp], eax

; 5216 : 
; 5217 :          FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,

	push	0
	push	0
	lea	eax, DWORD PTR _pchMsg$4[ebp]
	push	eax
	push	1024					; 00000400H
	mov	ecx, DWORD PTR _dw$5[ebp]
	push	ecx
	push	0
	push	4352					; 00001100H
	call	DWORD PTR __imp__FormatMessageA@28

; 5218 :                         0, dw, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
; 5219 :                         (zPCHAR) &pchMsg, 0, 0 );
; 5220 :          TraceLine( "SysDeleteFile Error: %s   File: %s   RC: %d",

	mov	edx, DWORD PTR _dw$5[ebp]
	push	edx
	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchMsg$4[ebp]
	push	ecx
	push	OFFSET $SG99419
	call	_TraceLine
	add	esp, 16					; 00000010H

; 5221 :                     pchMsg, szTempFileName, dw );
; 5222 :       // fnSysMessageBox( lpTask, "Zeidon DeleteFile Error", pchMsg, 1 );
; 5223 :          LocalFree( pchMsg ); // free the buffer

	mov	edx, DWORD PTR _pchMsg$4[ebp]
	push	edx
	call	DWORD PTR __imp__LocalFree@4

; 5224 :          return( -1 );

	or	eax, -1
	jmp	$LN1@fnSysOpenF

; 5225 :       }

	jmp	SHORT $LN35@fnSysOpenF
$LN34@fnSysOpenF:

; 5226 :       else
; 5227 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSysOpenF
$LN35@fnSysOpenF:

; 5228 :    }

	jmp	SHORT $LN17@fnSysOpenF
$LN32@fnSysOpenF:

; 5229 :    else
; 5230 :    if ( nFlags & COREFILE_RENAME )

	mov	eax, DWORD PTR _nFlags$[ebp]
	and	eax, 16					; 00000010H
	je	SHORT $LN17@fnSysOpenF

; 5231 :    {
; 5232 :       zPCHAR pchNew = (zPCHAR) &cpcFileName[ zstrlen( cpcFileName ) + 1 ];

	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	lea	eax, DWORD PTR [edx+eax+1]
	mov	DWORD PTR _pchNew$2[ebp], eax

; 5233 : 
; 5234 :       // Call fnSysRenameFile.
; 5235 :       return( fnSysRenameFile( lpTask, (zPCHAR) cpcFileName, pchNew, TRUE ) );

	push	1
	mov	ecx, DWORD PTR _pchNew$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysRenameFile@16
	cwde
	jmp	$LN1@fnSysOpenF
$LN17@fnSysOpenF:

; 5236 :    }
; 5237 : 
; 5238 :    if ( hFile == (HANDLE) -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN37@fnSysOpenF

; 5239 :    {
; 5240 :       // The following statement was added and the lines
; 5241 :       // above commented out because getcwd was abending.
; 5242 :       // This should be reversed when getcwd is ok.
; 5243 :       TraceLineS( "(sy) Could not open file: ", szTempFileName );

	lea	ecx, DWORD PTR _szTempFileName$[ebp]
	push	ecx
	push	OFFSET $SG99422
	call	_TraceLineS@8

; 5244 :       TraceLineI( "(sy) Reason code = ", GetLastError( ) );

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	push	OFFSET $SG99423
	call	_TraceLineI@8

; 5245 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnSysOpenF
$LN37@fnSysOpenF:

; 5246 :    }
; 5247 : 
; 5248 :    // If we got here, then a file open was successful.
; 5249 :    // Create an open file record on the AnchorBlock chain.
; 5250 :    {
; 5251 :       zPVOID hOpenFile;
; 5252 : 
; 5253 :       // We need to allocate and initialize an OpenFile record and then
; 5254 :       // chain it to the task block.
; 5255 :       hOpenFile = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10028					; 0000272cH
	push	0
	push	1
	push	558					; 0000022eH
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hOpenFile$6[ebp], eax

; 5256 :                                     sizeof( OpenFileRecord ), 1, 0, iOpenFile );
; 5257 :       if ( hOpenFile )

	cmp	DWORD PTR _hOpenFile$6[ebp], 0
	je	$LN38@fnSysOpenF

; 5258 :       {
; 5259 :          zLONG lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$1[ebp], eax

; 5260 :          zBOOL bMutexLocked;
; 5261 : 
; 5262 :          lpOpenFile = zGETPTR( hOpenFile );

	mov	ecx, DWORD PTR _hOpenFile$6[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 5263 : 
; 5264 :          if ( zGETHNDL( lpTask ) == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [ecx+106]
	jne	SHORT $LN39@fnSysOpenF

; 5265 :          {
; 5266 :             bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$8[ebp], 1

; 5267 :             zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 5268 :          }

	jmp	SHORT $LN40@fnSysOpenF
$LN39@fnSysOpenF:

; 5269 :          else
; 5270 :             bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$8[ebp], 0
$LN40@fnSysOpenF:

; 5271 : 
; 5272 :          // Now chain the OpenFile record to the task block.
; 5273 :          lpOpenFile->hNextOpenFile = lpTask->hFirstOpenFile;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+118]
	mov	DWORD PTR [edx+6], ecx

; 5274 :          lpTask->hFirstOpenFile    = hOpenFile;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _hOpenFile$6[ebp]
	mov	DWORD PTR [edx+118], eax

; 5275 :          lpOpenFile->lProcessID    = lProcessID;

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR _lProcessID$1[ebp]
	mov	DWORD PTR [ecx+2], edx

; 5276 :          lpOpenFile->nFlags        = nFlags;

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	cx, WORD PTR _nFlags$[ebp]
	mov	WORD PTR [eax+10], cx

; 5277 :          lpOpenFile->lFileHandle   = (zLONG) hFile;

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR _hFile$[ebp]
	mov	DWORD PTR [edx+12], eax

; 5278 :          zstrcpy( lpOpenFile->szFileName, cpcFileName );

	mov	ecx, DWORD PTR _cpcFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	_strcpy
	add	esp, 8

; 5279 :          zstrcpy( lpOpenFile->szTempFileName, szTempFileName );

	lea	eax, DWORD PTR _szTempFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	add	ecx, 273				; 00000111H
	push	ecx
	call	_strcpy
	add	esp, 8

; 5280 : 
; 5281 :          if ( bMutexLocked )

	movzx	edx, BYTE PTR _bMutexLocked$8[ebp]
	test	edx, edx
	je	SHORT $LN38@fnSysOpenF

; 5282 :             zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN38@fnSysOpenF:

; 5283 :       }
; 5284 :    }
; 5285 : 
; 5286 : // TraceLine( "fnSysOpenFile %s   Handle: 0x%08x   Task: 0x%08x",
; 5287 : //            cpcFileName, hFile, lpTask );
; 5288 : 
; 5289 :    return( (zLONG) hFile );  // return the handle to the file

	mov	eax, DWORD PTR _hFile$[ebp]
$LN1@fnSysOpenF:

; 5290 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSysOpenFile@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_cd$1 = -65620						; size = 12
_nRC$ = -65608						; size = 4
_v$2 = -65604						; size = 4
_hTask$3 = -65600					; size = 4
_pchMsg$ = -65596					; size = 4
_g_szMessage$ = -65592					; size = 65536
_szFormattedDateTime$4 = -56				; size = 30
_szCurrentDateTime$5 = -24				; size = 20
__$ArrayPad$ = -4					; size = 4
_cpcMessage$ = 8					; size = 4
_SysMessageList@4 PROC

; 4548 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 65620				; 00010054H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4549 :    int    nRC = zCALL_ERROR;  // Default rc to zCALL_ERROR

	mov	DWORD PTR _nRC$[ebp], -16		; fffffff0H

; 4550 :    zPCHAR pchMsg;
; 4551 : 
; 4552 : #define zTRACE_LTH  65535
; 4553 :    char g_szMessage[ zTRACE_LTH + 1 ];  // SysMessageList
; 4554 : 
; 4555 :    if ( AnchorBlock && AnchorBlock->bTraceCnt == FALSE )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN2@SysMessage
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	shr	ecx, 1
	and	ecx, 1
	jne	SHORT $LN2@SysMessage

; 4556 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SysMessage
$LN2@SysMessage:

; 4557 : 
; 4558 :    pchMsg = g_szMessage;

	lea	edx, DWORD PTR _g_szMessage$[ebp]
	mov	DWORD PTR _pchMsg$[ebp], edx

; 4559 :    *pchMsg = *cpcMessage;

	mov	eax, DWORD PTR _pchMsg$[ebp]
	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 4560 : 
; 4561 :    pchMsg[ 1 ] = 0;  // force null termination of message

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchMsg$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 4562 :    if ( AnchorBlock && AnchorBlock->bShowTaskID )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN3@SysMessage
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1495]
	and	eax, 1
	je	$LN3@SysMessage

; 4563 :    {
; 4564 :       static zCHAR szLastDateTime[ 20 ] = "";
; 4565 :       zCHAR szCurrentDateTime[ 20 ];
; 4566 :       zCHAR szFormattedDateTime[ 30 ];
; 4567 :       zLONG hTask = 0;

	mov	DWORD PTR _hTask$3[ebp], 0

; 4568 :       zVIEW v = GetDefaultViewForActiveTask( );

	call	_GetDefaultViewForActiveTask@0
	mov	DWORD PTR _v$2[ebp], eax

; 4569 : 
; 4570 :       if ( v )

	cmp	DWORD PTR _v$2[ebp], 0
	je	SHORT $LN5@SysMessage

; 4571 :          hTask = (zLONG) v->hTask;

	mov	ecx, DWORD PTR _v$2[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hTask$3[ebp], edx
$LN5@SysMessage:

; 4572 : 
; 4573 :       if ( hTask == 0 )

	cmp	DWORD PTR _hTask$3[ebp], 0
	jne	SHORT $LN6@SysMessage

; 4574 :          hTask = (zLONG) AnchorBlock->hMainTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	mov	DWORD PTR _hTask$3[ebp], ecx
$LN6@SysMessage:

; 4575 : 
; 4576 :       SysGetDateTime( szCurrentDateTime );

	lea	edx, DWORD PTR _szCurrentDateTime$5[ebp]
	push	edx
	call	_SysGetDateTime@4

; 4577 :       if ( zstrncmp( szLastDateTime, szCurrentDateTime, 6 ) == 0 )

	push	6
	lea	eax, DWORD PTR _szCurrentDateTime$5[ebp]
	push	eax
	push	OFFSET ?szLastDateTime@?2??SysMessageList@@9@9
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@SysMessage

; 4578 :       {
; 4579 :          // Current date matches last date so we'll just display the time.
; 4580 :          UfFormatDateTime( szFormattedDateTime, szCurrentDateTime,

	push	OFFSET $SG99183
	lea	ecx, DWORD PTR _szCurrentDateTime$5[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFormattedDateTime$4[ebp]
	push	edx
	call	_UfFormatDateTime@12

; 4581 :                            "HH:MI:SS.999" );
; 4582 :       }

	jmp	SHORT $LN8@SysMessage
$LN7@SysMessage:

; 4583 :       else
; 4584 :       {
; 4585 :          // Current date is different from the date of the last message.
; 4586 :          // Print the date and time.
; 4587 :          UfFormatDateTime( szFormattedDateTime, szCurrentDateTime,

	push	OFFSET $SG99184
	lea	eax, DWORD PTR _szCurrentDateTime$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFormattedDateTime$4[ebp]
	push	ecx
	call	_UfFormatDateTime@12

; 4588 :                            "YYYY-MM-DD HH:MI:SS.999" );
; 4589 :          zstrcpy( szLastDateTime, szCurrentDateTime );

	lea	edx, DWORD PTR _szCurrentDateTime$5[ebp]
	push	edx
	push	OFFSET ?szLastDateTime@?2??SysMessageList@@9@9
	call	_strcpy
	add	esp, 8
$LN8@SysMessage:

; 4590 :       }
; 4591 : 
; 4592 :       zsprintf( pchMsg, "%s Task(%x) : ", szFormattedDateTime, hTask );

	mov	eax, DWORD PTR _hTask$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFormattedDateTime$4[ebp]
	push	ecx
	push	OFFSET $SG99185
	mov	edx, DWORD PTR _pchMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 4593 :       zstrncat( pchMsg, (zPCHAR) cpcMessage, zTRACE_LTH - zstrlen( pchMsg ) );

	mov	eax, DWORD PTR _pchMsg$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, 65535				; 0000ffffH
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH

; 4594 :    }

	jmp	SHORT $LN4@SysMessage
$LN3@SysMessage:

; 4595 :    else
; 4596 :    if ( *cpcMessage )

	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN4@SysMessage

; 4597 :    {
; 4598 :       zstrncat( pchMsg + 1, cpcMessage + 1, zTRACE_LTH - 1 );

	push	65534					; 0000fffeH
	mov	eax, DWORD PTR _cpcMessage$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _pchMsg$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH
$LN4@SysMessage:

; 4599 :    }
; 4600 : 
; 4601 :    if ( AnchorBlock && AnchorBlock->lOE_hListWnd )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN10@SysMessage
	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+98], 0
	je	SHORT $LN10@SysMessage

; 4602 :    {
; 4603 :       COPYDATASTRUCT cd;
; 4604 : 
; 4605 :       cd.dwData = LB_ADDSTRING;

	mov	DWORD PTR _cd$1[ebp], 384		; 00000180H

; 4606 :       cd.lpData = pchMsg;

	mov	eax, DWORD PTR _pchMsg$[ebp]
	mov	DWORD PTR _cd$1[ebp+8], eax

; 4607 :       cd.cbData = zstrlen( (zPCHAR) cd.lpData ) + 1;

	mov	ecx, DWORD PTR _cd$1[ebp+8]
	push	ecx
	call	_strlen
	add	esp, 4
	add	eax, 1
	mov	DWORD PTR _cd$1[ebp+4], eax

; 4608 : 
; 4609 : #ifdef __MUTEX_DEBUG__
; 4610 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 4611 :    // fnPrintMutexInfo( 's', zMUTEX_COUNT, __FILE__, __LINE__ ); recursion
; 4612 : #endif
; 4613 : 
; 4614 :       // Use WM_COPYDATA to send the message so we don't have any memory leaks.
; 4615 :       SendMessage( (HWND) AnchorBlock->lOE_hListWnd,

	lea	edx, DWORD PTR _cd$1[ebp]
	push	edx
	push	0
	push	74					; 0000004aH
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 4616 :                    WM_COPYDATA, 0, (LPARAM) &cd );
; 4617 : 
; 4618 : #ifdef __MUTEX_DEBUG__
; 4619 :       // We use 'zMUTEX_COUNT' as an ID for SendMessage.
; 4620 :      // fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ ); recursion
; 4621 : #endif
; 4622 : 
; 4623 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0

; 4624 :    }

	jmp	SHORT $LN11@SysMessage
$LN10@SysMessage:

; 4625 :    else
; 4626 :       SysMessageBox( 0, "OE Trace Unavailable", pchMsg, -1 );

	push	-1
	mov	edx, DWORD PTR _pchMsg$[ebp]
	push	edx
	push	OFFSET $SG99189
	push	0
	call	_SysMessageBox@16
$LN11@SysMessage:

; 4627 : 
; 4628 :    return( nRC );

	mov	eax, DWORD PTR _nRC$[ebp]
$LN1@SysMessage:

; 4629 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_SysMessageList@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$1 = -24						; size = 4
tv89 = -20						; size = 4
_sz$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_cpcTitle$ = 12						; size = 4
_cpcMessage$ = 16					; size = 4
_nBeep$ = 20						; size = 4
_SysMessageBox@16 PROC

; 4502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4503 :    zCHAR  sz[ 10 ];
; 4504 : 
; 4505 :    SysReadZeidonIni( -1, "[ObjectEngine]", "WebUserErrorMessages", sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	push	OFFSET $SG99149
	push	OFFSET $SG99150
	push	-1
	call	_SysReadZeidonIni@16

; 4506 :    if ( sz[ 0 ] == 'Y' || sz[ 0 ] == 'y' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$[ebp+edx]
	cmp	eax, 89					; 00000059H
	je	SHORT $LN4@SysMessage
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$[ebp+edx]
	cmp	eax, 121				; 00000079H
	jne	SHORT $LN2@SysMessage
$LN4@SysMessage:

; 4507 :    {
; 4508 :       TraceLine( "SysMessageBox Title: %s   Error: %s",

	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcTitle$[ebp]
	push	edx
	push	OFFSET $SG99154
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 4509 :                  cpcTitle, cpcMessage );
; 4510 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@SysMessage

; 4511 :    }

	jmp	SHORT $LN1@SysMessage
$LN2@SysMessage:

; 4512 :    else
; 4513 :    {
; 4514 :       if ( nBeep == -1 )  // no valid tasks/view exist

	cmp	DWORD PTR _nBeep$[ebp], -1
	jne	SHORT $LN5@SysMessage

; 4515 :       {
; 4516 :          MessageBox( GetActiveWindow( ), cpcMessage, cpcTitle,

	push	8208					; 00002010H
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 4517 :                      MB_ICONSTOP | MB_OK | MB_TASKMODAL );
; 4518 :          return( MB_OK );

	xor	eax, eax
	jmp	SHORT $LN1@SysMessage

; 4519 :       }

	jmp	SHORT $LN1@SysMessage
$LN5@SysMessage:

; 4520 :       else
; 4521 :       {
; 4522 :          LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN8@SysMessage
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN9@SysMessage
$LN8@SysMessage:
	mov	DWORD PTR tv89[ebp], 0
$LN9@SysMessage:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR _lpTask$1[ebp], ecx

; 4523 : 
; 4524 :          return( fnSysMessageBox( lpTask, cpcTitle, cpcMessage, nBeep ) );

	mov	edx, DWORD PTR _nBeep$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$1[ebp]
	push	edx
	call	_fnSysMessageBox@16
$LN1@SysMessage:

; 4525 :       }
; 4526 :    }
; 4527 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysMessageBox@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_uRC$ = -524						; size = 4
_hLogFile$1 = -520					; size = 4
_szLogFileName$2 = -516					; size = 256
_sz$3 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_cpcTitle$ = 12						; size = 4
_cpcMessage$ = 16					; size = 4
_nBeep$ = 20						; size = 4
_fnSysMessageBox@16 PROC

; 4425 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4426 :    unsigned uRC;
; 4427 :    static zCHAR cShowPopup = ' ';
; 4428 : 
; 4429 :    // If we are connected to OE, print in message list.
; 4430 :    if ( AnchorBlock && AnchorBlock->lOE_hListWnd )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN2@fnSysMessa
	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+98], 0
	je	SHORT $LN2@fnSysMessa

; 4431 :       SysMessageList( cpcMessage );

	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	call	_SysMessageList@4
$LN2@fnSysMessa:

; 4432 : 
; 4433 :    // If we are a server app then we don't wan't to actually pop up a message.
; 4434 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	$LN3@fnSysMessa

; 4435 :    {
; 4436 :       if ( cShowPopup == ' ' )

	movsx	edx, BYTE PTR ?cShowPopup@?1??fnSysMessageBox@@9@9
	cmp	edx, 32					; 00000020H
	jne	$LN4@fnSysMessa

; 4437 :       {
; 4438 :          if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN5@fnSysMessa

; 4439 :             lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN5@fnSysMessa:

; 4440 : 
; 4441 :       // if ( lpTask && lpTask->bServer )  don't care if server or not
; 4442 :          if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN6@fnSysMessa

; 4443 :          {
; 4444 :             zCHAR sz[ zMAX_FILENAME_LTH ];
; 4445 : 
; 4446 :             // Check a flag in the Zeidon INI to see if we should pop up the msg.
; 4447 :             SysReadZeidonIni( -1, "[Debug]", "ServerDebug", sz );

	lea	edx, DWORD PTR _sz$3[ebp]
	push	edx
	push	OFFSET $SG99122
	push	OFFSET $SG99123
	push	-1
	call	_SysReadZeidonIni@16

; 4448 :             if ( *sz == 0 ||

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sz$3[ebp+ecx]
	test	edx, edx
	je	SHORT $LN10@fnSysMessa
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sz$3[ebp+ecx]
	test	edx, edx
	je	SHORT $LN8@fnSysMessa
	movsx	eax, BYTE PTR _sz$3[ebp+1]
	test	eax, eax
	jne	SHORT $LN8@fnSysMessa
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$3[ebp+edx]
	cmp	eax, 89					; 00000059H
	je	SHORT $LN10@fnSysMessa
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$3[ebp+edx]
	cmp	eax, 121				; 00000079H
	je	SHORT $LN10@fnSysMessa
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$3[ebp+edx]
	cmp	eax, 49					; 00000031H
	jne	SHORT $LN8@fnSysMessa
$LN10@fnSysMessa:

; 4449 :                  ((*sz && *(sz + 1) == 0) &&
; 4450 :                   (*sz == 'Y' || *sz == 'y' || *sz == '1')) )
; 4451 :             {
; 4452 :                cShowPopup = 'Y';

	mov	BYTE PTR ?cShowPopup@?1??fnSysMessageBox@@9@9, 89 ; 00000059H

; 4453 :             }

	jmp	$LN9@fnSysMessa
$LN8@fnSysMessa:

; 4454 :             else
; 4455 :             {
; 4456 :                cShowPopup = 'N';

	mov	BYTE PTR ?cShowPopup@?1??fnSysMessageBox@@9@9, 78 ; 0000004eH

; 4457 :                if ( *sz && *(sz + 1) )  // assume log file name

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _sz$3[ebp+edx]
	test	eax, eax
	je	$LN9@fnSysMessa
	movsx	ecx, BYTE PTR _sz$3[ebp+1]
	test	ecx, ecx
	je	SHORT $LN9@fnSysMessa

; 4458 :                {
; 4459 :                   zCHAR szLogFileName[ zMAX_FILENAME_LTH ];
; 4460 :                   zLONG hLogFile;
; 4461 : 
; 4462 :                   SysConvertEnvironmentString( szLogFileName, sz );

	lea	edx, DWORD PTR _sz$3[ebp]
	push	edx
	lea	eax, DWORD PTR _szLogFileName$2[ebp]
	push	eax
	call	_SysConvertEnvironmentString@8

; 4463 :                   if ( (hLogFile = fnSysOpenFile( lpTask, szLogFileName,
; 4464 :                                                   COREFILE_APPEND )) != -1 )

	push	448					; 000001c0H
	lea	ecx, DWORD PTR _szLogFileName$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hLogFile$1[ebp], eax
	cmp	DWORD PTR _hLogFile$1[ebp], -1
	je	SHORT $LN13@fnSysMessa

; 4465 :                   {
; 4466 :                      fnSysWriteLine( lpTask, hLogFile, 0, cpcMessage );

	mov	eax, DWORD PTR _cpcMessage$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _hLogFile$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteLine@16

; 4467 :                      fnSysCloseFile( lpTask, hLogFile, 0 );

	push	0
	mov	eax, DWORD PTR _hLogFile$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 4468 :                   }

	jmp	SHORT $LN9@fnSysMessa
$LN13@fnSysMessa:

; 4469 :                   else
; 4470 :                   {
; 4471 :                      TraceLine( "Message Handler Error opening log file (%s) for message: %s",

	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	lea	eax, DWORD PTR _szLogFileName$2[ebp]
	push	eax
	push	OFFSET $SG99131
	call	_TraceLine
	add	esp, 12					; 0000000cH
$LN9@fnSysMessa:

; 4472 :                                 szLogFileName, cpcMessage );
; 4473 :                   }
; 4474 :                }
; 4475 :             }
; 4476 :          }

	jmp	SHORT $LN4@fnSysMessa
$LN6@fnSysMessa:

; 4477 :          else
; 4478 :             cShowPopup = 'Y';

	mov	BYTE PTR ?cShowPopup@?1??fnSysMessageBox@@9@9, 89 ; 00000059H
$LN4@fnSysMessa:

; 4479 :       }
; 4480 : 
; 4481 :       if ( cShowPopup == 'N' )

	movsx	ecx, BYTE PTR ?cShowPopup@?1??fnSysMessageBox@@9@9
	cmp	ecx, 78					; 0000004eH
	jne	SHORT $LN3@fnSysMessa

; 4482 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnSysMessa
$LN3@fnSysMessa:

; 4483 :    }
; 4484 : 
; 4485 : // if ( nBeep )                   the beep is generated by MB_ICONSTOP in the
; 4486 : //    MessageBeep( MB_ICONSTOP ); call to MessageBox below ... dks 2005.04.28
; 4487 : 
; 4488 :    if ( nBeep <= 1 || nBeep > 6 )

	cmp	DWORD PTR _nBeep$[ebp], 1
	jle	SHORT $LN18@fnSysMessa
	cmp	DWORD PTR _nBeep$[ebp], 6
	jle	SHORT $LN16@fnSysMessa
$LN18@fnSysMessa:

; 4489 :       nBeep = 0;

	mov	DWORD PTR _nBeep$[ebp], 0
	jmp	SHORT $LN17@fnSysMessa
$LN16@fnSysMessa:

; 4490 :    else
; 4491 :    if ( nBeep == 6 )

	cmp	DWORD PTR _nBeep$[ebp], 6
	jne	SHORT $LN17@fnSysMessa

; 4492 :       nBeep = 1;

	mov	DWORD PTR _nBeep$[ebp], 1
$LN17@fnSysMessa:

; 4493 : 
; 4494 :    uRC = MessageBox( GetActiveWindow( ), cpcMessage, cpcTitle,

	mov	edx, DWORD PTR _nBeep$[ebp]
	or	edx, 8208				; 00002010H
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16
	mov	DWORD PTR _uRC$[ebp], eax

; 4495 :                      MB_ICONSTOP | MB_OK | MB_TASKMODAL | nBeep );
; 4496 :    return( uRC );

	mov	eax, DWORD PTR _uRC$[ebp]
$LN1@fnSysMessa:

; 4497 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysMessageBox@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_SysMessageBeep@0 PROC

; 7809 : {

	push	ebp
	mov	ebp, esp

; 7810 :    MessageBeep( 0 );       // ring the buzzer...

	push	0
	call	DWORD PTR __imp__MessageBeep@4

; 7811 : }

	pop	ebp
	ret	0
_SysMessageBeep@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pMemory$ = 8						; size = 4
_SysMemSize@4 PROC

; 3305 : {

	push	ebp
	mov	ebp, esp

; 3306 :    return( (zULONG) _msize( pMemory ) );

	mov	eax, DWORD PTR _pMemory$[ebp]
	push	eax
	call	DWORD PTR __imp___msize
	add	esp, 4

; 3307 : }

	pop	ebp
	ret	4
_SysMemSize@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pvMemory$ = -4						; size = 4
_lSize$ = 8						; size = 4
_SysMalloc@4 PROC

; 3167 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3168 :    zPVOID pvMemory;
; 3169 : 
; 3170 : #ifdef DEBUG_MALLOC
; 3171 :    zLONG  k;
; 3172 : 
; 3173 :    if ( lSize <= -2 )
; 3174 :    {
; 3175 :       TraceLine( "SysMalloc Initializing Memory Usage ===============================> Size: %d", lSize );
; 3176 :       g_lHighWaterMark = -1;
; 3177 :    }
; 3178 : 
; 3179 :    if ( g_lHighWaterMark == -1 )
; 3180 :    {
; 3181 :       for ( k = 0; k < zMAX_ALLOC_TEST; k++ )
; 3182 :          g_pvAlloc[ k ] = 0;
; 3183 :    }
; 3184 : 
; 3185 :    if ( lSize <= 0 )
; 3186 :    {
; 3187 :       TraceLine( "SysMalloc Reporting Memory Usage ===============================> High Water Mark: %d", g_lHighWaterMark );
; 3188 :       for ( k = 0; k < g_lHighWaterMark; k += 2 )
; 3189 :       {
; 3190 :          if ( g_pvAlloc[ k ] )
; 3191 :          {
; 3192 :             TraceLine( "== %06d ============> Mem: 0x%08x  Size: %d",
; 3193 :                        k, g_pvAlloc[ k ], g_pvAlloc[ k + 1 ] );
; 3194 :          }
; 3195 :       }
; 3196 : 
; 3197 :    // g_lHighWaterMark = -1;
; 3198 :       return( 0 );
; 3199 :    }
; 3200 : 
; 3201 :    for ( k = 0; k < zMAX_ALLOC_TEST; k += 2 )
; 3202 :    {
; 3203 :       if ( g_pvAlloc[ k ] == 0 )
; 3204 :          break;
; 3205 :    }
; 3206 : 
; 3207 : #endif
; 3208 : 
; 3209 :    pvMemory = calloc( lSize, 1 );  // allocate the memory!!!

	push	1
	mov	eax, DWORD PTR _lSize$[ebp]
	push	eax
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR _pvMemory$[ebp], eax

; 3210 : 
; 3211 : #ifdef DEBUG_MALLOC
; 3212 : 
; 3213 :    if ( lSize == 262000 )
; 3214 :       TraceLine( "SysMalloc Size: %d   Mem: 0x%08x", lSize, pvMemory );
; 3215 : 
; 3216 :    if ( k == 18 || k == 12 || k == 14 || k == 16 )
; 3217 :       TraceLine( "SysMalloc (%d) Size: %d   Mem: 0x%08x", k, lSize, pvMemory );
; 3218 : 
; 3219 :    if ( k >= zMAX_ALLOC_TEST )
; 3220 :       MessageBox( 0, "SysMalloc Error", "Memory Test Error", MB_OK );
; 3221 :    else
; 3222 :    {
; 3223 :       if ( g_lHighWaterMark < k )
; 3224 :          g_lHighWaterMark = k;
; 3225 : 
; 3226 :       g_pvAlloc[ k ] = pvMemory;
; 3227 :       g_pvAlloc[ k + 1 ] = (HANDLE) lSize;
; 3228 :    }
; 3229 : 
; 3230 : #endif
; 3231 : 
; 3232 :    return( pvMemory );

	mov	eax, DWORD PTR _pvMemory$[ebp]

; 3233 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysMalloc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lProcessID$ = -828					; size = 4
tv153 = -824						; size = 4
tv152 = -820						; size = 4
_lLibOS$ = -816						; size = 4
_nUnqualLth$ = -812					; size = 2
_hLibrary$ = -808					; size = 4
_lpApp$ = -804						; size = 4
_bQualified$ = -797					; size = 1
_lpTask$ = -796						; size = 4
_pchUnqualifiedName$ = -792				; size = 4
_bMutexLocked$1 = -785					; size = 1
_lpLibrary$ = -784					; size = 4
_szCurrentDir$ = -780					; size = 257
_szMsg$2 = -520						; size = 256
_szFileName$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_cpcLibraryName$ = 12					; size = 4
_lFlag$ = 16						; size = 4
_SysLoadLibraryWithErrFlag@12 PROC

; 6926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 828				; 0000033cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6927 :    LPTASK     lpTask;
; 6928 :    LPAPP      lpApp;
; 6929 :    LPLIBRARY  hLibrary;
; 6930 :    LPLIBRARY  lpLibrary;
; 6931 :    zLONG      lLibOS;
; 6932 :    char       szFileName[ zMAX_FILENAME_LTH + 1 ];
; 6933 :    char       szCurrentDir[ zMAX_FILENAME_LTH + 1 ];
; 6934 :    char       *pchUnqualifiedName;
; 6935 :    zBOOL      bQualified;
; 6936 :    zSHORT     nUnqualLth;
; 6937 :    zLONG      lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 6938 : 
; 6939 :    // If AnchorBlock or application task does not exist, return zero.
; 6940 :    if ( AnchorBlock == 0 || lpTaskView == 0 ||

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN5@SysLoadLib
	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN5@SysLoadLib
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN4@SysLoadLib
$LN5@SysLoadLib:

; 6941 :         (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )
; 6942 :    {
; 6943 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SysLoadLib
$LN4@SysLoadLib:

; 6944 :    }
; 6945 : 
; 6946 :    if ( lpTaskView )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN6@SysLoadLib

; 6947 :    {
; 6948 :       if ( fnValidView( lpTask, lpTaskView ) == 0 )

	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN8@SysLoadLib

; 6949 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@SysLoadLib
$LN8@SysLoadLib:

; 6950 : 
; 6951 :       if ( fnGetApplicationForSubtask( &lpApp, lpTaskView ) != 0 )

	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN9@SysLoadLib

; 6952 :          return( 0 );

	xor	eax, eax
	jmp	$LN1@SysLoadLib
$LN9@SysLoadLib:

; 6953 :    }

	jmp	SHORT $LN7@SysLoadLib
$LN6@SysLoadLib:

; 6954 :    else
; 6955 :    {
; 6956 :       lpApp = zGETPTR( lpTask->hApp );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 6957 :       if ( lpApp == 0 )

	cmp	DWORD PTR _lpApp$[ebp], 0
	jne	SHORT $LN7@SysLoadLib

; 6958 :          lpApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax
$LN7@SysLoadLib:

; 6959 :    }
; 6960 : 
; 6961 :    zstrcpy( szFileName, cpcLibraryName );

	mov	eax, DWORD PTR _cpcLibraryName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6962 :    SysTranslateString( szFileName, 'U' );

	push	85					; 00000055H
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysTranslateString@8

; 6963 : 
; 6964 :    // Check to see if library name is qualified.
; 6965 :    pchUnqualifiedName = zstrrchr( szFileName, cDirSep );

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	mov	DWORD PTR _pchUnqualifiedName$[ebp], eax

; 6966 :    if ( pchUnqualifiedName )

	cmp	DWORD PTR _pchUnqualifiedName$[ebp], 0
	je	SHORT $LN11@SysLoadLib

; 6967 :    {
; 6968 :       bQualified = TRUE;

	mov	BYTE PTR _bQualified$[ebp], 1

; 6969 :       pchUnqualifiedName++;         // point to file name

	mov	edx, DWORD PTR _pchUnqualifiedName$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchUnqualifiedName$[ebp], edx

; 6970 :    }

	jmp	SHORT $LN12@SysLoadLib
$LN11@SysLoadLib:

; 6971 :    else
; 6972 :    {
; 6973 :       bQualified = FALSE;

	mov	BYTE PTR _bQualified$[ebp], 0

; 6974 :       pchUnqualifiedName = szFileName;

	lea	eax, DWORD PTR _szFileName$[ebp]
	mov	DWORD PTR _pchUnqualifiedName$[ebp], eax
$LN12@SysLoadLib:

; 6975 :    }
; 6976 : 
; 6977 :    nUnqualLth = zstrlen( pchUnqualifiedName );

	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nUnqualLth$[ebp], ax

; 6978 : 
; 6979 :    // If module is already loaded for this application task, get out quick!
; 6980 :    lpLibrary = zGETPTR( lpTask->hFirstLibrary );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+122]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax
$LN2@SysLoadLib:

; 6981 :    while ( lpLibrary )

	cmp	DWORD PTR _lpLibrary$[ebp], 0
	je	$LN3@SysLoadLib

; 6982 :    {
; 6983 :       // Name and flags must match!
; 6984 :       if ( zstrcmp( pchUnqualifiedName, lpLibrary->szName ) == 0 &&
; 6985 :            (lFlag & zLOADLIB_RESOURCES) == (lpLibrary->lFlag & zLOADLIB_RESOURCES) &&

	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	cmp	edx, ecx
	jne	SHORT $LN25@SysLoadLib
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _pchUnqualifiedName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv153[ebp], eax
	jmp	SHORT $LN26@SysLoadLib
$LN25@SysLoadLib:
	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	movsx	ecx, BYTE PTR [eax+6]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN23@SysLoadLib
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN24@SysLoadLib
$LN23@SysLoadLib:
	mov	DWORD PTR tv152[ebp], -1
$LN24@SysLoadLib:
	mov	edx, DWORD PTR tv152[ebp]
	mov	DWORD PTR tv153[ebp], edx
$LN26@SysLoadLib:
	cmp	DWORD PTR tv153[ebp], 0
	jne	SHORT $LN13@SysLoadLib
	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 2
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR [ecx+267]
	and	edx, 2
	cmp	eax, edx
	jne	SHORT $LN13@SysLoadLib
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+271]
	cmp	ecx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN13@SysLoadLib

; 6986 :            lpLibrary->lProcessID == lProcessID )
; 6987 :       {
; 6988 :          lpLibrary->ulUseCnt++;

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+275]
	add	eax, 1
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	DWORD PTR [ecx+275], eax

; 6989 :          return( zGETHNDL( lpLibrary ) );

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	jmp	$LN1@SysLoadLib
$LN13@SysLoadLib:

; 6990 :       }
; 6991 : 
; 6992 :       lpLibrary = zGETPTR( lpLibrary->hNextLibrary );

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 6993 :    }

	jmp	$LN2@SysLoadLib
$LN3@SysLoadLib:

; 6994 : 
; 6995 :    // Environment specific code begins here =================================
; 6996 : 
; 6997 :    // Set the current working directory.
; 6998 :    GetCurrentDirectory( zMAX_FILENAME_LTH + 1, szCurrentDir );

	lea	edx, DWORD PTR _szCurrentDir$[ebp]
	push	edx
	push	257					; 00000101H
	call	DWORD PTR __imp__GetCurrentDirectoryA@8

; 6999 :    SetCurrentDirectory( lpApp->szLibraryDir );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 90					; 0000005aH
	push	eax
	call	DWORD PTR __imp__SetCurrentDirectoryA@4

; 7000 : 
; 7001 :    zstrcat( szFileName, ".dll" );

	push	OFFSET $SG100025
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 7002 : 
; 7003 :    if ( lFlag & zLOADLIB_RESOURCES )

	mov	edx, DWORD PTR _lFlag$[ebp]
	and	edx, 2
	je	SHORT $LN14@SysLoadLib

; 7004 :       lLibOS = (zLONG) LoadLibraryEx( szFileName, 0,

	push	2
	push	0
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadLibraryExA@12
	mov	DWORD PTR _lLibOS$[ebp], eax
	jmp	SHORT $LN15@SysLoadLib
$LN14@SysLoadLib:

; 7005 :                                       LOAD_LIBRARY_AS_DATAFILE );
; 7006 :    else
; 7007 :       lLibOS = (zLONG) LoadLibrary( szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _lLibOS$[ebp], eax
$LN15@SysLoadLib:

; 7008 : 
; 7009 :    SetCurrentDirectory( szCurrentDir );

	lea	edx, DWORD PTR _szCurrentDir$[ebp]
	push	edx
	call	DWORD PTR __imp__SetCurrentDirectoryA@4

; 7010 : 
; 7011 :    if ( lLibOS == 0 )

	cmp	DWORD PTR _lLibOS$[ebp], 0
	jne	$LN16@SysLoadLib

; 7012 :    {
; 7013 :       TraceLine( "(sy) SysLoadLibrary failed to load file: \"%s\"  "

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 90					; 0000005aH
	push	eax
	call	DWORD PTR __imp__GetLastError@0
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET $SG100029
	call	_TraceLine
	add	esp, 16					; 00000010H

; 7014 :                    "with error code = %d  using Current directory: %s",
; 7015 :                  szFileName, (zLONG) GetLastError( ), lpApp->szLibraryDir );
; 7016 :       if ( lFlag & zLOADLIB_WITHERR )

	mov	edx, DWORD PTR _lFlag$[ebp]
	and	edx, 1
	je	SHORT $LN17@SysLoadLib

; 7017 :       {
; 7018 :          char  szMsg[ 256 ];
; 7019 : 
; 7020 :          zsprintf( szMsg, "Load failed for: %s (%s)", cpcLibraryName, szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcLibraryName$[ebp]
	push	ecx
	push	OFFSET $SG100031
	lea	edx, DWORD PTR _szMsg$2[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 7021 :          MessageSend( lpTaskView, "SY00101", "System Services", szMsg,

	push	1
	push	1000					; 000003e8H
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	push	OFFSET $SG100032
	push	OFFSET $SG100033
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_MessageSend@24
$LN17@SysLoadLib:

; 7022 :                       zMSGQ_SYSTEM_ERROR, 1 );
; 7023 :       }
; 7024 : 
; 7025 :       // Trace the dll name always on failure!!!
; 7026 :       TraceLine( "Load failed for: %s (%s)", cpcLibraryName, szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcLibraryName$[ebp]
	push	eax
	push	OFFSET $SG100034
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 7027 : 
; 7028 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SysLoadLib
$LN16@SysLoadLib:

; 7029 :    }
; 7030 : 
; 7031 : // TraceLine( "LoadLibrary Task (0x%08x) successful for: %s (%s)",
; 7032 : //            zGETHNDL( lpTask ), cpcLibraryName, szFileName );
; 7033 : 
; 7034 :    // Environment specific code ends here ===================================
; 7035 : 
; 7036 :    // Allocate a Library record for the current task.
; 7037 :    hLibrary = fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10025					; 00002729H
	push	0
	push	1
	push	279					; 00000117H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hLibrary$[ebp], eax

; 7038 :                                 sizeof( LibraryRecord ), 1, 0, iLibrary );
; 7039 :    if ( hLibrary )

	cmp	DWORD PTR _hLibrary$[ebp], 0
	je	$LN18@SysLoadLib

; 7040 :    {
; 7041 :       zBOOL bMutexLocked;
; 7042 : 
; 7043 :       lpLibrary = zGETPTR( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7044 :       lpLibrary->lFlag    = lFlag;

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR _lFlag$[ebp]
	mov	DWORD PTR [ecx+267], edx

; 7045 :       lpLibrary->hLibrary = lLibOS;

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR _lLibOS$[ebp]
	mov	DWORD PTR [eax+263], ecx

; 7046 :       lpLibrary->ulUseCnt = 1;

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	DWORD PTR [edx+275], 1

; 7047 :       lpLibrary->lProcessID = lProcessID;

	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR _lProcessID$[ebp]
	mov	DWORD PTR [eax+271], ecx

; 7048 : 
; 7049 :       pchUnqualifiedName[ nUnqualLth ] = 0;

	movsx	edx, WORD PTR _nUnqualLth$[ebp]
	mov	eax, DWORD PTR _pchUnqualifiedName$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 7050 :       zstrcpy( lpLibrary->szName, pchUnqualifiedName );

	mov	ecx, DWORD PTR _pchUnqualifiedName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	add	edx, 6
	push	edx
	call	_strcpy
	add	esp, 8

; 7051 : 
; 7052 :    // fnTraceLibrary( lpLibrary, 1 );
; 7053 :       if ( zGETHNDL( lpTask ) == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [ecx+106]
	jne	SHORT $LN19@SysLoadLib

; 7054 :       {
; 7055 :          bMutexLocked = TRUE;

	mov	BYTE PTR _bMutexLocked$1[ebp], 1

; 7056 :          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 7057 :       }

	jmp	SHORT $LN20@SysLoadLib
$LN19@SysLoadLib:

; 7058 :       else
; 7059 :          bMutexLocked = FALSE;

	mov	BYTE PTR _bMutexLocked$1[ebp], 0
$LN20@SysLoadLib:

; 7060 : 
; 7061 :       lpLibrary->hNextLibrary = lpTask->hFirstLibrary;

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+122]
	mov	DWORD PTR [edx+2], ecx

; 7062 :       lpTask->hFirstLibrary = hLibrary;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR [edx+122], eax

; 7063 : 
; 7064 :       if ( bMutexLocked )

	movzx	ecx, BYTE PTR _bMutexLocked$1[ebp]
	test	ecx, ecx
	je	SHORT $LN18@SysLoadLib

; 7065 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN18@SysLoadLib:

; 7066 :    }
; 7067 : 
; 7068 :    return( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
$LN1@SysLoadLib:

; 7069 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysLoadLibraryWithErrFlag@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTaskView$ = 8					; size = 4
_cpcLibraryName$ = 12					; size = 4
_SysLoadLibrary@8 PROC

; 7104 : {

	push	ebp
	mov	ebp, esp

; 7105 :    return( SysLoadLibraryWithErrFlag( lpTaskView, cpcLibraryName, zLOADLIB_WITHERR ) );

	push	1
	mov	eax, DWORD PTR _cpcLibraryName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysLoadLibraryWithErrFlag@12

; 7106 : }

	pop	ebp
	ret	8
_SysLoadLibrary@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_lpView$ = 8						; size = 4
_pchUserID$ = 12					; size = 4
_pchPassword$ = 16					; size = 4
_SysGetUserID@12 PROC

; 4757 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4758 :    LPTASK lpTask;
; 4759 : 
; 4760 :    // Initialize in case of early errors.
; 4761 :    pchUserID[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchUserID$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 4762 :    pchPassword[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchPassword$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 4763 : 
; 4764 :    // OE not up, get out.
; 4765 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN2@SysGetUser

; 4766 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysGetUser
$LN2@SysGetUser:

; 4767 : 
; 4768 :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN3@SysGetUser

; 4769 :       lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN4@SysGetUser
$LN3@SysGetUser:

; 4770 :    else
; 4771 :       lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN4@SysGetUser:

; 4772 : 
; 4773 :    // No task for this caller, gonzo.
; 4774 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN5@SysGetUser

; 4775 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysGetUser
$LN5@SysGetUser:

; 4776 : 
; 4777 :    // first check for a userid at the task level.
; 4778 :    if ( zGETHNDL( lpTask ) != AnchorBlock->hMainTask && lpTask->hUserID )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _AnchorBlock
	cmp	eax, DWORD PTR [edx+106]
	je	SHORT $LN6@SysGetUser
	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+32], 0
	je	SHORT $LN6@SysGetUser

; 4779 :    {
; 4780 :       // return the userid
; 4781 :       zstrcpy( pchUserID, zGETPTR( lpTask->hUserID ) );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _pchUserID$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4782 : 
; 4783 :       // return password, if present.
; 4784 :       if ( lpTask->hPassword )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN8@SysGetUser

; 4785 :          zstrcpy( pchPassword, zGETPTR( lpTask->hPassword ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchPassword$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN8@SysGetUser:

; 4786 :    }

	jmp	SHORT $LN7@SysGetUser
$LN6@SysGetUser:

; 4787 :    else
; 4788 :    {
; 4789 :       // Next, check the system level for a userid
; 4790 :       if ( *AnchorBlock->szUserID )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, BYTE PTR [ecx+eax+1423]
	test	edx, edx
	je	SHORT $LN7@SysGetUser

; 4791 :       {
; 4792 :          // return the system userid
; 4793 :          zstrcpy( pchUserID, AnchorBlock->szUserID );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1423				; 0000058fH
	push	eax
	mov	ecx, DWORD PTR _pchUserID$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4794 : 
; 4795 :          // return the system password
; 4796 :          if ( *AnchorBlock->szPassword )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _AnchorBlock
	movsx	edx, BYTE PTR [ecx+eax+1456]
	test	edx, edx
	je	SHORT $LN7@SysGetUser

; 4797 :             zstrcpy( pchPassword, AnchorBlock->szPassword );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 1456				; 000005b0H
	push	eax
	mov	ecx, DWORD PTR _pchPassword$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN7@SysGetUser:

; 4798 :       }
; 4799 :    }
; 4800 : 
; 4801 :    return( 0 );

	xor	eax, eax
$LN1@SysGetUser:

; 4802 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetUserID@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpInternational$1 = -4					; size = 4
_pchReturnString$ = 8					; size = 4
_SysGetTimeFormat@4 PROC

; 1869 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1870 :    *pchReturnString = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 1871 : 
; 1872 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN1@SysGetTime
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+2515], 0
	je	SHORT $LN1@SysGetTime

; 1873 :    {
; 1874 :       LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$1[ebp], eax

; 1875 : 
; 1876 :       if ( lpInternational->hTimeFmt )

	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	cmp	DWORD PTR [ecx+106], 0
	je	SHORT $LN1@SysGetTime

; 1877 :          zstrcpy( pchReturnString, zGETPTR( lpInternational->hTimeFmt ) );

	mov	edx, DWORD PTR _lpInternational$1[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN1@SysGetTime:

; 1878 :    }
; 1879 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetTimeFormat@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_SysGetTickCount@0 PROC

; 8047 : {

	push	ebp
	mov	ebp, esp

; 8048 :    return( (zULONG) GetTickCount( ) );

	call	DWORD PTR __imp__GetTickCount@0

; 8049 : }

	pop	ebp
	ret	0
_SysGetTickCount@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpInternational$1 = -4					; size = 4
_pchReturnString$ = 8					; size = 4
_SysGetShortDateFormat@4 PROC

; 1897 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1898 :    *pchReturnString = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 1899 : 
; 1900 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN1@SysGetShor
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+2515], 0
	je	SHORT $LN1@SysGetShor

; 1901 :    {
; 1902 :       LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$1[ebp], eax

; 1903 : 
; 1904 :       if ( lpInternational->hShortDate )

	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	cmp	DWORD PTR [ecx+98], 0
	je	SHORT $LN1@SysGetShor

; 1905 :          zstrcpy( pchReturnString, zGETPTR( lpInternational->hShortDate ) );

	mov	edx, DWORD PTR _lpInternational$1[ebp]
	mov	eax, DWORD PTR [edx+98]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN1@SysGetShor:

; 1906 :    }
; 1907 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetShortDateFormat@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lProcessID$ = -28					; size = 4
tv139 = -24						; size = 4
tv138 = -20						; size = 4
tv86 = -16						; size = 4
tv71 = -12						; size = 4
_lThreadID$ = -8					; size = 4
_lpTask$ = -4						; size = 4
_cpcSessionId$ = 8					; size = 4
_vSubtask$ = 12						; size = 4
_bOn$ = 16						; size = 1
_cpcTitle$ = 20						; size = 4
_SetTransientTaskProcess@16 PROC

; 640  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 641  :    LPTASK lpTask;
; 642  :    zLONG  lProcessID;
; 643  :    zLONG  lThreadID;
; 644  : 
; 645  :    lProcessID = SysGetProcessID( &lThreadID );

	lea	eax, DWORD PTR _lThreadID$[ebp]
	push	eax
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 646  :    if ( vSubtask == 0 )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $LN2@SetTransie

; 647  :    {
; 648  :       TraceLine( "Session Id: %s  ==> %s (%s)  Thread: %d ... null Subtask",

	movzx	ecx, BYTE PTR _bOn$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@SetTransie
	mov	DWORD PTR tv71[ebp], OFFSET $SG98072
	jmp	SHORT $LN9@SetTransie
$LN8@SetTransie:
	mov	DWORD PTR tv71[ebp], OFFSET $SG98073
$LN9@SetTransie:
	mov	edx, DWORD PTR _lThreadID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSessionId$[ebp]
	push	edx
	push	OFFSET $SG98074
	call	_TraceLine
	add	esp, 20					; 00000014H

; 649  :                  cpcSessionId, bOn ? "ON " : "OFF", cpcTitle, lThreadID );
; 650  :       return( -1 );

	or	eax, -1
	jmp	$LN1@SetTransie
$LN2@SetTransie:

; 651  :    }
; 652  : 
; 653  :    lpTask = zGETPTR( vSubtask->hTask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 654  :    if ( lpTask->bWebTrace )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	je	SHORT $LN3@SetTransie

; 655  :    {
; 656  :       TraceLine( "STP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d",

	movzx	ecx, BYTE PTR _bOn$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@SetTransie
	mov	DWORD PTR tv86[ebp], OFFSET $SG98076
	jmp	SHORT $LN11@SetTransie
$LN10@SetTransie:
	mov	DWORD PTR tv86[ebp], OFFSET $SG98077
$LN11@SetTransie:
	mov	edx, DWORD PTR _lThreadID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv86[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSessionId$[ebp]
	push	edx
	push	OFFSET $SG98078
	call	_TraceLine
	add	esp, 28					; 0000001cH
$LN3@SetTransie:

; 657  :                  cpcSessionId, vSubtask, vSubtask->hTask, bOn ? "ON " : "OFF", cpcTitle, lThreadID );
; 658  :    }
; 659  : 
; 660  :    if ( zstrcmp( cpcSessionId, lpTask->szSessionId ) != 0 )

	mov	eax, DWORD PTR _cpcSessionId$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	cmp	ecx, eax
	jne	SHORT $LN14@SetTransie
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	mov	edx, DWORD PTR _cpcSessionId$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN15@SetTransie
$LN14@SetTransie:
	mov	eax, DWORD PTR _cpcSessionId$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+194]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN12@SetTransie
	mov	DWORD PTR tv138[ebp], 1
	jmp	SHORT $LN13@SetTransie
$LN12@SetTransie:
	mov	DWORD PTR tv138[ebp], -1
$LN13@SetTransie:
	mov	ecx, DWORD PTR tv138[ebp]
	mov	DWORD PTR tv139[ebp], ecx
$LN15@SetTransie:
	cmp	DWORD PTR tv139[ebp], 0
	je	SHORT $LN4@SetTransie

; 661  :    {
; 662  :       TraceLine( "STP S/V/T: %s/0x%08x/0x%08x  ==> Conflict with Task Session Id: %s  (%s)  Thread: %d",

	mov	edx, DWORD PTR _lThreadID$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSessionId$[ebp]
	push	edx
	push	OFFSET $SG98080
	call	_TraceLine
	add	esp, 28					; 0000001cH
$LN4@SetTransie:

; 663  :                  cpcSessionId, vSubtask, vSubtask->hTask, lpTask->szSessionId, cpcTitle, lThreadID );
; 664  :    // SysMessageBox( vSubtask, "SetTransientTaskProcess", "Conflicting Session Id's", -1 );
; 665  :    }
; 666  : 
; 667  :    if ( bOn )

	movzx	eax, BYTE PTR _bOn$[ebp]
	test	eax, eax
	je	SHORT $LN5@SetTransie

; 668  :    {
; 669  :       // Lock critical section so other threads don't muck stuff.
; 670  :       EnterCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+439]
	push	edx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 671  :    // TraceLine( "EnterCriticalSection STP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d",
; 672  :    //            cpcSessionId, vSubtask, vSubtask->hTask, bOn ? "ON " : "OFF", cpcTitle, lThreadID );
; 673  : #if 1
; 674  :       SysGetDateTime( lpTask->szTimeStamp );

	mov	eax, DWORD PTR _lpTask$[ebp]
	add	eax, 174				; 000000aeH
	push	eax
	call	_SysGetDateTime@4

; 675  : #else
; 676  :       if ( FindWebSubtask( cpcSessionId ) == vSubtask )
; 677  :       {
; 678  :          SysGetDateTime( lpTask->szTimeStamp );
; 679  :       }
; 680  :       else
; 681  :       {
; 682  :       // LeaveCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );
; 683  :          return( -1 );
; 684  :       }
; 685  : #endif
; 686  :    }

	jmp	SHORT $LN6@SetTransie
$LN5@SetTransie:

; 687  :    else
; 688  :    {
; 689  : #if 0 // The task is running as a thread within the process, so the resources should be
; 690  :       // good to go.
; 691  :       fnCloseTaskNetworkModules( lpTask );
; 692  :       fnDropTaskHandlers( lpTask );
; 693  :       fnCloseTaskOpenFiles( lpTask );
; 694  :       fnDropTaskDomains( lpTask );
; 695  :       fnFreeTaskModules( lpTask );
; 696  :       fnDropTaskOperations( lpTask );
; 697  :       fnDropTaskMutexes( lpTask );
; 698  : #endif
; 699  : 
; 700  :    // TraceLine( "LeaveCriticalSection STP S/V/T: %s/0x%08x/0x%08x  ==> %s (%s)  Thread: %d",
; 701  :    //            cpcSessionId, vSubtask, vSubtask->hTask, bOn ? "ON " : "OFF", cpcTitle, lThreadID );
; 702  :       LeaveCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+439]
	push	edx
	call	DWORD PTR __imp__LeaveCriticalSection@4
$LN6@SetTransie:

; 703  : 
; 704  :    // SysSetDefaultTaskForProcess( 0 );
; 705  :    }
; 706  : 
; 707  :    return( 0 );

	xor	eax, eax
$LN1@SetTransie:

; 708  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetTransientTaskProcess@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_SysGetTaskFromView@4 PROC

; 530  : {

	push	ebp
	mov	ebp, esp

; 531  :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN2@SysGetTask

; 532  :       return( (zLONG) lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [eax+14]
	jmp	SHORT $LN1@SysGetTask
	jmp	SHORT $LN1@SysGetTask
$LN2@SysGetTask:

; 533  :    else
; 534  :       return( 0 );

	xor	eax, eax
$LN1@SysGetTask:

; 535  : }

	pop	ebp
	ret	4
_SysGetTaskFromView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lProcessID$ = -4					; size = 4
_plThreadID$ = 8					; size = 4
_SysGetProcessID@4 PROC

; 506  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 507  :    zLONG lProcessID = (zLONG) GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _lProcessID$[ebp], eax

; 508  :    if ( plThreadID )

	cmp	DWORD PTR _plThreadID$[ebp], 0
	je	SHORT $LN2@SysGetProc

; 509  :       *plThreadID = (zLONG) GetCurrentThreadId( );

	call	DWORD PTR __imp__GetCurrentThreadId@0
	mov	ecx, DWORD PTR _plThreadID$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@SysGetProc:

; 510  : 
; 511  :    return( lProcessID );

	mov	eax, DWORD PTR _lProcessID$[ebp]

; 512  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetProcessID@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pfReturn$ = -8						; size = 4
_lpLibrary$ = -4					; size = 4
_hLibrary$ = 8						; size = 4
_cpcProcName$ = 12					; size = 4
_SysGetProc@8 PROC

; 7126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7127 :    LPLIBRARY lpLibrary = zGETPTR( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7128 :    zPVOID    pfReturn;
; 7129 : 
; 7130 :    if ( cpcProcName == 0 || cpcProcName[ 0 ] == 0 || lpLibrary == 0 )

	cmp	DWORD PTR _cpcProcName$[ebp], 0
	je	SHORT $LN4@SysGetProc
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcProcName$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN4@SysGetProc
	cmp	DWORD PTR _lpLibrary$[ebp], 0
	jne	SHORT $LN2@SysGetProc
$LN4@SysGetProc:

; 7131 :       pfReturn = 0;

	mov	DWORD PTR _pfReturn$[ebp], 0
	jmp	SHORT $LN3@SysGetProc
$LN2@SysGetProc:

; 7132 :    else
; 7133 :    {
; 7134 :       pfReturn = GetProcAddress( (HMODULE) lpLibrary->hLibrary, cpcProcName );

	mov	edx, DWORD PTR _cpcProcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+263]
	push	ecx
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _pfReturn$[ebp], eax

; 7135 :       if ( pfReturn == 0 )

	cmp	DWORD PTR _pfReturn$[ebp], 0
	jne	SHORT $LN3@SysGetProc

; 7136 :       {
; 7137 : #if 0
; 7138 :          char szMessage[ 16 ];
; 7139 : 
; 7140 :          SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );
; 7141 :          if ( szMessage[ 0 ] == 'Y' )
; 7142 :          {
; 7143 :             zSHORT k = 0;
; 7144 :             k /= k;
; 7145 :          }
; 7146 : #endif
; 7147 :          TraceLine( "(sy) SysGetProc failed with error code: %d   DLL: %s   Function: %s xx:%s",

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+263]
	push	eax
	mov	ecx, DWORD PTR _cpcProcName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	add	edx, 6
	push	edx
	call	DWORD PTR __imp__GetLastError@0
	push	eax
	push	OFFSET $SG100058
	call	_TraceLine
	add	esp, 20					; 00000014H
$LN3@SysGetProc:

; 7148 :                     (zLONG) GetLastError( ), lpLibrary->szName, cpcProcName,lpLibrary->hLibrary  );
; 7149 :       }
; 7150 :    }
; 7151 : 
; 7152 :    return( pfReturn );

	mov	eax, DWORD PTR _pfReturn$[ebp]

; 7153 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysGetProc@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpLibrary$ = -4					; size = 4
_hLibrary$ = 8						; size = 4
_SysGetInstance@4 PROC

; 7173 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7174 :    LPLIBRARY lpLibrary = zGETPTR( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7175 : 
; 7176 :    if ( lpLibrary )

	cmp	DWORD PTR _lpLibrary$[ebp], 0
	je	SHORT $LN2@SysGetInst

; 7177 :       return( (zLONG) lpLibrary->hLibrary );

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [ecx+263]
	jmp	SHORT $LN1@SysGetInst
	jmp	SHORT $LN1@SysGetInst
$LN2@SysGetInst:

; 7178 :    else
; 7179 :       return( 0 );

	xor	eax, eax
$LN1@SysGetInst:

; 7180 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetInstance@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pHandle$ = 8						; size = 4
_SysGetPointerFromHandle@4 PROC

; 4129 : {

	push	ebp
	mov	ebp, esp

; 4130 :    return( (*g_pfnGetPtr)( pHandle ) );

	mov	eax, DWORD PTR _pHandle$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr

; 4131 : }

	pop	ebp
	ret	4
_SysGetPointerFromHandle@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_plSubVersion$ = 8					; size = 4
_SysGetOS_Info@4 PROC

; 8091 : {

	push	ebp
	mov	ebp, esp

; 8092 :    // For now we just return zero for sub-version.
; 8093 :    if ( plSubVersion )

	cmp	DWORD PTR _plSubVersion$[ebp], 0
	je	SHORT $LN2@SysGetOS_I

; 8094 :       *plSubVersion = 0;

	mov	eax, DWORD PTR _plSubVersion$[ebp]
	mov	DWORD PTR [eax], 0
$LN2@SysGetOS_I:

; 8095 : 
; 8096 :    if ( g_bWin95 )

	movzx	ecx, BYTE PTR _g_bWin95
	test	ecx, ecx
	je	SHORT $LN3@SysGetOS_I

; 8097 :       return( zOS_WINDOWS95 );

	mov	eax, 2
	jmp	SHORT $LN1@SysGetOS_I
	jmp	SHORT $LN1@SysGetOS_I
$LN3@SysGetOS_I:

; 8098 :    else
; 8099 :       return( zOS_WINDOWSNT );

	mov	eax, 3
$LN1@SysGetOS_I:

; 8100 : }

	pop	ebp
	ret	4
_SysGetOS_Info@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpInternational$1 = -4					; size = 4
_pchReturnThou$ = 8					; size = 4
_pchReturnDecPt$ = 12					; size = 4
_plPrecision$ = 16					; size = 4
_SysGetNumberFormat@12 PROC

; 1852 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1853 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN2@SysGetNumb
	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+2515], 0
	je	SHORT $LN2@SysGetNumb

; 1854 :    {
; 1855 :       LPINTERNATIONAL lpInternational;
; 1856 : 
; 1857 :       lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2515]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$1[ebp], eax

; 1858 :       zstrcpy( pchReturnThou, lpInternational->szThousand );

	mov	eax, DWORD PTR _lpInternational$1[ebp]
	add	eax, 126				; 0000007eH
	push	eax
	mov	ecx, DWORD PTR _pchReturnThou$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1859 :       zstrcpy( pchReturnDecPt, lpInternational->szDecimal );

	mov	edx, DWORD PTR _lpInternational$1[ebp]
	add	edx, 131				; 00000083H
	push	edx
	mov	eax, DWORD PTR _pchReturnDecPt$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1860 :       *plPrecision = (zLONG) lpInternational->nDigits;

	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	movsx	edx, WORD PTR [ecx+136]
	mov	eax, DWORD PTR _plPrecision$[ebp]
	mov	DWORD PTR [eax], edx

; 1861 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SysGetNumb

; 1862 :    }

	jmp	SHORT $LN1@SysGetNumb
$LN2@SysGetNumb:

; 1863 :    else
; 1864 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@SysGetNumb:

; 1865 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetNumberFormat@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpInternational$1 = -4					; size = 4
_pchReturnString$ = 8					; size = 4
_SysGetLongDateFormat@4 PROC

; 1883 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1884 :    *pchReturnString = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 1885 : 
; 1886 :    if ( AnchorBlock && AnchorBlock->hInternational )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN1@SysGetLong
	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+2515], 0
	je	SHORT $LN1@SysGetLong

; 1887 :    {
; 1888 :       LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$1[ebp], eax

; 1889 : 
; 1890 :       if ( lpInternational->hLongDate )

	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	cmp	DWORD PTR [ecx+102], 0
	je	SHORT $LN1@SysGetLong

; 1891 :          zstrcpy( pchReturnString, zGETPTR( lpInternational->hLongDate ) );

	mov	edx, DWORD PTR _lpInternational$1[ebp]
	mov	eax, DWORD PTR [edx+102]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN1@SysGetLong:

; 1892 :    }
; 1893 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetLongDateFormat@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pchReturnDir$ = 8					; size = 4
_SysGetLocalSysDirectory@4 PROC

; 6687 : {

	push	ebp
	mov	ebp, esp

; 6688 :    // Temporarily return the Zeidon Sys directory.
; 6689 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN2@SysGetLoca

; 6690 :    {
; 6691 :       zstrcpy( pchReturnDir, AnchorBlock->szZeidonSys );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 652				; 0000028cH
	push	eax
	mov	ecx, DWORD PTR _pchReturnDir$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6692 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SysGetLoca
$LN2@SysGetLoca:

; 6693 :    }
; 6694 : 
; 6695 :    *pchReturnDir = 0;

	mov	edx, DWORD PTR _pchReturnDir$[ebp]
	mov	BYTE PTR [edx], 0

; 6696 :    return( -1 );

	or	eax, -1
$LN1@SysGetLoca:

; 6697 : }

	pop	ebp
	ret	4
_SysGetLocalSysDirectory@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pchReturnDir$ = 8					; size = 4
_SysGetLocalDirectory@4 PROC

; 6657 : {

	push	ebp
	mov	ebp, esp

; 6658 :    // Temporarily return the Zeidon Bin directory.
; 6659 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN2@SysGetLoca

; 6660 :    {
; 6661 :       zstrcpy( pchReturnDir, AnchorBlock->szZeidonBin );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 395				; 0000018bH
	push	eax
	mov	ecx, DWORD PTR _pchReturnDir$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 6662 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SysGetLoca
$LN2@SysGetLoca:

; 6663 :    }
; 6664 : 
; 6665 :    *pchReturnDir = 0;

	mov	edx, DWORD PTR _pchReturnDir$[ebp]
	mov	BYTE PTR [edx], 0

; 6666 :    return( -1 );

	or	eax, -1
$LN1@SysGetLoca:

; 6667 : }

	pop	ebp
	ret	4
_SysGetLocalDirectory@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpInternational$ = -4					; size = 4
_lpnLanguageCode$ = 8					; size = 4
_SysGetLanguageCode@4 PROC

; 1818 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1819 :    LPINTERNATIONAL   lpInternational;
; 1820 : 
; 1821 :    // Follow the chain from the AnchorBlock to the International Language
; 1822 :    // pointer to the International Language Code.  Then return the Code.
; 1823 : 
; 1824 :    lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2515]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$[ebp], eax

; 1825 :    *lpnLanguageCode = lpInternational->nLanguage;

	mov	edx, DWORD PTR _lpnLanguageCode$[ebp]
	mov	eax, DWORD PTR _lpInternational$[ebp]
	mov	cx, WORD PTR [eax+70]
	mov	WORD PTR [edx], cx

; 1826 : 
; 1827 :    return( 0 );

	xor	eax, eax

; 1828 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetLanguageCode@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pPointer$ = 8						; size = 4
_SysGetHandleFromPointer@4 PROC

; 4172 : {

	push	ebp
	mov	ebp, esp

; 4173 :    return( (*g_pfnGetHndl)( pPointer ) );

	mov	eax, DWORD PTR _pPointer$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl

; 4174 : }

	pop	ebp
	ret	4
_SysGetHandleFromPointer@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hFile$ = 8						; size = 4
_SysGetFileSize@4 PROC

; 6509 : {

	push	ebp
	mov	ebp, esp

; 6510 :    return( GetFileSize( (HANDLE) hFile, 0 ) );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__GetFileSize@8

; 6511 : }

	pop	ebp
	ret	4
_SysGetFileSize@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hFile$ = 8						; size = 4
_SysGetFilePosition@4 PROC

; 6492 : {

	push	ebp
	mov	ebp, esp

; 6493 :    return( SetFilePointer( (HANDLE) hFile, 0, 0, FILE_CURRENT ) );

	push	1
	push	0
	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	call	DWORD PTR __imp__SetFilePointer@16

; 6494 : }

	pop	ebp
	ret	4
_SysGetFilePosition@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_LastWriteTime$ = -28					; size = 8
_ST$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hFile$ = 8						; size = 4
_pchDateTime$ = 12					; size = 4
_SysGetFileDateTime@8 PROC

; 6722 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6723 :    FILETIME   LastWriteTime;
; 6724 :    SYSTEMTIME ST;             // SystemTime
; 6725 : 
; 6726 :    pchDateTime[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchDateTime$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6727 : 
; 6728 :    if ( GetFileTime( (HANDLE) hFile, 0, 0, &LastWriteTime ) )

	lea	eax, DWORD PTR _LastWriteTime$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetFileTime@16
	test	eax, eax
	je	SHORT $LN2@SysGetFile

; 6729 :    {
; 6730 :       FileTimeToSystemTime( &LastWriteTime, &ST );

	lea	edx, DWORD PTR _ST$[ebp]
	push	edx
	lea	eax, DWORD PTR _LastWriteTime$[ebp]
	push	eax
	call	DWORD PTR __imp__FileTimeToSystemTime@8

; 6731 :       zsprintf( pchDateTime, "%4d%02d%02d%02d%02d%02d%03d",

	movzx	ecx, WORD PTR _ST$[ebp+14]
	push	ecx
	movzx	edx, WORD PTR _ST$[ebp+12]
	push	edx
	movzx	eax, WORD PTR _ST$[ebp+10]
	push	eax
	movzx	ecx, WORD PTR _ST$[ebp+8]
	push	ecx
	movzx	edx, WORD PTR _ST$[ebp+6]
	push	edx
	movzx	eax, WORD PTR _ST$[ebp+2]
	push	eax
	movzx	ecx, WORD PTR _ST$[ebp]
	push	ecx
	push	OFFSET $SG99910
	mov	edx, DWORD PTR _pchDateTime$[ebp]
	push	edx
	call	_sprintf
	add	esp, 36					; 00000024H

; 6732 :                 (int) ST.wYear, (int) ST.wMonth, (int) ST.wDay, (int) ST.wHour,
; 6733 :                 (int) ST.wMinute, (int) ST.wSecond, (int) ST.wMilliseconds );
; 6734 :    }

	jmp	SHORT $LN1@SysGetFile
$LN2@SysGetFile:

; 6735 :    else
; 6736 :       zstrcpy( pchDateTime, "???????????????" );

	push	OFFSET $SG99911
	mov	eax, DWORD PTR _pchDateTime$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN1@SysGetFile:

; 6737 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_SysGetFileDateTime@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pchReturnEnv$ = 8					; size = 4
_cpcEnvName$ = 12					; size = 4
_nMaxLth$ = 16						; size = 4
_SysGetEnvVar@12 PROC

; 4345 : {

	push	ebp
	mov	ebp, esp

; 4346 :    *pchReturnEnv = 0;

	mov	eax, DWORD PTR _pchReturnEnv$[ebp]
	mov	BYTE PTR [eax], 0

; 4347 : 
; 4348 :    if ( GetEnvironmentVariable( cpcEnvName, pchReturnEnv, nMaxLth ) == 0 )

	mov	ecx, DWORD PTR _nMaxLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnEnv$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEnvName$[ebp]
	push	eax
	call	DWORD PTR __imp__GetEnvironmentVariableA@12
	test	eax, eax
	jne	SHORT $LN2@SysGetEnvV

; 4349 :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@SysGetEnvV
	jmp	SHORT $LN1@SysGetEnvV
$LN2@SysGetEnvV:

; 4350 :    else
; 4351 :       return( 0 );

	xor	eax, eax
$LN1@SysGetEnvV:

; 4352 : }

	pop	ebp
	ret	12					; 0000000cH
_SysGetEnvVar@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_lpView$ = 8						; size = 4
_pchUserID$ = 12					; size = 4
_pchPassword$ = 16					; size = 4
_SysGetDB_UserID@12 PROC

; 4824 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4825 :    LPTASK lpTask;
; 4826 : 
; 4827 :    // Initialize in case of early errors.
; 4828 :    pchUserID[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchUserID$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 4829 :    pchPassword[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchPassword$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 4830 : 
; 4831 :    // OE not up, get out.
; 4832 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN2@SysGetDB_U

; 4833 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysGetDB_U
$LN2@SysGetDB_U:

; 4834 : 
; 4835 :    lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 4836 : 
; 4837 :    // No task for this caller, gonzo.
; 4838 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN3@SysGetDB_U

; 4839 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysGetDB_U
$LN3@SysGetDB_U:

; 4840 : 
; 4841 :    // first check for a userid at the task level.
; 4842 :    if ( lpTask->hDBUserID )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+40], 0
	je	SHORT $LN4@SysGetDB_U

; 4843 :    {
; 4844 :       // return the userid
; 4845 :       zstrcpy( pchUserID, zGETPTR( lpTask->hDBUserID ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _pchUserID$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4846 : 
; 4847 :       // return password, if present.
; 4848 :       if ( lpTask->hDBPassword )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+44], 0
	je	SHORT $LN6@SysGetDB_U

; 4849 :          zstrcpy( pchPassword, zGETPTR( lpTask->hDBPassword ) );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _pchPassword$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN6@SysGetDB_U:

; 4850 :    }

	jmp	SHORT $LN5@SysGetDB_U
$LN4@SysGetDB_U:

; 4851 :    else
; 4852 :    {
; 4853 :       SysGetUserID( lpView, pchUserID, pchPassword );

	mov	ecx, DWORD PTR _pchPassword$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchUserID$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysGetUserID@12
$LN5@SysGetDB_U:

; 4854 :    }
; 4855 : 
; 4856 :    return( 0 );

	xor	eax, eax
$LN1@SysGetDB_U:

; 4857 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetDB_UserID@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_nRC$ = -24						; size = 2
_EarlyDate$ = -20					; size = 6
_LaterDate$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_plDiff$ = 8						; size = 4
_pchEarlyDate$ = 12					; size = 4
_pchLaterDate$ = 16					; size = 4
_nDiffType$ = 20					; size = 2
_SysGetDateTimeDifference@16 PROC

; 6832 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6833 :    DateTimeRecord EarlyDate;
; 6834 :    DateTimeRecord LaterDate;
; 6835 :    zSHORT         nRC;
; 6836 : 
; 6837 :    nRC = UfStringToDateTime( pchEarlyDate, &EarlyDate );

	lea	eax, DWORD PTR _EarlyDate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchEarlyDate$[ebp]
	push	ecx
	call	_UfStringToDateTime@8
	mov	WORD PTR _nRC$[ebp], ax

; 6838 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN2@SysGetDate

; 6839 :    {
; 6840 :       TraceLineS( "SysGetDateTimeDifference: ",  "Invalid type for Early Date" );

	push	OFFSET $SG99962
	push	OFFSET $SG99963
	call	_TraceLineS@8

; 6841 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysGetDate
$LN2@SysGetDate:

; 6842 :    }
; 6843 : 
; 6844 :    nRC = UfStringToDateTime( pchLaterDate, &LaterDate );

	lea	eax, DWORD PTR _LaterDate$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchLaterDate$[ebp]
	push	ecx
	call	_UfStringToDateTime@8
	mov	WORD PTR _nRC$[ebp], ax

; 6845 :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN3@SysGetDate

; 6846 :    {
; 6847 :       TraceLineS( "SysGetDateTimeDifference: ",  "Invalid type for Later Date" );

	push	OFFSET $SG99965
	push	OFFSET $SG99966
	call	_TraceLineS@8

; 6848 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysGetDate
$LN3@SysGetDate:

; 6849 :    }
; 6850 : 
; 6851 :    // Subtract the values.
; 6852 :    nRC = UfDateTimeDiff( plDiff, &EarlyDate, &LaterDate, nDiffType );

	movzx	eax, WORD PTR _nDiffType$[ebp]
	push	eax
	lea	ecx, DWORD PTR _LaterDate$[ebp]
	push	ecx
	lea	edx, DWORD PTR _EarlyDate$[ebp]
	push	edx
	mov	eax, DWORD PTR _plDiff$[ebp]
	push	eax
	call	_UfDateTimeDiff@16
	mov	WORD PTR _nRC$[ebp], ax

; 6853 : 
; 6854 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SysGetDate:

; 6855 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysGetDateTimeDifference@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_vSystem$1 = -12					; size = 4
_lpViewOD$ = -8						; size = 4
_nRC$2 = -4						; size = 2
_lpView$ = 8						; size = 4
_pchDateTime$ = 12					; size = 4
_SysGetServerDateTime@8 PROC

; 6785 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 6786 :    LPVIEWOD lpViewOD;
; 6787 : 
; 6788 :    pchDateTime[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchDateTime$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 6789 : 
; 6790 :    // First make sure the network is active.
; 6791 :    if ( lpView &&
; 6792 :         (lpViewOD = zGETPTR( lpView->hViewOD )) != 0 &&
; 6793 :         lpViewOD->szNetwork[ 0 ] &&

	cmp	DWORD PTR _lpView$[ebp], 0
	je	$LN2@SysGetServ
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN2@SysGetServ
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+109]
	test	edx, edx
	je	SHORT $LN2@SysGetServ
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 109				; 0000006dH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_NetStatus@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@SysGetServ

; 6794 :         NetStatus( lpView, lpViewOD->szNetwork ) != 0 )
; 6795 :    {
; 6796 :       zVIEW  vSystem;
; 6797 :       zSHORT nRC;
; 6798 : 
; 6799 :       SfCreateSystemSubtask( &vSystem, lpView, "Zeidon System" );

	push	OFFSET $SG99944
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vSystem$1[ebp]
	push	ecx
	call	_SfCreateSystemSubtask@12

; 6800 :       nRC = NetCallOperation( "zWinSock", 0,

	push	OFFSET $SG99945
	mov	edx, DWORD PTR _pchDateTime$[ebp]
	push	edx
	push	OFFSET $SG99946
	push	OFFSET $SG99947
	push	0
	mov	eax, DWORD PTR _vSystem$1[ebp]
	push	eax
	push	0
	push	OFFSET $SG99948
	call	_NetCallOperation
	add	esp, 32					; 00000020H
	mov	WORD PTR _nRC$2[ebp], ax

; 6801 :                               vSystem, FALSE, "kzoengaa", "GetDateTime",
; 6802 :                               pchDateTime, "T" );
; 6803 :       SfDropSubtask( vSystem, 0 );

	push	0
	mov	ecx, DWORD PTR _vSystem$1[ebp]
	push	ecx
	call	_SfDropSubtask@8

; 6804 :    }

	jmp	SHORT $LN1@SysGetServ
$LN2@SysGetServ:

; 6805 :    else
; 6806 :       SysGetDateTime( pchDateTime );

	mov	edx, DWORD PTR _pchDateTime$[ebp]
	push	edx
	call	_SysGetDateTime@4
$LN1@SysGetServ:

; 6807 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysGetServerDateTime@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_ST$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pchDateTime$ = 8					; size = 4
_SysGetDateTime@4 PROC

; 6763 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 6764 :    SYSTEMTIME ST;
; 6765 : 
; 6766 :    GetLocalTime( &ST );

	lea	eax, DWORD PTR _ST$[ebp]
	push	eax
	call	DWORD PTR __imp__GetLocalTime@4

; 6767 :    zsprintf( pchDateTime, "%4d%02d%02d%02d%02d%02d%03d",

	movzx	ecx, WORD PTR _ST$[ebp+14]
	push	ecx
	movzx	edx, WORD PTR _ST$[ebp+12]
	push	edx
	movzx	eax, WORD PTR _ST$[ebp+10]
	push	eax
	movzx	ecx, WORD PTR _ST$[ebp+8]
	push	ecx
	movzx	edx, WORD PTR _ST$[ebp+6]
	push	edx
	movzx	eax, WORD PTR _ST$[ebp+2]
	push	eax
	movzx	ecx, WORD PTR _ST$[ebp]
	push	ecx
	push	OFFSET $SG99923
	mov	edx, DWORD PTR _pchDateTime$[ebp]
	push	edx
	call	_sprintf
	add	esp, 36					; 00000024H

; 6768 :              (int) ST.wYear, (int) ST.wMonth, (int) ST.wDay, (int) ST.wHour,
; 6769 :              (int) ST.wMinute, (int) ST.wSecond, (int) ST.wMilliseconds );
; 6770 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_SysGetDateTime@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hMemory$ = 8						; size = 4
_SysFreeMemory@4 PROC

; 3415 : {

	push	ebp
	mov	ebp, esp

; 3416 :    if ( hMemory == 0 )

	cmp	DWORD PTR _hMemory$[ebp], 0
	jne	SHORT $LN2@SysFreeMem

; 3417 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysFreeMem
$LN2@SysFreeMem:

; 3418 : 
; 3419 :    SysFree( (zPVOID) hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]
	push	eax
	call	_SysFree@4

; 3420 :    return( 0 );

	xor	eax, eax
$LN1@SysFreeMem:

; 3421 : }

	pop	ebp
	ret	4
_SysFreeMemory@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -12						; size = 4
tv68 = -8						; size = 4
_nRC$ = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_hLibrary$ = 12						; size = 4
_SysFreeLibrary@8 PROC

; 7328 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 7329 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN4@SysFreeLib
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN5@SysFreeLib
$LN4@SysFreeLib:
	mov	DWORD PTR tv68[ebp], 0
$LN5@SysFreeLib:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 7330 : 
; 7331 :    int nRC = fnSysFreeLibrary( lpTask, hLibrary, FALSE );

	push	0
	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysFreeLibrary@12
	mov	DWORD PTR _nRC$[ebp], eax

; 7332 :    if ( nRC > 0 )

	cmp	DWORD PTR _nRC$[ebp], 0
	jle	SHORT $LN2@SysFreeLib

; 7333 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0
$LN2@SysFreeLib:

; 7334 : 
; 7335 :    return( nRC );

	mov	eax, DWORD PTR _nRC$[ebp]

; 7336 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SysFreeLibrary@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hModule$ = -32						; size = 4
_pOS_Record$1 = -28					; size = 4
_lProcessID$ = -24					; size = 4
_lpPrevSearchLibrary$ = -20				; size = 4
_lpProcessList$2 = -16					; size = 4
_lpSearchLibrary$ = -12					; size = 4
_lpLibrary$ = -8					; size = 4
_nProcessIdx$3 = -4					; size = 2
_lpTask$ = 8						; size = 4
_hLibrary$ = 12						; size = 4
_bAllUses$ = 16						; size = 1
_fnSysFreeLibrary@12 PROC

; 7198 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 7199 :    LPLIBRARY  lpPrevSearchLibrary;
; 7200 :    LPLIBRARY  lpSearchLibrary;
; 7201 :    LPLIBRARY  lpLibrary = zGETPTR( hLibrary );

	mov	eax, DWORD PTR _hLibrary$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax

; 7202 :    zLONG      lProcessID;
; 7203 :    HMODULE    hModule;
; 7204 : 
; 7205 :    // If no AnchorBlock return error.
; 7206 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN7@fnSysFreeL

; 7207 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysFreeL
$LN7@fnSysFreeL:

; 7208 : 
; 7209 :    // If task is not active, return error.
; 7210 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN8@fnSysFreeL

; 7211 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysFreeL
$LN8@fnSysFreeL:

; 7212 : 
; 7213 :    // Lock critical section so other threads don't muck stuff.
; 7214 :    EnterCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET _g_csSysLoadLibrary
	call	DWORD PTR __imp__EnterCriticalSection@4

; 7215 : 
; 7216 :    // Find Library passed from caller.
; 7217 :    lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 7218 :    lpPrevSearchLibrary = 0;

	mov	DWORD PTR _lpPrevSearchLibrary$[ebp], 0

; 7219 :    lpSearchLibrary = zGETPTR( lpTask->hFirstLibrary );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+122]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLibrary$[ebp], eax
$LN2@fnSysFreeL:

; 7220 :    while ( lpSearchLibrary )

	cmp	DWORD PTR _lpSearchLibrary$[ebp], 0
	je	SHORT $LN3@fnSysFreeL

; 7221 :    {
; 7222 :    // TraceLineS( "fnSysFreeLibrary checking library: ",
; 7223 :    //             lpSearchLibrary->szName );
; 7224 :       if ( lpSearchLibrary == lpLibrary || lpLibrary == 0 )

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	cmp	eax, DWORD PTR _lpLibrary$[ebp]
	je	SHORT $LN10@fnSysFreeL
	cmp	DWORD PTR _lpLibrary$[ebp], 0
	jne	SHORT $LN9@fnSysFreeL
$LN10@fnSysFreeL:

; 7225 :       {
; 7226 :          lpLibrary = lpSearchLibrary;  // ensure non-null library

	mov	ecx, DWORD PTR _lpSearchLibrary$[ebp]
	mov	DWORD PTR _lpLibrary$[ebp], ecx

; 7227 :          break;  // we found the Library record

	jmp	SHORT $LN3@fnSysFreeL
$LN9@fnSysFreeL:

; 7228 :       }
; 7229 : 
; 7230 :       lpPrevSearchLibrary = lpSearchLibrary;

	mov	edx, DWORD PTR _lpSearchLibrary$[ebp]
	mov	DWORD PTR _lpPrevSearchLibrary$[ebp], edx

; 7231 :       lpSearchLibrary = zGETPTR( lpSearchLibrary->hNextLibrary );

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchLibrary$[ebp], eax

; 7232 :    }

	jmp	SHORT $LN2@fnSysFreeL
$LN3@fnSysFreeL:

; 7233 : 
; 7234 :    // Check to see if Library record found for task.
; 7235 :    if ( lpSearchLibrary == 0 )

	cmp	DWORD PTR _lpSearchLibrary$[ebp], 0
	jne	SHORT $LN11@fnSysFreeL

; 7236 :    {
; 7237 :       LeaveCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET _g_csSysLoadLibrary
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7238 :       return( 0 );  // library already freed for this task

	xor	eax, eax
	jmp	$LN1@fnSysFreeL
$LN11@fnSysFreeL:

; 7239 :    }
; 7240 : 
; 7241 : // TraceLine( "Free Library (0x%08x) %s - UseCount: %d   Task 0x%08x",
; 7242 : //            lpLibrary, lpLibrary->szName,
; 7243 : //            lpLibrary ? lpLibrary->ulUseCnt : 0, zGETHNDL( lpTask ) );
; 7244 : 
; 7245 :    // Decrement the use count.  If the use count is greater than zero, then
; 7246 :    // the module has been loaded multiple times, so don't free it yet.
; 7247 :    if ( lpSearchLibrary->ulUseCnt )

	mov	edx, DWORD PTR _lpSearchLibrary$[ebp]
	cmp	DWORD PTR [edx+275], 0
	je	SHORT $LN12@fnSysFreeL

; 7248 :       lpSearchLibrary->ulUseCnt--;

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	mov	ecx, DWORD PTR [eax+275]
	sub	ecx, 1
	mov	edx, DWORD PTR _lpSearchLibrary$[ebp]
	mov	DWORD PTR [edx+275], ecx
$LN12@fnSysFreeL:

; 7249 : 
; 7250 :    if ( lpSearchLibrary->ulUseCnt && bAllUses == FALSE )

	mov	eax, DWORD PTR _lpSearchLibrary$[ebp]
	cmp	DWORD PTR [eax+275], 0
	je	SHORT $LN13@fnSysFreeL
	movzx	ecx, BYTE PTR _bAllUses$[ebp]
	test	ecx, ecx
	jne	SHORT $LN13@fnSysFreeL

; 7251 :    {
; 7252 :       LeaveCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET _g_csSysLoadLibrary
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7253 :       return( 2 );  // it is freed and can be freed again for this task

	mov	eax, 2
	jmp	$LN1@fnSysFreeL
$LN13@fnSysFreeL:

; 7254 :    }
; 7255 : 
; 7256 :    hModule = (HMODULE) lpLibrary->hLibrary;

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+263]
	mov	DWORD PTR _hModule$[ebp], eax

; 7257 : 
; 7258 :    // We have a zero use count for this module, so we want to remove
; 7259 :    // the Library record from the ProcLib Library chain.
; 7260 :    if ( lpPrevSearchLibrary )

	cmp	DWORD PTR _lpPrevSearchLibrary$[ebp], 0
	je	SHORT $LN14@fnSysFreeL

; 7261 :       lpPrevSearchLibrary->hNextLibrary = lpLibrary->hNextLibrary;

	mov	ecx, DWORD PTR _lpPrevSearchLibrary$[ebp]
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax
	jmp	SHORT $LN15@fnSysFreeL
$LN14@fnSysFreeL:

; 7262 :    else
; 7263 :       lpTask->hFirstLibrary = lpLibrary->hNextLibrary;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _lpLibrary$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+122], eax
$LN15@fnSysFreeL:

; 7264 : 
; 7265 :    // Environment specific code begins here.
; 7266 : 
; 7267 :    if ( lpLibrary->lProcessID == lProcessID )

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	mov	edx, DWORD PTR [ecx+271]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN16@fnSysFreeL

; 7268 :    {
; 7269 :    // fnTraceLibrary( lpLibrary, 0 );
; 7270 :       FreeLibrary( hModule );

	mov	eax, DWORD PTR _hModule$[ebp]
	push	eax
	call	DWORD PTR __imp__FreeLibrary@4

; 7271 :    }

	jmp	$LN17@fnSysFreeL
$LN16@fnSysFreeL:

; 7272 :    else
; 7273 :    {
; 7274 :       // Send a message to the other process specified by
; 7275 :       // lpLibrary->lProcessID to free the hLibrary.
; 7276 :       zSHORT nProcessIdx;
; 7277 :       LPANCHOROS_RECORD pOS_Record = &AnchorBlock->OS_Data;

	mov	ecx, DWORD PTR _AnchorBlock
	add	ecx, 1503				; 000005dfH
	mov	DWORD PTR _pOS_Record$1[ebp], ecx

; 7278 :       LPPROCESSLIST lpProcessList;
; 7279 : 
; 7280 :       // Find the process that loaded the library.
; 7281 :       for ( nProcessIdx = AnchorBlock->OS_Data.lProcessCount - 1;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1507]
	sub	eax, 1
	mov	WORD PTR _nProcessIdx$3[ebp], ax
	jmp	SHORT $LN6@fnSysFreeL
$LN4@fnSysFreeL:

; 7283 :             nProcessIdx-- )

	mov	cx, WORD PTR _nProcessIdx$3[ebp]
	sub	cx, 1
	mov	WORD PTR _nProcessIdx$3[ebp], cx
$LN6@fnSysFreeL:

; 7282 :             pOS_Record->ProcessList[ nProcessIdx ].lProcessID != lProcessID;

	movsx	edx, WORD PTR _nProcessIdx$3[ebp]
	imul	eax, edx, 20
	mov	ecx, DWORD PTR _pOS_Record$1[ebp]
	mov	edx, DWORD PTR [ecx+eax+24]
	cmp	edx, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN5@fnSysFreeL

; 7284 :       {
; 7285 :          // Nothing needs to be done here.
; 7286 :       }

	jmp	SHORT $LN4@fnSysFreeL
$LN5@fnSysFreeL:

; 7287 : 
; 7288 :       if ( nProcessIdx > 0 )

	movsx	eax, WORD PTR _nProcessIdx$3[ebp]
	test	eax, eax
	jle	SHORT $LN18@fnSysFreeL

; 7289 :       {
; 7290 :          lpProcessList = &pOS_Record->ProcessList[ nProcessIdx ];

	movsx	ecx, WORD PTR _nProcessIdx$3[ebp]
	imul	edx, ecx, 20
	mov	eax, DWORD PTR _pOS_Record$1[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	mov	DWORD PTR _lpProcessList$2[ebp], ecx

; 7291 :          lpProcessList->nOE_Request  = TASKREQ_FREELIB;

	mov	edx, 6
	mov	eax, DWORD PTR _lpProcessList$2[ebp]
	mov	WORD PTR [eax], dx

; 7292 :          lpProcessList->hMemHandle   = (zULONG) zGETHNDL( lpLibrary );

	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpProcessList$2[ebp]
	mov	DWORD PTR [edx+12], eax

; 7293 : 
; 7294 :          // Send the message.
; 7295 :          SendMessage( (HWND) lpProcessList->hWndAppOE_Msg,

	movsx	eax, WORD PTR _nProcessIdx$3[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpProcessList$2[ebp]
	movzx	edx, WORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _lpProcessList$2[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__SendMessageA@16

; 7296 :                       lpProcessList->uAppOE_Msg, 0, nProcessIdx );
; 7297 :          TraceLine( "FreeLibrary sent message (0x%08x) for Module: %s - Task: 0x%08x",

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	push	ecx
	push	OFFSET $SG100109
	call	_TraceLine
	add	esp, 16					; 00000010H

; 7298 :                     lpLibrary, lpLibrary->szName, zGETHNDL( lpTask ) );
; 7299 :       }

	jmp	SHORT $LN17@fnSysFreeL
$LN18@fnSysFreeL:

; 7300 :       else
; 7301 :       {
; 7302 :          TraceLine( "FreeLibrary did not free (0x%08x) Module: %s - Task: 0x%08x",

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	eax, DWORD PTR _lpLibrary$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	push	ecx
	push	OFFSET $SG100110
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN17@fnSysFreeL:

; 7303 :                     lpLibrary, lpLibrary->szName, zGETHNDL( lpTask ) );
; 7304 :       }
; 7305 : 
; 7306 :       // Environment specific code ends here.
; 7307 :    }
; 7308 : 
; 7309 :    fnFreeDataspace( lpLibrary );

	mov	edx, DWORD PTR _lpLibrary$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 7310 :    LeaveCriticalSection( &g_csSysLoadLibrary );

	push	OFFSET _g_csSysLoadLibrary
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7311 :    return( 1 );  // this library freed for this task

	mov	eax, 1
$LN1@fnSysFreeL:

; 7312 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnSysFreeLibrary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pvMemory$ = 8						; size = 4
_SysFree@4 PROC

; 3254 : {

	push	ebp
	mov	ebp, esp

; 3255 : #ifdef DEBUG_MALLOC
; 3256 :    zLONG  k;
; 3257 : 
; 3258 : // TraceLine( "SysFree Mem: 0x%08x", pvMemory );
; 3259 : #endif
; 3260 : 
; 3261 :    if ( pvMemory )

	cmp	DWORD PTR _pvMemory$[ebp], 0
	je	SHORT $LN1@SysFree

; 3262 :    {
; 3263 : 
; 3264 : #ifdef DEBUG_MALLOC
; 3265 :       for ( k = 0; k < zMAX_ALLOC_TEST; k += 2 )
; 3266 :       {
; 3267 :          if ( g_pvAlloc[ k ] == pvMemory )
; 3268 :          {
; 3269 :             g_pvAlloc[ k ] = 0;
; 3270 :             g_pvAlloc[ k + 1 ] = 0;
; 3271 :             break;
; 3272 :          }
; 3273 :       }
; 3274 : 
; 3275 :       if ( k >= zMAX_ALLOC_TEST )
; 3276 :       {
; 3277 :          TraceLine( "SysFree Error ... Memory Not Found: 0x%08x", pvMemory );
; 3278 :       // MessageBox( 0, "SysFree Error", "Memory Not Found", MB_OK );
; 3279 :       }
; 3280 : #endif
; 3281 : 
; 3282 :       free( pvMemory );

	mov	eax, DWORD PTR _pvMemory$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN1@SysFree:

; 3283 :    }
; 3284 : }

	pop	ebp
	ret	4
_SysFree@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv77 = -28						; size = 4
_sz$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_idx$ = 8						; size = 2
_pchMsg$ = 12						; size = 4
_SysElapsedTimer@8 PROC

; 8061 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 8062 :    zCHAR sz[ 20 ];
; 8063 : 
; 8064 :    zsprintf( sz, " = %lf seconds",

	call	DWORD PTR __imp__GetTickCount@0
	movzx	ecx, WORD PTR _idx$[ebp]
	sub	eax, DWORD PTR _g_lTable[ecx*4]
	mov	DWORD PTR tv77[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv77[ebp]
	mov	edx, DWORD PTR tv77[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG100334
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 8065 :             (double) (GetTickCount( ) - g_lTable[ idx ]) / zTICKS_PER_SECOND);
; 8066 :    TraceLineS( pchMsg, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchMsg$[ebp]
	push	edx
	call	_TraceLineS@8

; 8067 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_SysElapsedTimer@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szDiagnostic$ = -4					; size = 2
_lpTaskView$ = 8					; size = 4
_cpcTitle$ = 12						; size = 4
_cpcMessage$ = 16					; size = 4
_nBeep$ = 20						; size = 4
_SysDiagnosticMessage@16 PROC

; 4390 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4391 :    char szDiagnostic[ 2 ];
; 4392 : 
; 4393 :    SysReadZeidonIni( -1, "[Debug]", "Diagnostic", szDiagnostic );

	lea	eax, DWORD PTR _szDiagnostic$[ebp]
	push	eax
	push	OFFSET $SG99097
	push	OFFSET $SG99098
	push	-1
	call	_SysReadZeidonIni@16

; 4394 :    if ( szDiagnostic[ 0 ] != 'N' && szDiagnostic[ 0 ] != 'n' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szDiagnostic$[ebp+edx]
	cmp	eax, 78					; 0000004eH
	je	SHORT $LN2@SysDiagnos
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szDiagnostic$[ebp+edx]
	cmp	eax, 110				; 0000006eH
	je	SHORT $LN2@SysDiagnos

; 4395 :       return( SysMessageBox( lpTaskView, cpcTitle, cpcMessage, nBeep ) );

	mov	ecx, DWORD PTR _nBeep$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysMessageBox@16
	jmp	SHORT $LN1@SysDiagnos
$LN2@SysDiagnos:

; 4396 : 
; 4397 :    SysMessageList( cpcMessage );

	mov	edx, DWORD PTR _cpcMessage$[ebp]
	push	edx
	call	_SysMessageList@4

; 4398 :    return( 0 );

	xor	eax, eax
$LN1@SysDiagnos:

; 4399 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysDiagnosticMessage@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_ulTask$ = -8						; size = 4
_lTime$ = -4						; size = 4
_pchTargetName$ = 8					; size = 4
_SysCreateTempFileName@4 PROC

; 4880 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4881 :    zLONG  lTime;
; 4882 :    zULONG ulTask;
; 4883 :    *pchTargetName = 0;

	mov	eax, DWORD PTR _pchTargetName$[ebp]
	mov	BYTE PTR [eax], 0

; 4884 : 
; 4885 :    ulTask = (zULONG) GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _ulTask$[ebp], eax

; 4886 :    lTime = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _lTime$[ebp], eax

; 4887 :    zsprintf( pchTargetName, "%sZTF_%lx_%lx.TMP",

	mov	ecx, DWORD PTR _lTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ulTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 909				; 0000038dH
	push	eax
	push	OFFSET $SG99273
	mov	ecx, DWORD PTR _pchTargetName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 4888 :              AnchorBlock->szZeidonLoc, ulTask, lTime );
; 4889 :    return( 0 );

	xor	eax, eax

; 4890 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysCreateTempFileName@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_cpcFileSpecFrom$ = 12					; size = 4
_cpcFileSpecTo$ = 16					; size = 4
_bOverwrite$ = 20					; size = 1
_SysCopyFile@16 PROC

; 4972 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4973 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysCopyFil
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysCopyFil
$LN3@SysCopyFil:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysCopyFil:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 4974 : 
; 4975 :    return( fnSysCopyFile( lpTask, cpcFileSpecFrom,

	movzx	eax, BYTE PTR _bOverwrite$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcFileSpecFrom$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCopyFile@16

; 4976 :                           cpcFileSpecTo, bOverwrite ) );
; 4977 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysCopyFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hMem$ = -20						; size = 4
_pchBuffer$ = -16					; size = 4
_hFileTo$ = -12						; size = 4
_hFileFrom$ = -8					; size = 4
_k$ = -4						; size = 2
_lpTask$ = 8						; size = 4
_cpcFileSpecFrom$ = 12					; size = 4
_cpcFileSpecTo$ = 16					; size = 4
_bOverwrite$ = 20					; size = 1
_fnSysCopyFile@16 PROC

; 4920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 4921 :    zLONG    hFileTo;
; 4922 :    zLONG    hFileFrom;
; 4923 :    zSHORT   k;
; 4924 :    zLONG    hMem = 0;

	mov	DWORD PTR _hMem$[ebp], 0

; 4925 :    zPCHAR   pchBuffer;
; 4926 : 
; 4927 :    if ( bOverwrite == FALSE &&

	movzx	eax, BYTE PTR _bOverwrite$[ebp]
	test	eax, eax
	jne	SHORT $LN5@fnSysCopyF
	push	4
	mov	ecx, DWORD PTR _cpcFileSpecTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysOpenFile@12
	test	eax, eax
	jne	SHORT $LN5@fnSysCopyF

; 4928 :         fnSysOpenFile( lpTask, cpcFileSpecTo, COREFILE_EXIST ) == 0 )
; 4929 :    {
; 4930 :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnSysCopyF
$LN5@fnSysCopyF:

; 4931 :    }
; 4932 : 
; 4933 :    hFileFrom = fnSysOpenFile( lpTask, cpcFileSpecFrom, COREFILE_READ );

	push	128					; 00000080H
	mov	eax, DWORD PTR _cpcFileSpecFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFileFrom$[ebp], eax

; 4934 :    if ( hFileFrom <= 0 )

	cmp	DWORD PTR _hFileFrom$[ebp], 0
	jg	SHORT $LN6@fnSysCopyF

; 4935 :       return( -2 );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@fnSysCopyF
$LN6@fnSysCopyF:

; 4936 : 
; 4937 :    hFileTo = fnSysOpenFile( lpTask, cpcFileSpecTo, COREFILE_WRITE );

	push	64					; 00000040H
	mov	edx, DWORD PTR _cpcFileSpecTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysOpenFile@12
	mov	DWORD PTR _hFileTo$[ebp], eax

; 4938 :    if ( hFileTo <= 0 )

	cmp	DWORD PTR _hFileTo$[ebp], 0
	jg	SHORT $LN7@fnSysCopyF

; 4939 :    {
; 4940 :       fnSysCloseFile( lpTask, hFileFrom, 0 );

	push	0
	mov	ecx, DWORD PTR _hFileFrom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 4941 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysCopyF
$LN7@fnSysCopyF:

; 4942 :    }
; 4943 : 
; 4944 :    hMem = SysAllocMemory( &pchBuffer, COPY_BUFFER_LTH, 0, zCOREMEM_ALLOC, 0 );

	push	0
	push	32768					; 00008000H
	push	0
	push	10000					; 00002710H
	lea	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hMem$[ebp], eax

; 4945 :    if ( pchBuffer == 0 )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $LN4@fnSysCopyF

; 4946 :    {
; 4947 :       fnSysCloseFile( lpTask, hFileFrom, 0 );

	push	0
	mov	ecx, DWORD PTR _hFileFrom$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 4948 :       fnSysCloseFile( lpTask, hFileTo, 0 );

	push	0
	mov	eax, DWORD PTR _hFileTo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysCloseFile@12

; 4949 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnSysCopyF
$LN4@fnSysCopyF:

; 4950 :    }
; 4951 : 
; 4952 :    for ( ; ; )
; 4953 :    {
; 4954 :       k = fnSysReadFile( lpTask, hFileFrom, pchBuffer, COPY_BUFFER_LTH );

	push	10000					; 00002710H
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFileFrom$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysReadFile@16
	mov	WORD PTR _k$[ebp], ax

; 4955 :       if ( k > 0 )

	movsx	edx, WORD PTR _k$[ebp]
	test	edx, edx
	jle	SHORT $LN9@fnSysCopyF

; 4956 :          fnSysWriteFile( lpTask, hFileTo, pchBuffer, k );

	movsx	eax, WORD PTR _k$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hFileTo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysWriteFile@16
	jmp	SHORT $LN10@fnSysCopyF
$LN9@fnSysCopyF:

; 4957 :       else
; 4958 :          break;

	jmp	SHORT $LN3@fnSysCopyF
$LN10@fnSysCopyF:

; 4959 :    }

	jmp	SHORT $LN4@fnSysCopyF
$LN3@fnSysCopyF:

; 4960 : 
; 4961 :    SysFreeMemory( hMem );

	mov	ecx, DWORD PTR _hMem$[ebp]
	push	ecx
	call	_SysFreeMemory@4

; 4962 :    fnSysCloseFile( lpTask, hFileFrom, 0 );

	push	0
	mov	edx, DWORD PTR _hFileFrom$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12

; 4963 :    fnSysCloseFile( lpTask, hFileTo, 0 );

	push	0
	mov	ecx, DWORD PTR _hFileTo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFile@12

; 4964 :    return( 1 );

	mov	eax, 1
$LN1@fnSysCopyF:

; 4965 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysCopyFile@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pchTarget$ = 8						; size = 4
_pchSource$ = 12					; size = 4
_SysConvertEnvironmentString@8 PROC

; 1969 : {

	push	ebp
	mov	ebp, esp

; 1970 :    fnConvertEnvironmentString( pchTarget, pchSource );

	mov	eax, DWORD PTR _pchSource$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTarget$[ebp]
	push	ecx
	call	_fnConvertEnvironmentString@8

; 1971 : }

	pop	ebp
	ret	8
_SysConvertEnvironmentString@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_pchAnsiString$ = 8					; size = 4
_SysConvertANSI_String@4 PROC

; 8114 : {

	push	ebp
	mov	ebp, esp

; 8115 : }

	pop	ebp
	ret	4
_SysConvertANSI_String@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lFileHandle$ = 12					; size = 4
_lpOwningTask$ = 16					; size = 4
_lControl$ = 20						; size = 4
_SysCloseFileWithControl@16 PROC

; 6286 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6287 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysCloseFi
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysCloseFi
$LN3@SysCloseFi:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysCloseFi:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6288 : 
; 6289 :    return( fnSysCloseFileWithControl( lpTask, lFileHandle,

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFileWithControl@16

; 6290 :                                       lpOwningTask, lControl ) );
; 6291 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysCloseFileWithControl@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv154 = -20						; size = 4
_lProcessID$1 = -16					; size = 4
_lpPrevOpenFile$ = -12					; size = 4
_lpOpenFile$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTask$ = 8						; size = 4
_lFileHandle$ = 12					; size = 4
_lpOwningTask$ = 16					; size = 4
_lControl$ = 20						; size = 4
_fnSysCloseFileWithControl@16 PROC

; 6169 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 6170 :    LPOPENFILE  lpOpenFile;
; 6171 :    LPOPENFILE  lpPrevOpenFile;
; 6172 :    zSHORT      nRC;
; 6173 : 
; 6174 :    nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 6175 : 
; 6176 : // TraceLine( "fnSysCloseFileWithControl ??   Handle: 0x%08x   Task: 0x%08x   Process: 0x%08x",
; 6177 : //            lFileHandle, lpTask, lProcessID );
; 6178 : 
; 6179 :    // Get the task and match up the file handle passed with an
; 6180 :    // OpenFile record. If the record is not found, return a zCALL_ERROR;
; 6181 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN5@fnSysClose

; 6182 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysClose
$LN5@fnSysClose:

; 6183 : 
; 6184 :    if ( lpOwningTask == 0 )

	cmp	DWORD PTR _lpOwningTask$[ebp], 0
	jne	SHORT $LN6@fnSysClose

; 6185 :       lpOwningTask = lpTask;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR _lpOwningTask$[ebp], ecx
$LN6@fnSysClose:

; 6186 : 
; 6187 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 6188 : 
; 6189 :    // Find open file and prev open file.
; 6190 :    for ( lpPrevOpenFile = 0, lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	DWORD PTR _lpPrevOpenFile$[ebp], 0
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+118]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
	jmp	SHORT $LN4@fnSysClose
$LN2@fnSysClose:

; 6192 :          lpPrevOpenFile = lpOpenFile, lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile ) )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	DWORD PTR _lpPrevOpenFile$[ebp], ecx
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$LN4@fnSysClose:

; 6191 :          lpOpenFile;

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $LN3@fnSysClose

; 6193 :    {
; 6194 :       if ( lpOpenFile->lFileHandle == lFileHandle )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	cmp	edx, DWORD PTR _lFileHandle$[ebp]
	jne	SHORT $LN7@fnSysClose

; 6195 :          break;

	jmp	SHORT $LN3@fnSysClose
$LN7@fnSysClose:

; 6196 :    }

	jmp	SHORT $LN2@fnSysClose
$LN3@fnSysClose:

; 6197 : 
; 6198 :    if ( lpOpenFile == 0 )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	jne	SHORT $LN8@fnSysClose

; 6199 :    {
; 6200 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 6201 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSysClose
$LN8@fnSysClose:

; 6202 :    }
; 6203 : 
; 6204 :    if ( lpPrevOpenFile )

	cmp	DWORD PTR _lpPrevOpenFile$[ebp], 0
	je	SHORT $LN9@fnSysClose

; 6205 :       lpPrevOpenFile->hNextOpenFile = lpOpenFile->hNextOpenFile;

	mov	eax, DWORD PTR _lpPrevOpenFile$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+6], edx
	jmp	SHORT $LN10@fnSysClose
$LN9@fnSysClose:

; 6206 :    else
; 6207 :       lpTask->hFirstOpenFile = lpOpenFile->hNextOpenFile;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+118], edx
$LN10@fnSysClose:

; 6208 : 
; 6209 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 6210 : 
; 6211 :    // If the file has been used for buffered writes, write it out now.
; 6212 :    if ( lpOpenFile->nFlags & COREFILE_WRITELINE_BUFFERED )

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	movsx	ecx, WORD PTR [eax+10]
	and	ecx, 1
	je	SHORT $LN11@fnSysClose

; 6213 :    {
; 6214 :       if ( lpOwningTask == lpTask &&
; 6215 :            lpOpenFile->hWriteBuffer && lpOpenFile->uWriteBufferPos )

	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	cmp	edx, DWORD PTR _lpTask$[ebp]
	jne	SHORT $LN11@fnSysClose
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [eax+554], 0
	je	SHORT $LN11@fnSysClose
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	cmp	DWORD PTR [ecx+550], 0
	je	SHORT $LN11@fnSysClose

; 6216 :       {
; 6217 :          fnSysWriteFile( lpTask, lpOpenFile->lFileHandle,

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+550]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+554]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysWriteFile@16
$LN11@fnSysClose:

; 6218 :                          zGETPTR( lpOpenFile->hWriteBuffer ),
; 6219 :                          lpOpenFile->uWriteBufferPos );
; 6220 :       }
; 6221 :    }
; 6222 : 
; 6223 :    // Open file record cleaned up, close the file
; 6224 :    // Note: Although the close may fail, keeping the open
; 6225 :    // file record around is probably of little value.
; 6226 :    // Note: We only close when called by application, not
; 6227 :    // when called by a task cleanup from object services because
; 6228 :    // the handle may have been reused by another task
; 6229 :    // after the owning task bombed.
; 6230 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 6231 :    if ( lpOwningTask == lpTask )

	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	cmp	ecx, DWORD PTR _lpTask$[ebp]
	jne	SHORT $LN13@fnSysClose

; 6232 :    {
; 6233 :       zLONG lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$1[ebp], eax

; 6234 : 
; 6235 :       if ( lpTask != zGETPTR( AnchorBlock->hMainTask ) ) // this trace causes problems when starting OE

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpTask$[ebp], eax
	je	SHORT $LN14@fnSysClose

; 6236 :       {
; 6237 :          TraceLine( "fnSysCloseFileWithControl %s   Handle: 0x%08x   Task: 0x%08x   Process: 0x%08x:0x%08x",

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	mov	eax, DWORD PTR _lProcessID$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lFileHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	push	OFFSET $SG99742
	call	_TraceLine
	add	esp, 24					; 00000018H
$LN14@fnSysClose:

; 6238 :                     lpOpenFile->szFileName, lFileHandle, lpTask, lProcessID, lpOpenFile->lProcessID );
; 6239 :       }
; 6240 : 
; 6241 :       if ( lpOpenFile->lProcessID == lProcessID )

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _lProcessID$1[ebp]
	jne	SHORT $LN13@fnSysClose

; 6242 :          nRC = CloseHandle( (HANDLE) lFileHandle ) ? 0 : zCALL_ERROR;

	mov	eax, DWORD PTR _lFileHandle$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	je	SHORT $LN20@fnSysClose
	mov	DWORD PTR tv154[ebp], 0
	jmp	SHORT $LN21@fnSysClose
$LN20@fnSysClose:
	mov	DWORD PTR tv154[ebp], -16		; fffffff0H
$LN21@fnSysClose:
	mov	cx, WORD PTR tv154[ebp]
	mov	WORD PTR _nRC$[ebp], cx
$LN13@fnSysClose:

; 6243 :    }
; 6244 : 
; 6245 :    // If the file was opened with the backup option then we need to rename
; 6246 :    // the backup file to the original file.
; 6247 :    if ( lpOpenFile->nFlags & COREFILE_BACKUP )

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	movsx	eax, WORD PTR [edx+10]
	and	eax, 4096				; 00001000H
	je	SHORT $LN16@fnSysClose

; 6248 :    {
; 6249 :       // Don't rename the file if the abort option was set.
; 6250 :       if ( (lControl & CLOSEFILE_ABORT_BACKUP) == 0 )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1
	jne	SHORT $LN16@fnSysClose

; 6251 :       {
; 6252 : // DGC 2000.11.06 Following code creates backups.  Taken out for more
; 6253 : // consideration.
; 6254 : #if 0
; 6255 :          zCHAR szBackup[ zMAX_FILENAME_LTH + 1 ];
; 6256 : 
; 6257 :          // Rename the original file to a .BAK file.
; 6258 :          zstrcpy( szBackup, lpOpenFile->szFileName );
; 6259 :          zstrcat( szBackup, ".BAK" );
; 6260 :          if ( SysRenameFile( lpOpenFile->szFileName,
; 6261 :                              szBackup, TRUE ) == zCALL_ERROR )
; 6262 :          {
; 6263 :             nRC = zCALL_ERROR;
; 6264 :          }
; 6265 : #endif
; 6266 : 
; 6267 :          if ( fnSysRenameFile( lpOwningTask, lpOpenFile->szTempFileName,
; 6268 :                                lpOpenFile->szFileName, TRUE ) == zCALL_ERROR )

	push	1
	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	add	eax, 273				; 00000111H
	push	eax
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	push	ecx
	call	_fnSysRenameFile@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN16@fnSysClose

; 6269 :          {
; 6270 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN16@fnSysClose:

; 6271 :          }
; 6272 :       }
; 6273 :    }
; 6274 : 
; 6275 :    fnFreeDataspace( zGETPTR( lpOpenFile->hReadBuffer ) );

	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+542]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 6276 :    fnFreeDataspace( zGETPTR( lpOpenFile->hWriteBuffer ) );

	mov	eax, DWORD PTR _lpOpenFile$[ebp]
	mov	ecx, DWORD PTR [eax+554]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 6277 :    fnFreeDataspace( lpOpenFile );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 6278 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnSysClose:

; 6279 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnSysCloseFileWithControl@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
tv68 = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_lFileHandle$ = 12					; size = 4
_lpOwningTask$ = 16					; size = 4
_SysCloseFile@12 PROC

; 6306 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 6307 :    LPTASK lpTask = lpTaskView ? zGETPTR( lpTaskView->hTask ) : 0;

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysCloseFi
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@SysCloseFi
$LN3@SysCloseFi:
	mov	DWORD PTR tv68[ebp], 0
$LN4@SysCloseFi:
	mov	edx, DWORD PTR tv68[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 6308 : 
; 6309 :    return( fnSysCloseFileWithControl( lpTask, lFileHandle, lpOwningTask, 0 ) );

	push	0
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFileWithControl@16
	cwde

; 6310 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysCloseFile@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_lFileHandle$ = 12					; size = 4
_lpOwningTask$ = 16					; size = 4
_fnSysCloseFile@12 PROC

; 6297 : {

	push	ebp
	mov	ebp, esp

; 6298 :    return( fnSysCloseFileWithControl( lpTask, lFileHandle,

	push	0
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lFileHandle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysCloseFileWithControl@16
	cwde

; 6299 :                                       lpOwningTask, 0 ) );
; 6300 : }

	pop	ebp
	ret	12					; 0000000cH
_fnSysCloseFile@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_SysCheckTaskMemory@0 PROC

; 3496 : {

	push	ebp
	mov	ebp, esp

; 3497 :    return( 0 );

	xor	eax, eax

; 3498 : }

	pop	ebp
	ret	0
_SysCheckTaskMemory@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_vKZXMLPGO$ = -4					; size = 4
_v$ = 8							; size = 4
_cpcDialog$ = 12					; size = 4
_pchBannerName$ = 16					; size = 4
_SysGetWebBannerName@12 PROC

; 833  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 834  :    zVIEW      vKZXMLPGO;
; 835  : 
; 836  :    pchBannerName[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchBannerName$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 837  :    GetViewByName( &vKZXMLPGO, "KZXMLPGO", v, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET $SG98174
	lea	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 838  :    if ( vKZXMLPGO )

	cmp	DWORD PTR _vKZXMLPGO$[ebp], 0
	je	SHORT $LN2@SysGetWebB

; 839  :    {
; 840  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "DynamicBannerName", "DialogName",
; 841  :                                          cpcDialog, "" ) >= zCURSOR_SET )

	push	OFFSET $SG98177
	mov	edx, DWORD PTR _cpcDialog$[ebp]
	push	edx
	push	OFFSET $SG98178
	push	OFFSET $SG98179
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jl	SHORT $LN3@SysGetWebB

; 842  :       {
; 843  :          GetStringFromAttribute( pchBannerName, vKZXMLPGO,

	push	OFFSET $SG98180
	push	OFFSET $SG98181
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBannerName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16
$LN3@SysGetWebB:

; 844  :                                  "DynamicBannerName", "DialogName" );
; 845  :       }
; 846  : 
; 847  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SysGetWebB
$LN2@SysGetWebB:

; 848  :    }
; 849  : 
; 850  :    return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@SysGetWebB:

; 851  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysGetWebBannerName@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_vKZXMLPGO$ = -4					; size = 4
_v$ = 8							; size = 4
_cpcDialog$ = 12					; size = 4
_cpcBannerName$ = 16					; size = 4
_SysSetWebBannerName@12 PROC

; 809  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 810  :    zVIEW      vKZXMLPGO;
; 811  : 
; 812  :    GetViewByName( &vKZXMLPGO, "KZXMLPGO", v, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET $SG98155
	lea	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 813  :    if ( vKZXMLPGO )

	cmp	DWORD PTR _vKZXMLPGO$[ebp], 0
	je	SHORT $LN2@SysSetWebB

; 814  :    {
; 815  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "DynamicBannerName", "DialogName",
; 816  :                                          cpcDialog, "" ) < zCURSOR_SET )

	push	OFFSET $SG98158
	mov	edx, DWORD PTR _cpcDialog$[ebp]
	push	edx
	push	OFFSET $SG98159
	push	OFFSET $SG98160
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN3@SysSetWebB

; 817  :       {
; 818  :          CreateEntity( vKZXMLPGO, "DynamicBannerName", zPOS_FIRST );

	push	1
	push	OFFSET $SG98161
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_CreateEntity@12

; 819  :          SetAttributeFromString( vKZXMLPGO, "DynamicBannerName",

	mov	eax, DWORD PTR _cpcDialog$[ebp]
	push	eax
	push	OFFSET $SG98162
	push	OFFSET $SG98163
	mov	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN3@SysSetWebB:

; 820  :                                  "DialogName", cpcDialog );
; 821  :       }
; 822  : 
; 823  :       SetAttributeFromString( vKZXMLPGO, "DynamicBannerName", "BannerName", cpcBannerName );

	mov	edx, DWORD PTR _cpcBannerName$[ebp]
	push	edx
	push	OFFSET $SG98164
	push	OFFSET $SG98165
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 824  : 
; 825  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SysSetWebB
$LN2@SysSetWebB:

; 826  :    }
; 827  : 
; 828  :    return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@SysSetWebB:

; 829  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysSetWebBannerName@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -76						; size = 4
_lpApp$ = -72						; size = 4
_szName$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_pchReturnName$ = 8					; size = 4
_v$ = 12						; size = 4
_lFlags$ = 16						; size = 4
_SysMakeWebFileName@12 PROC

; 712  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 713  :    LPAPP  lpApp;
; 714  :    LPTASK lpTask;
; 715  :    zCHAR  szName[ 64 ];
; 716  : 
; 717  :    SfGetApplicationForSubtask( &lpApp, v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_SfGetApplicationForSubtask@8

; 718  : 
; 719  :    pchReturnName[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 720  :    if ( lFlags & 0x00000001 )  // use Application

	mov	edx, DWORD PTR _lFlags$[ebp]
	and	edx, 1
	je	SHORT $LN2@SysMakeWeb

; 721  :    {
; 722  :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN4@SysMakeWeb

; 723  :          zstrcpy( pchReturnName, lpApp->szLocalDir );

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 604				; 0000025cH
	push	eax
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN4@SysMakeWeb:

; 724  :    }

	jmp	SHORT $LN3@SysMakeWeb
$LN2@SysMakeWeb:

; 725  :    else
; 726  :    if ( lFlags & 0x00000002 )  // use Ini WebDirectory

	mov	edx, DWORD PTR _lFlags$[ebp]
	and	edx, 2
	je	SHORT $LN3@SysMakeWeb

; 727  :    {
; 728  :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN6@SysMakeWeb

; 729  :       {
; 730  :          zstrcpy( szName, "[App." );

	push	OFFSET $SG98099
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 731  :          zstrcpy( szName + 5, lpApp->szName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp+5]
	push	edx
	call	_strcpy
	add	esp, 8

; 732  :          zstrcat( szName, "]" );

	push	OFFSET $SG98100
	lea	eax, DWORD PTR _szName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 733  :          SysReadZeidonIni( -1, szName, "WebDirectory", pchReturnName );

	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	push	OFFSET $SG98101
	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	push	-1
	call	_SysReadZeidonIni@16
$LN6@SysMakeWeb:

; 734  :       }
; 735  : 
; 736  :       if ( pchReturnName[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN3@SysMakeWeb

; 737  :          SysReadZeidonIni( -1, "[Workstation]", "WebDirectory", pchReturnName );

	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	push	OFFSET $SG98103
	push	OFFSET $SG98104
	push	-1
	call	_SysReadZeidonIni@16
$LN3@SysMakeWeb:

; 738  :    }
; 739  : 
; 740  :    if ( pchReturnName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN8@SysMakeWeb

; 741  :       SysAppendcDirSep( pchReturnName );

	mov	eax, DWORD PTR _pchReturnName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4
$LN8@SysMakeWeb:

; 742  : 
; 743  :    lpTask = zGETPTR( v->hTask );

	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 744  :    if ( lpTask->szSessionId[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+194]
	test	eax, eax
	je	SHORT $LN9@SysMakeWeb

; 745  :    {
; 746  :       szName[ 0 ] = 's';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szName$[ebp+edx], 115		; 00000073H

; 747  :       szName[ 1 ] = 'i';

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _szName$[ebp+eax], 105		; 00000069H

; 748  :       zstrcpy( szName + 2, lpTask->szSessionId );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	lea	edx, DWORD PTR _szName$[ebp+2]
	push	edx
	call	_strcpy
	add	esp, 8

; 749  :    }

	jmp	SHORT $LN10@SysMakeWeb
$LN9@SysMakeWeb:

; 750  :    else
; 751  :    {
; 752  :       zsprintf( szName, "0x%08x", v );

	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET $SG98108
	lea	ecx, DWORD PTR _szName$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN10@SysMakeWeb:

; 753  :    }
; 754  : 
; 755  :    zstrcat( pchReturnName, szName );

	lea	edx, DWORD PTR _szName$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 756  : // TraceLineS( "SysMakeWebFileName: ", pchReturnName );
; 757  :    return( zstrlen( pchReturnName ) );

	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4

; 758  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysMakeWebFileName@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lKey$1 = -80						; size = 4
_vKZXMLPGO$ = -76					; size = 4
_nLth$2 = -72						; size = 2
_szFullCtrlTag$3 = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_v$ = 8							; size = 4
_cpcDialog$ = 12					; size = 4
_cpcWindow$ = 16					; size = 4
_cpcEntity$ = 20					; size = 4
_cpcCtrlTag$ = 24					; size = 4
_SysSetFocusToWebCtrl@20 PROC

; 763  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 764  :    zVIEW      vKZXMLPGO;
; 765  : 
; 766  :    GetViewByName( &vKZXMLPGO, "KZXMLPGO", v, zLEVEL_TASK );

	push	2
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	push	OFFSET $SG98126
	lea	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_GetViewByName@16

; 767  :    if ( vKZXMLPGO )

	cmp	DWORD PTR _vKZXMLPGO$[ebp], 0
	je	$LN2@SysSetFocu

; 768  :    {
; 769  :       zCHAR szFullCtrlTag[ 64 ];
; 770  : 
; 771  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "Dialog", "DialogName",
; 772  :                                          cpcDialog, "" ) < zCURSOR_SET )

	push	OFFSET $SG98129
	mov	edx, DWORD PTR _cpcDialog$[ebp]
	push	edx
	push	OFFSET $SG98130
	push	OFFSET $SG98131
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN3@SysSetFocu

; 773  :       {
; 774  :          CreateEntity( vKZXMLPGO, "Dialog", zPOS_FIRST );

	push	1
	push	OFFSET $SG98132
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_CreateEntity@12

; 775  :          SetAttributeFromString( vKZXMLPGO, "Dialog", "DialogName", cpcDialog );

	mov	eax, DWORD PTR _cpcDialog$[ebp]
	push	eax
	push	OFFSET $SG98133
	push	OFFSET $SG98134
	mov	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN3@SysSetFocu:

; 776  :       }
; 777  : 
; 778  :       if ( SetCursorFirstEntityByString( vKZXMLPGO, "Window", "WindowName",
; 779  :                                          cpcWindow, "" ) < zCURSOR_SET )

	push	OFFSET $SG98136
	mov	edx, DWORD PTR _cpcWindow$[ebp]
	push	edx
	push	OFFSET $SG98137
	push	OFFSET $SG98138
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN4@SysSetFocu

; 780  :       {
; 781  :          CreateEntity( vKZXMLPGO, "Window", zPOS_FIRST );

	push	1
	push	OFFSET $SG98139
	mov	edx, DWORD PTR _vKZXMLPGO$[ebp]
	push	edx
	call	_CreateEntity@12

; 782  :          SetAttributeFromString( vKZXMLPGO, "Window", "WindowName", cpcWindow );

	mov	eax, DWORD PTR _cpcWindow$[ebp]
	push	eax
	push	OFFSET $SG98140
	push	OFFSET $SG98141
	mov	ecx, DWORD PTR _vKZXMLPGO$[ebp]
	push	ecx
	call	_SetAttributeFromString@16
$LN4@SysSetFocu:

; 783  :       }
; 784  : 
; 785  :       if ( cpcEntity && cpcEntity[ 0 ] )

	cmp	DWORD PTR _cpcEntity$[ebp], 0
	je	SHORT $LN5@SysSetFocu
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN5@SysSetFocu

; 786  :       {
; 787  :          zLONG  lKey = GetEntityKey( v, cpcEntity );

	mov	eax, DWORD PTR _cpcEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	_GetEntityKey@8
	mov	DWORD PTR _lKey$1[ebp], eax

; 788  :          zSHORT nLth;
; 789  : 
; 790  :          szFullCtrlTag[ 0 ] = '@';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szFullCtrlTag$3[ebp+eax], 64	; 00000040H

; 791  :          zstrcpy( szFullCtrlTag + 1, cpcCtrlTag );

	mov	ecx, DWORD PTR _cpcCtrlTag$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFullCtrlTag$3[ebp+1]
	push	edx
	call	_strcpy
	add	esp, 8

; 792  :          nLth = zstrlen( szFullCtrlTag );

	lea	eax, DWORD PTR _szFullCtrlTag$3[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$2[ebp], ax

; 793  :          szFullCtrlTag[ nLth++ ] = '#';

	movsx	ecx, WORD PTR _nLth$2[ebp]
	mov	BYTE PTR _szFullCtrlTag$3[ebp+ecx], 35	; 00000023H
	mov	dx, WORD PTR _nLth$2[ebp]
	add	dx, 1
	mov	WORD PTR _nLth$2[ebp], dx

; 794  :          zltoa( lKey, szFullCtrlTag + nLth );

	push	10					; 0000000aH
	movsx	eax, WORD PTR _nLth$2[ebp]
	lea	ecx, DWORD PTR _szFullCtrlTag$3[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _lKey$1[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 795  :       }

	jmp	SHORT $LN6@SysSetFocu
$LN5@SysSetFocu:

; 796  :       else
; 797  :          zstrcpy( szFullCtrlTag, cpcCtrlTag );

	mov	eax, DWORD PTR _cpcCtrlTag$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFullCtrlTag$3[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
$LN6@SysSetFocu:

; 798  : 
; 799  :       SetAttributeFromString( vKZXMLPGO, "Window", "FocusCtrl", szFullCtrlTag );

	lea	edx, DWORD PTR _szFullCtrlTag$3[ebp]
	push	edx
	push	OFFSET $SG98144
	push	OFFSET $SG98145
	mov	eax, DWORD PTR _vKZXMLPGO$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 800  : 
; 801  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SysSetFocu
$LN2@SysSetFocu:

; 802  :    }
; 803  : 
; 804  :    return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@SysSetFocu:

; 805  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SysSetFocusToWebCtrl@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lLth$ = -4						; size = 4
_pchString$ = 8						; size = 4
_SysAppendcDirSep@4 PROC

; 7824 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7825 :    zLONG  lLth;
; 7826 : 
; 7827 :    lLth = zstrlen( pchString );

	mov	eax, DWORD PTR _pchString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lLth$[ebp], eax

; 7828 :    if ( lLth > 1 && pchString[ lLth - 1 ] != cDirSep )

	cmp	DWORD PTR _lLth$[ebp], 1
	jle	SHORT $LN2@SysAppendc
	mov	ecx, DWORD PTR _pchString$[ebp]
	add	ecx, DWORD PTR _lLth$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	movsx	eax, BYTE PTR _cDirSep
	cmp	edx, eax
	je	SHORT $LN2@SysAppendc

; 7829 :    {
; 7830 :       pchString[ lLth++ ] = cDirSep;

	mov	ecx, DWORD PTR _pchString$[ebp]
	add	ecx, DWORD PTR _lLth$[ebp]
	mov	dl, BYTE PTR _cDirSep
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _lLth$[ebp]
	add	eax, 1
	mov	DWORD PTR _lLth$[ebp], eax

; 7831 :       pchString[ lLth ] = 0;

	mov	ecx, DWORD PTR _pchString$[ebp]
	add	ecx, DWORD PTR _lLth$[ebp]
	mov	BYTE PTR [ecx], 0
$LN2@SysAppendc:

; 7832 :    }
; 7833 : 
; 7834 :    return( (zSHORT) lLth );

	mov	ax, WORD PTR _lLth$[ebp]

; 7835 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysAppendcDirSep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_szMsg$1 = -64						; size = 60
__$ArrayPad$ = -4					; size = 4
_ppvMemory$ = 8						; size = 4
_lBytes$ = 12						; size = 4
_hMemory$ = 16						; size = 4
_uMemFlags$ = 20					; size = 4
_cpcShareName$ = 24					; size = 4
_SysAllocMemory@20 PROC

; 3365 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3366 :    *ppvMemory = SysMalloc( lBytes );

	mov	eax, DWORD PTR _lBytes$[ebp]
	push	eax
	call	_SysMalloc@4
	mov	ecx, DWORD PTR _ppvMemory$[ebp]
	mov	DWORD PTR [ecx], eax

; 3367 :    hMemory = (zLONG) *ppvMemory;

	mov	edx, DWORD PTR _ppvMemory$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _hMemory$[ebp], eax

; 3368 : 
; 3369 :    // If an error occurred, tell operator about it, NOTE we do not call
; 3370 :    // fnIssueCoreError because out of memory is a very delicate situation
; 3371 :    // to be in!!.
; 3372 :    if ( hMemory == 0 )

	cmp	DWORD PTR _hMemory$[ebp], 0
	jne	SHORT $LN2@SysAllocMe

; 3373 :    {
; 3374 :       char szMsg[ 60 ];
; 3375 : 
; 3376 :       // offset ...... 1234567890123456789212345678931234567894123456
; 3377 :       zstrcpy( szMsg, "KZOE0012 - Error allocating memory for length " );

	push	OFFSET $SG98824
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 3378 :       zltoa( lBytes, szMsg + 46 );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _szMsg$1[ebp+46]
	push	edx
	mov	eax, DWORD PTR _lBytes$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 3379 :       SysMessageBox( 0, szlOE_SystemError, szMsg, -1 );

	push	-1
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16
$LN2@SysAllocMe:

; 3380 :    }
; 3381 : 
; 3382 :    // Return the handle to the memory allocated.
; 3383 :    return( hMemory );

	mov	eax, DWORD PTR _hMemory$[ebp]

; 3384 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_SysAllocMemory@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hMemory$ = 8						; size = 4
_SysAddressMemory@4 PROC

; 3439 : {

	push	ebp
	mov	ebp, esp

; 3440 :    if ( hMemory == g_hAnchorBlock )  // we share the anchor block by name

	mov	eax, DWORD PTR _hMemory$[ebp]
	cmp	eax, DWORD PTR _g_hAnchorBlock
	jne	SHORT $LN2@SysAddress

; 3441 :    {
; 3442 : //    TraceLineX( "SysAddressMemory hAnchorBlock ", (zLONG) hMemory );
; 3443 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SysAddress
$LN2@SysAddress:

; 3444 :    }
; 3445 : 
; 3446 :    // Do nothing for addressing since GlobalLock does not seem to
; 3447 :    // increment the memory lock count and all memory is shareable in
; 3448 :    // windows. Therefore, we never attempt to increase the lock count
; 3449 :    // and also never free memory unless the main task requests the free
; 3450 :    // (see SysFreeMemory).
; 3451 :    return( 0 );

	xor	eax, eax
$LN1@SysAddress:

; 3452 : }

	pop	ebp
	ret	4
_SysAddressMemory@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpEntityInstance$ = -4					; size = 4
_lpViewEntityCsr$ = 8					; size = 4
_fnReuseEntity@4 PROC

; 7352 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 7353 :    LPENTITYINSTANCE  lpEntityInstance;
; 7354 : 
; 7355 :    EnterCriticalSection( &g_csReuseEntity );

	push	OFFSET _g_csReuseEntity
	call	DWORD PTR __imp__EnterCriticalSection@4

; 7356 : 
; 7357 :    lpEntityInstance = zGETPTR( ((LPVIEWENTITYCSR) lpViewEntityCsr)->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN2@fnReuseEnt:

; 7358 :    while ( lpEntityInstance )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN3@fnReuseEnt

; 7359 :    {
; 7360 :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN4@fnReuseEnt

; 7361 :       {
; 7362 :          lpEntityInstance->u.nInd.bHidden = FALSE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	and	edx, -1025				; fffffbffH
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx

; 7363 :          LeaveCriticalSection( &g_csReuseEntity );

	push	OFFSET _g_csReuseEntity
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7364 :          return( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	jmp	SHORT $LN1@fnReuseEnt
$LN4@fnReuseEnt:

; 7365 :       }
; 7366 : 
; 7367 :       lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 7368 :    }

	jmp	SHORT $LN2@fnReuseEnt
$LN3@fnReuseEnt:

; 7369 : 
; 7370 :    LeaveCriticalSection( &g_csReuseEntity );

	push	OFFSET _g_csReuseEntity
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 7371 :    return( 0 );

	xor	eax, eax
$LN1@fnReuseEnt:

; 7372 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnReuseEntity@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_dw$ = -32						; size = 4
_hInstance$ = -28					; size = 4
tv139 = -24						; size = 4
_hMainWnd$ = -20					; size = 4
_lpSearchTask$1 = -16					; size = 4
_lCount$2 = -12						; size = 4
_lpTask$ = -8						; size = 4
_nRC$ = -4						; size = 2
_vTaskView$ = 8						; size = 4
_UnregisterZeidonApplication@4 PROC

; 1119 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1120 :    DWORD     dw;
; 1121 :    HWND      hMainWnd;
; 1122 :    HINSTANCE hInstance;
; 1123 : 
; 1124 :    LPTASK lpTask;
; 1125 :    zSHORT nRC;
; 1126 : 
; 1127 :    lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 1128 : 
; 1129 :    zLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysLockCoreMutex@4

; 1130 : 
; 1131 :    hInstance = (HINSTANCE) lpTask->lHab;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hInstance$[ebp], eax

; 1132 : 
; 1133 :    if ( lpTask->bTransientTask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN5@Unregister

; 1134 :    {
; 1135 :       LeaveCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+439]
	push	ecx
	call	DWORD PTR __imp__LeaveCriticalSection@4

; 1136 :       DeleteCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+439]
	push	eax
	call	DWORD PTR __imp__DeleteCriticalSection@4

; 1137 :       free( lpTask->pcsCriticalSection );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+439]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN5@Unregister:

; 1138 :    }
; 1139 : 
; 1140 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN6@Unregister

; 1141 :    {
; 1142 :       TraceLine( "(Unr) Cleaning up Registered S/Task: 0x%08x / 0x%08x (%d)   Process: %d   Thread: %d  %s",

	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 194				; 000000c2H
	push	edx
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _vTaskView$[ebp]
	push	eax
	push	OFFSET $SG98273
	call	_TraceLine
	add	esp, 28					; 0000001cH
$LN6@Unregister:

; 1143 :                  vTaskView, vTaskView->hTask, lpTask, GetCurrentProcessId( ),
; 1144 :                  GetCurrentThreadId( ), lpTask->szSessionId );
; 1145 :    // {
; 1146 :    //    zVIEW        vDbhWork;
; 1147 :    //
; 1148 :    //    GetViewByName( &vDbhWork, zDBHANDLER_WORK_VIEW_NAME,
; 1149 :    //                   vTaskView, zLEVEL_SYSTEM );
; 1150 :    //    if ( vDbhWork )
; 1151 :    //    {
; 1152 :    //       DisplayObjectInstance( vDbhWork, 0, 0 );
; 1153 :    //       TraceLineS( "", "" );
; 1154 :    //    }
; 1155 :    // }
; 1156 :    }
; 1157 : 
; 1158 :    // Check to see if we should drop the object engine if there are no other
; 1159 :    // tasks.  We'll do the check now because DeleteTask drops the AnchorBlock.
; 1160 :    hMainWnd = 0;

	mov	DWORD PTR _hMainWnd$[ebp], 0

; 1161 :    if ( AnchorBlock->bDropEngineIfNoTasks )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1495]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN7@Unregister

; 1162 :    {
; 1163 :       LPTASK lpSearchTask;
; 1164 :       zLONG  lCount = 0;

	mov	DWORD PTR _lCount$2[ebp], 0

; 1165 : 
; 1166 :       // Count the number of tasks.
; 1167 :       for ( lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$1[ebp], eax
	jmp	SHORT $LN4@Unregister
$LN2@Unregister:

; 1169 :             lpSearchTask = zGETPTR( lpSearchTask->hNextTask ) )

	mov	edx, DWORD PTR _lpSearchTask$1[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$1[ebp], eax
$LN4@Unregister:

; 1168 :             lpSearchTask;

	cmp	DWORD PTR _lpSearchTask$1[ebp], 0
	je	SHORT $LN3@Unregister

; 1170 :       {
; 1171 :          // We only care if there are 2 or fewer.
; 1172 :          if ( lCount++ > 1 )

	mov	ecx, DWORD PTR _lCount$2[ebp]
	mov	DWORD PTR tv139[ebp], ecx
	mov	edx, DWORD PTR _lCount$2[ebp]
	add	edx, 1
	mov	DWORD PTR _lCount$2[ebp], edx
	cmp	DWORD PTR tv139[ebp], 1
	jle	SHORT $LN8@Unregister

; 1173 :             break;

	jmp	SHORT $LN3@Unregister
$LN8@Unregister:

; 1174 :       }

	jmp	SHORT $LN2@Unregister
$LN3@Unregister:

; 1175 : 
; 1176 :       // If there are only 2 tasks that means only the current one and the
; 1177 :       // system task are running.  Set the HWND so we'll know to drop the
; 1178 :       // engine later.
; 1179 :       if ( lCount <= 2 )

	cmp	DWORD PTR _lCount$2[ebp], 2
	jg	SHORT $LN7@Unregister

; 1180 :          hMainWnd = (HWND) AnchorBlock->lOE_hMainWnd;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+94]
	mov	DWORD PTR _hMainWnd$[ebp], ecx
$LN7@Unregister:

; 1181 :    }
; 1182 : 
; 1183 :    nRC = DeleteTask( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_DeleteTask@4
	mov	WORD PTR _nRC$[ebp], ax

; 1184 : 
; 1185 :    // If hMainWnd is not 0 then we need to drop the engine.
; 1186 :    if ( hMainWnd )

	cmp	DWORD PTR _hMainWnd$[ebp], 0
	je	SHORT $LN10@Unregister

; 1187 :       PostMessage( hMainWnd, WM_CLOSE, 0, 0 );

	push	0
	push	0
	push	16					; 00000010H
	mov	eax, DWORD PTR _hMainWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__PostMessageA@16
$LN10@Unregister:

; 1188 : 
; 1189 :    zUNLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysUnlockCoreMutex@4

; 1190 : 
; 1191 :    if ( !UnregisterClass( szlNT_ThreadClassName, hInstance ) )

	mov	ecx, DWORD PTR _hInstance$[ebp]
	push	ecx
	push	OFFSET _szlNT_ThreadClassName
	call	DWORD PTR __imp__UnregisterClassA@8
	test	eax, eax
	jne	SHORT $LN11@Unregister

; 1192 :       dw = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dw$[ebp], eax
$LN11@Unregister:

; 1193 : 
; 1194 :    // Current thread has performed UnregisterZeidonApp( ) so ...
; 1195 :    g_bProcessRegistered = FALSE;

	mov	BYTE PTR _g_bProcessRegistered, 0

; 1196 : // g_lpCurrentTask = 0;
; 1197 : 
; 1198 : // SysMalloc( -1 );  // report memory usage (debug)
; 1199 : 
; 1200 : #ifdef __MUTEX_DEBUG__
; 1201 :    if ( g_MutexInfoTable )
; 1202 :    {
; 1203 :       zLONG  lTaskID = SysGetProcessID( 0 );
; 1204 :       zSHORT k, j;
; 1205 : 
; 1206 :       for ( k = 0; k < zMUTEX_COUNT; k++ )
; 1207 :       {
; 1208 :          for ( j = 0; j < g_MutexInfoTable[ k ].lLastTaskIdx; j++ )
; 1209 :          {
; 1210 :             if ( g_MutexInfoTable[ k ].TaskInfo[ j ].lTaskID != lTaskID )
; 1211 :                continue;
; 1212 : 
; 1213 :             g_MutexInfoTable[ k ].TaskInfo[ j ].lTaskID = 0;
; 1214 :             break;
; 1215 :          }
; 1216 :       }
; 1217 :    }
; 1218 : #endif
; 1219 : 
; 1220 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 1221 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_UnregisterZeidonApplication@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpLibrary$1 = -192					; size = 4
_hCurrentMem$2 = -188					; size = 4
_lPageTableIndex$3 = -184				; size = 4
_dwCurrentProcess$ = -180				; size = 4
_lpMutex$4 = -176					; size = 4
_lpMsg$5 = -172						; size = 4
_lRC$6 = -168						; size = 4
_lRC2$7 = -164						; size = 4
_hCurrentProcess$8 = -160				; size = 4
_dw$9 = -156						; size = 4
_hOwnerMem$10 = -152					; size = 4
_lProcessIdx$ = -148					; size = 4
_lPageTableIndex$11 = -144				; size = 4
_hOwnerTask$12 = -140					; size = 4
tv85 = -136						; size = 4
_lpTask$ = -132						; size = 4
_lPageTableIndex$13 = -128				; size = 4
_lPageTableIndex$14 = -124				; size = 4
_nRequest$ = -120					; size = 2
_lpSearchTask$15 = -116					; size = 4
_lpDataHeader$16 = -112					; size = 4
_lpRequestProcess$ = -108				; size = 4
_szMsg$17 = -104					; size = 100
__$ArrayPad$ = -4					; size = 4
_wParam$ = 8						; size = 4
_lParam$ = 12						; size = 4
_ProcessZeidonMessage@8 PROC

; 2487 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2488 :    LPPROCESSLIST lpRequestProcess;
; 2489 :    LPTASK        lpTask = 0;

	mov	DWORD PTR _lpTask$[ebp], 0

; 2490 :    zLONG         lProcessIdx = lParam;

	mov	eax, DWORD PTR _lParam$[ebp]
	mov	DWORD PTR _lProcessIdx$[ebp], eax

; 2491 :    DWORD         dwCurrentProcess = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	DWORD PTR _dwCurrentProcess$[ebp], eax

; 2492 :    zSHORT        nRequest;
; 2493 : 
; 2494 : //#ifdef DEBUG
; 2495 :    if ( g_bServerMode )

	movzx	ecx, BYTE PTR _g_bServerMode
	test	ecx, ecx
	je	SHORT $LN13@ProcessZei

; 2496 :    {
; 2497 :       SysMessageBox( (zVIEW) wParam, szlOE_SystemError,

	push	-1
	push	OFFSET $SG98677
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	_SysMessageBox@16

; 2498 :                      "Received a message while in Server Mode", -1 );
; 2499 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@ProcessZei
$LN13@ProcessZei:

; 2500 :    }
; 2501 : //#endif
; 2502 : 
; 2503 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN14@ProcessZei

; 2504 :       return( zCALL_ERROR );  // failure ... get out!

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ProcessZei
$LN14@ProcessZei:

; 2505 : 
; 2506 :    // Get address of requesting process.
; 2507 :    if ( lProcessIdx == -1 )

	cmp	DWORD PTR _lProcessIdx$[ebp], -1
	jne	SHORT $LN15@ProcessZei

; 2508 :    {
; 2509 :       nRequest = TASKREQ_FREEALL;

	mov	ecx, 5
	mov	WORD PTR _nRequest$[ebp], cx

; 2510 :       lpTask = zGETPTR( wParam );

	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 2511 :       lpRequestProcess = 0;

	mov	DWORD PTR _lpRequestProcess$[ebp], 0

; 2512 :    }

	jmp	SHORT $LN16@ProcessZei
$LN15@ProcessZei:

; 2513 :    else
; 2514 :    {
; 2515 :       lpRequestProcess = &AnchorBlock->OS_Data.ProcessList[ lProcessIdx ];

	imul	eax, DWORD PTR _lProcessIdx$[ebp], 20
	mov	ecx, DWORD PTR _AnchorBlock
	lea	edx, DWORD PTR [ecx+eax+1511]
	mov	DWORD PTR _lpRequestProcess$[ebp], edx

; 2516 :       if ( lpRequestProcess == 0 )

	cmp	DWORD PTR _lpRequestProcess$[ebp], 0
	jne	SHORT $LN17@ProcessZei

; 2517 :       {
; 2518 :          SysMessageBox( (zVIEW) wParam, "Zeidon Object Engine",

	push	-1
	push	OFFSET $SG98682
	push	OFFSET $SG98683
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	_SysMessageBox@16

; 2519 :                         "Internal Error - lpRequestProcess is null", -1 );
; 2520 :          return( zCALL_ERROR );  // Failure get out

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ProcessZei
$LN17@ProcessZei:

; 2521 :       }
; 2522 : 
; 2523 :       nRequest = lpRequestProcess->nOE_Request;

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _nRequest$[ebp], dx
$LN16@ProcessZei:

; 2524 : 
; 2525 : #ifdef SHARED_MEM_TRACE
; 2526 :       TraceLine( "ProcessZeidonMessage CurrentProcess: %d   "
; 2527 :                     "ProcessIdx: %d   Request CurrentProcess: %d   %s",
; 2528 :                  dwCurrentProcess, lProcessIdx, lpRequestProcess->lProcessID,
; 2529 :                  lpRequestProcess->nOE_Request == TASKREQ_SHARE ? "TASKREQ_SHARE" :
; 2530 :                  lpRequestProcess->nOE_Request == TASKREQ_ALLOC ? "TASKREQ_ALLOC" : "TASKREQ_FREE" );
; 2531 : #endif
; 2532 :    }
; 2533 : 
; 2534 :    // The requesting task is valid, process the message.
; 2535 :    switch ( nRequest )

	movsx	eax, WORD PTR _nRequest$[ebp]
	mov	DWORD PTR tv85[ebp], eax
	mov	ecx, DWORD PTR tv85[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv85[ebp], ecx
	cmp	DWORD PTR tv85[ebp], 6
	ja	$LN40@ProcessZei
	mov	edx, DWORD PTR tv85[ebp]
	jmp	DWORD PTR $LN42@ProcessZei[edx*4]
$LN18@ProcessZei:

; 2536 :    {
; 2537 :       case TASKREQ_SHARE:  // get here from fnGetAnchorBlock's task
; 2538 :                            // switch to main task
; 2539 :       {
; 2540 :          // Share a single block of the requesting task's memory.
; 2541 : 
; 2542 :          // We should only get this message for the main task.  Another task
; 2543 :          // has just started and needs to share all file mappings.  Go
; 2544 :          // through the table of file mappings and return some info.
; 2545 :          // lParam contains the last index into the process table with which
; 2546 :          // the calling process has shared memory.
; 2547 : 
; 2548 :          // OK to lose original ProcessID.
; 2549 :          lpRequestProcess->lProcessID = dwCurrentProcess;

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR _dwCurrentProcess$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 2550 :          lpRequestProcess->lPageTableIndex++;

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 2551 :          lpRequestProcess->hMemHandle = 0;  // no more blocks to share

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	DWORD PTR [edx+12], 0
$LN4@ProcessZei:

; 2552 : 
; 2553 : #ifdef SHARED_MEM_TRACE
; 2554 :          TraceLine( "TASKREQ_SHARE Process: 0x%08x   PageTableIndex: %d",
; 2555 :                     lpRequestProcess->lProcessID, lpRequestProcess->lPageTableIndex );
; 2556 : #endif
; 2557 : 
; 2558 :          while ( lpRequestProcess->lPageTableIndex < zSHR_MAX_PAGES )

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	cmp	DWORD PTR [eax+8], 256			; 00000100H
	jae	SHORT $LN5@ProcessZei

; 2559 :          {
; 2560 :             if ( g_ZeidonPageTable[ lpRequestProcess->lPageTableIndex ] )

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR _g_ZeidonPageTable[edx*4], 0
	je	SHORT $LN19@ProcessZei

; 2561 :             {
; 2562 :                // We found a used file mapping.  Copy the handle to parm2 and break loop.
; 2563 :                lpRequestProcess->hMemHandle = g_FileMappingHandles[ lpRequestProcess->lPageTableIndex ];

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR _g_FileMappingHandles[ecx*4]
	mov	DWORD PTR [edx+12], eax

; 2564 :                break;

	jmp	SHORT $LN5@ProcessZei
$LN19@ProcessZei:

; 2565 :             }
; 2566 : 
; 2567 :             lpRequestProcess->lPageTableIndex++;

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 1
	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	DWORD PTR [eax+8], edx

; 2568 :          }

	jmp	SHORT $LN4@ProcessZei
$LN5@ProcessZei:

; 2569 : 
; 2570 :          break;

	jmp	$LN2@ProcessZei
$LN20@ProcessZei:

; 2571 :       }
; 2572 : 
; 2573 :       case TASKREQ_ALLOC:  // get here from fnAllocSharedMemory and fnGetAnchorBlock
; 2574 :       {
; 2575 :          // Allocate shared memory.
; 2576 :          // Some other task wants to allocate shared memory and has already
; 2577 :          // created a file mapping.  Open a view to that file mapping.
; 2578 :          HANDLE hOwnerTask;
; 2579 :          HANDLE hOwnerMem  = (HANDLE) lpRequestProcess->hMemHandle;

	mov	ecx, DWORD PTR _lpRequestProcess$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _hOwnerMem$10[ebp], edx

; 2580 :          HANDLE hCurrentMem;
; 2581 :          HANDLE hCurrentProcess = GetCurrentProcess( );  // intentionally

	call	DWORD PTR __imp__GetCurrentProcess@0
	mov	DWORD PTR _hCurrentProcess$8[ebp], eax

; 2582 :          zLONG  lPageTableIndex = lpRequestProcess->lPageTableIndex;

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lPageTableIndex$3[ebp], ecx

; 2583 : 
; 2584 : #ifdef SHARED_MEM_TRACE
; 2585 :          TraceLine( "TASKREQ_ALLOC Page Table mapping at Index: %x   0x%08x   Process: (%d) %d",
; 2586 :                     lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], hCurrentProcess, GetCurrentProcessId( ) );
; 2587 : #endif
; 2588 : 
; 2589 :          // Creates a windows object handle from the current process to the
; 2590 :          // process specified by lpRequestProcess->lProcessID.
; 2591 :          hOwnerTask = OpenProcess( PROCESS_ALL_ACCESS, 0,

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	0
	push	2097151					; 001fffffH
	call	DWORD PTR __imp__OpenProcess@12
	mov	DWORD PTR _hOwnerTask$12[ebp], eax

; 2592 :                                    lpRequestProcess->lProcessID );
; 2593 : 
; 2594 :          if ( !DuplicateHandle( hOwnerTask, hOwnerMem, hCurrentProcess,

	push	2
	push	1
	push	0
	lea	ecx, DWORD PTR _hCurrentMem$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _hCurrentProcess$8[ebp]
	push	edx
	mov	eax, DWORD PTR _hOwnerMem$10[ebp]
	push	eax
	mov	ecx, DWORD PTR _hOwnerTask$12[ebp]
	push	ecx
	call	DWORD PTR __imp__DuplicateHandle@28
	test	eax, eax
	jne	$LN21@ProcessZei

; 2595 :                                 &hCurrentMem, 0, TRUE, DUPLICATE_SAME_ACCESS ) )
; 2596 :          {
; 2597 :             zLONG  lRC = (zLONG) GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC$6[ebp], eax

; 2598 :             zLONG  lRC2;
; 2599 :             zPCHAR lpMsg;
; 2600 :             DWORD  dw;
; 2601 : 
; 2602 :             if ( !GetHandleInformation( hOwnerTask, &dw ) )

	lea	edx, DWORD PTR _dw$9[ebp]
	push	edx
	mov	eax, DWORD PTR _hOwnerTask$12[ebp]
	push	eax
	call	DWORD PTR __imp__GetHandleInformation@8
	test	eax, eax
	jne	SHORT $LN22@ProcessZei

; 2603 :                lRC2 = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC2$7[ebp], eax
$LN22@ProcessZei:

; 2604 : 
; 2605 :             if ( !GetHandleInformation( hOwnerMem, &dw ) )

	lea	ecx, DWORD PTR _dw$9[ebp]
	push	ecx
	mov	edx, DWORD PTR _hOwnerMem$10[ebp]
	push	edx
	call	DWORD PTR __imp__GetHandleInformation@8
	test	eax, eax
	jne	SHORT $LN23@ProcessZei

; 2606 :                lRC2 = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC2$7[ebp], eax
$LN23@ProcessZei:

; 2607 : 
; 2608 :             if ( !GetHandleInformation( hCurrentProcess, &dw ) )

	lea	eax, DWORD PTR _dw$9[ebp]
	push	eax
	mov	ecx, DWORD PTR _hCurrentProcess$8[ebp]
	push	ecx
	call	DWORD PTR __imp__GetHandleInformation@8
	test	eax, eax
	jne	SHORT $LN24@ProcessZei

; 2609 :                lRC2 = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _lRC2$7[ebp], eax
$LN24@ProcessZei:

; 2610 : 
; 2611 :             FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,

	push	0
	push	0
	lea	edx, DWORD PTR _lpMsg$5[ebp]
	push	edx
	push	1024					; 00000400H
	mov	eax, DWORD PTR _lRC$6[ebp]
	push	eax
	push	0
	push	4352					; 00001100H
	call	DWORD PTR __imp__FormatMessageA@28

; 2612 :                            NULL, lRC, MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT),
; 2613 :                            (LPTSTR) &lpMsg, 0, NULL );
; 2614 : 
; 2615 :             TraceLineI( "(sy) DuplicateHandle RC = ", lRC );

	mov	ecx, DWORD PTR _lRC$6[ebp]
	push	ecx
	push	OFFSET $SG98691
	call	_TraceLineI@8

; 2616 :             TraceLineS( "(sy) DuplicateHandle Failed: ", lpMsg );

	mov	edx, DWORD PTR _lpMsg$5[ebp]
	push	edx
	push	OFFSET $SG98692
	call	_TraceLineS@8

; 2617 :             SysMessageBox( 0, szlOE_SystemError,

	push	-1
	push	OFFSET $SG98693
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 2618 :                            "Internal error -- DuplicateHandle failed!", -1 );
; 2619 :             CloseHandle( hOwnerTask );

	mov	ecx, DWORD PTR _hOwnerTask$12[ebp]
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4

; 2620 :             LocalFree( (LPVOID) lpMsg );

	mov	edx, DWORD PTR _lpMsg$5[ebp]
	push	edx
	call	DWORD PTR __imp__LocalFree@4

; 2621 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ProcessZei
$LN21@ProcessZei:

; 2622 :          }
; 2623 : 
; 2624 :          fnMapFile( &hCurrentMem, 0, &lPageTableIndex, 0 );

	push	0
	lea	eax, DWORD PTR _lPageTableIndex$3[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _hCurrentMem$2[ebp]
	push	ecx
	call	_fnMapFile@16

; 2625 :          CloseHandle( hOwnerTask );

	mov	edx, DWORD PTR _hOwnerTask$12[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 2626 :          break;

	jmp	$LN2@ProcessZei
$LN25@ProcessZei:

; 2627 :       }
; 2628 : 
; 2629 :       case TASKREQ_FREEALL:
; 2630 :       {
; 2631 :          LPTASK lpSearchTask;
; 2632 : 
; 2633 :          // The task is shutting down ... free requesting task's hold on
; 2634 :          // all memory "owned" by other tasks.
; 2635 : 
; 2636 :          // If the task is a thread task then we don't need to free memory --
; 2637 :          // it will be handled by the process task.
; 2638 :          if ( lpTask->bThreadTask )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 7
	and	ecx, 1
	je	SHORT $LN26@ProcessZei

; 2639 :             break;

	jmp	$LN2@ProcessZei
$LN26@ProcessZei:

; 2640 : 
; 2641 :          // Make sure nobody is currently deleting a task.
; 2642 :          fnStartBrowseOfTaskList( lpTask, FALSE );

	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnStartBrowseOfTaskList@8

; 2643 : 
; 2644 :          for ( lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$15[ebp], eax
	jmp	SHORT $LN8@ProcessZei
$LN6@ProcessZei:

; 2646 :                lpSearchTask = zGETPTR( lpSearchTask->hNextTask ) )

	mov	edx, DWORD PTR _lpSearchTask$15[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$15[ebp], eax
$LN8@ProcessZei:

; 2645 :                lpSearchTask;

	cmp	DWORD PTR _lpSearchTask$15[ebp], 0
	je	$LN7@ProcessZei

; 2647 :          {
; 2648 :             LPDATAHEADER lpDataHeader;
; 2649 : 
; 2650 :             // Don't bother for the current task.
; 2651 :             if ( lpSearchTask == lpTask )

	mov	ecx, DWORD PTR _lpSearchTask$15[ebp]
	cmp	ecx, DWORD PTR _lpTask$[ebp]
	jne	SHORT $LN27@ProcessZei

; 2652 :                continue;

	jmp	SHORT $LN6@ProcessZei
$LN27@ProcessZei:

; 2653 : 
; 2654 :             // Free all memory allocated for the task.
; 2655 :             lpDataHeader = zGETPTR( lpSearchTask->hFirstDataHeader );

	mov	edx, DWORD PTR _lpSearchTask$15[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$16[ebp], eax

; 2656 :             if ( lpDataHeader )

	cmp	DWORD PTR _lpDataHeader$16[ebp], 0
	je	$LN28@ProcessZei
$LN9@ProcessZei:

; 2657 :             {
; 2658 :                while ( lpDataHeader->hNextDataHeader )

	mov	ecx, DWORD PTR _lpDataHeader$16[ebp]
	cmp	DWORD PTR [ecx+38], 0
	je	SHORT $LN11@ProcessZei

; 2659 :                   lpDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );

	mov	edx, DWORD PTR _lpDataHeader$16[ebp]
	mov	eax, DWORD PTR [edx+38]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$16[ebp], eax
	jmp	SHORT $LN9@ProcessZei
$LN11@ProcessZei:

; 2660 : 
; 2661 :                while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN28@ProcessZei

; 2662 :                {
; 2663 :                   if ( lpDataHeader->lNextDataHandle )

	mov	edx, DWORD PTR _lpDataHeader$16[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN29@ProcessZei

; 2664 :                   {
; 2665 :                      zLONG lPageTableIndex;
; 2666 : 
; 2667 :                      if ( g_bWin95 )

	movzx	eax, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $LN30@ProcessZei

; 2668 :                         lPageTableIndex = (zLONG) *((zPLONG) lpDataHeader->lNextDataHandle - 1);

	mov	ecx, DWORD PTR _lpDataHeader$16[ebp]
	mov	edx, DWORD PTR [ecx+34]
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR _lPageTableIndex$14[ebp], eax
	jmp	SHORT $LN31@ProcessZei
$LN30@ProcessZei:

; 2669 :                      else
; 2670 :                         lPageTableIndex = (zLONG) ((zULONG) lpDataHeader->lNextDataHandle >> 24);

	mov	ecx, DWORD PTR _lpDataHeader$16[ebp]
	mov	edx, DWORD PTR [ecx+34]
	shr	edx, 24					; 00000018H
	mov	DWORD PTR _lPageTableIndex$14[ebp], edx
$LN31@ProcessZei:

; 2671 : 
; 2672 : #ifdef SHARED_MEM_TRACE
; 2673 :                      fnTraceSharedMemory( "TASKREQ_FREEALL: freeing memory owned by other tasks." );
; 2674 : #endif
; 2675 : 
; 2676 :                   // if ( lPageTableIndex == 134 )
; 2677 :                   // {
; 2678 :                   //    TraceLine( "UnmapViewOfFile1 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 2679 :                   //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2680 :                   // }
; 2681 : 
; 2682 :                      UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$14[ebp]
	mov	ecx, DWORD PTR _g_ZeidonPageTable[eax*4]
	push	ecx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2683 :                      CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$14[ebp]
	mov	eax, DWORD PTR _g_FileMappingHandles[edx*4]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 2684 :                      g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$14[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], 0

; 2685 :                      g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$14[ebp]
	mov	DWORD PTR _g_FileMappingHandles[edx*4], 0
$LN29@ProcessZei:

; 2686 :                   }
; 2687 : 
; 2688 :                   lpDataHeader = zGETPTR( lpDataHeader->hPrevDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$16[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$16[ebp], eax

; 2689 :                   if ( lpDataHeader == 0 )

	cmp	DWORD PTR _lpDataHeader$16[ebp], 0
	jne	SHORT $LN32@ProcessZei

; 2690 :                      break;

	jmp	SHORT $LN28@ProcessZei
$LN32@ProcessZei:

; 2691 :                }

	jmp	$LN11@ProcessZei
$LN28@ProcessZei:

; 2692 :             }
; 2693 : 
; 2694 :             if ( lpSearchTask->hFirstDataHandle )

	mov	edx, DWORD PTR _lpSearchTask$15[ebp]
	cmp	DWORD PTR [edx+52], 0
	je	SHORT $LN33@ProcessZei

; 2695 :             {
; 2696 :                zLONG lPageTableIndex;
; 2697 : 
; 2698 :                if ( g_bWin95 )

	movzx	eax, BYTE PTR _g_bWin95
	test	eax, eax
	je	SHORT $LN34@ProcessZei

; 2699 :                   lPageTableIndex = (zLONG) *((zPLONG) lpSearchTask->hFirstDataHandle - 1);

	mov	ecx, DWORD PTR _lpSearchTask$15[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [edx-4]
	mov	DWORD PTR _lPageTableIndex$13[ebp], eax
	jmp	SHORT $LN35@ProcessZei
$LN34@ProcessZei:

; 2700 :                else
; 2701 :                   lPageTableIndex = (zLONG) ((zULONG) lpSearchTask->hFirstDataHandle >> 24);

	mov	ecx, DWORD PTR _lpSearchTask$15[ebp]
	mov	edx, DWORD PTR [ecx+52]
	shr	edx, 24					; 00000018H
	mov	DWORD PTR _lPageTableIndex$13[ebp], edx
$LN35@ProcessZei:

; 2702 : 
; 2703 : #ifdef SHARED_MEM_TRACE
; 2704 :                fnTraceSharedMemory( "TASKREQ_FREEALL: Freeing last page table." );
; 2705 : #endif
; 2706 : 
; 2707 :             // if ( lPageTableIndex == 134 )
; 2708 :             // {
; 2709 :             //    TraceLine( "UnmapViewOfFile2 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 2710 :             //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2711 :             // }
; 2712 : 
; 2713 :                UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	eax, DWORD PTR _lPageTableIndex$13[ebp]
	mov	ecx, DWORD PTR _g_ZeidonPageTable[eax*4]
	push	ecx
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2714 :                CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$13[ebp]
	mov	eax, DWORD PTR _g_FileMappingHandles[edx*4]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 2715 :                g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$13[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[ecx*4], 0

; 2716 :                g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	edx, DWORD PTR _lPageTableIndex$13[ebp]
	mov	DWORD PTR _g_FileMappingHandles[edx*4], 0
$LN33@ProcessZei:

; 2717 :             }
; 2718 :          }

	jmp	$LN6@ProcessZei
$LN7@ProcessZei:

; 2719 : 
; 2720 :          fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 2721 :          break;

	jmp	$LN2@ProcessZei
$LN36@ProcessZei:

; 2722 : 
; 2723 :       } // TASKREQ_FREEALL
; 2724 : 
; 2725 :       case TASKREQ_FREE:
; 2726 :       {
; 2727 :          // Free a particular chunk of memory.
; 2728 : 
; 2729 :          zLONG lPageTableIndex = lpRequestProcess->lPageTableIndex;

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _lPageTableIndex$11[ebp], ecx

; 2730 : 
; 2731 : #ifdef SHARED_MEM_TRACE
; 2732 :          fnTraceSharedMemory( "TASKREQ_FREE:  Freeing a current page." );
; 2733 :          TraceLine( "TASKREQ_FREE Page Table UNmapping at Index: %x   0x%08x   Process: %d",
; 2734 :                     lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2735 : #endif
; 2736 : 
; 2737 :       // if ( lPageTableIndex == 134 )
; 2738 :       // {
; 2739 :       //    TraceLine( "UnmapViewOfFile3 Page Table at Index: %x   0x%08x   Process: 0x%08x",
; 2740 :       //               lPageTableIndex, g_ZeidonPageTable[ lPageTableIndex ], SysGetProcessID( 0 ) );
; 2741 :       // }
; 2742 : 
; 2743 :          UnmapViewOfFile( g_ZeidonPageTable[ lPageTableIndex ] );

	mov	edx, DWORD PTR _lPageTableIndex$11[ebp]
	mov	eax, DWORD PTR _g_ZeidonPageTable[edx*4]
	push	eax
	call	DWORD PTR __imp__UnmapViewOfFile@4

; 2744 :          CloseHandle( (HANDLE) g_FileMappingHandles[ lPageTableIndex ] );

	mov	ecx, DWORD PTR _lPageTableIndex$11[ebp]
	mov	edx, DWORD PTR _g_FileMappingHandles[ecx*4]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 2745 :          g_ZeidonPageTable[ lPageTableIndex ] = 0;

	mov	eax, DWORD PTR _lPageTableIndex$11[ebp]
	mov	DWORD PTR _g_ZeidonPageTable[eax*4], 0

; 2746 :          g_FileMappingHandles[ lPageTableIndex ] = 0;

	mov	ecx, DWORD PTR _lPageTableIndex$11[ebp]
	mov	DWORD PTR _g_FileMappingHandles[ecx*4], 0

; 2747 :          break;

	jmp	$LN2@ProcessZei
$LN37@ProcessZei:

; 2748 :       }
; 2749 : 
; 2750 :       case TASKREQ_FREELIB:
; 2751 :       {
; 2752 :          LPLIBRARY lpLibrary = zGETPTR( lpRequestProcess->hMemHandle );

	mov	edx, DWORD PTR _lpRequestProcess$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$1[ebp], eax

; 2753 :       // TraceLineS( "(sy) TASKREQ_FREELIB: freeing library ",
; 2754 :       //             lpLibrary->szName );
; 2755 :       // fnTraceLibrary( lpLibrary, 0 );
; 2756 :          FreeLibrary( (HMODULE) lpLibrary->hLibrary );

	mov	ecx, DWORD PTR _lpLibrary$1[ebp]
	mov	edx, DWORD PTR [ecx+263]
	push	edx
	call	DWORD PTR __imp__FreeLibrary@4

; 2757 :          break;

	jmp	$LN2@ProcessZei
$LN38@ProcessZei:

; 2758 :       }
; 2759 : 
; 2760 :       case TASKREQ_FREEMUTEX:
; 2761 :       {
; 2762 :          LPMUTEX lpMutex = zGETPTR( lpRequestProcess->hMemHandle );

	mov	eax, DWORD PTR _lpRequestProcess$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$4[ebp], eax

; 2763 :          if ( CloseHandle( (HANDLE) lpMutex->Info.hMutexOS ) == 0 )

	mov	edx, DWORD PTR _lpMutex$4[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4
	test	eax, eax
	jne	SHORT $LN39@ProcessZei

; 2764 :          {
; 2765 :             char szMsg[ 100 ];
; 2766 : 
; 2767 :             zsprintf( szMsg, "Error destroying mutex: %s", lpMutex->szName );

	mov	ecx, DWORD PTR _lpMutex$4[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET $SG98709
	lea	edx, DWORD PTR _szMsg$17[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 2768 :             TraceLineS( szMsg, "" );

	push	OFFSET $SG98710
	lea	eax, DWORD PTR _szMsg$17[ebp]
	push	eax
	call	_TraceLineS@8

; 2769 :             fnSysMessageBox( lpTask, szlOE_SystemError, szMsg, 1 );

	push	1
	lea	ecx, DWORD PTR _szMsg$17[ebp]
	push	ecx
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16
$LN39@ProcessZei:

; 2770 :          }
; 2771 : 
; 2772 :          break;

	jmp	SHORT $LN2@ProcessZei
$LN40@ProcessZei:

; 2773 :       }
; 2774 : 
; 2775 :       default:
; 2776 :       {
; 2777 :          SysMessageBox( (zVIEW) wParam, "Zeidon Object Engine", "Unknown message", -1 );

	push	-1
	push	OFFSET $SG98712
	push	OFFSET $SG98713
	mov	ecx, DWORD PTR _wParam$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 2778 :          return( zCALL_ERROR ); // Failure

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@ProcessZei
$LN2@ProcessZei:

; 2779 :       }
; 2780 :    }
; 2781 : 
; 2782 :    return( 0 );  // ok ... get out

	xor	eax, eax
$LN1@ProcessZei:

; 2783 : 
; 2784 : } // end of:  ProcessZeidonMessage

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN42@ProcessZei:
	DD	$LN20@ProcessZei
	DD	$LN18@ProcessZei
	DD	$LN40@ProcessZei
	DD	$LN36@ProcessZei
	DD	$LN25@ProcessZei
	DD	$LN37@ProcessZei
	DD	$LN38@ProcessZei
_ProcessZeidonMessage@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpFirstSubtask$1 = -816				; size = 4
_hWndMain$ = -812					; size = 4
_lProcessID$ = -808					; size = 4
_lThreadID$ = -804					; size = 4
$T2 = -800						; size = 4
_hMutex$ = -796						; size = 4
_lpApp$ = -792						; size = 4
_k$ = -788						; size = 2
_nRC$ = -784						; size = 2
_chWebTrace$3 = -777					; size = 1
_lpTask$ = -776						; size = 4
_szCommand$ = -772					; size = 256
_szUserID$ = -516					; size = 64
_szPassword$ = -452					; size = 64
_szTaskTitle$ = -388					; size = 256
_szAppName$ = -132					; size = 64
_szDialog$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_pvSubtask$ = 8						; size = 4
_lSystemInstance$ = 12					; size = 4
_lMainWnd$ = 16						; size = 4
_lMsg$ = 20						; size = 4
_cpcAppString$ = 24					; size = 4
_cpcControlData$ = 28					; size = 4
_lControl$ = 32						; size = 4
_RegisterZeidonApplication@28 PROC

; 922  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 816				; 00000330H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 923  :    char   szTaskTitle[ 256 ];
; 924  :    char   szAppName[ 64 ];
; 925  :    char   szUserID[ 64 ];
; 926  :    char   szDialog[ 64 ];
; 927  :    char   szPassword[ 64 ];
; 928  :    char   szCommand[ 256 ];
; 929  :    LPAPP  lpApp;
; 930  :    LPTASK lpTask;
; 931  :    HWND   hWndMain = (HWND) lMainWnd;

	mov	eax, DWORD PTR _lMainWnd$[ebp]
	mov	DWORD PTR _hWndMain$[ebp], eax

; 932  :    HANDLE hMutex;
; 933  :    zLONG  lProcessID = 0;

	mov	DWORD PTR _lProcessID$[ebp], 0

; 934  :    zLONG  lThreadID = 0;

	mov	DWORD PTR _lThreadID$[ebp], 0

; 935  :    zSHORT k;
; 936  :    zSHORT nRC;
; 937  : 
; 938  :    SysDescribeZeidonPageTable( szTaskTitle );

	lea	ecx, DWORD PTR _szTaskTitle$[ebp]
	push	ecx
	call	_SysDescribeZeidonPageTable@4

; 939  : // SysMalloc( -2 );  // initialize memory usage (debug)
; 940  : 
; 941  :    // Check to see if the "termination" mutex is defined.  If it is then
; 942  :    // KZOENGWA.EXE is in the process of shutting down so fail the request.
; 943  :    if ( (hMutex = OpenMutex( MUTEX_ALL_ACCESS,
; 944  :                              FALSE, "KZOENGWA - Termination" )) != 0 )

	push	OFFSET $SG98226
	push	0
	push	2031617					; 001f0001H
	call	DWORD PTR __imp__OpenMutexA@12
	mov	DWORD PTR _hMutex$[ebp], eax
	cmp	DWORD PTR _hMutex$[ebp], 0
	je	SHORT $LN2@RegisterZe

; 945  :    {
; 946  :       // Close all the mutexes and get out.
; 947  :       CloseHandle( hMutex );

	mov	edx, DWORD PTR _hMutex$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 948  : 
; 949  :       MessageBox( GetActiveWindow( ),

	push	8208					; 00002010H
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	OFFSET $SG98227
	call	DWORD PTR __imp__GetActiveWindow@0
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 950  :                   "The Zeidon Object Engine hasn't finished shutting down. "
; 951  :                   "Please wait for the engine to shut down and restart.",
; 952  :                   szlOE_SystemError, MB_ICONSTOP | MB_OK | MB_TASKMODAL );
; 953  : 
; 954  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN23@RegisterZe
$LN2@RegisterZe:

; 955  :    }
; 956  : 
; 957  :    // Parse the Application string passed in from the client
; 958  :    fnParseAppString( szAppName, szDialog,

	mov	ecx, DWORD PTR _cpcAppString$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szCommand$[ebp]
	push	edx
	lea	eax, DWORD PTR _szPassword$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szUserID$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDialog$[ebp]
	push	edx
	lea	eax, DWORD PTR _szAppName$[ebp]
	push	eax
	call	_fnParseAppString
	add	esp, 24					; 00000018H

; 959  :                      szUserID,  szPassword,
; 960  :                      szCommand, cpcAppString );
; 961  : 
; 962  :    if ( szDialog[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szDialog$[ebp+edx]
	test	eax, eax
	je	SHORT $LN3@RegisterZe

; 963  :       zstrcpy( szTaskTitle, szDialog );

	lea	ecx, DWORD PTR _szDialog$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szTaskTitle$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN4@RegisterZe
$LN3@RegisterZe:

; 964  :    else
; 965  :       szTaskTitle[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 256			; 00000100H
	jae	SHORT $LN24@RegisterZe
	jmp	SHORT $LN25@RegisterZe
$LN24@RegisterZe:
	call	___report_rangecheckfailure
$LN25@RegisterZe:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szTaskTitle$[ebp+edx], 0
$LN4@RegisterZe:

; 966  : 
; 967  :    zLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysLockCoreMutex@4

; 968  : 
; 969  :    // See if we can initialize OE.
; 970  :    k = SysStartObjectServices( lMsg, lMainWnd );

	mov	eax, DWORD PTR _lMainWnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lMsg$[ebp]
	push	ecx
	call	_SysStartObjectServices
	add	esp, 8
	mov	WORD PTR _k$[ebp], ax

; 971  :    if ( k )

	movsx	edx, WORD PTR _k$[ebp]
	test	edx, edx
	je	SHORT $LN5@RegisterZe

; 972  :    {
; 973  :       zUNLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysUnlockCoreMutex@4

; 974  :       return( k );  // return if start not successful

	mov	ax, WORD PTR _k$[ebp]
	jmp	$LN23@RegisterZe
$LN5@RegisterZe:

; 975  :    }
; 976  : 
; 977  : #ifdef ALLOC_FREE_TRACE
; 978  :    AnchorBlock->bTraceMem = (zBOOL) SysSendOE_Message( IDM_GETMEMORYTRACE, 0 );
; 979  : #endif
; 980  : 
; 981  :    nRC = zCALL_ERROR;   // Default nRC to bad (zCALL_ERROR)

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 982  :    if ( (lpTask = fnCreateTask( lSystemInstance, (zLONG) hWndMain,
; 983  :                                 lMsg, szTaskTitle )) != 0 )

	lea	ecx, DWORD PTR _szTaskTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lMsg$[ebp]
	push	edx
	mov	eax, DWORD PTR _hWndMain$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lSystemInstance$[ebp]
	push	ecx
	call	_fnCreateTask
	add	esp, 16					; 00000010H
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN6@RegisterZe

; 984  :    {
; 985  :       // Current process has performed RegisterZeidonApp( ) so ...
; 986  :       g_bProcessRegistered = TRUE;

	mov	BYTE PTR _g_bProcessRegistered, 1

; 987  :    // g_lpCurrentTask = lpTask;
; 988  : 
; 989  :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 990  : 
; 991  :       lpApp = fnCreateApp( lpTask, szAppName );

	lea	edx, DWORD PTR _szAppName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnCreateApp
	add	esp, 8
	mov	DWORD PTR _lpApp$[ebp], eax

; 992  :       if ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	$LN7@RegisterZe

; 993  :       {
; 994  :          LPSUBTASK lpFirstSubtask = zGETPTR( lpTask->hFirstSubtask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSubtask$1[ebp], eax

; 995  : 
; 996  :          // Now point the application task to the application.
; 997  :          lpTask->hApp = zGETHNDL( lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 998  :          lpFirstSubtask->hApp = lpTask->hApp;

	mov	edx, DWORD PTR _lpFirstSubtask$1[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR [edx+10], ecx

; 999  : 
; 1000 :          if ( szDialog && szDialog[ 0 ] )

	lea	edx, DWORD PTR _szDialog$[ebp]
	test	edx, edx
	je	SHORT $LN9@RegisterZe
	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szDialog$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN9@RegisterZe

; 1001 :             zstrcpy( lpTask->szDialog, szDialog );

	lea	eax, DWORD PTR _szDialog$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 278				; 00000116H
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN10@RegisterZe
$LN9@RegisterZe:

; 1002 :          else
; 1003 :             zstrcpy( lpTask->szDialog, lpApp->szDefaultDialog );

	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 39					; 00000027H
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	add	eax, 278				; 00000116H
	push	eax
	call	_strcpy
	add	esp, 8
$LN10@RegisterZe:

; 1004 : 
; 1005 :          if ( szCommand[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szCommand$[ebp+edx]
	test	eax, eax
	je	SHORT $LN11@RegisterZe

; 1006 :          {
; 1007 :             lpTask->hCommand =

	lea	ecx, DWORD PTR _szCommand$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+142], eax

; 1008 :                fnStoreStringInDataspace( (LPDATAHEADER) g_hAnchorBlock,
; 1009 :                                          szCommand );
; 1010 :          }

	jmp	SHORT $LN12@RegisterZe
$LN11@RegisterZe:

; 1011 :          else
; 1012 :             lpTask->hCommand = 0;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+142], 0
$LN12@RegisterZe:

; 1013 : 
; 1014 :          // Task is now ready to go.
; 1015 : 
; 1016 :          if ( lControl & 0x00000001 )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1
	je	$LN13@RegisterZe

; 1017 :          {
; 1018 :             zCHAR  chWebTrace;
; 1019 : 
; 1020 :             lpTask->bTransientTask = TRUE;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 1021 :             lProcessID = SysGetProcessID( &lThreadID );

	lea	ecx, DWORD PTR _lThreadID$[ebp]
	push	ecx
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 1022 : 
; 1023 :             TraceLineS( "InitCriticalSection: " , cpcControlData );

	mov	edx, DWORD PTR _cpcControlData$[ebp]
	push	edx
	push	OFFSET $SG98239
	call	_TraceLineS@8

; 1024 : 
; 1025 :             lpTask->pcsCriticalSection = calloc( sizeof( CRITICAL_SECTION ), 1 );

	push	1
	push	24					; 00000018H
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+439], eax

; 1026 :             InitializeCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+439]
	push	eax
	call	DWORD PTR __imp__InitializeCriticalSection@4

; 1027 :             EnterCriticalSection( (LPCRITICAL_SECTION) lpTask->pcsCriticalSection );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+439]
	push	edx
	call	DWORD PTR __imp__EnterCriticalSection@4

; 1028 :             chWebTrace = (zCHAR) SysSendOE_Message( IDM_GETWEBTRACE, 0 );

	push	0
	push	214					; 000000d6H
	call	_SysSendOE_Message@8
	mov	BYTE PTR _chWebTrace$3[ebp], al

; 1029 :             if ( chWebTrace == 'Y' || chWebTrace == 'y' )

	movsx	eax, BYTE PTR _chWebTrace$3[ebp]
	cmp	eax, 89					; 00000059H
	je	SHORT $LN15@RegisterZe
	movsx	ecx, BYTE PTR _chWebTrace$3[ebp]
	cmp	ecx, 121				; 00000079H
	jne	SHORT $LN13@RegisterZe
$LN15@RegisterZe:

; 1030 :                lpTask->bWebTrace = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 4096				; 00001000H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax
$LN13@RegisterZe:

; 1031 :          }
; 1032 : 
; 1033 :          lpTask->bDisable = FALSE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 1034 : 
; 1035 :          ActivateViewObject( zGETPTR( lpTask->hFirstView ), szlMessageObject, 0 );

	push	0
	mov	edx, DWORD PTR _szlMessageObject
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_ActivateViewObject@12

; 1036 :          *pvSubtask = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _pvSubtask$[ebp]
	mov	DWORD PTR [ecx], eax

; 1037 : 
; 1038 :          if ( lControl & 0x00000001 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1
	je	SHORT $LN16@RegisterZe

; 1039 :          {
; 1040 :             if ( cpcControlData && zstrlen( cpcControlData ) < sizeof( lpTask->szSessionId ) )

	cmp	DWORD PTR _cpcControlData$[ebp], 0
	je	SHORT $LN17@RegisterZe
	mov	eax, DWORD PTR _cpcControlData$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	eax, 50					; 00000032H
	jae	SHORT $LN17@RegisterZe

; 1041 :             {
; 1042 :                zstrcpy( lpTask->szTaskTitle, cpcControlData );

	mov	ecx, DWORD PTR _cpcControlData$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 311				; 00000137H
	push	edx
	call	_strcpy
	add	esp, 8

; 1043 :                zstrcpy( lpTask->szSessionId, cpcControlData );

	mov	eax, DWORD PTR _cpcControlData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 194				; 000000c2H
	push	ecx
	call	_strcpy
	add	esp, 8
$LN17@RegisterZe:

; 1044 :             }
; 1045 : 
; 1046 :             lpTask->vWebSubtask = *pvSubtask;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _pvSubtask$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx+28], ecx

; 1047 :             SysGetDateTime( lpTask->szTimeStamp );

	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 174				; 000000aeH
	push	edx
	call	_SysGetDateTime@4
$LN16@RegisterZe:

; 1048 :          }
; 1049 : 
; 1050 :          SetViewFlags( *pvSubtask, zVF_MESSAGEONDROP );

	push	1
	mov	eax, DWORD PTR _pvSubtask$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetViewFlags@8

; 1051 : 
; 1052 :       // {
; 1053 :       //    zPVOID p = zGETHNDL( lpTask );
; 1054 :       //
; 1055 :       //    TraceLine( "RegisterZeidonApplication for Task: 0x%08x (%d)", p, p );
; 1056 :       // }
; 1057 : 
; 1058 :          nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 1059 :       }

	jmp	SHORT $LN8@RegisterZe
$LN7@RegisterZe:

; 1060 :       else
; 1061 :       {
; 1062 :          DeleteTask( lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_DeleteTask@4

; 1063 : 
; 1064 :          // Current process has performed RegisterZeidonApp( ) so ...
; 1065 :          g_bProcessRegistered = FALSE;

	mov	BYTE PTR _g_bProcessRegistered, 0
$LN8@RegisterZe:

; 1066 :       // g_lpCurrentTask = 0;
; 1067 :       }
; 1068 : 
; 1069 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN6@RegisterZe:

; 1070 :    }
; 1071 : 
; 1072 :    // Check nRC and do a task release on anchor block if init failed.
; 1073 :    if ( nRC )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@RegisterZe

; 1074 :    {
; 1075 :       if ( g_hAnchorBlock )

	cmp	DWORD PTR _g_hAnchorBlock, 0
	je	SHORT $LN20@RegisterZe

; 1076 :          fnFreeSharedMemory( 0, g_hAnchorBlock );

	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	push	0
	call	_fnFreeSharedMemory@8
$LN20@RegisterZe:

; 1077 :    }

	jmp	SHORT $LN19@RegisterZe
$LN18@RegisterZe:

; 1078 :    else
; 1079 : // if ( nRC == 0 )
; 1080 :       SfStartNetworks( *pvSubtask, 0 );

	push	0
	mov	eax, DWORD PTR _pvSubtask$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SfStartNetworks@8
$LN19@RegisterZe:

; 1081 : 
; 1082 :    if ( lControl & 0x00000001 )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1
	je	SHORT $LN21@RegisterZe

; 1083 :    {
; 1084 :       if ( lpTask->bWebTrace )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	je	SHORT $LN21@RegisterZe

; 1085 :       {
; 1086 :          TraceLine( "RegisterZeidonApplication ===============> %s   V/Task: 0x%08x / 0x%08x  Process: %d   Thread: %d",

	mov	edx, DWORD PTR _lThreadID$[ebp]
	push	edx
	mov	eax, DWORD PTR _lProcessID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvSubtask$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _pvSubtask$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _cpcAppString$[ebp]
	push	eax
	push	OFFSET $SG98249
	call	_TraceLine
	add	esp, 24					; 00000018H
$LN21@RegisterZe:

; 1087 :                     cpcAppString, *pvSubtask, (*pvSubtask)->hTask, lProcessID, lThreadID );
; 1088 :       }
; 1089 :    }
; 1090 : 
; 1091 :    zUNLOCK_MUTEX( zMUTEX_INITTERM );

	push	0
	call	_fnSysUnlockCoreMutex@4

; 1092 : 
; 1093 :    TraceLine( "RegisterZeidonApplication ===============> %s   Process: %d   Thread: %d   Memory: %s   Wnd: 0x%08x=%d",

	mov	ecx, DWORD PTR _lMainWnd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lMainWnd$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTaskTitle$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCurrentThreadId@0
	push	eax
	call	DWORD PTR __imp__GetCurrentProcessId@0
	push	eax
	mov	ecx, DWORD PTR _cpcAppString$[ebp]
	push	ecx
	push	OFFSET $SG98250
	call	_TraceLine
	add	esp, 28					; 0000001cH

; 1094 :                cpcAppString, GetCurrentProcessId( ), GetCurrentThreadId( ), szTaskTitle, lMainWnd, lMainWnd );
; 1095 : 
; 1096 :    return( nRC );  // return the result

	mov	ax, WORD PTR _nRC$[ebp]
$LN23@RegisterZe:

; 1097 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_RegisterZeidonApplication@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
tv85 = -1024						; size = 4
_dwRC$ = -1020						; size = 4
_lpTask$ = -1016					; size = 4
_lpMutex$ = -1012					; size = 4
_k$ = -1008						; size = 2
_szMsg$ = -1004						; size = 1000
__$ArrayPad$ = -4					; size = 4
_SysMutexQueryStatus@0 PROC

; 9267 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1024				; 00000400H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 9268 :    zCHAR   szMsg[ 1000 ];
; 9269 :    LPMUTEX lpMutex;
; 9270 :    LPTASK  lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 9271 :    DWORD   dwRC;
; 9272 :    zSHORT  k;
; 9273 : 
; 9274 :    TraceLineS( " ---- MUTEX LIST ---- ", "" );

	push	OFFSET $SG100770
	push	OFFSET $SG100771
	call	_TraceLineS@8

; 9275 : 
; 9276 :    for ( k = 0; k < zMUTEX_COUNT; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@SysMutexQu
$LN2@SysMutexQu:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@SysMutexQu:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 16					; 00000010H
	jge	$LN3@SysMutexQu

; 9277 :    {
; 9278 :       TraceLine( "MutexQueryStatus %s -- Checking ...", g_ZeidonMutexName[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexName[edx*4]
	push	eax
	push	OFFSET $SG100772
	call	_TraceLine
	add	esp, 8

; 9279 :       dwRC = WaitForSingleObject( g_ZeidonMutexTable[ k ], 2000 );

	push	2000					; 000007d0H
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexTable[ecx*4]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	DWORD PTR _dwRC$[ebp], eax

; 9280 :       if ( dwRC == WAIT_FAILED )

	cmp	DWORD PTR _dwRC$[ebp], -1
	jne	SHORT $LN16@SysMutexQu

; 9281 :       {
; 9282 :          switch ( GetLastError( ) )

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR tv85[ebp], eax
	cmp	DWORD PTR tv85[ebp], 128		; 00000080H
	je	SHORT $LN18@SysMutexQu
	cmp	DWORD PTR tv85[ebp], 258		; 00000102H
	je	SHORT $LN19@SysMutexQu
	jmp	SHORT $LN20@SysMutexQu
$LN18@SysMutexQu:

; 9283 :          {
; 9284 :             case WAIT_ABANDONED:
; 9285 :                // This means that another thread terminated without unlocking
; 9286 :                // its mutex.  We'll consider this OK.
; 9287 :                dwRC = 0;

	mov	DWORD PTR _dwRC$[ebp], 0

; 9288 :                break;

	jmp	SHORT $LN5@SysMutexQu
$LN19@SysMutexQu:

; 9289 : 
; 9290 :             case WAIT_TIMEOUT:
; 9291 :                dwRC = 1;

	mov	DWORD PTR _dwRC$[ebp], 1

; 9292 :                break;

	jmp	SHORT $LN5@SysMutexQu
$LN20@SysMutexQu:

; 9293 : 
; 9294 :             default:
; 9295 :                dwRC = 2;

	mov	DWORD PTR _dwRC$[ebp], 2
$LN5@SysMutexQu:

; 9296 :                break;
; 9297 :          }
; 9298 :       }

	jmp	SHORT $LN17@SysMutexQu
$LN16@SysMutexQu:

; 9299 :       else
; 9300 :          dwRC = 0;

	mov	DWORD PTR _dwRC$[ebp], 0
$LN17@SysMutexQu:

; 9301 : 
; 9302 :       if ( dwRC )

	cmp	DWORD PTR _dwRC$[ebp], 0
	je	SHORT $LN21@SysMutexQu

; 9303 :       {
; 9304 :          TraceLine( "MutexQueryStatus %s -- FAILED (%d)", g_ZeidonMutexName[ k ], dwRC );

	mov	eax, DWORD PTR _dwRC$[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_ZeidonMutexName[ecx*4]
	push	edx
	push	OFFSET $SG100780
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 9305 :       }

	jmp	SHORT $LN22@SysMutexQu
$LN21@SysMutexQu:

; 9306 :       else
; 9307 :       {
; 9308 :          ReleaseMutex( g_ZeidonMutexTable[ k ] );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _g_ZeidonMutexTable[eax*4]
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4

; 9309 :          TraceLine( "MutexQueryStatus %s -- OK", g_ZeidonMutexName[ k ] );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _g_ZeidonMutexName[edx*4]
	push	eax
	push	OFFSET $SG100781
	call	_TraceLine
	add	esp, 8
$LN22@SysMutexQu:

; 9310 :       }
; 9311 :    }

	jmp	$LN2@SysMutexQu
$LN3@SysMutexQu:

; 9312 : 
; 9313 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN23@SysMutexQu

; 9314 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysMutexQu
$LN23@SysMutexQu:

; 9315 : 
; 9316 :    // Set lock to make sure nobody's changing the mutex chains.
; 9317 :    zLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysLockCoreMutex@4

; 9318 : 
; 9319 :    for ( lpMutex = zGETPTR( AnchorBlock->hFirstSysMutex );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2519]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
	jmp	SHORT $LN9@SysMutexQu
$LN7@SysMutexQu:

; 9321 :          lpMutex = zGETPTR( lpMutex->hNextMutex ) )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
$LN9@SysMutexQu:

; 9320 :          lpMutex;

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $LN8@SysMutexQu

; 9322 :    {
; 9323 :       if ( lpMutex->lLockedTaskID )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	cmp	DWORD PTR [edx+81], 0
	je	SHORT $LN24@SysMutexQu

; 9324 :       {
; 9325 :          zsprintf( szMsg, "Mutex '%s' locked by Task: %d  ProcessID: %d",

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+89]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+81]
	push	eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	push	OFFSET $SG100785
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 20					; 00000014H

; 9326 :                    lpMutex->szName, lpMutex->lLockedTaskID, lpMutex->lProcessID );
; 9327 :       }

	jmp	SHORT $LN25@SysMutexQu
$LN24@SysMutexQu:

; 9328 :       else
; 9329 :       {
; 9330 :          zsprintf( szMsg, "Mutex '%s' is unlocked   ProcessID: %d",

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+89]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	add	edx, 6
	push	edx
	push	OFFSET $SG100786
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN25@SysMutexQu:

; 9331 :                    lpMutex->szName, lpMutex->lProcessID );
; 9332 :       }
; 9333 : 
; 9334 :       TraceLineS( szMsg, "" );

	push	OFFSET $SG100787
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_TraceLineS@8

; 9335 :    }

	jmp	$LN7@SysMutexQu
$LN8@SysMutexQu:

; 9336 : 
; 9337 :    fnStartBrowseOfTaskList( zGETHNDL( lpTask ), FALSE );

	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 9338 : 
; 9339 :    for ( lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN12@SysMutexQu
$LN10@SysMutexQu:

; 9341 :          lpTask = zGETPTR( lpTask->hNextTask ) )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN12@SysMutexQu:

; 9340 :          lpTask;

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN11@SysMutexQu

; 9342 :    {
; 9343 :       for ( lpMutex = zGETPTR( lpTask->hFirstMutex );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+150]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
	jmp	SHORT $LN15@SysMutexQu
$LN13@SysMutexQu:

; 9345 :             lpMutex = zGETPTR( lpMutex->hNextMutex ) )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
$LN15@SysMutexQu:

; 9344 :             lpMutex;

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $LN14@SysMutexQu

; 9346 :       {
; 9347 :          // We only care about tasks waiting for a mutex.
; 9348 :          if ( lpMutex->bWaiting == FALSE )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+85]
	and	eax, 1
	jne	SHORT $LN26@SysMutexQu

; 9349 :             continue;

	jmp	SHORT $LN13@SysMutexQu
$LN26@SysMutexQu:

; 9350 : 
; 9351 :          zsprintf( szMsg, "Task 0x%08x (process id:%d) is waiting on mutex '%s'   Lock Count: %d",

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	add	ecx, 6
	push	ecx
	call	_SysMutexQueryLock@4
	movsx	edx, ax
	push	edx
	mov	eax, DWORD PTR _lpMutex$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+89]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	OFFSET $SG100789
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H

; 9352 :                    lpTask, lpMutex->lProcessID, lpMutex->szName, SysMutexQueryLock( lpMutex->szName ) );
; 9353 :       }

	jmp	SHORT $LN13@SysMutexQu
$LN14@SysMutexQu:

; 9354 :    }

	jmp	$LN10@SysMutexQu
$LN11@SysMutexQu:

; 9355 : 
; 9356 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 9357 : 
; 9358 :    zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4

; 9359 : 
; 9360 :    return( 0 );

	xor	eax, eax
$LN1@SysMutexQu:

; 9361 : 
; 9362 : } // SysMutexQueryStatus

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SysMutexQueryStatus@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpMutex$ = -12						; size = 4
_lpTask$ = -8						; size = 4
_nLockCount$ = -4					; size = 2
_cpcMutexName$ = 8					; size = 4
_SysMutexQueryLock@4 PROC

; 9231 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 9232 :    LPMUTEX lpMutex;
; 9233 :    LPTASK  lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 9234 :    zSHORT  nLockCount = 0;

	xor	edx, edx
	mov	WORD PTR _nLockCount$[ebp], dx
$LN2@SysMutexQu:

; 9235 : 
; 9236 :    while ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN3@SysMutexQu

; 9237 :    {
; 9238 :       lpMutex = fnMutexFind( lpTask, cpcMutexName );

	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnMutexFind@8
	mov	DWORD PTR _lpMutex$[ebp], eax

; 9239 :       if ( lpMutex )

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $LN4@SysMutexQu

; 9240 :          nLockCount += lpMutex->nLockCount;

	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, WORD PTR [edx+75]
	movsx	ecx, WORD PTR _nLockCount$[ebp]
	add	ecx, eax
	mov	WORD PTR _nLockCount$[ebp], cx
$LN4@SysMutexQu:

; 9241 : 
; 9242 :       lpTask = zGETPTR( lpTask->hNextTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 9243 :    }

	jmp	SHORT $LN2@SysMutexQu
$LN3@SysMutexQu:

; 9244 : 
; 9245 :    return( nLockCount );

	mov	ax, WORD PTR _nLockCount$[ebp]

; 9246 : 
; 9247 : } // SysMutexQueryLock

	mov	esp, ebp
	pop	ebp
	ret	4
_SysMutexQueryLock@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpSysMutex$ = -16					; size = 4
_lpTask$ = -12						; size = 4
_lpMutex$ = -8						; size = 4
tv81 = -2						; size = 2
_lpTaskView$ = 8					; size = 4
_cpcMutexName$ = 12					; size = 4
_lControl$ = 16						; size = 4
_SysMutexUnlock@12 PROC

; 9099 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 9100 :    LPTASK  lpTask;
; 9101 :    LPMUTEX lpMutex;
; 9102 :    LPMUTEX lpSysMutex;
; 9103 : 
; 9104 :    if ( lpTaskView == 0 || (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysMutexUn
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@SysMutexUn
$LN3@SysMutexUn:

; 9105 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysMutexUn
$LN2@SysMutexUn:

; 9106 : 
; 9107 :    if ( (lpMutex = fnMutexFind( lpTask, cpcMutexName )) == 0 )

	mov	edx, DWORD PTR _cpcMutexName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnMutexFind@8
	mov	DWORD PTR _lpMutex$[ebp], eax
	cmp	DWORD PTR _lpMutex$[ebp], 0
	jne	SHORT $LN4@SysMutexUn

; 9108 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysMutexUn
$LN4@SysMutexUn:

; 9109 : 
; 9110 :    if ( lpMutex->nLockCount == 0 )

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	movsx	edx, WORD PTR [ecx+75]
	test	edx, edx
	jne	SHORT $LN5@SysMutexUn

; 9111 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@SysMutexUn
$LN5@SysMutexUn:

; 9112 : 
; 9113 :    if ( lpMutex->nLockCount > 1 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	movsx	ecx, WORD PTR [eax+75]
	cmp	ecx, 1
	jle	SHORT $LN6@SysMutexUn

; 9114 :       return( --lpMutex->nLockCount );  // pre-decrement intended

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	ax, WORD PTR [edx+75]
	sub	ax, 1
	mov	WORD PTR tv81[ebp], ax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	dx, WORD PTR tv81[ebp]
	mov	WORD PTR [ecx+75], dx
	mov	ax, WORD PTR tv81[ebp]
	jmp	SHORT $LN1@SysMutexUn
$LN6@SysMutexUn:

; 9115 : 
; 9116 :    // We'll reset the lLockedTaskID even though we haven't actually locked
; 9117 :    // it yet.  This protects us from having two tasks change the ID at the
; 9118 :    // same time.
; 9119 :    lpSysMutex = zGETPTR( lpMutex->hSysMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+77]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSysMutex$[ebp], eax

; 9120 :    lpSysMutex->lLockedTaskID = 0;

	mov	edx, DWORD PTR _lpSysMutex$[ebp]
	mov	DWORD PTR [edx+81], 0

; 9121 : 
; 9122 :    if ( fnSysMutexUnlock( lpTask, lpMutex ) != 0 )

	mov	eax, DWORD PTR _lpMutex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMutexUnlock@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN7@SysMutexUn

; 9123 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysMutexUn
$LN7@SysMutexUn:

; 9124 : 
; 9125 :    lpMutex->nLockCount = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [ecx+75], ax

; 9126 :    return( 0 );

	xor	eax, eax
$LN1@SysMutexUn:

; 9127 : 
; 9128 : } // SysMutexUnlock

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysMutexUnlock@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpSysMutex$1 = -20					; size = 4
_lpTask$ = -16						; size = 4
_lpMutex$ = -12						; size = 4
tv82 = -8						; size = 2
tv135 = -6						; size = 2
_nRC$ = -4						; size = 2
_lpTaskView$ = 8					; size = 4
_cpcMutexName$ = 12					; size = 4
_ulTimeout$ = 16					; size = 4
_lControl$ = 20						; size = 4
_SysMutexLock@16 PROC

; 9001 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 9002 :    LPTASK  lpTask;
; 9003 :    LPMUTEX lpMutex;
; 9004 :    zSHORT  nRC;
; 9005 : 
; 9006 :    if ( lpTaskView == 0 || (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysMutexLo
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@SysMutexLo
$LN3@SysMutexLo:

; 9007 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysMutexLo
$LN2@SysMutexLo:

; 9008 : 
; 9009 :    // If the mutex hasn't been created yet, try to create it.
; 9010 :    lpMutex = fnMutexCreate( lpTask, cpcMutexName, lControl, 0 );

	push	0
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnMutexCreate@16
	mov	DWORD PTR _lpMutex$[ebp], eax

; 9011 :    if ( lpMutex == 0 )

	cmp	DWORD PTR _lpMutex$[ebp], 0
	jne	SHORT $LN4@SysMutexLo

; 9012 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SysMutexLo
$LN4@SysMutexLo:

; 9013 : 
; 9014 :    // Check to see if the mutex is already locked for this task.
; 9015 :    if ( lpMutex->nLockCount )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, WORD PTR [edx+75]
	test	eax, eax
	je	SHORT $LN5@SysMutexLo

; 9016 :       return( lpMutex->nLockCount++ );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	dx, WORD PTR [ecx+75]
	mov	WORD PTR tv82[ebp], dx
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	cx, WORD PTR [eax+75]
	add	cx, 1
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [edx+75], cx
	mov	ax, WORD PTR tv82[ebp]
	jmp	$LN1@SysMutexLo
$LN5@SysMutexLo:

; 9017 : 
; 9018 :    lpMutex->bWaiting = TRUE;

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+85]
	or	ecx, 1
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [edx+85], ecx

; 9019 : 
; 9020 :    nRC = fnSysMutexLock( lpTask, lpMutex, ulTimeout, lControl );

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulTimeout$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMutexLock@16
	mov	WORD PTR _nRC$[ebp], ax

; 9021 : 
; 9022 :    lpMutex->bWaiting = FALSE;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	edx, DWORD PTR [ecx+85]
	and	edx, -2					; fffffffeH
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR [eax+85], edx

; 9023 : 
; 9024 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@SysMutexLo

; 9025 :    {
; 9026 :       LPMUTEX lpSysMutex = zGETPTR( lpMutex->hSysMutex );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+77]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSysMutex$1[ebp], eax

; 9027 : 
; 9028 :       lpSysMutex->lLockedTaskID = GetCurrentProcessId( );

	call	DWORD PTR __imp__GetCurrentProcessId@0
	mov	ecx, DWORD PTR _lpSysMutex$1[ebp]
	mov	DWORD PTR [ecx+81], eax

; 9029 :       return( ++lpMutex->nLockCount );  // pre-increment intended

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	ax, WORD PTR [edx+75]
	add	ax, 1
	mov	WORD PTR tv135[ebp], ax
	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	dx, WORD PTR tv135[ebp]
	mov	WORD PTR [ecx+75], dx
	mov	ax, WORD PTR tv135[ebp]
	jmp	SHORT $LN1@SysMutexLo

; 9030 :    }

	jmp	SHORT $LN1@SysMutexLo
$LN6@SysMutexLo:

; 9031 :    else
; 9032 :    {
; 9033 :       TraceLineS( "(tm) Error trying to lock mutex ", cpcMutexName );

	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	push	OFFSET $SG100671
	call	_TraceLineS@8

; 9034 :       SysMessageBox( lpTaskView, "Error", "Error locking mutex", 0 );

	push	0
	push	OFFSET $SG100672
	push	OFFSET $SG100673
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 9035 :       nRC /= nRC - nRC;

	movsx	ecx, WORD PTR _nRC$[ebp]
	movsx	edx, WORD PTR _nRC$[ebp]
	sub	ecx, edx
	movsx	eax, WORD PTR _nRC$[ebp]
	cdq
	idiv	ecx
	mov	WORD PTR _nRC$[ebp], ax

; 9036 : 
; 9037 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@SysMutexLo:

; 9038 :    }
; 9039 : 
; 9040 : } // SysMutexLock

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SysMutexLock@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_cpcMutexName$ = 12					; size = 4
_lControl$ = 16						; size = 4
_SysMutexCreate@12 PROC

; 8916 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8917 :    LPTASK  lpTask;
; 8918 : 
; 8919 :    if ( lpTaskView == 0 || (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN3@SysMutexCr
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@SysMutexCr
$LN3@SysMutexCr:

; 8920 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysMutexCr
$LN2@SysMutexCr:

; 8921 : 
; 8922 :    if ( fnMutexCreate( lpTask, cpcMutexName, lControl, FALSE ) == 0 )

	push	0
	mov	edx, DWORD PTR _lControl$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcMutexName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnMutexCreate@16
	test	eax, eax
	jne	SHORT $LN4@SysMutexCr

; 8923 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SysMutexCr
$LN4@SysMutexCr:

; 8924 : 
; 8925 :    return( 0 );

	xor	eax, eax
$LN1@SysMutexCr:

; 8926 : 
; 8927 : } // SysMutexCreate

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SysMutexCreate@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_hMutexOS$ = 8						; size = 4
_SysMutexClose@4 PROC

; 9132 : {

	push	ebp
	mov	ebp, esp

; 9133 :    return( CloseHandle( (HANDLE) hMutexOS ) );

	mov	eax, DWORD PTR _hMutexOS$[ebp]
	push	eax
	call	DWORD PTR __imp__CloseHandle@4

; 9134 : }

	pop	ebp
	ret	4
_SysMutexClose@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzoesyaa.c
_TEXT	SEGMENT
_nCnt$ = -12						; size = 2
_k$ = -8						; size = 2
_nLth$ = -4						; size = 2
_pchResults$ = 8					; size = 4
_SysDescribeZeidonPageTable@4 PROC

; 8161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 8162 :    zSHORT nLth;
; 8163 :    zSHORT nCnt;
; 8164 :    zSHORT k;
; 8165 : 
; 8166 :    pchResults[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchResults$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 8167 :    nLth = 0;

	xor	eax, eax
	mov	WORD PTR _nLth$[ebp], ax

; 8168 :    nCnt = 0;

	xor	ecx, ecx
	mov	WORD PTR _nCnt$[ebp], cx

; 8169 : 
; 8170 :    for ( k = 0; k < 256; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@SysDescrib
$LN2@SysDescrib:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@SysDescrib:
	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 256				; 00000100H
	jge	$LN3@SysDescrib

; 8171 :    {
; 8172 :       if ( g_ZeidonPageTable[ k ] == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	DWORD PTR _g_ZeidonPageTable[edx*4], 0
	jne	SHORT $LN5@SysDescrib

; 8173 :          continue;

	jmp	SHORT $LN2@SysDescrib
$LN5@SysDescrib:

; 8174 : 
; 8175 :       nCnt++;

	mov	ax, WORD PTR _nCnt$[ebp]
	add	ax, 1
	mov	WORD PTR _nCnt$[ebp], ax

; 8176 :       if ( nLth > 0 )

	movsx	ecx, WORD PTR _nLth$[ebp]
	test	ecx, ecx
	jle	SHORT $LN6@SysDescrib

; 8177 :       {
; 8178 :          pchResults[ nLth++ ] =  ',';

	movsx	edx, WORD PTR _nLth$[ebp]
	mov	eax, DWORD PTR _pchResults$[ebp]
	mov	BYTE PTR [eax+edx], 44			; 0000002cH
	mov	cx, WORD PTR _nLth$[ebp]
	add	cx, 1
	mov	WORD PTR _nLth$[ebp], cx

; 8179 :          pchResults[ nLth++ ] =  ' ';

	movsx	edx, WORD PTR _nLth$[ebp]
	mov	eax, DWORD PTR _pchResults$[ebp]
	mov	BYTE PTR [eax+edx], 32			; 00000020H
	mov	cx, WORD PTR _nLth$[ebp]
	add	cx, 1
	mov	WORD PTR _nLth$[ebp], cx
$LN6@SysDescrib:

; 8180 :       }
; 8181 : 
; 8182 :       zltox( k, pchResults + nLth );

	push	16					; 00000010H
	movsx	edx, WORD PTR _nLth$[ebp]
	add	edx, DWORD PTR _pchResults$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 8183 :       nLth += zstrlen( pchResults + nLth );

	movsx	ecx, WORD PTR _nLth$[ebp]
	add	ecx, DWORD PTR _pchResults$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	movsx	edx, WORD PTR _nLth$[ebp]
	add	edx, eax
	mov	WORD PTR _nLth$[ebp], dx

; 8184 :    }

	jmp	$LN2@SysDescrib
$LN3@SysDescrib:

; 8185 : 
; 8186 : // fnPrintMutexInfo( 'S', zMUTEX_COUNT, __FILE__, __LINE__ );
; 8187 :    return( nCnt );

	mov	ax, WORD PTR _nCnt$[ebp]

; 8188 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SysDescribeZeidonPageTable@4 ENDP
_TEXT	ENDS
END
