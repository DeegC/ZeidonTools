; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOETMAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG13533 DB	01H DUP (?)
$SG13605 DB	01H DUP (?)
$SG13699 DB	01H DUP (?)
$SG13720 DB	01H DUP (?)
$SG13725 DB	01H DUP (?)
$SG13833 DB	01H DUP (?)
$SG13836 DB	01H DUP (?)
$SG13839 DB	01H DUP (?)
$SG13842 DB	01H DUP (?)
$SG13845 DB	01H DUP (?)
$SG13848 DB	01H DUP (?)
$SG13849 DB	01H DUP (?)
$SG13861 DB	01H DUP (?)
$SG13964 DB	01H DUP (?)
$SG14269 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG13466 DB	'App Task 0x%08x', 00H
$SG13467 DB	'(tm) ', 00H
	ORG $+2
$SG13470 DB	'Main ', 00H
	ORG $+2
$SG13474 DB	' created', 00H
	ORG $+3
$SG13534 DB	'(tm) DeleteTask error dropping task domain', 00H
	ORG $+1
$SG13606 DB	'(tm) DeleteTask error dropping task operation', 00H
	ORG $+2
$SG13621 DB	'SfCloseTaskDatabases for Process: %d   Task: %d (0x%08x)'
	DB	00H
	ORG $+3
$SG13623 DB	'Zeidon DBH', 00H
	ORG $+1
$SG13624 DB	'Zeidon DBH', 00H
	ORG $+1
$SG13653 DB	'Zeidon DBH', 00H
	ORG $+1
$SG13657 DB	'Zeidon DBH', 00H
	ORG $+1
$SG13658 DB	'Zeidon GKH', 00H
	ORG $+1
$SG13662 DB	'Zeidon GKH', 00H
	ORG $+1
$SG13700 DB	'(tm) DeleteTask error closing file', 00H
	ORG $+1
$SG13721 DB	'(tm) DeleteTask error freeing library', 00H
	ORG $+2
$SG13723 DB	'Error freeing library', 00H
	ORG $+2
$SG13724 DB	'Zeidon Library Error', 00H
	ORG $+3
$SG13726 DB	'(tm) DeleteTask error freeing library', 00H
	ORG $+2
$SG13775 DB	'   ', 00H
$SG13834 DB	'CleanupTask unexpected Library', 00H
	ORG $+1
$SG13837 DB	'CleanupTask unexpected OpenFile', 00H
$SG13840 DB	'CleanupTask unexpected DBHandler', 00H
	ORG $+3
$SG13843 DB	'CleanupTask unexpected GKHandler', 00H
	ORG $+3
$SG13846 DB	'CleanupTask unexpected Domain', 00H
	ORG $+2
$SG13851 DB	'   Task: 0x%08x              Task: 0x%08x', 00H
	ORG $+2
$SG13850 DB	'After Cleanup ==================================>> Task:'
	DB	' 0x%08x   Task: 0x%08x', 00H
	ORG $+1
$SG13852 DB	'???', 00H
$SG13857 DB	'???', 00H
$SG13853 DB	'      Subtask: 0x%08x   Task: 0x%08x   App: 0x%08x (%s) '
	DB	'  Subtask View: 0x%08x', 00H
	ORG $+1
$SG13854 DB	'         ViewName: 0x%08x   View: 0x%08x   View Name %s', 00H
$SG13855 DB	'      ViewOI: 0x%08x   Task: 0x%08x   Alloc Task: 0x%08x'
	DB	'   ViewOD: 0x%08x  (%s)', 00H
$SG13856 DB	'         ViewName: 0x%08x   View: 0x%08x   View Name %s', 00H
$SG13858 DB	'         View: 0x%08x   Task: 0x%08x   ViewOD: 0x%08x (%'
	DB	's)  Name Cnt: %d', 00H
	ORG $+3
$SG13860 DB	'Keep Alive', 00H
	ORG $+1
$SG13859 DB	'      DataHeader: 0x%08x   Nbr: %d   Total Size: %d   Us'
	DB	'ed Size: %d   Max Free Blocksize: %d   Used Blocks: %d   Free'
	DB	' Blocks: %d', 00H
	ORG $+3
$SG13862 DB	'   App: 0x%08x (%s)   Application Task: 0x%08x   %s', 00H
$SG13951 DB	'DeleteTask ==================> 0x%08x   ProcessID: %d   '
	DB	'Task: 0x%08x          FirstOpenFile: 0x%08x', 00H
$SG13952 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG13957 DB	'First View not NULL!!!', 00H
	ORG $+1
$SG13958 DB	'DKS', 00H
$SG13962 DB	'(tm) Freeing application allocated memory for task ', 00H
$SG13965 DB	'(tm) DeleteTask error dropping task app', 00H
$SG13971 DB	'(tm) Task (0x%08x) deleted for Process %d', 00H
	ORG $+2
$SG13973 DB	'   UserName: ', 00H
	ORG $+2
$SG13975 DB	'Post DeleteTask - ', 00H
	ORG $+1
$SG14039 DB	'Zeidon OE', 00H
	ORG $+2
$SG14037 DB	'SfCreateSubtask now REQUIRES a non-zero qualification vi'
	DB	'ewfor Application: %s.', 00H
	ORG $+1
$SG14038 DB	'SfCreateSubtask now REQUIRES a non-zero qualification vi'
	DB	'ew.  System will now crash', 00H
	ORG $+1
$SG14063 DB	'Zeidon OE', 00H
	ORG $+2
$SG14061 DB	'SfCreateSystemSubtask now REQUIRES a non-zero qualificat'
	DB	'ion viewfor Application: %s.', 00H
	ORG $+3
$SG14062 DB	'SfCreateSystemSubtask now REQUIRES a non-zero qualificat'
	DB	'ion view.  System will now crash', 00H
	ORG $+3
$SG14144 DB	'GarbageCollectViews Unregistering Task: ', 00H
	ORG $+3
$SG14263 DB	'Display Tasks/Apps ', 00H
$SG14264 DB	'   Task (0x%08x) %s   Process: %d', 00H
	ORG $+2
$SG14266 DB	'   UserName: ', 00H
	ORG $+2
$SG14267 DB	'      Open file: ''%s''', 00H
	ORG $+2
$SG14268 DB	'(KeepAlive)', 00H
$SG14270 DB	'   App (0x%08x) %s   %s', 00H
$SG14271 DB	'      View OD (0x%08x): ''%s''', 00H
_DATA	ENDS
PUBLIC	_DisableTask@4
PUBLIC	_EnableTask@4
PUBLIC	_DisplayOpenFiles@8
PUBLIC	_GarbageCollectViews@8
PUBLIC	_GetTaskDBHandlerTraceLevel@4
PUBLIC	_SetTaskDBHandlerTraceLevel@8
PUBLIC	_SfCreateSubtask@12
PUBLIC	_SfCurrentTaskIsServer@4
PUBLIC	_SfCreateSystemSubtask@12
PUBLIC	_SfDropSubtask@8
PUBLIC	_SfAllocTaskMemory@12
PUBLIC	_SfReAllocTaskMemory@12
PUBLIC	_SfFreeTaskMemory@4
PUBLIC	_SfGetTaskMemoryLength@4
PUBLIC	_SfLockTaskMemory@4
PUBLIC	_SfUnlockTaskMemory@4
PUBLIC	_SfIsObjectServicesTask@4
PUBLIC	_SfSetTaskFlag@12
PUBLIC	_SfCloseTaskDatabases@4
PUBLIC	_SfGetNextTask@4
PUBLIC	_SfGetCurrentTask@4
PUBLIC	_SfGetTaskInfo@12
PUBLIC	_DeleteTask@4
PUBLIC	_fnDropTaskOperations@4
PUBLIC	_fnDropTaskHandlers@4
PUBLIC	_fnDropTaskDomains@4
PUBLIC	_fnFreeTaskModules@4
PUBLIC	_fnDropTaskMutexes@4
PUBLIC	_fnCloseTaskOpenFiles@4
PUBLIC	_fnCloseTaskNetworkModules@4
PUBLIC	_fnCreateProcess
PUBLIC	_fnCreateTask
PUBLIC	_fnCreateSubtask
PUBLIC	_fnDropSubtask
PUBLIC	_fnFreeTaskDataspace
PUBLIC	_fnStartBrowseOfProcessList@8
PUBLIC	_fnEndBrowseOfProcessList@4
PUBLIC	_fnStartBrowseOfTaskList@8
PUBLIC	_fnEndBrowseOfTaskList@4
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnDropTaskDomain
PUBLIC	_fnDropTaskOperation@8
PUBLIC	_fnDropTaskApp
PUBLIC	_fnBuildHexAscii
PUBLIC	_fnCleanupTask
PUBLIC	_fnGarbageCollectViews
EXTRN	_memcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_SysDescribeZeidonPageTable@4:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_SetDefaultViewForActiveTask@8:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SysMutexLock@16:PROC
EXTRN	_SysMutexUnlock@12:PROC
EXTRN	_UnregisterZeidonApplication@4:PROC
EXTRN	_SysCheckTaskMemory@0:PROC
EXTRN	_fnSysCloseFile@12:PROC
EXTRN	_fnSysFreeLibrary@12:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysGetDateTime@4:PROC
EXTRN	_SysGetDateTimeDifference@16:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysMessageList@4:PROC
EXTRN	_SysTranslateString@8:PROC
EXTRN	_SysWait@4:PROC
EXTRN	_ActivateViewObject@12:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnFreeSharedMemory@8:PROC
EXTRN	_fnSysMutexUnlock@8:PROC
EXTRN	_fnSysMutexDestroy@8:PROC
EXTRN	_fnCreateApp:PROC
EXTRN	_fnDeleteApp:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnGetDataspaceLength:PROC
EXTRN	_fnInitializeDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnInvokeOCEOperation:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnDeclareView@20:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_fnChainFreespaces:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_g_hAnchorBlock:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_szlMessageObject:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpViewApp$1 = -12					; size = 4
_lpNextView$ = -8					; size = 4
_lpView$ = -4						; size = 4
_lpTask$ = 8						; size = 4
_lpDropApp$ = 12					; size = 4
_fnGarbageCollectViews PROC

; 2825 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2826 :    zVIEW  lpView;
; 2827 :    zVIEW  lpNextView = 0;

	mov	DWORD PTR _lpNextView$[ebp], 0

; 2828 : 
; 2829 :    if ( lpDropApp == 0 )

	cmp	DWORD PTR _lpDropApp$[ebp], 0
	jne	SHORT $LN5@fnGarbageC

; 2830 :       lpDropApp = zGETPTR( lpTask->hApp );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDropApp$[ebp], eax
$LN5@fnGarbageC:

; 2831 : 
; 2832 :    // Go through views for the task and drop views where nViewName == 0,
; 2833 :    // unless the View is marked as locked (bViewLocked == TRUE).
; 2834 :    for ( lpView = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax
	jmp	SHORT $LN4@fnGarbageC
$LN2@fnGarbageC:

; 2836 :          lpView = lpNextView )

	mov	ecx, DWORD PTR _lpNextView$[ebp]
	mov	DWORD PTR _lpView$[ebp], ecx
$LN4@fnGarbageC:

; 2835 :          lpView;

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN1@fnGarbageC

; 2837 :    {
; 2838 :       // Get the next view.  We do it here because we might drop the current
; 2839 :       // lpView in which case lpView->hNextView is undefined.
; 2840 :       lpNextView = zGETPTR( lpView->hNextView );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextView$[ebp], eax

; 2841 : 
; 2842 :       // Don't drop locked views.
; 2843 :       if ( lpView->bViewLocked )

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN6@fnGarbageC

; 2844 :          continue;

	jmp	SHORT $LN2@fnGarbageC
$LN6@fnGarbageC:

; 2845 : 
; 2846 :       // If number of view names for the view is greater than the number of
; 2847 :       // names allowed for auto dropped views (usually 0) then don't drop it.
; 2848 :       if ( lpView->nViewNames > lpView->nAutoDropNames )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	mov	edx, DWORD PTR _lpView$[ebp]
	movsx	eax, WORD PTR [edx+24]
	cmp	ecx, eax
	jle	SHORT $LN7@fnGarbageC

; 2849 :          continue;

	jmp	SHORT $LN2@fnGarbageC
$LN7@fnGarbageC:

; 2850 : 
; 2851 :       if ( lpDropApp && lpDropApp != (LPAPP) -1 )

	cmp	DWORD PTR _lpDropApp$[ebp], 0
	je	SHORT $LN8@fnGarbageC
	cmp	DWORD PTR _lpDropApp$[ebp], -1
	je	SHORT $LN8@fnGarbageC

; 2852 :       {
; 2853 :          LPAPP lpViewApp;
; 2854 : 
; 2855 :          fnGetApplicationForSubtask( &lpViewApp, lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewApp$1[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 2856 :          if ( lpViewApp != lpDropApp )

	mov	eax, DWORD PTR _lpViewApp$1[ebp]
	cmp	eax, DWORD PTR _lpDropApp$[ebp]
	je	SHORT $LN8@fnGarbageC

; 2857 :             continue;

	jmp	SHORT $LN2@fnGarbageC
$LN8@fnGarbageC:

; 2858 :       }
; 2859 : 
; 2860 :       // If we get here then all conditions indicate we can drop the view.
; 2861 :       fnDropView( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 2862 :    }

	jmp	SHORT $LN2@fnGarbageC
$LN1@fnGarbageC:

; 2863 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnGarbageCollectViews ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
tv263 = -40						; size = 4
tv218 = -36						; size = 4
tv149 = -32						; size = 4
_lpViewOD$1 = -28					; size = 4
_lpView$2 = -24						; size = 4
_lpViewOI$3 = -20					; size = 4
_lpSubtask$4 = -16					; size = 4
_lpApp$5 = -12						; size = 4
_lpDataHeader$6 = -8					; size = 4
_lpViewName$7 = -4					; size = 4
_lpTask$ = 8						; size = 4
_fnCleanupTask PROC

; 1695 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1696 :    // TraceLine( "CleanupTask         Task: 0x%08x   Process: %d",
; 1697 :    //            hTask, lProcessID );
; 1698 : 
; 1699 :    if ( lpTask->hFirstLibrary )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+122], 0
	je	SHORT $LN18@fnCleanupT

; 1700 :    {
; 1701 :       TraceLineS( "CleanupTask unexpected Library", "" );

	push	OFFSET $SG13833
	push	OFFSET $SG13834
	call	_TraceLineS@8

; 1702 :       fnFreeTaskModules( lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnFreeTaskModules@4
$LN18@fnCleanupT:

; 1703 :    }
; 1704 : 
; 1705 :    if ( lpTask->hFirstOpenFile )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+118], 0
	je	SHORT $LN19@fnCleanupT

; 1706 :    {
; 1707 :       TraceLineS( "CleanupTask unexpected OpenFile", "" );

	push	OFFSET $SG13836
	push	OFFSET $SG13837
	call	_TraceLineS@8
$LN19@fnCleanupT:

; 1708 :    }
; 1709 : 
; 1710 :    if ( lpTask->hFirstTaskDBHandler )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+134], 0
	je	SHORT $LN20@fnCleanupT

; 1711 :    {
; 1712 :       TraceLineS( "CleanupTask unexpected DBHandler", "" );

	push	OFFSET $SG13839
	push	OFFSET $SG13840
	call	_TraceLineS@8
$LN20@fnCleanupT:

; 1713 :    }
; 1714 : 
; 1715 :    if ( lpTask->hFirstTaskGKHandler )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+138], 0
	je	SHORT $LN21@fnCleanupT

; 1716 :    {
; 1717 :       TraceLineS( "CleanupTask unexpected GKHandler", "" );

	push	OFFSET $SG13842
	push	OFFSET $SG13843
	call	_TraceLineS@8
$LN21@fnCleanupT:

; 1718 :    }
; 1719 : 
; 1720 :    if ( lpTask->hFirstTaskDomain )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+126], 0
	je	SHORT $LN22@fnCleanupT

; 1721 :    {
; 1722 :       TraceLineS( "CleanupTask unexpected Domain", "" );

	push	OFFSET $SG13845
	push	OFFSET $SG13846
	call	_TraceLineS@8
$LN22@fnCleanupT:

; 1723 :    }
; 1724 : 
; 1725 : #if 1 // debugging code
; 1726 : 
; 1727 :    if ( lpTask->bWebTrace )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	je	$LN23@fnCleanupT

; 1728 :    {
; 1729 :       LPAPP      lpApp;
; 1730 :       LPSUBTASK  lpSubtask;
; 1731 :       LPVIEWNAME lpViewName;
; 1732 :       LPVIEWOI   lpViewOI;
; 1733 :       LPVIEWOD   lpViewOD;
; 1734 :       zVIEW      lpView;
; 1735 :       LPDATAHEADER lpDataHeader;
; 1736 :    // LPFREESPACE lpNextFreespace;
; 1737 :    // LPFREESPACE lpPrevFreespace;
; 1738 :    // LPFREESPACE lpFreespace; // actual space
; 1739 :    // zPVOID      pvEndOfBuffer;
; 1740 :    // zCHAR       szHex[ 1024 ];
; 1741 :    // zCHAR       szAscii[ 256 ];
; 1742 :    // zCHAR       szMsg[ 2048 ];
; 1743 :    // zCPCHAR     cpcText;
; 1744 : 
; 1745 :       zLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysLockCoreMutex@4

; 1746 : 
; 1747 :       TraceLineS( "", "" );

	push	OFFSET $SG13848
	push	OFFSET $SG13849
	call	_TraceLineS@8

; 1748 :       TraceLine( "After Cleanup ==================================>> Task: 0x%08x   Task: 0x%08x",

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG13850
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 1749 :                  zGETHNDL( lpTask ), lpTask );
; 1750 :       lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN2@fnCleanupT:

; 1751 :       while ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN3@fnCleanupT

; 1752 :       {
; 1753 :          TraceLine( "   Task: 0x%08x              Task: 0x%08x", zGETHNDL( lpTask ), lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG13851
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 1754 : 
; 1755 :          lpSubtask = zGETPTR( lpTask->hFirstSubtask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$4[ebp], eax
$LN4@fnCleanupT:

; 1756 :          while ( lpSubtask )

	cmp	DWORD PTR _lpSubtask$4[ebp], 0
	je	$LN5@fnCleanupT

; 1757 :          {
; 1758 :             lpApp = zGETPTR( lpSubtask->hApp );

	mov	ecx, DWORD PTR _lpSubtask$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$5[ebp], eax

; 1759 :             TraceLine( "      Subtask: 0x%08x   Task: 0x%08x   App: 0x%08x (%s)   Subtask View: 0x%08x",

	cmp	DWORD PTR _lpApp$5[ebp], 0
	je	SHORT $LN25@fnCleanupT
	mov	eax, DWORD PTR _lpApp$5[ebp]
	add	eax, 6
	mov	DWORD PTR tv149[ebp], eax
	jmp	SHORT $LN26@fnCleanupT
$LN25@fnCleanupT:
	mov	DWORD PTR tv149[ebp], OFFSET $SG13852
$LN26@fnCleanupT:
	mov	ecx, DWORD PTR _lpSubtask$4[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR tv149[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSubtask$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _lpSubtask$4[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	mov	edx, DWORD PTR _lpSubtask$4[ebp]
	push	edx
	push	OFFSET $SG13853
	call	_TraceLine
	add	esp, 24					; 00000018H

; 1760 :                        lpSubtask, lpSubtask->hTask, lpSubtask->hApp, lpApp ? lpApp->szName : "???", lpSubtask->hSubtaskView );
; 1761 : 
; 1762 :             lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	eax, DWORD PTR _lpSubtask$4[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$7[ebp], eax
$LN6@fnCleanupT:

; 1763 :             while ( lpViewName )

	cmp	DWORD PTR _lpViewName$7[ebp], 0
	je	SHORT $LN7@fnCleanupT

; 1764 :             {
; 1765 :                TraceLine( "         ViewName: 0x%08x   View: 0x%08x   View Name %s",

	mov	edx, DWORD PTR _lpViewName$7[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewName$7[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$7[ebp]
	push	edx
	push	OFFSET $SG13854
	call	_TraceLine
	add	esp, 16					; 00000010H

; 1766 :                           lpViewName, lpViewName->hView, lpViewName->szName );
; 1767 : 
; 1768 :                lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$7[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$7[ebp], eax

; 1769 :             }

	jmp	SHORT $LN6@fnCleanupT
$LN7@fnCleanupT:

; 1770 : 
; 1771 :             lpSubtask = zGETPTR( lpSubtask->hNextSubtask );

	mov	edx, DWORD PTR _lpSubtask$4[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$4[ebp], eax

; 1772 :          }

	jmp	$LN4@fnCleanupT
$LN5@fnCleanupT:

; 1773 : 
; 1774 :          lpViewOI = zGETPTR( lpTask->hFirstViewOI );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+98]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$3[ebp], eax
$LN8@fnCleanupT:

; 1775 :          while ( lpViewOI )

	cmp	DWORD PTR _lpViewOI$3[ebp], 0
	je	SHORT $LN9@fnCleanupT

; 1776 :          {
; 1777 :             lpViewOD = zGETPTR( lpViewOI->hViewOD );

	mov	eax, DWORD PTR _lpViewOI$3[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 1778 :             TraceLine( "      ViewOI: 0x%08x   Task: 0x%08x   Alloc Task: 0x%08x   ViewOD: 0x%08x  (%s)",

	mov	edx, DWORD PTR _lpViewOD$1[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewOI$3[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	mov	edx, DWORD PTR _lpViewOI$3[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	mov	ecx, DWORD PTR _lpViewOI$3[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpViewOI$3[ebp]
	push	eax
	push	OFFSET $SG13855
	call	_TraceLine
	add	esp, 24					; 00000018H

; 1779 :                        lpViewOI, lpViewOI->hTask, lpViewOI->hAllocTask, lpViewOI->hViewOD, lpViewOD->szName );
; 1780 : 
; 1781 :             lpViewOI = zGETPTR( lpViewOI->hNextViewOI );

	mov	ecx, DWORD PTR _lpViewOI$3[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$3[ebp], eax

; 1782 :          }

	jmp	SHORT $LN8@fnCleanupT
$LN9@fnCleanupT:

; 1783 : 
; 1784 :          lpViewName = zGETPTR( lpTask->hFirstViewName );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$7[ebp], eax
$LN10@fnCleanupT:

; 1785 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$7[ebp], 0
	je	SHORT $LN11@fnCleanupT

; 1786 :          {
; 1787 :             TraceLine( "         ViewName: 0x%08x   View: 0x%08x   View Name %s",

	mov	edx, DWORD PTR _lpViewName$7[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewName$7[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$7[ebp]
	push	edx
	push	OFFSET $SG13856
	call	_TraceLine
	add	esp, 16					; 00000010H

; 1788 :                        lpViewName, lpViewName->hView, lpViewName->szName );
; 1789 : 
; 1790 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$7[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$7[ebp], eax

; 1791 :          }

	jmp	SHORT $LN10@fnCleanupT
$LN11@fnCleanupT:

; 1792 : 
; 1793 :          lpView = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$2[ebp], eax
$LN12@fnCleanupT:

; 1794 :          while ( lpView )

	cmp	DWORD PTR _lpView$2[ebp], 0
	je	SHORT $LN13@fnCleanupT

; 1795 :          {
; 1796 :             lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$2[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 1797 :             TraceLine( "         View: 0x%08x   Task: 0x%08x   ViewOD: 0x%08x (%s)  Name Cnt: %d",

	cmp	DWORD PTR _lpViewOD$1[ebp], 0
	je	SHORT $LN27@fnCleanupT
	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	mov	DWORD PTR tv218[ebp], eax
	jmp	SHORT $LN28@fnCleanupT
$LN27@fnCleanupT:
	mov	DWORD PTR tv218[ebp], OFFSET $SG13857
$LN28@fnCleanupT:
	mov	ecx, DWORD PTR _lpView$2[ebp]
	movsx	edx, WORD PTR [ecx+22]
	push	edx
	mov	eax, DWORD PTR tv218[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$2[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	mov	eax, DWORD PTR _lpView$2[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpView$2[ebp]
	push	edx
	push	OFFSET $SG13858
	call	_TraceLine
	add	esp, 24					; 00000018H

; 1798 :                        lpView, lpView->hTask, lpView->hViewOD, lpViewOD ? lpViewOD->szName : "???",
; 1799 :                        lpView->nViewNames );
; 1800 : 
; 1801 :             lpView = zGETPTR( lpView->hNextView );

	mov	eax, DWORD PTR _lpView$2[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$2[ebp], eax

; 1802 :          }

	jmp	SHORT $LN12@fnCleanupT
$LN13@fnCleanupT:

; 1803 : 
; 1804 :          lpDataHeader = zGETPTR( lpTask->hFirstDataHeader );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$6[ebp], eax
$LN14@fnCleanupT:

; 1805 :          while ( lpDataHeader )

	cmp	DWORD PTR _lpDataHeader$6[ebp], 0
	je	SHORT $LN15@fnCleanupT

; 1806 :          {
; 1807 :             fnChainFreespaces( lpDataHeader);

	mov	ecx, DWORD PTR _lpDataHeader$6[ebp]
	push	ecx
	call	_fnChainFreespaces
	add	esp, 4

; 1808 :             TraceLine( "      DataHeader: 0x%08x   Nbr: %d   Total Size: %d"

	mov	edx, DWORD PTR _lpDataHeader$6[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	mov	ecx, DWORD PTR _lpDataHeader$6[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpDataHeader$6[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	mov	edx, DWORD PTR _lpDataHeader$6[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	mov	ecx, DWORD PTR _lpDataHeader$6[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	mov	eax, DWORD PTR _lpDataHeader$6[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 24					; 00000018H
	push	ecx
	mov	edx, DWORD PTR _lpDataHeader$6[ebp]
	push	edx
	push	OFFSET $SG13859
	call	_TraceLine
	add	esp, 32					; 00000020H

; 1809 :                           "   Used Size: %d   Max Free Blocksize: %d"
; 1810 :                           "   Used Blocks: %d   Free Blocks: %d",
; 1811 :                        lpDataHeader,
; 1812 :                        (unsigned long) lpDataHeader->hDataHandle >> 24,
; 1813 :                        lpDataHeader->ulUseableSize,
; 1814 :                        lpDataHeader->ulUsedSpace,
; 1815 :                        lpDataHeader->ulMaxEmptyBlockSize,
; 1816 :                        lpDataHeader->ulCntUsedEntries,
; 1817 :                        lpDataHeader->ulCntFreeSpaces );
; 1818 : #if 0
; 1819 : #if 0
; 1820 :          // TraceDataHeader( lpDataHeader, FALSE ); // trace this header
; 1821 :             lpPrevFreespace = &lpDataHeader->Freespace;
; 1822 :             lpNextFreespace = zGETPTR( lpPrevFreespace->hNextFreespace );
; 1823 :             while ( lpNextFreespace )
; 1824 :             {
; 1825 :                TraceLine( "         %s: 0x%08x   Lth: %8d   Next: 0x%08x",
; 1826 :                           lpNextFreespace->nTableID == iFreespace ? "Free Space" :
; 1827 :                           lpNextFreespace->nTableID == iUsedFreespace ? "Used Space" : "???? Space",
; 1828 :                           lpNextFreespace, lpNextFreespace->ulFreeLth,
; 1829 :                           ((zPCHAR) lpNextFreespace) + lpNextFreespace->ulFreeLth );
; 1830 : 
; 1831 :                lpNextFreespace = zGETPTR( lpNextFreespace->hNextFreespace );
; 1832 :             }
; 1833 : #else
; 1834 :             // Trace out the freespace here.
; 1835 :             lpFreespace = (LPFREESPACE) ((zPCHAR) lpDataHeader + sizeof( DataHeaderRecord ));
; 1836 :             pvEndOfBuffer = (zPCHAR) lpDataHeader + sizeof( DataHeaderRecord ) +
; 1837 :                                                                  lpDataHeader->ulUseableSize;
; 1838 :             while ( (void *) lpFreespace < pvEndOfBuffer )
; 1839 :             {
; 1840 :                if ( lpFreespace->nTableID == iUsedFreespace ||
; 1841 :                     lpFreespace->nTableID == iUsedFreespace1 )
; 1842 :                {
; 1843 :                   fnBuildHexAscii( szHex, szAscii, (zCPCHAR) zGETPTR( lpFreespace->hFreespace ), 0,
; 1844 :                                    lpDataHeader->ulUseableSize );
; 1845 :                                 // lpDataHeader->ulUseableSize >= 32 ? 32 : lpDataHeader->ulUseableSize );
; 1846 :                   zstrcpy( szMsg, szHex );
; 1847 :                   zstrcat( szMsg, " | " );
; 1848 :                   zstrcat( szMsg, szAscii );
; 1849 :                   cpcText = " Used Space";
; 1850 :                }
; 1851 :                else
; 1852 :                {
; 1853 :                   szMsg[ 0 ] = 0;
; 1854 :                   if ( lpFreespace->nTableID == iFreespace )
; 1855 :                      cpcText = "*Free Space";
; 1856 :                   else
; 1857 :                      cpcText = "????? Space";
; 1858 :                }
; 1859 : 
; 1860 : #if 1
; 1861 :                if ( lpFreespace->nTableID == iUsedFreespace )
; 1862 :                {
; 1863 :                   TraceLine( "        %s: 0x%08x  Lth: %8d  Next: 0x%08x  %s",
; 1864 :                              cpcText, lpFreespace, lpFreespace->ulFreeLth,
; 1865 :                              ((zPCHAR) lpFreespace) + lpFreespace->ulFreeLth, szMsg );
; 1866 :                   lpFreespace->nTableID = iUsedFreespace1; // mark it as previously traced
; 1867 :                }
; 1868 : #endif
; 1869 : 
; 1870 :                lpFreespace = (LPFREESPACE) ((zPCHAR) lpFreespace + lpFreespace->ulFreeLth);
; 1871 :             }
; 1872 : #endif
; 1873 : #endif
; 1874 :             lpDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$6[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$6[ebp], eax

; 1875 :          }

	jmp	SHORT $LN14@fnCleanupT
$LN15@fnCleanupT:

; 1876 : 
; 1877 :          lpTask = zGETPTR( lpTask->hNextTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 1878 :       }

	jmp	$LN2@fnCleanupT
$LN3@fnCleanupT:

; 1879 : 
; 1880 :       zUNLOCK_MUTEX( zMUTEX_MEMORY );

	push	1
	call	_fnSysUnlockCoreMutex@4

; 1881 : 
; 1882 :       lpApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+126]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$5[ebp], eax
$LN16@fnCleanupT:

; 1883 :       while ( lpApp )

	cmp	DWORD PTR _lpApp$5[ebp], 0
	je	SHORT $LN23@fnCleanupT

; 1884 :       {
; 1885 :          TraceLine( "   App: 0x%08x (%s)   Application Task: 0x%08x   %s",

	mov	eax, DWORD PTR _lpApp$5[ebp]
	mov	ecx, DWORD PTR [eax+1905]
	and	ecx, 1
	je	SHORT $LN29@fnCleanupT
	mov	DWORD PTR tv263[ebp], OFFSET $SG13860
	jmp	SHORT $LN30@fnCleanupT
$LN29@fnCleanupT:
	mov	DWORD PTR tv263[ebp], OFFSET $SG13861
$LN30@fnCleanupT:
	mov	edx, DWORD PTR tv263[ebp]
	push	edx
	mov	eax, DWORD PTR _lpApp$5[ebp]
	mov	ecx, DWORD PTR [eax+1901]
	push	ecx
	mov	edx, DWORD PTR _lpApp$5[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lpApp$5[ebp]
	push	eax
	push	OFFSET $SG13862
	call	_TraceLine
	add	esp, 20					; 00000014H

; 1886 :                     lpApp, lpApp->szName, lpApp->hApplicationTask, lpApp->bKeepAlive ? "Keep Alive" : "" );
; 1887 : 
; 1888 :          lpApp = zGETPTR( lpApp->hNextApp );

	mov	ecx, DWORD PTR _lpApp$5[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$5[ebp], eax

; 1889 :       }

	jmp	SHORT $LN16@fnCleanupT
$LN23@fnCleanupT:

; 1890 :    }
; 1891 : 
; 1892 : // MiListOE_Memory( 0, 0 );
; 1893 : 
; 1894 : #endif
; 1895 : 
; 1896 :    return( 0 );

	xor	eax, eax

; 1897 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCleanupTask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_k$ = -272						; size = 4
_nLthAscii$ = -268					; size = 2
_nLthHex$ = -264					; size = 2
_sz$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pchHex$ = 8						; size = 4
_pchAscii$ = 12						; size = 4
_cpcBuffer$ = 16					; size = 4
_ulPos$ = 20						; size = 4
_ulLth$ = 24						; size = 4
_fnBuildHexAscii PROC

; 1640 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 272				; 00000110H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1641 :    zCHAR   sz[ 256 ];
; 1642 :    zSHORT  nLthHex;
; 1643 :    zSHORT  nLthAscii;
; 1644 :    zULONG  k;
; 1645 : 
; 1646 :    pchHex[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchHex$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 1647 :    pchAscii[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchAscii$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 1648 :    nLthHex = 0;

	xor	eax, eax
	mov	WORD PTR _nLthHex$[ebp], ax

; 1649 :    nLthAscii = 0;

	xor	ecx, ecx
	mov	WORD PTR _nLthAscii$[ebp], cx

; 1650 : 
; 1651 :    // Loop through each byte in the buffer and display a block of ulLth bytes
; 1652 :    // on a line in the trace window.
; 1653 :    for ( k = 0; k < (sizeof( sz ) - 2) && ulPos < ulLth; k++, ulPos++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@fnBuildHex
$LN2@fnBuildHex:
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx
	mov	eax, DWORD PTR _ulPos$[ebp]
	add	eax, 1
	mov	DWORD PTR _ulPos$[ebp], eax
$LN4@fnBuildHex:
	cmp	DWORD PTR _k$[ebp], 254			; 000000feH
	jae	$LN3@fnBuildHex
	mov	ecx, DWORD PTR _ulPos$[ebp]
	cmp	ecx, DWORD PTR _ulLth$[ebp]
	jae	$LN3@fnBuildHex

; 1654 :    {
; 1655 :       if ( k && (k % 8) == 0 )

	cmp	DWORD PTR _k$[ebp], 0
	je	SHORT $LN5@fnBuildHex
	mov	eax, DWORD PTR _k$[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	test	edx, edx
	jne	SHORT $LN5@fnBuildHex

; 1656 :          zstrcat( pchHex, "   " );

	push	OFFSET $SG13775
	mov	edx, DWORD PTR _pchHex$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN5@fnBuildHex:

; 1657 : 
; 1658 :       // Convert the current byte to a 2-char hex number.
; 1659 :       zltox( (zLONG) cpcBuffer[ ulPos ], sz );

	push	16					; 00000010H
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcBuffer$[ebp]
	add	ecx, DWORD PTR _ulPos$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1660 : 
; 1661 :       // Add the hex number to pchHex.
; 1662 :       if ( sz[ 0 ] == 0 || sz[ 1 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _sz$[ebp+ecx]
	test	edx, edx
	je	SHORT $LN8@fnBuildHex
	mov	eax, 1
	shl	eax, 0
	movsx	ecx, BYTE PTR _sz$[ebp+eax]
	test	ecx, ecx
	jne	$LN6@fnBuildHex
$LN8@fnBuildHex:

; 1663 :       {
; 1664 :          pchHex[ nLthHex++ ] = '0';

	movsx	edx, WORD PTR _nLthHex$[ebp]
	mov	eax, DWORD PTR _pchHex$[ebp]
	mov	BYTE PTR [eax+edx], 48			; 00000030H
	mov	cx, WORD PTR _nLthHex$[ebp]
	add	cx, 1
	mov	WORD PTR _nLthHex$[ebp], cx

; 1665 :          if ( sz[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _sz$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN9@fnBuildHex

; 1666 :             pchHex[ nLthHex++ ] = '0';

	movsx	edx, WORD PTR _nLthHex$[ebp]
	mov	eax, DWORD PTR _pchHex$[ebp]
	mov	BYTE PTR [eax+edx], 48			; 00000030H
	mov	cx, WORD PTR _nLthHex$[ebp]
	add	cx, 1
	mov	WORD PTR _nLthHex$[ebp], cx
	jmp	SHORT $LN10@fnBuildHex
$LN9@fnBuildHex:

; 1667 :          else
; 1668 :             pchHex[ nLthHex++ ] = sz[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, WORD PTR _nLthHex$[ebp]
	mov	edx, DWORD PTR _pchHex$[ebp]
	mov	al, BYTE PTR _sz$[ebp+eax]
	mov	BYTE PTR [edx+ecx], al
	mov	cx, WORD PTR _nLthHex$[ebp]
	add	cx, 1
	mov	WORD PTR _nLthHex$[ebp], cx
$LN10@fnBuildHex:

; 1669 :       }

	jmp	SHORT $LN7@fnBuildHex
$LN6@fnBuildHex:

; 1670 :       else
; 1671 :       {
; 1672 :          pchHex[ nLthHex++ ] = sz[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, WORD PTR _nLthHex$[ebp]
	mov	edx, DWORD PTR _pchHex$[ebp]
	mov	al, BYTE PTR _sz$[ebp+eax]
	mov	BYTE PTR [edx+ecx], al
	mov	cx, WORD PTR _nLthHex$[ebp]
	add	cx, 1
	mov	WORD PTR _nLthHex$[ebp], cx

; 1673 :          pchHex[ nLthHex++ ] = sz[ 1 ];

	mov	edx, 1
	shl	edx, 0
	movsx	eax, WORD PTR _nLthHex$[ebp]
	mov	ecx, DWORD PTR _pchHex$[ebp]
	mov	dl, BYTE PTR _sz$[ebp+edx]
	mov	BYTE PTR [ecx+eax], dl
	mov	ax, WORD PTR _nLthHex$[ebp]
	add	ax, 1
	mov	WORD PTR _nLthHex$[ebp], ax
$LN7@fnBuildHex:

; 1674 :       }
; 1675 : 
; 1676 :       pchHex[ nLthHex++ ] = ' ';

	movsx	ecx, WORD PTR _nLthHex$[ebp]
	mov	edx, DWORD PTR _pchHex$[ebp]
	mov	BYTE PTR [edx+ecx], 32			; 00000020H
	mov	ax, WORD PTR _nLthHex$[ebp]
	add	ax, 1
	mov	WORD PTR _nLthHex$[ebp], ax

; 1677 :       pchHex[ nLthHex ] = 0;

	movsx	ecx, WORD PTR _nLthHex$[ebp]
	mov	edx, DWORD PTR _pchHex$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 1678 : 
; 1679 :       // If the current byte is a printable char, then copy it to the ASCII
; 1680 :       // buffer.  Otherwise add a "." to the buffer.
; 1681 :       if ( cpcBuffer[ ulPos ] >= 32 && cpcBuffer[ ulPos ] <= 126 )

	mov	eax, DWORD PTR _cpcBuffer$[ebp]
	add	eax, DWORD PTR _ulPos$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN11@fnBuildHex
	mov	edx, DWORD PTR _cpcBuffer$[ebp]
	add	edx, DWORD PTR _ulPos$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 126				; 0000007eH
	jg	SHORT $LN11@fnBuildHex

; 1682 :          pchAscii[ nLthAscii++ ] = cpcBuffer[ ulPos ];

	movsx	ecx, WORD PTR _nLthAscii$[ebp]
	mov	edx, DWORD PTR _cpcBuffer$[ebp]
	add	edx, DWORD PTR _ulPos$[ebp]
	mov	eax, DWORD PTR _pchAscii$[ebp]
	mov	dl, BYTE PTR [edx]
	mov	BYTE PTR [eax+ecx], dl
	mov	ax, WORD PTR _nLthAscii$[ebp]
	add	ax, 1
	mov	WORD PTR _nLthAscii$[ebp], ax
	jmp	SHORT $LN12@fnBuildHex
$LN11@fnBuildHex:

; 1683 :       else
; 1684 :          pchAscii[ nLthAscii++ ] = '.';

	movsx	ecx, WORD PTR _nLthAscii$[ebp]
	mov	edx, DWORD PTR _pchAscii$[ebp]
	mov	BYTE PTR [edx+ecx], 46			; 0000002eH
	mov	ax, WORD PTR _nLthAscii$[ebp]
	add	ax, 1
	mov	WORD PTR _nLthAscii$[ebp], ax
$LN12@fnBuildHex:

; 1685 : 
; 1686 :       pchAscii[ nLthAscii ] = 0;

	movsx	ecx, WORD PTR _nLthAscii$[ebp]
	mov	edx, DWORD PTR _pchAscii$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 1687 :    }

	jmp	$LN2@fnBuildHex
$LN3@fnBuildHex:

; 1688 : 
; 1689 :    return( ulPos );

	mov	eax, DWORD PTR _ulPos$[ebp]

; 1690 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnBuildHexAscii ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_lpTaskApp$ = 12					; size = 4
_fnDropTaskApp PROC

; 1118 : {

	push	ebp
	mov	ebp, esp

; 1119 :    if ( lpTask && lpTaskApp )  // make sure pointers are not null

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN2@fnDropTask
	cmp	DWORD PTR _lpTaskApp$[ebp], 0
	je	SHORT $LN2@fnDropTask

; 1120 :    {
; 1121 :       // Point to next item in the chain off the task structure.
; 1122 :       lpTask->hFirstTaskApp = lpTaskApp->hNextTaskApp;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+102], edx

; 1123 : 
; 1124 :       // If MQ Interface pointers, drop them.
; 1125 :       if ( lpTaskApp->hMQInterface )

	mov	eax, DWORD PTR _lpTaskApp$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN3@fnDropTask

; 1126 :          fnFreeDataspace( zGETPTR( lpTaskApp->hMQInterface ) );

	mov	ecx, DWORD PTR _lpTaskApp$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN3@fnDropTask:

; 1127 : 
; 1128 :       // Free the TaskApp space.
; 1129 :       fnFreeDataspace( lpTaskApp );

	mov	eax, DWORD PTR _lpTaskApp$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1130 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnDropTask
$LN2@fnDropTask:

; 1131 :    }
; 1132 : 
; 1133 :    return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@fnDropTask:

; 1134 : }

	pop	ebp
	ret	0
_fnDropTaskApp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpViewAttrib$1 = -24					; size = 4
_lpViewEntity$2 = -20					; size = 4
_lpViewOD$3 = -16					; size = 4
_hTaskOperation$ = -12					; size = 4
_lpNextTaskOperation$ = -8				; size = 4
_lpPrevTaskOperation$ = -4				; size = 4
_lpTask$ = 8						; size = 4
_lpTaskOperation$ = 12					; size = 4
_fnDropTaskOperation@8 PROC

; 793  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 794  :    LPTASKOPER  hTaskOperation = zGETHNDL( lpTaskOperation );

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hTaskOperation$[ebp], eax

; 795  :    LPTASKOPER  lpNextTaskOperation;
; 796  :    LPTASKOPER  lpPrevTaskOperation;
; 797  : // zBOOL       bMutexLocked;
; 798  : 
; 799  :    // Make sure pointers are not null.
; 800  :    if ( lpTaskOperation == 0 )

	cmp	DWORD PTR _lpTaskOperation$[ebp], 0
	jne	SHORT $LN5@fnDropTask

; 801  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDropTask
$LN5@fnDropTask:

; 802  : 
; 803  :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN6@fnDropTask

; 804  :    {
; 805  :       lpTask = zGETPTR( lpTaskOperation->hTask );

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 806  :       if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN6@fnDropTask

; 807  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDropTask
$LN6@fnDropTask:

; 808  :    }
; 809  : 
; 810  : #if 0
; 811  :    // We don't need this since fnDropTaskOperation is only called through
; 812  :    // DeleteTask which already is protected by the ANCHORBLOCK mutex.
; 813  :    if ( zGETHNDL( lpTask ) == AnchorBlock->hMainTask )  // added dks
; 814  :    {
; 815  :       bMutexLocked = TRUE;
; 816  :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );
; 817  :    }
; 818  :    else
; 819  :       bMutexLocked = FALSE;
; 820  : #endif
; 821  : 
; 822  :    // Remove the TaskOperation from the operation list for the task.
; 823  :    if ( lpTask->hFirstTaskOperation == hTaskOperation )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+130]
	cmp	ecx, DWORD PTR _hTaskOperation$[ebp]
	jne	SHORT $LN8@fnDropTask

; 824  :       lpTask->hFirstTaskOperation = lpTaskOperation->hNextTaskOperationForTask;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+130], ecx
	jmp	SHORT $LN9@fnDropTask
$LN8@fnDropTask:

; 825  :    else
; 826  :    {
; 827  :       for ( lpPrevTaskOperation = zGETPTR( lpTask->hFirstTaskOperation );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+130]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTaskOperation$[ebp], eax
	jmp	SHORT $LN4@fnDropTask
$LN2@fnDropTask:

; 829  :             lpPrevTaskOperation =

	mov	ecx, DWORD PTR _lpPrevTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTaskOperation$[ebp], eax
$LN4@fnDropTask:

; 828  :             lpPrevTaskOperation->hNextTaskOperationForTask != hTaskOperation;

	mov	eax, DWORD PTR _lpPrevTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hTaskOperation$[ebp]
	je	SHORT $LN3@fnDropTask

; 830  :                   zGETPTR( lpPrevTaskOperation->hNextTaskOperationForTask ) )
; 831  :       {
; 832  :          // Nothing needs to be done here.
; 833  :       }

	jmp	SHORT $LN2@fnDropTask
$LN3@fnDropTask:

; 834  : 
; 835  :       lpPrevTaskOperation->hNextTaskOperationForTask =

	mov	edx, DWORD PTR _lpPrevTaskOperation$[ebp]
	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx
$LN9@fnDropTask:

; 836  :                                     lpTaskOperation->hNextTaskOperationForTask;
; 837  :    }
; 838  : 
; 839  : // if ( bMutexLocked )
; 840  : //    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );
; 841  : 
; 842  :    if ( lpTaskOperation->hViewOD )

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	$LN10@fnDropTask

; 843  :    {
; 844  :       LPVIEWOD lpViewOD;
; 845  : 
; 846  :       // Remove from the chain off of the ViewOD structure.
; 847  :       lpViewOD = zGETPTR( lpTaskOperation->hViewOD ); // save ViewAttribute

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$3[ebp], eax

; 848  :       lpNextTaskOperation =

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskOperation$[ebp], eax

; 849  :                      zGETPTR( lpTaskOperation->hNextTaskOperationForOEA );
; 850  :       lpPrevTaskOperation =

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTaskOperation$[ebp], eax

; 851  :                      zGETPTR( lpTaskOperation->hPrevTaskOperationForOEA );  // blew on this line 2006.07.03 dks
; 852  : 
; 853  :       // If no next link, then the previous one becomes the tail of the chain.
; 854  :       if ( lpNextTaskOperation )

	cmp	DWORD PTR _lpNextTaskOperation$[ebp], 0
	je	SHORT $LN12@fnDropTask

; 855  :          lpNextTaskOperation->hPrevTaskOperationForOEA = zGETHNDL( lpPrevTaskOperation );

	mov	eax, DWORD PTR _lpPrevTaskOperation$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNextTaskOperation$[ebp]
	mov	DWORD PTR [ecx+10], eax
	jmp	SHORT $LN13@fnDropTask
$LN12@fnDropTask:

; 856  :       else
; 857  :          lpViewOD->hLastTaskOperation = zGETHNDL( lpPrevTaskOperation );

	mov	edx, DWORD PTR _lpPrevTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOD$3[ebp]
	mov	DWORD PTR [ecx+220], eax
$LN13@fnDropTask:

; 858  : 
; 859  :       // If no previous link, then the next one becomes the head of the chain.
; 860  :       if ( lpPrevTaskOperation )

	cmp	DWORD PTR _lpPrevTaskOperation$[ebp], 0
	je	SHORT $LN14@fnDropTask

; 861  :          lpPrevTaskOperation->hNextTaskOperationForOEA = zGETHNDL( lpNextTaskOperation );

	mov	edx, DWORD PTR _lpNextTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevTaskOperation$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN15@fnDropTask
$LN14@fnDropTask:

; 862  :       else
; 863  :          lpViewOD->hFirstTaskOperation = zGETHNDL( lpNextTaskOperation );

	mov	edx, DWORD PTR _lpNextTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewOD$3[ebp]
	mov	DWORD PTR [ecx+216], eax
$LN15@fnDropTask:

; 864  :    }

	jmp	$LN11@fnDropTask
$LN10@fnDropTask:

; 865  :    else
; 866  :    if ( lpTaskOperation->hViewEntity )

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	$LN16@fnDropTask

; 867  :    {
; 868  :       LPVIEWENTITY   lpViewEntity;
; 869  : 
; 870  :       // Remove from the chain off of the ViewEntity structure.
; 871  :       lpViewEntity = zGETPTR( lpTaskOperation->hViewEntity ); // save ViewAttribute

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 872  :       lpNextTaskOperation =

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskOperation$[ebp], eax

; 873  :                         zGETPTR( lpTaskOperation->hNextTaskOperationForOEA );
; 874  :       lpPrevTaskOperation =

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTaskOperation$[ebp], eax

; 875  :                         zGETPTR( lpTaskOperation->hPrevTaskOperationForOEA );
; 876  : 
; 877  :       // If no next link, then the previous one becomes the tail of the chain.
; 878  :       if ( lpNextTaskOperation )

	cmp	DWORD PTR _lpNextTaskOperation$[ebp], 0
	je	SHORT $LN18@fnDropTask

; 879  :          lpNextTaskOperation->hPrevTaskOperationForOEA = zGETHNDL( lpPrevTaskOperation );

	mov	eax, DWORD PTR _lpPrevTaskOperation$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNextTaskOperation$[ebp]
	mov	DWORD PTR [ecx+10], eax
	jmp	SHORT $LN19@fnDropTask
$LN18@fnDropTask:

; 880  :       else
; 881  :          lpViewEntity->hLastTaskOperation = zGETHNDL( lpPrevTaskOperation );

	mov	edx, DWORD PTR _lpPrevTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	mov	DWORD PTR [ecx+187], eax
$LN19@fnDropTask:

; 882  : 
; 883  :       // If no previous link, then the next one becomes the head of the chain.
; 884  :       if ( lpPrevTaskOperation )

	cmp	DWORD PTR _lpPrevTaskOperation$[ebp], 0
	je	SHORT $LN20@fnDropTask

; 885  :          lpPrevTaskOperation->hNextTaskOperationForOEA = zGETHNDL( lpNextTaskOperation );

	mov	edx, DWORD PTR _lpNextTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevTaskOperation$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN21@fnDropTask
$LN20@fnDropTask:

; 886  :       else
; 887  :          lpViewEntity->hFirstTaskOperation = zGETHNDL( lpNextTaskOperation );

	mov	edx, DWORD PTR _lpNextTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	mov	DWORD PTR [ecx+183], eax
$LN21@fnDropTask:

; 888  :    }

	jmp	$LN11@fnDropTask
$LN16@fnDropTask:

; 889  :    else
; 890  :    if ( lpTaskOperation->hViewAttrib )

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	cmp	DWORD PTR [edx+26], 0
	je	$LN22@fnDropTask

; 891  :    {
; 892  :       LPVIEWATTRIB lpViewAttrib;
; 893  : 
; 894  :       // Remove from the chain off of the ViewAttrib structure.
; 895  :       lpViewAttrib = zGETPTR( lpTaskOperation->hViewAttrib ); // save ViewAttribute

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$1[ebp], eax

; 896  :       lpNextTaskOperation =

	mov	edx, DWORD PTR _lpTaskOperation$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskOperation$[ebp], eax

; 897  :                      zGETPTR( lpTaskOperation->hNextTaskOperationForOEA );
; 898  :       lpPrevTaskOperation =

	mov	ecx, DWORD PTR _lpTaskOperation$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTaskOperation$[ebp], eax

; 899  :                      zGETPTR( lpTaskOperation->hPrevTaskOperationForOEA );
; 900  : 
; 901  :       // If no next link, then the previous one becomes the tail of the chain.
; 902  :       if ( lpNextTaskOperation )

	cmp	DWORD PTR _lpNextTaskOperation$[ebp], 0
	je	SHORT $LN24@fnDropTask

; 903  :          lpNextTaskOperation->hPrevTaskOperationForOEA = zGETHNDL( lpPrevTaskOperation );

	mov	eax, DWORD PTR _lpPrevTaskOperation$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNextTaskOperation$[ebp]
	mov	DWORD PTR [ecx+10], eax
	jmp	SHORT $LN25@fnDropTask
$LN24@fnDropTask:

; 904  :       else
; 905  :          lpViewAttrib->hLastTaskOperation = zGETHNDL( lpPrevTaskOperation );

	mov	edx, DWORD PTR _lpPrevTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewAttrib$1[ebp]
	mov	DWORD PTR [ecx+189], eax
$LN25@fnDropTask:

; 906  : 
; 907  :       // If no previous link, then the next one becomes the head of the chain.
; 908  :       if ( lpPrevTaskOperation )

	cmp	DWORD PTR _lpPrevTaskOperation$[ebp], 0
	je	SHORT $LN26@fnDropTask

; 909  :          lpPrevTaskOperation->hNextTaskOperationForOEA = zGETHNDL( lpNextTaskOperation );

	mov	edx, DWORD PTR _lpNextTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevTaskOperation$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN27@fnDropTask
$LN26@fnDropTask:

; 910  :       else
; 911  :          lpViewAttrib->hFirstTaskOperation = zGETHNDL( lpNextTaskOperation );

	mov	edx, DWORD PTR _lpNextTaskOperation$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewAttrib$1[ebp]
	mov	DWORD PTR [ecx+185], eax
$LN27@fnDropTask:

; 912  :    }

	jmp	SHORT $LN11@fnDropTask
$LN22@fnDropTask:

; 913  :    else
; 914  :    {
; 915  :       // "KZOEE021 - Internal error, TaskOperation block has no
; 916  :       //  Object/Entity/Attr"
; 917  :       fnIssueCoreError( lpTask, 0, 16, 21, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	21					; 00000015H
	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN11@fnDropTask:

; 918  :    }
; 919  : 
; 920  :    fnFreeDataspace( lpTaskOperation );

	mov	eax, DWORD PTR _lpTaskOperation$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 921  :    return( 0 );

	xor	eax, eax
$LN1@fnDropTask:

; 922  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_fnDropTaskOperation@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpDomain$ = -12					; size = 4
_lpPrevTaskDomain$ = -8					; size = 4
_lpNextTaskDomain$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpTaskDomain$ = 12					; size = 4
_fnDropTaskDomain PROC

; 657  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 658  :    LPDOMAIN     lpDomain;
; 659  : // LPTASKDOMAIN hTaskDomain;
; 660  :    LPTASKDOMAIN lpNextTaskDomain;
; 661  :    LPTASKDOMAIN lpPrevTaskDomain;
; 662  : 
; 663  :    if ( lpTask == 0 || lpTaskDomain == 0 ) // ensure pointers are not null

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN5@fnDropTask
	cmp	DWORD PTR _lpTaskDomain$[ebp], 0
	jne	SHORT $LN4@fnDropTask
$LN5@fnDropTask:

; 664  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDropTask
$LN4@fnDropTask:

; 665  : 
; 666  :    // Point to next item in the chain off the task structure.
; 667  :    lpPrevTaskDomain = 0;

	mov	DWORD PTR _lpPrevTaskDomain$[ebp], 0

; 668  :    lpNextTaskDomain = zGETPTR( lpTask->hFirstTaskDomain );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+126]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskDomain$[ebp], eax
$LN2@fnDropTask:

; 669  :    while ( lpNextTaskDomain )

	cmp	DWORD PTR _lpNextTaskDomain$[ebp], 0
	je	SHORT $LN3@fnDropTask

; 670  :    {
; 671  :       if ( lpTaskDomain == lpNextTaskDomain )

	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	cmp	edx, DWORD PTR _lpNextTaskDomain$[ebp]
	jne	SHORT $LN6@fnDropTask

; 672  :       {
; 673  :          if ( lpPrevTaskDomain )

	cmp	DWORD PTR _lpPrevTaskDomain$[ebp], 0
	je	SHORT $LN7@fnDropTask

; 674  :             lpPrevTaskDomain->hNextTaskDomainForTask = lpTaskDomain->hNextTaskDomainForTask;

	mov	eax, DWORD PTR _lpPrevTaskDomain$[ebp]
	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+2], edx
	jmp	SHORT $LN8@fnDropTask
$LN7@fnDropTask:

; 675  :          else
; 676  :             lpTask->hFirstTaskDomain = lpTaskDomain->hNextTaskDomainForTask;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+126], edx
$LN8@fnDropTask:

; 677  : 
; 678  :          break;

	jmp	SHORT $LN3@fnDropTask
$LN6@fnDropTask:

; 679  :       }
; 680  : 
; 681  :       lpPrevTaskDomain = lpNextTaskDomain;

	mov	eax, DWORD PTR _lpNextTaskDomain$[ebp]
	mov	DWORD PTR _lpPrevTaskDomain$[ebp], eax

; 682  :       lpNextTaskDomain = zGETPTR( lpNextTaskDomain->hNextTaskDomainForTask );

	mov	ecx, DWORD PTR _lpNextTaskDomain$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskDomain$[ebp], eax

; 683  :    }

	jmp	SHORT $LN2@fnDropTask
$LN3@fnDropTask:

; 684  : 
; 685  :    // Remove from the chain off of the Domain structure.
; 686  :    lpDomain = zGETPTR( lpTaskDomain->hDomain ); // save domain

	mov	eax, DWORD PTR _lpTaskDomain$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDomain$[ebp], eax

; 687  : // TraceLine( "fnDropTaskDomain Task: 0x%08x   Domain: 0x%08x - %s",
; 688  : //             zGETHNDL( lpTask ), lpTaskDomain, lpDomain->szName );
; 689  : 
; 690  :    lpNextTaskDomain = zGETPTR( lpTaskDomain->hNextTaskDomainForDomain );

	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskDomain$[ebp], eax

; 691  :    lpPrevTaskDomain = zGETPTR( lpTaskDomain->hPrevTaskDomainForDomain );

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTaskDomain$[ebp], eax

; 692  : 
; 693  :    // If no next link, then the previous one becomes the tail of the chain.
; 694  :    if ( lpNextTaskDomain )

	cmp	DWORD PTR _lpNextTaskDomain$[ebp], 0
	je	SHORT $LN9@fnDropTask

; 695  :       lpNextTaskDomain->hPrevTaskDomainForDomain = zGETHNDL( lpPrevTaskDomain );

	mov	eax, DWORD PTR _lpPrevTaskDomain$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNextTaskDomain$[ebp]
	mov	DWORD PTR [ecx+10], eax
	jmp	SHORT $LN10@fnDropTask
$LN9@fnDropTask:

; 696  :    else
; 697  :       lpDomain->hLastTaskDomain = zGETHNDL( lpPrevTaskDomain );

	mov	edx, DWORD PTR _lpPrevTaskDomain$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	DWORD PTR [ecx+55], eax
$LN10@fnDropTask:

; 698  : 
; 699  :    // If no previous link, then the next one becomes the head of the chain.
; 700  :    if ( lpPrevTaskDomain )

	cmp	DWORD PTR _lpPrevTaskDomain$[ebp], 0
	je	SHORT $LN11@fnDropTask

; 701  :       lpPrevTaskDomain->hNextTaskDomainForDomain = zGETHNDL( lpNextTaskDomain );

	mov	edx, DWORD PTR _lpNextTaskDomain$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevTaskDomain$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN12@fnDropTask
$LN11@fnDropTask:

; 702  :    else
; 703  :       lpDomain->hFirstTaskDomain = zGETHNDL( lpNextTaskDomain );

	mov	edx, DWORD PTR _lpNextTaskDomain$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpDomain$[ebp]
	mov	DWORD PTR [ecx+51], eax
$LN12@fnDropTask:

; 704  : 
; 705  : #if 0  // cannot do this here ... will be done when application is deleted
; 706  : 
; 707  :    // If the domain has no other TaskDomain (other than AnchorBlock's MainTask)
; 708  :    // pointing to it, delete it.
; 709  :    if ( lpDomain->hApp != AnchorBlock->hSystemApp )
; 710  :    {
; 711  :       hTaskDomain = zGETHNDL( lpTaskDomain );
; 712  :       if ( lpDomain->hFirstTaskDomain == 0 ||
; 713  :            (lpDomain->hFirstTaskDomain == hTaskDomain &&
; 714  :             lpDomain->hLastTaskDomain == hTaskDomain) )
; 715  :       {
; 716  :          LPAPP lpApp = zGETPTR( lpDomain->hApp );
; 717  :          if ( lpApp )
; 718  :          {
; 719  :             LPDOMAIN lpDomainNext = zGETPTR( lpApp->hFirstDomain );
; 720  :             LPDOMAIN lpDomainPrev = 0;
; 721  : 
; 722  :             // Clean up this domain.
; 723  :             while ( lpDomainNext )
; 724  :             {
; 725  :                if ( lpDomain == lpDomainNext )
; 726  :                {
; 727  :                   if ( lpDomainPrev )
; 728  :                      lpDomainPrev->hNextDomain = lpDomainNext->hNextDomain;
; 729  :                   else
; 730  :                      lpApp->hFirstDomain = lpDomainNext->hNextDomain;
; 731  : 
; 732  :                   TraceLine( "fnDropTaskDomain DELETING Domain for Task: 0x%08x   Domain: 0x%08x - %s",
; 733  :                              zGETHNDL( lpTask ), lpTaskDomain, lpDomain->szName );
; 734  :                   fnDeleteContext( lpDomain );
; 735  :                   fnFreeDataspace( lpDomain );
; 736  :                   break;
; 737  :                }
; 738  : 
; 739  :                lpDomainPrev = lpDomainNext;
; 740  :                lpDomainNext = zGETPTR( lpDomainPrev->hNextDomain );
; 741  :             }
; 742  :          }
; 743  :       }
; 744  :    }
; 745  : #endif
; 746  : 
; 747  :    // Free the TaskDomain space.
; 748  :    fnFreeDataspace( lpTaskDomain );

	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 749  :    return( 0 );

	xor	eax, eax
$LN1@fnDropTask:

; 750  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropTaskDomain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_bForWrite$ = 8						; size = 1
_fnEndBrowseOfTaskList@4 PROC

; 3155 : {

	push	ebp
	mov	ebp, esp

; 3156 :    if ( bForWrite )

	movzx	eax, BYTE PTR _bForWrite$[ebp]
	test	eax, eax
	je	SHORT $LN2@fnEndBrows

; 3157 :    {
; 3158 :       // See NOTE in fnStartBrowseOfTaskList for an explanation of why
; 3159 :       // we use a global variable.
; 3160 :       zLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysLockCoreMutex@4

; 3161 :       AnchorBlock->hTaskChainWriteLockTaskID = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1499], 0

; 3162 :       zUNLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysUnlockCoreMutex@4

; 3163 :    }

	jmp	SHORT $LN1@fnEndBrows
$LN2@fnEndBrows:

; 3164 :    else
; 3165 :    {
; 3166 :       // Lock the 'browse' mutex.
; 3167 :       zLOCK_MUTEX( zMUTEX_TASKCHAIN );

	push	5
	call	_fnSysLockCoreMutex@4

; 3168 : 
; 3169 :       // Decrement the counter that keeps track of all the tasks that are
; 3170 :       // reading the task list.
; 3171 :       AnchorBlock->nBrowseTaskListCounter--;

	mov	edx, DWORD PTR _AnchorBlock
	mov	ax, WORD PTR [edx+1493]
	sub	ax, 1
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+1493], ax

; 3172 : 
; 3173 :       // If the counter is 0 then this means no other tasks are currently
; 3174 :       // reading the task list and the 'write' lock can be freed.
; 3175 :       if ( AnchorBlock->nBrowseTaskListCounter == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	movzx	eax, WORD PTR [edx+1493]
	test	eax, eax
	jne	SHORT $LN4@fnEndBrows

; 3176 :       {
; 3177 :          // See NOTE in fnStartBrowseOfTaskList for an explanation of why
; 3178 :          // we use a global variable.
; 3179 :          zLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysLockCoreMutex@4

; 3180 :          AnchorBlock->hTaskChainWriteLockTaskID = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1499], 0

; 3181 :          zUNLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysUnlockCoreMutex@4
$LN4@fnEndBrows:

; 3182 :       }
; 3183 : 
; 3184 :       zUNLOCK_MUTEX( zMUTEX_TASKCHAIN );

	push	5
	call	_fnSysUnlockCoreMutex@4
$LN1@fnEndBrows:

; 3185 :    }
; 3186 : }

	pop	ebp
	ret	4
_fnEndBrowseOfTaskList@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_hTask$ = 8						; size = 4
_bForWrite$ = 12					; size = 1
_fnStartBrowseOfTaskList@8 PROC

; 3090 : {

	push	ebp
	mov	ebp, esp

; 3091 :    if ( bForWrite )

	movzx	eax, BYTE PTR _bForWrite$[ebp]
	test	eax, eax
	je	SHORT $LN6@fnStartBro
$LN2@fnStartBro:

; 3092 :    {
; 3093 :       while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN3@fnStartBro

; 3094 :       {
; 3095 :          // See note below about locking the 'write' mutex to find out
; 3096 :          // why we use a global variable instead of a regular mutex.
; 3097 :          zLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysLockCoreMutex@4

; 3098 :          if ( AnchorBlock->hTaskChainWriteLockTaskID == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+1499], 0
	jne	SHORT $LN8@fnStartBro

; 3099 :          {
; 3100 :             AnchorBlock->hTaskChainWriteLockTaskID = (zLONG) hTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [eax+1499], ecx

; 3101 :             zUNLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysUnlockCoreMutex@4

; 3102 :             break;

	jmp	SHORT $LN3@fnStartBro
$LN8@fnStartBro:

; 3103 :          }
; 3104 : 
; 3105 :          zUNLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysUnlockCoreMutex@4

; 3106 :          SysWait( 0 );

	push	0
	call	_SysWait@4

; 3107 :       }

	jmp	SHORT $LN2@fnStartBro
$LN3@fnStartBro:

; 3108 :    }

	jmp	$LN7@fnStartBro
$LN6@fnStartBro:

; 3109 :    else
; 3110 :    {
; 3111 :       // Lock the 'browse' mutex.
; 3112 :       zLOCK_MUTEX( zMUTEX_TASKCHAIN );

	push	5
	call	_fnSysLockCoreMutex@4

; 3113 : 
; 3114 :       // Bump up the counter that keeps track of all the tasks that are
; 3115 :       // reading the task list.
; 3116 :       AnchorBlock->nBrowseTaskListCounter++;

	mov	edx, DWORD PTR _AnchorBlock
	mov	ax, WORD PTR [edx+1493]
	add	ax, 1
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+1493], ax

; 3117 : 
; 3118 :       // If the counter is 1 then this means no other tasks are currently
; 3119 :       // reading the task list and so we need to make sure no other task
; 3120 :       // has the 'write' mutex locked.
; 3121 :       if ( AnchorBlock->nBrowseTaskListCounter == 1 )

	mov	edx, DWORD PTR _AnchorBlock
	movzx	eax, WORD PTR [edx+1493]
	cmp	eax, 1
	jne	SHORT $LN9@fnStartBro
$LN4@fnStartBro:

; 3122 :       {
; 3123 :          // NOTE
; 3124 :          // We need to lock the 'write' mutex to keep another task from
; 3125 :          // acquiring a 'write' lock while we are reading the task list.
; 3126 :          // Since the 'write' mutex can be locked by one task and then
; 3127 :          // unlocked by another task we will use a global variable to indicate
; 3128 :          // that the 'write' mutex is locked.  If lTaskChainWriteLockTaskID is
; 3129 :          // not 0 then the mutex is locked.
; 3130 :          while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN9@fnStartBro

; 3131 :          {
; 3132 :             zLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysLockCoreMutex@4

; 3133 :             if ( AnchorBlock->hTaskChainWriteLockTaskID == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+1499], 0
	jne	SHORT $LN10@fnStartBro

; 3134 :             {
; 3135 :                AnchorBlock->hTaskChainWriteLockTaskID = (zLONG) hTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [eax+1499], ecx

; 3136 :                zUNLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysUnlockCoreMutex@4

; 3137 :                break;

	jmp	SHORT $LN9@fnStartBro
$LN10@fnStartBro:

; 3138 :             }
; 3139 : 
; 3140 :             zUNLOCK_MUTEX( zMUTEX_TASKCHAIN_WRITE );

	push	6
	call	_fnSysUnlockCoreMutex@4

; 3141 :             SysWait( 0 );

	push	0
	call	_SysWait@4

; 3142 :          }

	jmp	SHORT $LN4@fnStartBro
$LN9@fnStartBro:

; 3143 :       }
; 3144 : 
; 3145 :       zUNLOCK_MUTEX( zMUTEX_TASKCHAIN );

	push	5
	call	_fnSysUnlockCoreMutex@4
$LN7@fnStartBro:

; 3146 :    }
; 3147 : 
; 3148 :    // If we get here everything's OK and the current task can now
; 3149 :    // browse the task list.
; 3150 :    return( 0 );

	xor	eax, eax

; 3151 : }

	pop	ebp
	ret	8
_fnStartBrowseOfTaskList@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_bForWrite$ = 8						; size = 1
_fnEndBrowseOfProcessList@4 PROC

; 3283 : {

	push	ebp
	mov	ebp, esp

; 3284 :    if ( bForWrite )

	movzx	eax, BYTE PTR _bForWrite$[ebp]
	test	eax, eax
	je	SHORT $LN2@fnEndBrows

; 3285 :    {
; 3286 :       // See NOTE in fnStartBrowseOfProcessList for an explanation of why
; 3287 :       // we use a global variable.
; 3288 :       zLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysLockCoreMutex@4

; 3289 :       AnchorBlock->hTaskChainWriteLockTaskID = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1499], 0

; 3290 :       zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysUnlockCoreMutex@4

; 3291 :    }

	jmp	SHORT $LN1@fnEndBrows
$LN2@fnEndBrows:

; 3292 :    else
; 3293 :    {
; 3294 :       // Lock the 'browse' mutex.
; 3295 :       zLOCK_MUTEX( zMUTEX_PROCESSCHAIN );

	push	13					; 0000000dH
	call	_fnSysLockCoreMutex@4

; 3296 : 
; 3297 :       // Decrement the counter that keeps track of all the tasks that are
; 3298 :       // reading the task list.
; 3299 :       AnchorBlock->nBrowseTaskListCounter--;

	mov	edx, DWORD PTR _AnchorBlock
	mov	ax, WORD PTR [edx+1493]
	sub	ax, 1
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+1493], ax

; 3300 : 
; 3301 :       // If the counter is 0 then this means no other tasks are currently
; 3302 :       // reading the task list and the 'write' lock can be freed.
; 3303 :       if ( AnchorBlock->nBrowseTaskListCounter == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	movzx	eax, WORD PTR [edx+1493]
	test	eax, eax
	jne	SHORT $LN4@fnEndBrows

; 3304 :       {
; 3305 :          // See NOTE in fnStartBrowseOfProcessList for an explanation of why
; 3306 :          // we use a global variable.
; 3307 :          zLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysLockCoreMutex@4

; 3308 :          AnchorBlock->hTaskChainWriteLockTaskID = 0;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1499], 0

; 3309 :          zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysUnlockCoreMutex@4
$LN4@fnEndBrows:

; 3310 :       }
; 3311 : 
; 3312 :       zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN );

	push	13					; 0000000dH
	call	_fnSysUnlockCoreMutex@4
$LN1@fnEndBrows:

; 3313 :    }
; 3314 : }

	pop	ebp
	ret	4
_fnEndBrowseOfProcessList@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_hTask$ = 8						; size = 4
_bForWrite$ = 12					; size = 1
_fnStartBrowseOfProcessList@8 PROC

; 3218 : {

	push	ebp
	mov	ebp, esp

; 3219 :    if ( bForWrite )

	movzx	eax, BYTE PTR _bForWrite$[ebp]
	test	eax, eax
	je	SHORT $LN6@fnStartBro
$LN2@fnStartBro:

; 3220 :    {
; 3221 :       while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN3@fnStartBro

; 3222 :       {
; 3223 :          // See note below about locking the 'write' mutex to find out
; 3224 :          // why we use a global variable instead of a regular mutex.
; 3225 :          zLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysLockCoreMutex@4

; 3226 :          if ( AnchorBlock->hTaskChainWriteLockTaskID == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+1499], 0
	jne	SHORT $LN8@fnStartBro

; 3227 :          {
; 3228 :             AnchorBlock->hTaskChainWriteLockTaskID = (zLONG) hTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [eax+1499], ecx

; 3229 :             zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysUnlockCoreMutex@4

; 3230 :             break;

	jmp	SHORT $LN3@fnStartBro
$LN8@fnStartBro:

; 3231 :          }
; 3232 : 
; 3233 :          zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysUnlockCoreMutex@4

; 3234 :          SysWait( 0 );

	push	0
	call	_SysWait@4

; 3235 :       }

	jmp	SHORT $LN2@fnStartBro
$LN3@fnStartBro:

; 3236 :    }

	jmp	$LN7@fnStartBro
$LN6@fnStartBro:

; 3237 :    else
; 3238 :    {
; 3239 :       // Lock the 'browse' mutex.
; 3240 :       zLOCK_MUTEX( zMUTEX_PROCESSCHAIN );

	push	13					; 0000000dH
	call	_fnSysLockCoreMutex@4

; 3241 : 
; 3242 :       // Bump up the counter that keeps track of all the tasks that are
; 3243 :       // reading the task list.
; 3244 :       AnchorBlock->nBrowseTaskListCounter++;

	mov	edx, DWORD PTR _AnchorBlock
	mov	ax, WORD PTR [edx+1493]
	add	ax, 1
	mov	ecx, DWORD PTR _AnchorBlock
	mov	WORD PTR [ecx+1493], ax

; 3245 : 
; 3246 :       // If the counter is 1 then this means no other tasks are currently
; 3247 :       // reading the task list and so we need to make sure no other task
; 3248 :       // has the 'write' mutex locked.
; 3249 :       if ( AnchorBlock->nBrowseTaskListCounter == 1 )

	mov	edx, DWORD PTR _AnchorBlock
	movzx	eax, WORD PTR [edx+1493]
	cmp	eax, 1
	jne	SHORT $LN9@fnStartBro
$LN4@fnStartBro:

; 3250 :       {
; 3251 :          // NOTE
; 3252 :          // We need to lock the 'write' mutex to keep another task from
; 3253 :          // acquiring a 'write' lock while we are reading the task list.
; 3254 :          // Since the 'write' mutex can be locked by one task and then
; 3255 :          // unlocked by another task we will use a global variable to indicate
; 3256 :          // that the 'write' mutex is locked.  If lTaskChainWriteLockTaskID is
; 3257 :          // not 0 then the mutex is locked.
; 3258 :          while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN9@fnStartBro

; 3259 :          {
; 3260 :             zLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysLockCoreMutex@4

; 3261 :             if ( AnchorBlock->hTaskChainWriteLockTaskID == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+1499], 0
	jne	SHORT $LN10@fnStartBro

; 3262 :             {
; 3263 :                AnchorBlock->hTaskChainWriteLockTaskID = (zLONG) hTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [eax+1499], ecx

; 3264 :                zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysUnlockCoreMutex@4

; 3265 :                break;

	jmp	SHORT $LN9@fnStartBro
$LN10@fnStartBro:

; 3266 :             }
; 3267 : 
; 3268 :             zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN_WRITE );

	push	14					; 0000000eH
	call	_fnSysUnlockCoreMutex@4

; 3269 :             SysWait( 0 );

	push	0
	call	_SysWait@4

; 3270 :          }

	jmp	SHORT $LN4@fnStartBro
$LN9@fnStartBro:

; 3271 :       }
; 3272 : 
; 3273 :       zUNLOCK_MUTEX( zMUTEX_PROCESSCHAIN );

	push	13					; 0000000dH
	call	_fnSysUnlockCoreMutex@4
$LN7@fnStartBro:

; 3274 :    }
; 3275 : 
; 3276 :    // If we get here everything's OK and the current task can now
; 3277 :    // browse the task list.
; 3278 :    return( 0 );

	xor	eax, eax

; 3279 : }

	pop	ebp
	ret	8
_fnStartBrowseOfProcessList@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpDataHeader$1 = -4					; size = 4
_lpTask$ = 8						; size = 4
_fnFreeTaskDataspace PROC

; 571  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 572  :    // If we are running in server mode, there are no dataspaces to free ...
; 573  :    // everything is allocated using local memory.
; 574  :    //if ( g_bServerMode )
; 575  : // {
; 576  :    // return( 0 );  not quite ... we need to free the Data Headers
; 577  : // }
; 578  : 
; 579  :    // Make sure pointer is not null
; 580  :    if ( lpTask && lpTask->nTableID != iTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN7@fnFreeTask
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10006				; 00002716H
	je	SHORT $LN7@fnFreeTask

; 581  :    {
; 582  :       // "KZOEE016 - Invalid Task"
; 583  :       fnIssueCoreError( lpTask, 0, 16, 16, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	16					; 00000010H
	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 584  :       return( -1 );

	or	eax, -1
	jmp	$LN1@fnFreeTask
$LN7@fnFreeTask:

; 585  :    }
; 586  : 
; 587  :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN8@fnFreeTask

; 588  :    {
; 589  :       LPDATAHEADER lpDataHeader;
; 590  : 
; 591  :       // Free all memory allocated for the task ... freeing the first data
; 592  :       // header last.  DG ... is there a better way???
; 593  :       lpDataHeader = zGETPTR( lpTask->hFirstDataHeader );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$1[ebp], eax

; 594  :       if ( lpDataHeader )

	cmp	DWORD PTR _lpDataHeader$1[ebp], 0
	je	SHORT $LN9@fnFreeTask
$LN2@fnFreeTask:

; 595  :       {
; 596  :       // TraceLineS( "Freeing a page", "" );
; 597  :          while ( lpDataHeader->hNextDataHeader )

	mov	edx, DWORD PTR _lpDataHeader$1[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN6@fnFreeTask

; 598  :             lpDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );

	mov	eax, DWORD PTR _lpDataHeader$1[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$1[ebp], eax
	jmp	SHORT $LN2@fnFreeTask
$LN6@fnFreeTask:

; 599  : 
; 600  :          for ( ; ; )
; 601  :          {
; 602  :             if ( lpDataHeader->lNextDataHandle )

	mov	edx, DWORD PTR _lpDataHeader$1[ebp]
	cmp	DWORD PTR [edx+34], 0
	je	SHORT $LN10@fnFreeTask

; 603  :             {
; 604  : #if 0
; 605  :                if ( g_bServerMode )
; 606  :                   SysFree( (zPVOID) lpDataHeader->lNextDataHandle );
; 607  :                else
; 608  : #endif
; 609  :                   fnFreeSharedMemory( lpTask, lpDataHeader->lNextDataHandle );

	mov	eax, DWORD PTR _lpDataHeader$1[ebp]
	mov	ecx, DWORD PTR [eax+34]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFreeSharedMemory@8

; 610  : 
; 611  :                lpDataHeader->lNextDataHandle = 0;

	mov	eax, DWORD PTR _lpDataHeader$1[ebp]
	mov	DWORD PTR [eax+34], 0
$LN10@fnFreeTask:

; 612  :             }
; 613  : 
; 614  :             lpDataHeader = zGETPTR( lpDataHeader->hPrevDataHeader );

	mov	ecx, DWORD PTR _lpDataHeader$1[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataHeader$1[ebp], eax

; 615  :             if ( lpDataHeader == 0 )

	cmp	DWORD PTR _lpDataHeader$1[ebp], 0
	jne	SHORT $LN11@fnFreeTask

; 616  :                break;

	jmp	SHORT $LN9@fnFreeTask
$LN11@fnFreeTask:

; 617  :          }

	jmp	SHORT $LN6@fnFreeTask
$LN9@fnFreeTask:

; 618  :       }
; 619  : 
; 620  :       if ( lpTask->hFirstDataHandle )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+52], 0
	je	SHORT $LN12@fnFreeTask

; 621  :       {
; 622  : #if 0
; 623  :          if ( g_bServerMode )
; 624  :             SysFree( (zPVOID) lpTask->hFirstDataHandle );
; 625  :          else
; 626  : #endif
; 627  :             fnFreeSharedMemory( lpTask, lpTask->hFirstDataHandle );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnFreeSharedMemory@8

; 628  : 
; 629  :          lpTask->hFirstDataHandle = 0;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+52], 0
$LN12@fnFreeTask:

; 630  :       }
; 631  : 
; 632  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnFreeTask
$LN8@fnFreeTask:

; 633  :    }
; 634  : 
; 635  :    return( -1 );

	or	eax, -1
$LN1@fnFreeTask:

; 636  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnFreeTaskDataspace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpDropApp$ = -28					; size = 4
_lpView$1 = -24						; size = 4
_hSubtask$ = -20					; size = 4
_lpViewName$ = -16					; size = 4
_lpApp$ = -12						; size = 4
_vSubtask$ = -8						; size = 4
_lpSearchSubtask$2 = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpSubtask$ = 12					; size = 4
_nCleanup$ = 16						; size = 2
_fnDropSubtask PROC

; 2937 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2938 :    LPAPP       lpApp;
; 2939 :    LPAPP       lpDropApp;
; 2940 :    LPVIEWNAME  lpViewName;
; 2941 :    zVIEW       vSubtask;
; 2942 :    LPSUBTASK   hSubtask = zGETHNDL( lpSubtask );

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hSubtask$[ebp], eax

; 2943 : 
; 2944 :    // Get application for subtask
; 2945 :    lpApp = zGETPTR( lpSubtask->hApp );

	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 2946 :    if ( nCleanup == 2 )

	movsx	eax, WORD PTR _nCleanup$[ebp]
	cmp	eax, 2
	jne	SHORT $LN6@fnDropSubt

; 2947 :       lpDropApp = lpApp;  // drop non-named non-locked views for this subtask

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	DWORD PTR _lpDropApp$[ebp], ecx
	jmp	SHORT $LN7@fnDropSubt
$LN6@fnDropSubt:

; 2948 :    else
; 2949 :       lpDropApp = (LPAPP) -1;  // drop all non-named non-locked views

	mov	DWORD PTR _lpDropApp$[ebp], -1
$LN7@fnDropSubt:

; 2950 : 
; 2951 :    // NULL out the subtask pointer in the subtask view so fnDropView
; 2952 :    // will remove the view from the task.  Also unlock the view...
; 2953 :    vSubtask = zGETPTR( lpSubtask->hSubtaskView );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vSubtask$[ebp], eax

; 2954 :    vSubtask->hSubtask = 0;

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 2955 :    vSubtask->bViewLocked = 0;

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+30]
	and	eax, -33				; ffffffdfH
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2956 :    fnDropView( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_fnDropView@4
$LN2@fnDropSubt:

; 2957 : 
; 2958 :    // Drop all the view names chained to the subtask.
; 2959 :    while ( lpSubtask->hFirstViewName )

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN3@fnDropSubt

; 2960 :    {
; 2961 :       zVIEW lpView;
; 2962 : 
; 2963 :       lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2964 : 
; 2965 :       // Unchain the current view name.
; 2966 :       lpSubtask->hFirstViewName = lpViewName->hNextViewName;

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	mov	DWORD PTR [eax+18], edx

; 2967 : 
; 2968 :       // Decrement the name count in the View referenced by the ViewName.
; 2969 :       lpView = zGETPTR( lpViewName->hView );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$1[ebp], eax

; 2970 :       lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$1[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$1[ebp]
	mov	WORD PTR [ecx+22], ax

; 2971 : 
; 2972 :       // Free up storage for name string and the ViewName itself.
; 2973 :       fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 2974 :    }

	jmp	SHORT $LN2@fnDropSubt
$LN3@fnDropSubt:

; 2975 : 
; 2976 :    // We're about to unchain a few things (views, subtasks, etc.).  We have
; 2977 :    // to put this in a mutex so that other tasks won't try to delete an
; 2978 :    // application while we are unchaining.
; 2979 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 2980 : 
; 2981 : //
; 2982 : // NOTE: New parameter, nCleanup, used in view cleanup. When set to a
; 2983 : //       non-zero value, processing occurs as we did before this parameter
; 2984 : //       addition, that is, for the task associated with the subtask, we
; 2985 : //       drop ALL views that are NOT NAMED or are NOT LOCKED.  Specifying
; 2986 : //       a zero value will bypass this 'garbage' collection.
; 2987 : //       Note: nCleanup == 1 means drop all non-named non-locked views,
; 2988 : //       and nCleanup == 2 means drop only non-named non-locked views
; 2989 : //       associated with the subtask being dropped.
; 2990 : //
; 2991 :    if ( nCleanup > 0 )

	movsx	eax, WORD PTR _nCleanup$[ebp]
	test	eax, eax
	jle	SHORT $LN8@fnDropSubt

; 2992 :       fnGarbageCollectViews( zGETPTR( lpSubtask->hTask ), lpDropApp );

	mov	ecx, DWORD PTR _lpDropApp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGarbageCollectViews
	add	esp, 8
$LN8@fnDropSubt:

; 2993 : 
; 2994 :    // Unchain the subtask from the task.
; 2995 :    if ( lpTask->hFirstSubtask == hSubtask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	cmp	edx, DWORD PTR _hSubtask$[ebp]
	jne	SHORT $LN9@fnDropSubt

; 2996 :    {
; 2997 :       lpTask->hFirstSubtask = lpSubtask->hNextSubtask;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+6], edx

; 2998 :    }

	jmp	SHORT $LN10@fnDropSubt
$LN9@fnDropSubt:

; 2999 :    else
; 3000 :    {
; 3001 :       LPSUBTASK lpSearchSubtask;
; 3002 : 
; 3003 :       lpSearchSubtask = zGETPTR( lpTask->hFirstSubtask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchSubtask$2[ebp], eax
$LN4@fnDropSubt:

; 3004 :       while ( lpSearchSubtask->hNextSubtask != hSubtask )

	mov	edx, DWORD PTR _lpSearchSubtask$2[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hSubtask$[ebp]
	je	SHORT $LN5@fnDropSubt

; 3005 :          lpSearchSubtask = zGETPTR( lpSearchSubtask->hNextSubtask );

	mov	ecx, DWORD PTR _lpSearchSubtask$2[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchSubtask$2[ebp], eax
	jmp	SHORT $LN4@fnDropSubt
$LN5@fnDropSubt:

; 3006 : 
; 3007 :       if ( lpSearchSubtask->hNextSubtask == hSubtask )

	mov	eax, DWORD PTR _lpSearchSubtask$2[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hSubtask$[ebp]
	jne	SHORT $LN10@fnDropSubt

; 3008 :          lpSearchSubtask->hNextSubtask = lpSubtask->hNextSubtask;

	mov	edx, DWORD PTR _lpSearchSubtask$2[ebp]
	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx
$LN10@fnDropSubt:

; 3009 :    }
; 3010 : 
; 3011 :    lpSubtask = (LPSUBTASK) fnFreeDataspace( lpSubtask );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 3012 : 
; 3013 :    // If there is an application for the subtask and the application does
; 3014 :    // not match the startup application for the task, issue a delete for
; 3015 :    // the application.
; 3016 :    if ( nCleanup >= 0 && lpApp && lpApp != zGETPTR( lpTask->hApp ) )

	movsx	eax, WORD PTR _nCleanup$[ebp]
	test	eax, eax
	jl	SHORT $LN12@fnDropSubt
	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN12@fnDropSubt
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpApp$[ebp], eax
	je	SHORT $LN12@fnDropSubt

; 3017 :    {
; 3018 :       fnDeleteApp( lpApp );

	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnDeleteApp
	add	esp, 4
$LN12@fnDropSubt:

; 3019 :    }
; 3020 : 
; 3021 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 3022 : 
; 3023 :    return( 0 );

	xor	eax, eax

; 3024 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropSubtask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_hView$ = -16						; size = 4
_hSubtask$ = -12					; size = 4
_lpSubtask$ = -8					; size = 4
_lpView$ = -4						; size = 4
_lpTask$ = 8						; size = 4
_lpApp$ = 12						; size = 4
_fnCreateSubtask PROC

; 2716 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2717 :    LPSUBTASK lpSubtask;
; 2718 :    zVIEW     lpView;
; 2719 :    zPVOID    hView;
; 2720 :    zPVOID    hSubtask;
; 2721 : 
; 2722 :    // Return if application task is invalid.
; 2723 :    if ( lpTask == 0 || lpTask->nTableID != iTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN3@fnCreateSu
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10006				; 00002716H
	je	SHORT $LN2@fnCreateSu
$LN3@fnCreateSu:

; 2724 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnCreateSu
$LN2@fnCreateSu:

; 2725 : 
; 2726 :    // Create an application subtask.
; 2727 :    // Allocate an application task record.
; 2728 :    hView = fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,

	push	10021					; 00002725H
	push	0
	push	1
	push	38					; 00000026H
	mov	edx, DWORD PTR _g_hAnchorBlock
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hView$[ebp], eax

; 2729 :                              sizeof( ViewRecord ), 1, 0, iView );
; 2730 :    lpView = zGETPTR( hView );

	mov	eax, DWORD PTR _hView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 2731 :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	$LN4@fnCreateSu

; 2732 :    {
; 2733 :       hSubtask = fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,

	push	10010					; 0000271aH
	push	0
	push	1
	push	22					; 00000016H
	mov	ecx, DWORD PTR _g_hAnchorBlock
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hSubtask$[ebp], eax

; 2734 :                                    sizeof( SubtaskRecord ), 1, 0, iSubtask );
; 2735 :       lpSubtask = zGETPTR( hSubtask );

	mov	edx, DWORD PTR _hSubtask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 2736 : 
; 2737 :       // If Allocate was successful, chain to task.
; 2738 :       if ( lpSubtask )

	cmp	DWORD PTR _lpSubtask$[ebp], 0
	je	SHORT $LN5@fnCreateSu

; 2739 :       {
; 2740 :          lpView->hSubtask = hSubtask;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR _hSubtask$[ebp]
	mov	DWORD PTR [eax+18], ecx

; 2741 :          lpView->bViewLocked = TRUE; // automatically lock subtask views

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 2742 :          lpView->hTask = zGETHNDL( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 2743 :          lpView->hNextView = lpTask->hFirstView;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	mov	DWORD PTR [edx+2], ecx

; 2744 : 
; 2745 :          lpSubtask->hNextSubtask = lpTask->hFirstSubtask;

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+2], ecx

; 2746 :          lpSubtask->hTask = lpView->hTask; // = zGETHNDL( lpTask );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+6], ecx

; 2747 :          lpSubtask->hApp = zGETHNDL( lpApp );

	mov	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 2748 :          lpSubtask->hSubtaskView = hView;

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR _hView$[ebp]
	mov	DWORD PTR [edx+14], eax

; 2749 : 
; 2750 :          lpTask->hFirstSubtask = hSubtask;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hSubtask$[ebp]
	mov	DWORD PTR [ecx+6], edx

; 2751 :          lpTask->hFirstView    = hView;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _hView$[ebp]
	mov	DWORD PTR [eax+106], ecx

; 2752 :       // TraceLine( "CreateSubtask from task: 0x%08x   app: 0x%08x %s",
; 2753 :       //            lpView->hTask, lpSubtask->hApp, lpApp ? lpApp->szName : "" );
; 2754 :       }

	jmp	SHORT $LN4@fnCreateSu
$LN5@fnCreateSu:

; 2755 :       else
; 2756 :       {
; 2757 :          fnFreeDataspace( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 2758 :          lpView = 0;

	mov	DWORD PTR _lpView$[ebp], 0
$LN4@fnCreateSu:

; 2759 :       }
; 2760 :    }
; 2761 : 
; 2762 :    return( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
$LN1@fnCreateSu:

; 2763 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCreateSubtask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpFirstTask$1 = -108					; size = 4
_hTask$ = -104						; size = 4
_lpTask$ = -100						; size = 4
_szMessage$ = -96					; size = 60
_szTaskName$ = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_lSystemInstance$ = 8					; size = 4
_hMainWnd$ = 12						; size = 4
_lAppOE_Msg$ = 16					; size = 4
_cpcTaskTitle$ = 20					; size = 4
_fnCreateTask PROC

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 457  : // LPPROCESS hProcess;
; 458  :    LPTASK    lpTask;
; 459  :    zPVOID    hTask;
; 460  :    zCHAR     szTaskName[ 32 ];
; 461  :    zCHAR     szMessage[ 60 ];
; 462  : 
; 463  :    // Allocate an application task record.
; 464  :    hTask = fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,

	push	10006					; 00002716H
	push	0
	push	1
	push	447					; 000001bfH
	mov	eax, DWORD PTR _g_hAnchorBlock
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hTask$[ebp], eax

; 465  :                              sizeof( TaskRecord ), 1, 0, iTask );
; 466  :    lpTask = zGETPTR( hTask );

	mov	ecx, DWORD PTR _hTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 467  : 
; 468  :    // If a task record could not be acquired, return.
; 469  :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@fnCreateTa

; 470  :       return( 0 );  // return Failure

	xor	eax, eax
	jmp	$LN1@fnCreateTa
$LN2@fnCreateTa:

; 471  : 
; 472  :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 473  : 
; 474  :    // Add Application Task to Anchor Chain of tasks.
; 475  :    lpTask->lHab             = lSystemInstance;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _lSystemInstance$[ebp]
	mov	DWORD PTR [edx+14], eax

; 476  :    lpTask->hMainWnd         = hMainWnd;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _hMainWnd$[ebp]
	mov	DWORD PTR [ecx+22], edx

; 477  :    lpTask->uAppOE_Msg       = (zUSHORT) lAppOE_Msg;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	cx, WORD PTR _lAppOE_Msg$[ebp]
	mov	WORD PTR [eax+26], cx

; 478  : // lpTask->lTaskID          = (zLONG) hTask; // SysGetProcessID( );
; 479  :    lpTask->bAudit           = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 1
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 480  :    lpTask->bDebug           = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 2
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 481  :    lpTask->bTrace           = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 482  :    lpTask->nOperIdx         = -1;

	or	edx, -1
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [eax+58], dx

; 483  : 
; 484  :    // Initialize szTaskName
; 485  :    zsprintf( szTaskName, "App Task 0x%08x", hTask );

	mov	ecx, DWORD PTR _hTask$[ebp]
	push	ecx
	push	OFFSET $SG13466
	lea	edx, DWORD PTR _szTaskName$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 486  : 
; 487  :    // Task is disabled until we finish initializing it.
; 488  :    lpTask->bDisable         = TRUE;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	or	ecx, 8
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 489  : 
; 490  :    // Chain Task to main anchor block BEFORE allocating dataspace.
; 491  :    fnStartBrowseOfTaskList( hTask, TRUE ); // Get a 'write' lock on the task list.

	push	1
	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 492  :    lpTask->hNextTask = AnchorBlock->hFirstTask;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+130]
	mov	DWORD PTR [ecx+2], eax

; 493  :    AnchorBlock->hFirstTask = hTask;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [ecx+130], edx

; 494  :    fnEndBrowseOfTaskList( TRUE );

	push	1
	call	_fnEndBrowseOfTaskList@4

; 495  : 
; 496  :    // Create a dataspace for the task unless it is the main task.
; 497  :    zstrcpy( szMessage, "(tm) "); // prefix message

	push	OFFSET $SG13467
	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 498  :    if ( AnchorBlock->hMainTask == 0 ||

	mov	ecx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [ecx+106], 0
	je	SHORT $LN4@fnCreateTa
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	cmp	eax, DWORD PTR _hTask$[ebp]
	jne	SHORT $LN3@fnCreateTa
$LN4@fnCreateTa:

; 499  :         AnchorBlock->hMainTask == hTask )
; 500  :    {
; 501  :       zstrcat( szMessage, "Main " );

	push	OFFSET $SG13470
	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN3@fnCreateTa:

; 502  :    }
; 503  : 
; 504  :    zstrcat( szMessage, szTaskName );

	lea	edx, DWORD PTR _szTaskName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 505  :    zstrncpy( lpTask->szTaskTitle, cpcTaskTitle, 127 );

	push	127					; 0000007fH
	mov	ecx, DWORD PTR _cpcTaskTitle$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 311				; 00000137H
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 506  :    lpTask->szTaskTitle[ 127 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 127
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	BYTE PTR [edx+ecx+311], 0

; 507  : 
; 508  : #if 0
; 509  :    hProcess = fnFindProcess( 0 );
; 510  :    if ( hProcess == 0 )
; 511  :       hProcess = fnCreateProcess( hMainWnd, lAppOE_Msg );
; 512  : 
; 513  :    lpTask->hProcess = hProcess;
; 514  : #endif
; 515  : 
; 516  :    lpTask->hFirstDataHandle =

	push	0
	push	4000000					; 003d0900H
	lea	eax, DWORD PTR _szTaskName$[ebp]
	push	eax
	push	10006					; 00002716H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 94					; 0000005eH
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnInitializeDataspace
	add	esp, 24					; 00000018H
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+52], eax

; 517  :       fnInitializeDataspace( lpTask, (zCOREMEM) &lpTask->hFirstDataHeader,
; 518  :                              iTask, szTaskName, zSHARED_ALLOC, 0 );
; 519  : 
; 520  :    // Reset pointer to handle.
; 521  :    lpTask->hFirstDataHeader = (LPDATAHEADER) lpTask->hFirstDataHandle;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+94], ecx

; 522  : 
; 523  :    if ( AnchorBlock->hMainTask == 0 )

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+106], 0
	jne	SHORT $LN5@fnCreateTa

; 524  :    {
; 525  :       AnchorBlock->hMainTask = hTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [eax+106], ecx

; 526  :       AnchorBlock->hMainFirstDataHeader = lpTask->hFirstDataHeader;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	mov	DWORD PTR [edx+114], ecx
$LN5@fnCreateTa:

; 527  :    }
; 528  : 
; 529  :    fnCreateSubtask( lpTask, zGETPTR( lpTask->hApp ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnCreateSubtask
	add	esp, 8

; 530  : 
; 531  :    // If Dataspace initialization failed, delete the task and
; 532  :    // return a bad RC if the task is not the Main task.
; 533  :    if ( AnchorBlock->hMainTask &&
; 534  :         AnchorBlock->hMainTask != hTask &&

	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+106], 0
	je	SHORT $LN6@fnCreateTa
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	cmp	ecx, DWORD PTR _hTask$[ebp]
	je	SHORT $LN6@fnCreateTa
	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+94], 0
	jne	SHORT $LN6@fnCreateTa

; 535  :         lpTask->hFirstDataHeader == 0 )
; 536  :    {
; 537  :       LPTASK lpFirstTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstTask$1[ebp], eax

; 538  : 
; 539  :       // Unchain new task created.
; 540  :       AnchorBlock->hFirstTask = lpFirstTask->hNextTask;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lpFirstTask$1[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+130], ecx

; 541  :       fnFreeDataspace( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 542  :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 543  :       return( 0 );  // return Failure

	xor	eax, eax
	jmp	SHORT $LN1@fnCreateTa
$LN6@fnCreateTa:

; 544  :    }
; 545  : 
; 546  :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN7@fnCreateTa

; 547  :       TraceLineS( szMessage, " created" );

	push	OFFSET $SG13474
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	_TraceLineS@8
$LN7@fnCreateTa:

; 548  : 
; 549  :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 550  :    return( lpTask );  // return Success

	mov	eax, DWORD PTR _lpTask$[ebp]
$LN1@fnCreateTa:

; 551  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnCreateTask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_hProcess$ = -4						; size = 4
_hMainWnd$ = 8						; size = 4
_lAppOE_Msg$ = 12					; size = 4
_fnCreateProcess PROC

; 402  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 403  :    LPPROCESS hProcess = 0;

	mov	DWORD PTR _hProcess$[ebp], 0

; 404  : 
; 405  : #if 0
; 406  :    LPPROCESS lpProcess;
; 407  : 
; 408  :    // Allocate a process record.
; 409  :    hProcess = fnAllocDataspace( (LPDATAHEADER) g_hAnchorBlock,
; 410  :                                 sizeof( ProcessRecord ), 1, 0, iProcess );
; 411  :    // If a process record could not be acquired, return.
; 412  :    if ( hProcess == 0 )
; 413  :       return( 0 );  // return Failure
; 414  : 
; 415  :    lpProcess = zGETPTR( hProcess );
; 416  : 
; 417  :    // Chain Process to main anchor block.
; 418  :    lpProcess->hNextProcess = AnchorBlock->hFirstProcess;
; 419  :    AnchorBlock->hFirstProcess = hProcess;
; 420  : 
; 421  :    lpProcess->lProcessID    = SysGetProcessID( 0 );
; 422  : #endif
; 423  : 
; 424  :    return( hProcess );

	mov	eax, DWORD PTR _hProcess$[ebp]

; 425  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCreateProcess ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_fnCloseTaskNetworkModules@4 PROC

; 1427 : {

	push	ebp
	mov	ebp, esp

; 1428 : #if 0
; 1429 :    LPNETWORK lpNetwork;
; 1430 : 
; 1431 :    // Free any libraries for the networks.
; 1432 :    lpNetwork = zGETPTR( lpTask->hFirstNetwork );
; 1433 :    while ( lpNetwork )
; 1434 :    {
; 1435 :       // If we have a server directory function, use it.
; 1436 :       if ( lpNetwork->hServDirLib && lpNetwork->lpfnServDirGetAddr )
; 1437 :       {
; 1438 :          fnSysFreeLibrary( lpTask, zGETPTR( lpNetwork->hServDirLib ), FALSE );
; 1439 :          lpNetwork->hServDirLib = 0;
; 1440 :       }
; 1441 : 
; 1442 :       lpNetwork = zGETPTR( lpNetwork->hNextNetwork );
; 1443 :    }
; 1444 : #endif
; 1445 : }

	pop	ebp
	ret	4
_fnCloseTaskNetworkModules@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpOpenFile$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_fnCloseTaskOpenFiles@4 PROC

; 1449 : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN2@fnCloseTas:

; 1450 :    LPOPENFILE lpOpenFile;
; 1451 : 
; 1452 :    while ( lpTask->hFirstOpenFile )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+118], 0
	je	SHORT $LN1@fnCloseTas

; 1453 :    {
; 1454 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+118]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 1455 : 
; 1456 :       if ( fnSysCloseFile( lpTask, lpOpenFile->lFileHandle, lpTask ) < 0 )

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpOpenFile$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysCloseFile@12
	test	eax, eax
	jge	SHORT $LN4@fnCloseTas

; 1457 :       {
; 1458 :          TraceLineS( "(tm) DeleteTask error closing file", "" );

	push	OFFSET $SG13699
	push	OFFSET $SG13700
	call	_TraceLineS@8

; 1459 :          break;  // some kind of problem has occurred ... punt!

	jmp	SHORT $LN1@fnCloseTas
$LN4@fnCloseTas:

; 1460 :       }
; 1461 :    }

	jmp	SHORT $LN2@fnCloseTas
$LN1@fnCloseTas:

; 1462 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnCloseTaskOpenFiles@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lProcessID$ = -20					; size = 4
_lpMutexNext$1 = -16					; size = 4
_lpMainTask$ = -12					; size = 4
_lpMutexPrev$2 = -8					; size = 4
_lpMutex$ = -4						; size = 4
_lpTask$ = 8						; size = 4
_fnDropTaskMutexes@4 PROC

; 1505 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1506 :    LPTASK   lpMainTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$[ebp], eax

; 1507 :    LPMUTEX  lpMutex;
; 1508 :    zLONG    lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 1509 : 
; 1510 : #if 0  // I don't know why this is deprecated ... dks 2004.12.27
; 1511 : 
; 1512 :    // Drop all task mutexes.  Note that we don't care about freeing memory
; 1513 :    // taken up by mutex structures because we'll soon free it with the task.
; 1514 : 
; 1515 :    if ( AnchorBlock->hFirstMutex )
; 1516 :    {
; 1517 :       LPMUTEXTASK lpMutexTaskPrev;
; 1518 :       LPMUTEXTASK hMutexTaskNext;
; 1519 :       LPMUTEXTASK lpMutexTask;
; 1520 : 
; 1521 :       // Set lock to make sure nobody's changing the mutex chains.
; 1522 :       zLOCK_MUTEX( zMUTEX_MUTEX );
; 1523 : 
; 1524 :       // Pass through all mutexes.
; 1525 :       lpMutex = zGETPTR( AnchorBlock->hFirstMutex );
; 1526 :       while ( lpMutex )
; 1527 :       {
; 1528 :          lpMutexTaskPrev = 0;
; 1529 : 
; 1530 :          // Try finding task mutexes.
; 1531 :          lpMutexTask = zGETPTR( lpMutex->hFirstMutexTask );
; 1532 :          while ( lpMutexTask )
; 1533 :          {
; 1534 :             hMutexTaskNext = lpMutexTask->hNextMutexTask;
; 1535 :             if ( lpMutexTask->hTask == hTask )            // in the correct task
; 1536 :             {
; 1537 :                if ( lpMutexTaskPrev )
; 1538 :                   lpMutexTaskPrev->hNextMutexTask = hMutexTaskNext;
; 1539 :                else
; 1540 :                   lpMutex->hFirstMutexTask = hMutexTaskNext;
; 1541 : 
; 1542 :                if ( lpMutexTask->hMutexOS )
; 1543 :                {
; 1544 :                   if ( SysMutexClose( lpMutexTask->hMutexOS ) == 0 )
; 1545 :                      TraceLineS( "Error destroying mutex: ", lpMutex->szName );
; 1546 :                }
; 1547 : 
; 1548 :                fnFreeDataspace( lpMutexTask );
; 1549 :             }
; 1550 :             else
; 1551 :             {
; 1552 :                lpMutexTaskPrev = lpMutexTask;
; 1553 :             }
; 1554 : 
; 1555 :             lpMutexTask = zGETPTR( hMutexTaskNext );
; 1556 :          }
; 1557 : 
; 1558 :          lpMutex = zGETPTR( lpMutex->hNextMutex );
; 1559 :       }
; 1560 : 
; 1561 :       zUNLOCK_MUTEX( zMUTEX_MUTEX );
; 1562 :    }
; 1563 : 
; 1564 : #else
; 1565 : 
; 1566 :    zLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysLockCoreMutex@4

; 1567 : 
; 1568 :    // Drop all task mutexes.  Note that we don't care about freeing memory
; 1569 :    // taken up by mutex structures because we'll soon free it with the task.
; 1570 :    // Ah shucks ... go ahead and free it just to make me happy. // dks 2006.02.24
; 1571 :    if ( lpTask->hFirstMutex )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+150], 0
	je	SHORT $LN7@fnDropTask
$LN2@fnDropTask:

; 1572 :    {
; 1573 :       while ( (lpMutex = zGETPTR( lpTask->hFirstMutex )) != 0 )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+150]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	SHORT $LN7@fnDropTask

; 1574 :       {
; 1575 :          if ( lpMutex->nLockCount )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, WORD PTR [edx+75]
	test	eax, eax
	je	SHORT $LN8@fnDropTask

; 1576 :          {
; 1577 :             // First set nLockCount to 1 so that the next call to
; 1578 :             // fnSysMutexUnlock actually unlocks the mutex.
; 1579 :             lpMutex->nLockCount = 1;

	mov	ecx, 1
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [edx+75], cx

; 1580 :             fnSysMutexUnlock( lpTask, lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMutexUnlock@8
$LN8@fnDropTask:

; 1581 :          }
; 1582 : 
; 1583 :          fnSysMutexDestroy( lpTask, lpMutex );

	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMutexDestroy@8

; 1584 : 
; 1585 :          lpTask->hFirstMutex = lpMutex->hNextMutex;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+150], eax

; 1586 :          fnFreeDataspace( lpMutex );

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 1587 :       }

	jmp	SHORT $LN2@fnDropTask
$LN7@fnDropTask:

; 1588 :    }
; 1589 : 
; 1590 :    // We only dump the system mutexes when we are destroying the main task.
; 1591 :    // The system mutexes are only used to track the lLockedTaskID.
; 1592 :    if ( lpTask == lpMainTask )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	edx, DWORD PTR _lpMainTask$[ebp]
	jne	$LN9@fnDropTask

; 1593 :    {
; 1594 :       LPMUTEX  lpMutexPrev = 0;

	mov	DWORD PTR _lpMutexPrev$2[ebp], 0

; 1595 :       LPMUTEX  lpMutexNext;
; 1596 : 
; 1597 :       // We're dropping the main task so let's dump all the system mutexes.
; 1598 :       for ( lpMutex = zGETPTR( AnchorBlock->hFirstSysMutex );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2519]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutex$[ebp], eax
	jmp	SHORT $LN6@fnDropTask
$LN4@fnDropTask:

; 1600 :             lpMutex = lpMutexNext )

	mov	edx, DWORD PTR _lpMutexNext$1[ebp]
	mov	DWORD PTR _lpMutex$[ebp], edx
$LN6@fnDropTask:

; 1599 :             lpMutex;

	cmp	DWORD PTR _lpMutex$[ebp], 0
	je	$LN9@fnDropTask

; 1601 :       {
; 1602 :          lpMutexNext = zGETPTR( lpMutex->hNextMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMutexNext$1[ebp], eax

; 1603 :          if ( lpMutex->lProcessID != lProcessID )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	eax, DWORD PTR [edx+89]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	je	SHORT $LN10@fnDropTask

; 1604 :          {
; 1605 :             lpMutexPrev = lpMutex;

	mov	ecx, DWORD PTR _lpMutex$[ebp]
	mov	DWORD PTR _lpMutexPrev$2[ebp], ecx

; 1606 :             continue;

	jmp	SHORT $LN4@fnDropTask
$LN10@fnDropTask:

; 1607 :          }
; 1608 : 
; 1609 :          if ( lpMutex->nLockCount )

	mov	edx, DWORD PTR _lpMutex$[ebp]
	movsx	eax, WORD PTR [edx+75]
	test	eax, eax
	je	SHORT $LN11@fnDropTask

; 1610 :          {
; 1611 :             // First set nLockCount to 1 so that the next call to
; 1612 :             // fnSysMutexUnlock actually unlocks the mutex.
; 1613 :             lpMutex->nLockCount = 1;

	mov	ecx, 1
	mov	edx, DWORD PTR _lpMutex$[ebp]
	mov	WORD PTR [edx+75], cx

; 1614 :             fnSysMutexUnlock( lpTask, lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMutexUnlock@8
$LN11@fnDropTask:

; 1615 :          }
; 1616 : 
; 1617 :          if ( lpMutexPrev )

	cmp	DWORD PTR _lpMutexPrev$2[ebp], 0
	je	SHORT $LN12@fnDropTask

; 1618 :             lpMutexPrev->hNextMutex = lpMutex->hNextMutex;

	mov	edx, DWORD PTR _lpMutexPrev$2[ebp]
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx
	jmp	SHORT $LN13@fnDropTask
$LN12@fnDropTask:

; 1619 :          else
; 1620 :             AnchorBlock->hFirstSysMutex = lpMutex->hNextMutex;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _lpMutex$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2519], ecx
$LN13@fnDropTask:

; 1621 : 
; 1622 :          // Destroy the mutex--pass 0 for lpTask to indicate that we're
; 1623 :          // destroying system mutexes.
; 1624 :          fnSysMutexDestroy( 0, lpMutex );  // this call will do nothing

	mov	edx, DWORD PTR _lpMutex$[ebp]
	push	edx
	push	0
	call	_fnSysMutexDestroy@8

; 1625 :          fnFreeDataspace( lpMutex );

	mov	eax, DWORD PTR _lpMutex$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1626 :       }

	jmp	$LN4@fnDropTask
$LN9@fnDropTask:

; 1627 :    }
; 1628 : 
; 1629 :    zUNLOCK_MUTEX( zMUTEX_MUTEX );

	push	7
	call	_fnSysUnlockCoreMutex@4

; 1630 : 
; 1631 : #endif
; 1632 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnDropTaskMutexes@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lProcessID$ = -20					; size = 4
_hTask$ = -16						; size = 4
_lpLibraryNext$ = -12					; size = 4
_lRC$ = -8						; size = 4
_lpLibrary$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_fnFreeTaskModules@4 PROC

; 1466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 1467 :    LPLIBRARY lpLibrary;
; 1468 :    LPLIBRARY lpLibraryNext;
; 1469 :    LPTASK    hTask = zGETHNDL( lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hTask$[ebp], eax

; 1470 :    zLONG     lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax
$LN2@fnFreeTask:

; 1471 :    zLONG     lRC;
; 1472 : 
; 1473 :    // Free all modules loaded for this process.
; 1474 :    while ( lpTask->hFirstLibrary )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+122], 0
	je	$LN1@fnFreeTask

; 1475 :    {
; 1476 :       lpLibrary = zGETPTR( lpTask->hFirstLibrary );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+122]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibrary$[ebp], eax
$LN4@fnFreeTask:

; 1477 :       while ( lpLibrary )

	cmp	DWORD PTR _lpLibrary$[ebp], 0
	je	SHORT $LN5@fnFreeTask
$LN8@fnFreeTask:

; 1478 :       {
; 1479 :          do
; 1480 :             lRC = fnSysFreeLibrary( lpTask, lpLibrary, TRUE );

	push	1
	mov	ecx, DWORD PTR _lpLibrary$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysFreeLibrary@12
	mov	DWORD PTR _lRC$[ebp], eax

; 1481 :          while ( lRC > 1 );  // account for multiple loads

	cmp	DWORD PTR _lRC$[ebp], 1
	jg	SHORT $LN8@fnFreeTask

; 1482 : 
; 1483 :          if ( lRC < 0 )

	cmp	DWORD PTR _lRC$[ebp], 0
	jge	SHORT $LN9@fnFreeTask

; 1484 :          {
; 1485 :             TraceLineS( "(tm) DeleteTask error freeing library", "" );

	push	OFFSET $SG13720
	push	OFFSET $SG13721
	call	_TraceLineS@8

; 1486 :             break;  // some kind of problem has occurred ... punt!

	jmp	SHORT $LN5@fnFreeTask
$LN9@fnFreeTask:

; 1487 :          }
; 1488 : 
; 1489 :          lpLibraryNext = zGETPTR( lpTask->hFirstLibrary );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+122]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLibraryNext$[ebp], eax

; 1490 :          if ( lpLibraryNext == lpLibrary )

	mov	edx, DWORD PTR _lpLibraryNext$[ebp]
	cmp	edx, DWORD PTR _lpLibrary$[ebp]
	jne	SHORT $LN10@fnFreeTask

; 1491 :          {
; 1492 :             fnSysMessageBox( lpTask, "Zeidon Library Error",

	push	1
	push	OFFSET $SG13723
	push	OFFSET $SG13724
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnSysMessageBox@16

; 1493 :                              "Error freeing library", 1 );
; 1494 :             TraceLineS( "(tm) DeleteTask error freeing library", "" );

	push	OFFSET $SG13725
	push	OFFSET $SG13726
	call	_TraceLineS@8

; 1495 :             break;  // some kind of problem has occurred ... punt!

	jmp	SHORT $LN5@fnFreeTask
$LN10@fnFreeTask:

; 1496 :          }
; 1497 : 
; 1498 :          lpLibrary = lpLibraryNext;

	mov	ecx, DWORD PTR _lpLibraryNext$[ebp]
	mov	DWORD PTR _lpLibrary$[ebp], ecx

; 1499 :       }

	jmp	SHORT $LN4@fnFreeTask
$LN5@fnFreeTask:

; 1500 :    }

	jmp	$LN2@fnFreeTask
$LN1@fnFreeTask:

; 1501 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnFreeTaskModules@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpNextTaskDomain$ = -16				; size = 4
_lProcessID$ = -12					; size = 4
tv80 = -8						; size = 4
_lpTaskDomain$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_fnDropTaskDomains@4 PROC

; 754  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 755  :    LPTASKDOMAIN lpTaskDomain = zGETPTR( lpTask->hFirstTaskDomain );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+126]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDomain$[ebp], eax

; 756  :    LPTASKDOMAIN lpNextTaskDomain;
; 757  :    zLONG        lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax
$LN2@fnDropTask:

; 758  : 
; 759  :    while ( lpTaskDomain )

	cmp	DWORD PTR _lpTaskDomain$[ebp], 0
	je	SHORT $LN1@fnDropTask

; 760  :    {
; 761  :       lpNextTaskDomain = zGETPTR( lpTaskDomain->hNextTaskDomainForTask );

	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextTaskDomain$[ebp], eax

; 762  :       if ( lProcessID = lpTaskDomain->lProcessID && fnDropTaskDomain( lpTask, lpTaskDomain ) < 0 )

	mov	ecx, DWORD PTR _lpTaskDomain$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN6@fnDropTask
	mov	edx, DWORD PTR _lpTaskDomain$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnDropTaskDomain
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN6@fnDropTask
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN7@fnDropTask
$LN6@fnDropTask:
	mov	DWORD PTR tv80[ebp], 0
$LN7@fnDropTask:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _lProcessID$[ebp], edx
	cmp	DWORD PTR _lProcessID$[ebp], 0
	je	SHORT $LN4@fnDropTask

; 763  :       {
; 764  :          TraceLineS( "(tm) DeleteTask error dropping task domain", "" );

	push	OFFSET $SG13533
	push	OFFSET $SG13534
	call	_TraceLineS@8

; 765  :          break;  // some kind of problem has occurred ... punt!

	jmp	SHORT $LN1@fnDropTask
$LN4@fnDropTask:

; 766  :       }
; 767  : 
; 768  :       lpTaskDomain = lpNextTaskDomain;

	mov	eax, DWORD PTR _lpNextTaskDomain$[ebp]
	mov	DWORD PTR _lpTaskDomain$[ebp], eax

; 769  :    }

	jmp	SHORT $LN2@fnDropTask
$LN1@fnDropTask:

; 770  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnDropTaskDomains@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_pGKOper$ = -40						; size = 4
_pDBOper$ = -36						; size = 4
_hTask$ = -32						; size = 4
_lpPtr$ = -28						; size = 4
_lProcessID$ = -24					; size = 4
_lpMainTask$ = -20					; size = 4
_vTask$ = -16						; size = 4
_lpTaskGKHandler$ = -12					; size = 4
_lpTaskDBHandler$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTask$ = 8						; size = 4
_fnDropTaskHandlers@4 PROC

; 1018 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1019 :    LPTASK          lpMainTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$[ebp], eax

; 1020 :    LPTASK          hTask = zGETHNDL( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hTask$[ebp], eax

; 1021 :    LPTASKDBHANDLER lpTaskDBHandler;
; 1022 :    LPTASKGKHANDLER lpTaskGKHandler;
; 1023 :    zPDBHOPER       pDBOper;
; 1024 :    zPGKHOPER       pGKOper;
; 1025 :    zPVOID          lpPtr;
; 1026 :    zVIEW           vTask;
; 1027 :    zSHORT          nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1028 :    zLONG           lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 1029 : 
; 1030 :    if ( lpTask == 0 || lpTask->hFirstView == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN7@fnDropTask
	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+106], 0
	jne	SHORT $LN6@fnDropTask
$LN7@fnDropTask:

; 1031 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDropTask
$LN6@fnDropTask:

; 1032 : 
; 1033 :    vTask = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vTask$[ebp], eax

; 1034 :    if ( lpTask != lpMainTask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	ecx, DWORD PTR _lpMainTask$[ebp]
	je	SHORT $LN8@fnDropTask

; 1035 :       SysMutexLock( vTask, "Zeidon DBH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG13653
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysMutexLock@16
$LN8@fnDropTask:

; 1036 : 
; 1037 :    lpTaskDBHandler = zGETPTR( lpTask->hFirstTaskDBHandler );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+134]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
$LN2@fnDropTask:

; 1038 :    while ( lpTaskDBHandler )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $LN3@fnDropTask

; 1039 :    {
; 1040 :       if ( lpTaskDBHandler->lProcessID == lProcessID )

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+22]
	cmp	eax, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN9@fnDropTask

; 1041 :       {
; 1042 :          lpPtr = lpTaskDBHandler->lpConnection;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR _lpPtr$[ebp], edx

; 1043 : 
; 1044 :          // Call DBHandler routine to terminate database processing.
; 1045 :          pDBOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _pDBOper$[ebp], ecx

; 1046 :          if ( (*pDBOper)( (zLONG) hTask, DBH_Term,
; 1047 :                           0, 0, 0, 0, vTask, &lpPtr ) < 0 )

	lea	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTask$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	8192					; 00002000H
	mov	ecx, DWORD PTR _hTask$[ebp]
	push	ecx
	call	DWORD PTR _pDBOper$[ebp]
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN9@fnDropTask

; 1048 :          {
; 1049 :             nRC = zCALL_ERROR;  // continue to try to drop handlers

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN9@fnDropTask:

; 1050 :          }
; 1051 :       }
; 1052 : 
; 1053 :       // Point to next item in the chain.
; 1054 :       lpTask->hFirstTaskDBHandler = lpTaskDBHandler->hNextTaskDBHandler;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+134], eax

; 1055 : 
; 1056 :       // Free the TaskDBHandler space.
; 1057 :       fnFreeDataspace( lpTaskDBHandler );

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 1058 : 
; 1059 :       lpTaskDBHandler = zGETPTR( lpTask->hFirstTaskDBHandler );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+134]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 1060 :    }

	jmp	SHORT $LN2@fnDropTask
$LN3@fnDropTask:

; 1061 : 
; 1062 :    if ( lpTask != lpMainTask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	ecx, DWORD PTR _lpMainTask$[ebp]
	je	SHORT $LN11@fnDropTask

; 1063 :    {
; 1064 :       SysMutexUnlock( vTask, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG13657
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysMutexUnlock@12

; 1065 :       SysMutexLock( vTask, "Zeidon GKH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG13658
	mov	eax, DWORD PTR _vTask$[ebp]
	push	eax
	call	_SysMutexLock@16
$LN11@fnDropTask:

; 1066 :    }
; 1067 : 
; 1068 :    lpTaskGKHandler = zGETPTR( lpTask->hFirstTaskGKHandler );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+138]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax
$LN4@fnDropTask:

; 1069 :    while ( lpTaskGKHandler )

	cmp	DWORD PTR _lpTaskGKHandler$[ebp], 0
	je	SHORT $LN5@fnDropTask

; 1070 :    {
; 1071 :       if ( lpTaskGKHandler->lProcessID == lProcessID )

	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	cmp	ecx, DWORD PTR _lProcessID$[ebp]
	jne	SHORT $LN12@fnDropTask

; 1072 :       {
; 1073 :          lpPtr = lpTaskGKHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 1074 : 
; 1075 :          // Call GKHandler routine to terminate database processing.
; 1076 :          pGKOper = lpTaskGKHandler->pfGKHandlerOper;

	mov	ecx, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _pGKOper$[ebp], edx

; 1077 :          if ( (*pGKOper)( DBH_Term, 0, 0, 0, 0 ) < 0 )

	push	0
	push	0
	push	0
	push	0
	push	8192					; 00002000H
	call	DWORD PTR _pGKOper$[ebp]
	cwde
	test	eax, eax
	jge	SHORT $LN12@fnDropTask

; 1078 :          {
; 1079 :             nRC = zCALL_ERROR;  // continue to try to drop handlers

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN12@fnDropTask:

; 1080 :          }
; 1081 :       }
; 1082 : 
; 1083 :       // Point to next item in the chain.
; 1084 :       lpTask->hFirstTaskGKHandler = lpTaskGKHandler->hNextTaskGKHandler;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _lpTaskGKHandler$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+138], ecx

; 1085 : 
; 1086 :       // Free the TaskGKHandler space.
; 1087 :       fnFreeDataspace( lpTaskGKHandler );

	mov	edx, DWORD PTR _lpTaskGKHandler$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1088 : 
; 1089 :       lpTaskGKHandler = zGETPTR( lpTask->hFirstTaskGKHandler );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+138]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskGKHandler$[ebp], eax

; 1090 :    }

	jmp	SHORT $LN4@fnDropTask
$LN5@fnDropTask:

; 1091 : 
; 1092 :    if ( lpTask != lpMainTask )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	edx, DWORD PTR _lpMainTask$[ebp]
	je	SHORT $LN14@fnDropTask

; 1093 :       SysMutexUnlock( vTask, "Zeidon GKH", 0 );

	push	0
	push	OFFSET $SG13662
	mov	eax, DWORD PTR _vTask$[ebp]
	push	eax
	call	_SysMutexUnlock@12
$LN14@fnDropTask:

; 1094 : 
; 1095 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnDropTask:

; 1096 : 
; 1097 : } // fnDropTaskHandlers

	mov	esp, ebp
	pop	ebp
	ret	4
_fnDropTaskHandlers@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_fnDropTaskOperations@4 PROC

; 926  : {

	push	ebp
	mov	ebp, esp
$LN2@fnDropTask:

; 927  :    while ( lpTask->hFirstTaskOperation )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+130], 0
	je	SHORT $LN1@fnDropTask

; 928  :    {
; 929  :       if ( fnDropTaskOperation( lpTask,
; 930  :                                 zGETPTR( lpTask->hFirstTaskOperation ) ) < 0 )  // blew on this line 2006.07.03 dks

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnDropTaskOperation@8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN4@fnDropTask

; 931  :       {
; 932  :          TraceLineS( "(tm) DeleteTask error dropping task operation", "" );

	push	OFFSET $SG13605
	push	OFFSET $SG13606
	call	_TraceLineS@8

; 933  :          break;  // some kind of problem has occurred ... punt!

	jmp	SHORT $LN1@fnDropTask
$LN4@fnDropTask:

; 934  :       }
; 935  :    }

	jmp	SHORT $LN2@fnDropTask
$LN1@fnDropTask:

; 936  : }

	pop	ebp
	ret	4
_fnDropTaskOperations@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_vDbhWork$ = -4076					; size = 4
_lpNextApp$ = -4072					; size = 4
_lpFirstViewCsr$1 = -4068				; size = 4
_lpFirstViewOI$2 = -4064				; size = 4
_lpNextView$3 = -4060					; size = 4
_lpFirstViewCsr$4 = -4056				; size = 4
_lProcessID$ = -4052					; size = 4
_lpMainTask$ = -4048					; size = 4
_lpViewOD$5 = -4044					; size = 4
_lpViewName$ = -4040					; size = 4
_bCurrentTask$ = -4033					; size = 1
_lpApp$ = -4032						; size = 4
_hTask$ = -4028						; size = 4
_lpPrevTask$ = -4024					; size = 4
_nDrops$6 = -4020					; size = 2
_nPasses$7 = -4016					; size = 2
_lpViewOI$ = -4012					; size = 4
_lpView$ = -4008					; size = 4
_szMsg$ = -4004						; size = 4000
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_DeleteTask@4 PROC

; 1920 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 4076				; 00000fecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1921 : // LPSUBTASK  hFirstSubtask;
; 1922 :    LPTASK     hTask;
; 1923 :    LPTASK     lpPrevTask;
; 1924 :    LPTASK     lpMainTask;
; 1925 :    LPVIEWNAME lpViewName;
; 1926 :    LPAPP      lpNextApp;
; 1927 :    zCHAR      szMsg[ 4000 ];
; 1928 :    LPAPP      lpApp;
; 1929 :    LPVIEWOI   lpViewOI;
; 1930 : // LPOPENFILE lpOpenFileNext;
; 1931 :    zVIEW      lpView;
; 1932 :    zVIEW      vDbhWork;
; 1933 :    zBOOL      bCurrentTask;
; 1934 :    zLONG      lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 1935 : 
; 1936 :    // Make sure task is not null and is valid.
; 1937 :    if ( lpTask == 0 || lpTask->nTableID != iTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN26@DeleteTask
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10006				; 00002716H
	je	SHORT $LN25@DeleteTask
$LN26@DeleteTask:

; 1938 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DeleteTask
$LN25@DeleteTask:

; 1939 : 
; 1940 :    // Check to see if the task is being shutdown already by someone else.
; 1941 :    // If so then we'll get out and let the other task do it.
; 1942 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 1943 : 
; 1944 :    if ( lpTask->bShutdown )

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN27@DeleteTask

; 1945 :    {
; 1946 :       // It's already being shut down so skip it.
; 1947 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1948 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@DeleteTask
$LN27@DeleteTask:

; 1949 :    }
; 1950 : 
; 1951 :    // Mark task as being shutdown.
; 1952 :    lpTask->bShutdown = TRUE;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 1953 : 
; 1954 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1955 : 
; 1956 :    hTask = zGETHNDL( lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hTask$[ebp], eax

; 1957 :    lpMainTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$[ebp], eax

; 1958 : 
; 1959 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN28@DeleteTask

; 1960 :    {
; 1961 :       TraceLine( "DeleteTask ==================> 0x%08x   ProcessID: %d   Task: 0x%08x          FirstOpenFile: 0x%08x",

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+118]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lProcessID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hTask$[ebp]
	push	ecx
	push	OFFSET $SG13951
	call	_TraceLine
	add	esp, 20					; 00000014H
$LN28@DeleteTask:

; 1962 :                  hTask, lProcessID, lpTask, lpTask->hFirstOpenFile );
; 1963 :    }
; 1964 : 
; 1965 :    // Get Current Application Task.
; 1966 :    lpView = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 1967 :    GetViewByName( &vDbhWork, zDBHANDLER_WORK_VIEW_NAME, lpView, zLEVEL_SYSTEM );

	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG13952
	lea	edx, DWORD PTR _vDbhWork$[ebp]
	push	edx
	call	_GetViewByName@16

; 1968 : 
; 1969 :    // Free the task's counting buffer.
; 1970 :    fnFreeDataspace( zGETPTR( lpTask->hCountBuf ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+146]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 1971 :    lpTask->hCountBuf = 0;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+146], 0

; 1972 : 
; 1973 :    // Before releasing database handlers, call the drop constraint
; 1974 :    // for all viewoi's for the task which have a drop constraint.
; 1975 : // if ( lpTask == lpCurrentTask )  // gots to be in 10c+
; 1976 :    {
; 1977 :       zSHORT nDrops;
; 1978 :       zSHORT nPasses;
; 1979 : 
; 1980 :       bCurrentTask = TRUE;

	mov	BYTE PTR _bCurrentTask$[ebp], 1

; 1981 :       for ( nPasses = 3; nPasses; nPasses-- )

	mov	eax, 3
	mov	WORD PTR _nPasses$7[ebp], ax
	jmp	SHORT $LN4@DeleteTask
$LN2@DeleteTask:
	mov	cx, WORD PTR _nPasses$7[ebp]
	sub	cx, 1
	mov	WORD PTR _nPasses$7[ebp], cx
$LN4@DeleteTask:
	movsx	edx, WORD PTR _nPasses$7[ebp]
	test	edx, edx
	je	$LN3@DeleteTask

; 1982 :       {
; 1983 :          lpViewOI = zGETPTR( lpTask->hFirstViewOI );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1984 :          nDrops = 0;

	xor	edx, edx
	mov	WORD PTR _nDrops$6[ebp], dx
$LN5@DeleteTask:

; 1985 :          while ( lpViewOI )

	cmp	DWORD PTR _lpViewOI$[ebp], 0
	je	$LN6@DeleteTask

; 1986 :          {
; 1987 :             LPVIEWOD lpViewOD = zGETPTR( lpViewOI->hViewOD );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$5[ebp], eax

; 1988 : 
; 1989 :             if ( lpViewOD && lpViewOD->bDropOIConstraint &&

	cmp	DWORD PTR _lpViewOD$5[ebp], 0
	je	$LN29@DeleteTask
	mov	edx, DWORD PTR _lpViewOD$5[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN29@DeleteTask
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	shr	edx, 6
	and	edx, 1
	jne	SHORT $LN29@DeleteTask

; 1990 :                  lpViewOI->bDropConstraintInvoked == FALSE )
; 1991 :             {
; 1992 :                LPVIEWCSR lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$4[ebp], eax

; 1993 : 
; 1994 :                fnInvokeOCEOperation( zGETPTR( lpFirstViewCsr->hView ),

	push	2
	push	4
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpFirstViewCsr$4[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H

; 1995 :                                      lpTask,
; 1996 :                                      zOCE_DROPOI, zOCE_STATE_SHUTDOWN );
; 1997 :                lpViewOI->bDropConstraintInvoked = TRUE;

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1998 :                nDrops++;

	mov	dx, WORD PTR _nDrops$6[ebp]
	add	dx, 1
	mov	WORD PTR _nDrops$6[ebp], dx
$LN29@DeleteTask:

; 1999 :             }
; 2000 : 
; 2001 :             lpViewOI = zGETPTR( lpViewOI->hNextViewOI );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 2002 :          }

	jmp	$LN5@DeleteTask
$LN6@DeleteTask:

; 2003 : 
; 2004 :          // The drop constraint may have activated an object which in turn has
; 2005 :          // a drop constraint ... if so, try again until all passes complete
; 2006 :          // or no drops are issued.
; 2007 :          if ( nDrops == 0 )

	movsx	edx, WORD PTR _nDrops$6[ebp]
	test	edx, edx
	jne	SHORT $LN30@DeleteTask

; 2008 :             break;

	jmp	SHORT $LN3@DeleteTask
$LN30@DeleteTask:

; 2009 :       }

	jmp	$LN2@DeleteTask
$LN3@DeleteTask:

; 2010 :    }
; 2011 : // else
; 2012 : // {
; 2013 : //    bCurrentTask = FALSE;
; 2014 : // }
; 2015 : 
; 2016 :    // If the task being deleted is the main task, we first shut
; 2017 :    // the DBHandlers, before we drop the views.
; 2018 :    // This is for engine server under MVS. Here, the only existing
; 2019 :    // task is the main task. The DBHandler work object must not be
; 2020 :    // dropped prior to the DBHandler shutdown.
; 2021 :    // DG reversed the order of dropping views and DBH shutdown because
; 2022 :    // of Lock Views. Those should not exist for the main task.
; 2023 : 
; 2024 :    if ( lpTask == lpMainTask )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	eax, DWORD PTR _lpMainTask$[ebp]
	jne	SHORT $LN7@DeleteTask

; 2025 :       fnDropTaskHandlers( lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnDropTaskHandlers@4
$LN7@DeleteTask:

; 2026 : 
; 2027 :    // Drop all view names tied to the task.
; 2028 :    while ( lpTask->hFirstViewName )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+110], 0
	je	SHORT $LN8@DeleteTask

; 2029 :    {
; 2030 :       lpViewName = zGETPTR( lpTask->hFirstViewName );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2031 : 
; 2032 :       // Unchain the current view name.
; 2033 :       lpTask->hFirstViewName = lpViewName->hNextViewName;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+110], ecx

; 2034 : 
; 2035 :       // Decrement the name count in the View referenced by the ViewName.
; 2036 :       lpView = zGETPTR( lpViewName->hView );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 2037 :       lpView->nViewNames--;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	dx, WORD PTR [ecx+22]
	sub	dx, 1
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [eax+22], dx

; 2038 : 
; 2039 :       // Free up storage for name string and the ViewName itself.
; 2040 :       fnFreeDataspace( lpViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 2041 :    }

	jmp	SHORT $LN7@DeleteTask
$LN8@DeleteTask:

; 2042 : 
; 2043 : #if 0  // this is done by fnDropTaskHandlers!
; 2044 :    // I think this was a problem in previous versions of Zeidon, but we never
; 2045 :    // saw it because we never had the same "task id".  Now we get the same
; 2046 :    // task quite often (after delete), so we must remove the references in
; 2047 :    // the system work object that apply to this task id.  dks 2004.05.27
; 2048 :    // Do this after dropping task handlers.
; 2049 :    if ( MiValidView( vDbhWork ) )
; 2050 :    {
; 2051 :       zVIEW vWork;
; 2052 : 
; 2053 :    // SfCloseTaskDatabases( lpView );
; 2054 :    // zltoa( (zLONG) hTask, szMsg );
; 2055 :       sprintf( szMsg, "0x%08x", hTask );
; 2056 : 
; 2057 :       CreateViewFromViewForTask( &vWork, vDbhWork, lpView );
; 2058 :       while ( SetCursorFirstEntityByString( vWork, "Connection",
; 2059 :                                             "LogicalUserName",
; 2060 :                                             szMsg, zSCOPE_OI ) == zCURSOR_SET )
; 2061 :       {
; 2062 :       // LPCONNECTION lpConnection;
; 2063 : 
; 2064 :       // GetAddrForAttribute( (zPVOID) &lpConnection, vWork,
; 2065 :       //                      "Connection", "ConnectionBlob" );
; 2066 : 
; 2067 :       // Free connection memory (last parm zero).
; 2068 :       // fnAllocateConnectionMemory( vWork, lpConnection, TRUE, 0 );
; 2069 :       // fnAllocateConnectionMemory( vWork, lpConnection, FALSE, 0 );
; 2070 : 
; 2071 :          SetAttributeFromBlob( vWork, "Connection", "ConnectionBlob", 0, 0 );
; 2072 :          DeleteEntity( vWork, "Connection", zREPOS_PREV );
; 2073 :       }
; 2074 : 
; 2075 :       DropView( vWork );
; 2076 :    }
; 2077 : #endif
; 2078 : 
; 2079 :    // If object services coming down, skip freeing views and applications.
; 2080 :    // DGC 11/8/96
; 2081 :    // We should no longer care if the task is the main task.
; 2082 :    // Drop all the views chained to the task, any view names will
; 2083 :    // fall with the chips ...
; 2084 :    // Hey ... I'm with DGC 11/8/96 ... skip all this if we are the main
; 2085 :    // task because there ain't nothin nobody can do to stop us.
; 2086 : // if ( lpTask != lpMainTask ) // if main task, forget it ... can't forget it when OE on server/tomcat
; 2087 :    {
; 2088 :       zVIEW lpNextView;
; 2089 : 
; 2090 :       lpView = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpView$[ebp], eax

; 2091 :       lpTask->hFirstView = 0;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+106], 0
$LN9@DeleteTask:

; 2092 :       while ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN10@DeleteTask

; 2093 :       {
; 2094 :          lpNextView = zGETPTR( lpView->hNextView );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextView$3[ebp], eax

; 2095 :          fnDropView( lpView );  // dks 2006.09.18 error while cleaning up client OE

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDropView@4

; 2096 :          lpView = lpNextView;

	mov	edx, DWORD PTR _lpNextView$3[ebp]
	mov	DWORD PTR _lpView$[ebp], edx

; 2097 :       }

	jmp	SHORT $LN9@DeleteTask
$LN10@DeleteTask:

; 2098 : 
; 2099 :       if ( lpTask->hFirstView )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+106], 0
	je	SHORT $LN32@DeleteTask

; 2100 :          SysMessageBox( 0, "DKS", "First View not NULL!!!", -1 );

	push	-1
	push	OFFSET $SG13957
	push	OFFSET $SG13958
	push	0
	call	_SysMessageBox@16
$LN32@DeleteTask:

; 2101 : 
; 2102 : #if 1 // this is hooey!!! but necessary for fnDropTaskHandlers
; 2103 :       // Dummy view just to pass the task in case we need it.   dks
; 2104 :       fnDeclareView( &lpView, lpTask, (zVIEW) -1, 0, FALSE );

	push	0
	push	0
	push	-1
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDeclareView@20

; 2105 :       lpTask->hFirstView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+106], eax
$LN11@DeleteTask:

; 2106 : #endif // this is hooey!!!
; 2107 : 
; 2108 :       // If this task has any instances remaining, then some views are
; 2109 :       // outstanding to the instance in another task, drop those views
; 2110 :       // so the instance goes away!!
; 2111 :       while ( lpTask->hFirstViewOI )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+98], 0
	je	SHORT $LN12@DeleteTask

; 2112 :       {
; 2113 :          LPVIEWOI  lpFirstViewOI;
; 2114 :          LPVIEWCSR lpFirstViewCsr;
; 2115 : 
; 2116 :          lpFirstViewOI  = zGETPTR( lpTask->hFirstViewOI );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+98]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewOI$2[ebp], eax

; 2117 :          lpFirstViewCsr = zGETPTR( lpFirstViewOI->hFirstViewCsr );

	mov	edx, DWORD PTR _lpFirstViewOI$2[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$1[ebp], eax

; 2118 :          fnDropView( zGETPTR( lpFirstViewCsr->hView ) );

	mov	ecx, DWORD PTR _lpFirstViewCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropView@4

; 2119 :       }

	jmp	SHORT $LN11@DeleteTask
$LN12@DeleteTask:

; 2120 : 
; 2121 :       // Free all TaskDBHandlers, if not for the main task.
; 2122 :       if ( lpTask != lpMainTask )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	eax, DWORD PTR _lpMainTask$[ebp]
	je	SHORT $LN33@DeleteTask

; 2123 :          fnDropTaskHandlers( lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnDropTaskHandlers@4
$LN33@DeleteTask:

; 2124 : 
; 2125 :       fnDropView( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4

; 2126 :    }
; 2127 : 
; 2128 : // DGC 6/21/2006
; 2129 : // We might need to add code to tell the network handler that a task is
; 2130 : // shutting down.  It's not needed yet because the winsock handler doesn't
; 2131 : // do anything for a task.
; 2132 : #if 0
; 2133 :    // Close any networks.  Since we now need to supply a view to the NetClose
; 2134 :    // operation, we create a dummy view (all other views have been dropped).
; 2135 :    if ( lpTask->hFirstNetwork )
; 2136 :    {
; 2137 :       LPNETWORK lpNetwork = zGETPTR( lpTask->hFirstNetwork );
; 2138 :       zVIEW vTask;
; 2139 : 
; 2140 :       vTask = zGETPTR( lpTask->hFirstView );
; 2141 : 
; 2142 :       while ( lpTask->hFirstNetwork )
; 2143 :       {
; 2144 :          lpNetwork = zGETPTR( lpTask->hFirstNetwork );
; 2145 : 
; 2146 :          NetClose( vTask, lpNetwork->szNetworkName );
; 2147 :          if ( lpNetwork == zGETPTR( lpTask->hFirstNetwork ) )
; 2148 :          {
; 2149 :             fnSysMessageBox( lpTask, "Zeidon Network Error",
; 2150 :                              "Couldn't close network--assume system is unstable",
; 2151 :                              1 );
; 2152 :             break;
; 2153 :          }
; 2154 :       }
; 2155 :    }
; 2156 : #endif
; 2157 : 
; 2158 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 2159 : 
; 2160 :    // Let's make sure that no one else will browse the task list while we're
; 2161 :    // removing a task.  First set flag to tell all processes that we're
; 2162 :    // about to delete a task.
; 2163 :    AnchorBlock->bDeleteTaskInProgress = TRUE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2164 : 
; 2165 :    // Free the task's application allocated memory.  We have to
; 2166 :    // do this after dropping the DB Handler, because when closing
; 2167 :    // the DB Handler, it accesses its allocated memory!!!   97.07.10 GT
; 2168 :    if ( lpTask->hFirstAppMem )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+114], 0
	je	SHORT $LN15@DeleteTask

; 2169 :    {
; 2170 :    // zPVOID hFirstAppMem = lpTask->hFirstAppMem;
; 2171 : 
; 2172 :       if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2527]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN35@DeleteTask

; 2173 :       {
; 2174 :          TraceLineI( "(tm) Freeing application allocated memory for task ",

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG13962
	call	_TraceLineI@8
$LN35@DeleteTask:

; 2175 :                      (zLONG) zGETHNDL( lpTask ) );
; 2176 :       }
; 2177 : 
; 2178 :       SysCheckTaskMemory( );  // list unfreed memory

	call	_SysCheckTaskMemory@0
$LN13@DeleteTask:

; 2179 : 
; 2180 :       // Free any memory not taken care of by the application.
; 2181 :       while ( lpTask->hFirstAppMem )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+114], 0
	je	SHORT $LN15@DeleteTask

; 2182 :       {
; 2183 :          SysFreeMemory( (zLONG) lpTask->hFirstAppMem );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_SysFreeMemory@4

; 2184 :       // if ( hFirstAppMem == lpTask->hFirstAppMem )
; 2185 :       // {
; 2186 :       //    TraceLineS( "(tm) DeleteTask error removing app memory", "" );
; 2187 :       //    break;  // some kind of problem has occurred ... punt!
; 2188 :       // }
; 2189 :       //
; 2190 :       // hFirstAppMem = lpTask->hFirstAppMem;
; 2191 :       }

	jmp	SHORT $LN13@DeleteTask
$LN15@DeleteTask:

; 2192 :    }
; 2193 : 
; 2194 :    while ( lpTask->hFirstSubtask )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	SHORT $LN16@DeleteTask

; 2195 :    {
; 2196 :    // hFirstSubtask = lpTask->hFirstSubtask;
; 2197 :       fnDropSubtask( lpTask, zGETPTR( lpTask->hFirstSubtask ), 1 );

	push	1
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH

; 2198 :    // if ( hFirstSubtask == lpTask->hFirstSubtask )
; 2199 :    // {
; 2200 :    //    TraceLineS( "(tm) DeleteTask error removing subtask", "" );
; 2201 :    //    break;  // some kind of problem has occurred ... punt!
; 2202 :    // }
; 2203 :    }

	jmp	SHORT $LN15@DeleteTask
$LN16@DeleteTask:

; 2204 : 
; 2205 :    // Close all Open files.
; 2206 :    fnCloseTaskOpenFiles( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnCloseTaskOpenFiles@4

; 2207 : 
; 2208 :    // Free TaskDomains for this Task.
; 2209 :    fnDropTaskDomains( lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnDropTaskDomains@4

; 2210 : 
; 2211 :    // Drop all task mutexes.
; 2212 : // fnDropTaskMutexes( lpTask );
; 2213 : 
; 2214 :    // Null the application pointer for the task and issue a delete for
; 2215 :    // all applications currently active.
; 2216 :    lpTask->hApp = 0;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+10], 0

; 2217 :    lpApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+126]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax
$LN17@DeleteTask:

; 2218 :    while ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	SHORT $LN18@DeleteTask

; 2219 :    {
; 2220 :       lpNextApp = zGETPTR( lpApp->hNextApp );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextApp$[ebp], eax

; 2221 :       fnDeleteApp( lpApp );   // delete all apps with no tasks

	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnDeleteApp
	add	esp, 4

; 2222 :       lpApp = lpNextApp;

	mov	ecx, DWORD PTR _lpNextApp$[ebp]
	mov	DWORD PTR _lpApp$[ebp], ecx

; 2223 :    }

	jmp	SHORT $LN17@DeleteTask
$LN18@DeleteTask:

; 2224 : 
; 2225 :    // Free TaskOperations for this Task.
; 2226 :    fnDropTaskOperations( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnDropTaskOperations@4
$LN19@DeleteTask:

; 2227 : 
; 2228 :    // Free TaskApps for this Task.
; 2229 :    while ( lpTask->hFirstTaskApp )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+102], 0
	je	SHORT $LN21@DeleteTask

; 2230 :    {
; 2231 :       if ( fnDropTaskApp( lpTask, zGETPTR( lpTask->hFirstTaskApp ) ) < 0 )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+102]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnDropTaskApp
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jge	SHORT $LN36@DeleteTask

; 2232 :       {
; 2233 :          TraceLineS( "(tm) DeleteTask error dropping task app", "" );

	push	OFFSET $SG13964
	push	OFFSET $SG13965
	call	_TraceLineS@8

; 2234 :          break;  // some kind of problem has occurred ... punt!

	jmp	SHORT $LN21@DeleteTask
$LN36@DeleteTask:

; 2235 :       }
; 2236 :    }

	jmp	SHORT $LN19@DeleteTask
$LN21@DeleteTask:

; 2237 : 
; 2238 :    // Free the task dataspace now that all others have freed it.
; 2239 :    // First issue a SysFreeLibrary for all loaded modules for this task.
; 2240 : // fnFreeTaskModules( lpTask );
; 2241 : // if ( lpTask == lpCurrentTask )  gots to be in 10c+
; 2242 :    {
; 2243 :       while ( fnSysFreeLibrary( lpTask, 0, TRUE ) > 0 )

	push	1
	push	0
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysFreeLibrary@12
	test	eax, eax
	jle	SHORT $LN22@DeleteTask

; 2244 :       {
; 2245 :       }

	jmp	SHORT $LN21@DeleteTask
$LN22@DeleteTask:

; 2246 :    }
; 2247 : 
; 2248 :    // Drop all task mutexes.  try it here ... dks 2006.06.28
; 2249 :    fnDropTaskMutexes( lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnDropTaskMutexes@4

; 2250 : 
; 2251 : // fnDropView( lpView );  memory has already been freed
; 2252 :    lpTask->hFirstView = 0;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+106], 0

; 2253 :    SetDefaultViewForActiveTask( 0, 1 );

	push	1
	push	0
	call	_SetDefaultViewForActiveTask@8

; 2254 : 
; 2255 :    fnCleanupTask( lpTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnCleanupTask
	add	esp, 4

; 2256 : // SysMalloc( -1 );  // report memory usage
; 2257 : 
; 2258 : #if 0
; 2259 :    // Since we do not create an application task share record
; 2260 :    // for sharing with the main object engine task. Go to
; 2261 :    // the main object engine task and tell it to free this
; 2262 :    // task's dataspaces.
; 2263 :    // Have this task free all shared memory "given" to it by other
; 2264 :    // tasks that own the shared memory.
; 2265 :    if ( lpTask != lpMainTask && g_bServerMode == FALSE )
; 2266 :    {
; 2267 :       ProcessZeidonMessage( (zLONG) hTask, -1 );
; 2268 :    }
; 2269 : 
; 2270 :    // We've deleted a task.  Memory management was smart enough to not free
; 2271 :    // each memory fragment to save time.  We now need to free each of the
; 2272 :    // pages since it wasn't done by memory management.  In g_bServerMode
; 2273 :    // we use malloc/free so this isn't necessary.
; 2274 :    if ( g_bServerMode == FALSE )
; 2275 :    {
; 2276 :       LPDATAHEADER lpNextDataHeader;
; 2277 :       LPDATAHEADER lpDataHeader;
; 2278 : 
; 2279 :       for ( lpDataHeader = zGETPTR( lpTask->hFirstDataHeader );
; 2280 :             lpDataHeader;
; 2281 :             lpDataHeader = lpNextDataHeader )
; 2282 :       {
; 2283 :       // TraceLineS( "Freeing a page", "" );
; 2284 :          lpNextDataHeader = zGETPTR( lpDataHeader->hNextDataHeader );
; 2285 :          fnFreeSharedMemory( lpTask, lpDataHeader->hDataHandle );
; 2286 :       }
; 2287 :    }
; 2288 : #endif
; 2289 : 
; 2290 :    // Remove the task from the task chain.
; 2291 :    fnStartBrowseOfTaskList( hTask, TRUE ); // Get a 'write' lock on the task list.

	push	1
	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 2292 :    if ( AnchorBlock->hFirstTask == hTask )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	cmp	edx, DWORD PTR _hTask$[ebp]
	jne	SHORT $LN37@DeleteTask

; 2293 :       AnchorBlock->hFirstTask = lpTask->hNextTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+130], edx
	jmp	SHORT $LN38@DeleteTask
$LN37@DeleteTask:

; 2294 :    else
; 2295 :    {
; 2296 :       lpPrevTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTask$[ebp], eax
$LN23@DeleteTask:

; 2297 :       while ( lpPrevTask && lpPrevTask->hNextTask != hTask )

	cmp	DWORD PTR _lpPrevTask$[ebp], 0
	je	SHORT $LN24@DeleteTask
	mov	edx, DWORD PTR _lpPrevTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hTask$[ebp]
	je	SHORT $LN24@DeleteTask

; 2298 :          lpPrevTask = zGETPTR( lpPrevTask->hNextTask );

	mov	ecx, DWORD PTR _lpPrevTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevTask$[ebp], eax
	jmp	SHORT $LN23@DeleteTask
$LN24@DeleteTask:

; 2299 : 
; 2300 :       if ( lpPrevTask )

	cmp	DWORD PTR _lpPrevTask$[ebp], 0
	je	SHORT $LN39@DeleteTask

; 2301 :          lpPrevTask->hNextTask = lpTask->hNextTask;

	mov	eax, DWORD PTR _lpPrevTask$[ebp]
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+2], edx
	jmp	SHORT $LN38@DeleteTask
$LN39@DeleteTask:

; 2302 :       else
; 2303 :          lpPrevTask = 0;

	mov	DWORD PTR _lpPrevTask$[ebp], 0
$LN38@DeleteTask:

; 2304 :    }
; 2305 : 
; 2306 : #ifdef ALLOC_FREE_TRACE
; 2307 :    if ( AnchorBlock->bTraceMem )
; 2308 :       fnListDataspaceLeak( AnchorBlock, hTask, 0 );
; 2309 : #endif
; 2310 : 
; 2311 :    // Free the 'write' lock on the task list.
; 2312 :    fnEndBrowseOfTaskList( TRUE );

	push	1
	call	_fnEndBrowseOfTaskList@4

; 2313 : 
; 2314 :    // That was quick ... now indicate we are no longer deleting a task.
; 2315 :    AnchorBlock->bDeleteTaskInProgress = FALSE;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+1495]
	and	ecx, -17				; ffffffefH
	mov	edx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [edx+1495], ecx

; 2316 : 
; 2317 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2318 : 
; 2319 :    // Send message that task deleted (before we delete the task).
; 2320 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN41@DeleteTask

; 2321 :    {
; 2322 :       zsprintf( szMsg, "(tm) Task (0x%08x) deleted for Process %d",

	push	0
	call	_SysGetProcessID@4
	push	eax
	mov	edx, DWORD PTR _hTask$[ebp]
	push	edx
	push	OFFSET $SG13971
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2323 :                 hTask, SysGetProcessID( 0 ) );
; 2324 : 
; 2325 :       if ( lpTask && lpTask->szUserId[ 0 ] )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN41@DeleteTask
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+244]
	test	ecx, ecx
	je	SHORT $LN41@DeleteTask

; 2326 :       {
; 2327 :          zstrcat( szMsg, "   UserName: " );

	push	OFFSET $SG13973
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2328 :          zstrcat( szMsg, lpTask->szUserId );

	mov	eax, DWORD PTR _lpTask$[ebp]
	add	eax, 244				; 000000f4H
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN41@DeleteTask:

; 2329 :       }
; 2330 :    }
; 2331 : 
; 2332 :    // Free the stuff that is part of the system task's dataspace.
; 2333 :    fnFreeDataspace( zGETPTR( lpTask->hUserID ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2334 :    fnFreeDataspace( zGETPTR( lpTask->hPassword ) );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2335 :    fnFreeDataspace( zGETPTR( lpTask->hDBUserID ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2336 :    fnFreeDataspace( zGETPTR( lpTask->hDBPassword ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+44]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2337 :    fnFreeDataspace( zGETPTR( lpTask->hCommand ) );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+142]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 2338 :    fnFreeTaskDataspace( lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnFreeTaskDataspace
	add	esp, 4

; 2339 :    fnFreeDataspace( lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 2340 : 
; 2341 : 
; 2342 :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2527]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN43@DeleteTask

; 2343 :    {
; 2344 :       // Use SysMessageList because TraceLineS expects a current task.
; 2345 :       SysMessageList( szMsg );

	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_SysMessageList@4

; 2346 :    // MiListOE_Memory( 0, 0 );
; 2347 :       SysDescribeZeidonPageTable( szMsg );

	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_SysDescribeZeidonPageTable@4

; 2348 :       TraceLineS( "Post DeleteTask - ", szMsg );

	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	push	OFFSET $SG13975
	call	_TraceLineS@8
$LN43@DeleteTask:

; 2349 :    }
; 2350 : 
; 2351 :    // Free the shared segment if we deleted our own task and we are not
; 2352 :    // the main task.
; 2353 : // if ( bCurrentTask && lpTask != lpMainTask )
; 2354 : //    fnFreeLocalAnchorBlock( FALSE );
; 2355 : 
; 2356 :    return( 0 );

	xor	eax, eax
$LN1@DeleteTask:

; 2357 : 
; 2358 : } // end of:  DeleteTask

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_DeleteTask@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_nRC$ = -8						; size = 4
tv65 = -4						; size = 4
_pchReturnString$ = 8					; size = 4
_nInfoRequest$ = 12					; size = 2
_lpTask$ = 16						; size = 4
_SfGetTaskInfo@12 PROC

; 2468 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2469 :    int    nRC;
; 2470 : 
; 2471 :    switch ( nInfoRequest )

	movsx	eax, WORD PTR _nInfoRequest$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN4@SfGetTaskI
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN7@SfGetTaskI
	jmp	$LN10@SfGetTaskI
$LN4@SfGetTaskI:

; 2472 :    {
; 2473 :       case zTASK_DIALOG:
; 2474 :          if ( lpTask->szDialog[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+278]
	test	ecx, ecx
	je	SHORT $LN5@SfGetTaskI

; 2475 :          {
; 2476 :             zstrcpy( pchReturnString, lpTask->szDialog );

	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 278				; 00000116H
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2477 :             SysTranslateString( pchReturnString, 'U' ); // guarantee upper-case

	push	85					; 00000055H
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	push	ecx
	call	_SysTranslateString@8

; 2478 :          }

	jmp	SHORT $LN6@SfGetTaskI
$LN5@SfGetTaskI:

; 2479 :          else
; 2480 :             pchReturnString[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [ecx+eax], 0
$LN6@SfGetTaskI:

; 2481 : 
; 2482 :          break;

	jmp	SHORT $LN2@SfGetTaskI
$LN7@SfGetTaskI:

; 2483 : 
; 2484 :       case zTASK_COMMAND:
; 2485 :          if ( lpTask->hCommand )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+142], 0
	je	SHORT $LN8@SfGetTaskI

; 2486 :             zstrcpy( pchReturnString, zGETPTR( lpTask->hCommand ) );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+142]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN9@SfGetTaskI
$LN8@SfGetTaskI:

; 2487 :          else
; 2488 :             pchReturnString[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN9@SfGetTaskI:

; 2489 : 
; 2490 :          break;

	jmp	SHORT $LN2@SfGetTaskI
$LN10@SfGetTaskI:

; 2491 : 
; 2492 :       default:
; 2493 :          // "KZOEE019 - Invalid GetTaskInfo request: "
; 2494 :          fnIssueCoreError( lpTask, 0, 8, 19, (zLONG) nInfoRequest, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nInfoRequest$[ebp]
	push	eax
	push	19					; 00000013H
	push	8
	push	0
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2495 :          nRC = zCALL_ERROR;

	mov	DWORD PTR _nRC$[ebp], -16		; fffffff0H
$LN2@SfGetTaskI:

; 2496 :    }
; 2497 : 
; 2498 :    nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0

; 2499 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2500 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfGetTaskInfo@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_vTaskView$ = 8						; size = 4
_SfGetCurrentTask@4 PROC

; 2434 : {

	push	ebp
	mov	ebp, esp

; 2435 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN2@SfGetCurre

; 2436 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SfGetCurre
$LN2@SfGetCurre:

; 2437 : 
; 2438 :    return( zGETPTR( vTaskView->hTask ) );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
$LN1@SfGetCurre:

; 2439 : 
; 2440 : } // SfGetCurrentTask

	pop	ebp
	ret	4
_SfGetCurrentTask@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpSearchTask$1 = -4					; size = 4
_lpTask$ = 8						; size = 4
_SfGetNextTask@4 PROC

; 2378 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2379 :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN7@SfGetNextT

; 2380 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@SfGetNextT
$LN7@SfGetNextT:

; 2381 : 
; 2382 :    // Make sure nobody else is deleting a task.
; 2383 :    fnStartBrowseOfTaskList( zGETHNDL( lpTask ), FALSE );

	push	0
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 2384 : 
; 2385 :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN8@SfGetNextT

; 2386 :       lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN5@SfGetNextT
$LN8@SfGetNextT:

; 2387 :    else
; 2388 :    {
; 2389 :       LPTASK lpSearchTask;
; 2390 : 
; 2391 :       // The user passed in a task pointer.  Make sure that it is a valid
; 2392 :       // task pointer.  If it is then return the next task; otherwise return 0.
; 2393 : 
; 2394 :       for ( lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$1[ebp], eax
	jmp	SHORT $LN4@SfGetNextT
$LN2@SfGetNextT:

; 2396 :             lpSearchTask = zGETPTR( lpSearchTask->hNextTask ) )

	mov	edx, DWORD PTR _lpSearchTask$1[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$1[ebp], eax
$LN4@SfGetNextT:

; 2395 :             lpSearchTask && lpSearchTask != lpTask;

	cmp	DWORD PTR _lpSearchTask$1[ebp], 0
	je	SHORT $LN3@SfGetNextT
	mov	ecx, DWORD PTR _lpSearchTask$1[ebp]
	cmp	ecx, DWORD PTR _lpTask$[ebp]
	je	SHORT $LN3@SfGetNextT

; 2397 :       {
; 2398 :          // Nothing needs to be done here.
; 2399 :       }

	jmp	SHORT $LN2@SfGetNextT
$LN3@SfGetNextT:

; 2400 : 
; 2401 :       if ( lpSearchTask )

	cmp	DWORD PTR _lpSearchTask$1[ebp], 0
	je	SHORT $LN10@SfGetNextT

; 2402 :          lpTask = zGETPTR( lpSearchTask->hNextTask );

	mov	edx, DWORD PTR _lpSearchTask$1[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN5@SfGetNextT
$LN10@SfGetNextT:

; 2403 :       else
; 2404 :          lpTask = 0;

	mov	DWORD PTR _lpTask$[ebp], 0
$LN5@SfGetNextT:

; 2405 :    }
; 2406 : 
; 2407 :    // Now make sure task is in good condition.
; 2408 :    while ( lpTask && (lpTask->bDisable || lpTask->bShutdown) )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN6@SfGetNextT
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN12@SfGetNextT
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN6@SfGetNextT
$LN12@SfGetNextT:

; 2409 :       lpTask = zGETPTR( lpTask->hNextTask );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	jmp	SHORT $LN5@SfGetNextT
$LN6@SfGetNextT:

; 2410 : 
; 2411 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 2412 : 
; 2413 :    return( lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
$LN1@SfGetNextT:

; 2414 : 
; 2415 : } // SfGetNextTask

	mov	esp, ebp
	pop	ebp
	ret	4
_SfGetNextTask@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_pDBOper$ = -16						; size = 4
_lpPtr$ = -12						; size = 4
_lpTask$ = -8						; size = 4
_lpTaskDBHandler$ = -4					; size = 4
_vTaskView$ = 8						; size = 4
_SfCloseTaskDatabases@4 PROC

; 956  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 957  :    LPTASKDBHANDLER lpTaskDBHandler;
; 958  :    LPTASK          lpTask;
; 959  :    zPDBHOPER       pDBOper;
; 960  :    zPVOID          lpPtr;
; 961  : 
; 962  :    if ( AnchorBlock->TraceFlags.bTaskMsgs )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2527]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN4@SfCloseTas

; 963  :    {
; 964  :       TraceLine( "SfCloseTaskDatabases for Process: %d   Task: %d (0x%08x)",

	mov	edx, DWORD PTR _vTaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _vTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	push	0
	call	_SysGetProcessID@4
	push	eax
	push	OFFSET $SG13621
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN4@SfCloseTas:

; 965  :                  SysGetProcessID( 0 ), vTaskView->hTask, vTaskView->hTask );
; 966  :    }
; 967  : 
; 968  :    lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 969  :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN5@SfCloseTas

; 970  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfCloseTas
$LN5@SfCloseTas:

; 971  : 
; 972  :    SysMutexLock( vTaskView, "Zeidon DBH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG13623
	mov	edx, DWORD PTR _vTaskView$[ebp]
	push	edx
	call	_SysMutexLock@16

; 973  : 
; 974  :    lpTaskDBHandler = zGETPTR( lpTask->hFirstTaskDBHandler );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+134]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax
$LN2@SfCloseTas:

; 975  :    while ( lpTaskDBHandler )

	cmp	DWORD PTR _lpTaskDBHandler$[ebp], 0
	je	SHORT $LN3@SfCloseTas

; 976  :    {
; 977  :       lpPtr = lpTaskDBHandler->lpConnection;

	mov	edx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	eax, DWORD PTR [edx+18]
	mov	DWORD PTR _lpPtr$[ebp], eax

; 978  : 
; 979  :       // Call DBHandler Close routine to close any open connections.
; 980  :       pDBOper = lpTaskDBHandler->pfDBHandlerOper;

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _pDBOper$[ebp], edx

; 981  :       (*pDBOper)( (zLONG) vTaskView->hTask, DBH_TaskCloseAll,

	lea	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	push	0
	push	256					; 00000100H
	mov	ecx, DWORD PTR _vTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _pDBOper$[ebp]

; 982  :                   0, 0, 0, 0, 0, &lpPtr );
; 983  :       lpTaskDBHandler->lpConnection = 0;

	mov	eax, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	DWORD PTR [eax+18], 0

; 984  : 
; 985  :       lpTaskDBHandler = zGETPTR( lpTaskDBHandler->hNextTaskDBHandler );

	mov	ecx, DWORD PTR _lpTaskDBHandler$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskDBHandler$[ebp], eax

; 986  :    }

	jmp	SHORT $LN2@SfCloseTas
$LN3@SfCloseTas:

; 987  : 
; 988  :    SysMutexUnlock( vTaskView, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG13624
	mov	eax, DWORD PTR _vTaskView$[ebp]
	push	eax
	call	_SysMutexUnlock@12

; 989  : 
; 990  :    return( 0 );

	xor	eax, eax
$LN1@SfCloseTas:

; 991  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SfCloseTaskDatabases@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_lpView$ = 8						; size = 4
_nFlag$ = 12						; size = 2
_bSet$ = 16						; size = 2
_SfSetTaskFlag@12 PROC

; 262  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 263  :    LPTASK lpTask;
; 264  : 
; 265  :    // get the task block associated with input ID
; 266  :    lpTask = zGETPTR( lpView->hTask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 267  :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@SfSetTaskF

; 268  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfSetTaskF
$LN2@SfSetTaskF:

; 269  : 
; 270  :    if ( nFlag & zTASKFLAG_AUDIT )

	movsx	edx, WORD PTR _nFlag$[ebp]
	and	edx, 1
	je	SHORT $LN3@SfSetTaskF

; 271  :       lpTask->bAudit = bSet;

	movsx	eax, WORD PTR _bSet$[ebp]
	and	eax, 1
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	and	edx, -2					; fffffffeH
	or	edx, eax
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [eax+443], edx
$LN3@SfSetTaskF:

; 272  : 
; 273  :    if ( nFlag & zTASKFLAG_DEBUG )

	movsx	ecx, WORD PTR _nFlag$[ebp]
	and	ecx, 2
	je	SHORT $LN4@SfSetTaskF

; 274  :       lpTask->bDebug = bSet;

	movsx	edx, WORD PTR _bSet$[ebp]
	and	edx, 1
	shl	edx, 1
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ecx, -3					; fffffffdH
	or	ecx, edx
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+443], ecx
$LN4@SfSetTaskF:

; 275  : 
; 276  :    if ( nFlag & zTASKFLAG_TRACE )

	movsx	eax, WORD PTR _nFlag$[ebp]
	and	eax, 4
	je	SHORT $LN5@SfSetTaskF

; 277  :       lpTask->bTrace = bSet;

	movsx	ecx, WORD PTR _bSet$[ebp]
	and	ecx, 1
	shl	ecx, 2
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -5					; fffffffbH
	or	eax, ecx
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax
$LN5@SfSetTaskF:

; 278  : 
; 279  :    return( 0 );

	xor	eax, eax
$LN1@SfSetTaskF:

; 280  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfSetTaskFlag@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_hTask$ = 8						; size = 4
_SfIsObjectServicesTask@4 PROC

; 299  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 300  :    LPTASK lpTask;
; 301  : 
; 302  :    // get the task block associated with input ID
; 303  :    lpTask = zGETPTR( hTask );

	mov	eax, DWORD PTR _hTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 304  : 
; 305  :    // We should walk the task chains to find out for sure???
; 306  :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN2@SfIsObject

; 307  :       return( 1 );

	mov	al, 1
	jmp	SHORT $LN1@SfIsObject
	jmp	SHORT $LN1@SfIsObject
$LN2@SfIsObject:

; 308  :    else
; 309  :       return( 0 );

	xor	al, al
$LN1@SfIsObject:

; 310  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SfIsObjectServicesTask@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_Address$ = 8						; size = 4
_SfUnlockTaskMemory@4 PROC

; 238  : {

	push	ebp
	mov	ebp, esp

; 239  :    return( zGETHNDL( Address ) );

	mov	eax, DWORD PTR _Address$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl

; 240  : }

	pop	ebp
	ret	4
_SfUnlockTaskMemory@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_Address$ = 8						; size = 4
_SfLockTaskMemory@4 PROC

; 218  : {

	push	ebp
	mov	ebp, esp

; 219  :    return( zGETPTR( Address ) );

	mov	eax, DWORD PTR _Address$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr

; 220  : }

	pop	ebp
	ret	4
_SfLockTaskMemory@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_Address$ = 8						; size = 4
_SfGetTaskMemoryLength@4 PROC

; 175  : {

	push	ebp
	mov	ebp, esp

; 176  :    return( fnGetDataspaceLength( zGETPTR( Address ) ) );

	mov	eax, DWORD PTR _Address$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnGetDataspaceLength
	add	esp, 4

; 177  : }

	pop	ebp
	ret	4
_SfGetTaskMemoryLength@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_Address$ = 8						; size = 4
_SfFreeTaskMemory@4 PROC

; 195  : {

	push	ebp
	mov	ebp, esp

; 196  :    if ( fnFreeDataspace( zGETPTR( Address ) ) )

	mov	eax, DWORD PTR _Address$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN2@SfFreeTask

; 197  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfFreeTask
	jmp	SHORT $LN1@SfFreeTask
$LN2@SfFreeTask:

; 198  :    else
; 199  :       return( 0 );

	xor	eax, eax
$LN1@SfFreeTask:

; 200  : }

	pop	ebp
	ret	4
_SfFreeTaskMemory@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_MemoryOrig$1 = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_lMemoryLth$ = -4					; size = 4
_vTaskView$ = 8						; size = 4
_Memory$ = 12						; size = 4
_lBytes$ = 16						; size = 4
_SfReAllocTaskMemory@12 PROC

; 125  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 126  :    LPTASK   lpCurrentTask;
; 127  :    zLONG    lMemoryLth;
; 128  : 
; 129  :    if ( (lpCurrentTask = fnOperationCall( iSfReAllocTaskMemory,
; 130  :                                           vTaskView, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _vTaskView$[ebp]
	push	eax
	push	27					; 0000001bH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfReAllocT

; 131  :    {
; 132  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfReAllocT
$LN2@SfReAllocT:

; 133  :    }
; 134  : 
; 135  :    // Realloc requires initial memory.
; 136  :    if ( *Memory == 0 || (lMemoryLth = SfGetTaskMemoryLength( *Memory )) == 0 )

	mov	ecx, DWORD PTR _Memory$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN5@SfReAllocT
	mov	edx, DWORD PTR _Memory$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SfGetTaskMemoryLength@4
	mov	DWORD PTR _lMemoryLth$[ebp], eax
	cmp	DWORD PTR _lMemoryLth$[ebp], 0
	jne	SHORT $LN3@SfReAllocT
$LN5@SfReAllocT:

; 137  :    {
; 138  :       *Memory = 0;

	mov	ecx, DWORD PTR _Memory$[ebp]
	mov	DWORD PTR [ecx], 0

; 139  :    }

	jmp	SHORT $LN4@SfReAllocT
$LN3@SfReAllocT:

; 140  :    else
; 141  :    if ( lMemoryLth < lBytes )

	mov	edx, DWORD PTR _lMemoryLth$[ebp]
	cmp	edx, DWORD PTR _lBytes$[ebp]
	jge	SHORT $LN4@SfReAllocT

; 142  :    {
; 143  :       zPVOID MemoryOrig = *Memory;

	mov	eax, DWORD PTR _Memory$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _MemoryOrig$1[ebp], ecx

; 144  : 
; 145  :       *Memory = (zPCHAR) fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10044					; 0000273cH
	push	0
	push	1
	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _Memory$[ebp]
	mov	DWORD PTR [edx], eax

; 146  :                                            lBytes, 1, 0, iTaskMemory );
; 147  :       zmemcpy( zGETPTR( *Memory ), zGETPTR( MemoryOrig ), lMemoryLth );

	mov	eax, DWORD PTR _lMemoryLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _MemoryOrig$1[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _Memory$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 148  : 
; 149  :       SfFreeTaskMemory( MemoryOrig );

	mov	ecx, DWORD PTR _MemoryOrig$1[ebp]
	push	ecx
	call	_SfFreeTaskMemory@4
$LN4@SfReAllocT:

; 150  :    }
; 151  : 
; 152  :    fnOperationReturn( iSfReAllocTaskMemory, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	27					; 0000001bH
	call	_fnOperationReturn
	add	esp, 8

; 153  :    if ( *Memory )

	mov	eax, DWORD PTR _Memory$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@SfReAllocT

; 154  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SfReAllocT
	jmp	SHORT $LN1@SfReAllocT
$LN7@SfReAllocT:

; 155  :    else
; 156  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@SfReAllocT:

; 157  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfReAllocTaskMemory@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -4					; size = 4
_vTaskView$ = 8						; size = 4
_Memory$ = 12						; size = 4
_lBytes$ = 16						; size = 4
_SfAllocTaskMemory@12 PROC

; 86   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 87   :    LPTASK   lpCurrentTask;
; 88   : 
; 89   :    // initialize to no memory
; 90   :    *Memory = 0;

	mov	eax, DWORD PTR _Memory$[ebp]
	mov	DWORD PTR [eax], 0

; 91   :    if ( (lpCurrentTask = fnOperationCall( iSfAllocTaskMemory,
; 92   :                                           vTaskView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _vTaskView$[ebp]
	push	ecx
	push	25					; 00000019H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfAllocTas

; 93   :    {
; 94   :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfAllocTas
$LN2@SfAllocTas:

; 95   :    }
; 96   : 
; 97   :    *Memory = (zPCHAR) fnAllocDataspace( lpCurrentTask->hFirstDataHeader,

	push	10044					; 0000273cH
	push	0
	push	1
	mov	edx, DWORD PTR _lBytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _Memory$[ebp]
	mov	DWORD PTR [edx], eax

; 98   :                                         lBytes, 1, 0, iTaskMemory );
; 99   : 
; 100  :    fnOperationReturn( iSfAllocTaskMemory, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	25					; 00000019H
	call	_fnOperationReturn
	add	esp, 8

; 101  :    if ( *Memory )

	mov	ecx, DWORD PTR _Memory$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN3@SfAllocTas

; 102  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@SfAllocTas
	jmp	SHORT $LN1@SfAllocTas
$LN3@SfAllocTas:

; 103  :    else
; 104  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
$LN1@SfAllocTas:

; 105  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfAllocTaskMemory@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_nRC$ = -12						; size = 4
_lpCurrentTask$ = -8					; size = 4
_lpSubtask$ = -4					; size = 4
_vSubtask$ = 8						; size = 4
_nCleanup$ = 12						; size = 2
_SfDropSubtask@8 PROC

; 2788 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2789 :    LPTASK    lpCurrentTask;
; 2790 :    LPSUBTASK lpSubtask;
; 2791 :    int       nRC;
; 2792 : 
; 2793 :    // If task not active or disabled, or subtask view invalid, return zCALL_ERROR.
; 2794 :    if ( (lpCurrentTask = fnOperationCall( iSfDropSubtask, vSubtask,
; 2795 :                                           zVALID_SUBTASK_VIEW )) == 0 )

	push	3
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	11					; 0000000bH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfDropSubt

; 2796 :    {
; 2797 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfDropSubt
$LN2@SfDropSubt:

; 2798 :    }
; 2799 : 
; 2800 :    lpSubtask = zGETPTR( vSubtask->hSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 2801 :    nRC = fnDropSubtask( zGETPTR( lpSubtask->hTask ), lpSubtask, nCleanup );

	movzx	eax, WORD PTR _nCleanup$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropSubtask
	add	esp, 12					; 0000000cH
	movsx	ecx, ax
	mov	DWORD PTR _nRC$[ebp], ecx

; 2802 : 
; 2803 :    fnOperationReturn( iSfDropSubtask, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	11					; 0000000bH
	call	_fnOperationReturn
	add	esp, 8

; 2804 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfDropSubt:

; 2805 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfDropSubtask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpNewSubtaskView$ = -16				; size = 4
_lpApp$ = -12						; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 4
_pvReturnSubtask$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcAppName$ = 16					; size = 4
_SfCreateSystemSubtask@12 PROC

; 2644 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2645 :    LPTASK      lpCurrentTask;
; 2646 :    zVIEW       lpNewSubtaskView;
; 2647 :    LPAPP       lpApp;
; 2648 :    int         nRC;
; 2649 : 
; 2650 : #ifdef DEBUG
; 2651 :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN2@SfCreateSy

; 2652 :    {
; 2653 :       TraceLine( "SfCreateSystemSubtask now REQUIRES a non-zero qualification view"

	mov	eax, DWORD PTR _cpcAppName$[ebp]
	push	eax
	push	OFFSET $SG14061
	call	_TraceLine
	add	esp, 8

; 2654 :                    "for Application: %s.", cpcAppName );
; 2655 :       SysMessageBox( 0, "Zeidon OE", "SfCreateSystemSubtask now REQUIRES a "

	push	0
	push	OFFSET $SG14062
	push	OFFSET $SG14063
	push	0
	call	_SysMessageBox@16

; 2656 :                      "non-zero qualification view.  System will now crash", 0 );
; 2657 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0

; 2658 :       nRC /= nRC;

	mov	eax, DWORD PTR _nRC$[ebp]
	cdq
	idiv	DWORD PTR _nRC$[ebp]
	mov	DWORD PTR _nRC$[ebp], eax
$LN2@SfCreateSy:

; 2659 :    }
; 2660 : #endif
; 2661 : 
; 2662 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 2663 :    if ( (lpCurrentTask = fnOperationCall( iSfCreateSubtask, lpView,
; 2664 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	10					; 0000000aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN3@SfCreateSy

; 2665 :    {
; 2666 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfCreateSy
$LN3@SfCreateSy:

; 2667 :    }
; 2668 : 
; 2669 :    // We need to lock the anchor mutex because we might create a new app.
; 2670 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 2671 : 
; 2672 :    if ( cpcAppName && cpcAppName[ 0 ] )

	cmp	DWORD PTR _cpcAppName$[ebp], 0
	je	SHORT $LN4@SfCreateSy
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcAppName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN4@SfCreateSy

; 2673 :    {
; 2674 :       lpApp = fnCreateApp( lpCurrentTask, cpcAppName );

	mov	eax, DWORD PTR _cpcAppName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCreateApp
	add	esp, 8
	mov	DWORD PTR _lpApp$[ebp], eax

; 2675 :       if ( lpApp == 0 )

	cmp	DWORD PTR _lpApp$[ebp], 0
	jne	SHORT $LN6@SfCreateSy

; 2676 :       {
; 2677 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2678 :          fnOperationReturn( iSfCreateSubtask, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	10					; 0000000aH
	call	_fnOperationReturn
	add	esp, 8

; 2679 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfCreateSy
$LN6@SfCreateSy:

; 2680 :       }
; 2681 :    }

	jmp	SHORT $LN5@SfCreateSy
$LN4@SfCreateSy:

; 2682 :    else
; 2683 :       fnGetApplicationForSubtask( &lpApp, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8
$LN5@SfCreateSy:

; 2684 : 
; 2685 :    // Use the system task in the call to fnCreateSubtask
; 2686 :    lpNewSubtaskView = fnCreateSubtask( zGETPTR( AnchorBlock->hMainTask ), lpApp );

	mov	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCreateSubtask
	add	esp, 8
	mov	DWORD PTR _lpNewSubtaskView$[ebp], eax

; 2687 : 
; 2688 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2689 : 
; 2690 :    if ( lpNewSubtaskView )

	cmp	DWORD PTR _lpNewSubtaskView$[ebp], 0
	je	SHORT $LN7@SfCreateSy

; 2691 :    {
; 2692 :       *pvReturnSubtask = lpNewSubtaskView;

	mov	edx, DWORD PTR _pvReturnSubtask$[ebp]
	mov	eax, DWORD PTR _lpNewSubtaskView$[ebp]
	mov	DWORD PTR [edx], eax

; 2693 : 
; 2694 :       // When possibly creating a new App struct, we want to preload the
; 2695 :       // Message Object Definition.
; 2696 :       ActivateViewObject( lpNewSubtaskView, szlMessageObject, 1 );

	push	1
	mov	ecx, DWORD PTR _szlMessageObject
	push	ecx
	mov	edx, DWORD PTR _lpNewSubtaskView$[ebp]
	push	edx
	call	_ActivateViewObject@12

; 2697 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0

; 2698 :    }

	jmp	SHORT $LN8@SfCreateSy
$LN7@SfCreateSy:

; 2699 :    else
; 2700 :       nRC = zCALL_ERROR;

	mov	DWORD PTR _nRC$[ebp], -16		; fffffff0H
$LN8@SfCreateSy:

; 2701 : 
; 2702 :    fnOperationReturn( iSfCreateSubtask, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	10					; 0000000aH
	call	_fnOperationReturn
	add	esp, 8

; 2703 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfCreateSy:

; 2704 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfCreateSystemSubtask@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_vTaskView$ = 8						; size = 4
_SfCurrentTaskIsServer@4 PROC

; 3051 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3052 :    LPTASK lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 3053 : 
; 3054 :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN2@SfCurrentT

; 3055 :       return( lpTask->bServer );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 6
	and	eax, 1
	jmp	SHORT $LN1@SfCurrentT
	jmp	SHORT $LN1@SfCurrentT
$LN2@SfCurrentT:

; 3056 :    else
; 3057 :       return( (zBOOL) zCALL_ERROR );

	mov	al, 240					; 000000f0H
$LN1@SfCurrentT:

; 3058 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SfCurrentTaskIsServer@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpNewApp$1 = -24					; size = 4
_lpSubtask$2 = -20					; size = 4
_lpApp$ = -16						; size = 4
_lpNewSubtaskView$ = -12				; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 4
_pvReturnSubtask$ = 8					; size = 4
_lpView$ = 12						; size = 4
_cpcAppName$ = 16					; size = 4
_SfCreateSubtask@12 PROC

; 2537 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2538 :    LPTASK      lpCurrentTask;
; 2539 :    zVIEW       lpNewSubtaskView;
; 2540 :    LPAPP       lpApp;
; 2541 :    int         nRC;
; 2542 : 
; 2543 : #ifdef DEBUG
; 2544 :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN2@SfCreateSu

; 2545 :    {
; 2546 :       TraceLine( "SfCreateSubtask now REQUIRES a non-zero qualification view"

	mov	eax, DWORD PTR _cpcAppName$[ebp]
	push	eax
	push	OFFSET $SG14037
	call	_TraceLine
	add	esp, 8

; 2547 :                    "for Application: %s.", cpcAppName );
; 2548 :       SysMessageBox( 0, "Zeidon OE", "SfCreateSubtask now REQUIRES a "

	push	0
	push	OFFSET $SG14038
	push	OFFSET $SG14039
	push	0
	call	_SysMessageBox@16

; 2549 :                      "non-zero qualification view.  System will now crash", 0 );
; 2550 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0

; 2551 :       nRC /= nRC;

	mov	eax, DWORD PTR _nRC$[ebp]
	cdq
	idiv	DWORD PTR _nRC$[ebp]
	mov	DWORD PTR _nRC$[ebp], eax
$LN2@SfCreateSu:

; 2552 :    }
; 2553 : #endif
; 2554 : 
; 2555 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 2556 :    if ( (lpCurrentTask = fnOperationCall( iSfCreateSubtask, lpView,
; 2557 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	10					; 0000000aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN3@SfCreateSu

; 2558 :    {
; 2559 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfCreateSu
$LN3@SfCreateSu:

; 2560 :    }
; 2561 : 
; 2562 :    // We need to lock the anchor mutex because we might create a new app.
; 2563 :    zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 2564 : 
; 2565 :    if ( cpcAppName && cpcAppName[ 0 ] )

	cmp	DWORD PTR _cpcAppName$[ebp], 0
	je	SHORT $LN4@SfCreateSu
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcAppName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN4@SfCreateSu

; 2566 :    {
; 2567 :       lpApp = fnCreateApp( lpCurrentTask, cpcAppName );

	mov	eax, DWORD PTR _cpcAppName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCreateApp
	add	esp, 8
	mov	DWORD PTR _lpApp$[ebp], eax

; 2568 :       if ( lpApp == 0 )

	cmp	DWORD PTR _lpApp$[ebp], 0
	jne	SHORT $LN6@SfCreateSu

; 2569 :       {
; 2570 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2571 :          fnOperationReturn( iSfCreateSubtask, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	10					; 0000000aH
	call	_fnOperationReturn
	add	esp, 8

; 2572 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfCreateSu
$LN6@SfCreateSu:

; 2573 :       }
; 2574 :    }

	jmp	SHORT $LN5@SfCreateSu
$LN4@SfCreateSu:

; 2575 :    else
; 2576 :       fnGetApplicationForSubtask( &lpApp, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_fnGetApplicationForSubtask@8
$LN5@SfCreateSu:

; 2577 : 
; 2578 :    // Use the current task in the call to fnCreateSubtask
; 2579 :    lpNewSubtaskView = fnCreateSubtask( lpCurrentTask, lpApp );

	mov	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCreateSubtask
	add	esp, 8
	mov	DWORD PTR _lpNewSubtaskView$[ebp], eax

; 2580 : 
; 2581 :    zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 2582 : 
; 2583 :    if ( lpNewSubtaskView )

	cmp	DWORD PTR _lpNewSubtaskView$[ebp], 0
	je	SHORT $LN7@SfCreateSu

; 2584 :    {
; 2585 :       LPSUBTASK lpSubtask = zGETPTR( lpNewSubtaskView->hSubtask );

	mov	ecx, DWORD PTR _lpNewSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$2[ebp], eax

; 2586 :       LPAPP     lpNewApp  = zGETPTR( lpSubtask->hApp );

	mov	eax, DWORD PTR _lpSubtask$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewApp$1[ebp], eax

; 2587 : 
; 2588 :       *pvReturnSubtask = lpNewSubtaskView;

	mov	edx, DWORD PTR _pvReturnSubtask$[ebp]
	mov	eax, DWORD PTR _lpNewSubtaskView$[ebp]
	mov	DWORD PTR [edx], eax

; 2589 : 
; 2590 :       // When possibly creating a new App struct, we want to preload the
; 2591 :       // Message Object Definition.  The assumption that we are making
; 2592 :       // below is that the first object definition that is put on the
; 2593 :       // app struct will be the message object definition, so if there
; 2594 :       // is already a pointer in the app struct, to a ViewOD chain, then
; 2595 :       // the message object must already be preloaded. (We Hope!!!)
; 2596 :       nRC = 0;

	mov	DWORD PTR _nRC$[ebp], 0

; 2597 :       if ( lpNewApp->hFirstViewOD == 0 )

	mov	ecx, DWORD PTR _lpNewApp$1[ebp]
	cmp	DWORD PTR [ecx+84], 0
	jne	SHORT $LN9@SfCreateSu

; 2598 :       {
; 2599 :          if ( ActivateViewObject( lpNewSubtaskView, szlMessageObject, 0 ) == 0 )

	push	0
	mov	edx, DWORD PTR _szlMessageObject
	push	edx
	mov	eax, DWORD PTR _lpNewSubtaskView$[ebp]
	push	eax
	call	_ActivateViewObject@12
	test	eax, eax
	jne	SHORT $LN9@SfCreateSu

; 2600 :             nRC = zCALL_ERROR;

	mov	DWORD PTR _nRC$[ebp], -16		; fffffff0H
$LN9@SfCreateSu:

; 2601 :       }
; 2602 :    }

	jmp	SHORT $LN8@SfCreateSu
$LN7@SfCreateSu:

; 2603 :    else
; 2604 :       nRC = zCALL_ERROR;

	mov	DWORD PTR _nRC$[ebp], -16		; fffffff0H
$LN8@SfCreateSu:

; 2605 : 
; 2606 :    fnOperationReturn( iSfCreateSubtask, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	10					; 0000000aH
	call	_fnOperationReturn
	add	esp, 8

; 2607 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfCreateSu:

; 2608 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfCreateSubtask@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_nTraceLevel$ = 12					; size = 2
_SetTaskDBHandlerTraceLevel@8 PROC

; 1160 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1161 :    LPTASK lpCurrentTask;
; 1162 :    LPTASK lpTask;
; 1163 : 
; 1164 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 1165 :    if ( (lpCurrentTask = fnOperationCall( iSetTaskDBHandlerTraceLevel,
; 1166 :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	404					; 00000194H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SetTaskDBH

; 1167 :    {
; 1168 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetTaskDBH
$LN2@SetTaskDBH:

; 1169 :    }
; 1170 : 
; 1171 :    lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 1172 :    lpTask->nDBHandlerTraceLevel = nTraceLevel;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	cx, WORD PTR _nTraceLevel$[ebp]
	mov	WORD PTR [eax+92], cx

; 1173 : 
; 1174 :    fnOperationReturn( iSetTaskDBHandlerTraceLevel, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	404					; 00000194H
	call	_fnOperationReturn
	add	esp, 8

; 1175 :    return( 0 );

	xor	eax, eax
$LN1@SetTaskDBH:

; 1176 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SetTaskDBHandlerTraceLevel@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTask$ = -8						; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_GetTaskDBHandlerTraceLevel@4 PROC

; 1193 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1194 :    LPTASK lpCurrentTask;
; 1195 :    LPTASK lpTask;
; 1196 : 
; 1197 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 1198 :    if ( (lpCurrentTask = fnOperationCall( iGetTaskDBHandlerTraceLevel,
; 1199 :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	403					; 00000193H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@GetTaskDBH

; 1200 :    {
; 1201 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetTaskDBH
$LN2@GetTaskDBH:

; 1202 :    }
; 1203 : 
; 1204 :    lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 1205 : 
; 1206 :    fnOperationReturn( iGetTaskDBHandlerTraceLevel, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	403					; 00000193H
	call	_fnOperationReturn
	add	esp, 8

; 1207 :    return( lpTask->nDBHandlerTraceLevel );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	ax, WORD PTR [ecx+92]
$LN1@GetTaskDBH:

; 1208 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_GetTaskDBHandlerTraceLevel@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpTaskCurr$ = -40					; size = 4
_lDiffMinutes$ = -36					; size = 4
_hTask$ = -32						; size = 4
_lpTask$ = -28						; size = 4
_szDateTime$ = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpDropApp$ = 12					; size = 4
_GarbageCollectViews@8 PROC

; 2868 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2869 :    LPTASK hTask;
; 2870 :    LPTASK lpTask;
; 2871 :    LPTASK lpTaskCurr;
; 2872 :    zCHAR  szDateTime[ 20 ];
; 2873 :    zLONG  lDiffMinutes;
; 2874 : 
; 2875 :    lpTask = zGETPTR( lpTaskView->hTask );

	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 2876 :    fnGarbageCollectViews( lpTask, (LPAPP) lpDropApp );

	mov	edx, DWORD PTR _lpDropApp$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnGarbageCollectViews
	add	esp, 8

; 2877 : 
; 2878 :    fnStartBrowseOfTaskList( lpTaskView->hTask, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	_fnStartBrowseOfTaskList@8

; 2879 :    hTask = AnchorBlock->hFirstTask;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	mov	DWORD PTR _hTask$[ebp], ecx
$LN2@GarbageCol:

; 2880 :    while ( hTask )

	cmp	DWORD PTR _hTask$[ebp], 0
	je	$LN3@GarbageCol

; 2881 :    {
; 2882 :       lpTask = zGETPTR( hTask );

	mov	edx, DWORD PTR _hTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 2883 :       if ( lpTask->bTransientTask && hTask != lpTaskView->hTask )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN4@GarbageCol
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	mov	eax, DWORD PTR _hTask$[ebp]
	cmp	eax, DWORD PTR [edx+14]
	je	SHORT $LN4@GarbageCol

; 2884 :       {
; 2885 :          SysGetDateTime( szDateTime );

	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	call	_SysGetDateTime@4

; 2886 :          SysGetDateTimeDifference( &lDiffMinutes,

	push	4
	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	add	eax, 174				; 000000aeH
	push	eax
	lea	ecx, DWORD PTR _lDiffMinutes$[ebp]
	push	ecx
	call	_SysGetDateTimeDifference@16

; 2887 :                                    lpTask->szTimeStamp,
; 2888 :                                    szDateTime, zDT_MINUTE );
; 2889 :          if ( lDiffMinutes > 45 )

	cmp	DWORD PTR _lDiffMinutes$[ebp], 45	; 0000002dH
	jle	SHORT $LN4@GarbageCol

; 2890 :          {
; 2891 :             fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4

; 2892 :             TraceLineX( "GarbageCollectViews Unregistering Task: ",

	mov	edx, DWORD PTR _hTask$[ebp]
	push	edx
	push	OFFSET $SG14144
	call	_TraceLineX@8

; 2893 :                         (zLONG) hTask );
; 2894 :             lpTaskCurr = zGETPTR( lpTaskView->hTask );

	mov	eax, DWORD PTR _lpTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskCurr$[ebp], eax

; 2895 :             UnregisterZeidonApplication( zGETPTR( lpTask->hFirstView ) );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_UnregisterZeidonApplication@4

; 2896 : 
; 2897 :             // only remove one at a time so as to mimimize the impact on performance.
; 2898 :             // This also allows us to remove the lock on the task chain before
; 2899 :             // calling Unregister.  Unregister will lock it again.
; 2900 :             return;

	jmp	SHORT $LN1@GarbageCol
$LN4@GarbageCol:

; 2901 :          }
; 2902 :       }
; 2903 : 
; 2904 :       hTask = lpTask->hNextTask;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR _hTask$[ebp], edx

; 2905 :    }

	jmp	$LN2@GarbageCol
$LN3@GarbageCol:

; 2906 : 
; 2907 :    fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4
$LN1@GarbageCol:

; 2908 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_GarbageCollectViews@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lProcessID$ = -284					; size = 4
tv146 = -280						; size = 4
_lpOpenFile$ = -276					; size = 4
_lpViewOD$ = -272					; size = 4
_lpApp$ = -268						; size = 4
_lpTask$ = -264						; size = 4
_szMsg$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_cpcTitle$ = 8						; size = 4
_hTask$ = 12						; size = 4
_DisplayOpenFiles@8 PROC

; 3318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3319 :    LPAPP  lpApp;
; 3320 :    LPTASK lpTask;
; 3321 :    zLONG         lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _lProcessID$[ebp], eax

; 3322 :    LPOPENFILE    lpOpenFile;
; 3323 :    LPVIEWOD      lpViewOD;
; 3324 :    zCHAR szMsg[ 256 ];
; 3325 : 
; 3326 :    TraceLineS( "Display Tasks/Apps ", cpcTitle );

	mov	eax, DWORD PTR _cpcTitle$[ebp]
	push	eax
	push	OFFSET $SG14263
	call	_TraceLineS@8

; 3327 : 
; 3328 :    // Protected by fnStartBrowseOfTaskList.
; 3329 :    lpTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN2@DisplayOpe:

; 3330 :    while ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN3@DisplayOpe

; 3331 :    {
; 3332 :       zsprintf( szMsg, "   Task (0x%08x) %s   Process: %d",

	mov	eax, DWORD PTR _lProcessID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 311				; 00000137H
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG14264
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 3333 :                 zGETHNDL( lpTask ), lpTask->szTaskTitle, lProcessID );
; 3334 : 
; 3335 : //*********************************************************************************
; 3336 :       // KJS 04/20/09 - Added this so that we could also see who the user
; 3337 :       // is for this task (because of call sfSetUserIdForTask).
; 3338 :       if ( lpTask->szUserId[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+244]
	test	ecx, ecx
	je	SHORT $LN10@DisplayOpe

; 3339 :       {
; 3340 :          zstrcat( szMsg, "   UserName: " );

	push	OFFSET $SG14266
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 3341 :          zstrcat( szMsg, lpTask->szUserId );

	mov	eax, DWORD PTR _lpTask$[ebp]
	add	eax, 244				; 000000f4H
	push	eax
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8
$LN10@DisplayOpe:

; 3342 :       }
; 3343 : //*********************************************************************************
; 3344 : 
; 3345 :       SysMessageList( szMsg );

	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_SysMessageList@4

; 3346 : 
; 3347 :       lpOpenFile = zGETPTR( lpTask->hFirstOpenFile );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+118]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax
$LN4@DisplayOpe:

; 3348 :       while ( lpOpenFile )

	cmp	DWORD PTR _lpOpenFile$[ebp], 0
	je	SHORT $LN5@DisplayOpe

; 3349 :       {
; 3350 :          zsprintf( szMsg, "      Open file: '%s'", lpOpenFile->szFileName );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	push	OFFSET $SG14267
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 3351 :          SysMessageList( szMsg );

	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_SysMessageList@4

; 3352 :          lpOpenFile = zGETPTR( lpOpenFile->hNextOpenFile );

	mov	edx, DWORD PTR _lpOpenFile$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOpenFile$[ebp], eax

; 3353 :       }

	jmp	SHORT $LN4@DisplayOpe
$LN5@DisplayOpe:

; 3354 : 
; 3355 :       lpTask = zGETPTR( lpTask->hNextTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 3356 :    }

	jmp	$LN2@DisplayOpe
$LN3@DisplayOpe:

; 3357 : 
; 3358 :    lpApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+126]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax
$LN6@DisplayOpe:

; 3359 :    while ( lpApp )

	cmp	DWORD PTR _lpApp$[ebp], 0
	je	$LN1@DisplayOpe

; 3360 :    {
; 3361 :       zsprintf( szMsg, "   App (0x%08x) %s   %s",

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+1905]
	and	eax, 1
	je	SHORT $LN12@DisplayOpe
	mov	DWORD PTR tv146[ebp], OFFSET $SG14268
	jmp	SHORT $LN13@DisplayOpe
$LN12@DisplayOpe:
	mov	DWORD PTR tv146[ebp], OFFSET $SG14269
$LN13@DisplayOpe:
	mov	ecx, DWORD PTR tv146[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpApp$[ebp]
	add	edx, 6
	push	edx
	mov	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG14270
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 3362 :                 zGETHNDL( lpApp ), lpApp->szName, lpApp->bKeepAlive ? "(KeepAlive)" : "" );
; 3363 :       SysMessageList( szMsg );

	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_SysMessageList@4

; 3364 :       lpViewOD = zGETPTR( lpApp->hFirstViewOD );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
$LN8@DisplayOpe:

; 3365 :       while ( lpViewOD )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN9@DisplayOpe

; 3366 :       {
; 3367 :          zsprintf( szMsg, "      View OD (0x%08x): '%s'",

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	push	OFFSET $SG14271
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3368 :                    zGETHNDL( lpViewOD), lpViewOD->szName );
; 3369 :          SysMessageList( szMsg );

	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_SysMessageList@4

; 3370 :          lpViewOD = zGETPTR( lpViewOD->hNextViewOD );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3371 :       }

	jmp	SHORT $LN8@DisplayOpe
$LN9@DisplayOpe:

; 3372 : 
; 3373 :       lpApp = zGETPTR( lpApp->hNextApp );

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 3374 :    }

	jmp	$LN6@DisplayOpe
$LN1@DisplayOpe:

; 3375 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_DisplayOpenFiles@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_lpTask$ = -4						; size = 4
_lpView$ = 8						; size = 4
_EnableTask@4 PROC

; 360  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 361  :    LPTASK lpCurrentTask;
; 362  :    LPTASK lpTask;
; 363  : 
; 364  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 365  :    if ( (lpCurrentTask = fnOperationCall( iEnableTask, lpView,
; 366  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	13					; 0000000dH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@EnableTask

; 367  :    {
; 368  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@EnableTask
$LN2@EnableTask:

; 369  :    }
; 370  : 
; 371  :    lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 372  :    lpTask->bDisable = 0;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ecx, -9					; fffffff7H
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 373  : 
; 374  :    fnOperationReturn( iEnableTask, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	13					; 0000000dH
	call	_fnOperationReturn
	add	esp, 8

; 375  :    return( 0 );

	xor	eax, eax
$LN1@EnableTask:

; 376  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_EnableTask@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_lpTask$ = -4						; size = 4
_lpView$ = 8						; size = 4
_DisableTask@4 PROC

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 328  :    LPTASK lpCurrentTask;
; 329  :    LPTASK lpTask;
; 330  : 
; 331  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 332  :    if ( (lpCurrentTask = fnOperationCall( iDisableTask, lpView,
; 333  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	12					; 0000000cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@DisableTas

; 334  :    {
; 335  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@DisableTas
$LN2@DisableTas:

; 336  :    }
; 337  : 
; 338  :    lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 339  :    lpTask->bDisable = TRUE;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	or	ecx, 8
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+443], ecx

; 340  : 
; 341  :    fnOperationReturn( iDisableTask, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	12					; 0000000cH
	call	_fnOperationReturn
	add	esp, 8

; 342  :    return( 0 );

	xor	eax, eax
$LN1@DisableTas:

; 343  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DisableTask@4 ENDP
_TEXT	ENDS
END
