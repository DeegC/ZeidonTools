; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOETRAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_szBlankLine
_BSS	SEGMENT
$SG14348 DB	01H DUP (?)
$SG14349 DB	01H DUP (?)
$SG14350 DB	01H DUP (?)
$SG14365 DB	01H DUP (?)
$SG14366 DB	01H DUP (?)
$SG14367 DB	01H DUP (?)
$SG13402 DB	01H DUP (?)
$SG13414 DB	01H DUP (?)
$SG13511 DB	01H DUP (?)
$SG13549 DB	01H DUP (?)
$SG14614 DB	01H DUP (?)
$SG14620 DB	01H DUP (?)
$SG13608 DB	01H DUP (?)
$SG14641 DB	01H DUP (?)
$SG14644 DB	01H DUP (?)
$SG13640 DB	01H DUP (?)
$SG13641 DB	01H DUP (?)
$SG13680 DB	01H DUP (?)
$SG13681 DB	01H DUP (?)
$SG13742 DB	01H DUP (?)
$SG13743 DB	01H DUP (?)
$SG13745 DB	01H DUP (?)
$SG13746 DB	01H DUP (?)
$SG13807 DB	01H DUP (?)
$SG13824 DB	01H DUP (?)
$SG13827 DB	01H DUP (?)
$SG13830 DB	01H DUP (?)
$SG13833 DB	01H DUP (?)
$SG13836 DB	01H DUP (?)
$SG13879 DB	01H DUP (?)
$SG13882 DB	01H DUP (?)
$SG13884 DB	01H DUP (?)
$SG13885 DB	01H DUP (?)
$SG13887 DB	01H DUP (?)
$SG13889 DB	01H DUP (?)
$SG13890 DB	01H DUP (?)
$SG13901 DB	01H DUP (?)
$SG13908 DB	01H DUP (?)
$SG13910 DB	01H DUP (?)
$SG13911 DB	01H DUP (?)
$SG13912 DB	01H DUP (?)
$SG13913 DB	01H DUP (?)
$SG13955 DB	01H DUP (?)
$SG13957 DB	01H DUP (?)
$SG13958 DB	01H DUP (?)
$SG13959 DB	01H DUP (?)
$SG13961 DB	01H DUP (?)
$SG13962 DB	01H DUP (?)
$SG13963 DB	01H DUP (?)
$SG13965 DB	01H DUP (?)
$SG13966 DB	01H DUP (?)
$SG13967 DB	01H DUP (?)
$SG13969 DB	01H DUP (?)
$SG13970 DB	01H DUP (?)
$SG13976 DB	01H DUP (?)
$SG13977 DB	01H DUP (?)
$SG13979 DB	01H DUP (?)
$SG13981 DB	01H DUP (?)
$SG13984 DB	01H DUP (?)
$SG13987 DB	01H DUP (?)
$SG13989 DB	01H DUP (?)
$SG13991 DB	01H DUP (?)
$SG13999 DB	01H DUP (?)
$SG14001 DB	01H DUP (?)
$SG14003 DB	01H DUP (?)
$SG14005 DB	01H DUP (?)
$SG14006 DB	01H DUP (?)
$SG14019 DB	01H DUP (?)
$SG14020 DB	01H DUP (?)
$SG14040 DB	01H DUP (?)
$SG14043 DB	01H DUP (?)
$SG14046 DB	01H DUP (?)
$SG14049 DB	01H DUP (?)
$SG14052 DB	01H DUP (?)
$SG14055 DB	01H DUP (?)
$SG14058 DB	01H DUP (?)
$SG14061 DB	01H DUP (?)
$SG14064 DB	01H DUP (?)
$SG14067 DB	01H DUP (?)
$SG14070 DB	01H DUP (?)
$SG14073 DB	01H DUP (?)
$SG14076 DB	01H DUP (?)
$SG14079 DB	01H DUP (?)
$SG14082 DB	01H DUP (?)
$SG14085 DB	01H DUP (?)
$SG14088 DB	01H DUP (?)
$SG14091 DB	01H DUP (?)
$SG14094 DB	01H DUP (?)
$SG14097 DB	01H DUP (?)
$SG14100 DB	01H DUP (?)
$SG14103 DB	01H DUP (?)
$SG14106 DB	01H DUP (?)
$SG14109 DB	01H DUP (?)
$SG14112 DB	01H DUP (?)
$SG14115 DB	01H DUP (?)
$SG14118 DB	01H DUP (?)
$SG14121 DB	01H DUP (?)
$SG14124 DB	01H DUP (?)
$SG14127 DB	01H DUP (?)
$SG14130 DB	01H DUP (?)
$SG14133 DB	01H DUP (?)
$SG14136 DB	01H DUP (?)
$SG14139 DB	01H DUP (?)
$SG14142 DB	01H DUP (?)
$SG14145 DB	01H DUP (?)
$SG14148 DB	01H DUP (?)
$SG14151 DB	01H DUP (?)
$SG14163 DB	01H DUP (?)
$SG14164 DB	01H DUP (?)
$SG14175 DB	01H DUP (?)
$SG14179 DB	01H DUP (?)
$SG14182 DB	01H DUP (?)
$SG14185 DB	01H DUP (?)
$SG14188 DB	01H DUP (?)
$SG14191 DB	01H DUP (?)
$SG14194 DB	01H DUP (?)
$SG14197 DB	01H DUP (?)
$SG14200 DB	01H DUP (?)
$SG14203 DB	01H DUP (?)
$SG14206 DB	01H DUP (?)
$SG14209 DB	01H DUP (?)
$SG14212 DB	01H DUP (?)
$SG14215 DB	01H DUP (?)
$SG14218 DB	01H DUP (?)
$SG14221 DB	01H DUP (?)
$SG14285 DB	01H DUP (?)
$SG14286 DB	01H DUP (?)
$SG14287 DB	01H DUP (?)
$SG14289 DB	01H DUP (?)
$SG14290 DB	01H DUP (?)
$SG14292 DB	01H DUP (?)
$SG14308 DB	01H DUP (?)
$SG14311 DB	01H DUP (?)
$SG14314 DB	01H DUP (?)
$SG14317 DB	01H DUP (?)
$SG14320 DB	01H DUP (?)
$SG14323 DB	01H DUP (?)
$SG14326 DB	01H DUP (?)
$SG14329 DB	01H DUP (?)
$SG14332 DB	01H DUP (?)
$SG14334 DB	01H DUP (?)
$SG14335 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG14336 DB	'              DATARECORD name = ', 00H
	ORG $+3
$SG14337 DB	'              Record Type = ', 00H
	ORG $+3
$SG14339 DB	'              Record ID = ', 00H
	ORG $+1
$SG14340 DB	'                DATAFIELD Attribute name = ', 00H
$SG14341 DB	'                Field name = ', 00H
	ORG $+2
$SG14342 DB	'                Field type = ', 00H
	ORG $+2
$SG14343 DB	'                Field length = ', 00H
$SG14345 DB	'                Field length = ', 00H
$SG14347 DB	'                Field length = ', 00H
$SG14351 DB	'                RELRECORD', 00H
	ORG $+2
$SG14352 DB	'                cOwnerMember = ', 00H
$SG14354 DB	'                Record name = ', 00H
	ORG $+1
$SG14356 DB	'                Record ID = ', 00H
	ORG $+3
$SG14358 DB	'                Set name 1 = ', 00H
	ORG $+2
$SG14360 DB	'                Set 1 ID = ', 00H
$SG14362 DB	'                Set name 2 = ', 00H
	ORG $+2
$SG14364 DB	'                Set 2 ID = ', 00H
$SG14368 DB	'                     RELFIELD:', 00H
	ORG $+1
$SG14370 DB	'                     Source entity = ', 00H
	ORG $+2
$SG14371 DB	'                     Source attrib = ', 00H
	ORG $+2
$SG14373 DB	'                     Rel entity = ', 00H
	ORG $+1
$SG14374 DB	'                     Rel attrib = ', 00H
	ORG $+1
$SG14376 DB	'                     Field name = ', 00H
	ORG $+1
$SG13403 DB	'Operation Counts:', 00H
	ORG $+2
$SG13406 DB	'   ', 00H
$SG13410 DB	')', 00H
	ORG $+2
$SG13411 DB	', External calls (', 00H
	ORG $+1
$SG13412 DB	'), Internal calls (', 00H
$SG13413 DB	')', 00H
	ORG $+2
$SG13415 DB	'   Total external calls: ', 00H
	ORG $+2
$SG13416 DB	'   Total internal calls: ', 00H
	ORG $+2
$SG13417 DB	':', 00H
	ORG $+2
$SG13418 DB	':', 00H
	ORG $+2
$SG13419 DB	'.', 00H
	ORG $+2
$SG13420 DB	'   Start time: ', 00H
$SG13421 DB	':', 00H
	ORG $+2
$SG13422 DB	':', 00H
	ORG $+2
$SG13423 DB	'.', 00H
	ORG $+2
$SG13424 DB	'   Stop  time: ', 00H
$SG13425 DB	'!!!', 00H
$SG13426 DB	'   ERROR counting not active', 00H
	ORG $+3
$SG13481 DB	'(null)', 00H
	ORG $+1
$SG13488 DB	' +   ', 00H
	ORG $+2
$SG13495 DB	' +   ', 00H
	ORG $+2
$SG13496 DB	'(oetr) Invalid "null" TraceLine title', 00H
	ORG $+2
$SG13512 DB	'Error formatting message: ', 00H
	ORG $+1
$SG13548 DB	'%s  %d Repeat Lines (%4d thru %4d) ', 00H
$SG13550 DB	'%s(%4d) ', 00H
	ORG $+3
$SG13551 DB	'    ', 00H
	ORG $+3
$SG13553 DB	'   ', 00H
$SG13556 DB	'0', 00H
	ORG $+2
$SG13557 DB	' ', 00H
	ORG $+2
$SG13560 DB	'.', 00H
	ORG $+2
$SG14615 DB	'(tr) CompareOI_ToOI - Entity Structure mismatch', 00H
$SG14645 DB	'(tr) CompareOI_ToOI - Src and Tgt are same instance', 00H
_szBlankLine DB	'                                                        '
	DB	'                        ', 00H
	ORG $+3
$SG14621 DB	'(tr) CompareOI_ToOI - Entity Instance mismatch', 00H
	ORG $+1
$SG14625 DB	' Empty', 00H
	ORG $+1
$SG14626 DB	'(tr) CompareOI_ToOI - Entity Structure mismatch', 00H
$SG14642 DB	'CompareOI_ToOI - Object type mismatch', 00H
	ORG $+2
$SG13642 DB	'Entity Instance Display: %s  for view: 0x%08x', 00H
	ORG $+2
$SG13646 DB	'    Cursor is NULL or Undefined for ', 00H
	ORG $+3
$SG13685 DB	'    Cursor is NULL or Undefined for ', 00H
	ORG $+3
$SG13686 DB	'----', 00H
	ORG $+3
$SG13687 DB	'---- Begin Entity Instance Path Display ', 00H
	ORG $+3
$SG13688 DB	'----', 00H
	ORG $+3
$SG13689 DB	'---- End   Entity Instance Path Display ', 00H
	ORG $+3
$SG13744 DB	'Object Instance is NULL for entity ', 00H
$SG13747 DB	'Object Instance Display for View Id: 0x%08x  Def: %s', 00H
	ORG $+3
$SG13802 DB	'TraceAllAttributes', 00H
	ORG $+1
$SG13803 DB	'[Debug]', 00H
$SG13804 DB	'                            ', 00H
	ORG $+3
$SG13806 DB	' *', 00H
	ORG $+1
$SG13808 DB	'%s|==>%s%s', 00H
	ORG $+1
$SG13809 DB	'   ', 00H
$SG13812 DB	'UNSET', 00H
	ORG $+2
$SG13813 DB	'   Cursor for EntityInstance is ', 00H
	ORG $+3
$SG13816 DB	'NULL', 00H
	ORG $+3
$SG13817 DB	'   Cursor for EntityInstance is ', 00H
	ORG $+3
$SG13818 DB	'Incremental Update Flags: ', 00H
	ORG $+1
$SG13821 DB	' Start', 00H
	ORG $+1
$SG13822 DB	'>>>EntityInstance flags:', 00H
	ORG $+3
$SG13825 DB	'>>>EntityInstance is hidden', 00H
$SG13828 DB	'>>>EntityInstance is temporal', 00H
	ORG $+2
$SG13831 DB	'>>>EntityInstance has a previous version', 00H
	ORG $+3
$SG13834 DB	'>>>EntityInstance is a previous version', 00H
$SG13837 DB	'>>>EntityInstance is a previous version root', 00H
	ORG $+3
$SG13838 DB	' End', 00H
	ORG $+3
$SG13839 DB	'>>>EntityInstance flags:', 00H
	ORG $+3
$SG13841 DB	'C', 00H
	ORG $+2
$SG13843 DB	'I', 00H
	ORG $+2
$SG13845 DB	'D', 00H
	ORG $+2
$SG13847 DB	'X', 00H
	ORG $+2
$SG13849 DB	'U', 00H
	ORG $+2
$SG13851 DB	'>>>EntityInstance Tag:', 00H
	ORG $+1
$SG13853 DB	'>>>EntityInstance  ', 00H
$SG13855 DB	'Selected(', 00H
	ORG $+2
$SG13858 DB	',', 00H
	ORG $+2
$SG13859 DB	') ', 00H
	ORG $+1
$SG13860 DB	'Entity Key: ', 00H
	ORG $+3
$SG13861 DB	'%s%s%d', 00H
	ORG $+1
$SG13864 DB	'Blob Lth=', 00H
	ORG $+2
$SG13880 DB	'EntityInstance  ', 00H
	ORG $+3
$SG13883 DB	'       is UNSET', 00H
$SG13888 DB	'       is NULL', 00H
	ORG $+1
$SG13892 DB	'       level  ', 00H
	ORG $+1
$SG13893 DB	'       name   ', 00H
	ORG $+1
$SG13902 DB	'EntityCsr', 00H
	ORG $+2
$SG13905 DB	'       level  ', 00H
	ORG $+1
$SG13906 DB	'       hier   ', 00H
	ORG $+1
$SG13907 DB	'       name   ', 00H
	ORG $+1
$SG13909 DB	'       is NULL', 00H
	ORG $+1
$SG13954 DB	'View Cursor Info for Object ', 00H
	ORG $+3
$SG13956 DB	'  RootViewEntityCsr', 00H
$SG13960 DB	'ViewCsr HierRootInstance', 00H
	ORG $+3
$SG13964 DB	'ViewCsr HierInstance', 00H
	ORG $+3
$SG13968 DB	'ViewCsr ViewParentInstance', 00H
	ORG $+1
$SG13971 DB	'The number of entities is ', 00H
	ORG $+1
$SG13972 DB	'Entity number ', 00H
	ORG $+1
$SG13973 DB	'       level  ', 00H
	ORG $+1
$SG13974 DB	'       hier   ', 00H
	ORG $+1
$SG13975 DB	'       name   ', 00H
	ORG $+1
$SG13978 DB	'Subobject Information ', 00H
	ORG $+1
$SG13980 DB	'**ViewRootParentCsr', 00H
$SG13982 DB	'**SubobjectRootCsr', 00H
	ORG $+1
$SG13983 DB	'**Hierarchical number of root csr ', 00H
	ORG $+1
$SG13985 DB	'**LastDescendentCsr', 00H
$SG13986 DB	'**LastDescHierNbr ', 00H
	ORG $+1
$SG13988 DB	'**ViewParentEntityInstance', 00H
	ORG $+1
$SG13990 DB	'**RootEntityInstance', 00H
	ORG $+3
$SG13992 DB	'..Recursive subobject info..', 00H
	ORG $+3
$SG13993 DB	'  Level adjustment ', 00H
$SG13996 DB	'**Recursive View Entity: ', 00H
	ORG $+2
$SG13997 DB	'NULL', 00H
	ORG $+3
$SG13998 DB	'**Recursive View Entity: ', 00H
	ORG $+2
$SG14000 DB	'            View Entity Csr', 00H
$SG14002 DB	'        Parent EntityInstance', 00H
	ORG $+2
$SG14004 DB	'..End Recursive subobject info..', 00H
	ORG $+3
$SG14021 DB	'      ENTITY Name = ', 00H
	ORG $+3
$SG14022 DB	'      Level = ', 00H
	ORG $+1
$SG14024 DB	'      XML name = ', 00H
	ORG $+2
$SG14026 DB	'      Parent name = ', 00H
	ORG $+3
$SG14027 DB	'      Hier number = ', 00H
	ORG $+3
$SG14028 DB	'      Card min = ', 00H
	ORG $+2
$SG14029 DB	'      Card max = ', 00H
	ORG $+2
$SG14030 DB	'      Record size = ', 00H
	ORG $+3
$SG14031 DB	'      NonPersist size = ', 00H
	ORG $+3
$SG14032 DB	'      Max Attr lth = ', 00H
	ORG $+2
$SG14033 DB	'      Lock Level      = ', 00H
	ORG $+3
$SG14035 DB	'      Database name = ', 00H
	ORG $+1
$SG14037 DB	'      Server name = ', 00H
	ORG $+3
$SG14039 DB	'      ECEOper name = ', 00H
	ORG $+2
$SG14041 DB	'      Flags:', 00H
	ORG $+3
$SG14044 DB	'          bCreate', 00H
	ORG $+2
$SG14047 DB	'          bDelete', 00H
	ORG $+2
$SG14050 DB	'          bUpdate', 00H
	ORG $+2
$SG14053 DB	'          bInclude', 00H
	ORG $+1
$SG14056 DB	'          bExclude', 00H
	ORG $+1
$SG14059 DB	'          bInclSrc', 00H
	ORG $+1
$SG14062 DB	'          bHidden', 00H
	ORG $+2
$SG14065 DB	'          bPDelete', 00H
	ORG $+1
$SG14068 DB	'          bPRestrict', 00H
	ORG $+3
$SG14071 DB	'          bCheckRestrict', 00H
	ORG $+3
$SG14074 DB	'          bRecursiveSt', 00H
	ORG $+1
$SG14077 DB	'          bAutoCreate', 00H
	ORG $+2
$SG14080 DB	'          bDerived', 00H
	ORG $+1
$SG14083 DB	'          bDerivedPath', 00H
	ORG $+1
$SG14086 DB	'          bGenkey', 00H
	ORG $+2
$SG14089 DB	'          bAttrInit', 00H
$SG14092 DB	'          bAttrOrder', 00H
	ORG $+3
$SG14095 DB	'          bAttrOrderChild', 00H
	ORG $+2
$SG14098 DB	'          bAutoSeq', 00H
	ORG $+1
$SG14101 DB	'          bIncrLoad', 00H
$SG14104 DB	'          bFullPersist', 00H
	ORG $+1
$SG14107 DB	'          bSharesParRec', 00H
$SG14110 DB	'          bSharesChdRec', 00H
$SG14113 DB	'          bDupInstance', 00H
	ORG $+1
$SG14116 DB	'          bDupRel', 00H
	ORG $+2
$SG14119 DB	'          bDupRelPath', 00H
	ORG $+2
$SG14122 DB	'          bRelLink1', 00H
$SG14125 DB	'          bCreateConstraint', 00H
$SG14128 DB	'          bDeleteConstraint', 00H
$SG14131 DB	'          bIncludeConstraint', 00H
	ORG $+3
$SG14134 DB	'          bExcludeConstraint', 00H
	ORG $+3
$SG14137 DB	'          bAcceptConstraint', 00H
$SG14140 DB	'          bCancelConstraint', 00H
$SG14143 DB	'          bRequiredChild', 00H
	ORG $+3
$SG14146 DB	'          bAutoLoadFromParent', 00H
	ORG $+2
$SG14149 DB	'          bContainsBlob', 00H
$SG14152 DB	'          bHasDB_Oper', 00H
	ORG $+2
$SG14165 DB	'              ATTRIBUTE Name = ', 00H
$SG14166 DB	'              Type = ', 00H
	ORG $+2
$SG14167 DB	'              ERTok  = ', 00H
$SG14168 DB	'              Length = ', 00H
$SG14169 DB	'              Offset = ', 00H
$SG14171 DB	'              Sequencing # = ', 00H
	ORG $+2
$SG14173 DB	'              DerivedOper = ', 00H
	ORG $+3
$SG14176 DB	'              DerivedXPG = YES', 00H
	ORG $+1
$SG14178 DB	'              DB Oper = ', 00H
	ORG $+3
$SG14180 DB	'              FLAGS:', 00H
	ORG $+3
$SG14183 DB	'                 bPersist', 00H
	ORG $+2
$SG14186 DB	'                 bKey', 00H
	ORG $+2
$SG14189 DB	'                 bForeignKey', 00H
	ORG $+3
$SG14192 DB	'                 bGenkey', 00H
	ORG $+3
$SG14195 DB	'                 bRequired', 00H
	ORG $+1
$SG14198 DB	'                 bHidden', 00H
	ORG $+3
$SG14201 DB	'                 bCaseSens', 00H
	ORG $+1
$SG14204 DB	'                 bCrDate', 00H
	ORG $+3
$SG14207 DB	'                 bUpDate', 00H
	ORG $+3
$SG14210 DB	'                 bUserID', 00H
	ORG $+3
$SG14213 DB	'                 bAutoSeq', 00H
	ORG $+2
$SG14216 DB	'                 bSequencingD', 00H
	ORG $+2
$SG14219 DB	'                 bNoUpdate', 00H
	ORG $+1
$SG14222 DB	'                 bNoPersistUpd', 00H
	ORG $+1
$SG14288 DB	'Tracing object definition', 00H
	ORG $+2
$SG14293 DB	'Cancel Tracing, lpViewOD is null', 00H
	ORG $+3
$SG14294 DB	'Object def name = ', 00H
	ORG $+1
$SG14295 DB	'Database name = ', 00H
	ORG $+3
$SG14297 DB	'OperLib name = ', 00H
$SG14299 DB	'OCEOper name = ', 00H
$SG14301 DB	'DBHandler name = ', 00H
	ORG $+2
$SG14303 DB	'GKHandler name = ', 00H
	ORG $+2
$SG14304 DB	'Entity Count   = ', 00H
	ORG $+2
$SG14305 DB	'Cache Number   = ', 00H
	ORG $+2
$SG14306 DB	'Lock Level     = ', 00H
	ORG $+2
$SG14307 DB	'Ent Lock Level = ', 00H
	ORG $+2
$SG14309 DB	'Flags: ', 00H
$SG14312 DB	'     bHasDupInstance', 00H
	ORG $+3
$SG14315 DB	'     bHasDupRel', 00H
$SG14318 DB	'     bHasDerivedPath', 00H
	ORG $+3
$SG14321 DB	'     bActivateConstraint', 00H
	ORG $+3
$SG14324 DB	'     bActivateEmptyConstraint', 00H
	ORG $+2
$SG14327 DB	'     bCommitConstraint', 00H
	ORG $+1
$SG14330 DB	'     bDropOIConstraint', 00H
	ORG $+1
$SG14333 DB	'     bDeprecated', 00H
_DATA	ENDS
PUBLIC	_OperationCount@8
PUBLIC	_TraceLineI@8
PUBLIC	_TraceLineX@8
PUBLIC	_TraceBlob@12
PUBLIC	_DisplayEntityInstance@8
PUBLIC	_DisplayEntityInstancePath@8
PUBLIC	_DisplayObjectInstance@12
PUBLIC	_TraceLineS@8
PUBLIC	_TraceLine
PUBLIC	_TraceBuffer@12
PUBLIC	_DisplayObjectDef@8
PUBLIC	_CompareEntitiesIgnoringAttrs@20
PUBLIC	_CompareEntityToEntity@16
PUBLIC	_CompareOI_ToOI@8
PUBLIC	_DisplayCursorInfo@4
PUBLIC	_GetTracingFlags@0
PUBLIC	_fnDisplayEntityInstance
PUBLIC	_fnCompareOI_ToOI
PUBLIC	_fnCompareEntityToEntity
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsnprintf
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_SetHexBuffer
PUBLIC	_FormatInteger
PUBLIC	_TraceHex@8
PUBLIC	_fnShowEntityInstanceInfo
PUBLIC	_fnShowViewEntityCsrInfo
PUBLIC	_fnTraceViewEntity@4
PUBLIC	_fnTraceViewAttrib@8
PUBLIC	_fnCompareEntitiesIgnoringAttrs
PUBLIC	_fnCompareSkipEntityInstance
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__strrchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_SetViewFromView@8:PROC
EXTRN	_DropView@4:PROC
EXTRN	_ResetViewPositions@4:PROC
EXTRN	_SysGetDateTime@4:PROC
EXTRN	_SysMessageList@4:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysGetOperationMessage@12:PROC
EXTRN	_fnGetStringFromAttribute:PROC
EXTRN	_fnGetAttributeLength:PROC
EXTRN	_fnResetCursorForViewChildren:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnEstablishViewForInstance:PROC
EXTRN	_fnValidateInstanceParameters:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidViewCsr:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnDeclareView@20:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_fnCompareEIAttrs@36:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_hAnchorBlock:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpOldEntityInstance$ = -20				; size = 4
_lpViewEntity$1 = -16					; size = 4
tv128 = -12						; size = 4
_nLevel$2 = -8						; size = 2
_bSkip$3 = -1						; size = 1
_ppEntityInstance$ = 8					; size = 4
_lControl$ = 12						; size = 4
_fnCompareSkipEntityInstance PROC

; 2179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2180 :    LPENTITYINSTANCE lpOldEntityInstance = *ppEntityInstance;

	mov	eax, DWORD PTR _ppEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpOldEntityInstance$[ebp], ecx
$LN2@fnCompareS:

; 2181 : 
; 2182 :    // Skip entity instances for the following reasons:
; 2183 :    //   (1) Entity instance is hidden
; 2184 :    //   (2) User has indicated that we should ignore included instances
; 2185 :    //       and the entity instance is included.
; 2186 :    // Note that if any of the above conditions are true for a particular
; 2187 :    // entity, then we can safely skip over ALL the child entities for that
; 2188 :    // entity.  If we add a condition that doesn't allow us to skip children
; 2189 :    // (e.g. skip derived entities) then we will need another 'while' loop.
; 2190 :    while ( (*ppEntityInstance) )

	mov	edx, DWORD PTR _ppEntityInstance$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN3@fnCompareS

; 2191 :    {
; 2192 :       zBOOL bSkip;
; 2193 :       LPVIEWENTITY lpViewEntity = zGETPTR( (*ppEntityInstance)->hViewEntity );

	mov	eax, DWORD PTR _ppEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 2194 : 
; 2195 :       // If the user only wants to compare persistant data, see if the
; 2196 :       // current entity instance has a data record.  If it doesn't, then
; 2197 :       // the entity isn't persistent.
; 2198 :       if ( lControl & zCOMPAREOI_PERSISTONLY &&

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2
	je	SHORT $LN7@fnCompareS
	mov	ecx, DWORD PTR _lpViewEntity$1[ebp]
	cmp	DWORD PTR [ecx+191], 0
	jne	SHORT $LN7@fnCompareS

; 2199 :            lpViewEntity->hFirstDataRecord == 0 )
; 2200 :       {
; 2201 :          (*ppEntityInstance) = zGETPTR( (*ppEntityInstance)->hNextHier );

	mov	edx, DWORD PTR _ppEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _ppEntityInstance$[ebp]
	mov	DWORD PTR [edx], eax

; 2202 :          continue;

	jmp	SHORT $LN2@fnCompareS
$LN7@fnCompareS:

; 2203 :       }
; 2204 : 
; 2205 :       // We use bSkip for readability's sake.  We start off by assuming that
; 2206 :       // we will not skip the current *ppEntityInstance.  We then check each
; 2207 :       // of the reasons we would skip the entity instance.  If any of them
; 2208 :       // come up TRUE, then we set bSkip to indicate that we're going to
; 2209 :       // skip the entity instance.
; 2210 : 
; 2211 :       // Assume that we're not going to skip the entity instance.
; 2212 :       bSkip = FALSE;

	mov	BYTE PTR _bSkip$3[ebp], 0

; 2213 : 
; 2214 :       // Skip the entity instance if it's hidden.
; 2215 :       if ( (*ppEntityInstance)->u.nInd.bHidden )

	mov	eax, DWORD PTR _ppEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN8@fnCompareS

; 2216 :          bSkip = TRUE;

	mov	BYTE PTR _bSkip$3[ebp], 1
$LN8@fnCompareS:

; 2217 : 
; 2218 :       // If we're not skipping the current entity instance, then break the
; 2219 :       // loop.
; 2220 :       if ( bSkip == FALSE )

	movzx	eax, BYTE PTR _bSkip$3[ebp]
	test	eax, eax
	jne	SHORT $LN9@fnCompareS

; 2221 :          break;

	jmp	SHORT $LN3@fnCompareS
$LN9@fnCompareS:

; 2222 : 
; 2223 :       // Skip the current entity and all its children.
; 2224 :       if ( (*ppEntityInstance)->hNextTwin )

	mov	ecx, DWORD PTR _ppEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN10@fnCompareS

; 2225 :       {
; 2226 :          // Current entity has a twin, so set the twin as 'current'.
; 2227 :          (*ppEntityInstance) = zGETPTR( (*ppEntityInstance)->hNextTwin );

	mov	eax, DWORD PTR _ppEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _ppEntityInstance$[ebp]
	mov	DWORD PTR [ecx], eax

; 2228 :       }

	jmp	SHORT $LN11@fnCompareS
$LN10@fnCompareS:

; 2229 :       else
; 2230 :       {
; 2231 :          zSHORT nLevel;
; 2232 : 
; 2233 :          // Current entity has no twin, so look for the next entity that has
; 2234 :          // a level that is less than or equal to the 'current' entity.  This
; 2235 :          // will set (*ppEntityInstance) to the next entity in hier order
; 2236 :          // that is not a child of the 'current' entity.
; 2237 :          nLevel = (*ppEntityInstance)->nLevel;

	mov	edx, DWORD PTR _ppEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cx, WORD PTR [eax+58]
	mov	WORD PTR _nLevel$2[ebp], cx
$LN6@fnCompareS:

; 2238 :          do
; 2239 :          {
; 2240 :             (*ppEntityInstance) = zGETPTR( (*ppEntityInstance)->hNextHier );

	mov	edx, DWORD PTR _ppEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _ppEntityInstance$[ebp]
	mov	DWORD PTR [edx], eax

; 2241 :          } while ( (*ppEntityInstance) &&

	mov	eax, DWORD PTR _ppEntityInstance$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN11@fnCompareS
	mov	ecx, DWORD PTR _ppEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, WORD PTR [edx+58]
	movsx	ecx, WORD PTR _nLevel$2[ebp]
	cmp	eax, ecx
	jg	SHORT $LN6@fnCompareS
$LN11@fnCompareS:

; 2242 :                    (*ppEntityInstance)->nLevel > nLevel );
; 2243 :       }
; 2244 : 
; 2245 :    } // while...

	jmp	$LN2@fnCompareS
$LN3@fnCompareS:

; 2246 : 
; 2247 :    return( *ppEntityInstance == lpOldEntityInstance );

	mov	edx, DWORD PTR _ppEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _lpOldEntityInstance$[ebp]
	jne	SHORT $LN14@fnCompareS
	mov	DWORD PTR tv128[ebp], 1
	jmp	SHORT $LN15@fnCompareS
$LN14@fnCompareS:
	mov	DWORD PTR tv128[ebp], 0
$LN15@fnCompareS:
	mov	al, BYTE PTR tv128[ebp]

; 2248 : 
; 2249 : } // fnCompareSkipEntityInstance

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareSkipEntityInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpFirstSrcViewAttrib$1 = -60				; size = 4
_lpViewOI$ = -56					; size = 4
_lpCurrentTask$ = -52					; size = 4
tv211 = -48						; size = 4
tv210 = -44						; size = 4
tv159 = -40						; size = 4
tv158 = -36						; size = 4
tv136 = -32						; size = 4
tv135 = -28						; size = 4
_lpCompareViewAttrib$2 = -24				; size = 4
_lpSrcViewAttrib$3 = -20				; size = 4
_lpTgtViewAttrib$4 = -16				; size = 4
_pch$ = -12						; size = 4
_pchSemi$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpTgtViewEntity$ = 8					; size = 4
_lpTgtEntityInstance$ = 12				; size = 4
_lpSrcViewEntity$ = 16					; size = 4
_lpSrcEntityInstance$ = 20				; size = 4
_pchAttrList$ = 24					; size = 4
_fnCompareEntitiesIgnoringAttrs PROC

; 1972 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1973 :    zPCHAR   pch;
; 1974 :    zPCHAR   pchSemi;
; 1975 :    zSHORT   nRC;
; 1976 :    LPVIEWOI lpViewOI      = zGETPTR( lpSrcEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1977 :    LPTASK   lpCurrentTask = zGETPTR( lpViewOI->hTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 1978 : 
; 1979 :    // Start by assuming that the entities are equal.
; 1980 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 1981 : 
; 1982 :    if ( lpTgtViewEntity != lpSrcViewEntity )

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	cmp	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	je	$LN14@fnCompareE

; 1983 :    {
; 1984 :       LPVIEWATTRIB lpFirstSrcViewAttrib;
; 1985 :       LPVIEWATTRIB lpTgtViewAttrib;
; 1986 :       LPVIEWATTRIB lpSrcViewAttrib;
; 1987 : 
; 1988 :       // The view entities are different, so compare attributes by name.
; 1989 :       lpFirstSrcViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSrcViewAttrib$1[ebp], eax

; 1990 :       for ( lpTgtViewAttrib = zGETPTR( lpTgtViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewAttrib$4[ebp], eax
	jmp	SHORT $LN4@fnCompareE
$LN2@fnCompareE:

; 1992 :             lpTgtViewAttrib = zGETPTR( lpTgtViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewAttrib$4[ebp], eax
$LN4@fnCompareE:

; 1991 :             lpTgtViewAttrib;

	cmp	DWORD PTR _lpTgtViewAttrib$4[ebp], 0
	je	$LN3@fnCompareE

; 1993 :       {
; 1994 :          if ( lpTgtViewAttrib->bHidden )

	mov	eax, DWORD PTR _lpTgtViewAttrib$4[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN16@fnCompareE

; 1995 :             continue;

	jmp	SHORT $LN2@fnCompareE
$LN16@fnCompareE:

; 1996 : 
; 1997 :          pch = pchAttrList;

	mov	edx, DWORD PTR _pchAttrList$[ebp]
	mov	DWORD PTR _pch$[ebp], edx
$LN5@fnCompareE:

; 1998 :          while ( pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	$LN6@fnCompareE

; 1999 :          {
; 2000 :             pchSemi = zstrchr( pch, ';' );

	push	59					; 0000003bH
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchSemi$[ebp], eax

; 2001 :             if ( pchSemi )

	cmp	DWORD PTR _pchSemi$[ebp], 0
	je	SHORT $LN17@fnCompareE

; 2002 :                *pchSemi = 0;

	mov	ecx, DWORD PTR _pchSemi$[ebp]
	mov	BYTE PTR [ecx], 0
$LN17@fnCompareE:

; 2003 : 
; 2004 :             if ( zstrcmp( pch, lpTgtViewAttrib->szName ) == 0 )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	eax, edx
	jne	SHORT $LN35@fnCompareE
	mov	eax, DWORD PTR _lpTgtViewAttrib$4[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN36@fnCompareE
$LN35@fnCompareE:
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN33@fnCompareE
	mov	DWORD PTR tv135[ebp], 1
	jmp	SHORT $LN34@fnCompareE
$LN33@fnCompareE:
	mov	DWORD PTR tv135[ebp], -1
$LN34@fnCompareE:
	mov	eax, DWORD PTR tv135[ebp]
	mov	DWORD PTR tv136[ebp], eax
$LN36@fnCompareE:
	cmp	DWORD PTR tv136[ebp], 0
	jne	SHORT $LN18@fnCompareE

; 2005 :             {
; 2006 :                if ( pchSemi )

	cmp	DWORD PTR _pchSemi$[ebp], 0
	je	SHORT $LN19@fnCompareE

; 2007 :                   *pchSemi = ';';

	mov	ecx, DWORD PTR _pchSemi$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
$LN19@fnCompareE:

; 2008 : 
; 2009 :                break;

	jmp	SHORT $LN6@fnCompareE
$LN18@fnCompareE:

; 2010 :             }
; 2011 : 
; 2012 :             if ( pchSemi )

	cmp	DWORD PTR _pchSemi$[ebp], 0
	je	SHORT $LN20@fnCompareE

; 2013 :                *pchSemi = ';';

	mov	edx, DWORD PTR _pchSemi$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
$LN20@fnCompareE:

; 2014 : 
; 2015 :             pch = pchSemi;

	mov	eax, DWORD PTR _pchSemi$[ebp]
	mov	DWORD PTR _pch$[ebp], eax

; 2016 :          }

	jmp	$LN5@fnCompareE
$LN6@fnCompareE:

; 2017 : 
; 2018 :          if ( pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN21@fnCompareE

; 2019 :             continue;

	jmp	$LN2@fnCompareE
$LN21@fnCompareE:

; 2020 : 
; 2021 :          // Find the src view attrib that has the same name as lpTgtViewAttrib
; 2022 :          lpSrcViewAttrib = lpFirstSrcViewAttrib;

	mov	ecx, DWORD PTR _lpFirstSrcViewAttrib$1[ebp]
	mov	DWORD PTR _lpSrcViewAttrib$3[ebp], ecx
$LN7@fnCompareE:

; 2023 :          while ( lpSrcViewAttrib &&

	cmp	DWORD PTR _lpSrcViewAttrib$3[ebp], 0
	je	SHORT $LN8@fnCompareE
	mov	edx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	eax, edx
	jne	SHORT $LN39@fnCompareE
	mov	eax, DWORD PTR _lpTgtViewAttrib$4[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv159[ebp], eax
	jmp	SHORT $LN40@fnCompareE
$LN39@fnCompareE:
	mov	edx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN37@fnCompareE
	mov	DWORD PTR tv158[ebp], 1
	jmp	SHORT $LN38@fnCompareE
$LN37@fnCompareE:
	mov	DWORD PTR tv158[ebp], -1
$LN38@fnCompareE:
	mov	eax, DWORD PTR tv158[ebp]
	mov	DWORD PTR tv159[ebp], eax
$LN40@fnCompareE:
	cmp	DWORD PTR tv159[ebp], 0
	je	SHORT $LN8@fnCompareE

; 2024 :                  zstrcmp( lpSrcViewAttrib->szName,
; 2025 :                           lpTgtViewAttrib->szName ) != 0 )
; 2026 :          {
; 2027 :             lpSrcViewAttrib = zGETPTR( lpSrcViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$3[ebp], eax

; 2028 :          }

	jmp	SHORT $LN7@fnCompareE
$LN8@fnCompareE:

; 2029 : 
; 2030 :          // If no matching attr was found skip it.
; 2031 :          if ( lpSrcViewAttrib == 0 )

	cmp	DWORD PTR _lpSrcViewAttrib$3[ebp], 0
	jne	SHORT $LN22@fnCompareE

; 2032 :             continue;

	jmp	$LN2@fnCompareE
$LN22@fnCompareE:

; 2033 : 
; 2034 :          if ( lpSrcViewAttrib->bHidden )

	mov	eax, DWORD PTR _lpSrcViewAttrib$3[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN23@fnCompareE

; 2035 :             continue;

	jmp	$LN2@fnCompareE
$LN23@fnCompareE:

; 2036 : 
; 2037 :          if ( fnCompareEIAttrs( lpCurrentTask,
; 2038 :                                 0, lpTgtEntityInstance, lpTgtViewAttrib, 0,
; 2039 :                                 0, lpSrcEntityInstance,
; 2040 :                                 lpSrcViewAttrib, 0 ) != 0 )

	push	0
	mov	edx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnCompareEIAttrs@36
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN24@fnCompareE

; 2041 :          {
; 2042 :             return( 1 ); // Indicate unequal.

	mov	eax, 1
	jmp	$LN1@fnCompareE
$LN24@fnCompareE:

; 2043 :          }
; 2044 : 
; 2045 :       }  // for ( lpTgtViewAttrib... )...

	jmp	$LN2@fnCompareE
$LN3@fnCompareE:

; 2046 : 
; 2047 :    } // if ( lpTgtViewEntity != lpSrcViewEntity )...

	jmp	$LN15@fnCompareE
$LN14@fnCompareE:

; 2048 :    else
; 2049 :    {
; 2050 :       LPVIEWATTRIB lpCompareViewAttrib;
; 2051 : 
; 2052 :       // Compare each attribute for the entities.
; 2053 :       for ( lpCompareViewAttrib = zGETPTR( lpTgtViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareViewAttrib$2[ebp], eax
	jmp	SHORT $LN11@fnCompareE
$LN9@fnCompareE:

; 2055 :             lpCompareViewAttrib = zGETPTR( lpCompareViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareViewAttrib$2[ebp], eax
$LN11@fnCompareE:

; 2054 :             lpCompareViewAttrib;

	cmp	DWORD PTR _lpCompareViewAttrib$2[ebp], 0
	je	$LN15@fnCompareE

; 2056 :       {
; 2057 :          if ( lpCompareViewAttrib->bHidden )

	mov	eax, DWORD PTR _lpCompareViewAttrib$2[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN25@fnCompareE

; 2058 :             continue;

	jmp	SHORT $LN9@fnCompareE
$LN25@fnCompareE:

; 2059 : 
; 2060 :          pch = pchAttrList;

	mov	edx, DWORD PTR _pchAttrList$[ebp]
	mov	DWORD PTR _pch$[ebp], edx
$LN12@fnCompareE:

; 2061 :          while ( pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	$LN13@fnCompareE

; 2062 :          {
; 2063 :             pchSemi = zstrchr( pch, ';' );

	push	59					; 0000003bH
	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	mov	DWORD PTR _pchSemi$[ebp], eax

; 2064 :             if ( pchSemi )

	cmp	DWORD PTR _pchSemi$[ebp], 0
	je	SHORT $LN26@fnCompareE

; 2065 :                *pchSemi = 0;

	mov	ecx, DWORD PTR _pchSemi$[ebp]
	mov	BYTE PTR [ecx], 0
$LN26@fnCompareE:

; 2066 : 
; 2067 :             if ( zstrcmp( pch, lpCompareViewAttrib->szName ) == 0 )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	cmp	eax, edx
	jne	SHORT $LN43@fnCompareE
	mov	eax, DWORD PTR _lpCompareViewAttrib$2[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv211[ebp], eax
	jmp	SHORT $LN44@fnCompareE
$LN43@fnCompareE:
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN41@fnCompareE
	mov	DWORD PTR tv210[ebp], 1
	jmp	SHORT $LN42@fnCompareE
$LN41@fnCompareE:
	mov	DWORD PTR tv210[ebp], -1
$LN42@fnCompareE:
	mov	eax, DWORD PTR tv210[ebp]
	mov	DWORD PTR tv211[ebp], eax
$LN44@fnCompareE:
	cmp	DWORD PTR tv211[ebp], 0
	jne	SHORT $LN27@fnCompareE

; 2068 :             {
; 2069 :                if ( pchSemi )

	cmp	DWORD PTR _pchSemi$[ebp], 0
	je	SHORT $LN28@fnCompareE

; 2070 :                   *pchSemi = ';';

	mov	ecx, DWORD PTR _pchSemi$[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
$LN28@fnCompareE:

; 2071 : 
; 2072 :                break;

	jmp	SHORT $LN13@fnCompareE
$LN27@fnCompareE:

; 2073 :             }
; 2074 : 
; 2075 :             if ( pchSemi )

	cmp	DWORD PTR _pchSemi$[ebp], 0
	je	SHORT $LN29@fnCompareE

; 2076 :                *pchSemi = ';';

	mov	edx, DWORD PTR _pchSemi$[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
$LN29@fnCompareE:

; 2077 : 
; 2078 :             pch = pchSemi;

	mov	eax, DWORD PTR _pchSemi$[ebp]
	mov	DWORD PTR _pch$[ebp], eax

; 2079 :          }

	jmp	$LN12@fnCompareE
$LN13@fnCompareE:

; 2080 : 
; 2081 :          if ( pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN30@fnCompareE

; 2082 :             continue;

	jmp	$LN9@fnCompareE
$LN30@fnCompareE:

; 2083 : 
; 2084 :          // Compare the attributes.
; 2085 :          if ( fnCompareEIAttrs( lpCurrentTask,
; 2086 :                                 0, lpTgtEntityInstance, lpCompareViewAttrib, 0,
; 2087 :                                 0, lpSrcEntityInstance,
; 2088 :                                 lpCompareViewAttrib, 0 ) != 0 )

	push	0
	mov	ecx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _lpCompareViewAttrib$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnCompareEIAttrs@36
	cwde
	test	eax, eax
	je	SHORT $LN31@fnCompareE

; 2089 :          {
; 2090 :             return( 1 ); // Indicate unequal.

	mov	eax, 1
	jmp	SHORT $LN1@fnCompareE
$LN31@fnCompareE:

; 2091 :          }
; 2092 : 
; 2093 :       }  // while ( lpCompareViewAttrib )...

	jmp	$LN9@fnCompareE
$LN15@fnCompareE:

; 2094 : 
; 2095 :    }  // if (...) else...
; 2096 : 
; 2097 :    return( 0 );

	xor	eax, eax
$LN1@fnCompareE:

; 2098 : 
; 2099 : }  /* fnCompareEntitiesIgnoringAttrs */

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareEntitiesIgnoringAttrs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpViewAttrib$ = 8					; size = 4
_s$ = 12						; size = 4
_fnTraceViewAttrib@8 PROC

; 1449 : {

	push	ebp
	mov	ebp, esp

; 1450 :    TraceLineS( "", "" );

	push	OFFSET $SG14163
	push	OFFSET $SG14164
	call	_TraceLineS@8

; 1451 :    TraceLineS( "              ATTRIBUTE Name = ",

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14165
	call	_TraceLineS@8

; 1452 :                lpViewAttrib->szName );
; 1453 : 
; 1454 :    s[ 0 ] = lpViewAttrib->cType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [ecx+202]
	mov	BYTE PTR [eax+edx], cl

; 1455 :    TraceLineS( "              Type = ", s );

	mov	edx, DWORD PTR _s$[ebp]
	push	edx
	push	OFFSET $SG14166
	call	_TraceLineS@8

; 1456 :    TraceLineI( "              ERTok  = ", (zLONG) lpViewAttrib->lERAttTok );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+177]
	push	ecx
	push	OFFSET $SG14167
	call	_TraceLineI@8

; 1457 :    TraceLineI( "              Length = ", (zLONG) lpViewAttrib->ulLth );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+203]
	push	eax
	push	OFFSET $SG14168
	call	_TraceLineI@8

; 1458 :    TraceLineI( "              Offset = ",

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+250]
	push	edx
	push	OFFSET $SG14169
	call	_TraceLineI@8

; 1459 :                (zLONG) lpViewAttrib->ulRecordOffset );
; 1460 :    if ( lpViewAttrib->cSequencing > 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movzx	ecx, BYTE PTR [eax+197]
	test	ecx, ecx
	jle	SHORT $LN2@fnTraceVie

; 1461 :       TraceLineI( "              Sequencing # = ",

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movzx	eax, BYTE PTR [edx+197]
	push	eax
	push	OFFSET $SG14171
	call	_TraceLineI@8
$LN2@fnTraceVie:

; 1462 :                   (zLONG) lpViewAttrib->cSequencing );
; 1463 : 
; 1464 :    if ( lpViewAttrib->szDerivedOper[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN3@fnTraceVie

; 1465 :       TraceLineS( "              DerivedOper = ",

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 213				; 000000d5H
	push	edx
	push	OFFSET $SG14173
	call	_TraceLineS@8
$LN3@fnTraceVie:

; 1466 :                   lpViewAttrib->szDerivedOper );
; 1467 : 
; 1468 :    if ( lpViewAttrib->hDerivedXPG )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	cmp	DWORD PTR [eax+255], 0
	je	SHORT $LN4@fnTraceVie

; 1469 :       TraceLineS( "              DerivedXPG = YES", "" );

	push	OFFSET $SG14175
	push	OFFSET $SG14176
	call	_TraceLineS@8
$LN4@fnTraceVie:

; 1470 : 
; 1471 :    if ( lpViewAttrib->cDB_Oper )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+254]
	test	edx, edx
	je	SHORT $LN5@fnTraceVie

; 1472 :    {
; 1473 :       s[ 0 ] = lpViewAttrib->cDB_Oper;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	al, BYTE PTR [eax+254]
	mov	BYTE PTR [edx+ecx], al

; 1474 :       TraceLineS( "              DB Oper = ", s );

	mov	ecx, DWORD PTR _s$[ebp]
	push	ecx
	push	OFFSET $SG14178
	call	_TraceLineS@8
$LN5@fnTraceVie:

; 1475 :    }
; 1476 : 
; 1477 :    TraceLineS( "              FLAGS:", "" );

	push	OFFSET $SG14179
	push	OFFSET $SG14180
	call	_TraceLineS@8

; 1478 :    if ( lpViewAttrib->bPersist )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	je	SHORT $LN6@fnTraceVie

; 1479 :       TraceLineS( "                 bPersist", "" );

	push	OFFSET $SG14182
	push	OFFSET $SG14183
	call	_TraceLineS@8
$LN6@fnTraceVie:

; 1480 : 
; 1481 :    if ( lpViewAttrib->bKey )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN7@fnTraceVie

; 1482 :       TraceLineS( "                 bKey", "" );

	push	OFFSET $SG14185
	push	OFFSET $SG14186
	call	_TraceLineS@8
$LN7@fnTraceVie:

; 1483 : 
; 1484 :    if ( lpViewAttrib->bForeignKey )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN8@fnTraceVie

; 1485 :       TraceLineS( "                 bForeignKey", "" );

	push	OFFSET $SG14188
	push	OFFSET $SG14189
	call	_TraceLineS@8
$LN8@fnTraceVie:

; 1486 : 
; 1487 :    if ( lpViewAttrib->bGenkey )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN9@fnTraceVie

; 1488 :       TraceLineS( "                 bGenkey", "" );

	push	OFFSET $SG14191
	push	OFFSET $SG14192
	call	_TraceLineS@8
$LN9@fnTraceVie:

; 1489 : 
; 1490 :    if ( lpViewAttrib->bRequired )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN10@fnTraceVie

; 1491 :       TraceLineS( "                 bRequired", "" );

	push	OFFSET $SG14194
	push	OFFSET $SG14195
	call	_TraceLineS@8
$LN10@fnTraceVie:

; 1492 : 
; 1493 :    if ( lpViewAttrib->bHidden )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN11@fnTraceVie

; 1494 :       TraceLineS( "                 bHidden", "" );

	push	OFFSET $SG14197
	push	OFFSET $SG14198
	call	_TraceLineS@8
$LN11@fnTraceVie:

; 1495 : 
; 1496 :    if ( lpViewAttrib->bCaseSens )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN12@fnTraceVie

; 1497 :       TraceLineS( "                 bCaseSens", "" );

	push	OFFSET $SG14200
	push	OFFSET $SG14201
	call	_TraceLineS@8
$LN12@fnTraceVie:

; 1498 : 
; 1499 :    if ( lpViewAttrib->bCrDate )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 7
	and	edx, 1
	je	SHORT $LN13@fnTraceVie

; 1500 :       TraceLineS( "                 bCrDate", "" );

	push	OFFSET $SG14203
	push	OFFSET $SG14204
	call	_TraceLineS@8
$LN13@fnTraceVie:

; 1501 : 
; 1502 :    if ( lpViewAttrib->bUpDate )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 8
	and	ecx, 1
	je	SHORT $LN14@fnTraceVie

; 1503 :       TraceLineS( "                 bUpDate", "" );

	push	OFFSET $SG14206
	push	OFFSET $SG14207
	call	_TraceLineS@8
$LN14@fnTraceVie:

; 1504 : 
; 1505 :    if ( lpViewAttrib->bUserID )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN15@fnTraceVie

; 1506 :       TraceLineS( "                 bUserID", "" );

	push	OFFSET $SG14209
	push	OFFSET $SG14210
	call	_TraceLineS@8
$LN15@fnTraceVie:

; 1507 : 
; 1508 :    if ( lpViewAttrib->bAutoSeq )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN16@fnTraceVie

; 1509 :       TraceLineS( "                 bAutoSeq", "" );

	push	OFFSET $SG14212
	push	OFFSET $SG14213
	call	_TraceLineS@8
$LN16@fnTraceVie:

; 1510 : 
; 1511 :    if ( lpViewAttrib->bSequencingD )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN17@fnTraceVie

; 1512 :       TraceLineS( "                 bSequencingD", "" );

	push	OFFSET $SG14215
	push	OFFSET $SG14216
	call	_TraceLineS@8
$LN17@fnTraceVie:

; 1513 : 
; 1514 :    if ( lpViewAttrib->bNoUpdate )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	je	SHORT $LN18@fnTraceVie

; 1515 :       TraceLineS( "                 bNoUpdate", "" );

	push	OFFSET $SG14218
	push	OFFSET $SG14219
	call	_TraceLineS@8
$LN18@fnTraceVie:

; 1516 : 
; 1517 :    if ( lpViewAttrib->bNoPersistUpd )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 13					; 0000000dH
	and	edx, 1
	je	SHORT $LN1@fnTraceVie

; 1518 :       TraceLineS( "                 bNoPersistUpd", "" );

	push	OFFSET $SG14221
	push	OFFSET $SG14222
	call	_TraceLineS@8
$LN1@fnTraceVie:

; 1519 : 
; 1520 : } // fnTraceViewAttrib

	pop	ebp
	ret	8
_fnTraceViewAttrib@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpParent$1 = -4					; size = 4
_lpViewEntity$ = 8					; size = 4
_fnTraceViewEntity@4 PROC

; 1337 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1338 :    TraceLineS( "", "" );

	push	OFFSET $SG14019
	push	OFFSET $SG14020
	call	_TraceLineS@8

; 1339 :    TraceLineS( "      ENTITY Name = ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG14021
	call	_TraceLineS@8

; 1340 :    TraceLineI( "      Level = ", (zLONG) lpViewEntity->nLevel );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	push	edx
	push	OFFSET $SG14022
	call	_TraceLineI@8

; 1341 : 
; 1342 :    if ( lpViewEntity->szXML_Name[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+47]
	test	eax, eax
	je	SHORT $LN2@fnTraceVie

; 1343 :       TraceLineS( "      XML name = ", lpViewEntity->szXML_Name );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 47					; 0000002fH
	push	ecx
	push	OFFSET $SG14024
	call	_TraceLineS@8
$LN2@fnTraceVie:

; 1344 : 
; 1345 :    if ( lpViewEntity->hParent )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN3@fnTraceVie

; 1346 :    {
; 1347 :       LPVIEWENTITY lpParent = zGETPTR( lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$1[ebp], eax

; 1348 :       TraceLineS( "      Parent name = ", lpParent->szName );

	mov	edx, DWORD PTR _lpParent$1[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG14026
	call	_TraceLineS@8
$LN3@fnTraceVie:

; 1349 :    }
; 1350 : 
; 1351 :    TraceLineI( "      Hier number = ", (zLONG) lpViewEntity->nHierNbr );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	push	ecx
	push	OFFSET $SG14027
	call	_TraceLineI@8

; 1352 :    TraceLineI( "      Card min = ", (zLONG) lpViewEntity->uCardMin );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movzx	eax, WORD PTR [edx+219]
	push	eax
	push	OFFSET $SG14028
	call	_TraceLineI@8

; 1353 :    TraceLineI( "      Card max = ", (zLONG) lpViewEntity->uCardMax );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movzx	edx, WORD PTR [ecx+221]
	push	edx
	push	OFFSET $SG14029
	call	_TraceLineI@8

; 1354 :    TraceLineI( "      Record size = ", lpViewEntity->ulRecordSize );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+207]
	push	ecx
	push	OFFSET $SG14030
	call	_TraceLineI@8

; 1355 :    TraceLineI( "      NonPersist size = ",

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+211]
	push	eax
	push	OFFSET $SG14031
	call	_TraceLineI@8

; 1356 :                lpViewEntity->ulNonPersistSize );
; 1357 :    TraceLineI( "      Max Attr lth = ", (zLONG) lpViewEntity->ulMaxLth );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+203]
	push	edx
	push	OFFSET $SG14032
	call	_TraceLineI@8

; 1358 :    TraceLineI( "      Lock Level      = ", (zLONG) lpViewEntity->nLock );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movzx	ecx, BYTE PTR [eax+230]
	push	ecx
	push	OFFSET $SG14033
	call	_TraceLineI@8

; 1359 : 
; 1360 :    if ( lpViewEntity->szDBName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+80]
	test	edx, edx
	je	SHORT $LN4@fnTraceVie

; 1361 :       TraceLineS( "      Database name = ", lpViewEntity->szDBName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	push	OFFSET $SG14035
	call	_TraceLineS@8
$LN4@fnTraceVie:

; 1362 : 
; 1363 :    if ( lpViewEntity->szServer[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+113]
	test	ecx, ecx
	je	SHORT $LN5@fnTraceVie

; 1364 :       TraceLineS( "      Server name = ", lpViewEntity->szServer );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 113				; 00000071H
	push	edx
	push	OFFSET $SG14037
	call	_TraceLineS@8
$LN5@fnTraceVie:

; 1365 : 
; 1366 :    if ( lpViewEntity->szECEOpername[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+146]
	test	eax, eax
	je	SHORT $LN6@fnTraceVie

; 1367 :       TraceLineS( "      ECEOper name = ", lpViewEntity->szECEOpername );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 146				; 00000092H
	push	ecx
	push	OFFSET $SG14039
	call	_TraceLineS@8
$LN6@fnTraceVie:

; 1368 : 
; 1369 :    TraceLineS( "      Flags:", "" );

	push	OFFSET $SG14040
	push	OFFSET $SG14041
	call	_TraceLineS@8

; 1370 :    if ( lpViewEntity->bCreate )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	and	eax, 1
	je	SHORT $LN7@fnTraceVie

; 1371 :       TraceLineS( "          bCreate", "" );

	push	OFFSET $SG14043
	push	OFFSET $SG14044
	call	_TraceLineS@8
$LN7@fnTraceVie:

; 1372 :    if ( lpViewEntity->bDelete )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN8@fnTraceVie

; 1373 :       TraceLineS( "          bDelete", "" );

	push	OFFSET $SG14046
	push	OFFSET $SG14047
	call	_TraceLineS@8
$LN8@fnTraceVie:

; 1374 :    if ( lpViewEntity->bUpdate )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 2
	and	ecx, 1
	je	SHORT $LN9@fnTraceVie

; 1375 :       TraceLineS( "          bUpdate", "" );

	push	OFFSET $SG14049
	push	OFFSET $SG14050
	call	_TraceLineS@8
$LN9@fnTraceVie:

; 1376 :    if ( lpViewEntity->bInclude )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN10@fnTraceVie

; 1377 :       TraceLineS( "          bInclude", "" );

	push	OFFSET $SG14052
	push	OFFSET $SG14053
	call	_TraceLineS@8
$LN10@fnTraceVie:

; 1378 :    if ( lpViewEntity->bExclude )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN11@fnTraceVie

; 1379 :       TraceLineS( "          bExclude", "" );

	push	OFFSET $SG14055
	push	OFFSET $SG14056
	call	_TraceLineS@8
$LN11@fnTraceVie:

; 1380 :    if ( lpViewEntity->bInclSrc )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN12@fnTraceVie

; 1381 :       TraceLineS( "          bInclSrc", "" );

	push	OFFSET $SG14058
	push	OFFSET $SG14059
	call	_TraceLineS@8
$LN12@fnTraceVie:

; 1382 :    if ( lpViewEntity->bHidden )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 6
	and	eax, 1
	je	SHORT $LN13@fnTraceVie

; 1383 :       TraceLineS( "          bHidden", "" );

	push	OFFSET $SG14061
	push	OFFSET $SG14062
	call	_TraceLineS@8
$LN13@fnTraceVie:

; 1384 :    if ( lpViewEntity->bPDelete )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 7
	and	edx, 1
	je	SHORT $LN14@fnTraceVie

; 1385 :       TraceLineS( "          bPDelete", "" );

	push	OFFSET $SG14064
	push	OFFSET $SG14065
	call	_TraceLineS@8
$LN14@fnTraceVie:

; 1386 :    if ( lpViewEntity->bPRestrict )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 8
	and	ecx, 1
	je	SHORT $LN15@fnTraceVie

; 1387 :       TraceLineS( "          bPRestrict", "" );

	push	OFFSET $SG14067
	push	OFFSET $SG14068
	call	_TraceLineS@8
$LN15@fnTraceVie:

; 1388 :    if ( lpViewEntity->bCheckRestrict )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN16@fnTraceVie

; 1389 :       TraceLineS( "          bCheckRestrict", "" );

	push	OFFSET $SG14070
	push	OFFSET $SG14071
	call	_TraceLineS@8
$LN16@fnTraceVie:

; 1390 :    if ( lpViewEntity->bRecursiveSt )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN17@fnTraceVie

; 1391 :       TraceLineS( "          bRecursiveSt", "" );

	push	OFFSET $SG14073
	push	OFFSET $SG14074
	call	_TraceLineS@8
$LN17@fnTraceVie:

; 1392 :    if ( lpViewEntity->bAutoCreate )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	je	SHORT $LN18@fnTraceVie

; 1393 :       TraceLineS( "          bAutoCreate", "" );

	push	OFFSET $SG14076
	push	OFFSET $SG14077
	call	_TraceLineS@8
$LN18@fnTraceVie:

; 1394 :    if ( lpViewEntity->bDerived )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	je	SHORT $LN19@fnTraceVie

; 1395 :       TraceLineS( "          bDerived", "" );

	push	OFFSET $SG14079
	push	OFFSET $SG14080
	call	_TraceLineS@8
$LN19@fnTraceVie:

; 1396 :    if ( lpViewEntity->bDerivedPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 14					; 0000000eH
	and	edx, 1
	je	SHORT $LN20@fnTraceVie

; 1397 :       TraceLineS( "          bDerivedPath", "" );

	push	OFFSET $SG14082
	push	OFFSET $SG14083
	call	_TraceLineS@8
$LN20@fnTraceVie:

; 1398 :    if ( lpViewEntity->bGenkey )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 15					; 0000000fH
	and	ecx, 1
	je	SHORT $LN21@fnTraceVie

; 1399 :       TraceLineS( "          bGenkey", "" );

	push	OFFSET $SG14085
	push	OFFSET $SG14086
	call	_TraceLineS@8
$LN21@fnTraceVie:

; 1400 :    if ( lpViewEntity->bAttrInit )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 17					; 00000011H
	and	eax, 1
	je	SHORT $LN22@fnTraceVie

; 1401 :       TraceLineS( "          bAttrInit", "" );

	push	OFFSET $SG14088
	push	OFFSET $SG14089
	call	_TraceLineS@8
$LN22@fnTraceVie:

; 1402 :    if ( lpViewEntity->bAttrOrder )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 18					; 00000012H
	and	edx, 1
	je	SHORT $LN23@fnTraceVie

; 1403 :       TraceLineS( "          bAttrOrder", "" );

	push	OFFSET $SG14091
	push	OFFSET $SG14092
	call	_TraceLineS@8
$LN23@fnTraceVie:

; 1404 :    if ( lpViewEntity->bAttrOrderChild )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 19					; 00000013H
	and	ecx, 1
	je	SHORT $LN24@fnTraceVie

; 1405 :       TraceLineS( "          bAttrOrderChild", "" );

	push	OFFSET $SG14094
	push	OFFSET $SG14095
	call	_TraceLineS@8
$LN24@fnTraceVie:

; 1406 :    if ( lpViewEntity->bAutoSeq )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 20					; 00000014H
	and	eax, 1
	je	SHORT $LN25@fnTraceVie

; 1407 :       TraceLineS( "          bAutoSeq", "" );

	push	OFFSET $SG14097
	push	OFFSET $SG14098
	call	_TraceLineS@8
$LN25@fnTraceVie:

; 1408 :    if ( lpViewEntity->bIncrLoad )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 21					; 00000015H
	and	edx, 1
	je	SHORT $LN26@fnTraceVie

; 1409 :       TraceLineS( "          bIncrLoad", "" );

	push	OFFSET $SG14100
	push	OFFSET $SG14101
	call	_TraceLineS@8
$LN26@fnTraceVie:

; 1410 :    if ( lpViewEntity->bFullPersist )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 22					; 00000016H
	and	ecx, 1
	je	SHORT $LN27@fnTraceVie

; 1411 :       TraceLineS( "          bFullPersist", "" );

	push	OFFSET $SG14103
	push	OFFSET $SG14104
	call	_TraceLineS@8
$LN27@fnTraceVie:

; 1412 :    if ( lpViewEntity->bSharesParRec )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 23					; 00000017H
	and	eax, 1
	je	SHORT $LN28@fnTraceVie

; 1413 :       TraceLineS( "          bSharesParRec", "" );

	push	OFFSET $SG14106
	push	OFFSET $SG14107
	call	_TraceLineS@8
$LN28@fnTraceVie:

; 1414 :    if ( lpViewEntity->bSharesChdRec )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 24					; 00000018H
	and	edx, 1
	je	SHORT $LN29@fnTraceVie

; 1415 :       TraceLineS( "          bSharesChdRec", "" );

	push	OFFSET $SG14109
	push	OFFSET $SG14110
	call	_TraceLineS@8
$LN29@fnTraceVie:

; 1416 :    if ( lpViewEntity->bDupInstance )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 25					; 00000019H
	and	ecx, 1
	je	SHORT $LN30@fnTraceVie

; 1417 :       TraceLineS( "          bDupInstance", "" );

	push	OFFSET $SG14112
	push	OFFSET $SG14113
	call	_TraceLineS@8
$LN30@fnTraceVie:

; 1418 :    if ( lpViewEntity->bDupRel )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 26					; 0000001aH
	and	eax, 1
	je	SHORT $LN31@fnTraceVie

; 1419 :       TraceLineS( "          bDupRel", "" );

	push	OFFSET $SG14115
	push	OFFSET $SG14116
	call	_TraceLineS@8
$LN31@fnTraceVie:

; 1420 :    if ( lpViewEntity->bDupRelPath )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 27					; 0000001bH
	and	edx, 1
	je	SHORT $LN32@fnTraceVie

; 1421 :       TraceLineS( "          bDupRelPath", "" );

	push	OFFSET $SG14118
	push	OFFSET $SG14119
	call	_TraceLineS@8
$LN32@fnTraceVie:

; 1422 :    if ( lpViewEntity->bRelLink1 )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 28					; 0000001cH
	and	ecx, 1
	je	SHORT $LN33@fnTraceVie

; 1423 :       TraceLineS( "          bRelLink1", "" );

	push	OFFSET $SG14121
	push	OFFSET $SG14122
	call	_TraceLineS@8
$LN33@fnTraceVie:

; 1424 :    if ( lpViewEntity->bCreateConstraint )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN34@fnTraceVie

; 1425 :       TraceLineS( "          bCreateConstraint", "" );

	push	OFFSET $SG14124
	push	OFFSET $SG14125
	call	_TraceLineS@8
$LN34@fnTraceVie:

; 1426 :    if ( lpViewEntity->bDeleteConstraint )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN35@fnTraceVie

; 1427 :       TraceLineS( "          bDeleteConstraint", "" );

	push	OFFSET $SG14127
	push	OFFSET $SG14128
	call	_TraceLineS@8
$LN35@fnTraceVie:

; 1428 :    if ( lpViewEntity->bIncludeConstraint )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN36@fnTraceVie

; 1429 :       TraceLineS( "          bIncludeConstraint", "" );

	push	OFFSET $SG14130
	push	OFFSET $SG14131
	call	_TraceLineS@8
$LN36@fnTraceVie:

; 1430 :    if ( lpViewEntity->bExcludeConstraint )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN37@fnTraceVie

; 1431 :       TraceLineS( "          bExcludeConstraint", "" );

	push	OFFSET $SG14133
	push	OFFSET $SG14134
	call	_TraceLineS@8
$LN37@fnTraceVie:

; 1432 :    if ( lpViewEntity->bAcceptConstraint )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN38@fnTraceVie

; 1433 :       TraceLineS( "          bAcceptConstraint", "" );

	push	OFFSET $SG14136
	push	OFFSET $SG14137
	call	_TraceLineS@8
$LN38@fnTraceVie:

; 1434 :    if ( lpViewEntity->bCancelConstraint )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN39@fnTraceVie

; 1435 :       TraceLineS( "          bCancelConstraint", "" );

	push	OFFSET $SG14139
	push	OFFSET $SG14140
	call	_TraceLineS@8
$LN39@fnTraceVie:

; 1436 :    if ( lpViewEntity->bRequiredChild )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN40@fnTraceVie

; 1437 :       TraceLineS( "          bRequiredChild", "" );

	push	OFFSET $SG14142
	push	OFFSET $SG14143
	call	_TraceLineS@8
$LN40@fnTraceVie:

; 1438 :    if ( lpViewEntity->bAutoLoadFromParent )

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+235]
	shr	edx, 30					; 0000001eH
	and	edx, 1
	je	SHORT $LN41@fnTraceVie

; 1439 :       TraceLineS( "          bAutoLoadFromParent", "" );

	push	OFFSET $SG14145
	push	OFFSET $SG14146
	call	_TraceLineS@8
$LN41@fnTraceVie:

; 1440 :    if ( lpViewEntity->bContainsBlob )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 31					; 0000001fH
	and	ecx, 1
	je	SHORT $LN42@fnTraceVie

; 1441 :       TraceLineS( "          bContainsBlob", "" );

	push	OFFSET $SG14148
	push	OFFSET $SG14149
	call	_TraceLineS@8
$LN42@fnTraceVie:

; 1442 :    if ( lpViewEntity->bHasDB_Oper )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	and	eax, 1
	je	SHORT $LN1@fnTraceVie

; 1443 :       TraceLineS( "          bHasDB_Oper", "" );

	push	OFFSET $SG14151
	push	OFFSET $SG14152
	call	_TraceLineS@8
$LN1@fnTraceVie:

; 1444 : 
; 1445 : } // fnTraceViewEntity

	mov	esp, ebp
	pop	ebp
	ret	4
_fnTraceViewEntity@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpViewEntity$ = -4					; size = 4
_lpViewEntityCsr$ = 8					; size = 4
_fnShowViewEntityCsrInfo PROC

; 1195 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1196 :    LPVIEWENTITY lpViewEntity;
; 1197 : 
; 1198 :    TraceLineS( "EntityCsr", "" );

	push	OFFSET $SG13901
	push	OFFSET $SG13902
	call	_TraceLineS@8

; 1199 :    if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN2@fnShowView

; 1200 :    {
; 1201 :       TraceLineI( "       level  ", lpViewEntityCsr->nLevel );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	push	ecx
	push	OFFSET $SG13905
	call	_TraceLineI@8

; 1202 :       TraceLineI( "       hier   ", lpViewEntityCsr->nHierNbr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+24]
	push	eax
	push	OFFSET $SG13906
	call	_TraceLineI@8

; 1203 :       lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1204 :       TraceLineS( "       name   ", lpViewEntity->szName );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG13907
	call	_TraceLineS@8

; 1205 :       fnShowEntityInstanceInfo( zGETPTR( lpViewEntityCsr->hEntityInstance ) );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowEntityInstanceInfo
	add	esp, 4

; 1206 :    }

	jmp	SHORT $LN1@fnShowView
$LN2@fnShowView:

; 1207 :    else
; 1208 :    {
; 1209 :       TraceLineS( "       is NULL", "" );

	push	OFFSET $SG13908
	push	OFFSET $SG13909
	call	_TraceLineS@8

; 1210 :       TraceLineS( "", "" );

	push	OFFSET $SG13910
	push	OFFSET $SG13911
	call	_TraceLineS@8

; 1211 :       TraceLineS( "", "" );

	push	OFFSET $SG13912
	push	OFFSET $SG13913
	call	_TraceLineS@8
$LN1@fnShowView:

; 1212 :    }
; 1213 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnShowViewEntityCsrInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpViewEntity$ = -8					; size = 4
tv66 = -4						; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnShowEntityInstanceInfo PROC

; 1170 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1171 :    LPVIEWENTITY lpViewEntity;
; 1172 : 
; 1173 :    TraceLineS( "EntityInstance  ", "" );

	push	OFFSET $SG13879
	push	OFFSET $SG13880
	call	_TraceLineS@8

; 1174 :    switch ( (zLONG) lpEntityInstance )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 0
	je	SHORT $LN5@fnShowEnti
	cmp	DWORD PTR tv66[ebp], 1
	je	SHORT $LN4@fnShowEnti
	jmp	SHORT $LN6@fnShowEnti
$LN4@fnShowEnti:

; 1175 :    {
; 1176 :       case (zLONG) UNSET_CSR:
; 1177 :          TraceLineS( "       is UNSET", "" );

	push	OFFSET $SG13882
	push	OFFSET $SG13883
	call	_TraceLineS@8

; 1178 :          TraceLineS( "", "" );

	push	OFFSET $SG13884
	push	OFFSET $SG13885
	call	_TraceLineS@8

; 1179 :          break;

	jmp	SHORT $LN1@fnShowEnti
$LN5@fnShowEnti:

; 1180 : 
; 1181 :       case (zLONG) NULL_CSR:
; 1182 :          TraceLineS( "       is NULL", "" );

	push	OFFSET $SG13887
	push	OFFSET $SG13888
	call	_TraceLineS@8

; 1183 :          TraceLineS( "", "" );

	push	OFFSET $SG13889
	push	OFFSET $SG13890
	call	_TraceLineS@8

; 1184 :          break;

	jmp	SHORT $LN1@fnShowEnti
$LN6@fnShowEnti:

; 1185 : 
; 1186 :       default:
; 1187 :          TraceLineI( "       level  ", lpEntityInstance->nLevel );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	push	edx
	push	OFFSET $SG13892
	call	_TraceLineI@8

; 1188 :          lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1189 :          TraceLineS( "       name   ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13893
	call	_TraceLineS@8
$LN1@fnShowEnti:

; 1190 :    }
; 1191 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnShowEntityInstanceInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_pchEnd$ = -284						; size = 4
$T1 = -280						; size = 4
_pch$ = -276						; size = 4
_k$ = -272						; size = 2
_j$ = -268						; size = 2
_ch$ = -261						; size = 1
_szBuffer$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_pvBlob$ = 8						; size = 4
_lBlobLth$ = 12						; size = 4
_TraceHex@8 PROC

; 626  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 627  :    zCHAR  szBuffer[ 256 ];
; 628  :    zPCHAR pch = (zPCHAR) pvBlob;

	mov	eax, DWORD PTR _pvBlob$[ebp]
	mov	DWORD PTR _pch$[ebp], eax

; 629  :    zPCHAR pchEnd = pch + lBlobLth;

	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, DWORD PTR _lBlobLth$[ebp]
	mov	DWORD PTR _pchEnd$[ebp], ecx

; 630  :    unsigned char ch;
; 631  :    zSHORT k;
; 632  :    zSHORT j;
; 633  : 
; 634  :    k = 1;

	mov	edx, 1
	mov	WORD PTR _k$[ebp], dx

; 635  :    zstrcpy( szBuffer, szBlankLine );

	push	OFFSET _szBlankLine
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 636  :    szBuffer[ 34 ] = '-';

	mov	ecx, 1
	imul	edx, ecx, 34
	mov	BYTE PTR _szBuffer$[ebp+edx], 45	; 0000002dH

; 637  :    szBuffer[ 59 ] = szBuffer[ 76 ] = (zCHAR) 0xB3;

	mov	eax, 1
	imul	ecx, eax, 76
	mov	BYTE PTR _szBuffer$[ebp+ecx], -77	; ffffffb3H
	mov	edx, 1
	imul	eax, edx, 59
	mov	BYTE PTR _szBuffer$[ebp+eax], -77	; ffffffb3H

; 638  :    szBuffer[ 77 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 77
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN10@TraceHex
	jmp	SHORT $LN11@TraceHex
$LN10@TraceHex:
	call	___report_rangecheckfailure
$LN11@TraceHex:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szBuffer$[ebp+eax], 0
$LN2@TraceHex:

; 639  :    while ( pch < pchEnd )

	mov	ecx, DWORD PTR _pch$[ebp]
	cmp	ecx, DWORD PTR _pchEnd$[ebp]
	jae	$LN9@TraceHex

; 640  :    {
; 641  :       FormatInteger( szBuffer, (k - 1) * 16, 9, '0' );

	push	48					; 00000030H
	push	9
	movsx	edx, WORD PTR _k$[ebp]
	sub	edx, 1
	shl	edx, 4
	push	edx
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_FormatInteger
	add	esp, 16					; 00000010H

; 642  : 
; 643  :       for ( j = 0; j < 16; j++, pch++ )

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx
	jmp	SHORT $LN6@TraceHex
$LN4@TraceHex:
	mov	dx, WORD PTR _j$[ebp]
	add	dx, 1
	mov	WORD PTR _j$[ebp], dx
	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
$LN6@TraceHex:
	movsx	ecx, WORD PTR _j$[ebp]
	cmp	ecx, 16					; 00000010H
	jge	SHORT $LN5@TraceHex

; 644  :       {
; 645  :          if ( pch < pchEnd )

	mov	edx, DWORD PTR _pch$[ebp]
	cmp	edx, DWORD PTR _pchEnd$[ebp]
	jae	SHORT $LN7@TraceHex

; 646  :             ch = *pch;

	mov	eax, DWORD PTR _pch$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _ch$[ebp], cl
	jmp	SHORT $LN8@TraceHex
$LN7@TraceHex:

; 647  :          else
; 648  :             ch = 0;

	mov	BYTE PTR _ch$[ebp], 0
$LN8@TraceHex:

; 649  : 
; 650  :          SetHexBuffer( szBuffer + 11, j, ch );

	movzx	edx, BYTE PTR _ch$[ebp]
	push	edx
	movzx	eax, WORD PTR _j$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szBuffer$[ebp+11]
	push	ecx
	call	_SetHexBuffer
	add	esp, 12					; 0000000cH

; 651  :       }

	jmp	SHORT $LN4@TraceHex
$LN5@TraceHex:

; 652  : 
; 653  :       TraceLineS( szBuffer, "" );

	push	OFFSET $SG13608
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_TraceLineS@8

; 654  :       k++;

	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax

; 655  :    }

	jmp	$LN2@TraceHex
$LN9@TraceHex:

; 656  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TraceHex@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_pchBuffer$ = 8						; size = 4
_lValue$ = 12						; size = 4
_nDigits$ = 16						; size = 2
_chFill$ = 20						; size = 1
_FormatInteger PROC

; 603  : {

	push	ebp
	mov	ebp, esp
$LN2@FormatInte:

; 604  :    while ( nDigits )

	movsx	eax, WORD PTR _nDigits$[ebp]
	test	eax, eax
	je	SHORT $LN1@FormatInte

; 605  :    {
; 606  :       nDigits--;

	mov	cx, WORD PTR _nDigits$[ebp]
	sub	cx, 1
	mov	WORD PTR _nDigits$[ebp], cx

; 607  :       if ( lValue )

	cmp	DWORD PTR _lValue$[ebp], 0
	je	SHORT $LN4@FormatInte

; 608  :       {
; 609  :          pchBuffer[ nDigits ] = '0' + lValue % 10;

	mov	eax, DWORD PTR _lValue$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	add	edx, 48					; 00000030H
	movsx	eax, WORD PTR _nDigits$[ebp]
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 610  :       }

	jmp	SHORT $LN5@FormatInte
$LN4@FormatInte:

; 611  :       else
; 612  :       {
; 613  :          pchBuffer[ nDigits ] = chFill;

	movsx	edx, WORD PTR _nDigits$[ebp]
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	mov	cl, BYTE PTR _chFill$[ebp]
	mov	BYTE PTR [eax+edx], cl
$LN5@FormatInte:

; 614  :       }
; 615  : 
; 616  :       lValue /= 10;

	mov	eax, DWORD PTR _lValue$[ebp]
	cdq
	mov	ecx, 10					; 0000000aH
	idiv	ecx
	mov	DWORD PTR _lValue$[ebp], eax

; 617  :    }

	jmp	SHORT $LN2@FormatInte
$LN1@FormatInte:

; 618  : }

	pop	ebp
	ret	0
_FormatInteger ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
tv144 = -16						; size = 4
tv128 = -12						; size = 4
tv79 = -8						; size = 4
_chHex$ = -1						; size = 1
_pchBuffer$ = 8						; size = 4
_nOffset$ = 12						; size = 2
_ch$ = 16						; size = 1
_SetHexBuffer PROC

; 584  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 585  :    unsigned char chHex;
; 586  : 
; 587  : // pchBuffer[ nOffset + 49 ] = (isprint( ch ) || ch != 0xA1) ? '.' : ch;
; 588  :    pchBuffer[ nOffset + 49 ] =

	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 161				; 000000a1H
	je	SHORT $LN3@SetHexBuff
	movzx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 10					; 0000000aH
	je	SHORT $LN3@SetHexBuff
	movzx	edx, BYTE PTR _ch$[ebp]
	cmp	edx, 255				; 000000ffH
	je	SHORT $LN3@SetHexBuff
	movzx	eax, BYTE PTR _ch$[ebp]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN3@SetHexBuff
	movzx	ecx, BYTE PTR _ch$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@SetHexBuff
	movzx	edx, BYTE PTR _ch$[ebp]
	mov	DWORD PTR tv79[ebp], edx
	jmp	SHORT $LN4@SetHexBuff
$LN3@SetHexBuff:
	mov	DWORD PTR tv79[ebp], 46			; 0000002eH
$LN4@SetHexBuff:
	movsx	eax, WORD PTR _nOffset$[ebp]
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	dl, BYTE PTR tv79[ebp]
	mov	BYTE PTR [ecx+eax+49], dl

; 589  :          (ch == 0xA1 || ch == '\n' || ch == 0xFF ||
; 590  :           ch == '\r' || ch == 0) ? '.' : ch;
; 591  :    chHex = ch % 16;

	movzx	eax, BYTE PTR _ch$[ebp]
	and	eax, -2147483633			; 8000000fH
	jns	SHORT $LN9@SetHexBuff
	dec	eax
	or	eax, -16				; fffffff0H
	inc	eax
$LN9@SetHexBuff:
	mov	BYTE PTR _chHex$[ebp], al

; 592  :    pchBuffer[ nOffset * 3 + 1 ] = (chHex > 9) ? 'A' + chHex - 10 : '0' + chHex;

	movzx	ecx, BYTE PTR _chHex$[ebp]
	cmp	ecx, 9
	jle	SHORT $LN5@SetHexBuff
	movzx	edx, BYTE PTR _chHex$[ebp]
	add	edx, 55					; 00000037H
	mov	DWORD PTR tv128[ebp], edx
	jmp	SHORT $LN6@SetHexBuff
$LN5@SetHexBuff:
	movzx	eax, BYTE PTR _chHex$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR tv128[ebp], eax
$LN6@SetHexBuff:
	movsx	ecx, WORD PTR _nOffset$[ebp]
	imul	edx, ecx, 3
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	mov	cl, BYTE PTR tv128[ebp]
	mov	BYTE PTR [eax+edx+1], cl

; 593  :    chHex = ch / 16;

	movzx	eax, BYTE PTR _ch$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	BYTE PTR _chHex$[ebp], al

; 594  :    pchBuffer[ nOffset * 3 ] = (chHex > 9) ? 'A' + chHex - 10 : '0' + chHex;

	movzx	edx, BYTE PTR _chHex$[ebp]
	cmp	edx, 9
	jle	SHORT $LN7@SetHexBuff
	movzx	eax, BYTE PTR _chHex$[ebp]
	add	eax, 55					; 00000037H
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN8@SetHexBuff
$LN7@SetHexBuff:
	movzx	ecx, BYTE PTR _chHex$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR tv144[ebp], ecx
$LN8@SetHexBuff:
	movsx	edx, WORD PTR _nOffset$[ebp]
	imul	eax, edx, 3
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	mov	dl, BYTE PTR tv144[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 595  : // pchBuffer[ nOffset * 3 + 2 ] = (nOffset == 7) ? '-' : ' ';
; 596  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SetHexBuffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsnprintf PROC					; COMDAT

; 1405 : {

	push	ebp
	mov	ebp, esp

; 1406 :     #pragma warning(push)
; 1407 :     #pragma warning(disable: 4996) // Deprecation
; 1408 :     return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR __Format$[ebp]
	push	ecx
	mov	edx, DWORD PTR __BufferCount$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1409 :     #pragma warning(pop)
; 1410 : }

	pop	ebp
	ret	0
__vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpFirstSrcViewAttrib$1 = -36				; size = 4
_lpViewOI$ = -32					; size = 4
_lpCurrentTask$ = -28					; size = 4
tv146 = -24						; size = 4
tv145 = -20						; size = 4
_lpCompareViewAttrib$2 = -16				; size = 4
_lpSrcViewAttrib$3 = -12				; size = 4
_lpTgtViewAttrib$4 = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTgtViewEntity$ = 8					; size = 4
_lpTgtEntityInstance$ = 12				; size = 4
_lpSrcViewEntity$ = 16					; size = 4
_lpSrcEntityInstance$ = 20				; size = 4
_bPersistOnly$ = 24					; size = 1
_bKeysOnly$ = 28					; size = 1
_fnCompareEntityToEntity PROC

; 1793 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 1794 :    LPVIEWOI lpViewOI      = zGETPTR( lpSrcEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpSrcEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1795 :    LPTASK   lpCurrentTask = zGETPTR( lpViewOI->hTask );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 1796 :    zSHORT   nRC;
; 1797 : 
; 1798 :    // Start by assuming that the entities are equal.
; 1799 :    nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 1800 : 
; 1801 :    if ( lpTgtViewEntity != lpSrcViewEntity )

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	cmp	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	je	$LN10@fnCompareE

; 1802 :    {
; 1803 :       LPVIEWATTRIB lpFirstSrcViewAttrib;
; 1804 :       LPVIEWATTRIB lpTgtViewAttrib;
; 1805 :       LPVIEWATTRIB lpSrcViewAttrib;
; 1806 : 
; 1807 :       // The view entities are different, so compare attributes by name.
; 1808 :       lpFirstSrcViewAttrib = zGETPTR( lpSrcViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstSrcViewAttrib$1[ebp], eax

; 1809 :       for ( lpTgtViewAttrib = zGETPTR( lpTgtViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewAttrib$4[ebp], eax
	jmp	SHORT $LN4@fnCompareE
$LN2@fnCompareE:

; 1811 :             lpTgtViewAttrib = zGETPTR( lpTgtViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewAttrib$4[ebp], eax
$LN4@fnCompareE:

; 1810 :             lpTgtViewAttrib;

	cmp	DWORD PTR _lpTgtViewAttrib$4[ebp], 0
	je	$LN3@fnCompareE

; 1812 :       {
; 1813 :          if ( bPersistOnly && lpTgtViewAttrib->bPersist == FALSE )

	movzx	eax, BYTE PTR _bPersistOnly$[ebp]
	test	eax, eax
	je	SHORT $LN12@fnCompareE
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+193]
	and	edx, 1
	jne	SHORT $LN12@fnCompareE

; 1814 :             continue;

	jmp	SHORT $LN2@fnCompareE
$LN12@fnCompareE:

; 1815 : 
; 1816 :          if ( bKeysOnly && lpTgtViewAttrib->bKey == FALSE )

	movzx	eax, BYTE PTR _bKeysOnly$[ebp]
	test	eax, eax
	je	SHORT $LN13@fnCompareE
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN13@fnCompareE

; 1817 :             continue;

	jmp	SHORT $LN2@fnCompareE
$LN13@fnCompareE:

; 1818 : 
; 1819 :          if ( lpTgtViewAttrib->bHidden )

	mov	eax, DWORD PTR _lpTgtViewAttrib$4[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	je	SHORT $LN14@fnCompareE

; 1820 :             continue;

	jmp	SHORT $LN2@fnCompareE
$LN14@fnCompareE:

; 1821 : 
; 1822 :          // Find the src view attrib that has the same name as lpTgtViewAttrib
; 1823 :          lpSrcViewAttrib = lpFirstSrcViewAttrib;

	mov	edx, DWORD PTR _lpFirstSrcViewAttrib$1[ebp]
	mov	DWORD PTR _lpSrcViewAttrib$3[ebp], edx
$LN5@fnCompareE:

; 1824 :          while ( lpSrcViewAttrib &&

	cmp	DWORD PTR _lpSrcViewAttrib$3[ebp], 0
	je	SHORT $LN6@fnCompareE
	mov	eax, DWORD PTR _lpSrcViewAttrib$3[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	movsx	eax, BYTE PTR [edx+10]
	cmp	ecx, eax
	jne	SHORT $LN25@fnCompareE
	mov	ecx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN26@fnCompareE
$LN25@fnCompareE:
	mov	eax, DWORD PTR _lpSrcViewAttrib$3[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	movsx	eax, BYTE PTR [edx+10]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN23@fnCompareE
	mov	DWORD PTR tv145[ebp], 1
	jmp	SHORT $LN24@fnCompareE
$LN23@fnCompareE:
	mov	DWORD PTR tv145[ebp], -1
$LN24@fnCompareE:
	mov	ecx, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv146[ebp], ecx
$LN26@fnCompareE:
	cmp	DWORD PTR tv146[ebp], 0
	je	SHORT $LN6@fnCompareE

; 1825 :                  zstrcmp( lpSrcViewAttrib->szName,
; 1826 :                           lpTgtViewAttrib->szName ) != 0 )
; 1827 :          {
; 1828 :             lpSrcViewAttrib = zGETPTR( lpSrcViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewAttrib$3[ebp], eax

; 1829 :          }

	jmp	SHORT $LN5@fnCompareE
$LN6@fnCompareE:

; 1830 : 
; 1831 :          // If no matching attr was found skip it.
; 1832 :          if ( lpSrcViewAttrib == 0 )

	cmp	DWORD PTR _lpSrcViewAttrib$3[ebp], 0
	jne	SHORT $LN15@fnCompareE

; 1833 :             continue;

	jmp	$LN2@fnCompareE
$LN15@fnCompareE:

; 1834 : 
; 1835 :          if ( lpSrcViewAttrib->bHidden )

	mov	ecx, DWORD PTR _lpSrcViewAttrib$3[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN16@fnCompareE

; 1836 :             continue;

	jmp	$LN2@fnCompareE
$LN16@fnCompareE:

; 1837 : 
; 1838 :          if ( fnCompareEIAttrs( lpCurrentTask,
; 1839 :                                 0, lpTgtEntityInstance, lpTgtViewAttrib, 0,
; 1840 :                                 0, lpSrcEntityInstance, lpSrcViewAttrib, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpSrcViewAttrib$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _lpTgtViewAttrib$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCompareEIAttrs@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN17@fnCompareE

; 1841 :          {
; 1842 :             return( 1 ); // Indicate unequal.

	mov	eax, 1
	jmp	$LN1@fnCompareE
$LN17@fnCompareE:

; 1843 :          }
; 1844 : 
; 1845 :       }  // for ( lpTgtViewAttrib... )...

	jmp	$LN2@fnCompareE
$LN3@fnCompareE:

; 1846 : 
; 1847 :    } // if ( lpTgtViewEntity != lpSrcViewEntity )...

	jmp	$LN11@fnCompareE
$LN10@fnCompareE:

; 1848 :    else
; 1849 :    {
; 1850 :       LPVIEWATTRIB lpCompareViewAttrib;
; 1851 : 
; 1852 :       // Compare each attribute for the entities.
; 1853 :       for ( lpCompareViewAttrib = zGETPTR( lpTgtViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareViewAttrib$2[ebp], eax
	jmp	SHORT $LN9@fnCompareE
$LN7@fnCompareE:

; 1855 :             lpCompareViewAttrib = zGETPTR( lpCompareViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCompareViewAttrib$2[ebp], eax
$LN9@fnCompareE:

; 1854 :             lpCompareViewAttrib;

	cmp	DWORD PTR _lpCompareViewAttrib$2[ebp], 0
	je	SHORT $LN11@fnCompareE

; 1856 :       {
; 1857 :          if ( bPersistOnly && lpCompareViewAttrib->bPersist == FALSE )

	movzx	ecx, BYTE PTR _bPersistOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@fnCompareE
	mov	edx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	jne	SHORT $LN18@fnCompareE

; 1858 :             continue;

	jmp	SHORT $LN7@fnCompareE
$LN18@fnCompareE:

; 1859 : 
; 1860 :          if ( bKeysOnly && lpCompareViewAttrib->bKey == FALSE )

	movzx	ecx, BYTE PTR _bKeysOnly$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@fnCompareE
	mov	edx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN19@fnCompareE

; 1861 :             continue;

	jmp	SHORT $LN7@fnCompareE
$LN19@fnCompareE:

; 1862 : 
; 1863 :          if ( lpCompareViewAttrib->bHidden )

	mov	ecx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	mov	edx, DWORD PTR [ecx+193]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN20@fnCompareE

; 1864 :             continue;

	jmp	SHORT $LN7@fnCompareE
$LN20@fnCompareE:

; 1865 : 
; 1866 :          // Compare the attributes.
; 1867 :          if ( fnCompareEIAttrs( lpCurrentTask,
; 1868 :                                 0, lpTgtEntityInstance, lpCompareViewAttrib, 0,
; 1869 :                                 0, lpSrcEntityInstance,
; 1870 :                                 lpCompareViewAttrib, 0 ) != 0 )

	push	0
	mov	eax, DWORD PTR _lpCompareViewAttrib$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcEntityInstance$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _lpCompareViewAttrib$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnCompareEIAttrs@36
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN21@fnCompareE

; 1871 :          {
; 1872 :             return( 1 ); // Indicate unequal.

	mov	eax, 1
	jmp	SHORT $LN1@fnCompareE
$LN21@fnCompareE:

; 1873 :          }
; 1874 : 
; 1875 :       }  // while ( lpCompareViewAttrib )...

	jmp	$LN7@fnCompareE
$LN11@fnCompareE:

; 1876 : 
; 1877 :    }  // if (...) else...
; 1878 : 
; 1879 :    return( 0 );

	xor	eax, eax
$LN1@fnCompareE:

; 1880 : 
; 1881 : }  /* fnCompareEntityToEntity */

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareEntityToEntity ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpSrcEntity$1 = -36					; size = 4
_lpTgtViewOI$ = -32					; size = 4
_lpSrcViewOI$ = -28					; size = 4
_lpViewCsr$ = -24					; size = 4
_lpTgtEntity$2 = -20					; size = 4
_lpTgtInstance$ = -16					; size = 4
_lpSrcInstance$ = -12					; size = 4
_nRC$ = -8						; size = 2
_bComparePersistOnly$ = -2				; size = 1
_bCompareKeysOnly$ = -1					; size = 1
_lpTgtView$ = 8						; size = 4
_lpSrcView$ = 12					; size = 4
_lControl$ = 16						; size = 4
_fnCompareOI_ToOI PROC

; 2291 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2292 :    zSHORT            nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2293 :    LPVIEWCSR         lpViewCsr;
; 2294 :    LPVIEWOI          lpSrcViewOI;
; 2295 :    LPVIEWOI          lpTgtViewOI;
; 2296 :    LPENTITYINSTANCE  lpSrcInstance;
; 2297 :    LPENTITYINSTANCE  lpTgtInstance;
; 2298 :    zBOOL             bComparePersistOnly;
; 2299 :    zBOOL             bCompareKeysOnly;
; 2300 : 
; 2301 :    bComparePersistOnly = (zBOOL) (lControl & zCOMPAREOI_PERSISTONLY);

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2
	mov	BYTE PTR _bComparePersistOnly$[ebp], cl

; 2302 : 
; 2303 :    lpViewCsr   = zGETPTR( lpSrcView->hViewCsr );

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2304 :    lpSrcViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 2305 :    lpViewCsr   = zGETPTR( lpTgtView->hViewCsr );

	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2306 :    lpTgtViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax

; 2307 : 
; 2308 :    for ( lpSrcInstance = zGETPTR( lpSrcViewOI->hRootEntityInstance ),

	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$[ebp], eax
	mov	eax, DWORD PTR _lpTgtViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtInstance$[ebp], eax
	jmp	SHORT $LN4@fnCompareO
$LN2@fnCompareO:

; 2311 :          lpSrcInstance = zGETPTR( lpSrcInstance->hNextHier ),

	mov	edx, DWORD PTR _lpSrcInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcInstance$[ebp], eax
	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtInstance$[ebp], eax
$LN4@fnCompareO:

; 2309 :          lpTgtInstance = zGETPTR( lpTgtViewOI->hRootEntityInstance );
; 2310 :          lpSrcInstance && lpTgtInstance;

	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	je	$LN3@fnCompareO
	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	$LN3@fnCompareO

; 2312 :          lpTgtInstance = zGETPTR( lpTgtInstance->hNextHier ) )
; 2313 :    {
; 2314 :       LPVIEWENTITY lpTgtEntity;
; 2315 :       LPVIEWENTITY lpSrcEntity;
; 2316 : 
; 2317 :       // Root out undesired entities (e.g. hidden entities).
; 2318 :       if ( fnCompareSkipEntityInstance( &lpSrcInstance, lControl ) )

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpSrcInstance$[ebp]
	push	ecx
	call	_fnCompareSkipEntityInstance
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@fnCompareO

; 2319 :          if ( lpSrcInstance == 0 )

	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	jne	SHORT $LN5@fnCompareO

; 2320 :             break;

	jmp	$LN3@fnCompareO
$LN5@fnCompareO:

; 2321 : 
; 2322 :       if ( fnCompareSkipEntityInstance( &lpTgtInstance, lControl ) )

	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpTgtInstance$[ebp]
	push	ecx
	call	_fnCompareSkipEntityInstance
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN7@fnCompareO

; 2323 :          if ( lpTgtInstance == 0 )

	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	jne	SHORT $LN7@fnCompareO

; 2324 :             break;

	jmp	$LN3@fnCompareO
$LN7@fnCompareO:

; 2325 : 
; 2326 :       lpTgtEntity = zGETPTR( lpTgtInstance->hViewEntity );

	mov	eax, DWORD PTR _lpTgtInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtEntity$2[ebp], eax

; 2327 :       lpSrcEntity = zGETPTR( lpSrcInstance->hViewEntity );

	mov	edx, DWORD PTR _lpSrcInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcEntity$1[ebp], eax

; 2328 : 
; 2329 :       // If entity types are different or if the level of the instances don't
; 2330 :       // match (possible with recursive entities) then return with mismatch.
; 2331 :       if ( lpSrcEntity != lpTgtEntity ||

	mov	ecx, DWORD PTR _lpSrcEntity$1[ebp]
	cmp	ecx, DWORD PTR _lpTgtEntity$2[ebp]
	jne	SHORT $LN10@fnCompareO
	mov	edx, DWORD PTR _lpSrcInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	je	SHORT $LN9@fnCompareO
$LN10@fnCompareO:

; 2332 :            lpSrcInstance->nLevel != lpTgtInstance->nLevel )
; 2333 :       {
; 2334 :          TraceLineS( "(tr) CompareOI_ToOI - Entity Structure mismatch", "" );

	push	OFFSET $SG14614
	push	OFFSET $SG14615
	call	_TraceLineS@8

; 2335 :          return( 2 );

	mov	eax, 2
	jmp	$LN1@fnCompareO
$LN9@fnCompareO:

; 2336 :       }
; 2337 : 
; 2338 :       // Assume we're going to compare all attributes.
; 2339 :       bCompareKeysOnly = FALSE;

	mov	BYTE PTR _bCompareKeysOnly$[ebp], 0

; 2340 : 
; 2341 :       // If the control flag indicates we are to ignore non-keys in
; 2342 :       // include-only entities, check for include/create.
; 2343 :       if ( lControl & zCOMPAREOI_IGNOREINC )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1
	je	SHORT $LN11@fnCompareO

; 2344 :       {
; 2345 :          if ( lpTgtEntity->bCreate == FALSE && lpTgtEntity->bUpdate == FALSE )

	mov	ecx, DWORD PTR _lpTgtEntity$2[ebp]
	mov	edx, DWORD PTR [ecx+235]
	and	edx, 1
	jne	SHORT $LN11@fnCompareO
	mov	eax, DWORD PTR _lpTgtEntity$2[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 2
	and	ecx, 1
	jne	SHORT $LN11@fnCompareO

; 2346 :          {
; 2347 :             if ( lpTgtEntity->bInclude == FALSE )

	mov	edx, DWORD PTR _lpTgtEntity$2[ebp]
	mov	eax, DWORD PTR [edx+235]
	shr	eax, 3
	and	eax, 1
	jne	SHORT $LN13@fnCompareO

; 2348 :             {
; 2349 :                // User can't change entity at all so it's just displayable.
; 2350 :                // Ignore this entity instance.
; 2351 :                continue;

	jmp	$LN2@fnCompareO
$LN13@fnCompareO:

; 2352 :             }
; 2353 : 
; 2354 :             // Entity is only includable so only compare the keys.
; 2355 :             bCompareKeysOnly = TRUE;

	mov	BYTE PTR _bCompareKeysOnly$[ebp], 1
$LN11@fnCompareO:

; 2356 :          }
; 2357 :       }
; 2358 : 
; 2359 :       if ( fnCompareEntityToEntity( zGETPTR( lpTgtInstance->hViewEntity ),
; 2360 :                                     lpTgtInstance,
; 2361 :                                     zGETPTR( lpSrcInstance->hViewEntity ),
; 2362 :                                     lpSrcInstance, bComparePersistOnly,
; 2363 :                                     bCompareKeysOnly ) == 1 )

	movzx	ecx, BYTE PTR _bCompareKeysOnly$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _bComparePersistOnly$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnCompareEntityToEntity
	add	esp, 24					; 00000018H
	cwde
	cmp	eax, 1
	jne	SHORT $LN14@fnCompareO

; 2364 :       {
; 2365 :          TraceLineS( "(tr) CompareOI_ToOI - Entity Instance mismatch", "" );

	push	OFFSET $SG14620
	push	OFFSET $SG14621
	call	_TraceLineS@8

; 2366 :          if ( lControl & zCOMPAREOI_RETURN )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 2
	je	SHORT $LN15@fnCompareO

; 2367 :             return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnCompareO
$LN15@fnCompareO:

; 2368 : 
; 2369 :          nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN14@fnCompareO:

; 2370 :       }
; 2371 : 
; 2372 :    } // for ( ... )...

	jmp	$LN2@fnCompareO
$LN3@fnCompareO:

; 2373 : 
; 2374 :    // If either of the two entity instances are not null, then the OIs don't
; 2375 :    // match because at least one of the entity instances is null.
; 2376 :    if ( lpSrcInstance || lpTgtInstance )

	cmp	DWORD PTR _lpSrcInstance$[ebp], 0
	jne	SHORT $LN17@fnCompareO
	cmp	DWORD PTR _lpTgtInstance$[ebp], 0
	je	SHORT $LN16@fnCompareO
$LN17@fnCompareO:

; 2377 :    {
; 2378 :       TraceLineS( "(tr) CompareOI_ToOI - Entity Structure mismatch", " Empty" );

	push	OFFSET $SG14625
	push	OFFSET $SG14626
	call	_TraceLineS@8

; 2379 :       nRC = 2;

	mov	eax, 2
	mov	WORD PTR _nRC$[ebp], ax
$LN16@fnCompareO:

; 2380 :    }
; 2381 : 
; 2382 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@fnCompareO:

; 2383 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnCompareOI_ToOI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpViewCsr$ = -32148					; size = 4
$T1 = -32144						; size = 4
$T2 = -32140						; size = 4
_lpViewEntity$ = -32136					; size = 4
tv83 = -32132						; size = 4
$T3 = -32128						; size = 4
_ulLth$4 = -32124					; size = 4
_szTraceAll$ = -32120					; size = 2
_lpViewAttrib$ = -32116					; size = 4
_nWk2$5 = -32112					; size = 2
_nWk1$6 = -32108					; size = 2
_lpSelectedInstance$ = -32104				; size = 4
_nWk3$7 = -32100					; size = 2
_k$ = -32096						; size = 4
_lpEntityInstance$8 = -32092				; size = 4
_szWorkString$ = -32088					; size = 32000
_szSpaces$ = -88					; size = 30
_szFlags$9 = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntityCsr$ = 12					; size = 4
_nSpaces$ = 16						; size = 2
_lpViewEntityCsrPosition$ = 20				; size = 4
_fnDisplayEntityInstance PROC

; 1000 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 32148				; 00007d94H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 1001 :    LPVIEWENTITY  lpViewEntity;
; 1002 :    LPVIEWATTRIB  lpViewAttrib;
; 1003 :    zCHAR         szSpaces[ 30 ];
; 1004 :    zCHAR         szTraceAll[ 2 ];
; 1005 :    zCHAR         szWorkString[ 32000 ];
; 1006 :    LPVIEWCSR          lpViewCsr;
; 1007 :    LPSELECTEDINSTANCE lpSelectedInstance;
; 1008 :    int           k;
; 1009 : 
; 1010 :    SysReadZeidonIni( -1, "[Debug]", "TraceAllAttributes", szTraceAll );

	lea	eax, DWORD PTR _szTraceAll$[ebp]
	push	eax
	push	OFFSET $SG13802
	push	OFFSET $SG13803
	push	-1
	call	_SysReadZeidonIni@16

; 1011 : 
; 1012 :    zstrcpy( szSpaces, "                            " );

	push	OFFSET $SG13804
	lea	ecx, DWORD PTR _szSpaces$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1013 :    if ( nSpaces > 20 )

	movsx	edx, WORD PTR _nSpaces$[ebp]
	cmp	edx, 20					; 00000014H
	jle	SHORT $LN11@fnDisplayE

; 1014 :       nSpaces = 20;

	mov	eax, 20					; 00000014H
	mov	WORD PTR _nSpaces$[ebp], ax
$LN11@fnDisplayE:

; 1015 : 
; 1016 :    szSpaces[ nSpaces ] = 0;

	movsx	ecx, WORD PTR _nSpaces$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 30			; 0000001eH
	jae	SHORT $LN38@fnDisplayE
	jmp	SHORT $LN39@fnDisplayE
$LN38@fnDisplayE:
	call	___report_rangecheckfailure
$LN39@fnDisplayE:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szSpaces$[ebp+edx], 0

; 1017 : 
; 1018 :    lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1019 :    TraceLine( "%s|==>%s%s", szSpaces, lpViewEntity->szName,

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN40@fnDisplayE
	cmp	DWORD PTR _lpViewEntityCsrPosition$[ebp], 0
	je	SHORT $LN40@fnDisplayE
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsrPosition$[ebp]
	mov	ecx, DWORD PTR [edx+26]
	cmp	ecx, DWORD PTR [eax+26]
	jne	SHORT $LN40@fnDisplayE
	mov	DWORD PTR tv83[ebp], OFFSET $SG13806
	jmp	SHORT $LN41@fnDisplayE
$LN40@fnDisplayE:
	mov	DWORD PTR tv83[ebp], OFFSET $SG13807
$LN41@fnDisplayE:
	mov	edx, DWORD PTR tv83[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	lea	ecx, DWORD PTR _szSpaces$[ebp]
	push	ecx
	push	OFFSET $SG13808
	call	_TraceLine
	add	esp, 16					; 00000010H

; 1020 :               (lpViewEntityCsr && lpViewEntityCsrPosition &&
; 1021 :                lpViewEntityCsr->hEntityInstance ==
; 1022 :                   lpViewEntityCsrPosition->hEntityInstance) ? " *" : "" );
; 1023 : 
; 1024 :    lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1025 :    zstrcpy( szWorkString, "   " );

	push	OFFSET $SG13809
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1026 :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	SHORT $LN12@fnDisplayE

; 1027 :    {
; 1028 :       TraceLineS( "   Cursor for EntityInstance is ", "UNSET" );

	push	OFFSET $SG13812
	push	OFFSET $SG13813
	call	_TraceLineS@8

; 1029 :    }

	jmp	$LN13@fnDisplayE
$LN12@fnDisplayE:

; 1030 :    else
; 1031 :    if ( lpViewEntityCsr->hEntityInstance == NULL_CSR )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN14@fnDisplayE

; 1032 :    {
; 1033 :       TraceLineS( "   Cursor for EntityInstance is ", "NULL" );

	push	OFFSET $SG13816
	push	OFFSET $SG13817
	call	_TraceLineS@8

; 1034 :    }

	jmp	$LN13@fnDisplayE
$LN14@fnDisplayE:

; 1035 :    else
; 1036 :    {
; 1037 :       zCHAR            szFlags[ 50 ] = "Incremental Update Flags: ";

	mov	ecx, 6
	mov	esi, OFFSET $SG13818
	lea	edi, DWORD PTR _szFlags$9[ebp]
	rep movsd
	movsw
	movsb
	xor	ecx, ecx
	mov	DWORD PTR _szFlags$9[ebp+27], ecx
	mov	DWORD PTR _szFlags$9[ebp+31], ecx
	mov	DWORD PTR _szFlags$9[ebp+35], ecx
	mov	DWORD PTR _szFlags$9[ebp+39], ecx
	mov	DWORD PTR _szFlags$9[ebp+43], ecx
	mov	WORD PTR _szFlags$9[ebp+47], cx
	mov	BYTE PTR _szFlags$9[ebp+49], cl

; 1038 :       LPENTITYINSTANCE lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$8[ebp], eax

; 1039 : 
; 1040 :       if ( lpEntityInstance->u.nInd.bHidden      ||
; 1041 :            lpEntityInstance->u.nInd.bTemporal    ||
; 1042 :            lpEntityInstance->hPrevVsn            ||
; 1043 :            lpEntityInstance->u.nInd.bPrevVersion ||

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN17@fnDisplayE
	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN17@fnDisplayE
	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	cmp	DWORD PTR [edx+38], 0
	jne	SHORT $LN17@fnDisplayE
	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 8
	and	ecx, 1
	jne	SHORT $LN17@fnDisplayE
	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	$LN16@fnDisplayE
$LN17@fnDisplayE:

; 1044 :            lpEntityInstance->u.nInd.bPrevVsnRoot )
; 1045 :       {
; 1046 :          TraceLineS( ">>>EntityInstance flags:", " Start" );

	push	OFFSET $SG13821
	push	OFFSET $SG13822
	call	_TraceLineS@8

; 1047 :          if ( lpEntityInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN18@fnDisplayE

; 1048 :             TraceLineS( ">>>EntityInstance is hidden", "" );

	push	OFFSET $SG13824
	push	OFFSET $SG13825
	call	_TraceLineS@8
$LN18@fnDisplayE:

; 1049 :          if ( lpEntityInstance->u.nInd.bTemporal )

	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN19@fnDisplayE

; 1050 :             TraceLineS( ">>>EntityInstance is temporal", "" );

	push	OFFSET $SG13827
	push	OFFSET $SG13828
	call	_TraceLineS@8
$LN19@fnDisplayE:

; 1051 :          if ( lpEntityInstance->hPrevVsn )

	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	cmp	DWORD PTR [edx+38], 0
	je	SHORT $LN20@fnDisplayE

; 1052 :             TraceLineS( ">>>EntityInstance has a previous version", "" );

	push	OFFSET $SG13830
	push	OFFSET $SG13831
	call	_TraceLineS@8
$LN20@fnDisplayE:

; 1053 :          if ( lpEntityInstance->u.nInd.bPrevVersion )

	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 8
	and	ecx, 1
	je	SHORT $LN21@fnDisplayE

; 1054 :             TraceLineS( ">>>EntityInstance is a previous version", "" );

	push	OFFSET $SG13833
	push	OFFSET $SG13834
	call	_TraceLineS@8
$LN21@fnDisplayE:

; 1055 :          if ( lpEntityInstance->u.nInd.bPrevVsnRoot )

	mov	edx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 9
	and	eax, 1
	je	SHORT $LN22@fnDisplayE

; 1056 :             TraceLineS( ">>>EntityInstance is a previous version root", "" );

	push	OFFSET $SG13836
	push	OFFSET $SG13837
	call	_TraceLineS@8
$LN22@fnDisplayE:

; 1057 : 
; 1058 :          TraceLineS( ">>>EntityInstance flags:", " End" );

	push	OFFSET $SG13838
	push	OFFSET $SG13839
	call	_TraceLineS@8
$LN16@fnDisplayE:

; 1059 :       }
; 1060 : 
; 1061 :       if ( lpEntityInstance->u.nInd.bCreated )

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN23@fnDisplayE

; 1062 :          zstrcat( szFlags, "C" );

	push	OFFSET $SG13841
	lea	eax, DWORD PTR _szFlags$9[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN23@fnDisplayE:

; 1063 : 
; 1064 :       if ( lpEntityInstance->u.nInd.bIncluded )

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN24@fnDisplayE

; 1065 :          zstrcat( szFlags, "I" );

	push	OFFSET $SG13843
	lea	eax, DWORD PTR _szFlags$9[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN24@fnDisplayE:

; 1066 : 
; 1067 :       if ( lpEntityInstance->u.nInd.bDeleted )

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	je	SHORT $LN25@fnDisplayE

; 1068 :          zstrcat( szFlags, "D" );

	push	OFFSET $SG13845
	lea	eax, DWORD PTR _szFlags$9[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN25@fnDisplayE:

; 1069 : 
; 1070 :       if ( lpEntityInstance->u.nInd.bExcluded )

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN26@fnDisplayE

; 1071 :          zstrcat( szFlags, "X" );

	push	OFFSET $SG13847
	lea	eax, DWORD PTR _szFlags$9[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN26@fnDisplayE:

; 1072 : 
; 1073 :       if ( lpEntityInstance->u.nInd.bExcluded )

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 4
	and	edx, 1
	je	SHORT $LN27@fnDisplayE

; 1074 :          zstrcat( szFlags, "U" );

	push	OFFSET $SG13849
	lea	eax, DWORD PTR _szFlags$9[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN27@fnDisplayE:

; 1075 : 
; 1076 :       TraceLineS( szSpaces, szFlags );

	lea	ecx, DWORD PTR _szFlags$9[ebp]
	push	ecx
	lea	edx, DWORD PTR _szSpaces$[ebp]
	push	edx
	call	_TraceLineS@8

; 1077 : 
; 1078 :       if ( lpEntityInstance->lTag )

	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	cmp	DWORD PTR [eax+46], 0
	je	SHORT $LN28@fnDisplayE

; 1079 :          TraceLineX( ">>>EntityInstance Tag:", lpEntityInstance->lTag );

	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [ecx+46]
	push	edx
	push	OFFSET $SG13851
	call	_TraceLineX@8
$LN28@fnDisplayE:

; 1080 : 
; 1081 :       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1082 :       lpSelectedInstance = zGETPTR( lpViewCsr->hFirstSelectedInstance );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstance$[ebp], eax
$LN2@fnDisplayE:

; 1083 : 
; 1084 :       while ( lpSelectedInstance &&

	cmp	DWORD PTR _lpSelectedInstance$[ebp], 0
	je	SHORT $LN3@fnDisplayE
	mov	ecx, DWORD PTR _lpSelectedInstance$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpEntityInstance$8[ebp]
	jne	SHORT $LN29@fnDisplayE
	mov	eax, DWORD PTR _lpSelectedInstance$[ebp]
	mov	ecx, DWORD PTR _lpEntityInstance$8[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+2]
	je	SHORT $LN3@fnDisplayE
$LN29@fnDisplayE:

; 1085 :                  ((LPENTITYINSTANCE)
; 1086 :                    zGETPTR( lpSelectedInstance->xEntityInstance ) !=
; 1087 :                                                          lpEntityInstance ||
; 1088 :                    lpSelectedInstance->hViewEntity !=
; 1089 :                                             lpEntityInstance->hViewEntity ) )
; 1090 :       {
; 1091 :          lpSelectedInstance = (LPSELECTEDINSTANCE)

	mov	eax, DWORD PTR _lpSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstance$[ebp], eax

; 1092 :                         zGETPTR( lpSelectedInstance->hNextSelectedInstance );
; 1093 :       }

	jmp	SHORT $LN2@fnDisplayE
$LN3@fnDisplayE:

; 1094 : 
; 1095 :       zstrcpy( szWorkString, ">>>EntityInstance  " );

	push	OFFSET $SG13853
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1096 :       if ( lpSelectedInstance && lpSelectedInstance->nSelectSet )

	cmp	DWORD PTR _lpSelectedInstance$[ebp], 0
	je	$LN30@fnDisplayE
	mov	eax, DWORD PTR _lpSelectedInstance$[ebp]
	movsx	ecx, WORD PTR [eax+6]
	test	ecx, ecx
	je	$LN30@fnDisplayE

; 1097 :       {
; 1098 :          zSHORT nWk1, nWk2, nWk3;
; 1099 : 
; 1100 :          nWk1 = 0;

	xor	edx, edx
	mov	WORD PTR _nWk1$6[ebp], dx

; 1101 :          nWk2 = 0x0001;

	mov	eax, 1
	mov	WORD PTR _nWk2$5[ebp], ax

; 1102 :          zstrcat( szWorkString, "Selected(" );

	push	OFFSET $SG13855
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1103 :          for ( nWk3 = 1; nWk3 < 17; nWk3++ )

	mov	edx, 1
	mov	WORD PTR _nWk3$7[ebp], dx
	jmp	SHORT $LN6@fnDisplayE
$LN4@fnDisplayE:
	mov	ax, WORD PTR _nWk3$7[ebp]
	add	ax, 1
	mov	WORD PTR _nWk3$7[ebp], ax
$LN6@fnDisplayE:
	movsx	ecx, WORD PTR _nWk3$7[ebp]
	cmp	ecx, 17					; 00000011H
	jge	$LN5@fnDisplayE

; 1104 :          {
; 1105 :             if ( lpSelectedInstance->nSelectSet & nWk2 )

	mov	edx, DWORD PTR _lpSelectedInstance$[ebp]
	movsx	eax, WORD PTR [edx+6]
	movsx	ecx, WORD PTR _nWk2$5[ebp]
	and	eax, ecx
	je	SHORT $LN31@fnDisplayE

; 1106 :             {
; 1107 :                if ( nWk1 )

	movsx	edx, WORD PTR _nWk1$6[ebp]
	test	edx, edx
	je	SHORT $LN32@fnDisplayE

; 1108 :                   zstrcat( szWorkString, "," );

	push	OFFSET $SG13858
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN32@fnDisplayE:

; 1109 : 
; 1110 :                zltoa( (zLONG) nWk3, &szWorkString[ 250 ] );

	push	10					; 0000000aH
	mov	ecx, 1
	imul	edx, ecx, 250
	lea	eax, DWORD PTR _szWorkString$[ebp+edx]
	push	eax
	movsx	ecx, WORD PTR _nWk3$7[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1111 :                zstrcat( szWorkString, &szWorkString[ 250 ] );

	mov	edx, 1
	imul	eax, edx, 250
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1112 :                nWk1++;

	mov	ax, WORD PTR _nWk1$6[ebp]
	add	ax, 1
	mov	WORD PTR _nWk1$6[ebp], ax
$LN31@fnDisplayE:

; 1113 :             }
; 1114 : 
; 1115 :             nWk2 <<= 1;

	mov	cx, WORD PTR _nWk2$5[ebp]
	shl	cx, 1
	mov	WORD PTR _nWk2$5[ebp], cx

; 1116 :          }

	jmp	$LN4@fnDisplayE
$LN5@fnDisplayE:

; 1117 : 
; 1118 :          zstrcat( szWorkString, ") " );

	push	OFFSET $SG13859
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN30@fnDisplayE:

; 1119 :       }
; 1120 : 
; 1121 :       TraceLine( "%s%s%d", szSpaces, "Entity Key: ", lpEntityInstance->ulKey );

	mov	eax, DWORD PTR _lpEntityInstance$8[ebp]
	mov	ecx, DWORD PTR [eax+50]
	push	ecx
	push	OFFSET $SG13860
	lea	edx, DWORD PTR _szSpaces$[ebp]
	push	edx
	push	OFFSET $SG13861
	call	_TraceLine
	add	esp, 16					; 00000010H
$LN7@fnDisplayE:

; 1122 : 
; 1123 :       while ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN13@fnDisplayE

; 1124 :       {
; 1125 :          zstrcpy( szWorkString + 3, lpViewAttrib->szName );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	lea	ecx, DWORD PTR _szWorkString$[ebp+3]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1126 :          k = zstrlen( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _k$[ebp], eax

; 1127 :          szWorkString[ k++ ] = ' ';

	mov	eax, DWORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 32	; 00000020H
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN9@fnDisplayE:

; 1128 :          while ( k < 14 )

	cmp	DWORD PTR _k$[ebp], 14			; 0000000eH
	jge	SHORT $LN10@fnDisplayE

; 1129 :             szWorkString[ k++ ] = ' ';

	mov	edx, DWORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 32	; 00000020H
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
	jmp	SHORT $LN9@fnDisplayE
$LN10@fnDisplayE:

; 1130 : 
; 1131 :          szWorkString[ k ] = 0;

	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 32000		; 00007d00H
	jae	SHORT $LN42@fnDisplayE
	jmp	SHORT $LN43@fnDisplayE
$LN42@fnDisplayE:
	call	___report_rangecheckfailure
$LN43@fnDisplayE:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 0

; 1132 :          if ( lpViewAttrib->cType == 'B' )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	jne	$LN33@fnDisplayE

; 1133 :          {
; 1134 :             zULONG  ulLth;
; 1135 : 
; 1136 :             ulLth = 0;

	mov	DWORD PTR _ulLth$4[ebp], 0

; 1137 :             fnGetAttributeLength( &ulLth, lpView,

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulLth$4[ebp]
	push	eax
	call	_fnGetAttributeLength
	add	esp, 16					; 00000010H

; 1138 :                                   zGETPTR( lpViewEntityCsr->hEntityInstance ),
; 1139 :                                   lpViewAttrib );
; 1140 :             if ( ulLth )

	cmp	DWORD PTR _ulLth$4[ebp], 0
	je	$LN33@fnDisplayE

; 1141 :             {
; 1142 :                zstrcpy( &szWorkString[ k ], "Blob Lth=" );

	push	OFFSET $SG13864
	mov	ecx, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 1143 :                zltoa( (zLONG) ulLth, &szWorkString[ k + 9 ] );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _szWorkString$[ebp+eax+9]
	push	ecx
	mov	edx, DWORD PTR _ulLth$4[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1144 :                k = zstrlen( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _k$[ebp], eax

; 1145 :                szWorkString[ k++ ] = ' ';

	mov	ecx, DWORD PTR _k$[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 32	; 00000020H
	mov	edx, DWORD PTR _k$[ebp]
	add	edx, 1
	mov	DWORD PTR _k$[ebp], edx

; 1146 :                szWorkString[ k ] = 0;

	mov	eax, DWORD PTR _k$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 32000		; 00007d00H
	jae	SHORT $LN44@fnDisplayE
	jmp	SHORT $LN45@fnDisplayE
$LN44@fnDisplayE:
	call	___report_rangecheckfailure
$LN45@fnDisplayE:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 0
$LN33@fnDisplayE:

; 1147 :             }
; 1148 :          }
; 1149 :       // else  dks 2007.01.11
; 1150 :          {
; 1151 :             fnGetStringFromAttribute( &szWorkString[ k ],

	push	0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, 31000				; 00007918H
	sub	edx, DWORD PTR _k$[ebp]
	movsx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _k$[ebp]
	lea	edx, DWORD PTR _szWorkString$[ebp+ecx]
	push	edx
	call	_fnGetStringFromAttribute
	add	esp, 24					; 00000018H

; 1152 :                                       (zSHORT) ((sizeof( szWorkString ) - 1000) - k),
; 1153 :                                       lpView,
; 1154 :                                       lpViewEntityCsr,
; 1155 :                                       lpViewAttrib, 0 );
; 1156 :          }
; 1157 : 
; 1158 :          if ( szWorkString[ k ] || szTraceAll[ 0 ] == 'Y' )

	mov	eax, DWORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR _szWorkString$[ebp+eax]
	test	ecx, ecx
	jne	SHORT $LN36@fnDisplayE
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szTraceAll$[ebp+eax]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN35@fnDisplayE
$LN36@fnDisplayE:

; 1159 :             TraceLineS( szSpaces, szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szSpaces$[ebp]
	push	eax
	call	_TraceLineS@8
$LN35@fnDisplayE:

; 1160 : 
; 1161 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1162 :       }

	jmp	$LN7@fnDisplayE
$LN13@fnDisplayE:

; 1163 :    }
; 1164 : 
; 1165 :    return( 0 );

	xor	eax, eax
$LN37@fnDisplayE:

; 1166 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnDisplayEntityInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_GetTracingFlags@0 PROC

; 2465 : {

	push	ebp
	mov	ebp, esp

; 2466 :    if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN2@GetTracing

; 2467 :       return( &AnchorBlock->TraceFlags );

	mov	eax, DWORD PTR _AnchorBlock
	add	eax, 2527				; 000009dfH
	jmp	SHORT $LN1@GetTracing
	jmp	SHORT $LN1@GetTracing
$LN2@GetTracing:

; 2468 :    else
; 2469 :       return( 0 );

	xor	eax, eax
$LN1@GetTracing:

; 2470 : }

	pop	ebp
	ret	0
_GetTracingFlags@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpEntityInstance$ = -44				; size = 4
_lpRecursViewEntity$1 = -40				; size = 4
_lpViewOD$ = -36					; size = 4
_lpViewOI$ = -32					; size = 4
_lpCurrentTask$ = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpViewEntityCsr$ = -20					; size = 4
_lpViewCsr$ = -16					; size = 4
_lpViewSubobject$ = -12					; size = 4
_uLimit$ = -8						; size = 2
_uIdx$ = -4						; size = 2
_lpView$ = 8						; size = 4
_DisplayCursorInfo@4 PROC

; 1230 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1231 :    LPTASK            lpCurrentTask;
; 1232 :    LPVIEWCSR         lpViewCsr;
; 1233 :    LPVIEWOI          lpViewOI;
; 1234 :    LPVIEWOD          lpViewOD;
; 1235 :    LPVIEWENTITY      lpViewEntity;
; 1236 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1237 :    LPENTITYINSTANCE  lpEntityInstance;
; 1238 :    LPVIEWSUBOBJECT   lpViewSubobject;
; 1239 :    zUSHORT           uIdx, uLimit;
; 1240 : 
; 1241 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 1242 :    if ( (lpCurrentTask = fnOperationCall( iDisplayCursorInfo, lpView,
; 1243 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	402					; 00000192H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN7@DisplayCur

; 1244 :    {
; 1245 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DisplayCur
$LN7@DisplayCur:

; 1246 :    }
; 1247 : 
; 1248 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1249 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1250 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1251 :    lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 1252 : 
; 1253 :    TraceLineS( "View Cursor Info for Object ", lpViewOD->szName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG13954
	call	_TraceLineS@8

; 1254 :    TraceLineS( "  RootViewEntityCsr", "" );

	push	OFFSET $SG13955
	push	OFFSET $SG13956
	call	_TraceLineS@8

; 1255 :    fnShowViewEntityCsrInfo( zGETPTR( lpViewCsr->hRootViewEntityCsr ) );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowViewEntityCsrInfo
	add	esp, 4

; 1256 :    TraceLineS( "", "" );

	push	OFFSET $SG13957
	push	OFFSET $SG13958
	call	_TraceLineS@8

; 1257 : 
; 1258 :    lpEntityInstance = zGETPTR( lpViewCsr->hHierRootEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 1259 :    TraceLineS( "ViewCsr HierRootInstance", "" );

	push	OFFSET $SG13959
	push	OFFSET $SG13960
	call	_TraceLineS@8

; 1260 :    fnShowEntityInstanceInfo( zGETPTR( lpViewCsr->hHierRootEntityInstance ) );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowEntityInstanceInfo
	add	esp, 4

; 1261 :    TraceLineS( "", "" );

	push	OFFSET $SG13961
	push	OFFSET $SG13962
	call	_TraceLineS@8

; 1262 : 
; 1263 :    TraceLineS( "ViewCsr HierInstance", "" );

	push	OFFSET $SG13963
	push	OFFSET $SG13964
	call	_TraceLineS@8

; 1264 :    fnShowEntityInstanceInfo( zGETPTR( lpViewCsr->hHierEntityInstance ) );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowEntityInstanceInfo
	add	esp, 4

; 1265 :    TraceLineS( "", "" );

	push	OFFSET $SG13965
	push	OFFSET $SG13966
	call	_TraceLineS@8

; 1266 : 
; 1267 :    TraceLineS( "ViewCsr ViewParentInstance", "" );

	push	OFFSET $SG13967
	push	OFFSET $SG13968
	call	_TraceLineS@8

; 1268 :    fnShowEntityInstanceInfo( zGETPTR( lpViewCsr->hViewParentEntityInstance ) );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowEntityInstanceInfo
	add	esp, 4

; 1269 :    TraceLineS( "", "" );

	push	OFFSET $SG13969
	push	OFFSET $SG13970
	call	_TraceLineS@8

; 1270 : 
; 1271 :    uLimit = lpViewCsr->uEntities;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	ax, WORD PTR [edx+34]
	mov	WORD PTR _uLimit$[ebp], ax

; 1272 :    TraceLineI( "The number of entities is ", uLimit );

	movzx	ecx, WORD PTR _uLimit$[ebp]
	push	ecx
	push	OFFSET $SG13971
	call	_TraceLineI@8

; 1273 : 
; 1274 :    for ( uIdx = 1; uIdx <= uLimit; uIdx++, lpViewEntityCsr++ )

	mov	edx, 1
	mov	WORD PTR _uIdx$[ebp], dx
	jmp	SHORT $LN4@DisplayCur
$LN2@DisplayCur:
	mov	ax, WORD PTR _uIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _uIdx$[ebp], ax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx
$LN4@DisplayCur:
	movzx	edx, WORD PTR _uIdx$[ebp]
	movzx	eax, WORD PTR _uLimit$[ebp]
	cmp	edx, eax
	jg	SHORT $LN3@DisplayCur

; 1275 :    {
; 1276 :       lpViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1277 : 
; 1278 :       TraceLineI( "Entity number ", uIdx );

	movzx	eax, WORD PTR _uIdx$[ebp]
	push	eax
	push	OFFSET $SG13972
	call	_TraceLineI@8

; 1279 :       TraceLineI( "       level  ", lpViewEntity->nLevel );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	push	edx
	push	OFFSET $SG13973
	call	_TraceLineI@8

; 1280 :       TraceLineI( "       hier   ", lpViewEntity->nHierNbr );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	push	ecx
	push	OFFSET $SG13974
	call	_TraceLineI@8

; 1281 :       TraceLineS( "       name   ", lpViewEntity->szName );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13975
	call	_TraceLineS@8

; 1282 :       fnShowViewEntityCsrInfo( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnShowViewEntityCsrInfo
	add	esp, 4

; 1283 :       TraceLineS( "", "" );

	push	OFFSET $SG13976
	push	OFFSET $SG13977
	call	_TraceLineS@8

; 1284 :    }

	jmp	$LN2@DisplayCur
$LN3@DisplayCur:

; 1285 : 
; 1286 :    lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 1287 :    uIdx = 0;

	xor	eax, eax
	mov	WORD PTR _uIdx$[ebp], ax
$LN5@DisplayCur:

; 1288 :    while ( lpViewSubobject )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	je	$LN6@DisplayCur

; 1289 :    {
; 1290 :       TraceLineI( "Subobject Information ", ++uIdx );

	mov	cx, WORD PTR _uIdx$[ebp]
	add	cx, 1
	mov	WORD PTR _uIdx$[ebp], cx
	movzx	edx, WORD PTR _uIdx$[ebp]
	push	edx
	push	OFFSET $SG13978
	call	_TraceLineI@8

; 1291 :       TraceLineS( "**ViewRootParentCsr", "" );

	push	OFFSET $SG13979
	push	OFFSET $SG13980
	call	_TraceLineS@8

; 1292 :       fnShowViewEntityCsrInfo( zGETPTR( lpViewSubobject->hViewRootParentCsr ) );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowViewEntityCsrInfo
	add	esp, 4

; 1293 :       TraceLineS( "**SubobjectRootCsr", "" );

	push	OFFSET $SG13981
	push	OFFSET $SG13982
	call	_TraceLineS@8

; 1294 :       fnShowViewEntityCsrInfo( zGETPTR( lpViewSubobject->hRootCsr ) );

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowViewEntityCsrInfo
	add	esp, 4

; 1295 :       TraceLineI( "**Hierarchical number of root csr ",

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	movsx	edx, WORD PTR [ecx+18]
	push	edx
	push	OFFSET $SG13983
	call	_TraceLineI@8

; 1296 :                   lpViewSubobject->nRootHierNbr );
; 1297 :       TraceLineS( "**LastDescendentCsr", "" );

	push	OFFSET $SG13984
	push	OFFSET $SG13985
	call	_TraceLineS@8

; 1298 :       fnShowViewEntityCsrInfo( zGETPTR( lpViewSubobject->hLastDescCsr ) );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowViewEntityCsrInfo
	add	esp, 4

; 1299 :       TraceLineI( "**LastDescHierNbr ", lpViewSubobject->nLastDescHierNbr );

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	movsx	eax, WORD PTR [edx+24]
	push	eax
	push	OFFSET $SG13986
	call	_TraceLineI@8

; 1300 :       TraceLineS( "**ViewParentEntityInstance", "" );

	push	OFFSET $SG13987
	push	OFFSET $SG13988
	call	_TraceLineS@8

; 1301 :       fnShowEntityInstanceInfo( zGETPTR( lpViewSubobject->

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowEntityInstanceInfo
	add	esp, 4

; 1302 :                                              hViewParentEntityInstance ) );
; 1303 :       TraceLineS( "**RootEntityInstance", "" );

	push	OFFSET $SG13989
	push	OFFSET $SG13990
	call	_TraceLineS@8

; 1304 :       fnShowEntityInstanceInfo( zGETPTR( lpViewSubobject->

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowEntityInstanceInfo
	add	esp, 4

; 1305 :                                                    hRootEntityInstance ) );
; 1306 :       TraceLineS( "..Recursive subobject info..", "" );

	push	OFFSET $SG13991
	push	OFFSET $SG13992
	call	_TraceLineS@8

; 1307 :       TraceLineI( "  Level adjustment ", lpViewSubobject->nLevelChg );

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	movsx	eax, WORD PTR [edx+34]
	push	eax
	push	OFFSET $SG13993
	call	_TraceLineI@8

; 1308 :       if ( lpViewSubobject->hRecursViewEntity )

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	cmp	DWORD PTR [ecx+36], 0
	je	SHORT $LN8@DisplayCur

; 1309 :       {
; 1310 :          LPVIEWENTITY lpRecursViewEntity;
; 1311 : 
; 1312 :          lpRecursViewEntity = zGETPTR( lpViewSubobject->hRecursViewEntity );

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+36]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursViewEntity$1[ebp], eax

; 1313 :          TraceLineS( "**Recursive View Entity: ",

	mov	ecx, DWORD PTR _lpRecursViewEntity$1[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG13996
	call	_TraceLineS@8

; 1314 :                      lpRecursViewEntity->szName );
; 1315 :       }

	jmp	SHORT $LN9@DisplayCur
$LN8@DisplayCur:

; 1316 :       else
; 1317 :          TraceLineS( "**Recursive View Entity: ", "NULL" );

	push	OFFSET $SG13997
	push	OFFSET $SG13998
	call	_TraceLineS@8
$LN9@DisplayCur:

; 1318 : 
; 1319 :       TraceLineS( "            View Entity Csr", "" );

	push	OFFSET $SG13999
	push	OFFSET $SG14000
	call	_TraceLineS@8

; 1320 :       fnShowViewEntityCsrInfo( zGETPTR( lpViewSubobject->

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowViewEntityCsrInfo
	add	esp, 4

; 1321 :                                                    hRecursViewEntityCsr ) );
; 1322 :       TraceLineS( "        Parent EntityInstance", "" );

	push	OFFSET $SG14001
	push	OFFSET $SG14002
	call	_TraceLineS@8

; 1323 :       fnShowEntityInstanceInfo( zGETPTR( lpViewSubobject->

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnShowEntityInstanceInfo
	add	esp, 4

; 1324 :                                              hRecursParentEntityInstance ) );
; 1325 :       TraceLineS( "..End Recursive subobject info..", "" );

	push	OFFSET $SG14003
	push	OFFSET $SG14004
	call	_TraceLineS@8

; 1326 :       TraceLineS( "", "" );

	push	OFFSET $SG14005
	push	OFFSET $SG14006
	call	_TraceLineS@8

; 1327 : 
; 1328 :       lpViewSubobject = zGETPTR( lpViewSubobject->hNextViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 1329 :    }

	jmp	$LN5@DisplayCur
$LN6@DisplayCur:

; 1330 : 
; 1331 :    fnOperationReturn( iDisplayCursorInfo, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	402					; 00000192H
	call	_fnOperationReturn
	add	esp, 8

; 1332 :    return( 0 );

	xor	eax, eax
$LN1@DisplayCur:

; 1333 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DisplayCursorInfo@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpTgtViewCsr$ = -16					; size = 4
_lpSrcViewCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpTgtView$ = 8						; size = 4
_lpSrcView$ = 12					; size = 4
_CompareOI_ToOI@8 PROC

; 2406 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2407 :    LPTASK            lpCurrentTask;
; 2408 :    LPVIEWCSR         lpSrcViewCsr;
; 2409 :    LPVIEWCSR         lpTgtViewCsr;
; 2410 :    zSHORT            nRC;
; 2411 : 
; 2412 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2413 :    if ( (lpCurrentTask = fnOperationCall( iCompareOI_ToOI, lpTgtView,
; 2414 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	push	407					; 00000197H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@CompareOI_

; 2415 :    {
; 2416 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CompareOI_
$LN2@CompareOI_:

; 2417 :    }
; 2418 : 
; 2419 :    if ( fnValidViewCsr( lpCurrentTask, lpSrcView ) == 0 )

	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidViewCsr
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN3@CompareOI_

; 2420 :    {
; 2421 :       fnOperationReturn( iCompareOI_ToOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	407					; 00000197H
	call	_fnOperationReturn
	add	esp, 8

; 2422 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CompareOI_
$LN3@CompareOI_:

; 2423 :    }
; 2424 : 
; 2425 :    if ( lpSrcView->hViewOD != lpTgtView->hViewOD )

	mov	edx, DWORD PTR _lpSrcView$[ebp]
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	mov	ecx, DWORD PTR [edx+6]
	cmp	ecx, DWORD PTR [eax+6]
	je	SHORT $LN4@CompareOI_

; 2426 :    {
; 2427 :       TraceLineS( "CompareOI_ToOI - Object type mismatch", "" );

	push	OFFSET $SG14641
	push	OFFSET $SG14642
	call	_TraceLineS@8

; 2428 :       fnOperationReturn( iCompareOI_ToOI, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	407					; 00000197H
	call	_fnOperationReturn
	add	esp, 8

; 2429 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareOI_
$LN4@CompareOI_:

; 2430 :    }
; 2431 : 
; 2432 :    lpSrcViewCsr = zGETPTR( lpSrcView->hViewCsr );

	mov	eax, DWORD PTR _lpSrcView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewCsr$[ebp], eax

; 2433 :    lpTgtViewCsr = zGETPTR( lpTgtView->hViewCsr );

	mov	edx, DWORD PTR _lpTgtView$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewCsr$[ebp], eax

; 2434 : 
; 2435 :    if ( lpSrcViewCsr->hViewOI == lpTgtViewCsr->hViewOI )

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	eax, DWORD PTR [ecx+10]
	cmp	eax, DWORD PTR [edx+10]
	jne	SHORT $LN5@CompareOI_

; 2436 :    {
; 2437 :       TraceLineS( "(tr) CompareOI_ToOI - Src and Tgt are same instance", "" );

	push	OFFSET $SG14644
	push	OFFSET $SG14645
	call	_TraceLineS@8

; 2438 :       fnOperationReturn( iCompareOI_ToOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	407					; 00000197H
	call	_fnOperationReturn
	add	esp, 8

; 2439 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@CompareOI_
$LN5@CompareOI_:

; 2440 :    }
; 2441 : 
; 2442 :    nRC = fnCompareOI_ToOI( lpTgtView, lpSrcView, 0 );

	push	0
	mov	edx, DWORD PTR _lpSrcView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtView$[ebp]
	push	eax
	call	_fnCompareOI_ToOI
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2443 : 
; 2444 :    fnOperationReturn( iCompareOI_ToOI, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	407					; 00000197H
	call	_fnOperationReturn
	add	esp, 8

; 2445 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareOI_:

; 2446 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_CompareOI_ToOI@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_nRC$ = -24						; size = 4
_lpTgtViewEntity$ = -20					; size = 4
_lpTgtViewEntityCsr$ = -16				; size = 4
_lpSrcViewEntity$ = -12					; size = 4
_lpSrcViewEntityCsr$ = -8				; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_CompareEntityToEntity@16 PROC

; 1907 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1908 :    LPTASK           lpCurrentTask;
; 1909 :    LPVIEWENTITY     lpTgtViewEntity;
; 1910 :    LPVIEWENTITYCSR  lpTgtViewEntityCsr;
; 1911 :    LPVIEWENTITY     lpSrcViewEntity;
; 1912 :    LPVIEWENTITYCSR  lpSrcViewEntityCsr;
; 1913 :    int              nRC;
; 1914 : 
; 1915 :    // Validate parameters
; 1916 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	push	406					; 00000196H
	lea	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@CompareEnt

; 1917 :                                       &lpTgtViewEntity,
; 1918 :                                       &lpTgtViewEntityCsr,
; 1919 :                                       iCompareEntityToEntity,
; 1920 :                                       lpTgtView,
; 1921 :                                       cpcTgtEntityName, 0 ) )
; 1922 :    {
; 1923 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareEnt
$LN2@CompareEnt:

; 1924 :    }
; 1925 : 
; 1926 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	2
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	406					; 00000196H
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@CompareEnt

; 1927 :                                       &lpSrcViewEntity,
; 1928 :                                       &lpSrcViewEntityCsr,
; 1929 :                                       iCompareEntityToEntity,
; 1930 :                                       lpSrcView,
; 1931 :                                       cpcSrcEntityName,
; 1932 :                                       2 ) ) // we've already sent the id
; 1933 :    {
; 1934 :    // fnOperationReturn( iCompareEntityToEntity, lpCurrentTask );
; 1935 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareEnt
$LN3@CompareEnt:

; 1936 :    }
; 1937 : 
; 1938 :    // Start by assuming that the entities are equal.
; 1939 :    nRC = fnCompareEntityToEntity( lpTgtViewEntity,

	push	0
	push	0
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpSrcViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpTgtViewEntity$[ebp]
	push	edx
	call	_fnCompareEntityToEntity
	add	esp, 24					; 00000018H
	cwde
	mov	DWORD PTR _nRC$[ebp], eax

; 1940 :                                   zGETPTR( lpTgtViewEntityCsr->hEntityInstance ),
; 1941 :                                   lpSrcViewEntity,
; 1942 :                                   zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),
; 1943 :                                   FALSE, FALSE );  // Compare all attributes.
; 1944 : 
; 1945 :    fnOperationReturn( iCompareEntityToEntity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	406					; 00000196H
	call	_fnOperationReturn
	add	esp, 8

; 1946 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareEnt:

; 1947 : 
; 1948 : }  /* CompareEntityToEntity */

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CompareEntityToEntity@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_nRC$ = -24						; size = 4
_lpTgtViewEntity$ = -20					; size = 4
_lpTgtViewEntityCsr$ = -16				; size = 4
_lpSrcViewEntity$ = -12					; size = 4
_lpSrcViewEntityCsr$ = -8				; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpTgtView$ = 8						; size = 4
_cpcTgtEntityName$ = 12					; size = 4
_lpSrcView$ = 16					; size = 4
_cpcSrcEntityName$ = 20					; size = 4
_pchAttrList$ = 24					; size = 4
_CompareEntitiesIgnoringAttrs@20 PROC

; 2126 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2127 :    LPTASK           lpCurrentTask;
; 2128 :    LPVIEWENTITY     lpTgtViewEntity;
; 2129 :    LPVIEWENTITYCSR  lpTgtViewEntityCsr;
; 2130 :    LPVIEWENTITY     lpSrcViewEntity;
; 2131 :    LPVIEWENTITYCSR  lpSrcViewEntityCsr;
; 2132 :    int              nRC;
; 2133 : 
; 2134 :    // Validate parameters
; 2135 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	0
	mov	eax, DWORD PTR _cpcTgtEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtView$[ebp]
	push	ecx
	push	406					; 00000196H
	lea	edx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@CompareEnt

; 2136 :                                       &lpTgtViewEntity,
; 2137 :                                       &lpTgtViewEntityCsr,
; 2138 :                                       iCompareEntityToEntity,
; 2139 :                                       lpTgtView,
; 2140 :                                       cpcTgtEntityName, 0 ) )
; 2141 :    {
; 2142 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareEnt
$LN2@CompareEnt:

; 2143 :    }
; 2144 : 
; 2145 :    if ( fnValidateInstanceParameters( &lpCurrentTask,

	push	2
	mov	eax, DWORD PTR _cpcSrcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcView$[ebp]
	push	ecx
	push	406					; 00000196H
	lea	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidateInstanceParameters
	add	esp, 28					; 0000001cH
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@CompareEnt

; 2146 :                                       &lpSrcViewEntity,
; 2147 :                                       &lpSrcViewEntityCsr,
; 2148 :                                       iCompareEntityToEntity,
; 2149 :                                       lpSrcView,
; 2150 :                                       cpcSrcEntityName,
; 2151 :                                       2 ) ) // we've already sent the id
; 2152 :    {
; 2153 :    // fnOperationReturn( iCompareEntityToEntity, lpCurrentTask );
; 2154 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@CompareEnt
$LN3@CompareEnt:

; 2155 :    }
; 2156 : 
; 2157 :    // Start by assuming that the entities are equal.
; 2158 :    nRC = fnCompareEntitiesIgnoringAttrs( lpTgtViewEntity,

	mov	eax, DWORD PTR _pchAttrList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpSrcViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTgtViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	eax, DWORD PTR _lpTgtViewEntity$[ebp]
	push	eax
	call	_fnCompareEntitiesIgnoringAttrs
	add	esp, 20					; 00000014H
	movsx	ecx, ax
	mov	DWORD PTR _nRC$[ebp], ecx

; 2159 :                                          zGETPTR( lpTgtViewEntityCsr->hEntityInstance ),
; 2160 :                                          lpSrcViewEntity,
; 2161 :                                          zGETPTR( lpSrcViewEntityCsr->hEntityInstance ),
; 2162 :                                          pchAttrList ); // Ignore attrs in list
; 2163 : 
; 2164 :    fnOperationReturn( iCompareEntityToEntity, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	406					; 00000196H
	call	_fnOperationReturn
	add	esp, 8

; 2165 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareEnt:

; 2166 : 
; 2167 : }  /* CompareEntitiesIgnoringAttrs */

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_CompareEntitiesIgnoringAttrs@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpTemp$1 = -60						; size = 4
_lpGKHandler$2 = -56					; size = 4
_lpDBHandler$3 = -52					; size = 4
$T4 = -48						; size = 4
_lpTempViewEntity$5 = -44				; size = 4
_lpTempDataField$6 = -40				; size = 4
_lpViewAttrib$ = -36					; size = 4
_lpTempViewAttrib$7 = -32				; size = 4
_lpViewEntity$ = -28					; size = 4
_lpDataRecord$ = -24					; size = 4
_lpRelField$ = -20					; size = 4
_lpDataField$ = -16					; size = 4
_lpRelRecord$ = -12					; size = 4
_lpViewOD$ = -8						; size = 4
_sz$ = -4						; size = 2
_lpPtr$ = 8						; size = 4
_nControl$ = 12						; size = 2
_DisplayObjectDef@8 PROC

; 1541 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 1542 :    LPVIEWOD     lpViewOD;
; 1543 :    LPVIEWENTITY lpViewEntity;
; 1544 :    LPVIEWATTRIB lpViewAttrib;
; 1545 :    LPDATARECORD lpDataRecord;
; 1546 :    LPDATAFIELD  lpDataField;
; 1547 :    LPRELRECORD  lpRelRecord;
; 1548 :    LPRELFIELD   lpRelField;
; 1549 :    zCHAR        sz[ 2 ];
; 1550 : 
; 1551 :    if ( nControl == 1 )

	movsx	eax, WORD PTR _nControl$[ebp]
	cmp	eax, 1
	jne	SHORT $LN14@DisplayObj

; 1552 :       lpViewOD = (LPVIEWOD) lpPtr;

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR _lpViewOD$[ebp], ecx
	jmp	SHORT $LN15@DisplayObj
$LN14@DisplayObj:

; 1553 :    else
; 1554 :       lpViewOD = zGETPTR( lpPtr->hViewOD );

	mov	edx, DWORD PTR _lpPtr$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
$LN15@DisplayObj:

; 1555 : 
; 1556 :    sz[ 1 ] = 0;

	mov	DWORD PTR $T4[ebp], 1
	cmp	DWORD PTR $T4[ebp], 2
	jae	SHORT $LN42@DisplayObj
	jmp	SHORT $LN43@DisplayObj
$LN42@DisplayObj:
	call	___report_rangecheckfailure
$LN43@DisplayObj:
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _sz$[ebp+ecx], 0

; 1557 : 
; 1558 :    TraceLineS( "", "" );

	push	OFFSET $SG14285
	push	OFFSET $SG14286
	call	_TraceLineS@8

; 1559 :    TraceLineS( "Tracing object definition", "" );

	push	OFFSET $SG14287
	push	OFFSET $SG14288
	call	_TraceLineS@8

; 1560 :    TraceLineS( "", "" );

	push	OFFSET $SG14289
	push	OFFSET $SG14290
	call	_TraceLineS@8

; 1561 : 
; 1562 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN16@DisplayObj

; 1563 :    {
; 1564 :       TraceLineS( "Cancel Tracing, lpViewOD is null", "" );

	push	OFFSET $SG14292
	push	OFFSET $SG14293
	call	_TraceLineS@8

; 1565 :       return( -1 );

	or	eax, -1
	jmp	$LN41@DisplayObj
$LN16@DisplayObj:

; 1566 :    }
; 1567 : 
; 1568 :    TraceLineS( "Object def name = ", lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14294
	call	_TraceLineS@8

; 1569 :    TraceLineS( "Database name = ", lpViewOD->szDfltDBName );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 43					; 0000002bH
	push	eax
	push	OFFSET $SG14295
	call	_TraceLineS@8

; 1570 : 
; 1571 :    if ( lpViewOD->szOperLibname[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+142]
	test	ecx, ecx
	je	SHORT $LN17@DisplayObj

; 1572 :       TraceLineS( "OperLib name = ", lpViewOD->szOperLibname );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 142				; 0000008eH
	push	edx
	push	OFFSET $SG14297
	call	_TraceLineS@8
$LN17@DisplayObj:

; 1573 : 
; 1574 :    if ( lpViewOD->szOCEOpername[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+175]
	test	eax, eax
	je	SHORT $LN18@DisplayObj

; 1575 :       TraceLineS( "OCEOper name = ", lpViewOD->szOCEOpername );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 175				; 000000afH
	push	ecx
	push	OFFSET $SG14299
	call	_TraceLineS@8
$LN18@DisplayObj:

; 1576 : 
; 1577 :    if ( lpViewOD->hDBHandler )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [edx+208], 0
	je	SHORT $LN19@DisplayObj

; 1578 :    {
; 1579 :       LPDBHANDLER lpDBHandler = zGETPTR( lpViewOD->hDBHandler );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+208]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDBHandler$3[ebp], eax

; 1580 : 
; 1581 :       TraceLineS( "DBHandler name = ", lpDBHandler->szName );

	mov	edx, DWORD PTR _lpDBHandler$3[ebp]
	add	edx, 11					; 0000000bH
	push	edx
	push	OFFSET $SG14301
	call	_TraceLineS@8
$LN19@DisplayObj:

; 1582 :    }
; 1583 : 
; 1584 :    if ( lpViewOD->hGKHandler )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	cmp	DWORD PTR [eax+212], 0
	je	SHORT $LN20@DisplayObj

; 1585 :    {
; 1586 :       LPGKHANDLER lpGKHandler = zGETPTR( lpViewOD->hGKHandler );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+212]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpGKHandler$2[ebp], eax

; 1587 : 
; 1588 :       TraceLineS( "GKHandler name = ", lpGKHandler->szName );

	mov	eax, DWORD PTR _lpGKHandler$2[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14303
	call	_TraceLineS@8
$LN20@DisplayObj:

; 1589 :    }
; 1590 : 
; 1591 :    TraceLineI( "Entity Count   = ", lpViewOD->uEntities );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movzx	edx, WORD PTR [ecx+234]
	push	edx
	push	OFFSET $SG14304
	call	_TraceLineI@8

; 1592 :    TraceLineI( "Cache Number   = ", lpViewOD->cCacheNbr );

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	movsx	ecx, BYTE PTR [eax+238]
	push	ecx
	push	OFFSET $SG14305
	call	_TraceLineI@8

; 1593 :    TraceLineI( "Lock Level     = ", lpViewOD->nLock );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	movzx	eax, BYTE PTR [edx+236]
	push	eax
	push	OFFSET $SG14306
	call	_TraceLineI@8

; 1594 :    TraceLineI( "Ent Lock Level = ", lpViewOD->nEntityLock );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movzx	edx, BYTE PTR [ecx+237]
	push	edx
	push	OFFSET $SG14307
	call	_TraceLineI@8

; 1595 : 
; 1596 : #if 0
; 1597 :    TraceLineX( "Locking Flags  = 0x", lpViewOD->lLockFlags );
; 1598 :    if ( lpViewOD->lLockFlags != 0 )
; 1599 :    {
; 1600 :       if ( lpViewOD->lLockFlags & zLOCK_OPTIMISTIC )
; 1601 :          TraceLineS( "          zLOCK_OPTIMISTIC", "" );
; 1602 : 
; 1603 :       if ( lpViewOD->lLockFlags & zLOCK_IGNOREINC )
; 1604 :          TraceLineS( "          zLOCK_IGNOREINC", "" );
; 1605 :    }
; 1606 : #endif
; 1607 : 
; 1608 :    TraceLineS( "Flags: ", "" );

	push	OFFSET $SG14308
	push	OFFSET $SG14309
	call	_TraceLineS@8

; 1609 :    if ( lpViewOD->bHasDupInstance )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	and	ecx, 1
	je	SHORT $LN21@DisplayObj

; 1610 :       TraceLineS( "     bHasDupInstance", "" );

	push	OFFSET $SG14311
	push	OFFSET $SG14312
	call	_TraceLineS@8
$LN21@DisplayObj:

; 1611 : 
; 1612 :    if ( lpViewOD->bHasDupRel )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN22@DisplayObj

; 1613 :       TraceLineS( "     bHasDupRel", "" );

	push	OFFSET $SG14314
	push	OFFSET $SG14315
	call	_TraceLineS@8
$LN22@DisplayObj:

; 1614 : 
; 1615 :    if ( lpViewOD->bHasDerivedPath )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN23@DisplayObj

; 1616 :       TraceLineS( "     bHasDerivedPath", "" );

	push	OFFSET $SG14317
	push	OFFSET $SG14318
	call	_TraceLineS@8
$LN23@DisplayObj:

; 1617 : 
; 1618 :    if ( lpViewOD->bActivateConstraint )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN24@DisplayObj

; 1619 :       TraceLineS( "     bActivateConstraint", "" );

	push	OFFSET $SG14320
	push	OFFSET $SG14321
	call	_TraceLineS@8
$LN24@DisplayObj:

; 1620 : 
; 1621 :    if ( lpViewOD->bActivateEmptyConstraint )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN25@DisplayObj

; 1622 :       TraceLineS( "     bActivateEmptyConstraint", "" );

	push	OFFSET $SG14323
	push	OFFSET $SG14324
	call	_TraceLineS@8
$LN25@DisplayObj:

; 1623 : 
; 1624 :    if ( lpViewOD->bCommitConstraint )

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 5
	and	edx, 1
	je	SHORT $LN26@DisplayObj

; 1625 :       TraceLineS( "     bCommitConstraint", "" );

	push	OFFSET $SG14326
	push	OFFSET $SG14327
	call	_TraceLineS@8
$LN26@DisplayObj:

; 1626 : 
; 1627 :    if ( lpViewOD->bDropOIConstraint )

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 6
	and	ecx, 1
	je	SHORT $LN27@DisplayObj

; 1628 :       TraceLineS( "     bDropOIConstraint", "" );

	push	OFFSET $SG14329
	push	OFFSET $SG14330
	call	_TraceLineS@8
$LN27@DisplayObj:

; 1629 : 
; 1630 :    if ( lpViewOD->bDeprecated )

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	mov	eax, DWORD PTR [edx+240]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	SHORT $LN28@DisplayObj

; 1631 :       TraceLineS( "     bDeprecated", "" );

	push	OFFSET $SG14332
	push	OFFSET $SG14333
	call	_TraceLineS@8
$LN28@DisplayObj:

; 1632 : 
; 1633 :    lpViewEntity = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax
$LN2@DisplayObj:

; 1634 :    while ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	$LN3@DisplayObj

; 1635 :    {
; 1636 :       fnTraceViewEntity( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	call	_fnTraceViewEntity@4

; 1637 : 
; 1638 :       lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@DisplayObj:

; 1639 :       while ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN5@DisplayObj

; 1640 :       {
; 1641 :          fnTraceViewAttrib( lpViewAttrib, sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	call	_fnTraceViewAttrib@8

; 1642 : 
; 1643 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1644 :       } // while ( lpViewAttrib )...

	jmp	SHORT $LN4@DisplayObj
$LN5@DisplayObj:

; 1645 : 
; 1646 :       lpDataRecord = zGETPTR( lpViewEntity->hFirstDataRecord );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+191]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax
$LN6@DisplayObj:

; 1647 :       while ( lpDataRecord )

	cmp	DWORD PTR _lpDataRecord$[ebp], 0
	je	$LN7@DisplayObj

; 1648 :       {
; 1649 :          TraceLineS( "", "" );

	push	OFFSET $SG14334
	push	OFFSET $SG14335
	call	_TraceLineS@8

; 1650 :          TraceLineS( "              DATARECORD name = ",

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	add	eax, 15					; 0000000fH
	push	eax
	push	OFFSET $SG14336
	call	_TraceLineS@8

; 1651 :                      lpDataRecord->szRecordName );
; 1652 : 
; 1653 :          sz[ 0 ] = lpDataRecord->cRecordType;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	cl, BYTE PTR [eax+14]
	mov	BYTE PTR _sz$[ebp+edx], cl

; 1654 :          TraceLineS( "              Record Type = ", sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	OFFSET $SG14337
	call	_TraceLineS@8

; 1655 : 
; 1656 :          if ( lpDataRecord->lRecordID )

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	cmp	DWORD PTR [eax+271], 0
	je	SHORT $LN29@DisplayObj

; 1657 :             TraceLineI( "              Record ID = ", lpDataRecord->lRecordID );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+271]
	push	edx
	push	OFFSET $SG14339
	call	_TraceLineI@8
$LN29@DisplayObj:

; 1658 : 
; 1659 :          lpDataField = zGETPTR( lpDataRecord->hFirstDataField );

	mov	eax, DWORD PTR _lpDataRecord$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField$[ebp], eax
$LN8@DisplayObj:

; 1660 :          while ( lpDataField )

	cmp	DWORD PTR _lpDataField$[ebp], 0
	je	$LN9@DisplayObj

; 1661 :          {
; 1662 :             LPVIEWATTRIB lpTemp = zGETPTR( lpDataField->hViewAttrib );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTemp$1[ebp], eax

; 1663 : 
; 1664 :             TraceLineS( "                DATAFIELD Attribute name = ",

	mov	ecx, DWORD PTR _lpTemp$1[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14340
	call	_TraceLineS@8

; 1665 :                         lpTemp->szName );
; 1666 :             TraceLineS( "                Field name = ",

	mov	edx, DWORD PTR _lpDataField$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14341
	call	_TraceLineS@8

; 1667 :                         lpDataField->szFldName );
; 1668 : 
; 1669 :             sz[ 0 ] = lpDataField->cFldType;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	al, BYTE PTR [edx+270]
	mov	BYTE PTR _sz$[ebp+ecx], al

; 1670 :             TraceLineS( "                Field type = ", sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET $SG14342
	call	_TraceLineS@8

; 1671 : 
; 1672 :             TraceLineI( "                Field length = ",

	mov	edx, DWORD PTR _lpDataField$[ebp]
	movzx	eax, WORD PTR [edx+271]
	push	eax
	push	OFFSET $SG14343
	call	_TraceLineI@8

; 1673 :                         (zLONG) lpDataField->uFldLth );
; 1674 : 
; 1675 :             if ( lpDataField->uFldOffset )

	mov	ecx, DWORD PTR _lpDataField$[ebp]
	movzx	edx, WORD PTR [ecx+273]
	test	edx, edx
	je	SHORT $LN30@DisplayObj

; 1676 :                TraceLineI( "                Field length = ",

	mov	eax, DWORD PTR _lpDataField$[ebp]
	movzx	ecx, WORD PTR [eax+273]
	push	ecx
	push	OFFSET $SG14345
	call	_TraceLineI@8
$LN30@DisplayObj:

; 1677 :                            (zLONG) lpDataField->uFldOffset );
; 1678 :             if ( lpDataField->lFldID )

	mov	edx, DWORD PTR _lpDataField$[ebp]
	cmp	DWORD PTR [edx+266], 0
	je	SHORT $LN31@DisplayObj

; 1679 :                TraceLineI( "                Field length = ",

	mov	eax, DWORD PTR _lpDataField$[ebp]
	mov	ecx, DWORD PTR [eax+266]
	push	ecx
	push	OFFSET $SG14347
	call	_TraceLineI@8
$LN31@DisplayObj:

; 1680 :                            lpDataField->lFldID );
; 1681 : 
; 1682 :             lpDataField = zGETPTR( lpDataField->hNextDataField );

	mov	edx, DWORD PTR _lpDataField$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataField$[ebp], eax

; 1683 :          } // while ( lpDataField )...

	jmp	$LN8@DisplayObj
$LN9@DisplayObj:

; 1684 : 
; 1685 :          lpRelRecord = zGETPTR( lpDataRecord->hFirstRelRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax
$LN10@DisplayObj:

; 1686 :          while ( lpRelRecord )

	cmp	DWORD PTR _lpRelRecord$[ebp], 0
	je	$LN11@DisplayObj

; 1687 :          {
; 1688 :             TraceLineS( "", "" );

	push	OFFSET $SG14348
	push	OFFSET $SG14349
	call	_TraceLineS@8

; 1689 :             TraceLineS( "                RELRECORD", "" );

	push	OFFSET $SG14350
	push	OFFSET $SG14351
	call	_TraceLineS@8

; 1690 :             sz[ 0 ] = lpRelRecord->cOwnerMember;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	al, BYTE PTR [edx+10]
	mov	BYTE PTR _sz$[ebp+ecx], al

; 1691 :             TraceLineS( "                cOwnerMember = ", sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	push	OFFSET $SG14352
	call	_TraceLineS@8

; 1692 :             if ( lpRelRecord->szRecordName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+11]
	test	edx, edx
	je	SHORT $LN32@DisplayObj

; 1693 :                TraceLineS( "                Record name = ",

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	add	eax, 11					; 0000000bH
	push	eax
	push	OFFSET $SG14354
	call	_TraceLineS@8
$LN32@DisplayObj:

; 1694 :                            lpRelRecord->szRecordName );
; 1695 : 
; 1696 :             if ( lpRelRecord->lRecordID )

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	cmp	DWORD PTR [ecx+267], 0
	je	SHORT $LN33@DisplayObj

; 1697 :                TraceLineI( "                Record ID = ",

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+267]
	push	eax
	push	OFFSET $SG14356
	call	_TraceLineI@8
$LN33@DisplayObj:

; 1698 :                            (zLONG) lpRelRecord->lRecordID );
; 1699 : 
; 1700 :             if ( lpRelRecord->szSetName1[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+271]
	test	ecx, ecx
	je	SHORT $LN34@DisplayObj

; 1701 :                TraceLineS( "                Set name 1 = ",

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	add	edx, 271				; 0000010fH
	push	edx
	push	OFFSET $SG14358
	call	_TraceLineS@8
$LN34@DisplayObj:

; 1702 :                            lpRelRecord->szSetName1 );
; 1703 : 
; 1704 :             if ( lpRelRecord->lSetID1 )

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	cmp	DWORD PTR [eax+527], 0
	je	SHORT $LN35@DisplayObj

; 1705 :                TraceLineI( "                Set 1 ID = ",

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	mov	edx, DWORD PTR [ecx+527]
	push	edx
	push	OFFSET $SG14360
	call	_TraceLineI@8
$LN35@DisplayObj:

; 1706 :                            (zLONG) lpRelRecord->lSetID1 );
; 1707 : 
; 1708 :             if ( lpRelRecord->szSetName2[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+531]
	test	eax, eax
	je	SHORT $LN36@DisplayObj

; 1709 :                TraceLineS( "                Set name 2 = ",

	mov	ecx, DWORD PTR _lpRelRecord$[ebp]
	add	ecx, 531				; 00000213H
	push	ecx
	push	OFFSET $SG14362
	call	_TraceLineS@8
$LN36@DisplayObj:

; 1710 :                            lpRelRecord->szSetName2 );
; 1711 : 
; 1712 :             if ( lpRelRecord->lSetID2 )

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	cmp	DWORD PTR [edx+787], 0
	je	SHORT $LN37@DisplayObj

; 1713 :                TraceLineI( "                Set 2 ID = ",

	mov	eax, DWORD PTR _lpRelRecord$[ebp]
	mov	ecx, DWORD PTR [eax+787]
	push	ecx
	push	OFFSET $SG14364
	call	_TraceLineI@8
$LN37@DisplayObj:

; 1714 :                            (zLONG) lpRelRecord->lSetID2 );
; 1715 : 
; 1716 :             lpRelField = zGETPTR( lpRelRecord->hFirstRelField );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax
$LN12@DisplayObj:

; 1717 :             while ( lpRelField )

	cmp	DWORD PTR _lpRelField$[ebp], 0
	je	$LN13@DisplayObj

; 1718 :             {
; 1719 :                LPDATAFIELD  lpTempDataField;
; 1720 :                LPVIEWATTRIB lpTempViewAttrib;
; 1721 :                LPVIEWENTITY lpTempViewEntity;
; 1722 : 
; 1723 :                TraceLineS( "", "" );

	push	OFFSET $SG14365
	push	OFFSET $SG14366
	call	_TraceLineS@8

; 1724 :                TraceLineS( "                     RELFIELD:", "" );

	push	OFFSET $SG14367
	push	OFFSET $SG14368
	call	_TraceLineS@8

; 1725 : 
; 1726 :                if ( lpRelField->hSrcDataField )

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN38@DisplayObj

; 1727 :                {
; 1728 :                   lpTempDataField  = zGETPTR( lpRelField->hSrcDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempDataField$6[ebp], eax

; 1729 :                   lpTempViewAttrib = zGETPTR( lpTempDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpTempDataField$6[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewAttrib$7[ebp], eax

; 1730 :                   lpTempViewEntity = zGETPTR( lpTempViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpTempViewAttrib$7[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntity$5[ebp], eax

; 1731 : 
; 1732 :                   TraceLineS( "                     Source entity = ",

	mov	edx, DWORD PTR _lpTempViewEntity$5[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG14370
	call	_TraceLineS@8

; 1733 :                               lpTempViewEntity->szName );
; 1734 :                   TraceLineS( "                     Source attrib = ",

	mov	eax, DWORD PTR _lpTempViewAttrib$7[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14371
	call	_TraceLineS@8
$LN38@DisplayObj:

; 1735 :                               lpTempViewAttrib->szName );
; 1736 :                }
; 1737 : 
; 1738 :                if ( lpRelField->hRelDataField )

	mov	ecx, DWORD PTR _lpRelField$[ebp]
	cmp	DWORD PTR [ecx+14], 0
	je	SHORT $LN39@DisplayObj

; 1739 :                {
; 1740 :                   lpTempDataField  = zGETPTR( lpRelField->hRelDataField );

	mov	edx, DWORD PTR _lpRelField$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempDataField$6[ebp], eax

; 1741 :                   lpTempViewAttrib = zGETPTR( lpTempDataField->hViewAttrib );

	mov	ecx, DWORD PTR _lpTempDataField$6[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewAttrib$7[ebp], eax

; 1742 :                   lpTempViewEntity = zGETPTR( lpTempViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpTempViewAttrib$7[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempViewEntity$5[ebp], eax

; 1743 : 
; 1744 :                   TraceLineS( "                     Rel entity = ",

	mov	edx, DWORD PTR _lpTempViewEntity$5[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG14373
	call	_TraceLineS@8

; 1745 :                               lpTempViewEntity->szName );
; 1746 :                   TraceLineS( "                     Rel attrib = ",

	mov	eax, DWORD PTR _lpTempViewAttrib$7[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14374
	call	_TraceLineS@8
$LN39@DisplayObj:

; 1747 :                               lpTempViewAttrib->szName );
; 1748 :                }
; 1749 : 
; 1750 :                if ( lpRelField->szFldName[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpRelField$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+18]
	test	ecx, ecx
	je	SHORT $LN40@DisplayObj

; 1751 :                   TraceLineS( "                     Field name = ",

	mov	edx, DWORD PTR _lpRelField$[ebp]
	add	edx, 18					; 00000012H
	push	edx
	push	OFFSET $SG14376
	call	_TraceLineS@8
$LN40@DisplayObj:

; 1752 :                               lpRelField->szFldName );
; 1753 : 
; 1754 :                lpRelField = zGETPTR( lpRelField->hNextRelField );

	mov	eax, DWORD PTR _lpRelField$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelField$[ebp], eax

; 1755 :             } // while ( lpRelField )...

	jmp	$LN12@DisplayObj
$LN13@DisplayObj:

; 1756 : 
; 1757 :             lpRelRecord = zGETPTR( lpRelRecord->hNextRelRecord );

	mov	edx, DWORD PTR _lpRelRecord$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRelRecord$[ebp], eax

; 1758 :          } // while ( lpRelRecord )...

	jmp	$LN10@DisplayObj
$LN11@DisplayObj:

; 1759 : 
; 1760 :          lpDataRecord = zGETPTR( lpDataRecord->hNextDataRecord );

	mov	ecx, DWORD PTR _lpDataRecord$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDataRecord$[ebp], eax

; 1761 :       } // while ( lpDataRecord )...

	jmp	$LN6@DisplayObj
$LN7@DisplayObj:

; 1762 : 
; 1763 :       lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1764 :    } // while ( lpViewEntity )...

	jmp	$LN2@DisplayObj
$LN3@DisplayObj:

; 1765 : 
; 1766 :    return( 0 );

	xor	eax, eax
$LN41@DisplayObj:

; 1767 : 
; 1768 : }  /* DisplayObjectDef */

	mov	esp, ebp
	pop	ebp
	ret	8
_DisplayObjectDef@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
$T1 = -808						; size = 4
$T2 = -804						; size = 4
$T3 = -800						; size = 4
$T4 = -796						; size = 4
_ulBlankLines$ = -792					; size = 4
_cpcBuffer$ = -788					; size = 4
_uLongestStr$ = -784					; size = 2
_n$ = -780						; size = 4
_ulPos$ = -776						; size = 4
_sz$ = -772						; size = 256
_szAscii$ = -516					; size = 256
_szHex$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_cpcPrefix$ = 8						; size = 4
_pvBuffer$ = 12						; size = 4
_ulLth$ = 16						; size = 4
_TraceBuffer@12 PROC

; 468  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 808				; 00000328H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 469  :    zCPCHAR cpcBuffer = (zCPCHAR) pvBuffer;

	mov	eax, DWORD PTR _pvBuffer$[ebp]
	mov	DWORD PTR _cpcBuffer$[ebp], eax

; 470  :    zCHAR   szHex[ 256 ];
; 471  :    zCHAR   szAscii[ 256 ];
; 472  :    zCHAR   sz[ 256 ];
; 473  :    zULONG  ulPos;
; 474  :    zULONG  n;
; 475  :    zULONG  ulBlankLines;
; 476  :    zUSHORT uLongestStr = 0;

	xor	ecx, ecx
	mov	WORD PTR _uLongestStr$[ebp], cx

; 477  : 
; 478  :    // szHex is a buffer containing the prefix and the hex representation of
; 479  :    // 16 bytes from the buffer.  szAscii is a buffer containing the ASCII
; 480  :    // representation of those same 16 bytes.
; 481  : 
; 482  :    szHex[ 0 ]   = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T4[ebp], eax
	cmp	DWORD PTR $T4[ebp], 256			; 00000100H
	jae	SHORT $LN23@TraceBuffe
	jmp	SHORT $LN24@TraceBuffe
$LN23@TraceBuffe:
	call	___report_rangecheckfailure
$LN24@TraceBuffe:
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szHex$[ebp+ecx], 0

; 483  :    szAscii[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 256			; 00000100H
	jae	SHORT $LN25@TraceBuffe
	jmp	SHORT $LN26@TraceBuffe
$LN25@TraceBuffe:
	call	___report_rangecheckfailure
$LN26@TraceBuffe:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szAscii$[ebp+ecx], 0

; 484  : 
; 485  :    // Loop through each byte in the buffer and display a block of 16 bytes
; 486  :    // on each line in the trace window.
; 487  :    for ( ulPos = 0; ulPos < ulLth; ulPos++ )

	mov	DWORD PTR _ulPos$[ebp], 0
	jmp	SHORT $LN4@TraceBuffe
$LN2@TraceBuffe:
	mov	edx, DWORD PTR _ulPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _ulPos$[ebp], edx
$LN4@TraceBuffe:
	mov	eax, DWORD PTR _ulPos$[ebp]
	cmp	eax, DWORD PTR _ulLth$[ebp]
	jae	$LN3@TraceBuffe

; 488  :    {
; 489  :       // If the index is a multiple of 16, then trace the szHex and szAscii
; 490  :       // buffers (if they aren't empty) and reset them.
; 491  :       if ( ulPos % 16 == 0 )

	mov	eax, DWORD PTR _ulPos$[ebp]
	xor	edx, edx
	mov	ecx, 16					; 00000010H
	div	ecx
	test	edx, edx
	jne	$LN10@TraceBuffe

; 492  :       {
; 493  :          if ( szHex[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szHex$[ebp+eax]
	test	ecx, ecx
	je	SHORT $LN12@TraceBuffe

; 494  :          {
; 495  :             TraceLineS( szHex, szAscii );

	lea	edx, DWORD PTR _szAscii$[ebp]
	push	edx
	lea	eax, DWORD PTR _szHex$[ebp]
	push	eax
	call	_TraceLineS@8

; 496  : 
; 497  :             // Keep track of the longest hex string.
; 498  :             if ( uLongestStr < zstrlen( szHex ) )

	movzx	esi, WORD PTR _uLongestStr$[ebp]
	lea	ecx, DWORD PTR _szHex$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	esi, eax
	jae	SHORT $LN12@TraceBuffe

; 499  :                uLongestStr = zstrlen( szHex );

	lea	edx, DWORD PTR _szHex$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _uLongestStr$[ebp], ax
$LN12@TraceBuffe:

; 500  :          }
; 501  : 
; 502  :          // Check for long string of same characters.
; 503  :          for ( n = ulPos; n < ulLth; n++ )

	mov	eax, DWORD PTR _ulPos$[ebp]
	mov	DWORD PTR _n$[ebp], eax
	jmp	SHORT $LN7@TraceBuffe
$LN5@TraceBuffe:
	mov	ecx, DWORD PTR _n$[ebp]
	add	ecx, 1
	mov	DWORD PTR _n$[ebp], ecx
$LN7@TraceBuffe:
	mov	edx, DWORD PTR _n$[ebp]
	cmp	edx, DWORD PTR _ulLth$[ebp]
	jae	SHORT $LN6@TraceBuffe

; 504  :          {
; 505  :             if ( n > 0 && cpcBuffer[ n ] != cpcBuffer[ n - 1 ] )

	cmp	DWORD PTR _n$[ebp], 0
	jbe	SHORT $LN14@TraceBuffe
	mov	eax, DWORD PTR _cpcBuffer$[ebp]
	add	eax, DWORD PTR _n$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _cpcBuffer$[ebp]
	add	edx, DWORD PTR _n$[ebp]
	movsx	eax, BYTE PTR [edx-1]
	cmp	ecx, eax
	je	SHORT $LN14@TraceBuffe

; 506  :                break;

	jmp	SHORT $LN6@TraceBuffe
$LN14@TraceBuffe:

; 507  :          }

	jmp	SHORT $LN5@TraceBuffe
$LN6@TraceBuffe:

; 508  : 
; 509  :          ulBlankLines = (n - ulPos) / 16;

	mov	ecx, DWORD PTR _n$[ebp]
	sub	ecx, DWORD PTR _ulPos$[ebp]
	shr	ecx, 4
	mov	DWORD PTR _ulBlankLines$[ebp], ecx

; 510  :          if ( ulBlankLines > 2 )

	cmp	DWORD PTR _ulBlankLines$[ebp], 2
	jbe	SHORT $LN15@TraceBuffe

; 511  :          {
; 512  :             n = ulBlankLines * 16;

	mov	edx, DWORD PTR _ulBlankLines$[ebp]
	shl	edx, 4
	mov	DWORD PTR _n$[ebp], edx

; 513  :             zsprintf( szHex, "%s  %d Repeat Lines (%4d thru %4d) ",

	mov	eax, DWORD PTR _n$[ebp]
	mov	ecx, DWORD PTR _ulPos$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	push	edx
	mov	eax, DWORD PTR _ulPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulBlankLines$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcPrefix$[ebp]
	push	edx
	push	OFFSET $SG13548
	lea	eax, DWORD PTR _szHex$[ebp]
	push	eax
	call	_sprintf
	add	esp, 24					; 00000018H

; 514  :                       cpcPrefix, ulBlankLines, ulPos, ulPos + n - 1 );
; 515  :             TraceLineS( szHex, "" );

	push	OFFSET $SG13549
	lea	ecx, DWORD PTR _szHex$[ebp]
	push	ecx
	call	_TraceLineS@8

; 516  :             ulPos += n;

	mov	edx, DWORD PTR _ulPos$[ebp]
	add	edx, DWORD PTR _n$[ebp]
	mov	DWORD PTR _ulPos$[ebp], edx
$LN15@TraceBuffe:

; 517  :          }
; 518  : 
; 519  :          // Add the offset counter to cpcPrefix.
; 520  :          zsprintf( szHex, "%s(%4d) ", cpcPrefix, ulPos );

	mov	eax, DWORD PTR _ulPos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcPrefix$[ebp]
	push	ecx
	push	OFFSET $SG13550
	lea	edx, DWORD PTR _szHex$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 521  :          zstrcpy( szAscii, "    " );

	push	OFFSET $SG13551
	lea	eax, DWORD PTR _szAscii$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 522  :       }

	jmp	SHORT $LN11@TraceBuffe
$LN10@TraceBuffe:

; 523  :       else
; 524  :       if ( ulPos % 8 == 0 )

	mov	eax, DWORD PTR _ulPos$[ebp]
	xor	edx, edx
	mov	ecx, 8
	div	ecx
	test	edx, edx
	jne	SHORT $LN11@TraceBuffe

; 525  :       {
; 526  :          // The index is a multiple of 8, so add a few spaces to the buffers
; 527  :          // to make the trace a little easier to read.
; 528  :          zstrcat( szHex, "   " );

	push	OFFSET $SG13553
	lea	edx, DWORD PTR _szHex$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN11@TraceBuffe:

; 529  :       // zstrcat( szAscii, " " );
; 530  :       }
; 531  : 
; 532  :       // Convert the current byte to a 2-char hex number.
; 533  :       zltox( (zLONG) cpcBuffer[ ulPos ], sz );

	push	16					; 00000010H
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcBuffer$[ebp]
	add	ecx, DWORD PTR _ulPos$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 534  :       n = zstrlen( sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 535  :       if ( n < 2 )

	cmp	DWORD PTR _n$[ebp], 2
	jae	SHORT $LN17@TraceBuffe

; 536  :       {
; 537  :          zstrcat( szHex, "0" );

	push	OFFSET $SG13556
	lea	ecx, DWORD PTR _szHex$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 538  :          n = 0;

	mov	DWORD PTR _n$[ebp], 0

; 539  :       }

	jmp	SHORT $LN18@TraceBuffe
$LN17@TraceBuffe:

; 540  :       else
; 541  :          n -= 2;

	mov	edx, DWORD PTR _n$[ebp]
	sub	edx, 2
	mov	DWORD PTR _n$[ebp], edx
$LN18@TraceBuffe:

; 542  : 
; 543  :       // Add the hex number to szHex.
; 544  :       zstrcat( szHex, &sz[ n ] );

	mov	eax, DWORD PTR _n$[ebp]
	lea	ecx, DWORD PTR _sz$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _szHex$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 545  :       zstrcat( szHex, " " );

	push	OFFSET $SG13557
	lea	eax, DWORD PTR _szHex$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 546  : 
; 547  :       // If the current byte is a printable char, then copy it to the ASCII
; 548  :       // buffer.  Otherwise add a "." to the buffer.
; 549  :       if ( cpcBuffer[ ulPos ] >= 32 && cpcBuffer[ ulPos ] <= 126 )

	mov	ecx, DWORD PTR _cpcBuffer$[ebp]
	add	ecx, DWORD PTR _ulPos$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	$LN19@TraceBuffe
	mov	eax, DWORD PTR _cpcBuffer$[ebp]
	add	eax, DWORD PTR _ulPos$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 126				; 0000007eH
	jg	SHORT $LN19@TraceBuffe

; 550  :       {
; 551  :          n = zstrlen( szAscii );

	lea	edx, DWORD PTR _szAscii$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _n$[ebp], eax

; 552  :          szAscii[ n++ ] = cpcBuffer[ ulPos ];

	mov	eax, DWORD PTR _cpcBuffer$[ebp]
	add	eax, DWORD PTR _ulPos$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR _szAscii$[ebp+ecx], dl
	mov	eax, DWORD PTR _n$[ebp]
	add	eax, 1
	mov	DWORD PTR _n$[ebp], eax

; 553  :          szAscii[ n ]   = 0;

	mov	ecx, DWORD PTR _n$[ebp]
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 256			; 00000100H
	jae	SHORT $LN27@TraceBuffe
	jmp	SHORT $LN28@TraceBuffe
$LN27@TraceBuffe:
	call	___report_rangecheckfailure
$LN28@TraceBuffe:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szAscii$[ebp+edx], 0

; 554  :       }

	jmp	SHORT $LN20@TraceBuffe
$LN19@TraceBuffe:

; 555  :       else
; 556  :          zstrcat( szAscii, "." );

	push	OFFSET $SG13560
	lea	eax, DWORD PTR _szAscii$[ebp]
	push	eax
	call	_strcat
	add	esp, 8
$LN20@TraceBuffe:

; 557  : 
; 558  :    } // for...

	jmp	$LN2@TraceBuffe
$LN3@TraceBuffe:

; 559  : 
; 560  :    // If szHex is not empty, then the buffers contain information that needs
; 561  :    // to be traced.
; 562  :    if ( szHex[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szHex$[ebp+edx]
	test	eax, eax
	je	$LN22@TraceBuffe

; 563  :    {
; 564  :       // Pad the current szHex string with spaces so that it matches (in lth)
; 565  :       // the longest szHex string that was traced.
; 566  :       ulPos = zstrlen( szHex );

	lea	ecx, DWORD PTR _szHex$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulPos$[ebp], eax
$LN8@TraceBuffe:

; 567  :       while ( ulPos < uLongestStr )

	movzx	edx, WORD PTR _uLongestStr$[ebp]
	cmp	DWORD PTR _ulPos$[ebp], edx
	jae	SHORT $LN9@TraceBuffe

; 568  :          szHex[ ulPos++ ] = ' ';

	mov	eax, DWORD PTR _ulPos$[ebp]
	mov	BYTE PTR _szHex$[ebp+eax], 32		; 00000020H
	mov	ecx, DWORD PTR _ulPos$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ulPos$[ebp], ecx
	jmp	SHORT $LN8@TraceBuffe
$LN9@TraceBuffe:

; 569  : 
; 570  :       szHex[ ulPos ] = 0;

	mov	edx, DWORD PTR _ulPos$[ebp]
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN29@TraceBuffe
	jmp	SHORT $LN30@TraceBuffe
$LN29@TraceBuffe:
	call	___report_rangecheckfailure
$LN30@TraceBuffe:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szHex$[ebp+eax], 0

; 571  : 
; 572  :       TraceLineS( szHex, szAscii );

	lea	ecx, DWORD PTR _szAscii$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szHex$[ebp]
	push	edx
	call	_TraceLineS@8
$LN22@TraceBuffe:

; 573  :    }
; 574  : 
; 575  : } // TraceBuffer

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TraceBuffer@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_args$ = -65548						; size = 4
_nBufCnt$ = -65544					; size = 2
_szBuffer$ = -65540					; size = 65534
__$ArrayPad$ = -4					; size = 4
_cpcFormat$ = 8						; size = 4
_TraceLine PROC

; 438  : {

	push	ebp
	mov	ebp, esp
	mov	eax, 65548				; 0001000cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 439  :    short   nBufCnt;
; 440  :    zCHAR   szBuffer[ 65534 ];
; 441  :    va_list args;
; 442  : 
; 443  :    va_start( args, cpcFormat );

	lea	eax, DWORD PTR _cpcFormat$[ebp+4]
	mov	DWORD PTR _args$[ebp], eax

; 444  : 
; 445  :    nBufCnt = _vsnprintf( szBuffer, _countof( szBuffer ), cpcFormat, args );

	mov	ecx, DWORD PTR _args$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	push	edx
	push	65534					; 0000fffeH
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	__vsnprintf
	add	esp, 16					; 00000010H
	mov	WORD PTR _nBufCnt$[ebp], ax

; 446  : 
; 447  :    // was there an error? was the expanded string too long?
; 448  :    if ( nBufCnt >= 0 )

	movsx	ecx, WORD PTR _nBufCnt$[ebp]
	test	ecx, ecx
	jl	SHORT $LN2@TraceLine

; 449  :       TraceLineS( szBuffer, "" );

	push	OFFSET $SG13511
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_TraceLineS@8
	jmp	SHORT $LN3@TraceLine
$LN2@TraceLine:

; 450  :    else
; 451  :       TraceLineS( "Error formatting message: ", cpcFormat );

	mov	eax, DWORD PTR _cpcFormat$[ebp]
	push	eax
	push	OFFSET $SG13512
	call	_TraceLineS@8
$LN3@TraceLine:

; 452  : 
; 453  :    va_end( args );

	mov	DWORD PTR _args$[ebp], 0

; 454  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TraceLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
$T1 = -292						; size = 4
$T2 = -288						; size = 4
_nStringLth$3 = -284					; size = 4
_nTitleLth$4 = -280					; size = 4
_nVacant$5 = -276					; size = 4
_nMsgOffset$6 = -272					; size = 4
_pch$7 = -268						; size = 4
_nLth$8 = -264						; size = 4
_szMessage$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_Title$ = 8						; size = 4
_String$ = 12						; size = 4
_TraceLineS@8 PROC

; 289  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 292				; 00000124H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 290  :    zCHAR szMessage[ zMAX_MSG_LTH + 1 ];
; 291  : 
; 292  :    if ( g_hAnchorBlock == 0 )

	cmp	DWORD PTR _g_hAnchorBlock, 0
	jne	SHORT $LN6@TraceLineS

; 293  :       return;

	jmp	$LN27@TraceLineS
$LN6@TraceLineS:

; 294  : 
; 295  :    if ( Title )

	cmp	DWORD PTR _Title$[ebp], 0
	je	$LN7@TraceLineS

; 296  :    {
; 297  :       int  nTitleLth = zstrlen( Title );

	mov	eax, DWORD PTR _Title$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nTitleLth$4[ebp], eax

; 298  :       int  nStringLth;
; 299  : 
; 300  :       if ( String )

	cmp	DWORD PTR _String$[ebp], 0
	je	SHORT $LN9@TraceLineS

; 301  :          nStringLth = zstrlen( String );

	mov	ecx, DWORD PTR _String$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _nStringLth$3[ebp], eax
	jmp	SHORT $LN10@TraceLineS
$LN9@TraceLineS:

; 302  :       else
; 303  :          nStringLth = 6;   // for "(null)"

	mov	DWORD PTR _nStringLth$3[ebp], 6
$LN10@TraceLineS:

; 304  : 
; 305  :       // The common case is that everything fits nicely ... so take care of
; 306  :       // it right away.
; 307  :       if ( nTitleLth + nStringLth < zMAX_MSG_LTH )

	mov	edx, DWORD PTR _nTitleLth$4[ebp]
	add	edx, DWORD PTR _nStringLth$3[ebp]
	cmp	edx, 255				; 000000ffH
	jge	SHORT $LN11@TraceLineS

; 308  :       {
; 309  :          zstrcpy( szMessage, Title );

	mov	eax, DWORD PTR _Title$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 310  :          if ( String )

	cmp	DWORD PTR _String$[ebp], 0
	je	SHORT $LN13@TraceLineS

; 311  :             zstrcpy( szMessage + nTitleLth, String );

	mov	edx, DWORD PTR _String$[ebp]
	push	edx
	mov	eax, DWORD PTR _nTitleLth$4[ebp]
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN14@TraceLineS
$LN13@TraceLineS:

; 312  :          else
; 313  :             zstrcpy( szMessage + nTitleLth, "(null)" );

	push	OFFSET $SG13481
	mov	edx, DWORD PTR _nTitleLth$4[ebp]
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8
$LN14@TraceLineS:

; 314  :       }

	jmp	$LN12@TraceLineS
$LN11@TraceLineS:

; 315  :       else
; 316  :       {
; 317  :          // If we get to this code, our message exceeds the amount of
; 318  :          // memory allocated for szMessage ... so we try to nicely break
; 319  :          // up the message.
; 320  : 
; 321  :          int    nLth = 0;           // amount sent so far

	mov	DWORD PTR _nLth$8[ebp], 0

; 322  :          int    nMsgOffset = 0;     // amount of szMessage currently loaded

	mov	DWORD PTR _nMsgOffset$6[ebp], 0
$LN2@TraceLineS:

; 323  :          zPCHAR pch;
; 324  :          int    nVacant;
; 325  : 
; 326  :          while ( nLth < nTitleLth )

	mov	ecx, DWORD PTR _nLth$8[ebp]
	cmp	ecx, DWORD PTR _nTitleLth$4[ebp]
	jge	$LN3@TraceLineS

; 327  :          {
; 328  :             nVacant = zMAX_MSG_LTH - nMsgOffset;

	mov	edx, 255				; 000000ffH
	sub	edx, DWORD PTR _nMsgOffset$6[ebp]
	mov	DWORD PTR _nVacant$5[ebp], edx

; 329  :             if ( nVacant > nTitleLth - nLth )  // fit rest of title?

	mov	eax, DWORD PTR _nTitleLth$4[ebp]
	sub	eax, DWORD PTR _nLth$8[ebp]
	cmp	DWORD PTR _nVacant$5[ebp], eax
	jle	SHORT $LN15@TraceLineS

; 330  :             {
; 331  :                zstrcpy( szMessage + nMsgOffset, Title + nLth );

	mov	ecx, DWORD PTR _Title$[ebp]
	add	ecx, DWORD PTR _nLth$8[ebp]
	push	ecx
	mov	edx, DWORD PTR _nMsgOffset$6[ebp]
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8

; 332  :                nVacant -= (nTitleLth - nLth);

	mov	ecx, DWORD PTR _nTitleLth$4[ebp]
	sub	ecx, DWORD PTR _nLth$8[ebp]
	mov	edx, DWORD PTR _nVacant$5[ebp]
	sub	edx, ecx
	mov	DWORD PTR _nVacant$5[ebp], edx

; 333  :                nMsgOffset += nTitleLth - nLth;

	mov	eax, DWORD PTR _nTitleLth$4[ebp]
	sub	eax, DWORD PTR _nLth$8[ebp]
	add	eax, DWORD PTR _nMsgOffset$6[ebp]
	mov	DWORD PTR _nMsgOffset$6[ebp], eax

; 334  :                nLth = nTitleLth;

	mov	ecx, DWORD PTR _nTitleLth$4[ebp]
	mov	DWORD PTR _nLth$8[ebp], ecx

; 335  :             }

	jmp	$LN16@TraceLineS
$LN15@TraceLineS:

; 336  :             else
; 337  :             {
; 338  :                // fit as much of title as possible into szMessage using
; 339  :                // commas and spaces to break the message if possible
; 340  :                zstrncpy( szMessage + nMsgOffset, Title + nLth, nVacant );

	mov	edx, DWORD PTR _nVacant$5[ebp]
	push	edx
	mov	eax, DWORD PTR _Title$[ebp]
	add	eax, DWORD PTR _nLth$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _nMsgOffset$6[ebp]
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 341  :                szMessage[ zMAX_MSG_LTH ] = 0;

	mov	eax, 1
	imul	ecx, eax, 255
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 256			; 00000100H
	jae	SHORT $LN28@TraceLineS
	jmp	SHORT $LN29@TraceLineS
$LN28@TraceLineS:
	call	___report_rangecheckfailure
$LN29@TraceLineS:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szMessage$[ebp+edx], 0

; 342  : 
; 343  :                pch = zstrrchr( szMessage, ',' );

	push	44					; 0000002cH
	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	mov	DWORD PTR _pch$7[ebp], eax

; 344  :                if ( pch > szMessage + 5 )

	lea	ecx, DWORD PTR _szMessage$[ebp+5]
	cmp	DWORD PTR _pch$7[ebp], ecx
	jbe	SHORT $LN17@TraceLineS

; 345  :                {
; 346  :                   pch++;

	mov	edx, DWORD PTR _pch$7[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$7[ebp], edx

; 347  :                   *pch = 0;

	mov	eax, DWORD PTR _pch$7[ebp]
	mov	BYTE PTR [eax], 0

; 348  :                   nLth += (pch - (zPCHAR) szMessage) - nMsgOffset;

	mov	ecx, DWORD PTR _pch$7[ebp]
	lea	edx, DWORD PTR _szMessage$[ebp]
	sub	ecx, edx
	sub	ecx, DWORD PTR _nMsgOffset$6[ebp]
	add	ecx, DWORD PTR _nLth$8[ebp]
	mov	DWORD PTR _nLth$8[ebp], ecx

; 349  :                }

	jmp	SHORT $LN18@TraceLineS
$LN17@TraceLineS:

; 350  :                else
; 351  :                {
; 352  :                   pch = zstrrchr( szMessage, ' ' );

	push	32					; 00000020H
	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	mov	DWORD PTR _pch$7[ebp], eax

; 353  :                   if ( pch > szMessage + 5 )

	lea	ecx, DWORD PTR _szMessage$[ebp+5]
	cmp	DWORD PTR _pch$7[ebp], ecx
	jbe	SHORT $LN19@TraceLineS

; 354  :                   {
; 355  :                      pch++;

	mov	edx, DWORD PTR _pch$7[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$7[ebp], edx

; 356  :                      *pch = 0;

	mov	eax, DWORD PTR _pch$7[ebp]
	mov	BYTE PTR [eax], 0

; 357  :                      nLth += (pch - (zPCHAR) szMessage) - nMsgOffset;

	mov	ecx, DWORD PTR _pch$7[ebp]
	lea	edx, DWORD PTR _szMessage$[ebp]
	sub	ecx, edx
	sub	ecx, DWORD PTR _nMsgOffset$6[ebp]
	add	ecx, DWORD PTR _nLth$8[ebp]
	mov	DWORD PTR _nLth$8[ebp], ecx

; 358  :                   }

	jmp	SHORT $LN18@TraceLineS
$LN19@TraceLineS:

; 359  :                   else
; 360  :                      nLth += nVacant;

	mov	eax, DWORD PTR _nLth$8[ebp]
	add	eax, DWORD PTR _nVacant$5[ebp]
	mov	DWORD PTR _nLth$8[ebp], eax
$LN18@TraceLineS:

; 361  :                }
; 362  : 
; 363  :                SysMessageList( szMessage );

	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	call	_SysMessageList@4

; 364  :                zstrcpy( szMessage, " +   " );

	push	OFFSET $SG13488
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 365  :                nMsgOffset = 5;

	mov	DWORD PTR _nMsgOffset$6[ebp], 5
$LN16@TraceLineS:

; 366  :             }
; 367  :          }

	jmp	$LN2@TraceLineS
$LN3@TraceLineS:

; 368  : 
; 369  :          nLth = 0;

	mov	DWORD PTR _nLth$8[ebp], 0
$LN4@TraceLineS:

; 370  :          while ( nLth < nStringLth )

	mov	eax, DWORD PTR _nLth$8[ebp]
	cmp	eax, DWORD PTR _nStringLth$3[ebp]
	jge	$LN12@TraceLineS

; 371  :          {
; 372  :             nVacant = zMAX_MSG_LTH - nMsgOffset;

	mov	ecx, 255				; 000000ffH
	sub	ecx, DWORD PTR _nMsgOffset$6[ebp]
	mov	DWORD PTR _nVacant$5[ebp], ecx

; 373  :             if ( nVacant > nStringLth - nLth )  // fit rest of string?

	mov	edx, DWORD PTR _nStringLth$3[ebp]
	sub	edx, DWORD PTR _nLth$8[ebp]
	cmp	DWORD PTR _nVacant$5[ebp], edx
	jle	SHORT $LN21@TraceLineS

; 374  :             {
; 375  :                zstrcpy( szMessage + nMsgOffset, String + nLth );

	mov	eax, DWORD PTR _String$[ebp]
	add	eax, DWORD PTR _nLth$8[ebp]
	push	eax
	mov	ecx, DWORD PTR _nMsgOffset$6[ebp]
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 376  :                nVacant -= (nStringLth - nLth);

	mov	eax, DWORD PTR _nStringLth$3[ebp]
	sub	eax, DWORD PTR _nLth$8[ebp]
	mov	ecx, DWORD PTR _nVacant$5[ebp]
	sub	ecx, eax
	mov	DWORD PTR _nVacant$5[ebp], ecx

; 377  :                nMsgOffset += nStringLth - nLth;

	mov	edx, DWORD PTR _nStringLth$3[ebp]
	sub	edx, DWORD PTR _nLth$8[ebp]
	add	edx, DWORD PTR _nMsgOffset$6[ebp]
	mov	DWORD PTR _nMsgOffset$6[ebp], edx

; 378  :                nLth = nStringLth;

	mov	eax, DWORD PTR _nStringLth$3[ebp]
	mov	DWORD PTR _nLth$8[ebp], eax

; 379  :             }

	jmp	$LN22@TraceLineS
$LN21@TraceLineS:

; 380  :             else
; 381  :             {
; 382  :                // fit as much of title as possible into szMessage using
; 383  :                // commas and spaces to break the message if possible
; 384  :                zstrncpy( szMessage + nMsgOffset, String + nLth, nVacant );

	mov	ecx, DWORD PTR _nVacant$5[ebp]
	push	ecx
	mov	edx, DWORD PTR _String$[ebp]
	add	edx, DWORD PTR _nLth$8[ebp]
	push	edx
	mov	eax, DWORD PTR _nMsgOffset$6[ebp]
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 385  :                szMessage[ zMAX_MSG_LTH ] = 0;

	mov	edx, 1
	imul	eax, edx, 255
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN30@TraceLineS
	jmp	SHORT $LN31@TraceLineS
$LN30@TraceLineS:
	call	___report_rangecheckfailure
$LN31@TraceLineS:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szMessage$[ebp+ecx], 0

; 386  : 
; 387  :                pch = zstrrchr( szMessage, ',' );

	push	44					; 0000002cH
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	mov	DWORD PTR _pch$7[ebp], eax

; 388  :                if ( pch > szMessage + 5 )

	lea	eax, DWORD PTR _szMessage$[ebp+5]
	cmp	DWORD PTR _pch$7[ebp], eax
	jbe	SHORT $LN23@TraceLineS

; 389  :                {
; 390  :                   pch++;

	mov	ecx, DWORD PTR _pch$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$7[ebp], ecx

; 391  :                   *pch = 0;

	mov	edx, DWORD PTR _pch$7[ebp]
	mov	BYTE PTR [edx], 0

; 392  :                   nLth += (pch - (zPCHAR) szMessage) - nMsgOffset;

	mov	eax, DWORD PTR _pch$7[ebp]
	lea	ecx, DWORD PTR _szMessage$[ebp]
	sub	eax, ecx
	sub	eax, DWORD PTR _nMsgOffset$6[ebp]
	add	eax, DWORD PTR _nLth$8[ebp]
	mov	DWORD PTR _nLth$8[ebp], eax

; 393  :                }

	jmp	SHORT $LN24@TraceLineS
$LN23@TraceLineS:

; 394  :                else
; 395  :                {
; 396  :                   pch = zstrrchr( szMessage, ' ' );

	push	32					; 00000020H
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	DWORD PTR __imp__strrchr
	add	esp, 8
	mov	DWORD PTR _pch$7[ebp], eax

; 397  :                   if ( pch > szMessage + 5 )

	lea	eax, DWORD PTR _szMessage$[ebp+5]
	cmp	DWORD PTR _pch$7[ebp], eax
	jbe	SHORT $LN25@TraceLineS

; 398  :                   {
; 399  :                      pch++;

	mov	ecx, DWORD PTR _pch$7[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$7[ebp], ecx

; 400  :                      *pch = 0;

	mov	edx, DWORD PTR _pch$7[ebp]
	mov	BYTE PTR [edx], 0

; 401  :                      nLth += (pch - (zPCHAR) szMessage) - nMsgOffset;

	mov	eax, DWORD PTR _pch$7[ebp]
	lea	ecx, DWORD PTR _szMessage$[ebp]
	sub	eax, ecx
	sub	eax, DWORD PTR _nMsgOffset$6[ebp]
	add	eax, DWORD PTR _nLth$8[ebp]
	mov	DWORD PTR _nLth$8[ebp], eax

; 402  :                   }

	jmp	SHORT $LN24@TraceLineS
$LN25@TraceLineS:

; 403  :                   else
; 404  :                      nLth += nVacant;

	mov	edx, DWORD PTR _nLth$8[ebp]
	add	edx, DWORD PTR _nVacant$5[ebp]
	mov	DWORD PTR _nLth$8[ebp], edx
$LN24@TraceLineS:

; 405  :                }
; 406  : 
; 407  :                SysMessageList( szMessage );

	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_SysMessageList@4

; 408  :                zstrcpy( szMessage, " +   " );

	push	OFFSET $SG13495
	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 409  :                nMsgOffset = 5;

	mov	DWORD PTR _nMsgOffset$6[ebp], 5
$LN22@TraceLineS:

; 410  :             }
; 411  :          }

	jmp	$LN4@TraceLineS
$LN12@TraceLineS:

; 412  :       }
; 413  :    }

	jmp	SHORT $LN8@TraceLineS
$LN7@TraceLineS:

; 414  :    else
; 415  :    {
; 416  :       zstrcpy( szMessage, "(oetr) Invalid \"null\" TraceLine title" );

	push	OFFSET $SG13496
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN8@TraceLineS:

; 417  :    }
; 418  : 
; 419  :    SysMessageList( szMessage );

	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_SysMessageList@4
$LN27@TraceLineS:

; 420  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TraceLineS@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lpViewEntityCsrPosition$ = -56				; size = 4
_lpViewOD$ = -52					; size = 4
_lpViewOI$1 = -48					; size = 4
tv217 = -44						; size = 4
tv216 = -40						; size = 4
_lpViewCsr$2 = -36					; size = 4
_lpStartInstance$ = -32					; size = 4
_lpCurrentTask$ = -28					; size = 4
_lpEntityInstance$ = -24				; size = 4
_lpViewEntity$ = -20					; size = 4
_lpNewView$ = -16					; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_nStartLevel$ = -8					; size = 2
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcScopeEntity$ = 12					; size = 4
_cpcEntityName$ = 16					; size = 4
_DisplayObjectInstance@12 PROC

; 851  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 852  :    LPTASK            lpCurrentTask;
; 853  :    LPVIEWENTITY      lpViewEntity;
; 854  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 855  :    LPVIEWENTITYCSR   lpViewEntityCsrPosition;
; 856  :    LPENTITYINSTANCE  lpStartInstance;
; 857  :    LPENTITYINSTANCE  lpEntityInstance;
; 858  :    zVIEW             lpNewView;
; 859  :    LPVIEWOD          lpViewOD;
; 860  :    zSHORT            nStartLevel;
; 861  :    zSHORT            nRC;
; 862  : 
; 863  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 864  :    if ( (lpCurrentTask = fnOperationCall( iDisplayObjectInstance,
; 865  :                                           lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	401					; 00000191H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN5@DisplayObj

; 866  :    {
; 867  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DisplayObj
$LN5@DisplayObj:

; 868  :    }
; 869  : 
; 870  :    nRC = fnDeclareView( &lpNewView, lpCurrentTask, lpView, 0, 0 );

	push	0
	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpNewView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax

; 871  :    if ( nRC < 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN6@DisplayObj

; 872  :    {
; 873  :       fnOperationReturn( iDisplayObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	401					; 00000191H
	call	_fnOperationReturn
	add	esp, 8

; 874  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@DisplayObj
$LN6@DisplayObj:

; 875  :    }
; 876  : 
; 877  :    nRC = SetViewFromView( lpNewView, lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewView$[ebp]
	push	ecx
	call	_SetViewFromView@8
	mov	WORD PTR _nRC$[ebp], ax

; 878  :    if ( nRC < 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	SHORT $LN7@DisplayObj

; 879  :    {
; 880  :       DropView( lpNewView );

	mov	eax, DWORD PTR _lpNewView$[ebp]
	push	eax
	call	_DropView@4

; 881  :       fnOperationReturn( iDisplayObjectInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	401					; 00000191H
	call	_fnOperationReturn
	add	esp, 8

; 882  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@DisplayObj
$LN7@DisplayObj:

; 883  :    }
; 884  : 
; 885  :    // Validate that the (childmost) entity to be displayed exists.
; 886  :    if ( cpcEntityName && cpcEntityName[ 0 ] )

	cmp	DWORD PTR _cpcEntityName$[ebp], 0
	je	SHORT $LN8@DisplayObj
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN8@DisplayObj

; 887  :    {
; 888  :       if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 889  :                                               lpNewView,
; 890  :                                               cpcEntityName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN10@DisplayObj

; 891  :       {
; 892  :          cpcEntityName = 0;  // invalid entity passed in ... ignore

	mov	DWORD PTR _cpcEntityName$[ebp], 0
$LN10@DisplayObj:

; 893  :       }
; 894  :    }

	jmp	SHORT $LN9@DisplayObj
$LN8@DisplayObj:

; 895  :    else
; 896  :       cpcEntityName = 0;

	mov	DWORD PTR _cpcEntityName$[ebp], 0
$LN9@DisplayObj:

; 897  : 
; 898  :    // Validate that the scope entity exists.
; 899  :    if ( cpcScopeEntity && cpcScopeEntity[ 0 ] )

	cmp	DWORD PTR _cpcScopeEntity$[ebp], 0
	je	$LN11@DisplayObj
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcScopeEntity$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN11@DisplayObj

; 900  :    {
; 901  :       if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 902  :                                               lpNewView,
; 903  :                                               cpcScopeEntity, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _cpcScopeEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpNewView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN13@DisplayObj

; 904  :       {
; 905  :          DropView( lpNewView );

	mov	ecx, DWORD PTR _lpNewView$[ebp]
	push	ecx
	call	_DropView@4

; 906  :          fnOperationReturn( iDisplayObjectInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	401					; 00000191H
	call	_fnOperationReturn
	add	esp, 8

; 907  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DisplayObj
$LN13@DisplayObj:

; 908  :       }
; 909  : 
; 910  :       // If the cursor is not set, try resetting it.
; 911  :       if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR ||

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	je	SHORT $LN15@DisplayObj
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $LN14@DisplayObj
$LN15@DisplayObj:

; 912  :            lpViewEntityCsr->hEntityInstance == NULL_CSR )
; 913  :       {
; 914  :          fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 915  : 
; 916  :          // If it's STILL not set then there are no child entities so get out.
; 917  :          if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR ||

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	je	SHORT $LN17@DisplayObj
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	jne	SHORT $LN14@DisplayObj
$LN17@DisplayObj:

; 918  :               lpViewEntityCsr->hEntityInstance == NULL_CSR )
; 919  :          {
; 920  :             TraceLineS( "", "" );

	push	OFFSET $SG13742
	push	OFFSET $SG13743
	call	_TraceLineS@8

; 921  :             TraceLineS( "Object Instance is NULL for entity ", cpcScopeEntity );

	mov	edx, DWORD PTR _cpcScopeEntity$[ebp]
	push	edx
	push	OFFSET $SG13744
	call	_TraceLineS@8

; 922  :             DropView( lpNewView );

	mov	eax, DWORD PTR _lpNewView$[ebp]
	push	eax
	call	_DropView@4

; 923  :             fnOperationReturn( iDisplayObjectInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	401					; 00000191H
	call	_fnOperationReturn
	add	esp, 8

; 924  :             return( 0 );

	xor	eax, eax
	jmp	$LN1@DisplayObj
$LN14@DisplayObj:

; 925  :          }
; 926  :       }
; 927  : 
; 928  :       lpStartInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartInstance$[ebp], eax

; 929  :       nStartLevel = lpViewEntity->nLevel;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	dx, WORD PTR [ecx+215]
	mov	WORD PTR _nStartLevel$[ebp], dx

; 930  :    }

	jmp	SHORT $LN12@DisplayObj
$LN11@DisplayObj:

; 931  :    else
; 932  :    {
; 933  :       LPVIEWCSR lpViewCsr;
; 934  :       LPVIEWOI  lpViewOI;
; 935  : 
; 936  :    // ResetView( lpNewView );
; 937  :       ResetViewPositions( lpNewView );  // don't reset select states!

	mov	eax, DWORD PTR _lpNewView$[ebp]
	push	eax
	call	_ResetViewPositions@4

; 938  :       lpViewCsr = zGETPTR( lpNewView->hViewCsr );

	mov	ecx, DWORD PTR _lpNewView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 939  :       lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$2[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 940  :       nStartLevel = 0;

	xor	edx, edx
	mov	WORD PTR _nStartLevel$[ebp], dx

; 941  :       lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$2[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$1[ebp], eax

; 942  :       lpStartInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$1[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartInstance$[ebp], eax
$LN12@DisplayObj:

; 943  :    }
; 944  : 
; 945  :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 946  :    TraceLineS( "", "" );

	push	OFFSET $SG13745
	push	OFFSET $SG13746
	call	_TraceLineS@8

; 947  :    TraceLine( "Object Instance Display for View Id: 0x%08x  Def: %s",

	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG13747
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 948  :               lpView, lpViewOD->szName );
; 949  : 
; 950  :    for ( lpEntityInstance = lpStartInstance;

	mov	edx, DWORD PTR _lpStartInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], edx
	jmp	SHORT $LN4@DisplayObj
$LN2@DisplayObj:

; 952  :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN4@DisplayObj:

; 951  :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@DisplayObj

; 953  :    {
; 954  :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 955  :       if ( lpViewEntity->nLevel <= nStartLevel &&

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+215]
	movsx	eax, WORD PTR _nStartLevel$[ebp]
	cmp	edx, eax
	jg	SHORT $LN18@DisplayObj
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpStartInstance$[ebp]
	je	SHORT $LN18@DisplayObj

; 956  :            lpEntityInstance != lpStartInstance )
; 957  :       {
; 958  :          break;

	jmp	$LN3@DisplayObj
$LN18@DisplayObj:

; 959  :       }
; 960  : 
; 961  :       if ( lpEntityInstance->u.nInd.bHidden ||

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	jne	SHORT $LN20@DisplayObj
	cmp	DWORD PTR _cpcEntityName$[ebp], 0
	je	SHORT $LN19@DisplayObj
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	cmp	edx, ecx
	jne	SHORT $LN25@DisplayObj
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv217[ebp], eax
	jmp	SHORT $LN26@DisplayObj
$LN25@DisplayObj:
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN23@DisplayObj
	mov	DWORD PTR tv216[ebp], 1
	jmp	SHORT $LN24@DisplayObj
$LN23@DisplayObj:
	mov	DWORD PTR tv216[ebp], -1
$LN24@DisplayObj:
	mov	edx, DWORD PTR tv216[ebp]
	mov	DWORD PTR tv217[ebp], edx
$LN26@DisplayObj:
	cmp	DWORD PTR tv217[ebp], 0
	je	SHORT $LN19@DisplayObj
$LN20@DisplayObj:

; 962  :            (cpcEntityName && zstrcmp( cpcEntityName,
; 963  :                                       lpViewEntity->szName ) != 0) )
; 964  :       {
; 965  :          continue;

	jmp	$LN2@DisplayObj
$LN19@DisplayObj:

; 966  :       }
; 967  : 
; 968  :       lpViewEntityCsr = fnEstablishViewForInstance( lpNewView, 0,

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpNewView$[ebp]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 969  :                                                     lpEntityInstance );
; 970  : 
; 971  :       // Find entity at current position.
; 972  :       if ( fnValidViewEntity( &lpViewEntityCsrPosition, lpView,
; 973  :                               lpViewEntity->szName, 1 ) != 0 )

	push	1
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpViewEntityCsrPosition$[ebp]
	push	ecx
	call	_fnValidViewEntity@16
	test	eax, eax
	je	SHORT $LN21@DisplayObj

; 974  :       {
; 975  :          fnDisplayEntityInstance( lpNewView, lpViewEntityCsr,

	mov	edx, DWORD PTR _lpViewEntityCsrPosition$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nStartLevel$[ebp]
	sub	ecx, edx
	push	ecx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewView$[ebp]
	push	ecx
	call	_fnDisplayEntityInstance
	add	esp, 16					; 00000010H
$LN21@DisplayObj:

; 976  :                                   (zSHORT) (lpViewEntityCsr->nLevel - nStartLevel),
; 977  :                                   lpViewEntityCsrPosition );
; 978  :       }
; 979  :    }

	jmp	$LN2@DisplayObj
$LN3@DisplayObj:

; 980  : 
; 981  :    DropView( lpNewView );

	mov	edx, DWORD PTR _lpNewView$[ebp]
	push	edx
	call	_DropView@4

; 982  : 
; 983  :    fnOperationReturn( iDisplayObjectInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	401					; 00000191H
	call	_fnOperationReturn
	add	esp, 8

; 984  :    return( 0 );

	xor	eax, eax
$LN1@DisplayObj:

; 985  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_DisplayObjectInstance@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_nRC$ = -44						; size = 4
_lpViewEntity$1 = -40					; size = 4
_lpRootViewEntityCsr$2 = -36				; size = 4
_lpViewCsr$3 = -32					; size = 4
_lpViewEntity$ = -28					; size = 4
_lpCurrentTask$ = -24					; size = 4
_pchWorkEntityName$ = -20				; size = 4
_nLevel$ = -16						; size = 4
_lpEntityInstance$ = -12				; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_lpCurrentInstance$ = -4				; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_DisplayEntityInstancePath@8 PROC

; 758  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 759  :    LPTASK            lpCurrentTask;
; 760  :    LPVIEWENTITY      lpViewEntity;
; 761  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 762  :    LPENTITYINSTANCE  lpEntityInstance;
; 763  :    LPENTITYINSTANCE  lpCurrentInstance;
; 764  :    zPCHAR            pchWorkEntityName;
; 765  :    int               nRC, nLevel;
; 766  : 
; 767  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 768  :    if ( (lpCurrentTask = fnOperationCall( iDisplayEntityInstancePath,
; 769  :                                           lpView, zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	405					; 00000195H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN7@DisplayEnt

; 770  :    {
; 771  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DisplayEnt
$LN7@DisplayEnt:

; 772  :    }
; 773  : 
; 774  :    pchWorkEntityName = (zPCHAR) cpcEntityName;

	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	mov	DWORD PTR _pchWorkEntityName$[ebp], ecx

; 775  : 
; 776  :    if ( pchWorkEntityName == 0 || pchWorkEntityName[ 0 ] == 0 )

	cmp	DWORD PTR _pchWorkEntityName$[ebp], 0
	je	SHORT $LN9@DisplayEnt
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchWorkEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN8@DisplayEnt
$LN9@DisplayEnt:

; 777  :    {
; 778  :       LPVIEWCSR       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$3[ebp], eax

; 779  :       LPVIEWENTITYCSR lpRootViewEntityCsr =

	mov	edx, DWORD PTR _lpViewCsr$3[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$2[ebp], eax

; 780  :                                   zGETPTR( lpViewCsr->hRootViewEntityCsr );
; 781  :       LPVIEWENTITY    lpViewEntity =

	mov	ecx, DWORD PTR _lpRootViewEntityCsr$2[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 782  :                                   zGETPTR( lpRootViewEntityCsr->hViewEntity );
; 783  : 
; 784  :       pchWorkEntityName = lpViewEntity->szName;

	mov	eax, DWORD PTR _lpViewEntity$1[ebp]
	add	eax, 14					; 0000000eH
	mov	DWORD PTR _pchWorkEntityName$[ebp], eax
$LN8@DisplayEnt:

; 785  :    }
; 786  : 
; 787  :    // Validate that the entity exists
; 788  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr,
; 789  :                                            lpView, pchWorkEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _pchWorkEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN10@DisplayEnt

; 790  :    {
; 791  :       fnOperationReturn( iDisplayEntityInstancePath, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	405					; 00000195H
	call	_fnOperationReturn
	add	esp, 8

; 792  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DisplayEnt
$LN10@DisplayEnt:

; 793  :    }
; 794  : 
; 795  :    TraceLineS( "", "" );

	push	OFFSET $SG13680
	push	OFFSET $SG13681
	call	_TraceLineS@8

; 796  :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	SHORT $LN11@DisplayEnt

; 797  :       fnEstablishCursorForView( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnEstablishCursorForView
	add	esp, 4
$LN11@DisplayEnt:

; 798  : 
; 799  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 800  :    if ( lpEntityInstance == 0 || lpEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN13@DisplayEnt
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN12@DisplayEnt
$LN13@DisplayEnt:

; 801  :    {
; 802  :       TraceLineS( "    Cursor is NULL or Undefined for ",

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13685
	call	_TraceLineS@8

; 803  :                   lpViewEntity->szName );
; 804  :       fnOperationReturn( iDisplayEntityInstancePath, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	405					; 00000195H
	call	_fnOperationReturn
	add	esp, 8

; 805  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@DisplayEnt
$LN12@DisplayEnt:

; 806  :    }
; 807  : 
; 808  :    TraceLineS( "---- Begin Entity Instance Path Display ", "----" );

	push	OFFSET $SG13686
	push	OFFSET $SG13687
	call	_TraceLineS@8

; 809  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 810  :    nLevel = 1;

	mov	DWORD PTR _nLevel$[ebp], 1

; 811  :    CreateViewFromViewForTask( &lpView, lpView, 0 );

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12
$LN4@DisplayEnt:

; 812  :    do
; 813  :    {
; 814  :       lpCurrentInstance = lpEntityInstance;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR _lpCurrentInstance$[ebp], edx
$LN5@DisplayEnt:

; 815  :       while ( lpCurrentInstance->hParent &&

	mov	eax, DWORD PTR _lpCurrentInstance$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN6@DisplayEnt
	mov	ecx, DWORD PTR _lpCurrentInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, DWORD PTR _nLevel$[ebp]
	jle	SHORT $LN6@DisplayEnt

; 816  :               lpCurrentInstance->nLevel > nLevel )
; 817  :       {
; 818  :          lpCurrentInstance = zGETPTR( lpCurrentInstance->hParent );

	mov	eax, DWORD PTR _lpCurrentInstance$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentInstance$[ebp], eax

; 819  :       }

	jmp	SHORT $LN5@DisplayEnt
$LN6@DisplayEnt:

; 820  : 
; 821  :       nLevel = lpCurrentInstance->nLevel;

	mov	edx, DWORD PTR _lpCurrentInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	DWORD PTR _nLevel$[ebp], eax

; 822  :       lpViewEntityCsr = fnEstablishViewForInstance( lpView, 0,

	mov	ecx, DWORD PTR _lpCurrentInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 823  :                                                     lpCurrentInstance );
; 824  :       nRC = fnDisplayEntityInstance( lpView, lpViewEntityCsr, 0, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDisplayEntityInstance
	add	esp, 16					; 00000010H
	movsx	edx, ax
	mov	DWORD PTR _nRC$[ebp], edx

; 825  :       nLevel++;

	mov	eax, DWORD PTR _nLevel$[ebp]
	add	eax, 1
	mov	DWORD PTR _nLevel$[ebp], eax

; 826  :    }  while ( nLevel <= lpEntityInstance->nLevel );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	DWORD PTR _nLevel$[ebp], edx
	jle	SHORT $LN4@DisplayEnt

; 827  : 
; 828  :    TraceLineS( "---- End   Entity Instance Path Display ", "----" );

	push	OFFSET $SG13688
	push	OFFSET $SG13689
	call	_TraceLineS@8

; 829  :    DropView( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_DropView@4

; 830  : 
; 831  :    fnOperationReturn( iDisplayEntityInstancePath, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	405					; 00000195H
	call	_fnOperationReturn
	add	esp, 8

; 832  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DisplayEnt:

; 833  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DisplayEntityInstancePath@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_nRC$ = -36						; size = 4
_lpViewEntity$1 = -32					; size = 4
_lpRootViewEntityCsr$2 = -28				; size = 4
_lpViewCsr$3 = -24					; size = 4
_lpViewEntity$ = -20					; size = 4
_lpEntityInstance$ = -16				; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_pchWorkEntityName$ = -4				; size = 4
_lpView$ = 8						; size = 4
_cpcEntityName$ = 12					; size = 4
_DisplayEntityInstance@8 PROC

; 685  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 686  :    LPTASK            lpCurrentTask;
; 687  :    LPVIEWENTITY      lpViewEntity;
; 688  :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 689  :    LPENTITYINSTANCE  lpEntityInstance;
; 690  :    zPCHAR            pchWorkEntityName;
; 691  :    int               nRC;
; 692  : 
; 693  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 694  :    if ( (lpCurrentTask = fnOperationCall( iDisplayEntityInstance, lpView,
; 695  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	400					; 00000190H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@DisplayEnt

; 696  :    {
; 697  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DisplayEnt
$LN2@DisplayEnt:

; 698  :    }
; 699  : 
; 700  :    pchWorkEntityName = (zPCHAR) cpcEntityName;

	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	mov	DWORD PTR _pchWorkEntityName$[ebp], ecx

; 701  : 
; 702  :    if ( pchWorkEntityName == 0 || pchWorkEntityName[ 0 ] == 0 )

	cmp	DWORD PTR _pchWorkEntityName$[ebp], 0
	je	SHORT $LN4@DisplayEnt
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchWorkEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN3@DisplayEnt
$LN4@DisplayEnt:

; 703  :    {
; 704  :       LPVIEWCSR       lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$3[ebp], eax

; 705  :       LPVIEWENTITYCSR lpRootViewEntityCsr =

	mov	edx, DWORD PTR _lpViewCsr$3[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootViewEntityCsr$2[ebp], eax

; 706  :                                   zGETPTR( lpViewCsr->hRootViewEntityCsr );
; 707  :       LPVIEWENTITY    lpViewEntity =

	mov	ecx, DWORD PTR _lpRootViewEntityCsr$2[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 708  :                                   zGETPTR( lpRootViewEntityCsr->hViewEntity );
; 709  : 
; 710  :       pchWorkEntityName = lpViewEntity->szName;

	mov	eax, DWORD PTR _lpViewEntity$1[ebp]
	add	eax, 14					; 0000000eH
	mov	DWORD PTR _pchWorkEntityName$[ebp], eax
$LN3@DisplayEnt:

; 711  :    }
; 712  : 
; 713  :    // Validate that the entity exists
; 714  :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView,
; 715  :                                            pchWorkEntityName, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _pchWorkEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN5@DisplayEnt

; 716  :    {
; 717  :       fnOperationReturn( iDisplayEntityInstance, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	400					; 00000190H
	call	_fnOperationReturn
	add	esp, 8

; 718  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DisplayEnt
$LN5@DisplayEnt:

; 719  :    }
; 720  : 
; 721  :    TraceLineS( "", "" );

	push	OFFSET $SG13640
	push	OFFSET $SG13641
	call	_TraceLineS@8

; 722  :    TraceLine( "Entity Instance Display: %s  for view: 0x%08x",

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	OFFSET $SG13642
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 723  :                cpcEntityName, lpView );
; 724  :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN6@DisplayEnt

; 725  :       fnEstablishCursorForView( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN6@DisplayEnt:

; 726  : 
; 727  :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 728  :    if ( lpEntityInstance == 0 || lpEntityInstance->u.nInd.bHidden )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN8@DisplayEnt
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN7@DisplayEnt
$LN8@DisplayEnt:

; 729  :    {
; 730  :       TraceLineS( "    Cursor is NULL or Undefined for ",

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	push	OFFSET $SG13646
	call	_TraceLineS@8

; 731  :                   lpViewEntity->szName );
; 732  :       fnOperationReturn( iDisplayEntityInstance, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	400					; 00000190H
	call	_fnOperationReturn
	add	esp, 8

; 733  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@DisplayEnt
$LN7@DisplayEnt:

; 734  :    }
; 735  : 
; 736  :    nRC = fnDisplayEntityInstance( lpView, lpViewEntityCsr, 0, 0 );

	push	0
	push	0
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnDisplayEntityInstance
	add	esp, 16					; 00000010H
	movsx	edx, ax
	mov	DWORD PTR _nRC$[ebp], edx

; 737  : 
; 738  :    fnOperationReturn( iDisplayEntityInstance, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	400					; 00000190H
	call	_fnOperationReturn
	add	esp, 8

; 739  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DisplayEnt:

; 740  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DisplayEntityInstance@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_cpcMessage$ = 8					; size = 4
_pvBlob$ = 12						; size = 4
_lBlobLth$ = 16						; size = 4
_TraceBlob@12 PROC

; 662  : {

	push	ebp
	mov	ebp, esp

; 663  : 
; 664  :    TraceLineI( cpcMessage, lBlobLth );

	mov	eax, DWORD PTR _lBlobLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMessage$[ebp]
	push	ecx
	call	_TraceLineI@8

; 665  :    TraceHex( pvBlob, lBlobLth );

	mov	edx, DWORD PTR _lBlobLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvBlob$[ebp]
	push	eax
	call	_TraceHex@8

; 666  : }

	pop	ebp
	ret	12					; 0000000cH
_TraceBlob@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_szHex$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_Title$ = 8						; size = 4
_lValue$ = 12						; size = 4
_TraceLineX@8 PROC

; 268  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 269  :    zCHAR szHex[ 16 ];
; 270  : 
; 271  :    szHex[ 0 ] = '0';

	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _szHex$[ebp+ecx], 48		; 00000030H

; 272  :    szHex[ 1 ] = 'x';

	mov	edx, 1
	shl	edx, 0
	mov	BYTE PTR _szHex$[ebp+edx], 120		; 00000078H

; 273  :    zltox( lValue, szHex + 2 );

	push	16					; 00000010H
	lea	eax, DWORD PTR _szHex$[ebp+2]
	push	eax
	mov	ecx, DWORD PTR _lValue$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 274  :    TraceLineS( Title, szHex );

	lea	edx, DWORD PTR _szHex$[ebp]
	push	edx
	mov	eax, DWORD PTR _Title$[ebp]
	push	eax
	call	_TraceLineS@8

; 275  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TraceLineX@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_szLong$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
_Title$ = 8						; size = 4
_lValue$ = 12						; size = 4
_TraceLineI@8 PROC

; 249  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 250  :    zCHAR szLong[ 32 ];
; 251  : 
; 252  :    zltoa( lValue, szLong );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _szLong$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lValue$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 253  :    TraceLineS( Title, szLong );

	lea	edx, DWORD PTR _szLong$[ebp]
	push	edx
	mov	eax, DWORD PTR _Title$[ebp]
	push	eax
	call	_TraceLineS@8

; 254  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TraceLineI@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoetraa.c
_TEXT	SEGMENT
_lTime$ = -304						; size = 4
$T1 = -300						; size = 4
$T2 = -296						; size = 4
$T3 = -292						; size = 4
tv69 = -288						; size = 4
_lInternal$ = -284					; size = 4
_lExternal$ = -280					; size = 4
_lplCount2$ = -276					; size = 4
_lpTask$ = -272						; size = 4
_nIdx$ = -268						; size = 2
_lplCount1$ = -264					; size = 4
_szMessage$ = -260					; size = 256
__$ArrayPad$ = -4					; size = 4
_vTaskView$ = 8						; size = 4
_nOpt$ = 12						; size = 2
_OperationCount@8 PROC

; 107  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 108  :    LPTASK   lpTask;
; 109  :    zCHAR    szMessage[ 256 ];
; 110  :    zPLONG   lplCount1;
; 111  :    zPLONG   lplCount2;
; 112  :    zLONG    lExternal, lInternal, lTime;
; 113  :    zSHORT   nIdx;
; 114  : 
; 115  :    lpTask = zGETPTR( vTaskView->hTask );

	mov	eax, DWORD PTR _vTaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 116  :    if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN10@OperationC

; 117  :       return;

	jmp	$LN24@OperationC
$LN10@OperationC:

; 118  : 
; 119  :    switch ( nOpt )

	movsx	edx, WORD PTR _nOpt$[ebp]
	mov	DWORD PTR tv69[ebp], edx
	cmp	DWORD PTR tv69[ebp], 11			; 0000000bH
	ja	$LN24@OperationC
	mov	eax, DWORD PTR tv69[ebp]
	movzx	ecx, BYTE PTR $LN31@OperationC[eax]
	jmp	DWORD PTR $LN32@OperationC[ecx*4]
$LN11@OperationC:

; 120  :    {
; 121  :       case 0:   // Display existing counts
; 122  :          lExternal = 0;

	mov	DWORD PTR _lExternal$[ebp], 0

; 123  :          lInternal = 0;

	mov	DWORD PTR _lInternal$[ebp], 0

; 124  :          lpTask->bTrace = TRUE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	or	eax, 4
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 125  :          TraceLineS( "Operation Counts:", "" );

	push	OFFSET $SG13402
	push	OFFSET $SG13403
	call	_TraceLineS@8

; 126  :          if ( lpTask->hCountBuf )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+146], 0
	je	$LN12@OperationC

; 127  :          {
; 128  :             lplCount1 = (zPLONG) zGETPTR( lpTask->hCountBuf );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+146]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lplCount1$[ebp], eax

; 129  :             lplCount2 = lplCount1 + 1;

	mov	edx, DWORD PTR _lplCount1$[ebp]
	add	edx, 4
	mov	DWORD PTR _lplCount2$[ebp], edx

; 130  :             SysGetDateTime( szMessage );

	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_SysGetDateTime@4

; 131  :             szMessage[ 16 ] = 0;

	mov	ecx, 1
	shl	ecx, 4
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 256			; 00000100H
	jae	SHORT $LN25@OperationC
	jmp	SHORT $LN26@OperationC
$LN25@OperationC:
	call	___report_rangecheckfailure
$LN26@OperationC:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szMessage$[ebp+edx], 0

; 132  :             *lplCount2 = zatol( szMessage + 8 ) + 100000000;

	lea	eax, DWORD PTR _szMessage$[ebp+8]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	add	eax, 100000000				; 05f5e100H
	mov	ecx, DWORD PTR _lplCount2$[ebp]
	mov	DWORD PTR [ecx], eax

; 133  :             lTime = *lplCount2 - *lplCount1;

	mov	edx, DWORD PTR _lplCount2$[ebp]
	mov	eax, DWORD PTR _lplCount1$[ebp]
	mov	ecx, DWORD PTR [edx]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lTime$[ebp], ecx

; 134  :             zstrcpy( szMessage, "   " );

	push	OFFSET $SG13406
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 135  :             for ( nIdx = 1 ; nIdx < 450 ; nIdx++ )

	mov	eax, 1
	mov	WORD PTR _nIdx$[ebp], ax
	jmp	SHORT $LN6@OperationC
$LN4@OperationC:
	mov	cx, WORD PTR _nIdx$[ebp]
	add	cx, 1
	mov	WORD PTR _nIdx$[ebp], cx
$LN6@OperationC:
	movsx	edx, WORD PTR _nIdx$[ebp]
	cmp	edx, 450				; 000001c2H
	jge	$LN5@OperationC

; 136  :             {
; 137  :                lplCount1 += 2;

	mov	eax, DWORD PTR _lplCount1$[ebp]
	add	eax, 8
	mov	DWORD PTR _lplCount1$[ebp], eax

; 138  :                lplCount2 = lplCount1 + 1;

	mov	ecx, DWORD PTR _lplCount1$[ebp]
	add	ecx, 4
	mov	DWORD PTR _lplCount2$[ebp], ecx

; 139  :                if ( *lplCount1 || *lplCount2 )

	mov	edx, DWORD PTR _lplCount1$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN15@OperationC
	mov	eax, DWORD PTR _lplCount2$[ebp]
	cmp	DWORD PTR [eax], 0
	je	$LN14@OperationC
$LN15@OperationC:

; 140  :                {
; 141  :                   lExternal += *lplCount1;

	mov	ecx, DWORD PTR _lplCount1$[ebp]
	mov	edx, DWORD PTR _lExternal$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lExternal$[ebp], edx

; 142  :                   lInternal += *lplCount2;

	mov	eax, DWORD PTR _lplCount2$[ebp]
	mov	ecx, DWORD PTR _lInternal$[ebp]
	add	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lInternal$[ebp], ecx

; 143  :                   szMessage[ 3 ] = 0;

	mov	edx, 1
	imul	eax, edx, 3
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 256			; 00000100H
	jae	SHORT $LN27@OperationC
	jmp	SHORT $LN28@OperationC
$LN27@OperationC:
	call	___report_rangecheckfailure
$LN28@OperationC:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szMessage$[ebp+ecx], 0

; 144  :                   SysGetOperationMessage( &szMessage[ 3 ],

	push	40					; 00000028H
	movsx	edx, WORD PTR _nIdx$[ebp]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 3
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	call	_SysGetOperationMessage@12

; 145  :                                   nIdx, 40 );
; 146  :                   if ( szMessage[ 3 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 3
	movsx	edx, BYTE PTR _szMessage$[ebp+ecx]
	test	edx, edx
	jne	SHORT $LN16@OperationC

; 147  :                   {
; 148  :                      szMessage[ 3 ] = '(';

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _szMessage$[ebp+ecx], 40	; 00000028H

; 149  :                      zltoa( nIdx, &szMessage[ 4 ] );

	push	10					; 0000000aH
	mov	edx, 1
	shl	edx, 2
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	movsx	ecx, WORD PTR _nIdx$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 150  :                      zstrcat( szMessage, ")" );

	push	OFFSET $SG13410
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8
$LN16@OperationC:

; 151  :                   }
; 152  : 
; 153  :                   zstrcat( szMessage, ", External calls (" );

	push	OFFSET $SG13411
	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 154  :                   zltoa( *lplCount1, &szMessage[ 200 ] );

	push	10					; 0000000aH
	mov	ecx, 1
	imul	edx, ecx, 200
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	mov	ecx, DWORD PTR _lplCount1$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 155  :                   zstrcat( szMessage, &szMessage[ 200 ] );

	mov	eax, 1
	imul	ecx, eax, 200
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 156  :                   zstrcat( szMessage, "), Internal calls (" );

	push	OFFSET $SG13412
	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 157  :                   zltoa( *lplCount2, &szMessage[ 200 ] );

	push	10					; 0000000aH
	mov	edx, 1
	imul	eax, edx, 200
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _lplCount2$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 158  :                   zstrcat( szMessage, &szMessage[ 200 ] );

	mov	ecx, 1
	imul	edx, ecx, 200
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 159  :                   zstrcat( szMessage, ")" );

	push	OFFSET $SG13413
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 160  :                   TraceLineS( szMessage, "" );

	push	OFFSET $SG13414
	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_TraceLineS@8
$LN14@OperationC:

; 161  :                }
; 162  :             }

	jmp	$LN4@OperationC
$LN5@OperationC:

; 163  : 
; 164  :             TraceLineI( "   Total external calls: ", lExternal );

	mov	ecx, DWORD PTR _lExternal$[ebp]
	push	ecx
	push	OFFSET $SG13415
	call	_TraceLineI@8

; 165  :             TraceLineI( "   Total internal calls: ", lInternal );

	mov	edx, DWORD PTR _lInternal$[ebp]
	push	edx
	push	OFFSET $SG13416
	call	_TraceLineI@8

; 166  :             lplCount1 = (zPLONG) zGETPTR( lpTask->hCountBuf );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+146]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lplCount1$[ebp], eax

; 167  :             lplCount2 = lplCount1 + 1;

	mov	edx, DWORD PTR _lplCount1$[ebp]
	add	edx, 4
	mov	DWORD PTR _lplCount2$[ebp], edx

; 168  :             zltoa( *lplCount1, &szMessage[ 199 ] );

	push	10					; 0000000aH
	mov	eax, 1
	imul	ecx, eax, 199
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	mov	eax, DWORD PTR _lplCount1$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 169  :             zstrncpy( szMessage, &szMessage[ 200 ], 2 );

	push	2
	mov	edx, 1
	imul	eax, edx, 200
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	lea	edx, DWORD PTR _szMessage$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 170  :             zstrcpy( &szMessage[ 2 ], ":" );

	push	OFFSET $SG13417
	mov	eax, 1
	shl	eax, 1
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 171  :             zstrncpy( &szMessage[ 3 ], &szMessage[ 202 ], 2 );

	push	2
	mov	edx, 1
	imul	eax, edx, 202
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 3
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 172  :             zstrcpy( &szMessage[ 5 ], ":" );

	push	OFFSET $SG13418
	mov	edx, 1
	imul	eax, edx, 5
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	call	_strcpy
	add	esp, 8

; 173  :             zstrncpy( &szMessage[ 6 ], &szMessage[ 204 ], 2 );

	push	2
	mov	edx, 1
	imul	eax, edx, 204
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	mov	edx, 1
	imul	eax, edx, 6
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 174  :             zstrcpy( &szMessage[ 8 ], "." );

	push	OFFSET $SG13419
	mov	edx, 1
	shl	edx, 3
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8

; 175  :             zstrcpy( &szMessage[ 9 ], &szMessage[ 206 ] );

	mov	ecx, 1
	imul	edx, ecx, 206
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 9
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8

; 176  :             TraceLineS( "   Start time: ", szMessage );

	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	push	OFFSET $SG13420
	call	_TraceLineS@8

; 177  :             zltoa( *lplCount2, &szMessage[ 199 ] );

	push	10					; 0000000aH
	mov	edx, 1
	imul	eax, edx, 199
	lea	ecx, DWORD PTR _szMessage$[ebp+eax]
	push	ecx
	mov	edx, DWORD PTR _lplCount2$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 178  :             zstrncpy( szMessage, &szMessage[ 200 ], 2 );

	push	2
	mov	ecx, 1
	imul	edx, ecx, 200
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	lea	ecx, DWORD PTR _szMessage$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 179  :             zstrcpy( &szMessage[ 2 ], ":" );

	push	OFFSET $SG13421
	mov	edx, 1
	shl	edx, 1
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8

; 180  :             zstrncpy( &szMessage[ 3 ], &szMessage[ 202 ], 2 );

	push	2
	mov	ecx, 1
	imul	edx, ecx, 202
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 3
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 181  :             zstrcpy( &szMessage[ 5 ], ":" );

	push	OFFSET $SG13422
	mov	ecx, 1
	imul	edx, ecx, 5
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	_strcpy
	add	esp, 8

; 182  :             zstrncpy( &szMessage[ 6 ], &szMessage[ 204 ], 2 );

	push	2
	mov	ecx, 1
	imul	edx, ecx, 204
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 6
	lea	eax, DWORD PTR _szMessage$[ebp+edx]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 183  :             zstrcpy( &szMessage[ 8 ], "." );

	push	OFFSET $SG13423
	mov	ecx, 1
	shl	ecx, 3
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 184  :             zstrcpy( &szMessage[ 9 ], &szMessage[ 206 ] );

	mov	eax, 1
	imul	ecx, eax, 206
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	mov	eax, 1
	imul	ecx, eax, 9
	lea	edx, DWORD PTR _szMessage$[ebp+ecx]
	push	edx
	call	_strcpy
	add	esp, 8

; 185  :             TraceLineS( "   Stop  time: ", szMessage );

	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	push	OFFSET $SG13424
	call	_TraceLineS@8

; 186  :          }

	jmp	SHORT $LN13@OperationC
$LN12@OperationC:

; 187  :          else
; 188  :             TraceLineS( "   ERROR counting not active", "!!!" );

	push	OFFSET $SG13425
	push	OFFSET $SG13426
	call	_TraceLineS@8
$LN13@OperationC:

; 189  : 
; 190  :          break;

	jmp	$LN24@OperationC
$LN17@OperationC:

; 191  : 
; 192  :       case 1:    // Start counting
; 193  :       case 11:   // Start counting, disable trace
; 194  :          lpTask->bCount = TRUE;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 195  :          if ( nOpt == 11 )

	movsx	ecx, WORD PTR _nOpt$[ebp]
	cmp	ecx, 11					; 0000000bH
	jne	SHORT $LN18@OperationC

; 196  :             lpTask->bTrace = FALSE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -5					; fffffffbH
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax
$LN18@OperationC:

; 197  : 
; 198  :          if ( lpTask->hCountBuf == 0 )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+146], 0
	jne	SHORT $LN19@OperationC

; 199  :          {
; 200  :             lpTask->hCountBuf = (zPCHAR) fnAllocDataspace( lpTask->hFirstDataHeader,

	push	10046					; 0000273eH
	push	0
	push	1
	push	4000					; 00000fa0H
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [edx+146], eax
$LN19@OperationC:

; 201  :                                                            4000, 1, 0, iCountBuf );
; 202  :          }
; 203  : 
; 204  :          if ( lpTask->hCountBuf )

	mov	eax, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [eax+146], 0
	je	SHORT $LN20@OperationC

; 205  :          {
; 206  :             lplCount1 = (zPLONG) zGETPTR( lpTask->hCountBuf );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+146]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lplCount1$[ebp], eax

; 207  :             SysGetDateTime( szMessage );

	lea	eax, DWORD PTR _szMessage$[ebp]
	push	eax
	call	_SysGetDateTime@4

; 208  :             szMessage[ 16 ] = 0;

	mov	ecx, 1
	shl	ecx, 4
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN29@OperationC
	jmp	SHORT $LN30@OperationC
$LN29@OperationC:
	call	___report_rangecheckfailure
$LN30@OperationC:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szMessage$[ebp+edx], 0

; 209  :             *lplCount1 = zatol( szMessage + 8 ) + 100000000;

	lea	eax, DWORD PTR _szMessage$[ebp+8]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	add	eax, 100000000				; 05f5e100H
	mov	ecx, DWORD PTR _lplCount1$[ebp]
	mov	DWORD PTR [ecx], eax
$LN20@OperationC:

; 210  :          }
; 211  : 
; 212  :          break;

	jmp	$LN24@OperationC
$LN21@OperationC:

; 213  : 
; 214  :       case 2:   // Stop  counting
; 215  :          lpTask->bCount = FALSE;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	and	eax, -17				; ffffffefH
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [ecx+443], eax

; 216  :          break;

	jmp	$LN24@OperationC
$LN22@OperationC:

; 217  : 
; 218  :       case 3:   // Clear count buffer
; 219  :          if ( lpTask->hCountBuf )

	mov	edx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [edx+146], 0
	je	SHORT $LN24@OperationC

; 220  :          {
; 221  :             lplCount1 = (zPLONG) zGETPTR( lpTask->hCountBuf );

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+146]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lplCount1$[ebp], eax

; 222  :             for ( nIdx = 0 ; nIdx < 450 ; nIdx++ )

	xor	edx, edx
	mov	WORD PTR _nIdx$[ebp], dx
	jmp	SHORT $LN9@OperationC
$LN7@OperationC:
	mov	ax, WORD PTR _nIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nIdx$[ebp], ax
$LN9@OperationC:
	movsx	ecx, WORD PTR _nIdx$[ebp]
	cmp	ecx, 450				; 000001c2H
	jge	SHORT $LN24@OperationC

; 223  :             {
; 224  :                *lplCount1 = 0;

	mov	edx, DWORD PTR _lplCount1$[ebp]
	mov	DWORD PTR [edx], 0

; 225  :                lplCount1++;

	mov	eax, DWORD PTR _lplCount1$[ebp]
	add	eax, 4
	mov	DWORD PTR _lplCount1$[ebp], eax

; 226  :                *lplCount1 = 0;

	mov	ecx, DWORD PTR _lplCount1$[ebp]
	mov	DWORD PTR [ecx], 0

; 227  :                lplCount1++;

	mov	edx, DWORD PTR _lplCount1$[ebp]
	add	edx, 4
	mov	DWORD PTR _lplCount1$[ebp], edx

; 228  :             }

	jmp	SHORT $LN7@OperationC
$LN24@OperationC:

; 229  :          }
; 230  : 
; 231  :          break;
; 232  :    }
; 233  : 
; 234  :    return;
; 235  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN32@OperationC:
	DD	$LN11@OperationC
	DD	$LN17@OperationC
	DD	$LN21@OperationC
	DD	$LN22@OperationC
	DD	$LN24@OperationC
$LN31@OperationC:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
_OperationCount@8 ENDP
_TEXT	ENDS
END
