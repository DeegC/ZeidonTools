; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEUFAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_usDayTable
PUBLIC	_usLeapDayTable
PUBLIC	_g_pProbeArea
PUBLIC	_Encrypt1
PUBLIC	_Encrypt2
PUBLIC	_EncryptNonAlpha
_BSS	SEGMENT
_g_pProbeArea DD 01H DUP (?)
$SG14955 DB	01H DUP (?)
	ALIGN	4

$SG14957 DB	01H DUP (?)
	ALIGN	4

$SG14962 DB	01H DUP (?)
	ALIGN	4

$SG14964 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG14383 DB	'Invalid parameter', 00H
	ORG $+2
$SG14384 DB	'Zeidon Error', 00H
	ORG $+3
$SG13440 DB	'AM', 00H
	ORG $+1
$SG13441 DB	'PM', 00H
	ORG $+1
$SG13445 DB	'ddd', 00H
$SG13448 DB	'DDD', 00H
$SG13451 DB	'dd', 00H
	ORG $+1
$SG13454 DB	'DD', 00H
	ORG $+1
$SG13462 DB	'ddd', 00H
$SG13465 DB	'dd', 00H
	ORG $+1
$SG13491 DB	'jj', 00H
	ORG $+1
$SG13498 DB	'mmm', 00H
$SG13501 DB	'MMM', 00H
$SG13504 DB	'mm', 00H
	ORG $+1
$SG14530 DB	'ddd', 00H
$SG13507 DB	'MM', 00H
	ORG $+1
$SG14534 DB	'dd', 00H
	ORG $+1
$SG13515 DB	'mmm', 00H
$SG13518 DB	'mm', 00H
	ORG $+1
$SG14543 DB	'jj', 00H
	ORG $+1
$SG14549 DB	'mmm', 00H
$SG14553 DB	'mm', 00H
	ORG $+1
$SG13538 DB	'Missing ending delimiter', 00H
	ORG $+3
$SG13539 DB	'Zeidon Error', 00H
	ORG $+3
$SG14591 DB	'ZeidonStringCopy: Invalid parameter.', 00H
	ORG $+3
$SG14593 DB	'ZeidonStringCopy: Target string has negative length', 00H
$SG14596 DB	'ZeidonStringCopy: Target string is too small', 00H
	ORG $+3
$SG14598 DB	'ZeidonStringCopy: Invalid parameter (source index).', 00H
$SG14625 DB	'ZeidonStringConcat: Invalid parameter.', 00H
	ORG $+1
$SG14627 DB	'ZeidonStringConcat: Target string has negative length.', 00H
	ORG $+1
$SG14629 DB	'ZeidonStringConcat: Source string has negative length.', 00H
	ORG $+1
$SG13606 DB	'AM', 00H
	ORG $+1
$SG14631 DB	'ZeidonStringConcat: Target string is too small.', 00H
$SG13611 DB	'PM', 00H
	ORG $+1
$SG13617 DB	'DD', 00H
	ORG $+1
$SG14655 DB	'ZeidonStringCompare: Invalid parameter.', 00H
$SG14657 DB	'ZeidonStringCompare: Target string has negative length.', 00H
$SG14659 DB	'ZeidonStringCompare: Source string has negative length.', 00H
$SG14661 DB	'ZeidonStringCompare: Target string is too short.', 00H
	ORG $+3
$SG13642 DB	'jj', 00H
	ORG $+1
$SG13652 DB	'mm', 00H
	ORG $+1
$SG14697 DB	'ZeidonStringConvertFromNumber: Target string has negativ'
	DB	'e length.', 00H
	ORG $+2
$SG14701 DB	'ZeidonStringConvertFromNumber: Invalid parameter.', 00H
	ORG $+2
$SG14719 DB	'ZeidonStringCopy: Invalid parameter.', 00H
	ORG $+3
$SG14721 DB	'ZeidonStringCopy: Target string is too small', 00H
	ORG $+3
_cMonth_Val DB	06H
	DB	02H
	DB	02H
	DB	05H
	DB	00H
	DB	03H
	DB	05H
	DB	01H
	DB	04H
	DB	06H
	DB	02H
	DB	04H
_usDayTable DW	00H
	DW	01fH
	DW	03bH
	DW	05aH
	DW	078H
	DW	097H
	DW	0b5H
	DW	0d4H
	DW	0f3H
	DW	0111H
	DW	0130H
	DW	014eH
_usLeapDayTable DW 00H
	DW	01fH
	DW	03cH
	DW	05bH
	DW	079H
	DW	098H
	DW	0b6H
	DW	0d5H
	DW	0f4H
	DW	0112H
	DW	0131H
	DW	014fH
$SG14822 DB	'aeiou', 00H
	ORG $+2
$SG14823 DB	'_', 00H
	ORG $+2
$SG14826 DB	'aeiou', 00H
	ORG $+2
$SG14828 DB	'*', 00H
	ORG $+2
$SG14829 DB	'bcdfghjklmnpqrstvwxyz', 00H
	ORG $+2
$SG14883 DB	'UfZProbeOn: No more probes available for: ', 00H
	ORG $+1
$SG14888 DB	'UfZProbeOn: Invalid probe descriptor for probe: ', 00H
	ORG $+3
$SG14889 DB	'UfZProbeOn: Invalid probe descriptor   (input): ', 00H
	ORG $+3
$SG14890 DB	'UfZProbeOn: Invalid probe descriptor (current): ', 00H
	ORG $+3
$SG14905 DB	'UfZProbeOff: Invalid probe number: ', 00H
$SG14906 DB	'UfZProbeOff:           descriptor: ', 00H
$SG14909 DB	'UfZProbeOff: Probe not on for number: ', 00H
	ORG $+1
$SG14910 DB	'UfZProbeOff:              descriptor: ', 00H
	ORG $+1
$SG14934 DB	'UfZProbeOffByDesc: Probe not on for descriptor: ', 00H
	ORG $+3
$SG14954 DB	'======= Probe Trace - %30s ===START===', 00H
	ORG $+1
$SG14956 DB	'zp.ALL. -- elapsed for Init to Trace->:%8.3f seconds', 00H
	ORG $+3
$SG14960 DB	'zp.%03d. %30s:%8.3f secs. (avg.%8.3f for %8d times)', 00H
_Encrypt1 DB	016H
	DB	05H
	DB	0dH
	DB	010H
	DB	0fH
	DB	00H
	DB	06H
	DB	017H
	DB	02H
	DB	013H
	DB	0cH
	DB	09H
	DB	0aH
	DB	01H
	DB	019H
	DB	04H
	DB	011H
	DB	07H
	DB	012H
	DB	0bH
	DB	015H
	DB	0eH
	DB	018H
	DB	014H
	DB	03H
	DB	08H
	ORG $+2
$SG14961 DB	'zp.%03d. %30s:%8.3f secs. (avg.%8.3f for %8d times OFF, '
	DB	'but ON is %d times)', 00H
$SG14963 DB	'======= Probe Trace - %30s === END ===', 00H
	ORG $+1
_Encrypt2 DB	0aH
	DB	011H
	DB	04H
	DB	016H
	DB	01H
	DB	06H
	DB	014H
	DB	0dH
	DB	0cH
	DB	013H
	DB	05H
	DB	018H
	DB	08H
	DB	0fH
	DB	07H
	DB	017H
	DB	02H
	DB	0bH
	DB	015H
	DB	09H
	DB	0eH
	DB	00H
	DB	019H
	DB	03H
	DB	010H
	DB	012H
	ORG $+2
_EncryptNonAlpha DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	022H
	DB	040H
	DB	025H
	DB	034H
	DB	026H
	DB	024H
	DB	027H
	DB	033H
	DB	05bH
	DB	028H
	DB	03aH
	DB	035H
	DB	02bH
	DB	021H
	DB	023H
	DB	03fH
	DB	07cH
	DB	02eH
	DB	02fH
	DB	060H
	DB	036H
	DB	02cH
	DB	037H
	DB	02dH
	DB	039H
	DB	038H
	DB	02aH
	DB	031H
	DB	03bH
	DB	03eH
	DB	03cH
	DB	029H
	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07dH
	DB	03dH
	DB	032H
	DB	07bH
	DB	05cH
	DB	05dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	05eH
	DB	05fH
	DB	07eH
	DB	030H
	ORG $+1
$SG14203 DB	'Error decrypting string', 00H
$SG14204 DB	'Zeidon Internal Error', 00H
	ORG $+2
$SG14253 DB	'00010101', 00H
	ORG $+3
$SG14258 DB	'Year less than 1', 00H
	ORG $+3
$SG14259 DB	'Zeidon Error', 00H
	ORG $+3
$SG14261 DB	'Year greater than 9999', 00H
	ORG $+1
$SG14262 DB	'Zeidon Error', 00H
	ORG $+3
$SG14271 DB	'Year less than 1', 00H
	ORG $+3
$SG14272 DB	'Zeidon Error', 00H
	ORG $+3
$SG14276 DB	'Year greater than 9999', 00H
	ORG $+1
$SG14277 DB	'Zeidon Error', 00H
	ORG $+3
$SG14288 DB	'Invalid parameter', 00H
	ORG $+2
$SG14289 DB	'Zeidon Error', 00H
	ORG $+3
$SG14297 DB	'Year less than 1', 00H
	ORG $+3
$SG14298 DB	'Zeidon Error', 00H
	ORG $+3
$SG14301 DB	'Year less than 1', 00H
	ORG $+3
$SG14302 DB	'Zeidon Error', 00H
	ORG $+3
$SG14305 DB	'Integer overflow', 00H
	ORG $+3
$SG14306 DB	'Zeidon Error', 00H
_DATA	ENDS
PUBLIC	_UfFormatDateTime@12
PUBLIC	_UfEditFormatDateTime@8
PUBLIC	_UfEditFormatString@8
PUBLIC	_UfFormatString@8
PUBLIC	_UfEncryptString@12
PUBLIC	_UfDecryptString@12
PUBLIC	_UfCompressName@32
PUBLIC	_UfZProbeEnable@4
PUBLIC	_UfZProbeInit@0
PUBLIC	_UfZProbeOn@12
PUBLIC	_UfZProbeOff@8
PUBLIC	_UfZProbeOnByDesc@8
PUBLIC	_UfZProbeOffByDesc@4
PUBLIC	_UfZProbeTrace@4
PUBLIC	_ZeidonStringCopy@28
PUBLIC	_ZeidonStringConcat@28
PUBLIC	_ZeidonStringCompare@28
PUBLIC	_ZeidonCopyWithinString@16
PUBLIC	_ZeidonStringFind@12
PUBLIC	_ZeidonStringConvertFromNumber@64
PUBLIC	_UfDateTimeToString@12
PUBLIC	_UfStringToDateTime@8
PUBLIC	_UfCompareDateTimeToDateTime@8
PUBLIC	_UfAddToDateTime@12
PUBLIC	_UfDateTimeDiff@16
PUBLIC	_UfJulianToGregorian@8
PUBLIC	_UfGetDayOfWeek@4
PUBLIC	_UfGetDayOfYear@4
PUBLIC	_UfGetWeekOfYear@4
PUBLIC	_fnDetermineDateTimeStrlen
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_zltoal
PUBLIC	_fnValidateDay
PUBLIC	_fnGetDateTimeComponent
PUBLIC	_fnSetDateTimeComponent
PUBLIC	_fnRemoveChars@24
PUBLIC	__real@408f400000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__strstr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp___strnicmp:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp___strrev:PROC
EXTRN	_labs:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_SysGetTickCount@0:PROC
EXTRN	_SysMalloc@4:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_ConvertDecimalToString@52:PROC
EXTRN	_fnCompareDateTimeToDateTime:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__isalpha:PROC
EXTRN	__imp__isupper:PROC
EXTRN	__imp__islower:PROC
EXTRN	__imp__isdigit:PROC
EXTRN	__imp__isxdigit:PROC
EXTRN	__imp__isspace:PROC
EXTRN	__imp__isalnum:PROC
EXTRN	__imp__toupper:PROC
EXTRN	__imp__tolower:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_lNullInteger:DWORD
EXTRN	_stNullDateTime:FWORD
EXTRN	_szlOE_SystemError:DWORD
EXTRN	_g_pchMon:BYTE
EXTRN	_g_pchDOW:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv77 = -16						; size = 4
_pch$ = -12						; size = 4
_pch2$ = -8						; size = 4
_nLth$ = -4						; size = 2
_pchStr$ = 8						; size = 4
_nShortNameLth$ = 12					; size = 2
_cQualifier$ = 16					; size = 1
_pchRemoveChars$ = 20					; size = 4
_pchPrevChars$ = 24					; size = 4
_cReplace$ = 28						; size = 1
_fnRemoveChars@24 PROC

; 4229 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 4230 :    zSHORT nLth;
; 4231 :    zPCHAR pch;
; 4232 :    zPCHAR pch2;
; 4233 : 
; 4234 :    if ( pchStr == 0 || pchStr[ 0 ] == 0 )

	cmp	DWORD PTR _pchStr$[ebp], 0
	je	SHORT $LN11@fnRemoveCh
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchStr$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN10@fnRemoveCh
$LN11@fnRemoveCh:

; 4235 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnRemoveCh
$LN10@fnRemoveCh:

; 4236 : 
; 4237 :    if ( cQualifier == 0 )

	movsx	ecx, BYTE PTR _cQualifier$[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@fnRemoveCh

; 4238 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnRemoveCh
$LN12@fnRemoveCh:

; 4239 : 
; 4240 :    if ( pchRemoveChars == 0 || pchRemoveChars[ 0 ] == 0 )

	cmp	DWORD PTR _pchRemoveChars$[ebp], 0
	je	SHORT $LN14@fnRemoveCh
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchRemoveChars$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN13@fnRemoveCh
$LN14@fnRemoveCh:

; 4241 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnRemoveCh
$LN13@fnRemoveCh:

; 4242 : 
; 4243 :    switch ( cQualifier )

	mov	al, BYTE PTR _cQualifier$[ebp]
	mov	BYTE PTR tv77[ebp], al
	cmp	BYTE PTR tv77[ebp], 66			; 00000042H
	je	SHORT $LN16@fnRemoveCh
	cmp	BYTE PTR tv77[ebp], 70			; 00000046H
	je	SHORT $LN17@fnRemoveCh
	jmp	SHORT $LN2@fnRemoveCh

; 4244 :    {
; 4245 :       case 'A':
; 4246 :          break;

	jmp	SHORT $LN2@fnRemoveCh
$LN16@fnRemoveCh:

; 4247 : 
; 4248 :       case 'B':
; 4249 :          // Remove starting from back, so reverse string.
; 4250 :          zstrrev( pchStr );

	mov	ecx, DWORD PTR _pchStr$[ebp]
	push	ecx
	call	DWORD PTR __imp___strrev
	add	esp, 4

; 4251 :          nLth = zstrlen( pchStr );

	mov	edx, DWORD PTR _pchStr$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax

; 4252 :          break;

	jmp	SHORT $LN2@fnRemoveCh
$LN17@fnRemoveCh:

; 4253 : 
; 4254 :       case 'F':
; 4255 :          nLth = zstrlen( pchStr );

	mov	eax, DWORD PTR _pchStr$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nLth$[ebp], ax
$LN2@fnRemoveCh:

; 4256 :          break;
; 4257 :    }
; 4258 : 
; 4259 :    for ( pch = pch2 = pchStr; *pch; pch++ )

	mov	ecx, DWORD PTR _pchStr$[ebp]
	mov	DWORD PTR _pch2$[ebp], ecx
	mov	edx, DWORD PTR _pch2$[ebp]
	mov	DWORD PTR _pch$[ebp], edx
	jmp	SHORT $LN6@fnRemoveCh
$LN4@fnRemoveCh:
	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax
$LN6@fnRemoveCh:
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN5@fnRemoveCh

; 4260 :    {
; 4261 :       // If current char isn't to be removed, then copy char and continue.
; 4262 :       if ( zstrchr( pchRemoveChars, *pch ) == 0 )

	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _pchRemoveChars$[ebp]
	push	edx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@fnRemoveCh

; 4263 :       {
; 4264 :          *pch2++ = *pch;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	ecx, DWORD PTR _pch$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 4265 :          continue;

	jmp	SHORT $LN4@fnRemoveCh
$LN18@fnRemoveCh:

; 4266 :       }
; 4267 : 
; 4268 :       // Check to see if previous char is in pchPrevChars. If pchPrevChars is
; 4269 :       // NULL, then we assume we are removing the char.  If pchPrevChars is
; 4270 :       // not NULL, then we only remove the current char if the previous char
; 4271 :       // exists in the pchPrevChars string.
; 4272 :       if ( pchPrevChars )

	cmp	DWORD PTR _pchPrevChars$[ebp], 0
	je	$LN19@fnRemoveCh

; 4273 :       {
; 4274 :          // If we are at the beginning of the string then there is no prev
; 4275 :          // char so don't remove the char.
; 4276 :          if ( pch2 == pchStr )

	mov	ecx, DWORD PTR _pch2$[ebp]
	cmp	ecx, DWORD PTR _pchStr$[ebp]
	jne	SHORT $LN20@fnRemoveCh

; 4277 :          {
; 4278 :             *pch2++ = *pch;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	eax, DWORD PTR _pch$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 4279 :             continue;

	jmp	SHORT $LN4@fnRemoveCh
$LN20@fnRemoveCh:

; 4280 :          }
; 4281 : 
; 4282 :          // If pchPrevChars contains a '*', then we only remove the current
; 4283 :          // char if it is the same char as the previous char.
; 4284 :          if ( *pchPrevChars == '*' )

	mov	eax, DWORD PTR _pchPrevChars$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 42					; 0000002aH
	jne	SHORT $LN21@fnRemoveCh

; 4285 :          {
; 4286 :             if ( *pch != *(pch2 - 1) )

	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pch2$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	cmp	eax, edx
	je	SHORT $LN23@fnRemoveCh

; 4287 :             {
; 4288 :                // Chars are not the same, so copy char and continue.
; 4289 :                *pch2++ = *pch;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	ecx, DWORD PTR _pch$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax

; 4290 :                continue;

	jmp	$LN4@fnRemoveCh
$LN23@fnRemoveCh:

; 4291 :             }
; 4292 :          }

	jmp	SHORT $LN19@fnRemoveCh
$LN21@fnRemoveCh:

; 4293 :          else
; 4294 :          if ( zstrchr( pchPrevChars, *(pch2 - 1) ) == 0 )

	mov	ecx, DWORD PTR _pch2$[ebp]
	movsx	edx, BYTE PTR [ecx-1]
	push	edx
	mov	eax, DWORD PTR _pchPrevChars$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN19@fnRemoveCh

; 4295 :          {
; 4296 :             // The previous char is not in the pchPrevChars string, so we don't
; 4297 :             // want to remove the current char.
; 4298 :             *pch2++ = *pch;

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	edx, DWORD PTR _pch$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx

; 4299 :             continue;

	jmp	$LN4@fnRemoveCh
$LN19@fnRemoveCh:

; 4300 :          }
; 4301 :       }
; 4302 : 
; 4303 :       // If we are replacing the removed char with something, then do it.
; 4304 :       // Since this doesn't make the string any shorter, continue.
; 4305 :       if ( cReplace )

	movsx	edx, BYTE PTR _cReplace$[ebp]
	test	edx, edx
	je	SHORT $LN25@fnRemoveCh

; 4306 :       {
; 4307 :          *pch2++ = cReplace;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	cl, BYTE PTR _cReplace$[ebp]
	mov	BYTE PTR [eax], cl
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx

; 4308 :          continue;

	jmp	$LN4@fnRemoveCh
$LN25@fnRemoveCh:

; 4309 :       }
; 4310 : 
; 4311 :       // By not copying the char we've deleted it. If we are deleting ALL
; 4312 :       // chars, continue loop.
; 4313 :       if ( cQualifier == 'A' )

	movsx	eax, BYTE PTR _cQualifier$[ebp]
	cmp	eax, 65					; 00000041H
	jne	SHORT $LN26@fnRemoveCh

; 4314 :          continue;

	jmp	$LN4@fnRemoveCh
$LN26@fnRemoveCh:

; 4315 : 
; 4316 :       // We have removed a char.  Check to see if string is now short enough.
; 4317 : 
; 4318 :       // Take into account deleted char.
; 4319 :       nLth--;

	mov	cx, WORD PTR _nLth$[ebp]
	sub	cx, 1
	mov	WORD PTR _nLth$[ebp], cx

; 4320 : 
; 4321 :       if ( nLth > nShortNameLth )

	movsx	edx, WORD PTR _nLth$[ebp]
	movsx	eax, WORD PTR _nShortNameLth$[ebp]
	cmp	edx, eax
	jle	SHORT $LN27@fnRemoveCh

; 4322 :          continue;  // Name still isn't short enough.

	jmp	$LN4@fnRemoveCh
$LN27@fnRemoveCh:

; 4323 : 
; 4324 :       // Name is short enough.  Copy the rest of the string and
; 4325 :       // break loop.
; 4326 :       for ( ; *pch; pch++, pch2++ )

	jmp	SHORT $LN9@fnRemoveCh
$LN7@fnRemoveCh:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
	mov	edx, DWORD PTR _pch2$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch2$[ebp], edx
$LN9@fnRemoveCh:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN8@fnRemoveCh

; 4327 :          *pch2 = *pch;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	eax, DWORD PTR _pch$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	jmp	SHORT $LN7@fnRemoveCh
$LN8@fnRemoveCh:

; 4328 : 
; 4329 :       *pch2 = 0;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 0

; 4330 :       break;

	jmp	SHORT $LN5@fnRemoveCh

; 4331 : 
; 4332 :    } // for...

	jmp	$LN4@fnRemoveCh
$LN5@fnRemoveCh:

; 4333 : 
; 4334 :    *pch2 = 0;

	mov	eax, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [eax], 0

; 4335 : 
; 4336 :    if ( cQualifier == 'B' )

	movsx	ecx, BYTE PTR _cQualifier$[ebp]
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN28@fnRemoveCh

; 4337 :       zstrrev( pchStr );

	mov	edx, DWORD PTR _pchStr$[ebp]
	push	edx
	call	DWORD PTR __imp___strrev
	add	esp, 4
$LN28@fnRemoveCh:

; 4338 : 
; 4339 :    return( 0 );

	xor	eax, eax
$LN1@fnRemoveCh:

; 4340 : 
; 4341 : } // fnRemoveChars

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnRemoveChars@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv69 = -44						; size = 4
_nRC$ = -40						; size = 2
_szDateTime$ = -36					; size = 18
_sz$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_lpDateTime$ = 8					; size = 4
_nCID$ = 12						; size = 2
_lValue$ = 16						; size = 4
_fnSetDateTimeComponent PROC

; 2078 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2079 :    zCHAR    szDateTime[ 18 ];
; 2080 :    zCHAR    sz[ 10 ];
; 2081 :    zSHORT   nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2082 : 
; 2083 :    nRC = UfDateTimeToString( lpDateTime, szDateTime, sizeof( szDateTime ) );

	push	18					; 00000012H
	lea	ecx, DWORD PTR _szDateTime$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDateTime$[ebp]
	push	edx
	call	_UfDateTimeToString@12
	mov	WORD PTR _nRC$[ebp], ax

; 2084 :    switch ( nCID )

	movsx	eax, WORD PTR _nCID$[ebp]
	mov	DWORD PTR tv69[ebp], eax
	cmp	DWORD PTR tv69[ebp], 5
	ja	$LN10@fnSetDateT
	mov	ecx, DWORD PTR tv69[ebp]
	jmp	DWORD PTR $LN13@fnSetDateT[ecx*4]
$LN4@fnSetDateT:

; 2085 :    {
; 2086 :       case zDT_YEAR:
; 2087 :          zltoa( lValue + 10000L, sz );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lValue$[ebp]
	add	eax, 10000				; 00002710H
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 2088 :          zmemcpy( szDateTime, sz + 1, 4 );

	push	4
	lea	ecx, DWORD PTR _sz$[ebp+1]
	push	ecx
	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2089 :          break;

	jmp	$LN2@fnSetDateT
$LN5@fnSetDateT:

; 2090 : 
; 2091 :       case zDT_MONTH:
; 2092 :          zltoa( lValue + 100L, sz );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lValue$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 2093 :          zmemcpy( szDateTime + 4, sz + 1, 2 );

	push	2
	lea	edx, DWORD PTR _sz$[ebp+1]
	push	edx
	lea	eax, DWORD PTR _szDateTime$[ebp+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2094 :          break;

	jmp	$LN2@fnSetDateT
$LN6@fnSetDateT:

; 2095 : 
; 2096 :       case zDT_DAY:
; 2097 :          zltoa( lValue + 100L, sz );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lValue$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 2098 :          zmemcpy( szDateTime + 6, sz + 1, 2 );

	push	2
	lea	eax, DWORD PTR _sz$[ebp+1]
	push	eax
	lea	ecx, DWORD PTR _szDateTime$[ebp+6]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2099 :          break;

	jmp	$LN2@fnSetDateT
$LN7@fnSetDateT:

; 2100 : 
; 2101 :       case zDT_HOUR:
; 2102 :          zltoa( lValue + 100L, sz );

	push	10					; 0000000aH
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _lValue$[ebp]
	add	eax, 100				; 00000064H
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 2103 :          zmemcpy( szDateTime + 8, sz + 1, 2 );

	push	2
	lea	ecx, DWORD PTR _sz$[ebp+1]
	push	ecx
	lea	edx, DWORD PTR _szDateTime$[ebp+8]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2104 :          break;

	jmp	SHORT $LN2@fnSetDateT
$LN8@fnSetDateT:

; 2105 : 
; 2106 :       case zDT_MINUTE:
; 2107 :          zltoa( lValue + 100L, sz );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lValue$[ebp]
	add	ecx, 100				; 00000064H
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 2108 :          zmemcpy( szDateTime + 10, sz + 1, 2 );

	push	2
	lea	edx, DWORD PTR _sz$[ebp+1]
	push	edx
	lea	eax, DWORD PTR _szDateTime$[ebp+10]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2109 :          break;

	jmp	SHORT $LN2@fnSetDateT
$LN9@fnSetDateT:

; 2110 : 
; 2111 :       case zDT_SECOND:
; 2112 :          zltoa( lValue + 100L, sz );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lValue$[ebp]
	add	edx, 100				; 00000064H
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 2113 :          zmemcpy( szDateTime + 12, sz + 1, 2 );

	push	2
	lea	eax, DWORD PTR _sz$[ebp+1]
	push	eax
	lea	ecx, DWORD PTR _szDateTime$[ebp+12]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2114 :          break;

	jmp	SHORT $LN2@fnSetDateT
$LN10@fnSetDateT:

; 2115 : 
; 2116 :       default:
; 2117 :          nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN2@fnSetDateT:

; 2118 :    }
; 2119 : 
; 2120 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN11@fnSetDateT

; 2121 :       nRC = UfStringToDateTime( szDateTime, lpDateTime );

	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDateTime$[ebp]
	push	edx
	call	_UfStringToDateTime@8
	mov	WORD PTR _nRC$[ebp], ax
$LN11@fnSetDateT:

; 2122 : 
; 2123 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 2124 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN13@fnSetDateT:
	DD	$LN4@fnSetDateT
	DD	$LN5@fnSetDateT
	DD	$LN6@fnSetDateT
	DD	$LN7@fnSetDateT
	DD	$LN8@fnSetDateT
	DD	$LN9@fnSetDateT
_fnSetDateTimeComponent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
tv68 = -32						; size = 4
_lValue$ = -28						; size = 4
_szDateTime$ = -24					; size = 18
__$ArrayPad$ = -4					; size = 4
_lpDateTime$ = 8					; size = 4
_nCID$ = 12						; size = 2
_fnGetDateTimeComponent PROC

; 2020 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2021 :    zCHAR    szDateTime[ 18 ];
; 2022 :    zLONG    lValue = -1L;

	mov	DWORD PTR _lValue$[ebp], -1

; 2023 : 
; 2024 :    UfDateTimeToString( lpDateTime, szDateTime, sizeof( szDateTime ) );

	push	18					; 00000012H
	lea	eax, DWORD PTR _szDateTime$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	push	ecx
	call	_UfDateTimeToString@12

; 2025 :    switch ( nCID )

	movsx	edx, WORD PTR _nCID$[ebp]
	mov	DWORD PTR tv68[ebp], edx
	cmp	DWORD PTR tv68[ebp], 5
	ja	$LN2@fnGetDateT
	mov	eax, DWORD PTR tv68[ebp]
	jmp	DWORD PTR $LN23@fnGetDateT[eax*4]
$LN4@fnGetDateT:

; 2026 :    {
; 2027 :       case zDT_YEAR:
; 2028 :          szDateTime[ 4 ] = 0;

	mov	ecx, 1
	shl	ecx, 2
	mov	DWORD PTR $T6[ebp], ecx
	cmp	DWORD PTR $T6[ebp], 18			; 00000012H
	jae	SHORT $LN11@fnGetDateT
	jmp	SHORT $LN12@fnGetDateT
$LN11@fnGetDateT:
	call	___report_rangecheckfailure
$LN12@fnGetDateT:
	mov	edx, DWORD PTR $T6[ebp]
	mov	BYTE PTR _szDateTime$[ebp+edx], 0

; 2029 :          lValue = zatol( szDateTime );

	lea	eax, DWORD PTR _szDateTime$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lValue$[ebp], eax

; 2030 :          break;

	jmp	$LN2@fnGetDateT
$LN5@fnGetDateT:

; 2031 : 
; 2032 :       case zDT_MONTH:
; 2033 :          szDateTime[ 6 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 6
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 18			; 00000012H
	jae	SHORT $LN13@fnGetDateT
	jmp	SHORT $LN14@fnGetDateT
$LN13@fnGetDateT:
	call	___report_rangecheckfailure
$LN14@fnGetDateT:
	mov	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR _szDateTime$[ebp+eax], 0

; 2034 :          lValue = zatol( szDateTime + 4 );

	lea	ecx, DWORD PTR _szDateTime$[ebp+4]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lValue$[ebp], eax

; 2035 :          break;

	jmp	$LN2@fnGetDateT
$LN6@fnGetDateT:

; 2036 : 
; 2037 :       case zDT_DAY:
; 2038 :          szDateTime[ 8 ] = 0;

	mov	edx, 1
	shl	edx, 3
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 18			; 00000012H
	jae	SHORT $LN15@fnGetDateT
	jmp	SHORT $LN16@fnGetDateT
$LN15@fnGetDateT:
	call	___report_rangecheckfailure
$LN16@fnGetDateT:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szDateTime$[ebp+eax], 0

; 2039 :          lValue = zatol( szDateTime + 6 );

	lea	ecx, DWORD PTR _szDateTime$[ebp+6]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lValue$[ebp], eax

; 2040 :          break;

	jmp	$LN2@fnGetDateT
$LN7@fnGetDateT:

; 2041 : 
; 2042 :       case zDT_HOUR:
; 2043 :          szDateTime[ 10 ] = 0;

	mov	edx, 1
	imul	eax, edx, 10
	mov	DWORD PTR $T3[ebp], eax
	cmp	DWORD PTR $T3[ebp], 18			; 00000012H
	jae	SHORT $LN17@fnGetDateT
	jmp	SHORT $LN18@fnGetDateT
$LN17@fnGetDateT:
	call	___report_rangecheckfailure
$LN18@fnGetDateT:
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szDateTime$[ebp+ecx], 0

; 2044 :          lValue = zatol( szDateTime + 8 );

	lea	edx, DWORD PTR _szDateTime$[ebp+8]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lValue$[ebp], eax

; 2045 :          break;

	jmp	SHORT $LN2@fnGetDateT
$LN8@fnGetDateT:

; 2046 : 
; 2047 :       case zDT_MINUTE:
; 2048 :          szDateTime[ 12 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 12
	mov	DWORD PTR $T2[ebp], ecx
	cmp	DWORD PTR $T2[ebp], 18			; 00000012H
	jae	SHORT $LN19@fnGetDateT
	jmp	SHORT $LN20@fnGetDateT
$LN19@fnGetDateT:
	call	___report_rangecheckfailure
$LN20@fnGetDateT:
	mov	edx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szDateTime$[ebp+edx], 0

; 2049 :          lValue = zatol( szDateTime + 10 );

	lea	eax, DWORD PTR _szDateTime$[ebp+10]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lValue$[ebp], eax

; 2050 :          break;

	jmp	SHORT $LN2@fnGetDateT
$LN9@fnGetDateT:

; 2051 : 
; 2052 :       case zDT_SECOND:
; 2053 :          szDateTime[ 14 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 14
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 18			; 00000012H
	jae	SHORT $LN21@fnGetDateT
	jmp	SHORT $LN22@fnGetDateT
$LN21@fnGetDateT:
	call	___report_rangecheckfailure
$LN22@fnGetDateT:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szDateTime$[ebp+eax], 0

; 2054 :          lValue = zatol( szDateTime + 12 );

	lea	ecx, DWORD PTR _szDateTime$[ebp+12]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lValue$[ebp], eax
$LN2@fnGetDateT:

; 2055 :          break;
; 2056 :    }
; 2057 : 
; 2058 :    return( lValue );

	mov	eax, DWORD PTR _lValue$[ebp]
$LN10@fnGetDateT:

; 2059 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN23@fnGetDateT:
	DD	$LN4@fnGetDateT
	DD	$LN5@fnGetDateT
	DD	$LN6@fnGetDateT
	DD	$LN7@fnGetDateT
	DD	$LN8@fnGetDateT
	DD	$LN9@fnGetDateT
_fnGetDateTimeComponent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv71 = -8						; size = 4
_usMax$ = -4						; size = 2
_usMonth$ = 8						; size = 2
_usDay$ = 12						; size = 2
_ulYear$ = 16						; size = 4
_fnValidateDay PROC

; 1625 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1626 :    zUSHORT   usMax;
; 1627 : 
; 1628 :    if ( usDay >= 1 && usDay <= 28 )

	movzx	eax, WORD PTR _usDay$[ebp]
	cmp	eax, 1
	jl	SHORT $LN4@fnValidate
	movzx	ecx, WORD PTR _usDay$[ebp]
	cmp	ecx, 28					; 0000001cH
	jg	SHORT $LN4@fnValidate

; 1629 :       return( usDay );

	mov	ax, WORD PTR _usDay$[ebp]
	jmp	$LN1@fnValidate
$LN4@fnValidate:

; 1630 : 
; 1631 :    if ( usDay < 1 )

	movzx	edx, WORD PTR _usDay$[ebp]
	cmp	edx, 1
	jge	SHORT $LN5@fnValidate

; 1632 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnValidate
$LN5@fnValidate:

; 1633 : 
; 1634 :    switch ( usMonth )

	movzx	eax, WORD PTR _usMonth$[ebp]
	mov	DWORD PTR tv71[ebp], eax
	mov	ecx, DWORD PTR tv71[ebp]
	sub	ecx, 2
	mov	DWORD PTR tv71[ebp], ecx
	cmp	DWORD PTR tv71[ebp], 9
	ja	SHORT $LN10@fnValidate
	mov	edx, DWORD PTR tv71[ebp]
	movzx	eax, BYTE PTR $LN14@fnValidate[edx]
	jmp	DWORD PTR $LN15@fnValidate[eax*4]
$LN6@fnValidate:

; 1635 :    {
; 1636 :       case 2:
; 1637 :          usMax = 28;

	mov	ecx, 28					; 0000001cH
	mov	WORD PTR _usMax$[ebp], cx

; 1638 :          if ( (ulYear % 4) == 0 &&

	mov	eax, DWORD PTR _ulYear$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN7@fnValidate
	mov	eax, DWORD PTR _ulYear$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	test	edx, edx
	jne	SHORT $LN8@fnValidate
	mov	eax, DWORD PTR _ulYear$[ebp]
	xor	edx, edx
	mov	ecx, 400				; 00000190H
	div	ecx
	test	edx, edx
	jne	SHORT $LN7@fnValidate
$LN8@fnValidate:

; 1639 :               ((ulYear % 100) || (ulYear % 400) == 0) )
; 1640 :          {
; 1641 :             usMax = 29;

	mov	edx, 29					; 0000001dH
	mov	WORD PTR _usMax$[ebp], dx
$LN7@fnValidate:

; 1642 :          }
; 1643 : 
; 1644 :          break;

	jmp	SHORT $LN2@fnValidate
$LN9@fnValidate:

; 1645 : 
; 1646 :       case 4:
; 1647 :       case 6:
; 1648 :       case 9:
; 1649 :       case 11:
; 1650 :          usMax = 30;

	mov	eax, 30					; 0000001eH
	mov	WORD PTR _usMax$[ebp], ax

; 1651 :          break;

	jmp	SHORT $LN2@fnValidate
$LN10@fnValidate:

; 1652 : 
; 1653 :       default:
; 1654 :          usMax = 31;

	mov	ecx, 31					; 0000001fH
	mov	WORD PTR _usMax$[ebp], cx
$LN2@fnValidate:

; 1655 :    }
; 1656 : 
; 1657 :    if ( usDay > usMax )

	movzx	edx, WORD PTR _usDay$[ebp]
	movzx	eax, WORD PTR _usMax$[ebp]
	cmp	edx, eax
	jle	SHORT $LN11@fnValidate

; 1658 :       return( usMax );

	mov	ax, WORD PTR _usMax$[ebp]
	jmp	SHORT $LN1@fnValidate
	jmp	SHORT $LN1@fnValidate
$LN11@fnValidate:

; 1659 :    else
; 1660 :       return( usDay );

	mov	ax, WORD PTR _usDay$[ebp]
$LN1@fnValidate:

; 1661 : 
; 1662 : } /*** END fnValidateDay ***/

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN15@fnValidate:
	DD	$LN6@fnValidate
	DD	$LN9@fnValidate
	DD	$LN10@fnValidate
$LN14@fnValidate:
	DB	0
	DB	2
	DB	1
	DB	2
	DB	1
	DB	2
	DB	2
	DB	1
	DB	2
	DB	1
_fnValidateDay ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_nPos$ = -76						; size = 2
_k$ = -72						; size = 2
_szTemp$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_lValue$ = 8						; size = 4
_pchAsciiString$ = 12					; size = 4
_nLth$ = 16						; size = 2
_zltoal	PROC

; 150  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 151  :    zSHORT k;
; 152  :    zSHORT nPos;
; 153  :    zCHAR szTemp[ 64 ];
; 154  : 
; 155  :    zltoa( lValue, szTemp );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _szTemp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lValue$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 156  :    k = zstrlen( szTemp );

	lea	edx, DWORD PTR _szTemp$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _k$[ebp], ax

; 157  :    if ( k < nLth )

	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nLth$[ebp]
	cmp	eax, ecx
	jge	SHORT $LN2@zltoal

; 158  :    {
; 159  :       nPos = nLth - k;

	movsx	edx, WORD PTR _nLth$[ebp]
	movsx	eax, WORD PTR _k$[ebp]
	sub	edx, eax
	mov	WORD PTR _nPos$[ebp], dx

; 160  :       zmemset( pchAsciiString, '0', nPos );

	movsx	ecx, WORD PTR _nPos$[ebp]
	push	ecx
	push	48					; 00000030H
	mov	edx, DWORD PTR _pchAsciiString$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 161  :    }

	jmp	SHORT $LN3@zltoal
$LN2@zltoal:

; 162  :    else
; 163  :    {
; 164  :       nPos = 0;

	xor	eax, eax
	mov	WORD PTR _nPos$[ebp], ax

; 165  :       k = nLth;

	mov	cx, WORD PTR _nLth$[ebp]
	mov	WORD PTR _k$[ebp], cx
$LN3@zltoal:

; 166  :    }
; 167  : 
; 168  :    zstrncpy( pchAsciiString + nPos, szTemp, k );

	movsx	edx, WORD PTR _k$[ebp]
	push	edx
	lea	eax, DWORD PTR _szTemp$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nPos$[ebp]
	add	ecx, DWORD PTR _pchAsciiString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 169  :    pchAsciiString[ nLth ] = 0;

	movsx	edx, WORD PTR _nLth$[ebp]
	mov	eax, DWORD PTR _pchAsciiString$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 170  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_zltoal	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv142 = -56						; size = 4
_lpInternational$1 = -52				; size = 4
tv80 = -48						; size = 4
_n2$2 = -44						; size = 2
_n2$3 = -40						; size = 2
_k$4 = -36						; size = 2
_n1$5 = -32						; size = 2
_n1$6 = -28						; size = 2
_n2$7 = -24						; size = 2
_n1$8 = -20						; size = 2
_k$9 = -16						; size = 2
_k$10 = -12						; size = 2
_nCounter$ = -8						; size = 2
_chDelimiter$ = -1					; size = 1
_cpcEditString$ = 8					; size = 4
_fnDetermineDateTimeStrlen PROC

; 3234 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 3235 :    zSHORT   nCounter = 0;

	xor	eax, eax
	mov	WORD PTR _nCounter$[ebp], ax

; 3236 :    zCHAR    chDelimiter = 0;

	mov	BYTE PTR _chDelimiter$[ebp], 0

; 3237 : 
; 3238 :    if ( cpcEditString == 0 || cpcEditString[ 0 ] == 0 )

	cmp	DWORD PTR _cpcEditString$[ebp], 0
	je	SHORT $LN18@fnDetermin
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN2@fnDetermin
$LN18@fnDetermin:

; 3239 :       return( nCounter );

	mov	ax, WORD PTR _nCounter$[ebp]
	jmp	$LN1@fnDetermin
$LN2@fnDetermin:

; 3240 : 
; 3241 :    while ( *cpcEditString )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@fnDetermin

; 3242 :    {
; 3243 :       if ( chDelimiter )

	movsx	ecx, BYTE PTR _chDelimiter$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@fnDetermin

; 3244 :       {
; 3245 :          if ( *cpcEditString == chDelimiter )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _chDelimiter$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN21@fnDetermin

; 3246 :          {
; 3247 :             chDelimiter = 0;

	mov	BYTE PTR _chDelimiter$[ebp], 0

; 3248 :             cpcEditString++;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3249 :          }

	jmp	SHORT $LN22@fnDetermin
$LN21@fnDetermin:

; 3250 :          else
; 3251 :          {
; 3252 :             nCounter++;

	mov	ax, WORD PTR _nCounter$[ebp]
	add	ax, 1
	mov	WORD PTR _nCounter$[ebp], ax

; 3253 :             cpcEditString++;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx
$LN22@fnDetermin:

; 3254 :          }
; 3255 :       }

	jmp	$LN20@fnDetermin
$LN19@fnDetermin:

; 3256 :       else
; 3257 :       switch ( *cpcEditString )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR tv80[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR tv80[ebp], ecx
	cmp	DWORD PTR tv80[ebp], 77			; 0000004dH
	ja	$LN66@fnDetermin
	mov	edx, DWORD PTR tv80[ebp]
	movzx	eax, BYTE PTR $LN70@fnDetermin[edx]
	jmp	DWORD PTR $LN71@fnDetermin[eax*4]
$LN23@fnDetermin:

; 3258 :       {
; 3259 :          case 'A':
; 3260 :          case 'P':
; 3261 :             if ( *(cpcEditString + 1) == 'M' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 77					; 0000004dH
	jne	$LN24@fnDetermin

; 3262 :             {
; 3263 :                zSHORT   n1, n2;
; 3264 :                LPINTERNATIONAL lpInternational =

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2515]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$1[ebp], eax

; 3265 :                                        zGETPTR( AnchorBlock->hInternational );
; 3266 : 
; 3267 :                // use which ever length is greater
; 3268 :                if ( lpInternational->sz1159[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax+86]
	test	edx, edx
	jne	SHORT $LN26@fnDetermin

; 3269 :                   n1 = 2;

	mov	eax, 2
	mov	WORD PTR _n1$8[ebp], ax
	jmp	SHORT $LN27@fnDetermin
$LN26@fnDetermin:

; 3270 :                else
; 3271 :                   n1 = zstrlen( lpInternational->sz1159 );

	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	add	ecx, 86					; 00000056H
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n1$8[ebp], ax
$LN27@fnDetermin:

; 3272 : 
; 3273 :                if ( lpInternational->sz2359[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	movsx	edx, BYTE PTR [ecx+eax+91]
	test	edx, edx
	jne	SHORT $LN28@fnDetermin

; 3274 :                   n2 = 2;

	mov	eax, 2
	mov	WORD PTR _n2$7[ebp], ax
	jmp	SHORT $LN29@fnDetermin
$LN28@fnDetermin:

; 3275 :                else
; 3276 :                   n2 = zstrlen( lpInternational->sz2359 );

	mov	ecx, DWORD PTR _lpInternational$1[ebp]
	add	ecx, 91					; 0000005bH
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n2$7[ebp], ax
$LN29@fnDetermin:

; 3277 : 
; 3278 :                nCounter += ( n1 > n2 ) ? n1 : n2;

	movsx	edx, WORD PTR _n1$8[ebp]
	movsx	eax, WORD PTR _n2$7[ebp]
	cmp	edx, eax
	jle	SHORT $LN68@fnDetermin
	movsx	ecx, WORD PTR _n1$8[ebp]
	mov	DWORD PTR tv142[ebp], ecx
	jmp	SHORT $LN69@fnDetermin
$LN68@fnDetermin:
	movsx	edx, WORD PTR _n2$7[ebp]
	mov	DWORD PTR tv142[ebp], edx
$LN69@fnDetermin:
	movsx	eax, WORD PTR _nCounter$[ebp]
	add	eax, DWORD PTR tv142[ebp]
	mov	WORD PTR _nCounter$[ebp], ax

; 3279 :                cpcEditString += 2;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 3280 :             }

	jmp	SHORT $LN25@fnDetermin
$LN24@fnDetermin:

; 3281 :             else
; 3282 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDetermin
$LN25@fnDetermin:

; 3283 : 
; 3284 :             break;

	jmp	$LN20@fnDetermin
$LN30@fnDetermin:

; 3285 : 
; 3286 :          case 'd':
; 3287 :          case 'D':
; 3288 :             if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "ddd", 3 ) == 0 )

	push	3
	push	OFFSET $SG14530
	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN31@fnDetermin

; 3289 :             {
; 3290 :                zSHORT   k;
; 3291 :                zSHORT   n1, n2;
; 3292 :                // use the greatest length
; 3293 :                for ( n1 = 0, k = 0; k < 7; k++ )

	xor	eax, eax
	mov	WORD PTR _n1$6[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _k$10[ebp], cx
	jmp	SHORT $LN8@fnDetermin
$LN6@fnDetermin:
	mov	dx, WORD PTR _k$10[ebp]
	add	dx, 1
	mov	WORD PTR _k$10[ebp], dx
$LN8@fnDetermin:
	movsx	eax, WORD PTR _k$10[ebp]
	cmp	eax, 7
	jge	SHORT $LN7@fnDetermin

; 3294 :                {
; 3295 :                   n2 = zstrlen( g_pchDOW[ k ] );

	movsx	ecx, WORD PTR _k$10[ebp]
	mov	edx, DWORD PTR _g_pchDOW[ecx*4]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n2$3[ebp], ax

; 3296 :                   if ( n2 > n1 )

	movsx	eax, WORD PTR _n2$3[ebp]
	movsx	ecx, WORD PTR _n1$6[ebp]
	cmp	eax, ecx
	jle	SHORT $LN33@fnDetermin

; 3297 :                      n1 = n2;

	mov	dx, WORD PTR _n2$3[ebp]
	mov	WORD PTR _n1$6[ebp], dx
$LN33@fnDetermin:

; 3298 :                }

	jmp	SHORT $LN6@fnDetermin
$LN7@fnDetermin:

; 3299 : 
; 3300 :                nCounter += n1;

	movsx	eax, WORD PTR _n1$6[ebp]
	movsx	ecx, WORD PTR _nCounter$[ebp]
	add	ecx, eax
	mov	WORD PTR _nCounter$[ebp], cx

; 3301 :                cpcEditString += 4;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 4
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3302 :             }

	jmp	SHORT $LN32@fnDetermin
$LN31@fnDetermin:

; 3303 :             else
; 3304 :             if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "dd", 2 ) == 0 )

	push	2
	push	OFFSET $SG14534
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN34@fnDetermin

; 3305 :             {
; 3306 :                // three for short day name
; 3307 :                nCounter += 3;

	movsx	ecx, WORD PTR _nCounter$[ebp]
	add	ecx, 3
	mov	WORD PTR _nCounter$[ebp], cx

; 3308 :                cpcEditString += 3;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 3
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3309 :             }

	jmp	SHORT $LN32@fnDetermin
$LN34@fnDetermin:

; 3310 :             else
; 3311 :             if ( *(cpcEditString + 1) == 'D' ||

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 68					; 00000044H
	je	SHORT $LN38@fnDetermin
	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 100				; 00000064H
	jne	SHORT $LN36@fnDetermin
$LN38@fnDetermin:

; 3312 :                  *(cpcEditString + 1) == 'd' )
; 3313 :             {
; 3314 :                // two for the day of the month (w/leading zero if < 10 )
; 3315 :                nCounter += 2;

	movsx	ecx, WORD PTR _nCounter$[ebp]
	add	ecx, 2
	mov	WORD PTR _nCounter$[ebp], cx

; 3316 :                cpcEditString += 2;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 2
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3317 :             }

	jmp	SHORT $LN32@fnDetermin
$LN36@fnDetermin:

; 3318 :             else
; 3319 :             {
; 3320 :                // two for the day of the month ( max possible )
; 3321 :                nCounter += 2;

	movsx	eax, WORD PTR _nCounter$[ebp]
	add	eax, 2
	mov	WORD PTR _nCounter$[ebp], ax

; 3322 :                cpcEditString++;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx
$LN32@fnDetermin:

; 3323 :             }
; 3324 : 
; 3325 :             break;

	jmp	$LN20@fnDetermin
$LN39@fnDetermin:

; 3326 : 
; 3327 :          case 'H':
; 3328 :             // assume max ( 2 )
; 3329 :             nCounter += 2;

	movsx	edx, WORD PTR _nCounter$[ebp]
	add	edx, 2
	mov	WORD PTR _nCounter$[ebp], dx

; 3330 :             cpcEditString++;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 3331 :             if ( *cpcEditString == 'H' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 72					; 00000048H
	jne	SHORT $LN40@fnDetermin

; 3332 :                cpcEditString++;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _cpcEditString$[ebp], eax
$LN40@fnDetermin:

; 3333 : 
; 3334 :             break;

	jmp	$LN20@fnDetermin
$LN41@fnDetermin:

; 3335 : 
; 3336 :          case 'j':
; 3337 :             if ( zstrncmp( (zPCHAR)(cpcEditString + 1), "jj", 2 ) == 0 )

	push	2
	push	OFFSET $SG14543
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN42@fnDetermin

; 3338 :             {
; 3339 :                nCounter += 3;

	movsx	edx, WORD PTR _nCounter$[ebp]
	add	edx, 3
	mov	WORD PTR _nCounter$[ebp], dx

; 3340 :                cpcEditString += 3;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 3
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 3341 :             }

	jmp	SHORT $LN43@fnDetermin
$LN42@fnDetermin:

; 3342 :             else
; 3343 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDetermin
$LN43@fnDetermin:

; 3344 : 
; 3345 :             break;

	jmp	$LN20@fnDetermin
$LN44@fnDetermin:

; 3346 : 
; 3347 :          case 'M':
; 3348 :             if ( *(cpcEditString + 1) == 'I' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 73					; 00000049H
	jne	SHORT $LN46@fnDetermin

; 3349 :             {
; 3350 :                nCounter += 2;

	movsx	eax, WORD PTR _nCounter$[ebp]
	add	eax, 2
	mov	WORD PTR _nCounter$[ebp], ax

; 3351 :                cpcEditString += 2;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 3352 :                break;

	jmp	$LN20@fnDetermin
$LN46@fnDetermin:

; 3353 :             }
; 3354 :             // break left out intentionally!
; 3355 : 
; 3356 :          case 'm':
; 3357 :             if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "mmm", 3 ) == 0 )

	push	3
	push	OFFSET $SG14549
	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN47@fnDetermin

; 3358 :             {
; 3359 :                zSHORT   k;
; 3360 :                zSHORT   n1, n2;
; 3361 : 
; 3362 :                for ( n1 = 0, k = 0; k < 12; k++ )

	xor	eax, eax
	mov	WORD PTR _n1$5[ebp], ax
	xor	ecx, ecx
	mov	WORD PTR _k$9[ebp], cx
	jmp	SHORT $LN11@fnDetermin
$LN9@fnDetermin:
	mov	dx, WORD PTR _k$9[ebp]
	add	dx, 1
	mov	WORD PTR _k$9[ebp], dx
$LN11@fnDetermin:
	movsx	eax, WORD PTR _k$9[ebp]
	cmp	eax, 12					; 0000000cH
	jge	SHORT $LN10@fnDetermin

; 3363 :                {
; 3364 :                   n2 = zstrlen( g_pchMon[ k ] );

	movsx	ecx, WORD PTR _k$9[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n2$2[ebp], ax

; 3365 :                   if ( n2 > n1 )

	movsx	eax, WORD PTR _n2$2[ebp]
	movsx	ecx, WORD PTR _n1$5[ebp]
	cmp	eax, ecx
	jle	SHORT $LN49@fnDetermin

; 3366 :                      n1 = n2;

	mov	dx, WORD PTR _n2$2[ebp]
	mov	WORD PTR _n1$5[ebp], dx
$LN49@fnDetermin:

; 3367 :                }

	jmp	SHORT $LN9@fnDetermin
$LN10@fnDetermin:

; 3368 :                nCounter += n1;

	movsx	eax, WORD PTR _n1$5[ebp]
	movsx	ecx, WORD PTR _nCounter$[ebp]
	add	ecx, eax
	mov	WORD PTR _nCounter$[ebp], cx

; 3369 :                cpcEditString += 4;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 4
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3370 :             }

	jmp	SHORT $LN48@fnDetermin
$LN47@fnDetermin:

; 3371 :             else
; 3372 :             if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "mm", 2 ) == 0 )

	push	2
	push	OFFSET $SG14553
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN50@fnDetermin

; 3373 :             {
; 3374 :                nCounter += 3;

	movsx	ecx, WORD PTR _nCounter$[ebp]
	add	ecx, 3
	mov	WORD PTR _nCounter$[ebp], cx

; 3375 :                cpcEditString += 3;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 3
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3376 :             }

	jmp	SHORT $LN48@fnDetermin
$LN50@fnDetermin:

; 3377 :             else
; 3378 :             if ( *(cpcEditString + 1) == 'M' ||

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 77					; 0000004dH
	je	SHORT $LN54@fnDetermin
	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 109				; 0000006dH
	jne	SHORT $LN52@fnDetermin
$LN54@fnDetermin:

; 3379 :                  *(cpcEditString + 1) == 'm' )
; 3380 :             {
; 3381 :                // two for the month
; 3382 :                nCounter += 2;

	movsx	ecx, WORD PTR _nCounter$[ebp]
	add	ecx, 2
	mov	WORD PTR _nCounter$[ebp], cx

; 3383 :                cpcEditString += 2;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 2
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3384 :             }

	jmp	SHORT $LN48@fnDetermin
$LN52@fnDetermin:

; 3385 :             else
; 3386 :             {
; 3387 :                // two for the month
; 3388 :                nCounter += 2;

	movsx	eax, WORD PTR _nCounter$[ebp]
	add	eax, 2
	mov	WORD PTR _nCounter$[ebp], ax

; 3389 :                cpcEditString++;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx
$LN48@fnDetermin:

; 3390 :             }
; 3391 : 
; 3392 :             break;

	jmp	$LN20@fnDetermin
$LN55@fnDetermin:

; 3393 : 
; 3394 :          case 'S':
; 3395 :             if ( *(cpcEditString + 1) == 'S' )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN56@fnDetermin

; 3396 :             {
; 3397 :                nCounter += 2;

	movsx	ecx, WORD PTR _nCounter$[ebp]
	add	ecx, 2
	mov	WORD PTR _nCounter$[ebp], cx

; 3398 :                cpcEditString += 2;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 2
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 3399 :             }

	jmp	SHORT $LN57@fnDetermin
$LN56@fnDetermin:

; 3400 :             else
; 3401 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDetermin
$LN57@fnDetermin:

; 3402 : 
; 3403 :             break;

	jmp	$LN20@fnDetermin
$LN58@fnDetermin:

; 3404 : 
; 3405 :          case 'Y':
; 3406 :             if ( *(cpcEditString + 1) == 'Y' )

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN59@fnDetermin

; 3407 :             {
; 3408 :                if ( *(cpcEditString + 2) == 'Y' &&

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx+2]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN61@fnDetermin
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+3]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN61@fnDetermin

; 3409 :                     *(cpcEditString + 3) == 'Y' )
; 3410 :                {
; 3411 :                   // four for the year;
; 3412 :                   nCounter += 4;

	movsx	eax, WORD PTR _nCounter$[ebp]
	add	eax, 4
	mov	WORD PTR _nCounter$[ebp], ax

; 3413 :                   cpcEditString += 4;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 4
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 3414 :                }

	jmp	SHORT $LN62@fnDetermin
$LN61@fnDetermin:

; 3415 :                else
; 3416 :                {
; 3417 :                   // two for the year
; 3418 :                   nCounter += 2;

	movsx	edx, WORD PTR _nCounter$[ebp]
	add	edx, 2
	mov	WORD PTR _nCounter$[ebp], dx

; 3419 :                   cpcEditString += 2;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _cpcEditString$[ebp], eax
$LN62@fnDetermin:

; 3420 :                }
; 3421 :             }

	jmp	SHORT $LN60@fnDetermin
$LN59@fnDetermin:

; 3422 :             else
; 3423 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnDetermin
$LN60@fnDetermin:

; 3424 : 
; 3425 :             break;

	jmp	$LN20@fnDetermin
$LN63@fnDetermin:

; 3426 : 
; 3427 :          case '9':
; 3428 :          {
; 3429 :             zSHORT   k;
; 3430 :             for ( k = 0; *cpcEditString == '9' && k < 3; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$4[ebp], cx
	jmp	SHORT $LN14@fnDetermin
$LN12@fnDetermin:
	mov	dx, WORD PTR _k$4[ebp]
	add	dx, 1
	mov	WORD PTR _k$4[ebp], dx
$LN14@fnDetermin:
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jne	SHORT $LN15@fnDetermin
	movsx	edx, WORD PTR _k$4[ebp]
	cmp	edx, 3
	jge	SHORT $LN15@fnDetermin

; 3431 :             {
; 3432 :                nCounter++;

	mov	ax, WORD PTR _nCounter$[ebp]
	add	ax, 1
	mov	WORD PTR _nCounter$[ebp], ax

; 3433 :                cpcEditString++;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 3434 :             }

	jmp	SHORT $LN12@fnDetermin
$LN15@fnDetermin:

; 3435 : 
; 3436 :             while ( *cpcEditString == '9' )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 57					; 00000039H
	jne	SHORT $LN16@fnDetermin

; 3437 :                cpcEditString++;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx
	jmp	SHORT $LN15@fnDetermin
$LN16@fnDetermin:

; 3438 : 
; 3439 :             break;

	jmp	SHORT $LN20@fnDetermin
$LN64@fnDetermin:

; 3440 :          }
; 3441 : 
; 3442 :          case '\"':  // quote
; 3443 :          case '\'':  // aposthorpe
; 3444 :             chDelimiter = *cpcEditString++;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _chDelimiter$[ebp], al
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 3445 :             break;

	jmp	SHORT $LN20@fnDetermin
$LN65@fnDetermin:

; 3446 : 
; 3447 :          case '(':   // left paren
; 3448 :          case ')':   // right paren
; 3449 :          case ':':   // colon
; 3450 :          case ',':   // comma
; 3451 :          case '-':   // dash
; 3452 :          case '/':   // slash
; 3453 :          case '.':   // period
; 3454 :          case ' ':   // space
; 3455 :             nCounter++;

	mov	dx, WORD PTR _nCounter$[ebp]
	add	dx, 1
	mov	WORD PTR _nCounter$[ebp], dx

; 3456 :             cpcEditString++;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 3457 :             break;

	jmp	SHORT $LN20@fnDetermin
$LN66@fnDetermin:

; 3458 : 
; 3459 :          default:
; 3460 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnDetermin
$LN20@fnDetermin:

; 3461 : 
; 3462 :       }
; 3463 :    }

	jmp	$LN2@fnDetermin
$LN3@fnDetermin:

; 3464 : 
; 3465 :    return( nCounter );

	mov	ax, WORD PTR _nCounter$[ebp]
$LN1@fnDetermin:

; 3466 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN71@fnDetermin:
	DD	$LN65@fnDetermin
	DD	$LN64@fnDetermin
	DD	$LN63@fnDetermin
	DD	$LN23@fnDetermin
	DD	$LN30@fnDetermin
	DD	$LN39@fnDetermin
	DD	$LN44@fnDetermin
	DD	$LN55@fnDetermin
	DD	$LN58@fnDetermin
	DD	$LN41@fnDetermin
	DD	$LN46@fnDetermin
	DD	$LN66@fnDetermin
$LN70@fnDetermin:
	DB	0
	DB	11					; 0000000bH
	DB	1
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	1
	DB	0
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	0
	DB	0
	DB	0
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	2
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	3
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	5
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	6
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	3
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	7
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	8
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	9
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
_fnDetermineDateTimeStrlen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_cpcDateTime$ = 8					; size = 4
_UfGetWeekOfYear@4 PROC

; 1999 : {

	push	ebp
	mov	ebp, esp

; 2000 :    return( ((UfGetDayOfYear( cpcDateTime ) - 1) / 7 ) + 1 );

	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	push	eax
	call	_UfGetDayOfYear@4
	sub	eax, 1
	cdq
	mov	ecx, 7
	idiv	ecx
	add	eax, 1

; 2001 : }

	pop	ebp
	ret	4
_UfGetWeekOfYear@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_lDOY$ = -40						; size = 4
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_nDay$ = -24						; size = 2
_nYear$ = -20						; size = 2
_nMonth$ = -16						; size = 2
_sz$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_cpcDateTime$ = 8					; size = 4
_UfGetDayOfYear@4 PROC

; 1942 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1943 :    zSHORT   nMonth;
; 1944 :    zSHORT   nDay;
; 1945 :    zSHORT   nYear;
; 1946 :    zLONG    lDOY;
; 1947 : 
; 1948 :    zCHAR    sz[ 5 ];
; 1949 : 
; 1950 :    // year
; 1951 :    zstrncpy( sz, cpcDateTime, 4 );

	push	4
	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 1952 :    sz[ 4 ] = 0;

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 5
	jae	SHORT $LN9@UfGetDayOf
	jmp	SHORT $LN10@UfGetDayOf
$LN9@UfGetDayOf:
	call	___report_rangecheckfailure
$LN10@UfGetDayOf:
	mov	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR _sz$[ebp+eax], 0

; 1953 :    nYear = (zSHORT) zatol( sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nYear$[ebp], ax

; 1954 : 
; 1955 :    // month
; 1956 :    sz[ 0 ] = *(cpcDateTime + 4);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR _sz$[ebp+eax], dl

; 1957 :    sz[ 1 ] = *(cpcDateTime + 5);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR _sz$[ebp+eax], dl

; 1958 :    sz[ 2 ] = 0;

	mov	eax, 1
	shl	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 5
	jae	SHORT $LN11@UfGetDayOf
	jmp	SHORT $LN12@UfGetDayOf
$LN11@UfGetDayOf:
	call	___report_rangecheckfailure
$LN12@UfGetDayOf:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _sz$[ebp+ecx], 0

; 1959 :    nMonth = (zSHORT) zatol( sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nMonth$[ebp], ax

; 1960 :    if ( nMonth < 1 )

	movsx	eax, WORD PTR _nMonth$[ebp]
	cmp	eax, 1
	jge	SHORT $LN2@UfGetDayOf

; 1961 :       nMonth = 1;

	mov	ecx, 1
	mov	WORD PTR _nMonth$[ebp], cx
	jmp	SHORT $LN3@UfGetDayOf
$LN2@UfGetDayOf:

; 1962 :    else
; 1963 :    if ( nMonth > 12 )

	movsx	edx, WORD PTR _nMonth$[ebp]
	cmp	edx, 12					; 0000000cH
	jle	SHORT $LN3@UfGetDayOf

; 1964 :       nMonth = 12;

	mov	eax, 12					; 0000000cH
	mov	WORD PTR _nMonth$[ebp], ax
$LN3@UfGetDayOf:

; 1965 : 
; 1966 :    // day
; 1967 :    sz[ 0 ] = *(cpcDateTime + 6);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	mov	cl, BYTE PTR [eax+6]
	mov	BYTE PTR _sz$[ebp+edx], cl

; 1968 :    sz[ 1 ] = *(cpcDateTime + 7);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	mov	cl, BYTE PTR [eax+7]
	mov	BYTE PTR _sz$[ebp+edx], cl

; 1969 :    sz[ 2 ] = 0;

	mov	edx, 1
	shl	edx, 1
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 5
	jae	SHORT $LN13@UfGetDayOf
	jmp	SHORT $LN14@UfGetDayOf
$LN13@UfGetDayOf:
	call	___report_rangecheckfailure
$LN14@UfGetDayOf:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _sz$[ebp+eax], 0

; 1970 :    nDay = (zSHORT) zatol( sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nDay$[ebp], ax

; 1971 : 
; 1972 :    if ( (nYear % 4) == 0 &&

	movsx	edx, WORD PTR _nYear$[ebp]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN15@UfGetDayOf
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN15@UfGetDayOf:
	test	edx, edx
	jne	SHORT $LN5@UfGetDayOf
	movsx	eax, WORD PTR _nYear$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN7@UfGetDayOf
	movsx	eax, WORD PTR _nYear$[ebp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN5@UfGetDayOf
$LN7@UfGetDayOf:

; 1973 :          ((nYear % 100) || (nYear % 400) == 0) )
; 1974 :    {
; 1975 :       lDOY = (zLONG) usLeapDayTable[ nMonth - 1 ] + nDay;

	movsx	edx, WORD PTR _nMonth$[ebp]
	movzx	eax, WORD PTR _usLeapDayTable[edx*2-2]
	movsx	ecx, WORD PTR _nDay$[ebp]
	add	eax, ecx
	mov	DWORD PTR _lDOY$[ebp], eax

; 1976 :    }

	jmp	SHORT $LN6@UfGetDayOf
$LN5@UfGetDayOf:

; 1977 :    else
; 1978 :       lDOY = (zLONG) usDayTable[ nMonth - 1 ] + nDay;

	movsx	edx, WORD PTR _nMonth$[ebp]
	movzx	eax, WORD PTR _usDayTable[edx*2-2]
	movsx	ecx, WORD PTR _nDay$[ebp]
	add	eax, ecx
	mov	DWORD PTR _lDOY$[ebp], eax
$LN6@UfGetDayOf:

; 1979 : 
; 1980 :    return( lDOY );

	mov	eax, DWORD PTR _lDOY$[ebp]
$LN8@UfGetDayOf:

; 1981 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_UfGetDayOfYear@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_nDay$ = -28						; size = 2
_nMonth$ = -24						; size = 2
_lDOW$ = -20						; size = 4
_nYear$ = -16						; size = 2
_sz$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
_cpcDateTime$ = 8					; size = 4
_UfGetDayOfWeek@4 PROC

; 1887 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 1888 :    zSHORT   nMonth;
; 1889 :    zSHORT   nDay;
; 1890 :    zSHORT   nYear;
; 1891 :    zLONG    lDOW;
; 1892 : 
; 1893 :    zCHAR    sz[ 5 ];
; 1894 : 
; 1895 :    // year
; 1896 :    zstrncpy( sz, cpcDateTime, 4 );

	push	4
	mov	eax, DWORD PTR _cpcDateTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 1897 :    sz[ 4 ] = 0;

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T3[ebp], edx
	cmp	DWORD PTR $T3[ebp], 5
	jae	SHORT $LN7@UfGetDayOf
	jmp	SHORT $LN8@UfGetDayOf
$LN7@UfGetDayOf:
	call	___report_rangecheckfailure
$LN8@UfGetDayOf:
	mov	eax, DWORD PTR $T3[ebp]
	mov	BYTE PTR _sz$[ebp+eax], 0

; 1898 :    nYear = (zSHORT) zatol( sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nYear$[ebp], ax

; 1899 : 
; 1900 :    // month
; 1901 :    sz[ 0 ] = *(cpcDateTime + 4);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR _sz$[ebp+eax], dl

; 1902 :    sz[ 1 ] = *(cpcDateTime + 5);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cpcDateTime$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR _sz$[ebp+eax], dl

; 1903 :    sz[ 2 ] = 0;

	mov	eax, 1
	shl	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 5
	jae	SHORT $LN9@UfGetDayOf
	jmp	SHORT $LN10@UfGetDayOf
$LN9@UfGetDayOf:
	call	___report_rangecheckfailure
$LN10@UfGetDayOf:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _sz$[ebp+ecx], 0

; 1904 :    nMonth = (zSHORT) zatol( sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nMonth$[ebp], ax

; 1905 : 
; 1906 :    // day
; 1907 :    sz[ 0 ] = *(cpcDateTime + 6);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	mov	al, BYTE PTR [edx+6]
	mov	BYTE PTR _sz$[ebp+ecx], al

; 1908 :    sz[ 1 ] = *(cpcDateTime + 7);

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cpcDateTime$[ebp]
	mov	al, BYTE PTR [edx+7]
	mov	BYTE PTR _sz$[ebp+ecx], al

; 1909 :    sz[ 2 ] = 0;

	mov	ecx, 1
	shl	ecx, 1
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 5
	jae	SHORT $LN11@UfGetDayOf
	jmp	SHORT $LN12@UfGetDayOf
$LN11@UfGetDayOf:
	call	___report_rangecheckfailure
$LN12@UfGetDayOf:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _sz$[ebp+edx], 0

; 1910 :    nDay = (zSHORT) zatol( sz );

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nDay$[ebp], ax

; 1911 : 
; 1912 :    lDOW = nDay + cMonth_Val[ nMonth - 1 ];

	movsx	ecx, WORD PTR _nDay$[ebp]
	movsx	edx, WORD PTR _nMonth$[ebp]
	movsx	eax, BYTE PTR _cMonth_Val[edx-1]
	add	ecx, eax
	mov	DWORD PTR _lDOW$[ebp], ecx

; 1913 : 
; 1914 :    if ( nMonth < 3 )

	movsx	ecx, WORD PTR _nMonth$[ebp]
	cmp	ecx, 3
	jge	SHORT $LN2@UfGetDayOf

; 1915 :    {
; 1916 :       if ( !(nYear % 4) && (nYear % 100) || !(nYear % 400) )

	movsx	edx, WORD PTR _nYear$[ebp]
	and	edx, -2147483645			; 80000003H
	jns	SHORT $LN13@UfGetDayOf
	dec	edx
	or	edx, -4					; fffffffcH
	inc	edx
$LN13@UfGetDayOf:
	test	edx, edx
	jne	SHORT $LN5@UfGetDayOf
	movsx	eax, WORD PTR _nYear$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN4@UfGetDayOf
$LN5@UfGetDayOf:
	movsx	eax, WORD PTR _nYear$[ebp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN2@UfGetDayOf
$LN4@UfGetDayOf:

; 1917 :          lDOW--;

	mov	edx, DWORD PTR _lDOW$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lDOW$[ebp], edx
$LN2@UfGetDayOf:

; 1918 :    }
; 1919 : 
; 1920 :    lDOW += nYear + ( nYear / 4 );

	movsx	ecx, WORD PTR _nYear$[ebp]
	movsx	eax, WORD PTR _nYear$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	add	eax, DWORD PTR _lDOW$[ebp]
	add	eax, ecx
	mov	DWORD PTR _lDOW$[ebp], eax

; 1921 :    lDOW += (nYear / 400) - (nYear / 100);

	movsx	eax, WORD PTR _nYear$[ebp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	mov	ecx, eax
	movsx	eax, WORD PTR _nYear$[ebp]
	cdq
	mov	esi, 100				; 00000064H
	idiv	esi
	sub	ecx, eax
	add	ecx, DWORD PTR _lDOW$[ebp]
	mov	DWORD PTR _lDOW$[ebp], ecx

; 1922 :    lDOW %= 7;

	mov	eax, DWORD PTR _lDOW$[ebp]
	cdq
	mov	ecx, 7
	idiv	ecx
	mov	DWORD PTR _lDOW$[ebp], edx

; 1923 :    return( lDOW );

	mov	eax, DWORD PTR _lDOW$[ebp]
$LN6@UfGetDayOf:

; 1924 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_UfGetDayOfWeek@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
$T1 = -48						; size = 4
_usDay$ = -44						; size = 2
_ulYear$ = -40						; size = 4
_DT_Rec$ = -36						; size = 6
_ulWorkYear$ = -28					; size = 4
_sz$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_cpcJulian$ = 8						; size = 4
_pchGregorian$ = 12					; size = 4
_UfJulianToGregorian@8 PROC

; 2145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2146 :    zULONG                  ulYear;
; 2147 :    zULONG                  ulWorkYear;
; 2148 :    zUSHORT                 usDay;
; 2149 :    DateTimeInternalRecord  DT_Rec;
; 2150 :    zCHAR                   sz[ 18 ];
; 2151 : 
; 2152 :    // Get Day Value
; 2153 :    zstrcpy( sz, (zPCHAR) (cpcJulian + 4) );

	mov	eax, DWORD PTR _cpcJulian$[ebp]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 2154 :    usDay = (zUSHORT) zatol( sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _usDay$[ebp], ax

; 2155 : 
; 2156 :    // Get Year Value
; 2157 :    zstrncpy( sz, cpcJulian, 4 );

	push	4
	mov	eax, DWORD PTR _cpcJulian$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 2158 :    sz[ 4 ] = 0;

	mov	edx, 1
	shl	edx, 2
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 18			; 00000012H
	jae	SHORT $LN12@UfJulianTo
	jmp	SHORT $LN13@UfJulianTo
$LN12@UfJulianTo:
	call	___report_rangecheckfailure
$LN13@UfJulianTo:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _sz$[ebp+eax], 0

; 2159 :    ulYear = (zULONG) zatol( sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulYear$[ebp], eax

; 2160 :    if ( ulYear == 0 )

	cmp	DWORD PTR _ulYear$[ebp], 0
	jne	SHORT $LN4@UfJulianTo

; 2161 :       ulYear = 1900;

	mov	DWORD PTR _ulYear$[ebp], 1900		; 0000076cH
$LN4@UfJulianTo:

; 2162 : 
; 2163 :    /* Calculate Year in Minutes */
; 2164 :    ulWorkYear = 0;

	mov	DWORD PTR _ulWorkYear$[ebp], 0

; 2165 :    DT_Rec.ulDateMinutes = 0;

	mov	DWORD PTR _DT_Rec$[ebp], 0

; 2166 :    DT_Rec.usTSeconds = 0;

	xor	edx, edx
	mov	WORD PTR _DT_Rec$[ebp+4], dx

; 2167 : 
; 2168 :    // Fast path for dates starting Jan 1, 1900.
; 2169 :    // Start point set to beginning of century.
; 2170 :    if ( ulYear >= 1900L )

	cmp	DWORD PTR _ulYear$[ebp], 1900		; 0000076cH
	jb	SHORT $LN2@UfJulianTo

; 2171 :    {
; 2172 :       ulWorkYear = 1900L;

	mov	DWORD PTR _ulWorkYear$[ebp], 1900	; 0000076cH

; 2173 :       DT_Rec.ulDateMinutes = Year1900;

	mov	DWORD PTR _DT_Rec$[ebp], 999303840	; 3b902aa0H

; 2174 :       if ( ulYear >= 2000L )

	cmp	DWORD PTR _ulYear$[ebp], 2000		; 000007d0H
	jb	SHORT $LN2@UfJulianTo

; 2175 :       {
; 2176 :          ulWorkYear = 2000L;

	mov	DWORD PTR _ulWorkYear$[ebp], 2000	; 000007d0H

; 2177 :          DT_Rec.ulDateMinutes += Century;

	mov	eax, DWORD PTR _DT_Rec$[ebp]
	add	eax, 52594560				; 03228780H
	mov	DWORD PTR _DT_Rec$[ebp], eax
$LN2@UfJulianTo:

; 2178 :       }
; 2179 :    }
; 2180 : 
; 2181 :    // This will get us to Jan 1, of the desired year.
; 2182 :    // This will take a bit longer when the year is less than 1900.
; 2183 :    while ( ulWorkYear < ulYear )

	mov	ecx, DWORD PTR _ulWorkYear$[ebp]
	cmp	ecx, DWORD PTR _ulYear$[ebp]
	jae	SHORT $LN3@UfJulianTo

; 2184 :    {
; 2185 :       if ( (ulWorkYear % 4) == 0 &&

	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN7@UfJulianTo
	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	test	edx, edx
	jne	SHORT $LN9@UfJulianTo
	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 400				; 00000190H
	div	ecx
	test	edx, edx
	jne	SHORT $LN7@UfJulianTo
$LN9@UfJulianTo:

; 2186 :            ((ulWorkYear % 100) || (ulWorkYear % 400) == 0) )
; 2187 :       {
; 2188 :          DT_Rec.ulDateMinutes += LeapYear;

	mov	edx, DWORD PTR _DT_Rec$[ebp]
	add	edx, 527040				; 00080ac0H
	mov	DWORD PTR _DT_Rec$[ebp], edx

; 2189 :       }

	jmp	SHORT $LN8@UfJulianTo
$LN7@UfJulianTo:

; 2190 :       else
; 2191 :       {
; 2192 :          DT_Rec.ulDateMinutes += Year;

	mov	eax, DWORD PTR _DT_Rec$[ebp]
	add	eax, 525600				; 00080520H
	mov	DWORD PTR _DT_Rec$[ebp], eax
$LN8@UfJulianTo:

; 2193 :       }
; 2194 :       ulWorkYear++;

	mov	ecx, DWORD PTR _ulWorkYear$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ulWorkYear$[ebp], ecx

; 2195 :    }

	jmp	SHORT $LN2@UfJulianTo
$LN3@UfJulianTo:

; 2196 : 
; 2197 :    // add julian day count
; 2198 :    DT_Rec.ulDateMinutes += (zULONG) (usDay * (Day - 1));

	movzx	edx, WORD PTR _usDay$[ebp]
	imul	eax, edx, 1439
	add	eax, DWORD PTR _DT_Rec$[ebp]
	mov	DWORD PTR _DT_Rec$[ebp], eax

; 2199 : 
; 2200 :    if ( UfDateTimeToString( (LPDATETIME) &DT_Rec, sz, 9 ) == zCALL_ERROR )

	push	9
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	lea	edx, DWORD PTR _DT_Rec$[ebp]
	push	edx
	call	_UfDateTimeToString@12
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN10@UfJulianTo

; 2201 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN11@UfJulianTo
$LN10@UfJulianTo:

; 2202 : 
; 2203 :    zstrcpy( pchGregorian, sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchGregorian$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 2204 : 
; 2205 :    return( 0 );

	xor	eax, eax
$LN11@UfJulianTo:

; 2206 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_UfJulianToGregorian@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_dt$ = -84						; size = 6
_dt1$ = -76						; size = 6
_dt2$ = -68						; size = 6
_lD1$ = -60						; size = 4
_lD2$ = -56						; size = 4
_lM1$ = -52						; size = 4
_lM2$ = -48						; size = 4
tv154 = -44						; size = 4
tv93 = -40						; size = 4
_lY1$ = -36						; size = 4
_lY2$ = -32						; size = 4
_ulDiffHi$ = -28					; size = 4
_lDiff$ = -24						; size = 4
_lpDT2$ = -20						; size = 4
_lpDT1$ = -16						; size = 4
_usDiffLo$ = -12					; size = 2
_nRC$ = -8						; size = 2
_bNegative$ = -2					; size = 1
_bOverflow$ = -1					; size = 1
_plDiff$ = 8						; size = 4
_lpDateTime1$ = 12					; size = 4
_lpDateTime2$ = 16					; size = 4
_nDiffType$ = 20					; size = 2
_UfDateTimeDiff@16 PROC

; 2774 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi

; 2775 :    zSHORT               nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 2776 :    zUSHORT              usDiffLo;
; 2777 :    zULONG               ulDiffHi;
; 2778 :    zLONG                lDiff;
; 2779 :    zLONG                lY1, lY2, lM1, lM2, lD1, lD2;
; 2780 :    LPDTINTERNAL         lpDT1, lpDT2;
; 2781 :    DateTimeInternalRecord  dt, dt1, dt2;
; 2782 :    zBOOL                bNegative;
; 2783 :    zBOOL                bOverflow = FALSE;

	mov	BYTE PTR _bOverflow$[ebp], 0

; 2784 : 
; 2785 :    *plDiff = 0;

	mov	ecx, DWORD PTR _plDiff$[ebp]
	mov	DWORD PTR [ecx], 0

; 2786 :    memcpy( &dt1, lpDateTime1, sizeof(DateTimeInternalRecord) );

	push	6
	mov	edx, DWORD PTR _lpDateTime1$[ebp]
	push	edx
	lea	eax, DWORD PTR _dt1$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2787 :    memcpy( &dt2, lpDateTime2, sizeof(DateTimeInternalRecord) );

	push	6
	mov	ecx, DWORD PTR _lpDateTime2$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dt2$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2788 :    lpDT1 = &dt1;

	lea	eax, DWORD PTR _dt1$[ebp]
	mov	DWORD PTR _lpDT1$[ebp], eax

; 2789 :    lpDT2 = &dt2;

	lea	ecx, DWORD PTR _dt2$[ebp]
	mov	DWORD PTR _lpDT2$[ebp], ecx

; 2790 : 
; 2791 :    // For Year, Month or Date
; 2792 :    if ( nDiffType == zDT_YEAR ||
; 2793 :         nDiffType == zDT_MONTH ||

	movsx	edx, WORD PTR _nDiffType$[ebp]
	test	edx, edx
	je	SHORT $LN8@UfDateTime
	movsx	eax, WORD PTR _nDiffType$[ebp]
	cmp	eax, 1
	je	SHORT $LN8@UfDateTime
	movsx	ecx, WORD PTR _nDiffType$[ebp]
	cmp	ecx, 2
	jne	SHORT $LN7@UfDateTime
$LN8@UfDateTime:

; 2794 :         nDiffType == zDT_DAY )
; 2795 :    {
; 2796 :      // use only the date part of the timestamp
; 2797 :      lpDT1->usTSeconds = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpDT1$[ebp]
	mov	WORD PTR [eax+4], dx

; 2798 :      lpDT2->usTSeconds = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _lpDT2$[ebp]
	mov	WORD PTR [edx+4], cx

; 2799 :      ulDiffHi = lpDT1->ulDateMinutes % Day;

	mov	eax, DWORD PTR _lpDT1$[ebp]
	mov	eax, DWORD PTR [eax]
	xor	edx, edx
	mov	ecx, 1440				; 000005a0H
	div	ecx
	mov	DWORD PTR _ulDiffHi$[ebp], edx

; 2800 :      lpDT1->ulDateMinutes -= ulDiffHi;

	mov	edx, DWORD PTR _lpDT1$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _ulDiffHi$[ebp]
	mov	ecx, DWORD PTR _lpDT1$[ebp]
	mov	DWORD PTR [ecx], eax

; 2801 :      ulDiffHi = lpDT2->ulDateMinutes % Day;

	mov	edx, DWORD PTR _lpDT2$[ebp]
	mov	eax, DWORD PTR [edx]
	xor	edx, edx
	mov	ecx, 1440				; 000005a0H
	div	ecx
	mov	DWORD PTR _ulDiffHi$[ebp], edx

; 2802 :      lpDT2->ulDateMinutes -= ulDiffHi;

	mov	edx, DWORD PTR _lpDT2$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _ulDiffHi$[ebp]
	mov	ecx, DWORD PTR _lpDT2$[ebp]
	mov	DWORD PTR [ecx], eax
$LN7@UfDateTime:

; 2803 :    }
; 2804 : 
; 2805 :    // determine the sign of the difference
; 2806 :    nRC = fnCompareDateTimeToDateTime( &dt1, &dt2 );

	lea	edx, DWORD PTR _dt2$[ebp]
	push	edx
	lea	eax, DWORD PTR _dt1$[ebp]
	push	eax
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2807 :    bNegative = (nRC > 0);

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN27@UfDateTime
	mov	DWORD PTR tv93[ebp], 1
	jmp	SHORT $LN28@UfDateTime
$LN27@UfDateTime:
	mov	DWORD PTR tv93[ebp], 0
$LN28@UfDateTime:
	mov	dl, BYTE PTR tv93[ebp]
	mov	BYTE PTR _bNegative$[ebp], dl

; 2808 : 
; 2809 :    // shortcut for equal values.
; 2810 :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN9@UfDateTime

; 2811 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@UfDateTime
$LN9@UfDateTime:

; 2812 : 
; 2813 :    // If negative, exchange the two date time values.
; 2814 :    if ( bNegative )

	movzx	ecx, BYTE PTR _bNegative$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@UfDateTime

; 2815 :    {
; 2816 :      lpDT1 = &dt2;

	lea	edx, DWORD PTR _dt2$[ebp]
	mov	DWORD PTR _lpDT1$[ebp], edx

; 2817 :      lpDT2 = &dt1;

	lea	eax, DWORD PTR _dt1$[ebp]
	mov	DWORD PTR _lpDT2$[ebp], eax
$LN10@UfDateTime:

; 2818 :    }
; 2819 : 
; 2820 :    // calculate the difference with carry bit
; 2821 :    ulDiffHi = lpDT2->ulDateMinutes - lpDT1->ulDateMinutes;

	mov	ecx, DWORD PTR _lpDT2$[ebp]
	mov	edx, DWORD PTR _lpDT1$[ebp]
	mov	eax, DWORD PTR [ecx]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR _ulDiffHi$[ebp], eax

; 2822 :    if ( lpDT1->usTSeconds > lpDT2->usTSeconds )

	mov	ecx, DWORD PTR _lpDT1$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _lpDT2$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	cmp	edx, ecx
	jle	SHORT $LN11@UfDateTime

; 2823 :    {
; 2824 :      ulDiffHi--;

	mov	edx, DWORD PTR _ulDiffHi$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulDiffHi$[ebp], edx

; 2825 :      usDiffLo = (zUSHORT) (lpDT2->usTSeconds - lpDT1->usTSeconds + 60000);

	mov	eax, DWORD PTR _lpDT2$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	mov	edx, DWORD PTR _lpDT1$[ebp]
	movzx	eax, WORD PTR [edx+4]
	sub	ecx, eax
	add	ecx, 60000				; 0000ea60H
	mov	WORD PTR _usDiffLo$[ebp], cx

; 2826 :    }

	jmp	SHORT $LN12@UfDateTime
$LN11@UfDateTime:

; 2827 :    else
; 2828 :    {
; 2829 :      usDiffLo = lpDT2->usTSeconds - lpDT1->usTSeconds;

	mov	ecx, DWORD PTR _lpDT2$[ebp]
	movzx	edx, WORD PTR [ecx+4]
	mov	eax, DWORD PTR _lpDT1$[ebp]
	movzx	ecx, WORD PTR [eax+4]
	sub	edx, ecx
	mov	WORD PTR _usDiffLo$[ebp], dx
$LN12@UfDateTime:

; 2830 :    }
; 2831 : 
; 2832 :    switch ( nDiffType )

	movsx	edx, WORD PTR _nDiffType$[ebp]
	mov	DWORD PTR tv154[ebp], edx
	cmp	DWORD PTR tv154[ebp], 5
	ja	$LN23@UfDateTime
	mov	eax, DWORD PTR tv154[ebp]
	jmp	DWORD PTR $LN29@UfDateTime[eax*4]
$LN13@UfDateTime:

; 2833 :    {
; 2834 :       case zDT_YEAR:
; 2835 :          // calculate the difference of the year number
; 2836 :          lY1 = fnGetDateTimeComponent( (LPDATETIME)lpDT1, zDT_YEAR );

	push	0
	mov	ecx, DWORD PTR _lpDT1$[ebp]
	push	ecx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lY1$[ebp], eax

; 2837 :          lY2 = fnGetDateTimeComponent( (LPDATETIME)lpDT2, zDT_YEAR );

	push	0
	mov	edx, DWORD PTR _lpDT2$[ebp]
	push	edx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lY2$[ebp], eax

; 2838 :          lDiff = lY2 - lY1;

	mov	eax, DWORD PTR _lY2$[ebp]
	sub	eax, DWORD PTR _lY1$[ebp]
	mov	DWORD PTR _lDiff$[ebp], eax

; 2839 : 
; 2840 :          // check for carry (e.g. "19970101" - "19961231" has lDiff=1
; 2841 :          // and has to be corrected!)
; 2842 :          UfAddToDateTime( (LPDATETIME)lpDT1, lDiff, zDT_YEAR);

	push	0
	mov	ecx, DWORD PTR _lDiff$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpDT1$[ebp]
	push	edx
	call	_UfAddToDateTime@12

; 2843 :          if ( fnCompareDateTimeToDateTime( lpDT1, lpDT2 ) == 1 )

	mov	eax, DWORD PTR _lpDT2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDT1$[ebp]
	push	ecx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	movsx	edx, ax
	cmp	edx, 1
	jne	SHORT $LN14@UfDateTime

; 2844 :          {
; 2845 :            lDiff--;

	mov	eax, DWORD PTR _lDiff$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lDiff$[ebp], eax
$LN14@UfDateTime:

; 2846 :          }
; 2847 : 
; 2848 :          break;

	jmp	$LN2@UfDateTime
$LN15@UfDateTime:

; 2849 : 
; 2850 :       case zDT_MONTH:
; 2851 :          // get the days for additional carry, then set it 0 for calculation
; 2852 :          lD1 = fnGetDateTimeComponent( (LPDATETIME)lpDT1, zDT_DAY );

	push	2
	mov	ecx, DWORD PTR _lpDT1$[ebp]
	push	ecx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lD1$[ebp], eax

; 2853 :          lD2 = fnGetDateTimeComponent( (LPDATETIME)lpDT2, zDT_DAY );

	push	2
	mov	edx, DWORD PTR _lpDT2$[ebp]
	push	edx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lD2$[ebp], eax

; 2854 :          fnSetDateTimeComponent( (LPDATETIME)lpDT1, zDT_DAY, 0L );

	push	0
	push	2
	mov	eax, DWORD PTR _lpDT1$[ebp]
	push	eax
	call	_fnSetDateTimeComponent
	add	esp, 12					; 0000000cH

; 2855 :          fnSetDateTimeComponent( (LPDATETIME)lpDT2, zDT_DAY, 0L );

	push	0
	push	2
	mov	ecx, DWORD PTR _lpDT2$[ebp]
	push	ecx
	call	_fnSetDateTimeComponent
	add	esp, 12					; 0000000cH

; 2856 : 
; 2857 :          // calculate the difference of the years and the months
; 2858 :          lY1 = fnGetDateTimeComponent( (LPDATETIME)lpDT1, zDT_YEAR );

	push	0
	mov	edx, DWORD PTR _lpDT1$[ebp]
	push	edx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lY1$[ebp], eax

; 2859 :          lY2 = fnGetDateTimeComponent( (LPDATETIME)lpDT2, zDT_YEAR );

	push	0
	mov	eax, DWORD PTR _lpDT2$[ebp]
	push	eax
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lY2$[ebp], eax

; 2860 :          lM1 = fnGetDateTimeComponent( (LPDATETIME)lpDT1, zDT_MONTH );

	push	1
	mov	ecx, DWORD PTR _lpDT1$[ebp]
	push	ecx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lM1$[ebp], eax

; 2861 :          lM2 = fnGetDateTimeComponent( (LPDATETIME)lpDT2, zDT_MONTH );

	push	1
	mov	edx, DWORD PTR _lpDT2$[ebp]
	push	edx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lM2$[ebp], eax

; 2862 :          lDiff = (lY2 - lY1) * 12 + lM2 - lM1;

	mov	eax, DWORD PTR _lY2$[ebp]
	sub	eax, DWORD PTR _lY1$[ebp]
	imul	ecx, eax, 12
	add	ecx, DWORD PTR _lM2$[ebp]
	sub	ecx, DWORD PTR _lM1$[ebp]
	mov	DWORD PTR _lDiff$[ebp], ecx
$LN6@UfDateTime:

; 2863 : 
; 2864 :          // check for carry caused by leap year (has to be corrected!)
; 2865 :          do
; 2866 :          {
; 2867 :            memcpy( &dt, lpDT1, sizeof(DateTimeInternalRecord) );

	push	6
	mov	edx, DWORD PTR _lpDT1$[ebp]
	push	edx
	lea	eax, DWORD PTR _dt$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2868 :            UfAddToDateTime( (LPDATETIME)&dt, lDiff, zDT_MONTH);

	push	1
	mov	ecx, DWORD PTR _lDiff$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dt$[ebp]
	push	edx
	call	_UfAddToDateTime@12

; 2869 :            nRC = fnCompareDateTimeToDateTime( &dt, lpDT2 );

	mov	eax, DWORD PTR _lpDT2$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dt$[ebp]
	push	ecx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2870 : 
; 2871 :            lDiff += nRC;

	movsx	edx, WORD PTR _nRC$[ebp]
	add	edx, DWORD PTR _lDiff$[ebp]
	mov	DWORD PTR _lDiff$[ebp], edx

; 2872 : 
; 2873 :          } while ( nRC );

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN6@UfDateTime

; 2874 : 
; 2875 :          // check for carry caused by difference in days (and correct it)
; 2876 :          if ( lD2 < lD1 )

	mov	ecx, DWORD PTR _lD2$[ebp]
	cmp	ecx, DWORD PTR _lD1$[ebp]
	jge	SHORT $LN16@UfDateTime

; 2877 :            lDiff--;

	mov	edx, DWORD PTR _lDiff$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lDiff$[ebp], edx
$LN16@UfDateTime:

; 2878 : 
; 2879 :          break;

	jmp	SHORT $LN2@UfDateTime
$LN17@UfDateTime:

; 2880 : 
; 2881 :       case zDT_DAY:
; 2882 :          lDiff = (zLONG) (ulDiffHi / Day);

	mov	eax, DWORD PTR _ulDiffHi$[ebp]
	xor	edx, edx
	mov	ecx, 1440				; 000005a0H
	div	ecx
	mov	DWORD PTR _lDiff$[ebp], eax

; 2883 :          break;

	jmp	SHORT $LN2@UfDateTime
$LN18@UfDateTime:

; 2884 : 
; 2885 :       case zDT_HOUR:
; 2886 :          lDiff = (zLONG) (ulDiffHi / Hour);

	mov	eax, DWORD PTR _ulDiffHi$[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	DWORD PTR _lDiff$[ebp], eax

; 2887 :          break;

	jmp	SHORT $LN2@UfDateTime
$LN19@UfDateTime:

; 2888 : 
; 2889 :       case zDT_MINUTE:
; 2890 :          if (ulDiffHi > 0x7fffffff)

	cmp	DWORD PTR _ulDiffHi$[ebp], 2147483647	; 7fffffffH
	jbe	SHORT $LN20@UfDateTime

; 2891 :          {
; 2892 :            bOverflow = TRUE;

	mov	BYTE PTR _bOverflow$[ebp], 1

; 2893 :            break;

	jmp	SHORT $LN2@UfDateTime
$LN20@UfDateTime:

; 2894 :          }
; 2895 : 
; 2896 :          lDiff = (zLONG) ulDiffHi;

	mov	edx, DWORD PTR _ulDiffHi$[ebp]
	mov	DWORD PTR _lDiff$[ebp], edx

; 2897 :          break;

	jmp	SHORT $LN2@UfDateTime
$LN21@UfDateTime:

; 2898 : 
; 2899 :       case zDT_SECOND:
; 2900 :          if (ulDiffHi > (0x7fffffff / 60 - 1) )

	cmp	DWORD PTR _ulDiffHi$[ebp], 35791393	; 02222221H
	jbe	SHORT $LN22@UfDateTime

; 2901 :          {
; 2902 :            bOverflow = TRUE;

	mov	BYTE PTR _bOverflow$[ebp], 1

; 2903 :            break;

	jmp	SHORT $LN2@UfDateTime
$LN22@UfDateTime:

; 2904 :          }
; 2905 : 
; 2906 :          lDiff = (zLONG) (ulDiffHi * 60 + usDiffLo / 1000);

	imul	ecx, DWORD PTR _ulDiffHi$[ebp], 60
	movzx	eax, WORD PTR _usDiffLo$[ebp]
	cdq
	mov	esi, 1000				; 000003e8H
	idiv	esi
	add	ecx, eax
	mov	DWORD PTR _lDiff$[ebp], ecx

; 2907 :          break;

	jmp	SHORT $LN2@UfDateTime
$LN23@UfDateTime:

; 2908 : 
; 2909 :       default:
; 2910 :          // "KZOEE023 - Invalid parameter, "
; 2911 :          fnSysMessageBox( 0, "Zeidon Error", "Invalid parameter", 0 );

	push	0
	push	OFFSET $SG14383
	push	OFFSET $SG14384
	push	0
	call	_fnSysMessageBox@16

; 2912 :       // fnIssueCoreError( 0, lpView, 8, 23, 0, "nDiffType", 0 );
; 2913 :       // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
; 2914 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@UfDateTime
$LN2@UfDateTime:

; 2915 :    }
; 2916 : 
; 2917 :    if ( bOverflow )

	movzx	edx, BYTE PTR _bOverflow$[ebp]
	test	edx, edx
	je	SHORT $LN24@UfDateTime

; 2918 :    {
; 2919 :    // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
; 2920 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@UfDateTime
$LN24@UfDateTime:

; 2921 :    }
; 2922 : 
; 2923 :    if ( bNegative )

	movzx	eax, BYTE PTR _bNegative$[ebp]
	test	eax, eax
	je	SHORT $LN25@UfDateTime

; 2924 :      lDiff *= -1;

	imul	ecx, DWORD PTR _lDiff$[ebp], -1
	mov	DWORD PTR _lDiff$[ebp], ecx
$LN25@UfDateTime:

; 2925 : 
; 2926 :    *plDiff = lDiff;

	mov	edx, DWORD PTR _plDiff$[ebp]
	mov	eax, DWORD PTR _lDiff$[ebp]
	mov	DWORD PTR [edx], eax

; 2927 :    return( 0 );

	xor	eax, eax
$LN1@UfDateTime:

; 2928 : 
; 2929 : } // UfDateTimeDiff

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN29@UfDateTime:
	DD	$LN13@UfDateTime
	DD	$LN15@UfDateTime
	DD	$LN17@UfDateTime
	DD	$LN18@UfDateTime
	DD	$LN19@UfDateTime
	DD	$LN21@UfDateTime
_UfDateTimeDiff@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_dt$ = -56						; size = 6
tv154 = -48						; size = 4
_lYM$ = -44						; size = 4
tv152 = -40						; size = 4
tv81 = -36						; size = 4
tv66 = -32						; size = 4
_ul$ = -28						; size = 4
_lM$ = -24						; size = 4
_lY$ = -20						; size = 4
_usDay$1 = -16						; size = 2
_un$ = -12						; size = 2
_nRC$ = -8						; size = 2
_bSubtract$ = -3					; size = 1
_bYadjust$ = -2						; size = 1
_bDone$ = -1						; size = 1
_lpDateTime$ = 8					; size = 4
_lAmount$ = 12						; size = 4
_nAmountType$ = 16					; size = 2
_UfAddToDateTime@12 PROC

; 2497 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2498 :    zLONG                   lYM;
; 2499 :    zULONG                  ul;
; 2500 :    zUSHORT                 un = 0;

	xor	eax, eax
	mov	WORD PTR _un$[ebp], ax

; 2501 :    zLONG                   lY, lM;
; 2502 :    DateTimeInternalRecord  dt;
; 2503 :    zBOOL                   bSubtract;
; 2504 :    zBOOL                   bYadjust = 0;

	mov	BYTE PTR _bYadjust$[ebp], 0

; 2505 :    zBOOL                   bDone = 0;

	mov	BYTE PTR _bDone$[ebp], 0

; 2506 :    zSHORT                  nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 2507 : 
; 2508 :    // DGC:TODO -- use view passed in to get current task.  Uncomment other uses
; 2509 :    // of lpCurrentTask
; 2510 :    //if ( (lpCurrentTask = fnOperationCall( iUfAddToDateTime, vTaskView )) == 0 )
; 2511 :    //   return( zCALL_ERROR );
; 2512 : 
; 2513 :    // If amount to add is zero, get out.
; 2514 :    if ( lAmount == 0 )

	cmp	DWORD PTR _lAmount$[ebp], 0
	jne	SHORT $LN4@UfAddToDat

; 2515 :    {
; 2516 :    // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
; 2517 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@UfAddToDat
$LN4@UfAddToDat:

; 2518 :    }
; 2519 : 
; 2520 :    // Establish if adding or subtracting...
; 2521 :    bSubtract = (lAmount < 0) ? 1 : 0;

	cmp	DWORD PTR _lAmount$[ebp], 0
	jge	SHORT $LN45@UfAddToDat
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN46@UfAddToDat
$LN45@UfAddToDat:
	mov	DWORD PTR tv66[ebp], 0
$LN46@UfAddToDat:
	mov	dl, BYTE PTR tv66[ebp]
	mov	BYTE PTR _bSubtract$[ebp], dl

; 2522 :    lAmount = labs( lAmount );

	mov	eax, DWORD PTR _lAmount$[ebp]
	push	eax
	call	_labs
	add	esp, 4
	mov	DWORD PTR _lAmount$[ebp], eax

; 2523 : 
; 2524 :    // For safety's sake, make a copy
; 2525 :    zmemcpy( (zPCHAR) &dt, (zPCHAR) lpDateTime, sizeof( DateTimeRecord ) );

	push	6
	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	push	ecx
	lea	edx, DWORD PTR _dt$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2526 : 
; 2527 :    // if date time is null set to 1-1-1 prior to 'add'
; 2528 :    if ( fnCompareDateTimeToDateTime( &stNullDateTime,
; 2529 :                                      &dt ) == 0 )

	lea	eax, DWORD PTR _dt$[ebp]
	push	eax
	push	OFFSET _stNullDateTime
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN5@UfAddToDat

; 2530 :       UfStringToDateTime( "00010101", (LPDATETIME) &dt );

	lea	edx, DWORD PTR _dt$[ebp]
	push	edx
	push	OFFSET $SG14253
	call	_UfStringToDateTime@8
$LN5@UfAddToDat:

; 2531 : 
; 2532 :    switch ( nAmountType )

	movsx	eax, WORD PTR _nAmountType$[ebp]
	mov	DWORD PTR tv81[ebp], eax
	cmp	DWORD PTR tv81[ebp], 5
	ja	$LN31@UfAddToDat
	mov	ecx, DWORD PTR tv81[ebp]
	jmp	DWORD PTR $LN51@UfAddToDat[ecx*4]
$LN6@UfAddToDat:

; 2533 :    {
; 2534 :       case zDT_YEAR:
; 2535 :          lY = fnGetDateTimeComponent( (LPDATETIME)&dt, zDT_YEAR );

	push	0
	lea	edx, DWORD PTR _dt$[ebp]
	push	edx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lY$[ebp], eax

; 2536 :          if ( bSubtract )

	movzx	eax, BYTE PTR _bSubtract$[ebp]
	test	eax, eax
	je	SHORT $LN7@UfAddToDat

; 2537 :          {
; 2538 :             lY -= lAmount;

	mov	ecx, DWORD PTR _lY$[ebp]
	sub	ecx, DWORD PTR _lAmount$[ebp]
	mov	DWORD PTR _lY$[ebp], ecx

; 2539 :             if ( lY < 1 )

	cmp	DWORD PTR _lY$[ebp], 1
	jge	SHORT $LN9@UfAddToDat

; 2540 :             {
; 2541 :                // underflow...
; 2542 :                // "KZOEE236 - Integer underflow"
; 2543 :                fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );

	push	0
	push	OFFSET $SG14258
	push	OFFSET $SG14259
	push	0
	call	_fnSysMessageBox@16

; 2544 :             // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
; 2545 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 2546 :                bDone = TRUE;

	mov	BYTE PTR _bDone$[ebp], 1
$LN9@UfAddToDat:

; 2547 :             }
; 2548 :          }

	jmp	SHORT $LN8@UfAddToDat
$LN7@UfAddToDat:

; 2549 :          else
; 2550 :          {
; 2551 :             lY += lAmount;

	mov	eax, DWORD PTR _lY$[ebp]
	add	eax, DWORD PTR _lAmount$[ebp]
	mov	DWORD PTR _lY$[ebp], eax

; 2552 :             if ( lY > 9999 )

	cmp	DWORD PTR _lY$[ebp], 9999		; 0000270fH
	jle	SHORT $LN8@UfAddToDat

; 2553 :             {
; 2554 :                // overflow...
; 2555 :                // "KZOEE235 - Integer overflow"
; 2556 :                fnSysMessageBox( 0, "Zeidon Error", "Year greater than 9999", 0 );

	push	0
	push	OFFSET $SG14261
	push	OFFSET $SG14262
	push	0
	call	_fnSysMessageBox@16

; 2557 :             // fnIssueCoreError( 0, lpView, 16, 235, 0, "Year greater than 9999", 0 );
; 2558 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 2559 :                bDone = TRUE;

	mov	BYTE PTR _bDone$[ebp], 1
$LN8@UfAddToDat:

; 2560 :             }
; 2561 :          }
; 2562 : 
; 2563 :          if ( nRC == 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jne	SHORT $LN11@UfAddToDat

; 2564 :          {
; 2565 :             nRC = fnSetDateTimeComponent( (LPDATETIME)&dt, zDT_YEAR, lY );

	mov	eax, DWORD PTR _lY$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _dt$[ebp]
	push	ecx
	call	_fnSetDateTimeComponent
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2566 :             bDone = TRUE;

	mov	BYTE PTR _bDone$[ebp], 1
$LN11@UfAddToDat:

; 2567 :          }
; 2568 :          break;

	jmp	$LN2@UfAddToDat
$LN12@UfAddToDat:

; 2569 : 
; 2570 :       case zDT_MONTH:
; 2571 :          lY = (zLONG) fnGetDateTimeComponent( (LPDATETIME)&dt, zDT_YEAR );

	push	0
	lea	edx, DWORD PTR _dt$[ebp]
	push	edx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lY$[ebp], eax

; 2572 :          lM = (zLONG) fnGetDateTimeComponent( (LPDATETIME)&dt, zDT_MONTH );

	push	1
	lea	eax, DWORD PTR _dt$[ebp]
	push	eax
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	DWORD PTR _lM$[ebp], eax

; 2573 :          if ( bSubtract )

	movzx	ecx, BYTE PTR _bSubtract$[ebp]
	test	ecx, ecx
	je	$LN13@UfAddToDat

; 2574 :          {
; 2575 :             if ( lM <= lAmount )

	mov	edx, DWORD PTR _lM$[ebp]
	cmp	edx, DWORD PTR _lAmount$[ebp]
	jg	$LN15@UfAddToDat

; 2576 :             {
; 2577 :                bYadjust = TRUE;

	mov	BYTE PTR _bYadjust$[ebp], 1

; 2578 :                lYM = (lY * 12) + lM - lAmount;

	imul	eax, DWORD PTR _lY$[ebp], 12
	add	eax, DWORD PTR _lM$[ebp]
	sub	eax, DWORD PTR _lAmount$[ebp]
	mov	DWORD PTR _lYM$[ebp], eax

; 2579 :                lM = lYM % 12;

	mov	eax, DWORD PTR _lYM$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR _lM$[ebp], edx

; 2580 :                lY = (lYM / 12) - ( !lM ? 1 : 0 );

	cmp	DWORD PTR _lM$[ebp], 0
	jne	SHORT $LN47@UfAddToDat
	mov	DWORD PTR tv152[ebp], 1
	jmp	SHORT $LN48@UfAddToDat
$LN47@UfAddToDat:
	mov	DWORD PTR tv152[ebp], 0
$LN48@UfAddToDat:
	cmp	DWORD PTR tv152[ebp], 0
	je	SHORT $LN49@UfAddToDat
	mov	DWORD PTR tv154[ebp], 1
	jmp	SHORT $LN50@UfAddToDat
$LN49@UfAddToDat:
	mov	DWORD PTR tv154[ebp], 0
$LN50@UfAddToDat:
	mov	eax, DWORD PTR _lYM$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	sub	eax, DWORD PTR tv154[ebp]
	mov	DWORD PTR _lY$[ebp], eax

; 2581 :                if ( lM == 0 )

	cmp	DWORD PTR _lM$[ebp], 0
	jne	SHORT $LN17@UfAddToDat

; 2582 :                   lM = 12;

	mov	DWORD PTR _lM$[ebp], 12			; 0000000cH
$LN17@UfAddToDat:

; 2583 : 
; 2584 :                if ( lY < 1 )

	cmp	DWORD PTR _lY$[ebp], 1
	jge	SHORT $LN18@UfAddToDat

; 2585 :                {
; 2586 :                   // underflow...
; 2587 :                   // "KZOEE236 - Integer underflow"
; 2588 :                   fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );

	push	0
	push	OFFSET $SG14271
	push	OFFSET $SG14272
	push	0
	call	_fnSysMessageBox@16

; 2589 :                // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
; 2590 :                   nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 2591 :                   bDone = TRUE;

	mov	BYTE PTR _bDone$[ebp], 1
$LN18@UfAddToDat:

; 2592 :                }
; 2593 :             }

	jmp	SHORT $LN16@UfAddToDat
$LN15@UfAddToDat:

; 2594 :             else
; 2595 :                lM -= lAmount;

	mov	eax, DWORD PTR _lM$[ebp]
	sub	eax, DWORD PTR _lAmount$[ebp]
	mov	DWORD PTR _lM$[ebp], eax
$LN16@UfAddToDat:

; 2596 :          }

	jmp	SHORT $LN14@UfAddToDat
$LN13@UfAddToDat:

; 2597 :          else
; 2598 :          {
; 2599 :             lM += lAmount;

	mov	ecx, DWORD PTR _lM$[ebp]
	add	ecx, DWORD PTR _lAmount$[ebp]
	mov	DWORD PTR _lM$[ebp], ecx

; 2600 :             if ( lM > 12 )

	cmp	DWORD PTR _lM$[ebp], 12			; 0000000cH
	jle	SHORT $LN14@UfAddToDat

; 2601 :             {
; 2602 :                bYadjust = TRUE;

	mov	BYTE PTR _bYadjust$[ebp], 1

; 2603 :                lY += (lM / 12);

	mov	eax, DWORD PTR _lM$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	add	eax, DWORD PTR _lY$[ebp]
	mov	DWORD PTR _lY$[ebp], eax

; 2604 :                lM = (lM % 12);

	mov	eax, DWORD PTR _lM$[ebp]
	cdq
	mov	ecx, 12					; 0000000cH
	idiv	ecx
	mov	DWORD PTR _lM$[ebp], edx

; 2605 :                if ( !lM )

	cmp	DWORD PTR _lM$[ebp], 0
	jne	SHORT $LN20@UfAddToDat

; 2606 :                {
; 2607 :                   lY--;

	mov	edx, DWORD PTR _lY$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lY$[ebp], edx

; 2608 :                   lM = 12;

	mov	DWORD PTR _lM$[ebp], 12			; 0000000cH
$LN20@UfAddToDat:

; 2609 :                }
; 2610 : 
; 2611 :                if ( lY > 9999 )

	cmp	DWORD PTR _lY$[ebp], 9999		; 0000270fH
	jle	SHORT $LN14@UfAddToDat

; 2612 :                {
; 2613 :                   // overflow...
; 2614 :                   // "KZOEE235 - Integer overflow"
; 2615 :                   fnSysMessageBox( 0, "Zeidon Error", "Year greater than 9999", 0 );

	push	0
	push	OFFSET $SG14276
	push	OFFSET $SG14277
	push	0
	call	_fnSysMessageBox@16

; 2616 :                // fnIssueCoreError( 0, lpView, 16, 235, 0, "Year greater than 9999", 0 );
; 2617 :                   nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 2618 :                   bDone = TRUE;

	mov	BYTE PTR _bDone$[ebp], 1
$LN14@UfAddToDat:

; 2619 :                }
; 2620 :             }
; 2621 :          }
; 2622 : 
; 2623 :          if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	$LN22@UfAddToDat

; 2624 :          {
; 2625 :             zUSHORT usDay;
; 2626 : 
; 2627 :             if ( bYadjust )

	movzx	edx, BYTE PTR _bYadjust$[ebp]
	test	edx, edx
	je	SHORT $LN23@UfAddToDat

; 2628 :                fnSetDateTimeComponent( (LPDATETIME)&dt, zDT_YEAR, lY );

	mov	eax, DWORD PTR _lY$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _dt$[ebp]
	push	ecx
	call	_fnSetDateTimeComponent
	add	esp, 12					; 0000000cH
$LN23@UfAddToDat:

; 2629 :             nRC = fnSetDateTimeComponent( (LPDATETIME)&dt, zDT_MONTH, lM );

	mov	edx, DWORD PTR _lM$[ebp]
	push	edx
	push	1
	lea	eax, DWORD PTR _dt$[ebp]
	push	eax
	call	_fnSetDateTimeComponent
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2630 : 
; 2631 :             // Make sure the day is valid.
; 2632 :             if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN24@UfAddToDat

; 2633 :             {
; 2634 :                // Oops...day must be wrong.  Change it.
; 2635 :                usDay = (zUSHORT) fnGetDateTimeComponent( (LPDATETIME) &dt,

	push	2
	lea	edx, DWORD PTR _dt$[ebp]
	push	edx
	call	_fnGetDateTimeComponent
	add	esp, 8
	mov	WORD PTR _usDay$1[ebp], ax

; 2636 :                                                          zDT_DAY );
; 2637 :                usDay = fnValidateDay( (zUSHORT) lM, usDay, lY );

	mov	eax, DWORD PTR _lY$[ebp]
	push	eax
	movzx	ecx, WORD PTR _usDay$1[ebp]
	push	ecx
	movzx	edx, WORD PTR _lM$[ebp]
	push	edx
	call	_fnValidateDay
	add	esp, 12					; 0000000cH
	mov	WORD PTR _usDay$1[ebp], ax

; 2638 :                nRC = fnSetDateTimeComponent( (LPDATETIME) &dt, zDT_DAY, usDay );

	movzx	eax, WORD PTR _usDay$1[ebp]
	push	eax
	push	2
	lea	ecx, DWORD PTR _dt$[ebp]
	push	ecx
	call	_fnSetDateTimeComponent
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax
$LN24@UfAddToDat:

; 2639 :             }
; 2640 : 
; 2641 :             bDone = TRUE;

	mov	BYTE PTR _bDone$[ebp], 1
$LN22@UfAddToDat:

; 2642 :          }
; 2643 : 
; 2644 :          break;

	jmp	$LN2@UfAddToDat
$LN25@UfAddToDat:

; 2645 : 
; 2646 :       case zDT_DAY:
; 2647 :          ul = lAmount * Day;

	imul	edx, DWORD PTR _lAmount$[ebp], 1440
	mov	DWORD PTR _ul$[ebp], edx

; 2648 :          break;

	jmp	SHORT $LN2@UfAddToDat
$LN26@UfAddToDat:

; 2649 : 
; 2650 :       case zDT_HOUR:
; 2651 :          ul = lAmount * Hour;

	imul	eax, DWORD PTR _lAmount$[ebp], 60
	mov	DWORD PTR _ul$[ebp], eax

; 2652 :          break;

	jmp	SHORT $LN2@UfAddToDat
$LN27@UfAddToDat:

; 2653 : 
; 2654 :       case zDT_MINUTE:
; 2655 :          ul = lAmount * Minute;

	mov	ecx, DWORD PTR _lAmount$[ebp]
	mov	DWORD PTR _ul$[ebp], ecx

; 2656 :          break;

	jmp	SHORT $LN2@UfAddToDat
$LN28@UfAddToDat:

; 2657 : 
; 2658 :       case zDT_SECOND:
; 2659 :          ul = lAmount;

	mov	edx, DWORD PTR _lAmount$[ebp]
	mov	DWORD PTR _ul$[ebp], edx

; 2660 :          if ( ul > 59 )

	cmp	DWORD PTR _ul$[ebp], 59			; 0000003bH
	jbe	SHORT $LN29@UfAddToDat

; 2661 :          {
; 2662 :             un = (zUSHORT)(ul % 60);

	mov	eax, DWORD PTR _ul$[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR _un$[ebp], dx

; 2663 :             ul /= 60;

	mov	eax, DWORD PTR _ul$[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	DWORD PTR _ul$[ebp], eax

; 2664 :          }

	jmp	SHORT $LN30@UfAddToDat
$LN29@UfAddToDat:

; 2665 :          else
; 2666 :          {
; 2667 :             un = (zUSHORT) ul;

	mov	dx, WORD PTR _ul$[ebp]
	mov	WORD PTR _un$[ebp], dx

; 2668 :             ul = 0;

	mov	DWORD PTR _ul$[ebp], 0
$LN30@UfAddToDat:

; 2669 :          }
; 2670 :          un *= 1000;  // adjust to thousandths of a second

	movzx	eax, WORD PTR _un$[ebp]
	imul	ecx, eax, 1000
	mov	WORD PTR _un$[ebp], cx

; 2671 :          break;

	jmp	SHORT $LN2@UfAddToDat
$LN31@UfAddToDat:

; 2672 : 
; 2673 :       default:
; 2674 :          // "KZOEE023 - Invalid parameter, "
; 2675 :          fnSysMessageBox( 0, "Zeidon Error", "Invalid parameter", 0 );

	push	0
	push	OFFSET $SG14288
	push	OFFSET $SG14289
	push	0
	call	_fnSysMessageBox@16

; 2676 :       // fnIssueCoreError( 0, lpView, 8, 23, 0, "lAmountType", 0 );
; 2677 :       // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
; 2678 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@UfAddToDat
$LN2@UfAddToDat:

; 2679 :    }
; 2680 : 
; 2681 :    if ( bDone == FALSE )

	movzx	edx, BYTE PTR _bDone$[ebp]
	test	edx, edx
	jne	$LN32@UfAddToDat

; 2682 :    {
; 2683 :       if ( bSubtract )

	movzx	eax, BYTE PTR _bSubtract$[ebp]
	test	eax, eax
	je	$LN33@UfAddToDat

; 2684 :       {
; 2685 :          // Subtract
; 2686 :          if ( un > dt.usTSeconds )

	movzx	ecx, WORD PTR _un$[ebp]
	movzx	edx, WORD PTR _dt$[ebp+4]
	cmp	ecx, edx
	jle	SHORT $LN35@UfAddToDat

; 2687 :          {
; 2688 :             if ( ul > (dt.ulDateMinutes - 1) )

	mov	eax, DWORD PTR _dt$[ebp]
	sub	eax, 1
	cmp	DWORD PTR _ul$[ebp], eax
	jbe	SHORT $LN37@UfAddToDat

; 2689 :             {
; 2690 :                // underflow...
; 2691 :                // "KZOEE236 - Integer underflow"
; 2692 :                fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );

	push	0
	push	OFFSET $SG14297
	push	OFFSET $SG14298
	push	0
	call	_fnSysMessageBox@16

; 2693 :             // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
; 2694 :                nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 2695 :             }

	jmp	SHORT $LN38@UfAddToDat
$LN37@UfAddToDat:

; 2696 :             else
; 2697 :             {
; 2698 :                dt.usTSeconds += ( (zUSHORT)60000 - un );

	movzx	edx, WORD PTR _un$[ebp]
	mov	eax, 60000				; 0000ea60H
	sub	eax, edx
	movzx	ecx, WORD PTR _dt$[ebp+4]
	add	ecx, eax
	mov	WORD PTR _dt$[ebp+4], cx

; 2699 :                dt.ulDateMinutes -= ul + 1;

	mov	edx, DWORD PTR _ul$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _dt$[ebp]
	sub	eax, edx
	mov	DWORD PTR _dt$[ebp], eax
$LN38@UfAddToDat:

; 2700 :             }
; 2701 :          }

	jmp	SHORT $LN36@UfAddToDat
$LN35@UfAddToDat:

; 2702 :          else
; 2703 :          {
; 2704 :             if ( ul > dt.ulDateMinutes )

	mov	ecx, DWORD PTR _ul$[ebp]
	cmp	ecx, DWORD PTR _dt$[ebp]
	jbe	SHORT $LN39@UfAddToDat

; 2705 :             {
; 2706 :                // underflow...
; 2707 :                // "KZOEE236 - Integer underflow"
; 2708 :                fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );

	push	0
	push	OFFSET $SG14301
	push	OFFSET $SG14302
	push	0
	call	_fnSysMessageBox@16

; 2709 :             // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
; 2710 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 2711 :             }

	jmp	SHORT $LN36@UfAddToDat
$LN39@UfAddToDat:

; 2712 :             else
; 2713 :             {
; 2714 :                dt.usTSeconds -= un;

	movzx	eax, WORD PTR _un$[ebp]
	movzx	ecx, WORD PTR _dt$[ebp+4]
	sub	ecx, eax
	mov	WORD PTR _dt$[ebp+4], cx

; 2715 :                dt.ulDateMinutes -= ul;

	mov	edx, DWORD PTR _dt$[ebp]
	sub	edx, DWORD PTR _ul$[ebp]
	mov	DWORD PTR _dt$[ebp], edx
$LN36@UfAddToDat:

; 2716 :             }
; 2717 :          }
; 2718 :       }

	jmp	SHORT $LN32@UfAddToDat
$LN33@UfAddToDat:

; 2719 :       else
; 2720 :       {
; 2721 :          // Add
; 2722 :          dt.usTSeconds += un;

	movzx	eax, WORD PTR _un$[ebp]
	movzx	ecx, WORD PTR _dt$[ebp+4]
	add	ecx, eax
	mov	WORD PTR _dt$[ebp+4], cx

; 2723 :          if ( dt.usTSeconds >= 60000 )

	movzx	edx, WORD PTR _dt$[ebp+4]
	cmp	edx, 60000				; 0000ea60H
	jl	SHORT $LN41@UfAddToDat

; 2724 :          {
; 2725 :             dt.ulDateMinutes++;

	mov	eax, DWORD PTR _dt$[ebp]
	add	eax, 1
	mov	DWORD PTR _dt$[ebp], eax

; 2726 :             dt.usTSeconds -= 60000;

	movzx	ecx, WORD PTR _dt$[ebp+4]
	sub	ecx, 60000				; 0000ea60H
	mov	WORD PTR _dt$[ebp+4], cx
$LN41@UfAddToDat:

; 2727 :          }
; 2728 :          dt.ulDateMinutes += ul;

	mov	edx, DWORD PTR _dt$[ebp]
	add	edx, DWORD PTR _ul$[ebp]
	mov	DWORD PTR _dt$[ebp], edx

; 2729 : 
; 2730 :          if ( fnCompareDateTimeToDateTime( &dt, (LPDTINTERNAL) lpDateTime )
; 2731 :               == -1 )

	mov	eax, DWORD PTR _lpDateTime$[ebp]
	push	eax
	lea	ecx, DWORD PTR _dt$[ebp]
	push	ecx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN32@UfAddToDat

; 2732 :          {
; 2733 :             // overflow
; 2734 :             // "KZOEE235 - Integer overflow"
; 2735 :             fnSysMessageBox( 0, "Zeidon Error", "Integer overflow", 0 );

	push	0
	push	OFFSET $SG14305
	push	OFFSET $SG14306
	push	0
	call	_fnSysMessageBox@16

; 2736 :          // fnIssueCoreError( 0, lpView, 16, 235, 0, 0, 0 );
; 2737 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN32@UfAddToDat:

; 2738 :          }
; 2739 :       }
; 2740 :    }
; 2741 : 
; 2742 :    // if no problems copy back to user area.
; 2743 :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN43@UfAddToDat

; 2744 :       zmemcpy( (zPCHAR) lpDateTime, (zPCHAR) &dt, sizeof( DateTimeRecord ) );

	push	6
	lea	edx, DWORD PTR _dt$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpDateTime$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN43@UfAddToDat:

; 2745 : 
; 2746 : // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
; 2747 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@UfAddToDat:

; 2748 : } // UfAddToDateTime

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	3
$LN51@UfAddToDat:
	DD	$LN6@UfAddToDat
	DD	$LN12@UfAddToDat
	DD	$LN25@UfAddToDat
	DD	$LN26@UfAddToDat
	DD	$LN27@UfAddToDat
	DD	$LN28@UfAddToDat
_UfAddToDateTime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_lpDateTime1$ = 8					; size = 4
_lpDateTime2$ = 12					; size = 4
_UfCompareDateTimeToDateTime@8 PROC

; 1858 : {

	push	ebp
	mov	ebp, esp

; 1859 :    return( fnCompareDateTimeToDateTime( (LPDTINTERNAL) lpDateTime1,

	mov	eax, DWORD PTR _lpDateTime2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDateTime1$[ebp]
	push	ecx
	call	_fnCompareDateTimeToDateTime
	add	esp, 8

; 1860 :                                         (LPDTINTERNAL) lpDateTime2 ) );
; 1861 : }

	pop	ebp
	ret	8
_UfCompareDateTimeToDateTime@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv199 = -108						; size = 4
$T1 = -104						; size = 4
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
tv86 = -80						; size = 4
_lpDTInternal$ = -76					; size = 4
_ulHours$ = -72						; size = 4
_ulDays$ = -68						; size = 4
tv75 = -64						; size = 4
_usDayOrg$ = -60					; size = 2
_usStringLth$ = -56					; size = 2
_usSeconds$ = -52					; size = 2
_usTSeconds$ = -48					; size = 2
_usMinutes$ = -44					; size = 2
_ulYear$ = -40						; size = 4
_ulWorkYear$ = -36					; size = 4
_usDay$ = -32						; size = 2
_ulDateMinutes$ = -28					; size = 4
_bDateSet$ = -21					; size = 1
_nRC$ = -20						; size = 2
_usMonth$ = -16						; size = 2
_szWorkString$ = -12					; size = 5
__$ArrayPad$ = -4					; size = 4
_cpcDateTimeString$ = 8					; size = 4
_lpDateTime$ = 12					; size = 4
_UfStringToDateTime@8 PROC

; 1418 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1419 :    zUSHORT        usStringLth;
; 1420 :    zUSHORT        usMonth;
; 1421 :    zUSHORT        usDay;
; 1422 :    zUSHORT        usDayOrg;
; 1423 :    zUSHORT        usSeconds;
; 1424 :    zUSHORT        usTSeconds;
; 1425 :    zULONG         ulYear;
; 1426 :    zULONG         ulHours;
; 1427 :    zUSHORT        usMinutes;
; 1428 :    zULONG         ulDateMinutes;
; 1429 :    zULONG         ulDays;
; 1430 :    zULONG         ulWorkYear;
; 1431 :    zCHAR          szWorkString[ 5 ];
; 1432 :    LPDTINTERNAL   lpDTInternal;
; 1433 :    zBOOL          bDateSet;
; 1434 :    zSHORT         nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1435 : 
; 1436 :    lpDTInternal = (LPDTINTERNAL) lpDateTime;

	mov	ecx, DWORD PTR _lpDateTime$[ebp]
	mov	DWORD PTR _lpDTInternal$[ebp], ecx

; 1437 : 
; 1438 :    // Null string will set the DateTime to 'NULL'
; 1439 :    if ( cpcDateTimeString == 0 || cpcDateTimeString[ 0 ] == 0 )

	cmp	DWORD PTR _cpcDateTimeString$[ebp], 0
	je	SHORT $LN7@UfStringTo
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN6@UfStringTo
$LN7@UfStringTo:

; 1440 :    {
; 1441 :       lpDTInternal->ulDateMinutes = (zULONG) lNullInteger;

	mov	eax, DWORD PTR _lpDTInternal$[ebp]
	mov	ecx, DWORD PTR _lNullInteger
	mov	DWORD PTR [eax], ecx

; 1442 :       lpDTInternal->usTSeconds = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _lpDTInternal$[ebp]
	mov	WORD PTR [eax+4], dx

; 1443 :       return( 0 );

	xor	eax, eax
	jmp	$LN33@UfStringTo
$LN6@UfStringTo:

; 1444 :    }
; 1445 : 
; 1446 :    usMonth = 0;

	xor	ecx, ecx
	mov	WORD PTR _usMonth$[ebp], cx

; 1447 :    usDay = 0;

	xor	edx, edx
	mov	WORD PTR _usDay$[ebp], dx

; 1448 :    ulYear = 0;

	mov	DWORD PTR _ulYear$[ebp], 0

; 1449 :    ulHours = 0;

	mov	DWORD PTR _ulHours$[ebp], 0

; 1450 :    usMinutes = 0;

	xor	eax, eax
	mov	WORD PTR _usMinutes$[ebp], ax

; 1451 :    usSeconds = 0;

	xor	ecx, ecx
	mov	WORD PTR _usSeconds$[ebp], cx

; 1452 :    usTSeconds = 0;

	xor	edx, edx
	mov	WORD PTR _usTSeconds$[ebp], dx

; 1453 : 
; 1454 :    usStringLth = (zUSHORT) zstrlen( cpcDateTimeString );

	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _usStringLth$[ebp], ax

; 1455 :    switch ( usStringLth )

	movzx	ecx, WORD PTR _usStringLth$[ebp]
	mov	DWORD PTR tv75[ebp], ecx
	mov	edx, DWORD PTR tv75[ebp]
	sub	edx, 8
	mov	DWORD PTR tv75[ebp], edx
	cmp	DWORD PTR tv75[ebp], 9
	ja	$LN24@UfStringTo
	mov	eax, DWORD PTR tv75[ebp]
	movzx	ecx, BYTE PTR $LN50@UfStringTo[eax]
	jmp	DWORD PTR $LN51@UfStringTo[ecx*4]
$LN8@UfStringTo:

; 1456 :    {
; 1457 :       case 17:   // YYYYMMDDHHmmSSTht
; 1458 :       case 16:   // YYYYMMDDHHmmSSTh
; 1459 :       case 15:   // YYYYMMDDHHmmSST
; 1460 :          // Get Thousandths of seconds Value
; 1461 :          zstrcpy( szWorkString, (zPCHAR) (cpcDateTimeString + 14) );

	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1462 :          usTSeconds = (zUSHORT) zatol( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _usTSeconds$[ebp], ax

; 1463 :          if ( usStringLth < 17 )

	movzx	edx, WORD PTR _usStringLth$[ebp]
	cmp	edx, 17					; 00000011H
	jge	SHORT $LN10@UfStringTo

; 1464 :             usTSeconds *= ( usStringLth == 16 ) ? 10 : 100 ;

	movzx	eax, WORD PTR _usStringLth$[ebp]
	cmp	eax, 16					; 00000010H
	jne	SHORT $LN34@UfStringTo
	mov	DWORD PTR tv86[ebp], 10			; 0000000aH
	jmp	SHORT $LN35@UfStringTo
$LN34@UfStringTo:
	mov	DWORD PTR tv86[ebp], 100		; 00000064H
$LN35@UfStringTo:
	movzx	ecx, WORD PTR _usTSeconds$[ebp]
	imul	ecx, DWORD PTR tv86[ebp]
	mov	WORD PTR _usTSeconds$[ebp], cx
$LN10@UfStringTo:

; 1465 : 
; 1466 :       case 14:   // YYYYMMDDHHmmSS
; 1467 :          // Get Seconds Value
; 1468 :          szWorkString[ 0 ] = *(cpcDateTimeString + 12);

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+12]
	mov	BYTE PTR _szWorkString$[ebp+eax], dl

; 1469 :          szWorkString[ 1 ] = *(cpcDateTimeString + 13);

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+13]
	mov	BYTE PTR _szWorkString$[ebp+eax], dl

; 1470 :          szWorkString[ 2 ] = 0;

	mov	eax, 1
	shl	eax, 1
	mov	DWORD PTR $T6[ebp], eax
	cmp	DWORD PTR $T6[ebp], 5
	jae	SHORT $LN36@UfStringTo
	jmp	SHORT $LN37@UfStringTo
$LN36@UfStringTo:
	call	___report_rangecheckfailure
$LN37@UfStringTo:
	mov	ecx, DWORD PTR $T6[ebp]
	mov	BYTE PTR _szWorkString$[ebp+ecx], 0

; 1471 :          usSeconds = (zUSHORT) zatol( szWorkString );

	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _usSeconds$[ebp], ax

; 1472 :          if ( usSeconds > 59 )

	movzx	eax, WORD PTR _usSeconds$[ebp]
	cmp	eax, 59					; 0000003bH
	jle	SHORT $LN12@UfStringTo

; 1473 :          {
; 1474 :             usSeconds = 59;

	mov	ecx, 59					; 0000003bH
	mov	WORD PTR _usSeconds$[ebp], cx

; 1475 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN12@UfStringTo:

; 1476 :          }
; 1477 : 
; 1478 :       case 12:   // YYYYMMDDHHmm
; 1479 :          // Get Minutes Value
; 1480 :          szWorkString[ 0 ] = *(cpcDateTimeString + 10);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+10]
	mov	BYTE PTR _szWorkString$[ebp+ecx], al

; 1481 :          szWorkString[ 1 ] = *(cpcDateTimeString + 11);

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+11]
	mov	BYTE PTR _szWorkString$[ebp+ecx], al

; 1482 :          szWorkString[ 2 ] = 0;

	mov	ecx, 1
	shl	ecx, 1
	mov	DWORD PTR $T5[ebp], ecx
	cmp	DWORD PTR $T5[ebp], 5
	jae	SHORT $LN38@UfStringTo
	jmp	SHORT $LN39@UfStringTo
$LN38@UfStringTo:
	call	___report_rangecheckfailure
$LN39@UfStringTo:
	mov	edx, DWORD PTR $T5[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 0

; 1483 :          usMinutes = (zUSHORT) zatol( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _usMinutes$[ebp], ax

; 1484 :          if ( usMinutes > 59 )

	movzx	ecx, WORD PTR _usMinutes$[ebp]
	cmp	ecx, 59					; 0000003bH
	jle	SHORT $LN13@UfStringTo

; 1485 :          {
; 1486 :             usMinutes = 59;

	mov	edx, 59					; 0000003bH
	mov	WORD PTR _usMinutes$[ebp], dx

; 1487 :             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN13@UfStringTo:

; 1488 :          }
; 1489 : 
; 1490 :          // Get Hours Value
; 1491 :          szWorkString[ 0 ] = *(cpcDateTimeString + 8);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+8]
	mov	BYTE PTR _szWorkString$[ebp+edx], cl

; 1492 :          szWorkString[ 1 ] = *(cpcDateTimeString + 9);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+9]
	mov	BYTE PTR _szWorkString$[ebp+edx], cl

; 1493 :          szWorkString[ 2 ] = 0;

	mov	edx, 1
	shl	edx, 1
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 5
	jae	SHORT $LN40@UfStringTo
	jmp	SHORT $LN41@UfStringTo
$LN40@UfStringTo:
	call	___report_rangecheckfailure
$LN41@UfStringTo:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0

; 1494 :          ulHours = (zULONG) zatol( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulHours$[ebp], eax

; 1495 :          if ( ulHours > 23 )

	cmp	DWORD PTR _ulHours$[ebp], 23		; 00000017H
	jbe	SHORT $LN15@UfStringTo

; 1496 :          {
; 1497 :             ulHours = 23;

	mov	DWORD PTR _ulHours$[ebp], 23		; 00000017H

; 1498 :             nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN15@UfStringTo:

; 1499 :          }
; 1500 : 
; 1501 :       case 8:    // YYYYMMDD
; 1502 :          // Get Day Value
; 1503 :          szWorkString[ 0 ] = *(cpcDateTimeString + 6);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+6]
	mov	BYTE PTR _szWorkString$[ebp+ecx], al

; 1504 :          szWorkString[ 1 ] = *(cpcDateTimeString + 7);

	mov	ecx, 1
	shl	ecx, 0
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+7]
	mov	BYTE PTR _szWorkString$[ebp+ecx], al

; 1505 :          szWorkString[ 2 ] = 0;

	mov	ecx, 1
	shl	ecx, 1
	mov	DWORD PTR $T3[ebp], ecx
	cmp	DWORD PTR $T3[ebp], 5
	jae	SHORT $LN42@UfStringTo
	jmp	SHORT $LN43@UfStringTo
$LN42@UfStringTo:
	call	___report_rangecheckfailure
$LN43@UfStringTo:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 0

; 1506 :          usDay = (zUSHORT) zatol( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _usDay$[ebp], ax

; 1507 : 
; 1508 :          // Get Month Value
; 1509 :          szWorkString[ 0 ] = *(cpcDateTimeString + 4);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _szWorkString$[ebp+edx], cl

; 1510 :          szWorkString[ 1 ] = *(cpcDateTimeString + 5);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+5]
	mov	BYTE PTR _szWorkString$[ebp+edx], cl

; 1511 :          szWorkString[ 2 ] = 0;

	mov	edx, 1
	shl	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 5
	jae	SHORT $LN44@UfStringTo
	jmp	SHORT $LN45@UfStringTo
$LN44@UfStringTo:
	call	___report_rangecheckfailure
$LN45@UfStringTo:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szWorkString$[ebp+eax], 0

; 1512 :          usMonth = (zUSHORT) zatol( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _usMonth$[ebp], ax

; 1513 : 
; 1514 :          // Get Year Value
; 1515 :          zstrncpy( szWorkString, cpcDateTimeString, 4 );

	push	4
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 1516 :          szWorkString[ 4 ] = 0;

	mov	ecx, 1
	shl	ecx, 2
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 5
	jae	SHORT $LN46@UfStringTo
	jmp	SHORT $LN47@UfStringTo
$LN46@UfStringTo:
	call	___report_rangecheckfailure
$LN47@UfStringTo:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szWorkString$[ebp+edx], 0

; 1517 :          ulYear = (zULONG) zatol( szWorkString );

	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _ulYear$[ebp], eax

; 1518 : 
; 1519 :          // Check to see if we have date/datetime or only time without date.
; 1520 :          bDateSet = (ulYear || usMonth || usDay);

	cmp	DWORD PTR _ulYear$[ebp], 0
	jne	SHORT $LN48@UfStringTo
	movzx	ecx, WORD PTR _usMonth$[ebp]
	test	ecx, ecx
	jne	SHORT $LN48@UfStringTo
	movzx	edx, WORD PTR _usDay$[ebp]
	test	edx, edx
	jne	SHORT $LN48@UfStringTo
	mov	DWORD PTR tv199[ebp], 0
	jmp	SHORT $LN49@UfStringTo
$LN48@UfStringTo:
	mov	DWORD PTR tv199[ebp], 1
$LN49@UfStringTo:
	mov	al, BYTE PTR tv199[ebp]
	mov	BYTE PTR _bDateSet$[ebp], al

; 1521 : 
; 1522 :          if ( !ulYear )

	cmp	DWORD PTR _ulYear$[ebp], 0
	jne	SHORT $LN16@UfStringTo

; 1523 :          {
; 1524 :            ulYear = 1900;

	mov	DWORD PTR _ulYear$[ebp], 1900		; 0000076cH

; 1525 :            if ( bDateSet )

	movzx	ecx, BYTE PTR _bDateSet$[ebp]
	test	ecx, ecx
	je	SHORT $LN16@UfStringTo

; 1526 :              nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN16@UfStringTo:

; 1527 :          }
; 1528 :          // the year will be multiplied with minutes/year and then stored as
; 1529 :          // unsigned long. These means, max. can be not much more than 8000
; 1530 :          if ( ulYear > 8000 )

	cmp	DWORD PTR _ulYear$[ebp], 8000		; 00001f40H
	jbe	SHORT $LN18@UfStringTo

; 1531 :          {
; 1532 :            ulYear = 8000;

	mov	DWORD PTR _ulYear$[ebp], 8000		; 00001f40H

; 1533 :            nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN18@UfStringTo:

; 1534 :          }
; 1535 : 
; 1536 :          // if month out of range, make it January
; 1537 :          if ( usMonth < 1 || usMonth > 12 )

	movzx	ecx, WORD PTR _usMonth$[ebp]
	cmp	ecx, 1
	jl	SHORT $LN20@UfStringTo
	movzx	edx, WORD PTR _usMonth$[ebp]
	cmp	edx, 12					; 0000000cH
	jle	SHORT $LN19@UfStringTo
$LN20@UfStringTo:

; 1538 :          {
; 1539 :             usMonth = 1;

	mov	eax, 1
	mov	WORD PTR _usMonth$[ebp], ax

; 1540 :             if ( bDateSet )

	movzx	ecx, BYTE PTR _bDateSet$[ebp]
	test	ecx, ecx
	je	SHORT $LN19@UfStringTo

; 1541 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN19@UfStringTo:

; 1542 :          }
; 1543 : 
; 1544 :          // Get valid day for the month
; 1545 :          usDayOrg = usDay;

	mov	ax, WORD PTR _usDay$[ebp]
	mov	WORD PTR _usDayOrg$[ebp], ax

; 1546 :          usDay = fnValidateDay( usMonth, usDayOrg, ulYear );

	mov	ecx, DWORD PTR _ulYear$[ebp]
	push	ecx
	movzx	edx, WORD PTR _usDayOrg$[ebp]
	push	edx
	movzx	eax, WORD PTR _usMonth$[ebp]
	push	eax
	call	_fnValidateDay
	add	esp, 12					; 0000000cH
	mov	WORD PTR _usDay$[ebp], ax

; 1547 :          if ( usDay != usDayOrg )

	movzx	ecx, WORD PTR _usDay$[ebp]
	movzx	edx, WORD PTR _usDayOrg$[ebp]
	cmp	ecx, edx
	je	SHORT $LN22@UfStringTo

; 1548 :          {
; 1549 :            if ( bDateSet )

	movzx	eax, BYTE PTR _bDateSet$[ebp]
	test	eax, eax
	je	SHORT $LN22@UfStringTo

; 1550 :              nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN22@UfStringTo:

; 1551 :          }
; 1552 :          break;

	jmp	SHORT $LN2@UfStringTo
$LN24@UfStringTo:

; 1553 : 
; 1554 :       default:
; 1555 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN33@UfStringTo
$LN2@UfStringTo:

; 1556 :    }
; 1557 : 
; 1558 :    /* Calculate Year in Minutes */
; 1559 :    ulWorkYear = 0;

	mov	DWORD PTR _ulWorkYear$[ebp], 0

; 1560 :    ulDateMinutes = 0;

	mov	DWORD PTR _ulDateMinutes$[ebp], 0

; 1561 : 
; 1562 :    // Fast path for dates starting Jan 1, 1900.
; 1563 :    // Start point set to beginning of century.
; 1564 :    if ( ulYear >= 1900L )

	cmp	DWORD PTR _ulYear$[ebp], 1900		; 0000076cH
	jb	SHORT $LN4@UfStringTo

; 1565 :    {
; 1566 :       ulWorkYear = 1900L;

	mov	DWORD PTR _ulWorkYear$[ebp], 1900	; 0000076cH

; 1567 :       ulDateMinutes = Year1900;

	mov	DWORD PTR _ulDateMinutes$[ebp], 999303840 ; 3b902aa0H

; 1568 :       if ( ulYear >= 2000L )

	cmp	DWORD PTR _ulYear$[ebp], 2000		; 000007d0H
	jb	SHORT $LN4@UfStringTo

; 1569 :       {
; 1570 :          ulWorkYear = 2000L;

	mov	DWORD PTR _ulWorkYear$[ebp], 2000	; 000007d0H

; 1571 :          ulDateMinutes += Century;

	mov	edx, DWORD PTR _ulDateMinutes$[ebp]
	add	edx, 52594560				; 03228780H
	mov	DWORD PTR _ulDateMinutes$[ebp], edx
$LN4@UfStringTo:

; 1572 :       }
; 1573 :    }
; 1574 : 
; 1575 :    // This will get us to Jan 1, of the desired year.
; 1576 :    // This will take a bit longer when the year is less than 1900.
; 1577 :    while ( ulWorkYear < ulYear )

	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	cmp	eax, DWORD PTR _ulYear$[ebp]
	jae	SHORT $LN5@UfStringTo

; 1578 :    {
; 1579 :       if ( !(ulWorkYear % 4) &&

	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN27@UfStringTo
	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	test	edx, edx
	jne	SHORT $LN29@UfStringTo
	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 400				; 00000190H
	div	ecx
	test	edx, edx
	jne	SHORT $LN27@UfStringTo
$LN29@UfStringTo:

; 1580 :            ((ulWorkYear % 100) || !(ulWorkYear % 400)) )
; 1581 :       {
; 1582 :          ulDateMinutes += LeapYear;

	mov	edx, DWORD PTR _ulDateMinutes$[ebp]
	add	edx, 527040				; 00080ac0H
	mov	DWORD PTR _ulDateMinutes$[ebp], edx

; 1583 :       }

	jmp	SHORT $LN28@UfStringTo
$LN27@UfStringTo:

; 1584 :       else
; 1585 :       {
; 1586 :          ulDateMinutes += Year;

	mov	eax, DWORD PTR _ulDateMinutes$[ebp]
	add	eax, 525600				; 00080520H
	mov	DWORD PTR _ulDateMinutes$[ebp], eax
$LN28@UfStringTo:

; 1587 :       }
; 1588 : 
; 1589 :       ulWorkYear++;

	mov	ecx, DWORD PTR _ulWorkYear$[ebp]
	add	ecx, 1
	mov	DWORD PTR _ulWorkYear$[ebp], ecx

; 1590 :    }

	jmp	SHORT $LN4@UfStringTo
$LN5@UfStringTo:

; 1591 : 
; 1592 :    // This will get the number of days from the Jan 1,
; 1593 :    // to the beginning of the desired month.
; 1594 :    if ( !(ulWorkYear % 4) &&

	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN30@UfStringTo
	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 100				; 00000064H
	div	ecx
	test	edx, edx
	jne	SHORT $LN32@UfStringTo
	mov	eax, DWORD PTR _ulWorkYear$[ebp]
	xor	edx, edx
	mov	ecx, 400				; 00000190H
	div	ecx
	test	edx, edx
	jne	SHORT $LN30@UfStringTo
$LN32@UfStringTo:

; 1595 :         ((ulWorkYear % 100) || !(ulWorkYear % 400)) )
; 1596 :    {
; 1597 :       ulDays = usLeapDayTable[ usMonth - 1 ];

	movzx	edx, WORD PTR _usMonth$[ebp]
	movzx	eax, WORD PTR _usLeapDayTable[edx*2-2]
	mov	DWORD PTR _ulDays$[ebp], eax

; 1598 :    }

	jmp	SHORT $LN31@UfStringTo
$LN30@UfStringTo:

; 1599 :    else
; 1600 :    {
; 1601 :       ulDays = usDayTable[ usMonth - 1 ];

	movzx	ecx, WORD PTR _usMonth$[ebp]
	movzx	edx, WORD PTR _usDayTable[ecx*2-2]
	mov	DWORD PTR _ulDays$[ebp], edx
$LN31@UfStringTo:

; 1602 :    }
; 1603 : 
; 1604 :    ulDays += usDay - 1;                 // add day of the month, for days

	movzx	eax, WORD PTR _usDay$[ebp]
	mov	ecx, DWORD PTR _ulDays$[ebp]
	lea	edx, DWORD PTR [ecx+eax-1]
	mov	DWORD PTR _ulDays$[ebp], edx

; 1605 :                                         // this year
; 1606 :    ulDateMinutes += ulDays * Day;       // add days_minutes to total minutes

	imul	eax, DWORD PTR _ulDays$[ebp], 1440
	add	eax, DWORD PTR _ulDateMinutes$[ebp]
	mov	DWORD PTR _ulDateMinutes$[ebp], eax

; 1607 :    ulDateMinutes += ulHours * Hour;     // add hours_minutes to total minutes

	imul	ecx, DWORD PTR _ulHours$[ebp], 60
	add	ecx, DWORD PTR _ulDateMinutes$[ebp]
	mov	DWORD PTR _ulDateMinutes$[ebp], ecx

; 1608 :    // add minutes to total minutes
; 1609 :    ulDateMinutes += (zULONG)(usMinutes * Minute);

	movzx	edx, WORD PTR _usMinutes$[ebp]
	add	edx, DWORD PTR _ulDateMinutes$[ebp]
	mov	DWORD PTR _ulDateMinutes$[ebp], edx

; 1610 : 
; 1611 :    // Now save this, before we forget...
; 1612 :    lpDTInternal->ulDateMinutes = ulDateMinutes;

	mov	eax, DWORD PTR _lpDTInternal$[ebp]
	mov	ecx, DWORD PTR _ulDateMinutes$[ebp]
	mov	DWORD PTR [eax], ecx

; 1613 : 
; 1614 :    // Convert seconds to thousandths, and save it too.
; 1615 :    lpDTInternal->usTSeconds = usTSeconds + (usSeconds * 1000);

	movzx	edx, WORD PTR _usTSeconds$[ebp]
	movzx	eax, WORD PTR _usSeconds$[ebp]
	imul	ecx, eax, 1000
	add	edx, ecx
	mov	eax, DWORD PTR _lpDTInternal$[ebp]
	mov	WORD PTR [eax+4], dx

; 1616 : 
; 1617 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN33@UfStringTo:

; 1618 : 
; 1619 : }  /* END of StringToDateTime */

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN51@UfStringTo:
	DD	$LN15@UfStringTo
	DD	$LN12@UfStringTo
	DD	$LN10@UfStringTo
	DD	$LN8@UfStringTo
	DD	$LN24@UfStringTo
$LN50@UfStringTo:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	1
	DB	4
	DB	2
	DB	3
	DB	3
	DB	3
_UfStringToDateTime@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv240 = -44						; size = 4
_lpDTInternal$ = -40					; size = 4
_ulDateMinutes$ = -36					; size = 4
_usMinute$ = -32					; size = 2
_usHour$ = -28						; size = 2
_usSeconds$ = -24					; size = 2
_usMonth$ = -20						; size = 2
_usTSeconds$ = -16					; size = 2
_usDay$ = -12						; size = 2
_usYear$ = -8						; size = 2
_k$ = -4						; size = 2
_lpDateTime$ = 8					; size = 4
_pchReturnString$ = 12					; size = 4
_nMaxLth$ = 16						; size = 2
_UfDateTimeToString@12 PROC

; 1711 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1712 :    zULONG         ulDateMinutes;
; 1713 :    zUSHORT        k;
; 1714 :    zUSHORT        usYear, usMonth, usDay, usHour, usMinute;
; 1715 :    zUSHORT        usSeconds, usTSeconds;
; 1716 :    LPDTINTERNAL   lpDTInternal;
; 1717 : 
; 1718 :    lpDTInternal = (LPDTINTERNAL) lpDateTime;

	mov	eax, DWORD PTR _lpDateTime$[ebp]
	mov	DWORD PTR _lpDTInternal$[ebp], eax

; 1719 : 
; 1720 :    if ( lpDTInternal->ulDateMinutes == (zULONG) lNullInteger )

	mov	ecx, DWORD PTR _lpDTInternal$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _lNullInteger
	jne	SHORT $LN9@UfDateTime

; 1721 :    {
; 1722 :       *pchReturnString = 0;

	mov	eax, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [eax], 0

; 1723 :       return( -1 );

	or	eax, -1
	jmp	$LN1@UfDateTime
$LN9@UfDateTime:

; 1724 :    }
; 1725 : 
; 1726 :    if ( nMaxLth < 9 )

	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	cmp	ecx, 9
	jge	SHORT $LN10@UfDateTime

; 1727 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@UfDateTime
	jmp	SHORT $LN11@UfDateTime
$LN10@UfDateTime:

; 1728 :    else
; 1729 :    if ( nMaxLth < 13 )

	movsx	edx, WORD PTR _nMaxLth$[ebp]
	cmp	edx, 13					; 0000000dH
	jge	SHORT $LN12@UfDateTime

; 1730 :       nMaxLth = 9;      // Let's assume 9.

	mov	eax, 9
	mov	WORD PTR _nMaxLth$[ebp], ax
	jmp	SHORT $LN11@UfDateTime
$LN12@UfDateTime:

; 1731 :    else
; 1732 :    if ( nMaxLth < 15 )

	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	cmp	ecx, 15					; 0000000fH
	jge	SHORT $LN11@UfDateTime

; 1733 :       nMaxLth = 13;     // Let's assume 13.

	mov	edx, 13					; 0000000dH
	mov	WORD PTR _nMaxLth$[ebp], dx
$LN11@UfDateTime:

; 1734 : 
; 1735 :    ulDateMinutes = lpDTInternal->ulDateMinutes;

	mov	eax, DWORD PTR _lpDTInternal$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ulDateMinutes$[ebp], ecx

; 1736 :    usTSeconds = lpDTInternal->usTSeconds;

	mov	edx, DWORD PTR _lpDTInternal$[ebp]
	mov	ax, WORD PTR [edx+4]
	mov	WORD PTR _usTSeconds$[ebp], ax

; 1737 : 
; 1738 :    if ( ulDateMinutes >= Year2000 )

	cmp	DWORD PTR _ulDateMinutes$[ebp], 1051898400 ; 3eb2b220H
	jb	SHORT $LN15@UfDateTime

; 1739 :    {
; 1740 :       usYear = 2000;

	mov	ecx, 2000				; 000007d0H
	mov	WORD PTR _usYear$[ebp], cx

; 1741 :       ulDateMinutes -= Year2000;

	mov	edx, DWORD PTR _ulDateMinutes$[ebp]
	sub	edx, 1051898400				; 3eb2b220H
	mov	DWORD PTR _ulDateMinutes$[ebp], edx

; 1742 :    }

	jmp	SHORT $LN4@UfDateTime
$LN15@UfDateTime:

; 1743 :    else
; 1744 :    if ( ulDateMinutes >= Year1900 )

	cmp	DWORD PTR _ulDateMinutes$[ebp], 999303840 ; 3b902aa0H
	jb	SHORT $LN17@UfDateTime

; 1745 :    {
; 1746 :       usYear = 1900;

	mov	eax, 1900				; 0000076cH
	mov	WORD PTR _usYear$[ebp], ax

; 1747 :       ulDateMinutes -= Year1900;

	mov	ecx, DWORD PTR _ulDateMinutes$[ebp]
	sub	ecx, 999303840				; 3b902aa0H
	mov	DWORD PTR _ulDateMinutes$[ebp], ecx

; 1748 :    }

	jmp	SHORT $LN4@UfDateTime
$LN17@UfDateTime:

; 1749 :    else
; 1750 :       usYear = 0;

	xor	edx, edx
	mov	WORD PTR _usYear$[ebp], dx
$LN4@UfDateTime:

; 1751 : 
; 1752 :    for ( ; ; )
; 1753 :    {
; 1754 :       if ( !(usYear % 4) &&

	movzx	eax, WORD PTR _usYear$[ebp]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN41@UfDateTime
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN41@UfDateTime:
	test	eax, eax
	jne	SHORT $LN19@UfDateTime
	movzx	eax, WORD PTR _usYear$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN21@UfDateTime
	movzx	eax, WORD PTR _usYear$[ebp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN19@UfDateTime
$LN21@UfDateTime:

; 1755 :             ((usYear % 100) || !(usYear % 400)) )
; 1756 :       {
; 1757 :          if ( ulDateMinutes >= LeapYear )

	cmp	DWORD PTR _ulDateMinutes$[ebp], 527040	; 00080ac0H
	jb	SHORT $LN22@UfDateTime

; 1758 :          {
; 1759 :             usYear++;

	mov	dx, WORD PTR _usYear$[ebp]
	add	dx, 1
	mov	WORD PTR _usYear$[ebp], dx

; 1760 :             ulDateMinutes -= LeapYear;

	mov	eax, DWORD PTR _ulDateMinutes$[ebp]
	sub	eax, 527040				; 00080ac0H
	mov	DWORD PTR _ulDateMinutes$[ebp], eax

; 1761 :          }

	jmp	SHORT $LN23@UfDateTime
$LN22@UfDateTime:

; 1762 :          else
; 1763 :             break;

	jmp	SHORT $LN3@UfDateTime
$LN23@UfDateTime:

; 1764 :       }

	jmp	SHORT $LN20@UfDateTime
$LN19@UfDateTime:

; 1765 :       else
; 1766 :       {
; 1767 :          if ( ulDateMinutes >= Year )

	cmp	DWORD PTR _ulDateMinutes$[ebp], 525600	; 00080520H
	jb	SHORT $LN24@UfDateTime

; 1768 :          {
; 1769 :             usYear++;

	mov	cx, WORD PTR _usYear$[ebp]
	add	cx, 1
	mov	WORD PTR _usYear$[ebp], cx

; 1770 :             ulDateMinutes -= Year;

	mov	edx, DWORD PTR _ulDateMinutes$[ebp]
	sub	edx, 525600				; 00080520H
	mov	DWORD PTR _ulDateMinutes$[ebp], edx

; 1771 :          }

	jmp	SHORT $LN20@UfDateTime
$LN24@UfDateTime:

; 1772 :          else
; 1773 :             break;

	jmp	SHORT $LN3@UfDateTime
$LN20@UfDateTime:

; 1774 :       }
; 1775 :    }

	jmp	$LN4@UfDateTime
$LN3@UfDateTime:

; 1776 : 
; 1777 :    usDay = (zUSHORT) ( ulDateMinutes / Day );

	mov	eax, DWORD PTR _ulDateMinutes$[ebp]
	xor	edx, edx
	mov	ecx, 1440				; 000005a0H
	div	ecx
	mov	WORD PTR _usDay$[ebp], ax

; 1778 :    ulDateMinutes %= Day;

	mov	eax, DWORD PTR _ulDateMinutes$[ebp]
	xor	edx, edx
	mov	ecx, 1440				; 000005a0H
	div	ecx
	mov	DWORD PTR _ulDateMinutes$[ebp], edx

; 1779 : 
; 1780 :    k = 1;

	mov	edx, 1
	mov	WORD PTR _k$[ebp], dx

; 1781 :    if ( (usYear % 4) == 0 &&

	movzx	eax, WORD PTR _usYear$[ebp]
	and	eax, -2147483645			; 80000003H
	jns	SHORT $LN42@UfDateTime
	dec	eax
	or	eax, -4					; fffffffcH
	inc	eax
$LN42@UfDateTime:
	test	eax, eax
	jne	$LN7@UfDateTime
	movzx	eax, WORD PTR _usYear$[ebp]
	cdq
	mov	ecx, 100				; 00000064H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN5@UfDateTime
	movzx	eax, WORD PTR _usYear$[ebp]
	cdq
	mov	ecx, 400				; 00000190H
	idiv	ecx
	test	edx, edx
	jne	SHORT $LN7@UfDateTime
$LN5@UfDateTime:

; 1782 :         ((usYear % 100) || (usYear % 400) == 0) )
; 1783 :    {
; 1784 :       while ( k < 12 && usDay >= usLeapDayTable[ k ] )

	movzx	edx, WORD PTR _k$[ebp]
	cmp	edx, 12					; 0000000cH
	jge	SHORT $LN6@UfDateTime
	movzx	eax, WORD PTR _usDay$[ebp]
	movzx	ecx, WORD PTR _k$[ebp]
	movzx	edx, WORD PTR _usLeapDayTable[ecx*2]
	cmp	eax, edx
	jl	SHORT $LN6@UfDateTime

; 1785 :          k++;

	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN5@UfDateTime
$LN6@UfDateTime:

; 1786 : 
; 1787 :       usMonth = k;

	mov	cx, WORD PTR _k$[ebp]
	mov	WORD PTR _usMonth$[ebp], cx

; 1788 :       if ( k == 12 || usDay <= usLeapDayTable[ k ] )

	movzx	edx, WORD PTR _k$[ebp]
	cmp	edx, 12					; 0000000cH
	je	SHORT $LN30@UfDateTime
	movzx	eax, WORD PTR _usDay$[ebp]
	movzx	ecx, WORD PTR _k$[ebp]
	movzx	edx, WORD PTR _usLeapDayTable[ecx*2]
	cmp	eax, edx
	jg	SHORT $LN29@UfDateTime
$LN30@UfDateTime:

; 1789 :          k--;

	mov	ax, WORD PTR _k$[ebp]
	sub	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN29@UfDateTime:

; 1790 : 
; 1791 :       usDay -= usLeapDayTable[ k ];

	movzx	ecx, WORD PTR _k$[ebp]
	movzx	edx, WORD PTR _usLeapDayTable[ecx*2]
	movzx	eax, WORD PTR _usDay$[ebp]
	sub	eax, edx
	mov	WORD PTR _usDay$[ebp], ax

; 1792 :    }

	jmp	SHORT $LN27@UfDateTime
$LN7@UfDateTime:

; 1793 :    else
; 1794 :    {
; 1795 :       while ( k < 12 && usDay >= usDayTable[ k ] )

	movzx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 12					; 0000000cH
	jge	SHORT $LN8@UfDateTime
	movzx	edx, WORD PTR _usDay$[ebp]
	movzx	eax, WORD PTR _k$[ebp]
	movzx	ecx, WORD PTR _usDayTable[eax*2]
	cmp	edx, ecx
	jl	SHORT $LN8@UfDateTime

; 1796 :          k++;

	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN7@UfDateTime
$LN8@UfDateTime:

; 1797 : 
; 1798 :       usMonth = k;

	mov	ax, WORD PTR _k$[ebp]
	mov	WORD PTR _usMonth$[ebp], ax

; 1799 :       if ( k == 12 || usDay <= usDayTable[ k ] )

	movzx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN32@UfDateTime
	movzx	edx, WORD PTR _usDay$[ebp]
	movzx	eax, WORD PTR _k$[ebp]
	movzx	ecx, WORD PTR _usDayTable[eax*2]
	cmp	edx, ecx
	jg	SHORT $LN31@UfDateTime
$LN32@UfDateTime:

; 1800 :          k--;

	mov	dx, WORD PTR _k$[ebp]
	sub	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN31@UfDateTime:

; 1801 : 
; 1802 :       usDay -= usDayTable[ k ];

	movzx	eax, WORD PTR _k$[ebp]
	movzx	ecx, WORD PTR _usDayTable[eax*2]
	movzx	edx, WORD PTR _usDay$[ebp]
	sub	edx, ecx
	mov	WORD PTR _usDay$[ebp], dx
$LN27@UfDateTime:

; 1803 :    }
; 1804 : 
; 1805 :    usDay++;

	mov	ax, WORD PTR _usDay$[ebp]
	add	ax, 1
	mov	WORD PTR _usDay$[ebp], ax

; 1806 :    usHour = (zUSHORT) ( ulDateMinutes / Hour );

	mov	eax, DWORD PTR _ulDateMinutes$[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR _usHour$[ebp], ax

; 1807 :    usMinute = (zUSHORT) ( ulDateMinutes % Hour );

	mov	eax, DWORD PTR _ulDateMinutes$[ebp]
	xor	edx, edx
	mov	ecx, 60					; 0000003cH
	div	ecx
	mov	WORD PTR _usMinute$[ebp], dx

; 1808 :    if ( usTSeconds )

	movzx	edx, WORD PTR _usTSeconds$[ebp]
	test	edx, edx
	je	SHORT $LN33@UfDateTime

; 1809 :    {
; 1810 :       usSeconds = (zUSHORT) ( usTSeconds / 1000 );

	movzx	eax, WORD PTR _usTSeconds$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	WORD PTR _usSeconds$[ebp], ax

; 1811 :       usTSeconds %= 1000;

	movzx	eax, WORD PTR _usTSeconds$[ebp]
	cdq
	mov	ecx, 1000				; 000003e8H
	idiv	ecx
	mov	WORD PTR _usTSeconds$[ebp], dx

; 1812 :    }

	jmp	SHORT $LN34@UfDateTime
$LN33@UfDateTime:

; 1813 :    else
; 1814 :       usSeconds = 0;

	xor	edx, edx
	mov	WORD PTR _usSeconds$[ebp], dx
$LN34@UfDateTime:

; 1815 : 
; 1816 :    zltoal( (zLONG) usYear, pchReturnString, 4 );          // year to string

	push	4
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	movzx	ecx, WORD PTR _usYear$[ebp]
	push	ecx
	call	_zltoal
	add	esp, 12					; 0000000cH

; 1817 :    zltoal( (zLONG) usMonth, pchReturnString + 4, 2 );     // month to string

	push	2
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	add	edx, 4
	push	edx
	movzx	eax, WORD PTR _usMonth$[ebp]
	push	eax
	call	_zltoal
	add	esp, 12					; 0000000cH

; 1818 :    zltoal( (zLONG) usDay, pchReturnString + 6, 2 );       // day to string

	push	2
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	add	ecx, 6
	push	ecx
	movzx	edx, WORD PTR _usDay$[ebp]
	push	edx
	call	_zltoal
	add	esp, 12					; 0000000cH

; 1819 :    if ( nMaxLth == 9 )

	movsx	eax, WORD PTR _nMaxLth$[ebp]
	cmp	eax, 9
	jne	SHORT $LN35@UfDateTime

; 1820 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@UfDateTime
$LN35@UfDateTime:

; 1821 : 
; 1822 :    zltoal( (zLONG) usHour, pchReturnString + 8, 2 );      // hour to string

	push	2
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	add	ecx, 8
	push	ecx
	movzx	edx, WORD PTR _usHour$[ebp]
	push	edx
	call	_zltoal
	add	esp, 12					; 0000000cH

; 1823 :    zltoal( (zLONG) usMinute, pchReturnString + 10, 2 );   // minute to string

	push	2
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	movzx	ecx, WORD PTR _usMinute$[ebp]
	push	ecx
	call	_zltoal
	add	esp, 12					; 0000000cH

; 1824 :    if ( nMaxLth == 13 )

	movsx	edx, WORD PTR _nMaxLth$[ebp]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN36@UfDateTime

; 1825 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@UfDateTime
$LN36@UfDateTime:

; 1826 : 
; 1827 :    zltoal( (zLONG) usSeconds, pchReturnString + 12, 2 );  // seconds to string

	push	2
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	movzx	ecx, WORD PTR _usSeconds$[ebp]
	push	ecx
	call	_zltoal
	add	esp, 12					; 0000000cH

; 1828 :    if ( nMaxLth == 15 )

	movsx	edx, WORD PTR _nMaxLth$[ebp]
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN37@UfDateTime

; 1829 :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@UfDateTime
$LN37@UfDateTime:

; 1830 : 
; 1831 :    // milliseconds to string
; 1832 :    zltoal( (zLONG) usTSeconds, pchReturnString + 14,

	movsx	eax, WORD PTR _nMaxLth$[ebp]
	sub	eax, 15					; 0000000fH
	cmp	eax, 3
	jle	SHORT $LN39@UfDateTime
	mov	DWORD PTR tv240[ebp], 3
	jmp	SHORT $LN40@UfDateTime
$LN39@UfDateTime:
	movsx	ecx, WORD PTR _nMaxLth$[ebp]
	sub	ecx, 15					; 0000000fH
	mov	DWORD PTR tv240[ebp], ecx
$LN40@UfDateTime:
	movzx	edx, WORD PTR tv240[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	movzx	ecx, WORD PTR _usTSeconds$[ebp]
	push	ecx
	call	_zltoal
	add	esp, 12					; 0000000cH

; 1833 :            (zSHORT) (((nMaxLth - 15 ) > 3) ? 3 : (nMaxLth - 15)));
; 1834 : 
; 1835 :    return( 0 );

	xor	eax, eax
$LN1@UfDateTime:

; 1836 : 
; 1837 : }  /* END of DateTimeToString */

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_UfDateTimeToString@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_lLth$ = -72						; size = 4
_szWorkString$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_pchTgtString$ = 8					; size = 4
_lTgtIdx$ = 12						; size = 4
_lMaxReceive$ = 16					; size = 4
_lMaxTgtLth$ = 20					; size = 4
_lIntegerValue$ = 24					; size = 4
_dDecimalValue$ = 28					; size = 40
_cpcNumberType$ = 68					; size = 4
_ZeidonStringConvertFromNumber@64 PROC

; 4036 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi

; 4037 :    zCHAR szWorkString[ 64 ];
; 4038 :    zLONG lLth;
; 4039 : 
; 4040 : #ifdef  DEBUG_STRINGS
; 4041 :    TraceLineS( "(kzoeufaa) ZeidonStringConvertFromNumber:  TgtString", pchTgtString );
; 4042 :    TraceLineI( "                                           lTgtIdx", lTgtIdx );
; 4043 :    TraceLineI( "                                           lMaxTgtLth", lMaxTgtLth );
; 4044 :    TraceLineI( "                                           lIntegerValue", lIntegerValue );
; 4045 : #endif
; 4046 : 
; 4047 : 
; 4048 :    if ( lMaxReceive < 0 )

	cmp	DWORD PTR _lMaxReceive$[ebp], 0
	jge	SHORT $LN4@ZeidonStri

; 4049 :    {
; 4050 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14697
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 4051 :                      "ZeidonStringConvertFromNumber: Target string has negative length.", 1 );
; 4052 :       return( qMAXRECEIVEISNEGATIVE );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@ZeidonStri
$LN4@ZeidonStri:

; 4053 :    }
; 4054 : 
; 4055 : //   if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )
; 4056 : //      return( qMAXRECEIVEEXCEEDSTARGETLEN );
; 4057 : 
; 4058 : 
; 4059 :    // if lMaxReceive is the default of 0 then the Max is really
; 4060 :    // lMaxTgtLth - lTgtIdx +1 ( as lTgtIdx is 1-based )
; 4061 :    if ( lMaxReceive == 0 )

	cmp	DWORD PTR _lMaxReceive$[ebp], 0
	jne	SHORT $LN5@ZeidonStri

; 4062 :       lMaxReceive = lMaxTgtLth -lTgtIdx +1;

	mov	ecx, DWORD PTR _lMaxTgtLth$[ebp]
	sub	ecx, DWORD PTR _lTgtIdx$[ebp]
	add	ecx, 1
	mov	DWORD PTR _lMaxReceive$[ebp], ecx
$LN5@ZeidonStri:

; 4063 : 
; 4064 :    if ( pchTgtString == NULL || lTgtIdx <= 0 )

	cmp	DWORD PTR _pchTgtString$[ebp], 0
	je	SHORT $LN7@ZeidonStri
	cmp	DWORD PTR _lTgtIdx$[ebp], 0
	jg	SHORT $LN6@ZeidonStri
$LN7@ZeidonStri:

; 4065 :    {
; 4066 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14701
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 4067 :                      "ZeidonStringConvertFromNumber: Invalid parameter.", 1 );
; 4068 :       return( qINVALIDPARAMETER );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ZeidonStri
$LN6@ZeidonStri:

; 4069 :    }
; 4070 : 
; 4071 :    if ( cpcNumberType[ 0 ] != 'I' && cpcNumberType[ 0 ] != 'D' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcNumberType$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	je	SHORT $LN8@ZeidonStri
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcNumberType$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 68					; 00000044H
	je	SHORT $LN8@ZeidonStri

; 4072 :       return( qINVALIDPARAMETER );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ZeidonStri
$LN8@ZeidonStri:

; 4073 : 
; 4074 :    lTgtIdx--;  // convert 1-based index to 0-based index

	mov	edx, DWORD PTR _lTgtIdx$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lTgtIdx$[ebp], edx

; 4075 : 
; 4076 :    if ( cpcNumberType[ 0 ] == 'I' )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcNumberType$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 73					; 00000049H
	jne	SHORT $LN9@ZeidonStri

; 4077 :       zltoa( lIntegerValue, szWorkString );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lIntegerValue$[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN10@ZeidonStri
$LN9@ZeidonStri:

; 4078 :    else
; 4079 :       ConvertDecimalToString( szWorkString, 0, dDecimalValue, 0 );

	push	0
	sub	esp, 40					; 00000028H
	mov	ecx, 10					; 0000000aH
	lea	esi, DWORD PTR _dDecimalValue$[ebp]
	mov	edi, esp
	rep movsd
	push	0
	lea	eax, DWORD PTR _szWorkString$[ebp]
	push	eax
	call	_ConvertDecimalToString@52
$LN10@ZeidonStri:

; 4080 : 
; 4081 :    // Copy the lesser of lMaxReceive or the length of the converted value.
; 4082 :    lLth = zstrlen( szWorkString );

	lea	ecx, DWORD PTR _szWorkString$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lLth$[ebp], eax

; 4083 :    if ( lLth > lMaxReceive )

	mov	edx, DWORD PTR _lLth$[ebp]
	cmp	edx, DWORD PTR _lMaxReceive$[ebp]
	jle	SHORT $LN11@ZeidonStri

; 4084 :    {
; 4085 :       lLth = lMaxReceive;

	mov	eax, DWORD PTR _lMaxReceive$[ebp]
	mov	DWORD PTR _lLth$[ebp], eax

; 4086 :       *(pchTgtString + lTgtIdx + lLth) = 0;

	mov	ecx, DWORD PTR _pchTgtString$[ebp]
	add	ecx, DWORD PTR _lTgtIdx$[ebp]
	mov	edx, DWORD PTR _lLth$[ebp]
	mov	BYTE PTR [ecx+edx], 0

; 4087 :       lLth--;

	mov	eax, DWORD PTR _lLth$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lLth$[ebp], eax
$LN2@ZeidonStri:

; 4088 :       while ( lLth >= 0 )

	cmp	DWORD PTR _lLth$[ebp], 0
	jl	SHORT $LN3@ZeidonStri

; 4089 :       {
; 4090 :          *(pchTgtString + lTgtIdx + lLth) = '*';

	mov	ecx, DWORD PTR _pchTgtString$[ebp]
	add	ecx, DWORD PTR _lTgtIdx$[ebp]
	mov	edx, DWORD PTR _lLth$[ebp]
	mov	BYTE PTR [ecx+edx], 42			; 0000002aH

; 4091 :          lLth--;

	mov	eax, DWORD PTR _lLth$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lLth$[ebp], eax

; 4092 :       }

	jmp	SHORT $LN2@ZeidonStri
$LN3@ZeidonStri:

; 4093 :    }

	jmp	SHORT $LN12@ZeidonStri
$LN11@ZeidonStri:

; 4094 :    else
; 4095 :    {
; 4096 :       zstrncpy( pchTgtString + lTgtIdx, szWorkString, lLth );

	mov	ecx, DWORD PTR _lLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szWorkString$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTgtString$[ebp]
	add	eax, DWORD PTR _lTgtIdx$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 4097 :       pchTgtString[ lTgtIdx + lLth ] = 0;

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	add	ecx, DWORD PTR _lLth$[ebp]
	mov	edx, DWORD PTR _pchTgtString$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN12@ZeidonStri:

; 4098 :    }
; 4099 : 
; 4100 : 
; 4101 : #ifdef  DEBUG_STRINGS
; 4102 :    TraceLineI( "                                RESULT",
; 4103 :                zstrlen( pchTgtString ) );
; 4104 :    TraceLineS( "                                String", pchTgtString );
; 4105 :    TraceLineS( "-----------------------------------------------------------",
; 4106 :                "" );
; 4107 : #endif
; 4108 : 
; 4109 :    return( zstrlen( pchTgtString ) );

	mov	eax, DWORD PTR _pchTgtString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
$LN1@ZeidonStri:

; 4110 : }

	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	64					; 00000040H
_ZeidonStringConvertFromNumber@64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_pch$1 = -4						; size = 4
_cpcTgtString$ = 8					; size = 4
_nTgtIdx$ = 12						; size = 2
_cpcSearch$ = 16					; size = 4
_ZeidonStringFind@12 PROC

; 3967 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3968 :    if ( nTgtIdx > 0 )

	movsx	eax, WORD PTR _nTgtIdx$[ebp]
	test	eax, eax
	jle	SHORT $LN2@ZeidonStri

; 3969 :    {
; 3970 :       zPCHAR pch = zstrstr( cpcTgtString + nTgtIdx - 1, cpcSearch );

	mov	ecx, DWORD PTR _cpcSearch$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nTgtIdx$[ebp]
	mov	eax, DWORD PTR _cpcTgtString$[ebp]
	lea	ecx, DWORD PTR [eax+edx-1]
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	mov	DWORD PTR _pch$1[ebp], eax

; 3971 : 
; 3972 :       if ( pch )

	cmp	DWORD PTR _pch$1[ebp], 0
	je	SHORT $LN3@ZeidonStri

; 3973 :          return( pch - cpcTgtString + 1 );

	mov	eax, DWORD PTR _pch$1[ebp]
	sub	eax, DWORD PTR _cpcTgtString$[ebp]
	add	eax, 1
	jmp	SHORT $LN1@ZeidonStri
	jmp	SHORT $LN2@ZeidonStri
$LN3@ZeidonStri:

; 3974 :       else
; 3975 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@ZeidonStri
$LN2@ZeidonStri:

; 3976 :    }
; 3977 : 
; 3978 :    return( -1 );

	or	eax, -1
$LN1@ZeidonStri:

; 3979 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_ZeidonStringFind@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_lSrcLth$ = -4						; size = 4
_pchTgtString$ = 8					; size = 4
_lTgtIdx$ = 12						; size = 4
_lSrcIdx$ = 16						; size = 4
_lMaxTgtLth$ = 20					; size = 4
_ZeidonCopyWithinString@16 PROC

; 4154 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4155 :    zLONG lSrcLth;
; 4156 : 
; 4157 :    if ( pchTgtString == 0 ||                          // gotta have strings
; 4158 :         lTgtIdx == 0 || lSrcIdx == 0 )                // 1-based index

	cmp	DWORD PTR _pchTgtString$[ebp], 0
	je	SHORT $LN3@ZeidonCopy
	cmp	DWORD PTR _lTgtIdx$[ebp], 0
	je	SHORT $LN3@ZeidonCopy
	cmp	DWORD PTR _lSrcIdx$[ebp], 0
	jne	SHORT $LN2@ZeidonCopy
$LN3@ZeidonCopy:

; 4159 :    {
; 4160 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14719
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 4161 :                      "ZeidonStringCopy: Invalid parameter.", 1 );
; 4162 :       return( qINVALIDPARAMETER );

	mov	eax, -5					; fffffffbH
	jmp	SHORT $LN1@ZeidonCopy
$LN2@ZeidonCopy:

; 4163 :    }
; 4164 : 
; 4165 :    lTgtIdx--;  // convert 1-based index to 0-based index

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _lTgtIdx$[ebp], ecx

; 4166 :    lSrcIdx--;

	mov	edx, DWORD PTR _lSrcIdx$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lSrcIdx$[ebp], edx

; 4167 : 
; 4168 :    lSrcLth = zstrlen( pchTgtString + lSrcIdx );

	mov	eax, DWORD PTR _pchTgtString$[ebp]
	add	eax, DWORD PTR _lSrcIdx$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lSrcLth$[ebp], eax

; 4169 :    if ( (lTgtIdx + lSrcLth) >= lMaxTgtLth )

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	add	ecx, DWORD PTR _lSrcLth$[ebp]
	cmp	ecx, DWORD PTR _lMaxTgtLth$[ebp]
	jl	SHORT $LN4@ZeidonCopy

; 4170 :    {
; 4171 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14721
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 4172 :                      "ZeidonStringCopy: Target string is too small", 1 );
; 4173 :       return( qMAXRECEIVEEXCEEDSTARGETLEN );

	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN1@ZeidonCopy
$LN4@ZeidonCopy:

; 4174 :    }
; 4175 : 
; 4176 :    zstrcpy( pchTgtString + lTgtIdx, pchTgtString + lSrcIdx );

	mov	eax, DWORD PTR _pchTgtString$[ebp]
	add	eax, DWORD PTR _lSrcIdx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTgtString$[ebp]
	add	ecx, DWORD PTR _lTgtIdx$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 4177 :    return( zstrlen( pchTgtString ) );

	mov	edx, DWORD PTR _pchTgtString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
$LN1@ZeidonCopy:

; 4178 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_ZeidonCopyWithinString@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_lNbrToCompare$ = -8					; size = 4
tv129 = -4						; size = 4
_cpcTgtString$ = 8					; size = 4
_lTgtIdx$ = 12						; size = 4
_lMaxReceive$ = 16					; size = 4
_cpcSrcString$ = 20					; size = 4
_lSrcIdx$ = 24						; size = 4
_lMaxCompare$ = 28					; size = 4
_lMaxTgtLth$ = 32					; size = 4
_ZeidonStringCompare@28 PROC

; 3865 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3866 :    zLONG lNbrToCompare;
; 3867 : 
; 3868 : #ifdef  DEBUG_STRINGS
; 3869 :    TraceLineS( "(kzoeufaa) ZeidonStringCompare: TgtString", cpcTgtString );
; 3870 :    TraceLineI( "                                lTgtIdx", lTgtIdx );
; 3871 :    TraceLineI( "                                lMaxReceive", lMaxReceive );
; 3872 :    TraceLineS( "                                SrcString", cpcTgtString );
; 3873 :    TraceLineI( "                                lSrcIndex", lSrcIdx );
; 3874 :    TraceLineI( "                                lMaxCompare", lMaxCompare );
; 3875 :    TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
; 3876 : #endif
; 3877 : 
; 3878 :    if ( cpcTgtString == 0 || cpcSrcString == 0 ||     // gotta have strings
; 3879 :         lTgtIdx <= 0 || lSrcIdx <= 0 )                // 1-based index

	cmp	DWORD PTR _cpcTgtString$[ebp], 0
	je	SHORT $LN3@ZeidonStri
	cmp	DWORD PTR _cpcSrcString$[ebp], 0
	je	SHORT $LN3@ZeidonStri
	cmp	DWORD PTR _lTgtIdx$[ebp], 0
	jle	SHORT $LN3@ZeidonStri
	cmp	DWORD PTR _lSrcIdx$[ebp], 0
	jg	SHORT $LN2@ZeidonStri
$LN3@ZeidonStri:

; 3880 :    {
; 3881 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14655
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 3882 :                      "ZeidonStringCompare: Invalid parameter.", 1 );
; 3883 :       return( qINVALIDPARAMETER );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ZeidonStri
$LN2@ZeidonStri:

; 3884 :    }
; 3885 : 
; 3886 :    lTgtIdx--;  // convert 1-based index to 0-based index for

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _lTgtIdx$[ebp], ecx

; 3887 :    lSrcIdx--;

	mov	edx, DWORD PTR _lSrcIdx$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lSrcIdx$[ebp], edx

; 3888 : 
; 3889 :    /* ensure all parms sync up and that lTgtIdx + lMaxReceive is less
; 3890 :       than lMaxTgtLth */
; 3891 :    if ( lMaxReceive < 0 )

	cmp	DWORD PTR _lMaxReceive$[ebp], 0
	jge	SHORT $LN4@ZeidonStri

; 3892 :    {
; 3893 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14657
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 3894 :                      "ZeidonStringCompare: Target string has negative length.", 1 );
; 3895 :       return( qMAXRECEIVEISNEGATIVE );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@ZeidonStri
$LN4@ZeidonStri:

; 3896 :    }
; 3897 : 
; 3898 :    if ( lMaxCompare < 0 )

	cmp	DWORD PTR _lMaxCompare$[ebp], 0
	jge	SHORT $LN5@ZeidonStri

; 3899 :    {
; 3900 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14659
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 3901 :                      "ZeidonStringCompare: Source string has negative length.", 1 );
; 3902 :       return( qMAXCOPYISNEGATIVE );

	mov	eax, -3					; fffffffdH
	jmp	$LN1@ZeidonStri
$LN5@ZeidonStri:

; 3903 :    }
; 3904 : 
; 3905 :    if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )

	mov	edx, DWORD PTR _lTgtIdx$[ebp]
	add	edx, DWORD PTR _lMaxReceive$[ebp]
	cmp	edx, DWORD PTR _lMaxTgtLth$[ebp]
	jle	SHORT $LN6@ZeidonStri

; 3906 :    {
; 3907 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14661
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 3908 :                      "ZeidonStringCompare: Target string is too short.", 1 );
; 3909 :       return( qMAXRECEIVEEXCEEDSTARGETLEN );

	mov	eax, -4					; fffffffcH
	jmp	SHORT $LN1@ZeidonStri
$LN6@ZeidonStri:

; 3910 :    }
; 3911 : 
; 3912 :    // If lMaxReceive is the default of 0 then the Max is really
; 3913 :    // lMaxTgtLth - lTgtIdx.
; 3914 :    if ( lMaxReceive == 0 )

	cmp	DWORD PTR _lMaxReceive$[ebp], 0
	jne	SHORT $LN7@ZeidonStri

; 3915 :    {
; 3916 :       // Max receive is 0, set max receive to the number of characters
; 3917 :       // in the target string EXCLUDING the null terminator
; 3918 :       lMaxReceive = lMaxTgtLth - (lTgtIdx - 1);

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	sub	ecx, 1
	mov	edx, DWORD PTR _lMaxTgtLth$[ebp]
	sub	edx, ecx
	mov	DWORD PTR _lMaxReceive$[ebp], edx

; 3919 : 
; 3920 :       // If MaxCompare is 0 as well, assume the C convention of comparing
; 3921 :       // by including the null terminator in the compare on the target
; 3922 :       // string.
; 3923 :       if ( lMaxCompare == 0 )

	cmp	DWORD PTR _lMaxCompare$[ebp], 0
	jne	SHORT $LN7@ZeidonStri

; 3924 :          lMaxReceive++;

	mov	eax, DWORD PTR _lMaxReceive$[ebp]
	add	eax, 1
	mov	DWORD PTR _lMaxReceive$[ebp], eax
$LN7@ZeidonStri:

; 3925 :    }
; 3926 : 
; 3927 :    if ( lMaxCompare == 0 )

	cmp	DWORD PTR _lMaxCompare$[ebp], 0
	jne	SHORT $LN9@ZeidonStri

; 3928 :       lMaxCompare = lMaxReceive;

	mov	ecx, DWORD PTR _lMaxReceive$[ebp]
	mov	DWORD PTR _lMaxCompare$[ebp], ecx
$LN9@ZeidonStri:

; 3929 : 
; 3930 :    // Compare the lesser of lMaxReceive or lMaxCompare.
; 3931 :    lNbrToCompare = (lMaxReceive < lMaxCompare) ? lMaxReceive : lMaxCompare;

	mov	edx, DWORD PTR _lMaxReceive$[ebp]
	cmp	edx, DWORD PTR _lMaxCompare$[ebp]
	jge	SHORT $LN11@ZeidonStri
	mov	eax, DWORD PTR _lMaxReceive$[ebp]
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN12@ZeidonStri
$LN11@ZeidonStri:
	mov	ecx, DWORD PTR _lMaxCompare$[ebp]
	mov	DWORD PTR tv129[ebp], ecx
$LN12@ZeidonStri:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR _lNbrToCompare$[ebp], edx

; 3932 :    return( zstrncmp( cpcSrcString + lSrcIdx,

	mov	eax, DWORD PTR _lNbrToCompare$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcTgtString$[ebp]
	add	ecx, DWORD PTR _lTgtIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcSrcString$[ebp]
	add	edx, DWORD PTR _lSrcIdx$[ebp]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
$LN1@ZeidonStri:

; 3933 :                      cpcTgtString + lTgtIdx, lNbrToCompare ) );
; 3934 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ZeidonStringCompare@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_lTgtLth$ = -16						; size = 4
_lSrcLth$ = -12						; size = 4
tv131 = -8						; size = 4
_lNbrToConcat$ = -4					; size = 4
_pchTgtString$ = 8					; size = 4
_lTgtIdx$ = 12						; size = 4
_lMaxReceive$ = 16					; size = 4
_cpcSrcString$ = 20					; size = 4
_lSrcIdx$ = 24						; size = 4
_lMaxConcat$ = 28					; size = 4
_lMaxTgtLth$ = 32					; size = 4
_ZeidonStringConcat@28 PROC

; 3712 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3713 :    zLONG lNbrToConcat;
; 3714 :    zLONG lSrcLth;
; 3715 :    zLONG lTgtLth;
; 3716 : 
; 3717 : #ifdef  DEBUG_STRINGS
; 3718 :    TraceLineS( "(kzoeufaa) ZeidonStringConcat:  TgtString", pchTgtString );
; 3719 :    TraceLineI( "                                lTgtIdx", lTgtIdx );
; 3720 :    TraceLineI( "                                lMaxReceive", lMaxReceive );
; 3721 :    TraceLineS( "                                SrcString", cpcSrcString );
; 3722 :    TraceLineI( "                                lSrcIndex", lSrcIdx );
; 3723 :    TraceLineI( "                                lMaxConcat", lMaxConcat );
; 3724 :    TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
; 3725 : #endif
; 3726 : 
; 3727 :    // If the source string is null, simply return.
; 3728 :    if ( *cpcSrcString == 0 )

	mov	eax, DWORD PTR _cpcSrcString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@ZeidonStri

; 3729 :       return( zstrlen( pchTgtString ) );

	mov	edx, DWORD PTR _pchTgtString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	jmp	$LN1@ZeidonStri
$LN2@ZeidonStri:

; 3730 : 
; 3731 :    if ( pchTgtString == 0 || cpcSrcString == 0 ||     // gotta have strings

	cmp	DWORD PTR _pchTgtString$[ebp], 0
	je	SHORT $LN4@ZeidonStri
	cmp	DWORD PTR _cpcSrcString$[ebp], 0
	je	SHORT $LN4@ZeidonStri
	cmp	DWORD PTR _lSrcIdx$[ebp], 0
	jne	SHORT $LN3@ZeidonStri
$LN4@ZeidonStri:

; 3732 :         lSrcIdx == 0 )                                // 1-based index
; 3733 :    {
; 3734 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14625
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 3735 :                      "ZeidonStringConcat: Invalid parameter.", 1 );
; 3736 :       return( qINVALIDPARAMETER );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ZeidonStri
$LN3@ZeidonStri:

; 3737 :    }
; 3738 : 
; 3739 :    lSrcIdx--;  // convert 1-based index to 0-based index for

	mov	ecx, DWORD PTR _lSrcIdx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _lSrcIdx$[ebp], ecx

; 3740 : 
; 3741 :    // Ensure all parms sync up and that lTgtIdx + lMaxReceive is less
; 3742 :    // than lMaxTgtLth.
; 3743 :    if ( lMaxReceive < 0 )

	cmp	DWORD PTR _lMaxReceive$[ebp], 0
	jge	SHORT $LN5@ZeidonStri

; 3744 :    {
; 3745 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14627
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 3746 :                      "ZeidonStringConcat: Target string has negative length.", 1 );
; 3747 :       return( qMAXRECEIVEISNEGATIVE );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@ZeidonStri
$LN5@ZeidonStri:

; 3748 :    }
; 3749 : 
; 3750 :    if ( lMaxConcat < 0 )

	cmp	DWORD PTR _lMaxConcat$[ebp], 0
	jge	SHORT $LN6@ZeidonStri

; 3751 :    {
; 3752 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14629
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 3753 :                      "ZeidonStringConcat: Source string has negative length.", 1 );
; 3754 :       return( qMAXCOPYISNEGATIVE );

	mov	eax, -3					; fffffffdH
	jmp	$LN1@ZeidonStri
$LN6@ZeidonStri:

; 3755 :    }
; 3756 : 
; 3757 :    if ( lMaxReceive > lMaxTgtLth )

	mov	ecx, DWORD PTR _lMaxReceive$[ebp]
	cmp	ecx, DWORD PTR _lMaxTgtLth$[ebp]
	jle	SHORT $LN7@ZeidonStri

; 3758 :    {
; 3759 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14631
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 3760 :                      "ZeidonStringConcat: Target string is too small.", 1 );
; 3761 :       return( qMAXRECEIVEEXCEEDSTARGETLEN );

	mov	eax, -4					; fffffffcH
	jmp	$LN1@ZeidonStri
$LN7@ZeidonStri:

; 3762 :    }
; 3763 : 
; 3764 :    // Find the current end.
; 3765 :    lTgtIdx = zstrlen( pchTgtString );

	mov	eax, DWORD PTR _pchTgtString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lTgtIdx$[ebp], eax

; 3766 :    if ( lTgtIdx > lMaxTgtLth )

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	cmp	ecx, DWORD PTR _lMaxTgtLth$[ebp]
	jle	SHORT $LN8@ZeidonStri

; 3767 :       lTgtIdx = lMaxTgtLth;

	mov	edx, DWORD PTR _lMaxTgtLth$[ebp]
	mov	DWORD PTR _lTgtIdx$[ebp], edx
$LN8@ZeidonStri:

; 3768 : 
; 3769 :    // If lMaxReceive is the default of 0 then the Max is really
; 3770 :    // lMaxTgtLth - lTgtIdx.
; 3771 :    if ( lMaxReceive == 0 )

	cmp	DWORD PTR _lMaxReceive$[ebp], 0
	jne	SHORT $LN9@ZeidonStri

; 3772 :       lMaxReceive = lMaxTgtLth - lTgtIdx;

	mov	eax, DWORD PTR _lMaxTgtLth$[ebp]
	sub	eax, DWORD PTR _lTgtIdx$[ebp]
	mov	DWORD PTR _lMaxReceive$[ebp], eax
$LN9@ZeidonStri:

; 3773 : 
; 3774 :    if ( lMaxConcat == 0 )

	cmp	DWORD PTR _lMaxConcat$[ebp], 0
	jne	SHORT $LN10@ZeidonStri

; 3775 :       lMaxConcat = lMaxReceive;

	mov	ecx, DWORD PTR _lMaxReceive$[ebp]
	mov	DWORD PTR _lMaxConcat$[ebp], ecx
$LN10@ZeidonStri:

; 3776 : 
; 3777 :    // concat the lesser of lMaxReceive or lMaxCopy.
; 3778 :    lNbrToConcat = (lMaxReceive < lMaxConcat) ? lMaxReceive : lMaxConcat;

	mov	edx, DWORD PTR _lMaxReceive$[ebp]
	cmp	edx, DWORD PTR _lMaxConcat$[ebp]
	jge	SHORT $LN14@ZeidonStri
	mov	eax, DWORD PTR _lMaxReceive$[ebp]
	mov	DWORD PTR tv131[ebp], eax
	jmp	SHORT $LN15@ZeidonStri
$LN14@ZeidonStri:
	mov	ecx, DWORD PTR _lMaxConcat$[ebp]
	mov	DWORD PTR tv131[ebp], ecx
$LN15@ZeidonStri:
	mov	edx, DWORD PTR tv131[ebp]
	mov	DWORD PTR _lNbrToConcat$[ebp], edx

; 3779 :    lTgtLth = zstrlen( pchTgtString );           // So many chars still there

	mov	eax, DWORD PTR _pchTgtString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lTgtLth$[ebp], eax

; 3780 :    lSrcLth = zstrlen( cpcSrcString + lSrcIdx ); // So many chars should be added

	mov	ecx, DWORD PTR _cpcSrcString$[ebp]
	add	ecx, DWORD PTR _lSrcIdx$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lSrcLth$[ebp], eax

; 3781 :    if ( lSrcLth < lNbrToConcat )                // check number of source chars to add

	mov	edx, DWORD PTR _lSrcLth$[ebp]
	cmp	edx, DWORD PTR _lNbrToConcat$[ebp]
	jge	SHORT $LN11@ZeidonStri

; 3782 :       lNbrToConcat = lSrcLth + 1;

	mov	eax, DWORD PTR _lSrcLth$[ebp]
	add	eax, 1
	mov	DWORD PTR _lNbrToConcat$[ebp], eax
$LN11@ZeidonStri:

; 3783 : 
; 3784 :    if ( (lTgtLth + lNbrToConcat) >= lMaxTgtLth ) // check whole length of new target

	mov	ecx, DWORD PTR _lTgtLth$[ebp]
	add	ecx, DWORD PTR _lNbrToConcat$[ebp]
	cmp	ecx, DWORD PTR _lMaxTgtLth$[ebp]
	jl	SHORT $LN12@ZeidonStri

; 3785 :       lNbrToConcat = lMaxTgtLth - lTgtLth - 1;

	mov	edx, DWORD PTR _lMaxTgtLth$[ebp]
	sub	edx, DWORD PTR _lTgtLth$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lNbrToConcat$[ebp], edx
$LN12@ZeidonStri:

; 3786 : 
; 3787 :    zstrncpy( pchTgtString + lTgtIdx, cpcSrcString + lSrcIdx, lNbrToConcat );

	mov	eax, DWORD PTR _lNbrToConcat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcString$[ebp]
	add	ecx, DWORD PTR _lSrcIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTgtString$[ebp]
	add	edx, DWORD PTR _lTgtIdx$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 3788 :    pchTgtString[ lTgtIdx + lNbrToConcat ] = 0;

	mov	eax, DWORD PTR _lTgtIdx$[ebp]
	add	eax, DWORD PTR _lNbrToConcat$[ebp]
	mov	ecx, DWORD PTR _pchTgtString$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 3789 : 
; 3790 : #ifdef  DEBUG_STRINGS
; 3791 :    TraceLineI( "                                RESULT",
; 3792 :                zstrlen( pchTgtString ) );
; 3793 :    TraceLineS( "                                String", pchTgtString );
; 3794 :    TraceLineS( "-----------------------------------------------------------",
; 3795 :                "" );
; 3796 : #endif
; 3797 : 
; 3798 :    return( zstrlen( pchTgtString ) );

	mov	edx, DWORD PTR _pchTgtString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
$LN1@ZeidonStri:

; 3799 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ZeidonStringConcat@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_lLth$ = -12						; size = 4
tv146 = -8						; size = 4
_lNbrToCopy$ = -4					; size = 4
_pchTgtString$ = 8					; size = 4
_lTgtIdx$ = 12						; size = 4
_lMaxReceive$ = 16					; size = 4
_cpcSrcString$ = 20					; size = 4
_lSrcIdx$ = 24						; size = 4
_lMaxCopy$ = 28						; size = 4
_lMaxTgtLth$ = 32					; size = 4
_ZeidonStringCopy@28 PROC

; 3558 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3559 :    zLONG lNbrToCopy;
; 3560 :    zLONG lLth;
; 3561 : 
; 3562 : #ifdef  DEBUG_STRINGS
; 3563 :    TraceLineS( "(kzoeufaa) ZeidonStringCopy:    TgtString", pchTgtString );
; 3564 :    TraceLineI( "                                lTgtIdx", lTgtIdx );
; 3565 :    TraceLineI( "                                lMaxReceive", lMaxReceive );
; 3566 :    TraceLineS( "                                SrcString", cpcSrcString );
; 3567 :    TraceLineI( "                                lSrcIndex", lSrcIdx );
; 3568 :    TraceLineI( "                                lMaxCopy", lMaxCopy );
; 3569 :    TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
; 3570 : #endif
; 3571 : 
; 3572 :    if ( pchTgtString == 0 || cpcSrcString == 0 ||     // gotta have strings
; 3573 :         lTgtIdx == 0 || lSrcIdx == 0 )                // 1-based index

	cmp	DWORD PTR _pchTgtString$[ebp], 0
	je	SHORT $LN5@ZeidonStri
	cmp	DWORD PTR _cpcSrcString$[ebp], 0
	je	SHORT $LN5@ZeidonStri
	cmp	DWORD PTR _lTgtIdx$[ebp], 0
	je	SHORT $LN5@ZeidonStri
	cmp	DWORD PTR _lSrcIdx$[ebp], 0
	jne	SHORT $LN4@ZeidonStri
$LN5@ZeidonStri:

; 3574 :    {
; 3575 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14591
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 3576 :                      "ZeidonStringCopy: Invalid parameter.", 1 );
; 3577 :       return( qINVALIDPARAMETER );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ZeidonStri
$LN4@ZeidonStri:

; 3578 :    }
; 3579 : 
; 3580 :    lTgtIdx--;  // convert 1-based index to 0-based index for

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _lTgtIdx$[ebp], ecx

; 3581 :    lSrcIdx--;

	mov	edx, DWORD PTR _lSrcIdx$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lSrcIdx$[ebp], edx

; 3582 : 
; 3583 :    // Ensure all parms sync up and that lTgtIdx + lMaxReceive is less than lMaxTgtLth.
; 3584 :    if ( lMaxReceive < -1 )

	cmp	DWORD PTR _lMaxReceive$[ebp], -1
	jge	SHORT $LN6@ZeidonStri

; 3585 :    {
; 3586 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14593
	mov	eax, DWORD PTR _szlOE_SystemError
	push	eax
	push	0
	call	_SysMessageBox@16

; 3587 :                      "ZeidonStringCopy: Target string has negative length", 1 );
; 3588 :       return( qMAXRECEIVEISNEGATIVE );

	mov	eax, -2					; fffffffeH
	jmp	$LN1@ZeidonStri
$LN6@ZeidonStri:

; 3589 :    }
; 3590 : 
; 3591 :    if ( lMaxCopy < 0 )

	cmp	DWORD PTR _lMaxCopy$[ebp], 0
	jge	SHORT $LN7@ZeidonStri

; 3592 :       return( qMAXCOPYISNEGATIVE );

	mov	eax, -3					; fffffffdH
	jmp	$LN1@ZeidonStri
$LN7@ZeidonStri:

; 3593 : 
; 3594 :    if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )

	mov	ecx, DWORD PTR _lTgtIdx$[ebp]
	add	ecx, DWORD PTR _lMaxReceive$[ebp]
	cmp	ecx, DWORD PTR _lMaxTgtLth$[ebp]
	jle	SHORT $LN8@ZeidonStri

; 3595 :    {
; 3596 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14596
	mov	edx, DWORD PTR _szlOE_SystemError
	push	edx
	push	0
	call	_SysMessageBox@16

; 3597 :                      "ZeidonStringCopy: Target string is too small", 1 );
; 3598 :       return( qMAXRECEIVEEXCEEDSTARGETLEN );

	mov	eax, -4					; fffffffcH
	jmp	$LN1@ZeidonStri
$LN8@ZeidonStri:

; 3599 :    }
; 3600 : 
; 3601 :    // Ensure the source index does not point beyond the end of the source string.
; 3602 :    if ( lSrcIdx > (zLONG)zstrlen(cpcSrcString) )

	mov	eax, DWORD PTR _cpcSrcString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _lSrcIdx$[ebp], eax
	jle	SHORT $LN9@ZeidonStri

; 3603 :    {
; 3604 :       SysMessageBox( 0, szlOE_SystemError,

	push	1
	push	OFFSET $SG14598
	mov	ecx, DWORD PTR _szlOE_SystemError
	push	ecx
	push	0
	call	_SysMessageBox@16

; 3605 :                      "ZeidonStringCopy: Invalid parameter (source index).", 1 );
; 3606 :       return( qINVALIDPARAMETER );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@ZeidonStri
$LN9@ZeidonStri:

; 3607 :    }
; 3608 : 
; 3609 :    // If lMaxReceive is -1, move the characters to the target without a null at end.
; 3610 :    if ( lMaxReceive == -1 )

	cmp	DWORD PTR _lMaxReceive$[ebp], -1
	jne	SHORT $LN10@ZeidonStri

; 3611 :    {
; 3612 :       if ( lMaxCopy == 0 )

	cmp	DWORD PTR _lMaxCopy$[ebp], 0
	jne	SHORT $LN2@ZeidonStri

; 3613 :          lMaxCopy = lMaxTgtLth - lTgtIdx - 1;

	mov	edx, DWORD PTR _lMaxTgtLth$[ebp]
	sub	edx, DWORD PTR _lTgtIdx$[ebp]
	sub	edx, 1
	mov	DWORD PTR _lMaxCopy$[ebp], edx
$LN2@ZeidonStri:

; 3614 : 
; 3615 :       while ( *(cpcSrcString + lSrcIdx) != 0 && lMaxCopy > 0 )

	mov	eax, DWORD PTR _cpcSrcString$[ebp]
	add	eax, DWORD PTR _lSrcIdx$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@ZeidonStri
	cmp	DWORD PTR _lMaxCopy$[ebp], 0
	jle	SHORT $LN3@ZeidonStri

; 3616 :       {
; 3617 :          *(pchTgtString + lTgtIdx++) = *(cpcSrcString + lSrcIdx++);

	mov	edx, DWORD PTR _pchTgtString$[ebp]
	add	edx, DWORD PTR _lTgtIdx$[ebp]
	mov	eax, DWORD PTR _cpcSrcString$[ebp]
	add	eax, DWORD PTR _lSrcIdx$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _lTgtIdx$[ebp]
	add	edx, 1
	mov	DWORD PTR _lTgtIdx$[ebp], edx
	mov	eax, DWORD PTR _lSrcIdx$[ebp]
	add	eax, 1
	mov	DWORD PTR _lSrcIdx$[ebp], eax

; 3618 :          lMaxCopy--;

	mov	ecx, DWORD PTR _lMaxCopy$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _lMaxCopy$[ebp], ecx

; 3619 :       }

	jmp	SHORT $LN2@ZeidonStri
$LN3@ZeidonStri:

; 3620 : 
; 3621 :       return( zstrlen( pchTgtString ) );

	mov	edx, DWORD PTR _pchTgtString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	jmp	$LN1@ZeidonStri
$LN10@ZeidonStri:

; 3622 :    }
; 3623 : 
; 3624 :    // If lMaxReceive is the default of 0 then the Max is really
; 3625 :    // lMaxTgtLth - lTgtIdx - 1 (for zero-based index).
; 3626 :    if ( lMaxReceive == 0 )

	cmp	DWORD PTR _lMaxReceive$[ebp], 0
	jne	SHORT $LN12@ZeidonStri

; 3627 :       lMaxReceive = lMaxTgtLth - lTgtIdx - 1;

	mov	eax, DWORD PTR _lMaxTgtLth$[ebp]
	sub	eax, DWORD PTR _lTgtIdx$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lMaxReceive$[ebp], eax
$LN12@ZeidonStri:

; 3628 : 
; 3629 :    if ( lMaxCopy == 0 )

	cmp	DWORD PTR _lMaxCopy$[ebp], 0
	jne	SHORT $LN13@ZeidonStri

; 3630 :       lMaxCopy = lMaxReceive;

	mov	ecx, DWORD PTR _lMaxReceive$[ebp]
	mov	DWORD PTR _lMaxCopy$[ebp], ecx
$LN13@ZeidonStri:

; 3631 : 
; 3632 :    // Copy the lesser of lMaxReceive or lMaxCopy.
; 3633 :    lNbrToCopy = (lMaxReceive < lMaxCopy) ? lMaxReceive : lMaxCopy;

	mov	edx, DWORD PTR _lMaxReceive$[ebp]
	cmp	edx, DWORD PTR _lMaxCopy$[ebp]
	jge	SHORT $LN16@ZeidonStri
	mov	eax, DWORD PTR _lMaxReceive$[ebp]
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN17@ZeidonStri
$LN16@ZeidonStri:
	mov	ecx, DWORD PTR _lMaxCopy$[ebp]
	mov	DWORD PTR tv146[ebp], ecx
$LN17@ZeidonStri:
	mov	edx, DWORD PTR tv146[ebp]
	mov	DWORD PTR _lNbrToCopy$[ebp], edx

; 3634 :    lLth = zstrlen( cpcSrcString + lSrcIdx );

	mov	eax, DWORD PTR _cpcSrcString$[ebp]
	add	eax, DWORD PTR _lSrcIdx$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _lLth$[ebp], eax

; 3635 :    if ( lLth < lNbrToCopy )

	mov	ecx, DWORD PTR _lLth$[ebp]
	cmp	ecx, DWORD PTR _lNbrToCopy$[ebp]
	jge	SHORT $LN14@ZeidonStri

; 3636 :       lNbrToCopy = lLth + 1;

	mov	edx, DWORD PTR _lLth$[ebp]
	add	edx, 1
	mov	DWORD PTR _lNbrToCopy$[ebp], edx
$LN14@ZeidonStri:

; 3637 : 
; 3638 :    zstrncpy( pchTgtString + lTgtIdx, cpcSrcString + lSrcIdx, lNbrToCopy );

	mov	eax, DWORD PTR _lNbrToCopy$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcSrcString$[ebp]
	add	ecx, DWORD PTR _lSrcIdx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTgtString$[ebp]
	add	edx, DWORD PTR _lTgtIdx$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 3639 :    pchTgtString[ lTgtIdx + lNbrToCopy ] = 0;

	mov	eax, DWORD PTR _lTgtIdx$[ebp]
	add	eax, DWORD PTR _lNbrToCopy$[ebp]
	mov	ecx, DWORD PTR _pchTgtString$[ebp]
	mov	BYTE PTR [ecx+eax], 0

; 3640 : 
; 3641 : #ifdef  DEBUG_STRINGS
; 3642 :    TraceLineI( "                                RESULT",
; 3643 :                zstrlen( pchTgtString ) );
; 3644 :    TraceLineS( "                                String", pchTgtString );
; 3645 :    TraceLineS( "-----------------------------------------------------------",
; 3646 :                "" );
; 3647 : #endif
; 3648 : 
; 3649 :    return( zstrlen( pchTgtString ) );

	mov	edx, DWORD PTR _pchTgtString$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
$LN1@ZeidonStri:

; 3650 : }

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_ZeidonStringCopy@28 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_fElapsedTimeAll$ = -248				; size = 8
_fElapsedTime$ = -240					; size = 8
tv253 = -232						; size = 4
tv241 = -228						; size = 4
tv234 = -224						; size = 4
tv208 = -220						; size = 4
_ulCount$ = -216					; size = 4
_k$ = -212						; size = 2
_szMsg$ = -208						; size = 201
__$ArrayPad$ = -4					; size = 4
_pchDesc$ = 8						; size = 4
_UfZProbeTrace@4 PROC

; 4995 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 248				; 000000f8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 4996 :    zSHORT k;
; 4997 :    double fElapsedTime;
; 4998 :    double fElapsedTimeAll;
; 4999 :    zULONG ulCount;
; 5000 :    zCHAR  szMsg[ 201 ];
; 5001 : 
; 5002 :    if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $LN9@UfZProbeTr
	mov	eax, DWORD PTR _g_pProbeArea
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN8@UfZProbeTr
$LN9@UfZProbeTr:

; 5003 :       return( -1 );

	or	eax, -1
	jmp	$LN1@UfZProbeTr
$LN8@UfZProbeTr:

; 5004 : 
; 5005 :    fElapsedTimeAll = (double) ( SysGetTickCount( )

	call	_SysGetTickCount@0
	mov	edx, DWORD PTR _g_pProbeArea
	sub	eax, DWORD PTR [edx+2463]
	mov	DWORD PTR tv208[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv208[ebp]
	mov	eax, DWORD PTR tv208[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _fElapsedTimeAll$[ebp], xmm0

; 5006 :                      - g_pProbeArea->ProbSetInitTime ) / zTICKS_PER_SECOND;
; 5007 : 
; 5008 :    for ( k = 0; k <= g_pProbeArea->nProbes; k++)

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@UfZProbeTr
$LN2@UfZProbeTr:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN4@UfZProbeTr:
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _g_pProbeArea
	movsx	edx, WORD PTR [ecx+13]
	cmp	eax, edx
	jg	SHORT $LN3@UfZProbeTr

; 5009 :    {
; 5010 :       if ( g_pProbeArea->Probes[ k ].zp_Active == TRUE )

	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	movzx	eax, BYTE PTR [edx+ecx+15]
	cmp	eax, 1
	jne	SHORT $LN10@UfZProbeTr

; 5011 :       {
; 5012 :          UfZProbeOff( k, g_pProbeArea->Probes[ k ].zp_Desc );

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	lea	ecx, DWORD PTR [eax+edx+16]
	push	ecx
	movzx	edx, WORD PTR _k$[ebp]
	push	edx
	call	_UfZProbeOff@8
$LN10@UfZProbeTr:

; 5013 :       }
; 5014 :    }

	jmp	SHORT $LN2@UfZProbeTr
$LN3@UfZProbeTr:

; 5015 : 
; 5016 :    // Print out all used probes. Format is:
; 5017 :    //   zp.nnn. 123456789012345678901234567890:nnnn.nnn secs. (avg.nnnn.nnn for nnnnnnn times)
; 5018 :    zsprintf( szMsg, "======= Probe Trace - %30s ===START===", pchDesc );

	mov	eax, DWORD PTR _pchDesc$[ebp]
	push	eax
	push	OFFSET $SG14954
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 5019 :    TraceLineS( szMsg, "" );

	push	OFFSET $SG14955
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_TraceLineS@8

; 5020 :    zsprintf( szMsg, "zp.ALL. -- elapsed for Init to Trace->:%8.3f seconds",

	sub	esp, 8
	movsd	xmm0, QWORD PTR _fElapsedTimeAll$[ebp]
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET $SG14956
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 5021 :              fElapsedTimeAll );
; 5022 :    TraceLineS( szMsg, "" );

	push	OFFSET $SG14957
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_TraceLineS@8

; 5023 :    for ( k = 0; k <= g_pProbeArea->nProbes; k++)

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN7@UfZProbeTr
$LN5@UfZProbeTr:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN7@UfZProbeTr:
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_pProbeArea
	movsx	eax, WORD PTR [edx+13]
	cmp	ecx, eax
	jg	$LN6@UfZProbeTr

; 5024 :    {
; 5025 :       ulCount = g_pProbeArea->Probes[ k ].zp_CountOff;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	ecx, DWORD PTR [eax+edx+59]
	mov	DWORD PTR _ulCount$[ebp], ecx

; 5026 :       fElapsedTime = (double) ( g_pProbeArea->Probes[ k ].zp_TotalTime )

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	edx, DWORD PTR [ecx+eax+51]
	mov	DWORD PTR tv234[ebp], edx
	cvtsi2sd xmm0, DWORD PTR tv234[ebp]
	mov	eax, DWORD PTR tv234[ebp]
	shr	eax, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
	divsd	xmm0, QWORD PTR __real@408f400000000000
	movsd	QWORD PTR _fElapsedTime$[ebp], xmm0

; 5027 :                               / zTICKS_PER_SECOND;
; 5028 :       if ( ulCount == g_pProbeArea->Probes[ k ].zp_CountOn )

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	ecx, DWORD PTR _ulCount$[ebp]
	cmp	ecx, DWORD PTR [eax+edx+55]
	jne	$LN11@UfZProbeTr

; 5029 :          zsprintf( szMsg, "zp.%03d. %30s:%8.3f secs. (avg.%8.3f for %8d times)",

	mov	edx, DWORD PTR _ulCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _ulCount$[ebp]
	mov	DWORD PTR tv241[ebp], eax
	cvtsi2sd xmm0, DWORD PTR tv241[ebp]
	mov	ecx, DWORD PTR tv241[ebp]
	shr	ecx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
	movsd	xmm1, QWORD PTR _fElapsedTime$[ebp]
	divsd	xmm1, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	sub	esp, 8
	movsd	xmm0, QWORD PTR _fElapsedTime$[ebp]
	movsd	QWORD PTR [esp], xmm0
	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	lea	edx, DWORD PTR [ecx+eax+16]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	push	eax
	push	OFFSET $SG14960
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 36					; 00000024H
	jmp	$LN12@UfZProbeTr
$LN11@UfZProbeTr:

; 5030 :                    k, g_pProbeArea->Probes[ k ].zp_Desc,
; 5031 :                    fElapsedTime, (fElapsedTime / ulCount), ulCount );
; 5032 :       else
; 5033 :          zsprintf( szMsg, "zp.%03d. %30s:%8.3f secs. (avg.%8.3f for %8d times OFF, but ON is %d times)",

	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	edx, DWORD PTR [ecx+eax+55]
	push	edx
	mov	eax, DWORD PTR _ulCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulCount$[ebp]
	mov	DWORD PTR tv253[ebp], ecx
	cvtsi2sd xmm0, DWORD PTR tv253[ebp]
	mov	edx, DWORD PTR tv253[ebp]
	shr	edx, 31					; 0000001fH
	addsd	xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
	movsd	xmm1, QWORD PTR _fElapsedTime$[ebp]
	divsd	xmm1, xmm0
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm1
	sub	esp, 8
	movsd	xmm0, QWORD PTR _fElapsedTime$[ebp]
	movsd	QWORD PTR [esp], xmm0
	movsx	eax, WORD PTR _k$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	lea	eax, DWORD PTR [edx+ecx+16]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	push	ecx
	push	OFFSET $SG14961
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 40					; 00000028H
$LN12@UfZProbeTr:

; 5034 :                    k, g_pProbeArea->Probes[ k ].zp_Desc,
; 5035 :                    fElapsedTime, (fElapsedTime / ulCount), ulCount,
; 5036 :                    g_pProbeArea->Probes[ k ].zp_CountOn );
; 5037 : 
; 5038 :       TraceLineS( szMsg, "" );

	push	OFFSET $SG14962
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_TraceLineS@8

; 5039 :    }

	jmp	$LN5@UfZProbeTr
$LN6@UfZProbeTr:

; 5040 : 
; 5041 :    zsprintf( szMsg, "======= Probe Trace - %30s === END ===", pchDesc );

	mov	ecx, DWORD PTR _pchDesc$[ebp]
	push	ecx
	push	OFFSET $SG14963
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 5042 :    TraceLineS( szMsg, "" );

	push	OFFSET $SG14964
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_TraceLineS@8

; 5043 : 
; 5044 :    return( 0 );

	xor	eax, eax
$LN1@UfZProbeTr:

; 5045 : 
; 5046 : }  // UfZProbeTrace

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_UfZProbeTrace@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_k$ = -4						; size = 2
_pchDesc$ = 8						; size = 4
_UfZProbeOffByDesc@4 PROC

; 4950 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4951 :    zSHORT k;
; 4952 : 
; 4953 :    if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $LN6@UfZProbeOf
	mov	eax, DWORD PTR _g_pProbeArea
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@UfZProbeOf
$LN6@UfZProbeOf:

; 4954 :       return( -1 );

	or	eax, -1
	jmp	$LN1@UfZProbeOf
$LN5@UfZProbeOf:

; 4955 : 
; 4956 :    for ( k = 0; k <= g_pProbeArea->nProbes; k++)

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@UfZProbeOf
$LN2@UfZProbeOf:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@UfZProbeOf:
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_pProbeArea
	movsx	eax, WORD PTR [edx+13]
	cmp	ecx, eax
	jg	SHORT $LN3@UfZProbeOf

; 4957 :    {
; 4958 :       if ( zstrcmpi( g_pProbeArea->Probes[ k ].zp_Desc, pchDesc ) == 0 )

	mov	ecx, DWORD PTR _pchDesc$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	lea	edx, DWORD PTR [ecx+eax+16]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@UfZProbeOf

; 4959 :       {
; 4960 :          return( UfZProbeOff( k, pchDesc ) );

	mov	eax, DWORD PTR _pchDesc$[ebp]
	push	eax
	movzx	ecx, WORD PTR _k$[ebp]
	push	ecx
	call	_UfZProbeOff@8
	jmp	SHORT $LN1@UfZProbeOf
$LN7@UfZProbeOf:

; 4961 :       }
; 4962 :    }

	jmp	SHORT $LN2@UfZProbeOf
$LN3@UfZProbeOf:

; 4963 : 
; 4964 :    if ( g_pProbeArea->nErrShown6 < MAX_ZPROBEERRS )

	mov	edx, DWORD PTR _g_pProbeArea
	movsx	eax, WORD PTR [edx+11]
	cmp	eax, 5
	jge	SHORT $LN8@UfZProbeOf

; 4965 :    {
; 4966 :       TraceLineS( "UfZProbeOffByDesc: Probe not on for descriptor: ", pchDesc );

	mov	ecx, DWORD PTR _pchDesc$[ebp]
	push	ecx
	push	OFFSET $SG14934
	call	_TraceLineS@8

; 4967 :       g_pProbeArea->nErrShown6++;

	mov	edx, DWORD PTR _g_pProbeArea
	mov	ax, WORD PTR [edx+11]
	add	ax, 1
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [ecx+11], ax
$LN8@UfZProbeOf:

; 4968 :    }
; 4969 : 
; 4970 :    return( -6 );

	mov	eax, -6					; fffffffaH
$LN1@UfZProbeOf:

; 4971 : 
; 4972 : }  // UfZProbeOffByDesc

	mov	esp, ebp
	pop	ebp
	ret	4
_UfZProbeOffByDesc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_k$ = -4						; size = 2
_pchDesc$ = 8						; size = 4
_bTurnPriorProbeOff$ = 12				; size = 1
_UfZProbeOnByDesc@8 PROC

; 4912 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4913 :    zSHORT k;
; 4914 : 
; 4915 :    if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $LN6@UfZProbeOn
	mov	eax, DWORD PTR _g_pProbeArea
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@UfZProbeOn
$LN6@UfZProbeOn:

; 4916 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@UfZProbeOn
$LN5@UfZProbeOn:

; 4917 : 
; 4918 :    for ( k = 0; k <= g_pProbeArea->nProbes; k++)

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN4@UfZProbeOn
$LN2@UfZProbeOn:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN4@UfZProbeOn:
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_pProbeArea
	movsx	eax, WORD PTR [edx+13]
	cmp	ecx, eax
	jg	SHORT $LN3@UfZProbeOn

; 4919 :    {
; 4920 :       if ( zstrcmpi( g_pProbeArea->Probes[ k ].zp_Desc, pchDesc ) == 0 )

	mov	ecx, DWORD PTR _pchDesc$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	imul	eax, edx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	lea	edx, DWORD PTR [ecx+eax+16]
	push	edx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN7@UfZProbeOn

; 4921 :       {
; 4922 :          return( UfZProbeOn( k, pchDesc, FALSE ) );

	push	0
	mov	eax, DWORD PTR _pchDesc$[ebp]
	push	eax
	movzx	ecx, WORD PTR _k$[ebp]
	push	ecx
	call	_UfZProbeOn@12
	jmp	SHORT $LN1@UfZProbeOn
$LN7@UfZProbeOn:

; 4923 :       }
; 4924 :    }

	jmp	SHORT $LN2@UfZProbeOn
$LN3@UfZProbeOn:

; 4925 : 
; 4926 :    return( UfZProbeOn( -1, pchDesc, bTurnPriorProbeOff ) );

	movzx	edx, BYTE PTR _bTurnPriorProbeOff$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchDesc$[ebp]
	push	eax
	push	-1
	call	_UfZProbeOn@12
$LN1@UfZProbeOn:

; 4927 : 
; 4928 : }  // UfZProbeOnByDesc

	mov	esp, ebp
	pop	ebp
	ret	8
_UfZProbeOnByDesc@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_ulElapsed$ = -8					; size = 4
_ulTime$ = -4						; size = 4
_nProbeNbr$ = 8						; size = 2
_pchDesc$ = 12						; size = 4
_UfZProbeOff@8 PROC

; 4847 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4848 :    zULONG ulTime;
; 4849 :    zULONG ulElapsed;
; 4850 : 
; 4851 :    if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $LN3@UfZProbeOf
	mov	eax, DWORD PTR _g_pProbeArea
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@UfZProbeOf
$LN3@UfZProbeOf:

; 4852 :       return( -1 );

	or	eax, -1
	jmp	$LN1@UfZProbeOf
$LN2@UfZProbeOf:

; 4853 : 
; 4854 :    ulTime = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	DWORD PTR _ulTime$[ebp], eax

; 4855 : 
; 4856 :    if ( nProbeNbr < 0 || nProbeNbr > g_pProbeArea->nProbes )

	movsx	edx, WORD PTR _nProbeNbr$[ebp]
	test	edx, edx
	jl	SHORT $LN5@UfZProbeOf
	movsx	eax, WORD PTR _nProbeNbr$[ebp]
	mov	ecx, DWORD PTR _g_pProbeArea
	movsx	edx, WORD PTR [ecx+13]
	cmp	eax, edx
	jle	SHORT $LN4@UfZProbeOf
$LN5@UfZProbeOf:

; 4857 :    {
; 4858 :       if ( g_pProbeArea->nErrShown4 < MAX_ZPROBEERRS )

	mov	eax, DWORD PTR _g_pProbeArea
	movsx	ecx, WORD PTR [eax+7]
	cmp	ecx, 5
	jge	SHORT $LN6@UfZProbeOf

; 4859 :       {
; 4860 :          TraceLineI( "UfZProbeOff: Invalid probe number: ", nProbeNbr );

	movsx	edx, WORD PTR _nProbeNbr$[ebp]
	push	edx
	push	OFFSET $SG14905
	call	_TraceLineI@8

; 4861 :          TraceLineS( "UfZProbeOff:           descriptor: ", pchDesc );

	mov	eax, DWORD PTR _pchDesc$[ebp]
	push	eax
	push	OFFSET $SG14906
	call	_TraceLineS@8

; 4862 :          return( -5 );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@UfZProbeOf

; 4863 :          g_pProbeArea->nErrShown4++;

	mov	ecx, DWORD PTR _g_pProbeArea
	mov	dx, WORD PTR [ecx+7]
	add	dx, 1
	mov	eax, DWORD PTR _g_pProbeArea
	mov	WORD PTR [eax+7], dx
$LN6@UfZProbeOf:

; 4864 :       }
; 4865 : 
; 4866 :       return( -4 );

	mov	eax, -4					; fffffffcH
	jmp	$LN1@UfZProbeOf
$LN4@UfZProbeOf:

; 4867 :    }
; 4868 : 
; 4869 :    if ( g_pProbeArea->Probes[ nProbeNbr ].zp_Active == FALSE )

	movsx	ecx, WORD PTR _nProbeNbr$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	movzx	ecx, BYTE PTR [eax+edx+15]
	test	ecx, ecx
	jne	SHORT $LN7@UfZProbeOf

; 4870 :    {
; 4871 :       if ( g_pProbeArea->nErrShown5 < MAX_ZPROBEERRS )

	mov	edx, DWORD PTR _g_pProbeArea
	movsx	eax, WORD PTR [edx+9]
	cmp	eax, 5
	jge	SHORT $LN8@UfZProbeOf

; 4872 :       {
; 4873 :          TraceLineI( "UfZProbeOff: Probe not on for number: ", nProbeNbr );

	movsx	ecx, WORD PTR _nProbeNbr$[ebp]
	push	ecx
	push	OFFSET $SG14909
	call	_TraceLineI@8

; 4874 :          TraceLineS( "UfZProbeOff:              descriptor: ", pchDesc );

	mov	edx, DWORD PTR _pchDesc$[ebp]
	push	edx
	push	OFFSET $SG14910
	call	_TraceLineS@8

; 4875 :          g_pProbeArea->nErrShown5++;

	mov	eax, DWORD PTR _g_pProbeArea
	mov	cx, WORD PTR [eax+9]
	add	cx, 1
	mov	edx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [edx+9], cx
$LN8@UfZProbeOf:

; 4876 :       }
; 4877 : 
; 4878 :       return( -5 );

	mov	eax, -5					; fffffffbH
	jmp	$LN1@UfZProbeOf
$LN7@UfZProbeOf:

; 4879 :    }
; 4880 :    ulElapsed = ulTime - g_pProbeArea->Probes[ nProbeNbr ].zp_StartTime;

	movsx	eax, WORD PTR _nProbeNbr$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	mov	eax, DWORD PTR _ulTime$[ebp]
	sub	eax, DWORD PTR [edx+ecx+47]
	mov	DWORD PTR _ulElapsed$[ebp], eax

; 4881 :    g_pProbeArea->Probes[ nProbeNbr ].zp_TotalTime += ulElapsed;

	movsx	ecx, WORD PTR _nProbeNbr$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	ecx, DWORD PTR [eax+edx+51]
	add	ecx, DWORD PTR _ulElapsed$[ebp]
	movsx	edx, WORD PTR _nProbeNbr$[ebp]
	imul	eax, edx, 48
	mov	edx, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [edx+eax+51], ecx

; 4882 :    g_pProbeArea->Probes[ nProbeNbr ].zp_StartTime = ulTime;

	movsx	eax, WORD PTR _nProbeNbr$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	mov	eax, DWORD PTR _ulTime$[ebp]
	mov	DWORD PTR [edx+ecx+47], eax

; 4883 :    g_pProbeArea->Probes[ nProbeNbr ].zp_Active = FALSE;

	movsx	ecx, WORD PTR _nProbeNbr$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	BYTE PTR [eax+edx+15], 0

; 4884 :    g_pProbeArea->Probes[ nProbeNbr ].zp_CountOff++;

	movsx	ecx, WORD PTR _nProbeNbr$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	ecx, DWORD PTR [eax+edx+59]
	add	ecx, 1
	movsx	edx, WORD PTR _nProbeNbr$[ebp]
	imul	eax, edx, 48
	mov	edx, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [edx+eax+59], ecx

; 4885 : 
; 4886 :    return( 0 );

	xor	eax, eax
$LN1@UfZProbeOf:

; 4887 : 
; 4888 : }  // UfZProbeOff

	mov	esp, ebp
	pop	ebp
	ret	8
_UfZProbeOff@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv91 = -6						; size = 2
_nProbeOn$ = -4						; size = 2
_nProbeNbr$ = 8						; size = 2
_pchDesc$ = 12						; size = 4
_bTurnPriorProbeOff$ = 16				; size = 1
_UfZProbeOn@12 PROC

; 4752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4753 :    zSHORT nProbeOn;
; 4754 : 
; 4755 :    if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $LN3@UfZProbeOn
	mov	eax, DWORD PTR _g_pProbeArea
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@UfZProbeOn
$LN3@UfZProbeOn:

; 4756 :       return( -1 );

	or	eax, -1
	jmp	$LN1@UfZProbeOn
$LN2@UfZProbeOn:

; 4757 : 
; 4758 :    nProbeOn = nProbeNbr;

	mov	dx, WORD PTR _nProbeNbr$[ebp]
	mov	WORD PTR _nProbeOn$[ebp], dx

; 4759 : 
; 4760 :    // check that input probe is not too large.
; 4761 :    if ( nProbeOn > ( MAX_ZPROBES - 1 ) )

	movsx	eax, WORD PTR _nProbeOn$[ebp]
	cmp	eax, 49					; 00000031H
	jle	SHORT $LN4@UfZProbeOn

; 4762 :       nProbeOn = -1;  // use the next available.

	or	ecx, -1
	mov	WORD PTR _nProbeOn$[ebp], cx
$LN4@UfZProbeOn:

; 4763 : 
; 4764 :    // check if the request is for a new probe and get number
; 4765 :    if ( nProbeOn < 0)

	movsx	edx, WORD PTR _nProbeOn$[ebp]
	test	edx, edx
	jge	$LN5@UfZProbeOn

; 4766 :    {
; 4767 :       if ( g_pProbeArea->nProbes >= MAX_ZPROBES - 1 )

	mov	eax, DWORD PTR _g_pProbeArea
	movsx	ecx, WORD PTR [eax+13]
	cmp	ecx, 49					; 00000031H
	jl	SHORT $LN7@UfZProbeOn

; 4768 :       {
; 4769 :          if ( g_pProbeArea->nErrShown2 < MAX_ZPROBEERRS )

	mov	edx, DWORD PTR _g_pProbeArea
	movsx	eax, WORD PTR [edx+3]
	cmp	eax, 5
	jge	SHORT $LN8@UfZProbeOn

; 4770 :          {
; 4771 :             TraceLineS( "UfZProbeOn: No more probes available for: ", pchDesc );

	mov	ecx, DWORD PTR _pchDesc$[ebp]
	push	ecx
	push	OFFSET $SG14883
	call	_TraceLineS@8

; 4772 :             g_pProbeArea->nErrShown2++;

	mov	edx, DWORD PTR _g_pProbeArea
	mov	ax, WORD PTR [edx+3]
	add	ax, 1
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [ecx+3], ax
$LN8@UfZProbeOn:

; 4773 :          }
; 4774 : 
; 4775 :          return( -2 );   // exit if no more probes available

	mov	eax, -2					; fffffffeH
	jmp	$LN1@UfZProbeOn
$LN7@UfZProbeOn:

; 4776 :       }
; 4777 : 
; 4778 :       if ( bTurnPriorProbeOff )

	movzx	edx, BYTE PTR _bTurnPriorProbeOff$[ebp]
	test	edx, edx
	je	SHORT $LN9@UfZProbeOn

; 4779 :          UfZProbeOff( g_pProbeArea->nProbes, pchDesc );

	mov	eax, DWORD PTR _pchDesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _g_pProbeArea
	movzx	edx, WORD PTR [ecx+13]
	push	edx
	call	_UfZProbeOff@8
$LN9@UfZProbeOn:

; 4780 : 
; 4781 :       nProbeOn = ++g_pProbeArea->nProbes;  // use next available probe

	mov	eax, DWORD PTR _g_pProbeArea
	mov	cx, WORD PTR [eax+13]
	add	cx, 1
	mov	WORD PTR tv91[ebp], cx
	mov	edx, DWORD PTR _g_pProbeArea
	mov	ax, WORD PTR tv91[ebp]
	mov	WORD PTR [edx+13], ax
	mov	cx, WORD PTR tv91[ebp]
	mov	WORD PTR _nProbeOn$[ebp], cx

; 4782 :       ZeidonStringCopy( g_pProbeArea->Probes[ nProbeOn ].zp_Desc, 1, 0,

	push	31					; 0000001fH
	push	0
	push	1
	mov	edx, DWORD PTR _pchDesc$[ebp]
	push	edx
	push	0
	push	1
	movsx	eax, WORD PTR _nProbeOn$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	lea	eax, DWORD PTR [edx+ecx+16]
	push	eax
	call	_ZeidonStringCopy@28

; 4783 :                         pchDesc, 1, 0, MAX_ZPROBEDESC );
; 4784 :    }

	jmp	$LN6@UfZProbeOn
$LN5@UfZProbeOn:

; 4785 :    else
; 4786 :    {
; 4787 :       if ( g_pProbeArea->Probes[ nProbeOn ].zp_Desc[ 0 ] != 0 )

	movsx	ecx, WORD PTR _nProbeOn$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	lea	ecx, DWORD PTR [eax+edx+15]
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR [ecx+eax+1]
	test	ecx, ecx
	je	$LN6@UfZProbeOn

; 4788 :       {
; 4789 :          // descriptor must match
; 4790 :          if ( zstrcmpi( g_pProbeArea->Probes[ nProbeOn ].zp_Desc, pchDesc ) != 0 )

	mov	edx, DWORD PTR _pchDesc$[ebp]
	push	edx
	movsx	eax, WORD PTR _nProbeOn$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	lea	eax, DWORD PTR [edx+ecx+16]
	push	eax
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	test	eax, eax
	je	SHORT $LN6@UfZProbeOn

; 4791 :          {
; 4792 :             if ( g_pProbeArea->nErrShown3 < MAX_ZPROBEERRS )

	mov	ecx, DWORD PTR _g_pProbeArea
	movsx	edx, WORD PTR [ecx+5]
	cmp	edx, 5
	jge	SHORT $LN12@UfZProbeOn

; 4793 :             {
; 4794 :                TraceLineI( "UfZProbeOn: Invalid probe descriptor for probe: ", nProbeNbr );

	movsx	eax, WORD PTR _nProbeNbr$[ebp]
	push	eax
	push	OFFSET $SG14888
	call	_TraceLineI@8

; 4795 :                TraceLineS( "UfZProbeOn: Invalid probe descriptor   (input): ", pchDesc );

	mov	ecx, DWORD PTR _pchDesc$[ebp]
	push	ecx
	push	OFFSET $SG14889
	call	_TraceLineS@8

; 4796 :                TraceLineS( "UfZProbeOn: Invalid probe descriptor (current): ",

	movsx	edx, WORD PTR _nProbeOn$[ebp]
	imul	eax, edx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	lea	edx, DWORD PTR [ecx+eax+16]
	push	edx
	push	OFFSET $SG14890
	call	_TraceLineS@8

; 4797 :                            g_pProbeArea->Probes[ nProbeOn ].zp_Desc );
; 4798 :                g_pProbeArea->nErrShown3++;

	mov	eax, DWORD PTR _g_pProbeArea
	mov	cx, WORD PTR [eax+5]
	add	cx, 1
	mov	edx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [edx+5], cx
$LN12@UfZProbeOn:

; 4799 :             }
; 4800 : 
; 4801 :             return( -3 );

	mov	eax, -3					; fffffffdH
	jmp	SHORT $LN1@UfZProbeOn
$LN6@UfZProbeOn:

; 4802 :          }
; 4803 :       }
; 4804 :    }
; 4805 : 
; 4806 :    // now actually turn on the probe
; 4807 :    //
; 4808 :    g_pProbeArea->Probes[ nProbeOn ].zp_CountOn++;

	movsx	eax, WORD PTR _nProbeOn$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	mov	eax, DWORD PTR [edx+ecx+55]
	add	eax, 1
	movsx	ecx, WORD PTR _nProbeOn$[ebp]
	imul	edx, ecx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [ecx+edx+55], eax

; 4809 :    if ( g_pProbeArea->Probes[ nProbeOn ].zp_Active == TRUE )

	movsx	edx, WORD PTR _nProbeOn$[ebp]
	imul	eax, edx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	movzx	edx, BYTE PTR [ecx+eax+15]
	cmp	edx, 1
	jne	SHORT $LN13@UfZProbeOn

; 4810 :    {
; 4811 :       // don't reset timer
; 4812 :    }

	jmp	SHORT $LN14@UfZProbeOn
$LN13@UfZProbeOn:

; 4813 :    else
; 4814 :    {
; 4815 :       g_pProbeArea->Probes[ nProbeOn ].zp_Active = TRUE;

	movsx	eax, WORD PTR _nProbeOn$[ebp]
	imul	ecx, eax, 48
	mov	edx, DWORD PTR _g_pProbeArea
	mov	BYTE PTR [edx+ecx+15], 1

; 4816 :       // Might want to use GetTickCount for better accuracy in tight loops.
; 4817 :       // But, that would have to change to be system independent ;-)
; 4818 :       g_pProbeArea->Probes[ nProbeOn ].zp_StartTime = SysGetTickCount( );

	call	_SysGetTickCount@0
	movsx	ecx, WORD PTR _nProbeOn$[ebp]
	imul	edx, ecx, 48
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [ecx+edx+47], eax
$LN14@UfZProbeOn:

; 4819 :    }
; 4820 : 
; 4821 :    return( nProbeOn );

	mov	ax, WORD PTR _nProbeOn$[ebp]
$LN1@UfZProbeOn:

; 4822 : 
; 4823 : }  // UfZProbeOn

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_UfZProbeOn@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_k$ = -4						; size = 2
_UfZProbeInit@0 PROC

; 4695 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4696 :    zSHORT k;
; 4697 : 
; 4698 :    if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )

	cmp	DWORD PTR _g_pProbeArea, 0
	je	SHORT $LN6@UfZProbeIn
	mov	eax, DWORD PTR _g_pProbeArea
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@UfZProbeIn
$LN6@UfZProbeIn:

; 4699 :       return( -1 );

	or	eax, -1
	jmp	$LN1@UfZProbeIn
$LN5@UfZProbeIn:

; 4700 : 
; 4701 :    g_pProbeArea->nProbes = -1;

	or	edx, -1
	mov	eax, DWORD PTR _g_pProbeArea
	mov	WORD PTR [eax+13], dx

; 4702 : 
; 4703 :    for ( k = 0; k < MAX_ZPROBES; k++)

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@UfZProbeIn
$LN2@UfZProbeIn:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN4@UfZProbeIn:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 50					; 00000032H
	jge	$LN3@UfZProbeIn

; 4704 :    {
; 4705 :       g_pProbeArea->Probes[ k ].zp_Active = FALSE;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	BYTE PTR [eax+edx+15], 0

; 4706 :       g_pProbeArea->Probes[ k ].zp_Desc[ 0 ] = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	lea	ecx, DWORD PTR [eax+edx+15]
	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR [ecx+eax+1], 0

; 4707 :       g_pProbeArea->Probes[ k ].zp_StartTime = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [eax+edx+47], 0

; 4708 :       g_pProbeArea->Probes[ k ].zp_TotalTime = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [eax+edx+51], 0

; 4709 :       g_pProbeArea->Probes[ k ].zp_CountOn = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [eax+edx+55], 0

; 4710 :       g_pProbeArea->Probes[ k ].zp_CountOff = 0;

	movsx	ecx, WORD PTR _k$[ebp]
	imul	edx, ecx, 48
	mov	eax, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [eax+edx+59], 0

; 4711 :    }

	jmp	$LN2@UfZProbeIn
$LN3@UfZProbeIn:

; 4712 : 
; 4713 :    g_pProbeArea->nErrShown1 = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [edx+1], cx

; 4714 :    g_pProbeArea->nErrShown2 = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [ecx+3], ax

; 4715 :    g_pProbeArea->nErrShown3 = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _g_pProbeArea
	mov	WORD PTR [eax+5], dx

; 4716 :    g_pProbeArea->nErrShown4 = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [edx+7], cx

; 4717 :    g_pProbeArea->nErrShown5 = 0;

	xor	eax, eax
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	WORD PTR [ecx+9], ax

; 4718 :    g_pProbeArea->nErrShown6 = 0;

	xor	edx, edx
	mov	eax, DWORD PTR _g_pProbeArea
	mov	WORD PTR [eax+11], dx

; 4719 : 
; 4720 :    g_pProbeArea->ProbSetInitTime = SysGetTickCount( );

	call	_SysGetTickCount@0
	mov	ecx, DWORD PTR _g_pProbeArea
	mov	DWORD PTR [ecx+2463], eax

; 4721 : 
; 4722 :    return( MAX_ZPROBES );

	mov	eax, 50					; 00000032H
$LN1@UfZProbeIn:

; 4723 : 
; 4724 : }  // UfZProbeInit

	mov	esp, ebp
	pop	ebp
	ret	0
_UfZProbeInit@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
_UfZProbeEnable@4 PROC

; 4664 : {

	push	ebp
	mov	ebp, esp

; 4665 : 
; 4666 :    if ( g_pProbeArea == 0 )

	cmp	DWORD PTR _g_pProbeArea, 0
	jne	SHORT $LN2@UfZProbeEn

; 4667 :    {
; 4668 :       if ( (g_pProbeArea = (ZPROBEAREA *) SysMalloc( sizeof( ZPROBEAREA ) )) == 0 )

	push	2467					; 000009a3H
	call	_SysMalloc@4
	mov	DWORD PTR _g_pProbeArea, eax
	cmp	DWORD PTR _g_pProbeArea, 0
	jne	SHORT $LN2@UfZProbeEn

; 4669 :          return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@UfZProbeEn
$LN2@UfZProbeEn:

; 4670 :    }
; 4671 : 
; 4672 :    g_pProbeArea->bProbesEnabled = bEnable;

	mov	eax, DWORD PTR _g_pProbeArea
	mov	cl, BYTE PTR _bEnable$[ebp]
	mov	BYTE PTR [eax], cl

; 4673 : 
; 4674 :    return( MAX_ZPROBES );

	mov	eax, 50					; 00000032H
$LN1@UfZProbeEn:

; 4675 : 
; 4676 : }  // UfZProbeEnable

	pop	ebp
	ret	4
_UfZProbeEnable@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
$T1 = -296						; size = 4
_pchPrevChar$ = -292					; size = 4
tv95 = -288						; size = 4
_pch2$ = -284						; size = 4
_j$ = -280						; size = 2
_k$ = -276						; size = 2
_cReplace$ = -269					; size = 1
_pch$ = -268						; size = 4
_nPhasesDone$ = -264					; size = 2
_sz$ = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_pchLongName$ = 8					; size = 4
_pchShortName$ = 12					; size = 4
_nShortNameLth$ = 16					; size = 2
_pchSpaceReplace$ = 20					; size = 4
_pchUnderscoreMode$ = 24				; size = 4
_pchLowerVowels$ = 28					; size = 4
_pchOtherChars$ = 32					; size = 4
_nPhasesToForce$ = 36					; size = 2
_UfCompressName@32 PROC

; 4401 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 296				; 00000128H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 4402 :    zPCHAR  pch;
; 4403 :    zPCHAR  pch2;
; 4404 :    zSHORT  nPhasesDone;
; 4405 :    zPCHAR  pchPrevChar;
; 4406 :    zCHAR   sz[ 256 ];
; 4407 :    zCHAR   cReplace;
; 4408 :    zSHORT  k, j;
; 4409 : 
; 4410 :    //========================================================================
; 4411 :    //
; 4412 :    // 0. remove any leading or trailing white space.
; 4413 :    //
; 4414 :    //========================================================================
; 4415 : 
; 4416 :    // Remove leading spaces.
; 4417 :    for ( pch = pchLongName; zisspace( *pch ); pch++ )

	mov	eax, DWORD PTR _pchLongName$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN4@UfCompress
$LN2@UfCompress:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN4@UfCompress:
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN3@UfCompress

; 4418 :    {
; 4419 :       // Nothing needs to be done here.
; 4420 :    }

	jmp	SHORT $LN2@UfCompress
$LN3@UfCompress:

; 4421 : 
; 4422 :    zstrcpy( sz, pch );

	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 4423 : 
; 4424 :    // Remove trailing spaces.
; 4425 :    for ( pch = &sz[ zstrlen( sz ) ] - 1; zisspace( *pch ) && pch > sz ; pch-- )

	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	lea	ecx, DWORD PTR _sz$[ebp+eax-1]
	mov	DWORD PTR _pch$[ebp], ecx
	jmp	SHORT $LN7@UfCompress
$LN5@UfCompress:
	mov	edx, DWORD PTR _pch$[ebp]
	sub	edx, 1
	mov	DWORD PTR _pch$[ebp], edx
$LN7@UfCompress:
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN6@UfCompress
	lea	edx, DWORD PTR _sz$[ebp]
	cmp	DWORD PTR _pch$[ebp], edx
	jbe	SHORT $LN6@UfCompress

; 4426 :    {
; 4427 :       // Nothing needs to be done here.
; 4428 :    }

	jmp	SHORT $LN5@UfCompress
$LN6@UfCompress:

; 4429 : 
; 4430 :    pch++;

	mov	eax, DWORD PTR _pch$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$[ebp], eax

; 4431 :    *pch = 0;

	mov	ecx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [ecx], 0

; 4432 : 
; 4433 :    /*
; 4434 :    ** remove any german 'umlaute'  (28.07.1997; RG)
; 4435 :    */
; 4436 :    for ( k = 0; k < (zSHORT) zstrlen( sz ); k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN10@UfCompress
$LN8@UfCompress:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN10@UfCompress:
	movsx	esi, WORD PTR _k$[ebp]
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	movsx	edx, ax
	cmp	esi, edx
	jge	$LN9@UfCompress

; 4437 :    {
; 4438 :       if ( zisascii( sz[ k ] ) == FALSE )

	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, BYTE PTR _sz$[ebp+eax]
	cmp	ecx, 128				; 00000080H
	jae	SHORT $LN33@UfCompress
	mov	DWORD PTR tv95[ebp], 1
	jmp	SHORT $LN34@UfCompress
$LN33@UfCompress:
	mov	DWORD PTR tv95[ebp], 0
$LN34@UfCompress:
	cmp	DWORD PTR tv95[ebp], 0
	jne	SHORT $LN17@UfCompress

; 4439 :       {
; 4440 :          for ( j = k; j < (zSHORT) zstrlen( sz ); j++ )

	mov	dx, WORD PTR _k$[ebp]
	mov	WORD PTR _j$[ebp], dx
	jmp	SHORT $LN13@UfCompress
$LN11@UfCompress:
	mov	ax, WORD PTR _j$[ebp]
	add	ax, 1
	mov	WORD PTR _j$[ebp], ax
$LN13@UfCompress:
	movsx	esi, WORD PTR _j$[ebp]
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	movsx	edx, ax
	cmp	esi, edx
	jge	SHORT $LN17@UfCompress

; 4441 :             sz[ j ] = sz[ j + 1 ];

	movsx	eax, WORD PTR _j$[ebp]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	dl, BYTE PTR _sz$[ebp+eax+1]
	mov	BYTE PTR _sz$[ebp+ecx], dl
	jmp	SHORT $LN11@UfCompress
$LN17@UfCompress:

; 4442 :       }
; 4443 :    }

	jmp	$LN8@UfCompress
$LN9@UfCompress:

; 4444 : 
; 4445 :    nPhasesDone = 0;

	xor	eax, eax
	mov	WORD PTR _nPhasesDone$[ebp], ax

; 4446 :    if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= nShortNameLth )

	movsx	ecx, WORD PTR _nPhasesDone$[ebp]
	movsx	edx, WORD PTR _nPhasesToForce$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN18@UfCompress
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movzx	ecx, WORD PTR _nShortNameLth$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN18@UfCompress

; 4447 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN18@UfCompress:

; 4448 : 
; 4449 :    //========================================================================
; 4450 :    //
; 4451 :    // 1. if pchSpaceReplace is NULL, remove embedded space.
; 4452 :    //      otherwise replace the spaces with pchSpaceReplace.
; 4453 :    //
; 4454 :    //========================================================================
; 4455 : 
; 4456 :    for ( pch = pch2 = sz; *pch; pch++ )

	lea	edx, DWORD PTR _sz$[ebp]
	mov	DWORD PTR _pch2$[ebp], edx
	mov	eax, DWORD PTR _pch2$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN16@UfCompress
$LN14@UfCompress:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN16@UfCompress:
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN15@UfCompress

; 4457 :    {
; 4458 :       if ( zisspace( *pch ) )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__isspace
	add	esp, 4
	test	eax, eax
	je	SHORT $LN19@UfCompress

; 4459 :       {
; 4460 :          if ( pchSpaceReplace && pchSpaceReplace[ 0 ] )

	cmp	DWORD PTR _pchSpaceReplace$[ebp], 0
	je	SHORT $LN21@UfCompress
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchSpaceReplace$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN21@UfCompress

; 4461 :             *pch2++ = pchSpaceReplace[ 0 ];

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pch2$[ebp]
	mov	ecx, DWORD PTR _pchSpaceReplace$[ebp]
	mov	dl, BYTE PTR [ecx+edx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch2$[ebp]
	add	eax, 1
	mov	DWORD PTR _pch2$[ebp], eax
$LN21@UfCompress:

; 4462 :       }

	jmp	SHORT $LN20@UfCompress
$LN19@UfCompress:

; 4463 :       else
; 4464 :          *pch2++ = *pch;

	mov	ecx, DWORD PTR _pch2$[ebp]
	mov	edx, DWORD PTR _pch$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch2$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch2$[ebp], ecx
$LN20@UfCompress:

; 4465 :    }

	jmp	$LN14@UfCompress
$LN15@UfCompress:

; 4466 : 
; 4467 :    *pch2 = 0;

	mov	edx, DWORD PTR _pch2$[ebp]
	mov	BYTE PTR [edx], 0

; 4468 : 
; 4469 :    nPhasesDone = 1;

	mov	eax, 1
	mov	WORD PTR _nPhasesDone$[ebp], ax

; 4470 :    if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= nShortNameLth )

	movsx	ecx, WORD PTR _nPhasesDone$[ebp]
	movsx	edx, WORD PTR _nPhasesToForce$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN22@UfCompress
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movzx	ecx, WORD PTR _nShortNameLth$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN22@UfCompress

; 4471 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN22@UfCompress:

; 4472 : 
; 4473 :    //========================================================================
; 4474 :    //
; 4475 :    // 2. remove underscores based on the value of pchUnderscorMode:
; 4476 :    //       NULL = No removal
; 4477 :    //       Ax = if x is NULL, remove All -- otherwize replace with x
; 4478 :    //       Fx = remove until short enough, starting at Front
; 4479 :    //       Bx = remove until short enough, starting at Back
; 4480 :    //       AL = remove All only after lowercase chars
; 4481 :    //       FL = remove only after lowercase chars, starting at Front
; 4482 :    //       BL = remove only after lowercase chars, starting at Back
; 4483 :    //
; 4484 :    //========================================================================
; 4485 : 
; 4486 :    if ( pchUnderscoreMode && pchUnderscoreMode[ 0 ] )

	cmp	DWORD PTR _pchUnderscoreMode$[ebp], 0
	je	$LN23@UfCompress
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchUnderscoreMode$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN23@UfCompress

; 4487 :    {
; 4488 :       if ( pchUnderscoreMode[ 1 ] == 'L' )

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchUnderscoreMode$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 76					; 0000004cH
	jne	SHORT $LN24@UfCompress

; 4489 :       {
; 4490 :          pchPrevChar = "aeiou";

	mov	DWORD PTR _pchPrevChar$[ebp], OFFSET $SG14822

; 4491 :          cReplace = 0;

	mov	BYTE PTR _cReplace$[ebp], 0

; 4492 :       }

	jmp	SHORT $LN25@UfCompress
$LN24@UfCompress:

; 4493 :       else
; 4494 :       {
; 4495 :          pchPrevChar = 0;

	mov	DWORD PTR _pchPrevChar$[ebp], 0

; 4496 :          cReplace = pchUnderscoreMode[ 1 ];

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchUnderscoreMode$[ebp]
	mov	dl, BYTE PTR [ecx+eax]
	mov	BYTE PTR _cReplace$[ebp], dl
$LN25@UfCompress:

; 4497 :       }
; 4498 : 
; 4499 :       fnRemoveChars( sz, nShortNameLth, pchUnderscoreMode[ 0 ], "_",

	movzx	eax, BYTE PTR _cReplace$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchPrevChar$[ebp]
	push	ecx
	push	OFFSET $SG14823
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchUnderscoreMode$[ebp]
	movzx	edx, BYTE PTR [ecx+eax]
	push	edx
	movzx	eax, WORD PTR _nShortNameLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_fnRemoveChars@24
$LN23@UfCompress:

; 4500 :                      pchPrevChar, cReplace );
; 4501 :    }
; 4502 : 
; 4503 :    nPhasesDone = 2;

	mov	edx, 2
	mov	WORD PTR _nPhasesDone$[ebp], dx

; 4504 :    if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= nShortNameLth )

	movsx	eax, WORD PTR _nPhasesDone$[ebp]
	movsx	ecx, WORD PTR _nPhasesToForce$[ebp]
	cmp	eax, ecx
	jl	SHORT $LN26@UfCompress
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	movzx	ecx, WORD PTR _nShortNameLth$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN26@UfCompress

; 4505 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN26@UfCompress:

; 4506 : 
; 4507 :    //========================================================================
; 4508 :    //
; 4509 :    // 3. remove lowercase vowels based on the value of pchLowerVowels:
; 4510 :    //       NULL = No removal
; 4511 :    //       Ax = remove All
; 4512 :    //       Fx = remove until short enough, starting at Front
; 4513 :    //       Bx = remove until short enough, starting at Back
; 4514 :    //       if x = 'c', then remove duplicate lowercase consonants
; 4515 :    //
; 4516 :    //========================================================================
; 4517 : 
; 4518 :    if ( pchLowerVowels && pchLowerVowels[ 0 ] != 0 )

	cmp	DWORD PTR _pchLowerVowels$[ebp], 0
	je	SHORT $LN27@UfCompress
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchLowerVowels$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN27@UfCompress

; 4519 :    {
; 4520 :       fnRemoveChars( sz, nShortNameLth, pchLowerVowels[ 0 ], "aeiou", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG14826
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLowerVowels$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	movzx	ecx, WORD PTR _nShortNameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_fnRemoveChars@24

; 4521 : 
; 4522 :       if ( pchLowerVowels[ 1 ] == 'c' )

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchLowerVowels$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 99					; 00000063H
	jne	SHORT $LN27@UfCompress

; 4523 :          fnRemoveChars( sz, nShortNameLth, pchLowerVowels[ 0 ],

	push	0
	push	OFFSET $SG14828
	push	OFFSET $SG14829
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchLowerVowels$[ebp]
	movzx	eax, BYTE PTR [edx+ecx]
	push	eax
	movzx	ecx, WORD PTR _nShortNameLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	call	_fnRemoveChars@24
$LN27@UfCompress:

; 4524 :                         "bcdfghjklmnpqrstvwxyz", "*", 0 );
; 4525 :    }
; 4526 : 
; 4527 :    nPhasesDone = 3;

	mov	eax, 3
	mov	WORD PTR _nPhasesDone$[ebp], ax

; 4528 :    if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= nShortNameLth )

	movsx	ecx, WORD PTR _nPhasesDone$[ebp]
	movsx	edx, WORD PTR _nPhasesToForce$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN29@UfCompress
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	movzx	ecx, WORD PTR _nShortNameLth$[ebp]
	cmp	eax, ecx
	ja	SHORT $LN29@UfCompress

; 4529 :       goto EndOfFunction;

	jmp	$EndOfFunction$37
$LN29@UfCompress:

; 4530 : 
; 4531 :    //========================================================================
; 4532 :    //
; 4533 :    // 4. remove any chars that match chars in pchOtherChars after the
; 4534 :    //      'mode'(first) char.  The mode char is:
; 4535 :    //      NULL = No removal
; 4536 :    //      A = remove All
; 4537 :    //      F = remove until short enough, starting at Front
; 4538 :    //      B = remove until short enough, starting at Back
; 4539 :    //
; 4540 :    //========================================================================
; 4541 : 
; 4542 :    if ( pchOtherChars[ 0 ] != 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchOtherChars$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN30@UfCompress

; 4543 :    {
; 4544 :       fnRemoveChars( sz, nShortNameLth, pchOtherChars[ 0 ],

	push	0
	push	0
	mov	eax, DWORD PTR _pchOtherChars$[ebp]
	add	eax, 1
	push	eax
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchOtherChars$[ebp]
	movzx	ecx, BYTE PTR [eax+edx]
	push	ecx
	movzx	edx, WORD PTR _nShortNameLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_fnRemoveChars@24
$LN30@UfCompress:

; 4545 :                      pchOtherChars + 1, 0, 0 );
; 4546 :    }
; 4547 : 
; 4548 :    nPhasesDone = 4;

	mov	ecx, 4
	mov	WORD PTR _nPhasesDone$[ebp], cx

; 4549 :    if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= nShortNameLth )

	movsx	edx, WORD PTR _nPhasesDone$[ebp]
	movsx	eax, WORD PTR _nPhasesToForce$[ebp]
	cmp	edx, eax
	jl	SHORT $LN31@UfCompress
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	movzx	edx, WORD PTR _nShortNameLth$[ebp]
	cmp	eax, edx
	ja	SHORT $LN31@UfCompress

; 4550 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$37
$LN31@UfCompress:

; 4551 : 
; 4552 :    //========================================================================
; 4553 :    //
; 4554 :    // 5. truncate the string to nShortNameLth.
; 4555 :    //
; 4556 :    //========================================================================
; 4557 :    sz[ nShortNameLth ] = 0;

	movzx	eax, WORD PTR _nShortNameLth$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 256			; 00000100H
	jae	SHORT $LN35@UfCompress
	jmp	SHORT $LN36@UfCompress
$LN35@UfCompress:
	call	___report_rangecheckfailure
$LN36@UfCompress:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _sz$[ebp+ecx], 0
$EndOfFunction$37:

; 4558 : 
; 4559 : EndOfFunction:
; 4560 :    zstrcpy( pchShortName, sz );

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchShortName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 4561 :    return( zstrlen( pchShortName ) );

	mov	ecx, DWORD PTR _pchShortName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
$LN32@UfCompress:

; 4562 : 
; 4563 : }  // UfCompressName

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_UfCompressName@32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_nReturnLth$ = -20					; size = 2
_nIdx$1 = -16						; size = 2
_uChar$ = -12						; size = 2
_nOrderIdx$ = -8					; size = 2
_cReturnLth$ = -3					; size = 1
_ucChar$ = -2						; size = 1
_cWk$ = -1						; size = 1
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_uLth$ = 16						; size = 2
_UfDecryptString@12 PROC

; 2387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2388 :    zUSHORT uChar;
; 2389 :    zSHORT  nOrderIdx;
; 2390 :    zUCHAR  ucChar;
; 2391 :    zCHAR   cWk;
; 2392 :    zCHAR   cReturnLth;
; 2393 :    zSHORT  nReturnLth;
; 2394 : // zCHAR   szMsg[ 256 ];
; 2395 : 
; 2396 : // zsprintf( szMsg, "UfDecryptString Length: %d   In: \"%s\"", uLth, pchIn );
; 2397 : // TraceLineS( szMsg, "" );
; 2398 : 
; 2399 :    if ( *pchIn == 0 )

	mov	eax, DWORD PTR _pchIn$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN17@UfDecryptS

; 2400 :    {
; 2401 :       *pchOut = 0;

	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx], 0

; 2402 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@UfDecryptS
$LN17@UfDecryptS:

; 2403 :    }
; 2404 : 
; 2405 :    if ( uLth > 26 )

	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	eax, 26					; 0000001aH
	jle	SHORT $LN18@UfDecryptS

; 2406 :       uLth = 26;

	mov	ecx, 26					; 0000001aH
	mov	WORD PTR _uLth$[ebp], cx
$LN18@UfDecryptS:

; 2407 : 
; 2408 :    uChar = 0;

	xor	edx, edx
	mov	WORD PTR _uChar$[ebp], dx

; 2409 :    nOrderIdx = 0;

	xor	eax, eax
	mov	WORD PTR _nOrderIdx$[ebp], ax
$LN2@UfDecryptS:

; 2410 :    while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )

	movsx	ecx, WORD PTR _nOrderIdx$[ebp]
	movzx	edx, BYTE PTR _Encrypt2[ecx]
	movzx	eax, WORD PTR _uLth$[ebp]
	sub	eax, 1
	cmp	edx, eax
	jle	SHORT $LN3@UfDecryptS

; 2411 :       nOrderIdx++;

	mov	cx, WORD PTR _nOrderIdx$[ebp]
	add	cx, 1
	mov	WORD PTR _nOrderIdx$[ebp], cx
	jmp	SHORT $LN2@UfDecryptS
$LN3@UfDecryptS:

; 2412 : 
; 2413 :    cReturnLth = pchIn[ Encrypt2[ nOrderIdx ] ] - 'a';

	movsx	edx, WORD PTR _nOrderIdx$[ebp]
	movzx	eax, BYTE PTR _Encrypt2[edx]
	mov	ecx, DWORD PTR _pchIn$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	sub	edx, 97					; 00000061H
	mov	BYTE PTR _cReturnLth$[ebp], dl

; 2414 :    nReturnLth = 0;

	xor	eax, eax
	mov	WORD PTR _nReturnLth$[ebp], ax
$LN4@UfDecryptS:

; 2415 :    while ( Encrypt1[ nReturnLth ] != (zUCHAR) cReturnLth )

	movsx	ecx, WORD PTR _nReturnLth$[ebp]
	movzx	edx, BYTE PTR _Encrypt1[ecx]
	movzx	eax, BYTE PTR _cReturnLth$[ebp]
	cmp	edx, eax
	je	SHORT $LN5@UfDecryptS

; 2416 :       nReturnLth++;

	mov	cx, WORD PTR _nReturnLth$[ebp]
	add	cx, 1
	mov	WORD PTR _nReturnLth$[ebp], cx
	jmp	SHORT $LN4@UfDecryptS
$LN5@UfDecryptS:

; 2417 : 
; 2418 :    cReturnLth = (zCHAR) nReturnLth;

	mov	dl, BYTE PTR _nReturnLth$[ebp]
	mov	BYTE PTR _cReturnLth$[ebp], dl

; 2419 :    nOrderIdx++;

	mov	ax, WORD PTR _nOrderIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nOrderIdx$[ebp], ax
$LN6@UfDecryptS:

; 2420 :    while ( cReturnLth )

	movsx	ecx, BYTE PTR _cReturnLth$[ebp]
	test	ecx, ecx
	je	$LN7@UfDecryptS
$LN8@UfDecryptS:

; 2421 :    {
; 2422 :       while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )

	movsx	edx, WORD PTR _nOrderIdx$[ebp]
	movzx	eax, BYTE PTR _Encrypt2[edx]
	movzx	ecx, WORD PTR _uLth$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN9@UfDecryptS

; 2423 :          nOrderIdx++;

	mov	dx, WORD PTR _nOrderIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nOrderIdx$[ebp], dx
	jmp	SHORT $LN8@UfDecryptS
$LN9@UfDecryptS:

; 2424 : 
; 2425 :       ucChar = pchIn[ Encrypt2[ nOrderIdx ] ];

	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR _Encrypt2[eax]
	mov	edx, DWORD PTR _pchIn$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _ucChar$[ebp], al

; 2426 :       if ( isalpha( ucChar ) )

	movzx	ecx, BYTE PTR _ucChar$[ebp]
	push	ecx
	call	DWORD PTR __imp__isalpha
	add	esp, 4
	test	eax, eax
	je	$LN19@UfDecryptS

; 2427 :       {
; 2428 :          ucChar -= 'a';

	movzx	edx, BYTE PTR _ucChar$[ebp]
	sub	edx, 97					; 00000061H
	mov	BYTE PTR _ucChar$[ebp], dl

; 2429 :          if ( uChar % 2 )

	movzx	eax, WORD PTR _uChar$[ebp]
	and	eax, -2147483647			; 80000001H
	jns	SHORT $LN26@UfDecryptS
	dec	eax
	or	eax, -2					; fffffffeH
	inc	eax
$LN26@UfDecryptS:
	test	eax, eax
	je	SHORT $LN21@UfDecryptS

; 2430 :          {
; 2431 :             cWk = 0;

	mov	BYTE PTR _cWk$[ebp], 0
$LN10@UfDecryptS:

; 2432 :             while ( Encrypt1[ cWk ] != ucChar )

	movsx	ecx, BYTE PTR _cWk$[ebp]
	movzx	edx, BYTE PTR _Encrypt1[ecx]
	movzx	eax, BYTE PTR _ucChar$[ebp]
	cmp	edx, eax
	je	SHORT $LN11@UfDecryptS

; 2433 :                cWk++;

	mov	cl, BYTE PTR _cWk$[ebp]
	add	cl, 1
	mov	BYTE PTR _cWk$[ebp], cl
	jmp	SHORT $LN10@UfDecryptS
$LN11@UfDecryptS:

; 2434 : 
; 2435 :             pchOut[ uChar ] = cWk + 'a';

	movsx	edx, BYTE PTR _cWk$[ebp]
	add	edx, 97					; 00000061H
	movzx	eax, WORD PTR _uChar$[ebp]
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [ecx+eax], dl

; 2436 :          }

	jmp	SHORT $LN22@UfDecryptS
$LN21@UfDecryptS:

; 2437 :          else
; 2438 :          {
; 2439 :             cWk = 0;

	mov	BYTE PTR _cWk$[ebp], 0
$LN12@UfDecryptS:

; 2440 :             while ( Encrypt2[ cWk ] != ucChar )

	movsx	edx, BYTE PTR _cWk$[ebp]
	movzx	eax, BYTE PTR _Encrypt2[edx]
	movzx	ecx, BYTE PTR _ucChar$[ebp]
	cmp	eax, ecx
	je	SHORT $LN13@UfDecryptS

; 2441 :                cWk++;

	mov	dl, BYTE PTR _cWk$[ebp]
	add	dl, 1
	mov	BYTE PTR _cWk$[ebp], dl
	jmp	SHORT $LN12@UfDecryptS
$LN13@UfDecryptS:

; 2442 : 
; 2443 :             pchOut[ uChar ] = cWk + 'a';

	movsx	eax, BYTE PTR _cWk$[ebp]
	add	eax, 97					; 00000061H
	movzx	ecx, WORD PTR _uChar$[ebp]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx+ecx], al
$LN22@UfDecryptS:

; 2444 :          }
; 2445 :       }

	jmp	SHORT $LN20@UfDecryptS
$LN19@UfDecryptS:

; 2446 :       else
; 2447 :       {
; 2448 :          zSHORT nIdx;
; 2449 : 
; 2450 :          // Look for the encrypted char in the non-alpha table.
; 2451 :          for ( nIdx = 32; nIdx < 127; nIdx++ )

	mov	eax, 32					; 00000020H
	mov	WORD PTR _nIdx$1[ebp], ax
	jmp	SHORT $LN16@UfDecryptS
$LN14@UfDecryptS:
	mov	cx, WORD PTR _nIdx$1[ebp]
	add	cx, 1
	mov	WORD PTR _nIdx$1[ebp], cx
$LN16@UfDecryptS:
	movsx	edx, WORD PTR _nIdx$1[ebp]
	cmp	edx, 127				; 0000007fH
	jge	SHORT $LN15@UfDecryptS

; 2452 :          {
; 2453 :             if ( EncryptNonAlpha[ nIdx ] == ucChar )

	movsx	eax, WORD PTR _nIdx$1[ebp]
	movzx	ecx, BYTE PTR _EncryptNonAlpha[eax]
	movzx	edx, BYTE PTR _ucChar$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN23@UfDecryptS

; 2454 :                break;

	jmp	SHORT $LN15@UfDecryptS
$LN23@UfDecryptS:

; 2455 :          }

	jmp	SHORT $LN14@UfDecryptS
$LN15@UfDecryptS:

; 2456 : 
; 2457 :          if ( nIdx == 127 )

	movsx	eax, WORD PTR _nIdx$1[ebp]
	cmp	eax, 127				; 0000007fH
	jne	SHORT $LN24@UfDecryptS

; 2458 :          {
; 2459 :             SysMessageBox( 0, "Zeidon Internal Error",

	push	0
	push	OFFSET $SG14203
	push	OFFSET $SG14204
	push	0
	call	_SysMessageBox@16

; 2460 :                            "Error decrypting string", 0 );
; 2461 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@UfDecryptS
$LN24@UfDecryptS:

; 2462 :          }
; 2463 : 
; 2464 :          pchOut[ uChar ] = (zCHAR) nIdx;

	movzx	ecx, WORD PTR _uChar$[ebp]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR _nIdx$1[ebp]
	mov	BYTE PTR [edx+ecx], al
$LN20@UfDecryptS:

; 2465 :       }
; 2466 : 
; 2467 :       cReturnLth--;

	mov	cl, BYTE PTR _cReturnLth$[ebp]
	sub	cl, 1
	mov	BYTE PTR _cReturnLth$[ebp], cl

; 2468 :       uChar++;

	mov	dx, WORD PTR _uChar$[ebp]
	add	dx, 1
	mov	WORD PTR _uChar$[ebp], dx

; 2469 :       nOrderIdx++;

	mov	ax, WORD PTR _nOrderIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nOrderIdx$[ebp], ax

; 2470 :    }

	jmp	$LN6@UfDecryptS
$LN7@UfDecryptS:

; 2471 : 
; 2472 :    pchOut[ uChar ] = 0;

	movzx	ecx, WORD PTR _uChar$[ebp]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 2473 : // zsprintf( szMsg, "UfDecryptString Out: \"%s\"", pchOut );
; 2474 : // TraceLineS( szMsg, "" );
; 2475 :    return( nReturnLth );

	mov	ax, WORD PTR _nReturnLth$[ebp]
$LN1@UfDecryptS:

; 2476 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_UfDecryptString@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_nInLth$ = -16						; size = 2
_uChar$ = -12						; size = 2
_nOrderIdx$ = -8					; size = 2
_bNullFound$ = -2					; size = 1
_cChar$ = -1						; size = 1
_pchOut$ = 8						; size = 4
_pchIn$ = 12						; size = 4
_uLth$ = 16						; size = 2
_UfEncryptString@12 PROC

; 2290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2291 :    zUSHORT uChar;
; 2292 :    zSHORT  nOrderIdx;
; 2293 :    zSHORT  nInLth;
; 2294 :    zCHAR   cChar;
; 2295 :    zBOOL   bNullFound;
; 2296 : // zCHAR   szMsg[ 256 ];
; 2297 : 
; 2298 : // zsprintf( szMsg, "UfEncryptString Length: %d   In: \"%s\"", uLth, pchIn );
; 2299 : // TraceLineS( szMsg, "" );
; 2300 : 
; 2301 :    if ( uLth > 26 )

	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	eax, 26					; 0000001aH
	jle	SHORT $LN17@UfEncryptS

; 2302 :       uLth = 26;

	mov	ecx, 26					; 0000001aH
	mov	WORD PTR _uLth$[ebp], cx
$LN17@UfEncryptS:

; 2303 : 
; 2304 :    uChar = 0;

	xor	edx, edx
	mov	WORD PTR _uChar$[ebp], dx

; 2305 :    nOrderIdx = 0;

	xor	eax, eax
	mov	WORD PTR _nOrderIdx$[ebp], ax

; 2306 :    bNullFound = FALSE;

	mov	BYTE PTR _bNullFound$[ebp], 0

; 2307 :    pchOut[ uLth ] = 0;

	movzx	ecx, WORD PTR _uLth$[ebp]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx+ecx], 0
$LN2@UfEncryptS:

; 2308 :    while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )

	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR _Encrypt2[eax]
	movzx	edx, WORD PTR _uLth$[ebp]
	sub	edx, 1
	cmp	ecx, edx
	jle	SHORT $LN3@UfEncryptS

; 2309 :       nOrderIdx++;

	mov	ax, WORD PTR _nOrderIdx$[ebp]
	add	ax, 1
	mov	WORD PTR _nOrderIdx$[ebp], ax
	jmp	SHORT $LN2@UfEncryptS
$LN3@UfEncryptS:

; 2310 : 
; 2311 :    nInLth = zstrlen( pchIn );

	mov	ecx, DWORD PTR _pchIn$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nInLth$[ebp], ax
$LN4@UfEncryptS:

; 2312 :    while ( (zUSHORT) nInLth > uLth || nInLth > 25 )

	movzx	edx, WORD PTR _nInLth$[ebp]
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	edx, eax
	jg	SHORT $LN18@UfEncryptS
	movsx	ecx, WORD PTR _nInLth$[ebp]
	cmp	ecx, 25					; 00000019H
	jle	SHORT $LN5@UfEncryptS
$LN18@UfEncryptS:

; 2313 :       nInLth -= uLth;

	movzx	edx, WORD PTR _uLth$[ebp]
	movsx	eax, WORD PTR _nInLth$[ebp]
	sub	eax, edx
	mov	WORD PTR _nInLth$[ebp], ax
	jmp	SHORT $LN4@UfEncryptS
$LN5@UfEncryptS:

; 2314 : 
; 2315 :    pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt1[ nInLth ];

	movsx	ecx, WORD PTR _nInLth$[ebp]
	movsx	edx, WORD PTR _nOrderIdx$[ebp]
	movzx	eax, BYTE PTR _Encrypt2[edx]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	cl, BYTE PTR _Encrypt1[ecx]
	mov	BYTE PTR [edx+eax], cl

; 2316 :    nOrderIdx++;

	mov	dx, WORD PTR _nOrderIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nOrderIdx$[ebp], dx
$LN6@UfEncryptS:

; 2317 :    while ( uChar < (uLth - 1) )

	movzx	eax, WORD PTR _uChar$[ebp]
	movzx	ecx, WORD PTR _uLth$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jge	$LN7@UfEncryptS
$LN8@UfEncryptS:

; 2318 :    {
; 2319 :       while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )

	movsx	edx, WORD PTR _nOrderIdx$[ebp]
	movzx	eax, BYTE PTR _Encrypt2[edx]
	movzx	ecx, WORD PTR _uLth$[ebp]
	sub	ecx, 1
	cmp	eax, ecx
	jle	SHORT $LN9@UfEncryptS

; 2320 :          nOrderIdx++;

	mov	dx, WORD PTR _nOrderIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nOrderIdx$[ebp], dx
	jmp	SHORT $LN8@UfEncryptS
$LN9@UfEncryptS:

; 2321 : 
; 2322 :       if ( bNullFound == FALSE && pchIn[ uChar ] )

	movzx	eax, BYTE PTR _bNullFound$[ebp]
	test	eax, eax
	jne	$LN19@UfEncryptS
	movzx	ecx, WORD PTR _uChar$[ebp]
	mov	edx, DWORD PTR _pchIn$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN19@UfEncryptS

; 2323 :       {
; 2324 :          cChar = pchIn[ uChar ];

	movzx	ecx, WORD PTR _uChar$[ebp]
	mov	edx, DWORD PTR _pchIn$[ebp]
	mov	al, BYTE PTR [edx+ecx]
	mov	BYTE PTR _cChar$[ebp], al

; 2325 : 
; 2326 :          if ( isalpha( cChar ) )

	movsx	ecx, BYTE PTR _cChar$[ebp]
	push	ecx
	call	DWORD PTR __imp__isalpha
	add	esp, 4
	test	eax, eax
	je	$LN21@UfEncryptS
$LN10@UfEncryptS:

; 2327 :          {
; 2328 :             while ( cChar >= 'a' )

	movsx	edx, BYTE PTR _cChar$[ebp]
	cmp	edx, 97					; 00000061H
	jl	SHORT $LN12@UfEncryptS

; 2329 :                cChar -= ' ';

	movsx	eax, BYTE PTR _cChar$[ebp]
	sub	eax, 32					; 00000020H
	mov	BYTE PTR _cChar$[ebp], al
	jmp	SHORT $LN10@UfEncryptS
$LN12@UfEncryptS:

; 2330 : 
; 2331 :             while ( cChar < 'A' )

	movsx	ecx, BYTE PTR _cChar$[ebp]
	cmp	ecx, 65					; 00000041H
	jge	SHORT $LN13@UfEncryptS

; 2332 :                cChar += 11;

	movsx	edx, BYTE PTR _cChar$[ebp]
	add	edx, 11					; 0000000bH
	mov	BYTE PTR _cChar$[ebp], dl
	jmp	SHORT $LN12@UfEncryptS
$LN13@UfEncryptS:

; 2333 : 
; 2334 :             cChar -= 'A';

	movsx	eax, BYTE PTR _cChar$[ebp]
	sub	eax, 65					; 00000041H
	mov	BYTE PTR _cChar$[ebp], al

; 2335 :             if ( uChar % 2 )

	movzx	ecx, WORD PTR _uChar$[ebp]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN29@UfEncryptS
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN29@UfEncryptS:
	test	ecx, ecx
	je	SHORT $LN23@UfEncryptS

; 2336 :                pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt1[ cChar ];

	movsx	edx, BYTE PTR _cChar$[ebp]
	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR _Encrypt2[eax]
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR _Encrypt1[edx]
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN24@UfEncryptS
$LN23@UfEncryptS:

; 2337 :             else
; 2338 :                pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt2[ cChar ];

	movsx	eax, BYTE PTR _cChar$[ebp]
	movsx	ecx, WORD PTR _nOrderIdx$[ebp]
	movzx	edx, BYTE PTR _Encrypt2[ecx]
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR _Encrypt2[eax]
	mov	BYTE PTR [ecx+edx], al
$LN24@UfEncryptS:

; 2339 :          }

	jmp	SHORT $LN22@UfEncryptS
$LN21@UfEncryptS:

; 2340 :          else
; 2341 :             pchOut[ Encrypt2[ nOrderIdx ] ] = EncryptNonAlpha[ cChar ] - 'a';

	movsx	ecx, BYTE PTR _cChar$[ebp]
	movzx	edx, BYTE PTR _EncryptNonAlpha[ecx]
	sub	edx, 97					; 00000061H
	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR _Encrypt2[eax]
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [eax+ecx], dl
$LN22@UfEncryptS:

; 2342 :       }

	jmp	SHORT $LN20@UfEncryptS
$LN19@UfEncryptS:

; 2343 :       else
; 2344 :       {
; 2345 :          cChar += 17;

	movsx	ecx, BYTE PTR _cChar$[ebp]
	add	ecx, 17					; 00000011H
	mov	BYTE PTR _cChar$[ebp], cl

; 2346 :          if ( cChar > 25 )

	movsx	edx, BYTE PTR _cChar$[ebp]
	cmp	edx, 25					; 00000019H
	jle	SHORT $LN25@UfEncryptS

; 2347 :             cChar -= 25;

	movsx	eax, BYTE PTR _cChar$[ebp]
	sub	eax, 25					; 00000019H
	mov	BYTE PTR _cChar$[ebp], al
$LN25@UfEncryptS:

; 2348 : 
; 2349 :          bNullFound = TRUE;

	mov	BYTE PTR _bNullFound$[ebp], 1

; 2350 :          if ( uChar % 2 )

	movzx	ecx, WORD PTR _uChar$[ebp]
	and	ecx, -2147483647			; 80000001H
	jns	SHORT $LN30@UfEncryptS
	dec	ecx
	or	ecx, -2					; fffffffeH
	inc	ecx
$LN30@UfEncryptS:
	test	ecx, ecx
	je	SHORT $LN26@UfEncryptS

; 2351 :             pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt2[ cChar ];

	movsx	edx, BYTE PTR _cChar$[ebp]
	movsx	eax, WORD PTR _nOrderIdx$[ebp]
	movzx	ecx, BYTE PTR _Encrypt2[eax]
	mov	eax, DWORD PTR _pchOut$[ebp]
	mov	dl, BYTE PTR _Encrypt2[edx]
	mov	BYTE PTR [eax+ecx], dl
	jmp	SHORT $LN20@UfEncryptS
$LN26@UfEncryptS:

; 2352 :          else
; 2353 :             pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt1[ cChar ];

	movsx	eax, BYTE PTR _cChar$[ebp]
	movsx	ecx, WORD PTR _nOrderIdx$[ebp]
	movzx	edx, BYTE PTR _Encrypt2[ecx]
	mov	ecx, DWORD PTR _pchOut$[ebp]
	mov	al, BYTE PTR _Encrypt1[eax]
	mov	BYTE PTR [ecx+edx], al
$LN20@UfEncryptS:

; 2354 :       }
; 2355 : 
; 2356 :       uChar++;

	mov	cx, WORD PTR _uChar$[ebp]
	add	cx, 1
	mov	WORD PTR _uChar$[ebp], cx

; 2357 :       nOrderIdx++;

	mov	dx, WORD PTR _nOrderIdx$[ebp]
	add	dx, 1
	mov	WORD PTR _nOrderIdx$[ebp], dx

; 2358 :    }

	jmp	$LN6@UfEncryptS
$LN7@UfEncryptS:

; 2359 : 
; 2360 :    for ( uChar = 0 ; uChar < uLth ; uChar++ )

	xor	eax, eax
	mov	WORD PTR _uChar$[ebp], ax
	jmp	SHORT $LN16@UfEncryptS
$LN14@UfEncryptS:
	mov	cx, WORD PTR _uChar$[ebp]
	add	cx, 1
	mov	WORD PTR _uChar$[ebp], cx
$LN16@UfEncryptS:
	movzx	edx, WORD PTR _uChar$[ebp]
	movzx	eax, WORD PTR _uLth$[ebp]
	cmp	edx, eax
	jge	SHORT $LN15@UfEncryptS

; 2361 :       pchOut[ uChar ] += 'a';

	movzx	ecx, WORD PTR _uChar$[ebp]
	mov	edx, DWORD PTR _pchOut$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	add	eax, 97					; 00000061H
	movzx	ecx, WORD PTR _uChar$[ebp]
	mov	edx, DWORD PTR _pchOut$[ebp]
	mov	BYTE PTR [edx+ecx], al
	jmp	SHORT $LN14@UfEncryptS
$LN15@UfEncryptS:

; 2362 : 
; 2363 : // zsprintf( szMsg, "UfEncryptString Out: \"%s\"", pchOut );
; 2364 : // TraceLineS( szMsg, "" );
; 2365 :    return( 0 );

	xor	eax, eax

; 2366 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_UfEncryptString@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv82 = -16						; size = 4
_i$ = -12						; size = 2
_k$ = -8						; size = 2
_j$ = -4						; size = 2
_pchReturnString$ = 8					; size = 4
_cpcFormat$ = 12					; size = 4
_UfFormatString@8 PROC

; 3124 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi

; 3125 :    zSHORT k, j, i;
; 3126 : 
; 3127 :    k = 0;

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax

; 3128 :    j = 0;

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx

; 3129 : 
; 3130 :    if ( pchReturnString[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN10@UfFormatSt

; 3131 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@UfFormatSt
$LN10@UfFormatSt:

; 3132 : 
; 3133 :    if ( cpcFormat == 0 || cpcFormat[ 0 ] == 0 )

	cmp	DWORD PTR _cpcFormat$[ebp], 0
	je	SHORT $LN12@UfFormatSt
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@UfFormatSt
$LN12@UfFormatSt:

; 3134 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@UfFormatSt
$LN2@UfFormatSt:

; 3135 : 
; 3136 :    while ( cpcFormat[ k ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN3@UfFormatSt

; 3137 :    {
; 3138 :       switch ( cpcFormat[ k ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR tv82[ebp], eax
	mov	ecx, DWORD PTR tv82[ebp]
	sub	ecx, 57					; 00000039H
	mov	DWORD PTR tv82[ebp], ecx
	cmp	DWORD PTR tv82[ebp], 31			; 0000001fH
	ja	$LN27@UfFormatSt
	mov	edx, DWORD PTR tv82[ebp]
	movzx	eax, BYTE PTR $LN33@UfFormatSt[edx]
	jmp	DWORD PTR $LN34@UfFormatSt[eax*4]
$LN13@UfFormatSt:

; 3139 :       {
; 3140 :          case  '9':
; 3141 :             if ( !isdigit( pchReturnString[ j ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN14@UfFormatSt

; 3142 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfFormatSt
$LN14@UfFormatSt:

; 3143 : 
; 3144 :             break;

	jmp	$LN4@UfFormatSt
$LN15@UfFormatSt:

; 3145 : 
; 3146 :          case  'A':
; 3147 :             if ( !isalpha( pchReturnString[ j ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN16@UfFormatSt

; 3148 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfFormatSt
$LN16@UfFormatSt:

; 3149 : 
; 3150 :             break;

	jmp	$LN4@UfFormatSt
$LN17@UfFormatSt:

; 3151 : 
; 3152 :          case  'N':
; 3153 :             if ( !zisalnum( pchReturnString[ j ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN18@UfFormatSt

; 3154 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfFormatSt
$LN18@UfFormatSt:

; 3155 : 
; 3156 :             break;

	jmp	$LN4@UfFormatSt
$LN19@UfFormatSt:

; 3157 : 
; 3158 :          case  'X':
; 3159 :             if ( !zisascii( pchReturnString[ j ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 128				; 00000080H
	jb	SHORT $LN20@UfFormatSt

; 3160 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfFormatSt
$LN20@UfFormatSt:

; 3161 : 
; 3162 :             break;

	jmp	$LN4@UfFormatSt
$LN21@UfFormatSt:

; 3163 : 
; 3164 :          case  'U':
; 3165 :             if ( !isupper( pchReturnString[ j ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isupper
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN22@UfFormatSt

; 3166 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfFormatSt
$LN22@UfFormatSt:

; 3167 : 
; 3168 :             break;

	jmp	$LN4@UfFormatSt
$LN23@UfFormatSt:

; 3169 : 
; 3170 :          case  'L':
; 3171 :             if ( !islower( pchReturnString[ j ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__islower
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN24@UfFormatSt

; 3172 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfFormatSt
$LN24@UfFormatSt:

; 3173 : 
; 3174 :             break;

	jmp	$LN4@UfFormatSt
$LN25@UfFormatSt:

; 3175 : 
; 3176 :          case  'H':
; 3177 :             if ( !isxdigit( pchReturnString[ j ] ) )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isxdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN26@UfFormatSt

; 3178 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfFormatSt
$LN26@UfFormatSt:

; 3179 : 
; 3180 :             break;

	jmp	$LN4@UfFormatSt
$LN27@UfFormatSt:

; 3181 : 
; 3182 :          default:
; 3183 :             if ( cpcFormat[ k ] == '\\' )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN28@UfFormatSt

; 3184 :             {
; 3185 :                if ( cpcFormat[ k + 1 ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+1]
	test	eax, eax
	je	SHORT $LN29@UfFormatSt

; 3186 :                   k++;

	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN28@UfFormatSt
$LN29@UfFormatSt:

; 3187 :                else
; 3188 :                   break;

	jmp	SHORT $LN4@UfFormatSt
$LN28@UfFormatSt:

; 3189 :             }
; 3190 : 
; 3191 :             i = j;

	mov	dx, WORD PTR _j$[ebp]
	mov	WORD PTR _i$[ebp], dx
$LN6@UfFormatSt:

; 3192 :             while ( pchReturnString[ i ] )

	movsx	eax, WORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN8@UfFormatSt

; 3193 :                i++;

	mov	ax, WORD PTR _i$[ebp]
	add	ax, 1
	mov	WORD PTR _i$[ebp], ax
	jmp	SHORT $LN6@UfFormatSt
$LN8@UfFormatSt:

; 3194 : 
; 3195 :             while ( i >= j ) // brute force

	movsx	ecx, WORD PTR _i$[ebp]
	movsx	edx, WORD PTR _j$[ebp]
	cmp	ecx, edx
	jl	SHORT $LN9@UfFormatSt

; 3196 :             {
; 3197 :                pchReturnString[ i + 1 ] = pchReturnString[ i ];

	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	esi, DWORD PTR _pchReturnString$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx+1], al

; 3198 :                i--;

	mov	cx, WORD PTR _i$[ebp]
	sub	cx, 1
	mov	WORD PTR _i$[ebp], cx

; 3199 :             }

	jmp	SHORT $LN8@UfFormatSt
$LN9@UfFormatSt:

; 3200 : 
; 3201 :             pchReturnString[ j ] = cpcFormat[ k ];

	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	mov	esi, DWORD PTR _cpcFormat$[ebp]
	mov	dl, BYTE PTR [esi+edx]
	mov	BYTE PTR [ecx+eax], dl
$LN4@UfFormatSt:

; 3202 :       }
; 3203 : 
; 3204 :       k++;

	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax

; 3205 :       j++;

	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx

; 3206 :    }

	jmp	$LN2@UfFormatSt
$LN3@UfFormatSt:

; 3207 : 
; 3208 :    // Error if the string is 'longer' than the format string.
; 3209 :    if ( pchReturnString[ j ] )

	movsx	edx, WORD PTR _j$[ebp]
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN31@UfFormatSt

; 3210 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@UfFormatSt
$LN31@UfFormatSt:

; 3211 : 
; 3212 :    return( 0 );

	xor	eax, eax
$LN1@UfFormatSt:

; 3213 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN34@UfFormatSt:
	DD	$LN13@UfFormatSt
	DD	$LN15@UfFormatSt
	DD	$LN25@UfFormatSt
	DD	$LN23@UfFormatSt
	DD	$LN17@UfFormatSt
	DD	$LN21@UfFormatSt
	DD	$LN19@UfFormatSt
	DD	$LN27@UfFormatSt
$LN33@UfFormatSt:
	DB	0
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	1
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	2
	DB	7
	DB	7
	DB	7
	DB	3
	DB	7
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	6
_UfFormatString@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv249 = -32						; size = 4
tv225 = -28						; size = 4
tv190 = -24						; size = 4
tv82 = -20						; size = 4
_l$ = -16						; size = 2
_k$ = -12						; size = 2
_i$ = -8						; size = 2
_j$ = -4						; size = 2
_pchReturnString$ = 8					; size = 4
_cpcFormat$ = 12					; size = 4
_UfEditFormatString@8 PROC

; 2968 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi

; 2969 :    zSHORT   i, j, k, l;
; 2970 : 
; 2971 :    k = 0;

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax

; 2972 :    j = 0;

	xor	ecx, ecx
	mov	WORD PTR _j$[ebp], cx

; 2973 :    if ( cpcFormat == 0 || cpcFormat[ 0 ] == 0 || pchReturnString[ 0 ] == 0 )

	cmp	DWORD PTR _cpcFormat$[ebp], 0
	je	SHORT $LN18@UfEditForm
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcFormat$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN18@UfEditForm
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN2@UfEditForm
$LN18@UfEditForm:

; 2974 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@UfEditForm
$LN2@UfEditForm:

; 2975 : 
; 2976 :    while ( pchReturnString[ j ] )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN3@UfEditForm

; 2977 :    {
; 2978 :       switch ( cpcFormat[ k ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR tv82[ebp], eax
	cmp	DWORD PTR tv82[ebp], 92			; 0000005cH
	ja	$LN41@UfEditForm
	mov	ecx, DWORD PTR tv82[ebp]
	movzx	edx, BYTE PTR $LN45@UfEditForm[ecx]
	jmp	DWORD PTR $LN46@UfEditForm[edx*4]
$LN19@UfEditForm:

; 2979 :       {
; 2980 :          case  0:
; 2981 :             return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN20@UfEditForm:

; 2982 : 
; 2983 :          case  '9':
; 2984 :             if ( !isdigit( pchReturnString[ j ] ) )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN21@UfEditForm

; 2985 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN21@UfEditForm:

; 2986 :             break;

	jmp	$LN4@UfEditForm
$LN22@UfEditForm:

; 2987 : 
; 2988 :          case  'A':
; 2989 :             if ( !isalpha( pchReturnString[ j ] ) )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	DWORD PTR __imp__isalpha
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN23@UfEditForm

; 2990 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN23@UfEditForm:

; 2991 :             break;

	jmp	$LN4@UfEditForm
$LN24@UfEditForm:

; 2992 : 
; 2993 :          case  'N':
; 2994 :             if ( !zisalnum( pchReturnString[ j ] ) )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN25@UfEditForm

; 2995 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN25@UfEditForm:

; 2996 :             break;

	jmp	$LN4@UfEditForm
$LN26@UfEditForm:

; 2997 : 
; 2998 :          case  'X':
; 2999 :             if ( !zisascii( pchReturnString[ j ] ) )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 128				; 00000080H
	jb	SHORT $LN27@UfEditForm

; 3000 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN27@UfEditForm:

; 3001 :             break;

	jmp	$LN4@UfEditForm
$LN28@UfEditForm:

; 3002 : 
; 3003 :          case  'L':
; 3004 :             if ( !islower( pchReturnString[ j ] ) )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	DWORD PTR __imp__islower
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN29@UfEditForm

; 3005 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN29@UfEditForm:

; 3006 :             break;

	jmp	$LN4@UfEditForm
$LN30@UfEditForm:

; 3007 : 
; 3008 :          case  'U':
; 3009 :             if ( !isupper( pchReturnString[ j ] ) )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	DWORD PTR __imp__isupper
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN31@UfEditForm

; 3010 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN31@UfEditForm:

; 3011 :             break;

	jmp	$LN4@UfEditForm
$LN32@UfEditForm:

; 3012 : 
; 3013 :          case  'H':
; 3014 :             if ( !isxdigit( pchReturnString[ j ] ) )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	push	edx
	call	DWORD PTR __imp__isxdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN33@UfEditForm

; 3015 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN33@UfEditForm:

; 3016 :             break;

	jmp	$LN4@UfEditForm
$LN34@UfEditForm:

; 3017 : 
; 3018 :          case  '\\':
; 3019 :             if ( cpcFormat[ ++k ] == 0 )

	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	jne	SHORT $LN35@UfEditForm

; 3020 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN35@UfEditForm:

; 3021 : 
; 3022 :             if ( pchReturnString[ j ] != cpcFormat[ k ] )

	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	ecx, BYTE PTR [edx+ecx]
	cmp	eax, ecx
	je	SHORT $LN36@UfEditForm

; 3023 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN36@UfEditForm:

; 3024 : 
; 3025 :             i = j;

	mov	dx, WORD PTR _j$[ebp]
	mov	WORD PTR _i$[ebp], dx
$LN8@UfEditForm:

; 3026 :             do
; 3027 :             {
; 3028 :                pchReturnString[ i ] = pchReturnString[ i + 1 ];

	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	esi, DWORD PTR _pchReturnString$[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx], al

; 3029 : 
; 3030 :             } while ( pchReturnString[ i++ ] );

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR tv190[ebp], eax
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
	cmp	DWORD PTR tv190[ebp], 0
	jne	SHORT $LN8@UfEditForm

; 3031 : 
; 3032 :             j--;

	mov	dx, WORD PTR _j$[ebp]
	sub	dx, 1
	mov	WORD PTR _j$[ebp], dx

; 3033 :             break;

	jmp	$LN4@UfEditForm
$LN37@UfEditForm:

; 3034 : 
; 3035 :          case  ' ':
; 3036 :             // This code treats all spaces in pchReturnString as one space,
; 3037 :             // seems like we should consider how many spaces are in
; 3038 :             // cpcFormat.
; 3039 : 
; 3040 :             if ( pchReturnString[ j ] == ' ' )

	movsx	eax, WORD PTR _j$[ebp]
	mov	ecx, DWORD PTR _pchReturnString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 32					; 00000020H
	jne	$LN38@UfEditForm

; 3041 :             {
; 3042 :                i = j + 1;

	movsx	eax, WORD PTR _j$[ebp]
	add	eax, 1
	mov	WORD PTR _i$[ebp], ax

; 3043 :                if ( cpcFormat[ k + 1 ] != ' ' )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+1]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN40@UfEditForm
$LN9@UfEditForm:

; 3044 :                {
; 3045 :                   while( pchReturnString[ i ] == ' ' )

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN40@UfEditForm

; 3046 :                      i++;

	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
	jmp	SHORT $LN9@UfEditForm
$LN40@UfEditForm:

; 3047 :                }
; 3048 : 
; 3049 :                l = j;

	mov	dx, WORD PTR _j$[ebp]
	mov	WORD PTR _l$[ebp], dx
$LN13@UfEditForm:

; 3050 :                do
; 3051 :                {
; 3052 :                   pchReturnString[ l++ ] = pchReturnString[ i ];

	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _l$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	esi, DWORD PTR _pchReturnString$[ebp]
	mov	al, BYTE PTR [esi+eax]
	mov	BYTE PTR [edx+ecx], al
	mov	cx, WORD PTR _l$[ebp]
	add	cx, 1
	mov	WORD PTR _l$[ebp], cx

; 3053 : 
; 3054 :                } while ( pchReturnString[ i++ ] );

	movsx	edx, WORD PTR _i$[ebp]
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	mov	DWORD PTR tv225[ebp], ecx
	mov	dx, WORD PTR _i$[ebp]
	add	dx, 1
	mov	WORD PTR _i$[ebp], dx
	cmp	DWORD PTR tv225[ebp], 0
	jne	SHORT $LN13@UfEditForm

; 3055 : 
; 3056 :                j--;

	mov	ax, WORD PTR _j$[ebp]
	sub	ax, 1
	mov	WORD PTR _j$[ebp], ax

; 3057 :             }

	jmp	SHORT $LN39@UfEditForm
$LN38@UfEditForm:

; 3058 :             else
; 3059 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@UfEditForm
$LN39@UfEditForm:

; 3060 : 
; 3061 :             break;

	jmp	SHORT $LN4@UfEditForm
$LN41@UfEditForm:

; 3062 : 
; 3063 :          default:
; 3064 :             if ( cpcFormat[ k ] != pchReturnString[ j ] )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _cpcFormat$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	movsx	ecx, WORD PTR _j$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	ecx, BYTE PTR [edx+ecx]
	cmp	eax, ecx
	je	SHORT $LN42@UfEditForm

; 3065 :                return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@UfEditForm
$LN42@UfEditForm:

; 3066 : 
; 3067 :             i = j;

	mov	dx, WORD PTR _j$[ebp]
	mov	WORD PTR _i$[ebp], dx
$LN16@UfEditForm:

; 3068 :             do
; 3069 :             {
; 3070 :                pchReturnString[ i ] = pchReturnString[ i + 1 ];

	movsx	eax, WORD PTR _i$[ebp]
	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	esi, DWORD PTR _pchReturnString$[ebp]
	mov	al, BYTE PTR [esi+eax+1]
	mov	BYTE PTR [edx+ecx], al

; 3071 : 
; 3072 :             } while ( pchReturnString[ i++ ] );

	movsx	ecx, WORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	mov	DWORD PTR tv249[ebp], eax
	mov	cx, WORD PTR _i$[ebp]
	add	cx, 1
	mov	WORD PTR _i$[ebp], cx
	cmp	DWORD PTR tv249[ebp], 0
	jne	SHORT $LN16@UfEditForm

; 3073 : 
; 3074 :             j--;

	mov	dx, WORD PTR _j$[ebp]
	sub	dx, 1
	mov	WORD PTR _j$[ebp], dx
$LN4@UfEditForm:

; 3075 :       }
; 3076 : 
; 3077 :       k++;

	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax

; 3078 :       j++;

	mov	cx, WORD PTR _j$[ebp]
	add	cx, 1
	mov	WORD PTR _j$[ebp], cx

; 3079 :    }

	jmp	$LN2@UfEditForm
$LN3@UfEditForm:

; 3080 : 
; 3081 :    if ( cpcFormat[ k ] )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _cpcFormat$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	je	SHORT $LN43@UfEditForm

; 3082 :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@UfEditForm
$LN43@UfEditForm:

; 3083 : 
; 3084 :    return( 0 );

	xor	eax, eax
$LN1@UfEditForm:

; 3085 : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN46@UfEditForm:
	DD	$LN19@UfEditForm
	DD	$LN37@UfEditForm
	DD	$LN20@UfEditForm
	DD	$LN22@UfEditForm
	DD	$LN32@UfEditForm
	DD	$LN28@UfEditForm
	DD	$LN24@UfEditForm
	DD	$LN30@UfEditForm
	DD	$LN26@UfEditForm
	DD	$LN34@UfEditForm
	DD	$LN41@UfEditForm
$LN45@UfEditForm:
	DB	0
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	1
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	2
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	3
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	4
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	5
	DB	10					; 0000000aH
	DB	6
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	7
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	8
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	10					; 0000000aH
	DB	9
_UfEditFormatString@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
_pchReturnString$ = -152				; size = 4
tv539 = -148						; size = 4
tv538 = -144						; size = 4
tv94 = -140						; size = 4
tv93 = -136						; size = 4
tv607 = -132						; size = 4
tv605 = -128						; size = 4
_szJulian$ = -124					; size = 4
$T1 = -120						; size = 4
tv367 = -116						; size = 4
$T2 = -112						; size = 4
tv204 = -108						; size = 4
_lpInternational$3 = -104				; size = 4
_lpInternational$4 = -100				; size = 4
tv128 = -96						; size = 4
_l$5 = -92						; size = 4
_pch$6 = -88						; size = 4
_pchTrailer$7 = -84					; size = 4
_bBadEditString$ = -79					; size = 1
_bAdjustTime$ = -78					; size = 1
_bTwelveHourClock$ = -77				; size = 1
_bConvertJulian$ = -76					; size = 1
_bLongFormat$8 = -75					; size = 1
_bLongFormat$9 = -74					; size = 1
_chDelimiter$ = -73					; size = 1
_n$ = -72						; size = 2
_bDayNeeded$ = -65					; size = 1
_k$ = -64						; size = 2
_bError$ = -57						; size = 1
_szG$10 = -56						; size = 9
_sz$ = -44						; size = 18
_szDT$ = -24						; size = 18
__$ArrayPad$ = -4					; size = 4
_pchDTString$ = 8					; size = 4
_cpcEditString$ = 12					; size = 4
_UfEditFormatDateTime@8 PROC

; 865  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 152				; 00000098H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 866  :    zPCHAR   pchReturnString = pchDTString;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	DWORD PTR _pchReturnString$[ebp], eax

; 867  :    zCHAR    szDT[ 18 ];
; 868  :    zCHAR    sz[ 18 ];
; 869  :    zCHAR    szJulian[ 4 ];
; 870  :    zCHAR    chDelimiter = 0;

	mov	BYTE PTR _chDelimiter$[ebp], 0

; 871  :    zSHORT   k, n;
; 872  :    zBOOL    bError = 0;

	mov	BYTE PTR _bError$[ebp], 0

; 873  :    zBOOL    bBadEditString = 0;

	mov	BYTE PTR _bBadEditString$[ebp], 0

; 874  :    zBOOL    bConvertJulian = 0;  // used when julian date is in the format

	mov	BYTE PTR _bConvertJulian$[ebp], 0

; 875  :    zBOOL    bTwelveHourClock = 0;

	mov	BYTE PTR _bTwelveHourClock$[ebp], 0

; 876  :    zBOOL    bAdjustTime = 0;     // used w/12 hour clock and time is PM

	mov	BYTE PTR _bAdjustTime$[ebp], 0

; 877  :    zBOOL    bDayNeeded = 0;      // used to see if day is in edit string (e.g.mm/YYYY)

	mov	BYTE PTR _bDayNeeded$[ebp], 0

; 878  : 
; 879  :    // If null input, just return a 0.
; 880  :    if ( pchDTString == 0 || pchDTString[ 0 ] == 0 )

	cmp	DWORD PTR _pchDTString$[ebp], 0
	je	SHORT $LN20@UfEditForm
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchDTString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN19@UfEditForm
$LN20@UfEditForm:

; 881  :       return( 0 );

	xor	eax, eax
	jmp	$LN120@UfEditForm
$LN19@UfEditForm:

; 882  : 
; 883  :    // If null edit string, error?
; 884  :    if ( cpcEditString == 0 || cpcEditString[ 0 ] == 0 )

	cmp	DWORD PTR _cpcEditString$[ebp], 0
	je	SHORT $LN22@UfEditForm
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	jne	SHORT $LN21@UfEditForm
$LN22@UfEditForm:

; 885  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN120@UfEditForm
$LN21@UfEditForm:

; 886  : 
; 887  :    // init scan pointers
; 888  :    k = sizeof( szDT ) - 1;

	mov	eax, 17					; 00000011H
	mov	WORD PTR _k$[ebp], ax

; 889  :    zmemset( szDT, 'X', k );

	movsx	ecx, WORD PTR _k$[ebp]
	push	ecx
	push	88					; 00000058H
	lea	edx, DWORD PTR _szDT$[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 890  :    *(szDT + k) = 0;

	movsx	eax, WORD PTR _k$[ebp]
	mov	BYTE PTR _szDT$[ebp+eax], 0
$LN2@UfEditForm:

; 891  : 
; 892  :    while ( *cpcEditString )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN3@UfEditForm

; 893  :    {
; 894  :       if ( chDelimiter )

	movsx	eax, BYTE PTR _chDelimiter$[ebp]
	test	eax, eax
	je	SHORT $LN23@UfEditForm

; 895  :       {
; 896  :          if ( *cpcEditString == chDelimiter )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR _chDelimiter$[ebp]
	cmp	edx, eax
	jne	SHORT $LN25@UfEditForm

; 897  :          {
; 898  :             chDelimiter = 0;

	mov	BYTE PTR _chDelimiter$[ebp], 0

; 899  :             cpcEditString++;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 900  :          }

	jmp	SHORT $LN26@UfEditForm
$LN25@UfEditForm:

; 901  :          else
; 902  :          {
; 903  :             if ( *cpcEditString++ != *pchDTString++ )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv93[ebp], eax
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv94[ebp], edx
	mov	eax, DWORD PTR _pchDTString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchDTString$[ebp], eax
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cpcEditString$[ebp], ecx
	mov	edx, DWORD PTR tv93[ebp]
	cmp	edx, DWORD PTR tv94[ebp]
	je	SHORT $LN26@UfEditForm

; 904  :             {
; 905  :                // error
; 906  :                bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1

; 907  :                break;

	jmp	$LN3@UfEditForm
$LN26@UfEditForm:

; 908  :             }
; 909  :          }
; 910  :       }

	jmp	$LN24@UfEditForm
$LN23@UfEditForm:

; 911  :       else
; 912  :       switch ( *cpcEditString )

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv128[ebp], ecx
	mov	edx, DWORD PTR tv128[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR tv128[ebp], edx
	cmp	DWORD PTR tv128[ebp], 77		; 0000004dH
	ja	$LN108@UfEditForm
	mov	eax, DWORD PTR tv128[ebp]
	movzx	ecx, BYTE PTR $LN133@UfEditForm[eax]
	jmp	DWORD PTR $LN134@UfEditForm[ecx*4]
$LN28@UfEditForm:

; 913  :       {
; 914  :          case 'A':
; 915  :          case 'P':
; 916  :             if ( *(cpcEditString + 1) == 'M' )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 77					; 0000004dH
	jne	$LN29@UfEditForm

; 917  :             {
; 918  :                zPCHAR          pchTrailer;
; 919  :                LPINTERNATIONAL lpInternational =

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2515]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$4[ebp], eax

; 920  :                                     zGETPTR( AnchorBlock->hInternational );
; 921  : 
; 922  :                bTwelveHourClock = TRUE;

	mov	BYTE PTR _bTwelveHourClock$[ebp], 1

; 923  :                if ( lpInternational->sz1159[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpInternational$4[ebp]
	movsx	eax, BYTE PTR [edx+ecx+86]
	test	eax, eax
	jne	SHORT $LN31@UfEditForm

; 924  :                   pchTrailer = "AM";

	mov	DWORD PTR _pchTrailer$7[ebp], OFFSET $SG13606
	jmp	SHORT $LN32@UfEditForm
$LN31@UfEditForm:

; 925  :                else
; 926  :                   pchTrailer = lpInternational->sz1159;

	mov	ecx, DWORD PTR _lpInternational$4[ebp]
	add	ecx, 86					; 00000056H
	mov	DWORD PTR _pchTrailer$7[ebp], ecx
$LN32@UfEditForm:

; 927  : 
; 928  :                n = zstrlen( pchTrailer );

	mov	edx, DWORD PTR _pchTrailer$7[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n$[ebp], ax

; 929  : 
; 930  :                // first check for the am time trailer
; 931  :                if ( zstrncmp( pchDTString, pchTrailer, n ) == 0 )

	movsx	eax, WORD PTR _n$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTrailer$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchDTString$[ebp]
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN33@UfEditForm

; 932  :                {
; 933  :                   pchDTString += n;

	movsx	eax, WORD PTR _n$[ebp]
	add	eax, DWORD PTR _pchDTString$[ebp]
	mov	DWORD PTR _pchDTString$[ebp], eax

; 934  :                   cpcEditString += 2;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 935  :                }

	jmp	$LN34@UfEditForm
$LN33@UfEditForm:

; 936  :                else
; 937  :                {
; 938  :                   LPINTERNATIONAL lpInternational =

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$3[ebp], eax

; 939  :                                     zGETPTR( AnchorBlock->hInternational );
; 940  : 
; 941  :                   if ( lpInternational->sz2359[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpInternational$3[ebp]
	movsx	ecx, BYTE PTR [eax+edx+91]
	test	ecx, ecx
	jne	SHORT $LN35@UfEditForm

; 942  :                      pchTrailer = "PM";

	mov	DWORD PTR _pchTrailer$7[ebp], OFFSET $SG13611
	jmp	SHORT $LN36@UfEditForm
$LN35@UfEditForm:

; 943  :                   else
; 944  :                      pchTrailer = lpInternational->sz2359;

	mov	edx, DWORD PTR _lpInternational$3[ebp]
	add	edx, 91					; 0000005bH
	mov	DWORD PTR _pchTrailer$7[ebp], edx
$LN36@UfEditForm:

; 945  : 
; 946  :                   n = zstrlen( pchTrailer );

	mov	eax, DWORD PTR _pchTrailer$7[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n$[ebp], ax

; 947  :                   // next check for the pm time trailer
; 948  :                   if ( zstrncmp( pchDTString, pchTrailer, n ) == 0 )

	movsx	ecx, WORD PTR _n$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchTrailer$7[ebp]
	push	edx
	mov	eax, DWORD PTR _pchDTString$[ebp]
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN37@UfEditForm

; 949  :                   {
; 950  :                      bAdjustTime = TRUE;

	mov	BYTE PTR _bAdjustTime$[ebp], 1

; 951  :                      pchDTString += n;

	movsx	ecx, WORD PTR _n$[ebp]
	add	ecx, DWORD PTR _pchDTString$[ebp]
	mov	DWORD PTR _pchDTString$[ebp], ecx

; 952  :                      cpcEditString += 2;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 2
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 953  :                   }

	jmp	SHORT $LN34@UfEditForm
$LN37@UfEditForm:

; 954  :                   else
; 955  :                   {
; 956  :                      // error
; 957  :                      bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN34@UfEditForm:

; 958  :                   }
; 959  :                }
; 960  :             }

	jmp	SHORT $LN30@UfEditForm
$LN29@UfEditForm:

; 961  :             else
; 962  :                bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN30@UfEditForm:

; 963  : 
; 964  :             break;

	jmp	$LN24@UfEditForm
$LN39@UfEditForm:

; 965  : 
; 966  :          case 'd':
; 967  :          case 'D':
; 968  :             if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "DD", 2 ) == 0 )

	push	2
	push	OFFSET $SG13617
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN40@UfEditForm

; 969  :             {
; 970  :                zBOOL bLongFormat = 0;

	mov	BYTE PTR _bLongFormat$9[ebp], 0

; 971  : 
; 972  :                if ( ztoupper( *(cpcEditString + 3) ) == 'D' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+3]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 68					; 00000044H
	jne	SHORT $LN42@UfEditForm

; 973  :                   bLongFormat = TRUE;

	mov	BYTE PTR _bLongFormat$9[ebp], 1
$LN42@UfEditForm:

; 974  : 
; 975  :                bDayNeeded = TRUE;

	mov	BYTE PTR _bDayNeeded$[ebp], 1

; 976  : 
; 977  :                // Day of the week
; 978  :                for ( k = 0; k < 7; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN8@UfEditForm
$LN6@UfEditForm:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN8@UfEditForm:
	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 7
	jge	$LN7@UfEditForm

; 979  :                {
; 980  :                   if ( ztoupper( *pchDTString ) == *g_pchDOW[ k ] )

	mov	eax, DWORD PTR _pchDTString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	movsx	edx, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _g_pchDOW[edx*4]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN43@UfEditForm

; 981  :                   {
; 982  :                      n = bLongFormat ? zstrlen( g_pchDOW[ k ] ) : 3;

	movzx	eax, BYTE PTR _bLongFormat$9[ebp]
	test	eax, eax
	je	SHORT $LN121@UfEditForm
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_pchDOW[ecx*4]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv204[ebp], eax
	jmp	SHORT $LN122@UfEditForm
$LN121@UfEditForm:
	mov	DWORD PTR tv204[ebp], 3
$LN122@UfEditForm:
	mov	ax, WORD PTR tv204[ebp]
	mov	WORD PTR _n$[ebp], ax

; 983  :                      if ( zstrncmpi( pchDTString, g_pchDOW[ k ], n ) == 0 )

	movsx	ecx, WORD PTR _n$[ebp]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _g_pchDOW[edx*4]
	push	eax
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN43@UfEditForm

; 984  :                      {
; 985  :                         pchDTString += n; // bump past the day of the week

	movsx	edx, WORD PTR _n$[ebp]
	add	edx, DWORD PTR _pchDTString$[ebp]
	mov	DWORD PTR _pchDTString$[ebp], edx

; 986  :                         cpcEditString += ( 3 + bLongFormat );

	movzx	eax, BYTE PTR _bLongFormat$9[ebp]
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	lea	edx, DWORD PTR [ecx+eax+3]
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 987  :                         break;

	jmp	SHORT $LN7@UfEditForm
$LN43@UfEditForm:

; 988  :                      }
; 989  :                   }
; 990  :                }

	jmp	$LN6@UfEditForm
$LN7@UfEditForm:

; 991  :                if ( k == 7 )

	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 7
	jne	SHORT $LN45@UfEditForm

; 992  :                {
; 993  :                   // error
; 994  :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN45@UfEditForm:

; 995  :                }
; 996  :             }

	jmp	$LN41@UfEditForm
$LN40@UfEditForm:

; 997  :             else
; 998  :             if ( ztoupper( *(cpcEditString + 1) ) == 'D' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 68					; 00000044H
	jne	SHORT $LN46@UfEditForm

; 999  :             {
; 1000 :                // two digit day of month
; 1001 :                bDayNeeded = TRUE;

	mov	BYTE PTR _bDayNeeded$[ebp], 1

; 1002 :                if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )

	mov	eax, DWORD PTR _pchDTString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN48@UfEditForm
	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN48@UfEditForm

; 1003 :                {
; 1004 :                   *(szDT + 6) = *pchDTString++;

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _szDT$[ebp+6], dl
	mov	eax, DWORD PTR _pchDTString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchDTString$[ebp], eax

; 1005 :                   *(szDT + 7) = *pchDTString++;

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _szDT$[ebp+7], dl
	mov	eax, DWORD PTR _pchDTString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchDTString$[ebp], eax

; 1006 :                   cpcEditString += 2;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 1007 :                }

	jmp	SHORT $LN49@UfEditForm
$LN48@UfEditForm:

; 1008 :                else
; 1009 :                {
; 1010 :                   // error
; 1011 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN49@UfEditForm:

; 1012 :                }
; 1013 :             }

	jmp	SHORT $LN41@UfEditForm
$LN46@UfEditForm:

; 1014 :             else
; 1015 :             {
; 1016 :                // must be day of month with no leading zero
; 1017 :                bDayNeeded = TRUE;

	mov	BYTE PTR _bDayNeeded$[ebp], 1

; 1018 :                if ( isdigit( *pchDTString ) )

	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN50@UfEditForm

; 1019 :                {
; 1020 :                   if ( isdigit( *(pchDTString + 1) ) )

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN52@UfEditForm

; 1021 :                   {
; 1022 :                      *(szDT + 6) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+6], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1023 :                      *(szDT + 7) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+7], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1024 :                   }

	jmp	SHORT $LN53@UfEditForm
$LN52@UfEditForm:

; 1025 :                   else
; 1026 :                   {
; 1027 :                      *(szDT + 6) = '0';

	mov	BYTE PTR _szDT$[ebp+6], 48		; 00000030H

; 1028 :                      *(szDT + 7) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+7], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx
$LN53@UfEditForm:

; 1029 :                   }
; 1030 :                   cpcEditString++;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 1031 :                }

	jmp	SHORT $LN41@UfEditForm
$LN50@UfEditForm:

; 1032 :                else
; 1033 :                {
; 1034 :                   // error
; 1035 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN41@UfEditForm:

; 1036 :                }
; 1037 :             }
; 1038 : 
; 1039 :             break;

	jmp	$LN24@UfEditForm
$LN54@UfEditForm:

; 1040 : 
; 1041 :          case 'H':
; 1042 :             if ( *(cpcEditString + 1) == 'H' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 72					; 00000048H
	jne	SHORT $LN55@UfEditForm

; 1043 :             {
; 1044 :                // Hour with leading zero
; 1045 :                if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )

	mov	eax, DWORD PTR _pchDTString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN57@UfEditForm
	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN57@UfEditForm

; 1046 :                {
; 1047 :                   *(szDT + 8) = *pchDTString++;

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _szDT$[ebp+8], dl
	mov	eax, DWORD PTR _pchDTString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchDTString$[ebp], eax

; 1048 :                   *(szDT + 9) = *pchDTString++;

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _szDT$[ebp+9], dl
	mov	eax, DWORD PTR _pchDTString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchDTString$[ebp], eax

; 1049 :                   cpcEditString += 2;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 1050 :                }

	jmp	SHORT $LN58@UfEditForm
$LN57@UfEditForm:

; 1051 :                else
; 1052 :                {
; 1053 :                   // error
; 1054 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN58@UfEditForm:

; 1055 :                }
; 1056 :             }

	jmp	SHORT $LN56@UfEditForm
$LN55@UfEditForm:

; 1057 :             else
; 1058 :             {
; 1059 :                // Hour without leading zero
; 1060 :                if ( isdigit( *pchDTString ) )

	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN59@UfEditForm

; 1061 :                {
; 1062 :                   if ( isdigit( *(pchDTString + 1) ) )

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN61@UfEditForm

; 1063 :                   {
; 1064 :                      *(szDT + 8) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+8], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1065 :                      *(szDT + 9) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+9], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1066 :                   }

	jmp	SHORT $LN62@UfEditForm
$LN61@UfEditForm:

; 1067 :                   else
; 1068 :                   {
; 1069 :                      *(szDT + 8) = '0';

	mov	BYTE PTR _szDT$[ebp+8], 48		; 00000030H

; 1070 :                      *(szDT + 9) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+9], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx
$LN62@UfEditForm:

; 1071 :                   }
; 1072 :                   cpcEditString++;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 1073 :                }

	jmp	SHORT $LN56@UfEditForm
$LN59@UfEditForm:

; 1074 :                else
; 1075 :                {
; 1076 :                   // error
; 1077 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN56@UfEditForm:

; 1078 :                }
; 1079 :             }
; 1080 : 
; 1081 :             break;

	jmp	$LN24@UfEditForm
$LN63@UfEditForm:

; 1082 : 
; 1083 :          case 'j':
; 1084 :             if ( zstrncmp( (zPCHAR)(cpcEditString + 1), "jj", 2 ) == 0 )

	push	2
	push	OFFSET $SG13642
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN64@UfEditForm

; 1085 :             {
; 1086 :                if ( isdigit( *pchDTString ) &&
; 1087 :                     isdigit( *(pchDTString + 1) ) &&

	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN66@UfEditForm
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN66@UfEditForm
	mov	eax, DWORD PTR _pchDTString$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN66@UfEditForm

; 1088 :                     isdigit( *(pchDTString + 2) ) )
; 1089 :                {
; 1090 :                   zstrncpy( szJulian, pchDTString, 3 );

	push	3
	mov	edx, DWORD PTR _pchDTString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szJulian$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 1091 :                   szJulian[ 3 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 3
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 4
	jae	SHORT $LN123@UfEditForm
	jmp	SHORT $LN124@UfEditForm
$LN123@UfEditForm:
	call	___report_rangecheckfailure
$LN124@UfEditForm:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szJulian$[ebp+eax], 0

; 1092 :                   bConvertJulian = TRUE;

	mov	BYTE PTR _bConvertJulian$[ebp], 1

; 1093 :                   bDayNeeded = TRUE;

	mov	BYTE PTR _bDayNeeded$[ebp], 1

; 1094 :                   cpcEditString += 3;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 3
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 1095 :                   pchDTString += 3;

	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 3
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1096 :                }

	jmp	SHORT $LN67@UfEditForm
$LN66@UfEditForm:

; 1097 :                else
; 1098 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN67@UfEditForm:

; 1099 :             }

	jmp	SHORT $LN65@UfEditForm
$LN64@UfEditForm:

; 1100 :             else
; 1101 :                bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN65@UfEditForm:

; 1102 : 
; 1103 :             break;

	jmp	$LN24@UfEditForm
$LN68@UfEditForm:

; 1104 : 
; 1105 :          case 'M':
; 1106 :             if ( *(cpcEditString + 1) == 'I' )

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 73					; 00000049H
	jne	SHORT $LN72@UfEditForm

; 1107 :             {
; 1108 :                // Minutes field
; 1109 :                if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )

	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN70@UfEditForm
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN70@UfEditForm

; 1110 :                {
; 1111 :                   *(szDT + 10) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+10], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1112 :                   *(szDT + 11) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+11], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1113 :                   cpcEditString += 2;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 1114 :                   break;

	jmp	$LN24@UfEditForm

; 1115 :                }

	jmp	SHORT $LN72@UfEditForm
$LN70@UfEditForm:

; 1116 :                else
; 1117 :                {
; 1118 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1

; 1119 :                   break;

	jmp	$LN24@UfEditForm
$LN72@UfEditForm:

; 1120 :                }
; 1121 :             }
; 1122 :             // break left out intentionally!!!
; 1123 : 
; 1124 :          case 'm':
; 1125 :             if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "mm", 2 ) == 0 )

	push	2
	push	OFFSET $SG13652
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN73@UfEditForm

; 1126 :             {
; 1127 :                zBOOL bLongFormat = 0;

	mov	BYTE PTR _bLongFormat$8[ebp], 0

; 1128 : 
; 1129 :                // Month of year( could be short or long )
; 1130 :                if ( ztoupper( *(cpcEditString + 3) ) == 'M' )

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx+3]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN75@UfEditForm

; 1131 :                   bLongFormat = TRUE;

	mov	BYTE PTR _bLongFormat$8[ebp], 1
$LN75@UfEditForm:

; 1132 : 
; 1133 :                for ( k = 0; k < 12; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN11@UfEditForm
$LN9@UfEditForm:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN11@UfEditForm:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 12					; 0000000cH
	jge	$LN10@UfEditForm

; 1134 :                {
; 1135 :                   if ( ztoupper( *pchDTString ) == *g_pchMon[ k ] )

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	movsx	ecx, BYTE PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN76@UfEditForm

; 1136 :                   {
; 1137 :                      n = bLongFormat ? zstrlen( g_pchMon[ k ] ) : 3;

	movzx	edx, BYTE PTR _bLongFormat$8[ebp]
	test	edx, edx
	je	SHORT $LN125@UfEditForm
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _g_pchMon[eax*4]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR tv367[ebp], eax
	jmp	SHORT $LN126@UfEditForm
$LN125@UfEditForm:
	mov	DWORD PTR tv367[ebp], 3
$LN126@UfEditForm:
	mov	dx, WORD PTR tv367[ebp]
	mov	WORD PTR _n$[ebp], dx

; 1138 :                      if ( zstrncmpi( pchDTString, g_pchMon[ k ], n ) == 0 )

	movsx	eax, WORD PTR _n$[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	push	edx
	mov	eax, DWORD PTR _pchDTString$[ebp]
	push	eax
	call	DWORD PTR __imp___strnicmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN76@UfEditForm

; 1139 :                      {
; 1140 :                         pchDTString += n; // bump past the Month

	movsx	ecx, WORD PTR _n$[ebp]
	add	ecx, DWORD PTR _pchDTString$[ebp]
	mov	DWORD PTR _pchDTString$[ebp], ecx

; 1141 :                         cpcEditString += (3 + bLongFormat);

	movzx	edx, BYTE PTR _bLongFormat$8[ebp]
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	lea	ecx, DWORD PTR [eax+edx+3]
	mov	DWORD PTR _cpcEditString$[ebp], ecx

; 1142 :                         break;

	jmp	SHORT $LN10@UfEditForm
$LN76@UfEditForm:

; 1143 :                      }
; 1144 :                   }
; 1145 :                }

	jmp	$LN9@UfEditForm
$LN10@UfEditForm:

; 1146 :                if ( k == 12 )

	movsx	edx, WORD PTR _k$[ebp]
	cmp	edx, 12					; 0000000cH
	jne	SHORT $LN78@UfEditForm

; 1147 :                {
; 1148 :                   // error
; 1149 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1

; 1150 :                }

	jmp	SHORT $LN79@UfEditForm
$LN78@UfEditForm:

; 1151 :                else
; 1152 :                {
; 1153 :                   zltoa( (zLONG) k + 101L, sz );

	push	10					; 0000000aH
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	movsx	ecx, WORD PTR _k$[ebp]
	add	ecx, 101				; 00000065H
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1154 :                   *(szDT + 4) = *(sz + 1);

	mov	dl, BYTE PTR _sz$[ebp+1]
	mov	BYTE PTR _szDT$[ebp+4], dl

; 1155 :                   *(szDT + 5) = *(sz + 2);

	mov	al, BYTE PTR _sz$[ebp+2]
	mov	BYTE PTR _szDT$[ebp+5], al
$LN79@UfEditForm:

; 1156 :                }
; 1157 :             }

	jmp	$LN74@UfEditForm
$LN73@UfEditForm:

; 1158 :             else
; 1159 :             if ( ztoupper( *(cpcEditString + 1) ) == 'M' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	cmp	eax, 77					; 0000004dH
	jne	SHORT $LN80@UfEditForm

; 1160 :             {
; 1161 :                // move the two digit number representing month to output
; 1162 :                *(szDT + 4) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+4], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1163 :                *(szDT + 5) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+5], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1164 :                cpcEditString += 2;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 1165 :             }

	jmp	SHORT $LN74@UfEditForm
$LN80@UfEditForm:

; 1166 :             else
; 1167 :             {
; 1168 :                // move the one/two digit number representing month
; 1169 :                // to output
; 1170 :                if ( isdigit( *pchDTString ) )

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN82@UfEditForm

; 1171 :                {
; 1172 :                   if ( isdigit( *(pchDTString + 1) ) )

	mov	eax, DWORD PTR _pchDTString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN84@UfEditForm

; 1173 :                   {
; 1174 :                      *(szDT + 4) = *pchDTString++;

	mov	edx, DWORD PTR _pchDTString$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szDT$[ebp+4], al
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchDTString$[ebp], ecx

; 1175 :                      *(szDT + 5) = *pchDTString++;

	mov	edx, DWORD PTR _pchDTString$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szDT$[ebp+5], al
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchDTString$[ebp], ecx

; 1176 :                   }

	jmp	SHORT $LN85@UfEditForm
$LN84@UfEditForm:

; 1177 :                   else
; 1178 :                   {
; 1179 :                      *(szDT + 4) = '0';

	mov	BYTE PTR _szDT$[ebp+4], 48		; 00000030H

; 1180 :                      *(szDT + 5) = *pchDTString++;

	mov	edx, DWORD PTR _pchDTString$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _szDT$[ebp+5], al
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchDTString$[ebp], ecx
$LN85@UfEditForm:

; 1181 :                   }
; 1182 :                   cpcEditString++;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 1183 :                }

	jmp	SHORT $LN74@UfEditForm
$LN82@UfEditForm:

; 1184 :                else
; 1185 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN74@UfEditForm:

; 1186 :             }
; 1187 : 
; 1188 :             break;

	jmp	$LN24@UfEditForm
$LN86@UfEditForm:

; 1189 : 
; 1190 :          case 'S':
; 1191 :             if ( *(cpcEditString + 1) == 'S' )

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN87@UfEditForm

; 1192 :             {
; 1193 :                if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )

	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN89@UfEditForm
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN89@UfEditForm

; 1194 :                {
; 1195 :                   *(szDT + 12) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+12], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1196 :                   *(szDT + 13) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+13], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1197 :                   cpcEditString += 2;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 1198 :                }

	jmp	SHORT $LN90@UfEditForm
$LN89@UfEditForm:

; 1199 :                else
; 1200 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN90@UfEditForm:

; 1201 :             }

	jmp	SHORT $LN88@UfEditForm
$LN87@UfEditForm:

; 1202 :             else
; 1203 :                bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN88@UfEditForm:

; 1204 : 
; 1205 :             break;

	jmp	$LN24@UfEditForm
$LN91@UfEditForm:

; 1206 : 
; 1207 :          case 'Y':
; 1208 :             if ( *(cpcEditString + 1) == 'Y' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 89					; 00000059H
	jne	$LN92@UfEditForm

; 1209 :             {
; 1210 :                if ( *(cpcEditString + 2) == 'Y' &&

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+2]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN94@UfEditForm
	mov	edx, DWORD PTR _cpcEditString$[ebp]
	movsx	eax, BYTE PTR [edx+3]
	cmp	eax, 89					; 00000059H
	jne	SHORT $LN94@UfEditForm

; 1211 :                     *(cpcEditString + 3) == 'Y' )
; 1212 :                {
; 1213 :                   // move the four digit year to output
; 1214 :                   for ( k = 0; k < 4; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN14@UfEditForm
$LN12@UfEditForm:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN14@UfEditForm:
	movsx	eax, WORD PTR _k$[ebp]
	cmp	eax, 4
	jge	SHORT $LN13@UfEditForm

; 1215 :                   {
; 1216 :                      if ( !isdigit( *(pchDTString + k) ) )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN96@UfEditForm

; 1217 :                         break;

	jmp	SHORT $LN13@UfEditForm
$LN96@UfEditForm:

; 1218 :                   }

	jmp	SHORT $LN12@UfEditForm
$LN13@UfEditForm:

; 1219 :                   if ( k < 4 )

	movsx	ecx, WORD PTR _k$[ebp]
	cmp	ecx, 4
	jge	SHORT $LN97@UfEditForm

; 1220 :                   {
; 1221 :                      bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1

; 1222 :                   }

	jmp	SHORT $LN98@UfEditForm
$LN97@UfEditForm:

; 1223 :                   else
; 1224 :                   {
; 1225 :                      zmemcpy( szDT, pchDTString, 4 );

	push	4
	mov	edx, DWORD PTR _pchDTString$[ebp]
	push	edx
	lea	eax, DWORD PTR _szDT$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 1226 :                      pchDTString += 4;

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchDTString$[ebp], ecx

; 1227 :                      cpcEditString += 4;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 4
	mov	DWORD PTR _cpcEditString$[ebp], edx
$LN98@UfEditForm:

; 1228 :                   }
; 1229 :                }

	jmp	SHORT $LN95@UfEditForm
$LN94@UfEditForm:

; 1230 :                else
; 1231 :                {
; 1232 :                   // move the two digit year to output
; 1233 :                   if ( isdigit( *pchDTString ) &&

	mov	eax, DWORD PTR _pchDTString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN99@UfEditForm
	mov	edx, DWORD PTR _pchDTString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	push	eax
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN99@UfEditForm

; 1234 :                        isdigit( *(pchDTString + 1) ) )
; 1235 :                   {
; 1236 :                      szDT[ 0 ] = '2';

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szDT$[ebp+edx], 50		; 00000032H

; 1237 :                      *(szDT + 1) = '0';

	mov	BYTE PTR _szDT$[ebp+1], 48		; 00000030H

; 1238 :                      *(szDT + 2) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+2], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1239 :                      *(szDT + 3) = *pchDTString++;

	mov	eax, DWORD PTR _pchDTString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _szDT$[ebp+3], cl
	mov	edx, DWORD PTR _pchDTString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchDTString$[ebp], edx

; 1240 :                      cpcEditString += 2;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 1241 :                   }

	jmp	SHORT $LN95@UfEditForm
$LN99@UfEditForm:

; 1242 :                   else
; 1243 :                      bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN95@UfEditForm:

; 1244 :                }
; 1245 :             }

	jmp	SHORT $LN93@UfEditForm
$LN92@UfEditForm:

; 1246 :             else
; 1247 :                bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN93@UfEditForm:

; 1248 : 
; 1249 :             break;

	jmp	$LN24@UfEditForm
$LN101@UfEditForm:

; 1250 : 
; 1251 :          case '9':
; 1252 :          {
; 1253 :             zPCHAR   pch;
; 1254 :             pch = (zPCHAR) (szDT + 14);

	lea	ecx, DWORD PTR _szDT$[ebp+14]
	mov	DWORD PTR _pch$6[ebp], ecx

; 1255 :             zmemset( pch, '0', 3 ); // init fraction

	push	3
	push	48					; 00000030H
	mov	edx, DWORD PTR _pch$6[ebp]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN15@UfEditForm:

; 1256 :             while ( *cpcEditString == '9' && *pch )

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jne	SHORT $LN16@UfEditForm
	mov	edx, DWORD PTR _pch$6[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN16@UfEditForm

; 1257 :             {
; 1258 :                if ( isdigit( *pchDTString ) )

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__isdigit
	add	esp, 4
	test	eax, eax
	je	SHORT $LN102@UfEditForm

; 1259 :                {
; 1260 :                   *pch++ = *pchDTString++;

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax
	mov	ecx, DWORD PTR _pchDTString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchDTString$[ebp], ecx

; 1261 :                   cpcEditString++;

	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _cpcEditString$[ebp], edx

; 1262 :                }

	jmp	SHORT $LN103@UfEditForm
$LN102@UfEditForm:

; 1263 :                else
; 1264 :                {
; 1265 :                   bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1

; 1266 :                   break;

	jmp	SHORT $LN16@UfEditForm
$LN103@UfEditForm:

; 1267 :                }
; 1268 :             }

	jmp	SHORT $LN15@UfEditForm
$LN16@UfEditForm:

; 1269 : 
; 1270 :             if ( bError )

	movzx	eax, BYTE PTR _bError$[ebp]
	test	eax, eax
	je	SHORT $LN17@UfEditForm

; 1271 :                break;

	jmp	SHORT $LN24@UfEditForm
$LN17@UfEditForm:

; 1272 : 
; 1273 :             while ( *cpcEditString == '9' )

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jne	SHORT $LN18@UfEditForm

; 1274 :                cpcEditString++;

	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _cpcEditString$[ebp], eax
	jmp	SHORT $LN17@UfEditForm
$LN18@UfEditForm:

; 1275 : 
; 1276 :             break;

	jmp	SHORT $LN24@UfEditForm
$LN105@UfEditForm:

; 1277 :          }
; 1278 : 
; 1279 :          case '\"':  // quote
; 1280 :          case '\'':  // aposthorpe
; 1281 :             chDelimiter = *cpcEditString++;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _chDelimiter$[ebp], dl
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _cpcEditString$[ebp], eax

; 1282 :             break;

	jmp	SHORT $LN24@UfEditForm
$LN106@UfEditForm:

; 1283 : 
; 1284 :          case '(':   // left paren
; 1285 :          case ')':   // right paren
; 1286 :          case ':':   // colon
; 1287 :          case ',':   // comma
; 1288 :          case '-':   // dash
; 1289 :          case '/':   // slash
; 1290 :          case '.':   // period
; 1291 :          case ' ':   // space
; 1292 :             if ( *pchDTString++ != *cpcEditString++ )

	mov	ecx, DWORD PTR _pchDTString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv538[ebp], edx
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv539[ebp], ecx
	mov	edx, DWORD PTR _cpcEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _cpcEditString$[ebp], edx
	mov	eax, DWORD PTR _pchDTString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchDTString$[ebp], eax
	mov	ecx, DWORD PTR tv538[ebp]
	cmp	ecx, DWORD PTR tv539[ebp]
	je	SHORT $LN107@UfEditForm

; 1293 :                bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN107@UfEditForm:

; 1294 : 
; 1295 :             break;

	jmp	SHORT $LN24@UfEditForm
$LN108@UfEditForm:

; 1296 : 
; 1297 :          default:
; 1298 :          {
; 1299 :             bBadEditString = TRUE;

	mov	BYTE PTR _bBadEditString$[ebp], 1

; 1300 :             bError = TRUE;

	mov	BYTE PTR _bError$[ebp], 1
$LN24@UfEditForm:

; 1301 :          }
; 1302 :       }
; 1303 : 
; 1304 :       if ( bError )

	movzx	edx, BYTE PTR _bError$[ebp]
	test	edx, edx
	je	SHORT $LN109@UfEditForm

; 1305 :          break;

	jmp	SHORT $LN3@UfEditForm
$LN109@UfEditForm:

; 1306 :    }

	jmp	$LN2@UfEditForm
$LN3@UfEditForm:

; 1307 : 
; 1308 :    // We should now have a valid DateTime string in szDT.
; 1309 :    if ( bError == FALSE )

	movzx	eax, BYTE PTR _bError$[ebp]
	test	eax, eax
	jne	$LN110@UfEditForm

; 1310 :    {
; 1311 :       if ( bConvertJulian )

	movzx	ecx, BYTE PTR _bConvertJulian$[ebp]
	test	ecx, ecx
	je	SHORT $LN111@UfEditForm

; 1312 :       {
; 1313 :          zCHAR szG[ 9 ];
; 1314 :          zstrncpy( sz, szDT, 4 ); // copy YYYY

	push	4
	lea	edx, DWORD PTR _szDT$[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 1315 :          sz[ 4 ] = 0;

	mov	ecx, 1
	shl	ecx, 2
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 18			; 00000012H
	jae	SHORT $LN127@UfEditForm
	jmp	SHORT $LN128@UfEditForm
$LN127@UfEditForm:
	call	___report_rangecheckfailure
$LN128@UfEditForm:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _sz$[ebp+edx], 0

; 1316 :          zstrcat( sz, szJulian ); // copy jjj

	lea	eax, DWORD PTR _szJulian$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 1317 :          UfJulianToGregorian( sz, szG );

	lea	edx, DWORD PTR _szG$10[ebp]
	push	edx
	lea	eax, DWORD PTR _sz$[ebp]
	push	eax
	call	_UfJulianToGregorian@8

; 1318 :          zmemcpy( szDT, szG, 8 );

	push	8
	lea	ecx, DWORD PTR _szG$10[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDT$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN111@UfEditForm:

; 1319 :          // now we really have a vaid DateTime in szDT
; 1320 :       }
; 1321 : 
; 1322 :       if ( bDayNeeded == FALSE )

	movzx	eax, BYTE PTR _bDayNeeded$[ebp]
	test	eax, eax
	jne	SHORT $LN112@UfEditForm

; 1323 :       {
; 1324 :          // Plug the day with "01" since the edit string doesnt require a valid day.
; 1325 :          if ( szDT[ 6 ] == 'X' )

	mov	ecx, 1
	imul	edx, ecx, 6
	movsx	eax, BYTE PTR _szDT$[ebp+edx]
	cmp	eax, 88					; 00000058H
	jne	SHORT $LN113@UfEditForm

; 1326 :             szDT[ 6 ] = '0';

	mov	ecx, 1
	imul	edx, ecx, 6
	mov	BYTE PTR _szDT$[ebp+edx], 48		; 00000030H
$LN113@UfEditForm:

; 1327 :          if ( szDT[ 7 ] == 'X' )

	mov	eax, 1
	imul	ecx, eax, 7
	movsx	edx, BYTE PTR _szDT$[ebp+ecx]
	cmp	edx, 88					; 00000058H
	jne	SHORT $LN112@UfEditForm

; 1328 :             szDT[ 7 ] = '1';

	mov	eax, 1
	imul	ecx, eax, 7
	mov	BYTE PTR _szDT$[ebp+ecx], 49		; 00000031H
$LN112@UfEditForm:

; 1329 :       }
; 1330 : 
; 1331 :       if ( bTwelveHourClock )

	movzx	edx, BYTE PTR _bTwelveHourClock$[ebp]
	test	edx, edx
	je	SHORT $LN115@UfEditForm

; 1332 :       {
; 1333 :          zLONG l;
; 1334 : 
; 1335 :          // Bump clock into the afternoon
; 1336 :          sz[ 0 ] = *(szDT + 8);

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _szDT$[ebp+8]
	mov	BYTE PTR _sz$[ebp+ecx], dl

; 1337 :          *(sz + 1) = *(szDT + 9);

	mov	al, BYTE PTR _szDT$[ebp+9]
	mov	BYTE PTR _sz$[ebp+1], al

; 1338 :          *(sz + 2) = 0;

	mov	BYTE PTR _sz$[ebp+2], 0

; 1339 :          l = zatol( sz );

	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _l$5[ebp], eax

; 1340 :          if ( bAdjustTime )

	movzx	edx, BYTE PTR _bAdjustTime$[ebp]
	test	edx, edx
	je	SHORT $LN116@UfEditForm

; 1341 :          {
; 1342 :             // if in here, we're in the pm time frame...
; 1343 :             if ( l < 12L )

	cmp	DWORD PTR _l$5[ebp], 12			; 0000000cH
	jge	SHORT $LN118@UfEditForm

; 1344 :             {
; 1345 :                l += 12L;

	mov	eax, DWORD PTR _l$5[ebp]
	add	eax, 12					; 0000000cH
	mov	DWORD PTR _l$5[ebp], eax

; 1346 :                zltoa( l, sz );

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	mov	edx, DWORD PTR _l$5[ebp]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1347 :                *(szDT + 8) = sz[ 0 ];

	mov	eax, 1
	imul	ecx, eax, 0
	mov	dl, BYTE PTR _sz$[ebp+ecx]
	mov	BYTE PTR _szDT$[ebp+8], dl

; 1348 :                *(szDT + 9) = *(sz + 1);

	mov	al, BYTE PTR _sz$[ebp+1]
	mov	BYTE PTR _szDT$[ebp+9], al
$LN118@UfEditForm:

; 1349 :             }
; 1350 :          }

	jmp	SHORT $LN115@UfEditForm
$LN116@UfEditForm:

; 1351 :          else
; 1352 :          if ( l == 12L )

	cmp	DWORD PTR _l$5[ebp], 12			; 0000000cH
	jne	SHORT $LN115@UfEditForm

; 1353 :          {
; 1354 :             // adjust for 12 am
; 1355 :             *(szDT + 8) = '0';

	mov	BYTE PTR _szDT$[ebp+8], 48		; 00000030H

; 1356 :             *(szDT + 9) = '0';

	mov	BYTE PTR _szDT$[ebp+9], 48		; 00000030H
$LN115@UfEditForm:

; 1357 :          }
; 1358 :       }
; 1359 : 
; 1360 :       // we should be all set, return value to the user.
; 1361 :       zstrcpy( pchReturnString, szDT );

	lea	ecx, DWORD PTR _szDT$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN110@UfEditForm:

; 1362 :    }
; 1363 : 
; 1364 :    return( (bError ? (bBadEditString ? zCALL_ERROR : -1) : 0 ) );

	movzx	eax, BYTE PTR _bError$[ebp]
	test	eax, eax
	je	SHORT $LN131@UfEditForm
	movzx	ecx, BYTE PTR _bBadEditString$[ebp]
	test	ecx, ecx
	je	SHORT $LN129@UfEditForm
	mov	DWORD PTR tv605[ebp], -16		; fffffff0H
	jmp	SHORT $LN130@UfEditForm
$LN129@UfEditForm:
	mov	DWORD PTR tv605[ebp], -1
$LN130@UfEditForm:
	mov	edx, DWORD PTR tv605[ebp]
	mov	DWORD PTR tv607[ebp], edx
	jmp	SHORT $LN132@UfEditForm
$LN131@UfEditForm:
	mov	DWORD PTR tv607[ebp], 0
$LN132@UfEditForm:
	mov	ax, WORD PTR tv607[ebp]
$LN120@UfEditForm:

; 1365 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN134@UfEditForm:
	DD	$LN106@UfEditForm
	DD	$LN105@UfEditForm
	DD	$LN101@UfEditForm
	DD	$LN28@UfEditForm
	DD	$LN39@UfEditForm
	DD	$LN54@UfEditForm
	DD	$LN68@UfEditForm
	DD	$LN86@UfEditForm
	DD	$LN91@UfEditForm
	DD	$LN63@UfEditForm
	DD	$LN72@UfEditForm
	DD	$LN108@UfEditForm
$LN133@UfEditForm:
	DB	0
	DB	11					; 0000000bH
	DB	1
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	1
	DB	0
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	0
	DB	0
	DB	0
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	2
	DB	0
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	3
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	5
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	6
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	3
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	7
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	8
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	4
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	9
	DB	11					; 0000000bH
	DB	11					; 0000000bH
	DB	10					; 0000000aH
_UfEditFormatDateTime@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoeufaa.c
_TEXT	SEGMENT
tv462 = -116						; size = 4
_lDOW$1 = -112						; size = 4
tv207 = -108						; size = 4
_lDOW$2 = -104						; size = 4
$T3 = -100						; size = 4
$T4 = -96						; size = 4
$T5 = -92						; size = 4
_lDOW$6 = -88						; size = 4
_lpInternational$7 = -84				; size = 4
_lpInternational$8 = -80				; size = 4
_lDOW$9 = -76						; size = 4
_lDOW$10 = -72						; size = 4
_pchFractionsOfSeconds$ = -68				; size = 4
_pchMover$11 = -64					; size = 4
_lDOW$12 = -60						; size = 4
_pchMover$13 = -56					; size = 4
tv139 = -52						; size = 4
_lMonth$14 = -48					; size = 4
_lHour$15 = -44						; size = 4
_pchTrailer$16 = -40					; size = 4
_lMonth$17 = -36					; size = 4
_pchEditString$ = -32					; size = 4
_pchOutString$ = -28					; size = 4
_szMonthNumber$18 = -24					; size = 3
_szMonthNumber$19 = -20					; size = 3
_sz$20 = -16						; size = 2
_n$ = -12						; size = 2
_nWSLength$ = -8					; size = 2
_bTwelveHour$ = -3					; size = 1
_bAM$ = -2						; size = 1
_chDelimiter$ = -1					; size = 1
_pchReturnString$ = 8					; size = 4
_cpcDateTimeString$ = 12				; size = 4
_cpcEditString$ = 16					; size = 4
_UfFormatDateTime@12 PROC

; 305  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 116				; 00000074H

; 306  :    zBOOL    bTwelveHour;
; 307  :    zBOOL    bAM;
; 308  :    zCHAR    chDelimiter = 0;

	mov	BYTE PTR _chDelimiter$[ebp], 0

; 309  :    zPCHAR   pchEditString;
; 310  :    zPCHAR   pchOutString;
; 311  :    zPCHAR   pchFractionsOfSeconds;
; 312  :    zSHORT   n;
; 313  :    zSHORT   nWSLength;           // length of WorkString
; 314  : 
; 315  :    pchReturnString[ 0 ] = 0;  // init to null string

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	BYTE PTR [edx+ecx], 0

; 316  : 
; 317  :    nWSLength = zstrlen( cpcDateTimeString );

	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _nWSLength$[ebp], ax

; 318  :    if ( nWSLength == 17 ||
; 319  :         nWSLength == 14 ||
; 320  :         nWSLength ==  8 ||
; 321  :         nWSLength == 12 ||
; 322  :         nWSLength == 16 ||

	movsx	ecx, WORD PTR _nWSLength$[ebp]
	cmp	ecx, 17					; 00000011H
	je	SHORT $LN16@UfFormatDa
	movsx	edx, WORD PTR _nWSLength$[ebp]
	cmp	edx, 14					; 0000000eH
	je	SHORT $LN16@UfFormatDa
	movsx	eax, WORD PTR _nWSLength$[ebp]
	cmp	eax, 8
	je	SHORT $LN16@UfFormatDa
	movsx	ecx, WORD PTR _nWSLength$[ebp]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LN16@UfFormatDa
	movsx	edx, WORD PTR _nWSLength$[ebp]
	cmp	edx, 16					; 00000010H
	je	SHORT $LN16@UfFormatDa
	movsx	eax, WORD PTR _nWSLength$[ebp]
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN14@UfFormatDa
$LN16@UfFormatDa:

; 323  :         nWSLength == 15 )
; 324  :       ; // faster than anding nots together

	jmp	SHORT $LN15@UfFormatDa
$LN14@UfFormatDa:

; 325  :    else
; 326  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN122@UfFormatDa
$LN15@UfFormatDa:

; 327  : 
; 328  :    if ( cpcEditString == 0 || cpcEditString[ 0 ] == 0 )

	cmp	DWORD PTR _cpcEditString$[ebp], 0
	je	SHORT $LN19@UfFormatDa
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	test	ecx, ecx
	jne	SHORT $LN17@UfFormatDa
$LN19@UfFormatDa:

; 329  :    {
; 330  :       // If no edit string, just copy the input work string to the
; 331  :       // return string.
; 332  :       zstrcpy( pchReturnString, cpcDateTimeString );

	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 333  :       return( 0 );

	xor	eax, eax
	jmp	$LN122@UfFormatDa

; 334  :    }

	jmp	$LN18@UfFormatDa
$LN17@UfFormatDa:

; 335  :    else
; 336  :    {
; 337  :       pchEditString = (zPCHAR) cpcEditString;

	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 338  :       pchOutString = pchReturnString;

	mov	edx, DWORD PTR _pchReturnString$[ebp]
	mov	DWORD PTR _pchOutString$[ebp], edx

; 339  : 
; 340  :       if ( zstrchr( cpcEditString, 'A' ) ||

	push	65					; 00000041H
	mov	eax, DWORD PTR _cpcEditString$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN22@UfFormatDa
	push	80					; 00000050H
	mov	ecx, DWORD PTR _cpcEditString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN20@UfFormatDa
$LN22@UfFormatDa:

; 341  :            zstrchr( cpcEditString, 'P' ) )
; 342  :       {
; 343  :          bTwelveHour = TRUE;

	mov	BYTE PTR _bTwelveHour$[ebp], 1

; 344  :          bAM = TRUE;

	mov	BYTE PTR _bAM$[ebp], 1

; 345  :       }

	jmp	SHORT $LN2@UfFormatDa
$LN20@UfFormatDa:

; 346  :       else
; 347  :          bTwelveHour = FALSE;

	mov	BYTE PTR _bTwelveHour$[ebp], 0
$LN2@UfFormatDa:

; 348  : 
; 349  :       while ( *pchEditString )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN3@UfFormatDa

; 350  :       {
; 351  :          if ( chDelimiter )

	movsx	ecx, BYTE PTR _chDelimiter$[ebp]
	test	ecx, ecx
	je	SHORT $LN23@UfFormatDa

; 352  :          {
; 353  :             if ( *pchEditString == chDelimiter )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _chDelimiter$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN25@UfFormatDa

; 354  :             {
; 355  :                chDelimiter = 0;

	mov	BYTE PTR _chDelimiter$[ebp], 0

; 356  :                pchEditString++;

	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchEditString$[ebp], edx

; 357  :             }

	jmp	SHORT $LN26@UfFormatDa
$LN25@UfFormatDa:

; 358  :             else
; 359  :                *pchOutString++ = *pchEditString++;

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _pchEditString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax
	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchEditString$[ebp], ecx
$LN26@UfFormatDa:

; 360  :          }

	jmp	$LN24@UfFormatDa
$LN23@UfFormatDa:

; 361  :          else
; 362  :          switch ( *pchEditString )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv139[ebp], eax
	mov	ecx, DWORD PTR tv139[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR tv139[ebp], ecx
	cmp	DWORD PTR tv139[ebp], 77		; 0000004dH
	ja	$LN120@UfFormatDa
	mov	edx, DWORD PTR tv139[ebp]
	movzx	eax, BYTE PTR $LN129@UfFormatDa[edx]
	jmp	DWORD PTR $LN130@UfFormatDa[eax*4]
$LN27@UfFormatDa:

; 363  :          {
; 364  :           case 'A':
; 365  :           case 'P':
; 366  :             if ( *(pchEditString + 1) == 'M' )

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 77					; 0000004dH
	jne	$LN28@UfFormatDa

; 367  :             {
; 368  :                zPCHAR   pchTrailer;
; 369  : 
; 370  :                // get national text for AM or PM
; 371  :                if ( bAM )

	movzx	eax, BYTE PTR _bAM$[ebp]
	test	eax, eax
	je	SHORT $LN30@UfFormatDa

; 372  :                {
; 373  :                   LPINTERNATIONAL lpInternational =

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2515]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$8[ebp], eax

; 374  :                                     zGETPTR( AnchorBlock->hInternational );
; 375  : 
; 376  :                   if ( lpInternational->sz1159 == 0 )

	mov	eax, DWORD PTR _lpInternational$8[ebp]
	add	eax, 86					; 00000056H
	jne	SHORT $LN32@UfFormatDa

; 377  :                      pchTrailer = NULL;

	mov	DWORD PTR _pchTrailer$16[ebp], 0
	jmp	SHORT $LN33@UfFormatDa
$LN32@UfFormatDa:

; 378  :                   else
; 379  :                      pchTrailer = lpInternational->sz1159;

	mov	ecx, DWORD PTR _lpInternational$8[ebp]
	add	ecx, 86					; 00000056H
	mov	DWORD PTR _pchTrailer$16[ebp], ecx
$LN33@UfFormatDa:

; 380  :                }

	jmp	SHORT $LN31@UfFormatDa
$LN30@UfFormatDa:

; 381  :                else
; 382  :                {
; 383  :                   LPINTERNATIONAL lpInternational =

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2515]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$7[ebp], eax

; 384  :                                     zGETPTR( AnchorBlock->hInternational );
; 385  : 
; 386  :                   if ( lpInternational->sz2359 == 0 )

	mov	ecx, DWORD PTR _lpInternational$7[ebp]
	add	ecx, 91					; 0000005bH
	jne	SHORT $LN34@UfFormatDa

; 387  :                      pchTrailer = NULL;

	mov	DWORD PTR _pchTrailer$16[ebp], 0
	jmp	SHORT $LN31@UfFormatDa
$LN34@UfFormatDa:

; 388  :                   else
; 389  :                      pchTrailer = lpInternational->sz2359;

	mov	edx, DWORD PTR _lpInternational$7[ebp]
	add	edx, 91					; 0000005bH
	mov	DWORD PTR _pchTrailer$16[ebp], edx
$LN31@UfFormatDa:

; 390  :                }
; 391  : 
; 392  :                // if no national text defined, use default text
; 393  :                if ( pchTrailer == NULL )

	cmp	DWORD PTR _pchTrailer$16[ebp], 0
	jne	SHORT $LN36@UfFormatDa

; 394  :                {
; 395  :                   if ( bAM )

	movzx	eax, BYTE PTR _bAM$[ebp]
	test	eax, eax
	je	SHORT $LN37@UfFormatDa

; 396  :                      pchTrailer = "AM";

	mov	DWORD PTR _pchTrailer$16[ebp], OFFSET $SG13440
	jmp	SHORT $LN36@UfFormatDa
$LN37@UfFormatDa:

; 397  :                   else
; 398  :                      pchTrailer = "PM";

	mov	DWORD PTR _pchTrailer$16[ebp], OFFSET $SG13441
$LN36@UfFormatDa:

; 399  :                }
; 400  : 
; 401  :                n = zstrlen( pchTrailer );

	mov	ecx, DWORD PTR _pchTrailer$16[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _n$[ebp], ax

; 402  :                zstrncpy( pchOutString, pchTrailer, n );

	movsx	edx, WORD PTR _n$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchTrailer$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 403  :                pchOutString[ n ] = 0;

	movsx	edx, WORD PTR _n$[ebp]
	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 404  :                pchOutString += n;

	movsx	ecx, WORD PTR _n$[ebp]
	add	ecx, DWORD PTR _pchOutString$[ebp]
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 405  :                pchEditString += 2;

	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 2
	mov	DWORD PTR _pchEditString$[ebp], edx

; 406  :             }

	jmp	SHORT $LN29@UfFormatDa
$LN28@UfFormatDa:

; 407  :             else
; 408  :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN122@UfFormatDa
$LN29@UfFormatDa:

; 409  : 
; 410  :             break;

	jmp	$LN24@UfFormatDa
$LN39@UfFormatDa:

; 411  : 
; 412  :           case 'D':
; 413  :             if ( zstrncmp( (pchEditString + 1), "ddd", 3 ) == 0 )

	push	3
	push	OFFSET $SG13445
	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN40@UfFormatDa

; 414  :             {
; 415  :                zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );

	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	push	ecx
	call	_UfGetDayOfWeek@4
	mov	DWORD PTR _lDOW$6[ebp], eax

; 416  :                zstrcpy( pchOutString, g_pchDOW[ lDOW ] );

	mov	edx, DWORD PTR _lDOW$6[ebp]
	mov	eax, DWORD PTR _g_pchDOW[edx*4]
	push	eax
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 417  :                pchOutString += zstrlen( g_pchDOW[ lDOW ] );

	mov	edx, DWORD PTR _lDOW$6[ebp]
	mov	eax, DWORD PTR _g_pchDOW[edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchOutString$[ebp]
	mov	DWORD PTR _pchOutString$[ebp], eax

; 418  :                pchEditString += 4;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 419  :             }

	jmp	$LN41@UfFormatDa
$LN40@UfFormatDa:

; 420  :             else
; 421  :             if ( zstrncmp( (pchEditString + 1), "DDD", 3 ) == 0 )

	push	3
	push	OFFSET $SG13448
	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN42@UfFormatDa

; 422  :             {
; 423  :                zPCHAR pchMover;
; 424  :                zLONG  lDOW = UfGetDayOfWeek( cpcDateTimeString );

	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	push	eax
	call	_UfGetDayOfWeek@4
	mov	DWORD PTR _lDOW$2[ebp], eax

; 425  :                pchMover = g_pchDOW[ lDOW ];

	mov	ecx, DWORD PTR _lDOW$2[ebp]
	mov	edx, DWORD PTR _g_pchDOW[ecx*4]
	mov	DWORD PTR _pchMover$13[ebp], edx
$LN6@UfFormatDa:

; 426  :                while ( *pchMover )

	mov	eax, DWORD PTR _pchMover$13[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN7@UfFormatDa

; 427  :                   *pchOutString++ = ztoupper( *pchMover++ );

	mov	edx, DWORD PTR _pchMover$13[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv207[ebp], eax
	mov	ecx, DWORD PTR tv207[ebp]
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax
	mov	ecx, DWORD PTR _pchMover$13[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchMover$13[ebp], ecx
	jmp	SHORT $LN6@UfFormatDa
$LN7@UfFormatDa:

; 428  : 
; 429  :                pchEditString += 4;

	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 4
	mov	DWORD PTR _pchEditString$[ebp], edx

; 430  :             }

	jmp	$LN41@UfFormatDa
$LN42@UfFormatDa:

; 431  :             else
; 432  :             if ( zstrncmp( (pchEditString + 1), "dd", 2 ) == 0 )

	push	2
	push	OFFSET $SG13451
	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN44@UfFormatDa

; 433  :             {
; 434  :                zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );

	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	push	ecx
	call	_UfGetDayOfWeek@4
	mov	DWORD PTR _lDOW$1[ebp], eax

; 435  :                zstrncpy( pchOutString, g_pchDOW[ lDOW ], 3 );

	push	3
	mov	edx, DWORD PTR _lDOW$1[ebp]
	mov	eax, DWORD PTR _g_pchDOW[edx*4]
	push	eax
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	push	ecx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 436  :                pchOutString += 3;

	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 3
	mov	DWORD PTR _pchOutString$[ebp], edx

; 437  :                pchEditString += 3;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 3
	mov	DWORD PTR _pchEditString$[ebp], eax

; 438  :             }

	jmp	$LN41@UfFormatDa
$LN44@UfFormatDa:

; 439  :             else
; 440  :             if ( zstrncmp( (pchEditString + 1), "DD", 2 ) == 0 )

	push	2
	push	OFFSET $SG13454
	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN46@UfFormatDa

; 441  :             {
; 442  :                zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );

	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	push	edx
	call	_UfGetDayOfWeek@4
	mov	DWORD PTR _lDOW$12[ebp], eax

; 443  :                zstrncpy( pchOutString, g_pchDOW[ lDOW ], 3 );

	push	3
	mov	eax, DWORD PTR _lDOW$12[ebp]
	mov	ecx, DWORD PTR _g_pchDOW[eax*4]
	push	ecx
	mov	edx, DWORD PTR _pchOutString$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 444  :                *pchOutString++ = *g_pchDOW[ lDOW ];

	mov	eax, DWORD PTR _lDOW$12[ebp]
	mov	ecx, DWORD PTR _g_pchDOW[eax*4]
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 445  :                *pchOutString++ = ztoupper( *(g_pchDOW[ lDOW ] + 1) );

	mov	edx, DWORD PTR _lDOW$12[ebp]
	mov	eax, DWORD PTR _g_pchDOW[edx*4]
	movsx	ecx, BYTE PTR [eax+1]
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 446  :                *pchOutString++ = ztoupper( *(g_pchDOW[ lDOW ] + 2) );

	mov	ecx, DWORD PTR _lDOW$12[ebp]
	mov	edx, DWORD PTR _g_pchDOW[ecx*4]
	movsx	eax, BYTE PTR [edx+2]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 447  :                pchEditString += 3;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 3
	mov	DWORD PTR _pchEditString$[ebp], eax

; 448  :             }

	jmp	$LN41@UfFormatDa
$LN46@UfFormatDa:

; 449  :             else
; 450  :             if ( *(pchEditString + 1) == 'D' ||

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 68					; 00000044H
	je	SHORT $LN50@UfFormatDa
	mov	eax, DWORD PTR _pchEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 100				; 00000064H
	jne	SHORT $LN48@UfFormatDa
$LN50@UfFormatDa:

; 451  :                  *(pchEditString + 1) == 'd' )
; 452  :             {
; 453  :                // move the day of the month (w/leading zero if < 10 )
; 454  :                // to output
; 455  :                *pchOutString++ = *(cpcDateTimeString + 6);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+6]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 456  :                *pchOutString++ = *(cpcDateTimeString + 7);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+7]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 457  :                pchEditString += 2;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 458  :             }

	jmp	SHORT $LN41@UfFormatDa
$LN48@UfFormatDa:

; 459  :             else
; 460  :             {
; 461  :                // move the day of the month (w/o leading zero if < 10 )
; 462  :                // to output
; 463  :                if ( *(cpcDateTimeString + 6) != '0' )

	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	movsx	eax, BYTE PTR [edx+6]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN51@UfFormatDa

; 464  :                {
; 465  :                   *pchOutString++ = *(cpcDateTimeString + 6);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+6]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx
$LN51@UfFormatDa:

; 466  :                }
; 467  : 
; 468  :                *pchOutString++ = *(cpcDateTimeString + 7);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+7]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 469  :                pchEditString++;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchEditString$[ebp], eax
$LN41@UfFormatDa:

; 470  :             }
; 471  : 
; 472  :             break;

	jmp	$LN24@UfFormatDa
$LN52@UfFormatDa:

; 473  : 
; 474  :           case 'd':
; 475  :             if ( zstrncmp( (pchEditString + 1), "ddd", 3 ) == 0 )

	push	3
	push	OFFSET $SG13462
	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN53@UfFormatDa

; 476  :             {
; 477  :                zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );

	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	push	edx
	call	_UfGetDayOfWeek@4
	mov	DWORD PTR _lDOW$10[ebp], eax

; 478  :                zstrcpy( pchOutString, g_pchDOW[ lDOW ] );

	mov	eax, DWORD PTR _lDOW$10[ebp]
	mov	ecx, DWORD PTR _g_pchDOW[eax*4]
	push	ecx
	mov	edx, DWORD PTR _pchOutString$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 479  :                *pchOutString = tolower( *g_pchDOW[ lDOW ] );

	mov	eax, DWORD PTR _lDOW$10[ebp]
	mov	ecx, DWORD PTR _g_pchDOW[eax*4]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__tolower
	add	esp, 4
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], al

; 480  :                pchOutString += zstrlen( g_pchDOW[ lDOW ] );

	mov	edx, DWORD PTR _lDOW$10[ebp]
	mov	eax, DWORD PTR _g_pchDOW[edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchOutString$[ebp]
	mov	DWORD PTR _pchOutString$[ebp], eax

; 481  :                pchEditString += 4;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 482  :             }

	jmp	$LN54@UfFormatDa
$LN53@UfFormatDa:

; 483  :             else
; 484  :             if ( zstrncmp( (pchEditString + 1), "dd", 2 ) == 0 )

	push	2
	push	OFFSET $SG13465
	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN55@UfFormatDa

; 485  :             {
; 486  :                zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );

	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	push	eax
	call	_UfGetDayOfWeek@4
	mov	DWORD PTR _lDOW$9[ebp], eax

; 487  :                *pchOutString++ = tolower( *g_pchDOW[ lDOW ] );

	mov	ecx, DWORD PTR _lDOW$9[ebp]
	mov	edx, DWORD PTR _g_pchDOW[ecx*4]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__tolower
	add	esp, 4
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 488  :                *pchOutString++ = *(g_pchDOW[ lDOW ] + 1);

	mov	eax, DWORD PTR _lDOW$9[ebp]
	mov	ecx, DWORD PTR _g_pchDOW[eax*4]
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	al, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 489  :                *pchOutString++ = *(g_pchDOW[ lDOW ] + 2);

	mov	edx, DWORD PTR _lDOW$9[ebp]
	mov	eax, DWORD PTR _g_pchDOW[edx*4]
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 490  :                pchEditString += 3;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 3
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 491  :             }

	jmp	SHORT $LN54@UfFormatDa
$LN55@UfFormatDa:

; 492  :             else
; 493  :             if ( *(pchEditString + 1) == 'd' )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 100				; 00000064H
	jne	SHORT $LN57@UfFormatDa

; 494  :             {
; 495  :                // move the day of the month (w/leading zero if < 10 )
; 496  :                // to output
; 497  :                *pchOutString++ = *(cpcDateTimeString + 6);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+6]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 498  :                *pchOutString++ = *(cpcDateTimeString + 7);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+7]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 499  :                pchEditString += 2;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _pchEditString$[ebp], eax

; 500  :             }

	jmp	SHORT $LN54@UfFormatDa
$LN57@UfFormatDa:

; 501  :             else
; 502  :             {
; 503  :                // move the day of the month (w/o leading zero if < 10 )
; 504  :                // to output
; 505  :                if ( *(cpcDateTimeString + 6) != '0' )

	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	movsx	edx, BYTE PTR [ecx+6]
	cmp	edx, 48					; 00000030H
	je	SHORT $LN59@UfFormatDa

; 506  :                {
; 507  :                   *pchOutString++ = *(cpcDateTimeString + 6);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+6]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax
$LN59@UfFormatDa:

; 508  :                }
; 509  :                *pchOutString++ = *(cpcDateTimeString + 7);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+7]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 510  :                pchEditString++;

	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchEditString$[ebp], edx
$LN54@UfFormatDa:

; 511  :             }
; 512  : 
; 513  :             break;

	jmp	$LN24@UfFormatDa
$LN60@UfFormatDa:

; 514  : 
; 515  :           case 'H':
; 516  :             if ( nWSLength >= 12 ) // ensure WorkString contains HH

	movsx	eax, WORD PTR _nWSLength$[ebp]
	cmp	eax, 12					; 0000000cH
	jl	$LN61@UfFormatDa

; 517  :             {
; 518  :                // move the hour of the day to output
; 519  :                *pchOutString++ = *(cpcDateTimeString + 8);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+8]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 520  :                *pchOutString++ = *(cpcDateTimeString + 9);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+9]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 521  :                if ( bTwelveHour )

	movzx	eax, BYTE PTR _bTwelveHour$[ebp]
	test	eax, eax
	je	$LN63@UfFormatDa

; 522  :                {
; 523  :                   zLONG    lHour;
; 524  : 
; 525  :                   *pchOutString = 0;         // null term the hour field

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], 0

; 526  :                   pchOutString -= 2;         // start of output HH field

	mov	edx, DWORD PTR _pchOutString$[ebp]
	sub	edx, 2
	mov	DWORD PTR _pchOutString$[ebp], edx

; 527  :                   lHour = zatol( pchOutString );

	mov	eax, DWORD PTR _pchOutString$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lHour$15[ebp], eax

; 528  :                   if ( lHour == 0 )

	cmp	DWORD PTR _lHour$15[ebp], 0
	jne	SHORT $LN65@UfFormatDa

; 529  :                   {
; 530  :                      lHour = 12;

	mov	DWORD PTR _lHour$15[ebp], 12		; 0000000cH

; 531  :                      zltoal( lHour, pchOutString, 2 );

	push	2
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lHour$15[ebp]
	push	edx
	call	_zltoal
	add	esp, 12					; 0000000cH

; 532  :                   }

	jmp	SHORT $LN66@UfFormatDa
$LN65@UfFormatDa:

; 533  :                   else
; 534  :                   if ( lHour > 11 )

	cmp	DWORD PTR _lHour$15[ebp], 11		; 0000000bH
	jle	SHORT $LN66@UfFormatDa

; 535  :                   {
; 536  :                      bAM = 0;

	mov	BYTE PTR _bAM$[ebp], 0

; 537  :                      if ( lHour > 12 )

	cmp	DWORD PTR _lHour$15[ebp], 12		; 0000000cH
	jle	SHORT $LN66@UfFormatDa

; 538  :                      {
; 539  :                         lHour -= 12;

	mov	eax, DWORD PTR _lHour$15[ebp]
	sub	eax, 12					; 0000000cH
	mov	DWORD PTR _lHour$15[ebp], eax

; 540  :                         zltoal( lHour, pchOutString, 2 );

	push	2
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lHour$15[ebp]
	push	edx
	call	_zltoal
	add	esp, 12					; 0000000cH
$LN66@UfFormatDa:

; 541  :                      }
; 542  :                   }
; 543  :                   if ( *pchOutString == '0' )

	mov	eax, DWORD PTR _pchOutString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 48					; 00000030H
	jne	SHORT $LN69@UfFormatDa

; 544  :                   {
; 545  :                      if ( *(pchEditString + 1) != 'H' )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 72					; 00000048H
	je	SHORT $LN71@UfFormatDa

; 546  :                      {
; 547  :                         *pchOutString = *(pchOutString + 1);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	al, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx], al

; 548  :                         pchOutString++;

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 549  :                         pchEditString++;

	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchEditString$[ebp], edx

; 550  :                      }

	jmp	SHORT $LN72@UfFormatDa
$LN71@UfFormatDa:

; 551  :                      else
; 552  :                      {
; 553  :                         pchOutString += 2;

	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 2
	mov	DWORD PTR _pchOutString$[ebp], eax

; 554  :                         pchEditString += 2;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pchEditString$[ebp], ecx
$LN72@UfFormatDa:

; 555  :                      }
; 556  :                   }

	jmp	SHORT $LN70@UfFormatDa
$LN69@UfFormatDa:

; 557  :                   else
; 558  :                   {
; 559  :                      pchOutString += 2;

	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 2
	mov	DWORD PTR _pchOutString$[ebp], edx

; 560  :                      pchEditString++;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchEditString$[ebp], eax

; 561  :                      if ( *pchEditString == 'H' )

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 72					; 00000048H
	jne	SHORT $LN70@UfFormatDa

; 562  :                         pchEditString++;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchEditString$[ebp], eax
$LN70@UfFormatDa:

; 563  :                   }
; 564  :                }

	jmp	SHORT $LN64@UfFormatDa
$LN63@UfFormatDa:

; 565  :                else
; 566  :                {
; 567  :                   if ( *(cpcDateTimeString + 8) == '0' )

	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	movsx	edx, BYTE PTR [ecx+8]
	cmp	edx, 48					; 00000030H
	jne	SHORT $LN74@UfFormatDa

; 568  :                   {
; 569  :                      if ( *(pchEditString + 1) != 'H' )

	mov	eax, DWORD PTR _pchEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 72					; 00000048H
	je	SHORT $LN76@UfFormatDa

; 570  :                      {
; 571  :                         pchOutString -= 2;

	mov	edx, DWORD PTR _pchOutString$[ebp]
	sub	edx, 2
	mov	DWORD PTR _pchOutString$[ebp], edx

; 572  :                         *pchOutString++ = *(cpcDateTimeString + 9);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+9]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 573  :                         pchEditString++;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 574  :                      }

	jmp	SHORT $LN77@UfFormatDa
$LN76@UfFormatDa:

; 575  :                      else
; 576  :                         pchEditString += 2;

	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 2
	mov	DWORD PTR _pchEditString$[ebp], edx
$LN77@UfFormatDa:

; 577  :                   }

	jmp	SHORT $LN64@UfFormatDa
$LN74@UfFormatDa:

; 578  :                   else
; 579  :                      pchEditString += 2;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _pchEditString$[ebp], eax
$LN64@UfFormatDa:

; 580  :                }
; 581  :             }

	jmp	SHORT $LN62@UfFormatDa
$LN61@UfFormatDa:

; 582  :             else
; 583  :             {
; 584  :                pchEditString++;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 585  :                if ( *pchEditString == 'H' )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 72					; 00000048H
	jne	SHORT $LN62@UfFormatDa

; 586  :                   pchEditString++;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchEditString$[ebp], ecx
$LN62@UfFormatDa:

; 587  :             }
; 588  : 
; 589  :             break;

	jmp	$LN24@UfFormatDa
$LN79@UfFormatDa:

; 590  : 
; 591  :           case 'j':
; 592  :             if ( zstrncmp( (pchEditString + 1), "jj", 2 ) == 0 )

	push	2
	push	OFFSET $SG13491
	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN80@UfFormatDa

; 593  :             {
; 594  :                zltoal( UfGetDayOfYear( cpcDateTimeString ),

	push	3
	mov	eax, DWORD PTR _pchOutString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	push	ecx
	call	_UfGetDayOfYear@4
	push	eax
	call	_zltoal
	add	esp, 12					; 0000000cH

; 595  :                        pchOutString, 3 );
; 596  :                pchOutString += 3;

	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 3
	mov	DWORD PTR _pchOutString$[ebp], edx

; 597  :                pchEditString += 3;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 3
	mov	DWORD PTR _pchEditString$[ebp], eax

; 598  :             }

	jmp	SHORT $LN81@UfFormatDa
$LN80@UfFormatDa:

; 599  :             else
; 600  :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN122@UfFormatDa
$LN81@UfFormatDa:

; 601  : 
; 602  :             break;

	jmp	$LN24@UfFormatDa
$LN82@UfFormatDa:

; 603  : 
; 604  :           case 'M':
; 605  :             if ( *(pchEditString + 1) == 'I' )

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 73					; 00000049H
	jne	SHORT $LN83@UfFormatDa

; 606  :             {
; 607  :                if ( nWSLength >= 12 ) // Ensure WorkString contains MI

	movsx	eax, WORD PTR _nWSLength$[ebp]
	cmp	eax, 12					; 0000000cH
	jl	SHORT $LN85@UfFormatDa

; 608  :                {
; 609  :                   // move the minute past hour to output
; 610  :                   *pchOutString++ = *(cpcDateTimeString + 10);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+10]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 611  :                   *pchOutString++ = *(cpcDateTimeString + 11);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+11]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx
$LN85@UfFormatDa:

; 612  :                }
; 613  :                pchEditString += 2;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _pchEditString$[ebp], eax

; 614  :             }

	jmp	$LN84@UfFormatDa
$LN83@UfFormatDa:

; 615  :             else
; 616  :             {
; 617  :                // move three char month to output
; 618  :                zCHAR  szMonthNumber[ 3 ];
; 619  :                zLONG  lMonth;
; 620  : 
; 621  :                // setup the following, assuming we're going to do something
; 622  :                // with the month
; 623  :                szMonthNumber[ 0 ] = *(cpcDateTimeString + 4);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _szMonthNumber$19[ebp+edx], cl

; 624  :                szMonthNumber[ 1 ] = *(cpcDateTimeString + 5);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+5]
	mov	BYTE PTR _szMonthNumber$19[ebp+edx], cl

; 625  :                szMonthNumber[ 2 ] = 0;

	mov	edx, 1
	shl	edx, 1
	mov	DWORD PTR $T5[ebp], edx
	cmp	DWORD PTR $T5[ebp], 3
	jae	SHORT $LN123@UfFormatDa
	jmp	SHORT $LN124@UfFormatDa
$LN123@UfFormatDa:
	call	___report_rangecheckfailure
$LN124@UfFormatDa:
	mov	eax, DWORD PTR $T5[ebp]
	mov	BYTE PTR _szMonthNumber$19[ebp+eax], 0

; 626  :                lMonth = zatol( szMonthNumber );

	lea	ecx, DWORD PTR _szMonthNumber$19[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lMonth$17[ebp], eax

; 627  :                lMonth--;   // make relative to 0

	mov	edx, DWORD PTR _lMonth$17[ebp]
	sub	edx, 1
	mov	DWORD PTR _lMonth$17[ebp], edx

; 628  : 
; 629  :                if ( zstrncmp( (pchEditString + 1), "mmm", 3 ) == 0 )

	push	3
	push	OFFSET $SG13498
	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN86@UfFormatDa

; 630  :                {
; 631  :                   zstrcpy( pchOutString, g_pchMon[ lMonth ] );

	mov	ecx, DWORD PTR _lMonth$17[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	push	edx
	mov	eax, DWORD PTR _pchOutString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 632  :                   pchOutString += zstrlen( g_pchMon[ lMonth ] );

	mov	ecx, DWORD PTR _lMonth$17[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchOutString$[ebp]
	mov	DWORD PTR _pchOutString$[ebp], eax

; 633  :                   pchEditString += 4;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 4
	mov	DWORD PTR _pchEditString$[ebp], eax

; 634  :                }

	jmp	$LN84@UfFormatDa
$LN86@UfFormatDa:

; 635  :                else
; 636  :                if ( zstrncmp( (pchEditString + 1), "MMM", 3 ) == 0 )

	push	3
	push	OFFSET $SG13501
	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	push	ecx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN88@UfFormatDa

; 637  :                {
; 638  :                   zPCHAR   pchMover;
; 639  :                   pchMover = g_pchMon[ lMonth ];

	mov	edx, DWORD PTR _lMonth$17[ebp]
	mov	eax, DWORD PTR _g_pchMon[edx*4]
	mov	DWORD PTR _pchMover$11[ebp], eax
$LN8@UfFormatDa:

; 640  :                   while ( *pchMover )

	mov	ecx, DWORD PTR _pchMover$11[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN9@UfFormatDa

; 641  :                      *pchOutString++ = ztoupper( *pchMover++ );

	mov	eax, DWORD PTR _pchMover$11[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv462[ebp], ecx
	mov	edx, DWORD PTR tv462[ebp]
	push	edx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx
	mov	eax, DWORD PTR _pchMover$11[ebp]
	add	eax, 1
	mov	DWORD PTR _pchMover$11[ebp], eax
	jmp	SHORT $LN8@UfFormatDa
$LN9@UfFormatDa:

; 642  : 
; 643  :                   pchEditString += 4;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 644  :                }

	jmp	$LN84@UfFormatDa
$LN88@UfFormatDa:

; 645  :                else
; 646  :                if ( zstrncmp( (pchEditString + 1), "mm", 2 ) == 0 )

	push	2
	push	OFFSET $SG13504
	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN90@UfFormatDa

; 647  :                {
; 648  :                   zstrncpy( pchOutString, g_pchMon[ lMonth ], 3 );

	push	3
	mov	eax, DWORD PTR _lMonth$17[ebp]
	mov	ecx, DWORD PTR _g_pchMon[eax*4]
	push	ecx
	mov	edx, DWORD PTR _pchOutString$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 649  :                   pchOutString += 3;

	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 3
	mov	DWORD PTR _pchOutString$[ebp], eax

; 650  :                   pchEditString += 3;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 3
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 651  :                }

	jmp	$LN84@UfFormatDa
$LN90@UfFormatDa:

; 652  :                else
; 653  :                if ( zstrncmp( (pchEditString + 1), "MM", 2 ) == 0 )

	push	2
	push	OFFSET $SG13507
	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	$LN92@UfFormatDa

; 654  :                {
; 655  :                   zstrncpy( pchOutString, g_pchMon[ lMonth ], 3 );

	push	3
	mov	eax, DWORD PTR _lMonth$17[ebp]
	mov	ecx, DWORD PTR _g_pchMon[eax*4]
	push	ecx
	mov	edx, DWORD PTR _pchOutString$[ebp]
	push	edx
	call	DWORD PTR __imp__strncpy
	add	esp, 12					; 0000000cH

; 656  :                   *pchOutString++ = *g_pchMon[ lMonth ];

	mov	eax, DWORD PTR _lMonth$17[ebp]
	mov	ecx, DWORD PTR _g_pchMon[eax*4]
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 657  :                   *pchOutString++ = ztoupper ( *(g_pchMon[ lMonth ] + 1) );

	mov	edx, DWORD PTR _lMonth$17[ebp]
	mov	eax, DWORD PTR _g_pchMon[edx*4]
	movsx	ecx, BYTE PTR [eax+1]
	push	ecx
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [edx], al
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 658  :                   *pchOutString++ = ztoupper ( *(g_pchMon[ lMonth ] + 2) );

	mov	ecx, DWORD PTR _lMonth$17[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	movsx	eax, BYTE PTR [edx+2]
	push	eax
	call	DWORD PTR __imp__toupper
	add	esp, 4
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 659  :                   pchEditString += 3;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 3
	mov	DWORD PTR _pchEditString$[ebp], eax

; 660  :                }

	jmp	$LN84@UfFormatDa
$LN92@UfFormatDa:

; 661  :                else
; 662  :                if ( *(pchEditString + 1) == 'M' ||

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 77					; 0000004dH
	je	SHORT $LN96@UfFormatDa
	mov	eax, DWORD PTR _pchEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+1]
	cmp	ecx, 109				; 0000006dH
	jne	SHORT $LN94@UfFormatDa
$LN96@UfFormatDa:

; 663  :                     *(pchEditString + 1) == 'm' )
; 664  :                {
; 665  :                   // move the two digit number representing month to output
; 666  :                   *pchOutString++ = *(cpcDateTimeString + 4);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 667  :                   *pchOutString++ = *(cpcDateTimeString + 5);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 668  :                   pchEditString += 2;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 669  :                }

	jmp	SHORT $LN84@UfFormatDa
$LN94@UfFormatDa:

; 670  :                else
; 671  : #if 0
; 672  :                if ( *(pchEditString + 1) == 'O' &&
; 673  :                     *(pchEditString + 2) == 'N' )
; 674  :                {
; 675  :                   zstrncpy( pchOutString, g_pchMon[ lMonth ], 3 );
; 676  :                   pchOutString += 3;
; 677  :                   pchEditString += 3;
; 678  :                }
; 679  :                else
; 680  : #endif
; 681  :                {
; 682  :                   // move the one/two digit number representing month
; 683  :                   // to output
; 684  :                   if ( *(cpcDateTimeString + 4) != '0' )

	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	movsx	eax, BYTE PTR [edx+4]
	cmp	eax, 48					; 00000030H
	je	SHORT $LN97@UfFormatDa

; 685  :                      *pchOutString++ = *(cpcDateTimeString + 4);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx
$LN97@UfFormatDa:

; 686  :                   *pchOutString++ = *(cpcDateTimeString + 5);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+5]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 687  :                   pchEditString++;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchEditString$[ebp], eax
$LN84@UfFormatDa:

; 688  :                }
; 689  :             }
; 690  : 
; 691  :             break;

	jmp	$LN24@UfFormatDa
$LN98@UfFormatDa:

; 692  : 
; 693  :           case 'm':
; 694  :             {
; 695  :                // move three char month to output
; 696  :                zCHAR  szMonthNumber[ 3 ];
; 697  :                zLONG  lMonth;
; 698  : 
; 699  :                // setup the following, assuming we're going to do something
; 700  :                // with the month
; 701  :                szMonthNumber[ 0 ] = *(cpcDateTimeString + 4);

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR _szMonthNumber$18[ebp+edx], cl

; 702  :                szMonthNumber[ 1 ] = *(cpcDateTimeString + 5);

	mov	edx, 1
	shl	edx, 0
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+5]
	mov	BYTE PTR _szMonthNumber$18[ebp+edx], cl

; 703  :                szMonthNumber[ 2 ] = 0;

	mov	edx, 1
	shl	edx, 1
	mov	DWORD PTR $T4[ebp], edx
	cmp	DWORD PTR $T4[ebp], 3
	jae	SHORT $LN125@UfFormatDa
	jmp	SHORT $LN126@UfFormatDa
$LN125@UfFormatDa:
	call	___report_rangecheckfailure
$LN126@UfFormatDa:
	mov	eax, DWORD PTR $T4[ebp]
	mov	BYTE PTR _szMonthNumber$18[ebp+eax], 0

; 704  :                lMonth = zatol( szMonthNumber );

	lea	ecx, DWORD PTR _szMonthNumber$18[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR _lMonth$14[ebp], eax

; 705  :                lMonth--;   // make relative to 0

	mov	edx, DWORD PTR _lMonth$14[ebp]
	sub	edx, 1
	mov	DWORD PTR _lMonth$14[ebp], edx

; 706  : 
; 707  :                if ( zstrncmp( (pchEditString + 1), "mmm", 3 ) == 0 )

	push	3
	push	OFFSET $SG13515
	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN99@UfFormatDa

; 708  :                {
; 709  :                   zstrcpy( pchOutString, g_pchMon[ lMonth ] );

	mov	ecx, DWORD PTR _lMonth$14[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	push	edx
	mov	eax, DWORD PTR _pchOutString$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 710  :                   *pchOutString = tolower( *g_pchMon[ lMonth ] );

	mov	ecx, DWORD PTR _lMonth$14[ebp]
	mov	edx, DWORD PTR _g_pchMon[ecx*4]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__tolower
	add	esp, 4
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], al

; 711  :                   pchOutString += zstrlen( g_pchMon[ lMonth ] );

	mov	edx, DWORD PTR _lMonth$14[ebp]
	mov	eax, DWORD PTR _g_pchMon[edx*4]
	push	eax
	call	_strlen
	add	esp, 4
	add	eax, DWORD PTR _pchOutString$[ebp]
	mov	DWORD PTR _pchOutString$[ebp], eax

; 712  :                   pchEditString += 4;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 4
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 713  :                }

	jmp	$LN100@UfFormatDa
$LN99@UfFormatDa:

; 714  :                else
; 715  :                if ( zstrncmp( (pchEditString + 1), "mm", 2 ) == 0 )

	push	2
	push	OFFSET $SG13518
	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	push	edx
	call	DWORD PTR __imp__strncmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN101@UfFormatDa

; 716  :                {
; 717  :                   *pchOutString++ = tolower( *g_pchMon[ lMonth ] );

	mov	eax, DWORD PTR _lMonth$14[ebp]
	mov	ecx, DWORD PTR _g_pchMon[eax*4]
	movsx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp__tolower
	add	esp, 4
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [ecx], al
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 718  :                   *pchOutString++ = *(g_pchMon[ lMonth ] + 1);

	mov	eax, DWORD PTR _lMonth$14[ebp]
	mov	ecx, DWORD PTR _g_pchMon[eax*4]
	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	al, BYTE PTR [ecx+1]
	mov	BYTE PTR [edx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 719  :                   *pchOutString++ = *(g_pchMon[ lMonth ] + 2);

	mov	edx, DWORD PTR _lMonth$14[ebp]
	mov	eax, DWORD PTR _g_pchMon[edx*4]
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	dl, BYTE PTR [eax+2]
	mov	BYTE PTR [ecx], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 720  :                   pchEditString += 3;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 3
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 721  :                }

	jmp	$LN100@UfFormatDa
$LN101@UfFormatDa:

; 722  :                else
; 723  :                if ( *(pchEditString + 1) == 'M' ||

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 77					; 0000004dH
	je	SHORT $LN105@UfFormatDa
	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+1]
	cmp	edx, 109				; 0000006dH
	jne	SHORT $LN103@UfFormatDa
$LN105@UfFormatDa:

; 724  :                     *(pchEditString + 1) == 'm' )
; 725  :                {
; 726  :                   // move the two digit number representing month to output
; 727  :                   *pchOutString++ = *(cpcDateTimeString + 4);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 728  :                   *pchOutString++ = *(cpcDateTimeString + 5);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+5]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 729  :                   pchEditString += 2;

	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 2
	mov	DWORD PTR _pchEditString$[ebp], edx

; 730  :                }

	jmp	SHORT $LN100@UfFormatDa
$LN103@UfFormatDa:

; 731  :                else
; 732  :                {
; 733  :                   // move the one/two digit number representing month
; 734  :                   // to output
; 735  :                   if ( *(cpcDateTimeString + 4) != '0' )

	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	movsx	ecx, BYTE PTR [eax+4]
	cmp	ecx, 48					; 00000030H
	je	SHORT $LN106@UfFormatDa

; 736  :                      *pchOutString++ = *(cpcDateTimeString + 4);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+4]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx
$LN106@UfFormatDa:

; 737  :                   *pchOutString++ = *(cpcDateTimeString + 5);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 738  :                   pchEditString++;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchEditString$[ebp], ecx
$LN100@UfFormatDa:

; 739  :                }
; 740  :             }
; 741  : 
; 742  :             break;

	jmp	$LN24@UfFormatDa
$LN107@UfFormatDa:

; 743  : 
; 744  :           case 'S':
; 745  :             if ( *(pchEditString + 1) == 'S' )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 83					; 00000053H
	jne	SHORT $LN108@UfFormatDa

; 746  :             {
; 747  :                if ( nWSLength >= 14 ) // Ensure WorkString contains SS

	movsx	ecx, WORD PTR _nWSLength$[ebp]
	cmp	ecx, 14					; 0000000eH
	jl	SHORT $LN110@UfFormatDa

; 748  :                {
; 749  :                   // move the second past minute to output
; 750  :                   *pchOutString++ = *(cpcDateTimeString + 12);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+12]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 751  :                   *pchOutString++ = *(cpcDateTimeString + 13);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+13]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax
$LN110@UfFormatDa:

; 752  :                }
; 753  : 
; 754  :                pchEditString += 2;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pchEditString$[ebp], ecx

; 755  :             }

	jmp	SHORT $LN109@UfFormatDa
$LN108@UfFormatDa:

; 756  :             else
; 757  :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN122@UfFormatDa
$LN109@UfFormatDa:

; 758  : 
; 759  :             break;

	jmp	$LN24@UfFormatDa
$LN111@UfFormatDa:

; 760  : 
; 761  :           case 'Y':
; 762  :             if ( *(pchEditString + 1) == 'Y' )

	mov	edx, DWORD PTR _pchEditString$[ebp]
	movsx	eax, BYTE PTR [edx+1]
	cmp	eax, 89					; 00000059H
	jne	$LN112@UfFormatDa

; 763  :             {
; 764  :                if ( *(pchEditString + 2) == 'Y' &&

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx+2]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN114@UfFormatDa
	mov	eax, DWORD PTR _pchEditString$[ebp]
	movsx	ecx, BYTE PTR [eax+3]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN114@UfFormatDa

; 765  :                     *(pchEditString + 3) == 'Y' )
; 766  :                {
; 767  :                   // move the four digit year to output
; 768  :                   *pchOutString++ = *(cpcDateTimeString + 0);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 769  :                   *pchOutString++ = *(cpcDateTimeString + 1);

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	ecx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	dl, BYTE PTR [ecx+1]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchOutString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchOutString$[ebp], eax

; 770  :                   *pchOutString++ = *(cpcDateTimeString + 2);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 771  :                   *pchOutString++ = *(cpcDateTimeString + 3);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 772  :                   pchEditString += 4;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 4
	mov	DWORD PTR _pchEditString$[ebp], eax

; 773  :                }

	jmp	SHORT $LN115@UfFormatDa
$LN114@UfFormatDa:

; 774  :                else
; 775  :                {
; 776  :                   // move the two digit year to output
; 777  :                   *pchOutString++ = *(cpcDateTimeString + 2);

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	mov	al, BYTE PTR [edx+2]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx

; 778  :                   *pchOutString++ = *(cpcDateTimeString + 3);

	mov	edx, DWORD PTR _pchOutString$[ebp]
	mov	eax, DWORD PTR _cpcDateTimeString$[ebp]
	mov	cl, BYTE PTR [eax+3]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchOutString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchOutString$[ebp], edx

; 779  :                   pchEditString += 2;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 2
	mov	DWORD PTR _pchEditString$[ebp], eax
$LN115@UfFormatDa:

; 780  :                }
; 781  :             }

	jmp	SHORT $LN113@UfFormatDa
$LN112@UfFormatDa:

; 782  :             else
; 783  :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN122@UfFormatDa
$LN113@UfFormatDa:

; 784  : 
; 785  :             break;

	jmp	$LN24@UfFormatDa
$LN116@UfFormatDa:

; 786  : 
; 787  :           case '9':
; 788  :             if ( nWSLength >= 15 )

	movsx	ecx, WORD PTR _nWSLength$[ebp]
	cmp	ecx, 15					; 0000000fH
	jl	SHORT $LN12@UfFormatDa

; 789  :             {
; 790  :                pchFractionsOfSeconds = (zPCHAR) (cpcDateTimeString + 14);

	mov	edx, DWORD PTR _cpcDateTimeString$[ebp]
	add	edx, 14					; 0000000eH
	mov	DWORD PTR _pchFractionsOfSeconds$[ebp], edx
$LN10@UfFormatDa:

; 791  :                while ( *pchEditString == '9' && *pchFractionsOfSeconds )

	mov	eax, DWORD PTR _pchEditString$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 57					; 00000039H
	jne	SHORT $LN12@UfFormatDa
	mov	edx, DWORD PTR _pchFractionsOfSeconds$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN12@UfFormatDa

; 792  :                {
; 793  :                   *pchOutString++ = *pchFractionsOfSeconds++;

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _pchFractionsOfSeconds$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx
	mov	edx, DWORD PTR _pchFractionsOfSeconds$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchFractionsOfSeconds$[ebp], edx

; 794  :                   pchEditString++;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchEditString$[ebp], eax

; 795  :                }

	jmp	SHORT $LN10@UfFormatDa
$LN12@UfFormatDa:

; 796  :             }
; 797  : 
; 798  :             while ( *pchEditString == '9' )

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jne	SHORT $LN13@UfFormatDa

; 799  :                pchEditString++;

	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchEditString$[ebp], eax
	jmp	SHORT $LN12@UfFormatDa
$LN13@UfFormatDa:

; 800  : 
; 801  :             break;

	jmp	SHORT $LN24@UfFormatDa
$LN118@UfFormatDa:

; 802  : 
; 803  :           case '\"':  // quote
; 804  :           case '\'':  // aposthorpe
; 805  :             chDelimiter = *pchEditString++;

	mov	ecx, DWORD PTR _pchEditString$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _chDelimiter$[ebp], dl
	mov	eax, DWORD PTR _pchEditString$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchEditString$[ebp], eax

; 806  :             break;

	jmp	SHORT $LN24@UfFormatDa
$LN119@UfFormatDa:

; 807  : 
; 808  :           case '(':   // left paren
; 809  :           case ')':   // right paren
; 810  :           case ':':   // colon
; 811  :           case ',':   // comma
; 812  :           case '-':   // dash
; 813  :           case '/':   // slash
; 814  :           case '.':   // period
; 815  :           case ' ':   // space
; 816  :             *pchOutString++ = *pchEditString++;

	mov	ecx, DWORD PTR _pchOutString$[ebp]
	mov	edx, DWORD PTR _pchEditString$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pchOutString$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchOutString$[ebp], ecx
	mov	edx, DWORD PTR _pchEditString$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchEditString$[ebp], edx

; 817  :             break;

	jmp	SHORT $LN24@UfFormatDa
$LN120@UfFormatDa:

; 818  : 
; 819  :           default:
; 820  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN122@UfFormatDa
$LN24@UfFormatDa:

; 821  :          }
; 822  :       }

	jmp	$LN2@UfFormatDa
$LN3@UfFormatDa:

; 823  : 
; 824  :       *pchOutString = 0; // don't forget to null terminate the string

	mov	eax, DWORD PTR _pchOutString$[ebp]
	mov	BYTE PTR [eax], 0

; 825  :       if ( chDelimiter )

	movsx	ecx, BYTE PTR _chDelimiter$[ebp]
	test	ecx, ecx
	je	SHORT $LN18@UfFormatDa

; 826  :       {
; 827  :          zCHAR sz[ 2 ];
; 828  :          sz[ 0 ] = chDelimiter;

	mov	edx, 1
	imul	eax, edx, 0
	mov	cl, BYTE PTR _chDelimiter$[ebp]
	mov	BYTE PTR _sz$20[ebp+eax], cl

; 829  :          sz[ 1 ] = 0;

	mov	DWORD PTR $T3[ebp], 1
	cmp	DWORD PTR $T3[ebp], 2
	jae	SHORT $LN127@UfFormatDa
	jmp	SHORT $LN128@UfFormatDa
$LN127@UfFormatDa:
	call	___report_rangecheckfailure
$LN128@UfFormatDa:
	mov	edx, DWORD PTR $T3[ebp]
	mov	BYTE PTR _sz$20[ebp+edx], 0

; 830  :          // "KZOEE360 - Missing ending delimiter "
; 831  :          fnSysMessageBox( 0, "Zeidon Error",

	push	0
	push	OFFSET $SG13538
	push	OFFSET $SG13539
	push	0
	call	_fnSysMessageBox@16
$LN18@UfFormatDa:

; 832  :                           "Missing ending delimiter", 0 );
; 833  :       // fnIssueCoreError( 0, lpView, 8, 360, 0, sz, 0 );
; 834  :       }
; 835  :    }
; 836  : 
; 837  :    return( 0 );

	xor	eax, eax
$LN122@UfFormatDa:

; 838  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN130@UfFormatDa:
	DD	$LN119@UfFormatDa
	DD	$LN118@UfFormatDa
	DD	$LN116@UfFormatDa
	DD	$LN27@UfFormatDa
	DD	$LN39@UfFormatDa
	DD	$LN60@UfFormatDa
	DD	$LN82@UfFormatDa
	DD	$LN107@UfFormatDa
	DD	$LN111@UfFormatDa
	DD	$LN52@UfFormatDa
	DD	$LN79@UfFormatDa
	DD	$LN98@UfFormatDa
	DD	$LN120@UfFormatDa
$LN129@UfFormatDa:
	DB	0
	DB	12					; 0000000cH
	DB	1
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	1
	DB	0
	DB	0
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	0
	DB	0
	DB	0
	DB	0
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	2
	DB	0
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	3
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	4
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	5
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	6
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	3
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	7
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	8
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	9
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	10					; 0000000aH
	DB	12					; 0000000cH
	DB	12					; 0000000cH
	DB	11					; 0000000bH
_UfFormatDateTime@12 ENDP
_TEXT	ENDS
END
