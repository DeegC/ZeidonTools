; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEVLAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_g_Operations
_BSS	SEGMENT
$SG14508 DB	01H DUP (?)
$SG14522 DB	01H DUP (?)
$SG14523 DB	01H DUP (?)
$SG14632 DB	01H DUP (?)
$SG14646 DB	01H DUP (?)
$SG14647 DB	01H DUP (?)
$SG14648 DB	01H DUP (?)
$SG14649 DB	01H DUP (?)
$SG14650 DB	01H DUP (?)
$SG14651 DB	01H DUP (?)
$SG14652 DB	01H DUP (?)
$SG14653 DB	01H DUP (?)
$SG14654 DB	01H DUP (?)
$SG14659 DB	01H DUP (?)
$SG14660 DB	01H DUP (?)
$SG14661 DB	01H DUP (?)
$SG14662 DB	01H DUP (?)
$SG14663 DB	01H DUP (?)
$SG14664 DB	01H DUP (?)
$SG14675 DB	01H DUP (?)
$SG14676 DB	01H DUP (?)
$SG14677 DB	01H DUP (?)
$SG14678 DB	01H DUP (?)
$SG14679 DB	01H DUP (?)
$SG14680 DB	01H DUP (?)
$SG14681 DB	01H DUP (?)
$SG14682 DB	01H DUP (?)
$SG14683 DB	01H DUP (?)
$SG14684 DB	01H DUP (?)
$SG14685 DB	01H DUP (?)
$SG14686 DB	01H DUP (?)
$SG14687 DB	01H DUP (?)
$SG14688 DB	01H DUP (?)
$SG14689 DB	01H DUP (?)
$SG14690 DB	01H DUP (?)
$SG14691 DB	01H DUP (?)
$SG14692 DB	01H DUP (?)
$SG14693 DB	01H DUP (?)
$SG14694 DB	01H DUP (?)
$SG14696 DB	01H DUP (?)
$SG14698 DB	01H DUP (?)
$SG14701 DB	01H DUP (?)
$SG14702 DB	01H DUP (?)
$SG14703 DB	01H DUP (?)
$SG14704 DB	01H DUP (?)
$SG14711 DB	01H DUP (?)
$SG14712 DB	01H DUP (?)
$SG14713 DB	01H DUP (?)
$SG14714 DB	01H DUP (?)
$SG14716 DB	01H DUP (?)
$SG14717 DB	01H DUP (?)
$SG14718 DB	01H DUP (?)
$SG14719 DB	01H DUP (?)
$SG14720 DB	01H DUP (?)
$SG14721 DB	01H DUP (?)
$SG14722 DB	01H DUP (?)
$SG14723 DB	01H DUP (?)
$SG14724 DB	01H DUP (?)
$SG14725 DB	01H DUP (?)
$SG14726 DB	01H DUP (?)
$SG14727 DB	01H DUP (?)
$SG14728 DB	01H DUP (?)
$SG14729 DB	01H DUP (?)
$SG14730 DB	01H DUP (?)
$SG14731 DB	01H DUP (?)
$SG14732 DB	01H DUP (?)
$SG14733 DB	01H DUP (?)
$SG14734 DB	01H DUP (?)
$SG14735 DB	01H DUP (?)
$SG14736 DB	01H DUP (?)
$SG14737 DB	01H DUP (?)
$SG14738 DB	01H DUP (?)
$SG14739 DB	01H DUP (?)
$SG14740 DB	01H DUP (?)
$SG14741 DB	01H DUP (?)
$SG14742 DB	01H DUP (?)
$SG14743 DB	01H DUP (?)
$SG14744 DB	01H DUP (?)
$SG14754 DB	01H DUP (?)
$SG14756 DB	01H DUP (?)
$SG14780 DB	01H DUP (?)
$SG14781 DB	01H DUP (?)
$SG14782 DB	01H DUP (?)
$SG14783 DB	01H DUP (?)
$SG14784 DB	01H DUP (?)
$SG14785 DB	01H DUP (?)
$SG14786 DB	01H DUP (?)
$SG14787 DB	01H DUP (?)
$SG14788 DB	01H DUP (?)
$SG14789 DB	01H DUP (?)
$SG14790 DB	01H DUP (?)
$SG14791 DB	01H DUP (?)
$SG14792 DB	01H DUP (?)
$SG14793 DB	01H DUP (?)
$SG14794 DB	01H DUP (?)
$SG14799 DB	01H DUP (?)
$SG14800 DB	01H DUP (?)
$SG14801 DB	01H DUP (?)
$SG14802 DB	01H DUP (?)
$SG14803 DB	01H DUP (?)
$SG14804 DB	01H DUP (?)
$SG14805 DB	01H DUP (?)
$SG14806 DB	01H DUP (?)
$SG14807 DB	01H DUP (?)
$SG14808 DB	01H DUP (?)
$SG14809 DB	01H DUP (?)
$SG14810 DB	01H DUP (?)
$SG14811 DB	01H DUP (?)
$SG14812 DB	01H DUP (?)
$SG14813 DB	01H DUP (?)
$SG14814 DB	01H DUP (?)
$SG14830 DB	01H DUP (?)
$SG14833 DB	01H DUP (?)
$SG14834 DB	01H DUP (?)
$SG14839 DB	01H DUP (?)
$SG14840 DB	01H DUP (?)
$SG14841 DB	01H DUP (?)
$SG14842 DB	01H DUP (?)
$SG14843 DB	01H DUP (?)
$SG14844 DB	01H DUP (?)
$SG14871 DB	01H DUP (?)
$SG14872 DB	01H DUP (?)
$SG14873 DB	01H DUP (?)
$SG14874 DB	01H DUP (?)
$SG14875 DB	01H DUP (?)
$SG14876 DB	01H DUP (?)
$SG14877 DB	01H DUP (?)
$SG14878 DB	01H DUP (?)
$SG14879 DB	01H DUP (?)
$SG14880 DB	01H DUP (?)
$SG14881 DB	01H DUP (?)
$SG14882 DB	01H DUP (?)
$SG14883 DB	01H DUP (?)
$SG14884 DB	01H DUP (?)
$SG14885 DB	01H DUP (?)
$SG14886 DB	01H DUP (?)
$SG14887 DB	01H DUP (?)
$SG14888 DB	01H DUP (?)
$SG14889 DB	01H DUP (?)
$SG14890 DB	01H DUP (?)
$SG14891 DB	01H DUP (?)
$SG14892 DB	01H DUP (?)
$SG14893 DB	01H DUP (?)
$SG14894 DB	01H DUP (?)
$SG14901 DB	01H DUP (?)
$SG14902 DB	01H DUP (?)
$SG14914 DB	01H DUP (?)
$SG14945 DB	01H DUP (?)
$SG14946 DB	01H DUP (?)
$SG14947 DB	01H DUP (?)
$SG14948 DB	01H DUP (?)
$SG14949 DB	01H DUP (?)
$SG14950 DB	01H DUP (?)
$SG14951 DB	01H DUP (?)
$SG14952 DB	01H DUP (?)
$SG14953 DB	01H DUP (?)
$SG14954 DB	01H DUP (?)
$SG14955 DB	01H DUP (?)
$SG14956 DB	01H DUP (?)
$SG14957 DB	01H DUP (?)
$SG14958 DB	01H DUP (?)
$SG14959 DB	01H DUP (?)
$SG14960 DB	01H DUP (?)
$SG14961 DB	01H DUP (?)
$SG14962 DB	01H DUP (?)
$SG14963 DB	01H DUP (?)
$SG14964 DB	01H DUP (?)
$SG14965 DB	01H DUP (?)
$SG14966 DB	01H DUP (?)
$SG14967 DB	01H DUP (?)
$SG14968 DB	01H DUP (?)
$SG14969 DB	01H DUP (?)
$SG14970 DB	01H DUP (?)
$SG14971 DB	01H DUP (?)
$SG14972 DB	01H DUP (?)
$SG14973 DB	01H DUP (?)
$SG14974 DB	01H DUP (?)
$SG14975 DB	01H DUP (?)
$SG14976 DB	01H DUP (?)
$SG14977 DB	01H DUP (?)
$SG14978 DB	01H DUP (?)
$SG14979 DB	01H DUP (?)
$SG14980 DB	01H DUP (?)
$SG14981 DB	01H DUP (?)
$SG14982 DB	01H DUP (?)
$SG14983 DB	01H DUP (?)
$SG14984 DB	01H DUP (?)
$SG14985 DB	01H DUP (?)
$SG14986 DB	01H DUP (?)
$SG14987 DB	01H DUP (?)
$SG14988 DB	01H DUP (?)
$SG14989 DB	01H DUP (?)
$SG14990 DB	01H DUP (?)
$SG14991 DB	01H DUP (?)
$SG14992 DB	01H DUP (?)
$SG14993 DB	01H DUP (?)
$SG14994 DB	01H DUP (?)
$SG14998 DB	01H DUP (?)
$SG14999 DB	01H DUP (?)
$SG15000 DB	01H DUP (?)
$SG15001 DB	01H DUP (?)
$SG15002 DB	01H DUP (?)
$SG15003 DB	01H DUP (?)
$SG15004 DB	01H DUP (?)
$SG15009 DB	01H DUP (?)
$SG15010 DB	01H DUP (?)
$SG15011 DB	01H DUP (?)
$SG15012 DB	01H DUP (?)
$SG15013 DB	01H DUP (?)
$SG15014 DB	01H DUP (?)
$SG15016 DB	01H DUP (?)
$SG15017 DB	01H DUP (?)
$SG15018 DB	01H DUP (?)
$SG15019 DB	01H DUP (?)
$SG15020 DB	01H DUP (?)
$SG15021 DB	01H DUP (?)
$SG15022 DB	01H DUP (?)
$SG15023 DB	01H DUP (?)
$SG15024 DB	01H DUP (?)
$SG15025 DB	01H DUP (?)
$SG15026 DB	01H DUP (?)
$SG15027 DB	01H DUP (?)
$SG15028 DB	01H DUP (?)
$SG15029 DB	01H DUP (?)
$SG15030 DB	01H DUP (?)
$SG15031 DB	01H DUP (?)
$SG15032 DB	01H DUP (?)
$SG15033 DB	01H DUP (?)
$SG15034 DB	01H DUP (?)
$SG15035 DB	01H DUP (?)
$SG15036 DB	01H DUP (?)
$SG15037 DB	01H DUP (?)
$SG15038 DB	01H DUP (?)
$SG15039 DB	01H DUP (?)
$SG15040 DB	01H DUP (?)
$SG15041 DB	01H DUP (?)
$SG15042 DB	01H DUP (?)
$SG15043 DB	01H DUP (?)
$SG15044 DB	01H DUP (?)
$SG15053 DB	01H DUP (?)
$SG15054 DB	01H DUP (?)
$SG15055 DB	01H DUP (?)
$SG15056 DB	01H DUP (?)
$SG15057 DB	01H DUP (?)
$SG15058 DB	01H DUP (?)
$SG15059 DB	01H DUP (?)
$SG15060 DB	01H DUP (?)
$SG15061 DB	01H DUP (?)
$SG15062 DB	01H DUP (?)
$SG15063 DB	01H DUP (?)
$SG15064 DB	01H DUP (?)
$SG15065 DB	01H DUP (?)
$SG15066 DB	01H DUP (?)
$SG15067 DB	01H DUP (?)
$SG15068 DB	01H DUP (?)
$SG15069 DB	01H DUP (?)
$SG15070 DB	01H DUP (?)
$SG15071 DB	01H DUP (?)
$SG15072 DB	01H DUP (?)
$SG15073 DB	01H DUP (?)
$SG15074 DB	01H DUP (?)
$SG15075 DB	01H DUP (?)
$SG15076 DB	01H DUP (?)
$SG15077 DB	01H DUP (?)
$SG15078 DB	01H DUP (?)
$SG15079 DB	01H DUP (?)
$SG15080 DB	01H DUP (?)
$SG15081 DB	01H DUP (?)
$SG15082 DB	01H DUP (?)
$SG15083 DB	01H DUP (?)
$SG15084 DB	01H DUP (?)
$SG15085 DB	01H DUP (?)
$SG15086 DB	01H DUP (?)
$SG15087 DB	01H DUP (?)
$SG15088 DB	01H DUP (?)
$SG15089 DB	01H DUP (?)
$SG15090 DB	01H DUP (?)
$SG15091 DB	01H DUP (?)
$SG15092 DB	01H DUP (?)
$SG15093 DB	01H DUP (?)
$SG15094 DB	01H DUP (?)
$SG15112 DB	01H DUP (?)
$SG15113 DB	01H DUP (?)
$SG15114 DB	01H DUP (?)
$SG15115 DB	01H DUP (?)
$SG15116 DB	01H DUP (?)
$SG15117 DB	01H DUP (?)
$SG15118 DB	01H DUP (?)
$SG15119 DB	01H DUP (?)
$SG15120 DB	01H DUP (?)
$SG15121 DB	01H DUP (?)
$SG15122 DB	01H DUP (?)
$SG15123 DB	01H DUP (?)
$SG15124 DB	01H DUP (?)
$SG15125 DB	01H DUP (?)
$SG15126 DB	01H DUP (?)
$SG15127 DB	01H DUP (?)
$SG15128 DB	01H DUP (?)
$SG15129 DB	01H DUP (?)
$SG15130 DB	01H DUP (?)
$SG15131 DB	01H DUP (?)
$SG15132 DB	01H DUP (?)
$SG15133 DB	01H DUP (?)
$SG15134 DB	01H DUP (?)
$SG15135 DB	01H DUP (?)
$SG15136 DB	01H DUP (?)
$SG15137 DB	01H DUP (?)
$SG15138 DB	01H DUP (?)
$SG15139 DB	01H DUP (?)
$SG15140 DB	01H DUP (?)
$SG15141 DB	01H DUP (?)
$SG15142 DB	01H DUP (?)
$SG15143 DB	01H DUP (?)
$SG15144 DB	01H DUP (?)
$SG15161 DB	01H DUP (?)
$SG15162 DB	01H DUP (?)
$SG15163 DB	01H DUP (?)
$SG15164 DB	01H DUP (?)
$SG15165 DB	01H DUP (?)
$SG15166 DB	01H DUP (?)
$SG15167 DB	01H DUP (?)
$SG15168 DB	01H DUP (?)
$SG15169 DB	01H DUP (?)
$SG15170 DB	01H DUP (?)
$SG15171 DB	01H DUP (?)
$SG15172 DB	01H DUP (?)
$SG15173 DB	01H DUP (?)
$SG15174 DB	01H DUP (?)
$SG15175 DB	01H DUP (?)
$SG15176 DB	01H DUP (?)
$SG15177 DB	01H DUP (?)
$SG15178 DB	01H DUP (?)
$SG15179 DB	01H DUP (?)
$SG15180 DB	01H DUP (?)
$SG15181 DB	01H DUP (?)
$SG15182 DB	01H DUP (?)
$SG15183 DB	01H DUP (?)
$SG15184 DB	01H DUP (?)
$SG15185 DB	01H DUP (?)
$SG15186 DB	01H DUP (?)
$SG15187 DB	01H DUP (?)
$SG15188 DB	01H DUP (?)
$SG15189 DB	01H DUP (?)
$SG15190 DB	01H DUP (?)
$SG15191 DB	01H DUP (?)
$SG15192 DB	01H DUP (?)
$SG15193 DB	01H DUP (?)
$SG15194 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG15366 DB	'fnValidViewEntity - Invalid View (0x%08x) for Entity: %s'
	DB	00H
	ORG $+7
$SG15371 DB	'fnValidViewEntity - Invalid Entity name: %s   for View ('
	DB	'0x%08x)   OD: %s', 00H
	ORG $+3
$SG15409 DB	'[View: 0x%08x] %s.%s.%s', 00H
$SG15410 DB	'fnValidViewAttrib error: ', 00H
	ORG $+2
$SG15424 DB	' (', 00H
	ORG $+1
$SG15425 DB	')', 00H
	ORG $+2
$SG14443 DB	'%s.%s.%s', 00H
	ORG $+3
$SG14444 DB	'Created DebugChange element for ', 00H
	ORG $+3
$SG15516 DB	'View does not have a valid OD', 00H
	ORG $+2
$SG15517 DB	'OI Integrity', 00H
	ORG $+3
$SG15520 DB	'View does not have a valid ViewCsr', 00H
	ORG $+1
$SG15521 DB	'OI Integrity', 00H
	ORG $+3
$SG15524 DB	'View does not have a valid View OI', 00H
	ORG $+1
$SG15525 DB	'OI Integrity', 00H
	ORG $+3
$SG15527 DB	'Too many entities', 00H
	ORG $+2
$SG15528 DB	'OI Integrity', 00H
	ORG $+3
$SG15530 DB	'OI Integrity--EI''s hier # = ', 00H
	ORG $+3
$SG15531 DB	'View has an invalid entity', 00H
	ORG $+1
$SG15532 DB	'OI Integrity', 00H
	ORG $+3
$SG14509 DB	'------- Attribute from same EI ----------', 00H
	ORG $+2
$SG14510 DB	'%s.%s.%s', 00H
	ORG $+3
$SG15535 DB	'OI Integrity--EI''s hier # = ', 00H
	ORG $+3
$SG14511 DB	'Attribute = ', 00H
	ORG $+3
$SG15536 DB	'Too many linked EIs', 00H
$SG15537 DB	'OI Integrity', 00H
	ORG $+3
$SG14513 DB	'Old value = ', 00H
	ORG $+3
$SG14514 DB	'New Value = ', 00H
	ORG $+3
$SG15539 DB	'OI Integrity--EI''s hier # = ', 00H
	ORG $+3
$SG15540 DB	'Invalid linked EI', 00H
	ORG $+2
$SG15541 DB	'OI Integrity', 00H
	ORG $+3
$SG14518 DB	'Old value = ', 00H
	ORG $+3
$SG14519 DB	'New Value = ', 00H
	ORG $+3
$SG14602 DB	'(DbgChg) Storing ', 00H
	ORG $+2
$SG14610 DB	'Old value = ', 00H
	ORG $+3
$SG14611 DB	'New Value = ', 00H
	ORG $+3
$SG14619 DB	'Old value = ', 00H
	ORG $+3
$SG14620 DB	'New Value = ', 00H
	ORG $+3
$SG14630 DB	'Old lth = ', 00H
	ORG $+1
$SG14631 DB	'New lth = ', 00H
	ORG $+1
$SG14633 DB	'Same lth but different values', 00H
	ORG $+2
$SG14634 DB	'Old ==> ', 00H
	ORG $+3
$SG14635 DB	'New ==> ', 00H
	ORG $+3
$SG14639 DB	'Start', 00H
	ORG $+2
$SG14640 DB	'Exit', 00H
	ORG $+3
$SG14645 DB	'?', 00H
	ORG $+2
$SG14641 DB	'Operation%s: Core detected a change in the attribute %s.'
	DB	'%s.%s.  See Trace for old and new values.', 00H
	ORG $+2
$SG14642 DB	'Debug Change', 00H
	ORG $+3
$SG14655 DB	'(10)SfCreateSubtask', 00H
_g_Operations DD FLAT:$SG14645
	DD	FLAT:$SG14646
	DD	FLAT:$SG14647
	DD	FLAT:$SG14648
	DD	FLAT:$SG14649
	DD	FLAT:$SG14650
	DD	FLAT:$SG14651
	DD	FLAT:$SG14652
	DD	FLAT:$SG14653
	DD	FLAT:$SG14654
	DD	FLAT:$SG14655
	DD	FLAT:$SG14656
	DD	FLAT:$SG14657
	DD	FLAT:$SG14658
	DD	FLAT:$SG14659
	DD	FLAT:$SG14660
	DD	FLAT:$SG14661
	DD	FLAT:$SG14662
	DD	FLAT:$SG14663
	DD	FLAT:$SG14664
	DD	FLAT:$SG14665
	DD	FLAT:$SG14666
	DD	FLAT:$SG14667
	DD	FLAT:$SG14668
	DD	FLAT:$SG14669
	DD	FLAT:$SG14670
	DD	FLAT:$SG14671
	DD	FLAT:$SG14672
	DD	FLAT:$SG14673
	DD	FLAT:$SG14674
	DD	FLAT:$SG14675
	DD	FLAT:$SG14676
	DD	FLAT:$SG14677
	DD	FLAT:$SG14678
	DD	FLAT:$SG14679
	DD	FLAT:$SG14680
	DD	FLAT:$SG14681
	DD	FLAT:$SG14682
	DD	FLAT:$SG14683
	DD	FLAT:$SG14684
	DD	FLAT:$SG14685
	DD	FLAT:$SG14686
	DD	FLAT:$SG14687
	DD	FLAT:$SG14688
	DD	FLAT:$SG14689
	DD	FLAT:$SG14690
	DD	FLAT:$SG14691
	DD	FLAT:$SG14692
	DD	FLAT:$SG14693
	DD	FLAT:$SG14694
	DD	FLAT:$SG14695
	DD	FLAT:$SG14696
	DD	FLAT:$SG14697
	DD	FLAT:$SG14698
	DD	FLAT:$SG14699
	DD	FLAT:$SG14700
	DD	FLAT:$SG14701
	DD	FLAT:$SG14702
	DD	FLAT:$SG14703
	DD	FLAT:$SG14704
	DD	FLAT:$SG14705
	DD	FLAT:$SG14706
	DD	FLAT:$SG14707
	DD	FLAT:$SG14708
	DD	FLAT:$SG14709
	DD	FLAT:$SG14710
	DD	FLAT:$SG14711
	DD	FLAT:$SG14712
	DD	FLAT:$SG14713
	DD	FLAT:$SG14714
	DD	FLAT:$SG14715
	DD	FLAT:$SG14716
	DD	FLAT:$SG14717
	DD	FLAT:$SG14718
	DD	FLAT:$SG14719
	DD	FLAT:$SG14720
	DD	FLAT:$SG14721
	DD	FLAT:$SG14722
	DD	FLAT:$SG14723
	DD	FLAT:$SG14724
	DD	FLAT:$SG14725
	DD	FLAT:$SG14726
	DD	FLAT:$SG14727
	DD	FLAT:$SG14728
	DD	FLAT:$SG14729
	DD	FLAT:$SG14730
	DD	FLAT:$SG14731
	DD	FLAT:$SG14732
	DD	FLAT:$SG14733
	DD	FLAT:$SG14734
	DD	FLAT:$SG14735
	DD	FLAT:$SG14736
	DD	FLAT:$SG14737
	DD	FLAT:$SG14738
	DD	FLAT:$SG14739
	DD	FLAT:$SG14740
	DD	FLAT:$SG14741
	DD	FLAT:$SG14742
	DD	FLAT:$SG14743
	DD	FLAT:$SG14744
	DD	FLAT:$SG14745
	DD	FLAT:$SG14746
	DD	FLAT:$SG14747
	DD	FLAT:$SG14748
	DD	FLAT:$SG14749
	DD	FLAT:$SG14750
	DD	FLAT:$SG14751
	DD	FLAT:$SG14752
	DD	FLAT:$SG14753
	DD	FLAT:$SG14754
	DD	FLAT:$SG14755
	DD	FLAT:$SG14756
	DD	FLAT:$SG14757
	DD	FLAT:$SG14758
	DD	FLAT:$SG14759
	DD	FLAT:$SG14760
	DD	FLAT:$SG14761
	DD	FLAT:$SG14762
	DD	FLAT:$SG14763
	DD	FLAT:$SG14764
	DD	FLAT:$SG14765
	DD	FLAT:$SG14766
	DD	FLAT:$SG14767
	DD	FLAT:$SG14768
	DD	FLAT:$SG14769
	DD	FLAT:$SG14770
	DD	FLAT:$SG14771
	DD	FLAT:$SG14772
	DD	FLAT:$SG14773
	DD	FLAT:$SG14774
	DD	FLAT:$SG14775
	DD	FLAT:$SG14776
	DD	FLAT:$SG14777
	DD	FLAT:$SG14778
	DD	FLAT:$SG14779
	DD	FLAT:$SG14780
	DD	FLAT:$SG14781
	DD	FLAT:$SG14782
	DD	FLAT:$SG14783
	DD	FLAT:$SG14784
	DD	FLAT:$SG14785
	DD	FLAT:$SG14786
	DD	FLAT:$SG14787
	DD	FLAT:$SG14788
	DD	FLAT:$SG14789
	DD	FLAT:$SG14790
	DD	FLAT:$SG14791
	DD	FLAT:$SG14792
	DD	FLAT:$SG14793
	DD	FLAT:$SG14794
	DD	FLAT:$SG14795
	DD	FLAT:$SG14796
	DD	FLAT:$SG14797
	DD	FLAT:$SG14798
	DD	FLAT:$SG14799
	DD	FLAT:$SG14800
	DD	FLAT:$SG14801
	DD	FLAT:$SG14802
	DD	FLAT:$SG14803
	DD	FLAT:$SG14804
	DD	FLAT:$SG14805
	DD	FLAT:$SG14806
	DD	FLAT:$SG14807
	DD	FLAT:$SG14808
	DD	FLAT:$SG14809
	DD	FLAT:$SG14810
	DD	FLAT:$SG14811
	DD	FLAT:$SG14812
	DD	FLAT:$SG14813
	DD	FLAT:$SG14814
	DD	FLAT:$SG14815
	DD	FLAT:$SG14816
	DD	FLAT:$SG14817
	DD	FLAT:$SG14818
	DD	FLAT:$SG14819
	DD	FLAT:$SG14820
	DD	FLAT:$SG14821
	DD	FLAT:$SG14822
	DD	FLAT:$SG14823
	DD	FLAT:$SG14824
	DD	FLAT:$SG14825
	DD	FLAT:$SG14826
	DD	FLAT:$SG14827
	DD	FLAT:$SG14828
	DD	FLAT:$SG14829
	DD	FLAT:$SG14830
	DD	FLAT:$SG14831
	DD	FLAT:$SG14832
	DD	FLAT:$SG14833
	DD	FLAT:$SG14834
	DD	FLAT:$SG14835
	DD	FLAT:$SG14836
	DD	FLAT:$SG14837
	DD	FLAT:$SG14838
	DD	FLAT:$SG14839
	DD	FLAT:$SG14840
	DD	FLAT:$SG14841
	DD	FLAT:$SG14842
	DD	FLAT:$SG14843
	DD	FLAT:$SG14844
	DD	FLAT:$SG14845
	DD	FLAT:$SG14846
	DD	FLAT:$SG14847
	DD	FLAT:$SG14848
	DD	FLAT:$SG14849
	DD	FLAT:$SG14850
	DD	FLAT:$SG14851
	DD	FLAT:$SG14852
	DD	FLAT:$SG14853
	DD	FLAT:$SG14854
	DD	FLAT:$SG14855
	DD	FLAT:$SG14856
	DD	FLAT:$SG14857
	DD	FLAT:$SG14858
	DD	FLAT:$SG14859
	DD	FLAT:$SG14860
	DD	FLAT:$SG14861
	DD	FLAT:$SG14862
	DD	FLAT:$SG14863
	DD	FLAT:$SG14864
	DD	FLAT:$SG14865
	DD	FLAT:$SG14866
	DD	FLAT:$SG14867
	DD	FLAT:$SG14868
	DD	FLAT:$SG14869
	DD	FLAT:$SG14870
	DD	FLAT:$SG14871
	DD	FLAT:$SG14872
	DD	FLAT:$SG14873
	DD	FLAT:$SG14874
	DD	FLAT:$SG14875
	DD	FLAT:$SG14876
	DD	FLAT:$SG14877
	DD	FLAT:$SG14878
	DD	FLAT:$SG14879
	DD	FLAT:$SG14880
	DD	FLAT:$SG14881
	DD	FLAT:$SG14882
	DD	FLAT:$SG14883
	DD	FLAT:$SG14884
	DD	FLAT:$SG14885
	DD	FLAT:$SG14886
	DD	FLAT:$SG14887
	DD	FLAT:$SG14888
	DD	FLAT:$SG14889
	DD	FLAT:$SG14890
	DD	FLAT:$SG14891
	DD	FLAT:$SG14892
	DD	FLAT:$SG14893
	DD	FLAT:$SG14894
	DD	FLAT:$SG14895
	DD	FLAT:$SG14896
	DD	FLAT:$SG14897
	DD	FLAT:$SG14898
	DD	FLAT:$SG14899
	DD	FLAT:$SG14900
	DD	FLAT:$SG14901
	DD	FLAT:$SG14902
	DD	FLAT:$SG14903
	DD	FLAT:$SG14904
	DD	FLAT:$SG14905
	DD	FLAT:$SG14906
	DD	FLAT:$SG14907
	DD	FLAT:$SG14908
	DD	FLAT:$SG14909
	DD	FLAT:$SG14910
	DD	FLAT:$SG14911
	DD	FLAT:$SG14912
	DD	FLAT:$SG14913
	DD	FLAT:$SG14914
	DD	FLAT:$SG14915
	DD	FLAT:$SG14916
	DD	FLAT:$SG14917
	DD	FLAT:$SG14918
	DD	FLAT:$SG14919
	DD	FLAT:$SG14920
	DD	FLAT:$SG14921
	DD	FLAT:$SG14922
	DD	FLAT:$SG14923
	DD	FLAT:$SG14924
	DD	FLAT:$SG14925
	DD	FLAT:$SG14926
	DD	FLAT:$SG14927
	DD	FLAT:$SG14928
	DD	FLAT:$SG14929
	DD	FLAT:$SG14930
	DD	FLAT:$SG14931
	DD	FLAT:$SG14932
	DD	FLAT:$SG14933
	DD	FLAT:$SG14934
	DD	FLAT:$SG14935
	DD	FLAT:$SG14936
	DD	FLAT:$SG14937
	DD	FLAT:$SG14938
	DD	FLAT:$SG14939
	DD	FLAT:$SG14940
	DD	FLAT:$SG14941
	DD	FLAT:$SG14942
	DD	FLAT:$SG14943
	DD	FLAT:$SG14944
	DD	FLAT:$SG14945
	DD	FLAT:$SG14946
	DD	FLAT:$SG14947
	DD	FLAT:$SG14948
	DD	FLAT:$SG14949
	DD	FLAT:$SG14950
	DD	FLAT:$SG14951
	DD	FLAT:$SG14952
	DD	FLAT:$SG14953
	DD	FLAT:$SG14954
	DD	FLAT:$SG14955
	DD	FLAT:$SG14956
	DD	FLAT:$SG14957
	DD	FLAT:$SG14958
	DD	FLAT:$SG14959
	DD	FLAT:$SG14960
	DD	FLAT:$SG14961
	DD	FLAT:$SG14962
	DD	FLAT:$SG14963
	DD	FLAT:$SG14964
	DD	FLAT:$SG14965
	DD	FLAT:$SG14966
	DD	FLAT:$SG14967
	DD	FLAT:$SG14968
	DD	FLAT:$SG14969
	DD	FLAT:$SG14970
	DD	FLAT:$SG14971
	DD	FLAT:$SG14972
	DD	FLAT:$SG14973
	DD	FLAT:$SG14974
	DD	FLAT:$SG14975
	DD	FLAT:$SG14976
	DD	FLAT:$SG14977
	DD	FLAT:$SG14978
	DD	FLAT:$SG14979
	DD	FLAT:$SG14980
	DD	FLAT:$SG14981
	DD	FLAT:$SG14982
	DD	FLAT:$SG14983
	DD	FLAT:$SG14984
	DD	FLAT:$SG14985
	DD	FLAT:$SG14986
	DD	FLAT:$SG14987
	DD	FLAT:$SG14988
	DD	FLAT:$SG14989
	DD	FLAT:$SG14990
	DD	FLAT:$SG14991
	DD	FLAT:$SG14992
	DD	FLAT:$SG14993
	DD	FLAT:$SG14994
	DD	FLAT:$SG14995
	DD	FLAT:$SG14996
	DD	FLAT:$SG14997
	DD	FLAT:$SG14998
	DD	FLAT:$SG14999
	DD	FLAT:$SG15000
	DD	FLAT:$SG15001
	DD	FLAT:$SG15002
	DD	FLAT:$SG15003
	DD	FLAT:$SG15004
	DD	FLAT:$SG15005
	DD	FLAT:$SG15006
	DD	FLAT:$SG15007
	DD	FLAT:$SG15008
	DD	FLAT:$SG15009
	DD	FLAT:$SG15010
	DD	FLAT:$SG15011
	DD	FLAT:$SG15012
	DD	FLAT:$SG15013
	DD	FLAT:$SG15014
	DD	FLAT:$SG15015
	DD	FLAT:$SG15016
	DD	FLAT:$SG15017
	DD	FLAT:$SG15018
	DD	FLAT:$SG15019
	DD	FLAT:$SG15020
	DD	FLAT:$SG15021
	DD	FLAT:$SG15022
	DD	FLAT:$SG15023
	DD	FLAT:$SG15024
	DD	FLAT:$SG15025
	DD	FLAT:$SG15026
	DD	FLAT:$SG15027
	DD	FLAT:$SG15028
	DD	FLAT:$SG15029
	DD	FLAT:$SG15030
	DD	FLAT:$SG15031
	DD	FLAT:$SG15032
	DD	FLAT:$SG15033
	DD	FLAT:$SG15034
	DD	FLAT:$SG15035
	DD	FLAT:$SG15036
	DD	FLAT:$SG15037
	DD	FLAT:$SG15038
	DD	FLAT:$SG15039
	DD	FLAT:$SG15040
	DD	FLAT:$SG15041
	DD	FLAT:$SG15042
	DD	FLAT:$SG15043
	DD	FLAT:$SG15044
	DD	FLAT:$SG15045
	DD	FLAT:$SG15046
	DD	FLAT:$SG15047
	DD	FLAT:$SG15048
	DD	FLAT:$SG15049
	DD	FLAT:$SG15050
	DD	FLAT:$SG15051
	DD	FLAT:$SG15052
	DD	FLAT:$SG15053
	DD	FLAT:$SG15054
	DD	FLAT:$SG15055
	DD	FLAT:$SG15056
	DD	FLAT:$SG15057
	DD	FLAT:$SG15058
	DD	FLAT:$SG15059
	DD	FLAT:$SG15060
	DD	FLAT:$SG15061
	DD	FLAT:$SG15062
	DD	FLAT:$SG15063
	DD	FLAT:$SG15064
	DD	FLAT:$SG15065
	DD	FLAT:$SG15066
	DD	FLAT:$SG15067
	DD	FLAT:$SG15068
	DD	FLAT:$SG15069
	DD	FLAT:$SG15070
	DD	FLAT:$SG15071
	DD	FLAT:$SG15072
	DD	FLAT:$SG15073
	DD	FLAT:$SG15074
	DD	FLAT:$SG15075
	DD	FLAT:$SG15076
	DD	FLAT:$SG15077
	DD	FLAT:$SG15078
	DD	FLAT:$SG15079
	DD	FLAT:$SG15080
	DD	FLAT:$SG15081
	DD	FLAT:$SG15082
	DD	FLAT:$SG15083
	DD	FLAT:$SG15084
	DD	FLAT:$SG15085
	DD	FLAT:$SG15086
	DD	FLAT:$SG15087
	DD	FLAT:$SG15088
	DD	FLAT:$SG15089
	DD	FLAT:$SG15090
	DD	FLAT:$SG15091
	DD	FLAT:$SG15092
	DD	FLAT:$SG15093
	DD	FLAT:$SG15094
	DD	FLAT:$SG15095
	DD	FLAT:$SG15096
	DD	FLAT:$SG15097
	DD	FLAT:$SG15098
	DD	FLAT:$SG15099
	DD	FLAT:$SG15100
	DD	FLAT:$SG15101
	DD	FLAT:$SG15102
	DD	FLAT:$SG15103
	DD	FLAT:$SG15104
	DD	FLAT:$SG15105
	DD	FLAT:$SG15106
	DD	FLAT:$SG15107
	DD	FLAT:$SG15108
	DD	FLAT:$SG15109
	DD	FLAT:$SG15110
	DD	FLAT:$SG15111
	DD	FLAT:$SG15112
	DD	FLAT:$SG15113
	DD	FLAT:$SG15114
	DD	FLAT:$SG15115
	DD	FLAT:$SG15116
	DD	FLAT:$SG15117
	DD	FLAT:$SG15118
	DD	FLAT:$SG15119
	DD	FLAT:$SG15120
	DD	FLAT:$SG15121
	DD	FLAT:$SG15122
	DD	FLAT:$SG15123
	DD	FLAT:$SG15124
	DD	FLAT:$SG15125
	DD	FLAT:$SG15126
	DD	FLAT:$SG15127
	DD	FLAT:$SG15128
	DD	FLAT:$SG15129
	DD	FLAT:$SG15130
	DD	FLAT:$SG15131
	DD	FLAT:$SG15132
	DD	FLAT:$SG15133
	DD	FLAT:$SG15134
	DD	FLAT:$SG15135
	DD	FLAT:$SG15136
	DD	FLAT:$SG15137
	DD	FLAT:$SG15138
	DD	FLAT:$SG15139
	DD	FLAT:$SG15140
	DD	FLAT:$SG15141
	DD	FLAT:$SG15142
	DD	FLAT:$SG15143
	DD	FLAT:$SG15144
	DD	FLAT:$SG15145
	DD	FLAT:$SG15146
	DD	FLAT:$SG15147
	DD	FLAT:$SG15148
	DD	FLAT:$SG15149
	DD	FLAT:$SG15150
	DD	FLAT:$SG15151
	DD	FLAT:$SG15152
	DD	FLAT:$SG15153
	DD	FLAT:$SG15154
	DD	FLAT:$SG15155
	DD	FLAT:$SG15156
	DD	FLAT:$SG15157
	DD	FLAT:$SG15158
	DD	FLAT:$SG15159
	DD	FLAT:$SG15160
	DD	FLAT:$SG15161
	DD	FLAT:$SG15162
	DD	FLAT:$SG15163
	DD	FLAT:$SG15164
	DD	FLAT:$SG15165
	DD	FLAT:$SG15166
	DD	FLAT:$SG15167
	DD	FLAT:$SG15168
	DD	FLAT:$SG15169
	DD	FLAT:$SG15170
	DD	FLAT:$SG15171
	DD	FLAT:$SG15172
	DD	FLAT:$SG15173
	DD	FLAT:$SG15174
	DD	FLAT:$SG15175
	DD	FLAT:$SG15176
	DD	FLAT:$SG15177
	DD	FLAT:$SG15178
	DD	FLAT:$SG15179
	DD	FLAT:$SG15180
	DD	FLAT:$SG15181
	DD	FLAT:$SG15182
	DD	FLAT:$SG15183
	DD	FLAT:$SG15184
	DD	FLAT:$SG15185
	DD	FLAT:$SG15186
	DD	FLAT:$SG15187
	DD	FLAT:$SG15188
	DD	FLAT:$SG15189
	DD	FLAT:$SG15190
	DD	FLAT:$SG15191
	DD	FLAT:$SG15192
	DD	FLAT:$SG15193
	DD	FLAT:$SG15194
	DD	FLAT:$SG15195
	DD	FLAT:$SG15196
	DD	FLAT:$SG15197
	DD	FLAT:$SG15198
	DD	FLAT:$SG15199
	ORG $+4
$SG14656 DB	'(11)SfDropSubtask', 00H
	ORG $+2
$SG14657 DB	'(12)DisableTask', 00H
$SG14658 DB	'(13)EnableTask', 00H
	ORG $+1
$SG14665 DB	'(20)GetApplDirectoryFromView', 00H
	ORG $+3
$SG14666 DB	'(21)SfGetApplicationForSubtask', 00H
	ORG $+1
$SG14667 DB	'(22)SfSetApplicationForSubtask', 00H
	ORG $+1
$SG14668 DB	'(23)SfGetDefaultContextForDomain', 00H
	ORG $+3
$SG14669 DB	'(24)SfGetTaskInfo', 00H
	ORG $+2
$SG14670 DB	'(25)SfAllocTaskMemory', 00H
	ORG $+2
$SG14671 DB	'(26)SfFreeTaskMemory', 00H
	ORG $+3
$SG14672 DB	'(27)SfReAllocTaskMemory', 00H
$SG14673 DB	'(28)SfCheckOI_Integrity', 00H
$SG14674 DB	'(29)SetDatabaseUser', 00H
$SG14695 DB	'(50)ActivateEmptyObjectInstance', 00H
$SG14697 DB	'(52)ActivateObjectInstance', 00H
	ORG $+1
$SG14699 DB	'(54)ActivateOI_FromFile', 00H
$SG14700 DB	'(55)ActivateOI_FromOI_ForTask', 00H
	ORG $+2
$SG14705 DB	'(60)CommitObjectInstance', 00H
	ORG $+3
$SG14706 DB	'(61)CommitOI_ToFile', 00H
$SG14707 DB	'(62)CommitMultipleOIs', 00H
	ORG $+2
$SG14708 DB	'(63)DropViewCluster', 00H
$SG14709 DB	'(64)AddToViewCluster', 00H
	ORG $+3
$SG14710 DB	'(65)GenerateQualFromEntityList', 00H
	ORG $+1
$SG14715 DB	'(70)DropObjectInstance', 00H
	ORG $+1
$SG14745 DB	'(100)CheckExistenceOfEntity', 00H
$SG14746 DB	'(101)CreateEntity', 00H
	ORG $+2
$SG14747 DB	'(102)CreateTemporalSubobjectVersion', 00H
$SG14748 DB	'(103)AcceptSubobject', 00H
	ORG $+3
$SG14749 DB	'(104)CancelSubobject', 00H
	ORG $+3
$SG14750 DB	'(105)IncludeSubobjectFromSubobject', 00H
	ORG $+1
$SG14751 DB	'(106)DeleteEntity', 00H
	ORG $+2
$SG14752 DB	'(107)ExcludeEntity', 00H
	ORG $+1
$SG14753 DB	'(108)GetEntityKey', 00H
	ORG $+2
$SG14755 DB	'(110)MoveSubobject', 00H
	ORG $+1
$SG14757 DB	'(112)GetSelectStateOfEntity', 00H
$SG14758 DB	'(113)SetAllSelectStatesForEntity', 00H
	ORG $+3
$SG14759 DB	'(114)SetSelectStateOfEntity', 00H
$SG14760 DB	'(115)CreateTemporalEntity', 00H
	ORG $+2
$SG14761 DB	'(116)RelinkInstanceToInstance', 00H
	ORG $+2
$SG14762 DB	'(117)LoadEntity', 00H
$SG14763 DB	'(118)ObjectInstanceUpdated', 00H
	ORG $+1
$SG14764 DB	'(119)SetIncrementalUpdateFlags', 00H
	ORG $+1
$SG14765 DB	'(120)GetIncrementalUpdateFlags', 00H
	ORG $+1
$SG14766 DB	'(121)RelinkAllSubobjectsForOI', 00H
	ORG $+2
$SG14767 DB	'(122)OrderEntityForView', 00H
$SG14768 DB	'(123)CountEntitiesForView', 00H
	ORG $+2
$SG14769 DB	'(124)OrderEntitiesByDefaultAttribs', 00H
	ORG $+1
$SG14770 DB	'(125)OrderOI_ByDefaultAttribs', 00H
	ORG $+2
$SG14771 DB	'(126)DropEntity', 00H
$SG14772 DB	'(127)AcceptAllTemporalSubobjects', 00H
	ORG $+3
$SG14773 DB	'(128)CancelAllTemporalSubobjects', 00H
	ORG $+3
$SG14774 DB	'(129)SetSelectSetForView', 00H
	ORG $+3
$SG14775 DB	'(130)ObjectInstanceUpdatedFromFile', 00H
	ORG $+1
$SG14776 DB	'(131)CountEntitiesForViewUnderParent', 00H
	ORG $+3
$SG14777 DB	'(132)CheckEntityInView', 00H
	ORG $+1
$SG14778 DB	'(133)IncludeSubobjectFromSubobjectEx', 00H
	ORG $+3
$SG14779 DB	'(134)SubobjectVersionUpdated', 00H
	ORG $+3
$SG14795 DB	'(150)SetCursorNextEntity', 00H
	ORG $+3
$SG14796 DB	'(151)SetCursorPrevEntity', 00H
	ORG $+3
$SG14797 DB	'(152)SetCursorFirstEntity', 00H
	ORG $+2
$SG14798 DB	'(153)SetCursorLastEntity', 00H
	ORG $+3
$SG14815 DB	'(170)SetCursorFirstEntityByString', 00H
	ORG $+2
$SG14816 DB	'(171)SetCursorNextEntityByString', 00H
	ORG $+3
$SG14817 DB	'(172)SetCursorFirstEntityByInteger', 00H
	ORG $+1
$SG14818 DB	'(173)SetCursorNextEntityByInteger', 00H
	ORG $+2
$SG14819 DB	'(174)SetCursorFirstEntityByDecimal', 00H
	ORG $+1
$SG14820 DB	'(175)SetCursorNextEntityByDecimal', 00H
	ORG $+2
$SG14821 DB	'(176)SetCursorFirstEntityByAttr', 00H
$SG14822 DB	'(177)SetCursorNextEntityByAttr', 00H
	ORG $+1
$SG14823 DB	'(178)SetCursorFirstEntityByEntityCs', 00H
$SG14824 DB	'(179)SetCursorNextEntityByEntityCsr', 00H
$SG14825 DB	'(180)SetCursorFirstSelectedEntity', 00H
	ORG $+2
$SG14826 DB	'(181)SetCursorNextSelectedEntity', 00H
	ORG $+3
$SG14827 DB	'(182)SetCursorRelativeEntity', 00H
	ORG $+3
$SG14828 DB	'(183)GetRelativeEntityNumber', 00H
	ORG $+3
$SG14829 DB	'(184)SetEntityCursor', 00H
	ORG $+3
$SG14831 DB	'(186)GetAbsolutePositionForEntity', 00H
	ORG $+2
$SG14832 DB	'(187)SetCursorAbsolutePosition', 00H
	ORG $+1
$SG14835 DB	'(190)DefineHierarchicalCursor', 00H
	ORG $+2
$SG14836 DB	'(191)DropHierarchicalCursor', 00H
$SG14837 DB	'(192)SetCursorNextEntityHierarchica', 00H
$SG14838 DB	'(193)GetEntityNameForHierarchicalCsr', 00H
	ORG $+3
$SG14845 DB	'(200)CreateViewFromViewForTask', 00H
	ORG $+1
$SG14846 DB	'(201)SetViewFromView', 00H
	ORG $+3
$SG14847 DB	'(202)SetViewToSubobject', 00H
$SG14848 DB	'(203)ResetViewFromSubobject', 00H
$SG14849 DB	'(204)SetNameForView', 00H
$SG14850 DB	'(205)DropNameForView', 00H
	ORG $+3
$SG14851 DB	'(206)GetViewByName', 00H
	ORG $+1
$SG14852 DB	'(207)SetSubtaskView', 00H
$SG14853 DB	'(208)GetNameForView', 00H
$SG14854 DB	'(209)SfGetFirstSubtaskView', 00H
	ORG $+1
$SG14855 DB	'(210)SfGetNextSubtaskView', 00H
	ORG $+2
$SG14856 DB	'(211)ResetView', 00H
	ORG $+1
$SG14857 DB	'(212)DropView', 00H
	ORG $+2
$SG14858 DB	'(213)SfTransferView', 00H
$SG14859 DB	'(214)SfLockView', 00H
$SG14860 DB	'(215)SfActivateSysOI_FromFile', 00H
	ORG $+2
$SG14861 DB	'(216)SfActivateSysEmptyOI', 00H
	ORG $+2
$SG14862 DB	'(217)SetViewReadOnly', 00H
	ORG $+3
$SG14863 DB	'(218)SfGetFirstNamedView', 00H
	ORG $+3
$SG14864 DB	'(219)SfGetNextNamedView', 00H
$SG14865 DB	'(220)SfCreateSysViewFromView', 00H
	ORG $+3
$SG14866 DB	'(221)ResetViewPositions', 00H
$SG14867 DB	'(222)SetViewFlags', 00H
	ORG $+2
$SG14868 DB	'(223)DropViewObject', 00H
$SG14869 DB	'(224)GetViewFlags', 00H
	ORG $+2
$SG14870 DB	'(225)SfSetApplicationTask', 00H
	ORG $+2
$SG14895 DB	'(250)GetStringFromAttribute', 00H
$SG14896 DB	'(251)GetIntegerFromAttribute', 00H
	ORG $+3
$SG14897 DB	'(252)GetDecimalFromAttribute', 00H
	ORG $+3
$SG14898 DB	'(253)GetBlobFromAttribute', 00H
	ORG $+2
$SG14899 DB	'(254)GetAttributeFlags', 00H
	ORG $+1
$SG14900 DB	'(255)AttributeUpdated', 00H
	ORG $+2
$SG14903 DB	'(258)GetStructFromEntityAttrs', 00H
	ORG $+2
$SG14904 DB	'(259)GetAddrForAttribute', 00H
	ORG $+3
$SG14905 DB	'(260)SetAttributeFromString', 00H
$SG14906 DB	'(261)SetAttributeFromInteger', 00H
	ORG $+3
$SG14907 DB	'(262)SetAttributeFromDecimal', 00H
	ORG $+3
$SG14908 DB	'(263)SetAttributeFromBlob', 00H
	ORG $+2
$SG14909 DB	'(264)SetAttributeFromAttribute', 00H
	ORG $+1
$SG14910 DB	'(265)SetAttributeFromCurrentDate', 00H
	ORG $+3
$SG14911 DB	'(266)AddToAttributeFromInteger', 00H
	ORG $+1
$SG14912 DB	'(267)AddToAttributeFromDecimal', 00H
	ORG $+1
$SG14913 DB	'(268)AddToAttributeFromAttribute', 00H
	ORG $+3
$SG14915 DB	'(270)CompareAttributeToString', 00H
	ORG $+2
$SG14916 DB	'(271)CompareAttributeToInteger', 00H
	ORG $+1
$SG14917 DB	'(272)CompareAttributeToDecimal', 00H
	ORG $+1
$SG14918 DB	'(273)CompareAttributeToAttribute', 00H
	ORG $+3
$SG14919 DB	'(274)GetAttributeLength', 00H
$SG14920 DB	'(275)SetMatchingAttributesByName', 00H
	ORG $+3
$SG14921 DB	'(276)SetBlobAttributeFromAttribute', 00H
	ORG $+1
$SG14922 DB	'(277)SetAttributeFromVariable', 00H
	ORG $+2
$SG14923 DB	'(278)CompareAttributeToVariable', 00H
$SG14924 DB	'(279)GetVariableFromAttribute', 00H
	ORG $+2
$SG14925 DB	'(280)GetFirstTableEntryForAttribute', 00H
$SG14926 DB	'(281)GetNextTableEntryForAttribute', 00H
	ORG $+1
$SG14927 DB	'(282)SetAttributeValueNext', 00H
	ORG $+1
$SG14928 DB	'(283)SetAttributeValuePrev', 00H
	ORG $+1
$SG14929 DB	'(284)StoreValueInRecord', 00H
$SG14930 DB	'(285)AddToAttributeFromVariable', 00H
$SG14931 DB	'(286)GetValueFromRecord', 00H
$SG14932 DB	'(287)StoreStringInRecord', 00H
	ORG $+3
$SG14933 DB	'(288)GetStringFromRecord', 00H
	ORG $+3
$SG14934 DB	'(289)GetActualAttributeLength', 00H
	ORG $+2
$SG14935 DB	'(290)GetAddrFromRecord', 00H
	ORG $+1
$SG14936 DB	'(291)SetBlobFromEntityAttributes', 00H
	ORG $+3
$SG14937 DB	'(292)SetEntityAttributesFromBlob', 00H
	ORG $+3
$SG14938 DB	'(293)GetAttributeDisplayLength', 00H
	ORG $+1
$SG14939 DB	'(294)SetBlobFromOI', 00H
	ORG $+1
$SG14940 DB	'(295)SetOI_FromBlob', 00H
$SG14941 DB	'(296)SetBlobFromFile', 00H
	ORG $+3
$SG14942 DB	'(297)WriteBlobToFile', 00H
	ORG $+3
$SG14943 DB	'(298)StoreValueInDerivedAttribute', 00H
	ORG $+2
$SG14944 DB	'(299)StoreStringInDerivedAttribute', 00H
	ORG $+1
$SG14995 DB	'(350)TableEntryExtToInt', 00H
$SG14996 DB	'(351)TableEntryIntToExt', 00H
$SG14997 DB	'(352)TableEntryForInternalValue', 00H
$SG15005 DB	'(360)MessageSend', 00H
	ORG $+3
$SG15006 DB	'(361)MessagePrompt', 00H
	ORG $+1
$SG15007 DB	'(362)MessagePromptForInput', 00H
	ORG $+1
$SG15008 DB	'(363)MessagePresent', 00H
$SG15015 DB	'(370)UfAddToDateTime', 00H
	ORG $+3
$SG15045 DB	'(400)DisplayEntityInstance', 00H
	ORG $+1
$SG15046 DB	'(401)DisplayObjectInstance', 00H
	ORG $+1
$SG15047 DB	'(402)DisplayCursorInfo', 00H
	ORG $+1
$SG15048 DB	'(403)GetTaskDBHandlerTraceLevel', 00H
$SG15049 DB	'(404)SetTaskDBHandlerTraceLevel', 00H
$SG15050 DB	'(405)DisplayEntityInstancePath', 00H
	ORG $+1
$SG15051 DB	'(406)CompareEntityToEntity', 00H
	ORG $+1
$SG15052 DB	'(407)CompareOI_ToOI', 00H
$SG15095 DB	'(450)MiGetParentEntityNameForView', 00H
	ORG $+2
$SG15096 DB	'(451)MiGetInstanceID_ForView', 00H
	ORG $+3
$SG15097 DB	'(452)MiGetUpdateForView', 00H
$SG15098 DB	'(453)MiGetUpdateForViewEntityAttr', 00H
	ORG $+2
$SG15099 DB	'(454)MiGetTemporalStateOfEntity', 00H
$SG15100 DB	'(455)MiGetDateTimeForOI', 00H
$SG15101 DB	'(456)MiGetERTokenForEntity', 00H
	ORG $+1
$SG15102 DB	'(457)MiGetKeyFromInstance', 00H
	ORG $+2
$SG15103 DB	'(458)MiGetViewEntityForView', 00H
$SG15104 DB	'(459)MiGetCardinalityForEntity', 00H
	ORG $+1
$SG15105 DB	'(460)MiGetObjectNameForView', 00H
$SG15106 DB	'(461)MiGetOI_ReleaseForView', 00H
$SG15107 DB	'(462)MiSetOI_ReleaseForView', 00H
$SG15108 DB	'(463)MiCompareOI_ReleaseToRelease', 00H
	ORG $+2
$SG15109 DB	'(464)MiGetActivateFlags', 00H
$SG15110 DB	'(465)MiHasPersistentChanges', 00H
$SG15111 DB	'(466)MiSetInstanceUpdateFlag', 00H
	ORG $+3
$SG15145 DB	'(500)NetActivateOI', 00H
	ORG $+1
$SG15146 DB	'(501)NetCommitOI', 00H
	ORG $+3
$SG15147 DB	'(502)NetClose', 00H
	ORG $+2
$SG15148 DB	'(503)NetGetTraceLevel', 00H
	ORG $+2
$SG15149 DB	'(504)NetListen', 00H
	ORG $+1
$SG15150 DB	'(505)NetProcessMessage', 00H
	ORG $+1
$SG15151 DB	'(506)NetSetTraceLevel', 00H
	ORG $+2
$SG15152 DB	'(507)NetStartup', 00H
$SG15153 DB	'(508)NetStatus', 00H
	ORG $+1
$SG15154 DB	'(509)NetStopListen', 00H
	ORG $+1
$SG15155 DB	'(510)NetCommitOI_ToFile', 00H
$SG15156 DB	'(511)NetActivateOI_FromFile', 00H
$SG15157 DB	'(512)NetSendBootstrapFile', 00H
	ORG $+2
$SG15158 DB	'(513)NetCallOperation', 00H
	ORG $+2
$SG15159 DB	'(514)NetGetLocalHostAddress', 00H
$SG15160 DB	'(515)NetSendFile', 00H
	ORG $+3
$SG15195 DB	'(550)WriteOI_ToXML', 00H
	ORG $+1
$SG15196 DB	'(551)ActivateOI_FromXML_File', 00H
	ORG $+3
$SG15197 DB	'(552)CommitOI_ToXML_File', 00H
	ORG $+3
$SG15198 DB	'(553)WriteSubobjectToXML', 00H
	ORG $+3
$SG15199 DB	'(554)CommitSubobjectToXML_File', 00H
	ORG $+1
$SG15221 DB	'KZOEE101 - Invalid view 0x%08x for Task: 0x%08x', 00H
$SG15222 DB	'BombZDr', 00H
$SG15223 DB	'[Debug]', 00H
$SG15237 DB	'Auditing error', 00H
	ORG $+1
$SG15238 DB	'KZOEE013 - Internal operation call error: ', 00H
	ORG $+1
$SG15243 DB	'Too many nested Core calls', 00H
	ORG $+1
$SG15244 DB	'Zeidon Core Internal Error: ', 00H
	ORG $+3
$SG15247 DB	'Too many nested Core calls', 00H
	ORG $+1
$SG15248 DB	'fnOperationCall: ', 00H
	ORG $+2
$SG15249 DB	' Too many nested Core calls. (This is the last message. '
	DB	' Subsequent errors will be traced only)', 00H
$SG15250 DB	'Zeidon Core Internal Error', 00H
	ORG $+1
$SG15251 DB	'Too many nested Core calls2', 00H
$SG15252 DB	'fnOperationCall: ', 00H
	ORG $+2
$SG15253 DB	' Too many nested Core calls', 00H
$SG15254 DB	'Zeidon Core Internal Error', 00H
	ORG $+1
$SG15274 DB	'KZOEE013 - Internal operation call error.', 00H
	ORG $+2
$SG15273 DB	'KZOEE013 - Internal operation (%d) %s call error: Recove'
	DB	'ring lost index: %d for Task: 0x%08x', 00H
	ORG $+3
$SG15275 DB	'Zeidon Core Error', 00H
	ORG $+2
$SG15295 DB	'CheckValidView found Invalid view: 0x%08x', 00H
	ORG $+2
$SG15296 DB	'BombZDr', 00H
$SG15297 DB	'[Debug]', 00H
_DATA	ENDS
PUBLIC	_TrueName@8
PUBLIC	_NameForZKey@8
PUBLIC	_SfCheckOI_Integrity@8
PUBLIC	_fnOperationCall
PUBLIC	_fnOperationReturn
PUBLIC	_fnValidView
PUBLIC	_fnValidViewObject
PUBLIC	_fnValidViewCsr
PUBLIC	_fnValidSubtaskView
PUBLIC	_fnValidViewEntity@16
PUBLIC	_fnValidViewAttrib
PUBLIC	_fnValidNumericString
PUBLIC	_fnValidDecimalString
PUBLIC	_fnCompareDebugChange@8
PUBLIC	_fnAddEntityToDebugChange@4
PUBLIC	_fnRemoveEntityFromDebugChange@4
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnPrintDebugFromSameInstance@4
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_TraceBuffer@12:PROC
EXTRN	_SysConvertStringToDecimal@8:PROC
EXTRN	_fnSysMessageBox@16:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysValidAddress@12:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnRecordForEntityAttr:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnStoreStringInDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	__imp__isalnum:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_g_vRealTaskView:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
?szWorkString@?1??TrueName@@9@9 DB 032H DUP (?)		; `TrueName'::`2'::szWorkString
_BSS	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_pchLastValue$1 = -244					; size = 4
_lpViewOD$ = -240					; size = 4
_lpViewEntity$ = -236					; size = 4
_lpViewOI$ = -232					; size = 4
_hEntityInstance$ = -228				; size = 4
tv147 = -224						; size = 4
_lpViewAttrib$ = -220					; size = 4
_lpEntityInstance$ = -216				; size = 4
_pchCurrent$2 = -212					; size = 4
_lpTemp$ = -208						; size = 4
_szMsg$3 = -204						; size = 200
__$ArrayPad$ = -4					; size = 4
_lpDbgChg$ = 8						; size = 4
_fnPrintDebugFromSameInstance@4 PROC

; 188  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 189  :    LPVIEWENTITY     lpViewEntity;
; 190  :    LPVIEWATTRIB     lpViewAttrib;
; 191  :    LPVIEWOD         lpViewOD;
; 192  :    LPVIEWOI         lpViewOI;
; 193  :    LPENTITYINSTANCE hEntityInstance = lpDbgChg->hEntityInstance;

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hEntityInstance$[ebp], ecx

; 194  :    LPENTITYINSTANCE lpEntityInstance = zGETPTR( lpDbgChg->hEntityInstance );

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 195  :    LPDEBUGCHANGE    lpTemp;
; 196  : 
; 197  :    zLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysLockCoreMutex@4

; 198  : 
; 199  :    for ( lpTemp = zGETPTR( AnchorBlock->hFirstDebugChange );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+2523]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTemp$[ebp], eax
	jmp	SHORT $LN4@fnPrintDeb
$LN2@fnPrintDeb:

; 201  :          lpTemp = zGETPTR( lpTemp->hNextDebugChange ) )

	mov	eax, DWORD PTR _lpTemp$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTemp$[ebp], eax
$LN4@fnPrintDeb:

; 200  :          lpTemp;

	cmp	DWORD PTR _lpTemp$[ebp], 0
	je	$LN3@fnPrintDeb

; 202  :    {
; 203  :       zPCHAR pchCurrent;
; 204  :       zCHAR  szMsg[ 200 ];
; 205  : 
; 206  :       if ( lpTemp->bInProgress )

	mov	edx, DWORD PTR _lpTemp$[ebp]
	mov	eax, DWORD PTR [edx+26]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN7@fnPrintDeb

; 207  :          continue;

	jmp	SHORT $LN2@fnPrintDeb
$LN7@fnPrintDeb:

; 208  : 
; 209  :       // bCompare will be FALSE if we don't want to compare this attribute.
; 210  :       // bCompare is FALSE when we initialize the attribute.
; 211  :       if ( lpTemp->bCompare == FALSE )

	mov	ecx, DWORD PTR _lpTemp$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, 1
	jne	SHORT $LN8@fnPrintDeb

; 212  :          continue;

	jmp	SHORT $LN2@fnPrintDeb
$LN8@fnPrintDeb:

; 213  : 
; 214  :       if ( lpTemp == lpDbgChg )

	mov	eax, DWORD PTR _lpTemp$[ebp]
	cmp	eax, DWORD PTR _lpDbgChg$[ebp]
	jne	SHORT $LN9@fnPrintDeb

; 215  :          continue;

	jmp	SHORT $LN2@fnPrintDeb
$LN9@fnPrintDeb:

; 216  : 
; 217  :       if ( lpTemp->hEntityInstance != hEntityInstance )

	mov	ecx, DWORD PTR _lpTemp$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	cmp	edx, DWORD PTR _hEntityInstance$[ebp]
	je	SHORT $LN10@fnPrintDeb

; 218  :          continue;

	jmp	SHORT $LN2@fnPrintDeb
$LN10@fnPrintDeb:

; 219  : 
; 220  :       lpViewAttrib = zGETPTR( lpTemp->hViewAttrib );

	mov	eax, DWORD PTR _lpTemp$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 221  :       pchCurrent = fnRecordForEntityAttr( lpEntityInstance, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchCurrent$2[ebp], eax

; 222  : 
; 223  :       TraceLineS( "------- Attribute from same EI ----------", "" );

	push	OFFSET $SG14508
	push	OFFSET $SG14509
	call	_TraceLineS@8

; 224  :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 225  :       lpViewOI     = zGETPTR( lpEntityInstance->hViewOI );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 226  :       lpViewOD     = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 227  :       zsprintf( szMsg, "%s.%s.%s", lpViewOD->szName,

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG14510
	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 228  :                 lpViewEntity->szName, lpViewAttrib->szName );
; 229  :       TraceLineS( "Attribute = ", szMsg );

	lea	edx, DWORD PTR _szMsg$3[ebp]
	push	edx
	push	OFFSET $SG14511
	call	_TraceLineS@8

; 230  : 
; 231  :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv147[ebp], cl
	cmp	BYTE PTR tv147[ebp], 76			; 0000004cH
	je	SHORT $LN11@fnPrintDeb
	cmp	BYTE PTR tv147[ebp], 83			; 00000053H
	je	SHORT $LN13@fnPrintDeb
	jmp	$LN5@fnPrintDeb
$LN11@fnPrintDeb:

; 232  :       {
; 233  :          case zTYPE_INTEGER:
; 234  :             TraceLineI( "Old value = ", lpTemp->lLastValue );

	mov	edx, DWORD PTR _lpTemp$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	push	OFFSET $SG14513
	call	_TraceLineI@8

; 235  :             TraceLineI( "New Value = ", *((zPLONG) pchCurrent) );

	mov	ecx, DWORD PTR _pchCurrent$2[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET $SG14514
	call	_TraceLineI@8

; 236  :             break;

	jmp	SHORT $LN5@fnPrintDeb

; 237  : 
; 238  :          case zTYPE_DECIMAL:
; 239  :             break;

	jmp	SHORT $LN5@fnPrintDeb
$LN13@fnPrintDeb:

; 240  : 
; 241  :          case zTYPE_STRING:
; 242  :          {
; 243  :             zPCHAR pchLastValue = (zPCHAR) zGETPTR( lpTemp->lLastValue );

	mov	eax, DWORD PTR _lpTemp$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchLastValue$1[ebp], eax

; 244  : 
; 245  :             if ( *pchCurrent == '\xff' )

	mov	edx, DWORD PTR _pchCurrent$2[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, -1
	jne	SHORT $LN14@fnPrintDeb

; 246  :             {
; 247  :                pchCurrent++;

	mov	ecx, DWORD PTR _pchCurrent$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchCurrent$2[ebp], ecx

; 248  :                pchCurrent = (zPCHAR) zGETPTR( *((zPPVOID) pchCurrent) );

	mov	edx, DWORD PTR _pchCurrent$2[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchCurrent$2[ebp], eax
$LN14@fnPrintDeb:

; 249  :             }
; 250  : 
; 251  :             TraceLineS( "Old value = ", pchLastValue );

	mov	ecx, DWORD PTR _pchLastValue$1[ebp]
	push	ecx
	push	OFFSET $SG14518
	call	_TraceLineS@8

; 252  :             TraceLineS( "New Value = ", pchCurrent );

	mov	edx, DWORD PTR _pchCurrent$2[ebp]
	push	edx
	push	OFFSET $SG14519
	call	_TraceLineS@8
$LN5@fnPrintDeb:

; 253  : 
; 254  :             break;
; 255  :          }
; 256  : 
; 257  :          case zTYPE_BLOB:
; 258  :             break;
; 259  : 
; 260  :          case zTYPE_DATETIME:
; 261  :             break;
; 262  :       }
; 263  : 
; 264  :       TraceLineS( "", "" );

	push	OFFSET $SG14522
	push	OFFSET $SG14523
	call	_TraceLineS@8

; 265  :    }

	jmp	$LN2@fnPrintDeb
$LN3@fnPrintDeb:

; 266  : 
; 267  :    zUNLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysUnlockCoreMutex@4

; 268  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnPrintDebugFromSameInstance@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_hEntityInstance$ = -20					; size = 4
_lpViewAttrib$ = -16					; size = 4
_lpPrevDbgChg$ = -12					; size = 4
_lpTemp$1 = -8						; size = 4
_lpDbgChg$ = -4						; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnRemoveEntityFromDebugChange@4 PROC

; 123  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 124  :    LPVIEWATTRIB     lpViewAttrib;
; 125  :    LPDEBUGCHANGE    lpDbgChg;
; 126  :    LPDEBUGCHANGE    lpPrevDbgChg;
; 127  :    LPENTITYINSTANCE hEntityInstance;
; 128  : 
; 129  :    if ( AnchorBlock->hFirstDebugChange == 0 )

	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+2523], 0
	jne	SHORT $LN4@fnRemoveEn

; 130  :       return;

	jmp	$LN1@fnRemoveEn
$LN4@fnRemoveEn:

; 131  : 
; 132  :    hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 133  : 
; 134  :    zLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysLockCoreMutex@4

; 135  : 
; 136  :    // Find the DebugChange entries that match hRecord and delete them.
; 137  :    // We'll skip the first DebugChange (for now) because it makes the
; 138  :    // logic easier.
; 139  :    lpPrevDbgChg = zGETPTR( AnchorBlock->hFirstDebugChange );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+2523]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevDbgChg$[ebp], eax

; 140  :    lpDbgChg     = zGETPTR( lpPrevDbgChg->hNextDebugChange );

	mov	ecx, DWORD PTR _lpPrevDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDbgChg$[ebp], eax
$LN2@fnRemoveEn:

; 141  :    while ( lpDbgChg )

	cmp	DWORD PTR _lpDbgChg$[ebp], 0
	je	$LN3@fnRemoveEn

; 142  :    {
; 143  :       LPDEBUGCHANGE lpTemp;
; 144  : 
; 145  :       lpTemp   = lpDbgChg;

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR _lpTemp$1[ebp], eax

; 146  :       lpDbgChg = zGETPTR( lpDbgChg->hNextDebugChange );

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDbgChg$[ebp], eax

; 147  : 
; 148  :       if ( lpTemp->hEntityInstance == hEntityInstance )

	mov	eax, DWORD PTR _lpTemp$1[ebp]
	mov	ecx, DWORD PTR [eax+14]
	cmp	ecx, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $LN5@fnRemoveEn

; 149  :       {
; 150  :          // We got a match.  Remove it.
; 151  :          lpPrevDbgChg->hNextDebugChange = lpTemp->hNextDebugChange;

	mov	edx, DWORD PTR _lpPrevDbgChg$[ebp]
	mov	eax, DWORD PTR _lpTemp$1[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx

; 152  : 
; 153  :          lpViewAttrib = zGETPTR( lpTemp->hViewAttrib );

	mov	edx, DWORD PTR _lpTemp$1[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 154  :          if ( lpViewAttrib->cType == zTYPE_STRING &&

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 83					; 00000053H
	jne	SHORT $LN6@fnRemoveEn
	mov	eax, DWORD PTR _lpTemp$1[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN6@fnRemoveEn

; 155  :               lpTemp->lLastValue != 0 )
; 156  :          {
; 157  :             fnFreeDataspace( zGETPTR( (zPVOID) lpTemp->lLastValue ) );

	mov	ecx, DWORD PTR _lpTemp$1[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN6@fnRemoveEn:

; 158  :          }
; 159  : 
; 160  :          fnFreeDataspace( lpTemp );

	mov	eax, DWORD PTR _lpTemp$1[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN5@fnRemoveEn:

; 161  :       }
; 162  : 
; 163  :       lpPrevDbgChg = zGETPTR( lpPrevDbgChg->hNextDebugChange );

	mov	ecx, DWORD PTR _lpPrevDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevDbgChg$[ebp], eax

; 164  :    }

	jmp	$LN2@fnRemoveEn
$LN3@fnRemoveEn:

; 165  : 
; 166  :    // Now check the first one.
; 167  :    lpDbgChg = zGETPTR( AnchorBlock->hFirstDebugChange );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2523]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDbgChg$[ebp], eax

; 168  :    if ( lpDbgChg->hEntityInstance == hEntityInstance )

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+14]
	cmp	eax, DWORD PTR _hEntityInstance$[ebp]
	jne	SHORT $LN7@fnRemoveEn

; 169  :    {
; 170  :       // We got a match.  Remove it.
; 171  :       AnchorBlock->hFirstDebugChange = lpDbgChg->hNextDebugChange;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2523], eax

; 172  : 
; 173  :       lpViewAttrib = zGETPTR( lpDbgChg->hViewAttrib );

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 174  :       if ( lpViewAttrib->cType == zTYPE_STRING &&

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 83					; 00000053H
	jne	SHORT $LN8@fnRemoveEn
	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN8@fnRemoveEn

; 175  :            lpDbgChg->lLastValue != 0 )
; 176  :       {
; 177  :          fnFreeDataspace( zGETPTR( (zPVOID) lpDbgChg->lLastValue ) );

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnFreeDataspace
	add	esp, 4
$LN8@fnRemoveEn:

; 178  :       }
; 179  : 
; 180  :       fnFreeDataspace( lpDbgChg );

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4
$LN7@fnRemoveEn:

; 181  :    }
; 182  : 
; 183  :    zUNLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysUnlockCoreMutex@4
$LN1@fnRemoveEn:

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_fnRemoveEntityFromDebugChange@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpTask$ = -136						; size = 4
_lpViewOD$1 = -132					; size = 4
_lpViewEntity$2 = -128					; size = 4
_lpViewOI$ = -124					; size = 4
_lpViewEntity$ = -120					; size = 4
_hDbgChg$ = -116					; size = 4
_lpViewAttrib$ = -112					; size = 4
_lpDbgChg$ = -108					; size = 4
_szMsg$3 = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_lpEntityInstance$ = 8					; size = 4
_fnAddEntityToDebugChange@4 PROC

; 51   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 52   :    LPVIEWENTITY  lpViewEntity;
; 53   :    LPVIEWATTRIB  lpViewAttrib;
; 54   :    LPDEBUGCHANGE lpDbgChg;
; 55   :    zPVOID        hDbgChg;
; 56   :    LPVIEWOI      lpViewOI;
; 57   :    LPTASK        lpTask;
; 58   : 
; 59   :    if ( lpEntityInstance == 0 )

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	jne	SHORT $LN5@fnAddEntit

; 60   :       return;

	jmp	$LN1@fnAddEntit
$LN5@fnAddEntit:

; 61   : 
; 62   :    // If the entity contains a DebugChange attribute we need to add it to
; 63   :    // the list.  This will cause fnOperationCall and fnOperationReturn to
; 64   :    // check to see if the attribute has been changed.
; 65   :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 66   :    if ( lpViewEntity->bDebugChange == FALSE )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	jne	SHORT $LN6@fnAddEntit

; 67   :       return;  // No DebugChange so skip it.

	jmp	$LN1@fnAddEntit
$LN6@fnAddEntit:

; 68   : 
; 69   :    lpViewOI = zGETPTR( lpEntityInstance->hViewOI );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 70   :    lpTask   = zGETPTR( lpViewOI->hTask );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 71   : 
; 72   :    // Lock the DEBUGCHANGE mutex so that no other task will do a
; 73   :    // compare while we're adding stuff.
; 74   :    zLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysLockCoreMutex@4

; 75   : 
; 76   :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnAddEntit
$LN2@fnAddEntit:

; 78   :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnAddEntit:

; 77   :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnAddEntit

; 79   :    {
; 80   :       LPVIEWENTITY lpViewEntity;
; 81   :       LPVIEWOD     lpViewOD;
; 82   :       zCHAR        szMsg[ 100 ];
; 83   : 
; 84   :       if ( lpViewAttrib->bDebugChange == FALSE )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 14					; 0000000eH
	and	ecx, 1
	jne	SHORT $LN7@fnAddEntit

; 85   :          continue;

	jmp	SHORT $LN2@fnAddEntit
$LN7@fnAddEntit:

; 86   : 
; 87   :       hDbgChg = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10052					; 00002744H
	push	0
	push	1
	push	30					; 0000001eH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hDbgChg$[ebp], eax

; 88   :                                   sizeof( DebugChangeRecord ), 1, 0,
; 89   :                                   iDebugChange );
; 90   :       if ( hDbgChg == 0 )

	cmp	DWORD PTR _hDbgChg$[ebp], 0
	jne	SHORT $LN8@fnAddEntit

; 91   :          return;

	jmp	$LN1@fnAddEntit
$LN8@fnAddEntit:

; 92   : 
; 93   :       lpDbgChg = zGETPTR( hDbgChg );

	mov	ecx, DWORD PTR _hDbgChg$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDbgChg$[ebp], eax

; 94   :       lpDbgChg->hNextDebugChange = AnchorBlock->hFirstDebugChange;

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2523]
	mov	DWORD PTR [edx+2], ecx

; 95   :       AnchorBlock->hFirstDebugChange = hDbgChg;

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _hDbgChg$[ebp]
	mov	DWORD PTR [edx+2523], eax

; 96   : 
; 97   :       // Copy the pertinent data to the structure.  Note that we don't copy
; 98   :       // the current value here.  It is done in fnOperationReturn( ).
; 99   :       lpDbgChg->hViewAttrib     = zGETHNDL( lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [edx+6], eax

; 100  :       lpDbgChg->hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [ecx+14], eax

; 101  :    // if ( lpDbgChg->hEntityInstance == UNSET_CSR )
; 102  :    //    SysMessageBox( 0, "fnAddEntityToDebugChange", "UNSET_CSR", -1 );
; 103  : 
; 104  :       lpDbgChg->hViewOD         = lpViewOI->hViewOD;

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+10], ecx

; 105  : 
; 106  :       // Set compare flag to FALSE.  This will keep a comparison from
; 107  :       // happening until the current Core operation is finished.  This
; 108  :       // allows the attribute to be initialized.
; 109  :       lpDbgChg->bCompare    = FALSE;

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+26]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 110  : 
; 111  :       lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 112  :       lpViewOD     = zGETPTR( lpDbgChg->hViewOD );

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 113  :       zsprintf( szMsg, "%s.%s.%s", lpViewOD->szName,

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$1[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14443
	lea	eax, DWORD PTR _szMsg$3[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 114  :                 lpViewEntity->szName, lpViewAttrib->szName );
; 115  :       TraceLineS( "Created DebugChange element for ", szMsg );

	lea	ecx, DWORD PTR _szMsg$3[ebp]
	push	ecx
	push	OFFSET $SG14444
	call	_TraceLineS@8

; 116  :    }

	jmp	$LN2@fnAddEntit
$LN3@fnAddEntit:

; 117  : 
; 118  :    zUNLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysUnlockCoreMutex@4
$LN1@fnAddEntit:

; 119  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnAddEntityToDebugChange@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpViewOD$1 = -288					; size = 4
_lpViewEntity$2 = -284					; size = 4
_lpBlob$3 = -280					; size = 4
_lp$4 = -276						; size = 4
_lpMainTask$5 = -272					; size = 4
_lpMainTask$6 = -268					; size = 4
tv300 = -264						; size = 4
_lpBlob$7 = -260					; size = 4
tv225 = -256						; size = 4
tv224 = -252						; size = 4
_hndl$8 = -248						; size = 4
_lpLastValue$9 = -244					; size = 4
tv192 = -240						; size = 4
_ulLth$10 = -236					; size = 4
tv94 = -232						; size = 4
_lpViewAttrib$ = -228					; size = 4
_ulLth$11 = -224					; size = 4
_pchLastValue$12 = -220					; size = 4
_bDifference$13 = -213					; size = 1
_lpDbgChg$ = -212					; size = 4
_pchCurrent$14 = -208					; size = 4
_szMsg$15 = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
_bOperationCall$ = 8					; size = 1
_lpTask$ = 12						; size = 4
_fnCompareDebugChange@8 PROC

; 272  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 273  :    LPDEBUGCHANGE lpDbgChg;
; 274  :    LPVIEWATTRIB  lpViewAttrib;
; 275  : 
; 276  :    zLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysLockCoreMutex@4

; 277  : 
; 278  :    for ( lpDbgChg = zGETPTR( AnchorBlock->hFirstDebugChange );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2523]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDbgChg$[ebp], eax
	jmp	SHORT $LN4@fnCompareD
$LN2@fnCompareD:

; 280  :          lpDbgChg = zGETPTR( lpDbgChg->hNextDebugChange ) )

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpDbgChg$[ebp], eax
$LN4@fnCompareD:

; 279  :          lpDbgChg;

	cmp	DWORD PTR _lpDbgChg$[ebp], 0
	je	$LN3@fnCompareD

; 281  :    {
; 282  :       zPCHAR pchCurrent;
; 283  :       zBOOL  bDifference;
; 284  : 
; 285  :       lpViewAttrib = zGETPTR( lpDbgChg->hViewAttrib );

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 286  :       pchCurrent = fnRecordForEntityAttr( zGETPTR( lpDbgChg->hEntityInstance ),

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnRecordForEntityAttr
	add	esp, 8
	mov	DWORD PTR _pchCurrent$14[ebp], eax

; 287  :                                           lpViewAttrib );
; 288  : 
; 289  :       // If pchCurrent is NULL then we haven't created an attribute yet
; 290  :       // so just skip it.
; 291  :       if ( pchCurrent == 0 )

	cmp	DWORD PTR _pchCurrent$14[ebp], 0
	jne	SHORT $LN9@fnCompareD

; 292  :          continue;

	jmp	SHORT $LN2@fnCompareD
$LN9@fnCompareD:

; 293  : 
; 294  :       pchCurrent = pchCurrent + lpViewAttrib->ulRecordOffset;

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	add	ecx, DWORD PTR [eax+250]
	mov	DWORD PTR _pchCurrent$14[ebp], ecx

; 295  : 
; 296  :       if ( lpDbgChg->bCompare == FALSE )

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+26]
	and	eax, 1
	jne	$LN10@fnCompareD

; 297  :       {
; 298  :          // If the bCompare flag is FALSE then we haven't set up the attribute
; 299  :          // value yet.  We only do this in fnOperationExit so if we are in
; 300  :          // fnOperationCall just continue to the next DebugChange.
; 301  :          if ( bOperationCall )

	movzx	ecx, BYTE PTR _bOperationCall$[ebp]
	test	ecx, ecx
	je	SHORT $LN11@fnCompareD

; 302  :             continue;

	jmp	$LN2@fnCompareD
$LN11@fnCompareD:

; 303  : 
; 304  :          // We only set up the attribute value if we are exiting the last
; 305  :          // (or topmost) Zeidon operation.  This allows the attribute to
; 306  :          // be initialized.
; 307  :          if ( lpTask->nOperIdx > 0 )

	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, WORD PTR [edx+58]
	test	eax, eax
	jle	SHORT $LN12@fnCompareD

; 308  :             continue;

	jmp	$LN2@fnCompareD
$LN12@fnCompareD:

; 309  : 
; 310  :          // Copy the current value for later comparison.
; 311  :          switch ( lpViewAttrib->cType )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	dl, BYTE PTR [ecx+202]
	mov	BYTE PTR tv94[ebp], dl
	cmp	BYTE PTR tv94[ebp], 66			; 00000042H
	je	$LN20@fnCompareD
	cmp	BYTE PTR tv94[ebp], 76			; 0000004cH
	je	SHORT $LN13@fnCompareD
	cmp	BYTE PTR tv94[ebp], 83			; 00000053H
	je	SHORT $LN15@fnCompareD
	jmp	$LN5@fnCompareD
$LN13@fnCompareD:

; 312  :          {
; 313  :             case zTYPE_INTEGER:
; 314  :                lpDbgChg->lLastValue = *((zPLONG) pchCurrent);

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+18], edx

; 315  :                break;

	jmp	$LN5@fnCompareD

; 316  : 
; 317  :             case zTYPE_DECIMAL:
; 318  :                break;

	jmp	$LN5@fnCompareD
$LN15@fnCompareD:

; 319  : 
; 320  :             case zTYPE_STRING:
; 321  :                if ( *pchCurrent == '\xff' )

	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	jne	SHORT $LN16@fnCompareD

; 322  :                {
; 323  :                   pchCurrent++;

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	add	edx, 1
	mov	DWORD PTR _pchCurrent$14[ebp], edx

; 324  :                   pchCurrent = (zPCHAR) zGETPTR( *((zPPVOID) pchCurrent) );

	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchCurrent$14[ebp], eax
$LN16@fnCompareD:

; 325  :                }
; 326  : 
; 327  :                if ( *pchCurrent )

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN17@fnCompareD

; 328  :                {
; 329  :                   LPTASK  lpMainTask = zGETPTR( AnchorBlock->hMainTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$6[ebp], eax

; 330  : 
; 331  :                   lpDbgChg->lLastValue = (zLONG)

	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpMainTask$6[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnStoreStringInDataspace
	add	esp, 8
	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [ecx+18], eax

; 332  :                      fnStoreStringInDataspace( lpMainTask->hFirstDataHeader,
; 333  :                                                pchCurrent );
; 334  : 
; 335  :                   if ( !zisalnum( *pchCurrent ) )

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp__isalnum
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN19@fnCompareD

; 336  :                      TraceLineS( "(DbgChg) Storing ", pchCurrent );

	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	push	ecx
	push	OFFSET $SG14602
	call	_TraceLineS@8
$LN19@fnCompareD:

; 337  :                }

	jmp	SHORT $LN18@fnCompareD
$LN17@fnCompareD:

; 338  :                else
; 339  :                   lpDbgChg->lLastValue = 0;

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [edx+18], 0
$LN18@fnCompareD:

; 340  : 
; 341  :                break;

	jmp	$LN5@fnCompareD
$LN20@fnCompareD:

; 342  : 
; 343  :             case zTYPE_BLOB:
; 344  :             {
; 345  :                zULONG ulLth;
; 346  :                zPVOID hndl, lpBlob;
; 347  : 
; 348  :                if ( *pchCurrent == '\xff' )

	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	jne	$LN21@fnCompareD

; 349  :                {
; 350  :                   LPTASK  lpMainTask = zGETPTR( AnchorBlock->hMainTask );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$5[ebp], eax

; 351  :                   zPVOID  lp;
; 352  : 
; 353  :                   pchCurrent++;

	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchCurrent$14[ebp], ecx

; 354  :                   ulLth = *((zPULONG) ((zCOREMEM) pchCurrent + 1));

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ulLth$10[ebp], eax

; 355  : 
; 356  :                   hndl = fnAllocDataspace( lpMainTask->hFirstDataHeader,

	push	10101					; 00002775H
	push	0
	push	0
	mov	ecx, DWORD PTR _ulLth$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMainTask$5[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hndl$8[ebp], eax

; 357  :                                            ulLth, 0, 0, iBlob );
; 358  :                   lpBlob = zGETPTR( hndl );

	mov	ecx, DWORD PTR _hndl$8[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBlob$3[ebp], eax

; 359  :                   lp = zGETPTR( *((zCOREMEM) pchCurrent) );

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lp$4[ebp], eax

; 360  :                   zmemcpy( lpBlob, lp, ulLth );

	mov	ecx, DWORD PTR _ulLth$10[ebp]
	push	ecx
	mov	edx, DWORD PTR _lp$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpBlob$3[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 361  :                   lpDbgChg->lLastValue = (zLONG) hndl;

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR _hndl$8[ebp]
	mov	DWORD PTR [ecx+18], edx

; 362  :                   lpDbgChg->ulLth = ulLth;

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR _ulLth$10[ebp]
	mov	DWORD PTR [eax+22], ecx

; 363  :                }

	jmp	SHORT $LN5@fnCompareD
$LN21@fnCompareD:

; 364  :                else
; 365  :                {
; 366  :                   lpDbgChg->lLastValue = 0;

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [edx+18], 0

; 367  :                   lpDbgChg->ulLth = 0;

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [eax+22], 0
$LN5@fnCompareD:

; 368  :                }
; 369  : 
; 370  :                break;
; 371  :             }
; 372  : 
; 373  :             case zTYPE_DATETIME:
; 374  :                break;
; 375  :          }
; 376  : 
; 377  :          lpDbgChg->bCompare = TRUE;

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	or	edx, 1
	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [eax+26], edx

; 378  : 
; 379  :          // We're done with this lpDbgChg so go to the next one.
; 380  :          continue;

	jmp	$LN2@fnCompareD
$LN10@fnCompareD:

; 381  : 
; 382  :       } // if ( lpDbgChg->bCompare == FALSE )...
; 383  : 
; 384  :       if ( lpDbgChg->bInProgress )

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN24@fnCompareD

; 385  :          continue;

	jmp	$LN2@fnCompareD
$LN24@fnCompareD:

; 386  : 
; 387  :       lpDbgChg->bInProgress = TRUE;

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	or	ecx, 2
	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [edx+26], ecx

; 388  : 
; 389  :       // Compare the current value of the attribute with the one we saved.
; 390  :       bDifference  = FALSE;

	mov	BYTE PTR _bDifference$13[ebp], 0

; 391  : 
; 392  :       switch ( lpViewAttrib->cType )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	cl, BYTE PTR [eax+202]
	mov	BYTE PTR tv192[ebp], cl
	cmp	BYTE PTR tv192[ebp], 66			; 00000042H
	je	$LN35@fnCompareD
	cmp	BYTE PTR tv192[ebp], 76			; 0000004cH
	je	SHORT $LN25@fnCompareD
	cmp	BYTE PTR tv192[ebp], 83			; 00000053H
	je	SHORT $LN28@fnCompareD
	jmp	$LN7@fnCompareD
$LN25@fnCompareD:

; 393  :       {
; 394  :          case zTYPE_INTEGER:
; 395  :             if ( lpDbgChg->lLastValue != *((zPLONG) pchCurrent) )

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	mov	ecx, DWORD PTR [edx+18]
	cmp	ecx, DWORD PTR [eax]
	je	SHORT $LN26@fnCompareD

; 396  :             {
; 397  :                bDifference = TRUE;

	mov	BYTE PTR _bDifference$13[ebp], 1

; 398  :                TraceLineI( "Old value = ", lpDbgChg->lLastValue );

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	push	OFFSET $SG14610
	call	_TraceLineI@8

; 399  :                TraceLineI( "New Value = ", *((zPLONG) pchCurrent) );

	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET $SG14611
	call	_TraceLineI@8
$LN26@fnCompareD:

; 400  :             }
; 401  : 
; 402  :             break;

	jmp	$LN7@fnCompareD

; 403  : 
; 404  :          case zTYPE_DECIMAL:
; 405  :             break;

	jmp	$LN7@fnCompareD
$LN28@fnCompareD:

; 406  : 
; 407  :          case zTYPE_STRING:
; 408  :          {
; 409  :             zPCHAR pchLastValue = (zPCHAR) zGETPTR( lpDbgChg->lLastValue );

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchLastValue$12[ebp], eax

; 410  : 
; 411  :             if ( *pchCurrent == '\xff' )

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, -1
	jne	SHORT $LN29@fnCompareD

; 412  :             {
; 413  :                pchCurrent++;

	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchCurrent$14[ebp], ecx

; 414  :                pchCurrent = (zPCHAR) zGETPTR( *((zPPVOID) pchCurrent) );

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _pchCurrent$14[ebp], eax
$LN29@fnCompareD:

; 415  :             }
; 416  : 
; 417  :             if ( pchCurrent && *pchCurrent == 0 )

	cmp	DWORD PTR _pchCurrent$14[ebp], 0
	je	SHORT $LN30@fnCompareD
	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	jne	SHORT $LN30@fnCompareD

; 418  :                pchCurrent = 0;

	mov	DWORD PTR _pchCurrent$14[ebp], 0
$LN30@fnCompareD:

; 419  : 
; 420  :             // If both values are null then they are equal.  They can only
; 421  :             // be equal if they are both null.
; 422  :             if ( pchCurrent == pchLastValue )

	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	cmp	eax, DWORD PTR _pchLastValue$12[ebp]
	jne	SHORT $LN31@fnCompareD

; 423  :                break;

	jmp	$LN7@fnCompareD
$LN31@fnCompareD:

; 424  : 
; 425  :             if ( pchLastValue == 0 || pchCurrent == 0 ||

	cmp	DWORD PTR _pchLastValue$12[ebp], 0
	je	$LN33@fnCompareD
	cmp	DWORD PTR _pchCurrent$14[ebp], 0
	je	SHORT $LN33@fnCompareD
	mov	ecx, DWORD PTR _pchLastValue$12[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN50@fnCompareD
	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	push	edx
	mov	eax, DWORD PTR _pchLastValue$12[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv225[ebp], eax
	jmp	SHORT $LN51@fnCompareD
$LN50@fnCompareD:
	mov	ecx, DWORD PTR _pchLastValue$12[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN48@fnCompareD
	mov	DWORD PTR tv224[ebp], 1
	jmp	SHORT $LN49@fnCompareD
$LN48@fnCompareD:
	mov	DWORD PTR tv224[ebp], -1
$LN49@fnCompareD:
	mov	edx, DWORD PTR tv224[ebp]
	mov	DWORD PTR tv225[ebp], edx
$LN51@fnCompareD:
	cmp	DWORD PTR tv225[ebp], 0
	je	SHORT $LN32@fnCompareD
$LN33@fnCompareD:

; 426  :                  zstrcmp( pchLastValue, pchCurrent ) != 0 )
; 427  :             {
; 428  :                bDifference = TRUE;

	mov	BYTE PTR _bDifference$13[ebp], 1

; 429  :                TraceLineS( "Old value = ", pchLastValue );

	mov	eax, DWORD PTR _pchLastValue$12[ebp]
	push	eax
	push	OFFSET $SG14619
	call	_TraceLineS@8

; 430  :                TraceLineS( "New Value = ", pchCurrent );

	mov	ecx, DWORD PTR _pchCurrent$14[ebp]
	push	ecx
	push	OFFSET $SG14620
	call	_TraceLineS@8

; 431  : 
; 432  :                // Free the dataspace since we don't need it anymore.
; 433  :                if ( pchLastValue )

	cmp	DWORD PTR _pchLastValue$12[ebp], 0
	je	SHORT $LN32@fnCompareD

; 434  :                {
; 435  :                   fnFreeDataspace( pchLastValue );

	mov	edx, DWORD PTR _pchLastValue$12[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 436  :                   lpDbgChg->lLastValue = 0;

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [eax+18], 0
$LN32@fnCompareD:

; 437  :                }
; 438  :             }
; 439  : 
; 440  :             break;

	jmp	$LN7@fnCompareD
$LN35@fnCompareD:

; 441  :          }
; 442  : 
; 443  :          case zTYPE_BLOB:
; 444  :          {
; 445  :             zULONG ulLth;
; 446  :             zPVOID lpBlob;
; 447  :             zPVOID lpLastValue = (zPVOID) zGETPTR( lpDbgChg->lLastValue );

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastValue$9[ebp], eax

; 448  : 
; 449  :             if ( *pchCurrent == '\xff' )

	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	jne	SHORT $LN36@fnCompareD

; 450  :             {
; 451  :                pchCurrent++;

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	add	edx, 1
	mov	DWORD PTR _pchCurrent$14[ebp], edx

; 452  :                lpBlob = zGETPTR( *((zCOREMEM) pchCurrent) );

	mov	eax, DWORD PTR _pchCurrent$14[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpBlob$7[ebp], eax

; 453  :                ulLth = *((zPULONG) ((zCOREMEM) pchCurrent + 1));

	mov	edx, DWORD PTR _pchCurrent$14[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ulLth$11[ebp], eax

; 454  :             }

	jmp	SHORT $LN37@fnCompareD
$LN36@fnCompareD:

; 455  :             else
; 456  :                ulLth = 0;

	mov	DWORD PTR _ulLth$11[ebp], 0
$LN37@fnCompareD:

; 457  : 
; 458  :             // If both blobs have a zero length then they are equal.
; 459  :             if ( ulLth == 0 && lpDbgChg->ulLth == 0 )

	cmp	DWORD PTR _ulLth$11[ebp], 0
	jne	SHORT $LN38@fnCompareD
	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	jne	SHORT $LN38@fnCompareD

; 460  :                break;

	jmp	$LN7@fnCompareD
$LN38@fnCompareD:

; 461  : 
; 462  :             if ( ulLth != lpDbgChg->ulLth ||

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR _ulLth$11[ebp]
	cmp	eax, DWORD PTR [edx+22]
	jne	SHORT $LN40@fnCompareD
	mov	ecx, DWORD PTR _ulLth$11[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpBlob$7[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLastValue$9[ebp]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	$LN7@fnCompareD
$LN40@fnCompareD:

; 463  :                  zmemcmp( lpLastValue, lpBlob, ulLth ) != 0 )
; 464  :             {
; 465  :                bDifference = TRUE;

	mov	BYTE PTR _bDifference$13[ebp], 1

; 466  : 
; 467  :                if ( ulLth != lpDbgChg->ulLth )

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR _ulLth$11[ebp]
	cmp	edx, DWORD PTR [ecx+22]
	je	SHORT $LN41@fnCompareD

; 468  :                {
; 469  :                   TraceLineI( "Old lth = ", lpDbgChg->ulLth );

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	push	OFFSET $SG14630
	call	_TraceLineI@8

; 470  :                   TraceLineI( "New lth = ", ulLth );

	mov	edx, DWORD PTR _ulLth$11[ebp]
	push	edx
	push	OFFSET $SG14631
	call	_TraceLineI@8

; 471  :                }

	jmp	SHORT $LN42@fnCompareD
$LN41@fnCompareD:

; 472  :                else
; 473  :                   TraceLineS( "Same lth but different values", "" );

	push	OFFSET $SG14632
	push	OFFSET $SG14633
	call	_TraceLineS@8
$LN42@fnCompareD:

; 474  : 
; 475  :                TraceBuffer( "Old ==> ", lpLastValue, lpDbgChg->ulLth );

	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	mov	edx, DWORD PTR _lpLastValue$9[ebp]
	push	edx
	push	OFFSET $SG14634
	call	_TraceBuffer@12

; 476  :                TraceBuffer( "New ==> ", lpBlob, ulLth );

	mov	eax, DWORD PTR _ulLth$11[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpBlob$7[ebp]
	push	ecx
	push	OFFSET $SG14635
	call	_TraceBuffer@12

; 477  : 
; 478  :                // Free the dataspace since we don't need it anymore.
; 479  :                if ( lpDbgChg->ulLth )

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN7@fnCompareD

; 480  :                {
; 481  :                   fnFreeDataspace( lpLastValue );

	mov	eax, DWORD PTR _lpLastValue$9[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 482  :                   lpDbgChg->lLastValue = 0;

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [ecx+18], 0

; 483  :                   lpDbgChg->ulLth      = 0;

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [edx+22], 0
$LN7@fnCompareD:

; 484  :                }
; 485  :             }
; 486  : 
; 487  :             break;
; 488  :          }
; 489  : 
; 490  :          case zTYPE_DATETIME:
; 491  :             break;
; 492  :       }
; 493  : 
; 494  :       if ( bDifference )

	movzx	eax, BYTE PTR _bDifference$13[ebp]
	test	eax, eax
	je	$LN45@fnCompareD

; 495  :       {
; 496  :          zCHAR        szMsg[ 200 ];
; 497  :          LPVIEWOD     lpViewOD = zGETPTR( lpDbgChg->hViewOD );

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 498  :          LPVIEWENTITY lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 499  : 
; 500  :          // Change bCompare flag so we don't do any more compares.  This will
; 501  :          // also cause a new copy of the value to stored in lpDbgChg.
; 502  :          lpDbgChg->bCompare = FALSE;

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	mov	eax, DWORD PTR [edx+26]
	and	eax, -2					; fffffffeH
	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [ecx+26], eax

; 503  : 
; 504  :          fnPrintDebugFromSameInstance( lpDbgChg );

	mov	edx, DWORD PTR _lpDbgChg$[ebp]
	push	edx
	call	_fnPrintDebugFromSameInstance@4

; 505  : 
; 506  :          zsprintf( szMsg, "Operation%s: Core detected a change in the attribute "

	movzx	eax, BYTE PTR _bOperationCall$[ebp]
	test	eax, eax
	je	SHORT $LN52@fnCompareD
	mov	DWORD PTR tv300[ebp], OFFSET $SG14639
	jmp	SHORT $LN53@fnCompareD
$LN52@fnCompareD:
	mov	DWORD PTR tv300[ebp], OFFSET $SG14640
$LN53@fnCompareD:
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$2[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR tv300[ebp]
	push	ecx
	push	OFFSET $SG14641
	lea	edx, DWORD PTR _szMsg$15[ebp]
	push	edx
	call	_sprintf
	add	esp, 24					; 00000018H

; 507  :                    "%s.%s.%s.  See Trace for old and new values.",
; 508  :                    bOperationCall ? "Start" : "Exit", lpViewOD->szName,
; 509  :                    lpViewEntity->szName, lpViewAttrib->szName );
; 510  : 
; 511  :          zUNLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysUnlockCoreMutex@4

; 512  : 
; 513  :          fnSysMessageBox( lpTask, "Debug Change", szMsg, 1 );

	push	1
	lea	eax, DWORD PTR _szMsg$15[ebp]
	push	eax
	push	OFFSET $SG14642
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnSysMessageBox@16

; 514  : 
; 515  :          zLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysLockCoreMutex@4

; 516  : 
; 517  :          // If we are in fnOperationExit and if the task oper idx is 0 then
; 518  :          // we'll call ourselves recursively to set up the next compare.
; 519  :          //if ( bOperationCall == FALSE && lpTask->nOperIdx == 0 )
; 520  :          if ( bOperationCall == FALSE )

	movzx	edx, BYTE PTR _bOperationCall$[ebp]
	test	edx, edx
	jne	SHORT $LN45@fnCompareD

; 521  :             fnCompareDebugChange( FALSE, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	0
	call	_fnCompareDebugChange@8
$LN45@fnCompareD:

; 522  :       }
; 523  : 
; 524  :       lpDbgChg->bInProgress = FALSE;

	mov	ecx, DWORD PTR _lpDbgChg$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	and	edx, -3					; fffffffdH
	mov	eax, DWORD PTR _lpDbgChg$[ebp]
	mov	DWORD PTR [eax+26], edx

; 525  : 
; 526  :    } // for ( lpDbgChg )...

	jmp	$LN2@fnCompareD
$LN3@fnCompareD:

; 527  : 
; 528  :    zUNLOCK_MUTEX( zMUTEX_DEBUGCHANGE );

	push	8
	call	_fnSysUnlockCoreMutex@4

; 529  : 
; 530  : } // fnCompareDebugChange

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnCompareDebugChange@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpInternational$ = -16					; size = 4
tv73 = -12						; size = 4
_cptr$ = -8						; size = 4
_cDec$ = -4						; size = 1
_bDecimalEncountered$ = -3				; size = 1
_bSpaceEncountered$ = -2				; size = 1
_bFirstDigitEncountered$ = -1				; size = 1
_lpdReturnValue$ = 8					; size = 4
_cpcString$ = 12					; size = 4
_fnValidDecimalString PROC

; 1671 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1672 :    zPCHAR   cptr;
; 1673 :    zBOOL    bSpaceEncountered = 0;

	mov	BYTE PTR _bSpaceEncountered$[ebp], 0

; 1674 :    zBOOL    bFirstDigitEncountered = 0;

	mov	BYTE PTR _bFirstDigitEncountered$[ebp], 0

; 1675 :    zBOOL    bDecimalEncountered = 0;

	mov	BYTE PTR _bDecimalEncountered$[ebp], 0

; 1676 :    zCHAR    cDec; // the decimal point character, internationally speaking...
; 1677 :    LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+2515]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpInternational$[ebp], eax

; 1678 : 
; 1679 :    cDec = lpInternational->szDecimal[ 0 ];

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpInternational$[ebp]
	mov	dl, BYTE PTR [ecx+eax+131]
	mov	BYTE PTR _cDec$[ebp], dl

; 1680 :    cptr = (zPCHAR) cpcString;

	mov	eax, DWORD PTR _cpcString$[ebp]
	mov	DWORD PTR _cptr$[ebp], eax
$LN2@fnValidDec:

; 1681 : 
; 1682 :    while ( *cptr )

	mov	ecx, DWORD PTR _cptr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN3@fnValidDec

; 1683 :    {
; 1684 :       switch ( *cptr )

	mov	eax, DWORD PTR _cptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv73[ebp], ecx
	mov	edx, DWORD PTR tv73[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR tv73[ebp], edx
	cmp	DWORD PTR tv73[ebp], 25			; 00000019H
	ja	SHORT $LN13@fnValidDec
	mov	eax, DWORD PTR tv73[ebp]
	movzx	ecx, BYTE PTR $LN19@fnValidDec[eax]
	jmp	DWORD PTR $LN20@fnValidDec[ecx*4]
$LN6@fnValidDec:

; 1685 :       {
; 1686 :          case '0':
; 1687 :          case '1':
; 1688 :          case '2':
; 1689 :          case '3':
; 1690 :          case '4':
; 1691 :          case '5':
; 1692 :          case '6':
; 1693 :          case '7':
; 1694 :          case '8':
; 1695 :          case '9':
; 1696 :             if ( bSpaceEncountered )

	movzx	edx, BYTE PTR _bSpaceEncountered$[ebp]
	test	edx, edx
	je	SHORT $LN7@fnValidDec

; 1697 :                return( 0 );

	xor	eax, eax
	jmp	$LN1@fnValidDec
$LN7@fnValidDec:

; 1698 : 
; 1699 :             bFirstDigitEncountered = TRUE;

	mov	BYTE PTR _bFirstDigitEncountered$[ebp], 1

; 1700 :             break;

	jmp	SHORT $LN4@fnValidDec
$LN8@fnValidDec:

; 1701 : 
; 1702 :          case '-':
; 1703 :          case '+':
; 1704 :             if ( bFirstDigitEncountered )

	movzx	eax, BYTE PTR _bFirstDigitEncountered$[ebp]
	test	eax, eax
	je	SHORT $LN9@fnValidDec

; 1705 :                return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnValidDec
	jmp	SHORT $LN10@fnValidDec
$LN9@fnValidDec:

; 1706 :             else
; 1707 :                bFirstDigitEncountered = TRUE;

	mov	BYTE PTR _bFirstDigitEncountered$[ebp], 1
$LN10@fnValidDec:

; 1708 : 
; 1709 :             break;

	jmp	SHORT $LN4@fnValidDec
$LN11@fnValidDec:

; 1710 : 
; 1711 :          case ' ':
; 1712 :             if ( bFirstDigitEncountered )

	movzx	ecx, BYTE PTR _bFirstDigitEncountered$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@fnValidDec

; 1713 :                bSpaceEncountered = TRUE;

	mov	BYTE PTR _bSpaceEncountered$[ebp], 1
$LN12@fnValidDec:

; 1714 :             break;

	jmp	SHORT $LN4@fnValidDec
$LN13@fnValidDec:

; 1715 : 
; 1716 :          default:
; 1717 :             if ( *cptr == cDec )

	mov	edx, DWORD PTR _cptr$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR _cDec$[ebp]
	cmp	eax, ecx
	jne	SHORT $LN14@fnValidDec

; 1718 :             {
; 1719 :                if ( bSpaceEncountered )

	movzx	edx, BYTE PTR _bSpaceEncountered$[ebp]
	test	edx, edx
	je	SHORT $LN15@fnValidDec

; 1720 :                   return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnValidDec
$LN15@fnValidDec:

; 1721 : 
; 1722 :                if ( bDecimalEncountered )

	movzx	eax, BYTE PTR _bDecimalEncountered$[ebp]
	test	eax, eax
	je	SHORT $LN16@fnValidDec

; 1723 :                   return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnValidDec
$LN16@fnValidDec:

; 1724 : 
; 1725 :                bDecimalEncountered = TRUE;

	mov	BYTE PTR _bDecimalEncountered$[ebp], 1

; 1726 :                bFirstDigitEncountered = TRUE;

	mov	BYTE PTR _bFirstDigitEncountered$[ebp], 1

; 1727 :                break;

	jmp	SHORT $LN4@fnValidDec
$LN14@fnValidDec:

; 1728 :             }
; 1729 : 
; 1730 :             return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnValidDec
$LN4@fnValidDec:

; 1731 :       }
; 1732 : 
; 1733 :       cptr++;

	mov	ecx, DWORD PTR _cptr$[ebp]
	add	ecx, 1
	mov	DWORD PTR _cptr$[ebp], ecx

; 1734 :    }

	jmp	$LN2@fnValidDec
$LN3@fnValidDec:

; 1735 : 
; 1736 :    if ( lpdReturnValue )

	cmp	DWORD PTR _lpdReturnValue$[ebp], 0
	je	SHORT $LN17@fnValidDec

; 1737 :       SysConvertStringToDecimal( (zPCHAR) cpcString, lpdReturnValue );

	mov	edx, DWORD PTR _lpdReturnValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcString$[ebp]
	push	eax
	call	_SysConvertStringToDecimal@8
$LN17@fnValidDec:

; 1738 : 
; 1739 :    return( 1 );

	mov	eax, 1
$LN1@fnValidDec:

; 1740 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN20@fnValidDec:
	DD	$LN11@fnValidDec
	DD	$LN8@fnValidDec
	DD	$LN6@fnValidDec
	DD	$LN13@fnValidDec
$LN19@fnValidDec:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	1
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
_fnValidDecimalString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_cptr$ = -12						; size = 4
tv67 = -8						; size = 4
_bSpaceEncountered$ = -2				; size = 1
_bFirstDigitEncountered$ = -1				; size = 1
_lplReturnValue$ = 8					; size = 4
_cpcString$ = 12					; size = 4
_fnValidNumericString PROC

; 1598 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1599 :    zPCHAR   cptr;
; 1600 :    zBOOL    bSpaceEncountered = 0;

	mov	BYTE PTR _bSpaceEncountered$[ebp], 0

; 1601 :    zBOOL    bFirstDigitEncountered = 0;

	mov	BYTE PTR _bFirstDigitEncountered$[ebp], 0

; 1602 : 
; 1603 :    cptr = (zPCHAR) cpcString;

	mov	eax, DWORD PTR _cpcString$[ebp]
	mov	DWORD PTR _cptr$[ebp], eax
$LN2@fnValidNum:

; 1604 : 
; 1605 :    while ( *cptr )

	mov	ecx, DWORD PTR _cptr$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN3@fnValidNum

; 1606 :    {
; 1607 :       switch ( *cptr )

	mov	eax, DWORD PTR _cptr$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv67[ebp], ecx
	mov	edx, DWORD PTR tv67[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 25			; 00000019H
	ja	SHORT $LN13@fnValidNum
	mov	eax, DWORD PTR tv67[ebp]
	movzx	ecx, BYTE PTR $LN16@fnValidNum[eax]
	jmp	DWORD PTR $LN17@fnValidNum[ecx*4]
$LN6@fnValidNum:

; 1608 :       {
; 1609 :          case '0':
; 1610 :          case '1':
; 1611 :          case '2':
; 1612 :          case '3':
; 1613 :          case '4':
; 1614 :          case '5':
; 1615 :          case '6':
; 1616 :          case '7':
; 1617 :          case '8':
; 1618 :          case '9':
; 1619 :             if ( bSpaceEncountered )

	movzx	edx, BYTE PTR _bSpaceEncountered$[ebp]
	test	edx, edx
	je	SHORT $LN7@fnValidNum

; 1620 :                return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnValidNum
$LN7@fnValidNum:

; 1621 : 
; 1622 :             bFirstDigitEncountered = TRUE;

	mov	BYTE PTR _bFirstDigitEncountered$[ebp], 1

; 1623 :             break;

	jmp	SHORT $LN4@fnValidNum
$LN8@fnValidNum:

; 1624 : 
; 1625 :          case '-':
; 1626 :          case '+':
; 1627 :             if ( bFirstDigitEncountered )

	movzx	eax, BYTE PTR _bFirstDigitEncountered$[ebp]
	test	eax, eax
	je	SHORT $LN9@fnValidNum

; 1628 :                return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnValidNum
	jmp	SHORT $LN10@fnValidNum
$LN9@fnValidNum:

; 1629 :             else
; 1630 :                bFirstDigitEncountered = TRUE;

	mov	BYTE PTR _bFirstDigitEncountered$[ebp], 1
$LN10@fnValidNum:

; 1631 : 
; 1632 :             break;

	jmp	SHORT $LN4@fnValidNum
$LN11@fnValidNum:

; 1633 : 
; 1634 :          case ' ':
; 1635 :             if ( bFirstDigitEncountered )

	movzx	ecx, BYTE PTR _bFirstDigitEncountered$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@fnValidNum

; 1636 :                bSpaceEncountered = TRUE;

	mov	BYTE PTR _bSpaceEncountered$[ebp], 1
$LN12@fnValidNum:

; 1637 : 
; 1638 :             break;

	jmp	SHORT $LN4@fnValidNum
$LN13@fnValidNum:

; 1639 : 
; 1640 :          default:
; 1641 :             return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnValidNum
$LN4@fnValidNum:

; 1642 :       }
; 1643 : 
; 1644 :       cptr++;

	mov	edx, DWORD PTR _cptr$[ebp]
	add	edx, 1
	mov	DWORD PTR _cptr$[ebp], edx

; 1645 :    }

	jmp	SHORT $LN2@fnValidNum
$LN3@fnValidNum:

; 1646 : 
; 1647 :    if ( lplReturnValue )

	cmp	DWORD PTR _lplReturnValue$[ebp], 0
	je	SHORT $LN14@fnValidNum

; 1648 :       *lplReturnValue = zatol( cpcString );

	mov	eax, DWORD PTR _cpcString$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	ecx, DWORD PTR _lplReturnValue$[ebp]
	mov	DWORD PTR [ecx], eax
$LN14@fnValidNum:

; 1649 : 
; 1650 :    return( 1 );

	mov	eax, 1
$LN1@fnValidNum:

; 1651 : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN17@fnValidNum:
	DD	$LN11@fnValidNum
	DD	$LN8@fnValidNum
	DD	$LN6@fnValidNum
	DD	$LN13@fnValidNum
$LN16@fnValidNum:
	DB	0
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	1
	DB	3
	DB	1
	DB	3
	DB	3
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
_fnValidNumericString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpViewOD$1 = -280					; size = 4
_lInputTok$ = -276					; size = 4
tv95 = -272						; size = 4
tv94 = -268						; size = 4
_lpViewAttrib$ = -264					; size = 4
_szLOD_Entity_Attribute$2 = -260			; size = 256
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_cpcAttribName$ = 16					; size = 4
_lControl$ = 20						; size = 4
_fnValidViewAttrib PROC

; 1461 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 280				; 00000118H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1462 :    LPVIEWATTRIB lpViewAttrib;
; 1463 :    zLONG        lInputTok;
; 1464 : 
; 1465 :    // Get first attribute for entity.
; 1466 :    lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1467 :    if ( *cpcAttribName == '\xff' )

	mov	edx, DWORD PTR _cpcAttribName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, -1
	jne	SHORT $LN4@fnValidVie

; 1468 :    {
; 1469 :       lInputTok = *((zPLONG) (cpcAttribName + 1) );

	mov	ecx, DWORD PTR _cpcAttribName$[ebp]
	mov	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR _lInputTok$[ebp], edx
$LN2@fnValidVie:

; 1470 :       while ( lpViewAttrib && (lpViewAttrib->bHidden ||

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN3@fnValidVie
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN8@fnValidVie
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+177]
	cmp	eax, DWORD PTR _lInputTok$[ebp]
	je	SHORT $LN3@fnValidVie
$LN8@fnValidVie:

; 1471 :                                lpViewAttrib->lERAttTok != lInputTok) )
; 1472 :       {
; 1473 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1474 :       }

	jmp	SHORT $LN2@fnValidVie
$LN3@fnValidVie:

; 1475 :    }

	jmp	$LN7@fnValidVie
$LN4@fnValidVie:

; 1476 :    else
; 1477 :    {
; 1478 :       // Look for the attribute.
; 1479 :       while ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN7@fnValidVie

; 1480 :       {
; 1481 :          if ( zstrcmp( lpViewAttrib->szName, cpcAttribName ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcAttribName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN16@fnValidVie
	mov	ecx, DWORD PTR _cpcAttribName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv95[ebp], eax
	jmp	SHORT $LN17@fnValidVie
$LN16@fnValidVie:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcAttribName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN14@fnValidVie
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN15@fnValidVie
$LN14@fnValidVie:
	mov	DWORD PTR tv94[ebp], -1
$LN15@fnValidVie:
	mov	ecx, DWORD PTR tv94[ebp]
	mov	DWORD PTR tv95[ebp], ecx
$LN17@fnValidVie:
	cmp	DWORD PTR tv95[ebp], 0
	jne	SHORT $LN9@fnValidVie

; 1482 :          {
; 1483 :             // We found it.  If the attribute is hidden check to see if we
; 1484 :             // allow hidden attributes.
; 1485 :             if ( lpViewAttrib->bHidden && (lControl & zALLOW_HIDDEN) == 0 )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN10@fnValidVie
	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1
	jne	SHORT $LN10@fnValidVie

; 1486 :                lpViewAttrib = 0; // No hidden attributes so set to NULL.

	mov	DWORD PTR _lpViewAttrib$[ebp], 0
$LN10@fnValidVie:

; 1487 : 
; 1488 :             break;

	jmp	SHORT $LN7@fnValidVie
$LN9@fnValidVie:

; 1489 :          }
; 1490 : 
; 1491 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1492 :       }

	jmp	$LN4@fnValidVie
$LN7@fnValidVie:

; 1493 :    }
; 1494 : 
; 1495 :    // If attribute not found return error.
; 1496 :    if ( lpViewAttrib )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN11@fnValidVie

; 1497 :       return( lpViewAttrib );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	jmp	$LN1@fnValidVie
	jmp	$LN1@fnValidVie
$LN11@fnValidVie:

; 1498 :    else
; 1499 :    {
; 1500 :       zCHAR    szLOD_Entity_Attribute[ 256 ];
; 1501 :       LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 1502 : 
; 1503 :       //  "KZOEE104 - Invalid Attribute name for LOD Entity"
; 1504 :       zsprintf( szLOD_Entity_Attribute, "[View: 0x%08x] %s.%s.%s",

	push	1
	mov	eax, DWORD PTR _cpcAttribName$[ebp]
	push	eax
	call	_TrueName@8
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$1[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET $SG15409
	lea	ecx, DWORD PTR _szLOD_Entity_Attribute$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 24					; 00000018H

; 1505 :                 lpView, lpViewOD->szName, lpViewEntity->szName,
; 1506 :                 TrueName( cpcAttribName, zSHOW_ZKEY ) );
; 1507 :       TraceLineS( "fnValidViewAttrib error: ", szLOD_Entity_Attribute );

	lea	edx, DWORD PTR _szLOD_Entity_Attribute$2[ebp]
	push	edx
	push	OFFSET $SG15410
	call	_TraceLineS@8

; 1508 :       fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 104,

	push	0
	lea	eax, DWORD PTR _szLOD_Entity_Attribute$2[ebp]
	push	eax
	push	0
	push	104					; 00000068H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1509 :                         0, szLOD_Entity_Attribute, 0 );
; 1510 : 
; 1511 :    // fnOperationReturn( 0, 0, 0 );
; 1512 :       return( 0 );  // return error

	xor	eax, eax
$LN1@fnValidVie:

; 1513 :    }
; 1514 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidViewAttrib ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lInputTok$ = -32					; size = 4
tv151 = -28						; size = 4
tv150 = -24						; size = 4
_lpViewOD$ = -20					; size = 4
_lpSearchViewEntityCsr$1 = -16				; size = 4
_lpViewCsr$ = -12					; size = 4
_lpViewEntityCsr$ = -8					; size = 4
_lpViewEntity$ = -4					; size = 4
_pvReturnViewEntityCsr$ = 8				; size = 4
_lpView$ = 12						; size = 4
_cpcEntityName$ = 16					; size = 4
_lFlags$ = 20						; size = 4
_fnValidViewEntity@16 PROC

; 1364 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 1365 :    LPVIEWCSR         lpViewCsr;
; 1366 :    LPVIEWOD          lpViewOD;
; 1367 :    LPVIEWENTITY      lpViewEntity;
; 1368 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1369 :    zLONG             lInputTok;
; 1370 : 
; 1371 :    *pvReturnViewEntityCsr = 0;  // initialize

	mov	eax, DWORD PTR _pvReturnViewEntityCsr$[ebp]
	mov	DWORD PTR [eax], 0

; 1372 :    if ( lpView == 0 )

	cmp	DWORD PTR _lpView$[ebp], 0
	jne	SHORT $LN8@fnValidVie

; 1373 :    {
; 1374 :       TraceLine( "fnValidViewEntity - Invalid View (0x%08x) for Entity: %s",

	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	OFFSET $SG15366
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 1375 :                  lpView, cpcEntityName );
; 1376 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnValidVie
$LN8@fnValidVie:

; 1377 :    }
; 1378 : 
; 1379 :    // Get the view csr for the view.
; 1380 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1381 : 
; 1382 :    // Get the view object definition for the view.
; 1383 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1384 : 
; 1385 :    // Validate that the entity exists.
; 1386 :    lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1387 :    lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 1388 : 
; 1389 :    // If the root cursor is not the first cursor, skip ViewEntities
; 1390 :    // until we get to the entity matching the root cursor.
; 1391 :    if ( lpViewEntityCsr != zGETPTR( lpViewCsr->hFirstOD_EntityCsr ) )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntityCsr$[ebp], eax
	je	SHORT $LN9@fnValidVie

; 1392 :    {
; 1393 :       LPVIEWENTITYCSR lpSearchViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchViewEntityCsr$1[ebp], eax
$LN2@fnValidVie:

; 1394 :       while ( lpSearchViewEntityCsr != lpViewEntityCsr )

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$1[ebp]
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	je	SHORT $LN9@fnValidVie

; 1395 :       {
; 1396 :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1397 :          lpSearchViewEntityCsr++;

	mov	eax, DWORD PTR _lpSearchViewEntityCsr$1[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSearchViewEntityCsr$1[ebp], eax

; 1398 :       }

	jmp	SHORT $LN2@fnValidVie
$LN9@fnValidVie:

; 1399 :    }
; 1400 : 
; 1401 :    if ( *cpcEntityName == '\xff' )

	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, -1
	jne	SHORT $LN6@fnValidVie

; 1402 :    {
; 1403 :       lInputTok = *((zPLONG) (cpcEntityName + 1));

	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	mov	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _lInputTok$[ebp], ecx
$LN4@fnValidVie:

; 1404 :       while ( lpViewEntityCsr && lpViewEntity->lEREntTok != lInputTok )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN5@fnValidVie
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+195]
	cmp	eax, DWORD PTR _lInputTok$[ebp]
	je	SHORT $LN5@fnValidVie

; 1405 :       {
; 1406 :          lpViewEntity    = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1407 :          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 1408 :       }

	jmp	SHORT $LN4@fnValidVie
$LN5@fnValidVie:

; 1409 :    }

	jmp	$LN11@fnValidVie
$LN6@fnValidVie:

; 1410 :    else
; 1411 :    {
; 1412 :       while ( lpViewEntityCsr &&

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN11@fnValidVie
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN17@fnValidVie
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN18@fnValidVie
$LN17@fnValidVie:
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	mov	ecx, DWORD PTR _cpcEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN15@fnValidVie
	mov	DWORD PTR tv150[ebp], 1
	jmp	SHORT $LN16@fnValidVie
$LN15@fnValidVie:
	mov	DWORD PTR tv150[ebp], -1
$LN16@fnValidVie:
	mov	eax, DWORD PTR tv150[ebp]
	mov	DWORD PTR tv151[ebp], eax
$LN18@fnValidVie:
	cmp	DWORD PTR tv151[ebp], 0
	je	SHORT $LN11@fnValidVie

; 1413 :               zstrcmp( lpViewEntity->szName, cpcEntityName ) != 0 )
; 1414 :       {
; 1415 :          lpViewEntity    = zGETPTR( lpViewEntity->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1416 :          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 1417 :       }

	jmp	SHORT $LN6@fnValidVie
$LN11@fnValidVie:

; 1418 :    }
; 1419 : 
; 1420 :    // If entity found return pointer.
; 1421 :    if ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN12@fnValidVie

; 1422 :    {
; 1423 :       *pvReturnViewEntityCsr = lpViewEntityCsr;

	mov	edx, DWORD PTR _pvReturnViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx], eax

; 1424 :       return( lpViewEntity );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	jmp	SHORT $LN1@fnValidVie
$LN12@fnValidVie:

; 1425 :    }
; 1426 : 
; 1427 :    // Note, the name may not be invalid, it may simply be out of view because
; 1428 :    // of a call to SetViewToSubobject
; 1429 :    //  "KZOEE103 - Invalid Entity name for View"
; 1430 :    TraceLine( "fnValidViewEntity - Invalid Entity name: %s   for View (0x%08x)   OD: %s",

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcEntityName$[ebp]
	push	eax
	push	OFFSET $SG15371
	call	_TraceLine
	add	esp, 16					; 00000010H

; 1431 :               cpcEntityName, lpView, lpViewOD->szName );
; 1432 : // DisplayObjectInstance( lpView, 0, 0 );
; 1433 :    if ( (lFlags & 1) == 0 )

	mov	ecx, DWORD PTR _lFlags$[ebp]
	and	ecx, 1
	jne	SHORT $LN13@fnValidVie

; 1434 :    {
; 1435 :       fnIssueCoreError( zGETPTR( lpView->hTask ), lpView, 8, 103, 0,

	push	1
	mov	edx, DWORD PTR _cpcEntityName$[ebp]
	push	edx
	call	_TrueName@8
	push	eax
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	0
	push	103					; 00000067H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN13@fnValidVie:

; 1436 :                         lpViewOD->szName,
; 1437 :                         TrueName( cpcEntityName, zSHOW_ZKEY ) );
; 1438 :    }
; 1439 : 
; 1440 : // fnOperationReturn( 0, 0, 0 );
; 1441 :    return( 0 );  // return error

	xor	eax, eax
$LN1@fnValidVie:

; 1442 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnValidViewEntity@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_lpView$ = 12						; size = 4
_fnValidSubtaskView PROC

; 1263 : {

	push	ebp
	mov	ebp, esp

; 1264 :    if ( fnValidView( lpTask, lpView ) )

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnValidView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@fnValidSub

; 1265 :    {
; 1266 :       if ( lpView->hSubtask == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+18], 0
	jne	SHORT $LN3@fnValidSub

; 1267 :       {
; 1268 :          //  "KZOEE107 - Invalid Subtask View"
; 1269 :          fnIssueCoreError( lpTask, lpView, 8, 107, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	107					; 0000006bH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1270 : 
; 1271 :       // fnOperationReturn( 0, lpTask, 0 );
; 1272 :          return( 0 );  // return error

	xor	eax, eax
	jmp	SHORT $LN1@fnValidSub

; 1273 :       }

	jmp	SHORT $LN2@fnValidSub
$LN3@fnValidSub:

; 1274 :       else
; 1275 :          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnValidSub
$LN2@fnValidSub:

; 1276 :    }
; 1277 : 
; 1278 :    return( 0 );

	xor	eax, eax
$LN1@fnValidSub:

; 1279 : }

	pop	ebp
	ret	0
_fnValidSubtaskView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpViewOD$1 = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpView$ = 12						; size = 4
_fnValidViewCsr PROC

; 1329 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1330 :    if ( fnValidViewObject( lpTask, lpView ) )

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnValidViewObject
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@fnValidVie

; 1331 :    {
; 1332 :       if ( lpView->hViewCsr == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN3@fnValidVie

; 1333 :       {
; 1334 :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 1335 : 
; 1336 :          //  "KZOEE109 - Invalid View, view contains no instance"
; 1337 :          fnIssueCoreError( lpTask, lpView, 8, 109, 0, lpViewOD->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewOD$1[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	0
	push	109					; 0000006dH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1338 : 
; 1339 :       // fnOperationReturn( 0, lpTask, 0 );
; 1340 :          return( 0 );  // return error

	xor	eax, eax
	jmp	SHORT $LN1@fnValidVie

; 1341 :       }

	jmp	SHORT $LN2@fnValidVie
$LN3@fnValidVie:

; 1342 :       else
; 1343 :          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnValidVie
$LN2@fnValidVie:

; 1344 :    }
; 1345 : 
; 1346 :    return( 0 );

	xor	eax, eax
$LN1@fnValidVie:

; 1347 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidViewCsr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_lpView$ = 12						; size = 4
_fnValidViewObject PROC

; 1296 : {

	push	ebp
	mov	ebp, esp

; 1297 :    if ( fnValidView( lpTask, lpView ) )

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnValidView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN2@fnValidVie

; 1298 :    {
; 1299 :       if ( lpView->hViewOD == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+6], 0
	jne	SHORT $LN3@fnValidVie

; 1300 :       {
; 1301 :          //  "KZOEE102 - Invalid View, view is hidden"
; 1302 :          fnIssueCoreError( lpTask, lpView, 8, 102, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	102					; 00000066H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1303 : 
; 1304 :       // fnOperationReturn( 0, lpTask, 0 );
; 1305 :          return( 0 );  // return error

	xor	eax, eax
	jmp	SHORT $LN1@fnValidVie

; 1306 :       }

	jmp	SHORT $LN2@fnValidVie
$LN3@fnValidVie:

; 1307 :       else
; 1308 :          return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnValidVie
$LN2@fnValidVie:

; 1309 :    }
; 1310 : 
; 1311 :    return( 0 );

	xor	eax, eax
$LN1@fnValidVie:

; 1312 : }

	pop	ebp
	ret	0
_fnValidViewObject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_k$1 = -40						; size = 4
_szMessage$2 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_lpView$ = 12						; size = 4
_fnValidView PROC

; 1104 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1105 :    if ( lpView )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN2@fnValidVie

; 1106 :    {
; 1107 :       if ( lpTask && lpTask->bDebug )   // Debug level validation

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN3@fnValidVie
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN3@fnValidVie

; 1108 :       {
; 1109 : #if 1
; 1110 :          if ( SysValidAddress( (zPVOID) lpView,

	push	1
	push	38					; 00000026H
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysValidAddress@12
	test	eax, eax
	je	SHORT $LN5@fnValidVie

; 1111 :                                (zLONG) sizeof( ViewRecord ), 1 ) )
; 1112 :          {
; 1113 :             if ( lpView->nTableID == iView )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10021				; 00002725H
	jne	SHORT $LN5@fnValidVie

; 1114 :                return( 1 );

	mov	eax, 1
	jmp	$LN1@fnValidVie
$LN5@fnValidVie:

; 1115 :          }
; 1116 : #else
; 1117 :          LPTASK    lpSearchTask;
; 1118 :          zVIEW     lpSearchView;
; 1119 :          LPAPP     lpSearchApp;
; 1120 : 
; 1121 :          // Check application bit.  If it is set, then the view is part of
; 1122 :          // an application, not a task--search for the view in all the
; 1123 :          // applications.  If it is not set, then look for the view in the
; 1124 :          // task.
; 1125 : 
; 1126 :          // Check the views for this task, in order to try to find a
; 1127 :          // matching view.
; 1128 :          lpSearchView = zGETPTR( lpTask->hFirstView );
; 1129 :          while ( lpSearchView )
; 1130 :          {
; 1131 :             if ( lpSearchView == lpView )
; 1132 :                return( 1 );
; 1133 : 
; 1134 :             lpSearchView = zGETPTR( lpSearchView->hNextView );
; 1135 :          }
; 1136 : 
; 1137 :          // If the view was not found in the current task, look in the
; 1138 :          // Application, for the task, for the view.
; 1139 :          if ( lpSearchView == 0 )
; 1140 :          {
; 1141 :             LPAPP lpApp = zGETPTR( lpTask->hApp );
; 1142 : 
; 1143 :             lpSearchView = zGETPTR( lpApp->hFirstView );
; 1144 :             while ( lpSearchView )
; 1145 :             {
; 1146 :                // If a match was found for views, then lpView is ok.
; 1147 :                if ( lpSearchView == lpView )
; 1148 :                   return( 1 );
; 1149 : 
; 1150 :                // Point lpSearchView to next view in chain.
; 1151 :                lpSearchView = zGETPTR( lpSearchView->hNextView );
; 1152 :             }
; 1153 :          }
; 1154 : 
; 1155 :          // If the view was not found in the application for the current
; 1156 :          // task, look in all tasks for the view.
; 1157 :          if ( lpSearchView == 0 )
; 1158 :          {
; 1159 :             // Make sure nobody else is deleting a task.
; 1160 :             fnStartBrowseOfTaskList( zGETHNDL( lpTask ), FALSE );
; 1161 : 
; 1162 :             // Point to the first task.
; 1163 :             lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );
; 1164 : 
; 1165 :             // While there are tasks, look through the view chain for each
; 1166 :             // task, looking for a view match.
; 1167 :             while ( lpSearchTask )
; 1168 :             {
; 1169 :                if ( lpSearchTask != lpTask )
; 1170 :                {
; 1171 :                   lpSearchView = zGETPTR( lpSearchTask->hFirstView );
; 1172 :                   while ( lpSearchView )
; 1173 :                   {
; 1174 :                      if ( lpSearchView == lpView )
; 1175 :                      {
; 1176 :                         fnEndBrowseOfTaskList( FALSE );
; 1177 :                         return( 1 );
; 1178 :                      }
; 1179 : 
; 1180 :                      lpSearchView = zGETPTR( lpSearchView->hNextView );
; 1181 :                   }
; 1182 :                }
; 1183 : 
; 1184 :                lpSearchTask = zGETPTR( lpSearchTask->hNextTask );
; 1185 :             }
; 1186 : 
; 1187 :             fnEndBrowseOfTaskList( FALSE );
; 1188 :          }
; 1189 : 
; 1190 :          // If the view has not been found, look in all apps for the view.
; 1191 :          if ( lpSearchView == 0 )
; 1192 :          {
; 1193 :             zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );
; 1194 : 
; 1195 :             // Set lpSearchApp to first application.
; 1196 :             lpSearchApp = zGETPTR( AnchorBlock->hFirstApp );
; 1197 : 
; 1198 :             // While there are applications, look through the view chain for
; 1199 :             // each application looking for a view match.
; 1200 :             while ( lpSearchApp )
; 1201 :             {
; 1202 :                lpSearchView = zGETPTR( lpSearchApp->hFirstView );
; 1203 :                while ( lpSearchView )
; 1204 :                {
; 1205 :                   // If a match was found for views, then lpView is ok.
; 1206 :                   if ( lpSearchView == lpView )
; 1207 :                      return( 1 );
; 1208 : 
; 1209 :                   // Point lpSearchView to next view in chain.
; 1210 :                   lpSearchView = zGETPTR( lpSearchView->hNextView );
; 1211 :                }
; 1212 : 
; 1213 :                // Point lpSearchApp to next app in chain.
; 1214 :                lpSearchApp = zGETPTR( lpSearchApp->hNextApp );
; 1215 :             }
; 1216 : 
; 1217 :             zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );
; 1218 :          }
; 1219 : #endif
; 1220 :       }     // if ( lpTask->bDebug )...

	jmp	SHORT $LN2@fnValidVie
$LN3@fnValidVie:

; 1221 :       else                   // Non-Debug level checking
; 1222 :       {
; 1223 :          if ( lpView->nTableID == iView )

	mov	edx, DWORD PTR _lpView$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10021				; 00002725H
	jne	SHORT $LN2@fnValidVie

; 1224 :             return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@fnValidVie
$LN2@fnValidVie:

; 1225 :       }
; 1226 :    }
; 1227 : 
; 1228 :    if ( lpTask->bTransientTask == FALSE )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	jne	SHORT $LN8@fnValidVie

; 1229 :    {
; 1230 :       zCHAR szMessage[ 32 ];
; 1231 : 
; 1232 :       TraceLine( "CheckValidView found Invalid view: 0x%08x", lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET $SG15295
	call	_TraceLine
	add	esp, 8

; 1233 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );

	lea	ecx, DWORD PTR _szMessage$2[ebp]
	push	ecx
	push	OFFSET $SG15296
	push	OFFSET $SG15297
	push	-1
	call	_SysReadZeidonIni@16

; 1234 :       if ( szMessage[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szMessage$2[ebp+eax]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN8@fnValidVie

; 1235 :       {
; 1236 :          int k = 0;

	mov	DWORD PTR _k$1[ebp], 0

; 1237 :          k /= k;

	mov	eax, DWORD PTR _k$1[ebp]
	cdq
	idiv	DWORD PTR _k$1[ebp]
	mov	DWORD PTR _k$1[ebp], eax
$LN8@fnValidVie:

; 1238 :       }
; 1239 :    }
; 1240 : 
; 1241 :    //  "KZOEE101 - Invalid View"
; 1242 :    fnIssueCoreError( lpTask, lpView, 8, 101, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	101					; 00000065H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1243 : 
; 1244 : //?fnOperationReturn( 0, lpTask, 0 );  dks???  2004.11.05
; 1245 :    return( 0 );  // return error

	xor	eax, eax
$LN1@fnValidVie:

; 1246 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnValidView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_k$1 = -4						; size = 4
_nOperationID$ = 8					; size = 2
_lpTask$ = 12						; size = 4
_fnOperationReturn PROC

; 1022 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1023 : #if 0  // this happens quite a bit
; 1024 : // if ( nOperationID == iDropViewCluster )
; 1025 :    {
; 1026 :       zVIEW v = GetDefaultViewForActiveTask( );
; 1027 :    // if ( v && v->hTask != zGETHNDL( lpTask ) )
; 1028 :       {
; 1029 :          TraceLine( "fnOperationReturn ID: %d-%s   Task: 0x%08x, TaskIn: 0x%08x   Idx: %d",
; 1030 :                     nOperationID, g_Operations[ nOperationID ],
; 1031 :                     v ? v->hTask : 0, lpTask ? zGETHNDL( lpTask ) : 0,
; 1032 :                     lpTask->nOperIdx );
; 1033 :       }
; 1034 :    }
; 1035 : #endif
; 1036 : 
; 1037 :    if ( lpTask )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	$LN4@fnOperatio

; 1038 :    {
; 1039 :       if ( lpTask->bAudit ) // is operation auditing enabled

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	and	ecx, 1
	je	$LN5@fnOperatio

; 1040 :       {
; 1041 :          int k;
; 1042 : 
; 1043 :          k = lpTask->nOperIdx;

	mov	edx, DWORD PTR _lpTask$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	DWORD PTR _k$1[ebp], eax

; 1044 :          if ( k >= 0 &&

	cmp	DWORD PTR _k$1[ebp], 0
	jl	SHORT $LN7@fnOperatio
	movsx	ecx, WORD PTR _nOperationID$[ebp]
	test	ecx, ecx
	je	SHORT $LN9@fnOperatio
	mov	edx, DWORD PTR _k$1[ebp]
	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+edx*2+60]
	movsx	edx, WORD PTR _nOperationID$[ebp]
	cmp	ecx, edx
	jne	SHORT $LN7@fnOperatio
$LN9@fnOperatio:

; 1045 :               (nOperationID == 0 || lpTask->nOper[ k ] == nOperationID) )
; 1046 :          {
; 1047 :             lpTask->nOperIdx--;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	cx, WORD PTR [eax+58]
	sub	cx, 1
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [edx+58], cx

; 1048 :          }

	jmp	SHORT $LN8@fnOperatio
$LN7@fnOperatio:

; 1049 :          else   // Try and recover lost index
; 1050 :          {
; 1051 :             //  "KZOEE013 - Internal operation call error"
; 1052 :             TraceLine( "KZOEE013 - Internal operation (%d) %s call error: "

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	push	eax
	mov	ecx, DWORD PTR _k$1[ebp]
	push	ecx
	movsx	edx, WORD PTR _nOperationID$[ebp]
	mov	eax, DWORD PTR _g_Operations[edx*4]
	push	eax
	movsx	ecx, WORD PTR _nOperationID$[ebp]
	push	ecx
	push	OFFSET $SG15273
	call	_TraceLine
	add	esp, 20					; 00000014H

; 1053 :                        "Recovering lost index: %d for Task: 0x%08x",
; 1054 :                        nOperationID,
; 1055 :                        g_Operations[ nOperationID ], k, zGETHNDL( lpTask ) );
; 1056 :             fnSysMessageBox( lpTask, "Zeidon Core Error",

	push	1
	push	OFFSET $SG15274
	push	OFFSET $SG15275
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnSysMessageBox@16
$LN2@fnOperatio:

; 1057 :                              "KZOEE013 - Internal operation call error.", 1 );
; 1058 :             while ( k >= 0 && lpTask->nOper[ k ] != nOperationID )

	cmp	DWORD PTR _k$1[ebp], 0
	jl	SHORT $LN3@fnOperatio
	mov	eax, DWORD PTR _k$1[ebp]
	mov	ecx, DWORD PTR _lpTask$[ebp]
	movsx	edx, WORD PTR [ecx+eax*2+60]
	movsx	eax, WORD PTR _nOperationID$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@fnOperatio

; 1059 :                k--;

	mov	ecx, DWORD PTR _k$1[ebp]
	sub	ecx, 1
	mov	DWORD PTR _k$1[ebp], ecx
	jmp	SHORT $LN2@fnOperatio
$LN3@fnOperatio:

; 1060 : 
; 1061 :             if ( k >= 0 )

	cmp	DWORD PTR _k$1[ebp], 0
	jl	SHORT $LN8@fnOperatio

; 1062 :                lpTask->nOperIdx--;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	ax, WORD PTR [edx+58]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [ecx+58], ax
$LN8@fnOperatio:

; 1063 :          }
; 1064 :       }

	jmp	SHORT $LN4@fnOperatio
$LN5@fnOperatio:

; 1065 :       else
; 1066 :       {
; 1067 :          lpTask->nOperIdx--;

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	ax, WORD PTR [edx+58]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [ecx+58], ax
$LN4@fnOperatio:

; 1068 :       }
; 1069 :    }
; 1070 : 
; 1071 : #if 0  // this happens quite a bit
; 1072 :    if ( nOperationID == iDropViewCluster )
; 1073 :    {
; 1074 :       zVIEW v = GetDefaultViewForActiveTask( );
; 1075 :    // if ( v && v->hTask != zGETHNDL( lpTask ) )
; 1076 :       {
; 1077 :          TraceLine( "FNOPERATIONRETURN ID: %d-%s   Task: 0x%08x, TaskIn: 0x%08x   Idx: %d",
; 1078 :                     nOperationID, g_Operations[ nOperationID ],
; 1079 :                     v ? v->hTask : 0, lpTask ? zGETHNDL( lpTask ) : 0,
; 1080 :                     lpTask->nOperIdx );
; 1081 :       }
; 1082 :    }
; 1083 : #endif
; 1084 : 
; 1085 :    if ( lpTask && AnchorBlock->hFirstDebugChange )

	cmp	DWORD PTR _lpTask$[ebp], 0
	je	SHORT $LN1@fnOperatio
	mov	edx, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [edx+2523], 0
	je	SHORT $LN1@fnOperatio

; 1086 :       fnCompareDebugChange( FALSE, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	0
	call	_fnCompareDebugChange@8
$LN1@fnOperatio:

; 1087 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnOperationReturn ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
tv75 = -52						; size = 4
_k$1 = -48						; size = 4
_plCount$ = -44						; size = 4
_lpTask$ = -40						; size = 4
_szMessage$2 = -36					; size = 32
__$ArrayPad$ = -4					; size = 4
_nOperationID$ = 8					; size = 2
_lpTaskView$ = 12					; size = 4
_lFlag$ = 16						; size = 4
_fnOperationCall PROC

; 858  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 859  :    LPTASK    lpTask = 0;

	mov	DWORD PTR _lpTask$[ebp], 0

; 860  :    zPLONG    plCount;
; 861  : 
; 862  :    if ( AnchorBlock == 0 )

	cmp	DWORD PTR _AnchorBlock, 0
	jne	SHORT $LN2@fnOperatio

; 863  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOperatio
$LN2@fnOperatio:

; 864  : 
; 865  :    if ( g_vRealTaskView )  // to fix object browser problem

	cmp	DWORD PTR _g_vRealTaskView, 0
	je	SHORT $LN3@fnOperatio

; 866  :       lpTaskView = g_vRealTaskView;

	mov	eax, DWORD PTR _g_vRealTaskView
	mov	DWORD PTR _lpTaskView$[ebp], eax
$LN3@fnOperatio:

; 867  : 
; 868  :    if ( lpTaskView == 0 || lpTaskView->hTask == 0 ||

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN5@fnOperatio
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	cmp	DWORD PTR [ecx+14], 0
	je	SHORT $LN5@fnOperatio
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	$LN4@fnOperatio
$LN5@fnOperatio:

; 869  :         (lpTask = zGETPTR( lpTaskView->hTask )) == 0 )
; 870  :    {
; 871  :       zCHAR  szMessage[ 32 ];
; 872  : 
; 873  :       TraceLine( "KZOEE101 - Invalid view 0x%08x for Task: 0x%08x",

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	je	SHORT $LN29@fnOperatio
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR tv75[ebp], edx
	jmp	SHORT $LN30@fnOperatio
$LN29@fnOperatio:
	mov	DWORD PTR tv75[ebp], 0
$LN30@fnOperatio:
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	push	OFFSET $SG15221
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 874  :                  lpTaskView, lpTaskView ? lpTaskView->hTask : 0 );
; 875  : 
; 876  :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szMessage );

	lea	edx, DWORD PTR _szMessage$2[ebp]
	push	edx
	push	OFFSET $SG15222
	push	OFFSET $SG15223
	push	-1
	call	_SysReadZeidonIni@16

; 877  :       if ( szMessage[ 0 ] == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szMessage$2[ebp+ecx]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN6@fnOperatio

; 878  :       {
; 879  :          int k = 0;

	mov	DWORD PTR _k$1[ebp], 0

; 880  :          k /= k;

	mov	eax, DWORD PTR _k$1[ebp]
	cdq
	idiv	DWORD PTR _k$1[ebp]
	mov	DWORD PTR _k$1[ebp], eax
$LN6@fnOperatio:

; 881  :       }
; 882  : 
; 883  :       if ( AnchorBlock )

	cmp	DWORD PTR _AnchorBlock, 0
	je	SHORT $LN7@fnOperatio

; 884  :       {
; 885  :          if ( lpTask == 0 )

	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN8@fnOperatio

; 886  :             lpTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN8@fnOperatio:

; 887  : 
; 888  :          if ( lpTaskView == 0 )

	cmp	DWORD PTR _lpTaskView$[ebp], 0
	jne	SHORT $LN9@fnOperatio

; 889  :             lpTaskView = zGETPTR( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTaskView$[ebp], eax
$LN9@fnOperatio:

; 890  : 
; 891  :          //  "KZOEE101 - Invalid View"
; 892  :          fnIssueCoreError( lpTask, lpTaskView, 8, 101, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	101					; 00000065H
	push	8
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN7@fnOperatio:

; 893  :       }
; 894  : 
; 895  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOperatio
$LN4@fnOperatio:

; 896  :    }
; 897  : 
; 898  :    if ( lpTask->bDisable && nOperationID != iEnableTask )

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN10@fnOperatio
	movsx	edx, WORD PTR _nOperationID$[ebp]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN10@fnOperatio

; 899  :    {
; 900  :       //  "KZOEE017 - Task is Disabled"
; 901  :    // fnIssueCoreError( zGETPTR( lpTaskView->hTask ), lpTaskView,
; 902  :    //                   16, 17, 0, 0, 0 );
; 903  :    // TraceLineS( "fnOperationCall: ", "2" );
; 904  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOperatio
$LN10@fnOperatio:

; 905  :    }
; 906  : 
; 907  : // if ( ((lFlag & zVALID_VIEW) && lpTaskView == 0) ||  // don/dks 2006.04.27
; 908  :    if ( ((lFlag & zVALID_VIEW) && fnValidView( lpTask, lpTaskView ) == 0) ||
; 909  :         ((lFlag & zVALID_VIEW_CSR) == zVALID_VIEW_CSR &&
; 910  :           fnValidViewCsr( lpTask, lpTaskView ) == 0) ||
; 911  :         ((lFlag & zVALID_VIEW_OBJECT) == zVALID_VIEW_OBJECT &&
; 912  :           fnValidViewObject( lpTask, lpTaskView ) == 0) ||

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 1
	je	SHORT $LN13@fnOperatio
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	cwde
	test	eax, eax
	je	SHORT $LN12@fnOperatio
$LN13@fnOperatio:
	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 13					; 0000000dH
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN14@fnOperatio
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	call	_fnValidViewCsr
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN12@fnOperatio
$LN14@fnOperatio:
	mov	edx, DWORD PTR _lFlag$[ebp]
	and	edx, 5
	cmp	edx, 5
	jne	SHORT $LN15@fnOperatio
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	call	_fnValidViewObject
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN12@fnOperatio
$LN15@fnOperatio:
	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 3
	cmp	eax, 3
	jne	SHORT $LN11@fnOperatio
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	call	_fnValidSubtaskView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN11@fnOperatio
$LN12@fnOperatio:

; 913  :         ((lFlag & zVALID_SUBTASK_VIEW) == zVALID_SUBTASK_VIEW &&
; 914  :           fnValidSubtaskView( lpTask, lpTaskView ) == 0) )
; 915  :    {
; 916  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOperatio
$LN11@fnOperatio:

; 917  :    }
; 918  : 
; 919  : #if 0  // this happens quite a bit
; 920  :    if ( nOperationID == iDropViewCluster )
; 921  :    {
; 922  :       zVIEW v = GetDefaultViewForActiveTask( );
; 923  :    // if ( v && v->hTask != lpTaskView->hTask )
; 924  :       {
; 925  :          TraceLine( "FNOPERATIONCALL ID: %d-%s  Task: 0x%08x   TaskIn: 0x%08x   PreIdx: %d",
; 926  :                     nOperationID, g_Operations[ nOperationID ],
; 927  :                     v ? v->hTask : 0, lpTaskView->hTask, lpTask->nOperIdx );
; 928  :       }
; 929  :    }
; 930  : #endif
; 931  : 
; 932  :    if ( lpTask->bAudit ) // is operation auditing enabled

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	and	edx, 1
	je	$LN16@fnOperatio

; 933  :    {
; 934  :    // TraceLineS( "fnOperationCall: ", "Audit" );
; 935  :       if ( lpTask->nOperIdx < -1 )

	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	ecx, -1
	jge	SHORT $LN18@fnOperatio

; 936  :       {
; 937  :       // lpTask->nOperIdx /= lpTask->nOperIdx - lpTask->nOperIdx;
; 938  :          lpTask->nOperIdx = -1;

	or	edx, -1
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [eax+58], dx

; 939  : 
; 940  :          //  "KZOEE013 - Internal operation call error"
; 941  :          TraceLineS( "KZOEE013 - Internal operation call error: ",

	push	OFFSET $SG15237
	push	OFFSET $SG15238
	call	_TraceLineS@8

; 942  :                      "Auditing error" );
; 943  :          fnIssueCoreError( zGETPTR( lpTaskView->hTask ), lpTaskView,

	push	0
	push	0
	push	0
	push	13					; 0000000dH
	push	16					; 00000010H
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH
$LN18@fnOperatio:

; 944  :                            16, 13, 0, 0, 0 );
; 945  :       }
; 946  : 
; 947  :       lpTask->nOperIdx++;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	dx, WORD PTR [ecx+58]
	add	dx, 1
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [eax+58], dx

; 948  :       if ( lpTask->nOperIdx <= 9 )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, 9
	jg	SHORT $LN19@fnOperatio

; 949  :          lpTask->nOper[ lpTask->nOperIdx ] = nOperationID;

	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	ax, WORD PTR _nOperationID$[ebp]
	mov	WORD PTR [edx+ecx*2+60], ax
	jmp	$LN20@fnOperatio
$LN19@fnOperatio:

; 950  :       else
; 951  :       if ( lpTask->nOperIdx > 15 )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	edx, 15					; 0000000fH
	jle	SHORT $LN21@fnOperatio

; 952  :       {
; 953  :          TraceLineS( "Zeidon Core Internal Error: ",

	push	OFFSET $SG15243
	push	OFFSET $SG15244
	call	_TraceLineS@8

; 954  :                      "Too many nested Core calls" );
; 955  :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOperatio

; 956  :       }

	jmp	SHORT $LN20@fnOperatio
$LN21@fnOperatio:

; 957  :       else
; 958  :       if ( lpTask->nOperIdx == 15 )

	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	ecx, 15					; 0000000fH
	jne	SHORT $LN23@fnOperatio

; 959  :       {
; 960  :          TraceLineS( "fnOperationCall: ", "Too many nested Core calls" );

	push	OFFSET $SG15247
	push	OFFSET $SG15248
	call	_TraceLineS@8

; 961  :          SysMessageBox( lpTaskView, "Zeidon Core Internal Error",

	push	0
	push	OFFSET $SG15249
	push	OFFSET $SG15250
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 962  :                         " Too many nested Core calls. "
; 963  :                         "(This is the last message.  "
; 964  :                         "Subsequent errors will be traced only)", 0 );
; 965  :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOperatio

; 966  :       }

	jmp	SHORT $LN20@fnOperatio
$LN23@fnOperatio:

; 967  :       else
; 968  :       {
; 969  :          TraceLineS( "fnOperationCall: ", "Too many nested Core calls2" );

	push	OFFSET $SG15251
	push	OFFSET $SG15252
	call	_TraceLineS@8

; 970  :          SysMessageBox( lpTaskView, "Zeidon Core Internal Error",

	push	0
	push	OFFSET $SG15253
	push	OFFSET $SG15254
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 971  :                         " Too many nested Core calls", 0 );
; 972  :          return( 0 );

	xor	eax, eax
	jmp	$LN1@fnOperatio
$LN20@fnOperatio:

; 973  :       }
; 974  : 
; 975  :       // Is operation call counting enabled.
; 976  :       if ( lpTask->hCountBuf && lpTask->bCount )

	mov	ecx, DWORD PTR _lpTask$[ebp]
	cmp	DWORD PTR [ecx+146], 0
	je	SHORT $LN25@fnOperatio
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN25@fnOperatio

; 977  :       {
; 978  :          plCount = (zPLONG) zGETPTR( lpTask->hCountBuf );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+146]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _plCount$[ebp], eax

; 979  :          plCount += (2 * nOperationID);

	movsx	eax, WORD PTR _nOperationID$[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _plCount$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _plCount$[ebp], edx

; 980  :          if ( lpTask->nOperIdx )

	mov	eax, DWORD PTR _lpTask$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	test	ecx, ecx
	je	SHORT $LN26@fnOperatio

; 981  :             plCount++;

	mov	edx, DWORD PTR _plCount$[ebp]
	add	edx, 4
	mov	DWORD PTR _plCount$[ebp], edx
$LN26@fnOperatio:

; 982  : 
; 983  :          (*plCount)++;

	mov	eax, DWORD PTR _plCount$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _plCount$[ebp]
	mov	DWORD PTR [edx], ecx
$LN25@fnOperatio:

; 984  :       }
; 985  :    }

	jmp	SHORT $LN17@fnOperatio
$LN16@fnOperatio:

; 986  :    else
; 987  :    {
; 988  :       lpTask->nOperIdx++;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	cx, WORD PTR [eax+58]
	add	cx, 1
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	WORD PTR [edx+58], cx
$LN17@fnOperatio:

; 989  :    }
; 990  : 
; 991  : #if 0  // this happens quite a bit
; 992  : // if ( nOperationID == iDropViewCluster )
; 993  :    {
; 994  :       zVIEW v = GetDefaultViewForActiveTask( );
; 995  :       TraceLine( "fnOperationCall ID: %d-%s  Task: 0x%08x   TaskIn: 0x%08x   Idx: %d",
; 996  :                  nOperationID, g_Operations[ nOperationID ],
; 997  :                  v ? v->hTask : 0, lpTaskView->hTask, lpTask->nOperIdx );
; 998  :    }
; 999  : #endif
; 1000 : 
; 1001 :    if ( AnchorBlock->hFirstDebugChange )

	mov	eax, DWORD PTR _AnchorBlock
	cmp	DWORD PTR [eax+2523], 0
	je	SHORT $LN27@fnOperatio

; 1002 :    {
; 1003 :    // TraceLineS( "fnOperationCall: ", "FirstDebugChange" );
; 1004 :       fnCompareDebugChange( TRUE, lpTask );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	push	ecx
	push	1
	call	_fnCompareDebugChange@8
$LN27@fnOperatio:

; 1005 :    }
; 1006 : 
; 1007 : // TraceLineS( "fnOperationCall: ", "Return" );
; 1008 :    return( lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
$LN1@fnOperatio:

; 1009 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_fnOperationCall ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lpViewEntity$1 = -40					; size = 4
_lpCurrentTask$ = -36					; size = 4
_lpViewOD$ = -32					; size = 4
_nLinkedCount$2 = -28					; size = 4
_lpViewOI$ = -24					; size = 4
_lpViewCsr$ = -20					; size = 4
_lpLinked$3 = -16					; size = 4
_nEntityCount$ = -12					; size = 4
_lpEntityInstance$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_lControl$ = 12						; size = 4
_SfCheckOI_Integrity@8 PROC

; 1752 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1753 :    LPTASK            lpCurrentTask;
; 1754 :    LPVIEWOD          lpViewOD;
; 1755 :    LPVIEWOI          lpViewOI;
; 1756 :    LPVIEWCSR         lpViewCsr;
; 1757 :    LPENTITYINSTANCE  lpEntityInstance;
; 1758 :    zLONG             nEntityCount;
; 1759 :    zSHORT            nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax

; 1760 : 
; 1761 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 1762 :    if ( (lpCurrentTask = fnOperationCall( iSfCheckOI_Integrity, lpView,
; 1763 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	28					; 0000001cH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN8@SfCheckOI_

; 1764 :    {
; 1765 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfCheckOI_
$LN8@SfCheckOI_:

; 1766 :    }
; 1767 : 
; 1768 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1769 :    if ( lpViewOD == 0 || lpViewOD->nTableID != iViewOD )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN10@SfCheckOI_
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	movsx	edx, WORD PTR [ecx]
	cmp	edx, 10011				; 0000271bH
	je	SHORT $LN9@SfCheckOI_
$LN10@SfCheckOI_:

; 1770 :    {
; 1771 :       SysMessageBox( lpView, "OI Integrity",

	push	1
	push	OFFSET $SG15516
	push	OFFSET $SG15517
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16

; 1772 :                      "View does not have a valid OD", 1 );
; 1773 :       goto EndOfFunction;

	jmp	$EndOfFunction$21
$LN9@SfCheckOI_:

; 1774 :    }
; 1775 : 
; 1776 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1777 :    if ( lpViewCsr == 0 || lpViewCsr->nTableID != iViewCsr )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	je	SHORT $LN12@SfCheckOI_
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	movsx	ecx, WORD PTR [eax]
	cmp	ecx, 10019				; 00002723H
	je	SHORT $LN11@SfCheckOI_
$LN12@SfCheckOI_:

; 1778 :    {
; 1779 :       SysMessageBox( lpView, "OI Integrity",

	push	1
	push	OFFSET $SG15520
	push	OFFSET $SG15521
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 1780 :                      "View does not have a valid ViewCsr", 1 );
; 1781 :       goto EndOfFunction;

	jmp	$EndOfFunction$21
$LN11@SfCheckOI_:

; 1782 :    }
; 1783 : 
; 1784 :    lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1785 :    if ( lpViewOI == 0 || lpViewOI->nTableID != iViewOI )

	cmp	DWORD PTR _lpViewOI$[ebp], 0
	je	SHORT $LN14@SfCheckOI_
	mov	edx, DWORD PTR _lpViewOI$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10018				; 00002722H
	je	SHORT $LN13@SfCheckOI_
$LN14@SfCheckOI_:

; 1786 :    {
; 1787 :       SysMessageBox( lpView, "OI Integrity",

	push	1
	push	OFFSET $SG15524
	push	OFFSET $SG15525
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 1788 :                      "View does not have a valid View OI", 1 );
; 1789 :       goto EndOfFunction;

	jmp	$EndOfFunction$21
$LN13@SfCheckOI_:

; 1790 :    }
; 1791 : 
; 1792 :    for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance ),

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	mov	DWORD PTR _nEntityCount$[ebp], 0
	jmp	SHORT $LN4@SfCheckOI_
$LN2@SfCheckOI_:

; 1795 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ),

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	mov	eax, DWORD PTR _nEntityCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _nEntityCount$[ebp], eax
$LN4@SfCheckOI_:

; 1793 :                nEntityCount = 0;
; 1794 :          lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	$LN3@SfCheckOI_

; 1796 :                nEntityCount++ )
; 1797 :    {
; 1798 :       LPENTITYINSTANCE lpLinked;
; 1799 :       LPVIEWENTITY     lpViewEntity;
; 1800 :       zLONG            nLinkedCount;
; 1801 : 
; 1802 :       if ( nEntityCount > 1000000 )

	cmp	DWORD PTR _nEntityCount$[ebp], 1000000	; 000f4240H
	jle	SHORT $LN15@SfCheckOI_

; 1803 :       {
; 1804 :          SysMessageBox( lpView, "OI Integrity", "Too many entities", 1 );

	push	1
	push	OFFSET $SG15527
	push	OFFSET $SG15528
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 1805 :          goto EndOfFunction;

	jmp	$EndOfFunction$21
$LN15@SfCheckOI_:

; 1806 :       }
; 1807 : 
; 1808 :       if ( lpEntityInstance->nTableID != iEntityInstance )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10024				; 00002728H
	je	SHORT $LN16@SfCheckOI_

; 1809 :       {
; 1810 :          TraceLineI( "OI Integrity--EI's hier # = ", nEntityCount );

	mov	ecx, DWORD PTR _nEntityCount$[ebp]
	push	ecx
	push	OFFSET $SG15530
	call	_TraceLineI@8

; 1811 :          SysMessageBox( lpView, "OI Integrity",

	push	1
	push	OFFSET $SG15531
	push	OFFSET $SG15532
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 1812 :                         "View has an invalid entity", 1 );
; 1813 :          goto EndOfFunction;

	jmp	$EndOfFunction$21
$LN16@SfCheckOI_:

; 1814 :       }
; 1815 : 
; 1816 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$1[ebp], eax

; 1817 : 
; 1818 :       if ( lpEntityInstance->hNextLinked )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [edx+42], 0
	je	$LN17@SfCheckOI_

; 1819 :       {
; 1820 :          for ( lpLinked = zGETPTR( lpEntityInstance->hNextLinked ), nLinkedCount = 0;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$3[ebp], eax
	mov	DWORD PTR _nLinkedCount$2[ebp], 0
	jmp	SHORT $LN7@SfCheckOI_
$LN5@SfCheckOI_:

; 1822 :                lpLinked = zGETPTR( lpLinked->hNextLinked ), nLinkedCount++ )

	mov	edx, DWORD PTR _lpLinked$3[ebp]
	mov	eax, DWORD PTR [edx+42]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLinked$3[ebp], eax
	mov	ecx, DWORD PTR _nLinkedCount$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _nLinkedCount$2[ebp], ecx
$LN7@SfCheckOI_:

; 1821 :                lpLinked != lpEntityInstance;

	mov	edx, DWORD PTR _lpLinked$3[ebp]
	cmp	edx, DWORD PTR _lpEntityInstance$[ebp]
	je	SHORT $LN17@SfCheckOI_

; 1823 :          {
; 1824 :             if ( nLinkedCount > 1000 )

	cmp	DWORD PTR _nLinkedCount$2[ebp], 1000	; 000003e8H
	jle	SHORT $LN18@SfCheckOI_

; 1825 :             {
; 1826 :                TraceLineI( "OI Integrity--EI's hier # = ", nEntityCount );

	mov	eax, DWORD PTR _nEntityCount$[ebp]
	push	eax
	push	OFFSET $SG15535
	call	_TraceLineI@8

; 1827 :                SysMessageBox( lpView, "OI Integrity",

	push	1
	push	OFFSET $SG15536
	push	OFFSET $SG15537
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16

; 1828 :                               "Too many linked EIs", 1 );
; 1829 :                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$21
$LN18@SfCheckOI_:

; 1830 :             }
; 1831 : 
; 1832 :             if ( lpLinked->nTableID != iEntityInstance )

	mov	edx, DWORD PTR _lpLinked$3[ebp]
	movsx	eax, WORD PTR [edx]
	cmp	eax, 10024				; 00002728H
	je	SHORT $LN19@SfCheckOI_

; 1833 :             {
; 1834 :                TraceLineI( "OI Integrity--EI's hier # = ", nEntityCount );

	mov	ecx, DWORD PTR _nEntityCount$[ebp]
	push	ecx
	push	OFFSET $SG15539
	call	_TraceLineI@8

; 1835 :                SysMessageBox( lpView, "OI Integrity",

	push	1
	push	OFFSET $SG15540
	push	OFFSET $SG15541
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16

; 1836 :                               "Invalid linked EI", 1 );
; 1837 :                goto EndOfFunction;

	jmp	SHORT $EndOfFunction$21
$LN19@SfCheckOI_:

; 1838 :             }
; 1839 :          }

	jmp	$LN5@SfCheckOI_
$LN17@SfCheckOI_:

; 1840 :       }
; 1841 : 
; 1842 :    } // for each lpEntityInstance...

	jmp	$LN2@SfCheckOI_
$LN3@SfCheckOI_:

; 1843 : 
; 1844 :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$21:

; 1845 : 
; 1846 : EndOfFunction:
; 1847 :    fnOperationReturn( iSfCheckOI_Integrity, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	28					; 0000001cH
	call	_fnOperationReturn
	add	esp, 8

; 1848 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfCheckOI_:

; 1849 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfCheckOI_Integrity@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_pchReturnString$ = 8					; size = 4
_lZKey$ = 12						; size = 4
_NameForZKey@8 PROC

; 1576 : {

	push	ebp
	mov	ebp, esp

; 1577 :    zltoa( lZKey, pchReturnString );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _pchReturnString$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lZKey$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1578 :    return( 0 );

	xor	eax, eax

; 1579 : }

	pop	ebp
	ret	8
_NameForZKey@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevlaa.c
_TEXT	SEGMENT
_lZKey$ = -4						; size = 4
_cpcName$ = 8						; size = 4
_nControl$ = 12						; size = 2
_TrueName@8 PROC

; 1539 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1540 :    zLONG    lZKey;
; 1541 :    static zCHAR szWorkString[ 50 ]; // ??? should be removed sometime (dks)
; 1542 : 
; 1543 :    // If the input is not a pointer to a ZKey, just return cpcName as is.
; 1544 :    if ( cpcName == 0 || (cpcName && *cpcName != '\xff') )

	cmp	DWORD PTR _cpcName$[ebp], 0
	je	SHORT $LN3@TrueName
	cmp	DWORD PTR _cpcName$[ebp], 0
	je	SHORT $LN2@TrueName
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, -1
	je	SHORT $LN2@TrueName
$LN3@TrueName:

; 1545 :       return( (zPCHAR) cpcName );

	mov	eax, DWORD PTR _cpcName$[ebp]
	jmp	SHORT $LN1@TrueName
$LN2@TrueName:

; 1546 : 
; 1547 :    // Extract the ZKey from the input.
; 1548 :    lZKey = *((zPLONG) (cpcName + 1) );

	mov	edx, DWORD PTR _cpcName$[ebp]
	mov	eax, DWORD PTR [edx+1]
	mov	DWORD PTR _lZKey$[ebp], eax

; 1549 :    if ( NameForZKey( szWorkString, lZKey ) && nControl & zSHOW_ZKEY )

	mov	ecx, DWORD PTR _lZKey$[ebp]
	push	ecx
	push	OFFSET ?szWorkString@?1??TrueName@@9@9
	call	_NameForZKey@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN4@TrueName
	movsx	eax, WORD PTR _nControl$[ebp]
	and	eax, 1
	je	SHORT $LN4@TrueName

; 1550 :    {
; 1551 :       zstrcat( szWorkString, " (" );

	push	OFFSET $SG15424
	push	OFFSET ?szWorkString@?1??TrueName@@9@9
	call	_strcat
	add	esp, 8

; 1552 :       zltoa( lZKey, szWorkString + zstrlen( szWorkString ) );

	push	10					; 0000000aH
	push	OFFSET ?szWorkString@?1??TrueName@@9@9
	call	_strlen
	add	esp, 4
	add	eax, OFFSET ?szWorkString@?1??TrueName@@9@9
	push	eax
	mov	ecx, DWORD PTR _lZKey$[ebp]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH

; 1553 :       zstrcat( szWorkString, ")" );

	push	OFFSET $SG15425
	push	OFFSET ?szWorkString@?1??TrueName@@9@9
	call	_strcat
	add	esp, 8
$LN4@TrueName:

; 1554 :    }
; 1555 : 
; 1556 :    return( szWorkString );

	mov	eax, OFFSET ?szWorkString@?1??TrueName@@9@9
$LN1@TrueName:

; 1557 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_TrueName@8 ENDP
_TEXT	ENDS
END
